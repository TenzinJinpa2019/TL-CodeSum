private int currentDepth ( ) { try { Integer oneBased = ( ( Integer ) DEPTH_FIELD . get ( this ) ) ; return oneBased - NUM_ ; } catch ( IllegalAccessException e ) { throw new AssertionError ( e ) ; } }
protected boolean [ ] datasetIntegrity ( boolean nominalPredictor , boolean numericPredictor , boolean stringPredictor , boolean datePredictor , boolean relationalPredictor , boolean multiInstance , int classType , boolean predictorMissing , boolean classMissing ) { print ( STR_ ) ; printAttributeSummary ( nominalPredictor , numericPredictor , stringPredictor , datePredictor , relationalPredictor , multiInstance , classType ) ; print ( STR_ ) ; int numTrain = getNumInstances ( ) , numClasses = NUM_ , missingLevel = NUM_ ; boolean [ ] result = new boolean [ NUM_ ] ; Instances train = null ; Kernel kernel = null ; try { train = makeTestDataset ( NUM_ , numTrain , nominalPredictor ? getNumNominal ( ) : NUM_ , numericPredictor ? getNumNumeric ( ) : NUM_ , stringPredictor ? getNumString ( ) : NUM_ , datePredictor ? getNumDate ( ) : NUM_ , relationalPredictor ? getNumRelational ( ) : NUM_ , numClasses , classType , multiInstance ) ; if ( missingLevel > NUM_ ) { addMissing ( train , missingLevel , predictorMissing , classMissing ) ; } kernel = Kernel . makeCopies ( getKernel ( ) , NUM_ ) [ NUM_ ] ; } catch ( Exception ex ) { throw new Error ( STR_ + ex . getMessage ( ) ) ; } try { Instances trainCopy = new Instances ( train ) ; kernel . buildKernel ( trainCopy ) ; compareDatasets ( train , trainCopy ) ; println ( STR_ ) ; result [ NUM_ ] = BOOL_ ; } catch ( Exception ex ) { println ( STR_ ) ; result [ NUM_ ] = BOOL_ ; if ( m_Debug ) { println ( STR_ ) ; print ( STR_ ) ; println ( STR_ + ex . getMessage ( ) + STR_ ) ; println ( STR_ ) ; println ( STR_ + train . toString ( ) + STR_ ) ; } } return result ; }
public static int unionSize ( long [ ] x , long [ ] y ) { final int lx = x . length , ly = y . length ; final int min = ( lx < ly ) ? lx : ly ; int i = NUM_ , res = NUM_ ; for ( ; i < min ; i ++ ) { res += Long . bitCount ( x [ i ] | y [ i ] ) ; } for ( ; i < lx ; i ++ ) { res += Long . bitCount ( x [ i ] ) ; } for ( ; i < ly ; i ++ ) { res += Long . bitCount ( y [ i ] ) ; } return res ; }
public void testReverseOrder4 ( ) throws Exception { UUID id = UUID . randomUUID ( ) ; GridCacheAdapter < String , String > cache = grid . internalCache ( ) ; GridCacheContext < String , String > ctx = cache . context ( ) ; GridCacheTestEntryEx entry1 = new GridCacheTestEntryEx ( ctx , STR_ ) ; GridCacheTestEntryEx entry2 = new GridCacheTestEntryEx ( ctx , STR_ ) ; GridCacheVersion ver1 = version ( NUM_ ) ; GridCacheVersion ver2 = version ( NUM_ ) ; GridCacheVersion ver3 = version ( NUM_ ) ; GridCacheMvccCandidate v3k1 = entry1 . addLocal ( NUM_ , ver3 , NUM_ , BOOL_ , BOOL_ ) ; GridCacheMvccCandidate v3k2 = entry2 . addLocal ( NUM_ , ver3 , NUM_ , BOOL_ , BOOL_ ) ; linkCandidates ( ctx , v3k1 , v3k2 ) ; entry1 . readyLocal ( ver3 ) ; checkLocal ( v3k1 , ver3 , BOOL_ , BOOL_ , BOOL_ ) ; checkLocal ( v3k2 , ver3 , BOOL_ , BOOL_ , BOOL_ ) ; GridCacheMvccCandidate v1k1 = entry1 . addLocal ( NUM_ , ver1 , NUM_ , BOOL_ , BOOL_ ) ; GridCacheMvccCandidate v1k2 = entry2 . addLocal ( NUM_ , ver1 , NUM_ , BOOL_ , BOOL_ ) ; linkCandidates ( ctx , v1k1 , v1k2 ) ; entry1 . readyLocal ( ver1 ) ; entry2 . readyLocal ( ver1 ) ; checkLocal ( v3k1 , ver3 , BOOL_ , BOOL_ , BOOL_ ) ; checkLocal ( v3k2 , ver3 , BOOL_ , BOOL_ , BOOL_ ) ; checkLocal ( v1k1 , ver1 , BOOL_ , BOOL_ , BOOL_ ) ; checkLocal ( v1k2 , ver1 , BOOL_ , BOOL_ , BOOL_ ) ; GridCacheMvccCandidate v2k2 = entry2 . addRemote ( id , NUM_ , ver2 , NUM_ , BOOL_ , BOOL_ ) ; checkRemote ( v2k2 , ver2 , BOOL_ , BOOL_ ) ; entry2 . readyLocal ( v3k2 ) ; checkLocal ( v3k1 , ver3 , BOOL_ , BOOL_ , BOOL_ ) ; checkLocal ( v3k2 , ver3 , BOOL_ , BOOL_ , BOOL_ ) ; }
@ Override public void closingOK ( ) { List < AddUserFields . AttributeSpec > specs = new ArrayList < AddUserFields . AttributeSpec > ( ) ; for ( int i = NUM_ ; i < m_listModel . size ( ) ; i ++ ) { AddUserFields . AttributeSpec a = ( AddUserFields . AttributeSpec ) m_listModel . elementAt ( i ) ; specs . add ( a ) ; } if ( m_modifyL != null ) { m_modifyL . setModifiedStatus ( AddUserFieldsCustomizer . this , BOOL_ ) ; } m_filter . setAttributeSpecs ( specs ) ; }
public String toString ( ) { StringBuffer text = new StringBuffer ( ) ; if ( ( m_classAttribute == null ) ) { return STR_ ; } try { text . append ( STR_ ) ; text . append ( STR_ + m_kernel . toString ( ) + STR_ ) ; for ( int i = NUM_ ; i < m_classAttribute . numValues ( ) ; i ++ ) { for ( int j = i + NUM_ ; j < m_classAttribute . numValues ( ) ; j ++ ) { text . append ( STR_ + m_classAttribute . value ( i ) + STR_ + m_classAttribute . value ( j ) + STR_ ) ; text . append ( m_classifiers [ i ] [ j ] ) ; if ( m_fitLogisticModels ) { text . append ( STR_ ) ; if ( m_classifiers [ i ] [ j ] . m_logistic == null ) { text . append ( STR_ ) ; } else { text . append ( m_classifiers [ i ] [ j ] . m_logistic ) ; } } text . append ( STR_ ) ; } } } catch ( Exception e ) { return STR_ ; } return text . toString ( ) ; }
public final Sector union ( Sector that ) { if ( that == null ) return this ; Angle minLat = this . minLatitude ; Angle maxLat = this . maxLatitude ; Angle minLon = this . minLongitude ; Angle maxLon = this . maxLongitude ; if ( that . minLatitude . degrees < this . minLatitude . degrees ) minLat = that . minLatitude ; if ( that . maxLatitude . degrees > this . maxLatitude . degrees ) maxLat = that . maxLatitude ; if ( that . minLongitude . degrees < this . minLongitude . degrees ) minLon = that . minLongitude ; if ( that . maxLongitude . degrees > this . maxLongitude . degrees ) maxLon = that . maxLongitude ; return new Sector ( minLat , maxLat , minLon , maxLon ) ; }
private static boolean isDoubleEqual ( double value , double valueToCompare ) { return ( Math . abs ( value - valueToCompare ) < NUM_ ) ; }
public void testIntValuePos ( ) { String a = STR_ ; BigDecimal aNumber = new BigDecimal ( a ) ; int result = - NUM_ ; assertTrue ( STR_ , aNumber . intValue ( ) == result ) ; }
private void walk ( File directory , int depth , Collection < T > results ) throws IOException { checkIfCancelled ( directory , depth , results ) ; if ( handleDirectory ( directory , depth , results ) ) { handleDirectoryStart ( directory , depth , results ) ; int childDepth = depth + NUM_ ; if ( depthLimit < NUM_ || childDepth <= depthLimit ) { checkIfCancelled ( directory , depth , results ) ; File [ ] childFiles = filter == null ? directory . listFiles ( ) : directory . listFiles ( filter ) ; childFiles = filterDirectoryContents ( directory , depth , childFiles ) ; if ( childFiles == null ) { handleRestricted ( directory , childDepth , results ) ; } else { for ( File childFile : childFiles ) { if ( childFile . isDirectory ( ) ) { walk ( childFile , childDepth , results ) ; } else { checkIfCancelled ( childFile , childDepth , results ) ; handleFile ( childFile , childDepth , results ) ; checkIfCancelled ( childFile , childDepth , results ) ; } } } } handleDirectoryEnd ( directory , depth , results ) ; } checkIfCancelled ( directory , depth , results ) ; }
public static Object [ ] ordinalArray ( TupleSet tuples , String field ) { return ordinalArray ( tuples , field , DefaultLiteralComparator . getInstance ( ) ) ; }
public void testDivideExceptionInvalidRM ( ) { String a = STR_ ; int aScale = NUM_ ; String b = STR_ ; int bScale = NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal bNumber = new BigDecimal ( new BigInteger ( b ) , bScale ) ; try { aNumber . divide ( bNumber , NUM_ ) ; fail ( STR_ ) ; } catch ( IllegalArgumentException e ) { assertEquals ( STR_ , STR_ , e . getMessage ( ) ) ; } }
@ Override public void datasetChanged ( DatasetChangeEvent event ) { super . datasetChanged ( event ) ; if ( this . subplots == null ) { return ; } XYDataset dataset = null ; if ( event . getDataset ( ) instanceof XYDataset ) { dataset = ( XYDataset ) event . getDataset ( ) ; } for ( XYPlot subplot : this . subplots ) { if ( subplot . indexOf ( dataset ) >= NUM_ ) { subplot . configureRangeAxes ( ) ; } } }
public boolean onScheduleAsLibrary ( Config config , Config runtime , IScheduler scheduler , PackingPlan packing ) { boolean ret = BOOL_ ; try { scheduler . initialize ( config , runtime ) ; ret = scheduler . onSchedule ( packing ) ; if ( ret ) { ret = SchedulerUtils . setLibSchedulerLocation ( runtime , scheduler , BOOL_ ) ; } else { LOG . severe ( STR_ ) ; } } finally { scheduler . close ( ) ; } return ret ; }
public static boolean isStringType ( Type t ) { return t . equals ( RefType . v ( STR_ ) ) ; }
public Entry updateOrCreateSource ( User user , String id , String url , String title , Long modTime , Long createTime , boolean isAdmin , Errors errors ) { if ( user == null ) { Errors . add ( errors , errorMessages . errorUserIsNull ( ) ) ; return null ; } if ( url == null ) { Errors . add ( errors , errorMessages . errorUrlIsNull ( ) ) ; return null ; } Entry source = getEntryByUserIdAndUrl ( user . getId ( ) , url ) ; if ( source == null ) { if ( url . isEmpty ( ) ) { Errors . add ( errors , errorMessages . errorUrlIsEmpty ( ) ) ; return null ; } if ( title == null ) { Errors . add ( errors , errorMessages . errorTitleIsNull ( ) ) ; return null ; } if ( title . isEmpty ( ) ) { Errors . add ( errors , errorMessages . errorTitleIsEmpty ( ) ) ; return null ; } if ( modTime == null ) { Errors . add ( errors , errorMessages . errorModTimeIsNull ( ) ) ; return null ; } if ( createTime == null ) { Errors . add ( errors , errorMessages . errorCreateTimeIsNull ( ) ) ; return null ; } if ( id != null && ! idGenerator . isIdWellFormed ( id ) ) { Errors . add ( errors , errorMessages . errorIdIsInvalid ( ) ) ; return null ; } if ( createTime . longValue ( ) > modTime . longValue ( ) ) { modTime = createTime ; } if ( url != null ) { url = cleanUpText ( url ) ; } if ( title != null ) { title = cleanUpText ( title ) ; } source = new Entry ( ) ; source . setDb ( db ) ; if ( id == null ) { id = idGenerator . getAnotherId ( ) ; } source . setId ( id ) ; source . setSourceUrl ( url ) ; source . setSourceTitle ( title ) ; source . setCreateTime ( createTime ) ; source . setType ( Constants . source ) ; source . setUserId ( user . getId ( ) ) ; db . persistEntry ( source ) ; } else if ( ! canUserModifyEntry ( user , source , isAdmin ) ) { Errors . add ( errors , errorMessages . errorUserIsNotEntitledToModifyTheSource ( ) ) ; return null ; } source . setModTime ( modTime ) ; return source ; }
private void validateSqlStatement ( String sql , int jdbcStatementIndex ) { Assert . isTrue ( StringUtils . isNotBlank ( sql ) , STR_ + jdbcStatementIndex + STR_ ) ; }
public static Long [ ] valuesOf ( long [ ] array ) { Long [ ] dest = new Long [ array . length ] ; for ( int i = NUM_ ; i < array . length ; i ++ ) { dest [ i ] = Long . valueOf ( array [ i ] ) ; } return dest ; }
@ Override public boolean isTraceEnabled ( ) { return logger . isLoggable ( Level . FINEST ) ; }
private static void useMissile ( Player player ) { StackableItem projectilesItem = null ; if ( player . getRangeWeapon ( ) != null ) { projectilesItem = player . getAmmunition ( ) ; } if ( projectilesItem == null ) { projectilesItem = player . getMissileIfNotHoldingOtherWeapon ( ) ; } if ( projectilesItem != null ) { projectilesItem . removeOne ( ) ; } }
public TcpMatcher ( final NetworkConfig config ) { super ( config ) ; }
private int determineMaxLevelRec ( int level , Node v ) { int newLevel = level ; for ( Edge e = v . getFirstOutEdge ( ) ; e != null ; e = v . getNextOutEdge ( e ) ) { newLevel = Math . max ( newLevel , determineMaxLevelRec ( level , e . getTarget ( ) ) + NUM_ ) ; } return newLevel ; }
protected void requestPassCodeConfirmation ( ) { clearBoxes ( ) ; mPassCodeHdr . setText ( R . string . pass_code_reenter_your_pass_code ) ; mPassCodeHdrExplanation . setVisibility ( View . INVISIBLE ) ; mConfirmingPassCode = BOOL_ ; }
private void addWorkerFailed ( Worker w ) { final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { if ( w != null ) workers . remove ( w ) ; decrementWorkerCount ( ) ; tryTerminate ( ) ; } finally { mainLock . unlock ( ) ; } }
public void testInsert4 ( ) throws SQLException { DatabaseCreator . fillSimpleTable1 ( conn ) ; statement . execute ( STR_ + DatabaseCreator . SIMPLE_TABLE2 + STR_ + DatabaseCreator . SIMPLE_TABLE1 ) ; ResultSet r = statement . executeQuery ( STR_ + DatabaseCreator . SIMPLE_TABLE2 + STR_ + DatabaseCreator . SIMPLE_TABLE1 + STR_ ) ; r . next ( ) ; assertEquals ( STR_ , NUM_ , r . getInt ( NUM_ ) ) ; r . close ( ) ; }
private synchronized void putMapEntry ( String localId , MapEntry entry ) { if ( ! isLocalId ( localId ) ) { throw new IllegalStateException ( STR_ + localId + STR_ ) ; } JSONObject json = new JSONObject ( ) ; try { json . put ( STR_ , entry . retainCount ) ; if ( entry . objectId != null ) { json . put ( STR_ , entry . objectId ) ; } } catch ( JSONException je ) { throw new IllegalStateException ( STR_ , je ) ; } File file = new File ( diskPath , localId ) ; if ( ! diskPath . exists ( ) ) { diskPath . mkdirs ( ) ; } try { ParseFileUtils . writeJSONObjectToFile ( file , json ) ; } catch ( IOException e ) { } }
public void endElement ( String namespaceURI , String localName , String name ) throws org . xml . sax . SAXException { if ( m_inEntityRef ) return ; m_prefixMap . popNamespaces ( m_elemContext . m_currentElemDepth , null ) ; try { final java . io . Writer writer = m_writer ; if ( m_elemContext . m_startTagOpen ) { if ( m_tracer != null ) super . fireStartElem ( m_elemContext . m_elementName ) ; int nAttrs = m_attributes . getLength ( ) ; if ( nAttrs > NUM_ ) { processAttributes ( m_writer , nAttrs ) ; m_attributes . clear ( ) ; } if ( m_spaceBeforeClose ) writer . write ( STR_ ) ; else writer . write ( STR_ ) ; } else { if ( m_cdataTagOpen ) closeCDATA ( ) ; if ( shouldIndent ( ) ) indent ( m_elemContext . m_currentElemDepth - NUM_ ) ; writer . write ( STR_ ) ; writer . write ( STR_ ) ; writer . write ( name ) ; writer . write ( STR_ ) ; } } catch ( IOException e ) { throw new SAXException ( e ) ; } if ( ! m_elemContext . m_startTagOpen && m_doIndent ) { m_ispreserve = m_preserves . isEmpty ( ) ? BOOL_ : m_preserves . pop ( ) ; } m_isprevtext = BOOL_ ; if ( m_tracer != null ) super . fireEndElem ( name ) ; m_elemContext = m_elemContext . m_prev ; }
public static void f ( String msg , Object ... args ) { if ( ! allowWtf ) return ; StackTraceElement caller = getCallerStackTraceElement ( ) ; String tag = generateTag ( caller ) ; if ( sLevel > LEVEL_FATAL ) { return ; } if ( args . length > NUM_ ) { msg = String . format ( msg , args ) ; } Log . wtf ( tag , msg ) ; }
public void deleteLeaves ( String name ) { for ( int i = NUM_ ; i < _leaves . size ( ) ; i ++ ) { CatalogTreeLeaf leaf = _leaves . get ( i ) ; if ( name . equals ( leaf . getName ( ) ) ) { _leaves . remove ( i ) ; } } }
public String toString ( ) { final StringBuffer s = new StringBuffer ( ) ; final int size = size ( ) ; for ( int i = NUM_ ; i < size ; i ++ ) s . append ( getInt ( i ) ) ; return s . toString ( ) ; }
protected boolean validate ( final char [ ] component , final int soffset , int eoffset , final BitSet generous ) { if ( eoffset == - NUM_ ) { eoffset = component . length - NUM_ ; } for ( int i = soffset ; i <= eoffset ; i ++ ) { if ( ! generous . get ( component [ i ] ) ) { return BOOL_ ; } } return BOOL_ ; }
private void buildPieces ( ) { pieces = new Piece [ pathArray . size ( ) ] ; Paint paint = new Paint ( ) ; Matrix matrix = new Matrix ( ) ; Canvas canvas = new Canvas ( ) ; for ( int i = NUM_ ; i < pieces . length ; i ++ ) { int shadow = Utils . nextInt ( Utils . dp2px ( NUM_ ) , Utils . dp2px ( NUM_ ) ) ; Path path = pathArray . get ( i ) ; RectF r = new RectF ( ) ; path . computeBounds ( r , BOOL_ ) ; Bitmap pBitmap = Utils . createBitmapSafely ( ( int ) r . width ( ) + shadow . NUM_ , ( int ) r . height ( ) + shadow . NUM_ , Bitmap . Config . ARGB_4444 , NUM_ ) ; if ( pBitmap == null ) { pieces [ i ] = new Piece ( - NUM_ , - NUM_ , null , shadow ) ; continue ; } pieces [ i ] = new Piece ( ( int ) r . left + mTouchPoint . x - shadow , ( int ) r . top + mTouchPoint . y - shadow , pBitmap , shadow ) ; canvas . setBitmap ( pieces [ i ] . bitmap ) ; BitmapShader mBitmapShader = new BitmapShader ( mBitmap , Shader . TileMode . CLAMP , Shader . TileMode . CLAMP ) ; matrix . reset ( ) ; matrix . setTranslate ( - r . left - offsetX + shadow , - r . top - offsetY + shadow ) ; mBitmapShader . setLocalMatrix ( matrix ) ; paint . reset ( ) ; Path offsetPath = new Path ( ) ; offsetPath . addPath ( path , - r . left + shadow , - r . top + shadow ) ; paint . setStyle ( Paint . Style . FILL ) ; paint . setShadowLayer ( shadow , NUM_ , NUM_ , xff333333 ) ; canvas . drawPath ( offsetPath , paint ) ; paint . setShadowLayer ( NUM_ , NUM_ , NUM_ , NUM_ ) ; paint . setXfermode ( new PorterDuffXfermode ( PorterDuff . Mode . XOR ) ) ; canvas . drawPath ( offsetPath , paint ) ; paint . setXfermode ( null ) ; paint . setShader ( mBitmapShader ) ; paint . setAlpha ( xcc ) ; canvas . drawPath ( offsetPath , paint ) ; } Arrays . sort ( pieces ) ; }
public boolean removeShutdownHook ( Thread hook ) { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) { sm . checkPermission ( RuntimePermissionCollection . SHUTDOWN_HOOKS_PERMISSION ) ; } if ( hook == null ) throw new NullPointerException ( STR_ ) ; if ( VMState > NUM_ ) { throw new IllegalStateException ( ) ; } synchronized ( hooksList ) { return hooksList . remove ( hook ) ; } }
public void run ( ) { while ( m_keyboardStream != null ) { try { if ( m_keyboardReadRequest ) { String s = m_keyboardStream . readLine ( ) ; m_keyboardInput . add ( s ) ; m_keyboardReadRequest = BOOL_ ; synchronized ( this ) { notifyAll ( ) ; } } else try { Thread . sleep ( NUM_ ) ; } catch ( InterruptedException ie ) { } } catch ( IOException io ) { } } }
public boolean boundScroll ( ) { float curScroll = getStackScroll ( ) ; float newScroll = getBoundedStackScroll ( curScroll ) ; if ( Float . compare ( newScroll , curScroll ) != NUM_ ) { setStackScroll ( newScroll ) ; return BOOL_ ; } return BOOL_ ; }
@ Override public AggregateableEvaluation aggregate ( Evaluation evaluation ) { m_Incorrect += evaluation . incorrect ( ) ; m_Correct += evaluation . correct ( ) ; m_Unclassified += evaluation . unclassified ( ) ; m_MissingClass += evaluation . m_MissingClass ; m_WithClass += evaluation . m_WithClass ; if ( evaluation . m_ConfusionMatrix != null ) { double [ ] [ ] newMatrix = evaluation . confusionMatrix ( ) ; if ( newMatrix != null ) { for ( int i = NUM_ ; i < m_ConfusionMatrix . length ; i ++ ) { for ( int j = NUM_ ; j < m_ConfusionMatrix [ i ] . length ; j ++ ) { m_ConfusionMatrix [ i ] [ j ] += newMatrix [ i ] [ j ] ; } } } } double [ ] newClassPriors = evaluation . m_ClassPriors ; if ( newClassPriors != null && m_ClassPriors != null ) { for ( int i = NUM_ ; i < this . m_ClassPriors . length ; i ++ ) { m_ClassPriors [ i ] = newClassPriors [ i ] ; } } m_ClassPriorsSum = evaluation . m_ClassPriorsSum ; m_TotalCost += evaluation . totalCost ( ) ; m_SumErr += evaluation . m_SumErr ; m_SumAbsErr += evaluation . m_SumAbsErr ; m_SumSqrErr += evaluation . m_SumSqrErr ; m_SumClass += evaluation . m_SumClass ; m_SumSqrClass += evaluation . m_SumSqrClass ; m_SumPredicted += evaluation . m_SumPredicted ; m_SumSqrPredicted += evaluation . m_SumSqrPredicted ; m_SumClassPredicted += evaluation . m_SumClassPredicted ; m_SumPriorAbsErr += evaluation . m_SumPriorAbsErr ; m_SumPriorSqrErr += evaluation . m_SumPriorSqrErr ; m_SumKBInfo += evaluation . m_SumKBInfo ; double [ ] newMarginCounts = evaluation . m_MarginCounts ; if ( newMarginCounts != null ) { for ( int i = NUM_ ; i < m_MarginCounts . length ; i ++ ) { m_MarginCounts [ i ] += newMarginCounts [ i ] ; } } m_ComplexityStatisticsAvailable = evaluation . m_ComplexityStatisticsAvailable ; m_CoverageStatisticsAvailable = evaluation . m_CoverageStatisticsAvailable ; m_SumPriorEntropy += evaluation . m_SumPriorEntropy ; m_SumSchemeEntropy += evaluation . m_SumSchemeEntropy ; m_TotalSizeOfRegions += evaluation . m_TotalSizeOfRegions ; m_TotalCoverage += evaluation . m_TotalCoverage ; ArrayList < Prediction > predsToAdd = evaluation . m_Predictions ; if ( predsToAdd != null ) { if ( m_Predictions == null ) { m_Predictions = new ArrayList < Prediction > ( ) ; } for ( int i = NUM_ ; i < predsToAdd . size ( ) ; i ++ ) { m_Predictions . add ( predsToAdd . get ( i ) ) ; } } return this ; }
public void waitForVolumesToBeVisible ( CGRequestParams request ) { scan ( request . getCopies ( ) , request . getRsets ( ) ) ; }
protected void startAdditionalServices ( final Cache cache , final Map < String , Object > options ) throws Exception { }
public void updateView ( ) { if ( fInputElement != null && fParentComposite != null ) { IndicatorViewState oldState = fStateMap . get ( fInputElement ) ; boolean reload = fFilesToReoad . contains ( fInputElement ) ; if ( reload || oldState == null ) { JsonObject jsonObject = DroidsafePluginUtilities . parseIndicatorFile ( fInputElement ) ; if ( jsonObject == null ) return ; fFilesToReoad . remove ( fInputElement ) ; fState = new IndicatorViewState ( fInputElement , jsonObject , getSecuritySpec ( ) , oldState ) ; fStateMap . put ( fInputElement , fState ) ; } else { fState = oldState ; } setPartName ( fState . indicatorType ) ; showPage ( PAGE_VIEWER ) ; fTreeViewer . setInput ( fState . jsonObject ) ; if ( fTreeViewer . getSorter ( ) == null ) sortByField ( getSortByField ( ) ) ; } else { setPartName ( DEFAULT_PART_NAME ) ; } }
@ Override public void paint ( Graphics g ) { g . drawImage ( image , NUM_ , NUM_ , this ) ; if ( ! paintCalled ) { paintCalled = BOOL_ ; synchronized ( this ) { notifyAll ( ) ; } } }
@ Override public boolean connectionAllowed ( String eventName ) { if ( m_listenees . containsKey ( eventName ) ) { return BOOL_ ; } return BOOL_ ; }
public boolean isPrefixed ( ) { return name . indexOf ( STR_ ) >= NUM_ ; }
public void releaseAnyConnection ( Connection connection ) throws SQLException { try { connection . close ( ) ; } catch ( Exception ex ) { throw new RuntimeException ( ex ) ; } }
public QuickActionView addActions ( Collection < Action > actions ) { checkShown ( ) ; mActions . addAll ( actions ) ; return this ; }
public void addSeriesRenderer ( int index , SimpleSeriesRenderer renderer ) { mRenderers . add ( index , renderer ) ; }
public static boolean copyStream ( InputStream is , OutputStream os , CopyListener listener , int bufferSize ) throws IOException { int current = NUM_ ; int total = is . available ( ) ; if ( total <= NUM_ ) { total = DEFAULT_IMAGE_TOTAL_SIZE ; } final byte [ ] bytes = new byte [ bufferSize ] ; int count ; if ( shouldStopLoading ( listener , current , total ) ) return BOOL_ ; while ( ( count = is . read ( bytes , NUM_ , bufferSize ) ) != - NUM_ ) { os . write ( bytes , NUM_ , count ) ; current += count ; if ( shouldStopLoading ( listener , current , total ) ) return BOOL_ ; } os . flush ( ) ; return BOOL_ ; }
private float calcAngle ( float value ) { return value / mData . getYValueSum ( ) . NUM_ ; }
public synchronized void returnBuf ( byte [ ] buf ) { if ( buf == null || buf . length > mSizeLimit ) { return ; } mBuffersByLastUse . add ( buf ) ; int pos = Collections . binarySearch ( mBuffersBySize , buf , BUF_COMPARATOR ) ; if ( pos < NUM_ ) { pos = - pos - NUM_ ; } mBuffersBySize . add ( pos , buf ) ; mCurrentSize += buf . length ; trim ( ) ; }
protected < T extends AbstractOptionValue < ? , ? > > AbstractOptions ( Function < T , T > valueFilter , AbstractOptions baseOptions , Iterable < T > values ) { requireNonNull ( baseOptions , STR_ ) ; requireNonNull ( valueFilter , STR_ ) ; requireNonNull ( values , STR_ ) ; valueMap = new IdentityHashMap < > ( baseOptions . valueMap ) ; putAll ( valueFilter , StreamSupport . stream ( values . spliterator ( ) , BOOL_ ) ) ; }
public CharSeq concat ( CharSeq another ) { return new CharSeq ( str + another . str ) ; }
@ Override protected void doGet ( HttpServletRequest req , HttpServletResponse resp ) throws ServletException , IOException { resp . setContentType ( STR_ ) ; PrintWriter sendToClient = resp . getWriter ( ) ; for ( Video v : this . videos ) { sendToClient . write ( v . getName ( ) + STR_ + v . getUrl ( ) + STR_ ) ; } }
protected void notifyStateChange ( int oldState , int newState ) { mState = newState ; if ( oldState != newState ) { firePropertyChange ( STR_ , Integer . valueOf ( oldState ) , Integer . valueOf ( newState ) ) ; } }
public void test_GetOrder ( ) { assertEquals ( STR_ , BigInteger . valueOf ( NUM_ ) , ecps . getOrder ( ) ) ; }
private void formatAndLogThrowable ( LoggingLevel level , Color color , String msg , Throwable t ) { if ( ! USE_COLORS ) { formatAndLogThrowable ( level , msg , t ) ; return ; } if ( PhotonLogger . level . id < level . id ) { return ; } LocalDateTime dateTime = LocalDateTime . now ( ) ; String formatted = formatLogLine ( level , dateTime , msg ) ; LoggingService . logThrowable ( dateTime , t , formatted , color ) ; }
public static String constructQueueRedisKey ( String queueName , String shardName , int priority , PinLaterJobState state ) { return String . format ( STR_ , PINLATER_QUEUE_KEY_PREFIX , shardName , queueName , priority , state . getValue ( ) ) ; }
public static String decodeCharset ( String s , String charset ) { if ( s == null ) { return null ; } try { byte buf [ ] = s . getBytes ( ASCII_CHARSET ) ; return ( new String ( buf , NUM_ , buf . length , charset ) ) ; } catch ( UnsupportedEncodingException uee ) { return s ; } }
public void addRestrictedDomain ( String domainName ) { if ( StringUtils . isEmpty ( domainName ) ) { return ; } if ( restrictedDomains == null ) { restrictedDomains = new ArrayList < > ( ) ; } restrictedDomains . add ( domainName ) ; }
StoppableReadLock ( ReadWriteLock lock , CancelCriterion stopper ) { this . lock = lock . readLock ( ) ; this . stopper = stopper ; }
public void testisAutoIncrement ( ) { try { assertFalse ( rsmd . isAutoIncrement ( NUM_ ) ) ; } catch ( SQLException e1 ) { fail ( STR_ + e1 . getMessage ( ) ) ; e1 . printStackTrace ( ) ; } try { conn . close ( ) ; rsmd . getSchemaName ( NUM_ ) ; fail ( STR_ ) ; } catch ( SQLException e ) { } }
private long computeInterfaceHash ( ) { long hash = NUM_ ; ByteArrayOutputStream sink = new ByteArrayOutputStream ( NUM_ ) ; try { MessageDigest md = MessageDigest . getInstance ( STR_ ) ; DataOutputStream out = new DataOutputStream ( new DigestOutputStream ( sink , md ) ) ; out . writeInt ( INTERFACE_HASH_STUB_VERSION ) ; for ( Method method : remoteMethods ) { MethodDoc methodDoc = method . methodDoc ( ) ; out . writeUTF ( methodDoc . name ( ) ) ; out . writeUTF ( Util . methodDescriptorOf ( methodDoc ) ) ; ClassDoc exceptions [ ] = methodDoc . thrownExceptions ( ) ; Arrays . sort ( exceptions , new ClassDocComparator ( ) ) ; for ( ClassDoc ex : exceptions ) { out . writeUTF ( Util . binaryNameOf ( ex ) ) ; } } out . flush ( ) ; byte hashArray [ ] = md . digest ( ) ; for ( int i = NUM_ ; i < Math . min ( NUM_ , hashArray . length ) ; i ++ ) { hash += ( ( long ) ( hashArray [ i ] & xFF ) ) << ( i . NUM_ ) ; } } catch ( IOException e ) { throw new AssertionError ( e ) ; } catch ( NoSuchAlgorithmException e ) { throw new AssertionError ( e ) ; } return hash ; }
public static void copy ( byte [ ] in , OutputStream out ) throws IOException { Assert . notNull ( in , STR_ ) ; Assert . notNull ( out , STR_ ) ; out . write ( in ) ; }
public boolean isEmpty ( ) { return items . isEmpty ( ) ; }
private static native boolean renderFrame ( int [ ] pixels , long gifFileInPtr , int [ ] metaData ) ;
private static int encodeText ( CharSequence msg , int startpos , int count , StringBuilder sb , int initialSubmode ) { StringBuilder tmp = new StringBuilder ( count ) ; int submode = initialSubmode ; int idx = NUM_ ; while ( BOOL_ ) { char ch = msg . charAt ( startpos + idx ) ; switch ( submode ) { case SUBMODE_ALPHA : if ( isAlphaUpper ( ch ) ) { if ( ch == STR_ ) { tmp . append ( ( char ) NUM_ ) ; } else { tmp . append ( ( char ) ( ch - NUM_ ) ) ; } } else { if ( isAlphaLower ( ch ) ) { submode = SUBMODE_LOWER ; tmp . append ( ( char ) NUM_ ) ; continue ; } else if ( isMixed ( ch ) ) { submode = SUBMODE_MIXED ; tmp . append ( ( char ) NUM_ ) ; continue ; } else { tmp . append ( ( char ) NUM_ ) ; tmp . append ( ( char ) PUNCTUATION [ ch ] ) ; break ; } } break ; case SUBMODE_LOWER : if ( isAlphaLower ( ch ) ) { if ( ch == STR_ ) { tmp . append ( ( char ) NUM_ ) ; } else { tmp . append ( ( char ) ( ch - NUM_ ) ) ; } } else { if ( isAlphaUpper ( ch ) ) { tmp . append ( ( char ) NUM_ ) ; tmp . append ( ( char ) ( ch - NUM_ ) ) ; break ; } else if ( isMixed ( ch ) ) { submode = SUBMODE_MIXED ; tmp . append ( ( char ) NUM_ ) ; continue ; } else { tmp . append ( ( char ) NUM_ ) ; tmp . append ( ( char ) PUNCTUATION [ ch ] ) ; break ; } } break ; case SUBMODE_MIXED : if ( isMixed ( ch ) ) { tmp . append ( ( char ) MIXED [ ch ] ) ; } else { if ( isAlphaUpper ( ch ) ) { submode = SUBMODE_ALPHA ; tmp . append ( ( char ) NUM_ ) ; continue ; } else if ( isAlphaLower ( ch ) ) { submode = SUBMODE_LOWER ; tmp . append ( ( char ) NUM_ ) ; continue ; } else { if ( startpos + idx + NUM_ < count ) { char next = msg . charAt ( startpos + idx + NUM_ ) ; if ( isPunctuation ( next ) ) { submode = SUBMODE_PUNCTUATION ; tmp . append ( ( char ) NUM_ ) ; continue ; } } tmp . append ( ( char ) NUM_ ) ; tmp . append ( ( char ) PUNCTUATION [ ch ] ) ; } } break ; default : if ( isPunctuation ( ch ) ) { tmp . append ( ( char ) PUNCTUATION [ ch ] ) ; } else { submode = SUBMODE_ALPHA ; tmp . append ( ( char ) NUM_ ) ; continue ; } } idx ++ ; if ( idx >= count ) { break ; } } char h = NUM_ ; int len = tmp . length ( ) ; for ( int i = NUM_ ; i < len ; i ++ ) { boolean odd = ( i % NUM_ ) != NUM_ ; if ( odd ) { h = ( char ) ( ( h . NUM_ ) + tmp . charAt ( i ) ) ; sb . append ( h ) ; } else { h = tmp . charAt ( i ) ; } } if ( ( len % NUM_ ) != NUM_ ) { sb . append ( ( char ) ( ( h . NUM_ ) + NUM_ ) ) ; } return submode ; }
public static boolean isValidNCName ( String ncName ) { if ( ncName . length ( ) == NUM_ ) return BOOL_ ; char ch = ncName . charAt ( NUM_ ) ; if ( isNCNameStart ( ch ) == BOOL_ ) return BOOL_ ; for ( int i = NUM_ ; i < ncName . length ( ) ; i ++ ) { ch = ncName . charAt ( i ) ; if ( isNCName ( ch ) == BOOL_ ) { return BOOL_ ; } } return BOOL_ ; }
public RepeatedFieldBuilder < MType , BType , IType > addMessage ( MType message ) { if ( message == null ) { throw new NullPointerException ( ) ; } ensureMutableMessageList ( ) ; messages . add ( message ) ; if ( builders != null ) { builders . add ( null ) ; } onChanged ( ) ; incrementModCounts ( ) ; return this ; }
protected void prepareDataSet ( ) { dataSet1 = Arrays . asList ( new String [ ] { STR_ , STR_ , STR_ } ) ; dataSet2 = Arrays . asList ( new String [ ] { STR_ , STR_ , STR_ } ) ; dataSet3 = Arrays . asList ( new String [ ] { STR_ , STR_ , STR_ , STR_ } ) ; }
private ServiceRegistrar [ ] buildServiceRegistrar ( ) { int k = NUM_ ; ServiceRegistrar [ ] proxys = new ServiceRegistrar [ proxyRegSet . size ( ) ] ; Iterator iter = proxyRegSet . iterator ( ) ; while ( iter . hasNext ( ) ) { ProxyReg reg = ( ProxyReg ) iter . next ( ) ; proxys [ k ++ ] = reg . proxy ; } return proxys ; }
private static boolean checkValue ( String val ) throws MalformedObjectNameException { if ( val == null ) throw new NullPointerException ( STR_ ) ; final int len = val . length ( ) ; if ( len == NUM_ ) return BOOL_ ; final char [ ] s = val . toCharArray ( ) ; final int [ ] result = parseValue ( s , NUM_ ) ; final int endValue = result [ NUM_ ] ; final boolean value_pattern = result [ NUM_ ] == NUM_ ; if ( endValue < len ) throw new MalformedObjectNameException ( STR_ + s [ endValue ] + STR_ ) ; return value_pattern ; }
protected void recoverPrimary ( Set excludedServers ) { if ( pool . getPoolOrCacheCancelInProgress ( ) != null ) { return ; } final boolean isDebugEnabled = logger . isDebugEnabled ( ) ; if ( queueConnections . getPrimary ( ) != null ) { if ( isDebugEnabled ) { logger . debug ( STR_ ) ; } return ; } if ( isDebugEnabled ) { logger . debug ( STR_ ) ; } if ( printRecoveringPrimary ) { logger . info ( LocalizedMessage . create ( LocalizedStrings . QueueManagerImpl_SUBSCRIPTION_MANAGER_REDUNDANCY_SATISFIER_PRIMARY_ENDPOINT_HAS_BEEN_LOST_ATTEMPTIMG_TO_RECOVER ) ) ; printRecoveringPrimary = BOOL_ ; } QueueConnectionImpl newPrimary = null ; while ( newPrimary == null && pool . getPoolOrCacheCancelInProgress ( ) == null ) { List backups = queueConnections . getBackups ( ) ; newPrimary = promoteBackupToPrimary ( backups ) ; if ( newPrimary == null ) { break ; } if ( ! addToConnectionList ( newPrimary , BOOL_ ) ) { synchronized ( lock ) { queueConnections = queueConnections . removeConnection ( newPrimary ) ; } newPrimary = null ; } } if ( newPrimary != null ) { if ( isDebugEnabled ) { logger . debug ( STR_ , newPrimary . getEndpoint ( ) ) ; } if ( PoolImpl . AFTER_PRIMARY_RECOVERED_CALLBACK_FLAG ) { ClientServerObserver bo = ClientServerObserverHolder . getInstance ( ) ; bo . afterPrimaryRecovered ( newPrimary . getServer ( ) ) ; } cqsConnected ( ) ; printPrimaryNotFoundError = BOOL_ ; printRecoveringPrimary = BOOL_ ; return ; } while ( newPrimary == null ) { newPrimary = createNewPrimary ( excludedServers ) ; if ( newPrimary == null ) { break ; } if ( ! addToConnectionList ( newPrimary , BOOL_ ) ) { excludedServers . add ( newPrimary . getServer ( ) ) ; newPrimary = null ; } if ( newPrimary != null ) { if ( isDebugEnabled ) { logger . debug ( STR_ , newPrimary . getEndpoint ( ) ) ; } if ( ! recoverInterest ( newPrimary , BOOL_ ) ) { excludedServers . add ( newPrimary . getServer ( ) ) ; newPrimary = null ; } cqsConnected ( ) ; } if ( newPrimary != null && PoolImpl . AFTER_PRIMARY_RECOVERED_CALLBACK_FLAG ) { ClientServerObserver bo = ClientServerObserverHolder . getInstance ( ) ; bo . afterPrimaryRecovered ( newPrimary . getServer ( ) ) ; } printPrimaryNotFoundError = BOOL_ ; printRecoveringPrimary = BOOL_ ; return ; } cqsDisconnected ( ) ; if ( isDebugEnabled ) { logger . debug ( STR_ ) ; } synchronized ( lock ) { queueConnections = queueConnections . setPrimaryDiscoveryFailed ( null ) ; lock . notifyAll ( ) ; } }
private synchronized void rebuildJournal ( ) throws IOException { if ( journalWriter != null ) { journalWriter . close ( ) ; } Writer writer = new BufferedWriter ( new FileWriter ( journalFileTmp ) , IO_BUFFER_SIZE ) ; writer . write ( MAGIC ) ; writer . write ( STR_ ) ; writer . write ( VERSION_1 ) ; writer . write ( STR_ ) ; writer . write ( Integer . toString ( appVersion ) ) ; writer . write ( STR_ ) ; writer . write ( Integer . toString ( valueCount ) ) ; writer . write ( STR_ ) ; writer . write ( STR_ ) ; for ( Entry entry : lruEntries . values ( ) ) { if ( entry . currentEditor != null ) { writer . write ( DIRTY + STR_ + entry . key + STR_ ) ; } else { writer . write ( CLEAN + STR_ + entry . key + entry . getLengths ( ) + STR_ ) ; } } writer . close ( ) ; journalFileTmp . renameTo ( journalFile ) ; journalWriter = new BufferedWriter ( new FileWriter ( journalFile , BOOL_ ) , IO_BUFFER_SIZE ) ; }
public void remove ( ) throws RecurrenceInfoException { List < RecurrenceRule > rulesList = new ArrayList < RecurrenceRule > ( ) ; rulesList . addAll ( rRulesList ) ; rulesList . addAll ( eRulesList ) ; try { for ( RecurrenceRule rule : rulesList ) rule . remove ( ) ; info . remove ( ) ; } catch ( RecurrenceRuleException rre ) { throw new RecurrenceInfoException ( rre . getMessage ( ) , rre ) ; } catch ( GenericEntityException gee ) { throw new RecurrenceInfoException ( gee . getMessage ( ) , gee ) ; } }
public void addNodesInDocOrder ( DTMIterator iterator , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; int node ; while ( DTM . NULL != ( node = iterator . nextNode ( ) ) ) { addNodeInDocOrder ( node , support ) ; } }
protected boolean needToRefetchData ( ) { long now = System . currentTimeMillis ( ) ; long last = lastDataFetchTime ; if ( ( last + fetchIntervalMillis ) < now ) { lastDataFetchTime = now ; return BOOL_ ; } return BOOL_ ; }
@ Override public DocumentType createDocumentType ( String qualifiedName , String publicID , String systemID ) { checkQName ( qualifiedName ) ; return new DocumentTypeImpl ( null , qualifiedName , publicID , systemID ) ; }
public void handleRequest ( RequestContext rc ) throws CLIException { super . handleRequest ( rc ) ; ldapLogin ( ) ; SSOToken adminSSOToken = getAdminSSOToken ( ) ; IOutput outputWriter = getOutputWriter ( ) ; String realm = getStringOptionValue ( IArgument . REALM_NAME ) ; String patternType = getStringOptionValue ( IArgument . AGENT_TYPE ) ; String filter = getStringOptionValue ( IArgument . FILTER ) ; if ( patternType == null ) { patternType = STR_ ; } if ( ( filter == null ) || ( filter . length ( ) == NUM_ ) ) { filter = STR_ ; } String [ ] params = { realm , patternType , filter } ; writeLog ( LogWriter . LOG_ACCESS , Level . INFO , STR_ , params ) ; try { AMIdentityRepository amir = new AMIdentityRepository ( adminSSOToken , realm ) ; IdSearchResults isr = amir . searchIdentities ( IdType . AGENTONLY , filter , new IdSearchControl ( ) ) ; Set results = isr . getSearchResults ( ) ; if ( ( results != null ) && ! results . isEmpty ( ) ) { for ( Iterator i = results . iterator ( ) ; i . hasNext ( ) ; ) { AMIdentity amid = ( AMIdentity ) i . next ( ) ; if ( ! matchType ( amid , patternType ) ) { i . remove ( ) ; } } } if ( ( results != null ) && ! results . isEmpty ( ) ) { for ( Iterator i = results . iterator ( ) ; i . hasNext ( ) ; ) { AMIdentity amid = ( AMIdentity ) i . next ( ) ; Object [ ] args = { amid . getName ( ) , amid . getUniversalId ( ) } ; outputWriter . printlnMessage ( MessageFormat . format ( getResourceString ( STR_ ) , args ) ) ; } } else { outputWriter . printlnMessage ( getResourceString ( STR_ ) ) ; } writeLog ( LogWriter . LOG_ACCESS , Level . INFO , STR_ , params ) ; } catch ( IdRepoException e ) { String [ ] args = { realm , patternType , filter , e . getMessage ( ) } ; debugError ( STR_ , e ) ; writeLog ( LogWriter . LOG_ERROR , Level . INFO , STR_ , args ) ; throw new CLIException ( e , ExitCodes . REQUEST_CANNOT_BE_PROCESSED ) ; } catch ( SSOException e ) { String [ ] args = { realm , patternType , filter , e . getMessage ( ) } ; debugError ( STR_ , e ) ; writeLog ( LogWriter . LOG_ERROR , Level . INFO , STR_ , args ) ; throw new CLIException ( e , ExitCodes . REQUEST_CANNOT_BE_PROCESSED ) ; } }
public byte [ ] toBytes ( ) { try { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; _field . store ( out , null ) ; return out . toByteArray ( ) ; } catch ( IOException e ) { throw new IllegalStateException ( e ) ; } }
@ SuppressWarnings ( STR_ ) public static < E extends Enum < ? extends Style . HasCssName > > E fromStyleName ( final String styleName , final Class < E > enumClass , final E defaultValue ) { if ( styleName == null || enumClass == null ) { return defaultValue ; } for ( final Enum < ? extends Style . HasCssName > constant : enumClass . getEnumConstants ( ) ) { final Style . HasCssName anEnum = ( Style . HasCssName ) constant ; final String cssClass = anEnum . getCssName ( ) ; if ( cssClass != null && StyleHelper . containsStyle ( styleName , cssClass ) ) { return ( E ) anEnum ; } } return defaultValue ; }
@ HLEUnimplemented @ HLEFunction ( nid = x3C37A7A6 , version = NUM_ , checkInsideInterrupt = BOOL_ ) public int sceMpegNextAvcRpAu ( @ CheckArgument ( STR_ ) int mpeg , int streamUid ) { if ( ! streamMap . containsKey ( streamUid ) ) { log . warn ( String . format ( STR_ , streamUid ) ) ; return - NUM_ ; } int result = hleMpegGetAvcAu ( null ) ; if ( result != NUM_ ) { if ( log . isDebugEnabled ( ) ) { log . debug ( String . format ( STR_ , result ) ) ; } return result ; } videoFrameCount ++ ; startedMpeg = BOOL_ ; return NUM_ ; }
private Map < URI , ExportMask > createExportMaskMap ( Set < URI > placedMasks ) { Map < URI , ExportMask > exportMaskMap = new HashMap < > ( ) ; Iterator < ExportMask > exportMaskIterator = dbClient . queryIterativeObjects ( ExportMask . class , placedMasks , BOOL_ ) ; while ( exportMaskIterator . hasNext ( ) ) { ExportMask exportMask = exportMaskIterator . next ( ) ; exportMaskMap . put ( exportMask . getId ( ) , exportMask ) ; } return exportMaskMap ; }
public ImmutableArray2 < K > insert ( int index , K obj ) { int len = length + NUM_ ; int newLen = len ; boolean extendable ; if ( index == len - NUM_ ) { AtomicBoolean x = canExtend ; if ( x != null ) { canExtend = null ; if ( array . length > index && x . getAndSet ( BOOL_ ) ) { array [ index ] = obj ; return new ImmutableArray2 < K > ( array , len , BOOL_ ) ; } } extendable = BOOL_ ; newLen = len + NUM_ ; } else { extendable = BOOL_ ; } @ SuppressWarnings ( STR_ ) K [ ] a2 = ( K [ ] ) new Object [ newLen ] ; DataUtils . copyWithGap ( array , a2 , length , index ) ; a2 [ index ] = obj ; return new ImmutableArray2 < K > ( a2 , len , extendable ) ; }
public void writeNoScale ( Image c , Component i ) { if ( page == null ) { newpage ( ) ; } int x = x0 + width - ( c . getWidth ( null ) + charwidth ) ; int y = y0 + ( linenum . lineheight ) + lineascent ; if ( page != null && pagenum >= prFirst ) { page . drawImage ( c , x , y , c . getWidth ( null ) , c . getHeight ( null ) , null ) ; } }
public void putDocumentInCache ( int n , Source source ) { int cachedNode = getNode ( source ) ; if ( DTM . NULL != cachedNode ) { if ( ! ( cachedNode == n ) ) throw new RuntimeException ( STR_ + STR_ + source . getSystemId ( ) ) ; return ; } if ( null != source . getSystemId ( ) ) { m_sourceTree . addElement ( new SourceTree ( n , source . getSystemId ( ) ) ) ; } }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
public static void copy ( InputStream is , Resource out , boolean closeIS ) throws IOException { OutputStream os = null ; try { os = toBufferedOutputStream ( out . getOutputStream ( ) ) ; } catch ( IOException ioe ) { IOUtil . closeEL ( os ) ; throw ioe ; } copy ( is , os , closeIS , BOOL_ ) ; }
public String fadeAudio ( String path , String type , double fadeInLength , double stopTime , double fadeOutLength ) throws IOException { final List < String > curves = Arrays . asList ( new String [ ] { STR_ , STR_ , STR_ , STR_ , STR_ } ) ; if ( ! curves . contains ( type ) ) { throw new RuntimeException ( STR_ + type ) ; } File file = new File ( path ) ; String outFile = file . getCanonicalPath ( ) + STR_ ; ArrayList < String > cmd = new ArrayList < String > ( ) ; cmd . add ( soxBin ) ; cmd . add ( path ) ; cmd . add ( outFile ) ; cmd . add ( STR_ ) ; cmd . add ( type ) ; cmd . add ( fadeInLength + STR_ ) ; if ( stopTime != - NUM_ ) cmd . add ( stopTime + STR_ ) ; if ( fadeOutLength != - NUM_ ) cmd . add ( fadeOutLength + STR_ ) ; try { int rc = execSox ( cmd , callback ) ; if ( rc != NUM_ ) { outFile = null ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } return outFile ; }
@ Override public void draw ( Canvas canvas ) { super . draw ( canvas ) ; if ( mEdgeGlowTop != null ) { final int scrollX = getScrollX ( ) ; if ( ! mEdgeGlowTop . isFinished ( ) ) { final int restoreCount = canvas . save ( ) ; final int topPadding = mListPadding . top + mGlowPaddingTop ; final int bottomPadding = mListPadding . bottom + mGlowPaddingBottom ; final int height = getHeight ( ) - topPadding - bottomPadding ; int edgeX = Math . min ( NUM_ , scrollX + mFirstPositionDistanceGuess ) ; canvas . rotate ( - NUM_ ) ; canvas . translate ( - getHeight ( ) + topPadding , edgeX ) ; mEdgeGlowTop . setSize ( height , height ) ; if ( mEdgeGlowTop . draw ( canvas ) ) { invalidate ( ) ; } canvas . restoreToCount ( restoreCount ) ; } if ( ! mEdgeGlowBottom . isFinished ( ) ) { final int restoreCount = canvas . save ( ) ; final int topPadding = mListPadding . left + mGlowPaddingTop ; final int bottomPadding = mListPadding . right + mGlowPaddingBottom ; final int height = getHeight ( ) - topPadding - bottomPadding ; final int width = getWidth ( ) ; int edgeX = Math . max ( width , scrollX + mLastPositionDistanceGuess ) ; canvas . rotate ( NUM_ ) ; canvas . translate ( - topPadding , - edgeX ) ; mEdgeGlowBottom . setSize ( height , height ) ; if ( mEdgeGlowBottom . draw ( canvas ) ) { invalidate ( ) ; } canvas . restoreToCount ( restoreCount ) ; } } }
public static ClassProperties loadProperties ( Class [ ] cls , Properties properties , boolean inherit ) { ClassProperties cp = new ClassProperties ( properties ) ; for ( Class c : cls ) { cp . load ( c , inherit ) ; } return cp ; }
public void testCase20 ( ) { byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte rBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int bSign = NUM_ ; BigInteger aNumber = BigInteger . ZERO ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . add ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
private static void fixGPSTimeStamp ( XMPNode exifSchema ) throws XMPException { XMPNode gpsDateTime = XMPNodeUtils . findChildNode ( exifSchema , STR_ , BOOL_ ) ; if ( gpsDateTime == null ) { return ; } try { XMPDateTime binGPSStamp ; XMPDateTime binOtherDate ; binGPSStamp = XMPUtils . convertToDate ( gpsDateTime . getValue ( ) ) ; if ( binGPSStamp . getYear ( ) != NUM_ || binGPSStamp . getMonth ( ) != NUM_ || binGPSStamp . getDay ( ) != NUM_ ) { return ; } XMPNode otherDate = XMPNodeUtils . findChildNode ( exifSchema , STR_ , BOOL_ ) ; if ( otherDate == null ) { otherDate = XMPNodeUtils . findChildNode ( exifSchema , STR_ , BOOL_ ) ; } binOtherDate = XMPUtils . convertToDate ( otherDate . getValue ( ) ) ; Calendar cal = binGPSStamp . getCalendar ( ) ; cal . set ( Calendar . YEAR , binOtherDate . getYear ( ) ) ; cal . set ( Calendar . MONTH , binOtherDate . getMonth ( ) ) ; cal . set ( Calendar . DAY_OF_MONTH , binOtherDate . getDay ( ) ) ; binGPSStamp = new XMPDateTimeImpl ( cal ) ; gpsDateTime . setValue ( XMPUtils . convertFromDate ( binGPSStamp ) ) ; } catch ( XMPException e ) { return ; } }
protected boolean cellConsumesEventType ( Cell < ? > cell , String eventType ) { Set < String > consumedEvents = cell . getConsumedEvents ( ) ; return consumedEvents != null && consumedEvents . contains ( eventType ) ; }
public int read ( ) throws IOException { int b0 = fInputStream . read ( ) ; if ( b0 > x80 ) { throw new IOException ( Localizer . getMessage ( STR_ , Integer . toString ( b0 ) ) ) ; } return b0 ; }
protected void create_y_axis ( int i ) { Log . e ( STR_ , i + STR_ ) ; float ver_height = ( ( graphheight / label_size ) . i ) + border ; if ( i == largest_value_set . size ( ) - NUM_ ) canvas . drawLine ( horstart , ver_height , width - ( border ) , ver_height , paint ) ; else canvas . drawLine ( horstart , ver_height , border , ver_height , paint ) ; paint . setColor ( Color . BLACK ) ; int Y_labels = ( int ) size - NUM_ - i ; String y_labels = String . format ( STR_ , Y_labels . y_axis_ratio ) ; paint . setTextAlign ( Paint . Align . RIGHT ) ; canvas . drawText ( y_labels , horstart - NUM_ , ver_height - NUM_ , paint ) ; paint . setTextAlign ( Paint . Align . LEFT ) ; }
public long max ( ) { return deltaMax . get ( ) ; }
public void print ( File file ) throws IOException { checkExec ( ) ; SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) { sm . checkPrintJobAccess ( ) ; } checkActionSupport ( Action . PRINT ) ; checkFileValidation ( file ) ; peer . print ( file ) ; }
public void extend ( RuleGrounding other ) { if ( other . isFailed ( ) ) { groundings . clear ( ) ; return ; } extend ( other . getAlternatives ( ) ) ; }
@ Override public String expect ( Pattern pattern ) { final String token = read ( pattern ) ; if ( token == null ) { throw new ParserException ( STR_ + pattern . pattern ( ) + STR_ + document ) ; } return token ; }
public void testGetTableTypesOrder ( ) throws Exception { DatabaseMetaData dmd = con . getMetaData ( ) ; ResultSet rs = dmd . getTableTypes ( ) ; String previousType = STR_ ; while ( rs . next ( ) ) { String type = rs . getString ( NUM_ ) ; assertTrue ( type . compareTo ( previousType ) >= NUM_ ) ; previousType = type ; } rs . close ( ) ; }
private FileChannel updateCache ( String filePath ) { FileChannel fileChannel = fileNameAndStreamCache . get ( filePath ) ; try { if ( null == fileChannel ) { FileInputStream stream = new FileInputStream ( filePath ) ; fileChannel = stream . getChannel ( ) ; fileNameAndStreamCache . put ( filePath , fileChannel ) ; } } catch ( IOException e ) { LOGGER . error ( e , e . getMessage ( ) ) ; } return fileChannel ; }
public void removeSwipeListener ( SwipeListener listener ) { if ( mListeners == null ) { return ; } mListeners . remove ( listener ) ; }
private static String descriptorForFieldSignature ( String signature ) { return signature . replace ( STR_ , STR_ ) ; }
public void addParameters ( final NameValuePair [ ] parameters ) { LOG . trace ( STR_ ) ; if ( parameters == null ) { LOG . warn ( STR_ ) ; } else { super . clearRequestBody ( ) ; for ( int i = NUM_ ; i < parameters . length ; i ++ ) { params . add ( parameters [ i ] ) ; } } }
@ Pure public Atom annotationInterfaceToAnnotationClass ( ) { byte [ ] annotationClassName_tmp = new byte [ val . length + NUM_ ] ; System . arraycopy ( val , NUM_ , annotationClassName_tmp , NUM_ , val . length - NUM_ ) ; annotationClassName_tmp [ val . length - NUM_ ] = STR_ ; annotationClassName_tmp [ val . length ] = STR_ ; annotationClassName_tmp [ val . length + NUM_ ] = STR_ ; return Atom . findOrCreateUtf8Atom ( annotationClassName_tmp ) ; }
public boolean resourceSupportAR ( Integer id ) { if ( id == null ) { return BOOL_ ; } return resourceSupportAR ( id . intValue ( ) ) ; }
public static Map < String , Object > createElectronicText ( DispatchContext dctx , Map < String , ? extends Object > context ) { Map < String , Object > result = createElectronicTextMethod ( dctx , context ) ; return result ; }
public PatternGuardExpr ( String namespace , String name , Expression [ ] parameters , PatternExpr guarded ) { this ( namespace , name , Arrays . asList ( parameters ) , guarded ) ; }
public static int intersectLineLine ( Line2D a , Line2D b , Point2D intersect ) { double a1x = a . getX1 ( ) , a1y = a . getY1 ( ) ; double a2x = a . getX2 ( ) , a2y = a . getY2 ( ) ; double b1x = b . getX1 ( ) , b1y = b . getY1 ( ) ; double b2x = b . getX2 ( ) , b2y = b . getY2 ( ) ; return intersectLineLine ( a1x , a1y , a2x , a2y , b1x , b1y , b2x , b2y , intersect ) ; }
public static Set updateAndGetRemovableOCs ( Set origSet , Set removeOCs ) { Set returnOCs = removeOCs ; if ( removeOCs != null && ! removeOCs . isEmpty ( ) ) { returnOCs = new HashSet ( ) ; Iterator itr1 = origSet . iterator ( ) ; while ( itr1 . hasNext ( ) ) { String origOC = ( String ) itr1 . next ( ) ; Iterator itr2 = removeOCs . iterator ( ) ; while ( itr2 . hasNext ( ) ) { String removeOC = ( String ) itr2 . next ( ) ; if ( origOC . equalsIgnoreCase ( removeOC ) ) { returnOCs . add ( origOC ) ; break ; } } } origSet . removeAll ( returnOCs ) ; } return returnOCs ; }
public static int unixTimestamp ( ) { return ( int ) ( System . currentTimeMillis ( ) / NUM_ ) ; }
public boolean isPDFLicense ( ) { String key = getSummary ( ) ; return key != null && key . length ( ) > NUM_ ; }
protected void drawGridBackground ( Canvas c ) { if ( mDrawGridBackground ) { c . drawRect ( mViewPortHandler . getContentRect ( ) , mGridBackgroundPaint ) ; } if ( mDrawBorders ) { c . drawRect ( mViewPortHandler . getContentRect ( ) , mBorderPaint ) ; } }
public ZipStreamImpl openReadImpl ( PathImpl path ) throws IOException { String pathName = path . getPath ( ) ; return openReadImpl ( pathName ) ; }
private static char [ ] zzUnpackCMap ( String packed ) { char [ ] map = new char [ x10000 ] ; int i = NUM_ ; int j = NUM_ ; while ( i < NUM_ ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM_ ) ; } return map ; }
@ Override public void onTmpFilesCopied ( ResultCode result ) { dismissLoadingDialog ( ) ; finish ( ) ; }
public synchronized OMGraphicList prepare ( ) { Projection projection = getProjection ( ) ; boolean DEBUG_FINE = logger . isLoggable ( Level . FINE ) ; if ( projection == null ) { if ( DEBUG_FINE ) { logger . fine ( getName ( ) + STR_ ) ; } return new OMGraphicList ( ) ; } if ( spatialIndex == null ) { if ( DEBUG_FINE ) { logger . fine ( getName ( ) + STR_ ) ; } OMGraphicList list = getList ( ) ; if ( list != null ) { list . generate ( projection , BOOL_ ) ; return list ; } else { return new OMGraphicList ( ) ; } } Point2D ul = projection . getUpperLeft ( ) ; Point2D lr = projection . getLowerRight ( ) ; double ulLat = ul . getY ( ) ; double ulLon = ul . getX ( ) ; double lrLat = lr . getY ( ) ; double lrLon = lr . getX ( ) ; OMGraphicList list = new OMGraphicList ( ) ; if ( ProjMath . isCrossingDateline ( ulLon , lrLon , projection . getScale ( ) ) ) { if ( DEBUG_FINE ) { logger . fine ( STR_ ) ; } double ymin = Math . min ( ulLat , lrLat ) ; double ymax = Math . max ( ulLat , lrLat ) ; try { list = spatialIndex . getOMGraphics ( ulLon , ymin , NUM_ , ymax , list , drawingAttributes , projection , coordTransform ) ; list = spatialIndex . getOMGraphics ( - NUM_ , ymin , lrLon , ymax , list , drawingAttributes , projection , coordTransform ) ; } catch ( InterruptedIOException iioe ) { list = null ; } catch ( IOException ex ) { if ( DEBUG_FINE ) { ex . printStackTrace ( ) ; } } catch ( FormatException fe ) { if ( DEBUG_FINE ) { fe . printStackTrace ( ) ; } } catch ( NullPointerException npe ) { if ( DEBUG_FINE ) { npe . printStackTrace ( ) ; } } } else { double xmin = Math . min ( ulLon , lrLon ) ; double xmax = Math . max ( ulLon , lrLon ) ; double ymin = Math . min ( ulLat , lrLat ) ; double ymax = Math . max ( ulLat , lrLat ) ; try { list = spatialIndex . getOMGraphics ( xmin , ymin , xmax , ymax , list , drawingAttributes , projection , coordTransform ) ; } catch ( InterruptedIOException iioe ) { list = null ; } catch ( java . io . IOException ex ) { if ( DEBUG_FINE ) { ex . printStackTrace ( ) ; } } catch ( FormatException fe ) { if ( DEBUG_FINE ) { fe . printStackTrace ( ) ; } } catch ( NullPointerException npe ) { if ( DEBUG_FINE ) { npe . printStackTrace ( ) ; } } } return list ; }
static WorkQueue commonSubmitterQueue ( ) { ForkJoinPool p ; WorkQueue [ ] ws ; int m ; Submitter z ; return ( ( z = submitters . get ( ) ) != null && ( p = commonPool ) != null && ( ws = p . workQueues ) != null && ( m = ws . length - NUM_ ) >= NUM_ ) ? ws [ m & z . seed & SQMASK ] : null ; }
private boolean isFieldPackagePrivate ( Element attribute ) { Set < Modifier > modifiers = attribute . getModifiers ( ) ; return ! modifiers . contains ( PUBLIC ) && ! modifiers . contains ( PROTECTED ) && ! modifiers . contains ( PRIVATE ) ; }
public void testDivideRoundHalfUpPos ( ) { String a = STR_ ; int aScale = - NUM_ ; String b = STR_ ; int bScale = NUM_ ; String c = STR_ ; int resScale = - NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal bNumber = new BigDecimal ( new BigInteger ( b ) , bScale ) ; BigDecimal result = aNumber . divide ( bNumber , resScale , BigDecimal . ROUND_HALF_UP ) ; assertEquals ( STR_ , c , result . toString ( ) ) ; assertEquals ( STR_ , resScale , result . scale ( ) ) ; }
public boolean reallyRestoreMsWordListFormatForUser ( String userId , InputStreamReader streamReader , boolean isAdmin , Errors errors ) { if ( userId == null ) { Errors . add ( errors , errorMessages . errorsUserIdIsNull ( ) ) ; return BOOL_ ; } if ( streamReader == null ) { Errors . add ( errors , errorMessages . errorsTheInputStreamReaderIsNull ( ) ) ; return BOOL_ ; } BufferedReader bf = new BufferedReader ( streamReader ) ; final User user = getUserById ( userId ) ; if ( user == null ) { return BOOL_ ; } boolean createdAnyChildren = BOOL_ ; try { final long now = System . currentTimeMillis ( ) ; Entry notebook = createEntryNoteBook ( user , STR_ , now , null , null , BOOL_ , BOOL_ , BOOL_ , isAdmin , BOOL_ , errors ) ; if ( notebook == null ) { return BOOL_ ; } Entry root = getEntryById ( notebook . getRootId ( ) ) ; ArrayList < Entry > parents = new ArrayList < Entry > ( ) ; HashMap < String , Integer > bulletToDepth = new HashMap < String , Integer > ( ) ; String line = null ; Integer previousDepth = NUM_ ; parents . add ( root ) ; while ( ( line = bf . readLine ( ) ) != null ) { line = line . trim ( ) ; if ( line . isEmpty ( ) ) { continue ; } String note = line ; Integer depth = NUM_ ; if ( line . length ( ) > NUM_ && line . charAt ( NUM_ ) == STR_ ) { String bullet = line . substring ( NUM_ , NUM_ ) ; note = line . substring ( NUM_ ) ; depth = bulletToDepth . get ( bullet ) ; if ( depth == null ) { depth = new Integer ( bulletToDepth . size ( ) + NUM_ ) ; bulletToDepth . put ( bullet , depth ) ; } for ( int i = parents . size ( ) ; i > depth . intValue ( ) ; -- i ) { parents . remove ( i - NUM_ ) ; } depth = new Integer ( parents . size ( ) + NUM_ ) ; } else { previousDepth = NUM_ ; while ( parents . size ( ) > NUM_ ) { parents . remove ( parents . size ( ) - NUM_ ) ; } } if ( parents . isEmpty ( ) ) { return BOOL_ ; } Entry parent = parents . get ( parents . size ( ) - NUM_ ) ; Entry entry = createSimpleEntry ( user , note , now , parent . getId ( ) , TreeRelType . Parent , BOOL_ , BOOL_ , BOOL_ , isAdmin , Constants . note , errors , null ) ; if ( entry == null ) { return BOOL_ ; } if ( previousDepth . intValue ( ) != depth . intValue ( ) ) { parents . add ( entry ) ; } else { parents . set ( parents . size ( ) - NUM_ , entry ) ; } createdAnyChildren = BOOL_ ; } } catch ( IOException e ) { Errors . add ( errors , errorMessages . errorProblemReadingInput ( ) ) ; } return createdAnyChildren ; }
@ CallSuper protected void onPageScrolled ( int position , float offset , int offsetPixels ) { if ( mDecorChildCount > NUM_ ) { final int scrollX = getScrollX ( ) ; int paddingLeft = getPaddingLeft ( ) ; int paddingRight = getPaddingRight ( ) ; final int width = getWidth ( ) ; final int childCount = getChildCount ( ) ; for ( int i = NUM_ ; i < childCount ; i ++ ) { final View child = getChildAt ( i ) ; final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; if ( ! lp . isDecor ) continue ; final int hgrav = lp . gravity & Gravity . HORIZONTAL_GRAVITY_MASK ; int childLeft = NUM_ ; switch ( hgrav ) { default : childLeft = paddingLeft ; break ; case Gravity . LEFT : childLeft = paddingLeft ; paddingLeft += child . getWidth ( ) ; break ; case Gravity . CENTER_HORIZONTAL : childLeft = Math . max ( ( width - child . getMeasuredWidth ( ) ) / NUM_ , paddingLeft ) ; break ; case Gravity . RIGHT : childLeft = width - paddingRight - child . getMeasuredWidth ( ) ; paddingRight += child . getMeasuredWidth ( ) ; break ; } childLeft += scrollX ; final int childOffset = childLeft - child . getLeft ( ) ; if ( childOffset != NUM_ ) { child . offsetLeftAndRight ( childOffset ) ; } } } dispatchOnPageScrolled ( position , offset , offsetPixels ) ; if ( mPageTransformer != null ) { final int scrollX = getScrollX ( ) ; final int childCount = getChildCount ( ) ; for ( int i = NUM_ ; i < childCount ; i ++ ) { final View child = getChildAt ( i ) ; final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; if ( lp . isDecor ) continue ; final float transformPos = ( float ) ( child . getLeft ( ) - scrollX ) / getClientWidth ( ) ; mPageTransformer . transformPage ( child , transformPos ) ; } } mCalledSuper = BOOL_ ; }
public static String convertCodes ( String string ) { if ( string == null ) return string ; int current = NUM_ ; char [ ] cs = string . toCharArray ( ) ; StringBuilder sb = new StringBuilder ( ) ; for ( char c : cs ) { if ( current <= cs . length && c == STR_ ) { char tc = Character . toLowerCase ( cs [ current + NUM_ ] ) ; if ( tc == STR_ || tc == STR_ || tc == STR_ || tc == STR_ || tc == STR_ || tc == STR_ || tc == STR_ || tc == STR_ || tc == STR_ || tc == STR_ || tc == STR_ || tc == STR_ || tc == STR_ || tc == STR_ || tc == STR_ || tc == STR_ || tc == STR_ || tc == STR_ || tc == STR_ || tc == STR_ || tc == STR_ ) { sb . append ( STR_ ) ; } else { sb . append ( c ) ; } } else { sb . append ( c ) ; } current ++ ; } return sb . toString ( ) ; }
private void loadText ( InputStream is ) { BufferedReader reader ; String line ; unitList = new ArrayList ( ) ; unitTypesList = new ArrayList ( ) ; if ( is == null ) { throw new Error ( STR_ ) ; } reader = new BufferedReader ( new InputStreamReader ( is ) ) ; try { line = reader . readLine ( ) ; lineCount ++ ; while ( line != null ) { if ( ! line . startsWith ( STR_ ) ) { parseAndAdd ( line , reader ) ; } line = reader . readLine ( ) ; } reader . close ( ) ; units = new DatabaseClusterUnit [ unitList . size ( ) ] ; units = ( DatabaseClusterUnit [ ] ) unitList . toArray ( units ) ; unitList = null ; unitTypes = new UnitType [ unitTypesList . size ( ) ] ; unitTypes = ( UnitType [ ] ) unitTypesList . toArray ( unitTypes ) ; unitTypesList = null ; } catch ( IOException e ) { throw new Error ( e . getMessage ( ) + STR_ + lineCount ) ; } finally { } }
private float calculateSelectorRadius ( ) { if ( mfSelectorRadius == NUM_ ) { int nHeight = mSelectedView . getHeight ( ) ; int nWidth = mSelectedView . getWidth ( ) ; int nLargerSide = Math . max ( nWidth , nHeight ) ; mfSelectorRadius = ( ( nLargerSide ^ NUM_ ) / NUM_ ) ; } return mfSelectorRadius ; }
private int measureWidth ( int measureSpec ) { int result ; int specMode = MeasureSpec . getMode ( measureSpec ) ; int specSize = MeasureSpec . getSize ( measureSpec ) ; if ( specMode == MeasureSpec . EXACTLY ) { result = specSize ; } else { result = ( int ) mTextPaint . measureText ( mText ) + getPaddingLeft ( ) + getPaddingRight ( ) ; if ( specMode == MeasureSpec . AT_MOST ) { result = Math . min ( result , specSize ) ; } } return result ; }
public void test_getPutByteArray ( ) { final int capacity = NUM_ ; final ByteArrayBuffer buf = new ByteArrayBuffer ( capacity ) ; assertEquals ( ( byte ) NUM_ , buf . getByte ( NUM_ ) ) ; assertEquals ( ( byte ) NUM_ , buf . getByte ( capacity - NUM_ ) ) ; final int pos = NUM_ ; for ( int i = NUM_ ; i < LIMIT ; i ++ ) { final byte [ ] expected = new byte [ r . nextInt ( capacity - NUM_ ) ] ; r . nextBytes ( expected ) ; buf . put ( pos , expected ) ; assertEquals ( NUM_ , BytesUtil . compareBytesWithLenAndOffset ( NUM_ , expected . length , expected , pos , expected . length , buf . array ( ) ) ) ; final byte [ ] actual = new byte [ expected . length ] ; buf . get ( pos , actual ) ; assertTrue ( BytesUtil . bytesEqual ( expected , actual ) ) ; } assertEquals ( ( byte ) NUM_ , buf . getByte ( NUM_ ) ) ; assertEquals ( ( byte ) NUM_ , buf . getByte ( pos + capacity - NUM_ ) ) ; }
@ Override public void onAdded ( final RPObject object ) { if ( isUser ( object ) ) { if ( object . has ( STR_ ) ) { adminlevel = object . getInt ( STR_ ) ; } } }
private String local_number ( ) throws ParseException { StringBuilder s = new StringBuilder ( ) ; if ( debug ) dbg_enter ( STR_ ) ; try { int lc = NUM_ ; while ( lexer . hasMoreChars ( ) ) { char la = lexer . lookAhead ( NUM_ ) ; if ( la == STR_ || la == STR_ || la == STR_ || la == STR_ || la == STR_ || la == STR_ || Lexer . isHexDigit ( la ) ) { lexer . consume ( NUM_ ) ; s . append ( la ) ; lc ++ ; } else if ( lc > NUM_ ) break ; else throw createParseException ( STR_ + la ) ; } return s . toString ( ) ; } finally { if ( debug ) dbg_leave ( STR_ ) ; } }
public void pathValuesToPixel ( List < Path > paths ) { for ( int i = NUM_ ; i < paths . size ( ) ; i ++ ) { pathValueToPixel ( paths . get ( i ) ) ; } }
public static byte [ ] decode ( String s ) { return decode ( s . toCharArray ( ) ) ; }
public static void checkState ( boolean expression , Object errorMessage ) { if ( ExoPlayerLibraryInfo . ASSERTIONS_ENABLED && ! expression ) { throw new IllegalStateException ( String . valueOf ( errorMessage ) ) ; } }
public static void slideInFromTopAnimator ( @ NonNull List < Animator > animators , @ NonNull View view , RecyclerView recyclerView ) { alphaAnimator ( animators , view , NUM_ ) ; animators . add ( ObjectAnimator . ofFloat ( view , STR_ , - recyclerView . getMeasuredHeight ( ) > > NUM_ , NUM_ ) ) ; if ( FlexibleAdapter . DEBUG ) Log . v ( TAG , STR_ ) ; }
MutableBigInteger ( MutableBigInteger val ) { intLen = val . intLen ; value = Arrays . copyOfRange ( val . value , val . offset , val . offset + intLen ) ; }
@ RequestMapping ( value = STR_ ) public void ssoBindingError ( Locale locale , @ PathVariable ( value = STR_ ) String tenant , HttpServletResponse response ) throws IOException { logger . info ( STR_ + locale . toString ( ) + STR_ + tenant ) ; ssoDefaultTenantError ( locale , response ) ; }
public CheckpointManager ( NetworkParameters params , @ Nullable InputStream inputStream ) throws IOException { this . params = checkNotNull ( params ) ; if ( inputStream == null ) inputStream = openStream ( params ) ; checkNotNull ( inputStream ) ; inputStream = new BufferedInputStream ( inputStream ) ; inputStream . mark ( NUM_ ) ; int first = inputStream . read ( ) ; inputStream . reset ( ) ; if ( first == BINARY_MAGIC . charAt ( NUM_ ) ) dataHash = readBinary ( inputStream ) ; else if ( first == TEXTUAL_MAGIC . charAt ( NUM_ ) ) dataHash = readTextual ( inputStream ) ; else throw new IOException ( STR_ ) ; }
public IndexSegmentIndex ( IRawStore store , Checkpoint checkpoint , IndexMetadata metadata , boolean readOnly ) { super ( store , checkpoint , metadata , readOnly ) ; }
private String liveness ( ) { boolean isClosed = BOOL_ ; try { if ( isClosed ( ) ) { isClosed = BOOL_ ; } } catch ( SQLException s ) { isClosed = BOOL_ ; } if ( isClosed ) { return STR_ ; } return STR_ ; }
private static void insertValue ( final Map < String , List < String > > paramsMap , final String paramVal , final String parameterName ) { if ( paramVal != null ) { List < String > list = new ArrayList < > ( ) ; list . add ( paramVal ) ; paramsMap . put ( parameterName , list ) ; } }
public Dimension minimumLayoutSize ( Container target ) { Dimension size ; synchronized ( this ) { checkContainer ( target ) ; checkRequests ( ) ; size = new Dimension ( xTotal . minimum , yTotal . minimum ) ; } Insets insets = target . getInsets ( ) ; size . width = ( int ) Math . min ( ( long ) size . width + ( long ) insets . left + ( long ) insets . right , Integer . MAX_VALUE ) ; size . height = ( int ) Math . min ( ( long ) size . height + ( long ) insets . top + ( long ) insets . bottom , Integer . MAX_VALUE ) ; return size ; }
private static void solve_l2r_l1l2_svr ( Problem prob , double [ ] w , Parameter param ) { int l = prob . l ; double C = param . C ; double p = param . p ; int w_size = prob . n ; double eps = param . eps ; int i , s , iter = NUM_ ; int max_iter = param . getMaxIters ( ) ; int active_size = l ; int [ ] index = new int [ l ] ; double d , G , H ; double Gmax_old = Double . POSITIVE_INFINITY ; double Gmax_new , Gnorm1_new ; double Gnorm1_init = - NUM_ ; double [ ] beta = new double [ l ] ; double [ ] QD = new double [ l ] ; double [ ] y = prob . y ; double [ ] lambda = new double [ ] { NUM_ / C } ; double [ ] upper_bound = new double [ ] { Double . POSITIVE_INFINITY } ; if ( param . solverType == SolverType . L2R_L1LOSS_SVR_DUAL ) { lambda [ NUM_ ] = NUM_ ; upper_bound [ NUM_ ] = C ; } for ( i = NUM_ ; i < l ; i ++ ) beta [ i ] = NUM_ ; for ( i = NUM_ ; i < w_size ; i ++ ) w [ i ] = NUM_ ; for ( i = NUM_ ; i < l ; i ++ ) { QD [ i ] = NUM_ ; for ( Feature xi : prob . x [ i ] ) { double val = xi . getValue ( ) ; QD [ i ] += val . val ; w [ xi . getIndex ( ) - NUM_ ] += beta [ i ] . val ; } index [ i ] = i ; } while ( iter < max_iter ) { Gmax_new = NUM_ ; Gnorm1_new = NUM_ ; for ( i = NUM_ ; i < active_size ; i ++ ) { int j = i + random . nextInt ( active_size - i ) ; swap ( index , i , j ) ; } for ( s = NUM_ ; s < active_size ; s ++ ) { i = index [ s ] ; G = - y [ i ] + lambda [ GETI_SVR ( i ) ] . beta [ i ] ; H = QD [ i ] + lambda [ GETI_SVR ( i ) ] ; for ( Feature xi : prob . x [ i ] ) { int ind = xi . getIndex ( ) - NUM_ ; double val = xi . getValue ( ) ; G += val . w [ ind ] ; } double Gp = G + p ; double Gn = G - p ; double violation = NUM_ ; if ( beta [ i ] == NUM_ ) { if ( Gp < NUM_ ) violation = - Gp ; else if ( Gn > NUM_ ) violation = Gn ; else if ( Gp > Gmax_old && Gn < - Gmax_old ) { active_size -- ; swap ( index , s , active_size ) ; s -- ; continue ; } } else if ( beta [ i ] >= upper_bound [ GETI_SVR ( i ) ] ) { if ( Gp > NUM_ ) violation = Gp ; else if ( Gp < - Gmax_old ) { active_size -- ; swap ( index , s , active_size ) ; s -- ; continue ; } } else if ( beta [ i ] <= - upper_bound [ GETI_SVR ( i ) ] ) { if ( Gn < NUM_ ) violation = - Gn ; else if ( Gn > Gmax_old ) { active_size -- ; swap ( index , s , active_size ) ; s -- ; continue ; } } else if ( beta [ i ] > NUM_ ) violation = Math . abs ( Gp ) ; else violation = Math . abs ( Gn ) ; Gmax_new = Math . max ( Gmax_new , violation ) ; Gnorm1_new += violation ; if ( Gp < H . beta [ i ] ) d = - Gp / H ; else if ( Gn > H . beta [ i ] ) d = - Gn / H ; else d = - beta [ i ] ; if ( Math . abs ( d ) < NUM_ ) continue ; double beta_old = beta [ i ] ; beta [ i ] = Math . min ( Math . max ( beta [ i ] + d , - upper_bound [ GETI_SVR ( i ) ] ) , upper_bound [ GETI_SVR ( i ) ] ) ; d = beta [ i ] - beta_old ; if ( d != NUM_ ) { for ( Feature xi : prob . x [ i ] ) { w [ xi . getIndex ( ) - NUM_ ] += d . xi . getValue ( ) ; } } } if ( iter == NUM_ ) Gnorm1_init = Gnorm1_new ; iter ++ ; if ( iter % NUM_ == NUM_ ) info ( STR_ ) ; if ( Gnorm1_new <= eps . Gnorm1_init ) { if ( active_size == l ) break ; else { active_size = l ; info ( STR_ ) ; Gmax_old = Double . POSITIVE_INFINITY ; continue ; } } Gmax_old = Gmax_new ; } info ( STR_ , iter ) ; if ( iter >= max_iter ) info ( STR_ ) ; double v = NUM_ ; int nSV = NUM_ ; for ( i = NUM_ ; i < w_size ; i ++ ) v += w [ i ] . w [ i ] ; v = NUM_ . v ; for ( i = NUM_ ; i < l ; i ++ ) { v += p . Math . abs ( beta [ i ] ) - y [ i ] . beta [ i ] + NUM_ . lambda [ GETI_SVR ( i ) ] . beta [ i ] . beta [ i ] ; if ( beta [ i ] != NUM_ ) nSV ++ ; } info ( STR_ , v ) ; info ( STR_ , nSV ) ; }
public boolean select ( int position ) { View v = mAllList . get ( position ) ; if ( mMultiChoiceAdapter != null ) { performVibrate ( ) ; performSelect ( v , position , BOOL_ ) ; return BOOL_ ; } return BOOL_ ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return result . elements ( ) ; }
@ Override public void ignorableWhitespace ( XMLString text , Augmentations augs ) throws XNIException { if ( ! fIncludeIgnorableWhitespace || fFilterReject ) { return ; } if ( ! fDeferNodeExpansion ) { Node child = fCurrentNode . getLastChild ( ) ; if ( child != null && child . getNodeType ( ) == Node . TEXT_NODE ) { Text textNode = ( Text ) child ; textNode . appendData ( text . toString ( ) ) ; } else { Text textNode = fDocument . createTextNode ( text . toString ( ) ) ; if ( fDocumentImpl != null ) { TextImpl textNodeImpl = ( TextImpl ) textNode ; textNodeImpl . setIgnorableWhitespace ( BOOL_ ) ; } fCurrentNode . appendChild ( textNode ) ; } } else { int txt = fDeferredDocumentImpl . createDeferredTextNode ( text . toString ( ) , BOOL_ ) ; fDeferredDocumentImpl . appendChild ( fCurrentNodeIndex , txt ) ; } }
private static final void waitForEditorToBeActive ( IEditorPart internalFileEditor , IWorkbenchPage page ) { long start = System . currentTimeMillis ( ) ; long end = start ; do { end = System . currentTimeMillis ( ) ; } while ( page . getActiveEditor ( ) != internalFileEditor && ( end - start ) < NUM_ ) ; if ( page . getActiveEditor ( ) != internalFileEditor ) logger . warn ( STR_ ) ; }
private Solution largestObjectiveValue ( int objective , Population population ) { Solution largest = null ; double value = Double . NEGATIVE_INFINITY ; for ( Solution solution : population ) { if ( solution . getObjective ( objective ) > value ) { largest = solution ; value = solution . getObjective ( objective ) ; } } return largest ; }
public static int convertLatmToY ( int latm ) { long v = Math . round ( ( Mercator . MAX_Y - Mercator . lat2y ( latm / LATLON_TO_LATLONM ) ) . MAX_AP_UNITS / ( Mercator . MAX_Y . NUM_ ) ) ; if ( v > MAX_AP_UNITS ) return MAX_AP_UNITS ; if ( v < NUM_ ) return - NUM_ ; return ( int ) v ; }
public void registerCallbackHandler ( SMSObjectListener changeListener ) throws SMSException { objectListener = changeListener ; if ( ! notificationInitialized ) { String notificationFlag = SystemProperties . get ( NOTIFICATION_PROPERTY , STR_ ) ; if ( notificationFlag . equalsIgnoreCase ( STR_ ) ) { try { URL url = WebtopNaming . getNotificationURL ( ) ; PLLClient . addNotificationHandler ( JAXRPCUtil . SMS_SERVICE , new SMSNotificationHandler ( ) ) ; client . send ( STR_ , url . toString ( ) , null , null ) ; if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + STR_ + url ) ; } } catch ( Exception e ) { if ( debug . warningEnabled ( ) ) { debug . warning ( STR_ + STR_ + e . getMessage ( ) + STR_ ) ; } startPollingThreadIfEnabled ( getCachePollingInterval ( ) ) ; } } else { startPollingThreadIfEnabled ( getCachePollingInterval ( ) ) ; } notificationInitialized = BOOL_ ; } }
public static NSObject parse ( InputStream in ) throws ParseException , IOException { byte [ ] buf = PropertyListParser . readAll ( in ) ; in . close ( ) ; return parse ( buf ) ; }
protected double currentScoreFunction ( ) { double score = NUM_ ; for ( int i = NUM_ ; i < this . values [ this . currentVar1 ] . length ; i ++ ) { for ( int j = NUM_ ; j < this . values [ this . currentVar2 ] . length ; j ++ ) { score -= this . currentCounts [ this . currentVar1 ] [ this . currentVar2 ] [ i ] [ j ] . Math . log ( this . currentPi [ i ] [ j ] ) ; } } return score ; }
public grammaticalityEstimator ( Set FileNames , int iMinChar , int iMaxChar , int iCharWindow , int iMinWord , int iMaxWord , int iWordWindow ) { iMinCharNGram = iMinChar ; iMaxCharNGram = iMaxChar ; iMinWordNGram = iMinWord ; iMaxWordNGram = iMaxWord ; iWordDist = iWordWindow ; iCharDist = iCharWindow ; DistroDocs = new TreeMap < Integer , DistributionDocument > ( ) ; DistroWordDocs = new TreeMap < Integer , DistributionWordDocument > ( ) ; StringBuffer sb = new StringBuffer ( ) ; Iterator iTexts = FileNames . iterator ( ) ; while ( iTexts . hasNext ( ) ) { String sFile = ( String ) iTexts . next ( ) ; try { BufferedReader bf = new BufferedReader ( new FileReader ( sFile ) ) ; String sTmp ; while ( ( sTmp = bf . readLine ( ) ) != null ) sb . append ( sTmp ) ; bf . close ( ) ; } catch ( FileNotFoundException ex ) { ex . printStackTrace ( System . err ) ; } catch ( IOException ex ) { ex . printStackTrace ( System . err ) ; } sb . append ( ( char ) NUM_ ) ; } FullTextDataString = sb . toString ( ) ; for ( int iCnt = iMinCharNGram ; iCnt <= iMaxCharNGram ; iCnt ++ ) { DistroDocs . put ( iCnt , new DistributionDocument ( iCharDist , iCnt ) ) ; } for ( int iCnt = iMinWordNGram ; iCnt <= iMaxWordNGram ; iCnt ++ ) { DistroWordDocs . put ( iCnt , new DistributionWordDocument ( iWordDist , iCnt ) ) ; } }
private int checkZoneLink ( SpannableStringBuilder out , String in , int start ) { int pos = start + NUM_ ; StringBuilder temp = new StringBuilder ( ) ; String targetString = in . substring ( pos , Math . min ( in . length ( ) , pos + NUM_ ) ) ; boolean prevIsDash = BOOL_ ; for ( int i = NUM_ ; i < targetString . length ( ) ; i ++ ) { char c = targetString . charAt ( i ) ; if ( ( c >= STR_ && c <= STR_ ) || ( c >= STR_ && c <= STR_ ) ) { temp . append ( c ) ; prevIsDash = BOOL_ ; } else if ( c == STR_ ) { if ( i == NUM_ ) { return - NUM_ ; } if ( prevIsDash ) { temp . deleteCharAt ( temp . length ( ) - NUM_ ) ; break ; } temp . append ( c ) ; prevIsDash = BOOL_ ; } else { if ( prevIsDash ) { temp . deleteCharAt ( temp . length ( ) - NUM_ ) ; } break ; } } String zone = temp . toString ( ) ; if ( zone . length ( ) < NUM_ || zone . equalsIgnoreCase ( STR_ ) ) { return - NUM_ ; } out . append ( zone ) ; return pos + zone . length ( ) - NUM_ ; }
public void checkNextPoissonConsistency ( double mean ) { final int sampleSize = NUM_ ; final int minExpectedCount = NUM_ ; long maxObservedValue = NUM_ ; final double alpha = NUM_ ; UnitTestUtils . Frequency < Long > frequency = new UnitTestUtils . Frequency < Long > ( ) ; for ( int i = NUM_ ; i < sampleSize ; i ++ ) { long value = randomData . nextPoisson ( mean ) ; if ( value > maxObservedValue ) { maxObservedValue = value ; } frequency . addValue ( value ) ; } PoissonDistribution poissonDistribution = new PoissonDistribution ( mean ) ; int lower = NUM_ ; while ( poissonDistribution . cumulativeProbability ( lower - NUM_ ) . sampleSize < minExpectedCount ) { lower ++ ; } int upper = ( int ) ( NUM_ . mean ) ; while ( ( NUM_ - poissonDistribution . cumulativeProbability ( upper - NUM_ ) ) . sampleSize < minExpectedCount ) { upper -- ; } int binWidth = NUM_ ; boolean widthSufficient = BOOL_ ; double lowerBinMass = NUM_ ; double upperBinMass = NUM_ ; while ( ! widthSufficient ) { binWidth ++ ; lowerBinMass = poissonDistribution . probability ( lower - NUM_ , lower + binWidth - NUM_ ) ; upperBinMass = poissonDistribution . probability ( upper - binWidth - NUM_ , upper - NUM_ ) ; widthSufficient = FastMath . min ( lowerBinMass , upperBinMass ) . sampleSize >= minExpectedCount ; } List < Integer > binBounds = new ArrayList < Integer > ( ) ; binBounds . add ( lower ) ; int bound = lower + binWidth ; while ( bound < upper - binWidth ) { binBounds . add ( bound ) ; bound += binWidth ; } binBounds . add ( upper ) ; final int binCount = binBounds . size ( ) + NUM_ ; long [ ] observed = new long [ binCount ] ; double [ ] expected = new double [ binCount ] ; observed [ NUM_ ] = NUM_ ; for ( int i = NUM_ ; i < lower ; i ++ ) { observed [ NUM_ ] += frequency . getCount ( ( long ) i ) ; } expected [ NUM_ ] = poissonDistribution . cumulativeProbability ( lower - NUM_ ) . sampleSize ; observed [ binCount - NUM_ ] = NUM_ ; for ( int i = upper ; i <= maxObservedValue ; i ++ ) { observed [ binCount - NUM_ ] += frequency . getCount ( ( long ) i ) ; } expected [ binCount - NUM_ ] = ( NUM_ - poissonDistribution . cumulativeProbability ( upper - NUM_ ) ) . sampleSize ; for ( int i = NUM_ ; i < binCount - NUM_ ; i ++ ) { observed [ i ] = NUM_ ; for ( int j = binBounds . get ( i - NUM_ ) ; j < binBounds . get ( i ) ; j ++ ) { observed [ i ] += frequency . getCount ( ( long ) j ) ; } expected [ i ] = ( poissonDistribution . cumulativeProbability ( binBounds . get ( i ) - NUM_ ) - poissonDistribution . cumulativeProbability ( binBounds . get ( i - NUM_ ) - NUM_ ) ) . sampleSize ; } if ( UnitTestUtils . chiSquareTest ( expected , observed ) < alpha ) { StringBuilder msgBuffer = new StringBuilder ( ) ; DecimalFormat df = new DecimalFormat ( STR_ ) ; msgBuffer . append ( STR_ ) ; msgBuffer . append ( mean ) ; msgBuffer . append ( STR_ ) ; msgBuffer . append ( UnitTestUtils . chiSquareTest ( expected , observed ) ) ; msgBuffer . append ( STR_ ) ; msgBuffer . append ( UnitTestUtils . chiSquare ( expected , observed ) ) ; msgBuffer . append ( STR_ ) ; msgBuffer . append ( STR_ ) ; for ( int i = NUM_ ; i < expected . length ; i ++ ) { msgBuffer . append ( STR_ ) ; msgBuffer . append ( i == NUM_ ? NUM_ : binBounds . get ( i - NUM_ ) ) ; msgBuffer . append ( STR_ ) ; msgBuffer . append ( i == binBounds . size ( ) ? STR_ : binBounds . get ( i ) ) ; msgBuffer . append ( STR_ ) ; msgBuffer . append ( STR_ ) ; msgBuffer . append ( df . format ( expected [ i ] ) ) ; msgBuffer . append ( STR_ ) ; msgBuffer . append ( observed [ i ] ) ; msgBuffer . append ( STR_ ) ; } msgBuffer . append ( STR_ ) ; msgBuffer . append ( alpha ) ; msgBuffer . append ( STR_ ) ; Assert . fail ( msgBuffer . toString ( ) ) ; } }
public static void checkValid ( double [ ] x ) { for ( double v : x ) { if ( Double . isNaN ( v ) ) { throw new RuntimeException ( STR_ + v ) ; } } }
protected void processConnectionEvent ( ConnectionEvent event ) { for ( Enumeration < ConnectionListener > e = connectionListeners . elements ( ) ; e . hasMoreElements ( ) ; ) { ConnectionListener l = e . nextElement ( ) ; switch ( event . getType ( ) ) { case ConnectionEvent . CONNECTED : l . connected ( ( ConnectedEvent ) event ) ; break ; case ConnectionEvent . DISCONNECTED : l . disconnected ( ( DisconnectedEvent ) event ) ; break ; case ConnectionEvent . PACKET_RECEIVED : l . packetReceived ( ( PacketReceivedEvent ) event ) ; break ; } } }
public double percentage ( ConstantRange range ) { SortedSet < Constant > sorted = values ( ) ; SortedSet < Constant > contained = new TreeSet < Constant > ( ) ; Constant prev = null ; for ( Constant pct : sorted ) { if ( range . contains ( pct ) ) contained . add ( pct ) ; else if ( contained . isEmpty ( ) ) prev = pct ; } if ( contained . size ( ) == NUM_ ) return NUM_ ; double prevPercent = prev == null ? NUM_ : pcts . get ( prev ) ; return pcts . get ( contained . last ( ) ) - prevPercent ; }
public static void closeQuiet ( @ Nullable Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( IOException ignored ) { } } }
@ Override public void releaseLuceePageContext ( PageContext pc , boolean register ) { if ( pc . getId ( ) < NUM_ ) return ; pc . release ( ) ; ThreadLocalPageContext . release ( ) ; runningPcs . remove ( Integer . valueOf ( pc . getId ( ) ) ) ; if ( pcs . size ( ) < NUM_ && pc . getRequestTimeoutException ( ) == null ) pcs . push ( pc ) ; }
public void addEventListener ( SIPDialogEventListener newListener ) { eventListeners . add ( newListener ) ; }
private boolean journalRebuildRequired ( ) { final int redundantOpCompactThreshold = NUM_ ; return redundantOpCount >= redundantOpCompactThreshold && redundantOpCount >= lruEntries . size ( ) ; }
private static byte [ ] stringToByteArray ( String str ) { if ( str == null ) { return null ; } byte [ ] srcByte = str . getBytes ( ) ; int srcLength = srcByte . length ; byte [ ] result = new byte [ srcLength + NUM_ ] ; System . arraycopy ( srcByte , NUM_ , result , NUM_ , srcLength ) ; result [ srcLength ] = NUM_ ; return result ; }
public static Properties loadProperties ( ClassLoader classLoader , String classpathResource ) { return loadProperties ( null , classpathResource ) ; }
@ Override public boolean equals ( Object o ) { if ( o instanceof Graph ) { return string . equals ( o . toString ( ) ) ; } return BOOL_ ; }
public final static NameValuePair parseNameValuePair ( final String value , HeaderValueParser parser ) throws ParseException { if ( value == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( parser == null ) parser = SaveHeaderValueParser . DEFAULT ; CharArrayBuffer buffer = new CharArrayBuffer ( value . length ( ) ) ; buffer . append ( value ) ; SaveParserCursor cursor = new SaveParserCursor ( NUM_ , value . length ( ) ) ; return parser . parseNameValuePair ( buffer , cursor ) ; }
private void pullEvent ( ) { final int newScrollValue ; final int itemDimension ; final float initialMotionValue , lastMotionValue ; switch ( getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : initialMotionValue = mInitialMotionX ; lastMotionValue = mLastMotionX ; break ; case VERTICAL : default : initialMotionValue = mInitialMotionY ; lastMotionValue = mLastMotionY ; break ; } switch ( mCurrentMode ) { case PULL_FROM_END : newScrollValue = Math . round ( Math . max ( initialMotionValue - lastMotionValue , NUM_ ) / FRICTION ) ; itemDimension = getFooterSize ( ) ; break ; case PULL_FROM_START : default : newScrollValue = Math . round ( Math . min ( initialMotionValue - lastMotionValue , NUM_ ) / FRICTION ) ; itemDimension = getHeaderSize ( ) ; break ; } setHeaderScroll ( newScrollValue ) ; if ( newScrollValue != NUM_ && ! isRefreshing ( ) ) { float scale = Math . abs ( newScrollValue ) / ( float ) itemDimension ; switch ( mCurrentMode ) { case PULL_FROM_END : mFooterLayout . onPull ( scale ) ; break ; case PULL_FROM_START : default : mHeaderLayout . onPull ( scale ) ; break ; } if ( mState != State . PULL_TO_REFRESH && itemDimension >= Math . abs ( newScrollValue ) ) { setState ( State . PULL_TO_REFRESH ) ; } else if ( mState == State . PULL_TO_REFRESH && itemDimension < Math . abs ( newScrollValue ) ) { setState ( State . RELEASE_TO_REFRESH ) ; } } }
private static MappingObject ObjectAt ( PCalLocation loc , MappingObject [ ] [ ] map ) { return map [ loc . getLine ( ) ] [ loc . getColumn ( ) ] ; }
public String parse ( File file , JSON m ) { try { Template template = getTemplate ( file ) ; if ( template != null ) { StringWriter w = new StringWriter ( ) ; BufferedWriter writer = new BufferedWriter ( w ) ; template . merge ( new VelocityContext ( m ) , writer ) ; writer . flush ( ) ; writer . close ( ) ; return w . toString ( ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; }
private LinkedList < Diff > diff_main ( String text1 , String text2 , boolean checklines , long deadline ) { if ( text1 == null || text2 == null ) { throw new IllegalArgumentException ( STR_ ) ; } LinkedList < Diff > diffs ; if ( text1 . equals ( text2 ) ) { diffs = new LinkedList < Diff > ( ) ; if ( text1 . length ( ) != NUM_ ) { diffs . add ( new Diff ( Operation . EQUAL , text1 ) ) ; } return diffs ; } int commonlength = diff_commonPrefix ( text1 , text2 ) ; String commonprefix = text1 . substring ( NUM_ , commonlength ) ; text1 = text1 . substring ( commonlength ) ; text2 = text2 . substring ( commonlength ) ; commonlength = diff_commonSuffix ( text1 , text2 ) ; String commonsuffix = text1 . substring ( text1 . length ( ) - commonlength ) ; text1 = text1 . substring ( NUM_ , text1 . length ( ) - commonlength ) ; text2 = text2 . substring ( NUM_ , text2 . length ( ) - commonlength ) ; diffs = diff_compute ( text1 , text2 , checklines , deadline ) ; if ( commonprefix . length ( ) != NUM_ ) { diffs . addFirst ( new Diff ( Operation . EQUAL , commonprefix ) ) ; } if ( commonsuffix . length ( ) != NUM_ ) { diffs . addLast ( new Diff ( Operation . EQUAL , commonsuffix ) ) ; } diff_cleanupMerge ( diffs ) ; return diffs ; }
public Repository ( String domain , boolean fairLock ) { lock = new ReentrantReadWriteLock ( fairLock ) ; domainTb = new HashMap < String , Map < String , NamedObject > > ( NUM_ ) ; if ( domain != null && domain . length ( ) != NUM_ ) this . domain = domain . intern ( ) ; else this . domain = ServiceName . DOMAIN ; domainTb . put ( this . domain , new HashMap < String , NamedObject > ( ) ) ; }
public int countTokens ( ) { int count = NUM_ ; boolean inToken = BOOL_ ; for ( int i = position , length = string . length ( ) ; i < length ; i ++ ) { if ( delimiters . indexOf ( string . charAt ( i ) , NUM_ ) >= NUM_ ) { if ( returnDelimiters ) count ++ ; if ( inToken ) { count ++ ; inToken = BOOL_ ; } } else { inToken = BOOL_ ; } } if ( inToken ) count ++ ; return count ; }
public static synchronized void indexDocument ( CodeIndexDocument codeIndexDocument ) throws IOException { Queue < CodeIndexDocument > queue = new ConcurrentLinkedQueue < > ( ) ; queue . add ( codeIndexDocument ) ; indexDocuments ( queue ) ; queue = null ; }
protected void resetCommon ( ) throws XNIException { int count = fCommonComponents . size ( ) ; for ( int i = NUM_ ; i < count ; i ++ ) { XMLComponent c = ( XMLComponent ) fCommonComponents . get ( i ) ; c . reset ( this ) ; } }
private void updateVolumeLabels ( Volume trustedSrc , Volume invalidTgt ) { VirtualArray invalidTgtVA = dbClient . queryObject ( VirtualArray . class , invalidTgt . getVirtualArray ( ) ) ; StringBuilder newLabel = new StringBuilder ( ) ; newLabel . append ( trustedSrc . getLabel ( ) ) ; newLabel . append ( STR_ ) ; newLabel . append ( invalidTgtVA . getLabel ( ) ) ; log . info ( STR_ + newLabel . toString ( ) ) ; invalidTgt . setLabel ( newLabel . toString ( ) ) ; NamedURI projectURI = invalidTgt . getProject ( ) ; projectURI . setName ( newLabel . toString ( ) ) ; invalidTgt . setProject ( projectURI ) ; NamedURI tenantURI = invalidTgt . getTenant ( ) ; tenantURI . setName ( newLabel . toString ( ) ) ; invalidTgt . setTenant ( tenantURI ) ; Volume tgtVplexVolume = VPlexSrdfUtil . getVplexVolumeFromSrdfVolume ( dbClient , invalidTgt ) ; if ( tgtVplexVolume != null ) { Volume srcVplexVolume = VPlexSrdfUtil . getVplexVolumeFromSrdfVolume ( dbClient , trustedSrc ) ; if ( srcVplexVolume != null ) { newLabel . setLength ( NUM_ ) ; newLabel . append ( srcVplexVolume . getLabel ( ) ) ; newLabel . append ( STR_ ) ; newLabel . append ( invalidTgtVA . getLabel ( ) ) ; log . info ( STR_ + newLabel . toString ( ) ) ; tgtVplexVolume . setLabel ( newLabel . toString ( ) ) ; projectURI = tgtVplexVolume . getProject ( ) ; projectURI . setName ( newLabel . toString ( ) ) ; tgtVplexVolume . setProject ( projectURI ) ; tenantURI = tgtVplexVolume . getTenant ( ) ; tenantURI . setName ( newLabel . toString ( ) ) ; tgtVplexVolume . setTenant ( tenantURI ) ; dbClient . updateAndReindexObject ( tgtVplexVolume ) ; } } }
protected void handle ( Exception exception , String title , String message ) { Utils . handleError ( getShell ( ) , exception , title , message ) ; }
private void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject ( ) ; i18n = Environment . getI18n ( ) ; beanContextChildSupport = new BeanContextChildSupport ( this ) ; }
private void paintForegroundEnabled ( Graphics2D g , int width , int height ) { Shape s = decodeArrowPath ( width , height ) ; g . setPaint ( enabledColor ) ; g . fill ( s ) ; }
private static void logThrow ( Level level , String className , String methodName , String message , Object [ ] args , Throwable thrown ) { java . util . logging . LogRecord lr = new java . util . logging . LogRecord ( level , message ) ; lr . setLoggerName ( logger . getName ( ) ) ; lr . setSourceClassName ( className ) ; lr . setSourceMethodName ( methodName ) ; lr . setParameters ( args ) ; lr . setThrown ( thrown ) ; logger . log ( lr ) ; }
public void testToBigIntegerZero ( ) { String a = STR_ ; BigInteger bNumber = new BigInteger ( STR_ ) ; BigDecimal aNumber = new BigDecimal ( a ) ; BigInteger result = aNumber . toBigInteger ( ) ; assertTrue ( STR_ , result . equals ( bNumber ) ) ; }
public void onAccuracyChanged ( Sensor sensor , int accuracy ) { if ( sensor . getType ( ) != Sensor . TYPE_ACCELEROMETER ) { return ; } if ( this . status == AccelListener . STOPPED ) { return ; } this . accuracy = accuracy ; }
public boolean allowsTrailingArguments ( ) { return allowsTrailingArguments ; }
@ AndroidOnly ( STR_ + STR_ ) public void testSetMaxCRLNumberLjava_math_BigInteger ( ) { X509CRLSelector selector = new X509CRLSelector ( ) ; BigInteger maxCRL = new BigInteger ( STR_ ) ; TestCRL crl = new TestCRL ( maxCRL ) ; selector . setMaxCRLNumber ( null ) ; assertTrue ( STR_ , selector . match ( crl ) ) ; selector . setMaxCRLNumber ( maxCRL ) ; assertTrue ( STR_ , selector . match ( crl ) ) ; selector . setMaxCRLNumber ( new BigInteger ( STR_ ) ) ; assertFalse ( STR_ , selector . match ( crl ) ) ; }
private void evaluatePopup ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) { JPopupMenu menu = createBookmarkPopupMenu ( ) ; if ( menu != null ) { menu . show ( this , e . getX ( ) , e . getY ( ) ) ; } } }
private boolean removeTask ( Task t , int min ) { for ( int i = tasks . size ( ) ; -- i >= min ; ) { if ( tasks . get ( i ) == t ) { tasks . remove ( i ) ; if ( i < firstPending ) { firstPending -- ; for ( int j = threads . size ( ) ; -- j >= NUM_ ; ) { TaskThread thread = threads . get ( j ) ; if ( thread . task == t ) { if ( thread != Thread . currentThread ( ) ) thread . interrupt ( ) ; break ; } } } return BOOL_ ; } } return BOOL_ ; }
public void test_DivideBigDecimalRoundingModeHALF_UP ( ) { String a = STR_ ; String b = STR_ ; RoundingMode rm = RoundingMode . HALF_UP ; String c = STR_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) ) ; BigDecimal bNumber = new BigDecimal ( new BigInteger ( b ) ) ; BigDecimal result = aNumber . divide ( bNumber , rm ) ; assertEquals ( STR_ , c , result . toString ( ) ) ; }
protected void ensurePathExists ( String path ) { String [ ] paths = path . split ( STR_ ) ; StringBuffer spath = new StringBuffer ( STR_ ) ; for ( String temp : paths ) { if ( StringUtils . isBlank ( temp ) ) { continue ; } spath . append ( temp ) ; ensureExists ( spath . toString ( ) , null , acl , CreateMode . PERSISTENT ) ; spath . append ( STR_ ) ; } }
public Class < ? > loadClass ( String name , boolean resolve ) throws ClassNotFoundException { int i = name . lastIndexOf ( STR_ ) ; if ( i != - NUM_ ) { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) { sm . checkPackageAccess ( name . substring ( NUM_ , i ) ) ; } } if ( ucp . knownToNotExist ( name ) ) { Class < ? > c = findLoadedClass ( name ) ; if ( c != null ) { if ( resolve ) { resolveClass ( c ) ; } return c ; } throw new ClassNotFoundException ( name ) ; } return ( super . loadClass ( name , resolve ) ) ; }
private int measureShort ( int measureSpec ) { int result ; int specMode = MeasureSpec . getMode ( measureSpec ) ; int specSize = MeasureSpec . getSize ( measureSpec ) ; if ( specMode == MeasureSpec . EXACTLY ) { result = specSize ; } else { result = ( int ) ( NUM_ . mRadius + getPaddingTop ( ) + getPaddingBottom ( ) + NUM_ ) ; if ( specMode == MeasureSpec . AT_MOST ) { result = Math . min ( result , specSize ) ; } } return result ; }
private boolean isListChildUnderClipped ( float x , float y ) { final View listChild = findListChildUnder ( x , y ) ; return listChild != null && isDescendantClipped ( listChild ) ; }
Rules ( Workspace workspace ) { this . root = workspace . getRoot ( ) ; this . teamHook = workspace . getTeamHook ( ) ; }
public static void writeByteArrayToFile ( File file , byte [ ] data , boolean append ) throws IOException { OutputStream out = null ; try { out = openOutputStream ( file , append ) ; out . write ( data ) ; out . close ( ) ; } finally { IOUtils . closeQuietly ( out ) ; } }
public void add ( @ NonNull T item ) { synchronized ( lock ) { if ( items == null ) { items = new ArrayList < > ( ) ; } items . add ( item ) ; } if ( notifyOnChange ) { notifyItemInserted ( items . size ( ) ) ; } }
private void checkPendingCustomMessages ( ) { if ( joiningNodes . isEmpty ( ) && isLocalNodeCoordinator ( ) ) { TcpDiscoveryCustomEventMessage msg ; while ( ( msg = pendingCustomMsgs . poll ( ) ) != null ) { processCustomMessage ( msg ) ; if ( msg . verified ( ) ) msgHist . add ( msg ) ; } } }
private static int determineConsecutiveDigitCount ( CharSequence msg , int startpos ) { int count = NUM_ ; int len = msg . length ( ) ; int idx = startpos ; if ( idx < len ) { char ch = msg . charAt ( idx ) ; while ( isDigit ( ch ) && idx < len ) { count ++ ; idx ++ ; if ( idx < len ) { ch = msg . charAt ( idx ) ; } } } return count ; }
protected int parseAndAddNode ( XmlResourceParser parser , HashMap < String , TagParser > tagParserMap , ArrayList < Long > screenIds ) throws XmlPullParserException , IOException { if ( TAG_INCLUDE . equals ( parser . getName ( ) ) ) { final int resId = getAttributeResourceValue ( parser , ATTR_WORKSPACE , NUM_ ) ; if ( resId != NUM_ ) { return parseLayout ( resId , screenIds ) ; } else { return NUM_ ; } } mValues . clear ( ) ; parseContainerAndScreen ( parser , mTemp ) ; final long container = mTemp [ NUM_ ] ; final long screenId = mTemp [ NUM_ ] ; mValues . put ( Favorites . CONTAINER , container ) ; mValues . put ( Favorites . SCREEN , screenId ) ; mValues . put ( Favorites . CELLX , convertToDistanceFromEnd ( getAttributeValue ( parser , ATTR_X ) , mColumnCount ) ) ; mValues . put ( Favorites . CELLY , convertToDistanceFromEnd ( getAttributeValue ( parser , ATTR_Y ) , mRowCount ) ) ; TagParser tagParser = tagParserMap . get ( parser . getName ( ) ) ; if ( tagParser == null ) { if ( LOGD ) Log . d ( TAG , STR_ + parser . getName ( ) ) ; return NUM_ ; } long newElementId = tagParser . parseAndAdd ( parser ) ; if ( newElementId >= NUM_ ) { if ( ! screenIds . contains ( screenId ) && container == Favorites . CONTAINER_DESKTOP ) { screenIds . add ( screenId ) ; } return NUM_ ; } return NUM_ ; }
private float calculateScrambleImageHeightMultiplier ( float multiplier ) { switch ( currentPuzzle ) { case PuzzleUtils . TYPE_777 : case PuzzleUtils . TYPE_666 : case PuzzleUtils . TYPE_555 : case PuzzleUtils . TYPE_222 : case PuzzleUtils . TYPE_444 : case PuzzleUtils . TYPE_333 : return ( multiplier / NUM_ ) . NUM_ ; case PuzzleUtils . TYPE_CLOCK : return multiplier / NUM_ ; case PuzzleUtils . TYPE_MEGA : return ( multiplier / NUM_ ) ; case PuzzleUtils . TYPE_PYRA : return ( float ) ( multiplier / Math . sqrt ( NUM_ ) ) ; case PuzzleUtils . TYPE_SKEWB : return ( multiplier / NUM_ ) . NUM_ ; case PuzzleUtils . TYPE_SQUARE1 : return multiplier ; } return multiplier ; }
public void testNumericScalars ( ) throws Exception { ObjectMapper m = new ObjectMapper ( ) ; m . enableDefaultTyping ( ) ; assertEquals ( STR_ , m . writeValueAsString ( new Object [ ] { Integer . valueOf ( NUM_ ) } ) ) ; assertEquals ( STR_ , m . writeValueAsString ( new Object [ ] { Long . valueOf ( NUM_ ) } ) ) ; assertEquals ( STR_ , m . writeValueAsString ( new Object [ ] { Double . valueOf ( NUM_ ) } ) ) ; assertEquals ( STR_ , m . writeValueAsString ( new Object [ ] { Float . valueOf ( NUM_ ) } ) ) ; }
protected void closeCallbacksExceptListener ( ) { closeCacheCallback ( getCacheLoader ( ) ) ; closeCacheCallback ( getCacheWriter ( ) ) ; closeCacheCallback ( getEvictionController ( ) ) ; }
private static int indexOf ( Object o , Object [ ] elements , int index , int fence ) { if ( o == null ) { for ( int i = index ; i < fence ; i ++ ) if ( elements [ i ] == null ) return i ; } else { for ( int i = index ; i < fence ; i ++ ) if ( o . equals ( elements [ i ] ) ) return i ; } return - NUM_ ; }
private void populateProfiles ( final ProfileList profiles ) { profilesComboBox . removeAllItems ( ) ; for ( Profile p : profiles ) { profilesComboBox . addItem ( p ) ; } final int count = profilesComboBox . getItemCount ( ) ; if ( count != NUM_ ) { profilesComboBox . setSelectedIndex ( count - NUM_ ) ; } }
private long checkFileHeader ( BufferedFileDataInput bfdi ) throws ReplicatorException , InterruptedException { int magic = NUM_ ; short major = NUM_ ; short minor = NUM_ ; try { bfdi . waitAvailable ( HEADER_LENGTH , HEADER_WAIT_MILLIS ) ; magic = bfdi . readInt ( ) ; major = bfdi . readShort ( ) ; minor = bfdi . readShort ( ) ; baseSeqno = bfdi . readLong ( ) ; } catch ( IOException e ) { throw new THLException ( STR_ + file . getAbsolutePath ( ) , e ) ; } if ( magic != MAGIC_NUMBER ) throw new THLException ( STR_ + file . getAbsolutePath ( ) + STR_ ) ; if ( major != MAJOR_VERSION ) throw new THLException ( STR_ + file . getAbsolutePath ( ) + STR_ ) ; if ( minor != MINOR_VERSION ) logger . warn ( STR_ + file . getAbsolutePath ( ) + STR_ + major + STR_ + minor + STR_ + MAJOR_VERSION + STR_ + MINOR_VERSION ) ; return baseSeqno ; }
public float realAbsolute ( ) { return Math . abs ( mLeft ) ; }
private ExtremumType extremumType ( int n , double [ ] alpha_extreme , HyperBoundingBox interval ) { if ( n == alpha_extreme . length - NUM_ ) { return extremumType ; } double [ ] alpha_extreme_l = new double [ alpha_extreme . length ] ; double [ ] alpha_extreme_r = new double [ alpha_extreme . length ] ; double [ ] alpha_extreme_c = new double [ alpha_extreme . length ] ; System . arraycopy ( alpha_extreme , NUM_ , alpha_extreme_l , NUM_ , alpha_extreme . length ) ; System . arraycopy ( alpha_extreme , NUM_ , alpha_extreme_r , NUM_ , alpha_extreme . length ) ; System . arraycopy ( alpha_extreme , NUM_ , alpha_extreme_c , NUM_ , alpha_extreme . length ) ; double [ ] centroid = SpatialUtil . centroid ( interval ) ; for ( int i = NUM_ ; i < n ; i ++ ) { alpha_extreme_l [ i ] = centroid [ i ] ; alpha_extreme_r [ i ] = centroid [ i ] ; alpha_extreme_c [ i ] = centroid [ i ] ; } double intervalLength = interval . getMax ( n ) - interval . getMin ( n ) ; alpha_extreme_l [ n ] = Math . random ( ) . intervalLength + interval . getMin ( n ) ; alpha_extreme_r [ n ] = Math . random ( ) . intervalLength + interval . getMin ( n ) ; double f_c = function ( alpha_extreme_c ) ; double f_l = function ( alpha_extreme_l ) ; double f_r = function ( alpha_extreme_r ) ; if ( f_l < f_c ) { if ( f_r < f_c || Math . abs ( f_r - f_c ) < DELTA ) { return ExtremumType . MAXIMUM ; } } if ( f_r < f_c ) { if ( f_l < f_c || Math . abs ( f_l - f_c ) < DELTA ) { return ExtremumType . MAXIMUM ; } } if ( f_l > f_c ) { if ( f_r > f_c || Math . abs ( f_r - f_c ) < DELTA ) { return ExtremumType . MINIMUM ; } } if ( f_r > f_c ) { if ( f_l > f_c || Math . abs ( f_l - f_c ) < DELTA ) { return ExtremumType . MINIMUM ; } } if ( Math . abs ( f_l - f_c ) < DELTA && Math . abs ( f_r - f_c ) < DELTA ) { return ExtremumType . CONSTANT ; } throw new IllegalArgumentException ( STR_ + this + STR_ + STR_ + f_l + STR_ + STR_ + f_c + STR_ + STR_ + f_r + STR_ + STR_ + vec . toArray ( ) + STR_ + STR_ + FormatUtil . format ( alpha_extreme_c ) + STR_ + STR_ + FormatUtil . format ( alpha_extreme_l ) + STR_ + STR_ + FormatUtil . format ( alpha_extreme_r ) + STR_ + STR_ + n ) ; }
public static String map2OID ( String algName ) { return alg2OidMap . get ( algName . toUpperCase ( Locale . US ) ) ; }
@ Override public Generator < ICircle > construct ( String [ ] args ) { return new UniformGenerator ( Double . valueOf ( args [ NUM_ ] ) ) ; }
private boolean yy_refill ( ) throws java . io . IOException { if ( yy_startRead > NUM_ ) { System . arraycopy ( yy_buffer , yy_startRead , yy_buffer , NUM_ , yy_endRead - yy_startRead ) ; yy_endRead -= yy_startRead ; yy_currentPos -= yy_startRead ; yy_markedPos -= yy_startRead ; yy_pushbackPos -= yy_startRead ; yy_startRead = NUM_ ; } if ( yy_currentPos >= yy_buffer . length ) { char newBuffer [ ] = new char [ yy_currentPos . NUM_ ] ; System . arraycopy ( yy_buffer , NUM_ , newBuffer , NUM_ , yy_buffer . length ) ; yy_buffer = newBuffer ; } int numRead = yy_reader . read ( yy_buffer , yy_endRead , yy_buffer . length - yy_endRead ) ; if ( numRead < NUM_ ) { return BOOL_ ; } else { yy_endRead += numRead ; return BOOL_ ; } }
protected void processMouseEvent ( MouseEvent e ) { if ( myInplaceComponent != null && ( MouseEvent . MOUSE_PRESSED == e . getID ( ) || MouseEvent . MOUSE_RELEASED == e . getID ( ) ) ) { finishEditing ( BOOL_ ) ; } super . processMouseEvent ( e ) ; }
protected void addModule ( Map < Class < ? extends IFloodlightService > , IFloodlightModule > moduleMap , Collection < IFloodlightModule > moduleList , IFloodlightModule module ) { Collection < Class < ? extends IFloodlightService > > servs = moduleServiceMap . get ( module ) ; if ( servs != null ) { for ( Class < ? extends IFloodlightService > c : servs ) moduleMap . put ( c , module ) ; } moduleList . add ( module ) ; }
protected boolean hasAllTables ( ) throws CouldntLoadDataException , InvalidDatabaseException { NaviLogger . info ( STR_ ) ; final int counter = PostgreSQLHelpers . getTableCount ( getConnection ( ) , Lists . newArrayList ( TABLES ) ) ; if ( counter == NUM_ ) { return BOOL_ ; } else if ( counter == TABLES . length ) { return BOOL_ ; } else { throw new InvalidDatabaseException ( String . format ( STR_ , counter , TABLES . length ) ) ; } }
public List < String > classify ( List < List < Feature > > features ) throws CleartkProcessingException { String [ ] [ ] featureStringArray = toStrings ( features ) ; Pipe pipe = transducer . getInputPipe ( ) ; Instance instance = new Instance ( featureStringArray , null , null , null ) ; instance = pipe . instanceFrom ( instance ) ; Sequence < ? > data = ( Sequence < ? > ) instance . getData ( ) ; Sequence < ? > untypedSequence = transducer . transduce ( data ) ; Sequence < String > sequence = ReflectionUtil . uncheckedCast ( untypedSequence ) ; List < String > returnValues = new ArrayList < String > ( ) ; for ( int i = NUM_ ; i < sequence . size ( ) ; i ++ ) { String encodedOutcome = sequence . get ( i ) ; returnValues . add ( outcomeEncoder . decode ( encodedOutcome ) ) ; } return returnValues ; }
public void onBindHeaderViewHolder ( RecyclerView . ViewHolder holder , int position ) { onBindHeaderViewHolder ( holder , position , Collections . emptyList ( ) ) ; }
private void updateLineList ( ) { if ( horizontalLineRadiobutton . isSelected ( ) ) { setHorizontalLineSelected ( ) ; } else { setVerticalLineSelected ( ) ; } updateButtonStates ( ) ; }
public void rectangle ( double x , double y , double halfWidth , double halfHeight ) { if ( halfWidth < NUM_ ) throw new IllegalArgumentException ( STR_ ) ; if ( halfHeight < NUM_ ) throw new IllegalArgumentException ( STR_ ) ; double xs = scaleX ( x ) ; double ys = scaleY ( y ) ; double ws = factorX ( NUM_ . halfWidth ) ; double hs = factorY ( NUM_ . halfHeight ) ; if ( ws <= NUM_ && hs <= NUM_ ) pixel ( x , y ) ; else offscreen . draw ( new Rectangle2D . Double ( xs - ws / NUM_ , ys - hs / NUM_ , ws , hs ) ) ; draw ( ) ; }
protected final void refreshLoadingViewsSize ( ) { final int maximumPullScroll = ( int ) ( getMaximumPullScroll ( ) . NUM_ ) ; int pLeft = getPaddingLeft ( ) ; int pTop = getPaddingTop ( ) ; int pRight = getPaddingRight ( ) ; int pBottom = getPaddingBottom ( ) ; switch ( getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setWidth ( maximumPullScroll ) ; pLeft = - maximumPullScroll ; } else { pLeft = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setWidth ( maximumPullScroll ) ; pRight = - maximumPullScroll ; } else { pRight = NUM_ ; } break ; case VERTICAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setHeight ( maximumPullScroll ) ; pTop = - maximumPullScroll ; } else { pTop = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setHeight ( maximumPullScroll ) ; pBottom = - maximumPullScroll ; } else { pBottom = NUM_ ; } break ; } if ( DEBUG ) { Log . d ( LOG_TAG , String . format ( STR_ , pLeft , pTop , pRight , pBottom ) ) ; } setPadding ( pLeft , pTop , pRight , pBottom ) ; }
public void replaceSplitElement ( int aIndex , Fragment aSplitElement ) { splits . set ( aIndex , aSplitElement ) ; }
private void startItemList ( StringBuilder result , String rootId ) { result . append ( STR_ + STR_ + rootId + STR_ ) ; }
private static int numInitialSplits ( long numRecords ) { final int maxSplits = NUM_ ; final long recordsPerSplit = NUM_ ; return ( int ) Math . min ( maxSplits , numRecords / recordsPerSplit + NUM_ ) ; }
public void mouseClicked ( MouseEvent e ) { if ( e . getClickCount ( ) > NUM_ ) { System . gc ( ) ; } }
private static String [ ] scanForSources ( final File sourceDir , final Set < String > sourceIncludes , final Set < String > sourceExcludes ) { final DirectoryScanner ds = new DirectoryScanner ( ) ; ds . setFollowSymlinks ( BOOL_ ) ; ds . setBasedir ( sourceDir ) ; ds . setIncludes ( sourceIncludes . toArray ( new String [ sourceIncludes . size ( ) ] ) ) ; ds . setExcludes ( sourceExcludes . toArray ( new String [ sourceExcludes . size ( ) ] ) ) ; ds . addDefaultExcludes ( ) ; try { ds . scan ( ) ; } catch ( IllegalStateException e ) { return new String [ NUM_ ] ; } return ds . getIncludedFiles ( ) ; }
private boolean hasNextPostponed ( ) { return ! postponedRoutes . isEmpty ( ) ; }
public boolean hasSingleElement ( ) { return mSelectedWidgets . size ( ) == NUM_ ; }
public IgfsPath ( URI uri ) { A . notNull ( uri , STR_ ) ; path = normalizePath ( uri . getPath ( ) ) ; }
public int toInt ( Element el , String attributeName ) { return Caster . toIntValue ( el . getAttribute ( attributeName ) , Integer . MIN_VALUE ) ; }
public static String readFully ( Reader reader ) throws IOException { try { StringWriter writer = new StringWriter ( ) ; char [ ] buffer = new char [ NUM_ ] ; int count ; while ( ( count = reader . read ( buffer ) ) != - NUM_ ) { writer . write ( buffer , NUM_ , count ) ; } return writer . toString ( ) ; } finally { reader . close ( ) ; } }
public void addGetters ( int assignedPropertyNumber , String propertyName ) { for ( EventType type : knownTypes ) { EventPropertyGetter getter = type . getGetter ( propertyName ) ; VariantPropertyGetterRow row = allGetters . get ( type ) ; if ( row == null ) { synchronized ( this ) { row = new VariantPropertyGetterRow ( type , new EventPropertyGetter [ assignedPropertyNumber + NUM_ ] ) ; allGetters . put ( type , row ) ; } } row . addGetter ( assignedPropertyNumber , getter ) ; } properties . add ( propertyName ) ; }
protected void markUsed ( Entry entry ) { entry . lastUsed = System . nanoTime ( ) ; }
@ Override public String execute ( ) { return SUCCESS ; }
private void handleStateLeft ( InetAddress endpoint , String [ ] pieces ) { assert pieces . length >= NUM_ ; Collection < Token > tokens = getTokensFor ( endpoint ) ; if ( logger . isDebugEnabled ( ) ) logger . debug ( STR_ , endpoint , tokens ) ; excise ( tokens , endpoint , extractExpireTime ( pieces ) ) ; }
public static void register ( String algorithmURI , Class < ? extends SignatureAlgorithmSpi > implementingClass ) throws AlgorithmAlreadyRegisteredException , ClassNotFoundException , XMLSignatureException { JavaUtils . checkRegisterPermission ( ) ; if ( log . isLoggable ( java . util . logging . Level . FINE ) ) { log . log ( java . util . logging . Level . FINE , STR_ + algorithmURI + STR_ + implementingClass ) ; } Class < ? extends SignatureAlgorithmSpi > registeredClass = algorithmHash . get ( algorithmURI ) ; if ( registeredClass != null ) { Object exArgs [ ] = { algorithmURI , registeredClass } ; throw new AlgorithmAlreadyRegisteredException ( STR_ , exArgs ) ; } algorithmHash . put ( algorithmURI , implementingClass ) ; }
@ SuppressWarnings ( STR_ ) public KeyValuePersistenceSettings ( File settingsFile ) { InputStream in ; try { in = new FileInputStream ( settingsFile ) ; } catch ( IOException e ) { throw new IgniteException ( STR_ + settingsFile . getAbsolutePath ( ) , e ) ; } init ( loadSettings ( in ) ) ; }
public boolean containsWordBreakingChar ( final @ NonNull CharSequence input ) { if ( ! TextUtils . isEmpty ( input ) ) { for ( int i = NUM_ ; i < input . length ( ) ; i ++ ) { char c = input . charAt ( i ) ; if ( isWordBreakingChar ( c ) ) { return BOOL_ ; } } } return BOOL_ ; }
private void checkInteriorIntersections ( ) { for ( Iterator i = segStrings . iterator ( ) ; i . hasNext ( ) ; ) { SegmentString ss0 = ( SegmentString ) i . next ( ) ; for ( Iterator j = segStrings . iterator ( ) ; j . hasNext ( ) ; ) { SegmentString ss1 = ( SegmentString ) j . next ( ) ; checkInteriorIntersections ( ss0 , ss1 ) ; } } }
public synchronized boolean removeElement ( Object object ) { int index ; if ( ( index = indexOf ( object , NUM_ ) ) == - NUM_ ) { return BOOL_ ; } removeElementAt ( index ) ; return BOOL_ ; }
private < T > UnaryOperator < T > compose ( UnaryOperator < T > before , UnaryOperator < T > after ) { return null ; }
private void addCdcColSpecs ( ArrayList < ColumnSpec > cdcSpecs , OneRowChange cdcRowChangeData ) { int cdcPos = cdcSpecs . size ( ) ; if ( cdcColumnsAtFront ) cdcPos = NUM_ ; ColumnSpec spec = cdcRowChangeData . new ColumnSpec ( ) ; spec . setIndex ( cdcPos + NUM_ ) ; spec . setName ( STR_ ) ; spec . setType ( java . sql . Types . VARCHAR ) ; spec . setLength ( NUM_ ) ; cdcSpecs . add ( cdcPos , spec ) ; spec = cdcRowChangeData . new ColumnSpec ( ) ; spec . setIndex ( cdcPos + NUM_ + NUM_ ) ; spec . setName ( STR_ ) ; spec . setType ( java . sql . Types . TIMESTAMP ) ; cdcSpecs . add ( cdcPos + NUM_ , spec ) ; spec = cdcRowChangeData . new ColumnSpec ( ) ; spec . setIndex ( cdcPos + NUM_ + NUM_ ) ; spec . setName ( STR_ ) ; spec . setType ( java . sql . Types . BIGINT ) ; cdcSpecs . add ( cdcPos + NUM_ , spec ) ; }
public static String convertToJavaFieldName ( String name ) { int dotIndex = name . indexOf ( STR_ ) ; if ( dotIndex >= NUM_ ) { name = name . substring ( NUM_ , dotIndex ) ; } String [ ] split = name . split ( STR_ ) ; StringBuilder out = new StringBuilder ( ) ; boolean first = BOOL_ ; for ( String section : split ) { if ( first ) { first = BOOL_ ; out . append ( section ) ; } else { out . append ( StringUtil . capitalize ( section ) ) ; } } return out . toString ( ) ; }
public static SecretKeys generateKey ( ) throws GeneralSecurityException { fixPrng ( ) ; KeyGenerator keyGen = KeyGenerator . getInstance ( CIPHER ) ; keyGen . init ( AES_KEY_LENGTH_BITS ) ; SecretKey confidentialityKey = keyGen . generateKey ( ) ; byte [ ] integrityKeyBytes = randomBytes ( HMAC_KEY_LENGTH_BITS / NUM_ ) ; SecretKey integrityKey = new SecretKeySpec ( integrityKeyBytes , HMAC_ALGORITHM ) ; return new SecretKeys ( confidentialityKey , integrityKey ) ; }
public static void checkArgument ( boolean expression , @ Nullable Object errorMessage ) { if ( ! expression ) { throw new IllegalArgumentException ( String . valueOf ( errorMessage ) ) ; } }
protected void execute ( String [ ] sqls , SQLiteDatabase db ) { String throwSQL = STR_ ; try { if ( sqls != null ) { for ( String sql : sqls ) { throwSQL = sql ; db . execSQL ( BaseUtility . changeCase ( sql ) ) ; } } } catch ( SQLException e ) { throw new DatabaseGenerateException ( DatabaseGenerateException . SQL_ERROR + throwSQL ) ; } }
private synchronized void rebuildJournal ( ) throws IOException { if ( journalWriter != null ) { journalWriter . close ( ) ; } Writer writer = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( journalFileTmp ) , Util . US_ASCII ) ) ; try { writer . write ( MAGIC ) ; writer . write ( STR_ ) ; writer . write ( VERSION_1 ) ; writer . write ( STR_ ) ; writer . write ( Integer . toString ( appVersion ) ) ; writer . write ( STR_ ) ; writer . write ( Integer . toString ( valueCount ) ) ; writer . write ( STR_ ) ; writer . write ( STR_ ) ; for ( Entry entry : lruEntries . values ( ) ) { if ( entry . currentEditor != null ) { writer . write ( DIRTY + STR_ + entry . key + STR_ ) ; } else { writer . write ( CLEAN + STR_ + entry . key + entry . getLengths ( ) + STR_ ) ; } } } finally { writer . close ( ) ; } if ( journalFile . exists ( ) ) { renameTo ( journalFile , journalFileBackup , BOOL_ ) ; } renameTo ( journalFileTmp , journalFile , BOOL_ ) ; journalFileBackup . delete ( ) ; journalWriter = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( journalFile , BOOL_ ) , Util . US_ASCII ) ) ; }
private void refreshDoneButton ( boolean done ) { butDone . setText ( done ? Messages . getString ( STR_ ) : Messages . getString ( STR_ ) ) ; }
private void createMigrationTaskPage ( ) { MigrationTaskEditor migrationTaskEditor = new MigrationTaskEditor ( migrationTask , getContainer ( ) ) ; int index = addPage ( migrationTaskEditor . getControl ( ) ) ; setPageText ( index , STR_ ) ; taskListeners . add ( migrationTaskEditor ) ; }
protected void onPageScrolled ( int position , float offset , int offsetPixels ) { if ( mDecorChildCount > NUM_ ) { final int scrollX = getScrollX ( ) ; int paddingLeft = getPaddingLeft ( ) ; int paddingRight = getPaddingRight ( ) ; final int width = getWidth ( ) ; final int childCount = getChildCount ( ) ; for ( int i = NUM_ ; i < childCount ; i ++ ) { final View child = getChildAt ( i ) ; final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; if ( ! lp . isDecor ) continue ; final int hgrav = lp . gravity & Gravity . HORIZONTAL_GRAVITY_MASK ; int childLeft = NUM_ ; switch ( hgrav ) { default : childLeft = paddingLeft ; break ; case Gravity . LEFT : childLeft = paddingLeft ; paddingLeft += child . getWidth ( ) ; break ; case Gravity . CENTER_HORIZONTAL : childLeft = Math . max ( ( width - child . getMeasuredWidth ( ) ) / NUM_ , paddingLeft ) ; break ; case Gravity . RIGHT : childLeft = width - paddingRight - child . getMeasuredWidth ( ) ; paddingRight += child . getMeasuredWidth ( ) ; break ; } childLeft += scrollX ; final int childOffset = childLeft - child . getLeft ( ) ; if ( childOffset != NUM_ ) { child . offsetLeftAndRight ( childOffset ) ; } } } if ( mOnPageChangeListener != null ) { mOnPageChangeListener . onPageScrolled ( position , offset , offsetPixels ) ; } if ( mInternalPageChangeListener != null ) { mInternalPageChangeListener . onPageScrolled ( position , offset , offsetPixels ) ; } if ( mPageTransformer != null ) { final int scrollX = getScrollX ( ) ; final int childCount = getChildCount ( ) ; for ( int i = NUM_ ; i < childCount ; i ++ ) { final View child = getChildAt ( i ) ; final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; if ( lp . isDecor ) continue ; final float transformPos = ( float ) ( child . getLeft ( ) - scrollX ) / getClientWidth ( ) ; mPageTransformer . transformPage ( child , transformPos ) ; } } mCalledSuper = BOOL_ ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
private void expand ( int i ) { if ( count + i <= buf . length ) { return ; } byte [ ] newbuf = mPool . getBuf ( ( count + i ) . NUM_ ) ; System . arraycopy ( buf , NUM_ , newbuf , NUM_ , count ) ; mPool . returnBuf ( buf ) ; buf = newbuf ; }
public static int toIPv4Address ( String ipAddress ) { if ( ipAddress == null ) throw new IllegalArgumentException ( STR_ + STR_ ) ; String [ ] octets = ipAddress . split ( STR_ ) ; if ( octets . length != NUM_ ) throw new IllegalArgumentException ( STR_ + STR_ ) ; int result = NUM_ ; for ( int i = NUM_ ; i < NUM_ ; ++ i ) { int oct = Integer . valueOf ( octets [ i ] ) ; if ( oct > NUM_ || oct < NUM_ ) throw new IllegalArgumentException ( STR_ + STR_ ) ; result |= oct << ( ( NUM_ - i ) . NUM_ ) ; } return result ; }
public void closeCursor ( Cursor cursor ) { cursor . close ( ) ; cursorMap . remove ( Integer . valueOf ( cursor . getCursorId ( ) ) ) ; }
private boolean hasNext ( Pattern pattern ) { if ( ! hasNext ( ) ) { return BOOL_ ; } Matcher matcher = pattern . matcher ( gserValue . substring ( pos , length ) ) ; return matcher . find ( ) ; }
void pushInt ( int i ) { switch ( i ) { case - NUM_ : mv . visitInsn ( ICONST_M1 ) ; return ; case NUM_ : mv . visitInsn ( ICONST_0 ) ; return ; case NUM_ : mv . visitInsn ( ICONST_1 ) ; return ; case NUM_ : mv . visitInsn ( ICONST_2 ) ; return ; case NUM_ : mv . visitInsn ( ICONST_3 ) ; return ; case NUM_ : mv . visitInsn ( ICONST_4 ) ; return ; case NUM_ : mv . visitInsn ( ICONST_5 ) ; return ; } if ( i >= Byte . MIN_VALUE && i <= Byte . MAX_VALUE ) { mv . visitIntInsn ( BIPUSH , i ) ; return ; } if ( i >= Short . MIN_VALUE && i <= Short . MAX_VALUE ) { mv . visitIntInsn ( SIPUSH , i ) ; return ; } mv . visitLdcInsn ( Integer . valueOf ( i ) ) ; }
public static String xmlNode ( String name , String attributes , String content , boolean indent ) { String start = attributes == null ? name : name + attributes ; if ( content == null ) { return STR_ + start + STR_ ; } if ( indent && content . indexOf ( STR_ ) >= NUM_ ) { content = STR_ + indent ( content ) ; } return STR_ + start + STR_ + content + STR_ + name + STR_ ; }
public void add ( int position , @ NonNull T item ) { synchronized ( lock ) { if ( items == null ) { items = new ArrayList < > ( ) ; } items . add ( position , item ) ; } if ( notifyOnChange ) { notifyItemInserted ( position ) ; } }
void notifyFailure ( Throwable exception ) { synchronized ( waitObject ) { isComplete = BOOL_ ; if ( exception instanceof MqttException ) { pendingException = ( MqttException ) exception ; } else { pendingException = new MqttException ( exception ) ; } waitObject . notifyAll ( ) ; if ( exception instanceof MqttException ) { lastException = ( MqttException ) exception ; } if ( listener != null ) { listener . onFailure ( this , exception ) ; } } }
public static void transform ( StreamSource src , StreamSource stylesheet , Fop fop ) throws FOPException { Result res = new SAXResult ( fop . getDefaultHandler ( ) ) ; try { TransformerFactory factory = TransformerFactory . newInstance ( ) ; Transformer transformer ; if ( stylesheet == null ) { transformer = factory . newTransformer ( ) ; } else { transformer = factory . newTransformer ( stylesheet ) ; } transformer . setURIResolver ( new LocalResolver ( transformer . getURIResolver ( ) ) ) ; transformer . transform ( src , res ) ; } catch ( Exception e ) { throw new FOPException ( e ) ; } }
public List < String > splitStringWithDefaultDelimiterEscaped ( String inputString ) { String delimiter = configurationHelper . getProperty ( ConfigurationValue . FIELD_DATA_DELIMITER ) ; String escapeChar = configurationHelper . getProperty ( ConfigurationValue . FIELD_DATA_DELIMITER_ESCAPE_CHAR ) ; List < String > splitString = new ArrayList < > ( ) ; if ( StringUtils . isNotBlank ( inputString ) ) { String regex = STR_ + Pattern . quote ( escapeChar ) + STR_ + Pattern . quote ( delimiter ) ; for ( String s : inputString . split ( regex ) ) { splitString . add ( s . replace ( escapeChar + delimiter , delimiter ) ) ; } } return splitString ; }
protected final boolean readAvailableBlocking ( ) throws IOException { char [ ] buffer = myBuffer ; StringBuilder token = myTextBuffer ; token . setLength ( NUM_ ) ; boolean read = BOOL_ ; int n ; while ( ( n = myReader . read ( buffer ) ) > NUM_ ) { if ( myScheduledSubmitter != null ) myScheduledSubmitter . cancel ( BOOL_ ) ; read = BOOL_ ; synchronized ( myTextBuffer ) { processLine ( buffer , token , n ) ; } myScheduledSubmitter = myExecutorService . submit ( myTokenSubmitter ) ; } submitToken ( ) ; return read ; }
public void deleteObligation ( final Obligation obligation , int basicBlockId ) throws ObligationAcquiredOrReleasedInLoopException { Map < ObligationSet , State > updatedStateMap = new HashMap < ObligationSet , State > ( ) ; for ( Iterator < State > i = stateIterator ( ) ; i . hasNext ( ) ; ) { State state = i . next ( ) ; checkCircularity ( state , obligation , basicBlockId ) ; ObligationSet obligationSet = state . getObligationSet ( ) ; obligationSet . remove ( obligation ) ; if ( ! obligationSet . isEmpty ( ) ) { updatedStateMap . put ( obligationSet , state ) ; } } replaceMap ( updatedStateMap ) ; }
private void clipViewOnTheRight ( Rect curViewBound , float curViewWidth , int right ) { curViewBound . right = ( int ) ( right - mClipPadding ) ; curViewBound . left = ( int ) ( curViewBound . right - curViewWidth ) ; }
public ContentImpl createCompoundPackageContent ( OleBlobImpl blob , String prettyName , String className , String typeName , ByteBuffer blobBb , int dataBlockLen ) { return new CompoundContentImpl ( blob , prettyName , className , typeName , blobBb . position ( ) , dataBlockLen ) ; }
protected boolean checkCoverage ( ) { int i ; int n ; int [ ] count ; Range r ; String attrIndex ; SubspaceClusterDefinition cl ; count = new int [ getNumAttributes ( ) ] ; for ( i = NUM_ ; i < getNumAttributes ( ) ; i ++ ) { for ( n = NUM_ ; n < getClusters ( ) . length ; n ++ ) { cl = ( SubspaceClusterDefinition ) getClusters ( ) [ n ] ; r = new Range ( cl . getAttrIndexRange ( ) ) ; r . setUpper ( getNumAttributes ( ) ) ; if ( r . isInRange ( i ) ) { count [ i ] ++ ; } } } attrIndex = STR_ ; for ( i = NUM_ ; i < count . length ; i ++ ) { if ( count [ i ] == NUM_ ) { if ( attrIndex . length ( ) != NUM_ ) { attrIndex += STR_ ; } attrIndex += ( i + NUM_ ) ; } } if ( attrIndex . length ( ) != NUM_ ) { throw new IllegalArgumentException ( STR_ + STR_ + attrIndex + STR_ ) ; } return BOOL_ ; }
private Set < Integer > findValues ( String string ) { Set < Integer > results = new TreeSet < Integer > ( ) ; for ( String str : string . split ( STR_ ) ) { if ( ! str . equals ( STR_ ) ) { results . add ( findValue ( str ) ) ; } } return results ; }
private static int indexOf ( Object [ ] array , int len , Object elt ) { for ( int i = NUM_ ; i < len ; i ++ ) { if ( elt . equals ( array [ i ] ) ) return i ; } return - NUM_ ; }
@ Deprecated public void append ( final String name , final String value ) { List < String > l = map . get ( name ) ; if ( l != null ) { l . add ( value ) ; } else { l = Lists . newArrayList ( value ) ; map . put ( name , l ) ; } }
public boolean equals ( Object obj ) { if ( obj == this ) { return BOOL_ ; } if ( ! ( obj instanceof Certificate ) ) { return BOOL_ ; } Certificate object = ( Certificate ) obj ; try { return Arrays . equals ( getEncoded ( ) , object . getEncoded ( ) ) ; } catch ( CertificateEncodingException e ) { return BOOL_ ; } }
public Statement between ( Object former , Object later ) { statement . append ( STR_ ) ; append ( former ) ; statement . append ( STR_ ) ; append ( later ) ; return this ; }
public byte [ ] encode1 ( final String s ) { final ByteArrayBuffer tmp = new ByteArrayBuffer ( s . length ( ) ) ; final int nwritten = uc . encode ( s , tmp ) ; final int npack = LongPacker . getByteLength ( nwritten ) ; final byte [ ] a = new byte [ npack + nwritten ] ; final DataOutputBuffer dob = new DataOutputBuffer ( NUM_ , a ) ; try { dob . packLong ( nwritten ) ; dob . append ( tmp . array ( ) , NUM_ , tmp . pos ( ) ) ; return a ; } finally { try { dob . close ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
public static Map < Object , Long > valueHistogram ( GeoTimeSerie gts ) { Map < Object , Long > occurrences = new HashMap < Object , Long > ( ) ; for ( int i = NUM_ ; i < gts . values ; i ++ ) { Object value = GTSHelper . valueAtIndex ( gts , i ) ; if ( ! occurrences . containsKey ( value ) ) { occurrences . put ( value , NUM_ ) ; } else { occurrences . put ( value , NUM_ + occurrences . get ( value ) ) ; } } if ( GTSHelper . isBucketized ( gts ) && gts . bucketcount != gts . values ) { occurrences . put ( null , ( long ) ( gts . bucketcount - gts . values ) ) ; } return occurrences ; }
private void updateExistingRow ( final SQLiteDatabase database , final long id , boolean bumpCount ) { String stringId = String . valueOf ( id ) ; database . beginTransaction ( ) ; final Cursor cursor = database . query ( SongPlayCountColumns . NAME , null , WHERE_ID_EQUALS , new String [ ] { stringId } , null , null , null ) ; if ( cursor != null && cursor . moveToFirst ( ) ) { int lastUpdatedIndex = cursor . getColumnIndex ( SongPlayCountColumns . LAST_UPDATED_WEEK_INDEX ) ; int lastUpdatedWeek = cursor . getInt ( lastUpdatedIndex ) ; int weekDiff = mNumberOfWeeksSinceEpoch - lastUpdatedWeek ; if ( Math . abs ( weekDiff ) >= NUM_WEEKS ) { deleteEntry ( database , stringId ) ; if ( bumpCount ) { createNewPlayedEntry ( database , id ) ; } } else if ( weekDiff != NUM_ ) { int [ ] playCounts = new int [ NUM_WEEKS ] ; if ( weekDiff > NUM_ ) { for ( int i = NUM_ ; i < NUM_WEEKS - weekDiff ; i ++ ) { playCounts [ i + weekDiff ] = cursor . getInt ( getColumnIndexForWeek ( i ) ) ; } } else if ( weekDiff < NUM_ ) { for ( int i = NUM_ ; i < NUM_WEEKS + weekDiff ; i ++ ) { playCounts [ i ] = cursor . getInt ( getColumnIndexForWeek ( i - weekDiff ) ) ; } } if ( bumpCount ) { playCounts [ NUM_ ] ++ ; } float score = calculateScore ( playCounts ) ; if ( score < NUM_ ) { deleteEntry ( database , stringId ) ; } else { ContentValues values = new ContentValues ( NUM_WEEKS + NUM_ ) ; values . put ( SongPlayCountColumns . LAST_UPDATED_WEEK_INDEX , mNumberOfWeeksSinceEpoch ) ; values . put ( SongPlayCountColumns . PLAYCOUNTSCORE , score ) ; for ( int i = NUM_ ; i < NUM_WEEKS ; i ++ ) { values . put ( getColumnNameForWeek ( i ) , playCounts [ i ] ) ; } database . update ( SongPlayCountColumns . NAME , values , WHERE_ID_EQUALS , new String [ ] { stringId } ) ; } } else if ( bumpCount ) { ContentValues values = new ContentValues ( NUM_ ) ; int scoreIndex = cursor . getColumnIndex ( SongPlayCountColumns . PLAYCOUNTSCORE ) ; float score = cursor . getFloat ( scoreIndex ) + getScoreMultiplierForWeek ( NUM_ ) ; values . put ( SongPlayCountColumns . PLAYCOUNTSCORE , score ) ; values . put ( getColumnNameForWeek ( NUM_ ) , cursor . getInt ( getColumnIndexForWeek ( NUM_ ) ) + NUM_ ) ; database . update ( SongPlayCountColumns . NAME , values , WHERE_ID_EQUALS , new String [ ] { stringId } ) ; } cursor . close ( ) ; } else if ( bumpCount ) { createNewPlayedEntry ( database , id ) ; } database . setTransactionSuccessful ( ) ; database . endTransaction ( ) ; }
private void computeWeights ( Node node ) { int wsum = NUM_ ; for ( Node child : node . children ) { computeWeights ( child ) ; wsum += child . weight ; } node . weight = Math . max ( NUM_ , wsum ) ; }
public Searcher ( ) throws IOException { searcher = new IndexSearcher ( DirectoryReader . open ( FSDirectory . open ( Paths . get ( INDEX_DIR ) ) ) ) ; parser = new QueryParser ( CONTENT_FIELD , new StandardAnalyzer ( ) ) ; }
public QueryStringQueryBuilder field ( String field ) { if ( fields == null ) { fields = new ArrayList < > ( ) ; } fields . add ( field ) ; return this ; }
public static < R , A , B > CompletionStage < R > combine ( CompletionStage < A > a , CompletionStage < B > b , BiFunction < A , B , R > function ) { return a . thenCombine ( b , function ) ; }
protected String buildCreateSchemaStatement ( ) throws ReplicatorException { return null ; }
public void testNegPosFirstShorter ( ) { byte aBytes [ ] = { - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { - NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ } ; int aSign = - NUM_ ; int bSign = NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . and ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public StreamInfoManager ( TwitchApi api , StreamInfoListener listener ) { this . listener = listener ; this . api = api ; pendingRequests = new HashMap < > ( ) ; invalidStreamInfo = new StreamInfo ( STR_ , listener ) ; invalidStreamInfo . setRequested ( ) ; }
public Sentence asSentence ( ) { return Sentence . newConjunction ( sentences ) ; }
public boolean isPronoun ( ) { return typeString . contains ( SUFFIX_PRONOUN ) ; }
protected void appendShortType ( StringBuilder sb , FieldType fieldType , int fieldWidth ) { sb . append ( STR_ ) ; }
public static Vector tokenizeString ( String source , String separator ) { if ( separator . length ( ) == NUM_ ) { return tokenizeString ( source , separator . charAt ( NUM_ ) ) ; } Vector tokenized = new Vector ( ) ; int len = source . length ( ) ; StringBuilder buf = new StringBuilder ( ) ; for ( int iter = NUM_ ; iter < len ; iter ++ ) { char current = source . charAt ( iter ) ; if ( separator . indexOf ( current ) > - NUM_ ) { if ( buf . length ( ) > NUM_ ) { tokenized . addElement ( buf . toString ( ) ) ; buf = new StringBuilder ( ) ; } } else { buf . append ( current ) ; } } if ( buf . length ( ) > NUM_ ) { tokenized . addElement ( buf . toString ( ) ) ; } return tokenized ; }
private void backupFavorites ( BackupDataOutput data ) throws IOException { ContentResolver cr = mContext . getContentResolver ( ) ; Cursor cursor = cr . query ( Favorites . CONTENT_URI , FAVORITE_PROJECTION , getUserSelectionArg ( ) , null , null ) ; try { cursor . moveToPosition ( - NUM_ ) ; while ( cursor . moveToNext ( ) ) { final long id = cursor . getLong ( ID_INDEX ) ; final long updateTime = cursor . getLong ( ID_MODIFIED ) ; Key key = getKey ( Key . FAVORITE , id ) ; mKeys . add ( key ) ; final String backupKey = keyToBackupKey ( key ) ; if ( ! mExistingKeys . contains ( backupKey ) || updateTime >= mLastBackupRestoreTime ) { writeRowToBackup ( key , packFavorite ( cursor ) , data ) ; } else { if ( DEBUG ) Log . d ( TAG , STR_ + id ) ; } } } finally { cursor . close ( ) ; } }
public void update ( ) { if ( lastTime != - NUM_ ) { long delta = System . nanoTime ( ) - lastTime ; rollingAverage . addValue ( delta ) ; } lastTime = System . nanoTime ( ) ; }
public List < ValidationErrorMessage > validate ( ) { errorMessageIds . clear ( ) ; if ( paymentProduct == null ) { throw new NullPointerException ( STR_ ) ; } for ( PaymentProductField field : paymentProduct . getPaymentProductFields ( ) ) { if ( ! isFieldInAccountOnFileAndNotAltered ( field ) ) { errorMessageIds . addAll ( field . validateValue ( getValue ( field . getId ( ) ) ) ) ; } } return errorMessageIds ; }
CryptoResult ( final T result , final List < K > masterKeys , final CiphertextHeaders headers ) { result_ = result ; masterKeys_ = Collections . unmodifiableList ( masterKeys ) ; headers_ = headers ; encryptionContext_ = headers_ . getEncryptionContextMap ( ) ; }
public void stateChanged ( ChangeEvent e ) { if ( ignoreUpdate ) { return ; } double value = ( double ) ( NUM_ - setpointSlider . getValue ( ) ) / NUM_ ; setSetPoint ( value ) ; sim . setSetPoint ( value ) ; }
public static String [ ] parseDelimitedList ( String list , char delimiter ) { String delim = STR_ + delimiter ; StringTokenizer st = new StringTokenizer ( list + delim + STR_ , delim , BOOL_ ) ; ArrayList < String > v = new ArrayList < String > ( ) ; String lastToken = STR_ ; String word = STR_ ; while ( st . hasMoreTokens ( ) ) { String tok = st . nextToken ( ) ; if ( lastToken != null ) { if ( tok . equals ( delim ) ) { word = word + lastToken ; if ( lastToken . equals ( delim ) ) tok = null ; } else { if ( ! word . equals ( STR_ ) ) v . add ( word ) ; word = STR_ ; } } lastToken = tok ; } return v . toArray ( new String [ NUM_ ] ) ; }
private void initializeLayout ( ) { GridLayout gl = new GridLayout ( NUM_ , NUM_ ) ; gl . setVgap ( NUM_ ) ; setLayout ( gl ) ; add ( new JLabel ( STR_ ) ) ; add ( frozenDD ) ; add ( new JLabel ( STR_ ) ) ; add ( tfUpBound ) ; add ( new JLabel ( STR_ ) ) ; add ( tfLowBound ) ; add ( new JLabel ( STR_ ) ) ; add ( tfIncrement ) ; add ( new JLabel ( STR_ ) ) ; add ( tfDelay ) ; setBorder ( BorderFactory . createEmptyBorder ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; }
@ Override public boolean isRunning ( ) { return ( frame != null && frame . isVisible ( ) ) ; }
public static MosaicDefinition createMosaicDefinition ( final Account creator ) { return createMosaicDefinition ( creator , Utils . createMosaicId ( STR_ , STR_ ) , createMosaicProperties ( ) ) ; }
public Result result ( SqlNode node , Collection < Clause > clauses , RelNode rel ) { final String alias2 = SqlValidatorUtil . getAlias ( node , - NUM_ ) ; final String alias3 = alias2 != null ? alias2 : STR_ ; final String alias4 = SqlValidatorUtil . uniquify ( alias3 , aliasSet , SqlValidatorUtil . EXPR_SUGGESTER ) ; final String alias5 = alias2 == null || ! alias2 . equals ( alias4 ) ? alias4 : null ; return new Result ( node , clauses , alias5 , Collections . singletonList ( Pair . of ( alias4 , rel . getRowType ( ) ) ) ) ; }
private static void _trustAllHttpsCertificates ( ) { SSLContext context ; if ( _trustManagers == null ) { _trustManagers = new TrustManager [ ] { new FakeX509TrustManager ( ) } ; } try { context = SSLContext . getInstance ( STR_ ) ; context . init ( null , _trustManagers , new SecureRandom ( ) ) ; } catch ( GeneralSecurityException gse ) { throw new IllegalStateException ( gse . getMessage ( ) ) ; } HttpsURLConnection . setDefaultSSLSocketFactory ( context . getSocketFactory ( ) ) ; }
private static boolean isInNeedOfForm ( UIComponent component ) { return ( component instanceof ActionSource || component instanceof ActionSource2 || component instanceof EditableValueHolder ) ; }
private void addInternalListeners ( ) { cbDistribution . addItemListener ( cbItemListener ) ; }
public static double safeSqrt ( double x ) { return ( x < NUM_ ? - Math . sqrt ( - x ) : Math . sqrt ( x ) ) ; }
public static long runMultiThreaded ( Iterable < Callable < ? > > calls , GridTestSafeThreadFactory threadFactory ) throws Exception { if ( ! busyLock . enterBusy ( ) ) throw new IllegalStateException ( STR_ ) ; Collection < Thread > threads = new ArrayList < > ( ) ; long time ; try { for ( Callable < ? > call : calls ) threads . add ( threadFactory . newThread ( call ) ) ; time = System . currentTimeMillis ( ) ; for ( Thread t : threads ) t . start ( ) ; } finally { busyLock . leaveBusy ( ) ; } for ( Thread t : threads ) t . join ( ) ; time = System . currentTimeMillis ( ) - time ; threadFactory . checkError ( ) ; return time ; }
private void bappend ( char ch ) { try { mBuff [ ++ mBuffIdx ] = ch ; } catch ( Exception exp ) { char buff [ ] = new char [ mBuff . length << NUM_ ] ; System . arraycopy ( mBuff , NUM_ , buff , NUM_ , mBuff . length ) ; mBuff = buff ; mBuff [ mBuffIdx ] = ch ; } }
public void initializeOwnerReferencesForField ( StateManager sm , FieldMetaData fmd ) { if ( fmd . getAssociationType ( ) == FieldMetaData . ONE_TO_MANY ) { Collection < ? > collection = ( Collection < ? > ) sm . fetch ( fmd . getIndex ( ) ) ; if ( collection != null ) { for ( Object item : collection ) { if ( item != null ) { _relationsManager . setOwnerStateManagerForPersistentInstance ( item , sm , fmd ) ; } } } } else if ( fmd . getAssociationType ( ) == FieldMetaData . ONE_TO_ONE || fmd . isEmbeddedPC ( ) ) { Object value = sm . fetch ( fmd . getIndex ( ) ) ; if ( value != null ) { _relationsManager . setOwnerStateManagerForPersistentInstance ( value , sm , fmd ) ; } } }
public String buildUnionSubQuery ( String typeDiscriminatorColumn , String [ ] unionColumns , Set < String > columnsPresentInTable , int computedColumnsOffset , String typeDiscriminatorValue , String selection , String groupBy , String having ) { int unionColumnsCount = unionColumns . length ; String [ ] projectionIn = new String [ unionColumnsCount ] ; for ( int i = NUM_ ; i < unionColumnsCount ; i ++ ) { String unionColumn = unionColumns [ i ] ; if ( unionColumn . equals ( typeDiscriminatorColumn ) ) { projectionIn [ i ] = STR_ + typeDiscriminatorValue + STR_ + typeDiscriminatorColumn ; } else if ( i <= computedColumnsOffset || columnsPresentInTable . contains ( unionColumn ) ) { projectionIn [ i ] = unionColumn ; } else { projectionIn [ i ] = STR_ + unionColumn ; } } return buildQuery ( projectionIn , selection , groupBy , having , null , null ) ; }
public Node ( Coordinate pt ) { this ( pt , new DirectedEdgeStar ( ) ) ; }
public synchronized void increase ( ) { if ( accuracy > NUM_ ) { long timePassed = System . currentTimeMillis ( ) - lastAdded ; if ( timePassed > accuracy ) { clearUp ( ) ; if ( count > NUM_ ) { data . addFirst ( lastAdded + accuracy ) ; } lastAdded = System . currentTimeMillis ( ) ; count = NUM_ ; } count ++ ; } else { clearUp ( ) ; data . addFirst ( System . currentTimeMillis ( ) ) ; } }
public void revert ( final VirtualFile root , final List < FilePath > files ) throws VcsException { for ( List < String > paths : VcsFileUtil . chunkPaths ( root , files ) ) { GitSimpleHandler handler = new GitSimpleHandler ( myProject , root , GitCommand . CHECKOUT ) ; handler . addParameters ( STR_ ) ; handler . endOptions ( ) ; handler . addParameters ( paths ) ; handler . run ( ) ; } }
public static float [ ] concatAllFloat ( float [ ] ... arrays ) { int totalLength = NUM_ ; final int subArrayCount = arrays . length ; for ( int i = NUM_ ; i < subArrayCount ; ++ i ) { totalLength += arrays [ i ] . length ; } float [ ] result = Arrays . copyOf ( arrays [ NUM_ ] , totalLength ) ; int offset = arrays [ NUM_ ] . length ; for ( int i = NUM_ ; i < subArrayCount ; ++ i ) { System . arraycopy ( arrays [ i ] , NUM_ , result , offset , arrays [ i ] . length ) ; offset += arrays [ i ] . length ; } return result ; }
public TaggedValueIterator ( final String aLine , final boolean attemptFirstWord , final String ... tags ) { this . aLine = aLine ; this . attemptFirstWord = attemptFirstWord ; this . tags = tags ; tagPos = NUM_ ; nextResult = getNextResult ( ) ; if ( attemptFirstWord ) { int a = NUM_ ; while ( a < aLine . length ( ) ) { if ( aLine . charAt ( a ) == STR_ || aLine . charAt ( a ) == STR_ || Character . isWhitespace ( aLine . charAt ( a ) ) ) a ++ ; else break ; } int b = a + NUM_ ; while ( b < aLine . length ( ) ) { if ( Character . isLetterOrDigit ( aLine . charAt ( b ) ) || aLine . charAt ( b ) == STR_ ) b ++ ; else break ; } if ( b - a > NUM_ ) { nextResult = aLine . substring ( a , b ) ; } tagPos = b ; } }
public void ascendTree ( ) { if ( null != parentPath ) { parentPath . append ( PARENT_PATH ) ; return ; } File parentTree = calcParentTree ( ) ; if ( null != parentTree ) { treeFile = parentTree ; return ; } parentPath = new StringBuilder ( provideLastName ( ) ) ; parentPath . append ( PARENT_PATH ) ; }
public boolean canRead ( ) { return _is != null ; }
void writeTo ( byte [ ] b , int off ) { System . arraycopy ( buf , NUM_ , b , off , count ) ; }
void onItemDismissed ( final int position ) { final T removed = mData . get ( position ) ; final boolean wasRemoved = remove ( position ) ; if ( wasRemoved && mDataChangeListener != null ) { mDataChangeListener . onItemRemoved ( removed , position ) ; } }
public static Object [ ] sortCopy ( Object [ ] objects , Comparer comparer ) { int len = objects . length ; Object [ ] copy = new Object [ len ] ; System . arraycopy ( objects , NUM_ , copy , NUM_ , len ) ; sort ( copy , comparer ) ; return copy ; }
public synchronized void addZoomListener ( ZoomListener listener ) { mZoomListeners . add ( listener ) ; }
private void clearRegisters ( Instruction start , Instruction end ) { for ( Instruction p = start ; ; p = p . nextInstructionInCodeOrder ( ) ) { for ( Enumeration < Operand > ops = p . getOperands ( ) ; ops . hasMoreElements ( ) ; ) { Operand op = ops . nextElement ( ) ; if ( op instanceof RegisterOperand ) { RegisterOperand rOp = ( RegisterOperand ) op ; clearDepGraphNodeForRegister ( rOp . getRegister ( ) ) ; } } if ( p == end ) break ; } for ( Enumeration < Register > e = GenericPhysicalDefUse . enumerateAllImplicitDefUses ( ir ) ; e . hasMoreElements ( ) ; ) { Register r = e . nextElement ( ) ; clearDepGraphNodeForRegister ( r ) ; } }
public void fireAnnotationSelected ( WorkflowAnnotation anno ) { List < WorkflowAnnotation > list = new LinkedList < > ( ) ; list . add ( anno ) ; fireAnnotationsChanged ( AnnotationEvent . SELECTED_ANNOTATION_CHANGED , list ) ; }
public boolean updateStatsAndReturnIfAllowed ( ) { long now = SystemClock . elapsedRealtime ( ) ; long deltaMs = now - mLastRequestTimestamp ; if ( deltaMs < mDelayMs ) return BOOL_ ; mLastRequestTimestamp = now ; if ( deltaMs < NUM_ . mDelayMs ) { mDelayMs = Math . min ( MAX_DELAY , mDelayMs . NUM_ ) ; } else { mDelayMs = MIN_DELAY ; } return BOOL_ ; }
public boolean verifyServerEvidenceMessage ( BigInteger serverM2 ) throws CryptoException { if ( ( this . A == null ) || ( this . M1 == null ) || ( this . S == null ) ) { throw new CryptoException ( STR_ + STR_ ) ; } BigInteger computedM2 = SRP6Util . calculateM2 ( digest , N , A , M1 , S ) ; if ( computedM2 . equals ( serverM2 ) ) { this . M2 = serverM2 ; return BOOL_ ; } return BOOL_ ; }
public void handleText ( String text ) { if ( skippingCharacters > NUM_ ) { if ( skippingCharacters >= text . length ( ) ) { skippingCharacters -= text . length ( ) ; return ; } else { text = text . substring ( skippingCharacters ) ; skippingCharacters = NUM_ ; } } if ( rtfDestination != null ) { rtfDestination . handleText ( text ) ; return ; } warning ( STR_ ) ; }
public final boolean remove ( final URI serviceURI ) { boolean modified = BOOL_ ; synchronized ( this ) { if ( aliases . remove ( serviceURI ) != null ) { modified = BOOL_ ; } final ServiceFactory factory = services . remove ( serviceURI ) ; if ( factory != null ) { modified = BOOL_ ; if ( factory instanceof CustomServiceFactory ) { customServices . remove ( factory ) ; } } } return modified ; }
@ Nullable private static String referenceToAttribute ( String attrib , boolean includeDummies ) { while ( attrib . startsWith ( STR_ ) ) { attrib = attrib . substring ( NUM_ ) ; } if ( attrib . startsWith ( STR_ ) ) { if ( includeDummies ) { attrib = attrib . substring ( NUM_ ) ; } else return null ; } if ( ! StringUtil . startsWithChar ( attrib , STR_ ) ) { return null ; } attrib = attrib . substring ( NUM_ ) ; if ( StringUtil . startsWithChar ( attrib , STR_ ) ) { String cleanAttribute = null ; for ( int i = NUM_ ; i < attrib . length ( ) ; i ++ ) { char currChar = attrib . charAt ( i ) ; if ( currChar == STR_ || currChar == STR_ ) { cleanAttribute = null ; break ; } else if ( currChar == STR_ ) { cleanAttribute = attrib . substring ( NUM_ , i ) ; break ; } } attrib = cleanAttribute ; } else { for ( int i = NUM_ ; i < attrib . length ( ) ; i ++ ) { char currChar = attrib . charAt ( i ) ; if ( currChar == STR_ || currChar == STR_ || currChar == STR_ ) { attrib = attrib . substring ( NUM_ , i ) ; break ; } } } return attrib ; }
public EscapedWriter ( Writer fos ) { super ( fos ) ; }
public boolean isExpired ( final Date date ) { if ( date == null ) { throw new IllegalArgumentException ( STR_ ) ; } return ( cookieExpiryDate != null && cookieExpiryDate . getTime ( ) <= date . getTime ( ) ) ; }
public void record ( RecordBuilderImpl recordBuilder ) { storeBitmap ( recordBuilder ) ; OutputStream viewHierarchyDump = null ; try { viewHierarchyDump = mAlbum . openViewHierarchyFile ( recordBuilder . getName ( ) ) ; mViewHierarchy . deflate ( recordBuilder . getView ( ) , viewHierarchyDump ) ; mAlbum . addRecord ( recordBuilder ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } finally { if ( viewHierarchyDump != null ) { try { viewHierarchyDump . close ( ) ; } catch ( IOException e ) { Log . e ( STR_ , STR_ , e ) ; } } } }
protected boolean isCorrectMethod ( Method method , Object [ ] args ) { return ( proxySignature . equals ( method . getName ( ) ) && args . length == NUM_ ) ; }
public void testCase17 ( ) { byte aBytes [ ] = { - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int bSign = NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . remainder ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public Metadata . Property . Builder clear ( ) { Metadata_Property_Builder _defaults = new Metadata . Property . Builder ( ) ; type = _defaults . type ; boxedType = _defaults . boxedType ; name = _defaults . name ; capitalizedName = _defaults . capitalizedName ; allCapsName = _defaults . allCapsName ; getterName = _defaults . getterName ; codeGenerator = _defaults . codeGenerator ; fullyCheckedCast = _defaults . fullyCheckedCast ; accessorAnnotations . clear ( ) ; _unsetProperties . clear ( ) ; _unsetProperties . addAll ( _defaults . _unsetProperties ) ; return ( Metadata . Property . Builder ) this ; }
public static float r_distance ( vec3 a , vec3 b ) { float x = a . m [ NUM_ ] - b . m [ NUM_ ] ; float y = a . m [ NUM_ ] - b . m [ NUM_ ] ; float z = a . m [ NUM_ ] - b . m [ NUM_ ] ; float result = ( float ) Math . sqrt ( x . x + y . y + z . z ) ; return result ; }
public void checkBackupInfo ( final File backupInfoFile , boolean backupInMultiVdc ) { try ( InputStream fis = new FileInputStream ( backupInfoFile ) ) { Properties properties = new Properties ( ) ; properties . load ( fis ) ; checkVersion ( properties ) ; checkHosts ( properties , backupInMultiVdc ) ; } catch ( IOException ex ) { log . warn ( STR_ , ex ) ; } }
static String toLowerCase ( String s ) { int len = s . length ( ) ; StringBuilder sb = null ; for ( int i = NUM_ ; i < len ; i ++ ) { char c = s . charAt ( i ) ; if ( ( c >= STR_ && c <= STR_ ) || ( c == STR_ ) ) { if ( sb != null ) sb . append ( c ) ; } else if ( ( c >= STR_ && c <= STR_ ) || ( c == STR_ ) ) { if ( sb != null ) sb . append ( c ) ; } else if ( c >= STR_ && c <= STR_ ) { if ( sb == null ) { sb = new StringBuilder ( len ) ; sb . append ( s , NUM_ , i ) ; } sb . append ( ( char ) ( c - CASE_DIFF ) ) ; } else { throw new IllegalArgumentException ( STR_ ) ; } } return sb == null ? s : sb . toString ( ) ; }
public void testConstructorSignBytesNegative3 ( ) { byte aBytes [ ] = { - NUM_ , NUM_ , NUM_ } ; int aSign = - NUM_ ; byte rBytes [ ] = { - NUM_ , NUM_ , - NUM_ , - NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , - NUM_ , aNumber . signum ( ) ) ; }
public static byte [ ] buildOpusComment ( String comment ) { byte [ ] data = new byte [ NUM_ + comment . length ( ) ] ; writeOpusComment ( data , NUM_ , comment ) ; return data ; }
public static void assertProps ( UniformPair < EventBean > received , String [ ] propertyNames , Object [ ] expectedInsert , Object [ ] expectedRemoved ) { assertProps ( received . getFirst ( ) , propertyNames , expectedInsert ) ; assertProps ( received . getSecond ( ) , propertyNames , expectedRemoved ) ; }
public int size ( ) { return al . size ( ) ; }
public static String toUpperCase ( String src ) { if ( src == null ) { return null ; } else { return src . toUpperCase ( ) ; } }
public final Iterator < KnowledgeEdge > requiredEdgesIterator ( ) { Set < KnowledgeEdge > edges = new HashSet < > ( ) ; for ( OrderedPair < Set < MyNode > > o : requiredRulesSpecs ) { final Set < MyNode > first = o . getFirst ( ) ; for ( MyNode s1 : first ) { final Set < MyNode > second = o . getSecond ( ) ; for ( MyNode s2 : second ) { if ( ! s1 . equals ( s2 ) ) { edges . add ( new KnowledgeEdge ( s1 . getName ( ) , s2 . getName ( ) ) ) ; } } } } return edges . iterator ( ) ; }
@ Deprecated public void unlock ( LockState < T > lockState ) { if ( lockState == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( lockState . setLock != this ) { throw new IllegalArgumentException ( STR_ ) ; } if ( lockState . thread != Thread . currentThread ( ) ) { throw new IllegalArgumentException ( STR_ ) ; } threadSet . remove ( Thread . currentThread ( ) ) ; for ( ReentrantLock lock : lockState . locks ) { lock . unlock ( ) ; } }
public static String formatJavaDocBox ( String text ) { requireNonNull ( text ) ; return formatTextBox ( text , JAVA_DOC_WIDTH , JAVADOC_WORDS , JAVA_DOC_SINGLE_LINE_WORDS ) ; }
private static String forceNumberStringToTwoDigits ( String text ) { while ( text . length ( ) < NUM_ ) { text = STR_ + text ; } if ( text . length ( ) > NUM_ ) { text = text . substring ( text . length ( ) - NUM_ , text . length ( ) ) ; } return text ; }
public void addDropItem ( final String name , final double probability , final int min , final int max ) { dropsItems . add ( new DropItem ( name , probability , min , max ) ) ; }
public static < E extends Identifiable > List < E > findByPrimaryKeys ( EntityManager em , List < BigInteger > ids , Class < E > type ) { requireArgument ( em != null , STR_ ) ; requireArgument ( ids != null && ! ids . isEmpty ( ) , STR_ ) ; requireArgument ( type != null , STR_ ) ; TypedQuery < E > query = em . createNamedQuery ( STR_ , type ) ; query . setHint ( STR_ , STR_ ) ; try { query . setParameter ( STR_ , ids ) ; query . setParameter ( STR_ , BOOL_ ) ; return query . getResultList ( ) ; } catch ( NoResultException ex ) { return new ArrayList < > ( NUM_ ) ; } }
private void loadWorkflow ( Properties ctx , int AD_Workflow_ID , HttpSession sess ) { MWorkflow wf = new MWorkflow ( ctx , AD_Workflow_ID , null ) ; MWFNode [ ] nodes = wf . getNodes ( BOOL_ , Env . getContextAsInt ( ctx , STR_ ) ) ; MWFNode wfn = null ; ArrayList nodes_ID = new ArrayList ( ) ; for ( int i = NUM_ ; i < nodes . length ; i ++ ) { wfn = nodes [ i ] ; nodes_ID . add ( new Integer ( wfn . getAD_WF_Node_ID ( ) ) ) ; } int imageMap [ ] [ ] = generateImageMap ( nodes_ID ) ; sess . setAttribute ( WORKFLOW , wf ) ; sess . setAttribute ( NODES , nodes ) ; sess . setAttribute ( NODES_ID , nodes_ID ) ; sess . setAttribute ( IMAGE_MAP , imageMap ) ; sess . setAttribute ( ACTIVE_NODE , new Integer ( - NUM_ ) ) ; }
public int hashCode ( ) { int h = hash ; if ( h == - NUM_ ) { try { h = Arrays . hashCode ( X509CertImpl . getEncodedInternal ( this ) ) ; } catch ( CertificateException e ) { h = NUM_ ; } hash = h ; } return h ; }
public void removeFromTags ( String removeTag ) { tags . remove ( removeTag ) ; firePropertyChange ( TAG , null , removeTag ) ; firePropertyChange ( TAGS_AS_STRING , null , removeTag ) ; }
public static boolean verify ( byte [ ] data , byte [ ] signature , byte [ ] pub ) { Preconditions . checkArgument ( data . length == NUM_ && signature . length <= NUM_ && pub . length <= NUM_ ) ; ByteBuffer byteBuff = nativeECDSABuffer . get ( ) ; if ( byteBuff == null ) { byteBuff = ByteBuffer . allocateDirect ( NUM_ + NUM_ + NUM_ + NUM_ ) ; byteBuff . order ( ByteOrder . nativeOrder ( ) ) ; nativeECDSABuffer . set ( byteBuff ) ; } byteBuff . rewind ( ) ; byteBuff . put ( data ) ; byteBuff . putInt ( signature . length ) ; byteBuff . putInt ( pub . length ) ; byteBuff . put ( signature ) ; byteBuff . put ( pub ) ; return secp256k1_ecdsa_verify ( byteBuff ) == NUM_ ; }
protected void deleteDirectory ( File webAppFile ) { if ( webAppFile . isDirectory ( ) ) { File [ ] children = webAppFile . listFiles ( ) ; for ( File element : children ) { deleteDirectory ( element ) ; } webAppFile . delete ( ) ; } else { webAppFile . delete ( ) ; } }
@ SuppressWarnings ( STR_ ) static public void assertSameIteratorAnyOrder ( final Object [ ] expected , final Iterator actual ) { assertSameIteratorAnyOrder ( STR_ , expected , actual ) ; }
public static String formattingFinishedPercentage ( final RolloutGroup rolloutGroup , final float finishedPercentage ) { float tmpFinishedPercentage = NUM_ ; switch ( rolloutGroup . getStatus ( ) ) { case READY : case SCHEDULED : case ERROR : tmpFinishedPercentage = NUM_ ; break ; case FINISHED : tmpFinishedPercentage = NUM_ ; break ; case RUNNING : tmpFinishedPercentage = finishedPercentage ; break ; default : break ; } return String . format ( STR_ , tmpFinishedPercentage ) ; }
public static String generateHostName ( String vmName , String hostId ) { String hostname = vmName + STR_ + hostId ; Preconditions . checkState ( hostname . equals ( hostname . toLowerCase ( ) ) , STR_ ) ; return hostname ; }
protected void transferFromFile ( File idFile ) throws IOException { try ( BufferedReader br = new BufferedReader ( new FileReader ( idFile ) ) ) { String line ; while ( ( line = br . readLine ( ) ) != null ) { line = line . trim ( ) ; if ( line . length ( ) > NUM_ ) { transfer ( line ) ; } } } }
private static String unwrap ( String expression ) { if ( expression . startsWith ( STR_ ) ) { expression = expression . substring ( expression . indexOf ( STR_ ) + NUM_ , expression . length ( ) - NUM_ ) ; if ( expression . endsWith ( STR_ ) ) { expression = expression . substring ( NUM_ , expression . lastIndexOf ( STR_ ) ) ; } else { expression = expression . substring ( NUM_ , expression . lastIndexOf ( STR_ ) ) ; } } return expression ; }
public boolean areAllSegmentPresent ( int datasetSize ) { return mPieSegmentList . size ( ) == datasetSize ; }
protected int drawNextEventTimeDiff ( ) { int timeDiff = msgInterval [ NUM_ ] == msgInterval [ NUM_ ] ? NUM_ : rng . nextInt ( msgInterval [ NUM_ ] - msgInterval [ NUM_ ] ) ; return msgInterval [ NUM_ ] + timeDiff ; }
private int createLines ( String text , int insertPosition , int offset ) { int count = NUM_ ; int start = NUM_ ; DelimiterInfo delimiterInfo = nextDelimiterInfo ( text , NUM_ ) ; while ( delimiterInfo != null && delimiterInfo . delimiterIndex > - NUM_ ) { int index = delimiterInfo . delimiterIndex + ( delimiterInfo . delimiterLength - NUM_ ) ; if ( insertPosition + count >= fLines . size ( ) ) fLines . add ( new Line ( offset + start , offset + index , delimiterInfo . delimiter ) ) ; else fLines . add ( insertPosition + count , new Line ( offset + start , offset + index , delimiterInfo . delimiter ) ) ; ++ count ; start = index + NUM_ ; delimiterInfo = nextDelimiterInfo ( text , start ) ; } if ( start < text . length ( ) ) { if ( insertPosition + count < fLines . size ( ) ) { Line l = ( Line ) fLines . get ( insertPosition + count ) ; int delta = text . length ( ) - start ; l . offset -= delta ; l . length += delta ; } else { fLines . add ( new Line ( offset + start , offset + text . length ( ) - NUM_ , null ) ) ; ++ count ; } } return count ; }
public static double sqrt ( double x ) { return Math . sqrt ( x ) ; }
private ResultPointsAndTransitions transitionsBetween ( ResultPoint from , ResultPoint to ) { int fromX = ( int ) from . getX ( ) ; int fromY = ( int ) from . getY ( ) ; int toX = ( int ) to . getX ( ) ; int toY = ( int ) to . getY ( ) ; boolean steep = Math . abs ( toY - fromY ) > Math . abs ( toX - fromX ) ; if ( steep ) { int temp = fromX ; fromX = fromY ; fromY = temp ; temp = toX ; toX = toY ; toY = temp ; } int dx = Math . abs ( toX - fromX ) ; int dy = Math . abs ( toY - fromY ) ; int error = - dx > > NUM_ ; int ystep = fromY < toY ? NUM_ : - NUM_ ; int xstep = fromX < toX ? NUM_ : - NUM_ ; int transitions = NUM_ ; boolean inBlack = image . get ( steep ? fromY : fromX , steep ? fromX : fromY ) ; for ( int x = fromX , y = fromY ; x != toX ; x += xstep ) { boolean isBlack = image . get ( steep ? y : x , steep ? x : y ) ; if ( isBlack != inBlack ) { transitions ++ ; inBlack = isBlack ; } error += dy ; if ( error > NUM_ ) { if ( y == toY ) { break ; } y += ystep ; error -= dx ; } } return new ResultPointsAndTransitions ( from , to , transitions ) ; }
public static String toBits ( final long x ) { final StringBuilder sb = new StringBuilder ( ) ; long t = x ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { if ( ( i & NUM_ ) == NUM_ && i > NUM_ ) { sb . append ( STR_ ) ; } sb . append ( t < NUM_ ? STR_ : STR_ ) ; t = t << NUM_ ; } assert t == NUM_ ; return sb . toString ( ) ; }
public static final byte [ ] encodeUrl ( BitSet urlsafe , byte [ ] bytes ) { if ( bytes == null ) { return null ; } if ( urlsafe == null ) { urlsafe = WWW_FORM_URL ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = NUM_ ; i < bytes . length ; i ++ ) { int b = bytes [ i ] ; if ( b < NUM_ ) { b = NUM_ + b ; } if ( urlsafe . get ( b ) ) { if ( b == STR_ ) { b = STR_ ; } buffer . write ( b ) ; } else { buffer . write ( STR_ ) ; char hex1 = Character . toUpperCase ( Character . forDigit ( ( b > > NUM_ ) & xF , NUM_ ) ) ; char hex2 = Character . toUpperCase ( Character . forDigit ( b & xF , NUM_ ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; } } return buffer . toByteArray ( ) ; }
public MessageTokenizer ( IDiscordClient client , String content ) { if ( content == null ) throw new IllegalArgumentException ( STR_ ) ; if ( content . length ( ) == NUM_ ) throw new IllegalArgumentException ( STR_ ) ; if ( client == null ) throw new IllegalArgumentException ( STR_ ) ; this . content = content ; this . client = client ; stepForward ( NUM_ ) ; }
public void await ( int ID ) throws InterruptedException { if ( parties == NUM_ ) return ; final boolean startCondition = competitionCondition ; int competingFor = ( locks . length . NUM_ - NUM_ - ID ) / NUM_ ; while ( competingFor >= NUM_ ) { final Lock node = locks [ competingFor ] ; if ( node . tryLock ( ) ) { synchronized ( node ) { while ( competitionCondition == startCondition ) node . wait ( ) ; } node . unlock ( ) ; wakeUpTarget ( competingFor . NUM_ + NUM_ ) ; wakeUpTarget ( competingFor . NUM_ + NUM_ ) ; return ; } else { if ( competingFor == NUM_ ) break ; competingFor = ( competingFor - NUM_ ) / NUM_ ; } } competitionCondition = ! competitionCondition ; wakeUpTarget ( NUM_ ) ; }
private void loadTranslationsCacheIfEmpty ( ) { if ( translationCache . isEmpty ( ) ) { for ( ObjectTranslation translation : translations ) { if ( translation . getLocale ( ) != null && translation . getProperty ( ) != null && ! StringUtils . isEmpty ( translation . getValue ( ) ) ) { String key = ObjectTranslation . getCacheKey ( translation . getLocale ( ) , translation . getProperty ( ) ) ; translationCache . put ( key , translation . getValue ( ) ) ; } } } }
public NavMouseMode ( boolean shouldConsumeEvents ) { super ( modeID , shouldConsumeEvents ) ; setModeCursor ( Cursor . getPredefinedCursor ( Cursor . CROSSHAIR_CURSOR ) ) ; rectAttributes . setLinePaint ( Color . GRAY ) ; rectAttributes . setMattingPaint ( Color . LIGHT_GRAY ) ; rectAttributes . setMatted ( BOOL_ ) ; }
public void addEvent ( SimEvent newEvent ) { newEvent . setSerial ( serial ++ ) ; sortedSet . add ( newEvent ) ; }
public static void stopTimer ( String name ) { long stopTime = System . nanoTime ( ) ; Long startTime = openTimers . remove ( name ) ; if ( startTime == null ) { throw new IllegalArgumentException ( STR_ ) ; } SummaryStatistics statistics = data . get ( name ) ; if ( statistics == null ) { statistics = new SummaryStatistics ( ) ; data . put ( name , statistics ) ; } statistics . addValue ( stopTime - startTime ) ; }
public String toStringSummary ( ) { int resultsetLength ; String result ; String titles ; int i ; int j ; if ( m_NonSigWins == null ) return STR_ ; resultsetLength = NUM_ + Math . max ( ( int ) ( Math . log ( getColCount ( ) ) / Math . log ( NUM_ ) ) , ( int ) ( Math . log ( getRowCount ( ) ) / Math . log ( NUM_ ) ) ) ; result = STR_ ; titles = STR_ ; result += STR_ ; result += STR_ + STR_ ; result += STR_ ; result += STR_ ; for ( i = NUM_ ; i < getColCount ( ) ; i ++ ) { if ( getColHidden ( i ) ) continue ; titles += STR_ ; result += STR_ ; titles += STR_ + Utils . padLeft ( STR_ + getSummaryTitle ( i ) , resultsetLength . NUM_ + NUM_ ) ; } result += STR_ ; result += titles + STR_ ; for ( i = NUM_ ; i < getColCount ( ) ; i ++ ) { if ( getColHidden ( i ) ) continue ; for ( j = NUM_ ; j < getColCount ( ) ; j ++ ) { if ( getColHidden ( j ) ) continue ; if ( j == NUM_ ) result += ( char ) ( ( int ) STR_ + i % NUM_ ) ; if ( j == i ) result += STR_ ; else result += STR_ + m_NonSigWins [ i ] [ j ] + STR_ + m_Wins [ i ] [ j ] + STR_ ; } result += STR_ ; } result += STR_ ; return result ; }
public static File createTempPath ( String path ) throws IOException { String sep = File . separator ; File tempDir = new File ( System . getProperty ( STR_ ) + sep + path ) ; if ( ! tempDir . exists ( ) ) if ( ! tempDir . mkdirs ( ) ) { boolean status = tempDir . delete ( ) ; throw new IOException ( STR_ + tempDir + STR_ + status ) ; } tempDir . deleteOnExit ( ) ; return tempDir ; }
public void hspan ( double start , double end , Paint color , String legend ) { LegendText legendText = new LegendText ( color , legend ) ; comments . add ( legendText ) ; plotElements . add ( new HSpan ( start , end , color , legendText ) ) ; }
public StateInteractive extent_to_whole_connections ( ) { Set < BrdItem > selected_items = new TreeSet < BrdItem > ( ) ; for ( BrdItem curr_item : items_list ) { if ( curr_item instanceof BrdConnectable ) { selected_items . addAll ( curr_item . get_connection_items ( ) ) ; } } if ( selected_items . isEmpty ( ) ) { return return_state ; } items_list = selected_items ; actlog_start_scope ( LogfileScope . EXTEND_TO_WHOLE_CONNECTIONS ) ; filter ( ) ; i_brd . repaint ( ) ; return this ; }
public static IKeyBuilder newInstance ( int capacity , CollatorEnum collatorChoice , Locale locale , Object strength , DecompositionEnum mode ) { if ( collatorChoice == CollatorEnum . ASCII ) { return new KeyBuilder ( capacity ) ; } if ( locale == null ) { locale = Locale . getDefault ( ) ; if ( log . isInfoEnabled ( ) ) log . info ( STR_ + locale . getDisplayName ( ) ) ; } final boolean icu = collatorChoice == CollatorEnum . ICU ; if ( icu && ! DefaultKeyBuilderFactory . isICUAvailable ( ) ) { throw new UnsupportedOperationException ( DefaultKeyBuilderFactory . ICU_NOT_AVAILABLE ) ; } final byte [ ] buf = createBuffer ( capacity ) ; final int len = NUM_ ; switch ( collatorChoice ) { case ICU : return new KeyBuilder ( new ICUSortKeyGenerator ( locale , strength , mode ) , len , buf ) ; case JDK : return new KeyBuilder ( new JDKSortKeyGenerator ( locale , strength , mode ) , len , buf ) ; default : throw new UnsupportedOperationException ( STR_ + collatorChoice ) ; } }
private List < Node > possibleParents ( Node x , List < Node > nodes , IKnowledge knowledge ) { List < Node > possibleParents = new LinkedList < > ( ) ; String _x = x . getName ( ) ; for ( Node z : nodes ) { String _z = z . getName ( ) ; if ( possibleParentOf ( _z , _x , knowledge ) ) { possibleParents . add ( z ) ; } } return possibleParents ; }
protected void configureFromProperties ( InputStream is , String rootDirectory ) throws IOException { Properties props = new Properties ( ) ; props . load ( is ) ; props . put ( ROOT_DIR_PATH_PROPERTY , rootDirectory ) ; String oldPrefix = getPropertyPrefix ( ) ; setProperties ( null , props ) ; setPropertyPrefix ( oldPrefix ) ; }
Connection openNewConnection ( ) throws SQLException { Connection newConn = DriverManager . getConnection ( url , user , password ) ; if ( url . startsWith ( STR_ ) ) { try ( Statement s = newConn . createStatement ( ) ) { } } else if ( url . startsWith ( STR_ ) ) { try ( Statement s = newConn . createStatement ( ) ) { s . execute ( STR_ ) ; } } return newConn ; }
@ Override public void addRelations ( Task task , Iterable < ObjectId > projectIds , String fieldName ) { List < Project > newProjectList = new LinkedList < > ( ) ; Iterable < Project > projectsToAdd = projectRepository . findAll ( projectIds , null ) ; for ( Project project : projectsToAdd ) { newProjectList . add ( project ) ; } try { if ( PropertyUtils . getProperty ( task , fieldName ) != null ) { Iterable < Project > projects = ( Iterable < Project > ) PropertyUtils . getProperty ( task , fieldName ) ; for ( Project project : projects ) { newProjectList . add ( project ) ; } } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } try { PropertyUtils . setProperty ( task , fieldName , newProjectList ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } taskRepository . save ( task ) ; }
protected void doFloodBDDP ( long pinSwitch , OFPacketIn pi , FloodlightContext cntx ) { TopologyInstance ti = getCurrentInstance ( BOOL_ ) ; Set < Long > switches = ti . getSwitchesInOpenflowDomain ( pinSwitch ) ; if ( switches == null ) { switches = new HashSet < Long > ( ) ; switches . add ( pinSwitch ) ; } for ( long sid : switches ) { IOFSwitch sw = floodlightProvider . getSwitch ( sid ) ; if ( sw == null ) continue ; Collection < Short > enabledPorts = sw . getEnabledPortNumbers ( ) ; if ( enabledPorts == null ) continue ; Set < Short > ports = new HashSet < Short > ( ) ; ports . addAll ( enabledPorts ) ; Set < Short > portsKnownToTopo = ti . getPortsWithLinks ( sid ) ; if ( portsKnownToTopo != null ) { for ( short p : portsKnownToTopo ) { NodePortTuple npt = new NodePortTuple ( sid , p ) ; if ( ti . isBroadcastDomainPort ( npt ) == BOOL_ ) { ports . remove ( p ) ; } } } Set < Short > portsToEliminate = getPortsToEliminateForBDDP ( sid ) ; if ( portsToEliminate != null ) { ports . removeAll ( portsToEliminate ) ; } if ( pinSwitch == sid ) { ports . remove ( pi . getInPort ( ) ) ; } doMultiActionPacketOut ( pi . getPacketData ( ) , sw , ports , cntx ) ; } }
public void sleepMillis ( final long millis ) { try { Thread . sleep ( millis ) ; } catch ( final InterruptedException e ) { logger . error ( e , e ) ; } }
private static void verifyWriteSetNotFound ( final BTree btree ) { log . info ( STR_ ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { if ( btree . contains ( i ) ) { throw new RuntimeException ( STR_ + i ) ; } } }
private double calculateEntropy ( double ... masses ) { double res = NUM_ ; for ( double d : masses ) { res -= ( d == NUM_ ) ? NUM_ : d . Math . log ( d ) ; } return res / LOG2 ; }
public static boolean isValidNmtoken ( String nmtoken ) { if ( nmtoken . length ( ) == NUM_ ) return BOOL_ ; for ( int i = NUM_ ; i < nmtoken . length ( ) ; i ++ ) { char ch = nmtoken . charAt ( i ) ; if ( ! isName ( ch ) ) { return BOOL_ ; } } return BOOL_ ; }
@ Override public void mousePressed ( MouseEvent e ) { m_frameLimiter . setRepeats ( BOOL_ ) ; if ( ( e . getModifiers ( ) & InputEvent . BUTTON1_MASK ) != NUM_ && ! e . isAltDown ( ) && m_mouseState == NUM_ && m_scaling == NUM_ ) { if ( ( ( e . getModifiers ( ) & InputEvent . CTRL_MASK ) != NUM_ ) && ( ( e . getModifiers ( ) & InputEvent . SHIFT_MASK ) == NUM_ ) ) { m_mouseState = NUM_ ; } else if ( ( ( e . getModifiers ( ) & InputEvent . SHIFT_MASK ) != NUM_ ) && ( ( e . getModifiers ( ) & InputEvent . CTRL_MASK ) == NUM_ ) ) { m_oldMousePos . width = e . getX ( ) ; m_oldMousePos . height = e . getY ( ) ; m_newMousePos . width = e . getX ( ) ; m_newMousePos . height = e . getY ( ) ; m_mouseState = NUM_ ; Graphics g = getGraphics ( ) ; if ( m_ZoomBoxColor == null ) { g . setColor ( Color . black ) ; } else { g . setColor ( m_ZoomBoxColor ) ; } if ( m_ZoomBoxXORColor == null ) { g . setXORMode ( Color . white ) ; } else { g . setXORMode ( m_ZoomBoxXORColor ) ; } g . drawRect ( m_oldMousePos . width , m_oldMousePos . height , m_newMousePos . width - m_oldMousePos . width , m_newMousePos . height - m_oldMousePos . height ) ; g . dispose ( ) ; } else { m_oldMousePos . width = e . getX ( ) ; m_oldMousePos . height = e . getY ( ) ; m_newMousePos . width = e . getX ( ) ; m_newMousePos . height = e . getY ( ) ; m_mouseState = NUM_ ; m_frameLimiter . start ( ) ; } } else if ( ( e . getButton ( ) == MouseEvent . BUTTON1 ) && e . isAltDown ( ) && e . isShiftDown ( ) && ! e . isControlDown ( ) ) { saveComponent ( ) ; } else if ( m_mouseState == NUM_ && m_scaling == NUM_ ) { } }
private static double parseDoubleValue ( String parseString , String openTag , String closeTag , DataTypeValidationException exception ) throws DataTypeValidationException { String tagValue ; tagValue = parseStringValue ( parseString , openTag , closeTag , exception ) ; double doubleValue ; try { doubleValue = Double . parseDouble ( tagValue ) ; } catch ( NumberFormatException e ) { throw e ; } return doubleValue ; }
public void putString ( String s ) throws ArrayIndexOutOfBoundsException , UnsupportedEncodingException { byte [ ] bytes = s . getBytes ( STR_ ) ; int length = bytes . length ; int endAt = m_index + length + NUM_ ; if ( endAt > m_content . length ) throw new ArrayIndexOutOfBoundsException ( endAt + STR_ + m_content . length ) ; System . arraycopy ( bytes , NUM_ , m_content , m_index , length ) ; m_index += length ; m_content [ m_index ++ ] = STR_ ; debugAppendString ( s ) ; }
private void pullEvent ( ) { final int newScrollValue ; final int itemDimension ; final float initialMotionValue , lastMotionValue ; switch ( getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : initialMotionValue = mInitialMotionX ; lastMotionValue = mLastMotionX ; break ; case VERTICAL : default : initialMotionValue = mInitialMotionY ; lastMotionValue = mLastMotionY ; break ; } switch ( mCurrentMode ) { case PULL_FROM_END : newScrollValue = Math . round ( Math . max ( initialMotionValue - lastMotionValue , NUM_ ) / FRICTION ) ; itemDimension = getFooterSize ( ) ; break ; case PULL_FROM_START : default : newScrollValue = Math . round ( Math . min ( initialMotionValue - lastMotionValue , NUM_ ) / FRICTION ) ; itemDimension = getHeaderSize ( ) ; break ; } setHeaderScroll ( newScrollValue ) ; if ( newScrollValue != NUM_ && ! isRefreshing ( ) ) { float scale = Math . abs ( newScrollValue ) / ( float ) itemDimension ; switch ( mCurrentMode ) { case PULL_FROM_END : mFooterLayout . onPull ( scale ) ; break ; case PULL_FROM_START : default : mHeaderLayout . onPull ( scale ) ; break ; } if ( mState != State . PULL_TO_REFRESH && itemDimension >= Math . abs ( newScrollValue ) ) { setState ( State . PULL_TO_REFRESH ) ; } else if ( mState == State . PULL_TO_REFRESH && itemDimension < Math . abs ( newScrollValue ) ) { setState ( State . RELEASE_TO_REFRESH ) ; } } }
public void addRtcpListener ( RtcpEventListener listener ) { listeners . addElement ( listener ) ; }
@ Override protected void ensureNumberOfColumns ( int numberOfColumns ) { if ( data . length >= numberOfColumns ) { return ; } double [ ] newData = new double [ numberOfColumns ] ; System . arraycopy ( data , NUM_ , newData , NUM_ , data . length ) ; data = newData ; }
private static BitMatrix extractPureBits ( BitMatrix image ) throws NotFoundException { int [ ] leftTopBlack = image . getTopLeftOnBit ( ) ; int [ ] rightBottomBlack = image . getBottomRightOnBit ( ) ; if ( leftTopBlack == null || rightBottomBlack == null ) { throw NotFoundException . getNotFoundInstance ( ) ; } float moduleSize = moduleSize ( leftTopBlack , image ) ; int top = leftTopBlack [ NUM_ ] ; int bottom = rightBottomBlack [ NUM_ ] ; int left = leftTopBlack [ NUM_ ] ; int right = rightBottomBlack [ NUM_ ] ; if ( left >= right || top >= bottom ) { throw NotFoundException . getNotFoundInstance ( ) ; } if ( bottom - top != right - left ) { right = left + ( bottom - top ) ; } int matrixWidth = Math . round ( ( right - left + NUM_ ) / moduleSize ) ; int matrixHeight = Math . round ( ( bottom - top + NUM_ ) / moduleSize ) ; if ( matrixWidth <= NUM_ || matrixHeight <= NUM_ ) { throw NotFoundException . getNotFoundInstance ( ) ; } if ( matrixHeight != matrixWidth ) { throw NotFoundException . getNotFoundInstance ( ) ; } int nudge = ( int ) ( moduleSize / NUM_ ) ; top += nudge ; left += nudge ; int nudgedTooFarRight = left + ( int ) ( ( matrixWidth - NUM_ ) . moduleSize ) - right ; if ( nudgedTooFarRight > NUM_ ) { if ( nudgedTooFarRight > nudge ) { throw NotFoundException . getNotFoundInstance ( ) ; } left -= nudgedTooFarRight ; } int nudgedTooFarDown = top + ( int ) ( ( matrixHeight - NUM_ ) . moduleSize ) - bottom ; if ( nudgedTooFarDown > NUM_ ) { if ( nudgedTooFarDown > nudge ) { throw NotFoundException . getNotFoundInstance ( ) ; } top -= nudgedTooFarDown ; } BitMatrix bits = new BitMatrix ( matrixWidth , matrixHeight ) ; for ( int y = NUM_ ; y < matrixHeight ; y ++ ) { int iOffset = top + ( int ) ( y . moduleSize ) ; for ( int x = NUM_ ; x < matrixWidth ; x ++ ) { if ( image . get ( left + ( int ) ( x . moduleSize ) , iOffset ) ) { bits . set ( x , y ) ; } } } return bits ; }
@ Override public void error ( String domain , String key , XMLParseException exception ) throws XNIException { if ( fErrorHandler != null ) { SAXParseException saxException = createSAXParseException ( exception ) ; try { fErrorHandler . error ( saxException ) ; } catch ( SAXParseException e ) { throw createXMLParseException ( e ) ; } catch ( SAXException e ) { throw createXNIException ( e ) ; } } }
public static boolean connect ( FileDescriptor fd , InetAddress inetAddress , int port ) throws SocketException { try { return IoBridge . connect ( fd , inetAddress , port , NUM_ ) ; } catch ( SocketTimeoutException ex ) { throw new AssertionError ( ex ) ; } }
public boolean isWhitespace ( int nodeHandle ) { int type = getNodeType ( nodeHandle ) ; Node node = getNode ( nodeHandle ) ; if ( TEXT_NODE == type || CDATA_SECTION_NODE == type ) { FastStringBuffer buf = StringBufferPool . get ( ) ; while ( node != null ) { buf . append ( node . getNodeValue ( ) ) ; node = logicalNextDOMTextNode ( node ) ; } boolean b = buf . isWhitespace ( NUM_ , buf . length ( ) ) ; StringBufferPool . free ( buf ) ; return b ; } return BOOL_ ; }
public CStatusPanel ( final BackEndDebuggerProvider debuggerProvider ) { super ( new BorderLayout ( ) ) ; Preconditions . checkNotNull ( debuggerProvider , STR_ ) ; m_label . setForeground ( Color . BLACK ) ; add ( m_label ) ; m_synchronizer = new CStatusLabelSynchronizer ( m_label , debuggerProvider ) ; }
@ Override public boolean open ( String access ) { if ( access . equals ( STR_ ) ) { try { iStream = new FileImageInputStream ( new File ( filePath ) ) ; parser = new LabelParser ( ) ; metadata = parser . parseHeader ( iStream ) ; iStream . close ( ) ; iStream = null ; } catch ( IOException e ) { try { iStream . close ( ) ; } catch ( Exception x ) { } return ( BOOL_ ) ; } } return ( super . open ( access ) ) ; }
void deregisterSpring ( Spring spring ) { if ( spring == null ) { throw new IllegalArgumentException ( STR_ ) ; } mActiveSprings . remove ( spring ) ; mSpringRegistry . remove ( spring . getId ( ) ) ; }
@ Nullable public String fileName ( ) { return JavaLogger . fileName ( delegate ) ; }
public static BNode parseBNode ( String nTriplesBNode , ValueFactory valueFactory ) throws IllegalArgumentException { if ( nTriplesBNode . startsWith ( STR_ ) ) { return valueFactory . createBNode ( nTriplesBNode . substring ( NUM_ ) ) ; } else { throw new IllegalArgumentException ( STR_ + nTriplesBNode ) ; } }
public void resetPSRs ( ) { pilotRolls . removeAllElements ( ) ; }
public static void sort ( byte [ ] array ) { DualPivotQuicksort . sort ( array ) ; }
public void closePopup ( ) { if ( openedSubPopup != null ) { openedSubPopup . closePopup ( ) ; } removeFromParent ( ) ; }
public void freeObject ( int id ) { if ( cacheId == id ) { cacheId = - NUM_ ; cache = null ; } map . remove ( id ) ; }
private void stretchViewVertically ( View view , int crossSize ) { LayoutParams lp = ( LayoutParams ) view . getLayoutParams ( ) ; int newHeight = crossSize - lp . topMargin - lp . bottomMargin ; newHeight = Math . max ( newHeight , NUM_ ) ; view . measure ( MeasureSpec . makeMeasureSpec ( view . getMeasuredWidth ( ) , MeasureSpec . EXACTLY ) , MeasureSpec . makeMeasureSpec ( newHeight , MeasureSpec . EXACTLY ) ) ; }
public static InetAddress hexToInet6Address ( String addrHexString ) throws IllegalArgumentException { try { return numericToInetAddress ( String . format ( STR_ , addrHexString . substring ( NUM_ , NUM_ ) , addrHexString . substring ( NUM_ , NUM_ ) , addrHexString . substring ( NUM_ , NUM_ ) , addrHexString . substring ( NUM_ , NUM_ ) , addrHexString . substring ( NUM_ , NUM_ ) , addrHexString . substring ( NUM_ , NUM_ ) , addrHexString . substring ( NUM_ , NUM_ ) , addrHexString . substring ( NUM_ , NUM_ ) ) ) ; } catch ( Exception e ) { Log . e ( STR_ , STR_ + addrHexString + STR_ + e ) ; throw new IllegalArgumentException ( e ) ; } }
public void trackFailure ( ) { retryTime = Utils . currentTimeMillis ( ) + ( long ) backoff ; backoff = Math . min ( backoff . params . multiplier , params . maximum ) ; }
public double readDouble ( ) throws IOException { return primitiveTypes . readDouble ( ) ; }
private boolean isAtMaximum ( Adjustable bar ) { return ( bar . getValue ( ) + bar . getVisibleAmount ( ) >= bar . getMaximum ( ) ) ; }
public boolean matchesCS ( String seq ) { return queue . startsWith ( seq , pos ) ; }
protected void parseAndAddMapTileSet ( URL tileSetProperties ) throws IOException , MalformedURLException { Properties descProps = new Properties ( ) ; Logger logger = getLogger ( ) ; logger . info ( STR_ ) ; InputStream descURLStream = tileSetProperties . openStream ( ) ; descProps . load ( descURLStream ) ; logger . info ( STR_ + tileSetProperties . toString ( ) + STR_ + descProps . toString ( ) ) ; MapTileSet mts = createMapTileSetFromProperties ( descProps ) ; if ( mts != null && mts . allGood ( ) ) { String mtsName = mts . getName ( ) ; mapTileSets . put ( mts . getName ( ) , mts ) ; logger . info ( STR_ + mtsName + STR_ ) ; } descURLStream . close ( ) ; }
protected Date compute ( double value ) { if ( Double . isNaN ( value ) ) { return null ; } long dateLong = ( long ) value ; Date date = new Date ( dateLong ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; return cal . getTime ( ) ; }
public void enablePan ( BluetoothAdapter adapter ) { if ( mPan == null ) mPan = ( BluetoothPan ) connectProxy ( adapter , BluetoothProfile . PAN ) ; assertNotNull ( mPan ) ; long start = System . currentTimeMillis ( ) ; mPan . setBluetoothTethering ( BOOL_ ) ; long stop = System . currentTimeMillis ( ) ; assertTrue ( mPan . isTetheringOn ( ) ) ; writeOutput ( String . format ( STR_ , ( stop - start ) ) ) ; }
private int distBetweenPoints ( int x1 , int z1 , int x2 , int z2 , boolean bAllowDiags ) { int w = Math . abs ( x2 - x1 ) ; int h = Math . abs ( z2 - z1 ) ; if ( bAllowDiags ) { if ( w < h ) w = NUM_ ; else h = NUM_ ; } return w + h + NUM_ ; }
public URL ( String protocol , String host , int port , String file , URLStreamHandler handler ) throws MalformedURLException { if ( port < - NUM_ ) { throw new MalformedURLException ( STR_ + port ) ; } if ( protocol == null ) { throw new NullPointerException ( STR_ ) ; } if ( host != null && host . contains ( STR_ ) && host . charAt ( NUM_ ) != STR_ ) { host = STR_ + host + STR_ ; } this . protocol = protocol ; this . host = host ; this . port = port ; file = UrlUtils . authoritySafePath ( host , file ) ; int hash = file . indexOf ( STR_ ) ; if ( hash != - NUM_ ) { this . file = file . substring ( NUM_ , hash ) ; this . ref = file . substring ( hash + NUM_ ) ; } else { this . file = file ; } fixURL ( BOOL_ ) ; if ( handler == null ) { setupStreamHandler ( ) ; if ( streamHandler == null ) { throw new MalformedURLException ( STR_ + protocol ) ; } } else { streamHandler = handler ; } }
private Workflow . Method createVolumesMethod ( URI systemURI , URI poolURI , List < URI > volumeURIs , VirtualPoolCapabilityValuesWrapper capabilities ) { return new Workflow . Method ( STR_ , systemURI , poolURI , volumeURIs , capabilities ) ; }
public FileCommandInfo ( int fd , String command , int result , String parameters ) { this ( BOOL_ , fd , command , result , parameters ) ; }
public void init ( GuiManualHerblore manual ) { for ( ManualWidgetBase widget : widgets ) widget . init ( manual ) ; }
private static SSLSocketFactory trustAllHosts ( HttpsURLConnection connection ) { SSLSocketFactory oldFactory = connection . getSSLSocketFactory ( ) ; try { SSLContext sc = SSLContext . getInstance ( STR_ ) ; sc . init ( null , trustAllCerts , new java . security . SecureRandom ( ) ) ; SSLSocketFactory newFactory = sc . getSocketFactory ( ) ; connection . setSSLSocketFactory ( newFactory ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , e . getMessage ( ) , e ) ; } return oldFactory ; }
public final double sampleMax ( ) { return _activeCountMax . getAndSet ( _activeCount . get ( ) ) ; }
@ Get public Representation userCodeForm ( ) throws OAuth2RestletException , InvalidGrantException , NotFoundException , ServerException { final OAuth2Request request = requestFactory . create ( getRequest ( ) ) ; if ( request . getParameter ( OAuth2Constants . DeviceCode . USER_CODE ) != null ) { return verify ( null ) ; } else { return getTemplateRepresentation ( FORM , request , null ) ; } }
public void testMissionNameConstruction ( ) { String xml = STR_ ; xml += createStartMissionXml ( STR_ , STR_ ) ; xml += createEndMissionXml ( ) ; InputStream missionInputStream = new ByteArrayInputStream ( xml . getBytes ( ) ) ; String missionName = null ; try { missionName = MissionParser . getMissionName ( missionInputStream ) ; } catch ( MissionParseException e ) { e . printStackTrace ( ) ; } Assert . assertEquals ( STR_ , missionName ) ; }
@ Override public boolean equals ( Object other ) { if ( other == this ) { return BOOL_ ; } if ( other instanceof ZoneOffsetTransition ) { ZoneOffsetTransition d = ( ZoneOffsetTransition ) other ; return transition . equals ( d . transition ) && offsetBefore . equals ( d . offsetBefore ) && offsetAfter . equals ( d . offsetAfter ) ; } return BOOL_ ; }
public void release ( ) { super . release ( ) ; init ( ) ; }
public void close ( ) { while ( ! mReceivers . isEmpty ( ) ) { mContext . unregisterReceiver ( mReceivers . remove ( NUM_ ) ) ; } if ( mOutputWriter != null ) { try { mOutputWriter . close ( ) ; } catch ( IOException e ) { Log . w ( mTag , STR_ , e ) ; } } }
private void resolveFiles ( List < String > classpaths , Map < String , String > files , String [ ] paths , String prefix ) { for ( String path : paths ) { String relativePath = fileHandler . getName ( path ) ; if ( prefix != null ) { relativePath = fileHandler . append ( prefix , relativePath ) ; } if ( classpaths != null ) { classpaths . add ( relativePath ) ; } if ( fileHandler . isDirectory ( path ) ) { String [ ] children = fileHandler . getChildren ( path ) ; if ( children != null && children . length != NUM_ ) { resolveFiles ( null , files , children , relativePath ) ; } } else { files . put ( relativePath , path ) ; } } }
public void testGetInstance ( ) throws Exception { try { ExemptionMechanism . getInstance ( ( String ) null , STR_ ) ; fail ( STR_ ) ; } catch ( NoSuchProviderException pe ) { } try { ExemptionMechanism . getInstance ( STR_ , ( String ) null ) ; fail ( STR_ ) ; } catch ( IllegalArgumentException e ) { } }
public synchronized void reloadConfiguration ( ) { properties = null ; finalParameters . clear ( ) ; }
protected void removeMessageProcessor ( MessageProcessor oldMessageProcessor ) { synchronized ( messageProcessors ) { if ( messageProcessors . remove ( oldMessageProcessor ) ) { oldMessageProcessor . stop ( ) ; } } }
X509IssuerSerial ( X509Certificate cert ) { this ( cert . getIssuerX500Principal ( ) , cert . getSerialNumber ( ) ) ; }
private void addToSet ( ObjectXmlPersist persist , IFile file , String setName ) throws IOException , CoreException { Collection < GraphEdgeMatcherDescriptor > updateSet = loadEdgeMatchers ( persist , file ) ; persistUpdatedBundle ( persist , file , updateSet , setName ) ; }
public void putBytes ( byte [ ] bytes ) { ensureCapacity ( bytes . length ) ; System . arraycopy ( bytes , NUM_ , this . byteBuffer , this . position , bytes . length ) ; this . position += bytes . length ; }
public static String arrayToDelimitedString ( Object [ ] arr , String delim ) { if ( arr == null ) { return STR_ ; } StringBuffer sb = new StringBuffer ( ) ; for ( int i = NUM_ ; i < arr . length ; i ++ ) { if ( i > NUM_ ) { sb . append ( delim ) ; } sb . append ( arr [ i ] ) ; } return sb . toString ( ) ; }
public void clearAll ( ) { final List < EncodedImage > old ; synchronized ( this ) { old = new ArrayList < > ( mMap . values ( ) ) ; mMap . clear ( ) ; } for ( int i = NUM_ ; i < old . size ( ) ; i ++ ) { EncodedImage encodedImage = old . get ( i ) ; if ( encodedImage != null ) { encodedImage . close ( ) ; } } }
public static CompiereColor parse ( String attributes ) { CompiereColor cc = new CompiereColor ( ) ; try { if ( attributes != null && attributes . length ( ) > NUM_ ) cc . parseAttributres ( attributes ) ; } catch ( Exception e ) { log . severe ( STR_ + attributes + STR_ + e . toString ( ) ) ; } return cc ; }
public synchronized static LuaState newLuaState ( ) { int i = getNextStateIndex ( ) ; LuaState L = new LuaState ( i ) ; states . add ( i , L ) ; return L ; }
static long checkPreambleSize ( Memory mem ) { final long cap = mem . getCapacity ( ) ; if ( cap < NUM_ ) { throwNotBigEnough ( cap , NUM_ ) ; } final long pre0 = mem . getLong ( NUM_ ) ; final int preLongs = ( int ) ( pre0 & X3FL ) ; final int required = Math . max ( preLongs << NUM_ , NUM_ ) ; if ( cap < required ) { throwNotBigEnough ( cap , required ) ; } return pre0 ; }
public int read ( ) throws IOException { if ( inputStream == null ) { reopen ( ) ; } count ( NUM_ ) ; return inputStream . read ( ) ; }
private void fitImageToView ( ) { Drawable drawable = getDrawable ( ) ; if ( drawable == null || drawable . getIntrinsicWidth ( ) == NUM_ || drawable . getIntrinsicHeight ( ) == NUM_ ) { return ; } if ( matrix == null || prevMatrix == null ) { return ; } int drawableWidth = drawable . getIntrinsicWidth ( ) ; int drawableHeight = drawable . getIntrinsicHeight ( ) ; float scaleX = ( float ) viewWidth / drawableWidth ; float scaleY = ( float ) viewHeight / drawableHeight ; switch ( mScaleType ) { case CENTER : scaleX = scaleY = NUM_ ; break ; case CENTER_CROP : scaleX = scaleY = Math . max ( scaleX , scaleY ) ; break ; case CENTER_INSIDE : scaleX = scaleY = Math . min ( NUM_ , Math . min ( scaleX , scaleY ) ) ; case FIT_CENTER : scaleX = scaleY = Math . min ( scaleX , scaleY ) ; break ; case FIT_XY : break ; default : throw new UnsupportedOperationException ( STR_ ) ; } float redundantXSpace = viewWidth - ( scaleX . drawableWidth ) ; float redundantYSpace = viewHeight - ( scaleY . drawableHeight ) ; matchViewWidth = viewWidth - redundantXSpace ; matchViewHeight = viewHeight - redundantYSpace ; if ( ! isZoomed ( ) && ! imageRenderedAtLeastOnce ) { matrix . setScale ( scaleX , scaleY ) ; matrix . postTranslate ( redundantXSpace / NUM_ , redundantYSpace / NUM_ ) ; normalizedScale = NUM_ ; } else { if ( prevMatchViewWidth == NUM_ || prevMatchViewHeight == NUM_ ) { savePreviousImageValues ( ) ; } prevMatrix . getValues ( m ) ; m [ Matrix . MSCALE_X ] = matchViewWidth / drawableWidth . normalizedScale ; m [ Matrix . MSCALE_Y ] = matchViewHeight / drawableHeight . normalizedScale ; float transX = m [ Matrix . MTRANS_X ] ; float transY = m [ Matrix . MTRANS_Y ] ; float prevActualWidth = prevMatchViewWidth . normalizedScale ; float actualWidth = getImageWidth ( ) ; translateMatrixAfterRotate ( Matrix . MTRANS_X , transX , prevActualWidth , actualWidth , prevViewWidth , viewWidth , drawableWidth ) ; float prevActualHeight = prevMatchViewHeight . normalizedScale ; float actualHeight = getImageHeight ( ) ; translateMatrixAfterRotate ( Matrix . MTRANS_Y , transY , prevActualHeight , actualHeight , prevViewHeight , viewHeight , drawableHeight ) ; matrix . setValues ( m ) ; } fixTrans ( ) ; setImageMatrix ( matrix ) ; }
public void limit ( double x1 , double y1 , double x2 , double y2 ) { clip [ NUM_ ] = Math . max ( clip [ NUM_ ] , x1 ) ; clip [ NUM_ ] = Math . max ( clip [ NUM_ ] , y1 ) ; clip [ NUM_ ] = Math . min ( clip [ NUM_ ] , x2 ) ; clip [ NUM_ ] = Math . min ( clip [ NUM_ ] , y2 ) ; }
public void shutdown ( ) { final long begin = System . currentTimeMillis ( ) ; log . info ( STR_ ) ; log . info ( STR_ + getTaskCount ( scheduledPool ) + STR_ ) ; log . info ( STR_ + getTaskCount ( instantPool ) + STR_ ) ; log . info ( STR_ + getTaskCount ( longRunningPool ) + STR_ ) ; log . info ( STR_ + ( workStealingPool . getQueuedTaskCount ( ) + workStealingPool . getQueuedSubmissionCount ( ) ) + STR_ ) ; scheduledPool . shutdown ( ) ; instantPool . shutdown ( ) ; longRunningPool . shutdown ( ) ; workStealingPool . shutdown ( ) ; boolean success = BOOL_ ; try { success |= awaitTermination ( NUM_ ) ; scheduledPool . setExecuteExistingDelayedTasksAfterShutdownPolicy ( BOOL_ ) ; scheduledPool . setContinueExistingPeriodicTasksAfterShutdownPolicy ( BOOL_ ) ; success |= awaitTermination ( NUM_ ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } log . info ( STR_ + success + STR_ + ( System . currentTimeMillis ( ) - begin ) + STR_ ) ; log . info ( STR_ + getTaskCount ( scheduledPool ) + STR_ ) ; log . info ( STR_ + getTaskCount ( instantPool ) + STR_ ) ; log . info ( STR_ + getTaskCount ( longRunningPool ) + STR_ ) ; log . info ( STR_ + ( workStealingPool . getQueuedTaskCount ( ) + workStealingPool . getQueuedSubmissionCount ( ) ) + STR_ ) ; workStealingPool . shutdownNow ( ) ; }
public static Collection < InetAddress > toInetAddresses ( Collection < String > addrs , Collection < String > hostNames ) throws IgniteCheckedException { Set < InetAddress > res = new HashSet < > ( addrs . size ( ) ) ; Iterator < String > hostNamesIt = hostNames . iterator ( ) ; for ( String addr : addrs ) { String hostName = hostNamesIt . hasNext ( ) ? hostNamesIt . next ( ) : null ; InetAddress inetAddr = null ; if ( ! F . isEmpty ( hostName ) ) { try { inetAddr = InetAddress . getByName ( hostName ) ; } catch ( UnknownHostException ignored ) { } } if ( inetAddr == null || inetAddr . isLoopbackAddress ( ) ) { try { inetAddr = InetAddress . getByName ( addr ) ; } catch ( UnknownHostException ignored ) { } } if ( inetAddr != null ) res . add ( inetAddr ) ; } if ( res . isEmpty ( ) ) throw new IgniteCheckedException ( STR_ + addrs + STR_ + hostNames + STR_ ) ; return res ; }
public static String removeNewLineChars ( String s ) { String retString = null ; if ( ( s != null ) && ( s . length ( ) > NUM_ ) && ( s . indexOf ( STR_ ) != - NUM_ ) ) { char [ ] chars = s . toCharArray ( ) ; int len = chars . length ; StringBuffer sb = new StringBuffer ( len ) ; for ( int i = NUM_ ; i < len ; i ++ ) { char c = chars [ i ] ; if ( c != STR_ ) { sb . append ( c ) ; } } retString = sb . toString ( ) ; } else { retString = s ; } return retString ; }
void calculateCounters ( ) { if ( ! isDBAvailable ( ) ) return ; long time = System . currentTimeMillis ( ) ; int total = NUM_ ; write . lock ( ) ; try { countResetFeedsAndCategories ( ) ; total += countFeedsWithUnread ( ) ; countCategoriesWithUnread ( ) ; countSpecialCategories ( total ) ; } finally { write . unlock ( ) ; } Log . i ( TAG , String . format ( STR_ , total , ( System . currentTimeMillis ( ) - time ) ) ) ; }
protected void appendHTML ( final StringBuilder sbuf , final char ch ) { switch ( ch ) { case STR_ : sbuf . append ( STR_ ) ; break ; case STR_ : sbuf . append ( STR_ ) ; break ; case STR_ : sbuf . append ( STR_ ) ; break ; default : sbuf . append ( ch ) ; break ; } }
private Collection < Var > migrateColumns ( SQLTable currentTable ) { List < Var > vars = new ArrayList < > ( ) ; String tableType = currentTable . getEntityType ( ) ; Map < String , ResourceType . DataType > columns = currentTable . getColumns ( ) ; Map < String , String > foreignColumns = currentTable . getForeignKeyColumns ( ) ; for ( String column : columns . keySet ( ) ) { ResourceType . DataType columnType = columns . get ( column ) ; if ( foreignColumns . containsKey ( column ) ) { vars . addAll ( migrateAsRelation ( tableType , column , foreignColumns . get ( column ) ) ) ; } else { vars . addAll ( migrateAsResource ( tableType , columnType , column ) ) ; } } return vars ; }
public int retrieveRowCount ( String tableName ) throws SQLException { ResultSet rs = null ; int rowCount = - NUM_ ; try { rs = statement . executeQuery ( STR_ + tableName ) ; rs . next ( ) ; rowCount = rs . getInt ( NUM_ ) ; } finally { if ( rs != null ) { rs . close ( ) ; } } return rowCount ; }
public JarModifier ( File jarFile ) throws JarException , IOException { this . jarFile = jarFile ; JarFile jar = new JarFile ( jarFile ) ; Enumeration < ? extends JarEntry > enumerator = jar . entries ( ) ; while ( enumerator . hasMoreElements ( ) ) { JarEntry currentEntry = ( JarEntry ) enumerator . nextElement ( ) ; JarEntry resetEntry = new JarEntry ( currentEntry . getName ( ) ) ; jarEntries . put ( currentEntry . getName ( ) , resetEntry ) ; } String manifestPath = META_INF + SEPERATOR + STR_ ; JarEntry jarEntry = jar . getJarEntry ( manifestPath ) ; if ( jarEntry != null ) { Enumeration < JarEntry > entries = jar . entries ( ) ; while ( entries . hasMoreElements ( ) ) { jarEntry = ( JarEntry ) entries . nextElement ( ) ; if ( manifestPath . equalsIgnoreCase ( jarEntry . getName ( ) ) ) { break ; } else { jarEntry = null ; } } } Manifest manifest = new Manifest ( ) ; if ( jarEntry != null ) { manifest . read ( jar . getInputStream ( jarEntry ) ) ; } this . manifest = manifest ; jar . close ( ) ; }
@ Override public int addAttribute ( Attribute a ) { if ( a == null ) { throw new IllegalArgumentException ( STR_ ) ; } else { int index = - NUM_ ; Attribute original = a ; a = ( Attribute ) a . clone ( ) ; if ( unusedColumnList . size ( ) > NUM_ ) { synchronized ( unusedColumnList ) { if ( unusedColumnList . size ( ) > NUM_ ) { index = unusedColumnList . remove ( NUM_ ) ; attributes . set ( index , a ) ; } else { index = attributes . size ( ) ; attributes . add ( a ) ; } } } else { index = attributes . size ( ) ; attributes . add ( a ) ; } a . setTableIndex ( index ) ; original . setTableIndex ( index ) ; return index ; } }
default B with ( String key , int value ) { return with ( key , Integer . toString ( value ) ) ; }
public static < X > void sortTopN ( X [ ] array , int offset , int limit , Comparator < ? super X > comp ) { partitionTopN ( array , offset , limit , comp ) ; Arrays . sort ( array , offset , ( int ) Math . min ( ( long ) offset + limit , array . length ) , comp ) ; }
protected boolean isServerTransaction ( ) { return this instanceof SIPServerTransaction ; }
Object addMarkedOccurrenceHighlight ( int start , int end , MarkOccurrencesHighlightPainter p ) throws BadLocationException { Document doc = textArea . getDocument ( ) ; TextUI mapper = textArea . getUI ( ) ; HighlightInfo i = new LayeredHighlightInfo ( ) ; i . painter = p ; i . p0 = doc . createPosition ( start ) ; i . p1 = doc . createPosition ( end - NUM_ ) ; markedOccurrences . add ( i ) ; mapper . damageRange ( textArea , start , end ) ; return i ; }
public static void readFully ( InputStream in , byte buf [ ] , int off , int len ) throws IOException { int toRead = len ; while ( toRead > NUM_ ) { int ret = in . read ( buf , off , toRead ) ; if ( ret < NUM_ ) { throw new IOException ( STR_ ) ; } toRead -= ret ; off += ret ; } }
public static void assumeTrue ( BooleanSupplier assumptionSupplier , Supplier < String > messageSupplier ) throws TestAbortedException { if ( ! assumptionSupplier . getAsBoolean ( ) ) { throwTestAbortedException ( messageSupplier . get ( ) ) ; } }
public static String addToCartBulk ( HttpServletRequest request , HttpServletResponse response ) { String categoryId = request . getParameter ( STR_ ) ; ShoppingCart cart = getCartObject ( request ) ; Delegator delegator = ( Delegator ) request . getAttribute ( STR_ ) ; LocalDispatcher dispatcher = ( LocalDispatcher ) request . getAttribute ( STR_ ) ; ShoppingCartHelper cartHelper = new ShoppingCartHelper ( delegator , dispatcher , cart ) ; String controlDirective ; Map < String , Object > result ; Map < String , Object > paramMap = UtilHttp . getParameterMap ( request ) ; String catalogId = CatalogWorker . getCurrentCatalogId ( request ) ; result = cartHelper . addToCartBulk ( catalogId , categoryId , paramMap ) ; controlDirective = processResult ( result , request ) ; if ( controlDirective . equals ( ERROR ) ) { return STR_ ; } else { return STR_ ; } }
public void addFrequentSet ( FrequentItemSet itemSet ) { frequentSets . add ( itemSet ) ; maximumSetSize = Math . max ( itemSet . getNumberOfItems ( ) , maximumSetSize ) ; }
private int skipFromPeekBuffer ( int length ) { int bytesSkipped = Math . min ( peekBufferLength , length ) ; updatePeekBuffer ( bytesSkipped ) ; return bytesSkipped ; }
protected Workflow . Method createRemoveVolumesFromCGMethod ( URI vplexURI , URI cgURI , List < URI > vplexVolumeURIs ) { return new Workflow . Method ( REMOVE_VOLUMES_FROM_CG_STEP , vplexURI , cgURI , vplexVolumeURIs ) ; }
private static int showUrlsPrompt ( Component parent , List < String > urls ) { String text = STR_ ; for ( String url : urls ) { url = splitUrl ( url ) ; text += url + STR_ ; } String okOption = STR_ ; if ( urls . size ( ) > NUM_ ) { okOption = STR_ + urls . size ( ) + STR_ ; } String [ ] options = { okOption , STR_ } ; if ( urls . size ( ) == NUM_ ) { options = new String [ ] { okOption , STR_ , STR_ } ; } int chosenOption = JOptionPane . showOptionDialog ( parent , text , STR_ , JOptionPane . OK_CANCEL_OPTION , JOptionPane . QUESTION_MESSAGE , null , options , NUM_ ) ; return chosenOption ; }
int convertMouse ( MouseEvent event ) { int result ; if ( panelFont == null ) return ( NO_MOUSE ) ; int colOff = event . getX ( ) - GRID_WIDTH - PANEL_MARGIN ; int colNum = colOff / horizStep ; int colRem = colOff % horizStep ; if ( ( colNum >= panelColumns ) || ( colRem < TEXT_MARGIN ) || ( colRem > ( horizStep - GRID_WIDTH - TEXT_MARGIN ) ) ) { return ( NO_MOUSE ) ; } int rowOff = event . getY ( ) - GRID_WIDTH - PANEL_MARGIN ; int rowNum = rowOff / vertiStep ; int rowRem = rowOff % vertiStep ; if ( ( rowRem < TEXT_MARGIN ) || ( rowRem > ( vertiStep - GRID_WIDTH - TEXT_MARGIN ) ) ) { return ( NO_MOUSE ) ; } result = cornerIndex + ( rowNum . panelColumns ) + colNum ; if ( result >= cellCount ) return ( NO_MOUSE ) ; return ( result ) ; }
private static String computeRegexString ( String originalString , String oldName , String newName ) { StringBuilder builder = new StringBuilder ( originalString . length ( ) ) ; String oldNameOrNewNameRegEx = String . format ( STR_ , Pattern . quote ( oldName ) , Pattern . quote ( newName ) ) ; int i = originalString . indexOf ( oldName ) ; if ( i >= NUM_ ) { int prevI = NUM_ ; while ( i >= NUM_ ) { builder . append ( Pattern . quote ( originalString . substring ( prevI , i ) ) ) ; builder . append ( oldNameOrNewNameRegEx ) ; prevI = i ; i = originalString . indexOf ( oldName , i + oldName . length ( ) ) ; } builder . append ( Pattern . quote ( originalString . substring ( prevI + oldName . length ( ) , originalString . length ( ) ) ) ) ; } return builder . toString ( ) ; }
public synchronized String generateCallIdentifier ( String address ) { String date = Long . toString ( System . currentTimeMillis ( ) + callIDCounter ++ + rand . nextLong ( ) ) ; byte cid [ ] = digester . digest ( date . getBytes ( ) ) ; String cidString = Utils . toHexString ( cid ) ; return cidString + STR_ + address ; }
int parseHour ( String source , char patternChar , int offset ) throws ParseException { int min = ( patternChar == HOUR_1_LETTER || patternChar == HOUR12_1_LETTER ) ? NUM_ : NUM_ ; int max = ( ( patternChar == HOUR_LETTER || patternChar == HOUR_1_LETTER ) ? NUM_ : NUM_ ) + min ; return parseNumber ( source , offset , STR_ , min , max ) - min ; }
public void doHistory ( KeyEvent e ) { if ( e . getSource ( ) == m_Input ) { switch ( e . getKeyCode ( ) ) { case KeyEvent . VK_UP : if ( m_HistoryPos > NUM_ ) { m_HistoryPos -- ; String command = m_CommandHistory . elementAt ( m_HistoryPos ) ; m_Input . setText ( command ) ; } break ; case KeyEvent . VK_DOWN : if ( m_HistoryPos < m_CommandHistory . size ( ) ) { m_HistoryPos ++ ; String command = STR_ ; if ( m_HistoryPos < m_CommandHistory . size ( ) ) { command = m_CommandHistory . elementAt ( m_HistoryPos ) ; } m_Input . setText ( command ) ; } break ; default : break ; } } }
public static ReferenceBinding [ ] substitute ( Substitution substitution , ReferenceBinding [ ] originalTypes ) { if ( originalTypes == null ) return null ; ReferenceBinding [ ] substitutedTypes = originalTypes ; for ( int i = NUM_ , length = originalTypes . length ; i < length ; i ++ ) { ReferenceBinding originalType = originalTypes [ i ] ; TypeBinding substitutedType = substitute ( substitution , originalType ) ; if ( ! ( substitutedType instanceof ReferenceBinding ) ) { return null ; } if ( substitutedType != originalType ) { if ( substitutedTypes == originalTypes ) { System . arraycopy ( originalTypes , NUM_ , substitutedTypes = new ReferenceBinding [ length ] , NUM_ , i ) ; } substitutedTypes [ i ] = ( ReferenceBinding ) substitutedType ; } else if ( substitutedTypes != originalTypes ) { substitutedTypes [ i ] = originalType ; } } return substitutedTypes ; }
private static Collection < TCPTransport > allKnownTransports ( ) { Set < TCPTransport > s ; synchronized ( localEndpoints ) { s = new HashSet < TCPTransport > ( localEndpoints . size ( ) ) ; for ( LinkedList < TCPEndpoint > epList : localEndpoints . values ( ) ) { TCPEndpoint ep = epList . getFirst ( ) ; s . add ( ep . transport ) ; } } return s ; }
public void requestSecondsUntilIdleLockout ( ) { operations . add ( PasswordPolicyStateOperationType . GET_SECONDS_UNTIL_IDLE_LOCKOUT ) ; }
@ RequestMapping ( value = STR_ , method = { RequestMethod . GET } ) @ ResponseBody private static List < String > showHiveDatabases ( ) throws IOException { IHiveClient hiveClient = HiveClientFactory . getHiveClient ( ) ; List < String > results = null ; try { results = hiveClient . getHiveDbNames ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new IOException ( e ) ; } return results ; }
public void testNegNegFirstShorter ( ) { byte aBytes [ ] = { - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { - NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ } ; int aSign = - NUM_ ; int bSign = - NUM_ ; byte rBytes [ ] = { - NUM_ , NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . and ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , - NUM_ , result . signum ( ) ) ; }
private static Object fromString ( String s ) throws IOException , ClassNotFoundException { byte [ ] data = Base64 . decode ( s , Base64 . DEFAULT ) ; ObjectInputStream ois = new ObjectInputStream ( new ByteArrayInputStream ( data ) ) ; Object o = ois . readObject ( ) ; ois . close ( ) ; return o ; }
private boolean copyDocument ( SearchDocument newDocument , SearchDocument document , Map < String , Set < String > > removedProperties ) { boolean mutated = BOOL_ ; for ( String oldFieldName : document . getPropertyNames ( ) ) { newDocument . addProperty ( oldFieldName ) ; List < String > oldValues = document . getProperty ( oldFieldName ) ; if ( oldValues != null ) { Set < String > objectsRemoved = ( removedProperties != null ) ? removedProperties . get ( oldFieldName ) : null ; for ( String oldValue : oldValues ) { if ( ( objectsRemoved != null ) && ( objectsRemoved . contains ( oldValue ) ) ) { mutated = BOOL_ ; } else { addProperty ( oldFieldName , oldValue , newDocument ) ; } } } } return mutated ; }
public SVDMatrix ( Matrix Arg ) { this ( Arg , BOOL_ , BOOL_ , BOOL_ ) ; }
public void unlockForClear ( InternalDistributedMember locker ) { synchronized ( this . clearLockSync ) { InternalDistributedSystem instance = InternalDistributedSystem . getAnyInstance ( ) ; if ( instance != null && logger . isDebugEnabled ( ) ) { logger . debug ( STR_ , locker , System . identityHashCode ( this ) ) ; } if ( this . lockOwner != null && ! locker . equals ( this . lockOwner ) ) { if ( instance != null && logger . isDebugEnabled ( ) ) { logger . debug ( STR_ , lockOwner ) ; } return ; } unlockVersionGeneration ( locker ) ; } }
private static int lastIndexOf ( Object o , @ NotNull Object [ ] elements , int index ) { if ( o == null ) { for ( int i = index ; i >= NUM_ ; i -- ) { if ( elements [ i ] == null ) { return i ; } } } else { for ( int i = index ; i >= NUM_ ; i -- ) { if ( o . equals ( elements [ i ] ) ) { return i ; } } } return - NUM_ ; }
public void write ( ByteBuffer buffer ) throws IOException { buffer . position ( NUM_ ) ; if ( mFileChannel . size ( ) + buffer . capacity ( ) < mMaxSize ) { while ( buffer . hasRemaining ( ) ) { mFileChannel . write ( buffer ) ; } updateWaveFileSize ( ) ; } else { int remaining = ( int ) ( mMaxSize - mFileChannel . size ( ) ) ; remaining -= ( int ) ( remaining % mAudioFormat . getFrameSize ( ) ) ; byte [ ] bytes = buffer . array ( ) ; ByteBuffer current = ByteBuffer . wrap ( Arrays . copyOf ( bytes , remaining ) ) ; ByteBuffer next = ByteBuffer . wrap ( Arrays . copyOfRange ( bytes , remaining , bytes . length ) ) ; while ( current . hasRemaining ( ) ) { mFileChannel . write ( current ) ; } updateWaveFileSize ( ) ; rollover ( ) ; while ( next . hasRemaining ( ) ) { mFileChannel . write ( next ) ; } updateWaveFileSize ( ) ; } }
public static double dmod_d ( double lhs , double rhs ) { return rhs != NUM_ ? lhs - rhs . Math . floor ( lhs / rhs ) : Double . NaN ; }
public void testMaxLess ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int bSign = NUM_ ; byte rBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . max ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertTrue ( STR_ , result . signum ( ) == NUM_ ) ; }
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m_ioThread . isAlive ( ) && m_state != IDLE ) { wait ( ) ; } } catch ( InterruptedException ex ) { } } else { notifyAll ( ) ; } }
public void move ( MouseEvent e ) { Point2D pnt = getProjectionPoint ( e ) ; int x = ( int ) pnt . getX ( ) ; int y = ( int ) pnt . getY ( ) ; if ( poly . getRenderType ( ) == OMGraphic . RENDERTYPE_OFFSET ) { gpm = new OffsetGrabPoint ( x , y ) ; gpm . clear ( ) ; } else { gpm = gpo ; gpm . clear ( ) ; gpm . set ( x , y ) ; } addPolyGrabPointsToOGP ( gpm ) ; movingPoint = gpm ; }
public FloatBuffer put ( float [ ] src , int srcOffset , int floatCount ) { Arrays . checkOffsetAndCount ( src . length , srcOffset , floatCount ) ; if ( floatCount > remaining ( ) ) { throw new BufferOverflowException ( ) ; } for ( int i = srcOffset ; i < srcOffset + floatCount ; ++ i ) { put ( src [ i ] ) ; } return this ; }
public final void dispatchCharactersEvents ( int nodeHandle , ContentHandler ch , boolean normalize ) throws SAXException { int identity = makeNodeIdentity ( nodeHandle ) ; if ( identity == DTM . NULL ) return ; int type = _type2 ( identity ) ; if ( type == DTM . ELEMENT_NODE || type == DTM . DOCUMENT_NODE ) { int startNode = identity ; identity = _firstch2 ( identity ) ; if ( DTM . NULL != identity ) { int offset = - NUM_ ; int length = NUM_ ; do { type = _exptype2 ( identity ) ; if ( type == DTM . TEXT_NODE || type == DTM . CDATA_SECTION_NODE ) { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex >= NUM_ ) { if ( - NUM_ == offset ) { offset = dataIndex > > > TEXT_LENGTH_BITS ; } length += dataIndex & TEXT_LENGTH_MAX ; } else { if ( - NUM_ == offset ) { offset = m_data . elementAt ( - dataIndex ) ; } length += m_data . elementAt ( - dataIndex + NUM_ ) ; } } identity ++ ; } while ( _parent2 ( identity ) >= startNode ) ; if ( length > NUM_ ) { if ( normalize ) m_chars . sendNormalizedSAXcharacters ( ch , offset , length ) ; else m_chars . sendSAXcharacters ( ch , offset , length ) ; } } } else if ( DTM . TEXT_NODE == type || DTM . CDATA_SECTION_NODE == type ) { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex >= NUM_ ) { if ( normalize ) m_chars . sendNormalizedSAXcharacters ( ch , dataIndex > > > TEXT_LENGTH_BITS , dataIndex & TEXT_LENGTH_MAX ) ; else m_chars . sendSAXcharacters ( ch , dataIndex > > > TEXT_LENGTH_BITS , dataIndex & TEXT_LENGTH_MAX ) ; } else { if ( normalize ) m_chars . sendNormalizedSAXcharacters ( ch , m_data . elementAt ( - dataIndex ) , m_data . elementAt ( - dataIndex + NUM_ ) ) ; else m_chars . sendSAXcharacters ( ch , m_data . elementAt ( - dataIndex ) , m_data . elementAt ( - dataIndex + NUM_ ) ) ; } } else { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex < NUM_ ) { dataIndex = - dataIndex ; dataIndex = m_data . elementAt ( dataIndex + NUM_ ) ; } String str = ( String ) m_values . elementAt ( dataIndex ) ; if ( normalize ) FastStringBuffer . sendNormalizedSAXcharacters ( str . toCharArray ( ) , NUM_ , str . length ( ) , ch ) ; else ch . characters ( str . toCharArray ( ) , NUM_ , str . length ( ) ) ; } }
public static boolean containIP ( int cidrPrefix , int cidrMaskBits , int ip ) { boolean matched = BOOL_ ; int bitsToShift = NUM_ - cidrMaskBits ; if ( bitsToShift > NUM_ ) { cidrPrefix = cidrPrefix > > bitsToShift ; ip = ip > > bitsToShift ; cidrPrefix = cidrPrefix << bitsToShift ; ip = ip << bitsToShift ; } if ( cidrPrefix != ip ) { matched = BOOL_ ; } return matched ; }
protected static Boolean lock ( String serviceName , Object name ) { DistributedLockService service = DistributedLockService . getServiceNamed ( serviceName ) ; boolean locked = service . lock ( name , NUM_ , - NUM_ ) ; return Boolean . valueOf ( locked ) ; }
protected int checkKnownCookie ( ) { int retVal = NUM_ ; debug . message ( STR_ , ADAPTIVE ) ; HttpServletRequest req = getHttpServletRequest ( ) ; if ( req != null ) { Cookie cookie = CookieUtils . getCookieFromReq ( req , knownCookieName ) ; if ( cookie != null ) { if ( knownCookieValue . equalsIgnoreCase ( CookieUtils . getCookieValue ( cookie ) ) ) { retVal = knownCookieScore ; } } } if ( knownCookieValue == null ) { knownCookieValue = STR_ ; } if ( knownCookieSave ) { postAuthNMap . put ( STR_ , knownCookieName ) ; postAuthNMap . put ( STR_ , knownCookieValue ) ; } if ( ! knownCookieInvert ) { retVal = knownCookieScore - retVal ; } return retVal ; }
public File [ ] selectImportFiles ( final String title , boolean multipleSelection , FileNameExtensionFilter [ ] fileNameExtensionFilters ) { if ( Boolean . parseBoolean ( System . getProperty ( STR_ , Boolean . toString ( OSType . isMac ( ) ) ) ) ) { FileDialog importDialog = fileDialogs . get ( title ) ; if ( importDialog == null ) { importDialog = new FileDialog ( this , title , FileDialog . LOAD ) ; fileDialogs . put ( title , importDialog ) ; } importDialog . setVisible ( BOOL_ ) ; if ( importDialog . getFile ( ) != null ) { return new File [ ] { new File ( importDialog . getDirectory ( ) , importDialog . getFile ( ) ) } ; } } else { JFileChooser importChooser = fileChoosers . get ( title ) ; if ( importChooser == null ) { importChooser = new JFileChooser ( Utils . getCWD ( ) ) ; importChooser . setMultiSelectionEnabled ( multipleSelection ) ; for ( FileNameExtensionFilter fileNameExtensionFilter : fileNameExtensionFilters ) { importChooser . setFileFilter ( fileNameExtensionFilter ) ; } importChooser . setDialogTitle ( title ) ; fileChoosers . put ( title , importChooser ) ; } int returnVal = importChooser . showOpenDialog ( this ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { if ( importChooser . isMultiSelectionEnabled ( ) ) { return importChooser . getSelectedFiles ( ) ; } else { return new File [ ] { importChooser . getSelectedFile ( ) } ; } } } return null ; }
public GT_MetaGenerated_Item ( String aUnlocalized , short aOffset , short aItemAmount ) { super ( aUnlocalized ) ; setCreativeTab ( GregTech_API . TAB_GREGTECH_MATERIALS ) ; setHasSubtypes ( BOOL_ ) ; setMaxDamage ( NUM_ ) ; mEnabledItems = new BitSet ( aItemAmount ) ; mVisibleItems = new BitSet ( aItemAmount ) ; mOffset = ( short ) Math . min ( NUM_ , aOffset ) ; mItemAmount = ( short ) Math . min ( aItemAmount , NUM_ - mOffset ) ; mIconList = new IIcon [ aItemAmount ] [ NUM_ ] ; sInstances . put ( getUnlocalizedName ( ) , this ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( NUM_ ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
@ Override public SSLEngineResult wrap ( ByteBuffer [ ] srcs , int offset , int len , ByteBuffer dst ) throws SSLException { if ( engine_was_shutteddown ) { return new SSLEngineResult ( SSLEngineResult . Status . CLOSED , SSLEngineResult . HandshakeStatus . NOT_HANDSHAKING , NUM_ , NUM_ ) ; } if ( ( srcs == null ) || ( dst == null ) ) { throw new IllegalStateException ( STR_ ) ; } if ( dst . isReadOnly ( ) ) { throw new ReadOnlyBufferException ( ) ; } if ( ! handshake_started ) { beginHandshake ( ) ; } SSLEngineResult . HandshakeStatus handshakeStatus = getHandshakeStatus ( ) ; if ( ( session == null || engine_was_closed ) && ( handshakeStatus . equals ( SSLEngineResult . HandshakeStatus . NEED_UNWRAP ) || handshakeStatus . equals ( SSLEngineResult . HandshakeStatus . NEED_TASK ) ) ) { return new SSLEngineResult ( getEngineStatus ( ) , handshakeStatus , NUM_ , NUM_ ) ; } int capacity = dst . remaining ( ) ; int produced = NUM_ ; if ( alertProtocol . hasAlert ( ) ) { if ( capacity < recordProtocol . getRecordSize ( NUM_ ) ) { return new SSLEngineResult ( SSLEngineResult . Status . BUFFER_OVERFLOW , handshakeStatus , NUM_ , NUM_ ) ; } byte [ ] alert_data = alertProtocol . wrap ( ) ; dst . put ( alert_data ) ; if ( alertProtocol . isFatalAlert ( ) ) { alertProtocol . setProcessed ( ) ; if ( session != null ) { session . invalidate ( ) ; } shutdown ( ) ; return new SSLEngineResult ( SSLEngineResult . Status . CLOSED , SSLEngineResult . HandshakeStatus . NOT_HANDSHAKING , NUM_ , alert_data . length ) ; } else { alertProtocol . setProcessed ( ) ; if ( close_notify_was_sent && close_notify_was_received ) { shutdown ( ) ; return new SSLEngineResult ( SSLEngineResult . Status . CLOSED , SSLEngineResult . HandshakeStatus . NOT_HANDSHAKING , NUM_ , alert_data . length ) ; } return new SSLEngineResult ( getEngineStatus ( ) , getHandshakeStatus ( ) , NUM_ , alert_data . length ) ; } } if ( capacity < recordProtocol . getMinRecordSize ( ) ) { if ( logger != null ) { logger . println ( STR_ + capacity + STR_ + recordProtocol . getMinRecordSize ( ) + STR_ ) ; } return new SSLEngineResult ( SSLEngineResult . Status . BUFFER_OVERFLOW , handshakeStatus , NUM_ , NUM_ ) ; } try { if ( ! handshakeStatus . equals ( SSLEngineResult . HandshakeStatus . NEED_WRAP ) ) { dataStream . setSourceBuffers ( srcs , offset , len ) ; if ( ( capacity < SSLRecordProtocol . MAX_SSL_PACKET_SIZE ) && ( capacity < recordProtocol . getRecordSize ( dataStream . available ( ) ) ) ) { if ( logger != null ) { logger . println ( STR_ + capacity + STR_ + recordProtocol . getRecordSize ( dataStream . available ( ) ) + STR_ ) ; } return new SSLEngineResult ( SSLEngineResult . Status . BUFFER_OVERFLOW , handshakeStatus , NUM_ , NUM_ ) ; } if ( remaining_wrapped_data == null ) { remaining_wrapped_data = recordProtocol . wrap ( ContentType . APPLICATION_DATA , dataStream ) ; } if ( capacity < remaining_wrapped_data . length ) { return new SSLEngineResult ( SSLEngineResult . Status . BUFFER_OVERFLOW , handshakeStatus , dataStream . consumed ( ) , NUM_ ) ; } else { dst . put ( remaining_wrapped_data ) ; produced = remaining_wrapped_data . length ; remaining_wrapped_data = null ; return new SSLEngineResult ( getEngineStatus ( ) , handshakeStatus , dataStream . consumed ( ) , produced ) ; } } else { if ( remaining_hsh_data == null ) { remaining_hsh_data = handshakeProtocol . wrap ( ) ; } if ( capacity < remaining_hsh_data . length ) { return new SSLEngineResult ( SSLEngineResult . Status . BUFFER_OVERFLOW , handshakeStatus , NUM_ , NUM_ ) ; } else { dst . put ( remaining_hsh_data ) ; produced = remaining_hsh_data . length ; remaining_hsh_data = null ; handshakeStatus = handshakeProtocol . getStatus ( ) ; if ( handshakeStatus . equals ( SSLEngineResult . HandshakeStatus . FINISHED ) ) { session = recordProtocol . getSession ( ) ; } } return new SSLEngineResult ( getEngineStatus ( ) , getHandshakeStatus ( ) , NUM_ , produced ) ; } } catch ( AlertException e ) { alertProtocol . alert ( AlertProtocol . FATAL , e . getDescriptionCode ( ) ) ; engine_was_closed = BOOL_ ; if ( session != null ) { session . invalidate ( ) ; } throw e . getReason ( ) ; } }
public static byte [ ] readFully ( InputStream in ) throws IOException { try { return readFullyNoClose ( in ) ; } finally { in . close ( ) ; } }
public static ParsedSql parseSqlStatement ( String sql ) { Set < String > namedParameters = new HashSet < String > ( ) ; ParsedSql parsedSql = new ParsedSql ( sql ) ; char [ ] statement = sql . toCharArray ( ) ; int namedParameterCount = NUM_ ; int unnamedParameterCount = NUM_ ; int totalParameterCount = NUM_ ; int i = NUM_ ; while ( i < statement . length ) { int skipToPosition = skipCommentsAndQuotes ( statement , i ) ; if ( i != skipToPosition ) { if ( skipToPosition >= statement . length ) { break ; } i = skipToPosition ; } char c = statement [ i ] ; if ( c == STR_ || c == STR_ ) { int j = i + NUM_ ; if ( j < statement . length && statement [ j ] == STR_ && c == STR_ ) { i = i + NUM_ ; continue ; } while ( j < statement . length && ! isParameterSeparator ( statement [ j ] ) ) { j ++ ; } if ( j - i > NUM_ ) { String parameter = sql . substring ( i + NUM_ , j ) ; if ( ! namedParameters . contains ( parameter ) ) { namedParameters . add ( parameter ) ; namedParameterCount ++ ; } parsedSql . addNamedParameter ( parameter , i , j ) ; totalParameterCount ++ ; } i = j - NUM_ ; } else { if ( c == STR_ ) { unnamedParameterCount ++ ; totalParameterCount ++ ; } } i ++ ; } parsedSql . setNamedParameterCount ( namedParameterCount ) ; parsedSql . setUnnamedParameterCount ( unnamedParameterCount ) ; parsedSql . setTotalParameterCount ( totalParameterCount ) ; return parsedSql ; }
final void putLong ( int offset , long value ) { unsafe . putLong ( offset + address , value ) ; }
public boolean onEvent ( ActionResult result ) { synchronized ( this ) { String requestId = result . getResponseInfo ( ) . mRequestId ; if ( requestId == null ) { return BOOL_ ; } boolean eventRemoved = mRequestIds . remove ( requestId ) ; if ( eventRemoved ) { Class key = null ; for ( Class type : mLastRequestIdByType . keySet ( ) ) { if ( requestId . equals ( mLastRequestIdByType . get ( type ) ) ) { key = type ; break ; } } if ( key != null ) { mLastRequestIdByType . remove ( key ) ; } } return eventRemoved ; } }
public static String gensalt ( int log_rounds , SecureRandom random ) { StringBuffer rs = new StringBuffer ( ) ; byte rnd [ ] = new byte [ BCRYPT_SALT_LEN ] ; random . nextBytes ( rnd ) ; rs . append ( STR_ ) ; if ( log_rounds < NUM_ ) { rs . append ( STR_ ) ; } if ( log_rounds > NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } rs . append ( Integer . toString ( log_rounds ) ) ; rs . append ( STR_ ) ; rs . append ( encode_base64 ( rnd , rnd . length ) ) ; return rs . toString ( ) ; }
public void checkKey ( Object key ) throws PartitionedRegionException { if ( ! hasHash ) { return ; } if ( key == null ) { return ; } int expected = key . hashCode ( ) ; if ( expected == keyHash ) { return ; } throw new PartitionedRegionException ( STR_ + expected + STR_ + keyHash ) ; }
public StringBuffer numberToString ( final String strNumberToConvert ) { String strNumber = STR_ , signBit = STR_ ; if ( strNumberToConvert . startsWith ( STR_ ) ) { strNumber = STR_ + strNumberToConvert . substring ( NUM_ , strNumberToConvert . length ( ) ) ; signBit = STR_ ; } else strNumber = STR_ + strNumberToConvert ; final DecimalFormat dft = new DecimalFormat ( STR_ ) ; final String strtemp = STR_ + dft . format ( Double . parseDouble ( strNumber ) ) ; StringBuffer strbNumber = new StringBuffer ( strtemp ) ; final int intLen = strbNumber . length ( ) ; for ( int i = intLen - NUM_ ; i > NUM_ ; i = i - NUM_ ) strbNumber . insert ( i , STR_ ) ; if ( signBit . equals ( STR_ ) ) strbNumber = strbNumber . insert ( NUM_ , STR_ ) ; return strbNumber ; }
private void runInitScriptIfRequired ( String url , Connection connection ) throws SQLException { Matcher matcher = INITSCRIPT_MATCHING_PATTERN . matcher ( url ) ; if ( matcher . matches ( ) ) { String initScriptPath = matcher . group ( NUM_ ) ; try { URL resource = Resources . getResource ( initScriptPath ) ; String sql = Resources . toString ( resource , Charsets . UTF_8 ) ; ScriptUtils . executeSqlScript ( connection , initScriptPath , sql ) ; } catch ( IOException | IllegalArgumentException e ) { LOGGER . warn ( STR_ , initScriptPath ) ; throw new SQLException ( STR_ + initScriptPath , e ) ; } catch ( ScriptException e ) { LOGGER . error ( STR_ , initScriptPath , e ) ; throw new SQLException ( STR_ + initScriptPath , e ) ; } } }
public static void println ( Object x ) { out . println ( x ) ; }
public static void checkFinite ( final double [ ] val ) throws MathIllegalArgumentException { for ( int i = NUM_ ; i < val . length ; i ++ ) { final double x = val [ i ] ; if ( Double . isInfinite ( x ) || Double . isNaN ( x ) ) { throw new MathIllegalArgumentException ( LocalizedCoreFormats . NOT_FINITE_NUMBER , x ) ; } } }
private void initKeyboardButtons ( KeyboardView view ) { mButtons = new ArrayList < > ( ) ; mButtons . add ( ( KeyboardButtonView ) view . findViewById ( R . id . pin_code_button_0 ) ) ; mButtons . add ( ( KeyboardButtonView ) view . findViewById ( R . id . pin_code_button_1 ) ) ; mButtons . add ( ( KeyboardButtonView ) view . findViewById ( R . id . pin_code_button_2 ) ) ; mButtons . add ( ( KeyboardButtonView ) view . findViewById ( R . id . pin_code_button_3 ) ) ; mButtons . add ( ( KeyboardButtonView ) view . findViewById ( R . id . pin_code_button_4 ) ) ; mButtons . add ( ( KeyboardButtonView ) view . findViewById ( R . id . pin_code_button_5 ) ) ; mButtons . add ( ( KeyboardButtonView ) view . findViewById ( R . id . pin_code_button_6 ) ) ; mButtons . add ( ( KeyboardButtonView ) view . findViewById ( R . id . pin_code_button_7 ) ) ; mButtons . add ( ( KeyboardButtonView ) view . findViewById ( R . id . pin_code_button_8 ) ) ; mButtons . add ( ( KeyboardButtonView ) view . findViewById ( R . id . pin_code_button_9 ) ) ; mButtons . add ( ( KeyboardButtonView ) view . findViewById ( R . id . pin_code_button_clear ) ) ; for ( View button : mButtons ) { button . setOnClickListener ( this ) ; } }
public static boolean isAutoNew ( Properties ctx , int WindowNo ) { if ( ctx == null ) throw new IllegalArgumentException ( STR_ ) ; String s = getContext ( ctx , WindowNo , STR_ , BOOL_ ) ; if ( s != null ) { if ( s . equals ( STR_ ) ) return BOOL_ ; else return BOOL_ ; } return isAutoNew ( ctx ) ; }
private static String findRelativePath ( String filePath , String dirPath ) { String relPath ; if ( ! dirPath . endsWith ( File . separator ) ) { dirPath = dirPath + File . separator ; } if ( filePath . startsWith ( dirPath ) ) { relPath = filePath . substring ( dirPath . length ( ) ) ; } else { relPath = filePath ; } return relPath ; }
public boolean init ( ) { log . config ( STR_ ) ; MClient client = MClient . get ( Env . getCtx ( ) ) ; String ASPFilter = STR_ ; if ( client . isUseASP ( ) ) ASPFilter = STR_ + STR_ + STR_ + STR_ + STR_ + client . getAD_Client_ID ( ) + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + client . getAD_Client_ID ( ) + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + client . getAD_Client_ID ( ) + STR_ + STR_ + STR_ + STR_ + STR_ ; String sql = null ; if ( Env . isBaseLanguage ( Env . getCtx ( ) , STR_ ) ) sql = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + ASPFilter + STR_ ; else sql = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + Env . getAD_Language ( Env . getCtx ( ) ) + STR_ + STR_ + ASPFilter + STR_ ; boolean hasFields = BOOL_ ; Rows rows = new Rows ( ) ; try { PreparedStatement pstmt = DB . prepareStatement ( sql , null ) ; pstmt . setInt ( NUM_ , m_processInfo . getAD_Process_ID ( ) ) ; ResultSet rs = pstmt . executeQuery ( ) ; while ( rs . next ( ) ) { hasFields = BOOL_ ; createField ( rs , rows ) ; isPair = ! isPair ; } rs . close ( ) ; pstmt . close ( ) ; } catch ( SQLException e ) { log . log ( Level . SEVERE , sql , e ) ; } if ( m_mFields . size ( ) != m_mFields2 . size ( ) || m_mFields . size ( ) != m_wEditors . size ( ) || m_mFields2 . size ( ) != m_wEditors2 . size ( ) ) log . log ( Level . SEVERE , STR_ ) ; if ( hasFields ) { centerPanel . appendChild ( rows ) ; dynamicDisplay ( ) ; } else dispose ( ) ; return hasFields ; }
private static String doNormalize ( String filename , char separator , boolean keepSeparator ) { if ( filename == null ) { return null ; } int size = filename . length ( ) ; if ( size == NUM_ ) { return filename ; } int prefix = getPrefixLength ( filename ) ; if ( prefix < NUM_ ) { return null ; } char [ ] array = new char [ size + NUM_ ] ; filename . getChars ( NUM_ , filename . length ( ) , array , NUM_ ) ; char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ; for ( int i = NUM_ ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; } } boolean lastIsDirectory = BOOL_ ; if ( array [ size - NUM_ ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = BOOL_ ; } for ( int i = prefix + NUM_ ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - NUM_ ] == separator ) { System . arraycopy ( array , i , array , i - NUM_ , size - i ) ; size -- ; i -- ; } } for ( int i = prefix + NUM_ ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - NUM_ ] == STR_ && ( i == prefix + NUM_ || array [ i - NUM_ ] == separator ) ) { if ( i == size - NUM_ ) { lastIsDirectory = BOOL_ ; } System . arraycopy ( array , i + NUM_ , array , i - NUM_ , size - i ) ; size -= NUM_ ; i -- ; } } outer : for ( int i = prefix + NUM_ ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - NUM_ ] == STR_ && array [ i - NUM_ ] == STR_ && ( i == prefix + NUM_ || array [ i - NUM_ ] == separator ) ) { if ( i == prefix + NUM_ ) { return null ; } if ( i == size - NUM_ ) { lastIsDirectory = BOOL_ ; } int j ; for ( j = i - NUM_ ; j >= prefix ; j -- ) { if ( array [ j ] == separator ) { System . arraycopy ( array , i + NUM_ , array , j + NUM_ , size - i ) ; size -= i - j ; i = j + NUM_ ; continue outer ; } } System . arraycopy ( array , i + NUM_ , array , prefix , size - i ) ; size -= i + NUM_ - prefix ; i = prefix + NUM_ ; } } if ( size <= NUM_ ) { return STR_ ; } if ( size <= prefix ) { return new String ( array , NUM_ , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , NUM_ , size ) ; } return new String ( array , NUM_ , size - NUM_ ) ; }
public void resetSingleton ( ) { root = null ; tmpFileCounter . set ( NUM_ ) ; accessedFiles . clear ( ) ; shouldAllThrowIOException = BOOL_ ; classesThatShouldThrowIOException . clear ( ) ; synchronized ( leakingResources ) { for ( LeakingResource resource : leakingResources ) { try { resource . release ( ) ; } catch ( Exception e ) { logger . warn ( STR_ + e . getMessage ( ) , e ) ; } } leakingResources . clear ( ) ; } }
public void testAndNotNegNegFirstLonger ( ) { byte aBytes [ ] = { - NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ } ; byte bBytes [ ] = { - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = - NUM_ ; int bSign = - NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . andNot ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public static String generateStringOfCharacters ( int count ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = NUM_ ; i < count ; i ++ ) { sb . append ( CHARACTERS . charAt ( ( int ) ( Math . random ( ) . CHARACTERS . length ( ) ) ) ) ; } return sb . toString ( ) ; }
private ExchangeRateManager ( ) { if ( System . getProperty ( STR_ ) == null ) throw new UnsupportedOperationException ( STR_ ) ; addKnownRates ( ) ; }
public void removeAttribute ( String name ) { if ( name != null ) if ( attributesList != null ) { for ( int i = NUM_ ; i < attributesList . size ( ) ; i ++ ) { Object o = attributesList . elementAt ( i ) ; if ( o instanceof AttributeField ) { AttributeField a = ( AttributeField ) o ; try { String n = a . getName ( ) ; if ( n != null ) { if ( name . equals ( n ) ) { attributesList . remove ( a ) ; } } } catch ( SdpParseException e ) { } } } } }
@ Override public void evict ( String key ) { key = safetyKey ( key ) ; final File file = new File ( cacheDirectory , key ) ; file . delete ( ) ; }
public static boolean isUniqueContraintError ( Exception e ) { if ( DB . isPostgreSQL ( ) ) return isSQLState ( e , STR_ ) ; return isErrorCode ( e , NUM_ ) ; }
ConfigurationError ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; }
void addFillComponents ( Container panel , int [ ] cols , int [ ] rows ) { Dimension filler = new Dimension ( NUM_ , NUM_ ) ; boolean filled_cell_11 = BOOL_ ; CellConstraints cc = new CellConstraints ( ) ; if ( cols . length > NUM_ && rows . length > NUM_ ) { if ( cols [ NUM_ ] == NUM_ && rows [ NUM_ ] == NUM_ ) { panel . add ( Box . createRigidArea ( filler ) , cc . xy ( NUM_ , NUM_ ) ) ; filled_cell_11 = BOOL_ ; } } for ( int index = NUM_ ; index < cols . length ; index ++ ) { if ( cols [ index ] == NUM_ && filled_cell_11 ) { continue ; } panel . add ( Box . createRigidArea ( filler ) , cc . xy ( cols [ index ] , NUM_ ) ) ; } for ( int index = NUM_ ; index < rows . length ; index ++ ) { if ( rows [ index ] == NUM_ && filled_cell_11 ) { continue ; } panel . add ( Box . createRigidArea ( filler ) , cc . xy ( NUM_ , rows [ index ] ) ) ; } }
private void insertUsedContextPrefixes ( ) { int unknownPrefixesCount = unknownPrefixesInXMLLiteral . size ( ) ; if ( unknownPrefixesCount > NUM_ ) { StringBuilder contextPrefixes = new StringBuilder ( NUM_ ) ; ElementInfo topElement = peekStack ( ) ; for ( int i = NUM_ ; i < unknownPrefixesCount ; i ++ ) { String prefix = unknownPrefixesInXMLLiteral . get ( i ) ; String namespace = topElement . getNamespace ( prefix ) ; if ( namespace != null ) { appendNamespaceDecl ( contextPrefixes , prefix , namespace ) ; } } int endOfFirstStartTag = charBuf . indexOf ( STR_ ) ; charBuf . insert ( endOfFirstStartTag , contextPrefixes . toString ( ) ) ; } unknownPrefixesInXMLLiteral . clear ( ) ; }
public void addPutTimeNanos ( long duration ) { putTimeNanos . addAndGet ( duration ) ; if ( delegate != null ) delegate . addPutTimeNanos ( duration ) ; }
public static List < Integer > precomputeHashes ( byte [ ] data , long tweak ) { ArrayList < Integer > list = new ArrayList < > ( MAX_HASH_FUNCS ) ; for ( int i = NUM_ ; i < MAX_HASH_FUNCS ; ++ i ) { list . add ( murmurhash3bit ( i , data , tweak ) ) ; } return list ; }
@ RequestProcessing ( value = STR_ , method = HTTPRequestMethod . GET ) @ Before ( adviceClass = { StopwatchStartAdvice . class , AnonymousViewCheck . class , UserBlockCheck . class } ) @ After ( adviceClass = StopwatchEndAdvice . class ) public void showHomeFollowingTags ( final HTTPRequestContext context , final HttpServletRequest request , final HttpServletResponse response , final String userName ) throws Exception { final JSONObject user = ( JSONObject ) request . getAttribute ( User . USER ) ; request . setAttribute ( Keys . TEMAPLTE_DIR_NAME , Symphonys . get ( STR_ ) ) ; final AbstractFreeMarkerRenderer renderer = new SkinRenderer ( ) ; context . setRenderer ( renderer ) ; renderer . setTemplateName ( STR_ ) ; final Map < String , Object > dataModel = renderer . getDataModel ( ) ; filler . fillHeaderAndFooter ( request , response , dataModel ) ; String pageNumStr = request . getParameter ( STR_ ) ; if ( Strings . isEmptyOrNull ( pageNumStr ) || ! Strings . isNumeric ( pageNumStr ) ) { pageNumStr = STR_ ; } final int pageNum = Integer . valueOf ( pageNumStr ) ; final int pageSize = Symphonys . getInt ( STR_ ) ; final int windowSize = Symphonys . getInt ( STR_ ) ; fillHomeUser ( dataModel , user ) ; final String followingId = user . optString ( Keys . OBJECT_ID ) ; dataModel . put ( Follow . FOLLOWING_ID , followingId ) ; avatarQueryService . fillUserAvatarURL ( user ) ; final JSONObject followingTagsResult = followQueryService . getFollowingTags ( followingId , pageNum , pageSize ) ; final List < JSONObject > followingTags = ( List < JSONObject > ) followingTagsResult . opt ( Keys . RESULTS ) ; dataModel . put ( Common . USER_HOME_FOLLOWING_TAGS , followingTags ) ; final boolean isLoggedIn = ( Boolean ) dataModel . get ( Common . IS_LOGGED_IN ) ; if ( isLoggedIn ) { final JSONObject currentUser = ( JSONObject ) dataModel . get ( Common . CURRENT_USER ) ; final String followerId = currentUser . optString ( Keys . OBJECT_ID ) ; final boolean isFollowing = followQueryService . isFollowing ( followerId , followingId ) ; dataModel . put ( Common . IS_FOLLOWING , isFollowing ) ; for ( final JSONObject followingTag : followingTags ) { final String homeUserFollowingTagId = followingTag . optString ( Keys . OBJECT_ID ) ; followingTag . put ( Common . IS_FOLLOWING , followQueryService . isFollowing ( followerId , homeUserFollowingTagId ) ) ; } } user . put ( UserExt . USER_T_CREATE_TIME , new Date ( user . getLong ( Keys . OBJECT_ID ) ) ) ; final int followingTagCnt = followingTagsResult . optInt ( Pagination . PAGINATION_RECORD_COUNT ) ; final int pageCount = ( int ) Math . ceil ( followingTagCnt / ( double ) pageSize ) ; final List < Integer > pageNums = Paginator . paginate ( pageNum , pageSize , pageCount , windowSize ) ; if ( ! pageNums . isEmpty ( ) ) { dataModel . put ( Pagination . PAGINATION_FIRST_PAGE_NUM , pageNums . get ( NUM_ ) ) ; dataModel . put ( Pagination . PAGINATION_LAST_PAGE_NUM , pageNums . get ( pageNums . size ( ) - NUM_ ) ) ; } dataModel . put ( Pagination . PAGINATION_CURRENT_PAGE_NUM , pageNum ) ; dataModel . put ( Pagination . PAGINATION_PAGE_COUNT , pageCount ) ; dataModel . put ( Pagination . PAGINATION_PAGE_NUMS , pageNums ) ; }
public int elevationAt ( float lat , float lon ) { if ( frame_is_valid == BOOL_ ) { if ( lat >= dsi . sw_lat && lat <= dsi . ne_lat && lon >= dsi . sw_lon && lon <= dsi . ne_lon ) { int lat_index = Math . round ( ( lat - dsi . sw_lat ) . NUM_ / uhl . lat_post_interval ) ; int lon_index = Math . round ( ( lon - dsi . sw_lon ) . NUM_ / uhl . lon_post_interval ) ; if ( elevations [ lon_index ] == null ) readDataRecord ( lon_index ) ; return ( int ) elevations [ lon_index ] [ lat_index ] ; } } return - NUM_ ; }
ObservedObject createObservedObject ( ObjectName object ) { return new ObservedObject ( object ) ; }
private void deleteChildren ( Element container ) { while ( container . hasChildNodes ( ) ) { container . removeChild ( container . getLastChild ( ) ) ; } }
private void saveInitialChildState ( FacesContext facesContext , UIComponent component ) { if ( component instanceof EditableValueHolder && ! component . isTransient ( ) ) { String clientId = component . getClientId ( facesContext ) ; SavedState state = new SavedState ( ) ; initialChildState . put ( clientId , state ) ; state . populate ( ( EditableValueHolder ) component ) ; } Iterator < UIComponent > iterator = component . getFacetsAndChildren ( ) ; while ( iterator . hasNext ( ) ) { saveChildState ( facesContext , iterator . next ( ) ) ; } }
public boolean is_overlap ( ) { Set < BrdItem > start_contacts = get_start_contacts ( ) ; Set < BrdItem > end_contacts = get_end_contacts ( ) ; for ( BrdItem end_contact : end_contacts ) { if ( start_contacts . contains ( end_contact ) ) return BOOL_ ; } return BOOL_ ; }
static Object ensureNotNull ( Location location , Object value ) { if ( value == null ) { throw new EvalException ( location , STR_ ) ; } return value ; }
public static final ArrayList readListXml ( InputStream in ) throws XmlPullParserException , IOException { XmlPullParser parser = Xml . newPullParser ( ) ; parser . setInput ( in , null ) ; return ( ArrayList ) readValueXml ( parser , new String [ NUM_ ] ) ; }
private static String padRight ( String s , int minLength ) { return String . format ( STR_ + minLength + STR_ , s ) ; }
@ Override public Enumeration < String > enumerateMeasures ( ) { Vector < String > newVector = new Vector < String > ( NUM_ ) ; newVector . addElement ( STR_ ) ; return newVector . elements ( ) ; }
protected synchronized void onSendTaskCompleted ( RecordBuffer < R > buffer ) { logger . trace ( STR_ , name ( ) , buffer ) ; activeSendTasks . decrementAndGet ( ) ; }
public void addPreferencesButton ( ) { JButton prefsButton = new JButton ( STR_ ) ; prefsButton . setHideActionText ( BOOL_ ) ; prefsButton . setAction ( RasterPlotActions . getPropertiesDialogAction ( this ) ) ; buttonPanel . add ( prefsButton ) ; }
public void clearUnused ( ConfigImpl config ) { SystemOut . printDate ( config . getOutWriter ( ) , STR_ + size ( ) + STR_ + maxSize + STR_ ) ; if ( size ( ) > maxSize ) { Object [ ] keys = keys ( ) ; LongKeyList list = new LongKeyList ( ) ; for ( int i = NUM_ ; i < keys . length ; i ++ ) { PageSource ps = getPageSource ( keys [ i ] , BOOL_ ) ; long updateTime = ps . getLastAccessTime ( ) ; if ( updateTime + timeout < System . currentTimeMillis ( ) ) { long add = ( ( ps . getAccessCount ( ) - NUM_ ) . NUM_ ) ; if ( add > timeout ) add = timeout ; list . add ( updateTime + add , keys [ i ] ) ; } } while ( size ( ) > maxSize ) { Object key = list . shift ( ) ; if ( key == null ) break ; remove ( key ) ; } } }
public static GridField [ ] createFields ( Properties ctx , int WindowNo , int TabNo , int AD_Tab_ID ) { ArrayList < GridFieldVO > listVO = new ArrayList < GridFieldVO > ( ) ; int AD_Window_ID = NUM_ ; boolean readOnly = BOOL_ ; String sql = GridFieldVO . getSQL ( ctx ) ; PreparedStatement pstmt = null ; try { pstmt = DB . prepareStatement ( sql , null ) ; pstmt . setInt ( NUM_ , AD_Tab_ID ) ; ResultSet rs = pstmt . executeQuery ( ) ; while ( rs . next ( ) ) { GridFieldVO vo = GridFieldVO . create ( ctx , WindowNo , TabNo , AD_Window_ID , AD_Tab_ID , readOnly , rs ) ; listVO . add ( vo ) ; } rs . close ( ) ; pstmt . close ( ) ; pstmt = null ; } catch ( Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } try { if ( pstmt != null ) pstmt . close ( ) ; pstmt = null ; } catch ( Exception e ) { pstmt = null ; } GridField [ ] retValue = new GridField [ listVO . size ( ) ] ; for ( int i = NUM_ ; i < listVO . size ( ) ; i ++ ) retValue [ i ] = new GridField ( ( GridFieldVO ) listVO . get ( i ) ) ; return retValue ; }
public ShortInterleavedRaster ( SampleModel sampleModel , DataBuffer dataBuffer , Point origin ) { this ( sampleModel , dataBuffer , new Rectangle ( origin . x , origin . y , sampleModel . getWidth ( ) , sampleModel . getHeight ( ) ) , origin , null ) ; }
private void copyCarbonDataFileToCarbonStorePath ( String localFileName ) throws CarbonDataWriterException { long copyStartTime = System . currentTimeMillis ( ) ; LOGGER . info ( STR_ + localFileName + STR_ + carbonDataDirectoryPath ) ; try { CarbonFile localCarbonFile = FileFactory . getCarbonFile ( localFileName , FileFactory . getFileType ( localFileName ) ) ; String carbonFilePath = carbonDataDirectoryPath + localFileName . substring ( localFileName . lastIndexOf ( File . separator ) ) ; copyLocalFileToCarbonStore ( carbonFilePath , localFileName , CarbonCommonConstants . BYTEBUFFER_SIZE , getMaxOfBlockAndFileSize ( fileSizeInBytes , localCarbonFile . getSize ( ) ) ) ; } catch ( IOException e ) { throw new CarbonDataWriterException ( STR_ ) ; } LOGGER . info ( STR_ + localFileName + STR_ + ( System . currentTimeMillis ( ) - copyStartTime ) ) ; }
@ Override public boolean flingBackward ( Selector obj , boolean isVertical ) throws UiObjectNotFoundException { UiScrollable scrollable = new UiScrollable ( obj . toUiSelector ( ) ) ; if ( isVertical ) scrollable . setAsVerticalList ( ) ; else scrollable . setAsHorizontalList ( ) ; return scrollable . flingBackward ( ) ; }
protected static double toDouble ( String s ) { try { return Double . parseDouble ( s ) ; } catch ( Exception e ) { TestCase . fail ( STR_ + s + STR_ + throwableToString ( e ) ) ; return Double . NaN ; } }
public void addListener ( final IFilterPanelListener < T > listener ) { m_listeners . addListener ( listener ) ; }
public void testmirror ( File orig , File origni , File truecolor ) { File mirror = TestSupport . addSuffixToName ( orig , STR_ ) ; File recov = TestSupport . addSuffixToName ( orig , STR_ ) ; long crc0 = NUM_ ; boolean interlaced ; boolean palete ; { PngReader pngr = new PngReader ( orig ) ; PngWriter pngw = null ; try { if ( rand . nextBoolean ( ) ) pngr . setLineSetFactory ( ImageLineSetDefault . getFactoryByte ( ) ) ; palete = pngr . imgInfo . indexed ; pngr . prepareSimpleDigestComputation ( ) ; interlaced = pngr . isInterlaced ( ) ; pngw = new PngWriter ( mirror , pngr . imgInfo , BOOL_ ) ; pngw . setFilterType ( FilterType . FILTER_CYCLIC ) ; pngw . copyChunksFrom ( pngr . getChunksList ( ) ) ; IImageLineSet < ? extends IImageLine > lines = pngr . readRows ( ) ; for ( int row = NUM_ ; row < pngr . imgInfo . rows ; row ++ ) { mirrorLine ( lines . getImageLine ( row ) , pngr . imgInfo ) ; pngw . writeRow ( lines . getImageLine ( row ) ) ; } pngr . end ( ) ; crc0 = PngHelperInternal . getDigest ( pngr ) ; pngw . end ( ) ; } finally { pngr . close ( ) ; if ( pngw != null ) pngw . close ( ) ; } } { PngReader pngr2 = new PngReader ( mirror ) ; PngWriter pngw = null ; try { if ( pngr2 . imgInfo . bitDepth < NUM_ && rand . nextBoolean ( ) ) pngr2 . setLineSetFactory ( ImageLineSetDefault . getFactoryByte ( ) ) ; pngw = new PngWriter ( recov , pngr2 . imgInfo , BOOL_ ) ; pngw . setFilterType ( FilterType . FILTER_DEFAULT ) ; pngw . copyChunksFrom ( pngr2 . getChunksList ( ) ) ; for ( int row = NUM_ ; row < pngr2 . imgInfo . rows ; row ++ ) { IImageLine line = pngr2 . readRow ( ) ; mirrorLine ( line , pngr2 . imgInfo ) ; pngw . writeRow ( line ) ; } pngr2 . end ( ) ; pngw . end ( ) ; } finally { pngr2 . close ( ) ; if ( pngw != null ) pngw . close ( ) ; } } if ( ! interlaced ) TestSupport . testCrcEquals ( recov , crc0 ) ; else TestSupport . testSameCrc ( recov , origni ) ; if ( interlaced ) additionalTestInterlaced ( orig , origni ) ; if ( palete && truecolor . exists ( ) ) additionalTestPalette ( orig , truecolor ) ; }
public boolean isStable ( ) { return myFeatures . contains ( FEATURE_STABLE ) ; }
public static void calcTextSize ( Paint paint , String demoText , FSize outputFSize ) { Rect r = mCalcTextSizeRect ; r . set ( NUM_ , NUM_ , NUM_ , NUM_ ) ; paint . getTextBounds ( demoText , NUM_ , demoText . length ( ) , r ) ; outputFSize . width = r . width ( ) ; outputFSize . height = r . height ( ) ; }
protected void performDefaults ( ) { super . performDefaults ( ) ; initializeValues ( ) ; verifyValidation ( ) ; }
public String toString ( ) { final StringBuilder buf = new StringBuilder ( STR_ ) ; for ( int i = NUM_ , end = _pos - NUM_ ; i < end ; i ++ ) { buf . append ( _data [ i ] ) ; buf . append ( STR_ ) ; } if ( size ( ) > NUM_ ) { buf . append ( _data [ _pos - NUM_ ] ) ; } buf . append ( STR_ ) ; return buf . toString ( ) ; }
public static void write ( int x1 , int y1 , Image image , int image_width , int image_height , LinkProperties properties , DataOutputStream dos ) throws IOException , InterruptedException { int [ ] pixels = new int [ image_width . image_height ] ; PixelGrabber pixelgrabber = new PixelGrabber ( image , NUM_ , NUM_ , image_width , image_height , pixels , NUM_ , image_width ) ; pixelgrabber . grabPixels ( ) ; LinkRaster . write ( x1 , y1 , image_width , image_height , pixels , properties , dos ) ; }
@ SuppressWarnings ( STR_ ) public void testProjectionPredicateDifferentClassLoaders ( ) throws Exception { final Ignite ignite3 = startGrid ( NUM_ ) ; URL [ ] clsLdrUrls ; try { clsLdrUrls = new URL [ ] { new URL ( GridTestProperties . getProperty ( STR_ ) ) } ; } catch ( MalformedURLException e ) { throw new RuntimeException ( STR_ , e ) ; } ClassLoader ldr1 = new URLClassLoader ( clsLdrUrls , getClass ( ) . getClassLoader ( ) ) ; Class taskCls = ldr1 . loadClass ( STR_ ) ; Class nodeFilterCls = ldr1 . loadClass ( STR_ ) ; IgnitePredicate < ClusterNode > nodeFilter = ( IgnitePredicate < ClusterNode > ) nodeFilterCls . getConstructor ( UUID . class ) . newInstance ( ignite2 . cluster ( ) . localNode ( ) . id ( ) ) ; Map < UUID , Integer > ret = ( Map < UUID , Integer > ) executeAsync ( compute ( ignite1 . cluster ( ) . forPredicate ( nodeFilter ) ) , taskCls , null ) . get ( TASK_EXEC_TIMEOUT_MS ) ; assert ret != null ; assert ret . get ( ignite1 . cluster ( ) . localNode ( ) . id ( ) ) != null && ret . get ( ignite1 . cluster ( ) . localNode ( ) . id ( ) ) == NUM_ : ret . get ( ignite1 . cluster ( ) . localNode ( ) . id ( ) ) ; assert ret . get ( ignite3 . cluster ( ) . localNode ( ) . id ( ) ) != null && ret . get ( ignite3 . cluster ( ) . localNode ( ) . id ( ) ) == NUM_ : ret . get ( ignite3 . cluster ( ) . localNode ( ) . id ( ) ) ; }
public void stateChanged ( ChangeEvent evt ) { int scale = slider . getValue ( ) ; value . setText ( STR_ + String . valueOf ( scale ) ) ; size . setText ( STR_ + ( width . scale ) + STR_ + ( height . scale ) + STR_ ) ; preview . repaint ( ) ; }
public static void writeToFile ( String content , File dstFile ) throws IOException { BufferedWriter bufferedWriter = new BufferedWriter ( new FileWriter ( dstFile , BOOL_ ) ) ; bufferedWriter . write ( content ) ; bufferedWriter . close ( ) ; }
public static boolean isFileURL ( URL url ) { String protocol = url . getProtocol ( ) ; return ( URL_PROTOCOL_FILE . equals ( protocol ) || URL_PROTOCOL_VFSFILE . equals ( protocol ) || URL_PROTOCOL_VFS . equals ( protocol ) ) ; }
private void updateStatus ( String relayState , int currentStatus ) { Integer tmp = ( Integer ) currentStatusMap . get ( relayState ) ; if ( tmp != null ) { int previousStatus = tmp . intValue ( ) ; switch ( previousStatus ) { case LOGOUT_SUCCEEDED_STATUS : if ( currentStatus > previousStatus ) { currentStatusMap . put ( relayState , new Integer ( currentStatus ) ) ; } break ; case LOGOUT_FAILED_STATUS : if ( currentStatus < LOGOUT_FAILED_STATUS ) { currentStatusMap . put ( relayState , new Integer ( LOGOUT_PARTIAL_STATUS ) ) ; } break ; default : break ; } } else { currentStatusMap . put ( relayState , new Integer ( currentStatus ) ) ; } }
public static int [ ] oidStrToInts ( String oid ) throws IOException { int length = oid . length ( ) ; if ( oid . charAt ( length - NUM_ ) == STR_ ) { throw new IOException ( STR_ + oid ) ; } int [ ] result = new int [ length / NUM_ + NUM_ ] ; int number = NUM_ ; for ( int i = NUM_ ; i < length ; i ++ ) { int value = NUM_ ; int pos = i ; for ( ; i < length ; i ++ ) { char ch = oid . charAt ( i ) ; if ( ( ch < STR_ ) || ( ch > STR_ ) ) { break ; } value = NUM_ . value + ( ch - STR_ ) ; } if ( i == pos ) { throw new IOException ( STR_ + oid ) ; } result [ number ++ ] = value ; if ( i == length ) { break ; } char ch = oid . charAt ( i ) ; if ( ch != STR_ ) { throw new IOException ( STR_ + oid ) ; } } if ( number < NUM_ ) { throw new IOException ( STR_ + oid ) ; } return Arrays . copyOfRange ( result , NUM_ , number ) ; }
public static Set < String > listServers ( SSOToken ssoToken , String siteName ) throws SMSException , SSOException , ConfigurationException { Set < String > members = new HashSet < > ( ) ; String siteId = getSiteId ( ssoToken , siteName ) ; if ( siteId != null ) { Set < String > allServers = ServerConfiguration . getServers ( ssoToken ) ; for ( String svr : allServers ) { if ( ServerConfiguration . belongToSite ( ssoToken , svr , siteName ) ) { members . add ( svr ) ; } } } return members ; }
public static GenericObjectEditorDialog createDialog ( Container parent ) { return createDialog ( parent , null ) ; }
public static boolean containsInLineFeatures ( StyledLayerDescriptor sld ) { if ( sld != null ) { for ( StyledLayer layer : sld . layers ( ) ) { if ( layer instanceof UserLayer ) { UserLayer userLayer = ( UserLayer ) layer ; if ( userLayer . getInlineFeatureDatastore ( ) != null ) { return BOOL_ ; } } } } return BOOL_ ; }
public byte decodeBuffer ( InputStream in ) [ ] throws IOException { ByteArrayOutputStream outStream = new ByteArrayOutputStream ( ) ; decodeBuffer ( in , outStream ) ; return ( outStream . toByteArray ( ) ) ; }
public static void runFinalization ( ) { RUNTIME . runFinalization ( ) ; }
private void displayAllStringDefinedInStringXml ( ) { SimpleIconFontTextView textView = ( SimpleIconFontTextView ) findViewById ( R . id . text_view_1 ) ; List < String > list = new ArrayList < > ( ) ; list . add ( getString ( R . string . gems_logo ) ) ; String text = TextUtils . join ( STR_ , list ) ; textView . setText ( text ) ; }
public static void checkHTTPRequestLength ( HttpServletRequest request ) throws ServletException { int maxContentLength = SAMLUtils . getMaxContentLength ( ) ; if ( maxContentLength != NUM_ ) { int length = request . getContentLength ( ) ; if ( length == - NUM_ ) { throw new ServletException ( bundle . getString ( STR_ ) ) ; } if ( length > maxContentLength ) { if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + STR_ + length ) ; } throw new ServletException ( bundle . getString ( STR_ ) ) ; } } }
public void addForeignKeyConstraint ( String name , String sourceField , String targetField , String targetTable ) { ForeignKeyConstraint foreignKey = new ForeignKeyConstraint ( name , sourceField , targetField , targetTable ) ; addForeignKeyConstraint ( foreignKey ) ; }
@ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; mHandler = new Handler ( ) ; setContentView ( R . layout . voice_recognition ) ; Button speakButton = ( Button ) findViewById ( R . id . btn_speak ) ; mList = ( ListView ) findViewById ( R . id . list ) ; mSupportedLanguageView = ( Spinner ) findViewById ( R . id . supported_languages ) ; PackageManager pm = getPackageManager ( ) ; List < ResolveInfo > activities = pm . queryIntentActivities ( new Intent ( RecognizerIntent . ACTION_RECOGNIZE_SPEECH ) , NUM_ ) ; if ( activities . size ( ) != NUM_ ) { speakButton . setOnClickListener ( this ) ; } else { speakButton . setEnabled ( BOOL_ ) ; speakButton . setText ( STR_ ) ; } refreshVoiceSettings ( ) ; }
public void push ( Notification notification , NotificationResponseListener listener ) { final String notificationTopic = notification . getTopic ( ) ; final String topic = notificationTopic == null ? defaultTopic : notificationTopic ; Request req = Utils . buildRequest ( client , topic , notification , gateway ) ; semaphore . acquireUninterruptibly ( ) ; req . send ( new ResponseListener ( semaphore , notification , listener ) ) ; }
private static void appendJSONPair ( StringBuilder json , String key , String value ) throws UnsupportedEncodingException { boolean isValueNumeric = BOOL_ ; try { if ( value . equals ( STR_ ) || ! value . endsWith ( STR_ ) ) { Double . parseDouble ( value ) ; isValueNumeric = BOOL_ ; } } catch ( NumberFormatException e ) { isValueNumeric = BOOL_ ; } if ( json . charAt ( json . length ( ) - NUM_ ) != STR_ ) { json . append ( STR_ ) ; } json . append ( escapeJSON ( key ) ) ; json . append ( STR_ ) ; if ( isValueNumeric ) { json . append ( value ) ; } else { json . append ( escapeJSON ( value ) ) ; } }
public void updateFromResource ( ) { for ( String resource : resources ) { InputStream is = ClassLoader . getSystemResourceAsStream ( resource ) ; LinkedHashMap < EntryType , LinkedHashMap < String , ConfigEntry > > parseResult = parse ( is ) ; for ( EntryType type : myMap . keySet ( ) ) { LinkedHashMap < String , ConfigEntry > dataMappings = myMap . get ( type ) ; LinkedHashMap < String , ConfigEntry > resourceMappings = parseResult . get ( type ) ; LinkedHashMap < String , ConfigEntry > tempMappings = new LinkedHashMap < String , ConfigEntry > ( ) ; LinkedHashSet < String > keys = new LinkedHashSet < String > ( ) ; keys . addAll ( dataMappings . keySet ( ) ) ; keys . addAll ( resourceMappings . keySet ( ) ) ; for ( String key : keys ) { if ( resourceMappings . containsKey ( key ) ) { tempMappings . put ( key , resourceMappings . get ( key ) ) ; } else { tempMappings . put ( key , dataMappings . get ( key ) ) ; } } myMap . put ( type , tempMappings ) ; } } }
private void deselect ( final int index , final boolean shouldFireEvents ) { checkWidget ( ) ; if ( index < NUM_ || index >= items . size ( ) ) { return ; } final DLItem item = selection . remove ( index ) ; if ( shouldFireEvents ) { fireSelectionEvent ( item ) ; } final List < DLItem > deselectedItems = new ArrayList < DLItem > ( ) ; item . setLastAction ( LAST_ACTION . DESELECTION ) ; deselectedItems . add ( item ) ; if ( shouldFireEvents ) { fireSelectionChangeEvent ( deselectedItems ) ; } redrawTables ( ) ; }
public boolean isLeaf ( Object nd ) { Node node = ( Node ) nd ; return ! node . hasChildNodes ( ) ; }
public void addListener ( Listener listener ) { mListeners . add ( listener ) ; notifyServiceDiscovered ( mMatchingDrones ) ; }
@ Override boolean equals ( Object obj ) ;
private double [ ] parseVector ( String s ) { String [ ] entries = WHITESPACE_PATTERN . split ( s ) ; double [ ] d = new double [ entries . length ] ; for ( int i = NUM_ ; i < entries . length ; i ++ ) { try { d [ i ] = ParseUtil . parseDouble ( entries [ i ] ) ; } catch ( NumberFormatException e ) { throw new AbortException ( STR_ ) ; } } return d ; }
public void test_create_update ( ) throws IOException { final String id = STR_ ; final Map < String , Object > metadata = new HashMap < String , Object > ( ) ; metadata . put ( FileMetadataSchema . ID , id ) ; metadata . put ( STR_ , STR_ ) ; final int version0 ; final long createTime0 ; final byte [ ] expected0 = new byte [ ] { NUM_ , NUM_ , NUM_ } ; { version0 = repo . create ( metadata ) ; metadata . put ( FileMetadataSchema . VERSION , Integer . valueOf ( version0 ) ) ; assertEquals ( STR_ , NUM_ , version0 ) ; RepositoryDocumentImpl doc = ( RepositoryDocumentImpl ) repo . read ( id ) ; createTime0 = doc . getVersionCreateTime ( ) ; Map < String , Object > actual = doc . asMap ( ) ; assertEquals ( STR_ , id , actual . get ( FileMetadataSchema . ID ) ) ; assertEquals ( STR_ , version0 , actual . get ( FileMetadataSchema . VERSION ) ) ; assertEquals ( STR_ , STR_ , actual . get ( STR_ ) ) ; assertEquals ( STR_ , metadata . size ( ) , actual . size ( ) ) ; repo . copyStream ( id , version0 , new ByteArrayInputStream ( expected0 ) ) ; assertEquals ( STR_ , expected0 , read ( repo . inputStream ( id , version0 ) ) ) ; } final int version1 ; final long createTime1 ; final byte [ ] expected1 = new byte [ ] { NUM_ , NUM_ , NUM_ } ; { metadata . put ( STR_ , STR_ ) ; DocumentImpl doc1 = new DocumentImpl ( metadata ) ; doc1 . copyStream ( expected1 ) ; version1 = repo . update ( doc1 ) ; assertEquals ( STR_ , NUM_ , version1 ) ; metadata . put ( FileMetadataSchema . VERSION , Integer . valueOf ( version1 ) ) ; RepositoryDocumentImpl doc = ( RepositoryDocumentImpl ) repo . read ( id ) ; createTime1 = doc . getVersionCreateTime ( ) ; assertNotSame ( STR_ , NUM_ , createTime1 ) ; assertNotSame ( STR_ , createTime0 , createTime1 ) ; Map < String , Object > actual = doc . asMap ( ) ; assertEquals ( STR_ , id , actual . get ( FileMetadataSchema . ID ) ) ; assertEquals ( STR_ , version1 , actual . get ( FileMetadataSchema . VERSION ) ) ; assertEquals ( STR_ , STR_ , actual . get ( STR_ ) ) ; assertEquals ( STR_ , metadata . size ( ) , actual . size ( ) ) ; assertEquals ( STR_ , expected1 , read ( repo . inputStream ( id , version1 ) ) ) ; assertEquals ( STR_ , new byte [ ] { } , read ( repo . inputStream ( id , version0 ) ) ) ; { ITPS tps = repo . readMetadata ( id , createTime1 - NUM_ ) ; ITPV tpv = tps . get ( FileMetadataSchema . VERSION ) ; assertEquals ( STR_ , null , tpv . getValue ( ) ) ; } } }
@ Override public void writeExternal ( ObjectOutput out ) throws IOException { super . writeExternal ( out ) ; out . writeDouble ( knnDistance ) ; }
public SessionWrapper ( Session ses ) { this . ses = ses ; this . time = System . currentTimeMillis ( ) ; }
public static List < BatchResponse > postWithSingleRequest ( final RequestSpecification requestSpec , final ResponseSpecification responseSpec , final BatchRequest br ) { final List < BatchRequest > batchRequests = new ArrayList < > ( ) ; batchRequests . add ( br ) ; final String jsonifiedRequest = BatchHelper . toJsonString ( batchRequests ) ; final List < BatchResponse > response = BatchHelper . postBatchRequestsWithoutEnclosingTransaction ( requestSpec , responseSpec , jsonifiedRequest ) ; Assert . assertNotNull ( response ) ; Assert . assertTrue ( response . size ( ) > NUM_ ) ; return response ; }
public File programDirectory ( ) { return programDirectory ; }
@ Override public void clearRouteSensors ( ) { _controlSensorList = new ArrayList < > ( ) ; }
public static KEYSTORE_TYPE fromString ( String x ) throws ConfigurationException { for ( KEYSTORE_TYPE currentType : KEYSTORE_TYPE . values ( ) ) { if ( x . equalsIgnoreCase ( currentType . toString ( ) ) ) return currentType ; } throw new ConfigurationException ( MessageFormat . format ( STR_ , x ) ) ; }
public ObjectMapper nextLevel ( ObjectMapper level ) { ObjectMapper previous = levelStack . peek ( ) ; levelStack . push ( level ) ; return previous ; }
protected static int toDigit ( final char ch , final int index ) throws HexDecodeException { final int digit = Character . digit ( ch , NUM_ ) ; if ( digit == - NUM_ ) { throw new HexDecodeException ( STR_ + ch + STR_ + index ) ; } return digit ; }
public JSONObject toJson ( ) throws JSONException { JSONObject json = new JSONObject ( ) ; JSONArray jpods = new JSONArray ( ) ; for ( DiasporaPod pod : pods ) { jpods . put ( pod . toJson ( ) ) ; } json . put ( STR_ , jpods ) ; json . put ( STR_ , System . currentTimeMillis ( ) ) ; return json ; }
public static KeyStore load ( File keyStoreFile , Password password ) throws CryptoException , FileNotFoundException { KeyStoreType keyStoreType = null ; try { keyStoreType = CryptoFileUtil . detectKeyStoreType ( new FileInputStream ( keyStoreFile ) ) ; } catch ( FileNotFoundException ex ) { throw ex ; } catch ( IOException ex ) { throw new CryptoException ( res . getString ( STR_ ) , ex ) ; } if ( keyStoreType == null ) { return null ; } return load ( keyStoreFile , password , keyStoreType ) ; }
@ Override public void removePropertyChangeListener ( PropertyChangeListener pcl ) { m_pcSupport . removePropertyChangeListener ( pcl ) ; }
@ VisibleForTesting static boolean isPrecachingEnabled ( Context context ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; return prefs . getBoolean ( PREF_IS_PRECACHING_ENABLED , BOOL_ ) ; }
public void and ( LongBitSet other ) { int pos = Math . min ( numWords , other . numWords ) ; while ( -- pos >= NUM_ ) { bits [ pos ] &= other . bits [ pos ] ; } if ( numWords > other . numWords ) { Arrays . fill ( bits , other . numWords , numWords , NUM_ ) ; } }
@ Override public boolean equals ( Object obj ) { if ( this == obj ) return BOOL_ ; if ( ! ( obj instanceof PrincipalEntry ) ) return BOOL_ ; PrincipalEntry that = ( PrincipalEntry ) obj ; return ( principalClass . equals ( that . principalClass ) && principalName . equals ( that . principalName ) ) ; }
public boolean isValidLockdownProfile ( ) { try { return BOOL_ ; } catch ( IllegalArgumentException e ) { Log . w ( TAG , STR_ , e ) ; return BOOL_ ; } }
private int readServerResponse ( ) throws IOException { StringBuffer replyBuf = new StringBuffer ( NUM_ ) ; int c ; int continuingCode = - NUM_ ; int code ; String response ; serverResponse . setSize ( NUM_ ) ; while ( BOOL_ ) { while ( ( c = in . read ( ) ) != - NUM_ ) { if ( c == STR_ ) { if ( ( c = in . read ( ) ) != STR_ ) { replyBuf . append ( STR_ ) ; } } replyBuf . append ( ( char ) c ) ; if ( c == STR_ ) { break ; } } response = replyBuf . toString ( ) ; replyBuf . setLength ( NUM_ ) ; if ( logger . isLoggable ( PlatformLogger . Level . FINEST ) ) { logger . finest ( STR_ + serverAddr + STR_ + response ) ; } if ( response . length ( ) == NUM_ ) { code = - NUM_ ; } else { try { code = Integer . parseInt ( response . substring ( NUM_ , NUM_ ) ) ; } catch ( NumberFormatException e ) { code = - NUM_ ; } catch ( StringIndexOutOfBoundsException e ) { continue ; } } serverResponse . addElement ( response ) ; if ( continuingCode != - NUM_ ) { if ( code != continuingCode || ( response . length ( ) >= NUM_ && response . charAt ( NUM_ ) == STR_ ) ) { continue ; } else { continuingCode = - NUM_ ; break ; } } else if ( response . length ( ) >= NUM_ && response . charAt ( NUM_ ) == STR_ ) { continuingCode = code ; continue ; } else { break ; } } return code ; }
public static boolean isExtension ( String filename , String [ ] extensions ) { if ( filename == null ) { return BOOL_ ; } if ( extensions == null || extensions . length == NUM_ ) { return indexOfExtension ( filename ) == - NUM_ ; } String fileExt = getExtension ( filename ) ; for ( String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return BOOL_ ; } } return BOOL_ ; }
public FromClause ( Stream streamOne , OuterJoinQualifier outerJoinQualifier , Stream streamTwo ) { this ( streamOne ) ; add ( streamTwo ) ; outerJoinQualifiers . add ( outerJoinQualifier ) ; }
private static void decodeAnsiX12Segment ( BitSource bits , StringBuilder result ) throws FormatException { int [ ] cValues = new int [ NUM_ ] ; do { if ( bits . available ( ) == NUM_ ) { return ; } int firstByte = bits . readBits ( NUM_ ) ; if ( firstByte == NUM_ ) { return ; } parseTwoBytes ( firstByte , bits . readBits ( NUM_ ) , cValues ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { int cValue = cValues [ i ] ; if ( cValue == NUM_ ) { result . append ( STR_ ) ; } else if ( cValue == NUM_ ) { result . append ( STR_ ) ; } else if ( cValue == NUM_ ) { result . append ( STR_ ) ; } else if ( cValue == NUM_ ) { result . append ( STR_ ) ; } else if ( cValue < NUM_ ) { result . append ( ( char ) ( cValue + NUM_ ) ) ; } else if ( cValue < NUM_ ) { result . append ( ( char ) ( cValue + NUM_ ) ) ; } else { throw FormatException . getFormatInstance ( ) ; } } } while ( bits . available ( ) > NUM_ ) ; }
public static KdbDatabase createKdbDatabase ( Credentials credentials , KdbHeader kdbHeader , InputStream inputStream ) throws IOException { DataInput dataInput = new LittleEndianDataInputStream ( inputStream ) ; checkSignature ( dataInput ) ; deserializeHeader ( kdbHeader , dataInput ) ; InputStream decryptedInputStream = kdbHeader . createDecryptedInputStream ( credentials . getKey ( ) , inputStream ) ; MessageDigest digest = Encryption . getMessageDigestInstance ( ) ; DigestInputStream digestInputStream = new DigestInputStream ( decryptedInputStream , digest ) ; dataInput = new LittleEndianDataInputStream ( digestInputStream ) ; KdbDatabase kdbDatabase = new KdbDatabase ( ) ; KdbGroup lastGroup = ( KdbGroup ) kdbDatabase . getRootGroup ( ) ; for ( long group = NUM_ ; group < kdbHeader . getGroupCount ( ) ; group ++ ) { lastGroup = deserializeGroup ( lastGroup , dataInput ) ; } for ( long entry = NUM_ ; entry < kdbHeader . getEntryCount ( ) ; entry ++ ) { deserializeEntry ( kdbDatabase , dataInput ) ; } if ( ! Arrays . equals ( digest . digest ( ) , kdbHeader . getContentHash ( ) ) ) { throw new IllegalStateException ( STR_ ) ; } digestInputStream . close ( ) ; return kdbDatabase ; }
private DiffPart decodeAdd ( final int blockSize_S , final int blockSize_L ) throws UnsupportedEncodingException , DecodingException { if ( blockSize_S < NUM_ || blockSize_L < NUM_ ) { throw new DecodingException ( STR_ + blockSize_S + STR_ + blockSize_L ) ; } int s = r . read ( blockSize_S ) ; int l = r . read ( blockSize_L ) ; ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; for ( int i = NUM_ ; i < l ; i ++ ) { output . write ( r . readByte ( ) ) ; } DiffPart part = new DiffPart ( DiffAction . INSERT ) ; part . setStart ( s ) ; part . setText ( output . toString ( WIKIPEDIA_ENCODING ) ) ; return part ; }
public void sort ( ) { Arrays . sort ( V , NUM_ , size ( ) ) ; }
public void rebuildPanel ( ) { if ( activeWorker != null && ! activeWorker . isDone ( ) ) { activeWorker . cancel ( BOOL_ ) ; } panelImages . removeAll ( ) ; panelImages . revalidate ( ) ; scrollPane . repaint ( ) ; activeWorker = new ImageLoader ( mediaFiles ) ; activeWorker . execute ( ) ; }
protected void processBytes ( byte [ ] buf , int off , int len ) { nBytesIn += len ; if ( len < NUM_ || state . isDone ( ) ) return ; if ( state == State . ROW_READY ) throw new PngjInputException ( STR_ ) ; if ( inf . needsDictionary ( ) || ! inf . needsInput ( ) ) throw new RuntimeException ( STR_ ) ; inf . setInput ( buf , off , len ) ; if ( isCallbackMode ( ) ) { while ( inflateData ( ) ) { int nextRowLen = processRowCallback ( ) ; prepareForNextRow ( nextRowLen ) ; if ( isDone ( ) ) processDoneCallback ( ) ; } } else inflateData ( ) ; }
@ Override protected String toString ( File obj ) { return obj . getAbsolutePath ( ) ; }
public final void goToNextPage ( ) { final boolean isLastPage = viewPager . getCurrentItem ( ) == ( pages . size ( ) - NUM_ ) ; if ( ! isLastPage ) { viewPager . setCurrentItem ( viewPager . getCurrentItem ( ) + NUM_ , BOOL_ ) ; } }
private static InputStream nullInputStream ( ) throws NullPointerException { if ( currentTimeMillis ( ) > NUM_ ) { return null ; } throw new NullPointerException ( ) ; }
public List < TypeId < ? > > asList ( ) { return Collections . unmodifiableList ( Arrays . asList ( types ) ) ; }
private static void deleteRules ( List < String > batchList , List < Rule > rulesToDelete ) { String deleteStatement = STR_ + RULES_TABLE + STR_ ; for ( Rule rule : rulesToDelete ) { batchList . add ( String . format ( deleteStatement , rule . getUid ( ) ) ) ; } }
public boolean isVisited ( Object element ) { return myVisitedElements . containsKey ( element ) ; }
public AwsIotConnection ( AbstractAwsIotClient client ) { this . client = client ; }
public static < T > CompletableFuture < T > exceptionallyCompletedFuture ( Throwable throwable ) { final CompletableFuture < T > future = new CompletableFuture < T > ( ) ; future . completeExceptionally ( throwable ) ; return future ; }
protected void initForecastErrors ( ArrayList < Float > model , TimeSeries . DataSequence data ) { double sumErr = NUM_ ; double sumAbsErr = NUM_ ; double sumAbsPercentErr = NUM_ ; double sumErrSquared = NUM_ ; int processedPoints = NUM_ ; int n = data . size ( ) ; for ( int i = NUM_ ; i < n ; i ++ ) { double error = model . get ( i ) - data . get ( i ) . value ; sumErr += error ; sumAbsErr += Math . abs ( error ) ; sumAbsPercentErr += Math . abs ( error / data . get ( i ) . value ) ; sumErrSquared += error . error ; processedPoints ++ ; } this . bias = sumErr / processedPoints ; this . mad = sumAbsErr / processedPoints ; this . mape = sumAbsPercentErr / processedPoints ; this . mse = sumErrSquared / processedPoints ; this . sae = sumAbsErr ; errorsInit = BOOL_ ; }
public boolean checkModifiers ( MouseEvent e ) { return e . getModifiers ( ) == modifiers ; }
public void emitRetainedVars ( GenerateJsVisitor gen ) { if ( ! retainedVars . isEmpty ( ) ) { gen . out ( STR_ ) ; boolean first = BOOL_ ; for ( String varName : retainedVars ) { if ( ! first ) { gen . out ( STR_ ) ; } first = BOOL_ ; gen . out ( varName ) ; } gen . endLine ( BOOL_ ) ; retainedVars . clear ( ) ; } }
public URI ( String scheme , String authority , String path , String query , String fragment ) throws URISyntaxException { if ( scheme != null && path != null && ! path . isEmpty ( ) && path . charAt ( NUM_ ) != STR_ ) { throw new URISyntaxException ( path , STR_ ) ; } StringBuilder uri = new StringBuilder ( ) ; if ( scheme != null ) { uri . append ( scheme ) ; uri . append ( STR_ ) ; } if ( authority != null ) { uri . append ( STR_ ) ; AUTHORITY_ENCODER . appendEncoded ( uri , authority ) ; } if ( path != null ) { PATH_ENCODER . appendEncoded ( uri , path ) ; } if ( query != null ) { uri . append ( STR_ ) ; ALL_LEGAL_ENCODER . appendEncoded ( uri , query ) ; } if ( fragment != null ) { uri . append ( STR_ ) ; ALL_LEGAL_ENCODER . appendEncoded ( uri , fragment ) ; } parseURI ( uri . toString ( ) , BOOL_ ) ; }
public List < StructuredTranslation > KbestExtractOnHG ( HyperGraph hg , int topN ) { resetState ( ) ; if ( hg == null || hg . goalNode == null ) { return emptyList ( ) ; } final List < StructuredTranslation > kbest = new ArrayList < > ( topN ) ; for ( int k = NUM_ ; k <= topN ; k ++ ) { StructuredTranslation translation = getKthStructuredTranslation ( hg . goalNode , k ) ; if ( translation == null ) { break ; } kbest . add ( translation ) ; } return kbest ; }
@ Override public int read ( ) throws IOException { synchronized ( lock ) { checkNotClosed ( ) ; if ( pos != count ) { return str . charAt ( pos ++ ) ; } return - NUM_ ; } }
public static boolean isSnapshotFullCopySupported ( URI blockSnapURI , DbClient dbClient ) { BlockSnapshot blockObj = dbClient . queryObject ( BlockSnapshot . class , blockSnapURI ) ; StorageSystem storage = dbClient . queryObject ( StorageSystem . class , blockObj . getStorageController ( ) ) ; return ( storage != null && ( storage . deviceIsType ( Type . openstack ) || storage . deviceIsType ( Type . vnxblock ) || storage . deviceIsType ( Type . ibmxiv ) || storage . deviceIsType ( Type . vmax ) ) ) ; }
public Iterable < ServiceDescriptor > listServices ( ) { ArrayList < ServiceDescriptor > serviceDescriptors = new ArrayList < ServiceDescriptor > ( ) ; for ( FileDescriptor fileDescriptor : fileDescriptors ) { serviceDescriptors . addAll ( fileDescriptor . getServices ( ) ) ; } return serviceDescriptors ; }
private String stripCodeValueSentences ( String string ) { return string . replaceAll ( STR_ , STR_ ) ; }
public void testDivideRoundHalfEvenNeg2 ( ) { String a = STR_ ; int aScale = NUM_ ; String b = STR_ ; int bScale = NUM_ ; String c = STR_ ; int resScale = - NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal bNumber = new BigDecimal ( new BigInteger ( b ) , bScale ) ; BigDecimal result = aNumber . divide ( bNumber , resScale , BigDecimal . ROUND_HALF_EVEN ) ; assertEquals ( STR_ , c , result . toString ( ) ) ; assertEquals ( STR_ , resScale , result . scale ( ) ) ; }
public static double quantile ( double p , double alpha , double beta ) { if ( Double . isNaN ( alpha ) || Double . isNaN ( beta ) || Double . isNaN ( p ) || alpha < NUM_ || beta < NUM_ ) { return Double . NaN ; } if ( p < NUM_ || p > NUM_ ) { return Double . NaN ; } if ( p == NUM_ ) { return NUM_ ; } if ( p == NUM_ ) { return NUM_ ; } if ( p > NUM_ ) { return NUM_ - rawQuantile ( NUM_ - p , beta , alpha , logBeta ( beta , alpha ) ) ; } else { return rawQuantile ( p , alpha , beta , logBeta ( alpha , beta ) ) ; } }
public boolean validate ( String cert , String signedData , String signature ) throws NoSuchAlgorithmException , IOException , Exception { byte [ ] certBytes = Base64 . decode ( cert ) ; byte [ ] signedDataBytes = Base64 . decode ( signedData ) ; byte [ ] signatureBytes = Base64 . decode ( signature ) ; return validate ( certBytes , signedDataBytes , signatureBytes ) ; }
private SharedDeployment createNewDeployment ( GridDeploymentMetadata meta , boolean isCache ) { assert Thread . holdsLock ( mux ) ; assert meta . parentLoader ( ) == null ; IgniteUuid ldrId = IgniteUuid . fromUuid ( ctx . localNodeId ( ) ) ; GridDeploymentClassLoader clsLdr ; if ( meta . deploymentMode ( ) == CONTINUOUS || meta . participants ( ) == null ) { clsLdr = new GridDeploymentClassLoader ( ldrId , meta . userVersion ( ) , meta . deploymentMode ( ) , BOOL_ , ctx , ctx . config ( ) . getClassLoader ( ) != null ? ctx . config ( ) . getClassLoader ( ) : U . gridClassLoader ( ) , meta . classLoaderId ( ) , meta . senderNodeId ( ) , comm , ctx . config ( ) . getNetworkTimeout ( ) , log , ctx . config ( ) . getPeerClassLoadingLocalClassPathExclude ( ) , ctx . config ( ) . getPeerClassLoadingMissedResourcesCacheSize ( ) , meta . deploymentMode ( ) == CONTINUOUS , BOOL_ ) ; if ( meta . participants ( ) != null ) for ( Map . Entry < UUID , IgniteUuid > e : meta . participants ( ) . entrySet ( ) ) clsLdr . register ( e . getKey ( ) , e . getValue ( ) ) ; if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + STR_ + clsLdr + STR_ + meta + STR_ ) ; } else { assert meta . deploymentMode ( ) == SHARED ; clsLdr = new GridDeploymentClassLoader ( ldrId , meta . userVersion ( ) , meta . deploymentMode ( ) , BOOL_ , ctx , U . gridClassLoader ( ) , meta . participants ( ) , comm , ctx . config ( ) . getNetworkTimeout ( ) , log , ctx . config ( ) . getPeerClassLoadingLocalClassPathExclude ( ) , ctx . config ( ) . getPeerClassLoadingMissedResourcesCacheSize ( ) , BOOL_ , BOOL_ ) ; if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + STR_ + clsLdr + STR_ + meta + STR_ ) ; } SharedDeployment dep = new SharedDeployment ( meta . deploymentMode ( ) , clsLdr , ldrId , meta . userVersion ( ) , meta . alias ( ) ) ; if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + dep ) ; if ( isCache ) { List < SharedDeployment > deps = F . addIfAbsent ( cache , meta . userVersion ( ) , new LinkedList < SharedDeployment > ( ) ) ; assert deps != null ; deps . add ( dep ) ; if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + cache ) ; } return dep ; }
public int size ( ) { return seq . size ( ) ; }
public void testAddServletRunAsRole ( ) throws Exception { String xml = WEBAPP_TEST_HEADER + STR_ + STR_ + STR_ + STR_ + STR_ ; WebXml webXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( xml . getBytes ( STR_ ) ) , getEntityResolver ( ) ) ; WebXmlUtils . addServletRunAsRoleName ( webXml , STR_ , STR_ ) ; String roleName = WebXmlUtils . getServletRunAsRoleName ( webXml , STR_ ) ; assertEquals ( STR_ , roleName ) ; }
public void testCase15 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = - NUM_ ; int bSign = - NUM_ ; byte rBytes [ ] = { - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . subtract ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( - NUM_ , result . signum ( ) ) ; }
public MultiTermQuery ( final String field ) { this . field = Objects . requireNonNull ( field , STR_ ) ; }
public static void printLine ( Object message ) { if ( ! isDisabled ( ) ) { printLine ( String . valueOf ( message ) ) ; } }
public void accumulate ( TaggedLogAPIEntity entity ) throws Exception { AggregateAPIEntity current = root ; for ( String groupby : groupbys ) { String tagv = locateGroupbyField ( groupby , entity ) ; if ( tagv == null || tagv . isEmpty ( ) ) { tagv = UNASSIGNED_GROUPBY_ROOT_FIELD_NAME ; } Map < String , AggregateAPIEntity > children = current . getEntityList ( ) ; if ( children . get ( tagv ) == null ) { children . put ( tagv , factory . create ( ) ) ; current . setNumDirectDescendants ( current . getNumDirectDescendants ( ) + NUM_ ) ; } AggregateAPIEntity child = children . get ( tagv ) ; if ( counting ) count ( child ) ; for ( String sumFunctionField : sumFunctionFields ) { sum ( child , entity , sumFunctionField ) ; } current = child ; } }
public void testInvalidXml ( ) throws Exception { testInvalidGpx ( INVALID_XML_GPX ) ; }
public String toString ( boolean expand ) { StringBuilder acc = new StringBuilder ( ) ; toString ( acc , NUM_ , expand ) ; return acc . toString ( ) ; }
public static boolean isAccessorPair ( TMember member , TMember member2 ) { return ( member instanceof TGetter && member2 instanceof TSetter ) || ( member instanceof TSetter && member2 instanceof TGetter ) ; }
public static DateFormat createUTCDateFormatter ( String dateFormat ) { DateFormat formatter = new SimpleDateFormat ( dateFormat ) ; formatter . setTimeZone ( TimeZone . getTimeZone ( STR_ ) ) ; return formatter ; }
public void writeLinkedKml ( final String filename , final KmlType kml ) { if ( filename . equals ( STR_ ) ) { throw new IllegalArgumentException ( STR_ ) ; } if ( filename . equals ( STR_ ) ) { throw new IllegalArgumentException ( STR_ ) ; } writeKml ( filename , kml ) ; }
String destinationFilePath ( ) { return destinationFilePath ; }
@ Override public void refreshUsersOrGroupsListFromServer ( ) { showLoadingDialog ( getString ( R . string . common_loading ) ) ; GetShareWithUsersAsyncTask getTask = new GetShareWithUsersAsyncTask ( this ) ; Object [ ] params = { getFile ( ) , getAccount ( ) , getStorageManager ( ) } ; getTask . execute ( params ) ; }
public BootPanel ( ) { initComponents ( ) ; }
private List < Header > defaultHeaders ( ) { DateFormat dateFormat = new SimpleDateFormat ( STR_ ) ; List < Header > headers = new ArrayList < > ( ) ; headers . add ( new BasicHeader ( STR_ , dateFormat . format ( new Date ( ) ) ) ) ; return headers ; }
public AemParsys clear ( ) { List < WebElement > list = currentScope . findElements ( By . cssSelector ( SELECTOR_FOR_COMPONENT_IN_PARSYS ) ) ; list . forEach ( null ) ; return this ; }
protected RequestHandle sendRequest ( DefaultHttpClient client , HttpContext httpContext , HttpUriRequest uriRequest , String contentType , ResponseHandlerInterface responseHandler , Context context ) { if ( contentType != null ) { uriRequest . setHeader ( STR_ , contentType ) ; } responseHandler . setRequestHeaders ( uriRequest . getAllHeaders ( ) ) ; responseHandler . setRequestURI ( uriRequest . getURI ( ) ) ; Future < ? > request = threadPool . submit ( new AsyncHttpRequest ( client , httpContext , uriRequest , responseHandler ) ) ; if ( context != null ) { List < WeakReference < Future < ? > > > requestList = requestMap . get ( context ) ; if ( requestList == null ) { requestList = new LinkedList < WeakReference < Future < ? > > > ( ) ; requestMap . put ( context , requestList ) ; } requestList . add ( new WeakReference < Future < ? > > ( request ) ) ; } return new RequestHandle ( request ) ; }
private void registerNewClient ( JsonObject jData ) { Client newClient = gson . fromJson ( jData , Client . class ) ; if ( newClient . isValid ( ) ) { addClient ( newClient ) ; broadcastNewClient ( newClient ) ; sendClientList ( newClient ) ; } else { logger . log ( Level . WARNING , STR_ ) ; } }
@ Override public void parse ( InputStream in , String baseURI ) throws IOException , RDFParseException , RDFHandlerException { if ( in == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( baseURI == null ) { throw new IllegalArgumentException ( STR_ ) ; } InputSource inputSource = new InputSource ( new BOMInputStream ( in , BOOL_ ) ) ; inputSource . setSystemId ( baseURI ) ; parse ( inputSource ) ; }
public static Date parseDate ( String dateValue , Collection dateFormats ) throws DateParseException { if ( dateValue == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( dateFormats == null ) { dateFormats = DEFAULT_PATTERNS ; } if ( dateValue . length ( ) > NUM_ && dateValue . startsWith ( STR_ ) && dateValue . endsWith ( STR_ ) ) { dateValue = dateValue . substring ( NUM_ , dateValue . length ( ) - NUM_ ) ; } SimpleDateFormat dateParser = null ; final Iterator formatIter = dateFormats . iterator ( ) ; while ( formatIter . hasNext ( ) ) { final String format = ( String ) formatIter . next ( ) ; if ( dateParser == null ) { dateParser = new SimpleDateFormat ( format , Locale . US ) ; dateParser . setTimeZone ( TimeZone . getTimeZone ( STR_ ) ) ; } else { dateParser . applyPattern ( format ) ; } try { return dateParser . parse ( dateValue ) ; } catch ( final ParseException pe ) { } } throw new DateParseException ( STR_ + dateValue ) ; }
public JSONObject remove ( String name ) { if ( name == null ) { throw new NullPointerException ( STR_ ) ; } int index = indexOf ( name ) ; if ( index != - NUM_ ) { table . remove ( index ) ; names . remove ( index ) ; values . remove ( index ) ; } return this ; }
EdgeMap < Block > findLoops ( Deque < Block > code , Map < Block , Block > idom , SetMap < Block , Edge > pred ) { EdgeMap < Block > loops = new EdgeMap < Block > ( ) ; for ( Block b : code ) for ( Edge s : b . succ ( ) ) if ( isLoop ( s , idom ) ) { verboseStatus ( STR_ + s ) ; Block h = s . to ; Set < Block > loop = loops . get ( h ) ; Set < Block > work = new TreeSet < Block > ( ) ; for ( Edge p : pred . get ( h ) ) { if ( isLoop ( p , idom ) && ! loop . contains ( p . from ) && p . from != h ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } while ( ! work . isEmpty ( ) ) { Block x = getBlock ( work ) ; for ( Edge p : pred . get ( x ) ) { if ( p . from != h && ! loop . contains ( p . from ) ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } } } return loops ; }
public int [ ] readLine ( ) { int record [ ] = new int [ MAX_LEN ] ; int checksum = NUM_ ; try { while ( ( ( charIn = buffIn . read ( ) ) == xd ) || ( charIn == xa ) ) { } if ( charIn != STR_ ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + lineNo ) ; } return new int [ ] { - NUM_ } ; } } catch ( IOException e ) { JOptionPane . showMessageDialog ( this , STR_ , STR_ , JOptionPane . ERROR_MESSAGE ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + e . toString ( ) ) ; } } record [ LEN ] = rdHexByte ( ) ; checksum += record [ LEN ] ; record [ ADDRH ] = rdHexByte ( ) ; checksum += record [ ADDRH ] ; record [ ADDRL ] = rdHexByte ( ) ; checksum += record [ ADDRL ] ; record [ TYPE ] = rdHexByte ( ) ; checksum += record [ TYPE ] ; address = ( address & xffff0000 ) + record [ ADDRH ] . NUM_ + record [ ADDRL ] ; type = record [ TYPE ] ; if ( type != END ) { len = record [ LEN ] ; for ( int i = NUM_ ; i <= len ; i ++ ) { record [ TYPE + i ] = rdHexByte ( ) ; checksum += record [ TYPE + i ] ; } } int fileCheck = rdHexByte ( ) ; if ( ( ( checksum + fileCheck ) & xff ) != NUM_ ) { log . error ( STR_ + lineNo ) ; } lineNo ++ ; return record ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
private void generateHiveTestFiles ( ) throws FileNotFoundException { try ( PrintWriter writerA = new PrintWriter ( new File ( testWorkDir , STR_ ) ) ; PrintWriter writerB = new PrintWriter ( new File ( testWorkDir , STR_ ) ) ) { char sep = STR_ ; int idB = NUM_ ; int idA = NUM_ ; int v = NUM_ ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { writerA . print ( idA ++ ) ; writerA . print ( sep ) ; writerA . println ( idB ) ; writerB . print ( idB ++ ) ; writerB . print ( sep ) ; writerB . println ( v += NUM_ ) ; writerB . print ( idB ++ ) ; writerB . print ( sep ) ; writerB . println ( v += NUM_ ) ; } writerA . flush ( ) ; writerB . flush ( ) ; } }
public void renameEditorPanel ( Editor panel ) { if ( panelsList . size ( ) == NUM_ ) { return ; } for ( int i = NUM_ ; i < panelsList . size ( ) ; i ++ ) { Object o = panelsList . get ( i ) ; if ( o == panel ) { JCheckBoxMenuItem r = ( JCheckBoxMenuItem ) panelsSubMenu . getItem ( i ) ; r . setText ( panel . getTitle ( ) ) ; return ; } } }
private boolean fitsAsSingleLine ( int col ) { return ( col + singleLineWidth ( ) <= PcalTLAGen . wrapColumn ) || ( bodyFormulas . sf == null && ( prcdFormulas == null || prcdFormulas . size ( ) == NUM_ ) ) ; }
@ Override protected void before ( ) throws Throwable { previousThreads = Thread . getAllStackTraces ( ) ; }
public void sphericalToWorld ( Vector3 vec ) { if ( pjUnprojected == null ) { String projStr = STR_ + projInfo . getSemiMajorAxis ( ) + STR_ + projInfo . getSemiMinorAxis ( ) + STR_ ; pjUnprojected = Proj4 . newInstance ( projStr ) ; } if ( pjProjected == null ) { pjProjected = Proj4 . newInstance ( proj4String ) ; } try { vec . toArray ( coord ) ; coord [ NUM_ ] = Math . toRadians ( coord [ NUM_ ] ) ; coord [ NUM_ ] = Math . toRadians ( coord [ NUM_ ] ) ; pjUnprojected . transform ( pjProjected , coord ) ; vec . setX ( coord [ NUM_ ] ) ; vec . setY ( coord [ NUM_ ] ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
public String replace ( CharSequence target , CharSequence replacement ) { if ( target == null ) { throw new NullPointerException ( STR_ ) ; } if ( replacement == null ) { throw new NullPointerException ( STR_ ) ; } String targetString = target . toString ( ) ; int matchStart = indexOf ( targetString , NUM_ ) ; if ( matchStart == - NUM_ ) { return this ; } String replacementString = replacement . toString ( ) ; int targetLength = targetString . length ( ) ; if ( targetLength == NUM_ ) { int resultLength = count + ( count + NUM_ ) . replacementString . length ( ) ; StringBuilder result = new StringBuilder ( resultLength ) ; result . append ( replacementString ) ; int end = offset + count ; for ( int i = offset ; i != end ; ++ i ) { result . append ( value [ i ] ) ; result . append ( replacementString ) ; } return result . toString ( ) ; } StringBuilder result = new StringBuilder ( count ) ; int searchStart = NUM_ ; do { result . append ( value , offset + searchStart , matchStart - searchStart ) ; result . append ( replacementString ) ; searchStart = matchStart + targetLength ; } while ( ( matchStart = indexOf ( targetString , searchStart ) ) != - NUM_ ) ; result . append ( value , offset + searchStart , count - searchStart ) ; return result . toString ( ) ; }
public static String encodeUrl ( final String str ) { return encode ( str , STR_ ) ; }
public void drawRenderedImage ( RenderedImage img , AffineTransform xform ) { if ( img == null ) { return ; } mPrintMetrics . drawImage ( this , img ) ; mDrawingArea . addInfinite ( ) ; }
private long buildSize ( int durationInSeconds , LinkInfo linfo ) { long result = - NUM_ ; double bitRateSum = NUM_ ; switch ( linfo . fmt ) { case NUM_ : bitRateSum = NUM_ + NUM_ / NUM_ ; break ; case NUM_ : bitRateSum = NUM_ + NUM_ / NUM_ ; break ; case NUM_ : bitRateSum = NUM_ + NUM_ / NUM_ ; break ; case NUM_ : bitRateSum = NUM_ + NUM_ / NUM_ ; break ; case NUM_ : bitRateSum = NUM_ + NUM_ / NUM_ ; break ; case NUM_ : bitRateSum = NUM_ + NUM_ / NUM_ ; break ; case NUM_ : bitRateSum = NUM_ + NUM_ / NUM_ ; break ; case NUM_ : bitRateSum = NUM_ + NUM_ / NUM_ ; break ; case NUM_ : bitRateSum = NUM_ + NUM_ / NUM_ ; break ; case NUM_ : bitRateSum = NUM_ + NUM_ / NUM_ ; break ; case NUM_ : bitRateSum = NUM_ + NUM_ / NUM_ ; break ; case NUM_ : bitRateSum = NUM_ + NUM_ / NUM_ ; break ; case NUM_ : bitRateSum = NUM_ + NUM_ / NUM_ ; break ; case NUM_ : bitRateSum = NUM_ + NUM_ / NUM_ ; break ; case NUM_ : bitRateSum = NUM_ + NUM_ / NUM_ ; break ; case NUM_ : bitRateSum = NUM_ + NUM_ / NUM_ ; break ; case NUM_ : bitRateSum = NUM_ + NUM_ / NUM_ ; break ; case NUM_ : bitRateSum = NUM_ + NUM_ / NUM_ ; break ; case NUM_ : bitRateSum = NUM_ + NUM_ / NUM_ ; break ; case NUM_ : bitRateSum = NUM_ + NUM_ / NUM_ ; break ; case NUM_ : bitRateSum = NUM_ + NUM_ / NUM_ ; break ; case NUM_ : bitRateSum = NUM_ + NUM_ / NUM_ ; break ; case NUM_ : bitRateSum = NUM_ + NUM_ / NUM_ ; break ; case NUM_ : bitRateSum = NUM_ + NUM_ / NUM_ ; break ; case NUM_ : bitRateSum = NUM_ + NUM_ / NUM_ ; break ; case NUM_ : bitRateSum = NUM_ + NUM_ / NUM_ ; break ; case NUM_ : bitRateSum = NUM_ / NUM_ ; break ; case NUM_ : bitRateSum = NUM_ / NUM_ ; break ; case NUM_ : bitRateSum = NUM_ / NUM_ ; break ; } bitRateSum = bitRateSum . NUM_ . NUM_ ; result = ( long ) ( Math . ceil ( ( bitRateSum . durationInSeconds ) / NUM_ ) ) ; return result ; }
private void skipToEndOfLine ( ) { for ( ; pos < in . length ( ) ; pos ++ ) { char c = in . charAt ( pos ) ; if ( c == STR_ || c == STR_ ) { pos ++ ; break ; } } }
public IndependenceTest indTestSubset ( List vars ) { return null ; }
@ Override public void actOn ( File f ) { BufferedReader reader = null ; try { reader = new BufferedReader ( new FileReader ( f ) ) ; announceSeedsFromReader ( reader ) ; } catch ( FileNotFoundException fnf ) { logger . log ( Level . SEVERE , STR_ , fnf ) ; } finally { IOUtils . closeQuietly ( reader ) ; } }
public static String formatMillis ( int millis ) { String result = STR_ ; int hr = millis / NUM_ ; millis %= NUM_ ; int min = millis / NUM_ ; millis %= NUM_ ; int sec = millis / NUM_ ; if ( hr > NUM_ ) { result += hr + STR_ ; } if ( min >= NUM_ ) { if ( min > NUM_ ) { result += min + STR_ ; } else { result += STR_ + min + STR_ ; } } if ( sec > NUM_ ) { result += sec ; } else { result += STR_ + sec ; } return result ; }
public void addPropertyChangeListener ( String propertyName , PropertyChangeListener listener ) { propertyChangeSupport . addPropertyChangeListener ( propertyName , listener ) ; }
public File createNewFolder ( File containingDir ) throws IOException { if ( containingDir == null ) { throw new IOException ( STR_ ) ; } File newFolder = createFileObject ( containingDir , newFolderString ) ; int i = NUM_ ; while ( newFolder . exists ( ) && i < NUM_ ) { newFolder = createFileObject ( containingDir , MessageFormat . format ( newFolderNextString , new Integer ( i ) ) ) ; i ++ ; } if ( newFolder . exists ( ) ) { throw new IOException ( STR_ + newFolder . getAbsolutePath ( ) ) ; } else { newFolder . mkdirs ( ) ; } return newFolder ; }
public ResourcesPoet addTypedArray ( String name , @ NotNull List < String > values ) { Element element = document . createElement ( STR_ ) ; element . setAttribute ( STR_ , name ) ; for ( String value : values ) { Element valueElement = document . createElement ( STR_ ) ; valueElement . appendChild ( document . createTextNode ( value ) ) ; element . appendChild ( valueElement ) ; } resourceElement . appendChild ( element ) ; return this ; }
public boolean addSubAction ( final ConfAction actionConf ) throws GeneralException , ConfigurationException { if ( actionConf . getType ( ) != null ) { final SubAction sub = SubAction . factory ( actionConf . getType ( ) , actionConf ) ; if ( sub == null ) { if ( Cfg . DEBUG ) { Check . log ( TAG + STR_ + actionConf . getType ( ) ) ; } return BOOL_ ; } list . add ( sub ) ; if ( sub instanceof SubActionSlow ) { setQueue ( MAIN_QUEUE ) ; } return BOOL_ ; } else { if ( Cfg . DEBUG ) { Check . log ( TAG + STR_ ) ; } return BOOL_ ; } }
void fillEntryTree ( Set < PageLeafEntry > entries , Row row ) { int ptr = _rowHead ; byte [ ] buffer = _buffer ; while ( ptr < BLOCK_SIZE ) { int code = buffer [ ptr ] & CODE_MASK ; int len = getLength ( code , row ) ; if ( code == INSERT || code == REMOVE ) { PageLeafEntry entry = new PageLeafEntry ( this , row , ptr , len , code ) ; entries . add ( entry ) ; } ptr += len ; } }
public static < S > boolean containsAtleastOne ( Collection < S > left , Collection < S > right ) { if ( left == null || right == null ) { return BOOL_ ; } for ( S id : left ) { if ( right . contains ( id ) ) { return BOOL_ ; } } return BOOL_ ; }
private boolean processKeyUp ( int keyCode ) { if ( keyCode == KeyEvent . KEYCODE_ESCAPE || keyCode == KeyEvent . KEYCODE_BACK ) { dismiss ( ) ; return BOOL_ ; } else if ( keyCode == KeyEvent . KEYCODE_TAB ) { if ( mInKbMode ) { if ( isTypedTimeFullyLegal ( ) ) { finishKbMode ( BOOL_ ) ; } return BOOL_ ; } } else if ( keyCode == KeyEvent . KEYCODE_ENTER ) { if ( mInKbMode ) { if ( ! isTypedTimeFullyLegal ( ) ) { return BOOL_ ; } finishKbMode ( BOOL_ ) ; } if ( mCallback != null ) { mCallback . onTimeSet ( mTimePicker , mTimePicker . getHours ( ) , mTimePicker . getMinutes ( ) ) ; } dismiss ( ) ; return BOOL_ ; } else if ( keyCode == KeyEvent . KEYCODE_DEL ) { if ( mInKbMode ) { if ( ! mTypedTimes . isEmpty ( ) ) { int deleted = deleteLastTypedKey ( ) ; String deletedKeyStr ; if ( deleted == getAmOrPmKeyCode ( AM ) ) { deletedKeyStr = mAmText ; } else if ( deleted == getAmOrPmKeyCode ( PM ) ) { deletedKeyStr = mPmText ; } else { deletedKeyStr = String . format ( STR_ , getValFromKeyCode ( deleted ) ) ; } Utils . tryAccessibilityAnnounce ( mTimePicker , String . format ( mDeletedKeyFormat , deletedKeyStr ) ) ; updateDisplay ( BOOL_ ) ; } } } else if ( keyCode == KeyEvent . KEYCODE_0 || keyCode == KeyEvent . KEYCODE_1 || keyCode == KeyEvent . KEYCODE_2 || keyCode == KeyEvent . KEYCODE_3 || keyCode == KeyEvent . KEYCODE_4 || keyCode == KeyEvent . KEYCODE_5 || keyCode == KeyEvent . KEYCODE_6 || keyCode == KeyEvent . KEYCODE_7 || keyCode == KeyEvent . KEYCODE_8 || keyCode == KeyEvent . KEYCODE_9 || ( ! mIs24HourMode && ( keyCode == getAmOrPmKeyCode ( AM ) || keyCode == getAmOrPmKeyCode ( PM ) ) ) ) { if ( ! mInKbMode ) { if ( mTimePicker == null ) { Log . e ( TAG , STR_ ) ; return BOOL_ ; } mTypedTimes . clear ( ) ; tryStartingKbMode ( keyCode ) ; return BOOL_ ; } if ( addKeyIfLegal ( keyCode ) ) { updateDisplay ( BOOL_ ) ; } return BOOL_ ; } return BOOL_ ; }
public void assertDurationIsInRange ( long expectedMillis ) { long minimum = ( long ) ( ( double ) expectedMillis . NUM_ ) ; long maximum = Math . max ( ( long ) ( ( double ) expectedMillis . NUM_ ) , NUM_ ) ; long waitMillis = Math . max ( expectedMillis . NUM_ , NUM_ ) ; long duration = getDurationMillis ( waitMillis ) ; if ( duration < minimum ) { Assert . fail ( STR_ + expectedMillis + STR_ + minimum + STR_ + duration ) ; } else if ( duration > maximum ) { Assert . fail ( STR_ + expectedMillis + STR_ + maximum + STR_ + duration ) ; } }
public void logDiff ( String id , String field , String db , String hw ) { StringBuffer diffBuffer = new StringBuffer ( String . format ( STR_ , id , field ) ) ; if ( db == null || db . isEmpty ( ) || db . equalsIgnoreCase ( NO_MATCHING_ENTRY ) ) { diffBuffer . append ( String . format ( STR_ , hw ) ) ; } else if ( hw == null || hw . isEmpty ( ) || hw . equalsIgnoreCase ( NO_MATCHING_ENTRY ) ) { diffBuffer . append ( String . format ( STR_ , db ) ) ; } else { diffBuffer . append ( String . format ( STR_ , db != null ? db : STR_ , hw != null ? hw : STR_ ) ) ; } msgs . append ( diffBuffer . toString ( ) + STR_ ) ; if ( log != null ) { log . info ( diffBuffer . toString ( ) ) ; } }
public FieldFrameBodyIMG ( Lyrics3Image image ) { images . add ( image ) ; }
public AbstractResource ( String mimetype ) { this ( mimetype , System . currentTimeMillis ( ) ) ; }
private Parameters ( ) { for ( Iterator i = arguments . iterator ( ) ; i . hasNext ( ) ; ) { String arg = ( String ) i . next ( ) ; arg = arg . toLowerCase ( ) ; if ( ! arg . startsWith ( STR_ ) ) throw new IllegalArgumentException ( STR_ + arg ) ; int colonIndex = arg . indexOf ( STR_ ) ; String key ; String value ; if ( colonIndex >= NUM_ ) { key = arg . substring ( NUM_ , colonIndex ) ; value = arg . substring ( colonIndex + NUM_ ) ; } else { key = arg . substring ( NUM_ ) ; value = STR_ ; } if ( ! allowedKeys . contains ( key ) ) throw new IllegalArgumentException ( STR_ + arg . substring ( NUM_ ) + STR_ + StringUtil . toCommaDelimitedString ( allowedKeys ) ) ; hashtable . put ( key , value ) ; } for ( Iterator i = requiredKeys . iterator ( ) ; i . hasNext ( ) ; ) { String requiredKey = ( String ) i . next ( ) ; if ( ! hashtable . containsKey ( requiredKey ) ) throw new IllegalArgumentException ( STR_ + requiredKey ) ; } }
public List < TLV > initRespondSmp ( String question , String secret , boolean initiating ) throws OtrException { if ( question != null && ! initiating ) throw new IllegalArgumentException ( STR_ ) ; byte [ ] our_fp = Hex . decode ( keyManager . getLocalFingerprint ( sessionID ) ) ; String remoteFingerprint = keyManager . getRemoteFingerprint ( sessionID ) ; if ( remoteFingerprint == null ) throw new OtrException ( STR_ ) ; byte [ ] their_fp = Hex . decode ( remoteFingerprint ) ; byte [ ] sessionId ; try { sessionId = computeSessionId ( session . getS ( ) ) ; } catch ( SMException ex ) { throw new OtrException ( ex ) ; } byte [ ] bytes = secret . getBytes ( SerializationUtils . UTF8 ) ; int combined_buf_len = NUM_ + sessionId . length + bytes . length ; byte [ ] combined_buf = new byte [ combined_buf_len ] ; combined_buf [ NUM_ ] = NUM_ ; if ( initiating ) { System . arraycopy ( our_fp , NUM_ , combined_buf , NUM_ , NUM_ ) ; System . arraycopy ( their_fp , NUM_ , combined_buf , NUM_ , NUM_ ) ; } else { System . arraycopy ( their_fp , NUM_ , combined_buf , NUM_ , NUM_ ) ; System . arraycopy ( our_fp , NUM_ , combined_buf , NUM_ , NUM_ ) ; } System . arraycopy ( sessionId , NUM_ , combined_buf , NUM_ , sessionId . length ) ; System . arraycopy ( bytes , NUM_ , combined_buf , NUM_ + sessionId . length , bytes . length ) ; MessageDigest sha256 ; try { sha256 = MessageDigest . getInstance ( STR_ ) ; } catch ( NoSuchAlgorithmException ex ) { throw new OtrException ( ex ) ; } byte [ ] combined_secret = sha256 . digest ( combined_buf ) ; byte [ ] smpmsg ; try { if ( initiating ) { smpmsg = SM . step1 ( smstate , combined_secret ) ; } else { smpmsg = SM . step2b ( smstate , combined_secret ) ; } } catch ( SMException ex ) { throw new OtrException ( ex ) ; } if ( question != null ) { bytes = question . getBytes ( SerializationUtils . UTF8 ) ; byte [ ] qsmpmsg = new byte [ bytes . length + NUM_ + smpmsg . length ] ; System . arraycopy ( bytes , NUM_ , qsmpmsg , NUM_ , bytes . length ) ; System . arraycopy ( smpmsg , NUM_ , qsmpmsg , bytes . length + NUM_ , smpmsg . length ) ; smpmsg = qsmpmsg ; } TLV sendtlv = new TLV ( initiating ? ( question != null ? TLV . SMP1Q : TLV . SMP1 ) : TLV . SMP2 , smpmsg ) ; smstate . nextExpected = initiating ? SM . EXPECT2 : SM . EXPECT3 ; return makeTlvList ( sendtlv ) ; }
public RoundedIconGenerator ( int iconWidthPx , int iconHeightPx , int cornerRadiusPx , int backgroundColor , float textSizePx ) { mIconWidthPx = iconWidthPx ; mIconHeightPx = iconHeightPx ; mCornerRadiusPx = cornerRadiusPx ; mBackgroundRect = new RectF ( NUM_ , NUM_ , mIconWidthPx , mIconHeightPx ) ; mBackgroundPaint = new Paint ( Paint . ANTI_ALIAS_FLAG ) ; mBackgroundPaint . setColor ( backgroundColor ) ; mTextPaint = new TextPaint ( Paint . ANTI_ALIAS_FLAG ) ; mTextPaint . setColor ( Color . WHITE ) ; mTextPaint . setFakeBoldText ( BOOL_ ) ; mTextPaint . setTextSize ( textSizePx ) ; FontMetrics textFontMetrics = mTextPaint . getFontMetrics ( ) ; mTextHeight = ( float ) Math . ceil ( textFontMetrics . bottom - textFontMetrics . top ) ; mTextYOffset = - textFontMetrics . top ; }
public static byte [ ] randomBytes ( int size ) { byte [ ] bytes = new byte [ size ] ; seededRandom . nextBytes ( bytes ) ; return bytes ; }
@ Override public String toString ( ) { StringBuffer BfString = new StringBuffer ( ) ; BfString . append ( STR_ ) ; if ( m_starting != null ) { BfString . append ( STR_ ) ; BfString . append ( startSetToString ( ) ) ; BfString . append ( STR_ ) ; } if ( m_threshold != - Double . MAX_VALUE ) { BfString . append ( STR_ + Utils . doubleToString ( m_threshold , NUM_ , NUM_ ) + STR_ ) ; } return BfString . toString ( ) ; }
protected void arraycopy ( byte [ ] buf , int pos , int length ) { mMessage . write ( buf , pos , length ) ; mPosition = mPosition + length ; }
public boolean expired ( ) { return System . currentTimeMillis ( ) - time > DFLT_EXPIRATION_TIMEOUT ; }
public JSONObject put ( String key , boolean value ) throws JSONException { put ( key , value ? Boolean . TRUE : Boolean . FALSE ) ; return this ; }
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; }
private void handleSelection ( View view , Item item , int position ) { if ( ! item . isSelectable ( ) ) { return ; } if ( item . isSelected ( ) && ! mAllowDeselection ) { return ; } boolean selected = BOOL_ ; if ( mPositionBasedStateManagement ) { selected = mSelections . contains ( position ) ; } else { selected = item . isSelected ( ) ; } if ( mSelectWithItemUpdate || view == null ) { if ( ! mMultiSelect ) { deselect ( ) ; } if ( selected ) { deselect ( position ) ; } else { select ( position ) ; } } else { if ( ! mMultiSelect ) { if ( mPositionBasedStateManagement ) { Iterator < Integer > entries = mSelections . iterator ( ) ; while ( entries . hasNext ( ) ) { Integer pos = entries . next ( ) ; if ( pos != position ) { deselect ( pos , entries ) ; } } } else { Set < Integer > selections = getSelections ( ) ; for ( int pos : selections ) { if ( pos != position ) { deselect ( pos ) ; } } } } item . withSetSelected ( ! selected ) ; view . setSelected ( ! selected ) ; if ( mSelectionListener != null ) mSelectionListener . onSelectionChanged ( item , ! selected ) ; if ( mPositionBasedStateManagement ) { if ( selected ) { if ( mSelections . contains ( position ) ) { mSelections . remove ( position ) ; } } else { mSelections . add ( position ) ; } } } }
public boolean canInvoke ( MDepreciationWorkfile assetwk , MAssetAcct assetAcct , int A_Current_Period , BigDecimal Accum_Dep ) { if ( assetwk == null ) { log . warning ( STR_ ) ; return BOOL_ ; } int offset = NUM_ ; int lifePeriods = assetwk . getUseLifeMonths ( assetwk . isFiscal ( ) ) ; boolean ok = ( offset <= A_Current_Period ) ; if ( CLogMgt . isLevelFinest ( ) ) log . finest ( STR_ + A_Current_Period + STR_ + lifePeriods + STR_ + offset + STR_ + ok ) ; return ok ; }
public boolean writeHeader ( OutputStream os ) { try { writeInt ( os , CACHE_MAGIC ) ; writeString ( os , key ) ; writeString ( os , etag == null ? STR_ : etag ) ; writeLong ( os , serverDate ) ; writeLong ( os , lastModified ) ; writeLong ( os , ttl ) ; writeLong ( os , softTtl ) ; writeStringStringMap ( responseHeaders , os ) ; os . flush ( ) ; return BOOL_ ; } catch ( IOException e ) { VolleyLog . d ( STR_ , e . toString ( ) ) ; return BOOL_ ; } }
public byte [ ] bytes ( ) throws HttpRequestException { final ByteArrayOutputStream output = byteStream ( ) ; try { copy ( buffer ( ) , output ) ; } catch ( IOException e ) { throw new HttpRequestException ( e ) ; } return output . toByteArray ( ) ; }
public void fadeOutAllLayers ( ) { mTransitionState = TRANSITION_STARTING ; Arrays . fill ( mIsLayerOn , BOOL_ ) ; invalidateSelf ( ) ; }
public TreeMap < Float , List < List < Integer > > > packModifiedFirstFitDescending ( ) { throw new UnsupportedOperationException ( STR_ ) ; }
public void addTextChangeListener ( final FilterQueryChangeListener textChangeListener ) { listeners . add ( textChangeListener ) ; }
@ Override public Iterator < Profile > iterator ( ) { return profiles . iterator ( ) ; }
private boolean startsWithSpace ( String str ) { return str . length ( ) != NUM_ && str . charAt ( NUM_ ) == STR_ ; }
public String wrap ( String path ) { return uriPrefix + path ; }
private int keyToLevel ( String key ) { String [ ] token = key . split ( STR_ ) ; return ( token . length - NUM_ ) ; }
public boolean mouseDragged ( MouseEvent e ) { if ( grabbed_plot_graphics_ ) { int x = e . getX ( ) ; int y = e . getY ( ) ; int dx = x - prevX ; int dy = y - prevY ; plotX += dx ; plotY += dy ; prevX = x ; prevY = y ; graph . resize ( plotX , plotY , plotWidth , plotHeight ) ; OMGraphicList plotGraphics = graph . getPlotGraphics ( ) ; plotGraphics . generate ( getProjection ( ) , BOOL_ ) ; repaint ( ) ; } return BOOL_ ; }
private void initCachingHttpHeadersFilter ( ServletContext servletContext , EnumSet < DispatcherType > disps ) { log . debug ( STR_ ) ; FilterRegistration . Dynamic cachingHttpHeadersFilter = servletContext . addFilter ( STR_ , new CachingHttpHeadersFilter ( jHipsterProperties ) ) ; cachingHttpHeadersFilter . addMappingForUrlPatterns ( disps , BOOL_ , STR_ ) ; cachingHttpHeadersFilter . addMappingForUrlPatterns ( disps , BOOL_ , STR_ ) ; cachingHttpHeadersFilter . setAsyncSupported ( BOOL_ ) ; }
protected void addCommonComponent ( XMLComponent component ) { if ( fCommonComponents . contains ( component ) ) { return ; } fCommonComponents . add ( component ) ; addRecognizedParamsAndSetDefaults ( component ) ; }
SNode awaitFulfill ( SNode s , boolean timed , long nanos ) { final long deadline = timed ? System . nanoTime ( ) + nanos : NUM_ ; Thread w = Thread . currentThread ( ) ; int spins = ( shouldSpin ( s ) ? ( timed ? maxTimedSpins : maxUntimedSpins ) : NUM_ ) ; for ( ; ; ) { if ( w . isInterrupted ( ) ) s . tryCancel ( ) ; SNode m = s . match ; if ( m != null ) return m ; if ( timed ) { nanos = deadline - System . nanoTime ( ) ; if ( nanos <= NUM_ ) { s . tryCancel ( ) ; continue ; } } if ( spins > NUM_ ) spins = shouldSpin ( s ) ? ( spins - NUM_ ) : NUM_ ; else if ( s . waiter == null ) s . waiter = w ; else if ( ! timed ) LockSupport . park ( this ) ; else if ( nanos > spinForTimeoutThreshold ) LockSupport . parkNanos ( this , nanos ) ; } }
public void load ( GeneralSubtrees generalSubtrees ) { List < GeneralSubtree > generalSubtreesList = generalSubtrees . getGeneralSubtrees ( ) ; Collections . sort ( generalSubtreesList , new GeneralSubtreeBaseComparator ( ) ) ; data = new Object [ generalSubtreesList . size ( ) ] [ NUM_ ] ; int i = NUM_ ; for ( GeneralSubtree generalSubtree : generalSubtreesList ) { data [ i ] [ NUM_ ] = generalSubtree ; data [ i ] [ NUM_ ] = generalSubtree ; data [ i ] [ NUM_ ] = generalSubtree ; i ++ ; } fireTableDataChanged ( ) ; }
@ Override public synchronized int read ( ) { return pos < count ? buffer . charAt ( pos ++ ) & xFF : - NUM_ ; }
public boolean isPingDisabled ( ) { return ( null != healthcheck && ! healthcheck . exists ( ) ) ; }
public static void writeToFile ( File file , String contents ) throws IOException { FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( contents . getBytes ( ) ) ; fos . close ( ) ; }
public void makeTreeOfWritables ( Iterable < Pair < String , Integer > > flatData ) { Text key = new Text ( ) ; for ( Pair < String , Integer > pair : flatData ) { key . set ( pair . key ) ; ArrayList < IntWritable > valList ; if ( ! mockInput . containsKey ( key ) ) { valList = new ArrayList < > ( ) ; mockInput . put ( key , valList ) ; key = new Text ( ) ; } else valList = ( ArrayList < IntWritable > ) mockInput . get ( key ) ; valList . add ( new IntWritable ( pair . value ( ) ) ) ; } }
public static double angle ( Coordinate p0 , Coordinate p1 ) { double dx = p1 . x - p0 . x ; double dy = p1 . y - p0 . y ; return Math . atan2 ( dy , dx ) ; }
public InMemoryCursor ( String [ ] columnNames ) { mCurrentPosition = - NUM_ ; mColumnNames = columnNames ; }
@ Override public boolean isEnabled ( ) { if ( ( attributeSelectionPanel != null ) && ! isValueOnly ( ) ) { return attributeSelectionPanel . isEnabled ( ) ; } else { if ( slider != null ) { return slider . isEnabled ( ) ; } } return BOOL_ ; }
private void renderForeground ( final ExecutionUnit process , final Graphics2D g2 , boolean printing ) { if ( drawHighlight && ! printing && ( model . isDragStarted ( ) || model . isDropTargetSet ( ) && model . isImportDragged ( ) ) || model . isOperatorSourceHovered ( ) ) { switch ( RapidMinerGUI . getDragHighlighteMode ( ) ) { case FULL : case BORDER : drawDragBorder ( process , g2 ) ; break ; case NONE : default : break ; } } }
public ModbusTransaction createTransaction ( ) { ModbusSerialTransaction transaction = new ModbusSerialTransaction ( ) ; transaction . setTransport ( this ) ; return transaction ; }
public void start ( ) { if ( runner == null ) { runner = new Thread ( this , STR_ ) ; runner . start ( ) ; } }
public synchronized int exportObject ( String name , Object obj ) throws CannotCompileException { Class clazz = obj . getClass ( ) ; ExportedObject eo = new ExportedObject ( ) ; eo . object = obj ; eo . methods = clazz . getMethods ( ) ; exportedObjects . addElement ( eo ) ; eo . identifier = exportedObjects . size ( ) - NUM_ ; if ( name != null ) exportedNames . put ( name , eo ) ; try { stubGen . makeProxyClass ( clazz ) ; } catch ( NotFoundException e ) { throw new CannotCompileException ( e ) ; } return eo . identifier ; }
protected final File createDBFFDCDirectory ( ) { File dbffdcDir = new File ( ffdcDirectoryName ) ; if ( ! dbffdcDir . exists ( ) ) { final boolean isDBFFDcDirCreated = dbffdcDir . mkdirs ( ) ; if ( isDBFFDcDirCreated ) { dbffdcDir = new File ( ffdcDirectoryName ) ; return dbffdcDir ; } } else if ( ! dbffdcDir . isDirectory ( ) ) { return null ; } return dbffdcDir ; }
public static String readCharacterSizedString ( InputStream stream ) throws IOException { StringBuilder result = new StringBuilder ( ) ; int strLen = readUINT16 ( stream ) ; int character = stream . read ( ) ; character |= stream . read ( ) << NUM_ ; do { if ( character != NUM_ ) { result . append ( ( char ) character ) ; character = stream . read ( ) ; character |= stream . read ( ) << NUM_ ; } } while ( character != NUM_ || ( result . length ( ) + NUM_ ) > strLen ) ; if ( strLen != ( result . length ( ) + NUM_ ) ) { throw new IllegalStateException ( STR_ ) ; } return result . toString ( ) ; }
protected void processChildren ( QueryNode queryTree ) throws QueryNodeException { List < QueryNode > children = queryTree . getChildren ( ) ; ChildrenList newChildren ; if ( children != null && children . size ( ) > NUM_ ) { newChildren = allocateChildrenList ( ) ; try { for ( QueryNode child : children ) { child = processIteration ( child ) ; if ( child == null ) { throw new NullPointerException ( ) ; } newChildren . add ( child ) ; } List < QueryNode > orderedChildrenList = setChildrenOrder ( newChildren ) ; queryTree . set ( orderedChildrenList ) ; } finally { newChildren . beingUsed = BOOL_ ; } } }
private void initializeMessages ( List < String > messages ) { messages . addAll ( Arrays . asList ( TipOfTheDayMessages . getGeneralMessages ( ) ) ) ; if ( OSUtils . isWindows ( ) ) { messages . addAll ( Arrays . asList ( TipOfTheDayMessages . getWindowsMessages ( ) ) ) ; } else if ( OSUtils . isMacOSX ( ) ) { messages . addAll ( Arrays . asList ( TipOfTheDayMessages . getMacOSXMessages ( ) ) ) ; } else if ( OSUtils . isLinux ( ) ) { messages . addAll ( Arrays . asList ( TipOfTheDayMessages . getLinuxMessages ( ) ) ) ; } else { messages . addAll ( Arrays . asList ( TipOfTheDayMessages . getOtherMessages ( ) ) ) ; } if ( ! OSUtils . isMacOSX ( ) ) { messages . addAll ( Arrays . asList ( TipOfTheDayMessages . getNonMacOSXMessages ( ) ) ) ; } messages . addAll ( Arrays . asList ( TipOfTheDayMessages . getFrostWireMessages ( ) ) ) ; Collections . shuffle ( messages ) ; _currentTip = - NUM_ ; }
public PersistedQueue ( final File queueEnvPath , final String queueName , final int cacheSize ) { queueEnvPath . mkdirs ( ) ; final EnvironmentConfig dbEnvConfig = new EnvironmentConfig ( ) ; dbEnvConfig . setTransactional ( BOOL_ ) ; dbEnvConfig . setAllowCreate ( BOOL_ ) ; this . dbEnv = new Environment ( queueEnvPath , dbEnvConfig ) ; DatabaseConfig dbConfig = new DatabaseConfig ( ) ; dbConfig . setTransactional ( BOOL_ ) ; dbConfig . setAllowCreate ( BOOL_ ) ; dbConfig . setDeferredWrite ( BOOL_ ) ; this . queueDatabase = dbEnv . openDatabase ( null , queueName , dbConfig ) ; this . queueName = queueName ; this . cacheSize = cacheSize ; this . opsCounter = NUM_ ; }
protected final StringBuilder write ( StringBuilder sb , final Object ... objects ) { for ( Object string : objects ) sb . append ( string ) ; return sb ; }
@ Override public boolean connectionAllowed ( EventSetDescriptor esd ) { return connectionAllowed ( esd . getName ( ) ) ; }
public static Request newPostOpenGraphActionRequest ( Session session , OpenGraphAction openGraphAction , Callback callback ) { if ( openGraphAction == null ) { throw new FacebookException ( STR_ ) ; } if ( Utility . isNullOrEmpty ( openGraphAction . getType ( ) ) ) { throw new FacebookException ( STR_ ) ; } String path = String . format ( MY_ACTION_FORMAT , openGraphAction . getType ( ) ) ; return newPostRequest ( session , path , openGraphAction , callback ) ; }
public void showLoading ( ) { switchState ( LOADING , null , null , null , null , null , Collections . < Integer > emptyList ( ) ) ; }
public void readExternal ( ObjectInput in ) throws IOException , ClassNotFoundException { int vocabSize = in . readInt ( ) ; for ( int i = NUM_ ; i < vocabSize ; i ++ ) { String line = in . readUTF ( ) ; Vocabulary . id ( line ) ; } numTokens = in . readDouble ( ) ; countFuncs = new long [ in . readInt ( ) ] [ NUM_ ] ; for ( int i = NUM_ ; i < countFuncs . length ; i ++ ) { countFuncs [ i ] [ NUM_ ] = in . readLong ( ) ; countFuncs [ i ] [ NUM_ ] = in . readLong ( ) ; } typesFuncs = new long [ in . readInt ( ) ] [ NUM_ ] ; for ( int i = NUM_ ; i < typesFuncs . length ; i ++ ) { typesFuncs [ i ] [ NUM_ ] = in . readLong ( ) ; typesFuncs [ i ] [ NUM_ ] = in . readLong ( ) ; } quantizationBase = in . readDouble ( ) ; bf = new BloomFilter ( ) ; bf . readExternal ( in ) ; }
public static double computeMAD ( double [ ] x , double median ) { for ( int i = NUM_ ; i < x . length ; i ++ ) { x [ i ] = Math . abs ( x [ i ] - median ) ; } double mad = QuickSelect . median ( x ) ; if ( ! ( mad > NUM_ ) ) { double min = Double . POSITIVE_INFINITY ; for ( double xi : x ) { if ( xi > NUM_ && xi < min ) { min = xi ; } } if ( min < Double . POSITIVE_INFINITY ) { mad = min ; } else { mad = NUM_ ; } } if ( mad == Double . POSITIVE_INFINITY ) { double max = NUM_ ; for ( double xi : x ) { if ( xi < Double . POSITIVE_INFINITY && xi > max ) { max = xi ; } } if ( max < Double . POSITIVE_INFINITY ) { mad = max ; } else { mad = NUM_ ; } } return mad ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
public SdpException ( Throwable rootCause ) { super ( rootCause . getLocalizedMessage ( ) ) ; }
private boolean linkFirst ( Node < E > node ) { if ( count >= capacity ) return BOOL_ ; Node < E > f = first ; node . next = f ; first = node ; if ( last == null ) last = node ; else f . prev = node ; ++ count ; notEmpty . signal ( ) ; return BOOL_ ; }
protected void notifyPropertyChangeListener ( String property , Object oldValue , Object newValue ) { Set < PropertyChangeListener > v ; synchronized ( this ) { v = new HashSet < > ( listeners ) ; } for ( PropertyChangeListener listener : v ) { listener . propertyChange ( new PropertyChangeEvent ( this , property , oldValue , newValue ) ) ; } }
public boolean indicateDirtyRead ( ITemplateHolder template ) { return ( ( template . isReadOperation ( ) && _useDirtyRead ) || template . isDirtyReadRequested ( ) ) ; }
public JValueSlider ( String title , int min , int max , int value ) { this ( title , new Integer ( min ) , new Integer ( max ) , new Integer ( value ) ) ; m_smin = min ; m_srange = max - min ; m_slider . setMinimum ( min ) ; m_slider . setMaximum ( max ) ; setValue ( new Integer ( value ) ) ; }
protected void applyAttributesToSymbol ( TacticalGraphicAttributes graphicAttributes , TacticalSymbolAttributes symbolAttributes ) { Double value = graphicAttributes . getInteriorOpacity ( ) ; if ( value != null ) { symbolAttributes . setOpacity ( value ) ; } value = graphicAttributes . getScale ( ) ; if ( value != null ) { symbolAttributes . setScale ( value ) ; } Material material = graphicAttributes . getInteriorMaterial ( ) ; symbolAttributes . setInteriorMaterial ( material ) ; Font font = graphicAttributes . getTextModifierFont ( ) ; if ( font != null ) { symbolAttributes . setTextModifierFont ( font ) ; } material = graphicAttributes . getTextModifierMaterial ( ) ; if ( material != null ) { symbolAttributes . setTextModifierMaterial ( material ) ; } }
public final void increaseIdleCount ( IdleStatus status , long currentTime ) { if ( status == IdleStatus . BOTH_IDLE ) { idleCountForBoth . incrementAndGet ( ) ; lastIdleTimeForBoth = currentTime ; } else if ( status == IdleStatus . READER_IDLE ) { idleCountForRead . incrementAndGet ( ) ; lastIdleTimeForRead = currentTime ; } else if ( status == IdleStatus . WRITER_IDLE ) { idleCountForWrite . incrementAndGet ( ) ; lastIdleTimeForWrite = currentTime ; } else { throw new IllegalArgumentException ( STR_ + status ) ; } }
public RemoteServiceDescriptor ( String baseUrl , HttpJsonRequestFactory requestFactory ) throws IllegalArgumentException { this . baseUrl = baseUrl ; this . requestFactory = requestFactory ; try { final URL baseUrlURL = new URL ( baseUrl ) ; final String protocol = baseUrlURL . getProtocol ( ) ; if ( ! ( protocol . equals ( STR_ ) || protocol . equals ( STR_ ) ) ) { throw new IllegalArgumentException ( String . format ( STR_ , baseUrl ) ) ; } } catch ( MalformedURLException e ) { throw new IllegalArgumentException ( String . format ( STR_ , baseUrl ) ) ; } }
private Journal readJournal ( ParcelFileDescriptor oldState ) { Journal journal = new Journal ( ) ; if ( oldState == null ) { return journal ; } FileInputStream inStream = new FileInputStream ( oldState . getFileDescriptor ( ) ) ; try { int availableBytes = inStream . available ( ) ; if ( DEBUG ) Log . d ( TAG , STR_ + availableBytes ) ; if ( availableBytes < MAX_JOURNAL_SIZE ) { byte [ ] buffer = new byte [ availableBytes ] ; int bytesRead = NUM_ ; boolean valid = BOOL_ ; InvalidProtocolBufferNanoException lastProtoException = null ; while ( availableBytes > NUM_ ) { try { int result = inStream . read ( buffer , bytesRead , NUM_ ) ; if ( result > NUM_ ) { availableBytes -= result ; bytesRead += result ; } else { Log . w ( TAG , STR_ ) ; availableBytes = NUM_ ; } } catch ( IOException e ) { buffer = null ; availableBytes = NUM_ ; } try { MessageNano . mergeFrom ( journal , readCheckedBytes ( buffer , bytesRead ) ) ; valid = BOOL_ ; availableBytes = NUM_ ; if ( VERBOSE ) Log . v ( TAG , STR_ + bytesRead + STR_ ) ; } catch ( InvalidProtocolBufferNanoException e ) { lastProtoException = e ; journal . clear ( ) ; } } if ( DEBUG ) Log . d ( TAG , STR_ + bytesRead ) ; if ( ! valid ) { Log . w ( TAG , STR_ , lastProtoException ) ; } } } catch ( IOException e ) { Log . w ( TAG , STR_ , e ) ; } return journal ; }
public Server start ( ) throws SQLException { try { started = BOOL_ ; service . start ( ) ; String name = service . getName ( ) + STR_ + service . getURL ( ) + STR_ ; Thread t = new Thread ( this , name ) ; t . setDaemon ( service . isDaemon ( ) ) ; t . start ( ) ; for ( int i = NUM_ ; i < NUM_ ; i += i ) { wait ( i ) ; if ( isRunning ( BOOL_ ) ) { return this ; } } if ( isRunning ( BOOL_ ) ) { return this ; } throw DbException . get ( ErrorCode . EXCEPTION_OPENING_PORT_2 , name , STR_ + STR_ ) ; } catch ( DbException e ) { throw DbException . toSQLException ( e ) ; } }
@ Override public boolean isComplete ( ) { return BOOL_ ; }
public ByteMatrix encode ( String contents , int width , int height , Map < EncodeHintType , Object > hints ) throws WriterException { if ( contents == null || contents . length ( ) == NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } if ( width < NUM_ || height < NUM_ ) { throw new IllegalArgumentException ( STR_ + width + STR_ + height ) ; } ErrorCorrectionLevel errorCorrectionLevel = ErrorCorrectionLevel . L ; if ( hints != null ) { ErrorCorrectionLevel requestedECLevel = ( ErrorCorrectionLevel ) hints . get ( EncodeHintType . ERROR_CORRECTION ) ; if ( requestedECLevel != null ) { errorCorrectionLevel = requestedECLevel ; } } QRCode code = new QRCode ( ) ; Encoder . encode ( contents , errorCorrectionLevel , hints , code ) ; return renderResult ( code , width , height ) ; }
public IntBuffer put ( int [ ] src , int srcOffset , int intCount ) { if ( isReadOnly ( ) ) { throw new ReadOnlyBufferException ( ) ; } Arrays . checkOffsetAndCount ( src . length , srcOffset , intCount ) ; if ( intCount > remaining ( ) ) { throw new BufferOverflowException ( ) ; } for ( int i = srcOffset ; i < srcOffset + intCount ; ++ i ) { put ( src [ i ] ) ; } return this ; }
public Request header ( String key , String value ) { Objects . requireNonNull ( key ) ; Objects . requireNonNull ( value ) ; _headers . put ( key , value ) ; return this ; }
public void updateUI ( ) { super . updateUI ( ) ; setBackground ( new Color ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; setWrapStyleWord ( BOOL_ ) ; setHighlighter ( null ) ; setEditable ( BOOL_ ) ; LookAndFeel . installBorder ( this , STR_ ) ; LookAndFeel . installColorsAndFont ( this , STR_ , STR_ , STR_ ) ; if ( resizeHandler != null ) { resizeHandler . componentResized ( null ) ; } SizePolicy policy = ( SizePolicy ) getClientProperty ( SizePolicy . class ) ; if ( policy != null ) { GUIUtils . restrictSize ( this , policy ) ; } }
public static void generateExtensionManager ( File rootFolder ) throws IOException { File outFile = new File ( rootFolder , REGISTRY_PATH ) ; StringBuilder builder = new StringBuilder ( ) ; builder . append ( STR_ ) ; generateImports ( builder ) ; generateClass ( builder ) ; FileUtils . writeStringToFile ( outFile , builder . toString ( ) ) ; }
public synchronized Future < V > submit ( Callable < V > task ) throws RejectedExecutionException { return pool . submit ( task ) ; }
private void checkBucketName ( String name ) throws InvalidBucketNameException { if ( name == null ) { throw new InvalidBucketNameException ( NULL_STRING , STR_ ) ; } if ( name . length ( ) < NUM_ || name . length ( ) > NUM_ ) { String msg = STR_ ; throw new InvalidBucketNameException ( name , msg ) ; } if ( name . matches ( STR_ ) ) { String msg = STR_ + STR_ ; throw new InvalidBucketNameException ( name , msg ) ; } if ( ! name . matches ( STR_ ) ) { String msg = STR_ + STR_ ; throw new InvalidBucketNameException ( name , msg ) ; } }
private void validateUserNamespaceAuthorizationCreateRequest ( UserNamespaceAuthorizationCreateRequest request ) { Assert . notNull ( request , STR_ ) ; validateUserNamespaceAuthorizationKey ( request . getUserNamespaceAuthorizationKey ( ) ) ; validateNamespacePermissions ( request . getNamespacePermissions ( ) ) ; }
protected String format ( Object o ) { return o . toString ( ) ; }
public void calculateDerived ( ) { xStats . calculateDerived ( ) ; yStats . calculateDerived ( ) ; differencesStats . calculateDerived ( ) ; correlation = Double . NaN ; if ( ! Double . isNaN ( xStats . stdDev ) && ! Double . isNaN ( yStats . stdDev ) && ! Utils . eq ( xStats . stdDev , NUM_ ) ) { double slope = ( xySum - xStats . sum . yStats . sum / count ) / ( xStats . sumSq - xStats . sum . xStats . mean ) ; if ( ! Utils . eq ( yStats . stdDev , NUM_ ) ) { correlation = slope . xStats . stdDev / yStats . stdDev ; } else { correlation = NUM_ ; } } if ( Utils . gr ( differencesStats . stdDev , NUM_ ) ) { double tval = differencesStats . mean . Math . sqrt ( count ) / differencesStats . stdDev ; if ( m_degreesOfFreedom >= NUM_ ) { differencesProbability = Statistics . FProbability ( tval . tval , NUM_ , m_degreesOfFreedom ) ; } else { if ( count > NUM_ ) { differencesProbability = Statistics . FProbability ( tval . tval , NUM_ , ( int ) count - NUM_ ) ; } else { differencesProbability = NUM_ ; } } } else { if ( differencesStats . sumSq == NUM_ ) { differencesProbability = NUM_ ; } else { differencesProbability = NUM_ ; } } differencesSignificance = NUM_ ; if ( differencesProbability <= sigLevel ) { if ( xStats . mean > yStats . mean ) { differencesSignificance = NUM_ ; } else { differencesSignificance = - NUM_ ; } } }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
protected boolean canDeleteConsistencyGroup ( final BlockConsistencyGroup consistencyGroup ) { return ( ! consistencyGroup . getInactive ( ) && ! consistencyGroup . created ( ) ) ; }
public static void closeQuietly ( Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( RuntimeException rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } }
public AmqpMessage receiveNoWait ( ) throws Exception { checkClosed ( ) ; return prefetch . poll ( ) ; }
@ Override protected void removeRange ( int start , int end ) { if ( start < NUM_ ) { throw new IndexOutOfBoundsException ( STR_ + start ) ; } else if ( end > size ) { throw new IndexOutOfBoundsException ( STR_ + end + STR_ + size ) ; } else if ( start > end ) { throw new IndexOutOfBoundsException ( STR_ + start + STR_ + end ) ; } if ( start == end ) { return ; } if ( end == size ) { Arrays . fill ( array , firstIndex + start , firstIndex + size , null ) ; } else if ( start == NUM_ ) { Arrays . fill ( array , firstIndex , firstIndex + end , null ) ; firstIndex += end ; } else { System . arraycopy ( array , firstIndex + end , array , firstIndex + start , size - end ) ; int lastIndex = firstIndex + size ; int newLast = lastIndex + start - end ; Arrays . fill ( array , newLast , lastIndex , null ) ; } size -= end - start ; modCount ++ ; }
private boolean zzRefill ( ) throws java . io . IOException { if ( zzStartRead > NUM_ ) { System . arraycopy ( zzBuffer , zzStartRead , zzBuffer , NUM_ , zzEndRead - zzStartRead ) ; zzEndRead -= zzStartRead ; zzCurrentPos -= zzStartRead ; zzMarkedPos -= zzStartRead ; zzPushbackPos -= zzStartRead ; zzStartRead = NUM_ ; } if ( zzCurrentPos >= zzBuffer . length ) { final char newBuffer [ ] = new char [ zzCurrentPos . NUM_ ] ; System . arraycopy ( zzBuffer , NUM_ , newBuffer , NUM_ , zzBuffer . length ) ; zzBuffer = newBuffer ; } final int numRead = zzReader . read ( zzBuffer , zzEndRead , zzBuffer . length - zzEndRead ) ; if ( numRead < NUM_ ) { return BOOL_ ; } else { zzEndRead += numRead ; return BOOL_ ; } }
private void checkDuplicateNamesDuringDelete ( List < Integer > ids ) { ArrayList < Entity > myEntities = game . getPlayerEntities ( game . getPlayer ( localPlayerNumber ) , BOOL_ ) ; Hashtable < String , ArrayList < Integer > > rawNameToId = new Hashtable < String , ArrayList < Integer > > ( ( int ) ( myEntities . size ( ) . NUM_ ) ) ; for ( Entity e : myEntities ) { String rawName = e . getShortNameRaw ( ) ; ArrayList < Integer > namedIds = rawNameToId . get ( rawName ) ; if ( namedIds == null ) { namedIds = new ArrayList < Integer > ( ) ; } namedIds . add ( e . getId ( ) ) ; rawNameToId . put ( rawName , namedIds ) ; } for ( int id : ids ) { Entity removedEntity = game . getEntity ( id ) ; if ( removedEntity == null ) { continue ; } String removedRawName = removedEntity . getShortNameRaw ( ) ; Integer count = duplicateNameHash . get ( removedEntity . getShortNameRaw ( ) ) ; if ( ( count != null ) && ( count > NUM_ ) ) { ArrayList < Integer > namedIds = rawNameToId . get ( removedRawName ) ; for ( Integer i : namedIds ) { Entity e = game . getEntity ( i ) ; String eRawName = e . getShortNameRaw ( ) ; if ( eRawName . equals ( removedRawName ) && ( e . duplicateMarker > removedEntity . duplicateMarker ) ) { e . duplicateMarker -- ; e . generateShortName ( ) ; e . generateDisplayName ( ) ; if ( ! ids . contains ( e . getId ( ) ) ) { sendUpdateEntity ( e ) ; } } } duplicateNameHash . put ( removedEntity . getShortNameRaw ( ) , new Integer ( count - NUM_ ) ) ; } else if ( count != null ) { duplicateNameHash . remove ( removedEntity . getShortNameRaw ( ) ) ; } } }
protected void stopBKCluster ( ) throws Exception { if ( bkc != null ) { bkc . close ( ) ; } for ( BookieServer server : bs ) { server . shutdown ( ) ; AutoRecoveryMain autoRecovery = autoRecoveryProcesses . get ( server ) ; if ( autoRecovery != null && isAutoRecoveryEnabled ( ) ) { autoRecovery . shutdown ( ) ; LOG . debug ( STR_ + server . getLocalAddress ( ) ) ; } } bs . clear ( ) ; for ( File f : tmpDirs ) { FileUtils . deleteDirectory ( f ) ; } }
public void or ( Criteria criteria ) { oredCriteria . add ( criteria ) ; }
public void releaseSelections ( Set < Entity > items ) { for ( Entity item : items ) { releaseSelection ( item ) ; } }
public HubLinkMapping ( String fileName , int numberOfHubs , Network network ) { this . numberOfHubs = numberOfHubs ; if ( fileName . contains ( STR_ ) ) { readMappingTable ( fileName ) ; unMappedLinksAtZeroHub = BOOL_ ; return ; } handleUnmappedLinksStart ( ) ; try { FileReader fr = new FileReader ( fileName ) ; BufferedReader br = new BufferedReader ( fr ) ; String line ; StringTokenizer tokenizer ; String token ; int linkId ; line = br . readLine ( ) ; while ( line != null ) { tokenizer = new StringTokenizer ( line ) ; for ( int i = NUM_ ; i < this . numberOfHubs ; i ++ ) { token = tokenizer . nextToken ( ) ; linkId = ( int ) Double . parseDouble ( token ) ; linkHubMapping . put ( Integer . toString ( linkId ) , i ) ; } if ( tokenizer . hasMoreTokens ( ) ) { throw new RuntimeException ( STR_ ) ; } line = br . readLine ( ) ; } } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw new RuntimeException ( STR_ ) ; } linkHubMapping . remove ( STR_ ) ; handleUnmappedLinksEnd ( network ) ; }
public boolean deleteLoadName ( String load ) { if ( ! _loadList . contains ( load ) ) { return BOOL_ ; } _loadList . remove ( load ) ; log . debug ( STR_ + getName ( ) + STR_ + load ) ; setDirtyAndFirePropertyChange ( LOADS_CHANGED_PROPERTY , _loadList . size ( ) + NUM_ , _loadList . size ( ) ) ; return BOOL_ ; }
private ComputeState validateComputeName ( String awsId , String vmName ) throws Throwable { if ( this . isAwsClientMock ) { return null ; } ComputeState computeState = getComputeByAWSId ( this . host , awsId ) ; String tagNameValue = computeState . name ; assertNotNull ( STR_ , tagNameValue ) ; assertEquals ( vmName , tagNameValue ) ; return computeState ; }
public static String fromTag ( IntArrayTag tag ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( ARRAY_START ) ; boolean start = BOOL_ ; for ( int value : tag . getValue ( ) ) { IntTag i = new IntTag ( value ) ; if ( start ) { start = BOOL_ ; } else { builder . append ( ELEMENT_SEPERATOR ) ; } builder . append ( fromTag ( i ) ) ; } builder . append ( ARRAY_END ) ; return builder . toString ( ) ; }
public static int removeArgsAndReturnInsertionIndex ( List < String > args , int argIndex , boolean tryRemovingArgValue ) { if ( argIndex < NUM_ || argIndex >= args . size ( ) ) { return NUM_ ; } if ( tryRemovingArgValue ) { String argValue = getArgValue ( args , argIndex + NUM_ ) ; if ( argValue != null ) { args . remove ( argIndex + NUM_ ) ; } } args . remove ( argIndex ) ; return argIndex ; }
void replacePolicyInResourceTree ( ServiceTypeManager svtm , SSOToken token , Policy oldPolicy , Policy newPolicy ) throws PolicyException , SSOException { removePolicyFromResourceTree ( svtm , token , oldPolicy ) ; addPolicyToResourceTree ( svtm , token , newPolicy ) ; }
public AtomicDoubleArray ( int length ) { larray = new AtomicLongArray ( length ) ; long ZERO = Double . doubleToRawLongBits ( NUM_ ) ; for ( int i = NUM_ ; i < length ; i ++ ) larray . set ( i , ZERO ) ; }
private void copyAction ( File srcFile , File destFile ) throws FileNotFoundException , IOException { FileInputStream istream = new FileInputStream ( srcFile ) ; FileOutputStream ostream = new FileOutputStream ( destFile ) ; FileChannel input = istream . getChannel ( ) ; FileChannel output = ostream . getChannel ( ) ; try { input . transferTo ( NUM_ , input . size ( ) , output ) ; } finally { istream . close ( ) ; ostream . close ( ) ; input . close ( ) ; output . close ( ) ; } }
private static BufferedImage makeSquare ( BufferedImage input ) { if ( input . getHeight ( ) == input . getWidth ( ) ) { return input ; } else { int max = Math . max ( input . getHeight ( ) , input . getWidth ( ) ) ; int dx = ( max - input . getWidth ( ) ) / NUM_ ; int dy = ( max - input . getHeight ( ) ) / NUM_ ; return createImg ( max , max , input . getType ( ) , null ) ; } }
protected abstract void handleLostEntry ( HttpRoute route ) ;
public void writeStartElement ( String localName ) throws XMLStreamException { if ( localName == null || localName . length ( ) == NUM_ ) { throw new XMLStreamException ( STR_ ) ; } _state = STATE_ELEMENT ; if ( _currentEle != null && _currentEle . getState ( ) == ELEMENT_STARTTAG_OPEN ) { closeStartTag ( ) ; } _currentEle = new Element ( _currentEle , localName , BOOL_ ) ; openStartTag ( ) ; _writer . write ( localName ) ; }
public void addProcessInteractionListener ( final ProcessInteractionListener l ) { if ( l == null ) { throw new IllegalArgumentException ( STR_ ) ; } processInteractionListeners . add ( l ) ; }
private void traverseInternal ( Object root , boolean yieldRoot , IdentityHashMap < Object , Object > seen ) { if ( root == null || seen . containsKey ( root ) ) { return ; } if ( yieldRoot ) { if ( ! visit ( root ) ) { return ; } } seen . put ( root , root ) ; if ( root instanceof JSONObject ) { JSONObject json = ( JSONObject ) root ; Iterator < String > keys = json . keys ( ) ; while ( keys . hasNext ( ) ) { String key = keys . next ( ) ; try { traverseInternal ( json . get ( key ) , BOOL_ , seen ) ; } catch ( JSONException e ) { throw new RuntimeException ( e ) ; } } } else if ( root instanceof JSONArray ) { JSONArray array = ( JSONArray ) root ; for ( int i = NUM_ ; i < array . length ( ) ; ++ i ) { try { traverseInternal ( array . get ( i ) , BOOL_ , seen ) ; } catch ( JSONException e ) { throw new RuntimeException ( e ) ; } } } else if ( root instanceof Map ) { Map < ? , ? > map = ( Map < ? , ? > ) root ; for ( Object value : map . values ( ) ) { traverseInternal ( value , BOOL_ , seen ) ; } } else if ( root instanceof List ) { List < ? > list = ( List < ? > ) root ; for ( Object value : list ) { traverseInternal ( value , BOOL_ , seen ) ; } } else if ( root instanceof ParseObject ) { if ( traverseParseObjects ) { ParseObject object = ( ParseObject ) root ; for ( String key : object . keySet ( ) ) { traverseInternal ( object . get ( key ) , BOOL_ , seen ) ; } } } else if ( root instanceof ParseACL ) { ParseACL acl = ( ParseACL ) root ; ParseUser user = acl . getUnresolvedUser ( ) ; if ( user != null && user . isCurrentUser ( ) ) { traverseInternal ( user , BOOL_ , seen ) ; } } }
public StrBuilder replaceFirst ( final String searchStr , final String replaceStr ) { final int searchLen = ( searchStr == null ? NUM_ : searchStr . length ( ) ) ; if ( searchLen > NUM_ ) { final int index = indexOf ( searchStr , NUM_ ) ; if ( index >= NUM_ ) { final int replaceLen = ( replaceStr == null ? NUM_ : replaceStr . length ( ) ) ; replaceImpl ( index , index + searchLen , searchLen , replaceStr , replaceLen ) ; } } return this ; }
protected abstract void internalPut ( int index , byte b ) ;
public CommonTurnoutOperationConfig ( TurnoutOperation op ) { super ( op ) ; myOp = ( CommonTurnoutOperation ) op ; maxTriesSpinner = new JSpinner ( ) ; intervalSpinner = new JSpinner ( ) ; Box vbox = Box . createVerticalBox ( ) ; Box hbox1 = Box . createHorizontalBox ( ) ; Box hbox2 = Box . createHorizontalBox ( ) ; vbox . add ( hbox2 ) ; vbox . add ( hbox1 ) ; vbox . add ( Box . createVerticalGlue ( ) ) ; hbox1 . add ( new JLabel ( Bundle . getMessage ( STR_ ) ) ) ; hbox1 . add ( Box . createHorizontalGlue ( ) ) ; intervalSpinner . setMinimumSize ( new Dimension ( NUM_ , NUM_ ) ) ; intervalSpinner . setModel ( new SpinnerNumberModel ( myOp . getInterval ( ) , CommonTurnoutOperation . minInterval , CommonTurnoutOperation . maxInterval , CommonTurnoutOperation . intervalStepSize ) ) ; hbox1 . add ( intervalSpinner ) ; hbox2 . add ( new JLabel ( Bundle . getMessage ( STR_ ) ) ) ; hbox2 . add ( Box . createHorizontalGlue ( ) ) ; maxTriesSpinner . setMinimumSize ( new Dimension ( NUM_ , NUM_ ) ) ; maxTriesSpinner . setModel ( new SpinnerNumberModel ( myOp . getMaxTries ( ) , CommonTurnoutOperation . minMaxTries , CommonTurnoutOperation . maxMaxTries , NUM_ ) ) ; hbox2 . add ( maxTriesSpinner ) ; Box hbox3 = Box . createHorizontalBox ( ) ; hbox3 . add ( Box . createHorizontalStrut ( NUM_ ) ) ; vbox . add ( hbox3 ) ; add ( vbox ) ; }
public static String gensalt ( int log_rounds , SecureRandom random ) { if ( log_rounds < NUM_ || log_rounds > NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } StringBuilder rs = new StringBuilder ( ) ; byte rnd [ ] = new byte [ BCRYPT_SALT_LEN ] ; random . nextBytes ( rnd ) ; rs . append ( STR_ ) ; if ( log_rounds < NUM_ ) { rs . append ( STR_ ) ; } rs . append ( log_rounds ) ; rs . append ( STR_ ) ; encode_base64 ( rnd , rnd . length , rs ) ; return rs . toString ( ) ; }
protected void drawDescription ( Canvas c ) { if ( ! mDescription . equals ( STR_ ) ) { if ( mDescriptionPosition == null ) { c . drawText ( mDescription , getWidth ( ) - mViewPortHandler . offsetRight ( ) - NUM_ , getHeight ( ) - mViewPortHandler . offsetBottom ( ) - NUM_ , mDescPaint ) ; } else { c . drawText ( mDescription , mDescriptionPosition . x , mDescriptionPosition . y , mDescPaint ) ; } } }
long parseBytes ( String freeSpace , String path ) throws IOException { try { long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < NUM_ ) { throw new IOException ( STR_ + DF + STR_ + STR_ + path + STR_ ) ; } return bytes ; } catch ( NumberFormatException ex ) { throw new IOExceptionWithCause ( STR_ + DF + STR_ + STR_ + path + STR_ , ex ) ; } }
public String findInterlanguageLink ( String lang ) { int start = page . indexOf ( STR_ + lang + STR_ ) ; if ( start < NUM_ ) return null ; int end = page . indexOf ( STR_ , start ) ; if ( end < NUM_ ) return null ; String link = page . substring ( start + NUM_ + lang . length ( ) , end ) ; if ( link . indexOf ( STR_ ) != - NUM_ ) { return null ; } if ( link . length ( ) == NUM_ ) return null ; return link ; }
private void updateActions ( final INaviAddressSpace addressSpace ) { m_loadAddressSpaceAction . setEnabled ( ! addressSpace . isLoaded ( ) ) ; }
public static < T > ParallelFlux < T > from ( Publisher < ? extends T > source , int parallelism ) { return from ( source , parallelism , QueueSupplier . SMALL_BUFFER_SIZE , QueueSupplier . small ( ) ) ; }
private static void cleanDirectoryOnExit ( File directory ) throws IOException { if ( ! directory . exists ( ) ) { String message = directory + STR_ ; throw new IllegalArgumentException ( message ) ; } if ( ! directory . isDirectory ( ) ) { String message = directory + STR_ ; throw new IllegalArgumentException ( message ) ; } File [ ] files = directory . listFiles ( ) ; if ( files == null ) { throw new IOException ( STR_ + directory ) ; } IOException exception = null ; for ( File file : files ) { try { forceDeleteOnExit ( file ) ; } catch ( IOException ioe ) { exception = ioe ; } } if ( null != exception ) { throw exception ; } }
private void addGumball ( float xPos , float yPos ) { Gumball gumball = new Gumball ( ) ; gumball . mXInitPos = xPos ; gumball . mYInitPos = yPos ; gumball . mSoundPoolId = UUID . randomUUID ( ) ; mSoundPoolId . put ( gumball . mSoundPoolId , BOOL_ ) ; mGameView . addGumball ( gumball ) ; mSoundPool . play ( mSoundBallDrop , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ ) ; }
int put ( T segment , List < ? super T > recycleBin ) { int count ; if ( lastCount == NUM_ ) { count = NUM_ ; lastCount = NUM_ ; last = segment ; } else if ( Objects . deepEquals ( last , segment ) ) { ++ lastCount ; count = NUM_ ; recycleBin . add ( segment ) ; } else { count = lastCount ; lastCount = NUM_ ; last = segment ; } return count ; }
@ KnownFailure ( STR_ ) public void testDelete6 ( ) throws SQLException { DatabaseCreator . fillFKStrictTable ( conn ) ; statement . execute ( STR_ + DatabaseCreator . FKSTRICT_TABLE + STR_ + DatabaseCreator . PARENT_TABLE + STR_ ) ; ResultSet r = statement . executeQuery ( STR_ + DatabaseCreator . FKSTRICT_TABLE + STR_ ) ; r . next ( ) ; assertEquals ( STR_ , NUM_ , r . getInt ( NUM_ ) ) ; r . close ( ) ; }
public Channel chan ( final String topic , final JsonNode payload ) { LOG . log ( Level . FINE , STR_ , new Object [ ] { topic , payload } ) ; final Channel channel = new Channel ( topic , payload , Socket . this ) ; synchronized ( channels ) { channels . add ( channel ) ; } return channel ; }
public PlaPointFloat change_size ( double p_new_size ) { if ( v_x == NUM_ && v_y == NUM_ ) { return this ; } double length = Math . sqrt ( v_x . v_x + v_y . v_y ) ; double new_x = ( v_x . p_new_size ) / length ; double new_y = ( v_y . p_new_size ) / length ; return new PlaPointFloat ( new_x , new_y ) ; }
int insert ( Row row , byte [ ] sourceBuffer , int sourceOffset , BlobOutputStream [ ] blobs ) { int rowHead = _rowHead ; int blobTail = _blobTail ; int rowLength = row . length ( ) ; rowHead -= rowLength ; if ( rowHead < blobTail ) { return - NUM_ ; } byte [ ] buffer = _buffer ; System . arraycopy ( sourceBuffer , sourceOffset , buffer , rowHead , rowLength ) ; buffer [ rowHead ] = ( byte ) ( ( buffer [ rowHead ] & ~ CODE_MASK ) | INSERT ) ; blobTail = row . insertBlobs ( buffer , rowHead , blobTail , blobs ) ; if ( blobTail < NUM_ ) { return - NUM_ ; } setBlobTail ( blobTail ) ; rowHead ( rowHead ) ; validateBlock ( row ) ; return rowHead ; }
private void addDefaultUri ( ) throws IgniteSpiException { assert uriEncodedList != null ; URI uri ; try { uri = U . resolveWorkDirectory ( DFLT_DEPLOY_DIR , BOOL_ ) . toURI ( ) ; } catch ( IgniteCheckedException e ) { throw new IgniteSpiException ( STR_ , e ) ; } uriEncodedList . add ( uri ) ; }
protected void transfer ( String seqRange ) throws IOException { try { final int rangePos = seqRange . indexOf ( STR_ ) ; if ( rangePos == - NUM_ ) { transfer ( Long . parseLong ( seqRange ) ) ; } else { final String start = seqRange . substring ( NUM_ , rangePos ) ; final String end = seqRange . substring ( rangePos + NUM_ ) ; final long startIdx ; if ( start . length ( ) == NUM_ ) { startIdx = NUM_ ; } else { startIdx = Long . parseLong ( start ) ; } final long endIdx ; if ( end . length ( ) == NUM_ ) { endIdx = mReader . numberSequences ( ) - NUM_ ; } else { endIdx = Long . parseLong ( end ) ; } if ( startIdx > endIdx ) { throw new NumberFormatException ( STR_ + seqRange ) ; } for ( long i = startIdx ; i <= endIdx ; i ++ ) { transfer ( i ) ; } } } catch ( final NumberFormatException e ) { warnInvalidSequence ( seqRange ) ; } }
BigInteger copy ( ) { prepareJavaRepresentation ( ) ; int [ ] copyDigits = new int [ numberLength ] ; System . arraycopy ( digits , NUM_ , copyDigits , NUM_ , numberLength ) ; return new BigInteger ( sign , numberLength , copyDigits ) ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; String childData ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; nameNode = elementList . item ( NUM_ ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; child . replaceData ( NUM_ , NUM_ , STR_ ) ; childData = child . getData ( ) ; assertEquals ( STR_ , STR_ , childData ) ; }
public String patchFixIds ( ) { return properties . getProperty ( STR_ ) ; }
public final void readFully ( byte [ ] b ) throws java . io . IOException { readFully ( b , NUM_ , b . length ) ; }
private void createGui ( ) { final JPanel outerNamePanel = new JPanel ( new BorderLayout ( ) ) ; outerNamePanel . setBorder ( new TitledBorder ( STR_ ) ) ; final JPanel namePanel = new JPanel ( new BorderLayout ( ) ) ; namePanel . setBorder ( new EmptyBorder ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; final JLabel nameLabel = new CHelpLabel ( STR_ + STR_ , new CNameHelp ( ) ) ; nameLabel . setPreferredSize ( new Dimension ( NUM_ , NUM_ ) ) ; namePanel . add ( nameLabel , BorderLayout . WEST ) ; namePanel . add ( m_nameTextField , BorderLayout . CENTER ) ; outerNamePanel . add ( namePanel , BorderLayout . CENTER ) ; final JPanel outerDescriptionPanel = new JPanel ( new BorderLayout ( ) ) ; outerDescriptionPanel . setBorder ( new EmptyBorder ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; final JPanel descriptionPanel = new JPanel ( new BorderLayout ( ) ) ; descriptionPanel . setBorder ( new TitledBorder ( STR_ ) ) ; descriptionPanel . setMinimumSize ( new Dimension ( NUM_ , NUM_ ) ) ; descriptionPanel . add ( new JScrollPane ( m_descriptionField ) ) ; outerDescriptionPanel . add ( descriptionPanel , BorderLayout . CENTER ) ; final JPanel buttonPanel = new JPanel ( new GridLayout ( NUM_ , NUM_ ) ) ; buttonPanel . add ( new JPanel ( ) ) ; buttonPanel . setBorder ( new EmptyBorder ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; buttonPanel . add ( m_saveButton ) ; final JPanel topPanel = new JPanel ( new BorderLayout ( ) ) ; topPanel . add ( outerNamePanel , BorderLayout . NORTH ) ; topPanel . add ( outerDescriptionPanel , BorderLayout . CENTER ) ; topPanel . add ( buttonPanel , BorderLayout . SOUTH ) ; final JPanel bottomPanel = new JPanel ( new BorderLayout ( ) ) ; bottomPanel . setBorder ( m_tableBorder ) ; final JScrollPane scrollPane = new JScrollPane ( m_childrenTagTable ) ; bottomPanel . add ( scrollPane , BorderLayout . CENTER ) ; final JSplitPane splitPane = new JSplitPane ( JSplitPane . VERTICAL_SPLIT , BOOL_ , topPanel , bottomPanel ) ; splitPane . setOneTouchExpandable ( BOOL_ ) ; splitPane . setDividerLocation ( splitPane . getMinimumDividerLocation ( ) ) ; splitPane . setResizeWeight ( NUM_ ) ; add ( splitPane ) ; }
public static boolean isJellybeanOrLater ( ) { return Build . VERSION . SDK_INT >= Build . VERSION_CODES . JELLY_BEAN ; }
public PartialCorrelationPdf ( int n , int k ) { this . n = n ; this . k = k ; double gammaRatio = gammaRatio ( n , k ) ; this . constant = ( NUM_ / Math . pow ( Math . PI , NUM_ ) ) . gammaRatio ; this . outsideExp = ( double ) ( n - k - NUM_ ) / NUM_ ; }
private static boolean isEnabled ( ) { if ( SystemUtils . IS_OS_WINDOWS ) { return BOOL_ ; } try { List < String > lines = CommandUtil . executeCommandAndGetLines ( Collections . singletonList ( STR_ ) ) ; for ( String line : lines ) { if ( line . contains ( STR_ ) ) { if ( line . contains ( STR_ ) ) { Logger . info ( STR_ ) ; return BOOL_ ; } return BOOL_ ; } } } catch ( Exception ex ) { } return BOOL_ ; }
public boolean validate ( ) { outputFile = new File ( outputPath ) ; if ( outputFile . exists ( ) || outputFile . isDirectory ( ) ) { invalidMessage = STR_ ; return valid = BOOL_ ; } if ( ! signMode ) { keyFile = new File ( keyFilePath ) ; if ( ! keyFile . exists ( ) || keyFile . isDirectory ( ) ) { invalidMessage = STR_ ; return valid = BOOL_ ; } } return valid = BOOL_ ; }
public void addResponseCodeListener ( ActionListener a ) { responseCodeListeners . addElement ( a ) ; }
public double calculateLogLikelihood ( ) { double logL = NUM_ ; for ( Statistic statistic : dataList ) { for ( int j = NUM_ ; j < statistic . getDimension ( ) ; j ++ ) { logL -= Math . log ( statistic . getStatisticValue ( j ) ) ; } } return logL ; }
public static boolean hasDeadStatesFromInitial ( Automaton a ) { BitSet reachableFromInitial = getLiveStatesFromInitial ( a ) ; BitSet reachableFromAccept = getLiveStatesToAccept ( a ) ; reachableFromInitial . andNot ( reachableFromAccept ) ; return reachableFromInitial . isEmpty ( ) == BOOL_ ; }
public Decimal subtract ( Decimal decimal ) { assertDefined ( ) ; if ( null == m_value ) { return ( decimal ) ; } BigDecimal value = m_value . subtract ( decimal . getBigDecimalValue ( ) ) ; return new Decimal ( value , SCALE ) ; }
public final boolean equals ( Object object ) { if ( object == null ) { return BOOL_ ; } if ( ! ( object instanceof KnowledgeEdge ) ) { return BOOL_ ; } KnowledgeEdge pair = ( KnowledgeEdge ) object ; return from . equals ( pair . from ) && to . equals ( pair . to ) ; }
protected int skipLine ( int c ) throws IOException { while ( c != - NUM_ && c != STR_ && c != STR_ ) { c = reader . read ( ) ; } if ( c == STR_ ) { c = reader . read ( ) ; lineNo ++ ; reportLocation ( lineNo , NUM_ ) ; } else if ( c == STR_ ) { c = reader . read ( ) ; if ( c == STR_ ) { c = reader . read ( ) ; } lineNo ++ ; reportLocation ( lineNo , NUM_ ) ; } return c ; }
@ Override public void listVolumes ( CommandInput input , CompletionHandler completionHandler ) { createOrUpdateTargetSsl ( input ) ; URI uri = UriUtils . extendUri ( input . getDockerUri ( ) , STR_ ) ; sendGet ( uri , null , completionHandler ) ; }
public static ByteBuffer base64StringToByteBuffer ( String base64EncodedKey ) { return ByteBuffer . wrap ( base64DecodeString ( base64EncodedKey ) ) ; }
public boolean step ( ) { long current = System . currentTimeMillis ( ) ; if ( mStart == NUM_ || ( current - mStart < NUM_ ) ) { mProgress = NUM_ ; } else if ( current - mStart > mDuration ) { if ( mLoop ) { mProgress = NUM_ ; start ( ) ; return BOOL_ ; } mProgress = NUM_ ; return BOOL_ ; } else { mProgress = ( current - mStart ) / ( double ) mDuration ; } return BOOL_ ; }
protected void load_raw_characters ( StringBuilder sb ) throws IOException { int c = read_char ( ) ; for ( ; ; ) { c = read_char ( ) ; switch ( c ) { case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1 : case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2 : case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3 : continue ; case - NUM_ : return ; default : if ( ! IonTokenConstsX . is7bitValue ( c ) ) { c = read_large_char_sequence ( c ) ; } } if ( IonUTF8 . needsSurrogateEncoding ( c ) ) { sb . append ( IonUTF8 . highSurrogate ( c ) ) ; c = IonUTF8 . lowSurrogate ( c ) ; } sb . append ( ( char ) c ) ; } }
public SignatureFakingOracle ( final String documentString ) throws SignatureFakingException { Security . addProvider ( new BouncyCastleProvider ( ) ) ; signatureValueElements = new LinkedList < Node > ( ) ; keyInfoElements = new LinkedList < Node > ( ) ; certificates = new LinkedList < String > ( ) ; certHandlers = new LinkedList < CertificateHandler > ( ) ; try { doc = DomUtilities . stringToDom ( documentString ) ; crawlSignatureElements ( ) ; log . debug ( STR_ + signatureValueElements . size ( ) + STR_ ) ; crawlKeyInfoElements ( ) ; log . debug ( STR_ + keyInfoElements . size ( ) + STR_ ) ; } catch ( SAXException e ) { throw new SignatureFakingException ( e ) ; } }
public ArbitraryLengthPathNode ( final TermNode left , final TermNode right , final VarNode tVarLeft , final VarNode tVarRight , final long lowerBound , final long upperBound ) { this ( new BOp [ ] { new JoinGroupNode ( ) } , NV . asMap ( new NV ( Annotations . LEFT_TERM , left ) , new NV ( Annotations . RIGHT_TERM , right ) , new NV ( Annotations . TRANSITIVITY_VAR_LEFT , tVarLeft ) , new NV ( Annotations . TRANSITIVITY_VAR_RIGHT , tVarRight ) , new NV ( Annotations . DROP_VARS , new ArrayList < VarNode > ( ) ) , new NV ( Annotations . LOWER_BOUND , lowerBound ) , new NV ( Annotations . UPPER_BOUND , upperBound ) ) ) ; final Set < VarNode > dropVars = new LinkedHashSet < > ( ) ; dropVars . add ( tVarLeft ) ; dropVars . add ( tVarRight ) ; setProperty ( Annotations . DROP_VARS , dropVars ) ; }
public void addChangingListener ( OnWheelChangedListener listener ) { changingListeners . add ( listener ) ; }
private Integer scanYamlDirectiveNumber ( Mark startMark ) { char ch = reader . peek ( ) ; if ( ! Character . isDigit ( ch ) ) { throw new ScannerException ( STR_ , startMark , STR_ + ch + STR_ + ( ( int ) ch ) + STR_ , reader . getMark ( ) ) ; } int length = NUM_ ; while ( Character . isDigit ( reader . peek ( length ) ) ) { length ++ ; } Integer value = Integer . parseInt ( reader . prefixForward ( length ) ) ; return value ; }
public static final String toBitString ( int i [ ] ) { StringBuilder sb = new StringBuilder ( i . length ) ; for ( int b : i ) { sb . append ( b ) ; } return sb . toString ( ) ; }
public static ByteBuffer convertToSigned16BitSamples ( Buffer buffer ) { return convertToSigned16BitSamples ( buffer . getSamples ( ) ) ; }
boolean checkToken ( ByteWrapper token , Key nodeId , InetAddress ip , int port , Key lookupKey ) { updateTokenTimestamps ( ) ; boolean valid = checkToken ( token , nodeId , ip , port , lookupKey , timestampCurrent . get ( ) ) || checkToken ( token , nodeId , ip , port , lookupKey , timestampPrevious ) ; if ( ! valid ) DHT . logDebug ( STR_ + ip . getHostAddress ( ) ) ; return valid ; }
private void writeAttribute ( java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( namespace . equals ( STR_ ) ) { xmlWriter . writeAttribute ( attName , attValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } }
public void expandAll ( ) { cancelEditing ( ) ; final TreeModel tm = getModel ( ) ; final Object root = tm . getRoot ( ) ; if ( root != null ) { expandAllPaths ( new TreePath ( root ) , tm ) ; } }
protected void describeVocabularies ( final IVCount [ ] predicatePartitionCounts ) { final Set < String > namespaces = new LinkedHashSet < String > ( ) ; { for ( IVCount tmp : predicatePartitionCounts ) { final URI p = ( URI ) tmp . getValue ( ) ; String namespace = p . getNamespace ( ) ; if ( namespace . endsWith ( STR_ ) ) { namespace = namespace . substring ( NUM_ , namespace . length ( ) - NUM_ ) ; } namespaces . add ( namespace ) ; } } final String [ ] a = namespaces . toArray ( new String [ namespaces . size ( ) ] ) ; Arrays . sort ( a ) ; for ( String namespace : a ) { g . add ( aDataset , VoidVocabularyDecl . vocabulary , f . createURI ( namespace ) ) ; } }
public void testInvokeAny4 ( ) throws Throwable { CountDownLatch latch = new CountDownLatch ( NUM_ ) ; ExecutorService e = new ForkJoinPool ( NUM_ ) ; PoolCleaner cleaner = null ; try { cleaner = cleaner ( e ) ; List < Callable < String > > l = new ArrayList < Callable < String > > ( ) ; l . add ( latchAwaitingStringTask ( latch ) ) ; l . add ( null ) ; try { e . invokeAny ( l ) ; shouldThrow ( ) ; } catch ( NullPointerException success ) { } latch . countDown ( ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
private static void solve_l2r_l1l2_svr ( Problem prob , double [ ] w , Parameter param ) { int l = prob . l ; double C = param . C ; double p = param . p ; int w_size = prob . n ; double eps = param . eps ; int i , s , iter = NUM_ ; int max_iter = NUM_ ; int active_size = l ; int [ ] index = new int [ l ] ; double d , G , H ; double Gmax_old = Double . POSITIVE_INFINITY ; double Gmax_new , Gnorm1_new ; double Gnorm1_init = NUM_ ; double [ ] beta = new double [ l ] ; double [ ] QD = new double [ l ] ; double [ ] y = prob . y ; double [ ] lambda = new double [ ] { NUM_ / C } ; double [ ] upper_bound = new double [ ] { Double . POSITIVE_INFINITY } ; if ( param . solverType == SolverType . L2R_L1LOSS_SVR_DUAL ) { lambda [ NUM_ ] = NUM_ ; upper_bound [ NUM_ ] = C ; } for ( i = NUM_ ; i < l ; i ++ ) { beta [ i ] = NUM_ ; } for ( i = NUM_ ; i < w_size ; i ++ ) { w [ i ] = NUM_ ; } for ( i = NUM_ ; i < l ; i ++ ) { QD [ i ] = NUM_ ; for ( Feature xi : prob . x [ i ] ) { double val = xi . getValue ( ) ; QD [ i ] += val . val ; w [ xi . getIndex ( ) - NUM_ ] += beta [ i ] . val ; } index [ i ] = i ; } while ( iter < max_iter ) { Gmax_new = NUM_ ; Gnorm1_new = NUM_ ; for ( i = NUM_ ; i < active_size ; i ++ ) { int j = i + random . nextInt ( active_size - i ) ; swap ( index , i , j ) ; } for ( s = NUM_ ; s < active_size ; s ++ ) { i = index [ s ] ; G = - y [ i ] + lambda [ GETI_SVR ( i ) ] . beta [ i ] ; H = QD [ i ] + lambda [ GETI_SVR ( i ) ] ; for ( Feature xi : prob . x [ i ] ) { int ind = xi . getIndex ( ) - NUM_ ; double val = xi . getValue ( ) ; G += val . w [ ind ] ; } double Gp = G + p ; double Gn = G - p ; double violation = NUM_ ; if ( beta [ i ] == NUM_ ) { if ( Gp < NUM_ ) { violation = - Gp ; } else if ( Gn > NUM_ ) { violation = Gn ; } else if ( Gp > Gmax_old && Gn < - Gmax_old ) { active_size -- ; swap ( index , s , active_size ) ; s -- ; continue ; } } else if ( beta [ i ] >= upper_bound [ GETI_SVR ( i ) ] ) { if ( Gp > NUM_ ) { violation = Gp ; } else if ( Gp < - Gmax_old ) { active_size -- ; swap ( index , s , active_size ) ; s -- ; continue ; } } else if ( beta [ i ] <= - upper_bound [ GETI_SVR ( i ) ] ) { if ( Gn < NUM_ ) { violation = - Gn ; } else if ( Gn > Gmax_old ) { active_size -- ; swap ( index , s , active_size ) ; s -- ; continue ; } } else if ( beta [ i ] > NUM_ ) { violation = Math . abs ( Gp ) ; } else { violation = Math . abs ( Gn ) ; } Gmax_new = Math . max ( Gmax_new , violation ) ; Gnorm1_new += violation ; if ( Gp < H . beta [ i ] ) { d = - Gp / H ; } else if ( Gn > H . beta [ i ] ) { d = - Gn / H ; } else { d = - beta [ i ] ; } if ( Math . abs ( d ) < NUM_ ) { continue ; } double beta_old = beta [ i ] ; beta [ i ] = Math . min ( Math . max ( beta [ i ] + d , - upper_bound [ GETI_SVR ( i ) ] ) , upper_bound [ GETI_SVR ( i ) ] ) ; d = beta [ i ] - beta_old ; if ( d != NUM_ ) { for ( Feature xi : prob . x [ i ] ) { w [ xi . getIndex ( ) - NUM_ ] += d . xi . getValue ( ) ; } } } if ( iter == NUM_ ) { Gnorm1_init = Gnorm1_new ; } iter ++ ; if ( iter % NUM_ == NUM_ ) { info ( STR_ ) ; } if ( Gnorm1_new <= eps . Gnorm1_init ) { if ( active_size == l ) { break ; } else { active_size = l ; info ( STR_ ) ; Gmax_old = Double . POSITIVE_INFINITY ; continue ; } } Gmax_old = Gmax_new ; } info ( STR_ , iter ) ; if ( iter >= max_iter ) { info ( STR_ ) ; } double v = NUM_ ; int nSV = NUM_ ; for ( i = NUM_ ; i < w_size ; i ++ ) { v += w [ i ] . w [ i ] ; } v = NUM_ . v ; for ( i = NUM_ ; i < l ; i ++ ) { v += p . Math . abs ( beta [ i ] ) - y [ i ] . beta [ i ] + NUM_ . lambda [ GETI_SVR ( i ) ] . beta [ i ] . beta [ i ] ; if ( beta [ i ] != NUM_ ) { nSV ++ ; } } info ( STR_ , v ) ; info ( STR_ , nSV ) ; }
public SignalGroupSubTableAction ( String s ) { }
public static List < String > generateXVals ( int from , int to ) { List < String > xvals = new ArrayList < String > ( ) ; for ( int i = from ; i < to ; i ++ ) { xvals . add ( STR_ + i ) ; } return xvals ; }
public void testCompareToDiffSigns1 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int bSign = - NUM_ ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; assertEquals ( NUM_ , aNumber . compareTo ( bNumber ) ) ; }
private HashMap addAttr ( SvcReg reg , EntryClass eclass , int fldidx , Object value ) { HashMap [ ] attrMaps = serviceByAttr . get ( eclass ) ; if ( attrMaps == null ) { attrMaps = new HashMap [ eclass . getNumFields ( ) ] ; serviceByAttr . put ( eclass , attrMaps ) ; } HashMap map = attrMaps [ fldidx ] ; if ( map == null ) { map = new HashMap ( NUM_ ) ; attrMaps [ fldidx ] = map ; } ArrayList regs = ( ArrayList ) map . get ( value ) ; if ( regs == null ) { regs = new ArrayList ( NUM_ ) ; map . put ( value , regs ) ; } else if ( regs . contains ( reg ) ) return map ; regs . add ( reg ) ; return map ; }
public QueryStringDecoderUtil ( URI uri ) { this ( uri , Charset . defaultCharset ( ) ) ; }
public static float [ ] cmykFromRgb ( int rgbColor ) { int red = ( xff0000 & rgbColor ) > > NUM_ ; int green = ( xff00 & rgbColor ) > > NUM_ ; int blue = ( xff & rgbColor ) ; float black = Math . min ( NUM_ - red / NUM_ , Math . min ( NUM_ - green / NUM_ , NUM_ - blue / NUM_ ) ) ; float cyan = NUM_ ; float magenta = NUM_ ; float yellow = NUM_ ; if ( black != NUM_ ) { cyan = ( NUM_ - ( red / NUM_ ) - black ) / ( NUM_ - black ) ; magenta = ( NUM_ - ( green / NUM_ ) - black ) / ( NUM_ - black ) ; yellow = ( NUM_ - ( blue / NUM_ ) - black ) / ( NUM_ - black ) ; } return new float [ ] { cyan , magenta , yellow , black } ; }
public void removeSwipeListener ( SwipeListener listener ) { if ( mListeners == null ) { return ; } mListeners . remove ( listener ) ; }
public static void showErrorMessage ( String msg ) { showErrorMessage ( msg , NUM_ ) ; }
public final static NameValuePair parseNameValuePair ( final String value , HeaderValueParser parser ) throws ParseException { if ( value == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( parser == null ) parser = BasicHeaderValueParser . DEFAULT ; CharArrayBuffer buffer = new CharArrayBuffer ( value . length ( ) ) ; buffer . append ( value ) ; ParserCursor cursor = new ParserCursor ( NUM_ , value . length ( ) ) ; return parser . parseNameValuePair ( buffer , cursor ) ; }
public static String stripCharsInBag ( String s , String bag ) { int i ; StringBuilder stringBuilder = new StringBuilder ( STR_ ) ; for ( i = NUM_ ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( bag . indexOf ( c ) == - NUM_ ) stringBuilder . append ( c ) ; } return stringBuilder . toString ( ) ; }
public static double cos ( double radians ) { return Math . cos ( radians ) ; }
@ Override protected void onDestroy ( ) { super . onDestroy ( ) ; doReallyStop ( BOOL_ ) ; mFragments . dispatchDestroy ( ) ; if ( mLoaderManager != null ) { mLoaderManager . doDestroy ( ) ; } }
public void removeVetoableChangeListener ( String propertyName , VetoableChangeListener in_vcl ) { beanContextChildSupport . removeVetoableChangeListener ( propertyName , in_vcl ) ; }
static public boolean doesFileExist ( Context c , String fileName , long fileSize , boolean deleteFileOnMismatch ) { File fileForNewFile = new File ( Helpers . generateSaveFileName ( c , fileName ) ) ; if ( fileForNewFile . exists ( ) ) { if ( fileForNewFile . length ( ) == fileSize ) { return BOOL_ ; } if ( deleteFileOnMismatch ) { fileForNewFile . delete ( ) ; } } return BOOL_ ; }
static WindowsFileAttributes fromFindData ( long address ) { int fileAttrs = unsafe . getInt ( address + OFFSETOF_FIND_DATA_ATTRIBUTES ) ; long creationTime = unsafe . getLong ( address + OFFSETOF_FIND_DATA_CREATETIME ) ; long lastAccessTime = unsafe . getLong ( address + OFFSETOF_FIND_DATA_LASTACCESSTIME ) ; long lastWriteTime = unsafe . getLong ( address + OFFSETOF_FIND_DATA_LASTWRITETIME ) ; long size = ( ( long ) ( unsafe . getInt ( address + OFFSETOF_FIND_DATA_SIZEHIGH ) ) << NUM_ ) + ( unsafe . getInt ( address + OFFSETOF_FIND_DATA_SIZELOW ) & xFFFFFFFFL ) ; int reparseTag = isReparsePoint ( fileAttrs ) ? unsafe . getInt ( address + OFFSETOF_FIND_DATA_RESERVED0 ) : NUM_ ; return new WindowsFileAttributes ( fileAttrs , creationTime , lastAccessTime , lastWriteTime , size , reparseTag , NUM_ , NUM_ , NUM_ ) ; }
public static final void writeMapXml ( Map val , XmlSerializer out , WriteMapCallback callback ) throws XmlPullParserException , IOException { if ( val == null ) { return ; } Set s = val . entrySet ( ) ; Iterator i = s . iterator ( ) ; while ( i . hasNext ( ) ) { Map . Entry e = ( Map . Entry ) i . next ( ) ; writeValueXml ( e . getValue ( ) , ( String ) e . getKey ( ) , out , callback ) ; } }
public void fireEventProgrammatically ( Event event ) { if ( ! event . isConsumed ( ) ) ripplerPane . fireEvent ( event ) ; }
private boolean hasFullEntry ( JsonValue entry , QuerySide querySide ) { if ( querySide == QuerySide . SOURCE && sourceQueryFullEntry != null ) { return sourceQueryFullEntry ; } else if ( querySide == QuerySide . TARGET && targetQueryFullEntry != null ) { return targetQueryFullEntry ; } if ( entry != null ) { short ignoreFields = NUM_ ; if ( entry . isDefined ( STR_ ) ) { ignoreFields ++ ; } if ( entry . isDefined ( STR_ ) ) { ignoreFields ++ ; } ignoreFields += NUM_ ; return entry . size ( ) > ignoreFields ; } else { return BOOL_ ; } }
public static boolean isModule ( IResource resource ) { return ( resource != null && TLA_EXTENSION . equals ( resource . getFileExtension ( ) ) ) ; }
public int writeAnnotation ( Annotation annotation ) { int off = data . position ( ) ; writeByte ( annotation . visibility ) ; writeEncodedArray ( annotation . encodedAnnotation ) ; return off ; }
public static long fromInet4Address ( final InetAddress inetAddress ) { ensureIsInet4Address ( inetAddress ) ; return Integer . toUnsignedLong ( inetAddress . hashCode ( ) ) ; }
public boolean revisionContainsTemplateName ( int revId , String templateName ) throws WikiApiException { return revisionContainsTemplateNames ( revId , Arrays . asList ( new String [ ] { templateName } ) ) ; }
public List < GenericEntry > retrieveAllAccountInfoRequests ( Date fromDate ) throws AppsForYourDomainException , IOException , ServiceException { String url = BASE_URL + STR_ + domain ; if ( fromDate != null ) { url += STR_ + DATE_FORMAT . format ( fromDate ) ; } return getAllPages ( new URL ( url ) , GenericFeed . class ) ; }
protected void drawCylinder ( int x , int y , int w , int h , Color fillColor , Paint fillPaint , Color penColor , boolean isShadow ) { int h4 = h / NUM_ ; int r = w - NUM_ ; if ( fillColor != null || fillPaint != null ) { Area area = new Area ( new Rectangle ( x , y + h4 / NUM_ , r , h - h4 ) ) ; area . add ( new Area ( new Rectangle ( x , y + h4 / NUM_ , r , h - h4 ) ) ) ; area . add ( new Area ( new Ellipse2D . Double ( x , y , r , h4 ) ) ) ; area . add ( new Area ( new Ellipse2D . Double ( x , y + h - h4 , r , h4 ) ) ) ; if ( isShadow ) { g . setColor ( mxConstants . SHADOW_COLOR ) ; g . translate ( mxConstants . SHADOW_OFFSETX , mxConstants . SHADOW_OFFSETY ) ; g . fill ( area ) ; g . translate ( - mxConstants . SHADOW_OFFSETX , - mxConstants . SHADOW_OFFSETY ) ; } if ( fillPaint != null ) { g . setPaint ( fillPaint ) ; } else { g . setColor ( fillColor ) ; } g . fill ( area ) ; } if ( penColor != null ) { g . setColor ( penColor ) ; int h2 = h4 / NUM_ ; g . drawOval ( x , y , r , h4 ) ; g . drawLine ( x , y + h2 , x , y + h - h2 ) ; g . drawLine ( x + w - NUM_ , y + h2 , x + w - NUM_ , y + h - h2 ) ; g . drawArc ( x , y + h - h4 , r , h4 , NUM_ , - NUM_ ) ; } }
public StringList plus ( String ... args ) { StringList newList = new StringList ( ) ; newList . addAll ( this ) ; newList . addAll ( Arrays . asList ( args ) ) ; return newList ; }
private void walkParseTree ( List < SwiftBaseListener > listeners , TopLevelContext tree ) { ParseTreeWalker walker = new ParseTreeWalker ( ) ; listeners . forEach ( null ) ; }
@ Override public final char readChar ( ) throws IOException { dis . readFully ( work , NUM_ , NUM_ ) ; return ( char ) ( ( work [ NUM_ ] & xff ) << NUM_ | ( work [ NUM_ ] & xff ) ) ; }
public static int truncatedCompareTo ( final Date date1 , final Date date2 , final int field ) { final Date truncatedDate1 = truncate ( date1 , field ) ; final Date truncatedDate2 = truncate ( date2 , field ) ; return truncatedDate1 . compareTo ( truncatedDate2 ) ; }
protected List < DecompoundedWord > makeSplit ( String aWord ) { List < DecompoundedWord > result = new ArrayList < DecompoundedWord > ( ) ; for ( int i = NUM_ ; i < aWord . length ( ) ; i ++ ) { String leftWord = aWord . substring ( NUM_ , i + NUM_ ) ; String rightWord = aWord . substring ( i + NUM_ ) ; boolean leftGood = dict . contains ( leftWord ) && leftWord . length ( ) >= minWordLength ; boolean rightGood = rightWord . length ( ) > minRestLength || rightWord . length ( ) == NUM_ ; if ( leftGood && rightGood ) { DecompoundedWord split = DecompoundedWord . createFromString ( leftWord + STR_ + rightWord ) ; split . setSplitPos ( i ) ; result . add ( split ) ; } for ( String morpheme : morphemes . getAll ( ) ) { try { String leftWithoutMorpheme = leftWord . substring ( NUM_ , leftWord . length ( ) - morpheme . length ( ) ) ; if ( leftWord . endsWith ( morpheme ) && dict . contains ( leftWithoutMorpheme ) && rightGood ) { DecompoundedWord split = DecompoundedWord . createFromString ( leftWithoutMorpheme + STR_ + morpheme + STR_ + rightWord ) ; split . setSplitPos ( i ) ; result . add ( split ) ; } } catch ( StringIndexOutOfBoundsException e ) { continue ; } } } return result ; }
public static boolean isBookSearchUrl ( String url ) { return url . startsWith ( STR_ ) || url . startsWith ( STR_ ) ; }
public static String classNamePath ( String className ) { String filename = className . replace ( STR_ , File . separator ) ; filename = filename . replaceFirst ( STR_ , STR_ ) ; if ( filename . indexOf ( STR_ ) > NUM_ ) { filename = filename . substring ( NUM_ , filename . indexOf ( STR_ ) ) ; } return STR_ + File . separator + filename + STR_ ; }
public void removeTitlePrefix ( String prfx ) { titlePrefix . remove ( prfx ) ; firePropertyChange ( TITLE_PREFIX , null , titlePrefix ) ; }
public void send ( Set recipients , boolean multicast ) throws InterruptedException , ReplyException { final boolean isDebugEnabled = logger . isDebugEnabled ( ) ; if ( Thread . interrupted ( ) ) throw new InterruptedException ( ) ; recipients = new HashSet ( recipients ) ; DistributedMember me = originDm . getDistributionManagerId ( ) ; if ( recipients . contains ( me ) ) { recipients . remove ( me ) ; } if ( isDebugEnabled ) { logger . debug ( STR_ , recipients ) ; } rp = new ReplyProcessor21 ( originDm , recipients ) ; processorId = rp . getProcessorId ( ) ; setRecipients ( recipients ) ; setMulticast ( multicast ) ; Set failures = originDm . putOutgoing ( this ) ; if ( failures != null && failures . size ( ) > NUM_ ) { for ( Iterator i = failures . iterator ( ) ; i . hasNext ( ) ; ) { InternalDistributedMember mbr = ( InternalDistributedMember ) i . next ( ) ; if ( isDebugEnabled ) { logger . debug ( STR_ , mbr ) ; } } } rp . waitForReplies ( ) ; }
private boolean isRelevant ( Object service , Entry [ ] attributes ) { LOOP : for ( Entry e : _serviceAttributes ) { for ( Entry en : attributes ) { if ( e . equals ( en ) ) continue LOOP ; } return BOOL_ ; } boolean flag = BOOL_ ; for ( Entry en : attributes ) { if ( _serviceName . equals ( en ) ) { flag = BOOL_ ; break ; } } if ( ! flag ) return BOOL_ ; flag = BOOL_ ; for ( Class cl : _classes ) { if ( cl . isInstance ( service ) ) { flag = BOOL_ ; break ; } } return flag ; }
private static boolean eq ( Object o1 , Object o2 ) { return o1 == null ? o2 == null : o1 . equals ( o2 ) ; }
public int findCarByRoadNumber ( String roadNumber ) { if ( sysList != null ) { if ( ! roadNumber . equals ( _roadNumber ) ) { return getIndex ( NUM_ , roadNumber ) ; } int index = getIndex ( _index , roadNumber ) ; if ( index > NUM_ ) { return index ; } return getIndex ( NUM_ , roadNumber ) ; } return - NUM_ ; }
@ SlashedClassName @ SuppressFBWarnings ( STR_ ) public static String toSlashedClassName ( @ SlashedClassName ( when = When . UNKNOWN ) String className ) { if ( className . indexOf ( STR_ ) >= NUM_ ) { return DescriptorFactory . canonicalizeString ( className . replace ( STR_ , STR_ ) ) ; } return className ; }
public static double P_AveragePrecision ( int y [ ] , int r [ ] ) { double avg_prec = NUM_ ; int L = y . length ; List < Integer > ones = new ArrayList < Integer > ( ) ; for ( int j = NUM_ ; j < L ; j ++ ) { if ( y [ j ] == NUM_ ) { ones . add ( j ) ; } } if ( ones . size ( ) <= NUM_ ) return NUM_ ; for ( int j : ones ) { double s = NUM_ ; for ( int k : ones ) { if ( r [ k ] <= r [ j ] ) { s ++ ; } } avg_prec += ( s / ( NUM_ + r [ j ] ) ) ; } avg_prec /= ones . size ( ) ; return avg_prec ; }
public Location newLocation ( String name ) { Location location = getLocationByName ( name ) ; if ( location == null ) { _id ++ ; location = new Location ( Integer . toString ( _id ) , name ) ; Integer oldSize = Integer . valueOf ( _locationHashTable . size ( ) ) ; _locationHashTable . put ( location . getId ( ) , location ) ; setDirtyAndFirePropertyChange ( LISTLENGTH_CHANGED_PROPERTY , oldSize , Integer . valueOf ( _locationHashTable . size ( ) ) ) ; } return location ; }
@ Override public void close ( ) { closing = BOOL_ ; if ( reservations == null || reservations . compareAndSet ( NUM_ , - NUM_ ) ) doClose ( ) ; }
private void removeOMADownloadFromSharedPrefs ( long downloadId ) { Set < String > omaDownloads = getStoredDownloadInfo ( PENDING_OMA_DOWNLOADS ) ; for ( String omaDownload : omaDownloads ) { OMAEntry entry = OMAEntry . parseOMAEntry ( omaDownload ) ; if ( entry . mDownloadId == downloadId ) { omaDownloads . remove ( omaDownload ) ; storeDownloadInfo ( PENDING_OMA_DOWNLOADS , omaDownloads ) ; return ; } } }
public static boolean isAndroidSdkDirInLocalPropertiesFile ( @ NotNull File projectDir ) { String androidHome = getAndroidHomeFromLocalPropertiesFile ( projectDir ) ; if ( ! Strings . isNullOrEmpty ( androidHome ) ) { String msg = String . format ( STR_ , androidHome ) ; LOG . info ( msg ) ; return BOOL_ ; } return BOOL_ ; }
public static boolean hasTokenInformation ( Bundle bundle ) { if ( bundle == null ) { return BOOL_ ; } String token = bundle . getString ( TOKEN_KEY ) ; if ( ( token == null ) || ( token . length ( ) == NUM_ ) ) { return BOOL_ ; } long expiresMilliseconds = bundle . getLong ( EXPIRATION_DATE_KEY , NUM_ ) ; if ( expiresMilliseconds == NUM_ ) { return BOOL_ ; } return BOOL_ ; }
public void resetPolicy ( ) { mPreferences . putString ( PREF_LAST_RESPONSE , Integer . toString ( Policy . RETRY ) ) ; setRetryUntil ( DEFAULT_RETRY_UNTIL ) ; setMaxRetries ( DEFAULT_MAX_RETRIES ) ; setRetryCount ( Long . parseLong ( DEFAULT_RETRY_COUNT ) ) ; setValidityTimestamp ( DEFAULT_VALIDITY_TIMESTAMP ) ; mPreferences . commit ( ) ; }
@ Override public boolean connectionAllowed ( String eventName ) { if ( eventName . equals ( STR_ ) && m_listenees . containsKey ( eventName ) ) { return BOOL_ ; } return BOOL_ ; }
public static Vector2 pow ( Vector2 o , double power ) { return new Vector2 ( Math . pow ( o . x , power ) , Math . pow ( o . z , power ) ) ; }
public static Object invokeStatic ( String clazz , String methodName , Class [ ] types , Object [ ] values ) throws NoSuchMethodException { try { return invokeStatic ( Class . forName ( clazz ) , methodName , types , values ) ; } catch ( ClassNotFoundException e ) { throw new NoSuchMethodException ( STR_ + clazz + STR_ ) ; } }
public Prototype undump ( InputStream stream , String chunkname ) throws IOException { if ( stream . read ( ) != LUA_SIGNATURE [ NUM_ ] || stream . read ( ) != LUA_SIGNATURE [ NUM_ ] || stream . read ( ) != LUA_SIGNATURE [ NUM_ ] || stream . read ( ) != LUA_SIGNATURE [ NUM_ ] ) return null ; String sname = getSourceName ( chunkname ) ; LoadState s = new LoadState ( stream , sname ) ; s . loadHeader ( ) ; switch ( s . luacNumberFormat ) { case NUMBER_FORMAT_FLOATS_OR_DOUBLES : case NUMBER_FORMAT_INTS_ONLY : case NUMBER_FORMAT_NUM_PATCH_INT32 : break ; default : throw new LuaError ( STR_ ) ; } return s . loadFunction ( LuaString . valueOf ( sname ) ) ; }
public void addButton ( URL url , String info , ActionListener al ) { JButton b = new JButton ( new ImageIcon ( url , info ) ) ; b . setToolTipText ( info ) ; b . setMargin ( new Insets ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; b . addActionListener ( al ) ; b . setBorderPainted ( BOOL_ ) ; add ( b ) ; }
private void mapRequestToResponses ( Matcher < Request > requestMatcher , ResponseSource responses ) { mappings . add ( new MatcherResponseSourcePair ( requestMatcher , responses ) ) ; }
@ Override protected void commitToInput ( ) { JmxBeanSensorAssignment assignment = getInput ( ) ; if ( null != assignment ) { assignment . setDomain ( domainText . getText ( ) ) ; assignment . setObjectNameParameters ( new HashMap < > ( parametersMap ) ) ; if ( allAttributesButton . getSelection ( ) ) { assignment . setAttributes ( Collections . < String > emptySet ( ) ) ; } else { assignment . setAttributes ( new HashSet < > ( attributesSet ) ) ; } } }
public static String [ ] split ( String original , String separator ) { Vector nodes = new Vector ( ) ; int index = original . indexOf ( separator ) ; while ( index >= NUM_ ) { nodes . addElement ( original . substring ( NUM_ , index ) ) ; original = original . substring ( index + separator . length ( ) ) ; index = original . indexOf ( separator ) ; } nodes . addElement ( original ) ; String [ ] ret = new String [ nodes . size ( ) ] ; for ( int i = NUM_ ; i < nodes . size ( ) ; i ++ ) { ret [ i ] = ( String ) nodes . elementAt ( i ) ; } return ret ; }
public void insertTwin ( Instruction inst , Instruction twin ) { ListIterator < GCIRMapElement > iter = list . listIterator ( ) ; while ( iter . hasNext ( ) ) { GCIRMapElement newPtr = iter . next ( ) ; if ( newPtr . getInstruction ( ) == inst ) { iter . add ( newPtr . createTwin ( twin ) ) ; return ; } } throw new OptimizingCompilerException ( STR_ + inst + STR_ ) ; }
public java . lang . Object newInstance ( ) throws java . lang . InstantiationException , java . lang . IllegalAccessException { Object o = newInstanceImpl ( ) ; if ( o == null ) { throw new InstantiationException ( ) ; } return o ; }
FormatSpecifierParser ( String format ) { this . format = format ; this . length = format . length ( ) ; }
public static void toString ( Iterator < ? > iter , String separator , StringBuilder sb ) { while ( iter . hasNext ( ) ) { sb . append ( iter . next ( ) ) ; if ( iter . hasNext ( ) ) { sb . append ( separator ) ; } } }
public boolean isFull ( ) { if ( maxSize > NUM_ && notifications . size ( ) >= maxSize ) { return BOOL_ ; } return BOOL_ ; }
private void schedulePlaylistSave ( ) { if ( ! mPlaylistLoading ) { if ( mPlaylistSavePending . compareAndSet ( BOOL_ , BOOL_ ) ) { mThreadPoolManager . scheduleOnce ( new PlaylistSaveTask ( ) , NUM_ , TimeUnit . SECONDS ) ; } } }
public boolean isToRead ( ) { Iterator < VariableValue > i = variables . iterator ( ) ; while ( i . hasNext ( ) ) { VariableValue v = i . next ( ) ; if ( v . isToRead ( ) ) { return BOOL_ ; } } return BOOL_ ; }
public void actionPerformed ( ActionEvent e ) { navigateToPriorDemo ( ) ; }
public String toString ( ) { StringBuffer text = new StringBuffer ( ) ; for ( int i = NUM_ ; i < m_Elements . length ; i ++ ) { if ( i > NUM_ ) text . append ( STR_ ) ; text . append ( Utils . doubleToString ( m_Elements [ i ] , NUM_ ) ) ; } text . append ( STR_ ) ; return text . toString ( ) ; }
@ Deprecated public static Integer Integer ( int i ) { return Integer . valueOf ( i ) ; }
public void or ( Criteria criteria ) { oredCriteria . add ( criteria ) ; }
public static void v ( String tag , String msg , Object ... args ) { if ( sLevel > LEVEL_VERBOSE ) { return ; } if ( args . length > NUM_ ) { msg = String . format ( msg , args ) ; } Log . v ( tag , msg ) ; }
public void saveIndexes ( ) { ArrayList toSave = new ArrayList ( ) ; synchronized ( this ) { Object [ ] valueTable = this . indexes . valueTable ; for ( int i = NUM_ , l = valueTable . length ; i < l ; i ++ ) { Index index = ( Index ) valueTable [ i ] ; if ( index != null ) toSave . add ( index ) ; } } boolean allSaved = BOOL_ ; for ( int i = NUM_ , length = toSave . size ( ) ; i < length ; i ++ ) { Index index = ( Index ) toSave . get ( i ) ; ReadWriteMonitor monitor = index . monitor ; if ( monitor == null ) continue ; try { monitor . enterRead ( ) ; if ( index . hasChanged ( ) ) { if ( monitor . exitReadEnterWrite ( ) ) { try { saveIndex ( index ) ; } catch ( IOException e ) { if ( VERBOSE ) { Util . verbose ( STR_ , System . err ) ; e . printStackTrace ( ) ; } allSaved = BOOL_ ; } finally { monitor . exitWriteEnterRead ( ) ; } } else { allSaved = BOOL_ ; } } } finally { monitor . exitRead ( ) ; } } if ( this . participantsContainers != null && this . participantUpdated ) { writeParticipantsIndexNamesFile ( ) ; this . participantUpdated = BOOL_ ; } this . needToSave = ! allSaved ; }
private double match_bitapScore ( int e , int x , int loc , String pattern ) { float accuracy = ( float ) e / pattern . length ( ) ; int proximity = Math . abs ( loc - x ) ; if ( Match_Distance == NUM_ ) { return proximity == NUM_ ? accuracy : NUM_ ; } return accuracy + ( proximity / ( float ) Match_Distance ) ; }
private void movePos ( float deltaY ) { if ( ( deltaY < NUM_ && mPtrIndicator . isInStartPosition ( ) ) ) { if ( DEBUG ) { PtrCLog . e ( LOG_TAG , String . format ( STR_ ) ) ; } return ; } int to = mPtrIndicator . getCurrentPosY ( ) + ( int ) deltaY ; if ( mPtrIndicator . willOverTop ( to ) ) { if ( DEBUG ) { PtrCLog . e ( LOG_TAG , String . format ( STR_ ) ) ; } to = PtrIndicator . POS_START ; } mPtrIndicator . setCurrentPos ( to ) ; int change = to - mPtrIndicator . getLastPosY ( ) ; updatePos ( change ) ; }
public void putAll ( Map < ? extends K , ? extends V > m ) { tryPresize ( m . size ( ) ) ; for ( Map . Entry < ? extends K , ? extends V > e : m . entrySet ( ) ) putVal ( e . getKey ( ) , e . getValue ( ) , BOOL_ ) ; }
public UndoableEdit insertString ( int where , String str ) throws BadLocationException { if ( where >= count || where < NUM_ ) { throw new BadLocationException ( STR_ , count ) ; } char [ ] chars = str . toCharArray ( ) ; replace ( where , NUM_ , chars , NUM_ , chars . length ) ; if ( marks != null ) { updateMarksForInsert ( where , str . length ( ) ) ; } return new InsertUndo ( where , str . length ( ) ) ; }
public String toString ( ) { return Byte . toString ( getValue ( ) ) ; }
boolean writeData ( ) throws IOException { int tosend ; int sent ; byte [ ] block = new byte [ kBlockSize ] ; do { tosend = Math . min ( sendStreamSize - totalSent , block . length ) ; System . arraycopy ( sendData , totalSent , block , NUM_ , tosend ) ; if ( tosend > NUM_ ) { sent = localSend ( block , tosend ) ; updateLocalClock ( ) ; if ( sent != - NUM_ ) { totalSent += sent ; } else { logger . log ( Level . FINE , STR_ ) ; } } else { sent = tosend = NUM_ ; } } while ( sent > NUM_ ) ; if ( logger . isLoggable ( Level . FINER ) ) { logger . log ( Level . FINER , STR_ + totalSent + STR_ + ( sendStreamSize - totalSent ) ) ; } return tosend == NUM_ ; }
public static int copyAndCloseOutput ( Reader input , Writer output ) throws IOException { try { return copy ( input , output ) ; } finally { output . close ( ) ; } }
public int checkBookiesUp ( int count , int timeout ) throws Exception { ZooKeeper zkc = connectZooKeeper ( zkHost , zkPort , zkTimeoutSec ) ; try { int mostRecentSize = NUM_ ; for ( int i = NUM_ ; i < timeout ; i ++ ) { try { List < String > children = zkc . getChildren ( STR_ , BOOL_ ) ; children . remove ( STR_ ) ; mostRecentSize = children . size ( ) ; if ( ( mostRecentSize > count ) || LOG . isDebugEnabled ( ) ) { LOG . info ( STR_ + mostRecentSize + STR_ + STR_ + count ) ; if ( ( mostRecentSize > count ) || LOG . isTraceEnabled ( ) ) { for ( String child : children ) { LOG . info ( STR_ + child ) ; } } } if ( mostRecentSize == count ) { break ; } } catch ( KeeperException e ) { } Thread . sleep ( NUM_ ) ; } return mostRecentSize ; } finally { zkc . close ( ) ; } }
public Point2D inverseTransform ( Point2D src , Point2D dst ) { try { src . setLocation ( src . getX ( ) + rotXOffset , src . getY ( ) + rotYOffset ) ; dst = rotTransform . inverseTransform ( src , dst ) ; } catch ( NoninvertibleTransformException e ) { logger . log ( Level . FINE , e . getMessage ( ) , e ) ; } return dst ; }
public static Throwable shouldFail ( Class clazz , Closure code ) { Throwable th = null ; try { code . call ( ) ; } catch ( GroovyRuntimeException gre ) { th = ScriptBytecodeAdapter . unwrap ( gre ) ; } catch ( Throwable e ) { th = e ; } if ( th == null ) { fail ( STR_ + code + STR_ + clazz . getName ( ) ) ; } else if ( ! clazz . isInstance ( th ) ) { fail ( STR_ + code + STR_ + clazz . getName ( ) + STR_ + th ) ; } return th ; }
public int write ( byte [ ] destMac , byte [ ] packet , int offset , int byteCount ) { if ( destMac == null ) { throw new NullPointerException ( STR_ ) ; } if ( packet == null ) { throw new NullPointerException ( STR_ ) ; } Arrays . checkOffsetAndCount ( packet . length , offset , byteCount ) ; if ( destMac . length != NUM_ ) { throw new IllegalArgumentException ( STR_ + destMac . length ) ; } return sendPacket ( fd , mInterfaceName , mProtocolType , destMac , packet , offset , byteCount ) ; }
private Boolean processYESNO ( StylesheetHandler handler , String uri , String name , String rawName , String value ) throws org . xml . sax . SAXException { if ( ! ( value . equals ( STR_ ) || value . equals ( STR_ ) ) ) { handleError ( handler , XSLTErrorResources . INVALID_BOOLEAN , new Object [ ] { name , value } , null ) ; return null ; } return new Boolean ( value . equals ( STR_ ) ? BOOL_ : BOOL_ ) ; }
protected ArrayList < KeyNamePair > loadRMAData ( int C_BPartner_ID ) { ArrayList < KeyNamePair > list = new ArrayList < KeyNamePair > ( ) ; String sqlStmt = STR_ + STR_ + STR_ + STR_ + STR_ ; PreparedStatement pstmt = null ; try { pstmt = DB . prepareStatement ( sqlStmt , null ) ; pstmt . setInt ( NUM_ , C_BPartner_ID ) ; ResultSet rs = pstmt . executeQuery ( ) ; while ( rs . next ( ) ) { list . add ( new KeyNamePair ( rs . getInt ( NUM_ ) , rs . getString ( NUM_ ) ) ) ; } rs . close ( ) ; } catch ( SQLException e ) { log . log ( Level . SEVERE , sqlStmt . toString ( ) , e ) ; } finally { if ( pstmt != null ) { try { pstmt . close ( ) ; } catch ( Exception ex ) { log . severe ( STR_ ) ; } } } return list ; }
@ Override public List < WorkOrder > searchWOForBilling ( final Map < String , Object > criteriaMap ) { logger . debug ( STR_ ) ; final List < WorkOrder > filteredList = new ArrayList < WorkOrder > ( ) ; criteriaMap . put ( ACTION_FLAG , STR_ ) ; for ( final WorkOrder workorder : searchWO ( criteriaMap ) ) if ( ! isWOValidforBill ( workorder . getId ( ) ) ) filteredList . add ( workorder ) ; return filteredList ; }
public Week ( Date time , TimeZone zone , Locale locale ) { ParamChecks . nullNotPermitted ( time , STR_ ) ; ParamChecks . nullNotPermitted ( zone , STR_ ) ; ParamChecks . nullNotPermitted ( locale , STR_ ) ; Calendar calendar = Calendar . getInstance ( zone , locale ) ; calendar . setTime ( time ) ; int tempWeek = calendar . get ( Calendar . WEEK_OF_YEAR ) ; if ( tempWeek == NUM_ && calendar . get ( Calendar . MONTH ) == Calendar . DECEMBER ) { this . week = NUM_ ; this . year = ( short ) ( calendar . get ( Calendar . YEAR ) + NUM_ ) ; } else { this . week = ( byte ) Math . min ( tempWeek , LAST_WEEK_IN_YEAR ) ; int yyyy = calendar . get ( Calendar . YEAR ) ; if ( calendar . get ( Calendar . MONTH ) == Calendar . JANUARY && this . week >= NUM_ ) { yyyy -- ; } this . year = ( short ) yyyy ; } peg ( calendar ) ; }
public ResourceQueue ( final NonBlockingLockManagerWithNewDesign < R > lockService , final R resource ) { if ( lockService == null ) throw new IllegalArgumentException ( ) ; if ( resource == null ) throw new IllegalArgumentException ( ) ; this . lockService = lockService ; this . resource = resource ; this . queue = new LinkedBlockingQueue < T > ( ) ; this . statisticsTask = new QueueSizeMovingAverageTask ( resource . toString ( ) , queue ) ; }
public void encodeAndSign ( X500Name subject , Signature signature ) throws CertificateException , IOException , SignatureException { DerOutputStream out , scratch ; byte [ ] certificateRequestInfo ; byte [ ] sig ; if ( encoded != null ) throw new SignatureException ( STR_ ) ; this . subject = subject ; scratch = new DerOutputStream ( ) ; scratch . putInteger ( BigInteger . ZERO ) ; subject . encode ( scratch ) ; scratch . write ( subjectPublicKeyInfo . getEncoded ( ) ) ; attributeSet . encode ( scratch ) ; out = new DerOutputStream ( ) ; out . write ( DerValue . tag_Sequence , scratch ) ; certificateRequestInfo = out . toByteArray ( ) ; scratch = out ; signature . update ( certificateRequestInfo , NUM_ , certificateRequestInfo . length ) ; sig = signature . sign ( ) ; AlgorithmId algId = null ; try { algId = AlgorithmId . get ( signature . getAlgorithm ( ) ) ; } catch ( NoSuchAlgorithmException nsae ) { throw new SignatureException ( nsae ) ; } algId . encode ( scratch ) ; scratch . putBitString ( sig ) ; out = new DerOutputStream ( ) ; out . write ( DerValue . tag_Sequence , scratch ) ; encoded = out . toByteArray ( ) ; }
public synchronized void schedulePeriodicTask ( TimerTask task , long period ) { try { m_timer . scheduleAtFixedRate ( task , NUM_ , period ) ; } catch ( IllegalStateException ie ) { m_timer = new Timer ( ) ; m_timer . scheduleAtFixedRate ( task , NUM_ , period ) ; } }
public static String abbreviate ( String str , FontMetrics fm , int width ) { int lastblank = NUM_ , nchars = NUM_ , cumx = NUM_ ; while ( cumx < width && nchars < str . length ( ) ) { if ( Character . isWhitespace ( str . charAt ( nchars ) ) ) { lastblank = nchars ; } cumx += fm . charWidth ( str . charAt ( nchars ) ) ; nchars ++ ; } if ( nchars < str . length ( ) && lastblank > NUM_ ) { nchars = lastblank ; } return ( nchars > NUM_ ? str . substring ( NUM_ , nchars ) : str ) ; }
protected void stopWraparoundTest ( ) { if ( testRunning && wrapTest ) { wrapTimer . stop ( ) ; statusText1 . setText ( STR_ + Integer . toString ( numErrors ) + STR_ ) ; statusText1 . setVisible ( BOOL_ ) ; statusText2 . setText ( Integer . toString ( numIterations ) + STR_ ) ; statusText2 . setVisible ( BOOL_ ) ; } }
protected void checkRowIndex ( final int row ) throws MathIllegalArgumentException { if ( row < NUM_ || row >= getRowDimension ( ) ) { throw new MathIllegalArgumentException ( LocalizedCoreFormats . ROW_INDEX , row , NUM_ , getRowDimension ( ) - NUM_ ) ; } }
private void nukeSymbols ( ) { _count = NUM_ ; _longestCollisionList = NUM_ ; Arrays . fill ( _mainHash , NUM_ ) ; Arrays . fill ( _mainNames , null ) ; Arrays . fill ( _collList , null ) ; _collCount = NUM_ ; _collEnd = NUM_ ; }
private static float determineEnemyBlitzStrength ( final Territory blitzHere , final List < Route > blitzTerrRoutes , final List < Territory > blockTerr , final GameData data , final PlayerID ePlayer ) { final HashSet < Integer > ignore = new HashSet < > ( ) ; ignore . add ( NUM_ ) ; final CompositeMatch < Unit > blitzUnit = new CompositeMatchAnd < > ( Matches . unitIsOwnedBy ( ePlayer ) , Matches . UnitCanBlitz , Matches . UnitCanMove ) ; final CompositeMatch < Territory > validBlitzRoute = new CompositeMatchAnd < > ( Matches . territoryHasNoEnemyUnits ( ePlayer , data ) , Matches . TerritoryIsNotImpassableToLandUnits ( ePlayer , data ) ) ; final List < Route > routes = new ArrayList < > ( ) ; final List < Unit > blitzUnits = findAttackers ( blitzHere , NUM_ , ignore , ePlayer , data , blitzUnit , validBlitzRoute , blockTerr , routes , BOOL_ ) ; for ( final Route r : routes ) { if ( r . numberOfSteps ( ) == NUM_ ) { blitzTerrRoutes . add ( r ) ; } } return strength ( blitzUnits , BOOL_ , BOOL_ , BOOL_ ) ; }
public Name join ( String identifier ) { validateLowerUnderscore ( identifier ) ; List < NamePiece > newPieceList = new ArrayList < > ( ) ; newPieceList . addAll ( namePieces ) ; newPieceList . add ( new NamePiece ( identifier , CaseFormat . LOWER_UNDERSCORE ) ) ; return new Name ( newPieceList ) ; }
private LocalDateTime parseDate ( String dateStr , boolean tryAgain ) { LocalDateTime date = LocalDateTime . now ( ZoneId . of ( STR_ ) ) ; if ( mDateTimeFormatter == null ) { initFormatter ( dateStr ) ; } if ( mDateTimeFormatter != null ) { try { date = LocalDateTime . parse ( dateStr , mDateTimeFormatter ) ; } catch ( DateTimeParseException e ) { Timber . d ( String . format ( STR_ , dateStr ) ) ; if ( tryAgain ) { Timber . d ( STR_ ) ; mDateTimeFormatter = null ; parseDate ( dateStr , BOOL_ ) ; } } } return date ; }
public String toString ( ) { String string = caller ; if ( level > NUM_ || thread != - NUM_ ) { string += STR_ ; } if ( level > NUM_ ) { string += level ; } if ( thread != - NUM_ ) { string += STR_ + thread ; } if ( level > NUM_ || thread != - NUM_ ) { string += STR_ ; } string += STR_ ; if ( spawnMessage ) { string += STR_ ; } if ( answer . length ( ) > NUM_ ) { string += answer + STR_ ; } if ( callee . length ( ) > NUM_ ) { string += callee + STR_ ; } string += message ; if ( returnsInstantly ) { string += STR_ ; } return string ; }
public static boolean isWhiteSpace ( int c ) { switch ( c ) { case NUL_CHAR : case STR_ : case STR_ : case FF_CHAR : case STR_ : case STR_ : return BOOL_ ; default : return BOOL_ ; } }
public void remove ( RequestFilter filter ) { filters . remove ( filter ) ; }
protected void removeClassifiers ( int [ ] indices ) { int i ; if ( indices == null ) { m_ModelClassifiers . removeAllElements ( ) ; } else { for ( i = indices . length - NUM_ ; i >= NUM_ ; i -- ) m_ModelClassifiers . remove ( indices [ i ] ) ; } setModified ( BOOL_ ) ; }
@ Override public void addPropertyChangeListener ( PropertyChangeListener pcl ) { m_pcSupport . addPropertyChangeListener ( pcl ) ; }
public int numCheckpoints ( ) { return checkpoints . size ( ) ; }
public void addElement ( Object anObject ) { p_data . add ( anObject ) ; fireIntervalAdded ( this , p_data . size ( ) - NUM_ , p_data . size ( ) - NUM_ ) ; if ( p_data . size ( ) == NUM_ && m_selectedObject == null && anObject != null ) setSelectedItem ( anObject ) ; }
public Builder addListenUrls ( List < String > urls ) { List < String > needAdd = new ArrayList < String > ( ) ; for ( String url : urls ) { if ( ! UrlUtil . isUrl ( url ) ) { continue ; } needAdd . add ( url ) ; } if ( ! CollectionUtil . isEmpty ( needAdd ) ) { if ( mListenUrls == null ) { mListenUrls = new HashSet < String > ( ) ; } mListenUrls . addAll ( needAdd ) ; } return this ; }
public void addAssignedVirtualArrays ( Set < String > virtualArrayURIs ) { if ( ( virtualArrayURIs != null ) && ( ! virtualArrayURIs . isEmpty ( ) ) ) { HashSet < String > addVirtualArrays = new HashSet < String > ( ) ; addVirtualArrays . addAll ( virtualArrayURIs ) ; if ( _assignedVirtualArrays == null ) { setAssignedVirtualArrays ( new StringSet ( ) ) ; _assignedVirtualArrays . addAll ( addVirtualArrays ) ; } else { _assignedVirtualArrays . addAll ( addVirtualArrays ) ; } updateVirtualArrayTags ( ) ; } }
@ Override public boolean isCellEditable ( int row , int column ) { EnvVar envVar = dataList . get ( row ) ; if ( column == COL_VALUE ) { return BOOL_ ; } return ! envVar . isPredefined ( ) ; }
private static char [ ] zzUnpackCMap ( String packed ) { char [ ] map = new char [ x10000 ] ; int i = NUM_ ; int j = NUM_ ; while ( i < NUM_ ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM_ ) ; } return map ; }
private boolean dropInTrash ( ) { if ( mHighlightedBlockView != null ) { mHighlightedBlockView . setHighlightedConnection ( null ) ; mHighlightedBlockView = null ; } mDraggedConnections . clear ( ) ; return mController . trashRootBlock ( mPendingDrag . getRootDraggedBlock ( ) ) ; }
< T > List < T > concatValues ( final T [ ] ... data ) { final List < T > rv = new ArrayList < > ( ) ; for ( T [ ] values : data ) { rv . addAll ( Arrays . asList ( values ) ) ; } return rv ; }
public DagIterator ( Graph pattern ) { for ( Edge edge : pattern . getEdges ( ) ) { if ( Edges . isDirectedEdge ( edge ) || Edges . isUndirectedEdge ( edge ) ) { continue ; } throw new IllegalArgumentException ( STR_ + STR_ + edge ) ; } decoratedGraphs . add ( new DecoratedGraph ( pattern ) ) ; }
private boolean validateCustomCatalog ( String title , String value ) { return BOOL_ ; }
public FunctionExecutionPooledExecutor ( BlockingQueue < Runnable > q , int poolSize , PoolStatHelper stats , ThreadFactory tf ) { this ( q , poolSize , stats , tf , Integer . getInteger ( DistributionConfig . GEMFIRE_PREFIX + STR_ , NUM_ . NUM_ ) , BOOL_ ) ; }
protected boolean isSSDPDiscovery ( String body ) { if ( body != null && body . startsWith ( STR_ ) && body . contains ( STR_ ) ) { return BOOL_ ; } return BOOL_ ; }
@ Override public void addChild ( WXComponent child , int index ) { if ( child == null || index < - NUM_ ) { return ; } if ( child instanceof WXBaseRefresh ) { if ( ! checkRefreshOrLoading ( child ) ) { mRefreshs . add ( child ) ; } return ; } if ( mChildren == null ) { mChildren = new ArrayList < > ( ) ; } int count = mChildren . size ( ) ; index = index >= count ? - NUM_ : index ; if ( index == - NUM_ ) { mChildren . add ( child ) ; } else { mChildren . add ( index , child ) ; } }
private void restoreSortingSelection ( int [ ] selection , int lead , ModelChange change ) { for ( int i = selection . length - NUM_ ; i >= NUM_ ; i -- ) { selection [ i ] = convertRowIndexToView ( selection [ i ] , change ) ; } lead = convertRowIndexToView ( lead , change ) ; if ( selection . length == NUM_ || ( selection . length == NUM_ && selection [ NUM_ ] == getSelectedRow ( ) ) ) { return ; } selectionModel . setValueIsAdjusting ( BOOL_ ) ; selectionModel . clearSelection ( ) ; for ( int i = selection . length - NUM_ ; i >= NUM_ ; i -- ) { if ( selection [ i ] != - NUM_ ) { selectionModel . addSelectionInterval ( selection [ i ] , selection [ i ] ) ; } } SwingUtilities2 . setLeadAnchorWithoutSelection ( selectionModel , lead , lead ) ; selectionModel . setValueIsAdjusting ( BOOL_ ) ; }
public synchronized byte [ ] toByteArray ( ) { int remaining = count ; if ( remaining == NUM_ ) { return EMPTY_BYTE_ARRAY ; } byte newbuf [ ] = new byte [ remaining ] ; int pos = NUM_ ; for ( byte [ ] buf : buffers ) { int c = Math . min ( buf . length , remaining ) ; System . arraycopy ( buf , NUM_ , newbuf , pos , c ) ; pos += c ; remaining -= c ; if ( remaining == NUM_ ) { break ; } } return newbuf ; }
@ After public void clean ( ) { mute ( null ) ; mute ( null ) ; mute ( null ) ; }
public void consume ( int eventCount , long timeoutInMillis , Predicate < Event > condition ) throws TimeoutException { if ( eventCount < NUM_ ) throw new IllegalArgumentException ( STR_ ) ; if ( eventCount == NUM_ ) return ; int eventsRemaining = eventCount ; final long stopTime = System . currentTimeMillis ( ) + timeoutInMillis ; while ( eventsRemaining > NUM_ && System . currentTimeMillis ( ) < stopTime ) { Event nextEvent = queue . poll ( ) ; if ( nextEvent != null ) { if ( condition . test ( nextEvent ) ) { -- eventsRemaining ; consumedEvents . accept ( nextEvent ) ; } else { ignoredEvents . accept ( nextEvent ) ; } } } if ( eventsRemaining > NUM_ ) { throw new TimeoutException ( STR_ + ( eventCount - eventsRemaining ) + STR_ + eventCount + STR_ + timeoutInMillis + STR_ ) ; } }
private void updateUiFromCommand ( Command command ) { if ( command == null ) { return ; } actionsComboBox . setText ( command . getAction ( ) ) ; dataTextField . setText ( command . getData ( ) ) ; categoryTextField . setText ( command . getCategory ( ) ) ; mimeTextField . setText ( command . getMimeType ( ) ) ; componentTextField . setText ( command . getComponent ( ) ) ; userTextField . setText ( command . getUser ( ) ) ; flagsList_ . removeSelectionInterval ( NUM_ , flagsList_ . getItemsCount ( ) ) ; List < IntentFlags > flags = command . getFlags ( ) ; if ( flags != null && flags . size ( ) > NUM_ ) { for ( IntentFlags flag : command . getFlags ( ) ) { flagsList_ . setSelectedValue ( flag , BOOL_ ) ; } } else { flagsList_ . setSelectedIndex ( NUM_ ) ; } updateFlagsTextField ( ) ; tableModel_ . removeAllRows ( ) ; List < ExtraField > extras = command . getExtras ( ) ; if ( extras != null && extras . size ( ) > NUM_ ) { for ( ExtraField extra : extras ) { tableModel_ . addRow ( extra ) ; } } updateTableVisibility ( ) ; }
public void testCompareToZeroZero ( ) { BigInteger aNumber = BigInteger . ZERO ; BigInteger bNumber = BigInteger . ZERO ; assertEquals ( NUM_ , aNumber . compareTo ( bNumber ) ) ; }
public static int randGaussian ( final int mean , final int sd ) { return ( int ) ( rand . nextGaussian ( ) . sd + mean ) ; }
private float computeOverscrollPercent ( ) { if ( mOverScrollOffset >= NUM_ ) { return mOverScrollOffset / mMaxOverScroll ; } else { return mOverScrollOffset / mMaxUnderScroll ; } }
public IVector ( int c ) { vector = new int [ Math . max ( defaultCapacity , c ) ] ; }
public void processInvite ( RequestEvent requestEvent , ServerTransaction serverTransaction ) { final Request request = requestEvent . getRequest ( ) ; final SipProvider sipProvider = ( SipProvider ) requestEvent . getSource ( ) ; ServerTransaction st = serverTransaction ; try { if ( st == null ) { try { st = sipProvider . getNewServerTransaction ( request ) ; } catch ( TransactionUnavailableException tae ) { tae . printStackTrace ( ) ; return ; } catch ( TransactionAlreadyExistsException taex ) { return ; } } final String toTag = STR_ + System . nanoTime ( ) ; Response response = messageFactory . createResponse ( Response . RINGING , request ) ; ToHeader toHeader = ( ToHeader ) response . getHeader ( ToHeader . NAME ) ; toHeader . setTag ( toTag ) ; st . sendResponse ( response ) ; response = messageFactory . createResponse ( Response . OK , request ) ; final Address address = addressFactory . createAddress ( STR_ + myAddress + STR_ + myPort + STR_ ) ; final ContactHeader contactHeader = headerFactory . createContactHeader ( address ) ; response . addHeader ( contactHeader ) ; toHeader = ( ToHeader ) response . getHeader ( ToHeader . NAME ) ; toHeader . setTag ( toTag ) ; st . sendResponse ( response ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }
public static IgniteLogger logger ( GridKernalContext ctx , AtomicReference < IgniteLogger > logRef , Object obj ) { IgniteLogger log = logRef . get ( ) ; if ( log == null ) { logRef . compareAndSet ( null , ctx . log ( obj . getClass ( ) ) ) ; log = logRef . get ( ) ; } return log ; }
protected boolean readReceiveDelay ( ) { try { receiveDelay = Integer . parseInt ( receiveDelayField . getText ( ) ) ; } catch ( Exception e ) { statusText1 . setText ( rb . getString ( STR_ ) ) ; statusText1 . setVisible ( BOOL_ ) ; receiveDelay = NUM_ ; errorInStatus1 = BOOL_ ; resetNotes2 ( ) ; return ( BOOL_ ) ; } if ( receiveDelay < NUM_ ) { statusText1 . setText ( rb . getString ( STR_ ) ) ; statusText1 . setVisible ( BOOL_ ) ; receiveDelay = NUM_ ; errorInStatus1 = BOOL_ ; resetNotes2 ( ) ; return ( BOOL_ ) ; } if ( receiveDelay > NUM_ ) { statusText1 . setText ( rb . getString ( STR_ ) ) ; statusText1 . setVisible ( BOOL_ ) ; receiveDelay = NUM_ ; errorInStatus1 = BOOL_ ; resetNotes2 ( ) ; return ( BOOL_ ) ; } return BOOL_ ; }
private void writeIndent ( int times ) throws IOException { for ( int i = options . getBaseIndent ( ) + times ; i > NUM_ ; i -- ) { writer . write ( options . getIndent ( ) ) ; } }
@ Override public int hashCode ( ) { int result = NUM_ ; Iterator < ? > it = iterator ( ) ; while ( it . hasNext ( ) ) { Object object = it . next ( ) ; result = ( NUM_ . result ) + ( object == null ? NUM_ : object . hashCode ( ) ) ; } return result ; }
public static int parseString ( String value ) { return Integer . parseInt ( value ) ; }
void doHandleJavaMouseEvent ( MouseEvent mouseEvent ) { if ( ! XToolkit . isLeftMouseButton ( mouseEvent ) && ! XToolkit . isRightMouseButton ( mouseEvent ) ) { return ; } XBaseWindow grabWindow = XAwtState . getGrabWindow ( ) ; Point ptGlobal = mouseEvent . getLocationOnScreen ( ) ; if ( ! hasPointerMoved ) { if ( grabInputPoint == null || ( Math . abs ( ptGlobal . x - grabInputPoint . x ) > getMouseMovementSmudge ( ) ) || ( Math . abs ( ptGlobal . y - grabInputPoint . y ) > getMouseMovementSmudge ( ) ) ) { hasPointerMoved = BOOL_ ; } } XBaseMenuWindow wnd = getMenuWindowFromPoint ( ptGlobal ) ; XMenuItemPeer item = ( wnd != null ) ? wnd . getItemFromPoint ( wnd . toLocal ( ptGlobal ) ) : null ; XBaseMenuWindow cwnd = getShowingLeaf ( ) ; switch ( mouseEvent . getID ( ) ) { case MouseEvent . MOUSE_PRESSED : showingMousePressedSubmenu = null ; if ( ( grabWindow == this ) && ( wnd == null ) ) { ungrabInput ( ) ; } else { grabInput ( ) ; if ( item != null && ! item . isSeparator ( ) && item . isTargetItemEnabled ( ) ) { if ( wnd . getShowingSubmenu ( ) == item ) { showingMousePressedSubmenu = ( XMenuPeer ) item ; } wnd . selectItem ( item , BOOL_ ) ; } else { if ( wnd != null ) { wnd . selectItem ( null , BOOL_ ) ; } } } break ; case MouseEvent . MOUSE_RELEASED : if ( item != null && ! item . isSeparator ( ) && item . isTargetItemEnabled ( ) ) { if ( item instanceof XMenuPeer ) { if ( showingMousePressedSubmenu == item ) { if ( wnd instanceof XMenuBarPeer ) { ungrabInput ( ) ; } else { wnd . selectItem ( item , BOOL_ ) ; } } } else { item . action ( mouseEvent . getWhen ( ) ) ; ungrabInput ( ) ; } } else { if ( hasPointerMoved || ( wnd instanceof XMenuBarPeer ) ) { ungrabInput ( ) ; } } showingMousePressedSubmenu = null ; break ; case MouseEvent . MOUSE_DRAGGED : if ( wnd != null ) { if ( item != null && ! item . isSeparator ( ) && item . isTargetItemEnabled ( ) ) { if ( grabWindow == this ) { wnd . selectItem ( item , BOOL_ ) ; } } else { wnd . selectItem ( null , BOOL_ ) ; } } else { if ( cwnd != null ) { cwnd . selectItem ( null , BOOL_ ) ; } } break ; } }
public boolean isInvalidNode ( ) { ASTNode first = fNodes . get ( NUM_ ) ; ASTNode candidate = first . getParent ( ) ; if ( candidate == null ) return BOOL_ ; if ( candidate . getNodeType ( ) == ASTNode . METHOD_DECLARATION ) return BOOL_ ; return BOOL_ ; }
public void push ( final float value ) { int bits = Float . floatToIntBits ( value ) ; if ( bits == NUM_ || bits == x3f800000 || bits == x40000000 ) { mv . visitInsn ( Opcodes . FCONST_0 + ( int ) value ) ; } else { mv . visitLdcInsn ( value ) ; } }
public void onMotion ( MotionEvent event , Interaction iact ) { }
public synchronized void removeBatchClustererListener ( BatchClustererListener cl ) { m_batchClustererListeners . remove ( cl ) ; }
public HeldLocksGrant refresh ( long expirationDateMs ) { return new HeldLocksGrant ( grantId , creationDateMs , expirationDateMs , lockMap , lockTimeout , versionId ) ; }
void removeKnownObject ( ParseObject object ) { synchronized ( mutex ) { knownObjects . remove ( object ) ; } }
static HeapBytesStore < byte [ ] > wrap ( @ NotNull byte [ ] bytes ) { return HeapBytesStore . wrap ( bytes ) ; }
private static String parse ( JsonValue base ) { if ( ! base . isString ( ) ) { return null ; } return buildString ( base . asString ( ) ) ; }
public void testValueOfLongNegative2 ( ) { long longVal = - NUM_ ; BigInteger aNumber = BigInteger . valueOf ( longVal ) ; byte rBytes [ ] = { - NUM_ , NUM_ , - NUM_ , - NUM_ } ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , - NUM_ , aNumber . signum ( ) ) ; }
public void beforeInsert ( int index , char element ) { if ( index > size || index < NUM_ ) throw new IndexOutOfBoundsException ( STR_ + index + STR_ + size ) ; ensureCapacity ( size + NUM_ ) ; System . arraycopy ( elements , index , elements , index + NUM_ , size - index ) ; elements [ index ] = element ; size ++ ; }
private void growEntries ( ) { int newLen = ( next . length << NUM_ ) + NUM_ ; int [ ] newNext = new int [ newLen ] ; GridUnsafe . copyMemory ( next , INT_ARR_OFF , newNext , INT_ARR_OFF , size << NUM_ ) ; next = newNext ; nextEmpty = new int [ newLen ] ; Arrays . fill ( nextEmpty , - NUM_ ) ; Object [ ] newObjs = new Object [ newLen ] ; System . arraycopy ( objs , NUM_ , newObjs , NUM_ , size ) ; objs = newObjs ; }
public SidedPlane ( final Vector p , final boolean onSide , final Vector A , final Vector B ) { super ( A , B ) ; sigNum = onSide ? Math . signum ( evaluate ( p ) ) : - Math . signum ( evaluate ( p ) ) ; if ( sigNum == NUM_ ) throw new IllegalArgumentException ( STR_ ) ; }
public static boolean isInputStreamGZIPCompressed ( final PushbackInputStream inputStream ) throws IOException { if ( inputStream == null ) return BOOL_ ; byte [ ] signature = new byte [ NUM_ ] ; int readStatus = inputStream . read ( signature ) ; inputStream . unread ( signature ) ; int streamHeader = ( ( int ) signature [ NUM_ ] & xff ) | ( ( signature [ NUM_ ] << NUM_ ) & xff00 ) ; return readStatus == NUM_ && GZIPInputStream . GZIP_MAGIC == streamHeader ; }
void insertOp ( int pos , int length , int op ) { int totalLen = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; for ( int i = totalLen - NUM_ ; i >= pos ; i -- ) { m_ops . setOp ( i + length , m_ops . getOp ( i ) ) ; } m_ops . setOp ( pos , op ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , totalLen + length ) ; }
private void clear ( ) { valid = BOOL_ ; if ( ( listenerObjects == null ) || listenerObjects . isEmpty ( ) ) { deregisterListener ( ) ; } ssm = null ; if ( SMSEntry . cacheSMSEntries ) { orgConfigs . clear ( ) ; globalConfigs . clear ( ) ; } }
public static void registerDecayableObject ( Decayable obj ) { decayObjects . add ( obj ) ; }
public static void assertExpectedOutputContains ( String expectedString , String x ) { if ( ! x . contains ( expectedString ) ) { fail ( STR_ + expectedString + STR_ + x + STR_ ) ; } }
public boolean remove ( String classname ) { String pkgname ; HashSet < String > names ; classname = cleanUp ( classname ) ; pkgname = extractPackage ( classname ) ; names = m_Cache . get ( pkgname ) ; if ( names != null ) { return names . remove ( classname ) ; } else { return BOOL_ ; } }
public void testFailedStage ( ) { CFException ex = new CFException ( ) ; CompletionStage < Integer > f = CompletableFuture . failedStage ( ex ) ; AtomicInteger x = new AtomicInteger ( NUM_ ) ; AtomicReference < Throwable > r = new AtomicReference < Throwable > ( ) ; f . whenComplete ( null ) ; assertEquals ( x . get ( ) , NUM_ ) ; assertEquals ( r . get ( ) , ex ) ; }
@ Override public void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D graphics = ( Graphics2D ) g ; graphics . setBackground ( mColorSpectrumBackground ) ; RenderingHints renderHints = new RenderingHints ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; renderHints . put ( RenderingHints . KEY_RENDERING , RenderingHints . VALUE_RENDER_QUALITY ) ; graphics . setRenderingHints ( renderHints ) ; drawFrequencies ( graphics ) ; drawCursor ( graphics ) ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
public void classLoaderDestroy ( DynamicClassLoader loader ) { Method destroy = getDestroyMethod ( _resource . getClass ( ) ) ; if ( destroy == null ) return ; try { destroy . invoke ( _resource ) ; } catch ( Throwable e ) { log . log ( Level . WARNING , e . toString ( ) , e ) ; } }
public boolean deleteAttachmentPoint ( DatapathId sw , OFPort port ) { AttachmentPoint ap = new AttachmentPoint ( sw , port , new Date ( NUM_ ) ) ; if ( this . oldAPs != null ) { ArrayList < AttachmentPoint > apList = new ArrayList < AttachmentPoint > ( ) ; apList . addAll ( this . oldAPs ) ; int index = apList . indexOf ( ap ) ; if ( index > NUM_ ) { apList . remove ( index ) ; this . oldAPs = apList ; } } if ( this . attachmentPoints != null ) { ArrayList < AttachmentPoint > apList = new ArrayList < AttachmentPoint > ( ) ; apList . addAll ( this . attachmentPoints ) ; int index = apList . indexOf ( ap ) ; if ( index > NUM_ ) { apList . remove ( index ) ; this . attachmentPoints = apList ; return BOOL_ ; } } return BOOL_ ; }
static boolean isAssignableTo ( ClassNode type , ClassNode toBeAssignedTo ) { if ( UNKNOWN_PARAMETER_TYPE == type ) return BOOL_ ; if ( type == toBeAssignedTo ) return BOOL_ ; if ( toBeAssignedTo . redirect ( ) == STRING_TYPE && type . redirect ( ) == GSTRING_TYPE ) { return BOOL_ ; } if ( isPrimitiveType ( toBeAssignedTo ) ) toBeAssignedTo = getWrapper ( toBeAssignedTo ) ; if ( isPrimitiveType ( type ) ) type = getWrapper ( type ) ; if ( Double_TYPE == toBeAssignedTo ) { return type . isDerivedFrom ( Number_TYPE ) ; } if ( Float_TYPE == toBeAssignedTo ) { return type . isDerivedFrom ( Number_TYPE ) && Double_TYPE != type . redirect ( ) ; } if ( Long_TYPE == toBeAssignedTo ) { return type . isDerivedFrom ( Number_TYPE ) && Double_TYPE != type . redirect ( ) && Float_TYPE != type . redirect ( ) ; } if ( Integer_TYPE == toBeAssignedTo ) { return type . isDerivedFrom ( Number_TYPE ) && Double_TYPE != type . redirect ( ) && Float_TYPE != type . redirect ( ) && Long_TYPE != type . redirect ( ) ; } if ( Short_TYPE == toBeAssignedTo ) { return type . isDerivedFrom ( Number_TYPE ) && Double_TYPE != type . redirect ( ) && Float_TYPE != type . redirect ( ) && Long_TYPE != type . redirect ( ) && Integer_TYPE != type . redirect ( ) ; } if ( Byte_TYPE == toBeAssignedTo ) { return type . redirect ( ) == Byte_TYPE ; } if ( type . isArray ( ) && toBeAssignedTo . isArray ( ) ) { return isAssignableTo ( type . getComponentType ( ) , toBeAssignedTo . getComponentType ( ) ) ; } if ( type . isDerivedFrom ( GSTRING_TYPE ) && STRING_TYPE . equals ( toBeAssignedTo ) ) { return BOOL_ ; } if ( toBeAssignedTo . isDerivedFrom ( GSTRING_TYPE ) && STRING_TYPE . equals ( type ) ) { return BOOL_ ; } if ( implementsInterfaceOrIsSubclassOf ( type , toBeAssignedTo ) ) { if ( OBJECT_TYPE . equals ( toBeAssignedTo ) ) return BOOL_ ; if ( toBeAssignedTo . isUsingGenerics ( ) ) { GenericsType gt = GenericsUtils . buildWildcardType ( toBeAssignedTo ) ; return gt . isCompatibleWith ( type ) ; } return BOOL_ ; } if ( type . isDerivedFrom ( CLOSURE_TYPE ) && isSAMType ( toBeAssignedTo ) ) { return BOOL_ ; } return BOOL_ ; }
public synchronized int totalRecoverFiles ( ) { int total = NUM_ ; for ( File file : fileDetails . values ( ) ) { if ( file . reused ( ) == BOOL_ ) { total ++ ; } } return total ; }
public static AnimGameItem process ( MD5Model md5Model , MD5AnimModel animModel , Vector3f defaultColour ) throws Exception { List < Matrix4f > invJointMatrices = calcInJointMatrices ( md5Model ) ; List < AnimatedFrame > animatedFrames = processAnimationFrames ( md5Model , animModel , invJointMatrices ) ; List < Mesh > list = new ArrayList < > ( ) ; for ( MD5Mesh md5Mesh : md5Model . getMeshes ( ) ) { Mesh mesh = generateMesh ( md5Model , md5Mesh ) ; handleTexture ( mesh , md5Mesh , defaultColour ) ; list . add ( mesh ) ; } Mesh [ ] meshes = new Mesh [ list . size ( ) ] ; meshes = list . toArray ( meshes ) ; AnimGameItem result = new AnimGameItem ( meshes , animatedFrames , invJointMatrices ) ; return result ; }
ConfigurationError ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; }
@ Override @ Timed public void deleteAssignment ( Experiment experiment , User . ID userID , Context context , Application . Name appName , Assignment currentAssignment ) { deleteUserFromLookUp ( experiment . getID ( ) , userID , context ) ; boolean countUp = BOOL_ ; assignmentsCountExecutor . execute ( new AssignmentCountEnvelope ( assignmentsRepository , experimentRepository , dbRepository , experiment , currentAssignment , countUp , eventLog , null , assignUserToExport , assignBucketCount ) ) ; deleteAssignmentOld ( experiment . getID ( ) , userID , context , appName , currentAssignment . getBucketLabel ( ) ) ; removeIndexUserToExperiment ( userID , experiment . getID ( ) , context , appName ) ; removeIndexUserToBucket ( userID , experiment . getID ( ) , context , currentAssignment . getBucketLabel ( ) ) ; removeIndexExperimentsToUser ( userID , experiment . getID ( ) , context , appName ) ; }
String format ( Object obj , StringBuffer toAppendTo ) throws IllegalArgumentException { Date source = null ; if ( obj instanceof Date ) { source = ( Date ) obj ; } else if ( obj instanceof String ) { try { source = parse ( ( String ) obj ) ; } catch ( ParseException pe ) { throw new RuntimeException ( pe . toString ( ) ) ; } } if ( source == null ) { throw new IllegalArgumentException ( ( obj == null ) ? STR_ : obj . toString ( ) ) ; } return format ( source , toAppendTo ) ; }
private static final boolean compareAndSetWaitStatus ( Node node , int expect , int update ) { return unsafe . compareAndSwapInt ( node , waitStatusOffset , expect , update ) ; }
public static ThreadDump create ( ) { ThreadDump threadDump = _threadDumpRef . get ( ) ; if ( threadDump == null ) { threadDump = new ThreadDumpPro ( ) ; _threadDumpRef . compareAndSet ( null , threadDump ) ; threadDump = _threadDumpRef . get ( ) ; } return threadDump ; }
private void checkStart ( ) { if ( mCanProcessAudio && ! mOutput . isRunning ( ) && mOutput . available ( ) <= mBufferStartThreshold ) { mOutput . start ( ) ; } }
protected boolean matchesFilter ( final String input , final String [ ] filter ) { for ( final String match : filter ) { if ( ! input . contains ( match ) ) return BOOL_ ; } return BOOL_ ; }
private E unlinkFirst ( ) { Node < E > f = first ; if ( f == null ) return null ; Node < E > n = f . next ; E item = f . item ; f . item = null ; f . next = f ; first = n ; if ( n == null ) last = null ; else n . prev = null ; -- count ; notFull . signal ( ) ; return item ; }
public IStatus run ( IProgressMonitor monitor ) { InputStream input = null ; FileOutputStream output = null ; IStatus jobStatus = Status . OK_STATUS ; byte [ ] b = new byte [ NUM_ ] ; int bytesRead ; try { HttpURLConnection connection = ( HttpURLConnection ) url . openConnection ( ) ; input = url . openStream ( ) ; long totalBytesRead = NUM_ ; int responseStatusCode = connection . getResponseCode ( ) ; if ( responseStatusCode >= HttpURLConnection . HTTP_BAD_REQUEST ) { jobStatus = new Status ( Status . ERROR , CorePlugin . PLUGIN_ID , MessageFormat . format ( STR_ , responseStatusCode , connection . getResponseMessage ( ) ) ) ; } long contentLength = connection . getContentLength ( ) ; output = new FileOutputStream ( target ) ; monitor . beginTask ( STR_ + url . toString ( ) , ( int ) contentLength ) ; while ( jobStatus == Status . OK_STATUS ) { if ( contentLength > NUM_ && totalBytesRead >= contentLength ) { break ; } bytesRead = input . read ( b ) ; if ( bytesRead == - NUM_ ) { break ; } output . write ( b , NUM_ , bytesRead ) ; totalBytesRead += bytesRead ; monitor . worked ( bytesRead ) ; if ( monitor . isCanceled ( ) ) { jobStatus = Status . CANCEL_STATUS ; break ; } } } catch ( MalformedURLException e ) { jobStatus = new Status ( Status . ERROR , CorePlugin . PLUGIN_ID , STR_ + url . toExternalForm ( ) , e ) ; } catch ( IOException e ) { jobStatus = new Status ( Status . ERROR , CorePlugin . PLUGIN_ID , STR_ + url . toExternalForm ( ) , e ) ; } closeStreams ( input , output ) ; return jobStatus ; }
private static synchronized void initDocBuilderFactory ( ) { docBuilderFactory = DocumentBuilderFactory . newInstance ( ) ; docBuilderFactory . setIgnoringComments ( BOOL_ ) ; docBuilderFactory . setCoalescing ( BOOL_ ) ; }
public double interceptStdErr ( ) { return Math . sqrt ( svar0 ) ; }
private void createMissingValues ( ) { String sql = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; PreparedStatement pstmt = null ; try { pstmt = DB . prepareStatement ( sql , get_TrxName ( ) ) ; pstmt . setInt ( NUM_ , getA_Registration_ID ( ) ) ; ResultSet rs = pstmt . executeQuery ( ) ; while ( rs . next ( ) ) { MRegistrationValue v = new MRegistrationValue ( this , rs . getInt ( NUM_ ) , STR_ ) ; v . saveEx ( ) ; } rs . close ( ) ; pstmt . close ( ) ; pstmt = null ; } catch ( Exception e ) { log . log ( Level . SEVERE , null , e ) ; } try { if ( pstmt != null ) pstmt . close ( ) ; pstmt = null ; } catch ( Exception e ) { pstmt = null ; } }
private static String normalisePath ( String path ) { return path . replace ( STR_ , STR_ ) ; }
public void startLaunchNotifier ( ) { if ( m_launchNotification == null ) throw new NullPointerException ( ) ; m_launchNotifierThread . setDaemon ( BOOL_ ) ; m_launchNotifierThread . start ( ) ; }
private static void encode ( List < AclEntry > acl , long address ) { long offset = address ; for ( AclEntry ace : acl ) { int flags = NUM_ ; UserPrincipal who = ace . principal ( ) ; if ( ! ( who instanceof UnixUserPrincipals . User ) ) throw new ProviderMismatchException ( ) ; UnixUserPrincipals . User user = ( UnixUserPrincipals . User ) who ; int uid ; if ( user . isSpecial ( ) ) { uid = - NUM_ ; if ( who == UnixUserPrincipals . SPECIAL_OWNER ) flags |= ACE_OWNER ; else if ( who == UnixUserPrincipals . SPECIAL_GROUP ) flags |= ( ACE_GROUP | ACE_IDENTIFIER_GROUP ) ; else if ( who == UnixUserPrincipals . SPECIAL_EVERYONE ) flags |= ACE_EVERYONE ; else throw new AssertionError ( STR_ ) ; } else { if ( user instanceof UnixUserPrincipals . Group ) { uid = user . gid ( ) ; flags |= ACE_IDENTIFIER_GROUP ; } else { uid = user . uid ( ) ; } } int type ; switch ( ace . type ( ) ) { case ALLOW : type = ACE_ACCESS_ALLOWED_ACE_TYPE ; break ; case DENY : type = ACE_ACCESS_DENIED_ACE_TYPE ; break ; case AUDIT : type = ACE_SYSTEM_AUDIT_ACE_TYPE ; break ; case ALARM : type = ACE_SYSTEM_ALARM_ACE_TYPE ; break ; default : throw new AssertionError ( STR_ ) ; } Set < AclEntryPermission > aceMask = ace . permissions ( ) ; int mask = NUM_ ; if ( aceMask . contains ( AclEntryPermission . READ_DATA ) ) mask |= ACE_READ_DATA ; if ( aceMask . contains ( AclEntryPermission . WRITE_DATA ) ) mask |= ACE_WRITE_DATA ; if ( aceMask . contains ( AclEntryPermission . APPEND_DATA ) ) mask |= ACE_APPEND_DATA ; if ( aceMask . contains ( AclEntryPermission . READ_NAMED_ATTRS ) ) mask |= ACE_READ_NAMED_ATTRS ; if ( aceMask . contains ( AclEntryPermission . WRITE_NAMED_ATTRS ) ) mask |= ACE_WRITE_NAMED_ATTRS ; if ( aceMask . contains ( AclEntryPermission . EXECUTE ) ) mask |= ACE_EXECUTE ; if ( aceMask . contains ( AclEntryPermission . DELETE_CHILD ) ) mask |= ACE_DELETE_CHILD ; if ( aceMask . contains ( AclEntryPermission . READ_ATTRIBUTES ) ) mask |= ACE_READ_ATTRIBUTES ; if ( aceMask . contains ( AclEntryPermission . WRITE_ATTRIBUTES ) ) mask |= ACE_WRITE_ATTRIBUTES ; if ( aceMask . contains ( AclEntryPermission . DELETE ) ) mask |= ACE_DELETE ; if ( aceMask . contains ( AclEntryPermission . READ_ACL ) ) mask |= ACE_READ_ACL ; if ( aceMask . contains ( AclEntryPermission . WRITE_ACL ) ) mask |= ACE_WRITE_ACL ; if ( aceMask . contains ( AclEntryPermission . WRITE_OWNER ) ) mask |= ACE_WRITE_OWNER ; if ( aceMask . contains ( AclEntryPermission . SYNCHRONIZE ) ) mask |= ACE_SYNCHRONIZE ; Set < AclEntryFlag > aceFlags = ace . flags ( ) ; if ( aceFlags . contains ( AclEntryFlag . FILE_INHERIT ) ) flags |= ACE_FILE_INHERIT_ACE ; if ( aceFlags . contains ( AclEntryFlag . DIRECTORY_INHERIT ) ) flags |= ACE_DIRECTORY_INHERIT_ACE ; if ( aceFlags . contains ( AclEntryFlag . NO_PROPAGATE_INHERIT ) ) flags |= ACE_NO_PROPAGATE_INHERIT_ACE ; if ( aceFlags . contains ( AclEntryFlag . INHERIT_ONLY ) ) flags |= ACE_INHERIT_ONLY_ACE ; unsafe . putInt ( offset + OFFSETOF_UID , uid ) ; unsafe . putInt ( offset + OFFSETOF_MASK , mask ) ; unsafe . putShort ( offset + OFFSETOF_FLAGS , ( short ) flags ) ; unsafe . putShort ( offset + OFFSETOF_TYPE , ( short ) type ) ; offset += SIZEOF_ACE_T ; } }
public static String expandHiddenDir ( final String filename ) { final int macro = filename . indexOf ( hiddenDirMacro , NUM_ ) ; String expandedFilter ; if ( macro == - NUM_ ) { return filename ; } if ( Cfg . DEBUG ) { Check . log ( TAG + STR_ ) ; } expandedFilter = filename . replaceFirst ( STR_ , StringUtils . chomp ( Path . hidden ( ) , STR_ ) ) ; if ( Cfg . DEBUG ) { Check . log ( TAG + STR_ + expandedFilter ) ; } return expandedFilter ; }
private boolean tryQueueCurrentBuffer ( long elapsedWaiting ) { if ( currentBuffer . isEmpty ( ) ) return BOOL_ ; if ( isOpen && neverPubQueue . size ( ) < neverPubCapacity ) { neverPubQueue . add ( currentBuffer ) ; totalQueuedRecords . addAndGet ( currentBuffer . sizeRecords ( ) ) ; totalQueuedBuffers . incrementAndGet ( ) ; onQueueBufferSuccess ( currentBuffer , elapsedWaiting ) ; currentBuffer = new RecordBuffer < > ( flow ) ; return BOOL_ ; } else if ( elapsedWaiting > NUM_ ) { onQueueBufferTimeout ( currentBuffer , elapsedWaiting ) ; return BOOL_ ; } else return BOOL_ ; }
public void updateValue ( final Object value , final boolean isSelected , boolean sync ) { if ( isReadOnly ( ) ) { return ; } if ( GenericFormFactory . isTextForm ( formType ) ) { textString = ( String ) value ; if ( textString != null && textString . equals ( lastTextString ) ) { sync = BOOL_ ; } lastTextString = textString ; } else { textString = ( String ) value ; this . isSelected = isSelected ; if ( isSelected != lastIsSelected && lastTextString != null && textString != null && textString . equals ( lastTextString ) ) { sync = BOOL_ ; } lastTextString = textString ; lastIsSelected = isSelected ; } if ( ( sync && guiType != FormFactory . ULC ) && guiComp != null ) { syncGUI ( value ) ; } }
public boolean hasNext ( ) throws IOException { dataInputStream . mark ( NUM_ ) ; int val = dataInputStream . read ( ) ; dataInputStream . reset ( ) ; return val != - NUM_ ; }
private final StringBuilder appendParameterSignature ( StringBuilder buffer , char [ ] [ ] parameterTypes , char [ ] [ ] parameterNames ) { if ( parameterTypes != null ) { for ( int i = NUM_ ; i < parameterTypes . length ; i ++ ) { if ( i > NUM_ ) { buffer . append ( STR_ ) ; buffer . append ( STR_ ) ; } buffer . append ( parameterTypes [ i ] ) ; if ( parameterNames != null && parameterNames [ i ] != null ) { buffer . append ( STR_ ) ; buffer . append ( parameterNames [ i ] ) ; } } } return buffer ; }
public void completeHeartbeat ( Database database , long seqno , String eventId ) throws SQLException { if ( logger . isDebugEnabled ( ) ) logger . debug ( STR_ ) ; Statement st = null ; ResultSet rs = null ; Timestamp sts = new Timestamp ( NUM_ ) ; Timestamp now = new Timestamp ( System . currentTimeMillis ( ) ) ; ArrayList < Column > whereClause = new ArrayList < Column > ( ) ; ArrayList < Column > values = new ArrayList < Column > ( ) ; if ( logger . isDebugEnabled ( ) ) logger . debug ( STR_ + now ) ; try { st = database . createStatement ( ) ; rs = st . executeQuery ( sourceTsQuery ) ; if ( rs . next ( ) ) sts = rs . getTimestamp ( NUM_ ) ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( SQLException e ) { } } if ( st != null ) { try { st . close ( ) ; } catch ( SQLException e ) { } } } long lag_millis = now . getTime ( ) - sts . getTime ( ) ; hbId . setValue ( KEY ) ; whereClause . add ( hbId ) ; hbSeqno . setValue ( seqno ) ; hbEventId . setValue ( eventId ) ; hbTargetTstamp . setValue ( now ) ; hbLagMillis . setValue ( lag_millis ) ; values . add ( hbSeqno ) ; values . add ( hbEventId ) ; values . add ( hbTargetTstamp ) ; values . add ( hbLagMillis ) ; database . update ( hbTable , whereClause , values ) ; }
public CipherParameters decrypt ( byte [ ] in , int inOff , int inLen , int keyLen ) throws IllegalArgumentException { if ( ! key . isPrivate ( ) ) { throw new IllegalArgumentException ( STR_ ) ; } BigInteger n = key . getModulus ( ) ; BigInteger d = key . getExponent ( ) ; byte [ ] C = new byte [ inLen ] ; System . arraycopy ( in , inOff , C , NUM_ , C . length ) ; BigInteger c = new BigInteger ( NUM_ , C ) ; BigInteger r = c . modPow ( d , n ) ; return generateKey ( n , r , keyLen ) ; }
public PrivateKey loadPrivateKey ( ) throws Exception { if ( defaultKeys ) { return getPrivateKeyFromString ( RSAKeyLoader . DEFAULT_PKEY ) ; } if ( priKey == null ) { FileReader f = new FileReader ( path + STR_ + this . id ) ; BufferedReader r = new BufferedReader ( f ) ; String tmp = STR_ ; String key = STR_ ; while ( ( tmp = r . readLine ( ) ) != null ) { key = key + tmp ; } f . close ( ) ; r . close ( ) ; priKey = getPrivateKeyFromString ( key ) ; } return priKey ; }
public void removeCategoriesListener ( SnapshotCategoriesListener listener ) { listeners . remove ( listener ) ; }
public boolean hasUnsupportedCriticalExtension ( ) { Set extns = getCriticalExtensionOIDs ( ) ; if ( extns == null ) { return BOOL_ ; } extns . remove ( RFC3280CertPathUtilities . ISSUING_DISTRIBUTION_POINT ) ; extns . remove ( RFC3280CertPathUtilities . DELTA_CRL_INDICATOR ) ; return ! extns . isEmpty ( ) ; }
private Integer zGetWeekNumberForASevenDayRange ( LocalDate firstDateInRange , WeekFields weekFieldRules , boolean requireUnanimousWeekNumber ) { ArrayList < Integer > weekNumbersList = new ArrayList < Integer > ( ) ; for ( int daysIntoTheFuture = NUM_ ; daysIntoTheFuture <= NUM_ ; ++ daysIntoTheFuture ) { LocalDate currentDateInRange ; try { currentDateInRange = firstDateInRange . plusDays ( daysIntoTheFuture ) ; int currentWeekNumber = currentDateInRange . get ( weekFieldRules . weekOfWeekBasedYear ( ) ) ; weekNumbersList . add ( currentWeekNumber ) ; } catch ( Exception ex ) { return NUM_ ; } } boolean isUnanimous = ( InternalUtilities . areObjectsEqual ( weekNumbersList . get ( NUM_ ) , weekNumbersList . get ( NUM_ ) ) ) ; if ( isUnanimous ) { return weekNumbersList . get ( NUM_ ) ; } if ( requireUnanimousWeekNumber ) { return null ; } int mostCommonWeekNumber = InternalUtilities . getMostCommonElementInList ( weekNumbersList ) ; return mostCommonWeekNumber ; }
private boolean isNotInArray ( String str , String [ ] array ) { for ( int i = NUM_ ; i < array . length ; i ++ ) { if ( str . equals ( array [ i ] ) ) { return BOOL_ ; } } return BOOL_ ; }
Node cloneOrImportNode ( short operation , Node node , boolean deep ) { NodeImpl copy = shallowCopy ( operation , node ) ; if ( deep ) { NodeList list = node . getChildNodes ( ) ; for ( int i = NUM_ ; i < list . getLength ( ) ; i ++ ) { copy . appendChild ( cloneOrImportNode ( operation , list . item ( i ) , deep ) ) ; } } notifyUserDataHandlers ( operation , node , copy ) ; return copy ; }
public static synchronized void cleanup ( ) { w . lock ( ) ; try { secp256k1_destroy_context ( Secp256k1Context . getContext ( ) ) ; } finally { w . unlock ( ) ; } }
public void init ( ) throws Exception { loadParameterFromZK ( ) ; _invalidLoginCleanupExecutor . scheduleWithFixedDelay ( new InvalidLoginCleaner ( ) , CLEANUP_THREAD_SCHEDULE_INTERVAL_IN_MINS , CLEANUP_THREAD_SCHEDULE_INTERVAL_IN_MINS , TimeUnit . MINUTES ) ; _log . info ( STR_ , _maxAuthnLoginAttemtsCount ) ; _log . info ( STR_ , _maxAuthnLoginAttemtsLifeTimeInMins ) ; _log . info ( STR_ , CLEANUP_THREAD_SCHEDULE_INTERVAL_IN_MINS ) ; }
public List < String > makeURLList ( String shard ) { List < String > urls = StrUtils . splitSmart ( shard , STR_ , BOOL_ ) ; for ( int i = NUM_ ; i < urls . size ( ) ; i ++ ) { urls . set ( i , buildUrl ( urls . get ( i ) ) ) ; } if ( urls . size ( ) > NUM_ ) Collections . shuffle ( urls , r ) ; return urls ; }
public InputStreamReader reader ( final String charset ) throws HttpRequestException { try { return new InputStreamReader ( stream ( ) , getValidCharset ( charset ) ) ; } catch ( UnsupportedEncodingException e ) { throw new HttpRequestException ( e ) ; } }
private byte [ ] toZLIB ( RenderedImage image , Color bkg , String colorModel ) throws IOException { return ImageGraphics2D . toByteArray ( image , ImageConstants . RAW , ImageConstants . ENCODING_FLATE_ASCII85 , ImageGraphics2D . getRAWProperties ( bkg , colorModel ) ) ; }
public void addVertex ( Object id ) throws IllegalArgumentException { if ( initialized ) { throw new IllegalArgumentException ( ) ; } Vertex vertex = new Vertex ( id ) ; Object existing = vertexMap . put ( id , vertex ) ; if ( existing != null ) { throw new IllegalArgumentException ( ) ; } vertexList . add ( vertex ) ; }
public void configureLocalServices ( ) { clientMemo . setLnTrafficController ( this ) ; clientMemo . configureCommandStation ( LnCommandStationType . COMMAND_STATION_DCS100 , BOOL_ , BOOL_ ) ; clientMemo . configureManagers ( ) ; }
private static int indexOf ( int fromIndex , CharSequence csq ) { if ( csq == null ) return NUM_ ; int length = csq . length ( ) ; int j = fromIndex ; int i = ( j < length ) ? csq . charAt ( j ++ ) : NUM_ ; i <<= NUM_ ; i |= ( j < length ) ? csq . charAt ( j ++ ) : NUM_ ; return i ; }
protected SizeRequirements calculateMinorAxisRequirements ( int axis , SizeRequirements r ) { updateGrid ( ) ; calculateColumnRequirements ( axis ) ; if ( r == null ) { r = new SizeRequirements ( ) ; } long min = NUM_ ; long pref = NUM_ ; int n = columnRequirements . length ; for ( int i = NUM_ ; i < n ; i ++ ) { SizeRequirements req = columnRequirements [ i ] ; min += req . minimum ; pref += req . preferred ; } int adjust = ( n + NUM_ ) . cellSpacing + NUM_ . borderWidth ; min += adjust ; pref += adjust ; r . minimum = ( int ) min ; r . preferred = ( int ) pref ; r . maximum = ( int ) pref ; AttributeSet attr = getAttributes ( ) ; CSS . LengthValue cssWidth = ( CSS . LengthValue ) attr . getAttribute ( CSS . Attribute . WIDTH ) ; if ( BlockView . spanSetFromAttributes ( axis , r , cssWidth , null ) ) { if ( r . minimum < ( int ) min ) { r . maximum = r . minimum = r . preferred = ( int ) min ; } } totalColumnRequirements . minimum = r . minimum ; totalColumnRequirements . preferred = r . preferred ; totalColumnRequirements . maximum = r . maximum ; Object o = attr . getAttribute ( CSS . Attribute . TEXT_ALIGN ) ; if ( o != null ) { String ta = o . toString ( ) ; if ( ta . equals ( STR_ ) ) { r . alignment = NUM_ ; } else if ( ta . equals ( STR_ ) ) { r . alignment = NUM_ ; } else if ( ta . equals ( STR_ ) ) { r . alignment = NUM_ ; } else { r . alignment = NUM_ ; } } else { r . alignment = NUM_ ; } return r ; }
public void append ( String string ) { for ( int i = NUM_ ; i < string . length ( ) ; i ++ ) append ( string . charAt ( i ) ) ; }
public ListenableFuture < String > push ( final String name , final Expression func ) { String let = String . format ( STR_ , name , func . toHaskell ( ) ) ; return pullRaw ( let ) ; }
public final String toString ( int depth ) { if ( depth <= NUM_ ) return STR_ ; return ( STR_ + super . toString ( depth ) + STR_ + mantissa + STR_ + exponent + STR_ + ( bigVal != null ? bigVal . toString ( ) : STR_ ) + STR_ + image ) ; }
public MetaDataColumnDescriptor ( String columnName , int jdbcType , Object defaultValue ) { _columnName = columnName . toUpperCase ( ) ; _jdbcType = jdbcType ; _defaultValue = defaultValue ; }
private void bulkLoad ( double [ ] lmin , double [ ] lmax , List < Node > children , ArrayModifiableDBIDs ids , int start , int end , int dim , int level , int code ) { if ( dim == NUM_ ) { DBIDArrayIter iter = ids . iter ( ) ; iter . seek ( start ) ; NumberVector first = relation . get ( iter ) ; iter . advance ( ) ; boolean degenerate = BOOL_ ; loop : for ( ; iter . getOffset ( ) < end ; iter . advance ( ) ) { NumberVector other = relation . get ( iter ) ; for ( int d = NUM_ ; d < lmin . length ; d ++ ) { if ( Math . abs ( first . doubleValue ( d ) - other . doubleValue ( d ) ) > NUM_ ) { degenerate = BOOL_ ; break loop ; } } } if ( degenerate ) { double [ ] center = new double [ lmin . length ] ; for ( int d = NUM_ ; d < lmin . length ; d ++ ) { center [ d ] = lmin [ d ] . NUM_ + lmax [ d ] . NUM_ + shift [ d ] ; if ( center [ d ] > min [ d ] + width [ d ] ) { center [ d ] -= width [ d ] ; } } children . add ( new Node ( code , center , end - start , level , null ) ) ; return ; } } if ( dim == lmin . length ) { double [ ] center = new double [ lmin . length ] ; for ( int d = NUM_ ; d < lmin . length ; d ++ ) { center [ d ] = lmin [ d ] . NUM_ + lmax [ d ] . NUM_ + shift [ d ] ; if ( center [ d ] > min [ d ] + width [ d ] ) { center [ d ] -= width [ d ] ; } } if ( end - start < nmin ) { children . add ( new Node ( code , center , end - start , level , null ) ) ; return ; } else { List < Node > newchildren = new ArrayList < > ( ) ; bulkLoad ( lmin , lmax , newchildren , ids , start , end , NUM_ , level + NUM_ , NUM_ ) ; children . add ( new Node ( code , center , end - start , level , newchildren ) ) ; return ; } } else { DBIDArrayIter siter = ids . iter ( ) , eiter = ids . iter ( ) ; siter . seek ( start ) ; eiter . seek ( end - NUM_ ) ; while ( siter . getOffset ( ) < eiter . getOffset ( ) ) { if ( getShiftedDim ( relation . get ( siter ) , dim , level ) <= NUM_ ) { siter . advance ( ) ; continue ; } if ( getShiftedDim ( relation . get ( eiter ) , dim , level ) > NUM_ ) { eiter . retract ( ) ; continue ; } ids . swap ( siter . getOffset ( ) , eiter . getOffset ( ) - NUM_ ) ; siter . advance ( ) ; eiter . retract ( ) ; } final int spos = siter . getOffset ( ) ; if ( start < spos ) { final double tmp = lmax [ dim ] ; lmax [ dim ] = lmax [ dim ] . NUM_ + lmin [ dim ] . NUM_ ; bulkLoad ( lmin , lmax , children , ids , start , spos , dim + NUM_ , level , code ) ; lmax [ dim ] = tmp ; } if ( spos < end ) { final double tmp = lmin [ dim ] ; lmin [ dim ] = lmax [ dim ] . NUM_ + lmin [ dim ] . NUM_ ; bulkLoad ( lmin , lmax , children , ids , spos , end , dim + NUM_ , level , code | ( NUM_ << dim ) ) ; lmin [ dim ] = tmp ; } } }
protected ArrayList < float [ ] > _forwardPoly ( float [ ] rawllpts , int ltype , int nsegs , boolean isFilled ) { boolean DEBUG = Debug . debugging ( STR_ ) ; int len = rawllpts . length > > > NUM_ ; if ( len < NUM_ ) return new ArrayList < float [ ] > ( NUM_ ) ; if ( isComplicatedLineType ( ltype ) ) return doPolyDispatch ( rawllpts , ltype , nsegs , isFilled ) ; int invalid_count = NUM_ ; boolean curr_invalid , prev_invalid = BOOL_ ; Point temp = new Point ( ) ; AzimuthVar az_first = null , az_save = null , azVar = new AzimuthVar ( ) ; ArrayList < AzimuthVar > sections = new ArrayList < AzimuthVar > ( NUM_ ) ; float [ ] x_ , xs = new float [ len ] ; float [ ] y_ , ys = new float [ len ] ; _forward ( rawllpts [ NUM_ ] , rawllpts [ NUM_ ] , temp , azVar ) ; xs [ NUM_ ] = temp . x ; ys [ NUM_ ] = temp . y ; prev_invalid = azVar . invalid_forward ; if ( prev_invalid ) { ++ invalid_count ; } else { azVar . index = NUM_ ; azVar . current_azimuth = GreatCircle . sphericalAzimuth ( ( float ) centerY , ( float ) centerX , rawllpts [ NUM_ ] , rawllpts [ NUM_ ] ) ; if ( ! isFilled ) { sections . add ( azVar ) ; } else { az_first = azVar ; } azVar = new AzimuthVar ( ) ; } int i = NUM_ , j = NUM_ ; for ( i = NUM_ , j = NUM_ ; i < len ; i ++ , j += NUM_ ) { azVar . invalid_forward = BOOL_ ; _forward ( rawllpts [ j ] , rawllpts [ j + NUM_ ] , temp , azVar ) ; curr_invalid = azVar . invalid_forward ; xs [ i ] = temp . x ; ys [ i ] = temp . y ; if ( ! curr_invalid && prev_invalid ) { azVar . index = i - NUM_ ; azVar . current_azimuth = GreatCircle . sphericalAzimuth ( ( float ) centerY , ( float ) centerX , rawllpts [ j - NUM_ ] , rawllpts [ j - NUM_ ] ) ; sections . add ( azVar ) ; azVar = new AzimuthVar ( ) ; } else if ( curr_invalid ) { if ( ! prev_invalid ) { azVar . index = i ; if ( isFilled && ( invalid_count == NUM_ ) ) { az_save = azVar ; } else { sections . add ( azVar ) ; } azVar = new AzimuthVar ( ) ; } ++ invalid_count ; } prev_invalid = curr_invalid ; } if ( invalid_count == NUM_ ) { ArrayList < float [ ] > ret_val = new ArrayList < float [ ] > ( NUM_ ) ; ret_val . add ( xs ) ; ret_val . add ( ys ) ; return ret_val ; } if ( invalid_count == len ) { return new ArrayList < float [ ] > ( NUM_ ) ; } if ( ! prev_invalid ) { if ( isFilled && ( az_save != null ) ) { int l = az_save . index ; x_ = new float [ len + l ] ; y_ = new float [ len + l ] ; System . arraycopy ( xs , NUM_ , x_ , NUM_ , len ) ; System . arraycopy ( ys , NUM_ , y_ , NUM_ , len ) ; System . arraycopy ( xs , NUM_ , x_ , len , l ) ; System . arraycopy ( ys , NUM_ , y_ , len , l ) ; az_save . index = len + l ; sections . add ( az_save ) ; xs = x_ ; ys = y_ ; } else { if ( DEBUG && isFilled && ( az_save == null ) ) { Debug . output ( STR_ ) ; } azVar . index = i ; j = rawllpts . length ; azVar . current_azimuth = GreatCircle . sphericalAzimuth ( ( float ) centerY , ( float ) centerX , rawllpts [ j - NUM_ ] , rawllpts [ j - NUM_ ] ) ; sections . add ( azVar ) ; } } else if ( az_save != null ) { if ( DEBUG ) Debug . output ( STR_ ) ; sections . add ( az_first ) ; sections . add ( az_save ) ; } int size = sections . size ( ) ; ArrayList < float [ ] > ret_val = new ArrayList < float [ ] > ( size ) ; if ( isFilled && ( len > NUM_ ) ) { generateFilledPoly ( xs , ys , sections , ret_val ) ; return ret_val ; } for ( j = NUM_ ; j < size ; j += NUM_ ) { AzimuthVar az1 = ( AzimuthVar ) sections . get ( j ) ; AzimuthVar az2 = ( AzimuthVar ) sections . get ( j + NUM_ ) ; int off1 = az1 . index ; int off2 = az2 . index ; int l = off2 - off1 ; x_ = new float [ l ] ; y_ = new float [ l ] ; System . arraycopy ( xs , off1 , x_ , NUM_ , l ) ; System . arraycopy ( ys , off1 , y_ , NUM_ , l ) ; ret_val . add ( x_ ) ; ret_val . add ( y_ ) ; } return ret_val ; }
private ArrayList < String > filterYears ( ArrayList < String > items ) { Iterator < String > iterator ; Calendar now = Calendar . getInstance ( ) ; int year = now . get ( Calendar . YEAR ) ; String yearInString = String . valueOf ( year ) ; Log . d ( TAG , STR_ + yearInString ) ; int prevYear = year - NUM_ ; String prevYearInString = String . valueOf ( prevYear ) ; Log . d ( TAG , STR_ + prevYearInString ) ; for ( iterator = items . iterator ( ) ; iterator . hasNext ( ) ; ) { String s = iterator . next ( ) ; if ( s . matches ( STR_ ) && ! s . contains ( yearInString ) && ! s . contains ( prevYearInString ) ) { Log . d ( TAG , STR_ + s ) ; iterator . remove ( ) ; } } Log . d ( TAG , STR_ + items . toString ( ) ) ; return items ; }
public DataProviderEvent ( final LocalizableMessage reason , final Set < Type > types ) { Reject . ifNull ( reason , types ) ; Reject . ifTrue ( types . isEmpty ( ) ) ; this . reason = reason ; final EnumSet < Type > tmp = EnumSet . noneOf ( Type . class ) ; tmp . addAll ( types ) ; this . types = Collections . unmodifiableSet ( tmp ) ; }
public < T > List < String > validateBean ( T bean , String errIfBeanNull ) { List < String > errors = new ArrayList < String > ( ) ; if ( bean == null ) { errors . add ( errIfBeanNull ) ; return errors ; } Set < ConstraintViolation < T > > violations = validator . validate ( bean ) ; for ( ConstraintViolation < T > violation : violations ) { errors . add ( violation . getMessage ( ) ) ; } return errors ; }
protected void smartInsertAfterBracket ( IDocument document , DocumentCommand command ) { if ( command . offset == - NUM_ || document . getLength ( ) == NUM_ ) { return ; } try { int p = ( command . offset == document . getLength ( ) ? command . offset - NUM_ : command . offset ) ; int line = document . getLineOfOffset ( p ) ; int start = document . getLineOffset ( line ) ; int whiteend = findEndOfWhiteSpace ( document , start , command . offset ) ; if ( whiteend == command . offset ) { int indLine = findMatchingOpenBracket ( document , line , command . offset , NUM_ ) ; if ( indLine != - NUM_ && indLine != line ) { StringBuffer replaceText = new StringBuffer ( getIndentOfLine ( document , indLine ) ) ; replaceText . append ( document . get ( whiteend , command . offset - whiteend ) ) ; replaceText . append ( command . text ) ; command . length = command . offset - start ; command . offset = start ; command . text = replaceText . toString ( ) ; } } } catch ( BadLocationException e ) { GWTPluginLog . logError ( e ) ; } }
private String attemptToChooseFormattingPattern ( ) { if ( nationalNumber . length ( ) >= MIN_LEADING_DIGITS_LENGTH ) { getAvailableFormats ( nationalNumber . toString ( ) ) ; String formattedNumber = attemptToFormatAccruedDigits ( ) ; if ( formattedNumber . length ( ) > NUM_ ) { return formattedNumber ; } return maybeCreateNewTemplate ( ) ? inputAccruedNationalNumber ( ) : accruedInput . toString ( ) ; } else { return appendNationalNumber ( nationalNumber . toString ( ) ) ; } }
private void fillPicks ( ) throws Exception { MLookup orgL = MLookupFactory . get ( Env . getCtx ( ) , m_WindowNo , NUM_ , NUM_ , DisplayType . TableDir ) ; fWarehouse = new VLookup ( STR_ , BOOL_ , BOOL_ , BOOL_ , orgL ) ; lWarehouse . setText ( Msg . translate ( Env . getCtx ( ) , STR_ ) ) ; fWarehouse . addVetoableChangeListener ( this ) ; m_M_Warehouse_ID = fWarehouse . getValue ( ) ; MLookup bpL = MLookupFactory . get ( Env . getCtx ( ) , m_WindowNo , NUM_ , NUM_ , DisplayType . Search ) ; fBPartner = new VLookup ( STR_ , BOOL_ , BOOL_ , BOOL_ , bpL ) ; lBPartner . setText ( Msg . translate ( Env . getCtx ( ) , STR_ ) ) ; fBPartner . addVetoableChangeListener ( this ) ; lDocType . setText ( Msg . translate ( Env . getCtx ( ) , STR_ ) ) ; cmbDocType . addItem ( new KeyNamePair ( MOrder . Table_ID , Msg . translate ( Env . getCtx ( ) , STR_ ) ) ) ; cmbDocType . addItem ( new KeyNamePair ( MRMA . Table_ID , Msg . translate ( Env . getCtx ( ) , STR_ ) ) ) ; cmbDocType . addActionListener ( this ) ; }
@ Override protected FieldConfigBase createCopy ( FieldConfigBase fieldConfigBase ) { FieldConfigFontPreview copy = null ; if ( fieldConfigBase != null ) { copy = new FieldConfigFontPreview ( fieldConfigBase . getCommonData ( ) ) ; } return copy ; }
public void testConstructorSignBytesZeroNull3 ( ) { byte aBytes [ ] = { } ; int aSign = NUM_ ; byte rBytes [ ] = { NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , aNumber . signum ( ) ) ; }
public Object castToType ( int t , XPathContext support ) throws javax . xml . transform . TransformerException { Object result ; switch ( t ) { case CLASS_STRING : result = str ( ) ; break ; case CLASS_NUMBER : result = new Double ( num ( ) ) ; break ; case CLASS_NODESET : result = iter ( ) ; break ; case CLASS_BOOLEAN : result = new Boolean ( bool ( ) ) ; break ; case CLASS_UNKNOWN : result = m_obj ; break ; default : error ( XPATHErrorResources . ER_CANT_CONVERT_TO_TYPE , new Object [ ] { getTypeString ( ) , Integer . toString ( t ) } ) ; result = null ; } return result ; }
public static void forceDeleteOnExit ( File file ) throws IOException { if ( file . isDirectory ( ) ) { deleteDirectoryOnExit ( file ) ; } else { file . deleteOnExit ( ) ; } }
public boolean init ( StepMetaInterface smi , StepDataInterface sdi ) { this . meta = ( ( SortKeyStepMeta ) smi ) ; this . data = ( ( SortKeyStepData ) sdi ) ; return super . init ( smi , sdi ) ; }
private void printAnnotationFromEditor ( final WorkflowAnnotation anno , final Graphics2D g2 ) { Graphics2D gPr = ( Graphics2D ) g2 . create ( ) ; Rectangle2D loc = anno . getLocation ( ) ; gPr . translate ( loc . getX ( ) , loc . getY ( ) ) ; gPr . setClip ( NUM_ , NUM_ , ( int ) loc . getWidth ( ) , ( int ) loc . getHeight ( ) ) ; Dimension size = new Dimension ( ( int ) loc . getWidth ( ) , ( int ) loc . getHeight ( ) ) ; pane . setSize ( size ) ; pane . setText ( AnnotationDrawUtils . createStyledCommentString ( anno ) ) ; pane . setCaretPosition ( NUM_ ) ; pane . paint ( gPr ) ; gPr . dispose ( ) ; }
public void add ( IPoint pt ) { if ( inProgress ) { throw new ConcurrentModificationException ( STR_ ) ; } points . add ( pt ) ; }
public static Configuration load ( Reader reader ) throws IOException { try { Properties properties = new Properties ( ) ; properties . load ( reader ) ; return from ( properties ) ; } finally { reader . close ( ) ; } }
public void add ( OffsettedItem item ) { throwIfPrepared ( ) ; try { if ( item . getAlignment ( ) > getAlignment ( ) ) { throw new IllegalArgumentException ( STR_ ) ; } } catch ( NullPointerException ex ) { throw new NullPointerException ( STR_ ) ; } items . add ( item ) ; }
public static void addAnnotationToXML ( Element annotationsElement , String name , String value ) { if ( value == null ) { deleteAnnotationFromXML ( annotationsElement , name ) ; } else { final Document doc = annotationsElement . getOwnerDocument ( ) ; Element elem = doc . createElement ( STR_ ) ; annotationsElement . appendChild ( elem ) ; elem . setAttribute ( STR_ , name ) ; elem . setTextContent ( value ) ; } }
public boolean readBoolean ( ) throws IOException { return primitiveTypes . readBoolean ( ) ; }
public Enumeration < String > enumerateMeasures ( ) { Vector < String > newVector = new Vector < String > ( NUM_ ) ; newVector . addElement ( STR_ ) ; return newVector . elements ( ) ; }
@ Override public Instances defineDataFormat ( ) throws Exception { ArrayList < Attribute > atts ; ArrayList < String > attValues ; int i ; m_Random = new Random ( getSeed ( ) ) ; m_nextClassShouldBeZero = BOOL_ ; m_lastLabel = Double . NaN ; setNumExamplesAct ( getNumExamples ( ) ) ; atts = new ArrayList < Attribute > ( ) ; atts . add ( new Attribute ( STR_ ) ) ; atts . add ( new Attribute ( STR_ ) ) ; atts . add ( new Attribute ( STR_ ) ) ; attValues = new ArrayList < String > ( ) ; for ( i = NUM_ ; i < NUM_ ; i ++ ) { attValues . add ( STR_ + i ) ; } atts . add ( new Attribute ( STR_ , attValues ) ) ; attValues = new ArrayList < String > ( ) ; for ( i = NUM_ ; i <= NUM_ ; i ++ ) { attValues . add ( STR_ + i ) ; } atts . add ( new Attribute ( STR_ , attValues ) ) ; attValues = new ArrayList < String > ( ) ; for ( i = NUM_ ; i < NUM_ ; i ++ ) { attValues . add ( STR_ + i ) ; } atts . add ( new Attribute ( STR_ , attValues ) ) ; atts . add ( new Attribute ( STR_ ) ) ; atts . add ( new Attribute ( STR_ ) ) ; atts . add ( new Attribute ( STR_ ) ) ; attValues = new ArrayList < String > ( ) ; for ( i = NUM_ ; i < NUM_ ; i ++ ) { attValues . add ( STR_ + i ) ; } atts . add ( new Attribute ( STR_ , attValues ) ) ; m_DatasetFormat = new Instances ( getRelationNameToUse ( ) , atts , NUM_ ) ; return m_DatasetFormat ; }
private static char [ ] zzUnpackCMap ( String packed ) { char [ ] map = new char [ x10000 ] ; int i = NUM_ ; int j = NUM_ ; while ( i < NUM_ ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM_ ) ; } return map ; }
public void startTicker ( long delay , boolean rightToLeft ) { if ( ! tickerEnabled ) { return ; } if ( ! isCellRenderer ( ) ) { Form parent = getComponentForm ( ) ; if ( parent != null ) { parent . registerAnimatedInternal ( this ) ; } } tickerStartTime = System . currentTimeMillis ( ) ; tickerDelay = delay ; tickerRunning = BOOL_ ; this . rightToLeft = rightToLeft ; if ( isRTL ( ) ) { this . rightToLeft = ! this . rightToLeft ; } }
static CipherSuite valueOf ( int id1 , int id2 ) { id1 &= xff ; id2 &= xff ; int id = ( id1 << NUM_ ) | id2 ; CipherSuite c = idMap . get ( id ) ; if ( c == null ) { String h1 = Integer . toString ( id1 , NUM_ ) ; String h2 = Integer . toString ( id2 , NUM_ ) ; c = new CipherSuite ( STR_ + h1 + STR_ + h2 , id ) ; } return c ; }
public static Context createPendingActionContext ( Context context , ReconAction action , String mappingName , JsonValue sourceObject , String reconId , Situation situation ) { Map < String , Object > pendingActionMap = new HashMap < String , Object > ( ) ; pendingActionMap . put ( MAPPING_NAME , mappingName ) ; pendingActionMap . put ( SOURCE_OBJECT , sourceObject ) ; pendingActionMap . put ( RECON_ID , reconId ) ; pendingActionMap . put ( ORIGINAL_SITUATION , situation . toString ( ) ) ; PendingActionContext pendingActionContext = new PendingActionContext ( context , pendingActionMap , action . toString ( ) ) ; return pendingActionContext ; }
private static char [ ] zzUnpackCMap ( String packed ) { char [ ] map = new char [ x10000 ] ; int i = NUM_ ; int j = NUM_ ; while ( i < NUM_ ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM_ ) ; } return map ; }
public void showDroidsafeTextMarkers ( IEditorPart openedEditor , String className ) { if ( openedEditor != null && openedEditor instanceof ITextEditor && fProcessedClasses != null ) { ITextEditor editor = ( ITextEditor ) openedEditor ; if ( fProcessedClasses . contains ( className ) ) { if ( fClassesNeedUpdate . contains ( className ) ) { ClassMarkerProcessor classProcessor = get ( className ) ; classProcessor . updateTaintMarkers ( editor ) ; fClassesNeedUpdate . remove ( className ) ; } } else { fProcessedClasses . add ( className ) ; Map < String , Map < IntRange , Map < String , Set < CallLocationModel > > > > classTaintedDataMap = fTaintedDataMap . get ( className ) ; Map < String , Set < IntRange > > classUnreachableMethodMap = fUnreachableSourceMethodMap . get ( className ) ; if ( classTaintedDataMap != null || classUnreachableMethodMap != null ) { IEditorInput input = editor . getEditorInput ( ) ; if ( input instanceof FileEditorInput ) { ClassMarkerProcessor classProcessor = get ( className ) ; classProcessor . showDroidsafeTextMarkers ( editor ) ; } } } } }
private static void resolveNewExpression ( NewExpression objSubjectExpression , HashSet < String > objTypesSet ) { ClassReference objClassRef = objSubjectExpression . getClassReference ( ) ; if ( null == objClassRef || null == objClassRef . getFQN ( ) ) { objTypesSet . add ( Types . strResolvingAbortedOnPsiLevel ) ; return ; } objTypesSet . add ( objClassRef . getFQN ( ) ) ; }
private static List < Size > pickUpToThree ( List < Size > sizes ) { List < Size > result = new ArrayList < Size > ( ) ; Size largest = sizes . get ( NUM_ ) ; result . add ( largest ) ; Size lastSize = largest ; for ( Size size : sizes ) { double targetArea = Math . pow ( NUM_ , result . size ( ) ) . area ( largest ) ; if ( area ( size ) < targetArea ) { if ( ! result . contains ( lastSize ) && ( targetArea - area ( lastSize ) < area ( size ) - targetArea ) ) { result . add ( lastSize ) ; } else { result . add ( size ) ; } } lastSize = size ; if ( result . size ( ) == NUM_ ) { break ; } } if ( result . size ( ) < NUM_ && ! result . contains ( lastSize ) ) { result . add ( lastSize ) ; } return result ; }
private boolean verifyLogRecord ( String [ ] record , int macPos ) throws Exception { StringBuilder data = new StringBuilder ( ) ; for ( int m = NUM_ ; m < record . length - NUM_ ; m ++ ) { data . append ( record [ m ] ) ; } curMAC = record [ macPos ] ; verified = helper . verifyMAC ( data . toString ( ) , helper . toByteArray ( curMAC ) ) ; return verified ; }
public static void copyToClipboard ( Transferable t ) { ClipboardHelper . copyToClipboard ( t ) ; }
public static String formatPercent ( int downloadSize , int fileSize ) { float num = ( float ) downloadSize / fileSize ; float percent = ( ( float ) ( int ) ( num . NUM_ ) ) / NUM_ ; return String . valueOf ( percent + STR_ ) ; }
final private String attrDef2AttrDesc ( Attributes attrs ) throws NamingException { StringBuffer attrDesc = new StringBuffer ( STR_ ) ; Attribute attr = null ; int count = NUM_ ; attr = attrs . get ( NUMERICOID_ID ) ; if ( attr != null ) { attrDesc . append ( writeNumericOID ( attr ) ) ; count ++ ; } else { throw new ConfigurationException ( STR_ + STR_ ) ; } attr = attrs . get ( NAME_ID ) ; if ( attr != null ) { attrDesc . append ( writeQDescrs ( attr ) ) ; count ++ ; } attr = attrs . get ( DESC_ID ) ; if ( attr != null ) { attrDesc . append ( writeQDString ( attr ) ) ; count ++ ; } attr = attrs . get ( OBSOLETE_ID ) ; if ( attr != null ) { attrDesc . append ( writeBoolean ( attr ) ) ; count ++ ; } attr = attrs . get ( SUP_ID ) ; if ( attr != null ) { attrDesc . append ( writeWOID ( attr ) ) ; count ++ ; } attr = attrs . get ( EQUALITY_ID ) ; if ( attr != null ) { attrDesc . append ( writeWOID ( attr ) ) ; count ++ ; } attr = attrs . get ( ORDERING_ID ) ; if ( attr != null ) { attrDesc . append ( writeWOID ( attr ) ) ; count ++ ; } attr = attrs . get ( SUBSTR_ID ) ; if ( attr != null ) { attrDesc . append ( writeWOID ( attr ) ) ; count ++ ; } attr = attrs . get ( SYNTAX_ID ) ; if ( attr != null ) { attrDesc . append ( writeWOID ( attr ) ) ; count ++ ; } attr = attrs . get ( SINGLE_VAL_ID ) ; if ( attr != null ) { attrDesc . append ( writeBoolean ( attr ) ) ; count ++ ; } attr = attrs . get ( COLLECTIVE_ID ) ; if ( attr != null ) { attrDesc . append ( writeBoolean ( attr ) ) ; count ++ ; } attr = attrs . get ( NO_USER_MOD_ID ) ; if ( attr != null ) { attrDesc . append ( writeBoolean ( attr ) ) ; count ++ ; } attr = attrs . get ( USAGE_ID ) ; if ( attr != null ) { attrDesc . append ( writeQDString ( attr ) ) ; count ++ ; } if ( count < attrs . size ( ) ) { String attrId = null ; for ( NamingEnumeration < ? extends Attribute > ae = attrs . getAll ( ) ; ae . hasMoreElements ( ) ; ) { attr = ae . next ( ) ; attrId = attr . getID ( ) ; if ( attrId . equals ( NUMERICOID_ID ) || attrId . equals ( NAME_ID ) || attrId . equals ( SYNTAX_ID ) || attrId . equals ( DESC_ID ) || attrId . equals ( SINGLE_VAL_ID ) || attrId . equals ( EQUALITY_ID ) || attrId . equals ( ORDERING_ID ) || attrId . equals ( SUBSTR_ID ) || attrId . equals ( NO_USER_MOD_ID ) || attrId . equals ( USAGE_ID ) || attrId . equals ( SUP_ID ) || attrId . equals ( COLLECTIVE_ID ) || attrId . equals ( OBSOLETE_ID ) ) { continue ; } else { attrDesc . append ( writeQDStrings ( attr ) ) ; } } } attrDesc . append ( STR_ ) ; return attrDesc . toString ( ) ; }
private void updateActions ( ) { String selectedText = getSelectedText ( ) ; if ( selectedText == null ) selectedText = STR_ ; boolean stuffSelected = ! selectedText . equals ( STR_ ) ; boolean allSelected = selectedText . equals ( getText ( ) ) ; UNDO_ACTION . setEnabled ( isEnabled ( ) && isEditable ( ) && isUndoAvailable ( ) ) ; CUT_ACTION . setEnabled ( isEnabled ( ) && isEditable ( ) && stuffSelected ) ; COPY_ACTION . setEnabled ( isEnabled ( ) && stuffSelected ) ; PASTE_ACTION . setEnabled ( isEnabled ( ) && isEditable ( ) && isPasteAvailable ( ) ) ; DELETE_ACTION . setEnabled ( isEnabled ( ) && stuffSelected ) ; SELECT_ALL_ACTION . setEnabled ( isEnabled ( ) && ! allSelected ) ; }
public static < T > Collection < T > makeImmutable ( Collection < T > mutableCollection ) { Collection < T > newCollection ; try { @ SuppressWarnings ( STR_ ) Class < Collection < T > > cls = ( Class < Collection < T > > ) mutableCollection . getClass ( ) ; newCollection = cls . newInstance ( ) ; } catch ( InstantiationException | IllegalAccessException e ) { throw new IllegalStateException ( e ) ; } for ( T element : mutableCollection ) { newCollection . add ( Utils . makeImmutable ( element ) ) ; } return Collections . unmodifiableCollection ( newCollection ) ; }
public synchronized void trackHexImages ( IHex hex , MediaTracker tracker ) { Image base = hexToImageCache . get ( hex ) ; List < Image > superImgs = hexToImageListCache . get ( hex ) ; List < Image > orthoImgs = orthoListCache . get ( hex ) ; tracker . addImage ( base , NUM_ ) ; if ( superImgs != null ) { for ( Iterator < Image > i = superImgs . iterator ( ) ; i . hasNext ( ) ; ) { tracker . addImage ( i . next ( ) , NUM_ ) ; } } if ( orthoImgs != null ) { for ( Iterator < Image > i = orthoImgs . iterator ( ) ; i . hasNext ( ) ; ) { tracker . addImage ( i . next ( ) , NUM_ ) ; } } }
public static Date parseText ( String dateStr ) { try { return mSimpleTextFormat . parse ( dateStr ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( STR_ ) ; } }
public boolean isProcessed ( Trace trace , Node node , Direction direction ) { boolean ret = BOOL_ ; if ( processor . getNodeType ( ) == node . getType ( ) && processor . getDirection ( ) == direction ) { if ( uriFilter == null || uriFilter . test ( node . getUri ( ) ) ) { ret = BOOL_ ; } } if ( log . isLoggable ( Level . FINEST ) ) { log . finest ( STR_ + trace + STR_ + node + STR_ + direction + STR_ + ret ) ; } return ret ; }
@ Override public synchronized void powerOnSelfTest ( ) throws Error { for ( Iterator < WaveformSynthesizer > it = waveformSynthesizers . iterator ( ) ; it . hasNext ( ) ; ) { WaveformSynthesizer ws = it . next ( ) ; ws . powerOnSelfTest ( ) ; } }
private QuadEdge [ ] fetchTriangleToVisit ( QuadEdge edge , Stack edgeStack , boolean includeFrame , Set visitedEdges ) { QuadEdge curr = edge ; int edgeCount = NUM_ ; boolean isFrame = BOOL_ ; do { triEdges [ edgeCount ] = curr ; if ( isFrameEdge ( curr ) ) isFrame = BOOL_ ; QuadEdge sym = curr . sym ( ) ; if ( ! visitedEdges . contains ( sym ) ) edgeStack . push ( sym ) ; visitedEdges . add ( curr ) ; edgeCount ++ ; curr = curr . lNext ( ) ; } while ( curr != edge ) ; if ( isFrame && ! includeFrame ) return null ; return triEdges ; }
public Collection engineGenerateCRLs ( InputStream inStream ) throws CRLException { CRL crl ; List crls = new ArrayList ( ) ; while ( ( crl = engineGenerateCRL ( inStream ) ) != null ) { crls . add ( crl ) ; } return crls ; }
public void deleteEntityConfig ( String realm , String federationId ) throws WSFederationMetaException { if ( federationId == null ) { return ; } if ( realm == null ) { realm = STR_ ; } String [ ] objs = { federationId , realm } ; try { Map oldAttrs = configInst . getConfiguration ( realm , federationId ) ; Set oldValues = ( Set ) oldAttrs . get ( ATTR_ENTITY_CONFIG ) ; if ( oldValues == null || oldValues . isEmpty ( ) ) { LogUtil . error ( Level . INFO , LogUtil . NO_ENTITY_DESCRIPTOR_DELETE_ENTITY_CONFIG , objs , null ) ; throw new WSFederationMetaException ( STR_ , objs ) ; } IDPSSOConfigElement idpconfig = getIDPSSOConfig ( realm , federationId ) ; if ( idpconfig != null ) { removeFromCircleOfTrust ( idpconfig , realm , federationId ) ; } SPSSOConfigElement spconfig = getSPSSOConfig ( realm , federationId ) ; if ( spconfig != null ) { removeFromCircleOfTrust ( spconfig , realm , federationId ) ; } Set attr = new HashSet ( ) ; attr . add ( ATTR_ENTITY_CONFIG ) ; configInst . deleteConfiguration ( realm , federationId , attr ) ; LogUtil . access ( Level . INFO , LogUtil . ENTITY_CONFIG_DELETED , objs , null ) ; WSFederationMetaCache . putEntityConfig ( realm , federationId , null ) ; } catch ( ConfigurationException e ) { debug . error ( STR_ , e ) ; String [ ] data = { e . getMessage ( ) , federationId , realm } ; LogUtil . error ( Level . INFO , LogUtil . CONFIG_ERROR_DELETE_ENTITY_CONFIG , data , null ) ; throw new WSFederationMetaException ( e ) ; } }
public static synchronized DataSourceViewsManager sharedInstance ( ) { if ( sharedInstance == null ) sharedInstance = new DataSourceViewsManager ( ) ; return sharedInstance ; }
public String tag ( String inner , String c1 , String c2 ) { boolean color = ( ( attr & ATTR_COLOR ) == ATTR_COLOR ) && ToastBootstrap . color ; String s = STR_ ; if ( color ) s += STR_ + c1 + STR_ ; s += inner ; if ( color ) s += STR_ + c2 + STR_ ; s += STR_ ; if ( color ) s += STR_ + c1 + STR_ ; return color ? Pretty . format ( s ) : s ; }
private final String loadXmlDefinition ( ) { final Cache cache = CacheFactory . getAnyInstance ( ) ; final StringWriter stringWriter = new StringWriter ( ) ; final PrintWriter printWriter = new PrintWriter ( stringWriter ) ; CacheXmlGenerator . generate ( cache , printWriter , BOOL_ , BOOL_ , BOOL_ ) ; printWriter . close ( ) ; return loadXmlDefinition ( stringWriter . toString ( ) ) ; }
private Long id ( HttpServletRequest request ) { Long id = null ; String pathInfo = request . getPathInfo ( ) ; if ( pathInfo != null && pathInfo . length ( ) > NUM_ ) { String idString = pathInfo . substring ( NUM_ ) ; id = Long . valueOf ( idString ) ; } return id ; }
public void uncompress ( ) { data . position ( NUM_ ) ; InflaterInputStream inflater = new InflaterInputStream ( data . asInputStream ( ) ) ; byte [ ] buffer = new byte [ NUM_ ] ; IoBuffer tmp = IoBuffer . allocate ( NUM_ ) ; tmp . setAutoExpand ( BOOL_ ) ; try { while ( inflater . available ( ) > NUM_ ) { int decompressed = inflater . read ( buffer ) ; if ( decompressed <= NUM_ ) { break ; } tmp . put ( buffer , NUM_ , decompressed ) ; } } catch ( IOException e ) { tmp . free ( ) ; throw new RuntimeException ( STR_ , e ) ; } finally { if ( inflater != null ) { try { inflater . close ( ) ; } catch ( IOException e1 ) { } } } data . free ( ) ; data = tmp ; data . flip ( ) ; prepareIO ( ) ; }
public void poll ( final TcpSocketStatisticsHandler handler ) { this . statisticsHandler = handler ; try { fileLoader . load ( ) ; final ByteBuffer buffer = fileLoader . getBuffer ( ) ; lineParser . reset ( ) ; lineParser . handleToken ( buffer , buffer . position ( ) , buffer . limit ( ) ) ; } finally { this . statisticsHandler = null ; } monitoredSockets . purgeEntriesOlderThan ( updateCount ) ; updateCount ++ ; }
@ Override public void close ( ) throws IOException { synchronized ( lock ) { if ( ! isClosed ( ) ) { in . close ( ) ; buf = null ; } } }
public int compareTo ( CharBuffer otherBuffer ) { int compareRemaining = ( remaining ( ) < otherBuffer . remaining ( ) ) ? remaining ( ) : otherBuffer . remaining ( ) ; int thisPos = position ; int otherPos = otherBuffer . position ; char thisByte , otherByte ; while ( compareRemaining > NUM_ ) { thisByte = get ( thisPos ) ; otherByte = otherBuffer . get ( otherPos ) ; if ( thisByte != otherByte ) { return thisByte < otherByte ? - NUM_ : NUM_ ; } thisPos ++ ; otherPos ++ ; compareRemaining -- ; } return remaining ( ) - otherBuffer . remaining ( ) ; }
public UrbanSimZoneCSVWriterV2 ( String matsim4opusTempDirectory , String matsimOutputDirectory ) { this . matsim4opusTempDirectory = matsim4opusTempDirectory ; this . matsimOutputDirectory = matsimOutputDirectory ; try { log . info ( STR_ ) ; zoneWriter = IOUtils . getBufferedWriter ( matsim4opusTempDirectory + FILE_NAME ) ; log . info ( STR_ + matsim4opusTempDirectory + FILE_NAME + STR_ ) ; zoneWriter . write ( Labels . ZONE_ID + STR_ + Labels . ACCESSIBILITY_BY_FREESPEED + STR_ + Labels . ACCESSIBILITY_BY_CAR + STR_ + Labels . ACCESSIBILITY_BY_BIKE + STR_ + Labels . ACCESSIBILITY_BY_WALK + STR_ + Labels . ACCESSIBILITY_BY_PT ) ; zoneWriter . newLine ( ) ; log . info ( STR_ ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
@ Override public void agg ( Object newVal ) { if ( newVal instanceof byte [ ] ) { ByteBuffer buffer = ByteBuffer . wrap ( ( byte [ ] ) newVal ) ; buffer . rewind ( ) ; while ( buffer . hasRemaining ( ) ) { aggVal += buffer . getLong ( ) ; count += buffer . getDouble ( ) ; firstTime = BOOL_ ; } return ; } aggVal += ( Long ) newVal ; count ++ ; firstTime = BOOL_ ; }
private static PolicyNotification extractPolicyNotification ( String xml ) throws PolicyEvaluationException { PolicyNotification policyNotification = null ; try { String notificationDataBlock = getNotificationDataBlock ( xml ) ; if ( notificationDataBlock != null ) { Document doc = XMLUtils . getXMLDocument ( new ByteArrayInputStream ( notificationDataBlock . getBytes ( ) ) ) ; Node rootNode = XMLUtils . getRootNode ( doc , NODE_POLICY_SERVICE ) ; if ( rootNode != null ) { Node notificationNode = XMLUtils . getChildNode ( rootNode , NODE_POLICY_NOTIFICATION ) ; if ( notificationNode != null ) { policyNotification = PolicyNotification . parseXML ( notificationNode ) ; } else { debug . error ( STR_ + STR_ + STR_ ) ; throw new PolicyEvaluationException ( ResBundleUtils . rbName , STR_ , null , null ) ; } } else { debug . error ( STR_ + STR_ ) ; } } else { debug . error ( STR_ + STR_ + STR_ ) ; } } catch ( Exception xe ) { debug . error ( STR_ , xe ) ; throw new PolicyEvaluationException ( ResBundleUtils . rbName , STR_ , null , xe ) ; } return policyNotification ; }
public synchronized void flush ( ) throws IOException { checkNotClosed ( ) ; trimToSize ( ) ; journalWriter . flush ( ) ; }
private Object findParcel ( @ NonNull byte [ ] objectArray , @ NonNull String className ) { try { Class classTmp = getClassForName ( className ) ; Constructor declaredConstructor = classTmp . getDeclaredConstructor ( Parcel . class ) ; declaredConstructor . setAccessible ( BOOL_ ) ; return declaredConstructor . newInstance ( WearBusTools . byteToParcel ( objectArray ) ) ; } catch ( Exception e ) { Log . d ( WearBusTools . BUSWEAR_TAG , STR_ + e . getMessage ( ) ) ; } return null ; }
private static final String decodeFieldName ( final String pXmlFieldName ) { StringBuilder str = new StringBuilder ( ) ; int fieldNameLength = pXmlFieldName . length ( ) ; char currentChar ; for ( int i = NUM_ ; i < fieldNameLength ; i ++ ) { currentChar = pXmlFieldName . charAt ( i ) ; if ( currentChar == STR_ ) { str . append ( Character . toUpperCase ( pXmlFieldName . charAt ( ++ i ) ) ) ; } else { str . append ( currentChar ) ; } } return str . toString ( ) ; }
public boolean isLoginSet ( ) { return ( username != null && ( password != null && ! username . equals ( STR_ ) && ! password . equals ( STR_ ) ) ) || oauth ; }
public void addContentItem ( ContentItem contentItem ) { if ( contentItems == null ) { contentItems = new ArrayList < ContentItem > ( ) ; } contentItems . add ( contentItem ) ; }
public static String canonicalizeClassName ( String name ) { String classname = name . replace ( STR_ , STR_ ) ; classname = classname . replace ( STR_ , STR_ ) ; if ( classname . startsWith ( STR_ ) ) classname = classname . substring ( NUM_ ) ; if ( classname . endsWith ( STR_ ) ) classname = classname . substring ( NUM_ , classname . length ( ) - NUM_ ) ; return classname ; }
public static final void pause ( final int milliseconds ) { if ( milliseconds >= NUM_ || logger . isDebugEnabled ( ) ) { logger . info ( STR_ , milliseconds ) ; } final long target = System . currentTimeMillis ( ) + milliseconds ; try { for ( ; ; ) { long msLeft = target - System . currentTimeMillis ( ) ; if ( msLeft <= NUM_ ) { break ; } Thread . sleep ( msLeft ) ; } } catch ( InterruptedException e ) { Assert . fail ( STR_ , e ) ; } }
public boolean isHighlightWithInvisibleEdge ( ) { return highlightWithInvisibleEdge ; }
private Configuration prepareJobForCancelling ( ) throws Exception { prepareFile ( STR_ , NUM_ ) ; executedTasks . set ( NUM_ ) ; cancelledTasks . set ( NUM_ ) ; failMapperId . set ( NUM_ ) ; splitsCount . set ( NUM_ ) ; Configuration cfg = new Configuration ( ) ; setupFileSystems ( cfg ) ; Job job = Job . getInstance ( cfg ) ; job . setOutputKeyClass ( Text . class ) ; job . setOutputValueClass ( IntWritable . class ) ; job . setMapperClass ( CancellingTestMapper . class ) ; job . setNumReduceTasks ( NUM_ ) ; job . setInputFormatClass ( InFormat . class ) ; FileInputFormat . setInputPaths ( job , new Path ( STR_ + getTestGridName ( NUM_ ) + STR_ ) ) ; FileOutputFormat . setOutputPath ( job , new Path ( STR_ + getTestGridName ( NUM_ ) + STR_ ) ) ; job . setJarByClass ( getClass ( ) ) ; return job . getConfiguration ( ) ; }
public void removeChangingListener ( OnWheelChangedListener listener ) { changingListeners . remove ( listener ) ; }
protected void generateFields ( ) { for ( Iterator < Element > iterator = mElements . iterator ( ) ; iterator . hasNext ( ) ; ) { Element element = iterator . next ( ) ; if ( ! element . used ) { iterator . remove ( ) ; continue ; } PsiField [ ] fields = mClass . getFields ( ) ; boolean duplicateField = BOOL_ ; for ( PsiField field : fields ) { String name = field . getName ( ) ; if ( name != null && name . equals ( element . getFieldName ( ) ) ) { duplicateField = BOOL_ ; break ; } } if ( duplicateField ) { iterator . remove ( ) ; continue ; } mClass . add ( mFactory . createFieldFromText ( STR_ + element . name + STR_ + element . getFieldName ( ) + STR_ , mClass ) ) ; } }
public boolean isFlying ( ) { return ( flyThroughDialog != null ) ; }
public synchronized void init ( ) { channelFactory = new NioClientSocketChannelFactory ( Executors . newCachedThreadPool ( ) , Executors . newCachedThreadPool ( ) ) ; datagramChannelFactory = new NioDatagramChannelFactory ( Executors . newCachedThreadPool ( ) ) ; timer = new HashedWheelTimer ( ) ; }
public static String removePattern ( final String source , final String regex ) { return replacePattern ( source , regex , StringUtils . EMPTY ) ; }
private void consumeNestedScroll ( int dxUnconsumed , int dyUnconsumed , int dxFinalUnconsumed , int dyFinalUnconsumed ) { if ( mOverScrollEffect == OverScrollEffect . BOUNCE && dyFinalUnconsumed != NUM_ ) { mUnconsumedOverScrollOffset += - dyFinalUnconsumed ; int maxOffset = mOverScrollOffsetLimit ; if ( mUnconsumedOverScrollOffset > NUM_ ) { mUnconsumedOverScrollOffset = Math . min ( maxOffset , mUnconsumedOverScrollOffset ) ; } else if ( mUnconsumedOverScrollOffset < NUM_ ) { mUnconsumedOverScrollOffset = Math . max ( - maxOffset , mUnconsumedOverScrollOffset ) ; } setScrollingOffset ( getUnconsumedScrollingOffset ( ) ) ; } pullEdgeEffects ( dxUnconsumed , dyUnconsumed ) ; }
private void retrieveWaypoints ( SearchQuery query , ArrayList < Waypoint > waypoints ) { String queryLikeSelection2 = STR_ + query . textQuery + STR_ ; String [ ] waypointSelectionArgs = new String [ ] { queryLikeSelection2 , queryLikeSelection2 , queryLikeSelection2 } ; Cursor cursor = null ; try { cursor = providerUtils . getWaypointCursor ( WAYPOINT_SELECTION_QUERY , waypointSelectionArgs , WAYPOINT_SELECTION_ORDER , MAX_SCORED_WAYPOINTS ) ; if ( cursor != null ) { waypoints . ensureCapacity ( cursor . getCount ( ) ) ; while ( cursor . moveToNext ( ) ) { Waypoint waypoint = providerUtils . createWaypoint ( cursor ) ; if ( LocationUtils . isValidLocation ( waypoint . getLocation ( ) ) ) { waypoints . add ( waypoint ) ; } } } } finally { if ( cursor != null ) { cursor . close ( ) ; } } }
void release ( ) { imageLoader . cancelPendingRequests ( ) ; loading = new boolean [ noxItems . size ( ) ] ; }
public int size ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { return count ; } finally { lock . unlock ( ) ; } }
public void add ( String name , long cnt ) { if ( _values == null ) { _values = new ArrayList < > ( NUM_ ) ; } _values . add ( new Count ( this , name , cnt ) ) ; }
private static void decodeTextCompaction ( int [ ] textCompactionData , int [ ] byteCompactionData , int length , StringBuilder result ) { Mode subMode = Mode . ALPHA ; Mode priorToShiftMode = Mode . ALPHA ; int i = NUM_ ; while ( i < length ) { int subModeCh = textCompactionData [ i ] ; char ch = NUM_ ; switch ( subMode ) { case ALPHA : if ( subModeCh < NUM_ ) { ch = ( char ) ( STR_ + subModeCh ) ; } else { if ( subModeCh == NUM_ ) { ch = STR_ ; } else if ( subModeCh == LL ) { subMode = Mode . LOWER ; } else if ( subModeCh == ML ) { subMode = Mode . MIXED ; } else if ( subModeCh == PS ) { priorToShiftMode = subMode ; subMode = Mode . PUNCT_SHIFT ; } else if ( subModeCh == MODE_SHIFT_TO_BYTE_COMPACTION_MODE ) { result . append ( ( char ) byteCompactionData [ i ] ) ; } else if ( subModeCh == TEXT_COMPACTION_MODE_LATCH ) { subMode = Mode . ALPHA ; } } break ; case LOWER : if ( subModeCh < NUM_ ) { ch = ( char ) ( STR_ + subModeCh ) ; } else { if ( subModeCh == NUM_ ) { ch = STR_ ; } else if ( subModeCh == AS ) { priorToShiftMode = subMode ; subMode = Mode . ALPHA_SHIFT ; } else if ( subModeCh == ML ) { subMode = Mode . MIXED ; } else if ( subModeCh == PS ) { priorToShiftMode = subMode ; subMode = Mode . PUNCT_SHIFT ; } else if ( subModeCh == MODE_SHIFT_TO_BYTE_COMPACTION_MODE ) { result . append ( ( char ) byteCompactionData [ i ] ) ; } else if ( subModeCh == TEXT_COMPACTION_MODE_LATCH ) { subMode = Mode . ALPHA ; } } break ; case MIXED : if ( subModeCh < PL ) { ch = MIXED_CHARS [ subModeCh ] ; } else { if ( subModeCh == PL ) { subMode = Mode . PUNCT ; } else if ( subModeCh == NUM_ ) { ch = STR_ ; } else if ( subModeCh == LL ) { subMode = Mode . LOWER ; } else if ( subModeCh == AL ) { subMode = Mode . ALPHA ; } else if ( subModeCh == PS ) { priorToShiftMode = subMode ; subMode = Mode . PUNCT_SHIFT ; } else if ( subModeCh == MODE_SHIFT_TO_BYTE_COMPACTION_MODE ) { result . append ( ( char ) byteCompactionData [ i ] ) ; } else if ( subModeCh == TEXT_COMPACTION_MODE_LATCH ) { subMode = Mode . ALPHA ; } } break ; case PUNCT : if ( subModeCh < PAL ) { ch = PUNCT_CHARS [ subModeCh ] ; } else { if ( subModeCh == PAL ) { subMode = Mode . ALPHA ; } else if ( subModeCh == MODE_SHIFT_TO_BYTE_COMPACTION_MODE ) { result . append ( ( char ) byteCompactionData [ i ] ) ; } else if ( subModeCh == TEXT_COMPACTION_MODE_LATCH ) { subMode = Mode . ALPHA ; } } break ; case ALPHA_SHIFT : subMode = priorToShiftMode ; if ( subModeCh < NUM_ ) { ch = ( char ) ( STR_ + subModeCh ) ; } else { if ( subModeCh == NUM_ ) { ch = STR_ ; } else if ( subModeCh == TEXT_COMPACTION_MODE_LATCH ) { subMode = Mode . ALPHA ; } } break ; case PUNCT_SHIFT : subMode = priorToShiftMode ; if ( subModeCh < PAL ) { ch = PUNCT_CHARS [ subModeCh ] ; } else { if ( subModeCh == PAL ) { subMode = Mode . ALPHA ; } else if ( subModeCh == MODE_SHIFT_TO_BYTE_COMPACTION_MODE ) { result . append ( ( char ) byteCompactionData [ i ] ) ; } else if ( subModeCh == TEXT_COMPACTION_MODE_LATCH ) { subMode = Mode . ALPHA ; } } break ; } if ( ch != NUM_ ) { result . append ( ch ) ; } i ++ ; } }
public MediaConfig createChannelFileAttachment ( String file , MediaConfig config ) { config . addCredentials ( this ) ; String xml = POSTFILE ( this . url + STR_ , file , config . name , config . toXML ( ) ) ; Element root = parse ( xml ) ; if ( root == null ) { return null ; } try { MediaConfig media = new MediaConfig ( ) ; media . parseXML ( root ) ; return media ; } catch ( Exception exception ) { this . exception = SDKException . parseFailure ( exception ) ; throw this . exception ; } }
public void addParam ( AstNode param ) { assertNotNull ( param ) ; if ( params == null ) { params = new ArrayList < AstNode > ( ) ; } params . add ( param ) ; param . setParent ( this ) ; }
DeleteEvent ( @ NonNull JSONObject json ) throws JSONException { super ( TYPE_DELETE , json ) ; if ( TextUtils . isEmpty ( mBlockId ) ) { throw new JSONException ( TYPENAME_DELETE + STR_ + JSON_BLOCK_ID ) ; } mOldXml = json . optString ( JSON_OLD_VALUE ) ; JSONArray ids = json . getJSONArray ( JSON_IDS ) ; int count = ids . length ( ) ; List < String > temp = new ArrayList < > ( count ) ; for ( int i = NUM_ ; i < count ; ++ i ) { temp . add ( ids . getString ( i ) ) ; } mIds = Collections . unmodifiableList ( temp ) ; }
public static boolean isFullCopyRestorable ( Volume volume , DbClient dbClient ) { boolean result = BOOL_ ; String replicaState = volume . getReplicaState ( ) ; if ( isVolumeFullCopy ( volume , dbClient ) && replicaState != null && ! replicaState . isEmpty ( ) ) { ReplicationState state = ReplicationState . getEnumValue ( replicaState ) ; if ( state != null && state == ReplicationState . SYNCHRONIZED ) { result = BOOL_ ; } } return result ; }
private final static String [ ] readQDStrings ( String string , int [ ] pos ) throws NamingException { return readQDescrs ( string , pos ) ; }
private static boolean isBufferTooLarge ( ByteBuffer buf ) { return isBufferTooLarge ( buf . capacity ( ) ) ; }
public static void resetIndexBufferTime ( ) { SAFE_QUERY_TIME . set ( NUM_ ) ; }
protected abstract AdminResponse createResponse ( DistributionManager dm ) ;
protected boolean checkExternalStorageAndNotify ( String fileName ) { if ( fileName != null && fileName . startsWith ( STR_ ) ) { alertDownloadFailure ( R . string . download_no_sdcard_dlg_title ) ; return BOOL_ ; } String status = Environment . getExternalStorageState ( ) ; if ( ! status . equals ( Environment . MEDIA_MOUNTED ) ) { int title ; if ( status . equals ( Environment . MEDIA_SHARED ) ) { title = R . string . download_sdcard_busy_dlg_title ; } else { title = R . string . download_no_sdcard_dlg_title ; } alertDownloadFailure ( title ) ; return BOOL_ ; } return BOOL_ ; }
public static String plnoun ( final int quantity , final String noun ) { final String enoun = fullForm ( noun ) ; if ( quantity == NUM_ ) { return singular ( enoun ) ; } else { return plural ( noun ) ; } }
public boolean verifyXMLSignature ( org . w3c . dom . Element element , java . lang . String certAlias ) throws XMLSignatureException { return verifyXMLSignature ( element , DEF_ID_ATTRIBUTE , certAlias ) ; }
public void add ( Video video ) { videoList . add ( video ) ; notifyDataSetChanged ( ) ; }
private static boolean isInHorizontalTargetZone ( float x , float y , float handleXStart , float handleXEnd , float handleY , float targetRadius ) { if ( x > handleXStart && x < handleXEnd && Math . abs ( y - handleY ) <= targetRadius ) { return BOOL_ ; } return BOOL_ ; }
public void readTransportSystems ( final int [ ] columnsIndices , final BufferedReader reader ) throws IOException { String line = reader . readLine ( ) ; while ( line != null && line . length ( ) > NUM_ ) { line = reader . readLine ( ) ; } }
private boolean hasPrefix ( byte [ ] nal ) { if ( nal [ NUM_ ] == NUM_ && nal [ NUM_ ] == NUM_ && nal [ NUM_ ] == NUM_ && nal [ NUM_ ] == x01 ) return BOOL_ ; else return BOOL_ ; }
private void unshareMain ( ) { int [ ] old = _mainHash ; int len = _mainHash . length ; _mainHash = new int [ len ] ; System . arraycopy ( old , NUM_ , _mainHash , NUM_ , len ) ; _mainHashShared = BOOL_ ; }
public ComponentConfigBuilder addItemInMultifield ( String multifieldLabel , int index , String itemType , String itemLabel , String value ) { String type = String . format ( STR_ , index , itemType ) ; String label = String . format ( STR_ , multifieldLabel , itemLabel ) ; config . add ( new ConfigurationEntry ( currentTab , type , label , value ) ) ; return this ; }
public int size ( ) { return names . size ( ) ; }
public static IMultiPoint [ ] randomPoints ( int n , int d , int scale ) { IMultiPoint points [ ] = new IMultiPoint [ n ] ; for ( int i = NUM_ ; i < n ; i ++ ) { StringBuilder sb = new StringBuilder ( ) ; for ( int j = NUM_ ; j < d ; j ++ ) { sb . append ( rGen . nextDouble ( ) . scale ) ; if ( j < d - NUM_ ) { sb . append ( STR_ ) ; } } points [ i ] = new Hyperpoint ( sb . toString ( ) ) ; } return points ; }
private void parseParameters ( String parameters ) { Log . v ( STR_ , STR_ + STR_ + parameters ) ; if ( parameters != null ) { int i ; do { i = parameters . indexOf ( STR_ ) ; if ( i < NUM_ ) { parseParameter ( parameters ) ; } else { parseParameter ( parameters . substring ( NUM_ , i ) ) ; parameters = parameters . substring ( i + NUM_ ) ; } } while ( i >= NUM_ ) ; } }
public void addHttpSessionToken ( String site , String token ) { if ( ! site . contains ( STR_ ) ) { site = site + ( STR_ ) ; } HttpSessionTokensSet siteTokens = sessionTokens . get ( site ) ; if ( siteTokens == null ) { siteTokens = new HttpSessionTokensSet ( ) ; sessionTokens . put ( site , siteTokens ) ; } log . info ( STR_ + site + STR_ + token ) ; siteTokens . addToken ( token ) ; unmarkRemovedDefaultSessionToken ( site , token ) ; }
public GradleDistribution deserializeFromString ( String distributionString ) { Preconditions . checkNotNull ( distributionString ) ; String localInstallationPrefix = STR_ ; if ( distributionString . startsWith ( localInstallationPrefix ) && distributionString . endsWith ( STR_ ) ) { String localInstallationDir = distributionString . substring ( localInstallationPrefix . length ( ) , distributionString . length ( ) - NUM_ ) ; return GradleDistribution . forLocalInstallation ( new File ( localInstallationDir ) ) ; } String remoteDistributionPrefix = STR_ ; if ( distributionString . startsWith ( remoteDistributionPrefix ) && distributionString . endsWith ( STR_ ) ) { String remoteDistributionUri = distributionString . substring ( remoteDistributionPrefix . length ( ) , distributionString . length ( ) - NUM_ ) ; return GradleDistribution . forRemoteDistribution ( createURI ( remoteDistributionUri ) ) ; } String versionPrefix = STR_ ; if ( distributionString . startsWith ( versionPrefix ) && distributionString . endsWith ( STR_ ) ) { String version = distributionString . substring ( versionPrefix . length ( ) , distributionString . length ( ) - NUM_ ) ; return GradleDistribution . forVersion ( version ) ; } String wrapperString = STR_ ; if ( distributionString . equals ( wrapperString ) ) { return GradleDistribution . fromBuild ( ) ; } String message = String . format ( STR_ , distributionString ) ; throw new RuntimeException ( message ) ; }
public double metersToPixels ( ) { double screenCenterLat = screenTopLeft . latitude - screenSize . latitude / NUM_ ; double metersToLon = NUM_ / ( Util . LON_TO_METERS_AT_EQUATOR . Math . cos ( screenCenterLat / NUM_ . Math . PI ) ) ; return screenSize . longitude / windowWidth . metersToLon ; }
public boolean sendViaDataSocket ( byte [ ] bytes , int start , int len ) { if ( dataOutputStream == null ) { Log . i ( TAG , STR_ ) ; return BOOL_ ; } if ( len == NUM_ ) { return BOOL_ ; } try { dataOutputStream . write ( bytes , start , len ) ; } catch ( IOException e ) { Log . i ( TAG , STR_ ) ; Log . i ( TAG , e . toString ( ) ) ; return BOOL_ ; } localDataSocket . reportTraffic ( len ) ; return BOOL_ ; }
private void pushContext ( BaseContext c ) { contextStack . push ( c ) ; }
@ Override public void bookmarksOrHistoryPicker ( ComboViews startView ) { if ( mTabControl . getCurrentWebView ( ) == null ) { return ; } if ( isInCustomActionMode ( ) ) { endActionMode ( ) ; } Bundle extras = new Bundle ( ) ; extras . putBoolean ( BrowserBookmarksPage . EXTRA_DISABLE_WINDOW , ! mTabControl . canCreateNewTab ( ) ) ; mUi . showComboView ( startView , extras ) ; }
public FST ( String fileName , String encoding , boolean verbose ) throws IOException { FileInputStream fis = new FileInputStream ( fileName ) ; try { loadHeaderless ( fis , encoding , verbose ) ; } finally { fis . close ( ) ; } }
public static double [ ] normalizeZscore ( double [ ] x ) { double mn = mean ( x , NUM_ ) ; double sd = standardDeviation ( x , NUM_ ) ; for ( int i = NUM_ ; i < x . length ; i ++ ) if ( ! Double . isNaN ( x [ i ] ) ) x [ i ] = ( x [ i ] - mn ) / sd ; return x ; }
void addLocation ( String location ) { if ( fLocationList . contains ( location ) ) { return ; } fLocationList . add ( location ) ; fTableViewer . refresh ( ) ; fTableViewer . setChecked ( location , BOOL_ ) ; fTableViewer . setSelection ( new StructuredSelection ( location ) ) ; validateLocations ( ) ; }
public JavaFormatter ( String lineDelimiter , int initialIndentLevel , boolean useCodeFormatter , IJavaProject project ) { fLineDelimiter = lineDelimiter ; fUseCodeFormatter = useCodeFormatter ; fInitialIndentLevel = initialIndentLevel ; fProject = project ; }
public String encode ( final String pString , final String charset ) throws EncoderException { if ( pString == null ) { return null ; } try { return encodeText ( pString , charset ) ; } catch ( UnsupportedEncodingException e ) { throw new EncoderException ( e . getMessage ( ) ) ; } }
private static void checkPathNeed ( ) { if ( samplingInterval == - NUM_ ) { lastPreloadTime = readMorePaths ( ) ; } if ( ! Double . isNaN ( lastPreloadTime ) && SimClock . getTime ( ) >= lastPreloadTime - ( samplingInterval . MIN_AHEAD_INTERVALS ) ) { for ( int i = NUM_ ; i < nrofPreload && ! Double . isNaN ( lastPreloadTime ) ; i ++ ) { lastPreloadTime = readMorePaths ( ) ; } } }
public double wide ( Prior prior , Likelihood likelihood ) throws OperatorFailedException { final int nodeCount = tree . getNodeCount ( ) ; final NodeRef root = tree . getRoot ( ) ; NodeRef i ; int indexI ; do { indexI = MathUtils . nextInt ( nodeCount ) ; i = tree . getNode ( indexI ) ; } while ( root == i || ( tree . getParent ( i ) == root && tree . getNodeHeight ( i ) > tree . getNodeHeight ( getOtherChild ( tree , tree . getParent ( i ) , i ) ) ) ) ; List < Integer > secondNodeIndices = new ArrayList < Integer > ( ) ; List < Double > probabilities = new ArrayList < Double > ( ) ; NodeRef j , jP ; NodeRef iP = tree . getParent ( i ) ; double heightIP = tree . getNodeHeight ( iP ) ; double heightI = tree . getNodeHeight ( i ) ; double sum = NUM_ ; double backward = calculateTreeLikelihood ( prior , likelihood , tree ) ; int offset = ( int ) - backward ; backward = Math . exp ( backward + offset ) ; for ( int n = NUM_ ; n < nodeCount ; n ++ ) { j = tree . getNode ( n ) ; if ( j != root ) { jP = tree . getParent ( j ) ; if ( ( iP != jP ) && ( tree . getNodeHeight ( j ) < heightIP ) && ( heightI < tree . getNodeHeight ( jP ) ) ) { secondNodeIndices . add ( n ) ; swap ( tree , i , j , iP , jP ) ; double prob = Math . exp ( calculateTreeLikelihood ( prior , likelihood , tree ) + offset ) ; probabilities . add ( prob ) ; swap ( tree , i , j , jP , iP ) ; sum += prob ; } } } if ( sum <= NUM_ ) { throw new OperatorFailedException ( STR_ ) ; } double ran = Math . random ( ) . sum ; int index = NUM_ ; while ( ran > NUM_ ) { ran -= probabilities . get ( index ) ; index ++ ; } index -- ; j = tree . getNode ( secondNodeIndices . get ( index ) ) ; jP = tree . getParent ( j ) ; double heightJP = tree . getNodeHeight ( jP ) ; double heightJ = tree . getNodeHeight ( j ) ; double sumForward2 = NUM_ ; NodeRef k , kP ; for ( int n = NUM_ ; n < nodeCount ; n ++ ) { k = tree . getNode ( n ) ; if ( k != root ) { kP = tree . getParent ( k ) ; if ( ( jP != kP ) && ( tree . getNodeHeight ( k ) < heightJP ) && ( heightJ < tree . getNodeHeight ( kP ) ) ) { swap ( tree , j , k , jP , kP ) ; double prob = Math . exp ( calculateTreeLikelihood ( prior , likelihood , tree ) + offset ) ; sumForward2 += prob ; swap ( tree , j , k , kP , jP ) ; } } } swap ( tree , i , j , iP , jP ) ; double forward = probabilities . get ( index ) ; iP = jP ; heightIP = heightJP ; double sumBackward = NUM_ ; for ( int n = NUM_ ; n < nodeCount ; n ++ ) { j = tree . getNode ( n ) ; if ( j != root ) { jP = tree . getParent ( j ) ; if ( ( iP != jP ) && ( tree . getNodeHeight ( j ) < heightIP ) && ( heightI < tree . getNodeHeight ( jP ) ) ) { swap ( tree , i , j , iP , jP ) ; double prob = Math . exp ( calculateTreeLikelihood ( prior , likelihood , tree ) + offset ) ; sumBackward += prob ; swap ( tree , i , j , jP , iP ) ; } } } double sumBackward2 = NUM_ ; j = tree . getNode ( secondNodeIndices . get ( index ) ) ; jP = tree . getParent ( j ) ; heightJP = tree . getNodeHeight ( jP ) ; heightJ = tree . getNodeHeight ( j ) ; for ( int n = NUM_ ; n < nodeCount ; n ++ ) { k = tree . getNode ( n ) ; if ( k != root ) { kP = tree . getParent ( k ) ; if ( ( jP != kP ) && ( tree . getNodeHeight ( k ) < heightJP ) && ( heightJ < tree . getNodeHeight ( kP ) ) ) { swap ( tree , j , k , jP , kP ) ; double prob = Math . exp ( calculateTreeLikelihood ( prior , likelihood , tree ) + offset ) ; sumBackward2 += prob ; swap ( tree , j , k , kP , jP ) ; } } } double forwardProb = ( forward / sum ) + ( forward / sumForward2 ) ; double backwardProb = ( backward / sumBackward ) + ( backward / sumBackward2 ) ; double hastingsRatio = Math . log ( backwardProb / forwardProb ) ; return hastingsRatio ; }
public boolean isInputColumnNameAllowed ( String columnName ) { if ( columnName == null || columnName . length ( ) == NUM_ ) return BOOL_ ; getInputColumnNames ( BOOL_ ) ; for ( int i = NUM_ ; i < m_inputcolumnnames . length ; i ++ ) { if ( columnName . equals ( m_inputcolumnnames [ i ] ) ) return BOOL_ ; } return BOOL_ ; }
public static int rgb ( String hex ) { int color = ( int ) Long . parseLong ( hex . replace ( STR_ , STR_ ) , NUM_ ) ; int r = ( color > > NUM_ ) & xFF ; int g = ( color > > NUM_ ) & xFF ; int b = ( color > > NUM_ ) & xFF ; return Color . rgb ( r , g , b ) ; }
@ Override public void addPropertyChangeListener ( String name , PropertyChangeListener pcl ) { m_bcSupport . addPropertyChangeListener ( name , pcl ) ; }
public void testEmptyOrNullBlob ( ) throws Exception { try { PreparedStatement stmt = connection . prepareStatement ( STR_ ) ; try { stmt . setInt ( NUM_ , NUM_ ) ; stmt . setBytes ( NUM_ , new byte [ NUM_ ] ) ; int insertedCount = stmt . executeUpdate ( ) ; assertTrue ( STR_ , insertedCount == NUM_ ) ; stmt . setInt ( NUM_ , NUM_ ) ; stmt . setNull ( NUM_ , Types . BINARY ) ; insertedCount = stmt . executeUpdate ( ) ; assertTrue ( STR_ , insertedCount == NUM_ ) ; } finally { stmt . close ( ) ; } stmt = connection . prepareStatement ( STR_ ) ; stmt . setInt ( NUM_ , NUM_ ) ; try { ResultSet rs = stmt . executeQuery ( ) ; assertTrue ( STR_ , rs . next ( ) ) ; assertTrue ( STR_ , Arrays . equals ( rs . getBytes ( NUM_ ) , new byte [ NUM_ ] ) ) ; rs . close ( ) ; stmt . setInt ( NUM_ , NUM_ ) ; rs = stmt . executeQuery ( ) ; assertTrue ( STR_ , rs . next ( ) ) ; assertTrue ( STR_ , rs . getObject ( NUM_ ) == null ) ; rs . close ( ) ; } finally { stmt . close ( ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; throw ex ; } }
private void writeAttribute ( java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( namespace . equals ( STR_ ) ) { xmlWriter . writeAttribute ( attName , attValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } }
private synchronized void rebuildJournal ( ) throws IOException { if ( journalWriter != null ) { journalWriter . close ( ) ; } Writer writer = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( journalFileTmp ) , Utils . US_ASCII ) ) ; try { writer . write ( MAGIC ) ; writer . write ( STR_ ) ; writer . write ( VERSION_1 ) ; writer . write ( STR_ ) ; writer . write ( Integer . toString ( appVersion ) ) ; writer . write ( STR_ ) ; writer . write ( Integer . toString ( valueCount ) ) ; writer . write ( STR_ ) ; writer . write ( STR_ ) ; for ( Entry entry : lruEntries . values ( ) ) { if ( entry . currentEditor != null ) { writer . write ( DIRTY + STR_ + entry . key + STR_ ) ; } else { writer . write ( CLEAN + STR_ + entry . key + entry . getLengths ( ) + STR_ ) ; } } } finally { writer . close ( ) ; } if ( journalFile . exists ( ) ) { renameTo ( journalFile , journalFileBackup , BOOL_ ) ; } renameTo ( journalFileTmp , journalFile , BOOL_ ) ; journalFileBackup . delete ( ) ; journalWriter = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( journalFile , BOOL_ ) , Utils . US_ASCII ) ) ; }
public void testCase22 ( ) { byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ } ; byte rBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ } ; int bSign = - NUM_ ; BigInteger aNumber = BigInteger . ZERO ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . subtract ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( NUM_ , result . signum ( ) ) ; }
@ SuppressWarnings ( STR_ ) public void restore ( String fileName ) throws IOException , ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream ( new FileInputStream ( fileName ) ) ; locations = ( Map < V , Point > ) ois . readObject ( ) ; ois . close ( ) ; initializeLocations ( ) ; locked = BOOL_ ; fireStateChanged ( ) ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
public void waitForData ( ) { if ( this . initialized ) { return ; } waitOnInitialization ( this . initializationLatchAfterGetInitialImage ) ; }
private byte [ ] calculateCMSKeyChecksum ( byte [ ] key ) { byte [ ] result = new byte [ NUM_ ] ; sha1 . update ( key , NUM_ , key . length ) ; sha1 . doFinal ( digest , NUM_ ) ; System . arraycopy ( digest , NUM_ , result , NUM_ , NUM_ ) ; return result ; }
public int hashCode ( ) { return _lowerNick . hashCode ( ) ; }
public boolean incrementReceived ( ) { Long diff = System . currentTimeMillis ( ) - startTime ; if ( diff >= NUM_ ) { packetsPerSecond = intervalPackets ; startTime = System . currentTimeMillis ( ) ; intervalPackets = NUM_ ; return BOOL_ ; } else { intervalPackets ++ ; } this . receivedPackets ++ ; return BOOL_ ; }
Sentence parseSentence ( final String text , final ConversationContext ctx ) { if ( isEmpty ( ) ) { return ConversationParser . parse ( text , ctx ) ; } String txt = text . trim ( ) ; final Sentence sentence = new SentenceImplementation ( ctx , txt ) ; txt = ConversationParser . detectSentenceType ( txt , sentence ) ; if ( typeMatching ) { readTypeMatchExpressions ( txt , ctx , sentence ) ; } else if ( exactMatching ) { readSimpleExpressions ( txt , ctx , sentence ) ; } else if ( similarMatching ) { readSimpleExpressions ( txt , ctx , sentence ) ; } else if ( jokerMatching ) { readJokerExpressions ( txt , ctx , sentence ) ; } else if ( caseInsensitive ) { readSimpleExpressions ( txt , ctx , sentence ) ; } return sentence ; }
public KafkaCluster usingDirectory ( File dataDir ) { if ( running ) throw new IllegalStateException ( STR_ ) ; if ( dataDir != null && dataDir . exists ( ) && ! dataDir . isDirectory ( ) && ! dataDir . canWrite ( ) && ! dataDir . canRead ( ) ) { throw new IllegalArgumentException ( STR_ ) ; } this . dataDir = dataDir ; return this ; }
private void expand ( int i ) { if ( count + i <= buf . length ) { return ; } byte [ ] newbuf = mPool . getBuf ( ( count + i ) . NUM_ ) ; System . arraycopy ( buf , NUM_ , newbuf , NUM_ , count ) ; mPool . returnBuf ( buf ) ; buf = newbuf ; }
void onConsumeFinished ( Purchase purchase , IabResult result ) ;
protected boolean checkProsodicPosition ( Element currentRulePart , String prosodicPositionType ) { NamedNodeMap attNodes = currentRulePart . getAttributes ( ) ; for ( int z = NUM_ ; z < attNodes . getLength ( ) ; z ++ ) { Node el = attNodes . item ( z ) ; String currentAtt = el . getNodeName ( ) ; String currentVal = el . getNodeValue ( ) ; if ( currentAtt . equals ( STR_ ) ) { if ( ! currentVal . startsWith ( STR_ ) ) { if ( ! prosodicPositionType . equals ( currentVal ) ) return BOOL_ ; } else { currentVal = currentVal . substring ( NUM_ , currentVal . length ( ) ) ; if ( prosodicPositionType . equals ( currentVal ) ) return BOOL_ ; } } } return BOOL_ ; }
public static BigDecimal parseBigDecimalForEntity ( String bigDecimalString ) throws NumberFormatException { if ( bigDecimalString == null ) { return null ; } bigDecimalString = bigDecimalString . trim ( ) ; bigDecimalString = bigDecimalString . replaceAll ( STR_ , STR_ ) ; if ( bigDecimalString . length ( ) < NUM_ ) { return null ; } return new BigDecimal ( bigDecimalString ) ; }
public static void registerOperators ( String name , InputStream operatorsXML , ClassLoader classLoader ) { registerOperators ( name , operatorsXML , classLoader , null ) ; }
private void doPermissionWorkBeforeAndroidM ( @ NonNull Activity activity , @ NonNull String [ ] permissions , @ Nullable PermissionsResultAction action ) { for ( String perm : permissions ) { if ( action != null ) { if ( ! mPermissions . contains ( perm ) ) { action . onResult ( perm , Permissions . NOT_FOUND ) ; } else if ( ActivityCompat . checkSelfPermission ( activity , perm ) != PackageManager . PERMISSION_GRANTED ) { action . onResult ( perm , Permissions . DENIED ) ; } else { action . onResult ( perm , Permissions . GRANTED ) ; } } } }
public void deleteSubGroupContainers ( Set groupContainers ) throws AMException , SSOException { Iterator iter = groupContainers . iterator ( ) ; while ( iter . hasNext ( ) ) { String groupContainerDN = ( String ) iter . next ( ) ; AMGroupContainer groupContainer = new AMGroupContainerImpl ( token , groupContainerDN ) ; groupContainer . delete ( ) ; } }
public GlowTask ( Plugin owner , Runnable task , boolean sync , long delay , long period ) { super ( task , null ) ; taskId = nextTaskId . getAndIncrement ( ) ; description = task . toString ( ) ; this . owner = owner ; this . delay = delay ; this . period = period ; counter = NUM_ ; this . sync = sync ; }
public static void init ( String [ ] args ) { try { compiler . initCompiler ( args ) ; if ( VM . BuildForAdaptiveSystem && VM . BuildWithBaseBootImageCompiler ) { optCompiler . initCompiler ( args ) ; } } catch ( Throwable e ) { while ( e != null ) { e . printStackTrace ( ) ; e = e . getCause ( ) ; } } }
static native boolean openDev ( ) ;
int sendNextByte ( ) { int result = NUM_ ; try { long tDiff = interByteTime - ( ( System . currentTimeMillis ( ) - lastRxTime ) . NUM_ ) ; if ( tDiff > NUM_ ) { log . debug ( STR_ + tDiff + STR_ ) ; Thread . sleep ( tDiff / NUM_ , ( int ) ( tDiff % NUM_ ) ) ; } } catch ( InterruptedException ex ) { log . error ( STR_ + ex . toString ( ) ) ; } if ( currTxCharPos >= currTxTgm . length ) { result = dequeueTelegram ( ) ; } if ( result == NUM_ ) { writeChar ( currTxTgm [ currTxCharPos ++ ] , BOOL_ ) ; if ( currTxCharPos >= currTxTgm . length ) { setProtStat ( ProtStatus . RECEIVING ) ; } } return result ; }
public static String encode ( Serializable o ) { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; try { ObjectOutputStream oos = new ObjectOutputStream ( bos ) ; try { oos . writeObject ( o ) ; oos . flush ( ) ; } finally { oos . close ( ) ; } return Base64 . encodeBytes ( bos . toByteArray ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public static Map < String , Object > createImage ( DispatchContext dctx , Map < String , ? extends Object > context ) { Map < String , Object > result = createImageMethod ( dctx , context ) ; return result ; }
public void addProfiles ( @ NonNull IProfile ... profiles ) { if ( mAccountHeaderBuilder . mProfiles == null ) { mAccountHeaderBuilder . mProfiles = new ArrayList < > ( ) ; } Collections . addAll ( mAccountHeaderBuilder . mProfiles , IdDistributor . checkIds ( profiles ) ) ; mAccountHeaderBuilder . updateHeaderAndList ( ) ; }
private static boolean isIdentifierName ( String k ) { int n = k . length ( ) ; if ( n == NUM_ ) { return BOOL_ ; } if ( ! Character . isJavaIdentifierStart ( k . charAt ( NUM_ ) ) ) { return BOOL_ ; } for ( int i = NUM_ ; i < n ; ++ i ) { if ( ! Character . isJavaIdentifierPart ( k . charAt ( i ) ) ) { return BOOL_ ; } } return BOOL_ ; }
static boolean lessThanUnsignedLong ( long x1 , long x2 ) { return ( x1 + Long . MIN_VALUE ) < ( x2 + Long . MIN_VALUE ) ; }
private void moveSingleNode ( Object source , Point newPoint ) { DisplayNode node = ( DisplayNode ) source ; int deltaX = newPoint . x - clickPoint . x ; int deltaY = newPoint . y - clickPoint . y ; int newX = node . getLocation ( ) . x + deltaX ; int newY = node . getLocation ( ) . y + deltaY ; node . setLocation ( newX , newY ) ; }
public static < T > List < T > toList ( T obj1 , T obj2 , T obj3 ) { List < T > list = new LinkedList < T > ( ) ; list . add ( obj1 ) ; list . add ( obj2 ) ; list . add ( obj3 ) ; return list ; }
public void addMacroRecord ( MacroRecord record ) { if ( record != null ) macroRecords . add ( record ) ; }
@ SuppressWarnings ( STR_ ) protected KafkaSpoutWrapper createKafkaSpout ( Map conf , TopologyContext context , SpoutOutputCollector collector , final String topic , String schemeClsName , SpoutSpec spoutSpec , Map < String , StreamDefinition > sds ) throws Exception { String kafkaBrokerZkQuorum = config . getString ( STR_ ) ; BrokerHosts hosts = null ; if ( config . hasPath ( STR_ ) ) { hosts = new ZkHosts ( kafkaBrokerZkQuorum , config . getString ( STR_ ) ) ; } else { hosts = new ZkHosts ( kafkaBrokerZkQuorum ) ; } String transactionZkRoot = DEFAULT_STORM_KAFKA_TRANSACTION_ZK_ROOT ; if ( config . hasPath ( STR_ ) ) { transactionZkRoot = config . getString ( STR_ ) ; } String zkStateTransactionRelPath = DEFAULT_STORM_KAFKA_TRANSACTION_ZK_RELATIVE_PATH ; if ( config . hasPath ( STR_ ) ) { zkStateTransactionRelPath = config . getString ( STR_ ) ; } SpoutConfig spoutConfig = new SpoutConfig ( hosts , topic , transactionZkRoot , zkStateTransactionRelPath + STR_ + topic + STR_ + topologyId ) ; boolean stormKafkaUseSameZkQuorumWithKafkaBroker = config . getBoolean ( STR_ ) ; if ( stormKafkaUseSameZkQuorumWithKafkaBroker ) { ZkServerPortUtils utils = new ZkServerPortUtils ( kafkaBrokerZkQuorum ) ; spoutConfig . zkServers = utils . getZkHosts ( ) ; spoutConfig . zkPort = utils . getZkPort ( ) ; } else { ZkServerPortUtils utils = new ZkServerPortUtils ( config . getString ( STR_ ) ) ; spoutConfig . zkServers = utils . getZkHosts ( ) ; spoutConfig . zkPort = utils . getZkPort ( ) ; } spoutConfig . stateUpdateIntervalMs = config . hasPath ( STR_ ) ? config . getInt ( STR_ ) : NUM_ ; spoutConfig . fetchSizeBytes = config . hasPath ( STR_ ) ? config . getInt ( STR_ ) : NUM_ ; if ( config . hasPath ( STR_ ) ) { spoutConfig . startOffsetTime = config . getInt ( STR_ ) ; } spoutConfig . scheme = createMultiScheme ( conf , topic , schemeClsName ) ; KafkaSpoutWrapper wrapper = new KafkaSpoutWrapper ( spoutConfig , kafkaSpoutMetric ) ; SpoutOutputCollectorWrapper collectorWrapper = new SpoutOutputCollectorWrapper ( this , collector , topic , spoutSpec , numOfRouterBolts , sds , this . serializer ) ; wrapper . open ( conf , context , collectorWrapper ) ; if ( LOG . isInfoEnabled ( ) ) { LOG . info ( STR_ , topic , schemeClsName ) ; } return wrapper ; }
public Builder addEmail ( Email email ) { emails . add ( email ) ; return this ; }
public static HashProvider best ( HashParameters params ) { return best ( params , EnumSet . of ( HashSupport . STATEFUL ) ) ; }
public byte [ ] readRawBytes ( final int size ) throws IOException { if ( size < NUM_ ) { throw InvalidProtocolBufferNanoException . negativeSize ( ) ; } if ( bufferPos + size > currentLimit ) { skipRawBytes ( currentLimit - bufferPos ) ; throw InvalidProtocolBufferNanoException . truncatedMessage ( ) ; } if ( size <= bufferSize - bufferPos ) { final byte [ ] bytes = new byte [ size ] ; System . arraycopy ( buffer , bufferPos , bytes , NUM_ , size ) ; bufferPos += size ; return bytes ; } else { throw InvalidProtocolBufferNanoException . truncatedMessage ( ) ; } }
static boolean pairSum ( int ar [ ] , int x ) { Arrays . sort ( ar ) ; int len = ar . length ; for ( int i = NUM_ , j = len - NUM_ ; i < j ; ) { if ( ar [ i ] + ar [ j ] == x ) { return BOOL_ ; } else if ( ar [ i ] + ar [ j ] < x ) { i ++ ; } else { j -- ; } } return BOOL_ ; }
public synchronized void loadFromFile ( ) { entries . clear ( ) ; Path file = Paths . get ( fileName ) ; try ( BufferedReader reader = Files . newBufferedReader ( file , CHARSET ) ) { String line ; do { line = reader . readLine ( ) ; AddressbookEntry parsedEntry = parseLine ( line ) ; if ( parsedEntry != null ) { entries . put ( parsedEntry . getName ( ) , parsedEntry ) ; } } while ( line != null ) ; } catch ( IOException ex ) { LOGGER . warning ( STR_ + ex . getLocalizedMessage ( ) ) ; } LOGGER . info ( STR_ + entries . size ( ) + STR_ + fileName ) ; scanCategories ( ) ; }
public double localScore ( int i , int ... parents ) { for ( int p : parents ) if ( forbidden . contains ( p ) ) return Double . NaN ; double residualVariance = covariances . get ( i , i ) ; int n = getSampleSize ( ) ; int p = parents . length ; Matrix covxx = getSelection1 ( covariances , parents ) ; try { Matrix covxxInv = covxx . inverse ( ) ; Matrix covxy = getSelection2 ( covariances , parents , i ) ; Matrix b = covxxInv . times ( covxy ) ; double dot = NUM_ ; for ( int j = NUM_ ; j < covxy . getRowDimension ( ) ; j ++ ) { for ( int k = NUM_ ; k < covxy . getColumnDimension ( ) ; k ++ ) { dot += covxy . get ( j , k ) . b . get ( j , k ) ; } } residualVariance -= dot ; if ( residualVariance <= NUM_ ) { if ( isVerbose ( ) ) { out . println ( STR_ + ( residualVariance / covariances . get ( i , i ) ) ) ; } return Double . NaN ; } double c = getPenaltyDiscount ( ) ; return score ( residualVariance , n , logn , p , c ) ; } catch ( Exception e ) { boolean removedOne = BOOL_ ; while ( removedOne ) { List < Integer > _parents = new ArrayList < > ( ) ; for ( int y = NUM_ ; y < parents . length ; y ++ ) _parents . add ( parents [ y ] ) ; _parents . removeAll ( forbidden ) ; parents = new int [ _parents . size ( ) ] ; for ( int y = NUM_ ; y < _parents . size ( ) ; y ++ ) parents [ y ] = _parents . get ( y ) ; removedOne = printMinimalLinearlyDependentSet ( parents , covariances ) ; } return Double . NaN ; } }
public boolean remove ( final int position ) { final AdapterTransaction removeTransaction = new RemoveTransaction < > ( this , position ) ; final boolean success = removeTransaction . perform ( ) ; mTransactions . offer ( removeTransaction ) ; return success ; }
private void encodeTypes ( List < Type > types , Map < String , Object > m , String key , Declaration from ) { if ( types == null || types . isEmpty ( ) ) return ; List < Map < String , Object > > sats = new ArrayList < > ( types . size ( ) ) ; for ( Type st : types ) { sats . add ( typeMap ( st , from ) ) ; } m . put ( key , sats ) ; }
public static void clearAssertionInformation ( ) { _AssertInfos . clear ( ) ; _AssertOccured = BOOL_ ; }
public void build ( String code , String customStatus ) { try { if ( customStatus != null ) { result . put ( resources . getString ( R . string . intent_extra_status ) , customStatus ) ; } else { result . put ( resources . getString ( R . string . intent_extra_status ) , resources . getString ( R . string . shared_pref_default_status ) ) ; } result . put ( resources . getString ( R . string . intent_extra_code ) , code ) ; operationListResult . put ( result ) ; } catch ( JSONException e ) { Log . e ( TAG , STR_ + e . toString ( ) ) ; } }
public static Operator generateBranchPlan ( AkibanInformationSchema ais , Table table ) { final Operator indexScan = generateIndexScan ( ais , table ) ; final Schema schema = SchemaCache . globalSchema ( ais ) ; PrimaryKey pkey = table . getPrimaryKeyIncludingInternal ( ) ; IndexRowType indexType = schema . indexRowType ( pkey . getIndex ( ) ) ; return generateBranchPlan ( table , indexScan , indexType ) ; }
protected void addToMaintenanceQueue ( NodePortTuple npt ) { if ( maintenanceQueue . contains ( npt ) == BOOL_ ) { maintenanceQueue . add ( npt ) ; } }
private boolean linkFirst ( Node < E > node ) { if ( count >= capacity ) return BOOL_ ; Node < E > f = first ; node . next = f ; first = node ; if ( last == null ) last = node ; else f . prev = node ; ++ count ; notEmpty . signal ( ) ; return BOOL_ ; }
public long startstack ( ) { return Long . parseLong ( fields [ NUM_ ] ) ; }
public static void copyRealmPrivilegesFromParent ( SSOToken token , OrganizationConfigManager parent , OrganizationConfigManager child ) throws SSOException , DelegationException { if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + STR_ + parent . getOrganizationName ( ) + STR_ + child . getOrganizationName ( ) ) ; } DelegationManager pdm = new DelegationManager ( token , parent . getOrganizationName ( ) ) ; DelegationManager cdm = new DelegationManager ( token , child . getOrganizationName ( ) ) ; String childOrgName = DNMapper . orgNameToDN ( child . getOrganizationName ( ) ) ; Set pdps = pdm . getPrivileges ( ) ; if ( pdps == null || pdps . isEmpty ( ) ) { if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + STR_ ) ; } return ; } for ( Iterator items = pdps . iterator ( ) ; items . hasNext ( ) ; ) { DelegationPrivilege dp = ( DelegationPrivilege ) items . next ( ) ; Set subjects = dp . getSubjects ( ) ; if ( subjects == null || subjects . isEmpty ( ) ) { if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + STR_ + dp ) ; } continue ; } Set newSubjects = new HashSet ( ) ; for ( Iterator subs = subjects . iterator ( ) ; subs . hasNext ( ) ; ) { String sName = ( String ) subs . next ( ) ; try { AMIdentity id = IdUtils . getIdentity ( token , sName ) ; AMIdentity newId = new AMIdentity ( token , id . getName ( ) , id . getType ( ) , childOrgName , id . getDN ( ) ) ; newSubjects . add ( IdUtils . getUniversalId ( newId ) ) ; } catch ( IdRepoException ide ) { if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + STR_ + dp , ide ) ; } continue ; } } dp . setSubjects ( newSubjects ) ; Set permissions = dp . getPermissions ( ) ; if ( ( permissions != null ) && ( ! permissions . isEmpty ( ) ) ) { Iterator it = permissions . iterator ( ) ; while ( it . hasNext ( ) ) { DelegationPermission perm = ( DelegationPermission ) it . next ( ) ; perm . setOrganizationName ( STR_ + childOrgName ) ; } } cdm . addPrivilege ( dp ) ; if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + STR_ + dp ) ; } } }
public boolean match ( MimeType other ) { if ( this == other ) return BOOL_ ; if ( type != null && other . type != null && ! type . equals ( other . type ) ) return BOOL_ ; if ( subtype != null && other . subtype != null && ! subtype . equals ( other . subtype ) ) return BOOL_ ; return BOOL_ ; }
@ Override public boolean isArmed ( ) { return other . isArmed ( ) ; }
public EncoderTestSuiteBuilder valid ( int min , int max ) { _valid . set ( min , max + NUM_ ) ; _invalid . clear ( min , max + NUM_ ) ; _encoded . clear ( min , max + NUM_ ) ; return this ; }
protected List < VolumeDescriptor > createChangeVirtualPoolDescriptors ( StorageSystem vplexSystem , Volume volume , VirtualPool newVpool , String taskId , List < Recommendation > recommendations , VirtualPoolCapabilityValuesWrapper capabilities , ControllerOperationValuesWrapper operationsWrapper ) throws InternalException { URI volumeVarrayURI = volume . getVirtualArray ( ) ; VirtualArray volumeVarray = _dbClient . queryObject ( VirtualArray . class , volumeVarrayURI ) ; s_logger . info ( STR_ , volumeVarrayURI ) ; URI volumeVpoolURI = volume . getVirtualPool ( ) ; VirtualPool currentVpool = _dbClient . queryObject ( VirtualPool . class , volumeVpoolURI ) ; List < VolumeDescriptor > descriptors = new ArrayList < VolumeDescriptor > ( ) ; VolumeDescriptor vplexVirtualVolumeDesc = new VolumeDescriptor ( VolumeDescriptor . Type . VPLEX_VIRT_VOLUME , volume . getStorageController ( ) , volume . getId ( ) , volume . getPool ( ) , null ) ; Map < String , Object > volumeParams = new HashMap < String , Object > ( ) ; volumeParams . put ( VolumeDescriptor . PARAM_VPOOL_CHANGE_EXISTING_VOLUME_ID , volume . getId ( ) ) ; volumeParams . put ( VolumeDescriptor . PARAM_VPOOL_CHANGE_NEW_VPOOL_ID , newVpool . getId ( ) ) ; volumeParams . put ( VolumeDescriptor . PARAM_VPOOL_CHANGE_OLD_VPOOL_ID , volume . getVirtualPool ( ) ) ; if ( operationsWrapper != null ) { if ( operationsWrapper . getMigrationSuspendBeforeCommit ( ) != null ) { volumeParams . put ( VolumeDescriptor . PARAM_MIGRATION_SUSPEND_BEFORE_COMMIT , operationsWrapper . getMigrationSuspendBeforeCommit ( ) ) ; } if ( operationsWrapper . getMigrationSuspendBeforeDeleteSource ( ) != null ) { volumeParams . put ( VolumeDescriptor . PARAM_MIGRATION_SUSPEND_BEFORE_DELETE_SOURCE , operationsWrapper . getMigrationSuspendBeforeDeleteSource ( ) ) ; } } vplexVirtualVolumeDesc . setParameters ( volumeParams ) ; descriptors . add ( vplexVirtualVolumeDesc ) ; if ( VirtualPoolChangeAnalyzer . vpoolChangeRequiresMigration ( currentVpool , newVpool ) ) { Volume migSrcVolume = getAssociatedVolumeInVArray ( volume , volumeVarrayURI ) ; descriptors . addAll ( createBackendVolumeMigrationDescriptors ( vplexSystem , volume , migSrcVolume , volumeVarray , newVpool , getVolumeCapacity ( migSrcVolume != null ? migSrcVolume : volume ) , taskId , recommendations , BOOL_ , capabilities ) ) ; } URI haVarrayURI = VirtualPoolChangeAnalyzer . getHaVarrayURI ( currentVpool ) ; if ( haVarrayURI != null ) { VirtualArray haVarray = _dbClient . queryObject ( VirtualArray . class , haVarrayURI ) ; VirtualPool currentHaVpool = VirtualPoolChangeAnalyzer . getHaVpool ( currentVpool , _dbClient ) ; VirtualPool newHaVpool = VirtualPoolChangeAnalyzer . getNewHaVpool ( currentVpool , newVpool , _dbClient ) ; if ( VirtualPoolChangeAnalyzer . vpoolChangeRequiresMigration ( currentHaVpool , newHaVpool ) ) { Volume migSrcVolume = getAssociatedVolumeInVArray ( volume , haVarrayURI ) ; descriptors . addAll ( createBackendVolumeMigrationDescriptors ( vplexSystem , volume , migSrcVolume , haVarray , newHaVpool , getVolumeCapacity ( migSrcVolume != null ? migSrcVolume : volume ) , taskId , recommendations , BOOL_ , capabilities ) ) ; } } return descriptors ; }
public static boolean isJavaScriptEnabled ( HttpServletRequest request ) { HttpSession session = request . getSession ( ) ; Boolean javaScriptEnabled = ( Boolean ) session . getAttribute ( STR_ ) ; if ( javaScriptEnabled != null ) { return javaScriptEnabled . booleanValue ( ) ; } return BOOL_ ; }
public boolean equals ( Object obj ) { if ( this == obj ) return BOOL_ ; if ( obj instanceof ECFieldFp ) { return ( p . equals ( ( ( ECFieldFp ) obj ) . p ) ) ; } return BOOL_ ; }
public String name ( ) { return theName ; }
public static void closeQuietly ( Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( RuntimeException rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } }
private static String checksumMD5 ( String data ) { MessageDigest md5 = null ; try { md5 = MessageDigest . getInstance ( STR_ ) ; } catch ( NoSuchAlgorithmException ex ) { throw new RuntimeException ( STR_ , ex ) ; } return hexEncode ( md5 . digest ( data . getBytes ( ) ) ) ; }
public static boolean validSkinSpecFile ( String fileName ) { File file = new File ( Configuration . skinsDir ( ) , fileName ) ; if ( ! file . exists ( ) || ! file . isFile ( ) ) { return BOOL_ ; } DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; try { DocumentBuilder builder = dbf . newDocumentBuilder ( ) ; Document doc = builder . parse ( file ) ; NodeList listOfComponents = doc . getElementsByTagName ( UI_ELEMENT ) ; if ( listOfComponents . getLength ( ) > NUM_ ) { return BOOL_ ; } else { return BOOL_ ; } } catch ( Exception e ) { return BOOL_ ; } }
private void generateLegalTimesTree ( ) { int k0 = KeyEvent . KEYCODE_0 ; int k1 = KeyEvent . KEYCODE_1 ; int k2 = KeyEvent . KEYCODE_2 ; int k3 = KeyEvent . KEYCODE_3 ; int k4 = KeyEvent . KEYCODE_4 ; int k5 = KeyEvent . KEYCODE_5 ; int k6 = KeyEvent . KEYCODE_6 ; int k7 = KeyEvent . KEYCODE_7 ; int k8 = KeyEvent . KEYCODE_8 ; int k9 = KeyEvent . KEYCODE_9 ; mLegalTimesTree = new Node ( ) ; if ( mIs24HourMode ) { Node minuteFirstDigit = new Node ( k0 , k1 , k2 , k3 , k4 , k5 ) ; Node minuteSecondDigit = new Node ( k0 , k1 , k2 , k3 , k4 , k5 , k6 , k7 , k8 , k9 ) ; minuteFirstDigit . addChild ( minuteSecondDigit ) ; Node firstDigit = new Node ( k0 , k1 ) ; mLegalTimesTree . addChild ( firstDigit ) ; Node secondDigit = new Node ( k0 , k1 , k2 , k3 , k4 , k5 ) ; firstDigit . addChild ( secondDigit ) ; secondDigit . addChild ( minuteFirstDigit ) ; Node thirdDigit = new Node ( k6 , k7 , k8 , k9 ) ; secondDigit . addChild ( thirdDigit ) ; secondDigit = new Node ( k6 , k7 , k8 , k9 ) ; firstDigit . addChild ( secondDigit ) ; secondDigit . addChild ( minuteFirstDigit ) ; firstDigit = new Node ( k2 ) ; mLegalTimesTree . addChild ( firstDigit ) ; secondDigit = new Node ( k0 , k1 , k2 , k3 ) ; firstDigit . addChild ( secondDigit ) ; secondDigit . addChild ( minuteFirstDigit ) ; secondDigit = new Node ( k4 , k5 ) ; firstDigit . addChild ( secondDigit ) ; secondDigit . addChild ( minuteSecondDigit ) ; firstDigit = new Node ( k3 , k4 , k5 , k6 , k7 , k8 , k9 ) ; mLegalTimesTree . addChild ( firstDigit ) ; firstDigit . addChild ( minuteFirstDigit ) ; } else { Node ampm = new Node ( getAmOrPmKeyCode ( AM ) , getAmOrPmKeyCode ( PM ) ) ; Node firstDigit = new Node ( k1 ) ; mLegalTimesTree . addChild ( firstDigit ) ; firstDigit . addChild ( ampm ) ; Node secondDigit = new Node ( k0 , k1 , k2 ) ; firstDigit . addChild ( secondDigit ) ; secondDigit . addChild ( ampm ) ; Node thirdDigit = new Node ( k0 , k1 , k2 , k3 , k4 , k5 ) ; secondDigit . addChild ( thirdDigit ) ; thirdDigit . addChild ( ampm ) ; Node fourthDigit = new Node ( k0 , k1 , k2 , k3 , k4 , k5 , k6 , k7 , k8 , k9 ) ; thirdDigit . addChild ( fourthDigit ) ; fourthDigit . addChild ( ampm ) ; thirdDigit = new Node ( k6 , k7 , k8 , k9 ) ; secondDigit . addChild ( thirdDigit ) ; thirdDigit . addChild ( ampm ) ; secondDigit = new Node ( k3 , k4 , k5 ) ; firstDigit . addChild ( secondDigit ) ; thirdDigit = new Node ( k0 , k1 , k2 , k3 , k4 , k5 , k6 , k7 , k8 , k9 ) ; secondDigit . addChild ( thirdDigit ) ; thirdDigit . addChild ( ampm ) ; firstDigit = new Node ( k2 , k3 , k4 , k5 , k6 , k7 , k8 , k9 ) ; mLegalTimesTree . addChild ( firstDigit ) ; firstDigit . addChild ( ampm ) ; secondDigit = new Node ( k0 , k1 , k2 , k3 , k4 , k5 ) ; firstDigit . addChild ( secondDigit ) ; thirdDigit = new Node ( k0 , k1 , k2 , k3 , k4 , k5 , k6 , k7 , k8 , k9 ) ; secondDigit . addChild ( thirdDigit ) ; thirdDigit . addChild ( ampm ) ; } }
public StrBuilder insert ( final int index , final Object obj ) { if ( obj == null ) { return insert ( index , nullText ) ; } return insert ( index , obj . toString ( ) ) ; }
@ Override public void handleMouseMoved ( ChartCanvas canvas , MouseEvent e ) { if ( ! canvas . isTooltipEnabled ( ) ) { return ; } String text = getTooltipText ( canvas , e . getX ( ) , e . getY ( ) ) ; canvas . setTooltip ( text , e . getScreenX ( ) , e . getScreenY ( ) ) ; }
public int size ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { return count ; } finally { lock . unlock ( ) ; } }
private boolean loadUnpackedUMD ( String filename ) throws IOException , GeneralJpcspException { if ( doUmdBuffering ) { return BOOL_ ; } File file = new File ( filename ) ; if ( file . exists ( ) ) { RandomAccessFile raf = new RandomAccessFile ( file , STR_ ) ; FileChannel roChannel = raf . getChannel ( ) ; ByteBuffer readbuffer = roChannel . map ( FileChannel . MapMode . READ_ONLY , NUM_ , ( int ) roChannel . size ( ) ) ; emulator . load ( STR_ , readbuffer ) ; raf . close ( ) ; log . info ( STR_ ) ; return BOOL_ ; } return BOOL_ ; }
public boolean disableVMAX3Compression ( URI blockObjectURI , StorageSystem storageSystem ) { VirtualPool virtualPool = null ; StoragePool storagePool = null ; Volume volume = null ; if ( URIUtil . isType ( blockObjectURI , Volume . class ) ) { volume = _dbClient . queryObject ( Volume . class , blockObjectURI ) ; } else if ( URIUtil . isType ( blockObjectURI , BlockSnapshot . class ) ) { BlockSnapshot snapshot = _dbClient . queryObject ( BlockSnapshot . class , blockObjectURI ) ; volume = _dbClient . queryObject ( Volume . class , snapshot . getParent ( ) ) ; } else if ( URIUtil . isType ( blockObjectURI , BlockMirror . class ) ) { BlockMirror mirror = _dbClient . queryObject ( BlockMirror . class , blockObjectURI ) ; virtualPool = _dbClient . queryObject ( VirtualPool . class , mirror . getVirtualPool ( ) ) ; storagePool = _dbClient . queryObject ( StoragePool . class , mirror . getPool ( ) ) ; } if ( volume != null ) { virtualPool = _dbClient . queryObject ( VirtualPool . class , volume . getVirtualPool ( ) ) ; storagePool = _dbClient . queryObject ( StoragePool . class , volume . getPool ( ) ) ; } return ( checkIfProviderSupportsCompressionOperations ( storageSystem ) && ! virtualPool . getCompressionEnabled ( ) && storagePool . getCompressionEnabled ( ) ) ; }
public static LatLon rhumbEndPosition ( LatLon p , double rhumbAzimuthRadians , double pathLengthRadians ) { if ( p == null ) { throw new IllegalArgumentException ( STR_ ) ; } return rhumbEndPosition ( p , Angle . fromRadians ( rhumbAzimuthRadians ) , Angle . fromRadians ( pathLengthRadians ) ) ; }
private static int indexOf ( Object [ ] array , Object elt ) { return indexOf ( array , array . length , elt ) ; }
public Dimension maximumLayoutSize ( Container target ) { return new Dimension ( Integer . MAX_VALUE , Integer . MAX_VALUE ) ; }
public static String readStream ( InputStream in ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( in ) ) ; StringBuilder sb = new StringBuilder ( ) ; String line = null ; try { while ( ( line = reader . readLine ( ) ) != null ) { sb . append ( line + STR_ ) ; } } catch ( IOException e ) { FreshAirLog . e ( STR_ , e ) ; } finally { try { in . close ( ) ; } catch ( IOException e ) { } try { reader . close ( ) ; } catch ( IOException e ) { } } return sb . toString ( ) ; }
public void update ( long n ) { uncounted . addAndGet ( n ) ; }
private void logExpiration ( Entry e ) { if ( e . renewalsDone ( ) ) { logger . log ( Level . FINE , STR_ , e . lease ) ; } else { logger . log ( Levels . FAILED , STR_ , e . lease ) ; } }
void removeRipple ( Ripple ripple ) { final Ripple [ ] ripples = mExitingRipples ; final int count = mExitingRipplesCount ; final int index = getRippleIndex ( ripple ) ; if ( index >= NUM_ ) { System . arraycopy ( ripples , index + NUM_ , ripples , index , count - ( index + NUM_ ) ) ; ripples [ count - NUM_ ] = null ; mExitingRipplesCount -- ; invalidateSelf ( ) ; } }
protected final void writeS ( ByteBuffer buf , String text ) { if ( text == null ) { buf . putChar ( STR_ ) ; } else { final int len = text . length ( ) ; for ( int i = NUM_ ; i < len ; i ++ ) { buf . putChar ( text . charAt ( i ) ) ; } buf . putChar ( STR_ ) ; } }
@ Override public void onDrawEye ( Eye eye ) { GLES20 . glClear ( GLES20 . GL_COLOR_BUFFER_BIT | GLES20 . GL_DEPTH_BUFFER_BIT ) ; Engine . checkGLError ( STR_ ) ; if ( ! prefOrientationProviderString . equals ( STR_ ) ) { if ( firstOnDrawEye > NUM_ ) { firstOnDrawEye -- ; float [ ] m = new float [ NUM_ ] ; Matrix . invertM ( m , NUM_ , mHeadViewSDK , NUM_ ) ; Matrix . multiplyMM ( m , NUM_ , eye . getEyeView ( ) , NUM_ , m , NUM_ ) ; if ( eye . getType ( ) == Eye . Type . RIGHT ) { mEyeRightView = m ; } else if ( eye . getType ( ) == Eye . Type . LEFT ) { mEyeLeftView = m ; } return ; } float [ ] m = new float [ NUM_ ] ; if ( eye . getType ( ) == Eye . Type . RIGHT ) { Matrix . multiplyMM ( m , NUM_ , mHeadViewUse , NUM_ , mEyeRightView , NUM_ ) ; } else { Matrix . multiplyMM ( m , NUM_ , mHeadViewUse , NUM_ , mEyeLeftView , NUM_ ) ; } Matrix . multiplyMM ( mView , NUM_ , m , NUM_ , mCamera , NUM_ ) ; } else { Matrix . multiplyMM ( mView , NUM_ , eye . getEyeView ( ) , NUM_ , mCamera , NUM_ ) ; } float [ ] perspective = eye . getPerspective ( Z_NEAR , Z_FAR ) ; GLES20 . glEnable ( GLES20 . GL_DEPTH_TEST ) ; GLES20 . glBlendFunc ( GLES20 . GL_SRC_ALPHA , GLES20 . GL_ONE_MINUS_SRC_ALPHA ) ; GLES20 . glEnable ( GLES20 . GL_BLEND ) ; if ( prefShowEnv && bgEnv . isReady ( ) ) { Matrix . multiplyMM ( mModelView , NUM_ , mView , NUM_ , bgEnv . model , NUM_ ) ; Matrix . multiplyMM ( mModelViewProjection , NUM_ , perspective , NUM_ , mModelView , NUM_ ) ; bgEnv . draw ( eye . getType ( ) , mModelViewProjection ) ; } GLES20 . glDisable ( GLES20 . GL_DEPTH_TEST ) ; Matrix . multiplyMM ( mModelViewProjection , NUM_ , perspective , NUM_ , cameraPreview . model , NUM_ ) ; cameraPreview . draw ( eye . getType ( ) , mModelViewProjection ) ; Matrix . multiplyMM ( mModelView , NUM_ , mView , NUM_ , screen . model , NUM_ ) ; Matrix . multiplyMM ( mModelViewProjection , NUM_ , perspective , NUM_ , mModelView , NUM_ ) ; screen . draw ( eye . getType ( ) , mModelViewProjection ) ; for ( ButtonThing button : buttonList ) { Matrix . multiplyMM ( mModelView , NUM_ , mView , NUM_ , button . model , NUM_ ) ; Matrix . multiplyMM ( mModelViewProjection , NUM_ , perspective , NUM_ , mModelView , NUM_ ) ; button . draw ( eye . getType ( ) , mModelViewProjection ) ; } Matrix . multiplyMM ( mModelViewProjection , NUM_ , perspective , NUM_ , aimPoint . model , NUM_ ) ; aimPoint . draw ( Eye . Type . MONOCULAR , mModelViewProjection ) ; }
protected SourceRecords consumeRecordsByTopic ( int numRecords ) throws InterruptedException { SourceRecords records = new SourceRecords ( ) ; consumeRecords ( numRecords , null ) ; return records ; }
@ Override public boolean equals ( Object o ) { if ( this == o ) { return BOOL_ ; } if ( ! ( o instanceof PrototypeSize ) ) { return BOOL_ ; } PrototypeSize size = ( PrototypeSize ) o ; return prototype . equals ( size . prototype ) ; }
private static int compareVersion ( String versionStr1 , String versionStr2 ) { if ( versionStr1 == null ) { throw new MLContextException ( STR_ ) ; } if ( versionStr2 == null ) { throw new MLContextException ( STR_ ) ; } Scanner scanner1 = null ; Scanner scanner2 = null ; try { scanner1 = new Scanner ( versionStr1 ) ; scanner2 = new Scanner ( versionStr2 ) ; scanner1 . useDelimiter ( STR_ ) ; scanner2 . useDelimiter ( STR_ ) ; while ( scanner1 . hasNextInt ( ) && scanner2 . hasNextInt ( ) ) { int version1 = scanner1 . nextInt ( ) ; int version2 = scanner2 . nextInt ( ) ; if ( version1 < version2 ) { return - NUM_ ; } else if ( version1 > version2 ) { return NUM_ ; } } return scanner1 . hasNextInt ( ) ? NUM_ : NUM_ ; } finally { scanner1 . close ( ) ; scanner2 . close ( ) ; } }
public static boolean isValidVector ( Vector2f vector ) { if ( vector == null ) { return BOOL_ ; } if ( Float . isNaN ( vector . x ) || Float . isNaN ( vector . y ) ) { return BOOL_ ; } if ( Float . isInfinite ( vector . x ) || Float . isInfinite ( vector . y ) ) { return BOOL_ ; } return BOOL_ ; }
public boolean isObsessional ( ) { return typeString . contains ( SUFFIX_OBSESSIONAL ) ; }
@ edu . umd . cs . findbugs . annotations . SuppressFBWarnings ( value = STR_ , justification = STR_ ) public void changeLocoSpeed ( DccThrottle t , Block blk , float speed ) { if ( blk == referenced && speed == desiredSpeedStep ) { return ; } float blockLength = blk . getLengthMm ( ) ; if ( blk == referenced ) { distanceRemaining = distanceRemaining - getDistanceTravelled ( _throttle . getIsForward ( ) , _throttle . getSpeedSetting ( ) , ( ( float ) ( System . nanoTime ( ) - lastTimeTimerStarted ) / NUM_ ) ) ; blockLength = distanceRemaining ; log . debug ( STR_ ) ; } else { referenced = blk ; } changeLocoSpeed ( t , blockLength , speed ) ; }
public boolean remove ( Object targetChild ) { return remove ( targetChild , BOOL_ ) ; }
private void notifyClassObservers ( ClassDescriptor classDescriptor ) { for ( IClassObserver observer : classObserverList ) { observer . observeClass ( classDescriptor ) ; } }
public void dup2 ( ) { mv . visitInsn ( Opcodes . DUP2 ) ; }
static boolean isAppXml ( String mime ) { return mime != null && ( mime . equals ( STR_ ) || mime . equals ( STR_ ) || mime . equals ( STR_ ) || mime . startsWith ( STR_ ) && mime . endsWith ( STR_ ) ) ; }
public static NativePage createNativePageForURL ( String url , NativePage candidatePage , Tab tab , TabModelSelector tabModelSelector , Activity activity ) { return createNativePageForURL ( url , candidatePage , tab , tabModelSelector , activity , tab . isIncognito ( ) ) ; }
protected void throwParseException ( ParseException e ) throws ParseException { if ( locator != null ) { String elementLocation = STR_ ; if ( curHandler != null ) { elementLocation += STR_ + curHandler . qName ; } String location = STR_ + String . valueOf ( locator . getLineNumber ( ) ) + STR_ + String . valueOf ( locator . getColumnNumber ( ) ) + elementLocation + STR_ ; LogUtils . logException ( logger , Level . FINE , location , e ) ; throw new ParseException ( location + e . getMessage ( ) , e ) ; } else { LogUtils . logException ( logger , Level . FINE , null , e ) ; throw e ; } }
public CustomEditor ( ) { setLayout ( new BorderLayout ( ) ) ; add ( m_Label , BorderLayout . CENTER ) ; m_DeleteBut . addActionListener ( m_InnerActionListener ) ; m_EditBut . addActionListener ( m_InnerActionListener ) ; m_UpBut . addActionListener ( m_InnerActionListener ) ; m_DownBut . addActionListener ( m_InnerActionListener ) ; m_AddBut . addActionListener ( m_InnerActionListener ) ; m_ElementList . addListSelectionListener ( m_InnerSelectionListener ) ; m_ElementList . addMouseListener ( m_InnerMouseListener ) ; m_AddBut . setToolTipText ( STR_ ) ; m_DeleteBut . setToolTipText ( STR_ ) ; m_EditBut . setToolTipText ( STR_ ) ; m_UpBut . setToolTipText ( STR_ ) ; m_DownBut . setToolTipText ( STR_ ) ; }
public MemoidOne ( Function < ? super Input , ? extends Output > fn , BiPredicate < Input , Input > equality ) { fn_ = Objects . requireNonNull ( fn ) ; equality_ = Objects . requireNonNull ( equality ) ; }
public static EPType singleValue ( Class singleValueType ) { if ( singleValueType != null && singleValueType . isArray ( ) ) { return new ClassMultiValuedEPType ( singleValueType , singleValueType . getComponentType ( ) ) ; } return new ClassEPType ( singleValueType ) ; }
private static Class < ? > convertFieldType ( String fieldType ) { if ( fieldTypeMap . containsKey ( fieldType ) ) { return fieldTypeMap . get ( fieldType ) ; } return null ; }
void addXMLElementAfterTokenIndex ( int lastTokenIndex , XMLElement element , boolean addAfterNewLine ) throws Exception { addXMLElementAfterTokenIndex ( lastTokenIndex , element , addAfterNewLine , BOOL_ ) ; }
public static Map < String , Object > findContentParents ( DispatchContext dctx , Map < String , ? extends Object > context ) { Map < String , Object > results = FastMap . newInstance ( ) ; List < Object > parentList = FastList . newInstance ( ) ; results . put ( STR_ , parentList ) ; LocalDispatcher dispatcher = dctx . getDispatcher ( ) ; String contentId = ( String ) context . get ( STR_ ) ; String contentAssocTypeId = ( String ) context . get ( STR_ ) ; String direction = ( String ) context . get ( STR_ ) ; if ( UtilValidate . isEmpty ( direction ) ) { direction = STR_ ; } Map < String , Object > traversMap = FastMap . newInstance ( ) ; traversMap . put ( STR_ , contentId ) ; traversMap . put ( STR_ , direction ) ; traversMap . put ( STR_ , contentAssocTypeId ) ; try { Map < String , Object > thisResults = dispatcher . runSync ( STR_ , traversMap ) ; String errorMsg = ServiceUtil . getErrorMessage ( thisResults ) ; if ( UtilValidate . isNotEmpty ( errorMsg ) ) { Debug . logError ( STR_ + errorMsg , module ) ; return ServiceUtil . returnError ( errorMsg ) ; } Map < String , Object > nodeMap = UtilGenerics . checkMap ( thisResults . get ( STR_ ) ) ; walkParentTree ( nodeMap , parentList ) ; } catch ( GenericServiceException e ) { return ServiceUtil . returnFailure ( e . getMessage ( ) ) ; } return results ; }
public static boolean arrayEquals ( Object x , Object y , double tolf , double told ) { if ( x == null && y == null ) { return BOOL_ ; } if ( x == null || y == null ) { return BOOL_ ; } Class < ? > xClass = x . getClass ( ) ; Class < ? > yClass = y . getClass ( ) ; if ( xClass != yClass ) { return BOOL_ ; } if ( ! xClass . isArray ( ) ) { return x . equals ( y ) ; } else { if ( xClass . equals ( int [ ] . class ) ) { return Arrays . equals ( ( int [ ] ) x , ( int [ ] ) y ) ; } else if ( xClass . equals ( double [ ] . class ) ) { if ( told == NUM_ ) { return Arrays . equals ( ( double [ ] ) x , ( double [ ] ) y ) ; } else { return doubleArrayEquals ( ( double [ ] ) x , ( double [ ] ) y , told ) ; } } else if ( xClass . equals ( long [ ] . class ) ) { return Arrays . equals ( ( long [ ] ) x , ( long [ ] ) y ) ; } else if ( xClass . equals ( float [ ] . class ) ) { if ( tolf == NUM_ ) { return Arrays . equals ( ( float [ ] ) x , ( float [ ] ) y ) ; } else { return floatArrayEquals ( ( float [ ] ) x , ( float [ ] ) y , ( float ) tolf ) ; } } else if ( xClass . equals ( byte [ ] . class ) ) { return Arrays . equals ( ( byte [ ] ) x , ( byte [ ] ) y ) ; } else if ( xClass . equals ( short [ ] . class ) ) { return Arrays . equals ( ( short [ ] ) x , ( short [ ] ) y ) ; } else if ( xClass . equals ( char [ ] . class ) ) { return Arrays . equals ( ( char [ ] ) x , ( char [ ] ) y ) ; } else if ( xClass . equals ( boolean [ ] . class ) ) { return Arrays . equals ( ( boolean [ ] ) x , ( boolean [ ] ) y ) ; } else { Object [ ] xo = ( Object [ ] ) x ; Object [ ] yo = ( Object [ ] ) y ; if ( xo . length != yo . length ) { return BOOL_ ; } for ( int i = NUM_ ; i < xo . length ; i += NUM_ ) { if ( ! arrayEquals ( xo [ i ] , yo [ i ] , tolf , told ) ) { return BOOL_ ; } } return BOOL_ ; } } }
public Dictionary ( Directory tempDir , String tempFileNamePrefix , InputStream affix , List < InputStream > dictionaries , boolean ignoreCase ) throws IOException , ParseException { this . ignoreCase = ignoreCase ; this . needsInputCleaning = ignoreCase ; this . needsOutputCleaning = BOOL_ ; flagLookup . add ( new BytesRef ( ) ) ; Path aff = Files . createTempFile ( tempPath , STR_ , STR_ ) ; OutputStream out = new BufferedOutputStream ( Files . newOutputStream ( aff ) ) ; InputStream aff1 = null ; InputStream aff2 = null ; boolean success = BOOL_ ; try { final byte [ ] buffer = new byte [ NUM_ . NUM_ ] ; int len ; while ( ( len = affix . read ( buffer ) ) > NUM_ ) { out . write ( buffer , NUM_ , len ) ; } out . close ( ) ; aff1 = new BufferedInputStream ( Files . newInputStream ( aff ) ) ; String encoding = getDictionaryEncoding ( aff1 ) ; CharsetDecoder decoder = getJavaEncoding ( encoding ) ; aff2 = new BufferedInputStream ( Files . newInputStream ( aff ) ) ; readAffixFile ( aff2 , decoder ) ; IntSequenceOutputs o = IntSequenceOutputs . getSingleton ( ) ; Builder < IntsRef > b = new Builder < > ( FST . INPUT_TYPE . BYTE4 , o ) ; readDictionaryFiles ( tempDir , tempFileNamePrefix , dictionaries , decoder , b ) ; words = b . finish ( ) ; aliases = null ; morphAliases = null ; success = BOOL_ ; } finally { IOUtils . closeWhileHandlingException ( out , aff1 , aff2 ) ; if ( success ) { Files . delete ( aff ) ; } else { IOUtils . deleteFilesIgnoringExceptions ( aff ) ; } } }
public void collapseBuilding ( Building bldg ) { buildings . removeElement ( bldg ) ; Enumeration < Coords > bldgCoords = bldg . getCoords ( ) ; while ( bldgCoords . hasMoreElements ( ) ) { final Coords coords = bldgCoords . nextElement ( ) ; collapseBuilding ( coords ) ; } }
@ RpcMethod public void detachISO ( String vmId , boolean isDeleteFile , AsyncMethodCallback < Host . AsyncClient . detach_iso_call > handler ) throws RpcException { ensureClient ( ) ; DetachISORequest detachISORequest = new DetachISORequest ( vmId ) ; detachISORequest . setDelete_file ( isDeleteFile ) ; clientProxy . setTimeout ( DETACH_ISO_TIMEOUT_MS ) ; logger . info ( STR_ , vmId , getHostIp ( ) , detachISORequest ) ; try { clientProxy . detach_iso ( detachISORequest , handler ) ; } catch ( TException e ) { throw new RpcException ( e . getMessage ( ) ) ; } }
private String readNfcErrorMsg ( ByteBuffer reply ) throws IOException { int errorType = reply . getInt ( ) ; int errorCode = reply . getInt ( ) ; int msgLen = reply . getInt ( ) ; if ( msgLen == NUM_ ) { return STR_ ; } ByteBuffer msgBuffer = ByteBuffer . allocate ( msgLen ) ; readFully ( msgBuffer ) ; String errorMsg = new String ( msgBuffer . array ( ) , NUM_ , msgLen - NUM_ , Charsets . US_ASCII ) ; return String . format ( STR_ , errorType , errorCode , errorMsg ) ; }
private void show ( boolean show ) { if ( show ) { if ( mXFade != null ) { mXFade . cancel ( ) ; } mState = STATE_PIE ; mCurrentItem = null ; PieItem root = getRoot ( ) ; for ( PieItem openItem : mOpen ) { if ( openItem . hasItems ( ) ) { for ( PieItem item : openItem . getItems ( ) ) { item . setSelected ( BOOL_ ) ; } } } mLabel . setText ( STR_ ) ; mOpen . clear ( ) ; mOpen . add ( root ) ; layoutPie ( ) ; fadeIn ( ) ; } else { mState = STATE_IDLE ; mTapMode = BOOL_ ; if ( mXFade != null ) { mXFade . cancel ( ) ; } if ( mLabel != null ) { mLabel . setText ( STR_ ) ; } } setVisible ( show ) ; mHandler . sendEmptyMessage ( show ? MSG_OPEN : MSG_CLOSE ) ; }
private synchronized void persistProfileAndNotifyChange ( AuthnProvider modifiedProvider , boolean newObject ) { modifiedProvider . setLastModified ( System . currentTimeMillis ( ) ) ; if ( newObject ) { _dbClient . createObject ( modifiedProvider ) ; } else { _dbClient . persistObject ( modifiedProvider ) ; } notifyChange ( ) ; }
public void addUndoableAction ( UndoableAction action ) { undoStack . push ( action ) ; redoStack . removeAllElements ( ) ; }
public IntArrayList ( int [ ] data ) { array = new int [ ( int ) ( data . length . NUM_ ) + NUM_ ] ; size = data . length ; System . arraycopy ( data , NUM_ , array , NUM_ , size ) ; }
private void addPingTimeData ( long sample ) { lastPingTimesLock . lock ( ) ; try { if ( lastPingTimes == null ) { lastPingTimes = new long [ PING_MOVING_AVERAGE_WINDOW ] ; Arrays . fill ( lastPingTimes , sample ) ; } else { System . arraycopy ( lastPingTimes , NUM_ , lastPingTimes , NUM_ , lastPingTimes . length - NUM_ ) ; lastPingTimes [ lastPingTimes . length - NUM_ ] = sample ; } } finally { lastPingTimesLock . unlock ( ) ; } }
public StringBuilder encodeBody ( StringBuilder buffer ) { return buffer . append ( contentEncoding ) ; }
protected void tearDown ( ) { try { ds . close ( ) ; sds . close ( ) ; } catch ( Exception e ) { } }
public String substring ( String subject , int start , int stop ) { if ( stop == - NUM_ || stop >= subject . length ( ) ) { return subject . substring ( start ) ; } return subject . substring ( start , stop ) ; }
public boolean controlRunTrain ( int idx ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + idx + STR_ + _runMode + STR_ + getDisplayName ( ) ) ; } boolean ret = BOOL_ ; int oldIndex = - MODE_MANUAL ; if ( _engineer == null ) { switch ( idx ) { case HALT : case RESUME : case RETRY : ret = BOOL_ ; break ; case ABORT : if ( _runMode == Warrant . MODE_LEARN ) { firePropertyChange ( STR_ , Integer . valueOf ( - MODE_LEARN ) , Integer . valueOf ( _idxCurrentOrder ) ) ; } else { stopWarrant ( BOOL_ ) ; } break ; } } else { synchronized ( _engineer ) { oldIndex = _engineer . getRunState ( ) ; switch ( idx ) { case HALT : _engineer . setHalt ( BOOL_ ) ; break ; case RESUME : _engineer . setHalt ( BOOL_ ) ; restart ( ) ; ret = moveIntoNextBlock ( MID ) ; break ; case RETRY : BlockOrder bo = getBlockOrderAt ( _idxCurrentOrder + NUM_ ) ; ret = BOOL_ ; if ( bo != null ) { OBlock b = bo . getBlock ( ) ; if ( b . allocate ( this ) == null && ( b . getState ( ) & OBlock . OCCUPIED ) != NUM_ ) { _idxCurrentOrder ++ ; if ( b . equals ( _stoppingBlock ) ) { _stoppingBlock . removePropertyChangeListener ( this ) ; _stoppingBlock = null ; } bo . setPath ( this ) ; restart ( ) ; goingActive ( b ) ; ret = BOOL_ ; } } break ; case ABORT : stopWarrant ( BOOL_ ) ; break ; } } } if ( ret ) { firePropertyChange ( STR_ , Integer . valueOf ( oldIndex ) , Integer . valueOf ( idx ) ) ; } return ret ; }
public void removeCustomSashFormListener ( ICustomSashFormListener listener ) { if ( customSashFormListeners != null ) { customSashFormListeners . remove ( listener ) ; } }
public static void writeStringToFile ( File file , String data ) throws IOException { writeStringToFile ( file , data , Charset . defaultCharset ( ) , BOOL_ ) ; }
protected void deleteSessionVariables ( String sessionId , String ... varNames ) { if ( sessionId . equals ( STR_ ) ) { return ; } Key key = keyFactory . newKey ( sessionId ) ; Transaction transaction = datastore . newTransaction ( ) ; try { Entity stateEntity = transaction . get ( key ) ; Entity . Builder builder = Entity . builder ( stateEntity ) ; StringBuilder delNames = new StringBuilder ( ) ; for ( String varName : varNames ) { delNames . append ( varName + STR_ ) ; builder = builder . remove ( varName ) ; } datastore . update ( builder . build ( ) ) ; } catch ( NullPointerException e ) { } finally { if ( transaction . active ( ) ) { transaction . rollback ( ) ; } } }
@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( NUM_ ) ; format ( ( getYear ( ) + NUM_ ) , NUM_ , sb ) ; sb . append ( STR_ ) ; format ( ( getMonth ( ) + NUM_ ) , NUM_ , sb ) ; sb . append ( STR_ ) ; format ( getDate ( ) , NUM_ , sb ) ; return sb . toString ( ) ; }
@ Override public void close ( ) throws IOException { if ( mBufferCount > NUM_ ) { try { mQueue . write ( mBuffer , NUM_ , mBufferCount ) ; } catch ( InterruptedException e ) { throw new IOException ( STR_ ) ; } mBufferCount = NUM_ ; } mQueue . close ( ) ; try { mThread . join ( ) ; } catch ( InterruptedException e ) { throw new IOException ( STR_ ) ; } finally { super . close ( ) ; } checkException ( ) ; }
public static int parseStringAsInt ( String in ) throws IndexParseFieldException { try { return Integer . parseInt ( in ) ; } catch ( NumberFormatException e ) { throw new IndexParseFieldException ( in , e ) ; } }
public void writeAll ( ResultSet rs , boolean includeColumnNames , boolean trim ) throws SQLException , IOException { if ( includeColumnNames ) { writeColumnNames ( rs ) ; } while ( rs . next ( ) ) { writeNext ( resultService . getColumnValues ( rs , trim ) ) ; } }
public void testSpecialCase1 ( ) { byte aBytes [ ] = { - NUM_ , - NUM_ , - NUM_ , - NUM_ } ; byte bBytes [ ] = { NUM_ , - NUM_ , - NUM_ , - NUM_ } ; int aSign = - NUM_ ; int bSign = - NUM_ ; byte rBytes [ ] = { - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . and ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , - NUM_ , result . signum ( ) ) ; }
private static void verifyDevice ( IDevice d , long mac , Short vlan , Integer ip , long swId , int port ) { assertNotNull ( d ) ; assertEquals ( MacAddress . of ( mac ) , d . getMACAddress ( ) ) ; if ( vlan == null ) assertArrayEquals ( new VlanVid [ ] { VlanVid . ofVlan ( - NUM_ ) } , d . getVlanId ( ) ) ; else assertArrayEquals ( new VlanVid [ ] { VlanVid . ofVlan ( vlan ) } , d . getVlanId ( ) ) ; if ( ip == null ) assertArrayEquals ( new IPv4Address [ ] { IPv4Address . of ( NUM_ ) } , d . getIPv4Addresses ( ) ) ; else assertArrayEquals ( new IPv4Address [ ] { IPv4Address . of ( ip ) } , d . getIPv4Addresses ( ) ) ; SwitchPort expectedAp = new SwitchPort ( DatapathId . of ( swId ) , OFPort . of ( port ) ) ; assertArrayEquals ( new SwitchPort [ ] { expectedAp } , d . getAttachmentPoints ( ) ) ; }
public ZoneRulesBuilder addWindow ( ZoneOffset standardOffset , LocalDateTime until , TimeDefinition untilDefinition ) { Objects . requireNonNull ( standardOffset , STR_ ) ; Objects . requireNonNull ( until , STR_ ) ; Objects . requireNonNull ( untilDefinition , STR_ ) ; TZWindow window = new TZWindow ( standardOffset , until , untilDefinition ) ; if ( windowList . size ( ) > NUM_ ) { TZWindow previous = windowList . get ( windowList . size ( ) - NUM_ ) ; window . validateWindowOrder ( previous ) ; } windowList . add ( window ) ; return this ; }
public Hashtable < IPoint , List < ILineSegment > > intersections ( Iterator < ILineSegment > it ) { Collection < ILineSegment > c = new ArrayList < ILineSegment > ( ) ; while ( it . hasNext ( ) ) { c . add ( it . next ( ) ) ; } return intersections ( c . toArray ( new ILineSegment [ ] { } ) ) ; }
public boolean isTTFNativeFont ( ) { return ttf ; }
private void registerProviders ( ) { final DevMachine devMachine = appContext . getDevMachine ( ) ; if ( devMachine == null ) { return ; } final Set < Macro > providers = getMacros ( devMachine ) ; checkNotNull ( providers ) ; if ( providers . isEmpty ( ) ) { return ; } providerRegistry . register ( providers ) ; }
public LongMap ( int initialCapacity , float loadFactor ) { if ( initialCapacity < NUM_ ) throw new IllegalArgumentException ( STR_ + initialCapacity ) ; if ( capacity > NUM_ << NUM_ ) throw new IllegalArgumentException ( STR_ + initialCapacity ) ; capacity = MathUtils . nextPowerOfTwo ( initialCapacity ) ; if ( loadFactor <= NUM_ ) throw new IllegalArgumentException ( STR_ + loadFactor ) ; this . loadFactor = loadFactor ; threshold = ( int ) ( capacity . loadFactor ) ; mask = capacity - NUM_ ; hashShift = NUM_ - Integer . numberOfTrailingZeros ( capacity ) ; stashCapacity = Math . max ( NUM_ , ( int ) Math . ceil ( Math . log ( capacity ) ) + NUM_ ) ; pushIterations = Math . max ( Math . min ( capacity , NUM_ ) , ( int ) Math . sqrt ( capacity ) / NUM_ ) ; keyTable = new long [ capacity + stashCapacity ] ; valueTable = ( V [ ] ) new Object [ keyTable . length ] ; }
protected ASN1Set ( ASN1Encodable obj ) { set . addElement ( obj ) ; }
protected void populateStreamBlob ( int testId , byte [ ] baseContent , int requiredSize ) throws SQLException { final byte [ ] testBytes = generateBlobContent ( baseContent , requiredSize ) ; try ( FbDatabase db = createDatabaseConnection ( ) ) { listener = new SimpleStatementListener ( ) ; transaction = getTransaction ( db ) ; try { statement = db . createStatement ( transaction ) ; statement . addStatementListener ( listener ) ; final BlobParameterBuffer blobParameterBuffer = db . createBlobParameterBuffer ( ) ; blobParameterBuffer . addArgument ( BlobParameterBuffer . TYPE , BlobParameterBuffer . TYPE_STREAM ) ; final FbBlob blob = db . createBlobForOutput ( transaction , blobParameterBuffer ) ; blob . open ( ) ; int bytesWritten = NUM_ ; while ( bytesWritten < testBytes . length ) { byte [ ] buffer = new byte [ Math . min ( blob . getMaximumSegmentSize ( ) , testBytes . length - bytesWritten ) ] ; System . arraycopy ( testBytes , bytesWritten , buffer , NUM_ , buffer . length ) ; blob . putSegment ( buffer ) ; bytesWritten += buffer . length ; } blob . close ( ) ; statement . prepare ( INSERT_BLOB_TABLE ) ; final DatatypeCoder datatypeCoder = db . getDatatypeCoder ( ) ; FieldValue param1 = new FieldValue ( datatypeCoder . encodeInt ( testId ) ) ; FieldValue param2 = new FieldValue ( datatypeCoder . encodeLong ( blob . getBlobId ( ) ) ) ; statement . execute ( RowValue . of ( param1 , param2 ) ) ; statement . close ( ) ; } finally { transaction . commit ( ) ; } } }
private static long signFromBit_antiCyclic ( final double value ) { return Double . doubleToRawLongBits ( value ) > > NUM_ | NUM_ ; }
public void addNearKey ( KeyCacheObject key , GridCacheSharedContext ctx ) throws IgniteCheckedException { nearKeys . add ( key ) ; }
private void analyzeClassFields ( String className , int action ) { try { Class < ? > dynamicClass = Class . forName ( className ) ; Field [ ] fields = dynamicClass . getDeclaredFields ( ) ; for ( Field field : fields ) { if ( isPrivateAndNonPrimitive ( field ) ) { oneToAnyConditions ( className , field , action ) ; manyToAnyConditions ( className , field , action ) ; } } } catch ( ClassNotFoundException ex ) { ex . printStackTrace ( ) ; throw new DatabaseGenerateException ( DatabaseGenerateException . CLASS_NOT_FOUND + className ) ; } }
protected boolean isLevelEnabled ( int logLevel ) { return ( logLevel >= currentLogLevel ) ; }
public static void loadAll ( final JFrame parent , final IDebugger debugger , final IAddress offset , final int size ) { checkArguments ( parent , debugger , offset ) ; final CDumpAllWaiter waiter = new CDumpAllWaiter ( debugger , offset , size ) ; CProgressDialog . showEndless ( parent , STR_ + STR_ , waiter ) ; if ( waiter . getException ( ) != null ) { CUtilityFunctions . logException ( waiter . getException ( ) ) ; final String innerMessage = STR_ + STR_ ; final String innerDescription = CUtilityFunctions . createDescription ( String . format ( STR_ , offset . toHexString ( ) ) , new String [ ] { STR_ } , new String [ ] { STR_ } ) ; NaviErrorDialog . show ( parent , innerMessage , innerDescription , waiter . getException ( ) ) ; } }
public static boolean deleteDirectory ( String directory , boolean useOSNativeDelete ) throws IOException { boolean result = BOOL_ ; if ( ! useOSNativeDelete ) { File dir = new File ( directory ) ; for ( File file : dir . listFiles ( ) ) { if ( file . delete ( ) ) { log . debug ( STR_ , file . getName ( ) ) ; } else { log . debug ( STR_ , file . getName ( ) ) ; file . deleteOnExit ( ) ; } file = null ; } if ( dir . delete ( ) ) { log . debug ( STR_ ) ; result = BOOL_ ; } else { log . debug ( STR_ ) ; dir . deleteOnExit ( ) ; } dir = null ; } else { Process p = null ; Thread std = null ; try { Runtime runTime = Runtime . getRuntime ( ) ; log . debug ( STR_ ) ; if ( File . separatorChar == STR_ ) { p = runTime . exec ( STR_ + directory . replace ( STR_ , STR_ ) + STR_ ) ; } else { p = runTime . exec ( STR_ + directory . replace ( STR_ , File . separatorChar ) ) ; } std = stdOut ( p ) ; while ( std . isAlive ( ) ) { try { Thread . sleep ( NUM_ ) ; } catch ( Exception e ) { } } log . debug ( STR_ ) ; result = BOOL_ ; } catch ( Exception e ) { log . error ( STR_ , e ) ; } finally { if ( null != p ) { log . debug ( STR_ ) ; p . destroy ( ) ; p = null ; } std = null ; } } return result ; }
public void testSetAttributeNodeNS1 ( ) throws Throwable { Document doc ; Element element ; Attr attribute1 ; Attr attribute2 ; Attr attrNode ; String attrName ; String attrNS ; NamedNodeMap attributes ; int length ; doc = ( Document ) load ( STR_ , builder ) ; element = doc . createElementNS ( STR_ , STR_ ) ; attribute1 = doc . createAttributeNS ( STR_ , STR_ ) ; attribute2 = doc . createAttributeNS ( STR_ , STR_ ) ; attribute2 . setValue ( STR_ ) ; element . setAttributeNodeNS ( attribute1 ) ; element . setAttributeNodeNS ( attribute2 ) ; attrNode = element . getAttributeNodeNS ( STR_ , STR_ ) ; attrName = attrNode . getNodeName ( ) ; attrNS = attrNode . getNamespaceURI ( ) ; assertEquals ( STR_ , STR_ , attrName ) ; assertEquals ( STR_ , STR_ , attrNS ) ; attributes = element . getAttributes ( ) ; length = ( int ) attributes . getLength ( ) ; assertEquals ( STR_ , NUM_ , length ) ; }
public boolean isCritical ( ) { return BOOL_ ; }
public static String findEditTable ( String tables ) { if ( ! StringUtils . isEmpty ( tables ) ) { int spacepos = tables . indexOf ( STR_ ) ; int commapos = tables . indexOf ( STR_ ) ; if ( spacepos > NUM_ && ( spacepos < commapos || commapos < NUM_ ) ) { return tables . substring ( NUM_ , spacepos ) ; } else if ( commapos > NUM_ && ( commapos < spacepos || spacepos < NUM_ ) ) { return tables . substring ( NUM_ , commapos ) ; } return tables ; } else { throw new IllegalStateException ( STR_ ) ; } }
public void writeOperationsCarFile ( ) { makeBackupFile ( defaultOperationsFilename ( ) ) ; try { if ( ! checkFile ( defaultOperationsFilename ( ) ) ) { java . io . File file = new java . io . File ( defaultOperationsFilename ( ) ) ; java . io . File parentDir = file . getParentFile ( ) ; if ( ! parentDir . exists ( ) ) { if ( ! parentDir . mkdir ( ) ) { log . error ( STR_ ) ; } } if ( file . createNewFile ( ) ) { log . debug ( STR_ ) ; } } writeFile ( defaultOperationsFilename ( ) ) ; } catch ( Exception e ) { log . error ( STR_ + e ) ; } }
ConfigurationError ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; }
private boolean hasNewFollowers ( List < Follower > followers ) { return ! followers . isEmpty ( ) && followers . get ( NUM_ ) . newFollower ; }
private void onTrackPointElementStart ( Attributes attributes ) throws SAXException { String latitude = attributes . getValue ( ATT_LAT ) ; String longitude = attributes . getValue ( ATT_LON ) ; if ( latitude == null || longitude == null ) { throw new SAXException ( createErrorMessage ( STR_ ) ) ; } try { latitudeValue = Double . parseDouble ( latitude ) ; longitudeValue = Double . parseDouble ( longitude ) ; } catch ( NumberFormatException e ) { throw new SAXException ( createErrorMessage ( STR_ + latitude + STR_ + longitude ) , e ) ; } }
protected final void firePropertyChange ( PropertyChangeEvent evt ) { pcs . firePropertyChange ( evt ) ; }
static int checkDesc ( final String desc , final int start , final boolean canBeVoid ) { if ( desc == null || start >= desc . length ( ) ) { throw new IllegalArgumentException ( STR_ ) ; } int index ; switch ( desc . charAt ( start ) ) { case STR_ : if ( canBeVoid ) { return start + NUM_ ; } else { throw new IllegalArgumentException ( STR_ + desc ) ; } case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : return start + NUM_ ; case STR_ : index = start + NUM_ ; while ( index < desc . length ( ) && desc . charAt ( index ) == STR_ ) { ++ index ; } if ( index < desc . length ( ) ) { return checkDesc ( desc , index , BOOL_ ) ; } else { throw new IllegalArgumentException ( STR_ + desc ) ; } case STR_ : index = desc . indexOf ( STR_ , start ) ; if ( index == - NUM_ || index - start < NUM_ ) { throw new IllegalArgumentException ( STR_ + desc ) ; } try { checkInternalName ( desc , start + NUM_ , index , null ) ; } catch ( IllegalArgumentException unused ) { throw new IllegalArgumentException ( STR_ + desc ) ; } return index + NUM_ ; default : throw new IllegalArgumentException ( STR_ + desc ) ; } }
public static void sortFields ( FieldBinding [ ] sortedFields , int left , int right ) { Arrays . sort ( sortedFields , left , right , FIELD_COMPARATOR ) ; }
private void drawBackground ( final Graphics g ) { g . setColor ( m_bgColorOffset ) ; g . fillRect ( - m_firstColumn . m_charWidth , NUM_ , m_offsetViewWidth , getHeight ( ) ) ; }
public void addUniqueAttribute ( final String elementName , final String attrName ) { if ( ( elementName != null ) && ( attrName != null ) ) { _uniqueElementAttrMap . put ( elementName , attrName ) ; } }
private static DeleteVmResponse checkDeleteVmResponse ( DeleteVmResponse deleteVmResponse ) throws RpcException { logger . info ( STR_ , deleteVmResponse ) ; switch ( deleteVmResponse . getResult ( ) ) { case OK : break ; case SYSTEM_ERROR : throw new SystemErrorException ( deleteVmResponse . getError ( ) ) ; case VM_NOT_FOUND : throw new VmNotFoundException ( deleteVmResponse . getError ( ) ) ; case VM_NOT_POWERED_OFF : throw new VmNotPoweredOffException ( deleteVmResponse . getError ( ) ) ; default : throw new RpcException ( String . format ( STR_ , deleteVmResponse . getResult ( ) ) ) ; } return deleteVmResponse ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; nameNode = elementList . item ( NUM_ ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; { boolean success = BOOL_ ; try { child . deleteData ( NUM_ , NUM_ ) ; } catch ( DOMException ex ) { success = ( ex . code == DOMException . INDEX_SIZE_ERR ) ; } assertTrue ( STR_ , success ) ; } }
public BlazeValueFactory valueFactory ( ) { return vf ; }
public StatefulRefreshToken ( JsonValue token ) throws InvalidGrantException { super ( token ) ; if ( ! OAUTH_REFRESH_TOKEN . equals ( getTokenName ( ) ) ) { throw new InvalidGrantException ( STR_ + getTokenId ( ) ) ; } }
public void putStyle ( String styleId , StyleSelector styleSelector ) { try { int id = Integer . parseInt ( styleId ) ; mMaxStyleId = Math . max ( mMaxStyleId , id ) ; } catch ( NumberFormatException e ) { } mStyles . put ( styleId , styleSelector ) ; }
private static String extractClientName ( String clientId , String host ) { String hostExcludedId = STR_ ; if ( ( isIPv6 ( host ) || isIPv4 ( host ) ) && clientId . startsWith ( host ) ) { hostExcludedId = clientId . substring ( host . length ( ) ) ; } else { int firstDotIndex = host . indexOf ( STR_ ) ; if ( firstDotIndex != - NUM_ ) { String hostShortName = host . substring ( NUM_ , firstDotIndex ) ; hostExcludedId = clientId . substring ( hostShortName . length ( ) ) ; } } String vmPIDAndKindRegex = STR_ ; String regex = STR_ ; String name = NOT_AVAILABLE ; String temp = hostExcludedId ; int openIndex = temp . indexOf ( STR_ ) ; if ( openIndex != - NUM_ ) { regex = vmPIDAndKindRegex + regex ; } if ( temp . matches ( regex ) ) { String [ ] splitted = temp . split ( STR_ ) ; name = splitted [ splitted . length - NUM_ ] ; } return name ; }
public static < T > FastFuture < T > fromCompletableFuture ( final CompletableFuture < T > cf ) { final FastFuture < T > f = new FastFuture < > ( ) ; cf . thenAccept ( null ) ; cf . exceptionally ( null ) ; return f ; }
public static boolean isPlaceAction ( InventoryAction action ) { switch ( action ) { case SWAP_WITH_CURSOR : case PLACE_ONE : case PLACE_ALL : case PLACE_SOME : return BOOL_ ; } return BOOL_ ; }
private void refreshMarkers ( ) { removeAll ( ) ; Map markerMap = new HashMap ( ) ; List notices = textArea . getParserNotices ( ) ; for ( Iterator i = notices . iterator ( ) ; i . hasNext ( ) ; ) { ParserNotice notice = ( ParserNotice ) i . next ( ) ; if ( notice . getLevel ( ) <= levelThreshold || ( notice instanceof TaskNotice ) ) { Integer key = new Integer ( notice . getLine ( ) ) ; Marker m = ( Marker ) markerMap . get ( key ) ; if ( m == null ) { m = new Marker ( notice ) ; m . addMouseListener ( listener ) ; markerMap . put ( key , m ) ; add ( m ) ; } else { m . addNotice ( notice ) ; } } } if ( getShowMarkedOccurrences ( ) && textArea . getMarkOccurrences ( ) ) { List occurrences = textArea . getMarkedOccurrences ( ) ; for ( Iterator i = occurrences . iterator ( ) ; i . hasNext ( ) ; ) { DocumentRange range = ( DocumentRange ) i . next ( ) ; int line = NUM_ ; try { line = textArea . getLineOfOffset ( range . getStartOffset ( ) ) ; } catch ( BadLocationException ble ) { continue ; } ParserNotice notice = new MarkedOccurrenceNotice ( range ) ; Integer key = new Integer ( line ) ; Marker m = ( Marker ) markerMap . get ( key ) ; if ( m == null ) { m = new Marker ( notice ) ; m . addMouseListener ( listener ) ; markerMap . put ( key , m ) ; add ( m ) ; } else { if ( ! m . containsMarkedOccurence ( ) ) { m . addNotice ( notice ) ; } } } } revalidate ( ) ; repaint ( ) ; }
private List < View > addView ( View view , List < View > cache ) { if ( cache == null ) { cache = new LinkedList < View > ( ) ; } cache . add ( view ) ; return cache ; }
public static byte [ ] readInputStream ( InputStream i ) throws IOException { ByteArrayOutputStream b = new ByteArrayOutputStream ( ) ; copy ( i , b ) ; return b . toByteArray ( ) ; }
public void playMedia ( boolean showPlayerWindow ) { String filename = stopAndPrepareFilename ( ) ; if ( filename . length ( ) > NUM_ ) { MPlayerMediator mplayerMediator = MPlayerMediator . instance ( ) ; if ( mplayerMediator != null ) { mplayerMediator . showPlayerWindow ( showPlayerWindow ) ; } mplayer . open ( filename , getAdjustedVolume ( ) ) ; } notifyState ( getState ( ) ) ; }
public static String toUTF8String ( String s ) { return new String ( s . getBytes ( ) , Charset . forName ( PanboxConstants . STANDARD_CHARSET ) ) ; }
public static int encodeCacheFlags ( Collection < GridClientCacheFlag > flagSet ) { int bits = NUM_ ; if ( flagSet . contains ( GridClientCacheFlag . SKIP_STORE ) ) bits |= NUM_ ; return bits ; }
public void add ( DataSource source , boolean visible ) { add ( data . size ( ) , source , visible ) ; }
@ Override public void addValue ( double value , double weight ) { m_WeightedSum += value . weight ; m_WeightedSumSquared += value . value . weight ; m_SumOfWeights += weight ; if ( m_TM . get ( value ) == null ) { m_TM . put ( value , weight ) ; } else { m_TM . put ( value , m_TM . get ( value ) + weight ) ; } }
private JPanel buildRow ( final String string , final JCheckBox checkBox ) { final JPanel panel = new JPanel ( new BorderLayout ( ) ) ; panel . add ( new JLabel ( string ) , BorderLayout . WEST ) ; panel . add ( checkBox , BorderLayout . EAST ) ; checkBox . addItemListener ( m_checkBoxListener ) ; return panel ; }
private static synchronized String formatAndParse ( SimpleDateFormat formatDate , SimpleDateFormat parseDate , String text ) { try { Date date = parseDate . parse ( text ) ; String result = formatDate . format ( date ) ; return result ; } catch ( ParseException e ) { logger . warning ( STR_ + text ) ; } return STR_ ; }
public static boolean isChildGroup ( String group ) { return group . indexOf ( GROUP_DELIMITER ) != - NUM_ ; }
private void throwArrayIndexOutOfBoundsException ( int itemIndex ) { throw new ArrayIndexOutOfBoundsException ( STR_ + STR_ + spaceItems . size ( ) + STR_ + itemIndex ) ; }
private LocusInfo createNextUncoveredLocusInfo ( final Locus stopBeforeLocus ) { while ( lastReferenceSequence <= stopBeforeLocus . getSequenceIndex ( ) && lastReferenceSequence <= referenceSequenceMask . getMaxSequenceIndex ( ) ) { if ( lastReferenceSequence == stopBeforeLocus . getSequenceIndex ( ) && lastPosition + NUM_ >= stopBeforeLocus . getPosition ( ) ) { return null ; } final int nextbit = referenceSequenceMask . nextPosition ( lastReferenceSequence , lastPosition ) ; if ( nextbit == - NUM_ ) { if ( lastReferenceSequence == stopBeforeLocus . getSequenceIndex ( ) ) { lastPosition = stopBeforeLocus . getPosition ( ) ; return null ; } lastReferenceSequence ++ ; lastPosition = NUM_ ; } else if ( lastReferenceSequence < stopBeforeLocus . getSequenceIndex ( ) || nextbit < stopBeforeLocus . getPosition ( ) ) { lastPosition = nextbit ; return new LocusInfo ( getReferenceSequence ( lastReferenceSequence ) , lastPosition ) ; } else if ( nextbit >= stopBeforeLocus . getPosition ( ) ) { return null ; } } return null ; }
public void globalConfigChanged ( String serviceName , String version , String groupName , String serviceComponent , int changeType ) { }
public static void launchEmailIntent ( final Activity activity , String addr , String text ) { Log . i ( LOG_TAG , STR_ + activity . getLocalClassName ( ) ) ; Intent emailIntent = new Intent ( Intent . ACTION_SEND ) ; emailIntent . putExtra ( Intent . EXTRA_EMAIL , new String [ ] { addr } ) ; emailIntent . setType ( STR_ ) ; PackageManager emailpackageManager = activity . getPackageManager ( ) ; List < ResolveInfo > emailresolveInfos = emailpackageManager . queryIntentActivities ( emailIntent , NUM_ ) ; if ( emailresolveInfos . size ( ) > NUM_ ) { activity . startActivity ( emailIntent ) ; } }
public int count ( ) { return n ; }
public void add ( int position , T item ) { mData . add ( position , item ) ; notifyItemInserted ( position ) ; }
public void addTranslator ( ClassPool cp , Translator t ) throws NotFoundException , CannotCompileException { source = cp ; translator = t ; t . start ( cp ) ; }
private void onMainContentScrolled ( int currentY , int deltaY ) { if ( deltaY > mActionBarAutoHideSensivity ) { deltaY = mActionBarAutoHideSensivity ; } else if ( deltaY < - mActionBarAutoHideSensivity ) { deltaY = - mActionBarAutoHideSensivity ; } if ( Math . signum ( deltaY ) . Math . signum ( mActionBarAutoHideSignal ) < NUM_ ) { mActionBarAutoHideSignal = deltaY ; } else { mActionBarAutoHideSignal += deltaY ; } boolean shouldShow = currentY < mActionBarAutoHideMinY || ( mActionBarAutoHideSignal <= - mActionBarAutoHideSensivity ) ; autoShowOrHideActionBar ( shouldShow ) ; }
public void writeLEChars ( String s ) throws IOException { int length = s . length ( ) ; for ( int i = NUM_ ; i < length ; i ++ ) { int c = s . charAt ( i ) ; out . write ( c & xFF ) ; out . write ( ( c > > > NUM_ ) & xFF ) ; } written += length . NUM_ ; }
public static String readLine ( ) { String line ; try { line = scanner . nextLine ( ) ; } catch ( NoSuchElementException e ) { line = null ; } return line ; }
@ Deprecated public boolean isValid ( String regex ) { if ( regex == null ) { return BOOL_ ; } Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( getText ( ) ) ; return matcher . matches ( ) ; }
public void writeToFile ( String filename ) { GridUtils . writeSpatialGridTable ( this , filename ) ; }
public void addFooterView ( View v , Object data , boolean isSelectable ) { FixedViewInfo info = new FixedViewInfo ( ) ; info . view = v ; info . data = data ; info . isSelectable = isSelectable ; mFooterViewInfos . add ( info ) ; if ( mAdapter != null && mDataSetObserver != null ) { mDataSetObserver . onChanged ( ) ; } }
public void addCloseHook ( CloseHook hook ) { if ( closeHooks == null ) { closeHooks = new ArrayList < > ( ) ; } closeHooks . add ( hook ) ; }
public void rejectedExecution ( Runnable r , ThreadPoolExecutor e ) { if ( ! e . isShutdown ( ) ) { r . run ( ) ; } }
private void updateRange ( double x , double y ) { mMinX = Math . min ( mMinX , x ) ; mMaxX = Math . max ( mMaxX , x ) ; mMinY = Math . min ( mMinY , y ) ; mMaxY = Math . max ( mMaxY , y ) ; }
public void readConfig ( String filename ) throws FileNotFoundException { if ( filename == null || filename . equals ( STR_ ) ) return ; readConfig ( new FileReader ( filename ) ) ; }
private void applyTradingBonus ( Player player ) { player . incrementTradescore ( ) ; }
public static String slurpURLNoExceptions ( URL u ) { try { return slurpURL ( u ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } }
private static void createCombinedTrace ( final TraceList newTrace , final List < TraceList > traces , final Set < BreakpointAddress > addresses ) { final Set < BreakpointAddress > visitedAddresses = new LinkedHashSet < BreakpointAddress > ( ) ; for ( final TraceList trace : traces ) { for ( final ITraceEvent event : trace ) { final BreakpointAddress address = event . getOffset ( ) ; if ( ! addresses . contains ( address ) ) { continue ; } if ( visitedAddresses . contains ( address ) ) { continue ; } visitedAddresses . add ( address ) ; newTrace . addEvent ( event ) ; } } }
public void interruptAll ( ) { synchronized ( knownActorTasks ) { for ( Future < Void > ft : knownActorTasks ) { ft . cancel ( BOOL_ ) ; } threadGuard . interruptAll ( ) ; } }
@ SuppressWarnings ( STR_ ) public void registerDefaultDeviceTypes ( ) { final HashMap < String , String > devicesList = DefaultPlatform . getDeviceServiceMap ( ) ; for ( HashMap . Entry < String , String > entry : devicesList . entrySet ( ) ) { String key = entry . getKey ( ) ; String value = entry . getValue ( ) ; try { registerDeviceService ( ( Class < DeviceService > ) Class . forName ( key ) , ( Class < DiscoveryProvider > ) Class . forName ( value ) ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } } }
private static void removeDependencySubsets ( String swcLocation , Map < String , Set < String > > dependencyMap , SwcDependencyInfoImpl depInfo ) { Set < String > removeSet = new HashSet < String > ( ) ; SwcExternalScriptInfo externalInfo = depInfo . getSwcExternalScriptInfo ( swcLocation ) ; Map < String , Set < String > > externalsBySwc = new HashMap < String , Set < String > > ( ) ; for ( String swcDependLocation : dependencyMap . get ( swcLocation ) ) { for ( String swcDependLocation2 : dependencyMap . get ( swcLocation ) ) { if ( swcDependLocation . equals ( swcDependLocation2 ) ) continue ; Set < String > externalScripts = externalsBySwc . get ( swcDependLocation ) ; Set < String > externalScripts2 = externalsBySwc . get ( swcDependLocation2 ) ; if ( externalScripts == null ) { externalScripts = externalInfo . getExternalScripts ( swcDependLocation ) ; externalsBySwc . put ( swcDependLocation , externalScripts ) ; } if ( externalScripts2 == null ) { externalScripts2 = externalInfo . getExternalScripts ( swcDependLocation2 ) ; externalsBySwc . put ( swcDependLocation2 , externalScripts2 ) ; } if ( externalScripts2 . size ( ) > externalScripts . size ( ) && externalScripts2 . containsAll ( externalScripts ) ) { removeSet . add ( swcDependLocation ) ; break ; } } } Set < String > dependencySet = dependencyMap . get ( swcLocation ) ; dependencySet . removeAll ( removeSet ) ; }
private void drawTicks ( Canvas canvas , double min , double max , double minAngle , double maxAngle , int centerX , int centerY , double longRadius , double shortRadius , double ticks , Paint paint , boolean labels ) { for ( double i = min ; i <= max ; i += ticks ) { double angle = getAngleForValue ( i , minAngle , maxAngle , min , max ) ; double sinValue = Math . sin ( angle ) ; double cosValue = Math . cos ( angle ) ; int x1 = Math . round ( centerX + ( float ) ( shortRadius . sinValue ) ) ; int y1 = Math . round ( centerY + ( float ) ( shortRadius . cosValue ) ) ; int x2 = Math . round ( centerX + ( float ) ( longRadius . sinValue ) ) ; int y2 = Math . round ( centerY + ( float ) ( longRadius . cosValue ) ) ; canvas . drawLine ( x1 , y1 , x2 , y2 , paint ) ; if ( labels ) { paint . setTextAlign ( Align . LEFT ) ; if ( x1 <= x2 ) { paint . setTextAlign ( Align . RIGHT ) ; } String text = i + STR_ ; if ( Math . round ( i ) == ( long ) i ) { text = ( long ) i + STR_ ; } canvas . drawText ( text , x1 , y1 , paint ) ; } } }
private void updateBaseMatrix ( Drawable d ) { ImageView imageView = getImageView ( ) ; if ( null == imageView || null == d ) { return ; } final float viewWidth = imageView . getWidth ( ) ; final float viewHeight = imageView . getHeight ( ) ; final int drawableWidth = d . getIntrinsicWidth ( ) ; final int drawableHeight = d . getIntrinsicHeight ( ) ; mBaseMatrix . reset ( ) ; final float widthScale = viewWidth / drawableWidth ; final float heightScale = viewHeight / drawableHeight ; if ( mScaleType == ScaleType . CENTER ) { mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth ) / NUM_ , ( viewHeight - drawableHeight ) / NUM_ ) ; } else if ( mScaleType == ScaleType . CENTER_CROP ) { float scale = Math . max ( widthScale , heightScale ) ; mBaseMatrix . postScale ( scale , scale ) ; mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth . scale ) / NUM_ , ( viewHeight - drawableHeight . scale ) / NUM_ ) ; } else if ( mScaleType == ScaleType . CENTER_INSIDE ) { float scale = Math . min ( NUM_ , Math . min ( widthScale , heightScale ) ) ; mBaseMatrix . postScale ( scale , scale ) ; mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth . scale ) / NUM_ , ( viewHeight - drawableHeight . scale ) / NUM_ ) ; } else { RectF mTempSrc = new RectF ( NUM_ , NUM_ , drawableWidth , drawableHeight ) ; RectF mTempDst = new RectF ( NUM_ , NUM_ , viewWidth , viewHeight ) ; switch ( mScaleType ) { case FIT_CENTER : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . CENTER ) ; break ; case FIT_START : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . START ) ; break ; case FIT_END : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . END ) ; break ; case FIT_XY : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . FILL ) ; break ; default : break ; } } resetMatrix ( ) ; }
public static < T , K , L extends List < T > > BiFunction < Partition < T , K , L > , T , Boolean > alwaysInsert ( ) { return null ; }
public void testFindSpringOpenLdap ( ) { LdapProxy proxy = getLdapOpenLdap ( ) ; List result = null ; try { result = proxy . find ( getLdapSearchVO ( STR_ , LdapConstants . NO_SEARCH_LIMIT , null , null , null , LdapScopeConstants . SCOPE_SUBTREE ) ) ; } catch ( Exception e ) { } assertNotNull ( result ) ; assertEquals ( NUM_ , result . size ( ) ) ; }
public void testConstructorStringRadix8 ( ) { String value = STR_ ; int radix = NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( value , radix ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , aNumber . signum ( ) ) ; }
private static boolean inEncoding ( char ch , String encoding ) { boolean isInEncoding ; try { char cArray [ ] = new char [ NUM_ ] ; cArray [ NUM_ ] = ch ; String s = new String ( cArray ) ; byte [ ] bArray = s . getBytes ( encoding ) ; isInEncoding = inEncoding ( ch , bArray ) ; } catch ( Exception e ) { isInEncoding = BOOL_ ; if ( encoding == null ) isInEncoding = BOOL_ ; } return isInEncoding ; }
public void delete ( SSOToken token , String dn ) throws SMSException , SSOException { for ( String entry : subEntries ( token , dn , STR_ , NUM_ , BOOL_ , BOOL_ ) ) { debug . message ( STR_ , entry ) ; delete ( token , getNamingAttribute ( ) + STR_ + entry + STR_ + dn ) ; } for ( String subOrg : searchSubOrgNames ( token , dn , STR_ , NUM_ , BOOL_ , BOOL_ , BOOL_ ) ) { debug . message ( STR_ , subOrg ) ; delete ( token , subOrg ) ; } delete ( token . getPrincipal ( ) , dn ) ; objectChanged ( dn , DELETE ) ; }
private void removeHighlights ( ) { if ( textArea != null ) { RSyntaxTextAreaHighlighter h = ( RSyntaxTextAreaHighlighter ) textArea . getHighlighter ( ) ; for ( int i = NUM_ ; i < tags . size ( ) ; i ++ ) { h . removeMarkOccurrencesHighlight ( tags . get ( i ) ) ; } } tags . clear ( ) ; }
private static < T extends AbstractBlockBase < T > > void enqueueSuccessors ( T block , PriorityQueue < T > worklist , BitSet visitedBlocks ) { for ( T successor : block . getSuccessors ( ) ) { if ( ! visitedBlocks . get ( successor . getId ( ) ) ) { visitedBlocks . set ( successor . getId ( ) ) ; worklist . add ( successor ) ; } } }
protected void addCommonComponent ( XMLComponent component ) { if ( fCommonComponents . contains ( component ) ) { return ; } fCommonComponents . add ( component ) ; addRecognizedParamsAndSetDefaults ( component ) ; }
public void addRole ( String role ) { if ( role != null ) { roles . add ( role ) ; } }
public CModulesCheckBoxPanel ( final CModulesTableModel modulesTableModel ) { super ( new BorderLayout ( ) ) ; final JCheckBox checkBox = new JCheckBox ( STR_ ) ; checkBox . addItemListener ( new InternalCheckboxListener ( ) ) ; add ( checkBox ) ; m_modulesTableModel = modulesTableModel ; }
public QDate ( ) { this ( _gmtTimeZone ) ; }
protected void responseSent ( StreamResponseMessage responseMessage ) { if ( syncProtocol != null ) syncProtocol . responseSent ( responseMessage ) ; }
public final void append ( FastStringBuffer value ) { if ( value == null ) return ; int strlen = value . length ( ) ; if ( NUM_ == strlen ) return ; int copyfrom = NUM_ ; char [ ] chunk = m_array [ m_lastChunk ] ; int available = m_chunkSize - m_firstFree ; while ( strlen > NUM_ ) { if ( available > strlen ) available = strlen ; int sourcechunk = ( copyfrom + value . m_chunkSize - NUM_ ) > > > value . m_chunkBits ; int sourcecolumn = copyfrom & value . m_chunkMask ; int runlength = value . m_chunkSize - sourcecolumn ; if ( runlength > available ) runlength = available ; System . arraycopy ( value . m_array [ sourcechunk ] , sourcecolumn , m_array [ m_lastChunk ] , m_firstFree , runlength ) ; if ( runlength != available ) System . arraycopy ( value . m_array [ sourcechunk + NUM_ ] , NUM_ , m_array [ m_lastChunk ] , m_firstFree + runlength , available - runlength ) ; strlen -= available ; copyfrom += available ; if ( strlen > NUM_ ) { int i = m_array . length ; if ( m_lastChunk + NUM_ == i ) { char [ ] [ ] newarray = new char [ i + NUM_ ] [ ] ; System . arraycopy ( m_array , NUM_ , newarray , NUM_ , i ) ; m_array = newarray ; } chunk = m_array [ ++ m_lastChunk ] ; if ( chunk == null ) { if ( m_lastChunk == NUM_ << m_rebundleBits && m_chunkBits < m_maxChunkBits ) { m_innerFSB = new FastStringBuffer ( this ) ; } chunk = m_array [ m_lastChunk ] = new char [ m_chunkSize ] ; } available = m_chunkSize ; m_firstFree = NUM_ ; } } m_firstFree += available ; }
protected Tuple < BlobStoreIndexShardSnapshots , Integer > buildBlobStoreIndexShardSnapshots ( Map < String , BlobMetaData > blobs ) { int latest = - NUM_ ; for ( String name : blobs . keySet ( ) ) { if ( name . startsWith ( SNAPSHOT_INDEX_PREFIX ) ) { try { int gen = Integer . parseInt ( name . substring ( SNAPSHOT_INDEX_PREFIX . length ( ) ) ) ; if ( gen > latest ) { latest = gen ; } } catch ( NumberFormatException ex ) { logger . warn ( STR_ , name ) ; } } } if ( latest >= NUM_ ) { try { return new Tuple < > ( indexShardSnapshotsFormat . read ( blobContainer , Integer . toString ( latest ) ) , latest ) ; } catch ( IOException e ) { logger . warn ( STR_ , e , SNAPSHOT_INDEX_PREFIX + latest ) ; } } List < SnapshotFiles > snapshots = new ArrayList < > ( ) ; for ( String name : blobs . keySet ( ) ) { try { BlobStoreIndexShardSnapshot snapshot = null ; if ( name . startsWith ( SNAPSHOT_PREFIX ) ) { snapshot = indexShardSnapshotFormat . readBlob ( blobContainer , name ) ; } else if ( name . startsWith ( LEGACY_SNAPSHOT_PREFIX ) ) { snapshot = indexShardSnapshotLegacyFormat . readBlob ( blobContainer , name ) ; } if ( snapshot != null ) { snapshots . add ( new SnapshotFiles ( snapshot . snapshot ( ) , snapshot . indexFiles ( ) ) ) ; } } catch ( IOException e ) { logger . warn ( STR_ , e , name ) ; } } return new Tuple < > ( new BlobStoreIndexShardSnapshots ( snapshots ) , - NUM_ ) ; }
protected MapleQuestRequirement ( MapleQuest quest , ReadBin data ) throws IOException { this . quest = quest ; this . dayByDay = data . readByte ( ) > NUM_ ; this . normalAutoStart = data . readByte ( ) > NUM_ ; this . lvmin = data . readShort ( ) ; this . lvmax = data . readShort ( ) ; this . mbmin = data . readShort ( ) ; this . charismaMin = data . readShort ( ) ; this . charmMin = data . readShort ( ) ; this . craftMin = data . readShort ( ) ; this . insightMin = data . readShort ( ) ; this . senseMin = data . readShort ( ) ; this . willMin = data . readShort ( ) ; this . pop = data . readShort ( ) ; this . pettamenessmin = data . readShort ( ) ; this . subJobFlag = data . readShort ( ) ; this . npc = data . readInt ( ) ; this . interval = data . readInt ( ) ; this . end = data . readString ( ) ; this . startscript = data . readString ( ) ; this . endscript = data . readString ( ) ; short size = data . readShort ( ) ; for ( int i = NUM_ ; i < size ; i ++ ) { int field = data . readInt ( ) ; fieldEnter . add ( field ) ; } size = data . readShort ( ) ; for ( int i = NUM_ ; i < size ; i ++ ) { short job = data . readShort ( ) ; jobs . add ( job ) ; } size = data . readShort ( ) ; for ( int i = NUM_ ; i < size ; i ++ ) { int id = data . readInt ( ) ; boolean acquire = data . readByte ( ) > NUM_ ; skills . put ( id , acquire ) ; } size = data . readShort ( ) ; for ( int i = NUM_ ; i < size ; i ++ ) { int id = data . readInt ( ) ; byte state = data . readByte ( ) ; byte order = data . readByte ( ) ; quests . put ( id , state ) ; } size = data . readShort ( ) ; for ( int i = NUM_ ; i < size ; i ++ ) { int id = data . readInt ( ) ; int count = data . readInt ( ) ; byte order = data . readByte ( ) ; items . put ( id , count ) ; } size = data . readShort ( ) ; for ( int i = NUM_ ; i < size ; i ++ ) { int id = data . readInt ( ) ; int count = data . readInt ( ) ; mobs . put ( id , count ) ; } size = data . readShort ( ) ; for ( int i = NUM_ ; i < size ; i ++ ) { int id = data . readInt ( ) ; pets . add ( id ) ; } }
public ForumPostConfig createReply ( ForumPostConfig config ) { config . addCredentials ( this ) ; String xml = POST ( this . url + STR_ , config . toXML ( ) ) ; Element root = parse ( xml ) ; if ( root == null ) { return null ; } try { ForumPostConfig reply = new ForumPostConfig ( ) ; reply . parseXML ( root ) ; return reply ; } catch ( Exception exception ) { this . exception = SDKException . parseFailure ( exception ) ; throw this . exception ; } }
public boolean isArmed ( ) { return other . isArmed ( ) ; }
public static AttribKey forHtmlAttrib ( ElKey el , String localName ) { return new AttribKey ( el , HTML_NS , localName ) ; }
SparseArray ( Class < L > linearArrayType , int [ ] rowIndices , int [ ] colIndices , L realValues , L imagValues , int numRows , int numCols ) { validateUserSuppliedParameters ( linearArrayType , rowIndices , colIndices , realValues , imagValues ) ; _baseComponentType = linearArrayType . getComponentType ( ) ; _outputArrayType = ( Class < L [ ] > ) ArrayUtils . getArrayClass ( _baseComponentType , NUM_ ) ; Map < SparseKey , SparseValue > sparseMap = createSparseMap ( linearArrayType , rowIndices , colIndices , realValues , imagValues , numRows , numCols ) ; _numRows = numRows ; _numCols = numCols ; ArrayList < SparseKey > keys = new ArrayList < SparseKey > ( sparseMap . keySet ( ) ) ; Collections . sort ( keys ) ; _rowIndices = new int [ keys . size ( ) ] ; _colIndices = new int [ keys . size ( ) ] ; _linearIndices = new int [ keys . size ( ) ] ; _realValues = linearArrayType . cast ( Array . newInstance ( _baseComponentType , keys . size ( ) ) ) ; _imagValues = imagValues == null ? null : linearArrayType . cast ( Array . newInstance ( _baseComponentType , keys . size ( ) ) ) ; for ( int i = NUM_ ; i < keys . size ( ) ; i ++ ) { SparseKey key = keys . get ( i ) ; _rowIndices [ i ] = key . row ; _colIndices [ i ] = key . col ; _linearIndices [ i ] = key . linearIndex ; SparseValue value = sparseMap . get ( key ) ; setSparseValue ( value , _realValues , _imagValues , i ) ; } }
public static Tuple max ( TupleSet tuples , String field , Comparator cmp ) { if ( tuples instanceof Table ) { Table table = ( Table ) tuples ; ColumnMetadata md = table . getMetadata ( field ) ; return table . getTuple ( md . getMaximumRow ( ) ) ; } else { return max ( tuples . tuples ( ) , field , cmp ) ; } }
protected void updateRadioLinks ( ) { m_CVBut . setEnabled ( BOOL_ ) ; m_CVText . setEnabled ( m_CVBut . isSelected ( ) ) ; m_CVLab . setEnabled ( m_CVBut . isSelected ( ) ) ; m_SeedText . setEnabled ( m_CVBut . isSelected ( ) ) ; m_SeedLab . setEnabled ( m_CVBut . isSelected ( ) ) ; if ( m_AttributeEvaluatorEditor . getValue ( ) instanceof AttributeTransformer ) { m_CVBut . setSelected ( BOOL_ ) ; m_CVBut . setEnabled ( BOOL_ ) ; m_CVText . setEnabled ( BOOL_ ) ; m_CVLab . setEnabled ( BOOL_ ) ; m_SeedText . setEnabled ( BOOL_ ) ; m_SeedLab . setEnabled ( BOOL_ ) ; m_TrainBut . setSelected ( BOOL_ ) ; } }
private String idString ( int id1 , int id2 ) { return STR_ + Integer . toHexString ( id2 & x7F ) + STR_ + Integer . toHexString ( id1 & x7F ) + STR_ + ( ( id2 & x7F ) . NUM_ + ( id1 & x7F ) ) + STR_ ; }
public EtagCache resetStats ( ) { hits . set ( NUM_ ) ; misses . set ( NUM_ ) ; return this ; }
public void testOtherToStringDefault ( ) { NumberConverter converter = makeConverter ( ) ; assertEquals ( STR_ , STR_ , converter . convert ( String . class , new StringBuffer ( STR_ ) ) ) ; }
private void removeItemAtInt ( int index , boolean updateChildrenOnMenuViews ) { if ( ( index < NUM_ ) || ( index >= mItems . size ( ) ) ) return ; mItems . remove ( index ) ; if ( updateChildrenOnMenuViews ) onItemsChanged ( BOOL_ ) ; }
public void testShiftRight3 ( ) { byte aBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int number = NUM_ ; byte rBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , - NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger result = aNumber . shiftRight ( number ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
private void showFilterDialog ( Filter filter ) { int sortOrder = mAdapter . getCount ( ) - NUM_ ; if ( filter == null ) { EditFilterActivity . createNewFilter ( getActivity ( ) , sortOrder ) ; } else { EditFilterActivity . editFilter ( getActivity ( ) , filter , sortOrder ) ; } }
public static int numPixelsBetween ( int x1 , int y1 , int x2 , int y2 ) { return ( int ) Math . sqrt ( Math . pow ( ( double ) ( x1 - x2 ) , NUM_ ) + Math . pow ( ( double ) ( y1 - y2 ) , NUM_ ) ) ; }
private KeyStore createKeys ( KeyStore keyStore , String keyAlgorithm , String publicAlias , String privateAlias , PrivateKeyEntry signer ) throws Exception { PrivateKey caKey ; X509Certificate caCert ; X509Certificate [ ] caCertChain ; if ( signer == null ) { caKey = null ; caCert = null ; caCertChain = null ; } else { caKey = signer . getPrivateKey ( ) ; caCert = ( X509Certificate ) signer . getCertificate ( ) ; caCertChain = ( X509Certificate [ ] ) signer . getCertificateChain ( ) ; } PrivateKey privateKey ; X509Certificate x509c ; if ( publicAlias == null && privateAlias == null ) { privateKey = null ; x509c = null ; } else { int keySize ; if ( keyAlgorithm . equals ( STR_ ) ) { keySize = NUM_ ; } else if ( keyAlgorithm . equals ( STR_ ) ) { keySize = NUM_ ; } else if ( keyAlgorithm . equals ( STR_ ) ) { keySize = NUM_ ; } else if ( keyAlgorithm . equals ( STR_ ) ) { keySize = NUM_ ; keyAlgorithm = STR_ ; } else { throw new IllegalArgumentException ( STR_ + keyAlgorithm ) ; } KeyPairGenerator kpg = KeyPairGenerator . getInstance ( keyAlgorithm ) ; kpg . initialize ( keySize , new SecureRandom ( ) ) ; KeyPair kp = kpg . generateKeyPair ( ) ; privateKey = kp . getPrivate ( ) ; PublicKey publicKey = kp . getPublic ( ) ; X500Principal issuer = ( ( caCert != null ) ? caCert . getSubjectX500Principal ( ) : subject ) ; PrivateKey signingKey = ( caKey == null ) ? privateKey : caKey ; x509c = createCertificate ( publicKey , signingKey , subject , issuer , keyUsage , ca , extendedKeyUsages , criticalExtendedKeyUsages , subjectAltNames , permittedNameConstraints , excludedNameConstraints ) ; } X509Certificate [ ] x509cc ; if ( privateAlias == null ) { x509cc = null ; } else if ( caCertChain == null ) { x509cc = new X509Certificate [ ] { x509c } ; } else { x509cc = new X509Certificate [ caCertChain . length + NUM_ ] ; x509cc [ NUM_ ] = x509c ; System . arraycopy ( caCertChain , NUM_ , x509cc , NUM_ , caCertChain . length ) ; } if ( privateAlias != null ) { keyStore . setKeyEntry ( privateAlias , privateKey , keyPassword , x509cc ) ; } if ( publicAlias != null ) { keyStore . setCertificateEntry ( publicAlias , x509c ) ; } return keyStore ; }
static boolean allowsPopup ( FormObject formObject ) { switch ( formObject . getParameterConstant ( PdfDictionary . Subtype ) ) { case PdfDictionary . Text : case PdfDictionary . Square : case PdfDictionary . Highlight : case PdfDictionary . Underline : case PdfDictionary . StrickOut : case PdfDictionary . Stamp : return BOOL_ ; default : return BOOL_ ; } }
public static LocalGitRepo fromCurrentDir ( String remoteUrl ) throws ValidationException { Git git ; File gitDir = new File ( STR_ ) ; try { git = Git . open ( gitDir ) ; } catch ( RepositoryNotFoundException rnfe ) { String fullPathOfCurrentDir = pathOf ( gitDir ) ; File gitRoot = getGitRootIfItExistsInOneOfTheParentDirectories ( new File ( fullPathOfCurrentDir ) ) ; String summary ; List < String > messages = new ArrayList < String > ( ) ; if ( gitRoot == null ) { summary = STR_ ; messages . add ( summary ) ; messages . add ( fullPathOfCurrentDir + STR_ ) ; } else { summary = STR_ ; messages . add ( summary ) ; messages . add ( fullPathOfCurrentDir + STR_ ) ; messages . add ( STR_ + pathOf ( gitRoot ) ) ; } throw new ValidationException ( summary , messages ) ; } catch ( Exception e ) { throw new ValidationException ( STR_ + pathOf ( gitDir ) + STR_ , Arrays . asList ( STR_ , e . toString ( ) ) ) ; } return new LocalGitRepo ( git , remoteUrl ) ; }
public static Vector2 min ( Vector2 o1 , Vector2 o2 ) { return new Vector2 ( Math . min ( o1 . x , o2 . x ) , Math . min ( o1 . z , o2 . z ) ) ; }
public void addTestCall ( GenericAccessibleObject < ? > call ) throws IllegalArgumentException { Inputs . checkNull ( call ) ; testMethods . add ( call ) ; }
public void serialize ( KXmlSerializer serializer ) throws IOException { mDeviceInfo . serialize ( serializer ) ; serializeHostInfo ( serializer ) ; serializeTestSummary ( serializer ) ; monkeyTag . serialize ( serializer ) ; List < TestPackageResult > pkgs = new ArrayList < TestPackageResult > ( mPackageMap . values ( ) ) ; Collections . sort ( pkgs , new PkgComparator ( ) ) ; for ( TestPackageResult r : pkgs ) { r . serialize ( serializer ) ; } }
private void verifyBlockMirrorMigration ( ) throws Exception { log . info ( STR_ ) ; Iterator < BlockMirror > blockMirrorItr = _dbClient . queryIterativeObjects ( BlockMirror . class , blockMirrorURIs ) ; List < BlockObject > blockObjects = new ArrayList < BlockObject > ( ) ; while ( blockMirrorItr . hasNext ( ) ) { blockObjects . add ( blockMirrorItr . next ( ) ) ; } verifyBlockObjects ( blockObjects ) ; }
public LogFormatter ( Logger log ) { if ( log == null ) log = Logger . getLogger ( Logger . GLOBAL_LOGGER_NAME ) ; Level lvl = null ; while ( log != null ) { lvl = log . getLevel ( ) ; if ( lvl != null ) break ; log = log . getParent ( ) ; } ; if ( lvl == null ) lvl = Level . WARNING ; this . level = lvl ; }
public synchronized void removeTextListener ( TextListener cl ) { m_textListeners . remove ( cl ) ; }
protected final void refreshLoadingViewsSize ( ) { final int maximumPullScroll = ( int ) ( getMaximumPullScroll ( ) . NUM_ ) ; int pLeft = getPaddingLeft ( ) ; int pTop = getPaddingTop ( ) ; int pRight = getPaddingRight ( ) ; int pBottom = getPaddingBottom ( ) ; switch ( getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setWidth ( maximumPullScroll ) ; pLeft = - maximumPullScroll ; } else { pLeft = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setWidth ( maximumPullScroll ) ; pRight = - maximumPullScroll ; } else { pRight = NUM_ ; } break ; case VERTICAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setHeight ( maximumPullScroll ) ; pTop = - maximumPullScroll ; } else { pTop = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setHeight ( maximumPullScroll ) ; pBottom = - maximumPullScroll ; } else { pBottom = NUM_ ; } break ; } if ( DEBUG ) { Log . d ( LOG_TAG , String . format ( STR_ , pLeft , pTop , pRight , pBottom ) ) ; } setPadding ( pLeft , pTop , pRight , pBottom ) ; }
private Element createIDPEntityDescriptor ( boolean exportPrivateData ) throws Exception { Element entEle = doc . createElementNS ( null , SAMLNames . ENTDESCRIPTOR ) ; String id = idmClient . getEntityID ( tenantName ) ; String alias = idmClient . getLocalIDPAlias ( tenantName ) ; if ( id == null ) { id = tenantName ; } entEle . setAttribute ( SAMLNames . ENTID , id ) ; Element idpSSO = createIDPSSODescriptor ( exportPrivateData ) ; entEle . appendChild ( idpSSO ) ; if ( exportPrivateData ) { if ( alias == null || alias . isEmpty ( ) ) { alias = id ; } Element orgEle = createOrganization ( tenantName , tenantName , alias , SAMLNames . ENGLISH ) ; entEle . appendChild ( orgEle ) ; } return entEle ; }
public void clear ( ) { infoQueue . clear ( ) ; while ( ! dataQueue . isEmpty ( ) ) { allocator . release ( dataQueue . remove ( ) ) ; } totalBytesDropped = NUM_ ; totalBytesWritten = NUM_ ; lastAllocation = null ; lastAllocationOffset = allocationLength ; }
public void applyCamera ( GL2 gl ) { gl . glMatrixMode ( GL2 . GL_PROJECTION ) ; gl . glLoadIdentity ( ) ; glu . gluPerspective ( NUM_ , width / ( float ) height , NUM_ , NUM_ ) ; eye [ NUM_ ] = ( float ) Math . sin ( theta ) . NUM_ ; eye [ NUM_ ] = NUM_ ; eye [ NUM_ ] = ( float ) Math . cos ( theta ) . NUM_ ; glu . gluLookAt ( eye [ NUM_ ] , eye [ NUM_ ] , eye [ NUM_ ] , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ ) ; gl . glMatrixMode ( GL2 . GL_MODELVIEW ) ; gl . glLoadIdentity ( ) ; gl . glViewport ( NUM_ , NUM_ , width , height ) ; }
public static ResultSet pointTable ( double x , double y ) { GeometryFactory factory = new GeometryFactory ( ) ; SimpleResultSet rs = new SimpleResultSet ( ) ; rs . addColumn ( STR_ , Types . JAVA_OBJECT , STR_ , NUM_ , NUM_ ) ; rs . addRow ( factory . createPoint ( new Coordinate ( x , y ) ) ) ; return rs ; }
public void addToExistingVolumesIfAbsent ( Map < String , Integer > volumeWWNs ) { if ( _existingVolumes == null ) { _existingVolumes = new StringMap ( ) ; } for ( String wwn : volumeWWNs . keySet ( ) ) { String normalizedWWN = BlockObject . normalizeWWN ( wwn ) ; if ( ! _existingVolumes . containsKey ( normalizedWWN ) && ( _userAddedVolumes == null || ! _userAddedVolumes . containsKey ( normalizedWWN ) ) ) { String hluStr = ExportGroup . LUN_UNASSIGNED_STR ; Integer hlu = volumeWWNs . get ( normalizedWWN ) ; if ( hlu != null ) { hluStr = hlu . toString ( ) ; } _existingVolumes . put ( normalizedWWN , hluStr ) ; } } }
public PathImpl createTempFile ( String prefix , String suffix ) throws IOException { if ( prefix == null || prefix . length ( ) == NUM_ ) prefix = STR_ ; if ( suffix == null ) suffix = STR_ ; synchronized ( LOCK ) { for ( int i = NUM_ ; i < NUM_ ; i ++ ) { int r = Math . abs ( ( int ) RandomUtil . getRandomLong ( ) ) ; PathImpl file = lookup ( prefix + r + suffix ) ; if ( file . createNewFile ( ) ) return file ; } } throw new IOException ( STR_ ) ; }
static Map < TargetType , List < TypeCompound > > partitionByTargetType ( Collection < TypeCompound > annos , List < TypeCompound > unmatched , TargetType ... targetTypes ) { final Map < TargetType , List < TypeCompound > > targetTypeToAnnos = new HashMap < > ( ) ; for ( TargetType targetType : targetTypes ) { targetTypeToAnnos . put ( targetType , new ArrayList < TypeCompound > ( NUM_ ) ) ; } for ( final TypeCompound anno : annos ) { final List < TypeCompound > annoSet = targetTypeToAnnos . get ( anno . getPosition ( ) . type ) ; if ( annoSet != null ) { annoSet . add ( anno ) ; } else if ( unmatched != null ) { unmatched . add ( anno ) ; } } return targetTypeToAnnos ; }
ConfigurationError ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; }
public void load ( ) { try { if ( fileChannel == null ) { fileChannel = FileChannel . open ( path , StandardOpenOption . READ ) ; } fileChannel . position ( NUM_ ) ; buffer . clear ( ) ; tmp . clear ( ) ; while ( fileChannel . read ( tmp ) > NUM_ ) { tmp . flip ( ) ; if ( tmp . remaining ( ) > buffer . capacity ( ) - buffer . position ( ) ) { final ByteBuffer next = ByteBuffer . allocateDirect ( Math . max ( buffer . capacity ( ) . NUM_ , tmp . remaining ( ) ) ) ; buffer . flip ( ) ; next . put ( buffer ) ; buffer = next ; } buffer . put ( tmp ) ; tmp . clear ( ) ; } buffer . flip ( ) ; } catch ( final IOException e ) { throw new UncheckedIOException ( e ) ; } }
private void onHPChange ( final int amount ) { if ( User . squaredDistanceTo ( x , y ) < HEARING_DISTANCE_SQ ) { if ( amount > NUM_ ) { addTextIndicator ( STR_ + amount , NotificationType . POSITIVE ) ; } else { addTextIndicator ( String . valueOf ( amount ) , NotificationType . NEGATIVE ) ; } } }
@ NotNull private File resolveName ( @ NotNull String name ) throws IOException { File file ; if ( name . startsWith ( ROOT ) ) { file = new File ( myTemplateRootFolder , name . substring ( ROOT . length ( ) ) ) ; } else if ( myLastTemplateFolders != null ) { file = new File ( myLastTemplateFolders . peek ( ) , name ) ; } else { file = new File ( myTemplateRootFolder , name ) ; } return file . getCanonicalFile ( ) ; }
public void initToolTip ( ) { if ( ttmanager == null ) { ttmanager = ToolTipManager . sharedInstance ( ) ; ttmanager . registerComponent ( map ) ; ttmanager . setEnabled ( BOOL_ ) ; return ; } if ( map != null ) { map . setToolTipText ( null ) ; } }
public static String [ ] decodeArray ( String encodedArray ) { String [ ] items = encodedArray . split ( STR_ ) ; ArrayList < String > list = new ArrayList < String > ( ) ; for ( int i = NUM_ ; i < items . length ; i ++ ) { String item = items [ i ] ; item = gsub ( STR_ , STR_ , item ) ; if ( ! item . equals ( STR_ ) ) { list . add ( item ) ; } } return list . toArray ( new String [ list . size ( ) ] ) ; }
public boolean computeAngleOffset ( ) { if ( mFinished ) { return BOOL_ ; } long systemClock = AnimationUtils . currentAnimationTimeMillis ( ) ; long timePassed = systemClock - mStartTime ; if ( timePassed < mDuration ) { switch ( mMode ) { case SCROLL_MODE : float sc = ( float ) timePassed / mDuration ; mCurrAngle = mStartAngle + Math . round ( mDeltaAngle . sc ) ; break ; case FLING_MODE : float timePassedSeconds = timePassed / NUM_ ; float distance ; if ( mVelocity < NUM_ ) { distance = mCoeffVelocity . mVelocity . timePassedSeconds - ( mDeceleration . timePassedSeconds . timePassedSeconds / NUM_ ) ; } else { distance = - mCoeffVelocity . mVelocity . timePassedSeconds - ( mDeceleration . timePassedSeconds . timePassedSeconds / NUM_ ) ; } mCurrAngle = mStartAngle - Math . signum ( mVelocity ) . Math . round ( distance ) ; break ; } return BOOL_ ; } else { mFinished = BOOL_ ; return BOOL_ ; } }
private void sendResource ( final UUID uuid , final Object resource , final long length , final InputStream is ) throws IOException { assert uuid != null ; assert resource != null ; assert length >= NUM_ ; assert is != null ; assert ! sentStatus ; long bytesWritten = NUM_ ; final long begin = System . nanoTime ( ) ; final OutputStream os = s . getOutputStream ( ) ; try { { final DataOutputStream dos = new DataOutputStream ( os ) ; dos . write ( new byte [ ] { StatusEnum . OK . get ( ) } ) ; dos . writeLong ( length ) ; dos . flush ( ) ; bytesWritten += NUM_ + Bytes . SIZEOF_LONG ; sentStatus = BOOL_ ; } final long checksum ; { final int BUFSIZE = Bytes . kilobyte32 . NUM_ ; final CheckedInputStream cis = new CheckedInputStream ( new BufferedInputStream ( is ) , new Adler32 ( ) ) ; final byte [ ] buff = new byte [ BUFSIZE ] ; while ( BOOL_ ) { final int read = cis . read ( buff , NUM_ , BUFSIZE ) ; if ( read <= NUM_ ) break ; os . write ( buff , NUM_ , read ) ; bytesWritten += read ; } checksum = cis . getChecksum ( ) . getValue ( ) ; } { final DataOutputStream dos = new DataOutputStream ( os ) ; dos . writeLong ( checksum ) ; bytesWritten += Bytes . SIZEOF_LONG ; dos . flush ( ) ; } os . flush ( ) ; if ( log . isInfoEnabled ( ) ) log . info ( STR_ + uuid + STR_ + resource + STR_ + length + STR_ + checksum + STR_ + TimeUnit . NANOSECONDS . toMillis ( System . nanoTime ( ) - begin ) + STR_ ) ; } finally { try { os . close ( ) ; } catch ( Throwable t ) { } counters . bytesWritten . add ( bytesWritten ) ; counters . elapsedWriteNanos . add ( System . nanoTime ( ) - begin ) ; synchronized ( counters . maxWriteSizeLock ) { counters . maxWriteSize = Math . max ( counters . maxWriteSize , bytesWritten ) ; } } }
public long sigignore ( ) { return Long . parseLong ( fields [ NUM_ ] ) ; }
private static byte [ ] generateSeed ( ) { try { final ByteArrayOutputStream seedBuffer = new ByteArrayOutputStream ( ) ; final DataOutputStream seedBufferOut = new DataOutputStream ( seedBuffer ) ; seedBufferOut . writeLong ( System . currentTimeMillis ( ) ) ; seedBufferOut . writeLong ( System . nanoTime ( ) ) ; seedBufferOut . writeInt ( Process . myPid ( ) ) ; seedBufferOut . writeInt ( Process . myUid ( ) ) ; seedBufferOut . write ( BUILD_FINGERPRINT_AND_DEVICE_SERIAL ) ; seedBufferOut . close ( ) ; return seedBuffer . toByteArray ( ) ; } catch ( final IOException e ) { throw new SecurityException ( STR_ , e ) ; } }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
public String render ( ValueExpr theExpr ) throws Exception { theExpr . visit ( this ) ; return mBuffer . toString ( ) ; }
public void stopSampling ( ) { if ( mSamplingCounter . decrementAndGet ( ) == NUM_ ) { mHandler . stopSamplingThread ( ) ; addFinalSample ( ) ; } }
public static final void reverseWinding ( List < Vector2 > points ) { if ( points == null ) throw new NullPointerException ( Messages . getString ( STR_ ) ) ; int size = points . size ( ) ; if ( size == NUM_ || size == NUM_ ) return ; Collections . reverse ( points ) ; }
public DSignCsr ( JFrame parent , PKCS10CertificationRequest pkcs10Csr , File csrFile , PrivateKey signPrivateKey , KeyPairType signKeyPairType , X509Certificate verificationCertificate , Provider provider ) throws CryptoException { super ( parent , Dialog . ModalityType . DOCUMENT_MODAL ) ; this . pkcs10Csr = pkcs10Csr ; this . csrFile = csrFile ; this . signPrivateKey = signPrivateKey ; this . signKeyPairType = signKeyPairType ; this . verificationCertificate = verificationCertificate ; this . provider = provider ; setTitle ( res . getString ( STR_ ) ) ; initComponents ( ) ; }
protected static void init ( ) { String notificationfactoryClassName = null ; try { notificationfactoryClassName = System . getProperty ( NOTIFICATION_FACTORY_NAME ) ; } catch ( SecurityException e ) { throw new RuntimeException ( e ) ; } if ( notificationfactoryClassName != null ) { Class < ? > nfc ; try { nfc = Class . forName ( notificationfactoryClassName ) ; factory = ( INotificationManagerFactory ) nfc . newInstance ( ) ; } catch ( ClassNotFoundException | InstantiationException | IllegalAccessException e ) { throw new RuntimeException ( e ) ; } } else { factory = new SyslogNotificationFactory ( ) ; } }
private int awaitDone ( boolean timed , long nanos ) throws InterruptedException { final long deadline = timed ? System . nanoTime ( ) + nanos : NUM_ ; WaitNode q = null ; boolean queued = BOOL_ ; for ( ; ; ) { if ( Thread . interrupted ( ) ) { removeWaiter ( q ) ; throw new InterruptedException ( ) ; } int s = state ; if ( s > COMPLETING ) { if ( q != null ) q . thread = null ; return s ; } else if ( s == COMPLETING ) Thread . yield ( ) ; else if ( q == null ) q = new WaitNode ( ) ; else if ( ! queued ) queued = UNSAFE . compareAndSwapObject ( this , waitersOffset , q . next = waiters , q ) ; else if ( timed ) { nanos = deadline - System . nanoTime ( ) ; if ( nanos <= NUM_ ) { removeWaiter ( q ) ; return state ; } LockSupport . parkNanos ( this , nanos ) ; } else LockSupport . park ( this ) ; } }
private boolean linkFirst ( Node < E > node ) { if ( count >= capacity ) return BOOL_ ; Node < E > f = first ; node . next = f ; first = node ; if ( last == null ) last = node ; else f . prev = node ; ++ count ; notEmpty . signal ( ) ; return BOOL_ ; }
public static double clamp ( double value , double low , double high ) { return Math . min ( Math . max ( value , low ) , high ) ; }
public static String parseVolumeHostDirectory ( String volume ) { if ( StringUtils . isEmpty ( volume ) ) { return volume ; } if ( ! volume . contains ( HOST_CONTAINER_DIR_DELIMITER ) ) { return volume ; } String [ ] hostContainerDir = volume . split ( HOST_CONTAINER_DIR_DELIMITER ) ; if ( hostContainerDir . length != NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } String hostDir = hostContainerDir [ NUM_ ] ; return hostDir ; }
private String fmtTime ( double time ) { return Utilities . pad ( timeFormatter . format ( time ) + STR_ , NUM_ ) ; }
@ Override public synchronized Object [ ] toArray ( ) { Object [ ] result = new Object [ elementCount ] ; System . arraycopy ( elementData , NUM_ , result , NUM_ , elementCount ) ; return result ; }
public static String right ( String s , int width , char fillChar ) { if ( s . length ( ) >= width ) { return s ; } StringBuffer sb = new StringBuffer ( width ) ; for ( int i = width - s . length ( ) ; -- i >= NUM_ ; ) { sb . append ( fillChar ) ; } sb . append ( s ) ; return sb . toString ( ) ; }
public synchronized boolean addAll ( Collection < ? extends E > c ) { modCount ++ ; Object [ ] a = c . toArray ( ) ; int numNew = a . length ; ensureCapacityHelper ( elementCount + numNew ) ; System . arraycopy ( a , NUM_ , elementData , elementCount , numNew ) ; elementCount += numNew ; return numNew != NUM_ ; }
@ Override public void update ( DefaultApplicationState transState ) { newCheckpoint ( transState . getState ( ) , transState . getStateHash ( ) , transState . getLastCheckpointCID ( ) ) ; setLastCheckpointCID ( transState . getLastCheckpointCID ( ) ) ; }
public static byte [ ] stringToUtf8Bytes ( String string ) { int len = string . length ( ) ; byte [ ] bytes = new byte [ len . NUM_ ] ; int outAt = NUM_ ; for ( int i = NUM_ ; i < len ; i ++ ) { char c = string . charAt ( i ) ; if ( ( c != NUM_ ) && ( c < x80 ) ) { bytes [ outAt ] = ( byte ) c ; outAt ++ ; } else if ( c < x800 ) { bytes [ outAt ] = ( byte ) ( ( ( c > > NUM_ ) & x1f ) | xc0 ) ; bytes [ outAt + NUM_ ] = ( byte ) ( ( c & x3f ) | x80 ) ; outAt += NUM_ ; } else { bytes [ outAt ] = ( byte ) ( ( ( c > > NUM_ ) & x0f ) | xe0 ) ; bytes [ outAt + NUM_ ] = ( byte ) ( ( ( c > > NUM_ ) & x3f ) | x80 ) ; bytes [ outAt + NUM_ ] = ( byte ) ( ( c & x3f ) | x80 ) ; outAt += NUM_ ; } } byte [ ] result = new byte [ outAt ] ; System . arraycopy ( bytes , NUM_ , result , NUM_ , outAt ) ; return result ; }
private List < Pair < String , Object > > toPairList ( final Map < String , Object > bindings ) { final List < Pair < String , Object > > blist = new ArrayList < Pair < String , Object > > ( ) ; for ( final Map . Entry < String , Object > pair : bindings . entrySet ( ) ) { blist . add ( new Pair < String , Object > ( pair . getKey ( ) , pair . getValue ( ) ) ) ; } return blist ; }
@ Override public boolean validateLabel ( String label ) { Objects . requireNonNull ( label , STR_ ) ; return ! labels . contains ( label ) ; }
public void addMessageObserver ( final MessageObserver observer ) { if ( observer == null ) { throw new NullPointerException ( ) ; } else if ( messageObservers == null ) { initMessageObserverList ( ) ; } messageObservers . add ( observer ) ; }
public void show ( char initialChar ) { initialString = initialString . append ( initialChar ) ; show ( ) ; if ( SWT . getPlatform ( ) != STR_ ) { setEditText ( initialString . toString ( ) ) ; } }
private static void byte2hex ( byte b , StringBuffer buf ) { int high = ( ( b & xf0 ) > > NUM_ ) ; int low = ( b & x0f ) ; buf . append ( HEX_DIGITS [ high ] ) ; buf . append ( HEX_DIGITS [ low ] ) ; }
public E remove ( int index ) { hashCodeUpToDate = BOOL_ ; modCount ++ ; E oldValue = elementData ( index ) ; int numMoved = size - index - NUM_ ; if ( numMoved > NUM_ ) System . arraycopy ( elementData , index + NUM_ , elementData , index , numMoved ) ; elementData [ -- size ] = null ; return oldValue ; }
public static DoubleVector rnorm ( int n , double mean , double sd , Random random ) { if ( sd < NUM_ ) throw new IllegalArgumentException ( STR_ ) ; if ( sd == NUM_ ) return new DoubleVector ( n , mean ) ; DoubleVector v = new DoubleVector ( n ) ; for ( int i = NUM_ ; i < n ; i ++ ) v . set ( i , ( random . nextGaussian ( ) + mean ) / sd ) ; return v ; }
private PdfObject readCompressedStream ( PdfObject rootObj , int pointer , final PdfFileReader currentPdfFile , final ObjectReader objectReader , final PdfObject linearObj ) throws PdfException { while ( pointer != - NUM_ ) { movePointer ( pointer ) ; final byte [ ] raw = objectReader . readObjectData ( - NUM_ , null ) ; final StringBuilder objectName = new StringBuilder ( ) ; char current1 , last = STR_ ; int matched = NUM_ , i1 = NUM_ ; while ( i1 < raw . length ) { current1 = ( char ) raw [ i1 ] ; if ( current1 == NUM_ || current1 == NUM_ ) { current1 = STR_ ; } if ( current1 == STR_ && last == STR_ ) { matched = NUM_ ; } else if ( current1 == pattern . charAt ( matched ) ) { matched ++ ; } else { matched = NUM_ ; objectName . append ( current1 ) ; } if ( matched == NUM_ ) { break ; } last = current1 ; i1 ++ ; } objectName . append ( STR_ ) ; final PdfObject pdfObject = new CompressedObject ( objectName . toString ( ) ) ; pdfObject . setCompressedStream ( BOOL_ ) ; final ObjectDecoder objectDecoder = new ObjectDecoder ( currentPdfFile ) ; objectDecoder . readDictionaryAsObject ( pdfObject , NUM_ , raw ) ; final int [ ] fieldSizes = pdfObject . getIntArray ( PdfDictionary . W ) ; byte [ ] xrefs = pdfObject . getDecodedStream ( ) ; if ( xrefs == null ) { xrefs = currentPdfFile . readStream ( pdfObject , BOOL_ , BOOL_ , BOOL_ , BOOL_ , BOOL_ , null ) ; } final int [ ] Index = pdfObject . getIntArray ( PdfDictionary . Index ) ; if ( Index == null ) { CompressedObjects . readCompressedOffsets ( NUM_ , NUM_ , pdfObject . getInt ( PdfDictionary . Size ) , fieldSizes , xrefs , offset , pdf_datafile ) ; } else { final int count = Index . length ; int pntr = NUM_ ; for ( int aa = NUM_ ; aa < count ; aa += NUM_ ) { pntr = CompressedObjects . readCompressedOffsets ( pntr , Index [ aa ] , Index [ aa + NUM_ ] , fieldSizes , xrefs , offset , pdf_datafile ) ; } } if ( rootObj == null ) { rootObj = pdfObject . getDictionary ( PdfDictionary . Root ) ; encryptObj = pdfObject . getDictionary ( PdfDictionary . Encrypt ) ; if ( encryptObj != null ) { final byte [ ] [ ] IDs = pdfObject . getStringArray ( PdfDictionary . ID ) ; if ( IDs != null && this . ID == null ) { this . ID = IDs [ NUM_ ] ; } } infoObject = pdfObject . getDictionary ( PdfDictionary . Info ) ; } if ( linearObj != null ) { pointer = - NUM_ ; } else { pointer = pdfObject . getInt ( PdfDictionary . Prev ) ; if ( pointer != - NUM_ && ! isCompressedStream ( pointer , ( int ) eof ) ) { return readLegacyReferenceTable ( rootObj , pointer , ( int ) eof , currentPdfFile ) ; } } } return rootObj ; }
protected void warningOccurred ( int code ) { cbLock . lock ( ) ; try { if ( ( code < NUM_ ) || ( code > MAX_WARNING ) ) { throw new InternalError ( STR_ ) ; } processWarningOccurred ( STR_ , Integer . toString ( code ) ) ; } finally { cbLock . unlock ( ) ; } }
public boolean isKnownSub ( String subName ) { return KNOWN_SUBS . contains ( subName ) ; }
public String diff_text1 ( LinkedList < Diff > diffs ) { StringBuilder text = new StringBuilder ( ) ; for ( Diff aDiff : diffs ) { if ( aDiff . operation != Operation . INSERT ) { text . append ( aDiff . text ) ; } } return text . toString ( ) ; }
public boolean isStored ( ) { return Integer . signum ( id ) != - NUM_ ; }
public static BigInteger sizeOfDirectoryAsBigInteger ( File directory ) { checkDirectory ( directory ) ; final File [ ] files = directory . listFiles ( ) ; if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { try { if ( ! isSymlink ( file ) ) { size = size . add ( BigInteger . valueOf ( sizeOf ( file ) ) ) ; } } catch ( IOException ioe ) { } } return size ; }
public boolean isSearchLightBit ( int bit ) { if ( nodeType != SMINI ) { log . error ( STR_ ) ; return ( BOOL_ ) ; } if ( ( bit < NUM_ ) || ( bit > NUM_ ) ) { log . error ( STR_ + Integer . toString ( bit ) ) ; return ( BOOL_ ) ; } if ( locSearchLightBits [ bit ] == NUM_ ) { return ( BOOL_ ) ; } return ( BOOL_ ) ; }
public AgeFileFilter ( Date cutoffDate , boolean acceptOlder ) { this ( cutoffDate . getTime ( ) , acceptOlder ) ; }
public void calcMajorTick ( ) { majorTick = NUM_ ; majorTickCount = ( int ) Math . round ( log10 ( maxTick / minTick ) ) + NUM_ ; }
public boolean next ( ) throws GenericDataSourceException { try { return _rs . next ( ) ; } catch ( SQLException sqle ) { throw new GenericDataSourceException ( STR_ + _sql , sqle ) ; } }
public void put ( String sample , HiddenAttribute attribute , Object value ) { put ( sample , attribute . toString ( ) , value ) ; }
void postMessage ( List < JetstreamMessage > msgs , DispatchQueueStats stats ) throws MessageServiceException { m_msgRcvCounter . addAndGet ( msgs . size ( ) ) ; if ( ( monitorUpstreamQueueAndPauseTraffic ( ) == UpstreamQueueState . FULL ) && ( m_paused . get ( ) ) ) { if ( ! m_msgProcessor . hasAvailableCapacity ( m_twentyPercentCapacity ) ) { m_totalMsgsDropped . increment ( ) ; return ; } } List < Runnable > requests = new ArrayList < Runnable > ( msgs . size ( ) ) ; for ( int i = NUM_ , t = msgs . size ( ) ; i < t ; i ++ ) { JetstreamMessage tm = msgs . get ( i ) ; if ( tm . getTopic ( ) == null ) { m_totalMsgsDropped . increment ( ) ; if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( STR_ ) ; } continue ; } MessageServiceRequest msr = new MessageServiceRequest ( tm ) ; msr . setPriority ( tm . getPriority ( ) ) ; msr . setSequenceid ( tm . getSequenceId ( ) ) ; if ( msr . getPriority ( ) == JetstreamMessage . INTERNAL_MSG_PRIORITY ) { if ( ! m_internalMsgProcessor . processRequest ( msr ) ) { m_totalMsgsDropped . increment ( ) ; throw new MessageServiceException ( MessageServiceException . BUFFER_FULL , STR_ ) ; } if ( m_msgsRcvdPerSec . addAndGet ( NUM_ ) < NUM_ ) m_msgsRcvdPerSec . set ( NUM_ ) ; m_totalMsgsRcvd . increment ( ) ; } else { requests . add ( msr ) ; } } if ( ! requests . isEmpty ( ) ) { int batchsize = requests . size ( ) ; if ( ! m_msgProcessor . processBatch ( requests ) ) { m_totalMsgsDropped . addAndGet ( batchsize ) ; throw new MessageServiceException ( MessageServiceException . BUFFER_FULL , STR_ + STR_ + batchsize + STR_ + m_msgProcessor . getAvailableCapacity ( ) ) ; } m_avgMsgsRcvdPerSec . add ( batchsize ) ; m_totalMsgsRcvd . addAndGet ( batchsize ) ; } if ( stats != null ) { stats . setHighPriorityQueueDepth ( ( int ) m_msgProcessor . getPendingRequests ( ) ) ; stats . setLowPriorityQueueDepth ( ( int ) m_msgProcessor . getPendingRequests ( ) ) ; stats . setMaxQueueDepth ( ( int ) m_msgProcessor . getMaxQueueSz ( ) ) ; } }
public boolean unsetOrdering ( Object first , Object second ) { DigraphNode firstPONode = ( DigraphNode ) poNodes . get ( first ) ; DigraphNode secondPONode = ( DigraphNode ) poNodes . get ( second ) ; return firstPONode . removeEdge ( secondPONode ) || secondPONode . removeEdge ( firstPONode ) ; }
public String convertSWFToHTML ( InputStream in ) throws Exception { StringWriter out1 = new StringWriter ( ) ; output = new PrintWriter ( out1 ) ; TagParser parser = new TagParser ( this ) ; SWFReader reader = new SWFReader ( parser , in ) ; reader . readFile ( ) ; in . close ( ) ; sizeCount = reader . size ; final String ret = STR_ + ( headerstr . isEmpty ( ) ? STR_ : STR_ + headerstr + STR_ ) + out1 . toString ( ) + STR_ ; return ret ; }
public void write ( ClassFile classFile , File f ) throws IOException { FileOutputStream f_out = new FileOutputStream ( f ) ; try { write ( classFile , f_out ) ; } finally { f_out . close ( ) ; } }
public Shape greatCircleLineShape ( ) { GeneralPath path = null ; if ( llpts != null && llpts . length >= NUM_ && llpts . length % NUM_ == NUM_ ) { double y1 = llpts [ NUM_ ] ; double x1 = llpts [ NUM_ ] ; path = new GeneralPath ( GeneralPath . WIND_EVEN_ODD , llpts . length / NUM_ ) ; boolean firstCoords = BOOL_ ; for ( int i = NUM_ ; i < llpts . length ; i += NUM_ ) { double y2 = llpts [ i ] ; double x2 = llpts [ i + NUM_ ] ; double radDist = GreatCircle . sphericalDistance ( y1 , x1 , y2 , x2 ) ; int nsegs = ( int ) ( ProjMath . radToDeg ( radDist ) . segsPerDeg ) ; if ( nsegs == NUM_ ) { nsegs = NUM_ ; } double [ ] coords = GreatCircle . greatCircle ( y1 , x1 , y2 , x2 , nsegs , BOOL_ ) ; if ( returnDegrees ) { ProjMath . arrayRadToDeg ( coords ) ; } for ( int j = NUM_ ; j <= coords . length - NUM_ ; j += NUM_ ) { if ( firstCoords ) { path . moveTo ( coords [ j + NUM_ ] , coords [ j ] ) ; firstCoords = BOOL_ ; } else { path . lineTo ( coords [ j + NUM_ ] , coords [ j ] ) ; } } x1 = x2 ; y1 = y2 ; } if ( returnDegrees ) { path . lineTo ( ProjMath . radToDeg ( x1 ) , ProjMath . radToDeg ( y1 ) ) ; } else { path . lineTo ( x1 , y1 ) ; } } return path ; }
public Connection ( final InetSocketAddress peerAddress ) { this ( peerAddress , ( Handshaker ) null ) ; }
protected static Vector convertToVector ( final Object [ ] anArray ) { if ( anArray == null ) { return null ; } final Vector v = new Vector ( anArray . length ) ; for ( final Object element : anArray ) { v . addElement ( element ) ; } return v ; }
protected synchronized void notifyVersion ( SprogVersion v ) { ver = v ; for ( SprogVersionListener listener : getCopyOfListeners ( ) ) { try { listener . notifyVersion ( ver ) ; versionListeners . remove ( listener ) ; } catch ( Exception e ) { log . warn ( STR_ + listener + STR_ + e ) ; } } }
protected void acceptDrop ( int dropOperation ) { DropTargetContextPeer peer = getDropTargetContextPeer ( ) ; if ( peer != null ) { peer . acceptDrop ( dropOperation ) ; } }
public void clear ( ) { oredCriteria . clear ( ) ; orderByClause = null ; distinct = BOOL_ ; }
@ Override public String toString ( ) { String result ; result = super . toString ( ) ; if ( m_CapabilitiesFilter != null ) { initCapabilities ( ) ; if ( m_Capabilities != null ) { if ( m_Capabilities . supportsMaybe ( m_CapabilitiesFilter ) && ! m_Capabilities . supports ( m_CapabilitiesFilter ) ) { result = STR_ + MAYBE_SUPPORT + STR_ + result + STR_ ; } else if ( ! m_Capabilities . supports ( m_CapabilitiesFilter ) ) { result = STR_ + NO_SUPPORT + STR_ + result + STR_ ; } } } return result ; }
ConfigurationError ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; }
public Date modifiedDate ( String path ) throws IllegalStateException , IOException , FTPIllegalReplyException , FTPException { synchronized ( lock ) { if ( ! connected ) { throw new IllegalStateException ( STR_ ) ; } if ( ! authenticated ) { throw new IllegalStateException ( STR_ ) ; } communication . sendFTPCommand ( STR_ + path ) ; FTPReply r = communication . readFTPReply ( ) ; touchAutoNoopTimer ( ) ; if ( ! r . isSuccessCode ( ) ) { throw new FTPException ( r ) ; } String [ ] messages = r . getMessages ( ) ; if ( messages . length != NUM_ ) { throw new FTPIllegalReplyException ( ) ; } else { try { return MDTM_DATE_FORMAT . parse ( messages [ NUM_ ] ) ; } catch ( ParseException e ) { throw new FTPIllegalReplyException ( ) ; } } } }
public boolean importPkcs8 ( ) { return jrbPkcs8 . isSelected ( ) ; }
public ControlFlowGraph run ( CompilationUnitTree root , ProcessingEnvironment env , MethodTree tree , ClassTree classTree ) { UnderlyingAST underlyingAST = new CFGMethod ( tree , classTree ) ; return run ( root , env , underlyingAST ) ; }
private boolean isValidEngine ( ) { if ( hasFlag ( ~ ( CLAN_ENGINE | TANK_ENGINE | LARGE_ENGINE | SUPERHEAVY_ENGINE | SUPPORT_VEE_ENGINE ) ) ) { problem . append ( STR_ + engineFlags ) ; return BOOL_ ; } if ( hasFlag ( SUPPORT_VEE_ENGINE ) && ( engineType != STEAM ) && ( engineType != COMBUSTION_ENGINE ) && ( engineType != BATTERY ) && ( engineType != FUEL_CELL ) && ( engineType != SOLAR ) && ( engineType != FISSION ) && ( engineType != NORMAL_ENGINE ) && ( engineType != NONE ) ) { problem . append ( STR_ ) ; return BOOL_ ; } if ( ( ( ( int ) Math . ceil ( engineRating / NUM_ ) > ENGINE_RATINGS . length ) || ( engineRating < NUM_ ) ) && ! hasFlag ( SUPPORT_VEE_ENGINE ) ) { problem . append ( STR_ + engineRating ) ; return BOOL_ ; } if ( ( engineRating > NUM_ ) && ! hasFlag ( SUPPORT_VEE_ENGINE ) ) { engineFlags |= LARGE_ENGINE ; } switch ( engineType ) { case COMBUSTION_ENGINE : case NORMAL_ENGINE : case XL_ENGINE : case XXL_ENGINE : case FUEL_CELL : case NONE : case MAGLEV : case BATTERY : case SOLAR : break ; case COMPACT_ENGINE : if ( hasFlag ( LARGE_ENGINE ) ) { problem . append ( Messages . getString ( STR_ ) ) ; return BOOL_ ; } break ; case LIGHT_ENGINE : case FISSION : if ( hasFlag ( CLAN_ENGINE ) ) { problem . append ( Messages . getString ( STR_ ) ) ; return BOOL_ ; } break ; default : problem . append ( STR_ + engineType ) ; return BOOL_ ; } return BOOL_ ; }
static public void assertEquals ( String message , float expected , float actual , float delta ) { if ( Float . isInfinite ( expected ) ) { if ( ! ( expected == actual ) ) failNotEquals ( message , new Float ( expected ) , new Float ( actual ) ) ; } else if ( ! ( Math . abs ( expected - actual ) <= delta ) ) failNotEquals ( message , new Float ( expected ) , new Float ( actual ) ) ; }
public static byte [ ] base64decode ( String coded ) { if ( null == coded ) return null ; byte [ ] src = coded . getBytes ( ) ; int len = src . length ; int dlen = len - ( len / NUM_ ) ; dlen = ( dlen > > > NUM_ ) + ( dlen > > > NUM_ ) ; int rem = NUM_ ; if ( NUM_ == src [ len - NUM_ ] ) rem ++ ; if ( NUM_ == src [ len - NUM_ ] ) rem ++ ; dlen -= rem ; byte [ ] dst = new byte [ dlen ] ; int pos = NUM_ ; int dpos = NUM_ ; int col = NUM_ ; len -= NUM_ ; while ( pos < len ) { byte b0 = _base64de [ src [ pos ++ ] ] ; byte b1 = _base64de [ src [ pos ++ ] ] ; byte b2 = _base64de [ src [ pos ++ ] ] ; byte b3 = _base64de [ src [ pos ++ ] ] ; if ( B64INV == b0 || B64INV == b1 || B64INV == b2 || B64INV == b3 ) throw new RuntimeException ( STR_ + pos ) ; dst [ dpos ++ ] = ( byte ) ( ( b0 << NUM_ ) | ( ( b1 > > > NUM_ ) & x03 ) ) ; dst [ dpos ++ ] = ( byte ) ( ( b1 << NUM_ ) | ( ( b2 > > > NUM_ ) & x0f ) ) ; dst [ dpos ++ ] = ( byte ) ( ( b2 << NUM_ ) | ( b3 & x3f ) ) ; col += NUM_ ; if ( NUM_ == col ) { if ( NUM_ != src [ pos ++ ] ) throw new RuntimeException ( STR_ + ( pos - NUM_ ) ) ; col = NUM_ ; } } byte b0 = _base64de [ src [ pos ++ ] ] ; byte b1 = _base64de [ src [ pos ++ ] ] ; byte b2 = _base64de [ src [ pos ++ ] ] ; byte b3 = _base64de [ src [ pos ++ ] ] ; if ( B64INV == b0 || B64INV == b1 || B64INV == b2 || B64INV == b3 ) throw new RuntimeException ( STR_ + pos ) ; dst [ dpos ++ ] = ( byte ) ( ( b0 << NUM_ ) | ( ( b1 > > > NUM_ ) & x03 ) ) ; if ( NUM_ == rem ) return dst ; dst [ dpos ++ ] = ( byte ) ( ( b1 << NUM_ ) | ( ( b2 > > > NUM_ ) & x0f ) ) ; if ( NUM_ == rem ) return dst ; dst [ dpos ++ ] = ( byte ) ( ( b2 << NUM_ ) | ( b3 & x3f ) ) ; return dst ; }
private static Properties loadProperties ( String propertiesFile ) { Properties properties = new Properties ( ) ; try ( InputStream is = new FileInputStream ( propertiesFile ) ) { properties . load ( is ) ; } catch ( IOException e ) { throw new RuntimeException ( STR_ , e ) ; } return properties ; }
public TextEditor replaceAll ( Pattern pattern , Replacement replacement ) { Matcher m = pattern . matcher ( text ) ; int lastIndex = NUM_ ; StringBuilder sb = new StringBuilder ( ) ; while ( m . find ( ) ) { sb . append ( text . subSequence ( lastIndex , m . start ( ) ) ) ; sb . append ( replacement . replacement ( m ) ) ; lastIndex = m . end ( ) ; } sb . append ( text . subSequence ( lastIndex , text . length ( ) ) ) ; text = sb ; return this ; }
public Map < String , Map < String , String > > list ( String serviceName ) { Map < String , Map < String , String > > results = new HashMap < String , Map < String , String > > ( ) ; ServiceInfo [ ] infos = jmdns . list ( STR_ + serviceName + STR_ ) ; for ( ServiceInfo info : infos ) { _log . info ( STR_ , info ) ; final String [ ] hostAddrs = info . getHostAddresses ( ) ; final StringBuffer buf = new StringBuffer ( ) ; for ( String hostAddr : hostAddrs ) { buf . append ( hostAddr ) ; buf . append ( STR_ ) ; } final String key = buf . toString ( ) ; _log . info ( STR_ , key ) ; final Map < String , String > values = new HashMap < String , String > ( ) ; for ( Enumeration < String > e = info . getPropertyNames ( ) ; e . hasMoreElements ( ) ; ) { final String prop = e . nextElement ( ) ; final String value = new String ( info . getPropertyBytes ( prop ) ) ; _log . info ( STR_ , prop , value ) ; values . put ( prop , value ) ; } if ( values . isEmpty ( ) ) { _log . warn ( STR_ , key ) ; } results . put ( key , values . isEmpty ( ) ? null : values ) ; } return results ; }
@ SuppressWarnings ( { STR_ } ) @ Override default LazyFutureStream < U > concat ( final Stream < ? extends U > other ) { return fromStream ( Stream . concat ( StreamSupport . stream ( Spliterators . spliteratorUnknownSize ( iterator ( ) , Spliterator . ORDERED ) , BOOL_ ) , StreamSupport . stream ( Spliterators . spliteratorUnknownSize ( other . iterator ( ) , Spliterator . ORDERED ) , BOOL_ ) ) ) ; }
private int moveComponents ( Container target , int x , int y , int width , int height , int rowStart , int rowEnd , boolean ltr , boolean useBaseline , int [ ] ascent , int [ ] descent ) { switch ( newAlign ) { case LEFT : x += ltr ? NUM_ : width ; break ; case CENTER : x += width / NUM_ ; break ; case RIGHT : x += ltr ? width : NUM_ ; break ; case LEADING : break ; case TRAILING : x += width ; break ; } int maxAscent = NUM_ ; int nonbaselineHeight = NUM_ ; int baselineOffset = NUM_ ; if ( useBaseline ) { int maxDescent = NUM_ ; for ( int i = rowStart ; i < rowEnd ; i ++ ) { Component m = target . getComponent ( i ) ; if ( m . visible ) { if ( ascent [ i ] >= NUM_ ) { maxAscent = Math . max ( maxAscent , ascent [ i ] ) ; maxDescent = Math . max ( maxDescent , descent [ i ] ) ; } else { nonbaselineHeight = Math . max ( m . getHeight ( ) , nonbaselineHeight ) ; } } } height = Math . max ( maxAscent + maxDescent , nonbaselineHeight ) ; baselineOffset = ( height - maxAscent - maxDescent ) / NUM_ ; } for ( int i = rowStart ; i < rowEnd ; i ++ ) { Component m = target . getComponent ( i ) ; if ( m . isVisible ( ) ) { int cy ; if ( useBaseline && ascent [ i ] >= NUM_ ) { cy = y + baselineOffset + maxAscent - ascent [ i ] ; } else { cy = y + ( height - m . height ) / NUM_ ; } if ( ltr ) { m . setLocation ( x , cy ) ; } else { m . setLocation ( target . width - x - m . width , cy ) ; } x += m . width + hgap ; } } return height ; }
@ Override public void readExternal ( ObjectInput in ) throws IOException { path = IgfsUtils . readPath ( in ) ; blockSize = in . readInt ( ) ; grpBlockSize = in . readLong ( ) ; len = in . readLong ( ) ; props = U . readStringMap ( in ) ; accessTime = in . readLong ( ) ; modificationTime = in . readLong ( ) ; flags = in . readByte ( ) ; }
public StandardXYItemLabelGenerator ( ) { this ( DEFAULT_ITEM_LABEL_FORMAT , NumberFormat . getNumberInstance ( ) , NumberFormat . getNumberInstance ( ) ) ; }
public Vector2 ( double direction ) { this . x = Math . cos ( direction ) ; this . y = Math . sin ( direction ) ; }
public static Map < String , Object > convertDocumentFileToFile ( DispatchContext dctx , Map < String , ? extends Object > context ) { XMultiComponentFactory xmulticomponentfactory = null ; String stringUrl = ( String ) context . get ( STR_ ) ; String stringConvertedFile = ( String ) context . get ( STR_ ) ; String inputMimeType = ( String ) context . get ( STR_ ) ; String outputMimeType = ( String ) context . get ( STR_ ) ; String oooHost = ( String ) context . get ( STR_ ) ; String oooPort = ( String ) context . get ( STR_ ) ; try { xmulticomponentfactory = OpenOfficeWorker . getRemoteServer ( oooHost , oooPort ) ; File inputFile = new File ( stringUrl ) ; long fileSize = inputFile . length ( ) ; FileInputStream fis = new FileInputStream ( inputFile ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ( int ) fileSize ) ; int c ; while ( ( c = fis . read ( ) ) != - NUM_ ) { baos . write ( c ) ; } OpenOfficeByteArrayInputStream oobais = new OpenOfficeByteArrayInputStream ( baos . toByteArray ( ) ) ; OpenOfficeByteArrayOutputStream oobaos = OpenOfficeWorker . convertOODocByteStreamToByteStream ( xmulticomponentfactory , oobais , inputMimeType , outputMimeType ) ; FileOutputStream fos = new FileOutputStream ( stringConvertedFile ) ; fos . write ( oobaos . toByteArray ( ) ) ; fos . close ( ) ; fis . close ( ) ; oobais . close ( ) ; oobaos . close ( ) ; Map results = ServiceUtil . returnSuccess ( ) ; return results ; } catch ( IOException e ) { Debug . logError ( e , STR_ , module ) ; return ServiceUtil . returnError ( e . toString ( ) ) ; } catch ( Exception e ) { Debug . logError ( e , STR_ , module ) ; return ServiceUtil . returnError ( e . toString ( ) ) ; } }
public double adjustedPow10 ( double val ) { boolean negFlag = ( val < NUM_ ) ; if ( negFlag ) { val = - val ; } double res ; if ( val < NUM_ ) { res = ( Math . pow ( NUM_ , val + NUM_ ) - NUM_ ) / NUM_ ; } else { res = Math . pow ( NUM_ , val ) ; } return negFlag ? ( - res ) : res ; }
@ Override public void clear ( ) { columnList . forEach ( null ) ; }
public boolean isLastInvoice ( ) { String cm = getCostingMethod ( ) ; return cm != null && cm . equals ( COSTINGMETHOD_LastInvoice ) ; }
public static void proxyPort ( final int port ) { final String portValue = Integer . toString ( port ) ; setProperty ( STR_ , portValue ) ; setProperty ( STR_ , portValue ) ; }
public static String fetchClusterName ( String clusterCgName ) { String clusterName = null ; if ( clusterCgName != null && ! clusterCgName . isEmpty ( ) ) { String [ ] tmp = clusterCgName . split ( SPLITTER ) ; clusterName = tmp [ NUM_ ] ; } return clusterName ; }
private void fetchMyServiceCardsFromServer ( ) { RetroCallback retroCallback ; retroCallback = new RetroCallback ( this ) ; retroCallback . setRequestId ( HttpConstants . ApiResponseCodes . GET_MY_SERVICES ) ; retroCallbackList . add ( retroCallback ) ; mYeloApi . getMyServiceCards ( retroCallback ) ; }
public DViewAsymmetricKeyFields ( JDialog parent , String title , RSAPublicKey rsaPublicKey ) { super ( parent , title , Dialog . ModalityType . DOCUMENT_MODAL ) ; key = rsaPublicKey ; initFields ( ) ; }
public List < ColourChange > sampleConditionalMigrationEvents2 ( int parentColour , double parentHeight , int childColour , double childHeight , double [ ] m ) { List < ColourChange > colourChanges = new ArrayList < ColourChange > ( ) ; if ( parentHeight < childHeight ) { throw new IllegalArgumentException ( STR_ + parentHeight + STR_ + childHeight + STR_ ) ; } try { int currentColour = parentColour ; double currentHeight = parentHeight ; while ( BOOL_ ) { ColourChange nextEvent = randomConditionalMigrationEvent ( currentColour , currentHeight , childColour , childHeight , m ) ; currentHeight = nextEvent . getTime ( ) ; currentColour = nextEvent . getColourAbove ( ) ; colourChanges . add ( nextEvent ) ; } } catch ( NoEventException nee ) { } reverseColourChangeList ( colourChanges , parentColour ) ; return colourChanges ; }
public static boolean isAttribute ( Object objValue ) { if ( objValue instanceof String ) { String stringValue = ( String ) objValue ; if ( stringValue . startsWith ( ATTRIBUTE_START ) && stringValue . endsWith ( ATTRIBUTE_END ) ) { return BOOL_ ; } } return BOOL_ ; }
public static String decodeASCII ( final byte [ ] key , final int off , final int len ) { final byte [ ] b = new byte [ len ] ; System . arraycopy ( key , off , b , NUM_ , len ) ; for ( int i = NUM_ ; i < len ; i ++ ) { b [ i ] = decodeByte ( b [ i ] ) ; } try { return new String ( b , STR_ ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } }
@ Override public void valueChanged ( TreeSelectionEvent e ) { if ( preventEvent ) { return ; } if ( mainFrame != null ) { List < Operator > selectedOperators = getSelectedOperators ( ) ; if ( selectedOperators != null && ! selectedOperators . isEmpty ( ) ) { mainFrame . selectOperators ( selectedOperators ) ; } } }
public synchronized void removePropertyChangeListener ( PropertyChangeListener listener ) { listeners . remove ( listener ) ; }
final boolean transferAfterCancelledWait ( Node node ) { if ( compareAndSetWaitStatus ( node , Node . CONDITION , NUM_ ) ) { enq ( node ) ; return BOOL_ ; } while ( ! isOnSyncQueue ( node ) ) Thread . yield ( ) ; return BOOL_ ; }
private static Intent createShareIntent ( Context context , final String shareText ) { final Intent shareIntent = new Intent ( Intent . ACTION_SEND ) ; shareIntent . putExtra ( android . content . Intent . EXTRA_SUBJECT , context . getString ( R . string . share_subject ) ) ; shareIntent . putExtra ( android . content . Intent . EXTRA_TEXT , shareText ) ; shareIntent . setType ( STR_ ) ; return shareIntent ; }
public static < U > AtomicIntegerFieldUpdater < U > newUpdater ( Class < U > tclass , String fieldName ) { if ( UnsafeHolder . isAvailable ( ) ) { return new AtomicIntegerFieldUpdaterImpl < U > ( tclass , fieldName ) ; } return AtomicIntegerFieldUpdater . newUpdater ( tclass , fieldName ) ; }
public Map < String , Object > convertDataToObjects ( Map < String , String > data ) { Map < String , Object > results = new HashMap < > ( ) ; if ( data != null ) { for ( String key : data . keySet ( ) ) { results . put ( key , data . get ( key ) ) ; } } return results ; }
private static Pair < String , String > offsetLSR ( final long offset , final ITranslationEnvironment environment , final List < ReilInstruction > instructions , final String registerNodeValue1 , final String registerNodeValue2 , final String immediateNodeValue ) { final String address = environment . getNextVariableString ( ) ; final String tmpVar1 = environment . getNextVariableString ( ) ; final String tmpVar2 = environment . getNextVariableString ( ) ; final String index = environment . getNextVariableString ( ) ; long baseOffset = offset ; instructions . add ( ReilHelpers . createBsh ( baseOffset ++ , dw , registerNodeValue2 , dw , STR_ + immediateNodeValue , qw , tmpVar1 ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , qw , tmpVar1 , dw , dWordBitMask , dw , index ) ) ; instructions . add ( ReilHelpers . createAdd ( baseOffset ++ , dw , registerNodeValue1 , dw , index , dw , tmpVar2 ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , dw , tmpVar2 , dw , dWordBitMask , dw , address ) ) ; return new Pair < String , String > ( address , registerNodeValue1 ) ; }
public static RowLimitSpec buildRowLimitSpec ( EsperEPL2GrammarParser . RowLimitContext ctx ) { Object numRows ; Object offset ; if ( ctx . o != null ) { numRows = parseNumOrVariableIdent ( ctx . n1 , ctx . i1 ) ; offset = parseNumOrVariableIdent ( ctx . n2 , ctx . i2 ) ; } else if ( ctx . c != null ) { offset = parseNumOrVariableIdent ( ctx . n1 , ctx . i1 ) ; numRows = parseNumOrVariableIdent ( ctx . n2 , ctx . i2 ) ; } else { numRows = parseNumOrVariableIdent ( ctx . n1 , ctx . i1 ) ; offset = null ; } Integer numRowsInt = null ; String numRowsVariable = null ; if ( numRows instanceof String ) { numRowsVariable = ( String ) numRows ; } else { numRowsInt = ( Integer ) numRows ; } Integer offsetInt = null ; String offsetVariable = null ; if ( offset instanceof String ) { offsetVariable = ( String ) offset ; } else { offsetInt = ( Integer ) offset ; } return new RowLimitSpec ( numRowsInt , offsetInt , numRowsVariable , offsetVariable ) ; }
public final int first_common_layer ( BrdItem p_other ) { int max_first_layer = Math . max ( first_layer ( ) , p_other . first_layer ( ) ) ; int min_last_layer = Math . min ( last_layer ( ) , p_other . last_layer ( ) ) ; if ( max_first_layer > min_last_layer ) { return - NUM_ ; } return max_first_layer ; }
public ItemStack removeItems ( ItemStack drive , ItemStack stack , int amountWanted ) { if ( getMaxKilobits ( drive ) == - NUM_ ) return null ; int stored = getAmountStored ( drive , stack ) ; int amountGiven = Math . min ( amountWanted , stored ) ; if ( amountGiven > NUM_ ) { setAmountStored ( drive , stack , stored - amountGiven ) ; stack . stackSize += amountGiven ; markDirty ( drive ) ; } return stack ; }
public void saveIndexes ( ) { ArrayList toSave = new ArrayList ( ) ; synchronized ( this ) { Object [ ] valueTable = this . indexes . valueTable ; for ( int i = NUM_ , l = valueTable . length ; i < l ; i ++ ) { Index index = ( Index ) valueTable [ i ] ; if ( index != null ) toSave . add ( index ) ; } } boolean allSaved = BOOL_ ; for ( int i = NUM_ , length = toSave . size ( ) ; i < length ; i ++ ) { Index index = ( Index ) toSave . get ( i ) ; ReadWriteMonitor monitor = index . monitor ; if ( monitor == null ) continue ; try { monitor . enterRead ( ) ; if ( index . hasChanged ( ) ) { if ( monitor . exitReadEnterWrite ( ) ) { try { saveIndex ( index ) ; } catch ( IOException e ) { if ( JobManager . VERBOSE ) { Util . verbose ( STR_ , System . err ) ; e . printStackTrace ( ) ; } allSaved = BOOL_ ; } finally { monitor . exitWriteEnterRead ( ) ; } } else { allSaved = BOOL_ ; } } } finally { monitor . exitRead ( ) ; } } if ( this . participantsContainers != null && this . participantUpdated ) { writeParticipantsIndexNamesFile ( ) ; this . participantUpdated = BOOL_ ; } this . needToSave = ! allSaved ; }
public void addItem ( Artist artist , int position ) { if ( artist == null ) throw new NullPointerException ( STR_ ) ; if ( position < getItemCount ( ) || position > getItemCount ( ) ) throw new IllegalArgumentException ( STR_ ) ; artists . add ( position , artist ) ; notifyItemInserted ( position ) ; }
public Process executeAsync ( final CommandLine command , Map < String , String > environment ) throws IOException { if ( workingDirectory != null && ! workingDirectory . exists ( ) ) { throw new IOException ( workingDirectory + STR_ ) ; } return executeInternal ( command , environment , workingDirectory , streamHandler , null ) ; }
public void expandAndSelectIfExists ( RepositoryLocation location ) { if ( location . parent ( ) != null ) { expandIfExists ( location . parent ( ) , location . getName ( ) ) ; } else { expandIfExists ( location , null ) ; } scrollPathToVisible ( getSelectionPath ( ) ) ; }
public void nextToken ( ) { previousLine = line ; previousColumn = column ; while ( pos < matcher . regionStart ( ) ) { if ( text . charAt ( pos ) == STR_ ) { ++ line ; column = NUM_ ; } else { ++ column ; } ++ pos ; } if ( matcher . regionStart ( ) == matcher . regionEnd ( ) ) { currentToken = STR_ ; } else { matcher . usePattern ( TOKEN ) ; if ( matcher . lookingAt ( ) ) { currentToken = matcher . group ( ) ; matcher . region ( matcher . end ( ) , matcher . regionEnd ( ) ) ; } else { currentToken = String . valueOf ( text . charAt ( pos ) ) ; matcher . region ( pos + NUM_ , matcher . regionEnd ( ) ) ; } skipWhitespace ( ) ; } }
public static void saveProvisioningValidity ( Context context , long validity ) { if ( validity <= NUM_ ) { return ; } long next = System . currentTimeMillis ( ) + validity ; SharedPreferences preferences = context . getSharedPreferences ( AndroidRegistryFactory . RCS_PREFS_NAME , Activity . MODE_PRIVATE ) ; SharedPreferences . Editor editor = preferences . edit ( ) ; editor . putLong ( REGISTRY_PROVISIONING_VALIDITY , validity ) ; editor . putLong ( REGISTRY_PROVISIONING_EXPIRATION , next ) ; editor . commit ( ) ; }
public void encode ( OutputStream out ) throws IOException { DerOutputStream tmp = new DerOutputStream ( ) ; if ( this . extensionValue == null ) { this . extensionId = PKIXExtensions . ReasonCode_Id ; this . critical = BOOL_ ; encodeThis ( ) ; } super . encode ( tmp ) ; out . write ( tmp . toByteArray ( ) ) ; }
public DriverTask unexportVolumesFromInitiators ( List < Initiator > initiators , List < StorageVolume > volumes ) { LOG . info ( STR_ ) ; DriverTask task = new DellSCDriverTask ( STR_ ) ; ScServer server = null ; StringBuilder errBuffer = new StringBuilder ( ) ; int volumesUnmapped = NUM_ ; for ( StorageVolume volume : volumes ) { String ssn = volume . getStorageSystemId ( ) ; boolean isSnapshot = StringUtils . countMatches ( volume . getNativeId ( ) , STR_ ) == NUM_ ; try { StorageCenterAPI api = connectionManager . getConnection ( ssn ) ; ScVolume scVol = null ; if ( isSnapshot ) { scVol = api . findReplayView ( volume . getNativeId ( ) ) ; if ( scVol != null ) { api . deleteVolume ( scVol . instanceId ) ; volumesUnmapped ++ ; continue ; } } else { scVol = api . getVolume ( volume . getNativeId ( ) ) ; } if ( scVol == null ) { throw new DellSCDriverException ( String . format ( STR_ , volume . getNativeId ( ) ) ) ; } if ( server == null ) { server = findScServer ( api , ssn , initiators ) ; } if ( server == null ) { throw new DellSCDriverException ( SERVER_CREATE_FAIL_MSG ) ; } ScMappingProfile [ ] mappingProfiles = api . findMappingProfiles ( server . instanceId , scVol . instanceId ) ; for ( ScMappingProfile mappingProfile : mappingProfiles ) { api . deleteMappingProfile ( mappingProfile . instanceId ) ; } volumesUnmapped ++ ; LOG . info ( STR_ , scVol . name , server . name ) ; } catch ( StorageCenterAPIException | DellSCDriverException dex ) { String error = String . format ( STR_ , volume . getDisplayName ( ) , dex ) ; LOG . error ( error ) ; errBuffer . append ( String . format ( STR_ , error ) ) ; if ( SERVER_CREATE_FAIL_MSG . equals ( dex . getMessage ( ) ) ) { break ; } } } task . setMessage ( errBuffer . toString ( ) ) ; if ( volumesUnmapped == volumes . size ( ) ) { task . setStatus ( TaskStatus . READY ) ; } else if ( volumesUnmapped == NUM_ ) { task . setStatus ( TaskStatus . FAILED ) ; } else { task . setStatus ( TaskStatus . PARTIALLY_FAILED ) ; } return task ; }
public void createClusterAsync ( final String projectId , final ClusterCreateSpec clusterCreateSpec , final FutureCallback < Task > responseCallback ) throws IOException { String path = String . format ( STR_ , getBasePath ( ) , projectId ) ; createObjectAsync ( path , serializeObjectAsJson ( clusterCreateSpec ) , responseCallback ) ; }
public static DereferenceAliasesPolicy valueOf ( final int intValue ) { if ( intValue < NUM_ || intValue >= ELEMENTS . length ) { return null ; } return ELEMENTS [ intValue ] ; }
public void testGetNamedItemNS2 ( ) throws Throwable { Document doc ; NamedNodeMap attributes ; Node element ; Attr attribute ; NodeList elementList ; String attrName ; doc = ( Document ) load ( STR_ , builder ) ; elementList = doc . getElementsByTagNameNS ( STR_ , STR_ ) ; element = elementList . item ( NUM_ ) ; attributes = element . getAttributes ( ) ; attribute = ( Attr ) attributes . getNamedItemNS ( STR_ , STR_ ) ; attrName = attribute . getNodeName ( ) ; assertEquals ( STR_ , STR_ , attrName ) ; }
public static void writeUnsafe ( PacketOutputStream out , String value , boolean noBackslashEscapes ) throws IOException { byte [ ] bytes = value . getBytes ( STR_ ) ; out . writeUnsafe ( QUOTE ) ; writeBytesEscapedUnsafe ( out , bytes , bytes . length , noBackslashEscapes ) ; out . writeUnsafe ( QUOTE ) ; }
public void add ( final SAMRecord read , final int position ) { recordAndOffsets . add ( new RecordAndOffset ( read , position ) ) ; }
private Sha256Hash calculateHash ( ) { try { ByteArrayOutputStream bos = new UnsafeByteArrayOutputStream ( HEADER_SIZE ) ; writeHeader ( bos ) ; return new Sha256Hash ( Utils . reverseBytes ( doubleDigest ( bos . toByteArray ( ) ) ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
private void addPropertyType ( URI p , Resource t ) { OwlProperty prop = getProperty ( p ) ; if ( t . equals ( OWL . TRANSITIVEPROPERTY ) ) { prop . setTransitive ( ) ; } else if ( t . equals ( OWL . SYMMETRICPROPERTY ) ) { prop . setSymmetric ( ) ; } else if ( t . equals ( OWL2 . ASYMMETRICPROPERTY ) ) { prop . setAsymmetric ( ) ; } else if ( t . equals ( OWL . FUNCTIONALPROPERTY ) ) { prop . setFunctional ( ) ; } else if ( t . equals ( OWL . INVERSEFUNCTIONALPROPERTY ) ) { prop . setInverseFunctional ( ) ; } else if ( t . equals ( OWL2 . IRREFLEXIVEPROPERTY ) ) { prop . setIrreflexive ( ) ; } }
public static void equals ( Object object1 , Object object2 ) { checkAssertion ( object1 . equals ( object2 ) , null ) ; }
public static String writeActionsToString ( OFInstructionWriteActions inst , Logger log ) throws Exception { return ActionUtils . actionsToString ( inst . getActions ( ) , log ) ; }
protected void preAddInterruptibly ( Object o ) throws InterruptedException { }
public static String encodeLines ( byte [ ] in , int iOff , int iLen , int lineLen , String lineSeparator ) { int blockLen = ( lineLen . NUM_ ) / NUM_ ; if ( blockLen <= NUM_ ) throw new IllegalArgumentException ( ) ; int lines = ( iLen + blockLen - NUM_ ) / blockLen ; int bufLen = ( ( iLen + NUM_ ) / NUM_ ) . NUM_ + lines . lineSeparator . length ( ) ; StringBuilder buf = new StringBuilder ( bufLen ) ; int ip = NUM_ ; while ( ip < iLen ) { int l = Math . min ( iLen - ip , blockLen ) ; buf . append ( encode ( in , iOff + ip , l ) ) ; buf . append ( lineSeparator ) ; ip += l ; } return buf . toString ( ) ; }
private ODataFeed readFeedLogPerf ( String query , Map < String , String > params ) throws IOException , ODataException { long delta_time = System . currentTimeMillis ( ) ; ODataFeed feed = client . readFeed ( query , params ) ; log ( Level . DEBUG , STR_ + query + STR_ + delta_time + STR_ ) ; return feed ; }
final int rllong ( DataInputStream dis ) throws IOException { int b1 , b2 , b3 , b4 ; int i = NUM_ ; i = dis . readInt ( ) ; b1 = ( i & xFF ) << NUM_ ; b2 = ( i & xFF00 ) << NUM_ ; b3 = ( i & xFF0000 ) > > NUM_ ; b4 = ( i & xFF000000 ) > > > NUM_ ; i = ( b1 | b2 | b3 | b4 ) ; return i ; }
public void testShiftRight4 ( ) { byte aBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int number = NUM_ ; byte rBytes [ ] = { NUM_ , NUM_ , - NUM_ , NUM_ , - NUM_ , - NUM_ , - NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger result = aNumber . shiftRight ( number ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public Dependencies resolveFromFile ( File file , String className , SootClass sc ) { DexlibWrapper wrapper = cache . get ( file ) ; if ( wrapper == null ) { wrapper = new DexlibWrapper ( file ) ; cache . put ( file , wrapper ) ; wrapper . initialize ( ) ; } Dependencies deps = wrapper . makeSootClass ( sc , className ) ; addSourceFileTag ( sc , STR_ + file . getName ( ) ) ; return deps ; }
public static String buildResponseUrl ( String tenant , LogoutState logoutState ) { String retval = null ; LogoutResponse samlResponse = logoutState . generateResponseForTenant ( tenant , logoutState . getMessageSource ( ) , logoutState . getLocale ( ) ) ; if ( samlResponse != null ) { log . info ( STR_ + samlResponse . toString ( ) ) ; retval = logoutState . generateResponseUrlForTenant ( samlResponse , tenant ) ; } return retval ; }
public static void assertLabel ( int [ ] path , String text ) { if ( verbose ) { log ( STR_ + toString ( path ) + STR_ + text + STR_ ) ; } Label l = ( Label ) getComponentByPath ( path ) ; assertBool ( l != null , STR_ + text ) ; assertBool ( text == l . getText ( ) || text . equals ( l . getText ( ) ) , ( STR_ + l . getText ( ) ) + STR_ + text ) ; }
private void interpolateResultList ( ArrayList < PathParser . PathDataNode > list ) { if ( list == null || list . size ( ) <= NUM_ ) return ; float [ ] [ ] listPenPos = PathNodeUtils . calculatePenPosition ( list ) ; ArrayList < PathParser . PathDataNode > subList = new ArrayList < > ( ) ; int size = list . size ( ) ; PathParser . PathDataNode currentNode = null ; int i = NUM_ ; while ( i < size - NUM_ ) { currentNode = list . get ( i ) ; if ( ! isInterpolatableCommand ( currentNode . mType ) ) { i ++ ; continue ; } boolean validSequence = BOOL_ ; int k = i ; for ( int j = i ; j < size && validSequence ; j ++ ) { if ( currentNode . mType == list . get ( j ) . mType ) { k = j ; if ( ! Arrays . equals ( currentNode . mParams , list . get ( j ) . mParams ) ) break ; } else validSequence = BOOL_ ; } if ( k - i > NUM_ ) { interpolateSubList ( list . subList ( i , k + NUM_ ) ) ; } i ++ ; } }
private void initTokenizer ( StreamTokenizer tokenizer ) { tokenizer . resetSyntax ( ) ; tokenizer . whitespaceChars ( NUM_ , ( STR_ - NUM_ ) ) ; tokenizer . wordChars ( STR_ , STR_ ) ; tokenizer . whitespaceChars ( STR_ , STR_ ) ; tokenizer . whitespaceChars ( STR_ , STR_ ) ; tokenizer . commentChar ( STR_ ) ; tokenizer . whitespaceChars ( STR_ , STR_ ) ; tokenizer . quoteChar ( STR_ ) ; tokenizer . quoteChar ( STR_ ) ; tokenizer . eolIsSignificant ( BOOL_ ) ; }
protected void illegalMessageReceived ( OFMessage m ) { String msg = getSwitchStateMessage ( m , STR_ ) ; throw new SwitchStateException ( msg ) ; }
protected void run_ThreadSizeLoop ( ) throws Exception { for ( int i = NUM_ ; i <= NUM_ ; i += NUM_ ) { setNumWorkers ( i ) ; try { Thread . sleep ( NUM_ . NUM_ ) ; } catch ( InterruptedException e ) { } } }
protected boolean read ( ) { if ( ! nReuseHeader ) { Debug . message ( STR_ , STR_ ) ; return readHeader ( ) ; } byte [ ] tempData = new byte [ nDataSize - nFieldOffset ] ; int nReadBytes = poModule . read ( tempData , NUM_ , tempData . length ) ; System . arraycopy ( pachData , nFieldOffset , tempData , NUM_ , tempData . length ) ; if ( nReadBytes != ( int ) ( nDataSize - nFieldOffset ) && nReadBytes == - NUM_ ) { return BOOL_ ; } else if ( nReadBytes != ( int ) ( nDataSize - nFieldOffset ) ) { Debug . error ( STR_ ) ; return BOOL_ ; } return BOOL_ ; }
@ Override public boolean lock ( ) { try { if ( ! FileFactory . isFileExist ( location , FileFactory . getFileType ( tmpPath ) ) ) { FileFactory . mkdirs ( location , FileFactory . getFileType ( tmpPath ) ) ; } String lockFilePath = location + CarbonCommonConstants . FILE_SEPARATOR + lockFile ; if ( ! FileFactory . isFileExist ( lockFilePath , FileFactory . getFileType ( location ) ) ) { FileFactory . createNewLockFile ( lockFilePath , FileFactory . getFileType ( location ) ) ; } fileOutputStream = new FileOutputStream ( lockFilePath ) ; channel = fileOutputStream . getChannel ( ) ; try { fileLock = channel . tryLock ( ) ; } catch ( OverlappingFileLockException e ) { return BOOL_ ; } if ( null != fileLock ) { return BOOL_ ; } else { return BOOL_ ; } } catch ( IOException e ) { return BOOL_ ; } }
public void open ( int port ) throws IOException { connection = new DatagramSocket ( port ) ; connection . setSoTimeout ( timeout ) ; }
public String globalInfo ( ) { return STR_ + STR_ ; }
public MLResults execute ( Script script ) { ScriptExecutor scriptExecutor = new ScriptExecutor ( sparkMonitoringUtil ) ; scriptExecutor . setExplain ( explain ) ; scriptExecutor . setExplainLevel ( explainLevel ) ; scriptExecutor . setStatistics ( statistics ) ; scriptExecutor . setInit ( scriptHistoryStrings . isEmpty ( ) ) ; return execute ( script , scriptExecutor ) ; }
public void disable ( RichFormatterFeature feature ) { features . remove ( feature ) ; }
public void removeEventListener ( ZWaveEventListener eventListener ) { synchronized ( zwaveEventListeners ) { zwaveEventListeners . remove ( eventListener ) ; } }
private static double pythonTime ( ) { return System . currentTimeMillis ( ) / NUM_ ; }
@ SafeVarargs public final void add ( T ... newItems ) { add ( Arrays . asList ( newItems ) ) ; }
public static String quoteIfJavaKeyword ( String name ) { return JVMModuleUtil . quoteIfJavaKeyword ( name ) ; }
public static Recipe fromCursor ( Cursor cursor ) { Recipe recipe = new Recipe ( null ) ; for ( int c = NUM_ ; c < cursor . getColumnCount ( ) ; c ++ ) { String columnName = cursor . getColumnName ( c ) ; if ( columnName . equals ( RecipeTable . ID_COLUMN ) ) { recipe . id = cursor . getString ( c ) ; } else if ( columnName . equals ( RecipeTable . TITLE_COLUMN ) ) { recipe . setTitle ( cursor . getString ( c ) ) ; } else if ( columnName . equals ( RecipeTable . DESCRIPTION_COLUMN ) ) { recipe . setDescription ( cursor . getString ( c ) ) ; } else if ( columnName . equals ( RecipeTable . PHOTO_COLUMN ) ) { recipe . setPhoto ( cursor . getString ( c ) ) ; } else if ( columnName . equals ( RecipeTable . PREP_TIME_COLUMN ) ) { recipe . setPrepTime ( cursor . getString ( c ) ) ; } } return recipe ; }
public static void checkState ( boolean expression , @ Nullable Object errorMessage ) { if ( ! expression ) { throw new IllegalStateException ( String . valueOf ( errorMessage ) ) ; } }
private static < T , ID > void addDropTableStatements ( DatabaseType databaseType , TableInfo < T , ID > tableInfo , List < String > statements ) { List < String > statementsBefore = new ArrayList < String > ( ) ; List < String > statementsAfter = new ArrayList < String > ( ) ; for ( FieldType fieldType : tableInfo . getFieldTypes ( ) ) { databaseType . dropColumnArg ( fieldType , statementsBefore , statementsAfter ) ; } StringBuilder sb = new StringBuilder ( NUM_ ) ; sb . append ( STR_ ) ; databaseType . appendEscapedEntityName ( sb , tableInfo . getTableName ( ) ) ; sb . append ( STR_ ) ; statements . addAll ( statementsBefore ) ; statements . add ( sb . toString ( ) ) ; statements . addAll ( statementsAfter ) ; }
public boolean isLocked ( ) { return ! queue . isEmpty ( ) ; }
public long cguest_time ( ) { return Long . parseLong ( fields [ NUM_ ] ) ; }
private static ClassInfo findOrCreateClass ( String t ) { if ( ! t . endsWith ( STR_ ) ) { return ClassInfo . findOrCreateClass ( t ) ; } else { String baseType = t . substring ( NUM_ , t . indexOf ( STR_ ) ) ; int level = ( t . length ( ) - t . indexOf ( STR_ ) ) / NUM_ ; String s = STR_ ; for ( int i = NUM_ ; i < level ; ++ i ) s += STR_ ; if ( baseType . equals ( STR_ ) ) s += STR_ ; else if ( baseType . equals ( STR_ ) ) s += STR_ ; else s += STR_ + baseType + STR_ ; return ClassInfo . findOrCreateClass ( s ) ; } }
private void resetNotes ( ) { if ( errorInStatus1 ) { if ( editMode ) { statusText1 . setText ( editStatus1 ) ; } else { statusText1 . setText ( stdStatus1 ) ; } errorInStatus1 = BOOL_ ; } resetNotes2 ( ) ; }
@ HLEFunction ( nid = x7ED29E40 , version = NUM_ ) public int sceRtcSetTick ( TPointer timeAddr , TPointer64 ticksAddr ) { long ticks = ticksAddr . getValue ( ) - rtcMagicOffset ; ScePspDateTime time = ScePspDateTime . fromMicros ( ticks ) ; time . write ( timeAddr ) ; return NUM_ ; }
public static void write ( File file , CharSequence data , Charset encoding , boolean append ) throws IOException { String str = data == null ? null : data . toString ( ) ; writeStringToFile ( file , str , encoding , append ) ; }
private void populateNavDrawer ( ) { mNavDrawerItems . clear ( ) ; mNavDrawerItems . add ( NAVDRAWER_ITEM_HOME ) ; mNavDrawerItems . add ( NAVDRAWER_ITEM_SEPARATOR ) ; mNavDrawerItems . add ( NAVDRAWER_ITEM_MY_FOLLOWING ) ; mNavDrawerItems . add ( NAVDRAWER_ITEM_MY_SHOTS ) ; mNavDrawerItems . add ( NAVDRAWER_ITEM_MY_BUCKETS ) ; mNavDrawerItems . add ( NAVDRAWER_ITEM_MY_PROJECTS ) ; mNavDrawerItems . add ( NAVDRAWER_ITEM_MY_TEAMS ) ; mNavDrawerItems . add ( NAVDRAWER_ITEM_MY_LIKES ) ; mNavDrawerItems . add ( NAVDRAWER_ITEM_SEPARATOR_SPECIAL ) ; mNavDrawerItems . add ( NAVDRAWER_ITEM_SETTINGS ) ; createNavDrawerItems ( ) ; }
private BigInteger oddModPow ( BigInteger y , BigInteger z ) { if ( y . equals ( ONE ) ) return this ; if ( signum == NUM_ ) return ZERO ; int [ ] base = mag . clone ( ) ; int [ ] exp = y . mag ; int [ ] mod = z . mag ; int modLen = mod . length ; if ( ( modLen & NUM_ ) != NUM_ ) { int [ ] x = new int [ modLen + NUM_ ] ; System . arraycopy ( mod , NUM_ , x , NUM_ , modLen ) ; mod = x ; modLen ++ ; } int wbits = NUM_ ; int ebits = bitLength ( exp , exp . length ) ; if ( ( ebits != NUM_ ) || ( exp [ NUM_ ] != NUM_ ) ) { while ( ebits > bnExpModThreshTable [ wbits ] ) { wbits ++ ; } } int tblmask = NUM_ << wbits ; int [ ] [ ] table = new int [ tblmask ] [ ] ; for ( int i = NUM_ ; i < tblmask ; i ++ ) table [ i ] = new int [ modLen ] ; long n0 = ( mod [ modLen - NUM_ ] & LONG_MASK ) + ( ( mod [ modLen - NUM_ ] & LONG_MASK ) << NUM_ ) ; long inv = - MutableBigInteger . inverseMod64 ( n0 ) ; int [ ] a = leftShift ( base , base . length , modLen << NUM_ ) ; MutableBigInteger q = new MutableBigInteger ( ) , a2 = new MutableBigInteger ( a ) , b2 = new MutableBigInteger ( mod ) ; b2 . normalize ( ) ; MutableBigInteger r = a2 . divide ( b2 , q ) ; table [ NUM_ ] = r . toIntArray ( ) ; if ( table [ NUM_ ] . length < modLen ) { int offset = modLen - table [ NUM_ ] . length ; int [ ] t2 = new int [ modLen ] ; System . arraycopy ( table [ NUM_ ] , NUM_ , t2 , offset , table [ NUM_ ] . length ) ; table [ NUM_ ] = t2 ; } int [ ] b = montgomerySquare ( table [ NUM_ ] , mod , modLen , inv , null ) ; int [ ] t = Arrays . copyOf ( b , modLen ) ; for ( int i = NUM_ ; i < tblmask ; i ++ ) { table [ i ] = montgomeryMultiply ( t , table [ i - NUM_ ] , mod , modLen , inv , null ) ; } int bitpos = NUM_ << ( ( ebits - NUM_ ) & ( NUM_ - NUM_ ) ) ; int buf = NUM_ ; int elen = exp . length ; int eIndex = NUM_ ; for ( int i = NUM_ ; i <= wbits ; i ++ ) { buf = ( buf << NUM_ ) | ( ( ( exp [ eIndex ] & bitpos ) != NUM_ ) ? NUM_ : NUM_ ) ; bitpos >>>= NUM_ ; if ( bitpos == NUM_ ) { eIndex ++ ; bitpos = NUM_ << ( NUM_ - NUM_ ) ; elen -- ; } } int multpos = ebits ; ebits -- ; boolean isone = BOOL_ ; multpos = ebits - wbits ; while ( ( buf & NUM_ ) == NUM_ ) { buf >>>= NUM_ ; multpos ++ ; } int [ ] mult = table [ buf > > > NUM_ ] ; buf = NUM_ ; if ( multpos == ebits ) isone = BOOL_ ; while ( BOOL_ ) { ebits -- ; buf <<= NUM_ ; if ( elen != NUM_ ) { buf |= ( ( exp [ eIndex ] & bitpos ) != NUM_ ) ? NUM_ : NUM_ ; bitpos >>>= NUM_ ; if ( bitpos == NUM_ ) { eIndex ++ ; bitpos = NUM_ << ( NUM_ - NUM_ ) ; elen -- ; } } if ( ( buf & tblmask ) != NUM_ ) { multpos = ebits - wbits ; while ( ( buf & NUM_ ) == NUM_ ) { buf >>>= NUM_ ; multpos ++ ; } mult = table [ buf > > > NUM_ ] ; buf = NUM_ ; } if ( ebits == multpos ) { if ( isone ) { b = mult . clone ( ) ; isone = BOOL_ ; } else { t = b ; a = montgomeryMultiply ( t , mult , mod , modLen , inv , a ) ; t = a ; a = b ; b = t ; } } if ( ebits == NUM_ ) break ; if ( ! isone ) { t = b ; a = montgomerySquare ( t , mod , modLen , inv , a ) ; t = a ; a = b ; b = t ; } } int [ ] t2 = new int [ NUM_ . modLen ] ; System . arraycopy ( b , NUM_ , t2 , modLen , modLen ) ; b = montReduce ( t2 , mod , modLen , ( int ) inv ) ; t2 = Arrays . copyOf ( b , modLen ) ; return new BigInteger ( NUM_ , t2 ) ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; String childValue ; int childLength ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; nameNode = elementList . item ( NUM_ ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; childValue = child . getData ( ) ; childLength = childValue . length ( ) ; assertEquals ( STR_ , NUM_ , childLength ) ; }
public int nextToken ( ) { while ( index < length && Character . isWhitespace ( expr [ index ] ) ) { index ++ ; } tokenVal = null ; if ( index == length ) return TOKEN_END ; int start = index ; char currentChar = expr [ index ] ; char nextChar = ( char ) NUM_ ; index ++ ; if ( index < length ) nextChar = expr [ index ] ; switch ( currentChar ) { case STR_ : return TOKEN_LBRACE ; case STR_ : return TOKEN_RBRACE ; case STR_ : return TOKEN_EQ ; case STR_ : if ( nextChar == STR_ ) { index ++ ; return TOKEN_NOT_EQ ; } return TOKEN_NOT ; case STR_ : if ( nextChar == STR_ ) { index ++ ; return TOKEN_OR ; } break ; case STR_ : if ( nextChar == STR_ ) { index ++ ; return TOKEN_AND ; } break ; case STR_ : if ( nextChar == STR_ ) { index ++ ; return TOKEN_GE ; } return TOKEN_GT ; case STR_ : if ( nextChar == STR_ ) { index ++ ; return TOKEN_LE ; } return TOKEN_LT ; default : break ; } int end = index ; if ( currentChar == STR_ || currentChar == STR_ ) { char endChar = currentChar ; boolean escaped = BOOL_ ; start ++ ; for ( ; index < length ; index ++ ) { if ( expr [ index ] == STR_ && ! escaped ) { escaped = BOOL_ ; continue ; } if ( expr [ index ] == endChar && ! escaped ) break ; escaped = BOOL_ ; } end = index ; index ++ ; } else if ( currentChar == STR_ ) { char endChar = currentChar ; boolean escaped = BOOL_ ; for ( ; index < length ; index ++ ) { if ( expr [ index ] == STR_ && ! escaped ) { escaped = BOOL_ ; continue ; } if ( expr [ index ] == endChar && ! escaped ) break ; escaped = BOOL_ ; } end = ++ index ; } else { for ( ; index < length ; index ++ ) { if ( isMetaChar ( expr [ index ] ) ) break ; } end = index ; } this . tokenVal = new String ( expr , start , end - start ) ; return TOKEN_STRING ; }
public static Byte [ ] valuesOf ( byte [ ] array ) { Byte [ ] dest = new Byte [ array . length ] ; for ( int i = NUM_ ; i < array . length ; i ++ ) { dest [ i ] = Byte . valueOf ( array [ i ] ) ; } return dest ; }
public void auditCallhome ( OperationTypeEnum auditType , String operationalStatus , String description , Object ... descparams ) { _auditMgr . recordAuditLog ( null , null , EVENT_SERVICE_TYPE , auditType , System . currentTimeMillis ( ) , operationalStatus , description , descparams ) ; }
public static float mean ( float [ ] data , int startIndex , int endIndex ) { float mean = NUM_ ; int total = NUM_ ; startIndex = Math . max ( startIndex , NUM_ ) ; startIndex = Math . min ( startIndex , data . length - NUM_ ) ; endIndex = Math . max ( endIndex , NUM_ ) ; endIndex = Math . min ( endIndex , data . length - NUM_ ) ; if ( startIndex > endIndex ) startIndex = endIndex ; for ( int i = startIndex ; i <= endIndex ; i ++ ) { if ( Float . isNaN ( data [ i ] ) ) throw new IllegalArgumentException ( STR_ ) ; mean += data [ i ] ; total ++ ; } mean /= total ; return mean ; }
public static String constructNTPtime ( long date ) { long ntpTime = NUM_ ; long startTime = ( date / SECONDS_TO_MILLISECONDS_CONVERSION_RATE ) + ntpTime ; return String . valueOf ( startTime ) ; }
protected MediaType selectMediaType ( ServerWebExchange exchange , List < MediaType > producibleTypes ) { List < MediaType > acceptableTypes = getAcceptableTypes ( exchange ) ; producibleTypes = getProducibleTypes ( exchange , producibleTypes ) ; Set < MediaType > compatibleMediaTypes = new LinkedHashSet < > ( ) ; for ( MediaType acceptable : acceptableTypes ) { for ( MediaType producible : producibleTypes ) { if ( acceptable . isCompatibleWith ( producible ) ) { compatibleMediaTypes . add ( selectMoreSpecificMediaType ( acceptable , producible ) ) ; } } } List < MediaType > result = new ArrayList < > ( compatibleMediaTypes ) ; MediaType . sortBySpecificityAndQuality ( result ) ; for ( MediaType mediaType : compatibleMediaTypes ) { if ( mediaType . isConcrete ( ) ) { return mediaType ; } else if ( mediaType . equals ( MediaType . ALL ) || mediaType . equals ( MEDIA_TYPE_APPLICATION_ALL ) ) { return MediaType . APPLICATION_OCTET_STREAM ; } } return null ; }
public void paintBorder ( Component c , Graphics g , int x , int y , int width , int height ) { if ( ! ( c instanceof JPopupMenu ) ) { return ; } Font origFont = g . getFont ( ) ; Color origColor = g . getColor ( ) ; JPopupMenu popup = ( JPopupMenu ) c ; String title = popup . getLabel ( ) ; if ( title == null ) { return ; } g . setFont ( font ) ; FontMetrics fm = SwingUtilities2 . getFontMetrics ( popup , g , font ) ; int fontHeight = fm . getHeight ( ) ; int descent = fm . getDescent ( ) ; int ascent = fm . getAscent ( ) ; Point textLoc = new Point ( ) ; int stringWidth = SwingUtilities2 . stringWidth ( popup , fm , title ) ; textLoc . y = y + ascent + TEXT_SPACING ; textLoc . x = x + ( ( width - stringWidth ) / NUM_ ) ; g . setColor ( background ) ; g . fillRect ( textLoc . x - TEXT_SPACING , textLoc . y - ( fontHeight - descent ) , stringWidth + ( NUM_ . TEXT_SPACING ) , fontHeight - descent ) ; g . setColor ( foreground ) ; SwingUtilities2 . drawString ( popup , g , title , textLoc . x , textLoc . y ) ; MotifGraphicsUtils . drawGroove ( g , x , textLoc . y + TEXT_SPACING , width , GROOVE_HEIGHT , shadowColor , highlightColor ) ; g . setFont ( origFont ) ; g . setColor ( origColor ) ; }
public void ensureCapacity ( int mincap ) { if ( mincap > array . length ) { int newcap = ( ( array . length . NUM_ ) > > NUM_ ) + NUM_ ; int [ ] olddata = array ; array = new int [ newcap < mincap ? mincap : newcap ] ; System . arraycopy ( olddata , NUM_ , array , NUM_ , size ) ; } }
public void invalidateAndUnmap ( ByteBuffer ... bufs ) throws IOException { if ( cleaner != null ) { invalidated = BOOL_ ; barrier . lazySet ( NUM_ ) ; Thread . yield ( ) ; for ( ByteBuffer b : bufs ) { cleaner . freeBuffer ( resourceDescription , b ) ; } } }
public int addDir ( File file ) { if ( ! file . exists ( ) ) { return NUM_ ; } String [ ] names = getNames ( getFiles ( file , STR_ ) ) ; loadClass ( file , names ) ; return NUM_ ; }
private boolean isMineshafterPresent ( ) { try { Class . forName ( STR_ ) ; return BOOL_ ; } catch ( Exception e ) { return BOOL_ ; } }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return BOOL_ ; } if ( ! ( obj instanceof BubbleXYItemLabelGenerator ) ) { return BOOL_ ; } if ( ! super . equals ( obj ) ) { return BOOL_ ; } BubbleXYItemLabelGenerator that = ( BubbleXYItemLabelGenerator ) obj ; if ( ! ObjectUtilities . equal ( this . zFormat , that . zFormat ) ) { return BOOL_ ; } if ( ! ObjectUtilities . equal ( this . zDateFormat , that . zDateFormat ) ) { return BOOL_ ; } return BOOL_ ; }
public static boolean hasElementChild ( Node node ) { NodeList nl = node . getChildNodes ( ) ; Node child = null ; int length = nl . getLength ( ) ; for ( int i = NUM_ ; i < length ; i ++ ) { child = nl . item ( i ) ; if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { return BOOL_ ; } } return BOOL_ ; }
public void delItem ( int index ) { synchronized ( getMenuTreeLock ( ) ) { if ( selectedIndex == index ) { selectItem ( null , BOOL_ ) ; } else if ( selectedIndex > index ) { selectedIndex -- ; } if ( index < items . size ( ) ) { items . remove ( index ) ; } else { if ( log . isLoggable ( PlatformLogger . Level . FINE ) ) { log . fine ( STR_ + index + STR_ + items . size ( ) ) ; } } } updateSize ( ) ; }
public static int countCSSPrimitiveNames ( ) { return ALL_PRIMITIVE_PROPERTY_NAMES . size ( ) ; }
public void printString ( String v ) throws IOException { printString ( v , NUM_ , v . length ( ) ) ; }
private void checkPermission ( Object object , NamespacePermissionEnum [ ] permissions , List < AccessDeniedException > accessDeniedExceptions ) { if ( object != null ) { if ( object instanceof Collection ) { Collection < ? > collection = ( Collection < ? > ) object ; for ( Object element : collection ) { checkPermission ( element , permissions , accessDeniedExceptions ) ; } } else if ( object instanceof String ) { try { checkPermission ( ( String ) object , permissions ) ; } catch ( AccessDeniedException accessDeniedException ) { accessDeniedExceptions . add ( accessDeniedException ) ; } } else { throw new IllegalStateException ( String . format ( STR_ , String . class , Collection . class , object . getClass ( ) ) ) ; } } }
private void displayAllStringDefinedInStringXml ( ) { SimpleIconFontTextView textView = ( SimpleIconFontTextView ) findViewById ( R . id . text_view_2 ) ; List < String > list = new ArrayList < > ( ) ; list . add ( getString ( R . string . cubeicon_gems_logo ) ) ; list . add ( getString ( R . string . cubeicon_android ) ) ; list . add ( getString ( R . string . cubeicon_heart ) ) ; String text = TextUtils . join ( STR_ , list ) ; textView . setText ( text ) ; }
private static Intent createMapActivityIntent ( Context context , URLSpan [ ] urlSpans ) { for ( int span_i = NUM_ ; span_i < urlSpans . length ; span_i ++ ) { URLSpan urlSpan = urlSpans [ span_i ] ; String urlString = urlSpan . getURL ( ) ; if ( urlString . startsWith ( GEO_PREFIX ) ) { Intent geoIntent = new Intent ( Intent . ACTION_VIEW , Uri . parse ( urlString ) ) ; geoIntent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; return geoIntent ; } } return null ; }
private StringBuilder generateParameters ( ) { StringBuilder parameters = new StringBuilder ( ) ; if ( filterMap == null && expandParameters == null ) { return parameters ; } parameters . append ( STR_ ) ; int filterParameterCounter = NUM_ ; if ( filterMap != null && ! filterMap . isEmpty ( ) ) { parameters . append ( FILTER_PREFIX ) ; for ( Map . Entry < String , String > filterEntry : filterMap . entrySet ( ) ) { parameters . append ( String . format ( STR_ , filterEntry . getKey ( ) , filterEntry . getValue ( ) ) ) ; if ( ++ filterParameterCounter < filterMap . size ( ) ) { parameters . append ( STR_ ) ; } } if ( expandParameters != null ) { parameters . append ( STR_ ) ; } } if ( expandParameters != null ) { parameters . append ( EXPAND_PREFIX ) ; Iterator iterator = expandParameters . iterator ( ) ; parameters . append ( String . format ( STR_ , iterator . next ( ) ) ) ; while ( iterator . hasNext ( ) ) { parameters . append ( String . format ( STR_ , iterator . next ( ) ) ) ; } } return parameters ; }
public void writeExif ( Bitmap bmap , OutputStream exifOutStream ) throws IOException { if ( bmap == null || exifOutStream == null ) { throw new IllegalArgumentException ( NULL_ARGUMENT_STRING ) ; } OutputStream s = getExifWriterStream ( exifOutStream ) ; bmap . compress ( Bitmap . CompressFormat . JPEG , NUM_ , s ) ; s . flush ( ) ; }
public void removeAttribute ( int index ) { if ( index >= NUM_ && index < length ) { if ( index < length - NUM_ ) { System . arraycopy ( data , ( index + NUM_ ) . NUM_ , data , index . NUM_ , ( length - index - NUM_ ) . NUM_ ) ; } index = ( length - NUM_ ) . NUM_ ; data [ index ++ ] = null ; data [ index ++ ] = null ; data [ index ++ ] = null ; data [ index ++ ] = null ; data [ index ] = null ; length -- ; } else { badIndex ( index ) ; } }
public static @ CheckForNull @ SlashedClassName String fromFieldSignature ( String signature ) { if ( signature . charAt ( NUM_ ) != STR_ ) { return null ; } return signature . substring ( NUM_ , signature . length ( ) - NUM_ ) ; }
private void paintPreview ( int dx , int dy , float zoomfactor ) { if ( image != null ) { Graphics2D g2 = ( Graphics2D ) getGraphics ( ) ; UColor bg = renderer . getBackgroundColor ( ) ; g2 . setBackground ( new Color ( bg . getRed ( ) , bg . getGreen ( ) , bg . getBlue ( ) , bg . getAlpha ( ) ) ) ; int newWidth = Math . round ( image . getWidth ( null ) . zoomfactor ) ; int newHeight = ( int ) Math . round ( image . getHeight ( null ) . zoomfactor ) ; g2 . drawImage ( image , dx , dy , newWidth , newHeight , null ) ; if ( dx > NUM_ ) g2 . clearRect ( NUM_ , NUM_ , dx , getHeight ( ) ) ; else g2 . clearRect ( getWidth ( ) + dx , NUM_ , getWidth ( ) , getHeight ( ) ) ; if ( dy > NUM_ ) g2 . clearRect ( NUM_ , NUM_ , getWidth ( ) , dy ) ; else g2 . clearRect ( NUM_ , getHeight ( ) + dy , getWidth ( ) , getHeight ( ) ) ; } }
@ RequiresPermission ( Manifest . permission . CAMERA ) public CameraSource start ( ) throws IOException { synchronized ( mCameraLock ) { if ( mCamera != null ) { return this ; } mCamera = createCamera ( ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . HONEYCOMB ) { mDummySurfaceTexture = new SurfaceTexture ( DUMMY_TEXTURE_NAME ) ; mCamera . setPreviewTexture ( mDummySurfaceTexture ) ; } else { mDummySurfaceView = new SurfaceView ( mContext ) ; mCamera . setPreviewDisplay ( mDummySurfaceView . getHolder ( ) ) ; } mCamera . startPreview ( ) ; mProcessingThread = new Thread ( mFrameProcessor ) ; mFrameProcessor . setActive ( BOOL_ ) ; mProcessingThread . start ( ) ; } return this ; }
public synchronized void clear ( ) { mCategories . clear ( ) ; mValues . clear ( ) ; }
public static List < List < Double > > partitionVariable ( List < Double > arr , int chunk ) { int count = NUM_ ; List < List < Double > > ret = new ArrayList < List < Double > > ( ) ; while ( count < arr . size ( ) ) { List < Double > sublist = arr . subList ( count , count + chunk ) ; count += chunk ; ret . add ( sublist ) ; } for ( List < Double > lists : ret ) { if ( lists . size ( ) < chunk ) ret . remove ( lists ) ; } return ret ; }
private static void updateWindowUI ( Window window ) { SwingUtilities . updateComponentTreeUI ( window ) ; Window ownedWins [ ] = window . getOwnedWindows ( ) ; for ( Window ownedWin : ownedWins ) { updateWindowUI ( ownedWin ) ; } }
public void clearResults ( ) { if ( resultList != null ) { resultList . clear ( ) ; mAdapter . notifyDataSetChanged ( ) ; } listener . onSearchCleared ( ) ; }
public ArrayList < ConstraintWidget > findWidgets ( WidgetContainer container , int x , int y , int width , int height ) { ArrayList < ConstraintWidget > found = new ArrayList < > ( ) ; Rectangle area = new Rectangle ( x , y , width , height ) ; for ( ConstraintWidget widget : container . getChildren ( ) ) { WidgetCompanion companion = ( WidgetCompanion ) widget . getCompanionWidget ( ) ; WidgetDecorator decorator = companion . getWidgetDecorator ( WidgetDecorator . BLUEPRINT_STYLE ) ; if ( ! decorator . isVisible ( ) ) { continue ; } Rectangle bounds = new Rectangle ( widget . getDrawX ( ) , widget . getDrawY ( ) , widget . getWidth ( ) , widget . getHeight ( ) ) ; if ( area . intersects ( bounds ) ) { found . add ( widget ) ; } } return found ; }
public final void printSymbol ( CharSequence text ) throws IOException { if ( text == null ) { appendAscii ( STR_ ) ; } else if ( text . length ( ) == NUM_ ) { throw new EmptySymbolException ( ) ; } else if ( symbolNeedsQuoting ( text , BOOL_ ) ) { appendAscii ( STR_ ) ; printCodePoints ( text , SYMBOL_ESCAPE_CODES ) ; appendAscii ( STR_ ) ; } else { appendAscii ( text ) ; } }
public static ShoppingCartItem makeItem ( Integer cartLocation , GenericValue product , BigDecimal selectedAmount , BigDecimal quantity , BigDecimal unitPrice , Timestamp reservStart , BigDecimal reservLength , BigDecimal reservPersons , Timestamp shipBeforeDate , Timestamp shipAfterDate , Map < String , GenericValue > additionalProductFeatureAndAppls , Map < String , Object > attributes , String prodCatalogId , ProductConfigWrapper configWrapper , String itemType , ShoppingCart . ShoppingCartItemGroup itemGroup , LocalDispatcher dispatcher , ShoppingCart cart , Boolean triggerExternalOpsBool , Boolean triggerPriceRulesBool , GenericValue parentProduct , Boolean skipInventoryChecks , Boolean skipProductChecks ) throws CartItemModifyException { return makeItem ( cartLocation , product , selectedAmount , quantity , unitPrice , reservStart , reservLength , reservPersons , null , null , shipBeforeDate , shipAfterDate , additionalProductFeatureAndAppls , attributes , prodCatalogId , configWrapper , itemType , itemGroup , dispatcher , cart , triggerExternalOpsBool , triggerPriceRulesBool , parentProduct , skipInventoryChecks , skipProductChecks ) ; }
@ Override public String toString ( ) { Map < Assignment , Double > sortedTable = InferenceUtils . getNBest ( table , Math . max ( table . size ( ) , NUM_ ) ) ; String str = STR_ ; for ( Entry < Assignment , Double > entry : sortedTable . entrySet ( ) ) { String prob = StringUtils . getShortForm ( entry . getValue ( ) ) ; str += STR_ + entry . getKey ( ) + STR_ + prob + STR_ ; } return ( str . length ( ) > NUM_ ) ? str . substring ( NUM_ , str . length ( ) - NUM_ ) : str ; }
protected final void updateBorderText ( final String text ) { Preconditions . checkNotNull ( text , STR_ ) ; m_titledBorder . setTitle ( text ) ; updateUI ( ) ; }
private void addClasses ( Class < ? > [ ] classes , HashSet < Class < ? > > result , String fieldName ) { if ( classes == null || classes . length == NUM_ ) Error . classesAbsent ( fieldName , configuredClass ) ; for ( Class < ? > classe : classes ) result . add ( classe ) ; }
public void resetReferences ( ) { if ( _refs != null ) _refs . clear ( ) ; }
public static BigInteger decodeMPI ( byte [ ] mpi , boolean hasLength ) { byte [ ] buf ; if ( hasLength ) { int length = ( int ) readUint32BE ( mpi , NUM_ ) ; buf = new byte [ length ] ; System . arraycopy ( mpi , NUM_ , buf , NUM_ , length ) ; } else buf = mpi ; if ( buf . length == NUM_ ) return BigInteger . ZERO ; boolean isNegative = ( buf [ NUM_ ] & x80 ) == x80 ; if ( isNegative ) buf [ NUM_ ] &= x7f ; BigInteger result = new BigInteger ( buf ) ; return isNegative ? result . negate ( ) : result ; }
public void schemaChanged ( String serviceName , String version ) { synchronized ( mapRealmToFormat ) { mapRealmToFormat . remove ( ROOT ) ; } }
public void sort ( DTMIterator v , Vector keys , XPathContext support ) throws javax . xml . transform . TransformerException { m_keys = keys ; int n = v . getLength ( ) ; Vector nodes = new Vector ( ) ; for ( int i = NUM_ ; i < n ; i ++ ) { NodeCompareElem elem = new NodeCompareElem ( v . item ( i ) ) ; nodes . addElement ( elem ) ; } Vector scratchVector = new Vector ( ) ; mergesort ( nodes , scratchVector , NUM_ , n - NUM_ , support ) ; for ( int i = NUM_ ; i < n ; i ++ ) { v . setItem ( ( ( NodeCompareElem ) nodes . elementAt ( i ) ) . m_node , i ) ; } v . setCurrentPos ( NUM_ ) ; }
protected DateTimeData parse ( String str ) throws SchemaDateTimeException { DateTimeData date = new DateTimeData ( str , this ) ; int len = str . length ( ) ; date . year = YEAR ; date . day = DAY ; if ( str . charAt ( NUM_ ) != STR_ || str . charAt ( NUM_ ) != STR_ ) { throw new SchemaDateTimeException ( STR_ + str ) ; } int stop = NUM_ ; date . month = parseInt ( str , NUM_ , stop ) ; if ( str . length ( ) >= stop + NUM_ && str . charAt ( stop ) == STR_ && str . charAt ( stop + NUM_ ) == STR_ ) { stop += NUM_ ; } if ( stop < len ) { if ( ! isNextCharUTCSign ( str , stop , len ) ) { throw new SchemaDateTimeException ( STR_ + str ) ; } else { getTimeZone ( str , date , stop , len ) ; } } validateDateTime ( date ) ; saveUnnormalized ( date ) ; if ( date . utc != NUM_ && date . utc != STR_ ) { normalize ( date ) ; } date . position = NUM_ ; return date ; }
private void addToQueue ( SerialMessage serialMessage ) { if ( serialMessage == null ) { return ; } if ( ! msgQueue . contains ( serialMessage ) && msgQueue . remainingCapacity ( ) > NUM_ ) { msgQueue . add ( serialMessage ) ; } sendMessage ( ) ; }
private DBID stringToDBID ( String query ) { return DBIDUtil . importInteger ( Integer . valueOf ( query ) ) ; }
@ Override public final void writeShort ( int v ) throws IOException { work [ NUM_ ] = ( byte ) v ; work [ NUM_ ] = ( byte ) ( v > > NUM_ ) ; dis . write ( work , NUM_ , NUM_ ) ; }
final public void println ( long v ) { Writer out = this . out ; if ( out == null ) return ; print ( v ) ; try { out . write ( _newline , NUM_ , _newline . length ) ; } catch ( IOException e ) { log . log ( Level . FINE , e . toString ( ) , e ) ; } }
public ThriftServiceMetadata ( Class < ? > serviceType ) { requireNonNull ( serviceType , STR_ ) ; interfaces = init ( null , Collections . singleton ( serviceType ) ) ; }
public WritableRaster createCompatibleWritableRaster ( int w , int h ) { if ( w <= NUM_ || h <= NUM_ ) { throw new RasterFormatException ( STR_ + ( ( w <= NUM_ ) ? STR_ : STR_ ) ) ; } SampleModel sm = sampleModel . createCompatibleSampleModel ( w , h ) ; return new BytePackedRaster ( sm , new Point ( NUM_ , NUM_ ) ) ; }
public static Response invalidEntity ( ConstraintViolationException e ) { StringBuilder errorMessage = new StringBuilder ( ) ; boolean firstPass = BOOL_ ; for ( ConstraintViolation error : e . getConstraintViolations ( ) ) { if ( ! firstPass ) { errorMessage . append ( STR_ ) ; } errorMessage . append ( String . format ( STR_ , error . getPropertyPath ( ) , error . getMessage ( ) , error . getInvalidValue ( ) ) ) ; firstPass = BOOL_ ; } ExternalException externalException = new ExternalException ( ErrorCode . INVALID_ENTITY , errorMessage . toString ( ) , null ) ; return externalException ( externalException ) ; }
public String checkStartBlock ( int mode ) { if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + getDisplayName ( ) + STR_ ) ; BlockOrder bo = _orders . get ( NUM_ ) ; OBlock block = bo . getBlock ( ) ; String msg = block . allocate ( this ) ; if ( msg != null ) { return msg ; } msg = bo . setPath ( this ) ; if ( msg != null ) { return msg ; } int state = block . getState ( ) ; if ( ( state & OBlock . DARK ) != NUM_ || _tempRunBlind ) { msg = Bundle . getMessage ( STR_ , block . getDisplayName ( ) ) ; } else if ( ( state & OBlock . OCCUPIED ) == NUM_ ) { if ( mode == MODE_LEARN ) { msg = STR_ ; } else { msg = STR_ ; } msg = Bundle . getMessage ( msg , getTrainName ( ) , block . getDisplayName ( ) ) ; } else { TrackerTableAction . stopTrackerIn ( block ) ; } return msg ; }
private void parseSwitch ( int indent , boolean firstContent , String header , Layout layout , List < Elem > elems ) { TokenStream tokens = new TokenStream ( header ) ; Elem selector = parseExpr ( tokens ) ; tokens . checkAtEnd ( ) ; ImmutableList . Builder < Case > cases = ImmutableList . builder ( ) ; List < Elem > defaultElems = null ; boolean done ; String line = getNextLine ( ) ; Matcher matcher = COMMAND_LINE . matcher ( line ) ; String command ; String rest ; if ( matcher . find ( ) ) { command = matcher . group ( COMMAND_NAME_GROUP ) ; rest = line . substring ( matcher . end ( ) ) ; done = BOOL_ ; } else { error ( STR_ ) ; done = BOOL_ ; command = null ; rest = null ; } while ( ! done ) { switch ( command ) { case END_COMMAND : checkHeaderEmpty ( command , rest ) ; done = BOOL_ ; break ; case DEFAULT_COMMAND : checkHeaderEmpty ( command , rest ) ; if ( defaultElems != null ) { error ( STR_ ) ; } defaultElems = parseUntil ( indent , layout , END_COMMAND ) ; command = lastTerminator ; rest = lastTerminatorHeader ; done = lastTerminator == null ; break ; case CASE_COMMAND : tokens = new TokenStream ( rest ) ; Elem value = parseExpr ( tokens ) ; tokens . checkAtEnd ( ) ; List < Elem > caseElems = parseUntil ( indent , layout , END_COMMAND , CASE_COMMAND , DEFAULT_COMMAND ) ; if ( value != null ) { cases . add ( Case . create ( value , caseElems ) ) ; } command = lastTerminator ; rest = lastTerminatorHeader ; done = lastTerminator == null ; break ; default : unexpectedCommandError ( command ) ; done = BOOL_ ; break ; } } if ( selector != null ) { elems . add ( Block . create ( ! firstContent , Switch . create ( input . location ( ) , selector , cases . build ( ) , defaultElems ) ) ) ; } }
public void init ( String prefix , java . net . URL url ) { try { java . io . InputStream in = url . openStream ( ) ; Properties props = new Properties ( ) ; props . load ( in ) ; init ( getLayers ( prefix , props ) ) ; } catch ( java . net . MalformedURLException murle ) { logger . warning ( STR_ + url + STR_ ) ; } catch ( java . io . IOException e ) { logger . warning ( STR_ ) ; } }
boolean suppressedBy ( DNSIncoming msg ) { try { for ( DNSRecord answer : msg . getAllAnswers ( ) ) { if ( suppressedBy ( answer ) ) { return BOOL_ ; } } return BOOL_ ; } catch ( ArrayIndexOutOfBoundsException e ) { logger . log ( Level . WARNING , STR_ + msg + STR_ , e ) ; return BOOL_ ; } }
public static Properties createProperties ( final Map < String , String > map ) { Properties properties = new Properties ( ) ; if ( ! ( map == null || map . isEmpty ( ) ) ) { for ( Entry < String , String > entry : map . entrySet ( ) ) { properties . setProperty ( entry . getKey ( ) , entry . getValue ( ) ) ; } } return properties ; }
public Node selectFirst ( String query ) { List < Node > selectedNodes = select ( query ) ; if ( selectedNodes . isEmpty ( ) ) { return null ; } return selectedNodes . get ( NUM_ ) ; }
public static String [ ] stringArrayFromProperties ( Properties p , String propName , String tok ) { String [ ] ret = null ; String raw = p . getProperty ( propName ) ; if ( raw != null && raw . length ( ) > NUM_ ) { try { StringTokenizer token = new StringTokenizer ( raw , tok ) ; int numPaths = token . countTokens ( ) ; ret = new String [ numPaths ] ; for ( int i = NUM_ ; i < numPaths ; i ++ ) { ret [ i ] = token . nextToken ( ) ; } return ret ; } catch ( java . util . NoSuchElementException e ) { e . printStackTrace ( ) ; } } return ret ; }
private static int compareLocales ( Locale primary , Locale other ) { final String lang = primary . getLanguage ( ) ; if ( ( lang == null ) || ! lang . equals ( other . getLanguage ( ) ) ) { return NUM_ ; } final String country = primary . getCountry ( ) ; if ( ( country == null ) || ! country . equals ( other . getCountry ( ) ) ) { return NUM_ ; } final String variant = primary . getVariant ( ) ; if ( ( variant == null ) || ! variant . equals ( other . getVariant ( ) ) ) { return NUM_ ; } return NUM_ ; }
void queryReadResult ( PreparedStatement prep ) throws SQLException { ResultSet rs = prep . executeQuery ( ) ; ResultSetMetaData meta = rs . getMetaData ( ) ; int columnCount = meta . getColumnCount ( ) ; while ( rs . next ( ) ) { for ( int i = NUM_ ; i < columnCount ; i ++ ) { rs . getString ( i + NUM_ ) ; } } }
public static < V > boolean addDistinctEntry ( List < V > sourceList , V entry ) { return ( sourceList != null && ! sourceList . contains ( entry ) ) ? sourceList . add ( entry ) : BOOL_ ; }
public boolean equals ( Object obj ) { if ( obj instanceof MSort ) { MSort ms = ( MSort ) obj ; if ( data == ms . data ) return BOOL_ ; } return BOOL_ ; }
public static void endTransaction ( final CConnection connection ) throws SQLException { endTransaction ( connection . getConnection ( ) ) ; }
public CCrossReferencesPanel ( ) { super ( new BorderLayout ( ) ) ; m_table . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; add ( new JScrollPane ( m_table ) ) ; m_table . addMouseListener ( new InternalMouseListener ( ) ) ; }
private void doubleCapacity ( ) { int p = head ; int n = elements . length ; int r = n - p ; int newCapacity = n << NUM_ ; if ( newCapacity < NUM_ ) throw new IllegalStateException ( STR_ ) ; Object [ ] a = new Object [ newCapacity ] ; System . arraycopy ( elements , p , a , NUM_ , r ) ; System . arraycopy ( elements , NUM_ , a , r , p ) ; elements = a ; head = NUM_ ; tail = n ; }
private void changeOpenAMDebugFolder ( String newOpenAMDebugFolder ) { SystemPropertiesManager . initializeProperties ( DebugConstants . CONFIG_DEBUG_DIRECTORY , newOpenAMDebugFolder ) ; }
protected String computeFullUrl ( URL baseUrl , String link ) { if ( link == null || link . length ( ) == NUM_ ) { return null ; } if ( ! link . startsWith ( STR_ ) ) { if ( link . startsWith ( STR_ ) ) { link = baseUrl . getProtocol ( ) + STR_ + baseUrl . getAuthority ( ) + link ; } else { if ( link . contains ( STR_ ) ) { return null ; } String path = baseUrl . getPath ( ) ; if ( ! path . endsWith ( STR_ ) ) { int sep = path . lastIndexOf ( STR_ ) ; String file = path . substring ( sep + NUM_ ) ; if ( file . contains ( STR_ ) || file . contains ( STR_ ) ) path = path . substring ( NUM_ , sep ) ; } link = baseUrl . getProtocol ( ) + STR_ + baseUrl . getAuthority ( ) + path + STR_ + link ; } } link = normalizeUrlEnding ( link ) ; String l = link . toLowerCase ( Locale . ROOT ) ; if ( l . endsWith ( STR_ ) || l . endsWith ( STR_ ) || l . endsWith ( STR_ ) || l . endsWith ( STR_ ) ) { return null ; } return link ; }
private void loadManifest ( ) { if ( _isManifestRead ) return ; synchronized ( this ) { if ( _isManifestRead ) return ; try { _manifest = _jarPath . getManifest ( ) ; if ( _manifest == null ) return ; Attributes attr = _manifest . getMainAttributes ( ) ; if ( attr != null ) addManifestPackage ( STR_ , attr ) ; Map < String , Attributes > entries = _manifest . getEntries ( ) ; for ( Map . Entry < String , Attributes > entry : entries . entrySet ( ) ) { String pkg = entry . getKey ( ) ; attr = entry . getValue ( ) ; if ( attr == null ) continue ; addManifestPackage ( pkg , attr ) ; } } catch ( IOException e ) { log . log ( Level . WARNING , e . toString ( ) , e ) ; } finally { _isManifestRead = BOOL_ ; } } }
public ReferenceBinding [ ] convertToRawTypes ( ReferenceBinding [ ] originalTypes , boolean forceErasure , boolean forceRawEnclosingType ) { if ( originalTypes == null ) return null ; ReferenceBinding [ ] convertedTypes = originalTypes ; for ( int i = NUM_ , length = originalTypes . length ; i < length ; i ++ ) { ReferenceBinding originalType = originalTypes [ i ] ; ReferenceBinding convertedType = ( ReferenceBinding ) convertToRawType ( forceErasure ? originalType . erasure ( ) : originalType , forceRawEnclosingType ) ; if ( convertedType != originalType ) { if ( convertedTypes == originalTypes ) { System . arraycopy ( originalTypes , NUM_ , convertedTypes = new ReferenceBinding [ length ] , NUM_ , i ) ; } convertedTypes [ i ] = convertedType ; } else if ( convertedTypes != originalTypes ) { convertedTypes [ i ] = originalType ; } } return convertedTypes ; }
public void addColumn ( int idx , Column column ) { if ( column != null ) { columns . add ( idx , column ) ; } }
public void readData ( DataInput din ) throws IOException { reference = din . readUnsignedShort ( ) ; andMask = din . readUnsignedShort ( ) ; orMask = din . readUnsignedShort ( ) ; }
boolean removeDisplay ( Display display ) { return m_displays . remove ( display ) ; }
public double nextGaussian ( ) { if ( mHaveNextNextGaussian ) { mHaveNextNextGaussian = BOOL_ ; return mNextNextGaussian ; } else { double v1 , v2 , s ; do { v1 = NUM_ . nextDouble ( ) - NUM_ ; v2 = NUM_ . nextDouble ( ) - NUM_ ; s = v1 . v1 + v2 . v2 ; } while ( s >= NUM_ || s == NUM_ ) ; final double multiplier = StrictMath . sqrt ( - NUM_ . StrictMath . log ( s ) / s ) ; mNextNextGaussian = v2 . multiplier ; mHaveNextNextGaussian = BOOL_ ; return v1 . multiplier ; } }
private void fireEvent ( final IRunningQuery q ) { if ( q == null ) throw new IllegalArgumentException ( ) ; if ( listeners . isEmpty ( ) ) { return ; } final IRunningQueryListener [ ] a = listeners . toArray ( new IRunningQueryListener [ NUM_ ] ) ; for ( IRunningQueryListener l : a ) { final IRunningQueryListener listener = l ; try { listener . notify ( q ) ; } catch ( Throwable t ) { if ( InnerCause . isInnerCause ( t , InterruptedException . class ) ) { throw new RuntimeException ( t ) ; } log . error ( t , t ) ; } } }
private void updateContactHeaderPort ( int localPort , SIPMessage message ) { if ( message != null && message . getContactHeader ( ) != null ) { ContactHeader contactHeader = message . getContactHeader ( ) ; Address contactAddress = contactHeader . getAddress ( ) ; contactAddress . setPort ( localPort ) ; } }
public static AndroidHttpClient newInstance ( String userAgent ) { return newInstance ( userAgent , null ) ; }
@ Nullable GridCacheMvccCandidate addEntry ( GridLocalCacheEntry entry ) throws GridCacheEntryRemovedException { GridCacheMvccCandidate c = entry . addLocal ( threadId , lockVer , null , null , timeout , ! inTx ( ) , inTx ( ) , implicitSingle ( ) , BOOL_ ) ; entries . add ( entry ) ; if ( c == null && timeout < NUM_ ) { if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + entry ) ; onFailed ( ) ; return null ; } if ( c != null ) { entry . readyLocal ( c ) ; } return c ; }
@ Override public void visitVertex ( StreetRouter . State state ) { Integer edgeIdx = state . backEdge ; if ( ! ( edgeIdx == null || edgeIdx == - NUM_ ) ) { EdgeStore . Edge edge = edgeStore . getCursor ( edgeIdx ) ; GeoJsonFeature feature = new GeoJsonFeature ( edge . getGeometry ( ) ) ; feature . addProperty ( STR_ , state . weight ) ; feature . addProperty ( STR_ , state . streetMode ) ; feature . addProperty ( STR_ , state . backEdge ) ; features . add ( feature ) ; } }
public void test_BSBM_Q1_noSolutions ( ) throws Exception { final TestHelper helper = new TestHelper ( STR_ , STR_ , new String [ ] { } , STR_ ) ; assertSameJoinOrder ( new int [ ] { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } , helper ) ; }
public static void deleteFileOrLog ( File file ) { if ( ! file . delete ( ) ) { logger . warn ( FAILED_DELETING_FILE + file . getPath ( ) ) ; } }
public synchronized void remove ( int index ) { super . remove ( index ) ; mMaxValues . remove ( index ) ; }
public GitlabGroupMember addGroupMember ( GitlabGroup group , GitlabUser user , GitlabAccessLevel accessLevel ) throws IOException { return addGroupMember ( group . getId ( ) , user . getId ( ) , accessLevel ) ; }
protected Logger ( String name , String resourceBundleName ) { super ( name , resourceBundleName ) ; }
@ Override public void increment ( double coord , short val ) { int bin = getBinNr ( coord ) ; if ( bin < NUM_ ) { if ( size - bin > data . length ) { short [ ] tmpdata = new short [ growSize ( data . length , size - bin ) ] ; System . arraycopy ( data , NUM_ , tmpdata , - bin , size ) ; data = tmpdata ; } else { System . arraycopy ( data , NUM_ , data , - bin , size ) ; Arrays . fill ( data , NUM_ , - bin , ( short ) NUM_ ) ; } data [ NUM_ ] = val ; assert ( data . length >= size - bin ) ; offset -= bin ; size -= bin ; } else if ( bin >= data . length ) { short [ ] tmpdata = new short [ growSize ( data . length , bin + NUM_ ) ] ; System . arraycopy ( data , NUM_ , tmpdata , NUM_ , size ) ; tmpdata [ bin ] = val ; data = tmpdata ; size = bin + NUM_ ; max = Double . MAX_VALUE ; } else { if ( bin >= size ) { size = bin + NUM_ ; } data [ bin ] += val ; } }
public static void checkArgument ( boolean expression , Object errorMessage ) { if ( ! expression ) { throw new IllegalArgumentException ( String . valueOf ( errorMessage ) ) ; } }
default Document putAll ( Map < ? extends CharSequence , Object > fields ) { if ( fields != null ) { for ( Map . Entry < ? extends CharSequence , Object > entry : fields . entrySet ( ) ) { set ( entry . getKey ( ) , entry . getValue ( ) ) ; } } return this ; }
private boolean containsIgnoreCase ( List < String > stringlist , String match ) { for ( String s : stringlist ) { if ( s . equalsIgnoreCase ( match ) ) { return BOOL_ ; } } return BOOL_ ; }
public static double computeMAD ( double [ ] x , double median ) { for ( int i = NUM_ ; i < x . length ; i ++ ) { x [ i ] = Math . abs ( x [ i ] - median ) ; } double mad = QuickSelect . median ( x ) ; if ( ! ( mad > NUM_ ) ) { double min = Double . POSITIVE_INFINITY ; for ( double xi : x ) { if ( xi > NUM_ && xi < min ) { min = xi ; } } if ( min < Double . POSITIVE_INFINITY ) { mad = min ; } else { mad = NUM_ ; } } return mad ; }
private static < T > void initializeKnownPlugins ( final T pluginInterface , final IPluginRegistry < IPlugin < T > > registry , final List < PluginConfigItem > xmlPluginOrder , final List < Pair < IPlugin < T > , PluginStatus > > validatedPlugins , final List < Pair < IPlugin < T > , Exception > > initializedPlugins , final Set < Long > processedPlugins ) { for ( final PluginConfigItem pt : xmlPluginOrder ) { processedPlugins . add ( pt . getGUID ( ) ) ; final IPlugin < T > plugin = findPlugin ( validatedPlugins , pt . getGUID ( ) ) ; if ( plugin != null ) { if ( pt . isLoad ( ) ) { initializePlugin ( plugin , pluginInterface , registry , initializedPlugins ) ; } else { registry . addDisabledPlugin ( plugin , DisabledPluginReason . NotLoaded ) ; } } } }
public static void sessionStop ( ) { if ( mProcess == null ) return ; mProcess . destroy ( ) ; mProcess = null ; }
public static void keepAlive ( final boolean keepAlive ) { setProperty ( STR_ , Boolean . toString ( keepAlive ) ) ; }
public static Request newUploadVideoRequest ( Session session , File file , Callback callback ) throws FileNotFoundException { ParcelFileDescriptor descriptor = ParcelFileDescriptor . open ( file , ParcelFileDescriptor . MODE_READ_ONLY ) ; Bundle parameters = new Bundle ( NUM_ ) ; parameters . putParcelable ( file . getName ( ) , descriptor ) ; return new Request ( session , MY_VIDEOS , parameters , HttpMethod . POST , callback ) ; }
private static byte [ ] readCheckedBytes ( byte [ ] buffer , int dataSize ) throws InvalidProtocolBufferNanoException { CheckedMessage wrapper = new CheckedMessage ( ) ; MessageNano . mergeFrom ( wrapper , buffer , NUM_ , dataSize ) ; CRC32 checksum = new CRC32 ( ) ; checksum . update ( wrapper . payload ) ; if ( wrapper . checksum != checksum . getValue ( ) ) { throw new InvalidProtocolBufferNanoException ( STR_ ) ; } return wrapper . payload ; }
private MulticastSocket createSocket ( ) throws IOException { MulticastSocket sock = new MulticastSocket ( mcastPort ) ; sock . setLoopbackMode ( BOOL_ ) ; if ( sockItf != null ) sock . setInterface ( sockItf ) ; if ( sock . getLoopbackMode ( ) ) U . warn ( log , STR_ + STR_ ) ; sock . joinGroup ( mcastGrp ) ; if ( ttl != - NUM_ ) sock . setTimeToLive ( ttl ) ; return sock ; }
void copyNodeStructure ( ArrayList < Node > destination ) { while ( destination . size ( ) < nodes . size ( ) ) destination . add ( new Node ( ) ) ; while ( destination . size ( ) > nodes . size ( ) ) destination . remove ( NUM_ ) ; int n = nodes . size ( ) ; for ( int i = NUM_ ; i < n ; i ++ ) { Node node0 = nodes . get ( i ) ; Node node1 = destination . get ( i ) ; node1 . heightParameter = node0 . heightParameter ; node1 . rateParameter = node0 . rateParameter ; node1 . traitParameter = node0 . traitParameter ; node1 . partitioning = node0 . partitioning ; node1 . taxon = node0 . taxon ; node1 . bifurcation = node0 . bifurcation ; node1 . number = node0 . number ; node1 . myHashCode = node0 . myHashCode ; if ( node0 . leftParent != null ) { node1 . leftParent = storedNodes . get ( nodes . indexOf ( node0 . leftParent ) ) ; } else { node1 . leftParent = null ; } if ( node0 . rightParent != null ) { node1 . rightParent = storedNodes . get ( nodes . indexOf ( node0 . rightParent ) ) ; } else { node1 . rightParent = null ; } if ( node0 . leftChild != null ) { node1 . leftChild = storedNodes . get ( nodes . indexOf ( node0 . leftChild ) ) ; } else { node1 . leftChild = null ; } if ( node0 . rightChild != null ) { node1 . rightChild = storedNodes . get ( nodes . indexOf ( node0 . rightChild ) ) ; } else { node1 . rightChild = null ; } } }
protected void checkSelectedSubsetMetaData ( ExampleSetMetaData subsetMetaData ) { }
private void validateWill ( String dest , Object payload ) { if ( ( dest == null ) || ( payload == null ) ) { throw new IllegalArgumentException ( ) ; } MqttTopic . validate ( dest , BOOL_ ) ; }
public BerInputStream ( InputStream in , int initialSize ) throws IOException { this . in = in ; buffer = new byte [ initialSize ] ; next ( ) ; if ( length != INDEFINIT_LENGTH ) { if ( buffer . length < ( length + offset ) ) { byte [ ] newBuffer = new byte [ length + offset ] ; System . arraycopy ( buffer , NUM_ , newBuffer , NUM_ , offset ) ; buffer = newBuffer ; } } else { isIndefinedLength = BOOL_ ; throw new ASN1Exception ( STR_ ) ; } }
private Member nextMember ( Member . Type type ) { return new TestMember ( type , new Address ( STR_ , ++ port ) , new Address ( STR_ , port + NUM_ ) ) ; }
protected void encodeLineSuffix ( OutputStream aStream ) throws IOException { pStream . println ( ) ; }
boolean isSystemFont ( ) { return systemFont ; }
public void addToBeLoaded ( final String url ) { if ( toBeLoaded == null ) { toBeLoaded = new ArrayList < String > ( ) ; } if ( StringUtils . isNotBlank ( url ) ) { toBeLoaded . add ( url ) ; } }
default Document putAll ( Iterator < Field > fields ) { while ( fields . hasNext ( ) ) { Field field = fields . next ( ) ; setValue ( field . getName ( ) , field . getValue ( ) ) ; } return this ; }
public AppraiseGitReviewClient ( Repository repo ) { this . repo = repo ; this . author = new PersonIdent ( repo ) ; }
public RootBlockView ( final boolean rootBlock0 , final ByteBuffer buf , final ChecksumUtility checker ) throws RootBlockException { if ( buf == null ) throw new IllegalArgumentException ( ) ; if ( buf . remaining ( ) != SIZEOF_ROOT_BLOCK ) { throw new IllegalArgumentException ( STR_ + SIZEOF_ROOT_BLOCK + STR_ + buf . remaining ( ) ) ; } this . buf = buf . asReadOnlyBuffer ( ) ; this . rootBlock0 = rootBlock0 ; switch ( getStoreType ( ) ) { case RW : { am = new RWAddressManager ( null ) ; break ; } case WORM : { final int offsetBits = getOffsetBits ( ) ; am = new WormAddressManager ( offsetBits ) ; break ; } default : throw new RootBlockException ( STR_ + getStoreType ( ) ) ; } if ( checker == null ) { log . warn ( STR_ ) ; } this . checker = checker ; valid ( ) ; }
protected SOAPRequest createSOAPRequest ( final String methodName , final SOAPMethodRequestWriter requestWriter ) { final PostMethod method = new PostMethod ( endpoint . toString ( ) ) ; method . setContentChunked ( BOOL_ ) ; setRequestHeaders ( method , methodName ) ; final SOAPRequestEntity requestEntity = buildRequestEntity ( methodName , requestWriter ) ; requestEntity . setSOAPHeaderProvider ( soapHeaderProvider ) ; final BufferedSOAPRequestEntity bufferedEntity = new BufferedSOAPRequestEntity ( requestEntity ) ; method . setRequestEntity ( bufferedEntity ) ; return new SOAPRequest ( method , requestEntity ) ; }
@ SuppressWarnings ( STR_ ) @ Test public void innerEnum ( ) { Class < ? > pc = PlayingCard . class ; List < Enum < ? > > include = new ArrayList < > ( ) ; List < Enum < ? > > exclude = new ArrayList < > ( ) ; for ( Class < ? > c : pc . getDeclaredClasses ( ) ) { int mods = c . getModifiers ( ) ; if ( c . isEnum ( ) ) { if ( Modifier . isPublic ( mods ) ) { include . addAll ( asList ( c . getEnumConstants ( ) ) ) ; } else { exclude . addAll ( asList ( c . getEnumConstants ( ) ) ) ; } } } Set < TypedOperation > actual = getConcreteOperations ( pc ) ; assertEquals ( STR_ , include . size ( ) + NUM_ , actual . size ( ) ) ; for ( Enum < ? > e : include ) { assertTrue ( STR_ + e . name ( ) + STR_ , actual . contains ( createEnumOperation ( e ) ) ) ; } for ( Enum < ? > e : exclude ) { assertFalse ( STR_ + e . name ( ) + STR_ , actual . contains ( createEnumOperation ( e ) ) ) ; } }
public String toURI ( ) { CharArrayBuffer buffer = new CharArrayBuffer ( NUM_ ) ; buffer . append ( this . schemeName ) ; buffer . append ( STR_ ) ; buffer . append ( this . hostname ) ; if ( this . port != - NUM_ ) { buffer . append ( STR_ ) ; buffer . append ( Integer . toString ( this . port ) ) ; } return buffer . toString ( ) ; }
public void testWildcardsDoesNotNeedTwoDots ( ) throws Exception { String cert = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; CertificateFactory cf = CertificateFactory . getInstance ( STR_ ) ; InputStream in = new ByteArrayInputStream ( cert . getBytes ( STR_ ) ) ; X509Certificate x509 = ( X509Certificate ) cf . generateCertificate ( in ) ; mySSLSession session = new mySSLSession ( new X509Certificate [ ] { x509 } ) ; HostnameVerifier verifier = HttpsURLConnection . getDefaultHostnameVerifier ( ) ; assertTrue ( verifier . verify ( STR_ , session ) ) ; }
public static boolean inTargetDir ( File file ) { return inTargetDir ( file . toPath ( ) ) ; }
public final boolean skipAny ( char c , CharSequence csq ) { int i = index ; int n = csq . length ( ) ; for ( ; ( i < n ) && ( csq . charAt ( i ) == c ) ; i ++ ) { } if ( i == index ) return BOOL_ ; index = i ; return BOOL_ ; }
private void generateUniformIntegerExamples ( Instances format , int numInstances , SubspaceClusterDefinition cl , String cName ) { Instance example = null ; int numAtts = m_NumAttributes ; if ( getClassFlag ( ) ) { numAtts ++ ; } example = new DenseInstance ( numAtts ) ; example . setDataset ( format ) ; boolean [ ] attributes = cl . getAttributes ( ) ; double [ ] minValue = cl . getMinValue ( ) ; double [ ] maxValue = cl . getMaxValue ( ) ; int [ ] minInt = new int [ minValue . length ] ; int [ ] maxInt = new int [ maxValue . length ] ; int [ ] intValue = new int [ maxValue . length ] ; int [ ] numInt = new int [ minValue . length ] ; int num = NUM_ ; for ( int i = NUM_ ; i < minValue . length ; i ++ ) { minInt [ i ] = ( int ) Math . ceil ( minValue [ i ] ) ; maxInt [ i ] = ( int ) Math . floor ( maxValue [ i ] ) ; numInt [ i ] = ( maxInt [ i ] - minInt [ i ] + NUM_ ) ; num = num . numInt [ i ] ; } int numEach = numInstances / num ; int rest = numInstances - numEach . num ; for ( int i = NUM_ ; i < m_NumAttributes ; i ++ ) { if ( attributes [ i ] ) { example . setValue ( i , minInt [ i ] ) ; intValue [ i ] = minInt [ i ] ; } else { example . setMissing ( i ) ; } } if ( getClassFlag ( ) ) { example . setClassValue ( cName ) ; } int added = NUM_ ; int attr = NUM_ ; do { for ( int k = NUM_ ; k < numEach ; k ++ ) { format . add ( example ) ; example = ( Instance ) example . copy ( ) ; added ++ ; } if ( rest > NUM_ ) { format . add ( example ) ; example = ( Instance ) example . copy ( ) ; added ++ ; rest -- ; } if ( added >= numInstances ) { break ; } boolean done = BOOL_ ; do { if ( attributes [ attr ] && ( intValue [ attr ] + NUM_ <= maxInt [ attr ] ) ) { intValue [ attr ] ++ ; done = BOOL_ ; } else { attr ++ ; } } while ( ! done ) ; example . setValue ( attr , intValue [ attr ] ) ; } while ( added < numInstances ) ; }
public synchronized boolean removeAll ( Collection c ) { Object [ ] elements = getArray ( ) ; int len = elements . length ; if ( len != NUM_ ) { int newlen = NUM_ ; Object [ ] temp = new Object [ len ] ; for ( int i = NUM_ ; i < len ; ++ i ) { Object element = elements [ i ] ; if ( ! c . contains ( element ) ) temp [ newlen ++ ] = element ; } if ( newlen != len ) { setArray ( copyOfRange ( temp , NUM_ , newlen , Object [ ] . class ) ) ; return BOOL_ ; } } return BOOL_ ; }
private final boolean compareAndSetTail ( Node expect , Node update ) { return unsafe . compareAndSwapObject ( this , tailOffset , expect , update ) ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
public Phone createPhone ( String value ) { PhoneField phoneImpl = new PhoneField ( ) ; try { phoneImpl . setValue ( value ) ; } catch ( SdpException s ) { s . printStackTrace ( ) ; } return phoneImpl ; }
private ListResourceBundle loadResourceBundle ( String resourceBundle ) throws MissingResourceException { m_resourceBundleName = resourceBundle ; Locale locale = getLocale ( ) ; ListResourceBundle lrb ; try { ResourceBundle rb = ResourceBundle . getBundle ( m_resourceBundleName , locale ) ; lrb = ( ListResourceBundle ) rb ; } catch ( MissingResourceException e ) { try { lrb = ( ListResourceBundle ) ResourceBundle . getBundle ( m_resourceBundleName , new Locale ( STR_ , STR_ ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( STR_ + m_resourceBundleName , m_resourceBundleName , STR_ ) ; } } m_resourceBundle = lrb ; return lrb ; }
private Set < String > returnRemotePoolsAssociatedWithRemoteCopySettings ( Map < String , List < String > > remoteCopySettings , Set < String > poolUris ) { Set < String > remotePoolUris = new HashSet < String > ( ) ; for ( Entry < String , List < String > > entry : remoteCopySettings . entrySet ( ) ) { VirtualPool vPool = _objectCache . queryObject ( VirtualPool . class , URI . create ( entry . getKey ( ) ) ) ; if ( null == vPool ) { remotePoolUris . addAll ( poolUris ) ; } else if ( null != vPool . getUseMatchedPools ( ) && vPool . getUseMatchedPools ( ) ) { if ( null != vPool . getMatchedStoragePools ( ) ) { remotePoolUris . addAll ( vPool . getMatchedStoragePools ( ) ) ; } } else if ( null != vPool . getAssignedStoragePools ( ) ) { remotePoolUris . addAll ( vPool . getAssignedStoragePools ( ) ) ; } } return remotePoolUris ; }
private String convertToHtml ( final String string ) { return STR_ + string . replaceAll ( STR_ , STR_ ) + STR_ ; }
private synchronized void addLock ( FileLock lock ) throws OverlappingFileLockException { long lockEnd = lock . position ( ) + lock . size ( ) ; for ( FileLock existingLock : locks ) { if ( existingLock . position ( ) > lockEnd ) { break ; } if ( existingLock . overlaps ( lock . position ( ) , lock . size ( ) ) ) { throw new OverlappingFileLockException ( ) ; } } locks . add ( lock ) ; }
public static void UF7 ( double [ ] x , double [ ] f , int nx ) { int count1 = NUM_ ; int count2 = NUM_ ; double sum1 = NUM_ ; double sum2 = NUM_ ; double yj ; for ( int j = NUM_ ; j <= nx ; j ++ ) { yj = x [ j - NUM_ ] - Math . sin ( NUM_ . PI . x [ NUM_ ] + j . PI / nx ) ; if ( j % NUM_ == NUM_ ) { sum2 += yj . yj ; count2 ++ ; } else { sum1 += yj . yj ; count1 ++ ; } } yj = Math . pow ( x [ NUM_ ] , NUM_ ) ; f [ NUM_ ] = yj + NUM_ . sum1 / ( double ) count1 ; f [ NUM_ ] = NUM_ - yj + NUM_ . sum2 / ( double ) count2 ; }
private void reloadModelWithNewValue ( final Long newValue ) { final long newValueAsPrimitive = newValue == null ? getModelUpdatePeriod ( ) : newValue ; for ( final PropertyChangeListener listener : modelUpdatePeriodListeners ) { final PropertyChangeEvent event = new PropertyChangeEvent ( this , STR_ , getModelUpdatePeriod ( ) , newValueAsPrimitive ) ; listener . propertyChange ( event ) ; } }
public static final String moveToUCIString ( Move m ) { String ret = squareToString ( m . from ) ; ret += squareToString ( m . to ) ; switch ( m . promoteTo ) { case Piece . WQUEEN : case Piece . BQUEEN : ret += STR_ ; break ; case Piece . WROOK : case Piece . BROOK : ret += STR_ ; break ; case Piece . WBISHOP : case Piece . BBISHOP : ret += STR_ ; break ; case Piece . WKNIGHT : case Piece . BKNIGHT : ret += STR_ ; break ; default : break ; } return ret ; }
public Image createAcceleratedImage ( Component target , int width , int height ) { ColorModel model = getColorModel ( Transparency . OPAQUE ) ; WritableRaster wr = model . createCompatibleWritableRaster ( width , height ) ; return new OffScreenImage ( target , model , wr , model . isAlphaPremultiplied ( ) ) ; }
public void displayState ( ) { PrintWriter xout = context . get ( Log . outKey ) ; xout . println ( STR_ + fileObjectHistory ) ; xout . println ( STR_ + openTypeNames ) ; xout . println ( STR_ + generatedSourceNames ) ; xout . println ( STR_ + generatedClasses . keySet ( ) ) ; xout . println ( STR_ + aggregateGeneratedSourceNames ) ; xout . println ( STR_ + aggregateGeneratedClassNames ) ; }
public static void writeStringToWriter ( String string , Writer writer ) throws IOException { BufferedWriter bw = new BufferedWriter ( writer ) ; try { bw . write ( string ) ; } finally { bw . close ( ) ; } }
public final void decRef ( ) throws IOException { ensureOpen ( ) ; final int rc = refCount . decrementAndGet ( ) ; if ( rc == NUM_ ) { boolean success = BOOL_ ; try { doClose ( ) ; closed = BOOL_ ; success = BOOL_ ; } finally { if ( ! success ) { refCount . incrementAndGet ( ) ; } } } else if ( rc < NUM_ ) { throw new IllegalStateException ( STR_ + rc + STR_ ) ; } }
public static X500Name x500PrincipalToX500Name ( X500Principal principal ) { return X500Name . getInstance ( KseX500NameStyle . INSTANCE , principal . getEncoded ( ) ) ; }
private void assertDescribedResource ( final BigdataValue describedResource , final IDescribeCache describeCache , final TestHelper h ) { final Graph actualGraph = describeCache . lookup ( describedResource . getIV ( ) ) ; assertNotNull ( actualGraph ) ; final Set < Statement > expectedGraph = getExpectedDescription ( describedResource , h ) ; h . compareGraphs ( new HashSet < Statement > ( actualGraph ) , expectedGraph ) ; for ( Statement stmt : actualGraph ) { assertTrue ( stmt instanceof BigdataStatement ) ; final BigdataStatement st = ( BigdataStatement ) stmt ; assertNotNull ( st . s ( ) ) ; assertNotNull ( st . p ( ) ) ; assertNotNull ( st . o ( ) ) ; if ( st . getContext ( ) != null ) { assertNotNull ( st . c ( ) ) ; } } }
public boolean isFlat ( ) { return TYPE_FLAT . equals ( getType ( ) ) ; }
@ Deprecated private List < CharSequence > buildLimitedNetworksList ( ) { final Context context = getActivity ( ) ; final ArrayList < CharSequence > limited = Lists . newArrayList ( ) ; if ( hasSubscription ( context ) ) { final String subscriberId = getActiveSubscriberId ( context ) ; if ( mPolicyEditor . hasLimitedPolicy ( buildTemplateMobileAll ( subscriberId ) ) ) { limited . add ( getText ( R . string . data_usage_list_mobile ) ) ; } if ( mPolicyEditor . hasLimitedPolicy ( buildTemplateMobile3gLower ( subscriberId ) ) ) { limited . add ( getText ( R . string . data_usage_tab_3g ) ) ; } if ( mPolicyEditor . hasLimitedPolicy ( buildTemplateMobile4g ( subscriberId ) ) ) { limited . add ( getText ( R . string . data_usage_tab_4g ) ) ; } } if ( mPolicyEditor . hasLimitedPolicy ( buildTemplateWifiWildcard ( ) ) ) { limited . add ( getText ( R . string . data_usage_tab_wifi ) ) ; } if ( mPolicyEditor . hasLimitedPolicy ( buildTemplateEthernet ( ) ) ) { limited . add ( getText ( R . string . data_usage_tab_ethernet ) ) ; } return limited ; }
public int evalRPN ( String [ ] tokens ) { if ( tokens == null || tokens . length == NUM_ ) return NUM_ ; Stack < String > s = new Stack < String > ( ) ; int len = tokens . length ; for ( int i = NUM_ ; i < len ; i ++ ) { String cur = tokens [ i ] ; if ( isOperator ( cur ) ) { int t2 = Integer . parseInt ( s . pop ( ) ) ; int t1 = Integer . parseInt ( s . pop ( ) ) ; int res = calculate ( t1 , t2 , cur ) ; s . push ( Integer . toString ( res ) ) ; } else s . push ( cur ) ; } return Integer . valueOf ( s . peek ( ) ) ; }
public synchronized void addAllSeries ( List < XYSeries > series ) { mSeries . addAll ( series ) ; }
private static void exit ( String errMsg , Options options , int exitCode ) { if ( errMsg != null ) echo ( STR_ + errMsg ) ; String runner = System . getProperty ( IGNITE_PROG_NAME , STR_ ) ; int space = runner . indexOf ( STR_ ) ; runner = runner . substring ( NUM_ , space == - NUM_ ? runner . length ( ) : space ) ; if ( options != null ) { HelpFormatter formatter = new HelpFormatter ( ) ; formatter . printHelp ( runner , options ) ; } System . exit ( exitCode ) ; }
@ Override public int compare ( NewSplitEmittedTerm term1 , NewSplitEmittedTerm term2 ) { return term1 . compareTo ( term2 ) ; }
public AABB merge ( AABB other ) { minX = Math . min ( minX , other . minX ) ; maxX = Math . max ( maxX , other . maxX ) ; minY = Math . min ( minY , other . minY ) ; maxY = Math . max ( maxY , other . maxY ) ; minZ = Math . min ( minZ , other . minZ ) ; maxZ = Math . max ( maxZ , other . maxZ ) ; return this ; }
public static String generateAutoTag ( int stackOffset ) { StackTraceElement [ ] currentStack = getCurrentStack ( ) ; StackTraceElement element = currentStack [ stackOffset ] ; String className = element . getClassName ( ) ; String pkgPath [ ] = className . split ( STR_ ) ; if ( pkgPath . length > NUM_ ) { className = pkgPath [ pkgPath . length - NUM_ ] ; } StringBuilder sbInnerClass = new StringBuilder ( ) ; int index ; String strLoop = className ; while ( ( index = strLoop . lastIndexOf ( STR_ ) ) != - NUM_ ) { String piece = strLoop . substring ( index + NUM_ ) ; sbInnerClass . insert ( NUM_ , piece ) ; if ( ! piece . matches ( STR_ ) ) { break ; } sbInnerClass . insert ( NUM_ , STR_ ) ; strLoop = strLoop . substring ( NUM_ , index ) ; } if ( sbInnerClass . length ( ) > NUM_ && sbInnerClass . charAt ( NUM_ ) == STR_ ) { sbInnerClass . deleteCharAt ( NUM_ ) ; } String innerClassName = sbInnerClass . toString ( ) ; if ( TextUtils . isDigitsOnly ( innerClassName ) ) { innerClassName = null ; } return TextUtils . isEmpty ( innerClassName ) ? className : innerClassName ; }
public void flushPending ( ) throws SAXException { if ( m_needToCallStartDocument ) { startDocumentInternal ( ) ; m_needToCallStartDocument = BOOL_ ; } if ( m_elemContext . m_startTagOpen ) { closeStartTag ( ) ; m_elemContext . m_startTagOpen = BOOL_ ; } if ( m_cdataTagOpen ) { closeCDATA ( ) ; m_cdataTagOpen = BOOL_ ; } if ( m_writer != null ) { try { m_writer . flush ( ) ; } catch ( IOException e ) { } } }
private void handleSubscribe ( String [ ] args ) { switch ( args [ NUM_ ] ) { case STR_ : TestSubscriber < Payload > rrsub = new TestSubscriber < > ( NUM_ ) ; payloadSubscribers . put ( args [ NUM_ ] , rrsub ) ; idToType . put ( args [ NUM_ ] , args [ NUM_ ] ) ; ReactiveSocket rrclient = createClient . get ( ) ; Publisher < Payload > rrpub = rrclient . requestResponse ( new PayloadImpl ( args [ NUM_ ] , args [ NUM_ ] ) ) ; rrpub . subscribe ( rrsub ) ; break ; case STR_ : TestSubscriber < Payload > rssub = new TestSubscriber < > ( NUM_ ) ; payloadSubscribers . put ( args [ NUM_ ] , rssub ) ; idToType . put ( args [ NUM_ ] , args [ NUM_ ] ) ; ReactiveSocket rsclient = createClient . get ( ) ; Publisher < Payload > rspub = rsclient . requestStream ( new PayloadImpl ( args [ NUM_ ] , args [ NUM_ ] ) ) ; rspub . subscribe ( rssub ) ; break ; case STR_ : TestSubscriber < Payload > rsubsub = new TestSubscriber < > ( NUM_ ) ; payloadSubscribers . put ( args [ NUM_ ] , rsubsub ) ; idToType . put ( args [ NUM_ ] , args [ NUM_ ] ) ; ReactiveSocket rsubclient = createClient . get ( ) ; Publisher < Payload > rsubpub = rsubclient . requestSubscription ( new PayloadImpl ( args [ NUM_ ] , args [ NUM_ ] ) ) ; rsubpub . subscribe ( rsubsub ) ; break ; case STR_ : TestSubscriber < Void > fnfsub = new TestSubscriber < > ( NUM_ ) ; fnfSubscribers . put ( args [ NUM_ ] , fnfsub ) ; idToType . put ( args [ NUM_ ] , args [ NUM_ ] ) ; ReactiveSocket fnfclient = createClient . get ( ) ; Publisher < Void > fnfpub = fnfclient . fireAndForget ( new PayloadImpl ( args [ NUM_ ] , args [ NUM_ ] ) ) ; fnfpub . subscribe ( fnfsub ) ; break ; default : break ; } }
@ PostConstruct public void init ( ) { configurationViews . add ( defaultDistributionSetTypeLayout ) ; configurationViews . add ( authenticationConfigurationView ) ; configurationViews . add ( pollingConfigurationView ) ; }
public ExtendedType ( int nodetype , String namespace , String localName ) { this . nodetype = nodetype ; this . namespace = namespace ; this . localName = localName ; this . hash = nodetype + namespace . hashCode ( ) + localName . hashCode ( ) ; }
private static void validateNewAddition ( Vector paths , ExpressionOwner owner , LocPathIterator path ) throws RuntimeException { assertion ( owner . getExpression ( ) == path , STR_ ) ; int n = paths . size ( ) ; for ( int i = NUM_ ; i < n ; i ++ ) { ExpressionOwner ew = ( ExpressionOwner ) paths . elementAt ( i ) ; assertion ( ew != owner , STR_ ) ; assertion ( ew . getExpression ( ) != path , STR_ ) ; } }
@ Override public void start ( ) { for ( int i = NUM_ ; i < threadCount ; ++ i ) { Set < SystemStreamPartition > threadSsps = new HashSet < SystemStreamPartition > ( ) ; for ( SystemStreamPartition ssp : ssps ) { if ( Math . abs ( ssp . hashCode ( ) ) % threadCount == i ) { threadSsps . add ( ssp ) ; } } Thread thread = new Thread ( new MockSystemConsumerRunnable ( threadSsps ) , STR_ + i ) ; thread . setDaemon ( BOOL_ ) ; threads . add ( thread ) ; thread . start ( ) ; } }
private List < double [ ] > initializeWeightsND ( ) { int N = NUM_ ; List < double [ ] > candidates = new ArrayList < double [ ] > ( numberOfPoints . N ) ; for ( int i = NUM_ ; i < numberOfPoints . N ; i ++ ) { double [ ] weight = new double [ numberOfObjectives ] ; for ( int j = NUM_ ; j < numberOfObjectives ; j ++ ) { weight [ j ] = PRNG . nextDouble ( ) ; } double sum = StatUtils . sum ( weight ) ; for ( int j = NUM_ ; j < numberOfObjectives ; j ++ ) { weight [ j ] /= sum ; } candidates . add ( weight ) ; } List < double [ ] > weights = new ArrayList < double [ ] > ( numberOfPoints . N ) ; for ( int i = NUM_ ; i < numberOfObjectives ; i ++ ) { double [ ] weight = new double [ numberOfObjectives ] ; weight [ i ] = NUM_ ; weights . add ( weight ) ; } while ( weights . size ( ) < numberOfPoints ) { double [ ] weight = null ; double distance = Double . NEGATIVE_INFINITY ; for ( int i = NUM_ ; i < candidates . size ( ) ; i ++ ) { double d = Double . POSITIVE_INFINITY ; for ( int j = NUM_ ; j < weights . size ( ) ; j ++ ) { d = Math . min ( d , MathArrays . distance ( candidates . get ( i ) , weights . get ( j ) ) ) ; } if ( d > distance ) { weight = candidates . get ( i ) ; distance = d ; } } weights . add ( weight ) ; candidates . remove ( weight ) ; } return weights ; }
public void undo ( ) { try { if ( undoManager != null ) undoManager . undoOrRedo ( ) ; } catch ( CannotUndoException ignored ) { } catch ( CannotRedoException ignored ) { } }
public void removeColumn ( Column column ) { if ( column != null ) { columns . remove ( column ) ; } }
public String info ( ) { StringBuilder sb = new StringBuilder ( STR_ + tableSize + STR_ + elements + STR_ + loadFactor + STR_ + threshold ) ; sb . append ( STR_ + numEmpty ) ; int size = NUM_ ; int min = elements ; int max = - NUM_ ; for ( int i = NUM_ ; i < tableSize ; i ++ ) { LinkedList < String > list = bins [ i ] ; if ( list != null ) { int sz = list . size ( ) ; size += sz ; if ( sz < min ) { min = sz ; } if ( sz > max ) { max = sz ; } } } float avg = size ; int base = ( tableSize - numEmpty ) ; if ( base == NUM_ ) { sb . append ( STR_ ) ; sb . append ( STR_ ) ; sb . append ( STR_ ) ; } else { avg /= base ; sb . append ( STR_ + avg ) ; sb . append ( STR_ + min ) ; sb . append ( STR_ + max ) ; } return sb . toString ( ) ; }
public boolean peekSample ( MediaCodec . BufferInfo out_bufferInfo ) { update ( ) ; boolean result = BOOL_ ; if ( ! mAvailableOutputBuffers . isEmpty ( ) ) { int index = mAvailableOutputBuffers . peek ( ) ; MediaCodec . BufferInfo info = mOutputBufferInfo [ index ] ; out_bufferInfo . set ( info . offset , info . size , info . presentationTimeUs , info . flags ) ; result = BOOL_ ; } return result ; }
@ Override public AbstractScannedResult scanBlocklet ( BlocksChunkHolder blocksChunkHolder ) throws QueryExecutionException { try { fillScannedResult ( blocksChunkHolder ) ; } catch ( FilterUnsupportedException e ) { throw new QueryExecutionException ( e . getMessage ( ) ) ; } return scannedResult ; }
@ Override public int hashCode ( ) { return subconditions . hashCode ( ) - operator . hashCode ( ) ; }
public void balanceSegments ( ) { MAcctSchemaElement [ ] elements = m_acctSchema . getAcctSchemaElements ( ) ; for ( int i = NUM_ ; i < elements . length ; i ++ ) { MAcctSchemaElement ase = elements [ i ] ; if ( ase . isBalanced ( ) ) balanceSegment ( ase . getElementType ( ) ) ; } }
public AnnotationDrawer ( final AnnotationsModel model , final ProcessRendererModel rendererModel ) { this . model = model ; this . rendererModel = rendererModel ; this . displayCache = new HashMap < > ( ) ; this . cachedID = new HashMap < > ( ) ; pane = new JEditorPane ( STR_ , STR_ ) ; pane . setBorder ( null ) ; pane . setOpaque ( BOOL_ ) ; }
public boolean hasUserPartitions ( ) { return ! userOutput . isEmpty ( ) ; }
@ Override public void insertString ( final int offs , final String str , final AttributeSet attr ) { if ( offs < NUM_ ) { return ; } if ( str . length ( ) > NUM_ ) { int i ; for ( i = NUM_ ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == STR_ ) { remainingTextString = str . substring ( i + NUM_ ) ; remainingTextAttr = attr ; inputKeyListener . keyPressed ( new KeyEvent ( new Container ( ) , KeyEvent . KEY_PRESSED , NUM_ , NUM_ , KeyEvent . VK_ENTER , STR_ ) ) ; break ; } else { insertChar ( offs + i , STR_ + str . charAt ( i ) ) ; } } } else if ( str . length ( ) == NUM_ ) { insertChar ( offs , str ) ; } }
protected int readCodePoint ( ) throws IOException { int next = reader . read ( ) ; if ( Character . isHighSurrogate ( ( char ) next ) ) { next = Character . toCodePoint ( ( char ) next , ( char ) reader . read ( ) ) ; } return next ; }
public static int putInt ( byte [ ] bytes , int offset , int val ) { if ( littleEndian ) { val = Integer . reverseBytes ( val ) ; } theUnsafe . putInt ( bytes , offset + BYTE_ARRAY_BASE_OFFSET , val ) ; return offset + Bytes . SIZEOF_INT ; }
public Item ( Drawable symbol , String labelText , Font font ) { double fontSize = font . getSize2D ( ) ; setLayout ( new EdgeLayout ( fontSize , NUM_ ) ) ; this . symbol = symbol ; add ( symbol , Location . WEST ) ; label = new Label ( labelText ) ; label . setFont ( font ) ; label . setAlignmentX ( NUM_ ) ; label . setAlignmentY ( NUM_ ) ; add ( label , Location . CENTER ) ; }
void tag ( String tag ) ;
public int consume ( ) { int consumedAmount ; if ( Math . abs ( left ) < Math . abs ( getRegen ( ) ) ) { consumedAmount = left ; left = NUM_ ; } else { consumedAmount = getRegen ( ) ; left -= getRegen ( ) ; } return consumedAmount ; }
private Delegate delegate ( ) throws HadoopIgfsCommunicationException { Exception errShmem = null ; Exception errTcp = null ; Delegate curDelegate = delegateRef . get ( ) ; if ( curDelegate != null ) return curDelegate ; boolean skipInProc = parameter ( conf , PARAM_IGFS_ENDPOINT_NO_EMBED , authority , BOOL_ ) ; if ( ! skipInProc ) { IgfsEx igfs = getIgfsEx ( endpoint . grid ( ) , endpoint . igfs ( ) ) ; if ( igfs != null ) { HadoopIgfsEx hadoop = null ; try { hadoop = new HadoopIgfsInProc ( igfs , log , userName ) ; curDelegate = new Delegate ( hadoop , hadoop . handshake ( logDir ) ) ; } catch ( IOException | IgniteCheckedException e ) { if ( e instanceof HadoopIgfsCommunicationException ) if ( hadoop != null ) hadoop . close ( BOOL_ ) ; if ( log . isDebugEnabled ( ) ) log . debug ( STR_ , e ) ; } } } boolean skipLocShmem = parameter ( conf , PARAM_IGFS_ENDPOINT_NO_LOCAL_SHMEM , authority , BOOL_ ) ; if ( curDelegate == null && ! skipLocShmem && ! U . isWindows ( ) ) { HadoopIgfsEx hadoop = null ; try { hadoop = new HadoopIgfsOutProc ( endpoint . port ( ) , endpoint . grid ( ) , endpoint . igfs ( ) , log , userName ) ; curDelegate = new Delegate ( hadoop , hadoop . handshake ( logDir ) ) ; } catch ( IOException | IgniteCheckedException e ) { if ( e instanceof HadoopIgfsCommunicationException ) hadoop . close ( BOOL_ ) ; if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + endpoint . port ( ) + STR_ , e ) ; errShmem = e ; } } boolean skipLocTcp = parameter ( conf , PARAM_IGFS_ENDPOINT_NO_LOCAL_TCP , authority , BOOL_ ) ; if ( curDelegate == null && ! skipLocTcp ) { HadoopIgfsEx hadoop = null ; try { hadoop = new HadoopIgfsOutProc ( LOCALHOST , endpoint . port ( ) , endpoint . grid ( ) , endpoint . igfs ( ) , log , userName ) ; curDelegate = new Delegate ( hadoop , hadoop . handshake ( logDir ) ) ; } catch ( IOException | IgniteCheckedException e ) { if ( e instanceof HadoopIgfsCommunicationException ) hadoop . close ( BOOL_ ) ; if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + endpoint . host ( ) + STR_ + endpoint . port ( ) + STR_ , e ) ; errTcp = e ; } } if ( curDelegate == null && ( skipLocTcp || ! F . eq ( LOCALHOST , endpoint . host ( ) ) ) ) { HadoopIgfsEx hadoop = null ; try { hadoop = new HadoopIgfsOutProc ( endpoint . host ( ) , endpoint . port ( ) , endpoint . grid ( ) , endpoint . igfs ( ) , log , userName ) ; curDelegate = new Delegate ( hadoop , hadoop . handshake ( logDir ) ) ; } catch ( IOException | IgniteCheckedException e ) { if ( e instanceof HadoopIgfsCommunicationException ) hadoop . close ( BOOL_ ) ; if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + endpoint . host ( ) + STR_ + endpoint . port ( ) + STR_ , e ) ; errTcp = e ; } } if ( curDelegate != null ) { if ( ! delegateRef . compareAndSet ( null , curDelegate ) ) curDelegate . doomed = BOOL_ ; return curDelegate ; } else { SB errMsg = new SB ( STR_ + authority + STR_ ) ; if ( errShmem != null ) errMsg . a ( STR_ + endpoint . port ( ) + STR_ + errShmem + STR_ ) ; errMsg . a ( STR_ + endpoint . host ( ) + STR_ + endpoint . port ( ) + STR_ + errTcp + STR_ ) ; errMsg . a ( STR_ + STR_ ) ; throw new HadoopIgfsCommunicationException ( errMsg . toString ( ) ) ; } }
public FromClause add ( OuterJoinQualifier outerJoinQualifier ) { outerJoinQualifiers . add ( outerJoinQualifier ) ; return this ; }
private static final File [ ] encode ( String src ) { if ( src == null || src . length ( ) == NUM_ ) { return ( new File [ NUM_ ] ) ; } StringTokenizer tokenizer = new StringTokenizer ( src , STR_ ) ; File [ ] dirs = new File [ tokenizer . countTokens ( ) ] ; for ( int i = NUM_ ; i < dirs . length ; i ++ ) { dirs [ i ] = new File ( tokenizer . nextToken ( ) ) ; } return dirs ; }
private boolean journalRebuildRequired ( ) { final int redundantOpCompactThreshold = NUM_ ; return redundantOpCount >= redundantOpCompactThreshold && redundantOpCount >= lruEntries . size ( ) ; }
public E poll ( long timeout , TimeUnit unit ) throws InterruptedException { long nanos = unit . toNanos ( timeout ) ; final ReentrantLock lock = this . lock ; lock . lockInterruptibly ( ) ; long t = now ( ) ; TenantQueue . Item item = null ; try { for ( ; ; ) { TenantQueue q = nextQueue ( t ) ; if ( q == null ) { if ( nanos <= NUM_ ) return null ; else nanos = available . awaitNanos ( nanos ) ; } else { long delay = q . next - t ; if ( delay <= NUM_ ) { item = q . poll ( t ) ; return item == null ? null : item . element ; } if ( nanos <= NUM_ ) return null ; if ( nanos < delay || leader != null ) nanos = available . awaitNanos ( nanos ) ; else { Thread thisThread = Thread . currentThread ( ) ; leader = thisThread ; try { long timeLeft = available . awaitNanos ( delay ) ; nanos -= delay - timeLeft ; } finally { if ( leader == thisThread ) leader = null ; } } } t = System . nanoTime ( ) ; } } finally { if ( leader == null && hasNext ( ) ) available . signal ( ) ; lock . unlock ( ) ; done ( item , t ) ; } }
public void addSwipeListener ( SwipeListener listener ) { if ( mListeners == null ) { mListeners = new ArrayList < SwipeListener > ( ) ; } mListeners . add ( listener ) ; }
public int size ( ) { return patterns . size ( ) ; }
private SublimeBaseMenuItem addInternal ( int pivotID , Positioned positioned , SublimeBaseMenuItem newItem ) { int newItemGroupId = newItem . getGroupId ( ) ; checkExistenceOfGroup ( newItemGroupId ) ; int pivotIndex = findItemIndex ( pivotID ) ; SublimeBaseMenuItem pivot = mItems . get ( pivotIndex ) ; if ( newItem . getItemType ( ) == SublimeBaseMenuItem . ItemType . GROUP_HEADER ) { checkIfGroupHeaderAlreadyExistsForGroup ( newItemGroupId ) ; int index = findGroupIndex ( newItemGroupId ) ; if ( index >= NUM_ ) { mItems . add ( index , newItem ) ; } else { if ( positioned == Positioned . BEFORE ) { if ( pivot . getGroupId ( ) == NO_GROUP_ID || pivot . getItemType ( ) == SublimeBaseMenuItem . ItemType . GROUP_HEADER ) { mItems . add ( pivotIndex , newItem ) ; } else { mItems . add ( newItem ) ; } } else if ( positioned == Positioned . AFTER ) { if ( pivot . getGroupId ( ) == NO_GROUP_ID || pivotIndex == findLastGroupIndex ( newItemGroupId ) ) { mItems . add ( pivotIndex + NUM_ , newItem ) ; } else { mItems . add ( newItem ) ; } } } } else { if ( newItemGroupId != NO_GROUP_ID ) { int lastGroupIndex = findLastGroupIndex ( newItemGroupId ) ; if ( lastGroupIndex == mItems . size ( ) ) { if ( positioned == Positioned . BEFORE ) { if ( pivot . getGroupId ( ) == NO_GROUP_ID || pivotIndex == findGroupIndex ( pivot . getGroupId ( ) ) ) { mItems . add ( pivotIndex , newItem ) ; } else { mItems . add ( newItem ) ; } } else if ( positioned == Positioned . AFTER ) { if ( pivot . getGroupId ( ) == NO_GROUP_ID || pivotIndex == findLastGroupIndex ( pivot . getGroupId ( ) ) ) { mItems . add ( pivotIndex + NUM_ , newItem ) ; } else { mItems . add ( newItem ) ; } } } else { if ( newItemGroupId == pivot . getGroupId ( ) ) { if ( positioned == Positioned . BEFORE ) { if ( pivot . getItemType ( ) != SublimeBaseMenuItem . ItemType . GROUP_HEADER ) { mItems . add ( pivotIndex , newItem ) ; } else { mItems . add ( lastGroupIndex + NUM_ , newItem ) ; } } else if ( positioned == Positioned . AFTER ) { mItems . add ( pivotIndex + NUM_ , newItem ) ; } } else { mItems . add ( lastGroupIndex + NUM_ , newItem ) ; } } } else { if ( positioned == Positioned . BEFORE ) { if ( pivot . getGroupId ( ) == NO_GROUP_ID || findGroupIndex ( pivot . getGroupId ( ) ) == pivotIndex ) { mItems . add ( pivotIndex , newItem ) ; } else { mItems . add ( newItem ) ; } } else if ( positioned == Positioned . AFTER ) { if ( pivot . getGroupId ( ) == NO_GROUP_ID || pivotIndex == findLastGroupIndex ( pivot . getGroupId ( ) ) ) { mItems . add ( pivotIndex + NUM_ , newItem ) ; } else { mItems . add ( newItem ) ; } } } } onItemsChanged ( ) ; return newItem ; }
public static void writeUint8 ( OutputStream theOs , int theValue ) throws IOException { theOs . write ( theValue ) ; }
private E unlinkFirst ( ) { Node < E > f = first ; if ( f == null ) return null ; Node < E > n = f . next ; E item = f . item ; f . item = null ; f . next = f ; first = n ; if ( n == null ) last = null ; else n . prev = null ; -- count ; notFull . signal ( ) ; return item ; }
public void testCase11 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int bSign = - NUM_ ; byte rBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . add ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
@ Override public void addHeader ( final String header , final String value ) { mHeadersOptions . add ( new HeaderOption ( header , value ) ) ; }
public void store ( ) throws SAMLException { try { keyProvider . store ( ) ; } catch ( KeyStoreException e ) { throw new SAMLException ( e . getMessage ( ) ) ; } catch ( CertificateException e ) { throw new SAMLException ( e . getMessage ( ) ) ; } catch ( NoSuchAlgorithmException e ) { throw new SAMLException ( e . getMessage ( ) ) ; } catch ( IOException e ) { throw new SAMLException ( e . getMessage ( ) ) ; } }
static void appendToPointerHierarchy ( final BaseType type , final BaseType pointer ) { Preconditions . checkNotNull ( type , STR_ ) ; Preconditions . checkNotNull ( pointer , STR_ ) ; Preconditions . checkArgument ( type != pointer , STR_ ) ; Preconditions . checkArgument ( pointer . pointedToBy != type , STR_ ) ; Preconditions . checkArgument ( type . pointsTo != pointer , STR_ ) ; pointer . pointsTo = type ; type . pointedToBy = pointer ; }
public static void sort ( long [ ] a ) { doSort ( a , NUM_ , a . length - NUM_ ) ; }
public String toString ( ) { return STR_ + String . format ( STR_ , ValueSimilarity . NUM_ ) + STR_ + String . format ( STR_ , ContainmentSimilarity . NUM_ ) + STR_ + String . format ( STR_ , SizeSimilarity . NUM_ ) ; }
public Optional < T > last ( ) { Iterator < T > iterator = iterator ( ) ; T value = null ; while ( iterator . hasNext ( ) ) value = iterator . next ( ) ; return Optional . of ( value ) ; }
public static void threadSleep ( long millis ) { try { Thread . sleep ( millis ) ; } catch ( InterruptedException ex ) { Log . e ( STR_ , StringUtils . exceptionStackTraceToString ( ex ) ) ; } }
public int indexOf ( Node elem , int index ) { runTo ( - NUM_ ) ; if ( null == m_map ) return - NUM_ ; for ( int i = index ; i < m_firstFree ; i ++ ) { Node node = m_map [ i ] ; if ( ( null != node ) && node . equals ( elem ) ) return i ; } return - NUM_ ; }
static boolean isPackageAccess ( final int modifiers ) { return ( modifiers & ACCESS_TEST ) == NUM_ ; }
public void write ( final String filename ) { PrintStream stream ; try { stream = new PrintStream ( new File ( filename ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; return ; } write ( stream ) ; stream . close ( ) ; }
ManagedWindowDecorator ( Window window , String windowId ) { this . window = window ; name = STR_ + windowId ; }
@ Override public void write ( byte [ ] b , int off , int len ) throws IOException { while ( len > NUM_ ) { int c = Math . min ( len , decoderIn . remaining ( ) ) ; decoderIn . put ( b , off , c ) ; processInput ( BOOL_ ) ; len -= c ; off += c ; } if ( writeImmediately ) { flushOutput ( ) ; } }
public static void log ( String message , Object ... args ) { if ( loggingEnabled ) { Log . d ( TAG , args . length == NUM_ ? message : String . format ( message , args ) ) ; } }
protected void processUpdates ( Queue < DeviceUpdate > updates ) { if ( updates == null ) return ; DeviceUpdate update = null ; while ( null != ( update = updates . poll ( ) ) ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( STR_ , update ) ; } if ( update . change == DeviceUpdate . Change . DELETE ) { deviceSyncManager . removeDevice ( update . device ) ; } else { deviceSyncManager . storeDevice ( update . device ) ; } List < IDeviceListener > listeners = deviceListeners . getOrderedListeners ( ) ; notifyListeners ( listeners , update ) ; } }
boolean handleRemoteCanRebalance ( long size ) { return BOOL_ ; }
public static File toSLDFile ( final File file ) { final String path = file . getAbsolutePath ( ) ; final String base = path . substring ( NUM_ , path . length ( ) - NUM_ ) ; String newPath = base + STR_ ; File sld = new File ( newPath ) ; if ( sld . exists ( ) ) { return sld ; } newPath = base + STR_ ; sld = new File ( newPath ) ; if ( sld . exists ( ) ) { return sld ; } return null ; }
private String insertProperties ( String template , Map < String , String > properties ) { for ( Entry < String , String > entry : properties . entrySet ( ) ) { template = template . replace ( entry . getKey ( ) , entry . getValue ( ) ) ; } return template ; }
public static void changeFont ( JComponent comp , int style ) { Font font = comp . getFont ( ) ; comp . setFont ( font . deriveFont ( style ) ) ; }
public void drawContours ( Mat img , Color color ) { Drawing . drawContours ( img , contours , color ) ; }
public static void saveX509Cert ( String certStr , File certFile ) throws IOException { BufferedWriter writer = new BufferedWriter ( new FileWriter ( certFile ) ) ; writer . write ( BEGIN_CERT ) ; writer . newLine ( ) ; writer . write ( certStr ) ; writer . newLine ( ) ; writer . write ( END_CERT ) ; writer . newLine ( ) ; writer . close ( ) ; }
public void clearOnCentralPositionChangedListener ( ) { mOnCentralPositionChangedListeners . clear ( ) ; }
public static Object invokeStatic ( Class clazz , String methodName ) throws NoSuchMethodException { try { Method method = clazz . getMethod ( methodName , new Class [ NUM_ ] ) ; Object result = method . invoke ( null , new Object [ NUM_ ] ) ; return result ; } catch ( IllegalAccessException e ) { throw new NoSuchMethodException ( methodName + STR_ ) ; } catch ( InvocationTargetException e ) { throw new InternalError ( e . getMessage ( ) ) ; } }
@ Deprecated public boolean isFillBelowLine ( ) { return mFillBelowLine . size ( ) > NUM_ ; }
public void onPatchServiceResult ( boolean isUpgradePatch ) { if ( ! isRetryEnable ) { TinkerLog . w ( TAG , STR_ ) ; return ; } if ( ! isUpgradePatch ) { TinkerLog . w ( TAG , STR_ ) ; return ; } if ( retryInfoFile . exists ( ) ) { SharePatchFileUtil . safeDeleteFile ( retryInfoFile ) ; } if ( tempPatchFile . exists ( ) ) { SharePatchFileUtil . safeDeleteFile ( tempPatchFile ) ; } }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case NUM_ : return NOTE_ID ; case NUM_ : return CLASS_NAME ; case NUM_ : return INTERPRETER_CONTEXT ; default : return null ; } }
public static boolean isStanza ( Packet packet ) { if ( packet instanceof Message ) return BOOL_ ; if ( packet instanceof IQ ) return BOOL_ ; if ( packet instanceof Presence ) return BOOL_ ; return BOOL_ ; }
@ Override public int execute ( final FormObject form , final int type , final String code , final int eventType , final char keyPressed ) { int messageCode = ActionHandler . NOMESSAGE ; if ( code instanceof String ) { final String js = code ; final String [ ] args = JSFunction . convertToArray ( js ) ; final String command = args [ NUM_ ] ; if ( command . startsWith ( STR_ ) ) { messageCode = handleAFCommands ( form , command , js , args , eventType , keyPressed ) ; } } return messageCode ; }
private boolean needsUpdate ( Long bundleVersion , String beanVersion ) { if ( beanVersion . contains ( STR_ ) ) { Log . i ( TAG , STR_ + bundleVersion ) ; Log . i ( TAG , STR_ + beanVersion ) ; return BOOL_ ; } else { try { long parsedVersion = Long . parseLong ( beanVersion . split ( STR_ ) [ NUM_ ] ) ; Log . i ( TAG , STR_ + bundleVersion ) ; Log . i ( TAG , STR_ + parsedVersion ) ; if ( bundleVersion > parsedVersion ) { return BOOL_ ; } else { Log . i ( TAG , STR_ ) ; } } catch ( NumberFormatException e ) { Log . e ( TAG , STR_ + beanVersion ) ; fail ( BeanError . UNPARSABLE_FW_VERSION ) ; } } return BOOL_ ; }
public void clear ( FacesContext facesContext , Map < String , Object > viewMap ) { if ( LOGGER . isLoggable ( Level . FINEST ) ) { LOGGER . log ( Level . FINEST , STR_ ) ; } Map < String , ViewScopeContextObject > contextMap = getContextMap ( facesContext , viewMap ) ; if ( contextMap != null ) { destroyBeans ( viewMap , contextMap ) ; } }
public void loadLogicalTablesWithGranularities ( Map < String , TableGroup > nameGroupMap , Set < ? extends Granularity > validGrains , ResourceDictionaries dictionaries ) { for ( Map . Entry < String , TableGroup > entry : nameGroupMap . entrySet ( ) ) { String logicalTableName = entry . getKey ( ) ; TableGroup group = entry . getValue ( ) ; loadLogicalTableWithGranularities ( logicalTableName , group , validGrains , dictionaries ) ; } }
protected int readBlock ( ) { blockSize = read ( ) ; int n = NUM_ ; if ( blockSize > NUM_ ) { try { int count = NUM_ ; while ( n < blockSize ) { count = in . read ( block , n , blockSize - n ) ; if ( count == - NUM_ ) break ; n += count ; } } catch ( IOException e ) { } if ( n < blockSize ) { status = STATUS_FORMAT_ERROR ; } } return n ; }
@ Override public void addNewSubscription ( final Subscription newSubscription ) { final String clientID = newSubscription . getClientId ( ) ; List < ClientTopicCouple > clientSubscriptions = subscriptions . get ( clientID ) ; if ( clientSubscriptions == null ) { clientSubscriptions = new ArrayList < > ( ) ; subscriptions . put ( clientID , clientSubscriptions ) ; } clientSubscriptions . add ( newSubscription . asClientTopicCouple ( ) ) ; }
public X509CertPathImpl ( List < ? extends java . security . cert . Certificate > certs ) throws CertificateException { super ( STR_ ) ; final int size = certs . size ( ) ; certificates = new ArrayList < X509Certificate > ( size ) ; for ( int i = NUM_ ; i < size ; i ++ ) { final java . security . cert . Certificate cert = certs . get ( i ) ; if ( ! ( cert instanceof X509Certificate ) ) { throw new CertificateException ( STR_ + i + STR_ ) ; } certificates . add ( ( X509Certificate ) cert ) ; } }
public Process ( final String xmlString ) throws IOException , XMLException { initContext ( ) ; StringReader in = new StringReader ( xmlString ) ; readProcess ( in ) ; in . close ( ) ; }
public ConsulTopologyFraction ( ) { this . url = DEFAULT_URL ; }
protected String buildQualifierRegex ( String qualifierValue ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( STR_ ) ; sb . append ( qualifierValue ) ; sb . append ( STR_ ) ; return sb . toString ( ) ; }
public String shortenName ( String name , int desiredLength ) { int originalLength = name . length ( ) ; if ( ( desiredLength <= NUM_ ) || ( originalLength <= desiredLength ) ) { return name ; } int delta = originalLength - desiredLength ; int startCut = desiredLength / NUM_ ; StringBuffer result = new StringBuffer ( ) ; result . append ( name . substring ( NUM_ , startCut ) ) ; if ( ( ( startCut == NUM_ ) || ( name . charAt ( startCut - NUM_ ) != STR_ ) ) && ( ( startCut + delta + NUM_ == originalLength ) || ( name . charAt ( startCut + delta + NUM_ ) != STR_ ) ) ) { result . append ( STR_ ) ; } result . append ( name . substring ( startCut + delta + NUM_ , originalLength ) ) ; return result . toString ( ) ; }
public static Color blend ( Color color1 , Color color2 , double weight ) { double w2 = MathUtils . limit ( weight , NUM_ , NUM_ ) ; double w1 = NUM_ - w2 ; int r = ( int ) Math . round ( w1 . color1 . getRed ( ) + w2 . color2 . getRed ( ) ) ; int g = ( int ) Math . round ( w1 . color1 . getGreen ( ) + w2 . color2 . getGreen ( ) ) ; int b = ( int ) Math . round ( w1 . color1 . getBlue ( ) + w2 . color2 . getBlue ( ) ) ; int a = ( int ) Math . round ( w1 . color1 . getAlpha ( ) + w2 . color2 . getAlpha ( ) ) ; return new Color ( r , g , b , a ) ; }
public long kstkeip ( ) { return Long . parseLong ( fields [ NUM_ ] ) ; }
private void decideUILookAndFeel ( MainOptions options ) { try { boolean systemPlaf = BOOL_ ; systemPlaf = options . system_plaf ; String systemPlafReq = System . getenv ( STR_ ) ; if ( systemPlafReq != null && systemPlafReq . equalsIgnoreCase ( STR_ ) ) systemPlaf = BOOL_ ; if ( systemPlaf ) UIManager . setLookAndFeel ( UIManager . getSystemLookAndFeelClassName ( ) ) ; } catch ( Exception exc ) { exc . printStackTrace ( ) ; } }
public static BufferedImage toBufferedImage ( Image img , int type ) { if ( img instanceof BufferedImage ) { return ( BufferedImage ) img ; } BufferedImage bimage = new BufferedImage ( img . getWidth ( null ) , img . getHeight ( null ) , type ) ; Graphics2D bGr = bimage . createGraphics ( ) ; bGr . drawImage ( img , NUM_ , NUM_ , null ) ; bGr . dispose ( ) ; return bimage ; }
private JSONArray readArray ( ) throws JSONException { JSONArray result = new JSONArray ( ) ; boolean hasTrailingSeparator = BOOL_ ; while ( BOOL_ ) { switch ( nextCleanInternal ( ) ) { case - NUM_ : throw syntaxError ( STR_ ) ; case STR_ : if ( hasTrailingSeparator ) { result . put ( null ) ; } return result ; case STR_ : case STR_ : result . put ( null ) ; hasTrailingSeparator = BOOL_ ; continue ; default : pos -- ; } result . put ( nextValue ( ) ) ; switch ( nextCleanInternal ( ) ) { case STR_ : return result ; case STR_ : case STR_ : hasTrailingSeparator = BOOL_ ; continue ; default : throw syntaxError ( STR_ ) ; } } }
public static byte [ ] hexStringToByteArray ( String strA ) { ByteArrayOutputStream result = new ByteArrayOutputStream ( ) ; byte sum = ( byte ) x00 ; boolean nextCharIsUpper = BOOL_ ; for ( int i = NUM_ ; i < strA . length ( ) ; i ++ ) { char c = strA . charAt ( i ) ; switch ( Character . toUpperCase ( c ) ) { case STR_ : if ( nextCharIsUpper ) { sum = ( byte ) x00 ; nextCharIsUpper = BOOL_ ; } else { sum |= ( byte ) x00 ; result . write ( sum ) ; nextCharIsUpper = BOOL_ ; } break ; case STR_ : if ( nextCharIsUpper ) { sum = ( byte ) x10 ; nextCharIsUpper = BOOL_ ; } else { sum |= ( byte ) x01 ; result . write ( sum ) ; nextCharIsUpper = BOOL_ ; } break ; case STR_ : if ( nextCharIsUpper ) { sum = ( byte ) x20 ; nextCharIsUpper = BOOL_ ; } else { sum |= ( byte ) x02 ; result . write ( sum ) ; nextCharIsUpper = BOOL_ ; } break ; case STR_ : if ( nextCharIsUpper ) { sum = ( byte ) x30 ; nextCharIsUpper = BOOL_ ; } else { sum |= ( byte ) x03 ; result . write ( sum ) ; nextCharIsUpper = BOOL_ ; } break ; case STR_ : if ( nextCharIsUpper ) { sum = ( byte ) x40 ; nextCharIsUpper = BOOL_ ; } else { sum |= ( byte ) x04 ; result . write ( sum ) ; nextCharIsUpper = BOOL_ ; } break ; case STR_ : if ( nextCharIsUpper ) { sum = ( byte ) x50 ; nextCharIsUpper = BOOL_ ; } else { sum |= ( byte ) x05 ; result . write ( sum ) ; nextCharIsUpper = BOOL_ ; } break ; case STR_ : if ( nextCharIsUpper ) { sum = ( byte ) x60 ; nextCharIsUpper = BOOL_ ; } else { sum |= ( byte ) x06 ; result . write ( sum ) ; nextCharIsUpper = BOOL_ ; } break ; case STR_ : if ( nextCharIsUpper ) { sum = ( byte ) x70 ; nextCharIsUpper = BOOL_ ; } else { sum |= ( byte ) x07 ; result . write ( sum ) ; nextCharIsUpper = BOOL_ ; } break ; case STR_ : if ( nextCharIsUpper ) { sum = ( byte ) x80 ; nextCharIsUpper = BOOL_ ; } else { sum |= ( byte ) x08 ; result . write ( sum ) ; nextCharIsUpper = BOOL_ ; } break ; case STR_ : if ( nextCharIsUpper ) { sum = ( byte ) x90 ; nextCharIsUpper = BOOL_ ; } else { sum |= ( byte ) x09 ; result . write ( sum ) ; nextCharIsUpper = BOOL_ ; } break ; case STR_ : if ( nextCharIsUpper ) { sum = ( byte ) xA0 ; nextCharIsUpper = BOOL_ ; } else { sum |= ( byte ) x0A ; result . write ( sum ) ; nextCharIsUpper = BOOL_ ; } break ; case STR_ : if ( nextCharIsUpper ) { sum = ( byte ) xB0 ; nextCharIsUpper = BOOL_ ; } else { sum |= ( byte ) x0B ; result . write ( sum ) ; nextCharIsUpper = BOOL_ ; } break ; case STR_ : if ( nextCharIsUpper ) { sum = ( byte ) xC0 ; nextCharIsUpper = BOOL_ ; } else { sum |= ( byte ) x0C ; result . write ( sum ) ; nextCharIsUpper = BOOL_ ; } break ; case STR_ : if ( nextCharIsUpper ) { sum = ( byte ) xD0 ; nextCharIsUpper = BOOL_ ; } else { sum |= ( byte ) x0D ; result . write ( sum ) ; nextCharIsUpper = BOOL_ ; } break ; case STR_ : if ( nextCharIsUpper ) { sum = ( byte ) xE0 ; nextCharIsUpper = BOOL_ ; } else { sum |= ( byte ) x0E ; result . write ( sum ) ; nextCharIsUpper = BOOL_ ; } break ; case STR_ : if ( nextCharIsUpper ) { sum = ( byte ) xF0 ; nextCharIsUpper = BOOL_ ; } else { sum |= ( byte ) x0F ; result . write ( sum ) ; nextCharIsUpper = BOOL_ ; } break ; default : break ; } } if ( ! nextCharIsUpper ) { throw new RuntimeException ( STR_ ) ; } return result . toByteArray ( ) ; }
public List < Node > listAvailableTerminals ( Class < ? > type ) { List < Node > result = new ArrayList < Node > ( ) ; for ( Node node : availableNodes ) { if ( ( node . getNumberOfArguments ( ) == NUM_ ) && type . isAssignableFrom ( node . getReturnType ( ) ) ) { result . add ( node ) ; } } return result ; }
public void removeSensorSelectionListener ( SensorSelectionListener listener ) { listenerList . remove ( SensorSelectionListener . class , listener ) ; }
public void write ( int c ) throws IOException { if ( _output == null ) throw new IOException ( STR_ ) ; _output . append ( ( char ) c ) ; }
private static void testDexClassLoader ( ) { ClassLoader dexClassLoader = getDexClassLoader ( ) ; Class anotherClass ; try { anotherClass = dexClassLoader . loadClass ( STR_ ) ; } catch ( ClassNotFoundException cnfe ) { throw new RuntimeException ( STR_ ) ; } Object another ; try { another = anotherClass . newInstance ( ) ; } catch ( IllegalAccessException ie ) { throw new RuntimeException ( STR_ , ie ) ; } catch ( InstantiationException ie ) { throw new RuntimeException ( STR_ , ie ) ; } dexClassLoader . getResource ( STR_ ) ; }
public void register ( GridCacheTtlManager mgr ) { synchronized ( mux ) { if ( cleanupWorker == null ) startCleanupWorker ( ) ; mgrs . add ( mgr ) ; } }
public static java . sql . Time toSqlTime ( int hour , int minute , int second ) { java . util . Date newDate = toDate ( NUM_ , NUM_ , NUM_ , hour , minute , second ) ; if ( newDate != null ) { return new java . sql . Time ( newDate . getTime ( ) ) ; } else { return null ; } }
public void initializeKeyStore ( ) { try { Logger logger = ( com . sun . identity . log . Logger ) Logger . getLogger ( logName ) ; resetCurrentFileList ( logName ) ; addToCurrentFileList ( logName , logName , logName ) ; String logPath = lmanager . getProperty ( LogConstants . LOG_LOCATION ) ; if ( ! logPath . endsWith ( STR_ ) ) logPath += STR_ ; String fileName = logName ; String loggerFileName = logPath + PREFIX + STR_ + fileName ; String verifierFileName = logPath + PREFIX + STR_ + fileName ; Debug . message ( logName + STR_ + loggerFileName ) ; Debug . message ( logName + STR_ + verifierFileName ) ; helper . initializeSecureLogHelper ( loggerFileName , logPassword , verifierFileName , logPassword ) ; Debug . message ( logName + STR_ ) ; helper . initializeVerifier ( verifierFileName , logPassword , verPassword ) ; Debug . message ( logName + STR_ ) ; } catch ( Exception e ) { Debug . error ( logName + STR_ , e ) ; } }
private native byte [ ] imageDataToPlatformImageBytes ( byte [ ] imageData , int width , int height , long format ) ;
public void writeExif ( Bitmap bmap , OutputStream exifOutStream ) throws IOException { if ( bmap == null || exifOutStream == null ) { throw new IllegalArgumentException ( NULL_ARGUMENT_STRING ) ; } OutputStream s = getExifWriterStream ( exifOutStream ) ; bmap . compress ( Bitmap . CompressFormat . JPEG , NUM_ , s ) ; s . flush ( ) ; }
public static String cleanFolderStackingMarkers ( String filename ) { if ( ! StringUtils . isEmpty ( filename ) ) { Matcher m = folderStackingPattern . matcher ( filename ) ; if ( m . matches ( ) ) { return m . group ( NUM_ ) + m . group ( NUM_ ) ; } } return filename ; }
public void discard ( ServiceRegistrar reg ) { synchronized ( registrars ) { if ( terminated ) { throw new IllegalStateException ( STR_ ) ; } if ( reg == null ) return ; sendDiscarded ( reg , null ) ; } }
public boolean isFinalState ( int state ) { return ( state < NUM_ ) ? BOOL_ : fFinalStateFlags [ state ] ; }
public static String generateScaleMarkers ( int proteinLength , int maxNumScaleMarkers ) { if ( maxNumScaleMarkers < NUM_ ) { maxNumScaleMarkers = NUM_ ; } int scale = calcScale ( proteinLength , maxNumScaleMarkers ) ; StringBuilder sb = new StringBuilder ( STR_ ) ; int index = NUM_ ; int numRemaining = proteinLength ; while ( index <= proteinLength ) { index += scale ; numRemaining -= scale ; sb . append ( STR_ ) ; if ( ( numRemaining > NUM_ ) && ( numRemaining < scale ) ) { if ( numRemaining < ( scale / NUM_ ) ) { sb . append ( proteinLength ) ; break ; } } if ( index >= proteinLength ) { sb . append ( proteinLength ) ; } else { sb . append ( index ) ; } } return sb . toString ( ) ; }
public void writeFigTreeBlock ( Map < String , Object > settings ) throws IOException { writer . println ( STR_ ) ; for ( String key : settings . keySet ( ) ) { Object value = settings . get ( key ) ; writer . println ( STR_ + key + STR_ + createString ( value ) + STR_ ) ; } writer . println ( STR_ ) ; }
public int hashCode ( ) { return font . hashCode ( ) ^ glyphs . length ; }
public boolean equals ( Object obj ) { if ( obj == this ) { return BOOL_ ; } if ( obj instanceof Map == BOOL_ ) { return BOOL_ ; } Map map = ( Map ) obj ; if ( map . size ( ) != size ( ) ) { return BOOL_ ; } MapIterator it = mapIterator ( ) ; try { while ( it . hasNext ( ) ) { Object key = it . next ( ) ; Object value = it . getValue ( ) ; if ( value == null ) { if ( map . get ( key ) != null || map . containsKey ( key ) == BOOL_ ) { return BOOL_ ; } } else { if ( value . equals ( map . get ( key ) ) == BOOL_ ) { return BOOL_ ; } } } } catch ( ClassCastException ignored ) { return BOOL_ ; } catch ( NullPointerException ignored ) { return BOOL_ ; } return BOOL_ ; }
@ Override public void doctypeDecl ( String rootElement , String publicId , String systemId , Augmentations augs ) throws XNIException { fInDTD = BOOL_ ; try { if ( fLexicalHandler != null ) { fLexicalHandler . startDTD ( rootElement , publicId , systemId ) ; } } catch ( SAXException e ) { throw new XNIException ( e ) ; } if ( fDeclHandler != null ) { fDeclaredAttrs = new SymbolHash ( ) ; } }
public void writeExif ( byte [ ] jpeg , String exifOutFileName ) throws FileNotFoundException , IOException { if ( jpeg == null || exifOutFileName == null ) { throw new IllegalArgumentException ( NULL_ARGUMENT_STRING ) ; } OutputStream s = null ; try { s = getExifWriterStream ( exifOutFileName ) ; s . write ( jpeg , NUM_ , jpeg . length ) ; s . flush ( ) ; } catch ( IOException e ) { closeSilently ( s ) ; throw e ; } s . close ( ) ; }
public void cleanStart ( ) { Connection conn = getConnection ( BOOL_ , BOOL_ ) ; if ( conn == null ) throw new IllegalStateException ( STR_ ) ; dropDatabase ( conn ) ; createUser ( conn ) ; createDatabase ( conn ) ; try { if ( conn != null ) conn . close ( ) ; } catch ( SQLException e2 ) { log . log ( Level . SEVERE , STR_ , e2 ) ; } conn = null ; }
static TemplateModelException newMethodArgInvalidValueException ( String methodName , int argIdx , Object ... details ) { return new _TemplateModelException ( methodName , STR_ , Integer . valueOf ( argIdx + NUM_ ) , STR_ , details ) ; }
public static byte [ ] compressForZlib ( String stringToCompress ) { byte [ ] returnValues = null ; try { returnValues = compressForZlib ( stringToCompress . getBytes ( STR_ ) ) ; } catch ( UnsupportedEncodingException uee ) { uee . printStackTrace ( ) ; } return returnValues ; }
private void loadMap ( String extension , String mimeType ) { if ( ! mimeTypeToExtensionMap . containsKey ( mimeType ) ) { mimeTypeToExtensionMap . put ( mimeType , extension ) ; } extensionToMimeTypeMap . put ( extension , mimeType ) ; if ( isImageType ( mimeType ) ) { imageMimeTypeSet . add ( mimeType ) ; } }
public void startDTD ( String name , String publicId , String systemId ) throws org . xml . sax . SAXException { }
private String convertTimestamp ( ) { String result = timestampFormat . replaceAll ( VALID_DATEFORMAT_CHAR_PATTERN + STR_ , STR_ ) ; result = result . replaceAll ( Pattern . quote ( STR_ ) , STR_ ) ; return result ; }
public static String encode ( byte [ ] bytes ) { int len = bytes . length ; final StringBuffer encoded = new StringBuffer ( ( len + NUM_ ) / NUM_ . NUM_ ) ; int i = NUM_ ; int j = len ; while ( j >= NUM_ ) { encoded . append ( to64 ( ( ( ( bytes [ i ] & xff ) << NUM_ ) | ( int ) ( ( bytes [ i + NUM_ ] & xff ) << NUM_ ) | ( int ) ( bytes [ i + NUM_ ] & xff ) ) , NUM_ ) ) ; i += NUM_ ; j -= NUM_ ; } if ( j == NUM_ ) { encoded . append ( to64 ( ( ( bytes [ i ] & xff ) << NUM_ ) | ( ( bytes [ i + NUM_ ] & xff ) ) , NUM_ ) ) ; } if ( j == NUM_ ) { encoded . append ( to64 ( ( ( bytes [ i ] & xff ) ) , NUM_ ) ) ; } return encoded . toString ( ) ; }
final public void print ( double v ) { Writer out = this . out ; if ( out == null ) return ; try { String s = String . valueOf ( v ) ; out . write ( s , NUM_ , s . length ( ) ) ; } catch ( IOException e ) { log . log ( Level . FINE , e . toString ( ) , e ) ; } }
public String toString ( ) { StringBuffer result = new StringBuffer ( ipAddress . toString ( ) ) ; result . append ( STR_ ) ; result . append ( extendedNetworkPrefix ) ; return result . toString ( ) ; }
private static boolean containsChroot ( String zkHost ) { return zkHost . contains ( STR_ ) ; }
public static void onDatabase ( MongoClient client , String dbName , Consumer < MongoDatabase > dbOperation ) { if ( contains ( client . listDatabaseNames ( ) , dbName ) ) { dbOperation . accept ( client . getDatabase ( dbName ) ) ; } }
protected int createHashCode ( ) { int result = uri . hashCode ( ) ^ prefix . hashCode ( ) ; if ( result == NUM_ ) { result = xbabe ; } return result ; }
private void updateBaseMatrix ( Drawable d ) { ImageView imageView = getImageView ( ) ; if ( null == imageView || null == d ) { return ; } final float viewWidth = imageView . getWidth ( ) ; final float viewHeight = imageView . getHeight ( ) ; final int drawableWidth = d . getIntrinsicWidth ( ) ; final int drawableHeight = d . getIntrinsicHeight ( ) ; mBaseMatrix . reset ( ) ; final float widthScale = viewWidth / drawableWidth ; final float heightScale = viewHeight / drawableHeight ; if ( mScaleType == ScaleType . CENTER ) { mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth ) / NUM_ , ( viewHeight - drawableHeight ) / NUM_ ) ; } else if ( mScaleType == ScaleType . CENTER_CROP ) { float scale = Math . max ( widthScale , heightScale ) ; mBaseMatrix . postScale ( scale , scale ) ; mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth . scale ) / NUM_ , ( viewHeight - drawableHeight . scale ) / NUM_ ) ; } else if ( mScaleType == ScaleType . CENTER_INSIDE ) { float scale = Math . min ( NUM_ , Math . min ( widthScale , heightScale ) ) ; mBaseMatrix . postScale ( scale , scale ) ; mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth . scale ) / NUM_ , ( viewHeight - drawableHeight . scale ) / NUM_ ) ; } else { RectF mTempSrc = new RectF ( NUM_ , NUM_ , drawableWidth , drawableHeight ) ; RectF mTempDst = new RectF ( NUM_ , NUM_ , viewWidth , viewHeight ) ; switch ( mScaleType ) { case FIT_CENTER : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . CENTER ) ; break ; case FIT_START : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . START ) ; break ; case FIT_END : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . END ) ; break ; case FIT_XY : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . FILL ) ; break ; default : break ; } } resetMatrix ( ) ; }
public static PlaceholderFragment newInstance ( int sectionNumber ) { PlaceholderFragment fragment = new PlaceholderFragment ( ) ; Bundle args = new Bundle ( ) ; args . putInt ( ARG_SECTION_NUMBER , sectionNumber ) ; fragment . setArguments ( args ) ; return fragment ; }
public String importTrl ( String directory , int AD_Client_ID , String AD_Language , String Trl_Table ) { String fileName = directory + File . separator + Trl_Table + STR_ + AD_Language + STR_ ; log . info ( fileName ) ; File in = new File ( fileName ) ; if ( ! in . exists ( ) ) { String msg = STR_ + fileName ; log . log ( Level . SEVERE , msg ) ; return msg ; } try { TranslationHandler handler = new TranslationHandler ( AD_Client_ID ) ; SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; SAXParser parser = factory . newSAXParser ( ) ; parser . parse ( in , handler ) ; log . info ( STR_ + handler . getUpdateCount ( ) ) ; return Msg . getMsg ( m_ctx , STR_ ) + STR_ + handler . getUpdateCount ( ) ; } catch ( Exception e ) { log . log ( Level . SEVERE , STR_ , e ) ; return e . toString ( ) ; } }
public ResultFileReader ( Problem problem , File file ) throws IOException { super ( ) ; this . problem = problem ; reader = new BufferedReader ( new FileReader ( file ) ) ; line = reader . readLine ( ) ; }
@ Override public void onFailure ( IMqttToken asyncActionToken , Throwable exception ) { exception . printStackTrace ( ) ; Log . e ( STR_ , STR_ + exception . getMessage ( ) ) ; onDisconnect ( BOOL_ ) ; }
@ Override public boolean exclude ( String identifier ) { return blacklist . contains ( identifier ) ; }
public static boolean checkCommunicationError ( Exception exc ) { Throwable rootCause = SolrException . getRootCause ( exc ) ; boolean wasCommError = ( rootCause instanceof ConnectException || rootCause instanceof ConnectTimeoutException || rootCause instanceof NoHttpResponseException || rootCause instanceof SocketException ) ; return wasCommError ; }
public boolean isReliable ( ) { return BOOL_ ; }
private void push ( final int type ) { if ( outputStack == null ) { outputStack = new int [ NUM_ ] ; } int n = outputStack . length ; if ( outputStackTop >= n ) { int [ ] t = new int [ Math . max ( outputStackTop + NUM_ , NUM_ . n ) ] ; System . arraycopy ( outputStack , NUM_ , t , NUM_ , n ) ; outputStack = t ; } outputStack [ outputStackTop ++ ] = type ; int top = owner . inputStackTop + outputStackTop ; if ( top > owner . outputStackMax ) { owner . outputStackMax = top ; } }
static private String SHORT_Max_Plus ( ) { long tempValue = Short . MAX_VALUE + NUM_ ; return String . valueOf ( tempValue ) ; }
public void firePropertyChange ( String name , Object oldValue , Object newValue ) { beanContextChildSupport . firePropertyChange ( name , oldValue , newValue ) ; }
public static String encode ( String value ) { value = value . replace ( STR_ , STR_ ) ; value = value . replace ( STR_ , STR_ ) ; value = value . replace ( STR_ , STR_ ) ; value = value . replace ( STR_ , STR_ ) ; value = value . replace ( STR_ , STR_ ) ; value = value . replace ( STR_ , STR_ ) ; return value ; }
public void createDatabaseEntitiesForStoragePolicyTesting ( ) { createDatabaseEntitiesForStoragePolicyTesting ( AbstractServiceTest . STORAGE_POLICY_NAMESPACE_CD , Arrays . asList ( AbstractServiceTest . STORAGE_POLICY_RULE_TYPE ) , AbstractServiceTest . BDEF_NAMESPACE , AbstractServiceTest . BDEF_NAME , Arrays . asList ( AbstractServiceTest . FORMAT_FILE_TYPE_CODE ) , Arrays . asList ( AbstractServiceTest . STORAGE_NAME ) , Arrays . asList ( AbstractServiceTest . STORAGE_NAME_2 ) ) ; }
private PDFPage createPage ( int pagenum , PDFObject pageObj ) throws IOException { int rotation = NUM_ ; RectF mediabox = null ; RectF cropbox = null ; PDFObject mediaboxObj = getInheritedValue ( pageObj , STR_ ) ; if ( mediaboxObj != null ) { mediabox = parseRect ( mediaboxObj ) ; } PDFObject cropboxObj = getInheritedValue ( pageObj , STR_ ) ; if ( cropboxObj != null ) { cropbox = parseRect ( cropboxObj ) ; } PDFObject rotateObj = getInheritedValue ( pageObj , STR_ ) ; if ( rotateObj != null ) { rotation = rotateObj . getIntValue ( ) ; } RectF bbox = ( ( cropbox == null ) ? mediabox : cropbox ) ; return new PDFPage ( pagenum , bbox , rotation , cache ) ; }
static Map addElementToMap ( String key , Set values , Map toMap ) { if ( ( key != null ) && ( toMap != null ) ) { toMap . put ( key , values ) ; } return toMap ; }
public void saveBootProp ( ) throws IOException { if ( ! bootProp . equals ( bootPropOrg ) ) { final String propFile = jarFolder + STR_ ; final OutputStream os = new FileOutputStream ( propFile ) ; try { bootProp . store ( os , STR_ ) ; } finally { os . close ( ) ; } } }
private int append ( FileSystem fs , Configuration conf , Path src , PrintWriter writer , int currentRecordNumber ) throws IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( fs . open ( src ) ) ) ; try { String line = reader . readLine ( ) ; while ( line != null ) { if ( line . startsWith ( STR_ ) ) { line = STR_ + currentRecordNumber ++ ; } writer . println ( line ) ; line = reader . readLine ( ) ; } return currentRecordNumber ; } finally { reader . close ( ) ; } }
public PacketOutputStream writeTimestampLength ( final Calendar calendar , Timestamp ts , boolean fractionalSeconds ) { assureBufferCapacity ( fractionalSeconds ? NUM_ : NUM_ ) ; buffer . put ( ( byte ) ( fractionalSeconds ? NUM_ : NUM_ ) ) ; buffer . putShort ( ( short ) calendar . get ( Calendar . YEAR ) ) ; buffer . put ( ( byte ) ( ( calendar . get ( Calendar . MONTH ) + NUM_ ) & xff ) ) ; buffer . put ( ( byte ) ( calendar . get ( Calendar . DAY_OF_MONTH ) & xff ) ) ; buffer . put ( ( byte ) calendar . get ( Calendar . HOUR_OF_DAY ) ) ; buffer . put ( ( byte ) calendar . get ( Calendar . MINUTE ) ) ; buffer . put ( ( byte ) calendar . get ( Calendar . SECOND ) ) ; if ( fractionalSeconds ) { buffer . putInt ( ts . getNanos ( ) / NUM_ ) ; } return this ; }
public int difference ( String s1 , String s2 ) throws EncoderException { return SoundexUtils . difference ( this , s1 , s2 ) ; }
public static String morpha ( String text , boolean tags ) { if ( text . isEmpty ( ) ) { return STR_ ; } String [ ] textParts = whitespace . split ( text ) ; StringBuilder result = new StringBuilder ( ) ; try { for ( String textPart : textParts ) { Morpha morpha = new Morpha ( new StringReader ( textPart ) , tags ) ; if ( result . length ( ) != NUM_ ) { result . append ( STR_ ) ; } result . append ( morpha . next ( ) ) ; } } catch ( Error e ) { return text ; } catch ( java . io . IOException e ) { return text ; } return result . toString ( ) ; }
public static void deleteFile ( File file ) throws AdeUsageException { if ( ! file . delete ( ) ) { throw new AdeUsageException ( FAILED_DELETING_FILE + file . getPath ( ) ) ; } }
public Shape createCheckMark ( final int x , final int y , final int w , final int h ) { double xf = w / NUM_ ; double hf = h / NUM_ ; path . reset ( ) ; path . moveTo ( x , y + NUM_ . hf ) ; path . lineTo ( x + NUM_ . xf , y + NUM_ . hf ) ; path . lineTo ( x + NUM_ . xf , y + NUM_ . hf ) ; path . lineTo ( x + NUM_ . xf , y ) ; path . lineTo ( x + NUM_ . xf , y ) ; path . lineTo ( x + NUM_ . xf , y + NUM_ . hf ) ; path . closePath ( ) ; return path ; }
@ Override public synchronized void initialize ( ) { if ( ! mRootDirectory . exists ( ) ) { if ( ! mRootDirectory . mkdirs ( ) ) { VolleyLog . e ( STR_ , mRootDirectory . getAbsolutePath ( ) ) ; } return ; } File [ ] files = mRootDirectory . listFiles ( ) ; if ( files == null ) { return ; } for ( File file : files ) { FileInputStream fis = null ; try { fis = new FileInputStream ( file ) ; CacheHeader entry = CacheHeader . readHeader ( fis ) ; entry . size = file . length ( ) ; putEntry ( entry . key , entry ) ; } catch ( IOException e ) { if ( file != null ) { file . delete ( ) ; } } finally { try { if ( fis != null ) { fis . close ( ) ; } } catch ( IOException ignored ) { } } } }
public TCPChannelClient ( ExecutorService executor , TCPChannelEvents eventListener , String ip , int port ) { this . executor = executor ; executorThreadCheck = new ThreadUtils . ThreadChecker ( ) ; executorThreadCheck . detachThread ( ) ; this . eventListener = eventListener ; InetAddress address ; try { address = InetAddress . getByName ( ip ) ; } catch ( UnknownHostException e ) { reportError ( STR_ ) ; return ; } if ( address . isAnyLocalAddress ( ) ) { socket = new TCPSocketServer ( address , port ) ; } else { socket = new TCPSocketClient ( address , port ) ; } socket . start ( ) ; }
protected void cutSelectedBean ( ) { if ( Debug . debugging ( STR_ ) ) Debug . output ( STR_ ) ; if ( selectedBean == null || selectedBeanLocation == null ) { if ( Debug . debugging ( STR_ ) ) Debug . output ( STR_ + selectedBean ) ; if ( Debug . debugging ( STR_ ) ) Debug . output ( STR_ + selectedBeanLocation ) ; clearSelection ( ) ; return ; } try { serBean = new ByteArrayOutputStream ( ) ; ObjectOutputStream oos = new ObjectOutputStream ( serBean ) ; oos . writeObject ( selectedBean ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; clearSelection ( ) ; if ( Debug . debugging ( STR_ ) ) Debug . output ( STR_ ) ; return ; } cutBean = selectedBean ; selectedBeanBox . showCut ( selectedBean ) ; if ( Debug . debugging ( STR_ ) ) Debug . output ( STR_ ) ; }
public RemoverManager track ( Remover remover ) { if ( handlers == null ) { handlers = new ArrayList < > ( ) ; } handlers . add ( remover ) ; return this ; }
public void actionPerformed ( java . awt . event . ActionEvent e ) { Object source = e . getSource ( ) ; if ( ! ( source instanceof JMenuItem ) ) return ; JMenuItem mi = ( JMenuItem ) source ; String name = mi . getText ( ) ; OMGraphicHandlerLayer targetLayer = ( OMGraphicHandlerLayer ) layers . get ( name ) ; if ( targetLayer == null ) { Debug . message ( STR_ , STR_ + STR_ + name ) ; return ; } targetLayer . doAction ( ( OMGraphic ) transferData , new OMAction ( OMAction . UPDATE_GRAPHIC_MASK ) ) ; }
private void addEntry ( ) { model . addNewEntry ( ) ; removeButton . setEnabled ( BOOL_ ) ; }
private void ensureSize ( ) { if ( children == EMPTY_CHILDREN ) { children = new FPNode [ NUM_ ] ; return ; } int newsize = children . length == NUM_ ? INITIAL_SIZE : ( children . length << NUM_ ) ; children = Arrays . copyOf ( children , newsize ) ; }
public UUID ( long mostSigBits , long leastSigBits ) { this . mostSigBits = mostSigBits ; this . leastSigBits = leastSigBits ; init ( ) ; }
public static PrettyPrint indentWithSpaces ( int number ) { if ( number < NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } char [ ] chars = new char [ number ] ; Arrays . fill ( chars , STR_ ) ; return new PrettyPrint ( chars ) ; }
private static void renderHandler ( FacesContext context , UIComponent component , Collection < ClientBehaviorContext . Parameter > params , String handlerName , Object handlerValue , String behaviorEventName , String submitTarget , boolean needsSubmit , boolean includeExec ) throws IOException { ResponseWriter writer = context . getResponseWriter ( ) ; String userHandler = getNonEmptyUserHandler ( handlerValue ) ; List < ClientBehavior > behaviors = getClientBehaviors ( component , behaviorEventName ) ; if ( ( null != behaviors ) && ( behaviors . size ( ) > NUM_ ) && Util . componentIsDisabled ( component ) ) { behaviors = null ; } if ( params == null ) { params = Collections . emptyList ( ) ; } String handler = null ; switch ( getHandlerType ( behaviors , params , userHandler , needsSubmit , includeExec ) ) { case USER_HANDLER_ONLY : handler = userHandler ; break ; case SINGLE_BEHAVIOR_ONLY : handler = getSingleBehaviorHandler ( context , component , behaviors . get ( NUM_ ) , params , behaviorEventName , submitTarget , needsSubmit ) ; break ; case SUBMIT_ONLY : handler = getSubmitHandler ( context , component , params , submitTarget , BOOL_ ) ; break ; case CHAIN : handler = getChainedHandler ( context , component , behaviors , params , behaviorEventName , userHandler , submitTarget , needsSubmit ) ; break ; default : assert ( BOOL_ ) ; } writer . writeAttribute ( handlerName , handler , null ) ; }
public String constructTSDBMetricName ( ) { StringBuilder sb = new StringBuilder ( getScope ( ) ) ; if ( _namespace != null && ! _namespace . isEmpty ( ) ) { sb . append ( getNamespace ( ) ) ; } return sb . toString ( ) ; }
@ Override protected void registerNewSelector ( ) throws IOException { synchronized ( selector ) { Set < SelectionKey > keys = selector . keys ( ) ; Selector newSelector = null ; if ( selectorProvider == null ) { newSelector = Selector . open ( ) ; } else { newSelector = selectorProvider . openSelector ( ) ; } for ( SelectionKey key : keys ) { SelectableChannel ch = key . channel ( ) ; NioSession session = ( NioSession ) key . attachment ( ) ; SelectionKey newKey = ch . register ( newSelector , key . interestOps ( ) , session ) ; session . setSelectionKey ( newKey ) ; } selector . close ( ) ; selector = newSelector ; } }
public void testCase4 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int bSign = NUM_ ; byte rBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . multiply ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
protected synchronized void received ( int responseCode , String stream , String json ) { FollowerInfo result = parseFollowers ( stream , json ) ; if ( result != null ) { noError ( stream ) ; cached . put ( stream , result ) ; if ( type == Follower . Type . FOLLOWER ) { listener . receivedFollowers ( result ) ; if ( hasNewFollowers ( result . followers ) ) { listener . newFollowers ( result ) ; } } else if ( type == Follower . Type . SUBSCRIBER ) { listener . receivedSubscribers ( result ) ; } requested . add ( stream ) ; } else { String errorMessage = STR_ ; if ( responseCode == NUM_ ) { errorMessage = STR_ ; error ( stream , NUM_ ) ; } else if ( responseCode == NUM_ ) { errorMessage = STR_ ; error ( stream , NUM_ ) ; } else if ( responseCode == NUM_ || responseCode == NUM_ ) { errorMessage = STR_ ; error ( stream , NUM_ ) ; } else if ( responseCode == NUM_ ) { errorMessage = STR_ ; error ( stream , NUM_ ) ; } else { errorMessage = STR_ ; error ( stream , NUM_ ) ; } FollowerInfo errorResult = new FollowerInfo ( type , stream , errorMessage ) ; cached . put ( stream , errorResult ) ; if ( type == Follower . Type . FOLLOWER ) { listener . receivedFollowers ( errorResult ) ; } else if ( type == Follower . Type . SUBSCRIBER ) { listener . receivedSubscribers ( errorResult ) ; } } }
public static < T > List < T > select ( Connection connection , String rawSqlQuery , RowProcessor < T > rowProcessor , Object ... parameters ) throws IOException , SQLException { PreparedStatement stmt = null ; ResultSet rs = null ; try { stmt = connection . prepareStatement ( rawSqlQuery ) ; for ( int index = NUM_ ; index < parameters . length ; index ++ ) { JdbcUtils . bindParameter ( stmt , index + NUM_ , parameters [ index ] ) ; } rs = stmt . executeQuery ( ) ; List < T > result = Lists . newLinkedList ( ) ; while ( rs . next ( ) ) { result . add ( rowProcessor . process ( rs ) ) ; } return result ; } finally { JdbcUtils . closeResultSet ( rs ) ; JdbcUtils . closeStatement ( stmt ) ; } }
public static long nowInNanos ( ) { return System . nanoTime ( ) ; }
public void test_clone ( ) { Format fm = new MockFormat ( ) ; Format fmc = ( Format ) fm . clone ( ) ; assertEquals ( fm . getClass ( ) , fmc . getClass ( ) ) ; }
public Future < SyncReply > sendRequest ( int xid , SyncMessage request ) throws RemoteStoreException { ensureConnected ( ) ; RemoteSyncFuture future = new RemoteSyncFuture ( xid , connectionGeneration ) ; futureMap . put ( Integer . valueOf ( xid ) , future ) ; if ( futureMap . size ( ) > MAX_PENDING_REQUESTS ) { synchronized ( futureNotify ) { while ( futureMap . size ( ) > MAX_PENDING_REQUESTS ) { try { futureNotify . wait ( ) ; } catch ( InterruptedException e ) { throw new RemoteStoreException ( STR_ , e ) ; } } } } channel . writeAndFlush ( request ) ; return future ; }
public static boolean isEmpty ( String str ) { return ( null == str || NUM_ == str . length ( ) ) ; }
private static final boolean compareAndSetWaitStatus ( Node node , int expect , int update ) { return unsafe . compareAndSwapInt ( node , waitStatusOffset , expect , update ) ; }
public void enableDependency ( Capability c ) { if ( doNotCheckCapabilities ( ) ) { return ; } if ( c == Capability . NOMINAL_ATTRIBUTES ) { enableDependency ( Capability . BINARY_ATTRIBUTES ) ; } else if ( c == Capability . BINARY_ATTRIBUTES ) { enableDependency ( Capability . UNARY_ATTRIBUTES ) ; } else if ( c == Capability . UNARY_ATTRIBUTES ) { enableDependency ( Capability . EMPTY_NOMINAL_ATTRIBUTES ) ; } else if ( c == Capability . NOMINAL_CLASS ) { enableDependency ( Capability . BINARY_CLASS ) ; } m_Dependencies . add ( c ) ; }
public IVariable [ ] extractRobotDebugVariables ( final int stackTraceId , final Map < String , Object > newVariables ) { final RobotDebugVariablesContext currentVariablesContext = findCurrentVariablesContext ( stackTraceId ) ; Map < String , IVariable > previousVariablesMap = initPreviousVariablesState ( currentVariablesContext ) ; final Map < String , IVariable > nonGlobalVariablesMap = new LinkedHashMap < > ( ) ; if ( previousVariablesMap == null ) { initNewNonGlobalVariables ( newVariables , nonGlobalVariablesMap ) ; } else { initVariablesComparingWithPreviousState ( newVariables , previousVariablesMap , nonGlobalVariablesMap ) ; } final LinkedList < IVariable > currentVariablesList = createCurrentVariablesList ( nonGlobalVariablesMap ) ; saveCurrentVariablesState ( stackTraceId , currentVariablesContext , nonGlobalVariablesMap ) ; return currentVariablesList . toArray ( new IVariable [ currentVariablesList . size ( ) ] ) ; }
public ResourcesPoet addInteger ( String name , String value ) { Element bool = document . createElement ( STR_ ) ; bool . setAttribute ( STR_ , name ) ; bool . appendChild ( document . createTextNode ( String . valueOf ( value ) ) ) ; resourceElement . appendChild ( bool ) ; return this ; }
public static String mapFullWidthLetterToHalfWidth ( String text ) { }
private static < T > void assertCollectionEqualsNoOrder ( Collection < T > expected , Collection < T > actual ) { String msg = String . format ( STR_ , expected . toString ( ) , actual . toString ( ) ) ; assertEquals ( msg , expected . size ( ) , actual . size ( ) ) ; for ( T e : expected ) { if ( ! actual . contains ( e ) ) { msg = String . format ( STR_ + STR_ , e , expected , actual ) ; fail ( msg ) ; } } }
private static boolean hasResponseBody ( int requestMethod , int responseCode ) { return requestMethod != Request . Method . HEAD && ! ( HttpStatus . SC_CONTINUE <= responseCode && responseCode < HttpStatus . SC_OK ) && responseCode != HttpStatus . SC_NO_CONTENT && responseCode != HttpStatus . SC_NOT_MODIFIED ; }
public int availableInProcess ( ) { return Math . max ( NUM_ , maxInProcess - pending . size ( ) ) ; }
public void add ( double x ) { Cell [ ] as ; long b , v ; int m ; Cell a ; if ( ( as = cells ) != null || ! casBase ( b = base , Double . doubleToRawLongBits ( Double . longBitsToDouble ( b ) + x ) ) ) { boolean uncontended = BOOL_ ; if ( as == null || ( m = as . length - NUM_ ) < NUM_ || ( a = as [ getProbe ( ) & m ] ) == null || ! ( uncontended = a . cas ( v = a . value , Double . doubleToRawLongBits ( Double . longBitsToDouble ( v ) + x ) ) ) ) doubleAccumulate ( x , null , uncontended ) ; } }
public boolean shouldExecuteAction ( ) { if ( delay <= NUM_ ) { return BOOL_ ; } long timePassed = System . currentTimeMillis ( ) - lastActionExecuted ; if ( timePassed > delay . NUM_ ) { lastActionExecuted = System . currentTimeMillis ( ) ; return BOOL_ ; } return BOOL_ ; }
public static int moveByWord ( String text , int column , boolean forward , boolean returnCursorAtEnd ) { int curColumn = column ; int length = text . length ( ) ; int direction = forward ? NUM_ : - NUM_ ; boolean farWordEnd = ( ( direction == NUM_ && returnCursorAtEnd ) || ( direction == - NUM_ && ! returnCursorAtEnd ) ) ; boolean foundEarlyMatch = BOOL_ ; if ( ! UnicodeUtils . isWhitespace ( text . charAt ( curColumn ) ) ) { curColumn = skipNonwhitespaceSimilar ( text , curColumn , forward ) ; if ( farWordEnd && curColumn - direction != column ) { curColumn -= direction ; foundEarlyMatch = BOOL_ ; } } if ( ! foundEarlyMatch && curColumn >= NUM_ && curColumn < length ) { curColumn = skipWhitespace ( text , curColumn , forward ) ; if ( farWordEnd && curColumn >= NUM_ && curColumn < length ) { curColumn = skipNonwhitespaceSimilar ( text , curColumn , forward ) - direction ; } } if ( curColumn < NUM_ || curColumn >= length ) { return - NUM_ ; } return curColumn ; }
protected void handleOrDeferMessage ( DistributionMessage msg ) { synchronized ( startupLock ) { if ( beingSick || playingDead ) { if ( msg . containsRegionContentChange ( ) || msg instanceof PartitionMessageWithDirectReply ) { startupMessages . add ( new StartupEvent ( msg ) ) ; return ; } } if ( ! processingEvents ) { startupMessages . add ( new StartupEvent ( msg ) ) ; return ; } } dispatchMessage ( msg ) ; }
public boolean zoneExportRemoveVolumes ( List < NetworkZoningParam > zoningParams , Collection < URI > volumeURIs , String stepId ) { NetworkZoningParam zoningParam = zoningParams . get ( NUM_ ) ; _log . info ( String . format ( STR_ , zoningParam . getExportGroupDisplay ( ) , volumeURIs . toString ( ) ) ) ; return doZoneExportMasksDelete ( zoningParams , volumeURIs , stepId ) ; }
private void shutdown ( ) { if ( nbestListWriter != null ) { logger . info ( STR_ ) ; nbestListWriter . close ( ) ; } if ( alignmentWriter != null ) { logger . info ( STR_ ) ; alignmentWriter . close ( ) ; } }
@ Override public void paintIcon ( Component c , Graphics g , int x , int y ) { Painter painter = ( Painter ) UIManager . get ( prefix + STR_ + key ) ; if ( painter != null ) { JComponent jc = ( c instanceof JComponent ) ? ( JComponent ) c : null ; Graphics2D gfx = ( Graphics2D ) g ; gfx . translate ( x , y ) ; painter . paint ( gfx , jc , width , height ) ; gfx . translate ( - x , - y ) ; } }
protected void zoomImageToPosition ( float scale , float centerX , float centerY , long durationMs ) { if ( scale > getMaxScale ( ) ) { scale = getMaxScale ( ) ; } final float oldScale = getCurrentScale ( ) ; final float deltaScale = scale - oldScale ; post ( mZoomImageToPositionRunnable = new ZoomImageToPosition ( CropImageView . this , durationMs , oldScale , deltaScale , centerX , centerY ) ) ; }
public List < Map < String , String > > list ( Database conn ) throws SQLException { ResultSet rs = null ; Statement statement = conn . createStatement ( ) ; List < Map < String , String > > shardToChannels = new ArrayList < Map < String , String > > ( ) ; try { rs = statement . executeQuery ( select ) ; while ( rs . next ( ) ) { Map < String , String > shard = new HashMap < String , String > ( ) ; shard . put ( ShardChannelTable . SHARD_ID_COL , rs . getString ( ShardChannelTable . SHARD_ID_COL ) ) ; shard . put ( ShardChannelTable . CHANNEL_COL , rs . getString ( ShardChannelTable . CHANNEL_COL ) ) ; shardToChannels . add ( shard ) ; } } finally { close ( rs ) ; close ( statement ) ; } return shardToChannels ; }
public Boolean isHidden ( File f ) { String name = f . getName ( ) ; if ( ( name != null ) && ! name . equals ( STR_ ) && ( name . charAt ( NUM_ ) == STR_ ) ) { return Boolean . TRUE ; } else { return Boolean . FALSE ; } }
private boolean scrollViewCanScrollVertically ( ScrollView scrollView , int direction ) { final int offset = Math . max ( NUM_ , scrollView . getScrollY ( ) ) ; final int range = computeVerticalScrollRange ( scrollView ) - scrollView . getHeight ( ) ; if ( range == NUM_ ) return BOOL_ ; if ( direction < NUM_ ) { return offset > NUM_ ; } else { return offset < range - NUM_ ; } }
public JarInfo loadJar ( ) throws IOException { ZipInputStream zis = null ; Manifest mf = null ; boolean empty = BOOL_ ; try { zis = new ZipInputStream ( jarStream ) ; ZipEntry ent = null ; while ( ( ent = zis . getNextEntry ( ) ) != null ) { empty = BOOL_ ; String name = ent . getName ( ) ; if ( Manifest . isManifestName ( name ) ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; byte buffer [ ] = new byte [ NUM_ ] ; for ( ; ; ) { int len = zis . read ( buffer ) ; if ( len < NUM_ ) { break ; } baos . write ( buffer , NUM_ , len ) ; } byte [ ] buf = baos . toByteArray ( ) ; mf = new Manifest ( buf ) ; } } } catch ( IOException ex ) { throw ex ; } catch ( Throwable th ) { th . printStackTrace ( ) ; throw new IOException ( STR_ + th ) ; } finally { if ( zis != null ) { try { zis . close ( ) ; } catch ( Exception ex ) { } } } if ( empty ) { throw new IOException ( STR_ ) ; } JarInfo ji = createJarInfo ( mf ) ; return ji ; }
public void invalidateTitleSortable ( ) { for ( Movie movie : new ArrayList < > ( movieList ) ) { movie . clearTitleSortable ( ) ; } }
public void addRow ( Assignment head , double prob ) { if ( prob < NUM_ || prob > NUM_ ) { return ; } headVars . addAll ( head . getVariables ( ) ) ; table . put ( head , prob ) ; }
public byte [ ] createJarFromFileContent ( final String fileName , final String content ) throws IOException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream ( ) ; JarOutputStream jarOutputStream = new JarOutputStream ( byteArrayOutputStream ) ; JarEntry entry = new JarEntry ( fileName ) ; entry . setTime ( System . currentTimeMillis ( ) ) ; jarOutputStream . putNextEntry ( entry ) ; jarOutputStream . write ( content . getBytes ( ) ) ; jarOutputStream . closeEntry ( ) ; jarOutputStream . close ( ) ; return byteArrayOutputStream . toByteArray ( ) ; }
private boolean goTo ( long day , boolean animate , boolean setSelected , boolean forceScroll ) { if ( setSelected ) { mSelectedDay . setTimeInMillis ( day ) ; } mTempDay . setTimeInMillis ( day ) ; final int position = getPositionFromDay ( day ) ; View child ; int i = NUM_ ; int top = NUM_ ; do { child = getChildAt ( i ++ ) ; if ( child == null ) { break ; } top = child . getTop ( ) ; } while ( top < NUM_ ) ; int selectedPosition ; if ( child != null ) { selectedPosition = getPositionForView ( child ) ; } else { selectedPosition = NUM_ ; } if ( setSelected ) { mAdapter . setSelectedDay ( mSelectedDay ) ; } if ( position != selectedPosition || forceScroll ) { setMonthDisplayed ( mTempDay ) ; mPreviousScrollState = OnScrollListener . SCROLL_STATE_FLING ; if ( animate ) { smoothScrollToPositionFromTop ( position , LIST_TOP_OFFSET , GOTO_SCROLL_DURATION ) ; return BOOL_ ; } else { postSetSelection ( position ) ; } } else if ( setSelected ) { setMonthDisplayed ( mSelectedDay ) ; } return BOOL_ ; }
public boolean search ( V v ) { int h = hashMethod . hash ( v ) ; LinkedList < V > list = ( LinkedList < V > ) table [ h ] ; if ( list == null ) { return BOOL_ ; } return list . contains ( v ) ; }
public void closeJDBCConnection ( Connection conn ) { try { if ( conn != null ) { conn . close ( ) ; } } catch ( SQLException sqle ) { subclassLogWrapper ( STR_ ) ; } }
@ Override public void messageItemDetails ( String strClass , String item , String description , String [ ] msgOption , int [ ] msgNumber , int defaultOption ) { HashMap < Integer , String > options = new HashMap < > ( msgOption . length ) ; for ( int i = NUM_ ; i < msgOption . length ; i ++ ) { options . put ( msgNumber [ i ] , msgOption [ i ] ) ; } messageItemDetails ( strClass , description , item , options , defaultOption ) ; }
public void addListener ( ColorMapListener listener ) { listeners . add ( listener ) ; }
protected void computePDists ( Relation < O > relation , KNNQuery < O > knn , WritableDoubleDataStore pdists ) { FiniteProgress prdsProgress = LOG . isVerbose ( ) ? new FiniteProgress ( STR_ , relation . size ( ) , LOG ) : null ; for ( DBIDIter iditer = relation . iterDBIDs ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { final KNNList neighbors = knn . getKNNForDBID ( iditer , kreach + NUM_ ) ; int ks = NUM_ ; double ssum = NUM_ ; for ( DoubleDBIDListIter neighbor = neighbors . iter ( ) ; neighbor . valid ( ) && ks < kreach ; neighbor . advance ( ) ) { if ( DBIDUtil . equal ( neighbor , iditer ) ) { continue ; } final double d = neighbor . doubleValue ( ) ; ssum += d . d ; ks ++ ; } double pdist = ks > NUM_ ? Math . sqrt ( ssum / ks ) : NUM_ ; pdists . putDouble ( iditer , pdist ) ; LOG . incrementProcessed ( prdsProgress ) ; } LOG . ensureCompleted ( prdsProgress ) ; }
private static String appendIfMissing ( final String str , final CharSequence suffix , final boolean ignoreCase , final CharSequence ... suffixes ) { if ( str == null || isEmpty ( suffix ) || endsWith ( str , suffix , ignoreCase ) ) { return str ; } if ( suffixes != null && suffixes . length > NUM_ ) { for ( final CharSequence s : suffixes ) { if ( endsWith ( str , s , ignoreCase ) ) { return str ; } } } return str + suffix . toString ( ) ; }
private JSONArray requestAllFileSystems ( ) throws IOException , JSONException { JSONArray ret = new JSONArray ( ) ; for ( Filesystem fs : filesystems ) { ret . put ( fs . getRootEntry ( ) ) ; } return ret ; }
ExternalProblem ( Process process ) { this ( process . getInputStream ( ) , process . getOutputStream ( ) ) ; RedirectStream . redirect ( process . getErrorStream ( ) , System . err ) ; }
protected static boolean networkMonitorExist ( String nwMonName ) { String classMethod = STR_ ; if ( debug . messageEnabled ( ) ) { debug . message ( classMethod + STR_ + nwMonName ) ; } if ( ( nwMonName == null ) || ( nwMonName . length ( ) == NUM_ ) ) { if ( debug . warningEnabled ( ) ) { debug . warning ( classMethod + STR_ ) ; } return BOOL_ ; } Set < String > ntwStats = NetworkMonitor . getInstanceNames ( ) ; String ss = nwMonName . toLowerCase ( ) ; if ( ntwStats . contains ( ss ) ) { return BOOL_ ; } else { return BOOL_ ; } }
protected boolean error_recovery ( boolean debug ) throws java . lang . Exception { if ( debug ) debug_message ( STR_ ) ; if ( ! find_recovery_config ( debug ) ) { if ( debug ) debug_message ( STR_ ) ; return BOOL_ ; } read_lookahead ( ) ; for ( ; ; ) { if ( debug ) debug_message ( STR_ ) ; if ( try_parse_ahead ( debug ) ) { break ; } if ( lookahead [ NUM_ ] . sym == EOF_sym ( ) ) { if ( debug ) debug_message ( STR_ ) ; return BOOL_ ; } if ( debug ) debug_message ( STR_ + lookahead [ NUM_ ] . sym ) ; restart_lookahead ( ) ; } if ( debug ) debug_message ( STR_ ) ; parse_lookahead ( debug ) ; return BOOL_ ; }
public void andWith ( List < QueryPredicate > predicates ) { children . addAll ( predicates ) ; }
public void addRoll ( MMRandom rng ) { int result = rng . randomInt ( this . faces ) + this . min ; all . addElement ( new Integer ( result ) ) ; this . total += result ; if ( keep != - NUM_ && all . size ( ) >= keep ) { this . total = NUM_ ; Collections . sort ( all , Collections . reverseOrder ( ) ) ; for ( int i = NUM_ ; i < keep ; i ++ ) { this . total += all . get ( i ) ; } } }
public boolean checkCanonicalUserOptions ( ) { boolean result ; OptionHandler handler ; String [ ] userOptions ; String [ ] userOptionsCheck ; print ( STR_ ) ; try { handler = getDefaultHandler ( ) ; handler . setOptions ( getUserOptions ( ) ) ; if ( getDebug ( ) ) { print ( STR_ ) ; } userOptions = handler . getOptions ( ) ; if ( getDebug ( ) ) { println ( printOptions ( userOptions ) ) ; } if ( getDebug ( ) ) { println ( STR_ ) ; } handler . setOptions ( userOptions . clone ( ) ) ; if ( getDebug ( ) ) { println ( STR_ ) ; } userOptionsCheck = handler . getOptions ( ) ; compareOptions ( userOptions , userOptionsCheck ) ; println ( STR_ ) ; result = BOOL_ ; } catch ( Exception e ) { println ( STR_ ) ; result = BOOL_ ; if ( getDebug ( ) ) { println ( e ) ; } } return result ; }
public static void closeQuietly ( final Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( final RuntimeException rethrown ) { throw rethrown ; } catch ( final Exception ignored ) { } } }
public static void pushEncryptedMessage ( final TextSecureEnvelope envelope ) { while ( BOOL_ ) { try { queue . put ( envelope ) ; return ; } catch ( final InterruptedException e ) { } } }
public void test_simplePrematureClose ( ) { Striterator iter = new Striterator ( m_data . iterator ( ) ) ; int i = NUM_ ; while ( iter . hasNext ( ) ) { iter . next ( ) ; if ( ++ i == NUM_ ) { iter . close ( ) ; assertTrue ( ! iter . hasNext ( ) ) ; } } assertTrue ( ! iter . isOpen ( ) ) ; assertTrue ( i == NUM_ ) ; }
public void pushDrawList ( PspGeList list ) { synchronized ( drawListQueue ) { drawListQueue . add ( list ) ; } }
private void populateTaskList ( Volume source , Map < BlockMirror , Volume > groupMirrorSourceMap , TaskList taskList , String taskId , ResourceOperationTypeEnum operationType ) { Set < URI > groupSet = new HashSet < URI > ( ) ; addTask ( taskList , source , taskId , operationType ) ; for ( Entry < BlockMirror , Volume > entry : groupMirrorSourceMap . entrySet ( ) ) { BlockMirror mirror = entry . getKey ( ) ; Volume mirrorSource = entry . getValue ( ) ; if ( source . isInCG ( ) && null != taskList . getTaskList ( ) ) { groupSet . add ( mirrorSource . getConsistencyGroup ( ) ) ; } } List < BlockConsistencyGroup > groups = _dbClient . queryObject ( BlockConsistencyGroup . class , groupSet ) ; for ( BlockConsistencyGroup group : groups ) { addTask ( taskList , group , taskId , operationType ) ; } }
public static Tuple max ( Iterator tuples , String field , Comparator cmp ) { Tuple t = null , tmp ; Object min = null ; if ( tuples . hasNext ( ) ) { t = ( Tuple ) tuples . next ( ) ; min = t . get ( field ) ; } while ( tuples . hasNext ( ) ) { tmp = ( Tuple ) tuples . next ( ) ; Object obj = tmp . get ( field ) ; if ( cmp . compare ( obj , min ) > NUM_ ) { t = tmp ; min = obj ; } } return t ; }
public String clusterDefinitionsTipText ( ) { return STR_ ; }
public void testConstructorSignBytesPositive1 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ } ; int aSign = NUM_ ; byte rBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , aNumber . signum ( ) ) ; }
public void fling ( int startX , int startY , int velocityX , int velocityY , int minX , int maxX , int minY , int maxY , int overX , int overY ) { if ( mFlywheel && ! isFinished ( ) ) { float oldVelocityX = mScrollerX . mCurrVelocity ; float oldVelocityY = mScrollerY . mCurrVelocity ; if ( Math . signum ( velocityX ) == Math . signum ( oldVelocityX ) && Math . signum ( velocityY ) == Math . signum ( oldVelocityY ) ) { velocityX += oldVelocityX ; velocityY += oldVelocityY ; } } mMode = FLING_MODE ; mScrollerX . fling ( startX , velocityX , minX , maxX , overX ) ; mScrollerY . fling ( startY , velocityY , minY , maxY , overY ) ; }
public Map < String , Object > convertDataToObjects ( Map < String , String > data ) { Map < String , Object > results = new HashMap < > ( ) ; if ( data != null ) { for ( String key : data . keySet ( ) ) { results . put ( key , data . get ( key ) ) ; } } return results ; }
private static char [ ] zzUnpackCMap ( String packed ) { char [ ] map = new char [ x10000 ] ; int i = NUM_ ; int j = NUM_ ; while ( i < NUM_ ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM_ ) ; } return map ; }
public void addListener ( NavigatorListener listener ) { listeners . add ( listener ) ; }
public void closeStream ( ) { CarbonUtil . closeStreams ( stream ) ; executorService . shutdown ( ) ; }
public double patience ( int k , F f , int N ) { double pf = p ( f ) ; BinomialDistribution dist = new BinomialDistribution ( null , N , pf ) ; double p0 = Math . pow ( NUM_ - pf , N ) ; return NUM_ - ( dist . cumulativeProbability ( k - NUM_ ) - p0 ) / ( NUM_ - p0 ) ; }
public static List seriesNameListFromDataArray ( Object [ ] [ ] data ) { int seriesCount = data . length ; List seriesNameList = new java . util . ArrayList ( seriesCount ) ; for ( int i = NUM_ ; i < seriesCount ; i ++ ) { seriesNameList . add ( STR_ + ( i + NUM_ ) ) ; } return seriesNameList ; }
@ Override public int read ( char b [ ] , int off , int len ) throws IOException { ensureOpen ( ) ; if ( ( off < NUM_ ) || ( off > b . length ) || ( len < NUM_ ) || ( ( off + len ) > b . length ) || ( ( off + len ) < NUM_ ) ) { throw new IndexOutOfBoundsException ( ) ; } else if ( len == NUM_ ) { return NUM_ ; } if ( pos >= count ) { return - NUM_ ; } if ( pos + len > count ) { len = count - pos ; } if ( len <= NUM_ ) { return NUM_ ; } System . arraycopy ( buf , pos , b , off , len ) ; pos += len ; return len ; }
public static void f ( String tag , String msg , Object ... args ) { if ( sLevel > LEVEL_FATAL ) { return ; } if ( args . length > NUM_ ) { msg = String . format ( msg , args ) ; } Log . wtf ( tag , msg ) ; }
private static void expandNumberAt ( String numberString , int startIndex , WordRelation wordRelation ) { expandNumber ( numberString . substring ( startIndex , numberString . length ( ) ) , wordRelation ) ; }
public static boolean nullEquals ( String s1 , String s2 ) { return ( s1 == null ? s2 == null : s1 . equals ( s2 ) ) ; }
@ Override public void run ( ) { MultipleObjectsBundle data = generator . loadData ( ) ; if ( LOG . isVerbose ( ) ) { LOG . verbose ( STR_ ) ; } try { if ( outputFile . exists ( ) && LOG . isVerbose ( ) ) { LOG . verbose ( STR_ + outputFile + STR_ + STR_ ) ; } try ( OutputStreamWriter outStream = new FileWriter ( outputFile , BOOL_ ) ) { writeClusters ( outStream , data ) ; } } catch ( IOException e ) { throw new AbortException ( STR_ , e ) ; } if ( LOG . isVerbose ( ) ) { LOG . verbose ( STR_ ) ; } }
private boolean usedAllRule17Directors ( Set < String > allocatedDirectors , PortAllocationContext context ) { Set < String > rule17Directors = getRule17Directors ( context ) ; for ( String director : allocatedDirectors ) { rule17Directors . remove ( director ) ; } return rule17Directors . isEmpty ( ) ; }
public void stop ( ) { synchronized ( privateInstanceLock ) { if ( connectionAcceptThread == null ) { return ; } } isStopped . set ( BOOL_ ) ; try { connectionAcceptThread . interrupt ( ) ; connectionAcceptThread . join ( ) ; } catch ( InterruptedException e ) { } try { serverSocket . close ( ) ; } catch ( IOException e ) { } }
private static String expandSystemIdStrictOn ( String systemId , String baseSystemId ) throws URI . MalformedURIException { URI systemURI = new URI ( systemId , BOOL_ ) ; if ( systemURI . isAbsoluteURI ( ) ) { return systemId ; } URI baseURI = null ; if ( baseSystemId == null || baseSystemId . length ( ) == NUM_ ) { baseURI = getUserDir ( ) ; } else { baseURI = new URI ( baseSystemId , BOOL_ ) ; if ( ! baseURI . isAbsoluteURI ( ) ) { baseURI . absolutize ( getUserDir ( ) ) ; } } systemURI . absolutize ( baseURI ) ; return systemURI . toString ( ) ; }
public static void free ( DMessage msg ) { int index = size2Index ( msg . getSize ( ) ) ; msg . clear ( ) ; if ( index < NUM_ ) ; else if ( m_cache [ index ] != null ) ; else m_cache [ index ] = msg ; }
public boolean equalsIgnoreCase ( final StrBuilder other ) { if ( this == other ) { return BOOL_ ; } if ( this . size != other . size ) { return BOOL_ ; } final char thisBuf [ ] = this . buffer ; final char otherBuf [ ] = other . buffer ; for ( int i = size - NUM_ ; i >= NUM_ ; i -- ) { final char c1 = thisBuf [ i ] ; final char c2 = otherBuf [ i ] ; if ( c1 != c2 && Character . toUpperCase ( c1 ) != Character . toUpperCase ( c2 ) ) { return BOOL_ ; } } return BOOL_ ; }
protected static Long convertUuidToLong ( UUID uuid ) { if ( uuid == null ) { return null ; } Long convertedUuid ; if ( uuid . version ( ) == NUM_ ) { convertedUuid = uuid . timestamp ( ) ; } else { convertedUuid = uuid . getMostSignificantBits ( ) ; } return convertedUuid ; }
public void addVMArguments ( String vmArgumentName , String vmArgumentValue ) { VmArgumentData vmArg = new VmArgumentData ( vmArgumentName , vmArgumentValue ) ; vmSet . add ( vmArg ) ; }
private void applyTo ( ClassVisitor v , Field f ) { if ( Log . isLoggingOn ( ) ) { Log . logLine ( String . format ( STR_ , f . toGenericString ( ) ) ) ; } v . visit ( f ) ; }
public void testCompareToEqualNeg ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = - NUM_ ; int bSign = - NUM_ ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; assertEquals ( NUM_ , aNumber . compareTo ( bNumber ) ) ; }
public void testScreenshot ( ) throws Exception { Log . d ( LOG_TAG , STR_ ) ; ScreenshotStubActivity activity = getActivity ( ) ; assertNotNull ( activity ) ; File screenshotDir = getScreenshotDir ( ) ; NewScreenshotObserver observer = new NewScreenshotObserver ( screenshotDir . getAbsolutePath ( ) ) ; observer . startWatching ( ) ; takeScreenshot ( ) ; if ( observer . getCreatedPath ( ) == null ) { synchronized ( observer ) { observer . wait ( SCREEN_WAIT_TIME_SEC . NUM_ ) ; } } assertNotNull ( String . format ( STR_ , SCREEN_WAIT_TIME_SEC ) , observer . getCreatedPath ( ) ) ; File screenshotFile = new File ( screenshotDir , observer . getCreatedPath ( ) ) ; try { assertTrue ( String . format ( STR_ , screenshotFile . getName ( ) ) , screenshotFile . isFile ( ) ) ; assertTrue ( String . format ( STR_ , screenshotFile . getName ( ) ) , isValidImage ( screenshotFile ) ) ; } finally { screenshotFile . delete ( ) ; } }
public TaskResourceRep unlinkTargetVolumesFromSnapshotSession ( URI snapSessionURI , SnapshotSessionUnlinkTargetsParam param ) { return unlinkTargetVolumesFromSnapshotSession ( snapSessionURI , param , OperationTypeEnum . UNLINK_SNAPSHOT_SESSION_TARGET ) ; }
private List reverse ( List seq ) { LinkedList newSeq = new LinkedList ( ) ; for ( Iterator i = seq . iterator ( ) ; i . hasNext ( ) ; ) { DirectedEdge de = ( DirectedEdge ) i . next ( ) ; newSeq . addFirst ( de . getSym ( ) ) ; } return newSeq ; }
protected LocPathIterator changePartToRef ( final QName uniquePseudoVarName , WalkingIterator wi , final int numSteps , final boolean isGlobal ) { Variable var = new Variable ( ) ; var . setQName ( uniquePseudoVarName ) ; var . setIsGlobal ( isGlobal ) ; if ( isGlobal ) { ElemTemplateElement elem = getElemFromExpression ( wi ) ; StylesheetRoot root = elem . getStylesheetRoot ( ) ; Vector vars = root . getVariablesAndParamsComposed ( ) ; var . setIndex ( vars . size ( ) - NUM_ ) ; } AxesWalker walker = wi . getFirstWalker ( ) ; for ( int i = NUM_ ; i < numSteps ; i ++ ) { assertion ( null != walker , STR_ ) ; walker = walker . getNextWalker ( ) ; } if ( null != walker ) { FilterExprWalker few = new FilterExprWalker ( wi ) ; few . setInnerExpression ( var ) ; few . exprSetParent ( wi ) ; few . setNextWalker ( walker ) ; walker . setPrevWalker ( few ) ; wi . setFirstWalker ( few ) ; return wi ; } else { FilterExprIteratorSimple feis = new FilterExprIteratorSimple ( var ) ; feis . exprSetParent ( wi . exprGetParent ( ) ) ; return feis ; } }
@ Deprecated @ Override public String readLine ( ) throws IOException { StringBuilder b = new StringBuilder ( NUM_ ) ; int chr ; while ( ( chr = read ( ) ) >= NUM_ ) { if ( chr != STR_ ) { b . append ( ( char ) chr ) ; } else { return b . toString ( ) ; } } return b . toString ( ) ; }
private void addToScene ( final Node items ) { collection . add ( items ) ; }
public String documentationHomePageUrl ( ) { return properties . getProperty ( STR_ ) ; }
public static boolean hasTaxonomyInfo ( SequencesReader reader ) { final File taxonFile = new File ( reader . path ( ) , TAXONOMY_FILE ) ; final File mappingFile = new File ( reader . path ( ) , TAXONOMY_TO_SEQUENCE_FILE ) ; if ( taxonFile . exists ( ) && mappingFile . exists ( ) ) { return BOOL_ ; } else if ( taxonFile . exists ( ) || mappingFile . exists ( ) ) { throw new NoTalkbackSlimException ( STR_ ) ; } else { return BOOL_ ; } }
public void removeSelectionListener ( final SelectionListener listener ) { checkWidget ( ) ; if ( listener == null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } listOfSelectionListeners . remove ( listener ) ; }
public void replace ( ClassNode type , int n ) { remove ( n ) ; push ( type ) ; }
public void handleButton1Request ( RequestInvocationEvent event ) throws ModelControlException { submitCycle = BOOL_ ; EntitiesModel model = ( EntitiesModel ) getModel ( ) ; AMPropertySheet prop = ( AMPropertySheet ) getChild ( PROPERTY_ATTRIBUTE ) ; String universalId = ( String ) getPageSessionAttribute ( UNIVERSAL_ID ) ; try { Map oldValues = model . getAttributeValues ( universalId , BOOL_ ) ; Map values = prop . getAttributeValues ( oldValues , BOOL_ , model ) ; String curRealm = ( String ) getPageSessionAttribute ( AMAdminConstants . CURRENT_REALM ) ; model . modifyEntity ( curRealm , universalId , values ) ; setInlineAlertMessage ( CCAlert . TYPE_INFO , STR_ , STR_ ) ; } catch ( AMConsoleException e ) { setInlineAlertMessage ( CCAlert . TYPE_ERROR , STR_ , e . getMessage ( ) ) ; } forwardTo ( ) ; }
private static Boolean isInsidePolygon ( final GeoPoint point , final List < GeoPoint > polyPoints ) { final double latitude = point . getLatitude ( ) ; final double longitude = point . getLongitude ( ) ; final double sinLatitude = Math . sin ( latitude ) ; final double cosLatitude = Math . cos ( latitude ) ; final double sinLongitude = Math . sin ( longitude ) ; final double cosLongitude = Math . cos ( longitude ) ; double arcDistance = NUM_ ; Double prevAngle = null ; for ( final GeoPoint polyPoint : polyPoints ) { final Double angle = computeAngle ( polyPoint , sinLatitude , cosLatitude , sinLongitude , cosLongitude ) ; if ( angle == null ) { return null ; } if ( prevAngle != null ) { double angleDelta = angle - prevAngle ; if ( angleDelta < - Math . PI ) { angleDelta += Math . PI . NUM_ ; } if ( angleDelta > Math . PI ) { angleDelta -= Math . PI . NUM_ ; } if ( Math . abs ( angleDelta - Math . PI ) < Vector . MINIMUM_RESOLUTION ) { return null ; } arcDistance += angleDelta ; } prevAngle = angle ; } if ( prevAngle != null ) { final Double lastAngle = computeAngle ( polyPoints . get ( NUM_ ) , sinLatitude , cosLatitude , sinLongitude , cosLongitude ) ; if ( lastAngle == null ) { return null ; } double angleDelta = lastAngle - prevAngle ; if ( angleDelta < - Math . PI ) { angleDelta += Math . PI . NUM_ ; } if ( angleDelta > Math . PI ) { angleDelta -= Math . PI . NUM_ ; } if ( Math . abs ( angleDelta - Math . PI ) < Vector . MINIMUM_RESOLUTION ) { return null ; } arcDistance += angleDelta ; } if ( Math . abs ( arcDistance ) < Vector . MINIMUM_RESOLUTION ) { return null ; } return arcDistance > NUM_ ; }
private Node deleteMax ( Node x ) { if ( x . right == null ) return x . left ; x . right = deleteMax ( x . right ) ; x . size = NUM_ + size ( x . left ) + size ( x . right ) ; x . height = NUM_ + Math . max ( height ( x . left ) , height ( x . right ) ) ; return balance ( x ) ; }
public void clear ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { for ( Node < E > f = first ; f != null ; ) { f . item = null ; Node < E > n = f . next ; f . prev = null ; f . next = null ; f = n ; } first = last = null ; count = NUM_ ; notFull . signalAll ( ) ; } finally { lock . unlock ( ) ; } }
protected void onProgress ( int itemcount , int size ) { }
private TreeNode ( long nodeValue , SnmpMibAgent agent , TreeNode sup ) { this . nodeValue = nodeValue ; this . parent = sup ; agents . addElement ( agent ) ; }
public Week ( Date time ) { this ( time , TimeZone . getDefault ( ) , Locale . getDefault ( ) ) ; }
public CodeAttribute createCode ( ) { CodeAttribute code = new CodeAttribute ( ) ; for ( int i = NUM_ ; i < _attributes . size ( ) ; i ++ ) { Attribute attr = _attributes . get ( i ) ; if ( attr instanceof CodeAttribute ) return ( CodeAttribute ) attr ; } return null ; }
public BinaryOut ( String filename ) { try { OutputStream os = new FileOutputStream ( filename ) ; out = new BufferedOutputStream ( os ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
protected ObjectStreamClass readClassDescriptor ( ) throws IOException , ClassNotFoundException { ObjectStreamClass newClassDesc = new ObjectStreamClass ( ) ; String name = input . readUTF ( ) ; if ( name . length ( ) == NUM_ ) { throw new IOException ( STR_ ) ; } newClassDesc . setName ( name ) ; newClassDesc . setSerialVersionUID ( input . readLong ( ) ) ; newClassDesc . setFlags ( input . readByte ( ) ) ; if ( descriptorHandle == - NUM_ ) { descriptorHandle = nextHandle ( ) ; } registerObjectRead ( newClassDesc , descriptorHandle , BOOL_ ) ; readFieldDescriptors ( newClassDesc ) ; return newClassDesc ; }
public static boolean createNewFile ( File targetFile ) { if ( targetFile . exists ( ) ) targetFile . delete ( ) ; try { return targetFile . createNewFile ( ) ; } catch ( IOException e ) { return BOOL_ ; } }
public void testZeroOne ( ) { byte aBytes [ ] = { NUM_ } ; byte bBytes [ ] = { NUM_ } ; int aSign = NUM_ ; int bSign = NUM_ ; byte rBytes [ ] = { NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . or ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
protected int executePrepareStatement ( List < Column > columns , PreparedStatement statement ) throws SQLException { int bindNo = NUM_ ; for ( Column c : columns ) { setColumnValue ( statement , bindNo , c ) ; bindNo ++ ; } return statement . executeUpdate ( ) ; }
public Config ( SamlAuthorityConfiguration samlAuthorityConfig , TokenRestrictions tokenRestrictions , Collection < List < Certificate > > validCerts , long clockTolerance , Collection < IDPConfig > inExternalIdps ) { Validate . notNull ( samlAuthorityConfig ) ; Validate . notNull ( tokenRestrictions ) ; Validate . notEmpty ( validCerts ) ; List < Certificate > authorityCert = samlAuthorityConfig . getSigningCertificateChain ( ) ; boolean authorityCertInValidCerts = BOOL_ ; for ( List < Certificate > currentChain : validCerts ) { Validate . notEmpty ( currentChain ) ; Validate . noNullElements ( currentChain ) ; if ( ! authorityCertInValidCerts && currentChain . equals ( authorityCert ) ) { authorityCertInValidCerts = BOOL_ ; } } Validate . isTrue ( authorityCertInValidCerts , STR_ ) ; Validate . isTrue ( clockTolerance >= NUM_ ) ; this . samlAuthorityConfig = samlAuthorityConfig ; this . validCerts = validCerts ; this . clockTolerance = clockTolerance ; this . tokenRestrictions = tokenRestrictions ; HashMap < String , IDPConfig > idpsSet = new HashMap < String , IDPConfig > ( ) ; if ( inExternalIdps != null ) { for ( IDPConfig conf : inExternalIdps ) { if ( conf != null ) { idpsSet . put ( conf . getEntityID ( ) , conf ) ; } } } this . externalIdps = Collections . unmodifiableMap ( idpsSet ) ; }
public static void checkNotEmpty ( String string ) { if ( string . isEmpty ( ) ) { throw new NullPointerException ( ) ; } }
protected void addCommonComponent ( XMLComponent component ) { if ( fCommonComponents . contains ( component ) ) { return ; } fCommonComponents . add ( component ) ; addRecognizedParamsAndSetDefaults ( component ) ; }
public void cancelUnnamedTasks ( ) { if ( unnamedTaskExecutor != null ) { unnamedTaskExecutor . shutdownNow ( ) ; } }
public static double [ ] minmax ( List < Double > values ) { if ( values . size ( ) == NUM_ ) { return new double [ NUM_ ] ; } double min = values . get ( NUM_ ) ; double max = min ; int length = values . size ( ) ; for ( int i = NUM_ ; i < length ; i ++ ) { double value = values . get ( i ) ; min = Math . min ( min , value ) ; max = Math . max ( max , value ) ; } return new double [ ] { min , max } ; }
public Criteria createCriteria ( ) { Criteria criteria = createCriteriaInternal ( ) ; if ( oredCriteria . size ( ) == NUM_ ) { oredCriteria . add ( criteria ) ; } return criteria ; }
private char readEscapeCharacter ( ) throws IOException { if ( pos == limit && ! fillBuffer ( NUM_ ) ) { throw syntaxError ( STR_ ) ; } char escaped = buffer [ pos ++ ] ; switch ( escaped ) { case STR_ : if ( pos + NUM_ > limit && ! fillBuffer ( NUM_ ) ) { throw syntaxError ( STR_ ) ; } char result = NUM_ ; for ( int i = pos , end = i + NUM_ ; i < end ; i ++ ) { char c = buffer [ i ] ; result <<= NUM_ ; if ( c >= STR_ && c <= STR_ ) { result += ( c - STR_ ) ; } else if ( c >= STR_ && c <= STR_ ) { result += ( c - STR_ + NUM_ ) ; } else if ( c >= STR_ && c <= STR_ ) { result += ( c - STR_ + NUM_ ) ; } else { throw new NumberFormatException ( STR_ + new String ( buffer , pos , NUM_ ) ) ; } } pos += NUM_ ; return result ; case STR_ : return STR_ ; case STR_ : return STR_ ; case STR_ : return STR_ ; case STR_ : return STR_ ; case STR_ : return STR_ ; case STR_ : lineNumber ++ ; lineStart = pos ; case STR_ : case STR_ : case STR_ : case STR_ : return escaped ; default : throw syntaxError ( STR_ ) ; } }
private void updateParamsForAuth ( String [ ] authNames , List < Pair > queryParams , Map < String , String > headerParams ) { for ( String authName : authNames ) { Authentication auth = authentications . get ( authName ) ; if ( auth == null ) throw new RuntimeException ( STR_ + authName ) ; auth . applyToParams ( queryParams , headerParams ) ; } }
private void fixSpannedWithSpaces ( SpannableStringBuilder builder , int widthMeasureSpec , int heightMeasureSpec ) { long startFix = System . currentTimeMillis ( ) ; FixingResult result = addSpacesAroundSpansUntilFixed ( builder , widthMeasureSpec , heightMeasureSpec ) ; if ( result . fixed ) { removeUnneededSpaces ( widthMeasureSpec , heightMeasureSpec , builder , result ) ; } else { fallbackToString ( widthMeasureSpec , heightMeasureSpec ) ; } long fixDuration = System . currentTimeMillis ( ) - startFix ; Logger . d ( TAG , STR_ + fixDuration ) ; }
public EventsIntegrationTest ( ) { setResponseLogLengthLimit ( NUM_ ) ; dateFormat = new SimpleDateFormat ( STR_ ) ; Calendar cal = Calendar . getInstance ( ) ; cal . add ( Calendar . DATE , - NUM_ ) ; yesterday = dateFormat . format ( cal . getTime ( ) ) ; yesterday += STR_ ; cal = Calendar . getInstance ( ) ; cal . add ( Calendar . DATE , NUM_ ) ; today = dateFormat . format ( cal . getTime ( ) ) ; today += STR_ ; cal = Calendar . getInstance ( ) ; cal . add ( Calendar . DATE , NUM_ ) ; tomorrow = dateFormat . format ( cal . getTime ( ) ) ; tomorrow += STR_ ; cal = Calendar . getInstance ( ) ; cal . add ( Calendar . DATE , NUM_ ) ; tomorrowPlus3 = dateFormat . format ( cal . getTime ( ) ) ; tomorrowPlus3 += STR_ ; cal = Calendar . getInstance ( ) ; cal . add ( Calendar . DATE , - NUM_ ) ; yesterdayMinus3 = dateFormat . format ( cal . getTime ( ) ) ; yesterdayMinus3 += STR_ ; cal = Calendar . getInstance ( ) ; cal . add ( Calendar . DATE , NUM_ ) ; tomorrowPlus5 = dateFormat . format ( cal . getTime ( ) ) ; tomorrowPlus5 += STR_ ; cal = Calendar . getInstance ( ) ; cal . add ( Calendar . DATE , - NUM_ ) ; yesterdayMinus5 = dateFormat . format ( cal . getTime ( ) ) ; yesterdayMinus5 += STR_ ; experiment = ExperimentFactory . createExperiment ( ) ; experiment . startTime = yesterdayMinus3 ; experiment . endTime = tomorrowPlus3 ; experiment . samplingPercent = NUM_ ; experiment . label = STR_ ; experiment . applicationName = QBO + UUID . randomUUID ( ) ; DefaultNameExclusionStrategy experimentComparisonStrategy = new DefaultNameExclusionStrategy ( STR_ , STR_ , STR_ ) ; experiment . setSerializationStrategy ( experimentComparisonStrategy ) ; }
private void removeBookmarkTrackingIcons ( ) { if ( trackingIcons != null ) { for ( Iterator i = trackingIcons . iterator ( ) ; i . hasNext ( ) ; ) { GutterIconImpl ti = ( GutterIconImpl ) i . next ( ) ; if ( ti . getIcon ( ) == bookmarkIcon ) { i . remove ( ) ; } } } }
public SimpleMetricGroup ( GroupName name , Stream < ? extends Metric > i ) { this ( name , i . collect ( Collectors . < Metric > toList ( ) ) ) ; }
public boolean isInside ( Point point ) { return bounds . contains ( point ) ; }
private void resolveProtocols ( ClassLoader loader ) { ServiceLoader < ProtocolManagerFactory > serviceLoader = ServiceLoader . load ( ProtocolManagerFactory . class , loader ) ; loadProtocolManagerFactories ( serviceLoader ) ; }
public static List < InetAddress > hostAddresses ( ) { List < InetAddress > addrList = new ArrayList < > ( ) ; Enumeration < NetworkInterface > IFCs = null ; try { IFCs = NetworkInterface . getNetworkInterfaces ( ) ; } catch ( SocketException ex ) { log . error ( STR_ , ex ) ; } if ( IFCs != null ) { while ( IFCs . hasMoreElements ( ) ) { NetworkInterface IFC = IFCs . nextElement ( ) ; try { if ( IFC . isUp ( ) ) { Enumeration < InetAddress > addresses = IFC . getInetAddresses ( ) ; while ( addresses . hasMoreElements ( ) ) { InetAddress address = addresses . nextElement ( ) ; if ( ! address . isLoopbackAddress ( ) && ! address . isLinkLocalAddress ( ) ) { addrList . add ( address ) ; } } } } catch ( SocketException ex ) { log . error ( STR_ , IFC . toString ( ) , ex ) ; } } } return addrList ; }
public final static int caculateInSampleSize ( BitmapFactory . Options options , int rqsW , int rqsH ) { final int height = options . outHeight ; final int width = options . outWidth ; int inSampleSize = NUM_ ; if ( rqsW == NUM_ || rqsH == NUM_ ) return NUM_ ; if ( height > rqsH || width > rqsW ) { final int heightRatio = Math . round ( ( float ) height / ( float ) rqsH ) ; final int widthRatio = Math . round ( ( float ) width / ( float ) rqsW ) ; inSampleSize = heightRatio < widthRatio ? heightRatio : widthRatio ; } return inSampleSize ; }
public boolean hasStatus ( final StatusID status ) { return statuses . contains ( status ) ; }
@ Override public String toString ( ) { return STR_ + STR_ + instanceList + STR_ + outcomeList + STR_ + weightList + STR_ + sequenceIds + STR_ + sequencePositions + STR_ + addingAnotherInstancesAllowed + STR_ + totalNonNullFeaturesCount + STR_ ; }
static synchronized void computePRF_SSLv3 ( byte [ ] out , byte [ ] secret , byte [ ] seed ) { if ( sha == null ) { init ( ) ; } int pos = NUM_ ; int iteration = NUM_ ; byte [ ] digest ; while ( pos < out . length ) { byte [ ] pref = new byte [ iteration ] ; Arrays . fill ( pref , ( byte ) ( NUM_ + iteration ++ ) ) ; sha . update ( pref ) ; sha . update ( secret ) ; sha . update ( seed ) ; md5 . update ( secret ) ; md5 . update ( sha . digest ( ) ) ; digest = md5 . digest ( ) ; if ( pos + NUM_ > out . length ) { System . arraycopy ( digest , NUM_ , out , pos , out . length - pos ) ; pos = out . length ; } else { System . arraycopy ( digest , NUM_ , out , pos , NUM_ ) ; pos += NUM_ ; } } }
public void addChannelMap ( ChannelMap channelMap ) { if ( ! mChannelMaps . contains ( channelMap ) ) { mChannelMaps . add ( channelMap ) ; int index = mChannelMaps . indexOf ( channelMap ) ; fireIntervalAdded ( this , index , index ) ; broadcast ( new ChannelMapEvent ( channelMap , Event . ADD ) ) ; } }
@ Override public boolean add ( E o ) { if ( null == o ) { throw new NullPointerException ( ) ; } if ( offer ( o ) ) { return BOOL_ ; } throw new IllegalStateException ( ) ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
public Object putResource ( Object key , Object value ) { return ( objectCache . put ( key , value ) ) ; }
public UidRange [ ] parseUidRange ( ) throws DecodingException { CharacterValidator validator = new MessageSetCharValidator ( ) ; String nextWord = consumeWord ( validator , BOOL_ ) ; int commaPos = nextWord . indexOf ( STR_ ) ; if ( commaPos == - NUM_ ) { return new UidRange [ ] { parseUidRange ( nextWord ) } ; } ArrayList < UidRange > rangeList = new ArrayList < UidRange > ( ) ; int pos = NUM_ ; while ( commaPos != - NUM_ ) { String range = nextWord . substring ( pos , commaPos ) ; UidRange set = parseUidRange ( range ) ; rangeList . add ( set ) ; pos = commaPos + NUM_ ; commaPos = nextWord . indexOf ( STR_ , pos ) ; } String range = nextWord . substring ( pos ) ; rangeList . add ( parseUidRange ( range ) ) ; List < UidRange > merged = UidRange . mergeRanges ( rangeList ) ; return merged . toArray ( new UidRange [ merged . size ( ) ] ) ; }
private String replaceSuffix ( String value , String toReplace , String changeTo ) { String vvalue ; if ( ( value == null ) || ( toReplace == null ) || ( changeTo == null ) ) { return value ; } vvalue = removeSuffix ( value , toReplace ) ; if ( value . equals ( vvalue ) ) { return value ; } else { return vvalue + changeTo ; } }
private void executeClaimedTask ( ClaimedTask claimedTask ) { if ( ! claimedTask . setStartTime ( new Date ( ) ) ) { _log . info ( STR_ , claimedTask . getTask ( ) ) ; return ; } ScanRangeTask task = claimedTask . getTask ( ) ; boolean releaseTask = BOOL_ ; try { _scanWorkflow . renewScanRangeTasks ( ImmutableList . of ( task ) , QUEUE_RENEW_TTL ) ; releaseTask = asyncRangeScan ( task ) ; } finally { unclaimTask ( claimedTask , releaseTask ) ; _backgroundService . submit ( _startScansIfAvailableRunnable ) ; } }
private static boolean createNaviDirectory ( ) { final File dir = new File ( ConfigHelper . getConfigurationDirectory ( Constants . COMPANY_NAME , Constants . PROJECT_NAME ) ) ; return dir . exists ( ) || dir . mkdir ( ) ; }
public void updateButtonActionPerformed ( ) { if ( ! readReceiveDelay ( ) ) { return ; } if ( ! readPulseWidth ( ) ) { return ; } if ( ! checkConsistency ( ) ) { return ; } if ( curNode . getNodeType ( ) != nodeType ) { curNode . setNodeType ( nodeType ) ; } setNodeParameters ( ) ; changedNode = BOOL_ ; editMode = BOOL_ ; curNode = null ; addButton . setVisible ( BOOL_ ) ; editButton . setVisible ( BOOL_ ) ; deleteButton . setVisible ( BOOL_ ) ; doneButton . setVisible ( BOOL_ ) ; updateButton . setVisible ( BOOL_ ) ; cancelButton . setVisible ( BOOL_ ) ; nodeAddrField . setVisible ( BOOL_ ) ; nodeAddrStatic . setVisible ( BOOL_ ) ; statusText2 . setText ( stdStatus2 ) ; statusText3 . setText ( stdStatus3 ) ; statusText1 . setText ( rb . getString ( STR_ ) + STR_ + Integer . toString ( nodeAddress ) ) ; errorInStatus1 = BOOL_ ; }
public static Class toClass ( ClassFile cf , ClassLoader loader , ProtectionDomain domain ) throws CannotCompileException { try { byte [ ] b = toBytecode ( cf ) ; Method method ; Object [ ] args ; if ( domain == null ) { method = defineClass1 ; args = new Object [ ] { cf . getName ( ) , b , new Integer ( NUM_ ) , new Integer ( b . length ) } ; } else { method = defineClass2 ; args = new Object [ ] { cf . getName ( ) , b , new Integer ( NUM_ ) , new Integer ( b . length ) , domain } ; } return toClass2 ( method , loader , args ) ; } catch ( RuntimeException e ) { throw e ; } catch ( java . lang . reflect . InvocationTargetException e ) { throw new CannotCompileException ( e . getTargetException ( ) ) ; } catch ( Exception e ) { throw new CannotCompileException ( e ) ; } }
public Iterator < Target > targetIterator ( ) { return targetList . iterator ( ) ; }
private void fitSizeOfScrolledContent ( ) { Point p = scrollComposite . getSize ( ) ; main . setSize ( main . computeSize ( p . x , SWT . DEFAULT ) ) ; }
public int hashCode ( ) { return name . hashCode ( ) ; }
private static Map < String , SnmpOid > buildPoolIndexMap ( SnmpCachedData cached ) { if ( cached == null ) return Collections . emptyMap ( ) ; final SnmpOid [ ] indexes = cached . indexes ; final Object [ ] datas = cached . datas ; final int len = indexes . length ; final Map < String , SnmpOid > m = new HashMap < > ( len ) ; for ( int i = NUM_ ; i < len ; i ++ ) { final SnmpOid index = indexes [ i ] ; if ( index == null ) continue ; final MemoryPoolMXBean mpm = ( MemoryPoolMXBean ) datas [ i ] ; if ( mpm == null ) continue ; final String name = mpm . getName ( ) ; if ( name == null ) continue ; m . put ( name , index ) ; } return m ; }
public DCryptoStrength ( JFrame parent ) throws CryptoException { super ( parent , res . getString ( STR_ ) , ModalityType . DOCUMENT_MODAL ) ; initComponents ( ) ; }
private Component createSeparator ( ) { JSeparator sep = new JSeparator ( SwingConstants . VERTICAL ) ; sep . setPreferredSize ( new Dimension ( NUM_ , NUM_ ) ) ; sep . setMinimumSize ( new Dimension ( NUM_ , NUM_ ) ) ; return sep ; }
public void add ( final T object ) { synchronized ( mLock ) { mList . add ( object ) ; } notifyDataSetChanged ( ) ; }
public void build ( RealmResults < T > results ) { int xIndex = NUM_ ; for ( T object : results ) { mValues . add ( buildEntryFromResultObject ( object , xIndex ++ ) ) ; } }
public byte [ ] generateSignature ( ) throws CryptoException , DataLengthException { contentDigest . doFinal ( mDash , mDash . length - hLen - sLen ) ; if ( sLen != NUM_ ) { random . nextBytes ( salt ) ; System . arraycopy ( salt , NUM_ , mDash , mDash . length - sLen , sLen ) ; } byte [ ] h = new byte [ hLen ] ; contentDigest . update ( mDash , NUM_ , mDash . length ) ; contentDigest . doFinal ( h , NUM_ ) ; block [ block . length - sLen - NUM_ - hLen - NUM_ ] = x01 ; System . arraycopy ( salt , NUM_ , block , block . length - sLen - hLen - NUM_ , sLen ) ; byte [ ] dbMask = maskGeneratorFunction1 ( h , NUM_ , h . length , block . length - hLen - NUM_ ) ; for ( int i = NUM_ ; i != dbMask . length ; i ++ ) { block [ i ] ^= dbMask [ i ] ; } block [ NUM_ ] &= ( xff > > ( ( block . length . NUM_ ) - emBits ) ) ; System . arraycopy ( h , NUM_ , block , block . length - hLen - NUM_ , hLen ) ; block [ block . length - NUM_ ] = trailer ; byte [ ] b = cipher . processBlock ( block , NUM_ , block . length ) ; clearBlock ( block ) ; return b ; }
public void testNegPosFirstLonger ( ) { byte aBytes [ ] = { - NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ } ; byte bBytes [ ] = { - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = - NUM_ ; int bSign = NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . and ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
@ Override public void write ( byte [ ] b , int off , int len ) { if ( ( off < NUM_ ) || ( off > b . length ) || ( len < NUM_ ) || ( ( off + len ) > b . length ) || ( ( off + len ) < NUM_ ) ) { throw new IndexOutOfBoundsException ( ) ; } else if ( len == NUM_ ) { return ; } synchronized ( this ) { int newcount = count + len ; int remaining = len ; int inBufferPos = count - filledBufferSum ; while ( remaining > NUM_ ) { int part = Math . min ( remaining , currentBuffer . length - inBufferPos ) ; System . arraycopy ( b , off + len - remaining , currentBuffer , inBufferPos , part ) ; remaining -= part ; if ( remaining > NUM_ ) { needNewBuffer ( newcount ) ; inBufferPos = NUM_ ; } } count = newcount ; } }
public static void openFileIntent ( Context context , File openFile ) { if ( context != null && openFile . exists ( ) ) { try { Intent intent = getFileIntent ( context , openFile ) ; context . startActivity ( intent ) ; } catch ( Exception e ) { GlobalUtils . logThis ( TAG , STR_ , e ) ; } } }
public static java . sql . Date toSqlDate ( String date ) { java . util . Date newDate = toDate ( date , STR_ ) ; if ( newDate != null ) { return new java . sql . Date ( newDate . getTime ( ) ) ; } else { return null ; } }
private synchronized void rebuildJournal ( ) throws IOException { if ( journalWriter != null ) { journalWriter . close ( ) ; } Writer writer = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( journalFileTmp ) , Util . US_ASCII ) ) ; try { writer . write ( MAGIC ) ; writer . write ( STR_ ) ; writer . write ( VERSION_1 ) ; writer . write ( STR_ ) ; writer . write ( Integer . toString ( appVersion ) ) ; writer . write ( STR_ ) ; writer . write ( Integer . toString ( valueCount ) ) ; writer . write ( STR_ ) ; writer . write ( STR_ ) ; for ( Entry entry : lruEntries . values ( ) ) { if ( entry . currentEditor != null ) { writer . write ( DIRTY + STR_ + entry . key + STR_ ) ; } else { writer . write ( CLEAN + STR_ + entry . key + entry . getLengths ( ) + STR_ ) ; } } } finally { writer . close ( ) ; } if ( journalFile . exists ( ) ) { renameTo ( journalFile , journalFileBackup , BOOL_ ) ; } renameTo ( journalFileTmp , journalFile , BOOL_ ) ; journalFileBackup . delete ( ) ; journalWriter = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( journalFile , BOOL_ ) , Util . US_ASCII ) ) ; }
public static int round ( final float value ) { final int bits = Float . floatToRawIntBits ( value ) ; final int biasedExp = bits > > NUM_ & xFF ; final int shift = NUM_ - NUM_ + MAX_FLOAT_EXPONENT - biasedExp ; if ( ( shift & - NUM_ ) == NUM_ ) { int extendedMantissa = x00800000 | bits & x007FFFFF ; if ( bits < NUM_ ) { extendedMantissa = - extendedMantissa ; } return ( extendedMantissa > > shift ) + NUM_ > > NUM_ ; } else { return ( int ) value ; } }
public static PlainText plain ( short text ) { return plain ( Integer . toString ( text ) ) ; }
public AttributeInfo copy ( ConstPool newCp , Map classnames ) { Copier copier = new Copier ( info , constPool , newCp , classnames ) ; try { copier . parameters ( ) ; return new ParameterAnnotationsAttribute ( newCp , getName ( ) , copier . close ( ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e . toString ( ) ) ; } }
private String createComponentChanges ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( ServiceCatalogDiff serviceCatalogDiff : diffList ) { builder . append ( createApiChanges ( serviceCatalogDiff ) ) ; } return builder . toString ( ) ; }
public static synchronized void it ( String description , UnsafeBlock block ) { it ( description , identity ( ) , block ) ; }
public static boolean isWritable ( final File file , final boolean makeDirs ) { if ( file == null ) { Log . e ( FileUtils . class , STR_ ) ; return BOOL_ ; } final String fileParentDir = file . getParent ( ) ; if ( ! TextUtils . isEmpty ( fileParentDir ) ) { final File fileDir = new File ( fileParentDir ) ; if ( ! fileDir . exists ( ) ) { if ( makeDirs ) return makeDirsForFile ( file ) ; else return BOOL_ ; } } boolean isWritable = BOOL_ ; if ( file . exists ( ) ) isWritable = file . canWrite ( ) ; else { try { isWritable = file . createNewFile ( ) ; } catch ( IOException e ) { } if ( isWritable ) isWritable = file . delete ( ) ; } return isWritable ; }
public String toString ( ) { return oid . toString ( ) ; }
private static void createOrgAuthConfig ( String realmName ) throws Exception { String classMethod = STR_ ; OrganizationConfigManager org = new OrganizationConfigManager ( ssoToken , realmName ) ; ServiceConfig orgConfig = org . getServiceConfig ( AUTH_SERVICE_NAME ) ; if ( orgConfig != null ) { Map aa = orgConfig . getAttributes ( ) ; if ( debug . messageEnabled ( ) ) { debug . message ( classMethod + STR_ + realmName ) ; debug . message ( classMethod + STR_ + aa ) ; } String orgName = realmName ; if ( LDAPUtils . isDN ( realmName ) ) { orgName = LDAPUtils . rdnValueFromDn ( realmName ) ; } String authConfigName = orgName + STR_ ; String adminAuthConfigName = orgName + STR_ ; Set authConfigAttrValue = ( Set ) aa . get ( ATTR_ORG_AUTH_MODULE ) ; if ( debug . messageEnabled ( ) ) { debug . message ( classMethod + STR_ + authConfigAttrValue ) ; } Set newVal = new HashSet ( ) ; if ( authConfigAttrValue . size ( ) != NUM_ && ! authConfigAttrValue . contains ( authConfigName ) ) { newVal . add ( authConfigName ) ; orgConfig . replaceAttributeValues ( ATTR_ORG_AUTH_MODULE , authConfigAttrValue , newVal ) ; } Set adminConfigAttrValue = ( Set ) aa . get ( ATTR_ADMIN_AUTH_MODULE ) ; if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + adminConfigAttrValue ) ; } if ( adminConfigAttrValue . size ( ) != NUM_ && ! adminConfigAttrValue . contains ( adminAuthConfigName ) ) { newVal . clear ( ) ; newVal . add ( adminAuthConfigName ) ; orgConfig . replaceAttributeValues ( ATTR_ADMIN_AUTH_MODULE , adminConfigAttrValue , newVal ) ; } aa = orgConfig . getAttributes ( ) ; ServiceConfig s = org . getServiceConfig ( AUTH_CONFIG_SERVICE ) ; ServiceConfig authConfig = s . getSubConfig ( NAMED_CONFIG ) ; if ( authConfig == null ) { s . addSubConfig ( NAMED_CONFIG , null , NUM_ , null ) ; authConfig = s . getSubConfig ( NAMED_CONFIG ) ; } Map aMap = new HashMap ( ) ; aMap . put ( ATTR_AUTH_CONFIG , authConfigAttrValue ) ; authConfig . addSubConfig ( authConfigName , SUB_NAMED_CONFIG , NUM_ , aMap ) ; aMap . clear ( ) ; aMap . put ( ATTR_AUTH_CONFIG , adminConfigAttrValue ) ; authConfig . addSubConfig ( adminAuthConfigName , SUB_NAMED_CONFIG , NUM_ , aMap ) ; } }
public void read ( ByteCodeParser in ) throws IOException { int length = in . readInt ( ) ; _maxStack = in . readShort ( ) ; _maxLocals = in . readShort ( ) ; int codeLength = in . readInt ( ) ; _code = new byte [ codeLength ] ; in . read ( _code , NUM_ , codeLength ) ; int exnCount = in . readShort ( ) ; for ( int i = NUM_ ; i < exnCount ; i ++ ) { ExceptionItem exn = new ExceptionItem ( ) ; exn . setStart ( in . readShort ( ) & xffff ) ; exn . setEnd ( in . readShort ( ) & xffff ) ; exn . setHandler ( in . readShort ( ) & xffff ) ; exn . setType ( in . readShort ( ) & xffff ) ; _exceptions . add ( exn ) ; } int attrCount = in . readShort ( ) ; for ( int i = NUM_ ; i < attrCount ; i ++ ) { Attribute attr = in . parseAttribute ( ) ; _attributes . add ( attr ) ; } }
public void testSkip ( ) throws Exception { byte [ ] data = new byte [ ] { - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; TestInputStream tis = new TestInputStream ( data ) ; CipherInputStream cis = new CipherInputStream ( tis , new NullCipher ( ) ) ; int expected = data . length ; byte [ ] result = new byte [ expected ] ; int skipped = ( int ) cis . skip ( NUM_ ) ; int ind = skipped ; int got = skipped + cis . read ( result , NUM_ , NUM_ ) ; while ( BOOL_ ) { for ( int j = NUM_ ; j < got - ind ; j ++ ) { if ( result [ j ] != data [ ind + j ] ) { fail ( STR_ + STR_ + data [ ind + j ] + STR_ + result [ j ] ) ; } } if ( got == expected ) { break ; } else if ( got > expected ) { fail ( STR_ + STR_ + STR_ ) ; } else { ind = got ; got += cis . read ( result , NUM_ , NUM_ ) ; } } if ( ( got = cis . read ( result , NUM_ , NUM_ ) ) != - NUM_ ) { fail ( STR_ + STR_ + got + STR_ ) ; } }
void addString ( int c ) { if ( strpos == str . length ) { char newstr [ ] = new char [ str . length + NUM_ ] ; System . arraycopy ( str , NUM_ , newstr , NUM_ , str . length ) ; str = newstr ; } str [ strpos ++ ] = ( char ) c ; }
@ Override public int hashCode ( ) { return oid . hashCode ( ) ; }
public CholeskyDecomposition ( Matrix Arg ) { double [ ] [ ] A = Arg . getArray ( ) ; n = Arg . getRowDimension ( ) ; L = new double [ n ] [ n ] ; isspd = ( Arg . getColumnDimension ( ) == n ) ; for ( int j = NUM_ ; j < n ; j ++ ) { double [ ] Lrowj = L [ j ] ; double d = NUM_ ; for ( int k = NUM_ ; k < j ; k ++ ) { double [ ] Lrowk = L [ k ] ; double s = NUM_ ; for ( int i = NUM_ ; i < k ; i ++ ) { s += Lrowk [ i ] . Lrowj [ i ] ; } Lrowj [ k ] = s = ( A [ j ] [ k ] - s ) / L [ k ] [ k ] ; d = d + s . s ; isspd = isspd & ( A [ k ] [ j ] == A [ j ] [ k ] ) ; } d = A [ j ] [ j ] - d ; isspd = isspd & ( d > NUM_ ) ; L [ j ] [ j ] = Math . sqrt ( Math . max ( d , NUM_ ) ) ; for ( int k = j + NUM_ ; k < n ; k ++ ) { L [ j ] [ k ] = NUM_ ; } } }
protected void findCandidateCrossings ( S2Point a , S2Point b , List < Integer > candidateCrossings ) { Preconditions . checkState ( indexComputed ) ; ArrayList < S2CellId > cover = Lists . newArrayList ( ) ; getCovering ( a , b , BOOL_ , cover ) ; Set < Integer > uniqueSet = new HashSet < Integer > ( ) ; getEdgesInParentCells ( cover , uniqueSet ) ; getEdgesInChildrenCells ( a , b , cover , uniqueSet ) ; candidateCrossings . clear ( ) ; candidateCrossings . addAll ( uniqueSet ) ; }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case NUM_ : return TRUE_AS_OF_SECS ; case NUM_ : return SOURCE ; case NUM_ : return SYSTEM ; default : return null ; } }
public RepositoryLocation ( String repositoryName , String [ ] pathComponents ) throws MalformedRepositoryLocationException { if ( repositoryName == null || repositoryName . isEmpty ( ) ) { throw new MalformedRepositoryLocationException ( STR_ ) ; } if ( pathComponents == null ) { throw new MalformedRepositoryLocationException ( STR_ ) ; } for ( String pathComp : pathComponents ) { if ( pathComp == null || pathComp . isEmpty ( ) ) { throw new MalformedRepositoryLocationException ( STR_ ) ; } } this . repositoryName = repositoryName ; this . path = pathComponents ; }
public void addProperty ( String key , String value ) { carbonProperties . setProperty ( key , value ) ; }
protected JavaElementDelta createDeltaTree ( IJavaElement element , JavaElementDelta delta ) { JavaElementDelta childDelta = delta ; ArrayList ancestors = getAncestors ( element ) ; if ( ancestors == null ) { if ( equalsAndSameParent ( delta . getElement ( ) , getElement ( ) ) ) { this . kind = delta . kind ; this . changeFlags = delta . changeFlags ; this . movedToHandle = delta . movedToHandle ; this . movedFromHandle = delta . movedFromHandle ; } } else { for ( int i = NUM_ , size = ancestors . size ( ) ; i < size ; i ++ ) { IJavaElement ancestor = ( IJavaElement ) ancestors . get ( i ) ; JavaElementDelta ancestorDelta = new JavaElementDelta ( ancestor ) ; ancestorDelta . addAffectedChild ( childDelta ) ; childDelta = ancestorDelta ; } } return childDelta ; }
@ Override public String toString ( ) { return getTitle ( ) ; }
public int size ( ) { if ( hmap == null ) { return NUM_ ; } return hmap . size ( ) ; }
public static String replace ( String inString , String oldPattern , String newPattern ) { if ( ! hasLength ( inString ) || ! hasLength ( oldPattern ) || newPattern == null ) { return inString ; } StringBuilder sb = new StringBuilder ( ) ; int pos = NUM_ ; int index = inString . indexOf ( oldPattern ) ; int patLen = oldPattern . length ( ) ; while ( index >= NUM_ ) { sb . append ( inString . substring ( pos , index ) ) ; sb . append ( newPattern ) ; pos = index + patLen ; index = inString . indexOf ( oldPattern , pos ) ; } sb . append ( inString . substring ( pos ) ) ; return sb . toString ( ) ; }
public boolean coordinateInZone ( Id < ActivityFacility > zoneID , Coord coordinate ) { Point point = MGC . xy2Point ( coordinate . getX ( ) , coordinate . getY ( ) ) ; return pointInZone ( zoneID , point ) ; }
public String associatorTipText ( ) { return STR_ ; }
public XwavesLabelfileReader ( Reader reader ) throws IOException { this . reader = new BufferedReader ( reader ) ; parseLabels ( ) ; reader . close ( ) ; }
public static double parseDoubleDefault ( String s , double def ) { if ( s == null ) { return def ; } try { return Double . parseDouble ( s ) ; } catch ( NumberFormatException e ) { return def ; } }
public static void registerApp ( int application , String appName ) throws AppIDException { if ( ( application & APP_ID_MASK ) != application ) { throw new InvalidAppIDValueException ( application ) ; } String oldApp = appIdMap . putIfAbsent ( application , appName ) ; if ( oldApp != null && ! oldApp . equals ( appName ) ) { throw new AppIDInUseException ( application , oldApp , appName ) ; } }
public boolean putProfile ( Profile profile ) { return putProfile ( profile , BOOL_ ) ; }
public void print ( char c ) { writer . print ( c ) ; }
public void initBlockViews ( ) { if ( mWorkspaceView != null ) { List < Block > rootBlocks = mWorkspace . getRootBlocks ( ) ; ConnectionManager connManager = mWorkspace . getConnectionManager ( ) ; for ( int i = NUM_ ; i < rootBlocks . size ( ) ; i ++ ) { BlockGroup bg = mViewFactory . buildBlockGroupTree ( rootBlocks . get ( i ) , connManager , mTouchHandler ) ; mWorkspaceView . addView ( bg ) ; } } }
protected void clearAllTrails ( SSOTokenID tokenID ) { boolean removed = BOOL_ ; String key = tokenID . toString ( ) ; synchronized ( mapTokenIDs ) { removed = ( mapTokenIDs . remove ( key ) != null ) ; } }
public DNetscapeCaRevocationUrl ( JDialog parent , byte [ ] value ) throws IOException { super ( parent ) ; setTitle ( res . getString ( STR_ ) ) ; initComponents ( ) ; prepopulateWithValue ( value ) ; }
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; }
public static int [ ] parseNumberList ( String listStr , int minVal , int maxVal , boolean allowZero ) { int [ ] values ; if ( listStr . indexOf ( STR_ ) < NUM_ ) { values = new int [ NUM_ ] ; values [ NUM_ ] = parseIntRange ( listStr , minVal , maxVal , allowZero ) ; } else { String [ ] valueStrs = listStr . split ( STR_ ) ; int len = valueStrs . length ; values = new int [ len ] ; for ( int i = NUM_ ; i < len ; i ++ ) { values [ i ] = parseIntRange ( valueStrs [ i ] , minVal , maxVal , allowZero ) ; } } return values ; }
public DirectoryOrFileNotFoundException ( String entity , String name ) { super ( String . format ( _errorMessage , entity , name ) ) ; }
public void closeStream ( ) { CarbonUtil . closeStreams ( stream ) ; executorService . shutdown ( ) ; }
void scramble ( ) { initialSize = getSize ( ) ; int a [ ] = new int [ initialSize . height / NUM_ ] ; double f = initialSize . width / ( double ) a . length ; for ( int i = a . length ; -- i >= NUM_ ; ) { a [ i ] = ( int ) ( i . f ) ; } for ( int i = a . length ; -- i >= NUM_ ; ) { int j = ( int ) ( i . Math . random ( ) ) ; int t = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = t ; } arr = a ; }
private int readAnnotationValue ( int v , final char [ ] buf , final String name , final AnnotationVisitor av ) { int i ; if ( av == null ) { switch ( b [ v ] & xFF ) { case STR_ : return v + NUM_ ; case STR_ : return readAnnotationValues ( v + NUM_ , buf , BOOL_ , null ) ; case STR_ : return readAnnotationValues ( v + NUM_ , buf , BOOL_ , null ) ; default : return v + NUM_ ; } } switch ( b [ v ++ ] & xFF ) { case STR_ : case STR_ : case STR_ : case STR_ : av . visit ( name , readConst ( readUnsignedShort ( v ) , buf ) ) ; v += NUM_ ; break ; case STR_ : av . visit ( name , new Byte ( ( byte ) readInt ( items [ readUnsignedShort ( v ) ] ) ) ) ; v += NUM_ ; break ; case STR_ : av . visit ( name , readInt ( items [ readUnsignedShort ( v ) ] ) == NUM_ ? Boolean . FALSE : Boolean . TRUE ) ; v += NUM_ ; break ; case STR_ : av . visit ( name , new Short ( ( short ) readInt ( items [ readUnsignedShort ( v ) ] ) ) ) ; v += NUM_ ; break ; case STR_ : av . visit ( name , new Character ( ( char ) readInt ( items [ readUnsignedShort ( v ) ] ) ) ) ; v += NUM_ ; break ; case STR_ : av . visit ( name , readUTF8 ( v , buf ) ) ; v += NUM_ ; break ; case STR_ : av . visitEnum ( name , readUTF8 ( v , buf ) , readUTF8 ( v + NUM_ , buf ) ) ; v += NUM_ ; break ; case STR_ : av . visit ( name , Type . getType ( readUTF8 ( v , buf ) ) ) ; v += NUM_ ; break ; case STR_ : v = readAnnotationValues ( v + NUM_ , buf , BOOL_ , av . visitAnnotation ( name , readUTF8 ( v , buf ) ) ) ; break ; case STR_ : int size = readUnsignedShort ( v ) ; v += NUM_ ; if ( size == NUM_ ) { return readAnnotationValues ( v - NUM_ , buf , BOOL_ , av . visitArray ( name ) ) ; } switch ( this . b [ v ++ ] & xFF ) { case STR_ : byte [ ] bv = new byte [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { bv [ i ] = ( byte ) readInt ( items [ readUnsignedShort ( v ) ] ) ; v += NUM_ ; } av . visit ( name , bv ) ; -- v ; break ; case STR_ : boolean [ ] zv = new boolean [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { zv [ i ] = readInt ( items [ readUnsignedShort ( v ) ] ) != NUM_ ; v += NUM_ ; } av . visit ( name , zv ) ; -- v ; break ; case STR_ : short [ ] sv = new short [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { sv [ i ] = ( short ) readInt ( items [ readUnsignedShort ( v ) ] ) ; v += NUM_ ; } av . visit ( name , sv ) ; -- v ; break ; case STR_ : char [ ] cv = new char [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { cv [ i ] = ( char ) readInt ( items [ readUnsignedShort ( v ) ] ) ; v += NUM_ ; } av . visit ( name , cv ) ; -- v ; break ; case STR_ : int [ ] iv = new int [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { iv [ i ] = readInt ( items [ readUnsignedShort ( v ) ] ) ; v += NUM_ ; } av . visit ( name , iv ) ; -- v ; break ; case STR_ : long [ ] lv = new long [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { lv [ i ] = readLong ( items [ readUnsignedShort ( v ) ] ) ; v += NUM_ ; } av . visit ( name , lv ) ; -- v ; break ; case STR_ : float [ ] fv = new float [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { fv [ i ] = Float . intBitsToFloat ( readInt ( items [ readUnsignedShort ( v ) ] ) ) ; v += NUM_ ; } av . visit ( name , fv ) ; -- v ; break ; case STR_ : double [ ] dv = new double [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { dv [ i ] = Double . longBitsToDouble ( readLong ( items [ readUnsignedShort ( v ) ] ) ) ; v += NUM_ ; } av . visit ( name , dv ) ; -- v ; break ; default : v = readAnnotationValues ( v - NUM_ , buf , BOOL_ , av . visitArray ( name ) ) ; } } return v ; }
public static SIPHeader parseSIPHeader ( String header ) throws ParseException { int start = NUM_ ; int end = header . length ( ) - NUM_ ; try { while ( header . charAt ( start ) <= x20 ) start ++ ; while ( header . charAt ( end ) <= x20 ) end -- ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new ParseException ( STR_ , NUM_ ) ; } StringBuilder buffer = new StringBuilder ( end + NUM_ ) ; int i = start ; int lineStart = start ; boolean endOfLine = BOOL_ ; while ( i <= end ) { char c = header . charAt ( i ) ; if ( c == STR_ || c == STR_ ) { if ( ! endOfLine ) { buffer . append ( header . substring ( lineStart , i ) ) ; endOfLine = BOOL_ ; } } else { if ( endOfLine ) { endOfLine = BOOL_ ; if ( c == STR_ || c == STR_ ) { buffer . append ( STR_ ) ; lineStart = i + NUM_ ; } else { lineStart = i ; } } } i ++ ; } buffer . append ( header . substring ( lineStart , i ) ) ; buffer . append ( STR_ ) ; HeaderParser hp = ParserFactory . createParser ( buffer . toString ( ) ) ; if ( hp == null ) throw new ParseException ( STR_ , NUM_ ) ; return hp . parse ( ) ; }
private static int convertSRGBtoLinearRGB ( int color ) { float input , output ; input = color / NUM_ ; if ( input <= NUM_ ) { output = input / NUM_ ; } else { output = ( float ) Math . pow ( ( input + NUM_ ) / NUM_ , NUM_ ) ; } return Math . round ( output . NUM_ ) ; }
public void recordBeginning ( ) { final String msg = STR_ + mModuleName + STR_ + mRunId ; mUsageMessages . add ( msg ) ; Diagnostic . developerLog ( msg ) ; mClient . recordBeginning ( mModuleName , mRunId ) ; }
public boolean isPronounceable ( String word ) { String lowerCaseWord = word . toLowerCase ( ) ; return ( prefixFSM . accept ( lowerCaseWord ) && suffixFSM . accept ( lowerCaseWord ) ) ; }
public void addSplitEdges ( List edgeList ) { addEndpoints ( ) ; Iterator it = iterator ( ) ; EdgeIntersection eiPrev = ( EdgeIntersection ) it . next ( ) ; while ( it . hasNext ( ) ) { EdgeIntersection ei = ( EdgeIntersection ) it . next ( ) ; Edge newEdge = createSplitEdge ( eiPrev , ei ) ; edgeList . add ( newEdge ) ; eiPrev = ei ; } }
public IOUtils ( ) { super ( ) ; }
public MemBasedCache ( int maxCacheSizeInBytes ) { mMaxCacheSizeInBytes = maxCacheSizeInBytes ; mDataEntries = new LinkedHashMap < String , CacheHeader > ( NUM_ , NUM_ , BOOL_ ) ; }
public void updateMaxTextWidths ( float requiredWidth , float matchContentsWidth ) { mMaxRequiredWidth = Math . max ( mMaxRequiredWidth , requiredWidth ) ; mMaxMatchContentsWidth = Math . max ( mMaxMatchContentsWidth , matchContentsWidth ) ; }
public void enableOverview ( boolean b ) { if ( overviewItem != null ) { overviewItem . setEnabled ( b ) ; } }
public void mouseEntered ( MouseEvent e ) { if ( Debug . debugging ( STR_ ) ) { Debug . output ( getID ( ) + STR_ ) ; } super . mouseEntered ( e ) ; autoZoom = BOOL_ ; }
public PageOfCollections fetchPage ( PageOfCollections page , SolrZkClient zkClient ) throws KeeperException , InterruptedException { List < String > children = getCollections ( zkClient ) ; page . selected = children ; if ( page . start == NUM_ && page . rows == - NUM_ && page . filter == null && children . size ( ) > NUM_ ) { page . rows = NUM_ ; page . start = NUM_ ; } if ( page . filterType == FilterType . name && page . filter != null ) children = page . applyNameFilter ( children ) ; if ( page . filterType != FilterType . status ) page . selectPage ( children ) ; return page ; }
public void accept ( final AnnotationVisitor av ) { if ( av != null ) { if ( values != null ) { for ( int i = NUM_ ; i < values . size ( ) ; i += NUM_ ) { String name = ( String ) values . get ( i ) ; Object value = values . get ( i + NUM_ ) ; accept ( av , name , value ) ; } } av . visitEnd ( ) ; } }
public IdsQueryBuilder addIds ( String ... ids ) { values . addAll ( Arrays . asList ( ids ) ) ; return this ; }
private void stop ( HttpServletRequest request , HttpServletResponse response ) throws IOException { PrintWriter out = response . getWriter ( ) ; String label = request . getParameter ( STR_ ) ; Monitor mon = removeMon ( label , null , DEFAULT_UNITS ) ; if ( mon == null ) { out . println ( ERROR + STR_ ) ; } else { mon . stop ( ) ; out . println ( OK + STR_ + mon ) ; } }
public static String normalizeUrl ( String requestUrl ) throws OAuthException { if ( ( requestUrl == null ) || ( requestUrl . length ( ) == NUM_ ) ) { throw new OAuthException ( STR_ ) ; } URI uri ; try { uri = new URI ( requestUrl ) ; } catch ( URISyntaxException e ) { throw new OAuthException ( e ) ; } String authority = uri . getAuthority ( ) ; String scheme = uri . getScheme ( ) ; if ( authority == null || scheme == null ) { throw new OAuthException ( STR_ ) ; } authority = authority . toLowerCase ( ) ; scheme = scheme . toLowerCase ( ) ; if ( ( scheme . equals ( STR_ ) && uri . getPort ( ) == NUM_ ) || ( scheme . equals ( STR_ ) && uri . getPort ( ) == NUM_ ) ) { int index = authority . lastIndexOf ( STR_ ) ; if ( index >= NUM_ ) { authority = authority . substring ( NUM_ , index ) ; } } return scheme + STR_ + authority + uri . getRawPath ( ) ; }
public void invoke ( InputStream is , OutputStream os , SerializerFactory serializerFactory ) throws Exception { boolean isDebug = BOOL_ ; if ( isDebugInvoke ( ) ) { isDebug = BOOL_ ; PrintWriter dbg = createDebugPrintWriter ( ) ; HessianDebugInputStream dIs = new HessianDebugInputStream ( is , dbg ) ; dIs . startTop2 ( ) ; is = dIs ; HessianDebugOutputStream dOs = new HessianDebugOutputStream ( os , dbg ) ; dOs . startTop2 ( ) ; os = dOs ; } HessianInputFactory . HeaderType header = _inputFactory . readHeader ( is ) ; AbstractHessianInput in ; AbstractHessianOutput out ; switch ( header ) { case CALL_1_REPLY_1 : in = _hessianFactory . createHessianInput ( is ) ; out = _hessianFactory . createHessianOutput ( os ) ; break ; case CALL_1_REPLY_2 : in = _hessianFactory . createHessianInput ( is ) ; out = _hessianFactory . createHessian2Output ( os ) ; break ; case HESSIAN_2 : in = _hessianFactory . createHessian2Input ( is ) ; in . readCall ( ) ; out = _hessianFactory . createHessian2Output ( os ) ; break ; default : throw new IllegalStateException ( header + STR_ ) ; } if ( serializerFactory != null ) { in . setSerializerFactory ( serializerFactory ) ; out . setSerializerFactory ( serializerFactory ) ; } try { invoke ( _service , in , out ) ; } finally { in . close ( ) ; out . close ( ) ; if ( isDebug ) os . close ( ) ; } }
private void commitLocalTransaction ( ) throws CommitFailedException { if ( _tx == null ) { return ; } if ( _logger . isLoggable ( Level . FINEST ) ) { _logger . log ( Level . FINEST , STR_ + _tx ) ; } try { _tx . commit ( ) ; } catch ( Exception e ) { if ( _logger . isLoggable ( Level . SEVERE ) ) { _logger . log ( Level . SEVERE , STR_ + _tx , e ) ; } throw new CommitFailedException ( e ) ; } }
public static Entry addObjectClass ( Entry entry ) { Attribute attribute = entry . getAttribute ( CoreTokenConstants . OBJECT_CLASS ) ; if ( attribute == null ) { entry . addAttribute ( CoreTokenConstants . OBJECT_CLASS , CoreTokenConstants . FR_CORE_TOKEN ) ; } return entry ; }
@ SuppressWarnings ( STR_ ) public List < Boundary > populateArea ( final Long wardId ) { HierarchyType hType = heirarchyTypeService . getHierarchyTypeByName ( hierarchyTypeName ) ; ; List < Boundary > areaList = new LinkedList < Boundary > ( ) ; final BoundaryType childBoundaryType = boundaryTypeService . getBoundaryTypeByNameAndHierarchyType ( STR_ , hType ) ; final Boundary parentBoundary = boundaryService . getBoundaryById ( wardId ) ; areaList = new LinkedList ( crossHeirarchyService . getCrossHierarchyChildrens ( parentBoundary , childBoundaryType ) ) ; LOGGER . info ( STR_ + areaList . toString ( ) ) ; return areaList ; }
private static String readName ( DataInputStream dis , byte data [ ] ) throws IOException { int c = dis . readUnsignedByte ( ) ; if ( ( c & xc0 ) == xc0 ) { c = ( ( c & x3f ) << NUM_ ) + dis . readUnsignedByte ( ) ; HashSet < Integer > jumps = new HashSet < Integer > ( ) ; jumps . add ( c ) ; return readName ( data , c , jumps ) ; } if ( c == NUM_ ) { return STR_ ; } byte b [ ] = new byte [ c ] ; dis . readFully ( b ) ; String s = IDN . toUnicode ( new String ( b ) ) ; String t = readName ( dis , data ) ; if ( t . length ( ) > NUM_ ) { s = s + STR_ + t ; } return s ; }
public SimpleString concat ( final char c ) { byte [ ] bytes = new byte [ data . length + NUM_ ] ; System . arraycopy ( data , NUM_ , bytes , NUM_ , data . length ) ; bytes [ data . length ] = ( byte ) ( c & xFF ) ; bytes [ data . length + NUM_ ] = ( byte ) ( c > > NUM_ & xFF ) ; return new SimpleString ( bytes ) ; }
public static double probToLogOdds ( double prob ) { if ( gr ( prob , NUM_ ) || ( sm ( prob , NUM_ ) ) ) { throw new IllegalArgumentException ( STR_ + STR_ + prob ) ; } double p = SMALL + ( NUM_ - NUM_ . SMALL ) . prob ; return Math . log ( p / ( NUM_ - p ) ) ; }
private void signalNotEmpty ( ) { final ReentrantLock takeLock = this . takeLock ; takeLock . lock ( ) ; try { notEmpty . signal ( ) ; } finally { takeLock . unlock ( ) ; } }
public void deepFill ( MaryNode specTree ) { tree = specTree ; numberOfLeaves = NUM_ ; sortNode ( NUM_ , tree ) ; }
public int nodeCount ( ) { return nodes == null ? NUM_ : nodes . size ( ) ; }
public void addToGlobalBlacklist ( String host ) { addToGlobalBlacklist ( host , System . currentTimeMillis ( ) + this . globalBlacklistTimeout ) ; }
public boolean addNode ( Lop node ) { if ( nodes . contains ( node ) ) return BOOL_ ; nodes . add ( node ) ; return BOOL_ ; }
private JSONArray requestAllFileSystems ( ) throws IOException , JSONException { JSONArray ret = new JSONArray ( ) ; for ( Filesystem fs : filesystems ) { ret . put ( fs . getRootEntry ( ) ) ; } return ret ; }
private void writeObject ( java . io . ObjectOutputStream s ) throws java . io . IOException { s . defaultWriteObject ( ) ; for ( Node < K , V > n = findFirst ( ) ; n != null ; n = n . next ) { V v = n . getValidValue ( ) ; if ( v != null ) { s . writeObject ( n . key ) ; s . writeObject ( v ) ; } } s . writeObject ( null ) ; }
public static final double sigma ( double a ) { return NUM_ / ( NUM_ + Math . exp ( - a ) ) ; }
public void insertOrRefresh ( final KBucketEntry newEntry ) { if ( newEntry == null ) return ; List < KBucketEntry > entriesRef = entries ; for ( KBucketEntry existing : entriesRef ) { if ( existing . equals ( newEntry ) ) { existing . mergeInTimestamps ( newEntry ) ; return ; } if ( existing . matchIPorID ( newEntry ) ) { DHT . logInfo ( STR_ + newEntry + STR_ + existing + STR_ ) ; return ; } } if ( newEntry . verifiedReachable ( ) ) { if ( entriesRef . size ( ) < DHTConstants . MAX_ENTRIES_PER_BUCKET ) { modifyMainBucket ( null , newEntry ) ; return ; } if ( replaceBadEntry ( newEntry ) ) return ; KBucketEntry youngest = entriesRef . get ( entriesRef . size ( ) - NUM_ ) ; if ( youngest . getCreationTime ( ) > newEntry . getCreationTime ( ) || newEntry . getRTT ( ) . NUM_ < youngest . getRTT ( ) ) { modifyMainBucket ( youngest , newEntry ) ; insertInReplacementBucket ( youngest ) ; return ; } } insertInReplacementBucket ( newEntry ) ; }
public void translate ( double x , double y ) { currentTransform . translate ( x , y ) ; try { writeTransform ( new AffineTransform ( NUM_ , NUM_ , NUM_ , NUM_ , x , y ) ) ; } catch ( IOException e ) { handleException ( e ) ; } }
public static boolean isSupportedAddRPProtectionVirtualPoolChange ( Volume volume , VirtualPool currentVpool , VirtualPool newVpool , DbClient dbClient , StringBuffer notSuppReasonBuff ) { s_logger . info ( String . format ( STR_ , currentVpool . getLabel ( ) , newVpool . getLabel ( ) ) ) ; if ( isSameVirtualPool ( currentVpool , newVpool , notSuppReasonBuff ) ) { return BOOL_ ; } if ( volume . checkForRp ( ) || VirtualPool . vPoolSpecifiesProtection ( currentVpool ) ) { notSuppReasonBuff . append ( STR_ ) ; return BOOL_ ; } if ( ! VirtualPool . vPoolSpecifiesHighAvailability ( currentVpool ) && VirtualPool . vPoolSpecifiesRPVPlex ( newVpool ) ) { notSuppReasonBuff . append ( STR_ ) ; return BOOL_ ; } if ( VirtualPool . vPoolSpecifiesHighAvailability ( currentVpool ) && ! VirtualPool . vPoolSpecifiesHighAvailabilityDistributed ( currentVpool ) && VirtualPool . vPoolSpecifiesMetroPoint ( newVpool ) ) { notSuppReasonBuff . append ( STR_ + STR_ ) ; return BOOL_ ; } String [ ] include = new String [ ] { TYPE , VARRAYS , REF_VPOOL , MIRROR_VPOOL , FAST_EXPANSION , ACLS , INACTIVE , PROTOCOLS , PROVISIONING_TYPE , USE_MATCHED_POOLS , ARRAY_INFO , DRIVE_TYPE , AUTO_TIER_POLICY_NAME , HOST_IO_LIMIT_IOPS , HOST_IO_LIMIT_BANDWIDTH , VMAX_COMPRESSION_ENABLED , IS_THIN_VOLUME_PRE_ALLOCATION_ENABLED , ASSIGNED_STORAGE_POOLS } ; Map < String , Change > changes = analyzeChanges ( currentVpool , newVpool , include , null , null ) ; if ( ! changes . isEmpty ( ) ) { notSuppReasonBuff . append ( STR_ ) ; fillInNotSupportedReasons ( changes , notSuppReasonBuff ) ; return BOOL_ ; } include = new String [ ] { PROTECTION_VARRAY_SETTINGS } ; changes = analyzeChanges ( currentVpool , newVpool , include , null , null ) ; if ( changes . isEmpty ( ) ) { notSuppReasonBuff . append ( STR_ ) ; fillInNotSupportedReasons ( changes , notSuppReasonBuff ) ; return BOOL_ ; } if ( VirtualPool . vPoolSpecifiesHighAvailability ( currentVpool ) && ( VirtualPool . vPoolSpecifiesRPVPlex ( newVpool ) || VirtualPool . vPoolSpecifiesMetroPoint ( newVpool ) ) ) { VirtualPoolChangeOperationEnum op = vplexCommonChecks ( volume , currentVpool , newVpool , dbClient , notSuppReasonBuff , include ) ; if ( op == null || ! op . equals ( VirtualPoolChangeOperationEnum . RP_PROTECTED ) ) { return BOOL_ ; } } return BOOL_ ; }
private void writeObject ( ObjectOutputStream oos ) throws IOException { oos . defaultWriteObject ( ) ; boolean writeFont = ( f != OMText . DEFAULT_FONT ) ; oos . writeBoolean ( writeFont ) ; if ( writeFont ) { oos . writeObject ( f . getName ( ) ) ; oos . writeInt ( f . getSize ( ) ) ; oos . writeInt ( f . getStyle ( ) ) ; } writeStroke ( oos , stroke , OMGraphic . BASIC_STROKE ) ; writeStroke ( oos , textMatteStroke , DEFAULT_TEXT_MATTE_STROKE ) ; }
private static void writeSpaces ( Writer out , int amt ) throws IOException { while ( amt > NUM_ ) { out . write ( STR_ ) ; amt -- ; } }
protected void handleAutoDraw ( ) { if ( isToolItemSelected ( ToolBarItemKey . AUTO_DRAW ) ) { onAutoDraw ( ) ; } }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
protected final void _loadToHaveAtLeast ( int minAvailable ) throws IOException { if ( _inputStream == null ) { throw _constructError ( STR_ + minAvailable + STR_ ) ; } int amount = _inputEnd - _inputPtr ; _currInputProcessed += _inputPtr ; if ( amount > NUM_ && _inputPtr > NUM_ ) { System . arraycopy ( _inputBuffer , _inputPtr , _inputBuffer , NUM_ , amount ) ; _inputEnd = amount ; } else { _inputEnd = NUM_ ; } _inputPtr = NUM_ ; while ( _inputEnd < minAvailable ) { int count = _inputStream . read ( _inputBuffer , _inputEnd , _inputBuffer . length - _inputEnd ) ; if ( count < NUM_ ) { _closeInput ( ) ; if ( count == NUM_ ) { throw new IOException ( STR_ + amount + STR_ ) ; } throw _constructError ( STR_ + minAvailable + STR_ + minAvailable + STR_ ) ; } _inputEnd += count ; } }
public Z21Message ( byte [ ] a , int l ) { super ( String . valueOf ( a ) ) ; setBinary ( BOOL_ ) ; }
private MethodDescriptor [ ] sortMethodDescriptors ( MethodDescriptor [ ] methodDescriptors ) { return methodSorter != null ? methodSorter . sortMethodDescriptors ( methodDescriptors ) : methodDescriptors ; }
public static Properties parsePropertyList ( String list ) throws PropertyStringFormatException { return parsePropertyList ( list , propertySeparators , keyValueSeparators ) ; }
public boolean packageHasAnnotation ( Annotation annotation ) { try { Package pkg = type . getPackage ( ) ; if ( pkg == null ) { return BOOL_ ; } String className = pkg . getName ( ) + STR_ ; Class < ? > packageType = Class . forName ( className ) ; AnnotationAccessor accessor = new AnnotationAccessor ( supportedAnnotations , packageType , ignoreAnnotationFailure ) ; return accessor . typeHas ( annotation ) ; } catch ( ClassNotFoundException e ) { return BOOL_ ; } }
private String buildToolTip ( final CTaggedGraphNodesContainerNode node ) { final StringBuilder tooltip = new StringBuilder ( STR_ ) ; boolean first = BOOL_ ; for ( final NaviNode graphnode : node . getGraphNodes ( ) ) { if ( ! first ) { tooltip . append ( STR_ ) ; } tooltip . append ( CNodesDisplayString . getDisplayString ( graphnode ) ) ; first = BOOL_ ; } return tooltip + STR_ ; }
public void makeGraph ( File linkGraph ) throws Exception { String temp212 ; int rowNum = NUM_ ; BufferedReader br = new BufferedReader ( new InputStreamReader ( new FileInputStream ( linkGraph ) ) ) ; while ( ( temp212 = br . readLine ( ) ) != null ) { String [ ] strs = temp212 . split ( STR_ ) ; for ( int i = NUM_ ; i < strs . length ; i ++ ) { graph [ rowNum ] [ i ] = Double . parseDouble ( strs [ i ] ) ; } rowNum ++ ; } for ( int i = NUM_ ; i < dataNum ; i ++ ) { for ( int j = NUM_ ; j < dimension ; j ++ ) { W [ i ] [ j ] = r . nextDouble ( ) ; H [ j ] [ i ] = r . nextDouble ( ) ; } } for ( int i = NUM_ ; i < dataNum ; i ++ ) { double sumW = NUM_ ; double sumH = NUM_ ; for ( int j = NUM_ ; j < dimension ; j ++ ) { sumW += W [ i ] [ j ] . W [ i ] [ j ] ; sumH += H [ j ] [ i ] . H [ j ] [ i ] ; } sumW = Math . sqrt ( sumW ) ; sumH = Math . sqrt ( sumH ) ; for ( int j = NUM_ ; j < dimension ; j ++ ) { W [ i ] [ j ] /= sumW ; H [ j ] [ i ] /= sumH ; } } trainW ( ) ; init = BOOL_ ; }
public void removeSwipeListener ( SwipeListener listener ) { if ( mListeners == null ) { return ; } mListeners . remove ( listener ) ; }
public boolean removeOnItemClickListener ( OnItemClickListener itemClickListener ) { return clickListeners . remove ( itemClickListener ) ; }
@ Override protected int lookForSelectablePosition ( int position , boolean lookDown ) { final ListAdapter adapter = mAdapter ; if ( adapter == null || isInTouchMode ( ) ) { return INVALID_POSITION ; } final int count = adapter . getCount ( ) ; if ( ! mAreAllItemsSelectable ) { if ( lookDown ) { position = Math . max ( NUM_ , position ) ; while ( position < count && ! adapter . isEnabled ( position ) ) { position ++ ; } } else { position = Math . min ( position , count - NUM_ ) ; while ( position >= NUM_ && ! adapter . isEnabled ( position ) ) { position -- ; } } if ( position < NUM_ || position >= count ) { return INVALID_POSITION ; } return position ; } else { if ( position < NUM_ || position >= count ) { return INVALID_POSITION ; } return position ; } }
public static String padRight ( final String s , final int length ) { final int pad = length - s . length ( ) ; return pad > NUM_ ? s + getSpaceString ( pad ) : s ; }
private static String [ ] collationMatchingRuleNames ( final List < String > localeNames , final int numSuffix , final String symbolicSuffix ) { final List < String > names = new ArrayList < > ( ) ; for ( String localeName : localeNames ) { if ( symbolicSuffix . isEmpty ( ) ) { names . add ( localeName ) ; } else { names . add ( localeName + STR_ + numSuffix ) ; names . add ( localeName + STR_ + symbolicSuffix ) ; } } return names . toArray ( new String [ names . size ( ) ] ) ; }
public static boolean isCacheSafe ( Class < ? > clazz , ClassLoader classLoader ) { Assert . notNull ( clazz , STR_ ) ; ClassLoader target = clazz . getClassLoader ( ) ; if ( target == null ) { return BOOL_ ; } ClassLoader cur = classLoader ; if ( cur == target ) { return BOOL_ ; } while ( cur != null ) { cur = cur . getParent ( ) ; if ( cur == target ) { return BOOL_ ; } } return BOOL_ ; }
public void write ( PrintStream out ) { write ( out , table ) ; }
static Part from ( String encoded , String decoded ) { if ( encoded == null ) { return NULL ; } if ( encoded . length ( ) == NUM_ ) { return EMPTY ; } if ( decoded == null ) { return NULL ; } if ( decoded . length ( ) == NUM_ ) { return EMPTY ; } return new Part ( encoded , decoded ) ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
private int [ ] createEpochMonths ( int epochDay , int minYear , int maxYear , Map < Integer , int [ ] > years ) { int numMonths = ( maxYear - minYear + NUM_ ) . NUM_ + NUM_ ; int epochMonth = NUM_ ; int [ ] epochMonths = new int [ numMonths ] ; minMonthLength = Integer . MAX_VALUE ; maxMonthLength = Integer . MIN_VALUE ; for ( int year = minYear ; year <= maxYear ; year ++ ) { int [ ] months = years . get ( year ) ; for ( int month = NUM_ ; month < NUM_ ; month ++ ) { int length = months [ month ] ; epochMonths [ epochMonth ++ ] = epochDay ; if ( length < NUM_ || length > NUM_ ) { throw new IllegalArgumentException ( STR_ + minYear ) ; } epochDay += length ; minMonthLength = Math . min ( minMonthLength , length ) ; maxMonthLength = Math . max ( maxMonthLength , length ) ; } } epochMonths [ epochMonth ++ ] = epochDay ; if ( epochMonth != epochMonths . length ) { throw new IllegalStateException ( STR_ + epochMonth + STR_ + epochMonths . length ) ; } return epochMonths ; }
private static String descriptorToInternalName ( String descriptor ) { switch ( descriptor . charAt ( NUM_ ) ) { case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : return descriptor ; case STR_ : return classDescriptorToInternalName ( descriptor ) ; default : throw new IllegalArgumentException ( STR_ + descriptor ) ; } }
public Subscription register ( Object mBean , MBeanDescription description ) { return register ( mBean , description . getMBeanName ( getNextId ( ) ) ) ; }
void checkAfterUnmarshalled ( ) { assertEquals ( shortVal . shortValue ( ) , x1122 ) ; assertEquals ( longVal , x8877665544332211L ) ; assertNull ( aArr ) ; assertNull ( strVal ) ; assertEquals ( doubleVal , NUM_ ) ; }
public void put ( int key , E value ) { int i = ContainerHelpers . binarySearch ( mKeys , mSize , key ) ; if ( i >= NUM_ ) { mValues [ i ] = value ; } else { i = ~ i ; if ( i < mSize && mValues [ i ] == DELETED ) { mKeys [ i ] = key ; mValues [ i ] = value ; return ; } if ( mGarbage && mSize >= mKeys . length ) { gc ( ) ; i = ~ ContainerHelpers . binarySearch ( mKeys , mSize , key ) ; } if ( mSize >= mKeys . length ) { int n = ContainerHelpers . idealIntArraySize ( mSize + NUM_ ) ; int [ ] nkeys = new int [ n ] ; Object [ ] nvalues = new Object [ n ] ; System . arraycopy ( mKeys , NUM_ , nkeys , NUM_ , mKeys . length ) ; System . arraycopy ( mValues , NUM_ , nvalues , NUM_ , mValues . length ) ; mKeys = nkeys ; mValues = nvalues ; } if ( mSize - i != NUM_ ) { System . arraycopy ( mKeys , i , mKeys , i + NUM_ , mSize - i ) ; System . arraycopy ( mValues , i , mValues , i + NUM_ , mSize - i ) ; } mKeys [ i ] = key ; mValues [ i ] = value ; mSize ++ ; } }
@ Override public < R > CompletableFuture < R > collect ( final Supplier < R > supplier , final BiConsumer < R , ? super T > accumulator , final BiConsumer < R , R > combiner ) { return CompletableFuture . supplyAsync ( null , exec ) ; }
@ SuppressWarnings ( STR_ ) protected Object fromReflectionType ( final Object value ) { FieldDescriptor descriptor = getDescriptor ( ) ; if ( descriptor . isRepeated ( ) ) { if ( descriptor . getJavaType ( ) == FieldDescriptor . JavaType . MESSAGE || descriptor . getJavaType ( ) == FieldDescriptor . JavaType . ENUM ) { final List result = new ArrayList ( ) ; for ( final Object element : ( List ) value ) { result . add ( singularFromReflectionType ( element ) ) ; } return result ; } else { return value ; } } else { return singularFromReflectionType ( value ) ; } }
public void registerManufacturerSpecificBuilder ( int companyId , ADManufacturerSpecificBuilder builder ) { if ( companyId < NUM_ || xFFFF < companyId ) { String message = String . format ( STR_ , companyId ) ; throw new IllegalArgumentException ( message ) ; } if ( builder == null ) { return ; } Integer key = Integer . valueOf ( companyId ) ; List < ADManufacturerSpecificBuilder > builders = mMSBuilders . get ( key ) ; if ( builders == null ) { builders = new ArrayList < ADManufacturerSpecificBuilder > ( ) ; mMSBuilders . put ( key , builders ) ; } builders . add ( NUM_ , builder ) ; }
public static ReilGraph copyReilCode ( final Window parent , final INaviCodeNode node ) { final ReilTranslator < INaviInstruction > translator = new ReilTranslator < INaviInstruction > ( ) ; try { return translator . translate ( new StandardEnvironment ( ) , node ) ; } catch ( final InternalTranslationException e ) { CUtilityFunctions . logException ( e ) ; final String message = STR_ + STR_ ; final String description = CUtilityFunctions . createDescription ( String . format ( STR_ , node . getAddress ( ) ) , new String [ ] { STR_ } , new String [ ] { STR_ + STR_ } ) ; NaviErrorDialog . show ( parent , message , description , e ) ; } return null ; }
private static void applyOverrides ( ) { InputStream stream = getContentTypesPropertiesStream ( ) ; if ( stream == null ) { return ; } try { try { Properties overrides = new Properties ( ) ; overrides . load ( stream ) ; for ( Map . Entry < Object , Object > entry : overrides . entrySet ( ) ) { String extension = ( String ) entry . getKey ( ) ; String mimeType = ( String ) entry . getValue ( ) ; add ( mimeType , extension ) ; } } finally { stream . close ( ) ; } } catch ( IOException ignored ) { } }
public static String toString ( Reader reader , long timeout ) throws IOException { StringWriter sw = new StringWriter ( NUM_ ) ; copy ( toBufferedReader ( reader ) , sw , timeout ) ; sw . close ( ) ; return sw . toString ( ) ; }
private static float computeSimilarity ( Lane a , Lane b ) { int same = NUM_ ; int diff = NUM_ ; int firstCoordinate = Math . max ( a . getFirstNonGapPosition ( ) , b . getFirstNonGapPosition ( ) ) ; int lastCoordinate = Math . min ( a . getLastNonGapPosition ( ) , b . getLastNonGapPosition ( ) ) ; for ( int i = firstCoordinate ; i <= lastCoordinate ; i ++ ) { char cha = a . charAt ( i ) ; char chb = b . charAt ( i ) ; if ( Character . isLetter ( cha ) && Character . isLetter ( chb ) ) { if ( Character . toLowerCase ( cha ) == Character . toLowerCase ( ( chb ) ) ) same ++ ; else diff ++ ; } } return Math . max ( same > NUM_ ? NUM_ : NUM_ , same - NUM_ . diff ) ; }
private void forceOverflow ( ) { forceOverflow ( ) ; }
public int find ( String string ) { if ( string == null ) { return - NUM_ ; } for ( int i = NUM_ ; i != m_stringOffsets . length ; ++ i ) { int offset = m_stringOffsets [ i ] ; int length = getShort ( m_strings , offset ) ; if ( length != string . length ( ) ) { continue ; } int j = NUM_ ; for ( ; j != length ; ++ j ) { offset += NUM_ ; if ( string . charAt ( j ) != getShort ( m_strings , offset ) ) { break ; } } if ( j == length ) { return i ; } } return - NUM_ ; }
public String prepOperand ( String label , DataType dt , ValueType vt , boolean literal ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( label ) ; sb . append ( Lop . DATATYPE_PREFIX ) ; sb . append ( dt ) ; sb . append ( Lop . VALUETYPE_PREFIX ) ; sb . append ( vt ) ; sb . append ( Lop . LITERAL_PREFIX ) ; sb . append ( literal ) ; return sb . toString ( ) ; }
public static List < SpaceTime > divideConquerBrownianBridge ( MultivariateNormalDistribution normal , SpaceTime start , SpaceTime end , int depth , int maxTries , SpaceTimeRejector rejector ) { List < SpaceTime > points = new LinkedList < SpaceTime > ( ) ; points . add ( start ) ; points . add ( end ) ; stop = BOOL_ ; if ( divideConquerBrownianBridge ( normal , NUM_ , points , depth , maxTries , rejector ) == ( NUM_ << ( depth - NUM_ ) ) ) { return points ; } stop = BOOL_ ; return null ; }
public static EjbJarXmlVersion valueOf ( DocumentType docType ) throws NullPointerException { return valueOf ( docType . getPublicId ( ) ) ; }
private boolean matchStrings ( String pattern , String str , boolean caseSensitive ) { char [ ] patArr = pattern . toCharArray ( ) ; char [ ] strArr = str . toCharArray ( ) ; int patIdxStart = NUM_ ; int patIdxEnd = patArr . length - NUM_ ; int strIdxStart = NUM_ ; int strIdxEnd = strArr . length - NUM_ ; char ch ; boolean containsStar = BOOL_ ; for ( char c : patArr ) { if ( c == STR_ ) { containsStar = BOOL_ ; break ; } } if ( ! containsStar ) { if ( patIdxEnd != strIdxEnd ) { return BOOL_ ; } for ( int i = NUM_ ; i <= patIdxEnd ; i ++ ) { ch = patArr [ i ] ; if ( ch != STR_ ) { if ( different ( caseSensitive , ch , strArr [ i ] ) ) { return BOOL_ ; } } } return BOOL_ ; } if ( patIdxEnd == NUM_ ) { return BOOL_ ; } while ( ( ch = patArr [ patIdxStart ] ) != STR_ && strIdxStart <= strIdxEnd ) { if ( ch != STR_ ) { if ( different ( caseSensitive , ch , strArr [ strIdxStart ] ) ) { return BOOL_ ; } } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != STR_ ) { return BOOL_ ; } } return BOOL_ ; } while ( ( ch = patArr [ patIdxEnd ] ) != STR_ && strIdxStart <= strIdxEnd ) { if ( ch != STR_ ) { if ( different ( caseSensitive , ch , strArr [ strIdxEnd ] ) ) { return BOOL_ ; } } patIdxEnd -- ; strIdxEnd -- ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != STR_ ) { return BOOL_ ; } } return BOOL_ ; } while ( patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd ) { int patIdxTmp = - NUM_ ; for ( int i = patIdxStart + NUM_ ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] == STR_ ) { patIdxTmp = i ; break ; } } if ( patIdxTmp == patIdxStart + NUM_ ) { patIdxStart ++ ; continue ; } int patLength = patIdxTmp - patIdxStart - NUM_ ; int strLength = strIdxEnd - strIdxStart + NUM_ ; int foundIdx = - NUM_ ; strLoop : for ( int i = NUM_ ; i <= strLength - patLength ; i ++ ) { for ( int j = NUM_ ; j < patLength ; j ++ ) { ch = patArr [ patIdxStart + j + NUM_ ] ; if ( ch != STR_ ) { if ( different ( caseSensitive , ch , strArr [ strIdxStart + i + j ] ) ) { continue strLoop ; } } } foundIdx = strIdxStart + i ; break ; } if ( foundIdx == - NUM_ ) { return BOOL_ ; } patIdxStart = patIdxTmp ; strIdxStart = foundIdx + patLength ; } for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != STR_ ) { return BOOL_ ; } } return BOOL_ ; }
public static List < Double > mergeCoords ( List < Double > x , List < Double > y ) { if ( x . size ( ) != y . size ( ) ) throw new IllegalArgumentException ( STR_ ) ; List < Double > ret = new ArrayList < > ( ) ; for ( int i = NUM_ ; i < x . size ( ) ; i ++ ) { ret . add ( x . get ( i ) ) ; ret . add ( y . get ( i ) ) ; } return ret ; }
public static void print ( int x ) { out . print ( x ) ; out . flush ( ) ; }
public void copyText ( ) { int end , start ; end = selectedCharField . getSelectionEnd ( ) ; start = selectedCharField . getSelectionStart ( ) ; selectedCharField . selectAll ( ) ; selectedCharField . copy ( ) ; selectedCharField . select ( start , end ) ; }
public void handleButton1Request ( RequestInvocationEvent event ) throws ModelControlException { try { AuthPropertiesModel model = ( AuthPropertiesModel ) getModel ( ) ; Map original = model . getValues ( ) ; AMPropertySheet ps = ( AMPropertySheet ) getChild ( PROPERTY_ATTRIBUTE ) ; model . setValues ( ps . getAttributeValues ( original , BOOL_ , model ) ) ; setInlineAlertMessage ( CCAlert . TYPE_INFO , STR_ , STR_ ) ; } catch ( AMConsoleException a ) { setInlineAlertMessage ( CCAlert . TYPE_ERROR , STR_ , a . getMessage ( ) ) ; } forwardTo ( ) ; }
private void buildDescriptionPanel ( final Composite parent ) { descriptionLabel = new StyledText ( parent , SWT . READ_ONLY ) ; descriptionLabel . setText ( STR_ ) ; descriptionLabel . setLayoutData ( new GridData ( GridData . FILL , GridData . FILL , BOOL_ , BOOL_ , NUM_ , NUM_ ) ) ; }
public HttpMethodClient ( ) { this ( NUM_ , NUM_ , NUM_ . NUM_ ) ; }
public ISO9796d2PSSSigner ( AsymmetricBlockCipher cipher , Digest digest , int saltLength , boolean implicit ) { this . cipher = cipher ; this . digest = digest ; this . hLen = digest . getDigestSize ( ) ; this . saltLength = saltLength ; if ( implicit ) { trailer = TRAILER_IMPLICIT ; } else { Integer trailerObj = ( Integer ) trailerMap . get ( digest . getAlgorithmName ( ) ) ; if ( trailerObj != null ) { trailer = trailerObj . intValue ( ) ; } else { throw new IllegalArgumentException ( STR_ ) ; } } }
String decodeTextValue ( byte [ ] data ) throws IOException { boolean isCompressed = ( ( data . length > NUM_ ) && ( data [ NUM_ ] == TEXT_COMPRESSION_HEADER [ NUM_ ] ) && ( data [ NUM_ ] == TEXT_COMPRESSION_HEADER [ NUM_ ] ) ) ; if ( isCompressed ) { StringBuilder textBuf = new StringBuilder ( data . length ) ; int dataStart = TEXT_COMPRESSION_HEADER . length ; int dataEnd = dataStart ; boolean inCompressedMode = BOOL_ ; while ( dataEnd < data . length ) { if ( data [ dataEnd ] == ( byte ) x00 ) { decodeTextSegment ( data , dataStart , dataEnd , inCompressedMode , textBuf ) ; inCompressedMode = ! inCompressedMode ; ++ dataEnd ; dataStart = dataEnd ; } else { ++ dataEnd ; } } decodeTextSegment ( data , dataStart , dataEnd , inCompressedMode , textBuf ) ; return textBuf . toString ( ) ; } return decodeUncompressedText ( data , getCharset ( ) ) ; }
private < S , T > Set < T > extract ( final Collection < S > collection , final Extractor < S , T > extractor ) { final Set < T > values = new HashSet < T > ( collection . size ( ) ) ; for ( final S instance : collection ) { values . add ( extractor . getValue ( instance ) ) ; } return values ; }
public static boolean isZTE ( ) { return sBuildModel . startsWith ( STR_ ) ; }
static public String normalizeToEncoding ( String origString_ , Charset encoding_ ) { String normString = origString_ ; CharsetEncoder encoder = encoding_ . newEncoder ( ) ; if ( ! encoder . canEncode ( origString_ ) ) { final int length = origString_ . length ( ) ; char [ ] normSeq = new char [ ( origString_ . length ( ) ) ] ; int charNum = NUM_ ; for ( int offset = NUM_ ; offset < length ; ) { Pair < Character , Integer > replacement = normalizeCodepoint ( origString_ , encoding_ , offset ) ; Character replacedChar = replacement . getFirst ( ) ; int codepoint = replacement . getSecond ( ) ; if ( null != replacedChar ) { normSeq [ charNum ] = replacedChar ; charNum ++ ; } offset += Character . charCount ( codepoint ) ; } normString = new String ( normSeq ) ; } return normString ; }
private FastConcurrentSkipListMap . Node < K , V > loNode ( ) { if ( lo == null ) return m . findFirst ( ) ; else if ( loInclusive ) return m . findNear ( lo , m . GT | m . EQ ) ; else return m . findNear ( lo , m . GT ) ; }
public int size ( ) { return m_sets . size ( ) ; }
public Line3D ( Stack < Vector3 > points , float thickness , int [ ] colors , boolean createVBOs ) { super ( ) ; mPoints = points ; mLineThickness = thickness ; mColors = colors ; if ( colors != null && colors . length != points . size ( ) ) throw new RuntimeException ( STR_ ) ; init ( createVBOs ) ; }
public static byte [ ] asUnsignedByteArray ( BigInteger value ) { byte [ ] bytes = value . toByteArray ( ) ; if ( bytes [ NUM_ ] == NUM_ ) { byte [ ] tmp = new byte [ bytes . length - NUM_ ] ; System . arraycopy ( bytes , NUM_ , tmp , NUM_ , tmp . length ) ; return tmp ; } return bytes ; }
public static float approximateLength ( float controlPoints [ ] [ ] ) { float length = NUM_ ; for ( int i = NUM_ ; i < controlPoints . length - NUM_ ; i ++ ) { float xDif = controlPoints [ i + NUM_ ] [ NUM_ ] - controlPoints [ i ] [ NUM_ ] ; float yDif = controlPoints [ i + NUM_ ] [ NUM_ ] - controlPoints [ i ] [ NUM_ ] ; float zDif = controlPoints [ i + NUM_ ] [ NUM_ ] - controlPoints [ i ] [ NUM_ ] ; length += Math . sqrt ( xDif . xDif + yDif . yDif + zDif . zDif ) ; } return length ; }
protected int mapDragOperationFromModifiers ( MouseEvent e ) { int mods = e . getModifiersEx ( ) ; int btns = mods & ButtonMask ; if ( ! ( btns == InputEvent . BUTTON1_DOWN_MASK || btns == InputEvent . BUTTON2_DOWN_MASK ) ) { return DnDConstants . ACTION_NONE ; } return SunDragSourceContextPeer . convertModifiersToDropAction ( mods , getSourceActions ( ) ) ; }
public UpdateClause addAssignment ( Expression expression ) { assignments . add ( new Assignment ( expression ) ) ; return this ; }
private boolean stepValue ( ) { while ( BOOL_ ) { if ( iter != null && iter . hasNext ( ) ) { svcs = ( ArrayList ) iter . next ( ) ; svcidx = svcs . size ( ) ; return BOOL_ ; } if ( ! stepClass ( ) ) return BOOL_ ; if ( iter == null ) return BOOL_ ; } }
private ArrayList < IconMarker > createIconMarkers ( ) { final ArrayList < IconMarker > iconMarkers = new ArrayList < > ( LOCATIONS . length ) ; iconMarkers . add ( new IconMarker ( LOCATIONS [ NUM_ ] , R . drawable . bread , R . drawable . bread_c ) ) ; iconMarkers . add ( new IconMarker ( LOCATIONS [ NUM_ ] , R . drawable . butcher , R . drawable . butcher_c ) ) ; iconMarkers . add ( new IconMarker ( LOCATIONS [ NUM_ ] , R . drawable . fruits , R . drawable . fruits_c ) ) ; iconMarkers . add ( new IconMarker ( LOCATIONS [ NUM_ ] , R . drawable . grocery , R . drawable . grocery_c ) ) ; iconMarkers . add ( new IconMarker ( LOCATIONS [ NUM_ ] , R . drawable . patisserie , R . drawable . patisserie_c ) ) ; return iconMarkers ; }
public void hasNetworkConnection ( NetworkRequestCheckListener listener ) { if ( hasNetworkConnection ( ) ) { testNetworkRequest ( listener ) ; } else { listener . onNoResponse ( ) ; } }
public void assignThreadForSubscriber ( @ NonNull Object subscriber ) { Looper looper = Looper . myLooper ( ) ; if ( looper != null ) { mSubscribersDefaultThreads . put ( new IdentityWeakReferenceKey < > ( subscriber ) , looper != Looper . getMainLooper ( ) ? new Handler ( looper ) : mUiThreadHandler ) ; } else { mSubscribersDefaultThreads . remove ( new IdentityWeakReferenceKey < > ( subscriber ) ) ; } }
private void validateDynamicAttribute ( Set dynamicSet ) throws PolicyException { if ( DEBUG . messageEnabled ( ) ) { DEBUG . message ( STR_ + STR_ + dynamicSet ) ; } responseAttrNames = new HashSet ( ) ; repoAttrNames = new HashSet ( ) ; responseAttrToRepoAttr = new HashMap ( ) ; if ( DEBUG . messageEnabled ( ) ) { DEBUG . message ( STR_ + STR_ + validDynamicAttrNames ) ; } Set dynamicAttrs = ( ( Set ) properties . get ( DYNAMIC_ATTRIBUTE ) ) ; if ( DEBUG . messageEnabled ( ) ) { DEBUG . message ( STR_ + STR_ + dynamicAttrs ) ; } Iterator dynamicAttrsIter = dynamicAttrs . iterator ( ) ; while ( dynamicAttrsIter . hasNext ( ) ) { String attr = ( String ) dynamicAttrsIter . next ( ) ; if ( ! validDynamicAttrNames . contains ( attr ) ) { if ( DEBUG . warningEnabled ( ) ) { DEBUG . warning ( STR_ + STR_ + STR_ + attr ) ; } continue ; } String [ ] attrNames = parseDynamicAttrName ( attr ) ; String responseAttrName = attrNames [ NUM_ ] ; String repoAttrName = attrNames [ NUM_ ] ; responseAttrNames . add ( responseAttrName ) ; repoAttrNames . add ( repoAttrName ) ; addToResponseAttrToRepoAttrMap ( responseAttrName , repoAttrName ) ; if ( DEBUG . messageEnabled ( ) ) { DEBUG . message ( STR_ + STR_ + STR_ + responseAttrName + STR_ + repoAttrName ) ; } } if ( DEBUG . messageEnabled ( ) ) { DEBUG . message ( STR_ + STR_ + responseAttrToRepoAttr ) ; DEBUG . message ( STR_ + STR_ ) ; } }
public static boolean typeCheck ( Class type , Object instance ) { return type . isAssignableFrom ( instance . getClass ( ) ) || isWrapperInstance ( type , instance ) ; }
public synchronized void init ( ) { ArrayList < Warrant > tempList = new ArrayList < Warrant > ( ) ; List < String > systemNameList = _manager . getSystemNameList ( ) ; Iterator < String > iter = systemNameList . iterator ( ) ; while ( iter . hasNext ( ) ) { Warrant w = _manager . getBySystemName ( iter . next ( ) ) ; if ( ! _warList . contains ( w ) ) { w . addPropertyChangeListener ( this ) ; } else { _warList . remove ( w ) ; } tempList . add ( w ) ; } for ( int i = NUM_ ; i < _warList . size ( ) ; i ++ ) { Warrant w = _warList . get ( i ) ; if ( ! _warNX . contains ( w ) ) { w . removePropertyChangeListener ( this ) ; } } for ( int i = NUM_ ; i < _warNX . size ( ) ; i ++ ) { tempList . add ( _warNX . get ( i ) ) ; } _warList = tempList ; }
public void addCommand ( Command cmd , int offset ) { menuBar . addCommand ( cmd , offset ) ; }
public boolean connect ( final String address ) { if ( mBluetoothAdapter == null || address == null ) { Log . w ( TAG , STR_ ) ; return BOOL_ ; } if ( mBluetoothDeviceAddress != null && address . equals ( mBluetoothDeviceAddress ) && mBluetoothGatt != null ) { Log . d ( TAG , STR_ ) ; if ( mBluetoothGatt . connect ( ) ) { mConnectionState = STATE_CONNECTING ; return BOOL_ ; } else { return BOOL_ ; } } final BluetoothDevice device = mBluetoothAdapter . getRemoteDevice ( address ) ; if ( device == null ) { Log . w ( TAG , STR_ ) ; return BOOL_ ; } mBluetoothGatt = device . connectGatt ( this , BOOL_ , mGattCallback ) ; Log . d ( TAG , STR_ ) ; mBluetoothDeviceAddress = address ; mConnectionState = STATE_CONNECTING ; return BOOL_ ; }
private double normalDens ( double x , double mean , double stdDev ) { double diff = x - mean ; return ( NUM_ / ( m_normConst . stdDev ) ) . Math . exp ( - ( diff . diff / ( NUM_ . stdDev . stdDev ) ) ) ; }
private static void drawShape ( GL2 gl , Shape s ) { PathIterator it = s . getPathIterator ( new AffineTransform ( ) , shapeFlatness ) ; float [ ] lastMoveTo = new float [ NUM_ ] ; float [ ] f = new float [ NUM_ ] ; while ( ! it . isDone ( ) ) { int res = it . currentSegment ( f ) ; switch ( res ) { case PathIterator . SEG_CLOSE : GLPanel . V ( gl , lastMoveTo [ NUM_ ] , lastMoveTo [ NUM_ ] ) ; break ; case PathIterator . SEG_MOVETO : GLPanel . V ( gl , f [ NUM_ ] , f [ NUM_ ] ) ; System . arraycopy ( f , NUM_ , lastMoveTo , NUM_ , NUM_ ) ; break ; case PathIterator . SEG_LINETO : GLPanel . V ( gl , f [ NUM_ ] , f [ NUM_ ] ) ; break ; case PathIterator . SEG_CUBICTO : CubicCurve2D c = new CubicCurve2D . Float ( lastMoveTo [ NUM_ ] , lastMoveTo [ NUM_ ] , f [ NUM_ ] , f [ NUM_ ] , f [ NUM_ ] , f [ NUM_ ] , f [ NUM_ ] , f [ NUM_ ] ) ; drawShape ( gl , c ) ; break ; default : throw new Error ( STR_ + STR_ + res ) ; } it . next ( ) ; } }
@ Override protected void tearDown ( ) throws NamingException , JMSException { NamingEnumeration < Binding > iter = context . listBindings ( STR_ ) ; while ( iter . hasMore ( ) ) { Binding binding = iter . next ( ) ; Object connFactory = binding . getObject ( ) ; if ( connFactory instanceof ActiveMQConnectionFactory ) { } } }
protected List < URI > load ( final InputStream in ) throws SAXException , IOException { SAXParser saxParser ; final SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; try { saxParser = factory . newSAXParser ( ) ; } catch ( final ParserConfigurationException ex ) { throw new SAXException ( ex ) ; } groups = new LinkedList < URI > ( ) ; saxParser . parse ( in , this ) ; return groups ; }
public final void lazySet ( long newValue ) { unsafe . putOrderedLong ( this , valueOffset , newValue ) ; }
private static List < Object > createEqualityKey ( Node node ) { List < Object > values = new ArrayList < Object > ( ) ; values . add ( node . getNodeType ( ) ) ; values . add ( node . getNodeName ( ) ) ; values . add ( node . getLocalName ( ) ) ; values . add ( node . getNamespaceURI ( ) ) ; values . add ( node . getPrefix ( ) ) ; values . add ( node . getNodeValue ( ) ) ; for ( Node child = node . getFirstChild ( ) ; child != null ; child = child . getNextSibling ( ) ) { values . add ( child ) ; } switch ( node . getNodeType ( ) ) { case DOCUMENT_TYPE_NODE : DocumentTypeImpl doctype = ( DocumentTypeImpl ) node ; values . add ( doctype . getPublicId ( ) ) ; values . add ( doctype . getSystemId ( ) ) ; values . add ( doctype . getInternalSubset ( ) ) ; values . add ( doctype . getEntities ( ) ) ; values . add ( doctype . getNotations ( ) ) ; break ; case ELEMENT_NODE : Element element = ( Element ) node ; values . add ( element . getAttributes ( ) ) ; break ; } return values ; }
@ Deprecated public static String Collection2String ( Collection < ? > in , String separator ) { if ( in == null ) { return null ; } return Iterator2String ( in . iterator ( ) , separator ) ; }
public static byte [ ] decodeBase64 ( String base64Str ) { return DatatypeConverter . parseBase64Binary ( base64Str ) ; }
protected void removeAllPremoveDrops ( ) { for ( PremoveInfo info : premoves . toArray ( new PremoveInfo [ NUM_ ] ) ) { if ( info . isPremoveDrop ) { premoves . remove ( info ) ; } } }
public void testClearBitZero ( ) { byte aBytes [ ] = { NUM_ } ; int aSign = NUM_ ; int number = NUM_ ; byte rBytes [ ] = { NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger result = aNumber . clearBit ( number ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public static String sayNumber ( StringBuffer appendTo , double number ) throws IllegalArgumentException { if ( number == Double . MIN_VALUE ) { throw new IllegalArgumentException ( STR_ ) ; } if ( number < NUM_ ) { appendTo . append ( STR_ ) ; } double abs = Math . abs ( number ) ; if ( abs < POWER_THREE ) { saySimpleNumber ( appendTo , ( int ) abs ) ; } else if ( abs < NUM_ ) { int thousand = ( int ) ( abs % POWER_THREE ) ; appendTo . append ( STR_ ) ; saySimpleNumber ( appendTo , thousand ) ; } else if ( abs < POWER_SIX ) { int thousand = ( int ) ( abs % POWER_SIX / POWER_THREE ) ; saySimpleNumber ( appendTo , thousand ) ; appendTo . append ( STR_ ) ; double remainder = abs - thousand . POWER_THREE ; if ( remainder > NUM_ ) { appendTo . append ( STR_ ) ; sayNumber ( appendTo , remainder ) ; } } else if ( abs < POWER_NINE ) { int million = ( int ) ( abs % POWER_NINE / POWER_SIX ) ; saySimpleNumber ( appendTo , million ) ; appendTo . append ( STR_ ) ; double remainder = abs - million . POWER_SIX ; if ( remainder > NUM_ ) { appendTo . append ( STR_ ) ; sayNumber ( appendTo , remainder ) ; } } else if ( abs < POWER_TWELVE ) { int billion = ( int ) ( abs % POWER_TWELVE / POWER_NINE ) ; saySimpleNumber ( appendTo , billion ) ; appendTo . append ( STR_ ) ; double remainder = abs - billion . POWER_NINE ; if ( remainder > NUM_ ) { appendTo . append ( STR_ ) ; sayNumber ( appendTo , remainder ) ; } } else if ( abs < POWER_FIFTEEN ) { int trillion = ( int ) ( abs % POWER_FIFTEEN / POWER_TWELVE ) ; saySimpleNumber ( appendTo , trillion ) ; appendTo . append ( STR_ ) ; double remainder = abs - trillion . POWER_TWELVE ; if ( remainder > NUM_ ) { appendTo . append ( STR_ ) ; sayNumber ( appendTo , remainder ) ; } } else { appendTo . append ( STR_ ) ; } return appendTo . toString ( ) ; }
public void stop ( ) { _throttle . setSpeedSetting ( - NUM_ ) ; _throttle . setSpeedSetting ( NUM_ ) ; stopLabel . setIcon ( stopIcon ) ; stopLabel . setIconTextGap ( _gap ) ; pack ( ) ; }
public void encode ( OutputStream out ) throws IOException { DerOutputStream tmp = new DerOutputStream ( ) ; dnName . encode ( tmp ) ; out . write ( tmp . toByteArray ( ) ) ; }
public void makeDirty ( ) { betaChanged = BOOL_ ; newMode = BOOL_ ; precisionChanged = BOOL_ ; regressionInterface . makeDirty ( instance ) ; }
private ArrayList < E > toArrayList ( ) { ArrayList < E > list = new ArrayList < E > ( ) ; for ( Node < E > p = first ( ) ; p != null ; p = succ ( p ) ) { E item = p . item ; if ( item != null ) list . add ( item ) ; } return list ; }
public boolean remove ( HttpConnection connection ) { TimeValues times = connectionToTimes . remove ( connection ) ; if ( times == null ) { log . warn ( STR_ ) ; return BOOL_ ; } else { return System . currentTimeMillis ( ) <= times . timeExpires ; } }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( NUM_ ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return newVector . elements ( ) ; }
private List < String > split ( String prefix ) { List < String > parts = new ArrayList < String > ( ) ; int bracketCount = NUM_ ; boolean inquotes = BOOL_ ; int lastIndex = NUM_ ; for ( int i = NUM_ ; i < prefix . length ( ) ; i ++ ) { char c = prefix . charAt ( i ) ; if ( c == STR_ ) { bracketCount ++ ; continue ; } else if ( c == STR_ ) { inquotes = ! inquotes ; continue ; } else if ( c == STR_ ) { bracketCount -- ; if ( bracketCount < NUM_ ) { throw new RuntimeException ( STR_ + prefix ) ; } continue ; } if ( c == STR_ && ! inquotes && bracketCount == NUM_ ) { parts . add ( prefix . substring ( lastIndex , i ) ) ; lastIndex = i + NUM_ ; } } if ( lastIndex < prefix . length ( ) - NUM_ && ! inquotes && bracketCount == NUM_ ) { parts . add ( prefix . substring ( lastIndex ) ) ; } return parts ; }
public static long lowerHexToUnsignedLong ( String lowerHex ) { int length = lowerHex . length ( ) ; if ( length < NUM_ || length > NUM_ ) throw isntLowerHexLong ( lowerHex ) ; int i = length > NUM_ ? length - NUM_ : NUM_ ; long result = NUM_ ; for ( ; i < length ; i ++ ) { char c = lowerHex . charAt ( i ) ; result <<= NUM_ ; if ( c >= STR_ && c <= STR_ ) { result |= c - STR_ ; } else if ( c >= STR_ && c <= STR_ ) { result |= c - STR_ + NUM_ ; } else { throw isntLowerHexLong ( lowerHex ) ; } } return result ; }
public void load ( List < PolicyQualifierInfo > policyQualifierInfo ) { PolicyQualifierInfo [ ] policyQualifierInfoArray = policyQualifierInfo . toArray ( new PolicyQualifierInfo [ policyQualifierInfo . size ( ) ] ) ; Arrays . sort ( policyQualifierInfoArray , new PolicyQualifierInfoComparator ( ) ) ; data = new Object [ policyQualifierInfoArray . length ] [ NUM_ ] ; int i = NUM_ ; for ( PolicyQualifierInfo policyQualInfo : policyQualifierInfoArray ) { data [ i ] [ NUM_ ] = policyQualInfo ; i ++ ; } fireTableDataChanged ( ) ; }
public void runScript ( Reader reader ) throws IOException , SQLException { try { boolean originalAutoCommit = connection . getAutoCommit ( ) ; try { if ( originalAutoCommit != this . autoCommit ) { connection . setAutoCommit ( this . autoCommit ) ; } runScript ( connection , reader ) ; } finally { connection . setAutoCommit ( originalAutoCommit ) ; } } catch ( IOException | SQLException e ) { throw e ; } catch ( Exception e ) { throw new RuntimeException ( STR_ + e , e ) ; } }
public double doOperation ( ) throws OperatorFailedException { double logq ; final NodeRef root = tree . getRoot ( ) ; final double oldTreeHeight = tree . getNodeHeight ( root ) ; NodeRef i ; do { i = tree . getNode ( MathUtils . nextInt ( tree . getNodeCount ( ) ) ) ; } while ( root == i ) ; final NodeRef iP = tree . getParent ( i ) ; final NodeRef CiP = getOtherChild ( tree , iP , i ) ; final NodeRef PiP = tree . getParent ( iP ) ; final double delta = getDelta ( ) ; final double oldHeight = tree . getNodeHeight ( iP ) ; final double newHeight = oldHeight + delta ; if ( delta > NUM_ ) { if ( PiP != null && tree . getNodeHeight ( PiP ) < newHeight ) { NodeRef newParent = PiP ; NodeRef newChild = iP ; while ( tree . getNodeHeight ( newParent ) < newHeight ) { newChild = newParent ; newParent = tree . getParent ( newParent ) ; if ( newParent == null ) break ; } tree . beginTreeEdit ( ) ; if ( tree . isRoot ( newChild ) ) { tree . removeChild ( iP , CiP ) ; tree . removeChild ( PiP , iP ) ; tree . addChild ( iP , newChild ) ; tree . addChild ( PiP , CiP ) ; tree . setRoot ( iP ) ; if ( tree . hasNodeTraits ( ) ) { tree . swapAllTraits ( newChild , iP ) ; } if ( tree . hasRates ( ) ) { final double rootNodeRate = tree . getNodeRate ( newChild ) ; tree . setNodeRate ( newChild , tree . getNodeRate ( iP ) ) ; tree . setNodeRate ( iP , rootNodeRate ) ; } } else { tree . removeChild ( iP , CiP ) ; tree . removeChild ( PiP , iP ) ; tree . removeChild ( newParent , newChild ) ; tree . addChild ( iP , newChild ) ; tree . addChild ( PiP , CiP ) ; tree . addChild ( newParent , iP ) ; } tree . setNodeHeight ( iP , newHeight ) ; tree . endTreeEdit ( ) ; final int possibleSources = intersectingEdges ( tree , newChild , oldHeight , null ) ; logq = - Math . log ( possibleSources ) ; } else { tree . setNodeHeight ( iP , newHeight ) ; logq = NUM_ ; } } else { if ( tree . getNodeHeight ( i ) > newHeight ) { return Double . NEGATIVE_INFINITY ; } if ( tree . getNodeHeight ( CiP ) > newHeight ) { List < NodeRef > newChildren = new ArrayList < NodeRef > ( ) ; final int possibleDestinations = intersectingEdges ( tree , CiP , newHeight , newChildren ) ; if ( newChildren . size ( ) == NUM_ ) { return Double . NEGATIVE_INFINITY ; } final int childIndex = MathUtils . nextInt ( newChildren . size ( ) ) ; NodeRef newChild = newChildren . get ( childIndex ) ; NodeRef newParent = tree . getParent ( newChild ) ; tree . beginTreeEdit ( ) ; if ( tree . isRoot ( iP ) ) { tree . removeChild ( iP , CiP ) ; tree . removeChild ( newParent , newChild ) ; tree . addChild ( iP , newChild ) ; tree . addChild ( newParent , iP ) ; tree . setRoot ( CiP ) ; if ( tree . hasNodeTraits ( ) ) { tree . swapAllTraits ( iP , CiP ) ; } if ( tree . hasRates ( ) ) { final double rootNodeRate = tree . getNodeRate ( iP ) ; tree . setNodeRate ( iP , tree . getNodeRate ( CiP ) ) ; tree . setNodeRate ( CiP , rootNodeRate ) ; } } else { tree . removeChild ( iP , CiP ) ; tree . removeChild ( PiP , iP ) ; tree . removeChild ( newParent , newChild ) ; tree . addChild ( iP , newChild ) ; tree . addChild ( PiP , CiP ) ; tree . addChild ( newParent , iP ) ; } tree . setNodeHeight ( iP , newHeight ) ; tree . endTreeEdit ( ) ; logq = Math . log ( possibleDestinations ) ; } else { tree . setNodeHeight ( iP , newHeight ) ; logq = NUM_ ; } } if ( swapInRandomRate ) { final NodeRef j = tree . getNode ( MathUtils . nextInt ( tree . getNodeCount ( ) ) ) ; if ( j != i ) { final double tmp = tree . getNodeRate ( i ) ; tree . setNodeRate ( i , tree . getNodeRate ( j ) ) ; tree . setNodeRate ( j , tmp ) ; } } if ( swapInRandomTrait ) { final NodeRef j = tree . getNode ( MathUtils . nextInt ( tree . getNodeCount ( ) ) ) ; if ( j != i ) { tree . swapAllTraits ( i , j ) ; } } if ( logq == Double . NEGATIVE_INFINITY ) throw new OperatorFailedException ( STR_ ) ; if ( scaledDirichletBranches ) { if ( oldTreeHeight != tree . getNodeHeight ( tree . getRoot ( ) ) ) throw new OperatorFailedException ( STR_ ) ; } return logq ; }
MarkerSegment findMarkerSegment ( Class cls , boolean first ) { if ( first ) { Iterator iter = markerSequence . iterator ( ) ; while ( iter . hasNext ( ) ) { MarkerSegment seg = ( MarkerSegment ) iter . next ( ) ; if ( cls . isInstance ( seg ) ) { return seg ; } } } else { ListIterator iter = markerSequence . listIterator ( markerSequence . size ( ) ) ; while ( iter . hasPrevious ( ) ) { MarkerSegment seg = ( MarkerSegment ) iter . previous ( ) ; if ( cls . isInstance ( seg ) ) { return seg ; } } } return null ; }
default Filterable < T > removeAll ( final T ... values ) { return removeAll ( Stream . of ( values ) ) ; }
public static Map < String , Object > createContentAssocMethod ( DispatchContext dctx , Map < String , ? extends Object > rcontext ) throws GenericServiceException , GenericEntityException { Map < String , Object > context = UtilMisc . makeMapWritable ( rcontext ) ; List < String > targetOperationList = ContentWorker . prepTargetOperationList ( context , STR_ ) ; List < String > contentPurposeList = ContentWorker . prepContentPurposeList ( context ) ; context . put ( STR_ , targetOperationList ) ; context . put ( STR_ , contentPurposeList ) ; Locale locale = ( Locale ) context . get ( STR_ ) ; Delegator delegator = dctx . getDelegator ( ) ; LocalDispatcher dispatcher = dctx . getDispatcher ( ) ; Map < String , Object > result = FastMap . newInstance ( ) ; String contentIdFrom = ( String ) context . get ( STR_ ) ; String contentIdTo = ( String ) context . get ( STR_ ) ; String contentId = ( String ) context . get ( STR_ ) ; int contentIdCount = NUM_ ; if ( UtilValidate . isNotEmpty ( contentIdFrom ) ) contentIdCount ++ ; if ( UtilValidate . isNotEmpty ( contentIdTo ) ) contentIdCount ++ ; if ( UtilValidate . isNotEmpty ( contentId ) ) contentIdCount ++ ; if ( contentIdCount < NUM_ ) { Debug . logError ( STR_ , STR_ ) ; return ServiceUtil . returnError ( UtilProperties . getMessage ( resource , STR_ , locale ) ) ; } if ( UtilValidate . isNotEmpty ( contentIdFrom ) ) { if ( UtilValidate . isEmpty ( contentIdTo ) ) contentIdTo = contentId ; } if ( UtilValidate . isNotEmpty ( contentIdTo ) ) { if ( UtilValidate . isEmpty ( contentIdFrom ) ) contentIdFrom = contentId ; } GenericValue contentAssoc = delegator . makeValue ( STR_ , FastMap . newInstance ( ) ) ; contentAssoc . put ( STR_ , contentIdFrom ) ; contentAssoc . put ( STR_ , contentIdTo ) ; contentAssoc . put ( STR_ , context . get ( STR_ ) ) ; contentAssoc . put ( STR_ , context . get ( STR_ ) ) ; contentAssoc . put ( STR_ , context . get ( STR_ ) ) ; Timestamp fromDate = ( Timestamp ) context . get ( STR_ ) ; if ( fromDate == null ) { contentAssoc . put ( STR_ , UtilDateTime . nowTimestamp ( ) ) ; } else { contentAssoc . put ( STR_ , fromDate ) ; } Timestamp thruDate = ( Timestamp ) context . get ( STR_ ) ; if ( thruDate == null ) { contentAssoc . put ( STR_ , null ) ; } else { contentAssoc . put ( STR_ , thruDate ) ; } contentAssoc . put ( STR_ , context . get ( STR_ ) ) ; contentAssoc . put ( STR_ , context . get ( STR_ ) ) ; String upperCoordinateStr = ( String ) context . get ( STR_ ) ; if ( UtilValidate . isEmpty ( upperCoordinateStr ) ) { contentAssoc . put ( STR_ , null ) ; } else { contentAssoc . put ( STR_ , upperCoordinateStr ) ; } String leftCoordinateStr = ( String ) context . get ( STR_ ) ; if ( UtilValidate . isEmpty ( leftCoordinateStr ) ) { contentAssoc . put ( STR_ , null ) ; } else { contentAssoc . put ( STR_ , leftCoordinateStr ) ; } GenericValue userLogin = ( GenericValue ) context . get ( STR_ ) ; String userLoginId = ( String ) userLogin . get ( STR_ ) ; String createdByUserLogin = userLoginId ; String lastModifiedByUserLogin = userLoginId ; Timestamp createdDate = UtilDateTime . nowTimestamp ( ) ; Timestamp lastModifiedDate = UtilDateTime . nowTimestamp ( ) ; contentAssoc . put ( STR_ , createdByUserLogin ) ; contentAssoc . put ( STR_ , lastModifiedByUserLogin ) ; contentAssoc . put ( STR_ , createdDate ) ; contentAssoc . put ( STR_ , lastModifiedDate ) ; Map < String , Object > serviceInMap = FastMap . newInstance ( ) ; String permissionStatus = null ; serviceInMap . put ( STR_ , context . get ( STR_ ) ) ; serviceInMap . put ( STR_ , targetOperationList ) ; serviceInMap . put ( STR_ , contentPurposeList ) ; serviceInMap . put ( STR_ , context . get ( STR_ ) ) ; serviceInMap . put ( STR_ , context . get ( STR_ ) ) ; serviceInMap . put ( STR_ , contentIdTo ) ; serviceInMap . put ( STR_ , contentIdFrom ) ; serviceInMap . put ( STR_ , context . get ( STR_ ) ) ; serviceInMap . put ( STR_ , context . get ( STR_ ) ) ; serviceInMap . put ( STR_ , context . get ( STR_ ) ) ; serviceInMap . put ( STR_ , context . get ( STR_ ) ) ; Map < String , Object > permResults = null ; permResults = dispatcher . runSync ( STR_ , serviceInMap ) ; permissionStatus = ( String ) permResults . get ( STR_ ) ; if ( permissionStatus != null && permissionStatus . equals ( STR_ ) ) { contentAssoc . create ( ) ; } else { String errorMsg = ( String ) permResults . get ( ModelService . ERROR_MESSAGE ) ; result . put ( ModelService . ERROR_MESSAGE , errorMsg ) ; return ServiceUtil . returnFailure ( errorMsg ) ; } result . put ( STR_ , contentIdTo ) ; result . put ( STR_ , contentIdFrom ) ; result . put ( STR_ , contentAssoc . get ( STR_ ) ) ; result . put ( STR_ , contentAssoc . get ( STR_ ) ) ; return result ; }
public void reset ( boolean clear ) { gotVersion = BOOL_ ; gotHeaderLength = BOOL_ ; gotHeader = BOOL_ ; gotBody = BOOL_ ; gotBodyBoundary = BOOL_ ; headerLength = NUM_ ; bodyLength = NUM_ ; bodyBytesReceived = NUM_ ; if ( clear ) { bufferOffset = NUM_ ; buffer . clear ( ) ; bodyFile = null ; if ( bodyStream != null ) { try { bodyStream . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } bodyStream = null ; } } }
void removeAt ( final int removeIndex ) { final Object [ ] items = this . items ; if ( removeIndex == takeIndex ) { items [ takeIndex ] = null ; takeIndex = inc ( takeIndex ) ; count -- ; if ( itrs != null ) itrs . elementDequeued ( ) ; } else { final int putIndex = this . putIndex ; for ( int i = removeIndex ; ; ) { int next = inc ( i ) ; if ( next != putIndex ) { items [ i ] = items [ next ] ; i = next ; } else { items [ i ] = null ; this . putIndex = i ; break ; } } count -- ; if ( itrs != null ) itrs . removedAt ( removeIndex ) ; } notFull . signal ( ) ; }
private void saveAndClose ( boolean save ) { content . setEnabled ( BOOL_ ) ; if ( timer != null ) { timer . cancel ( ) ; timer = null ; } if ( timerNextSync != null ) { timerNextSync . cancel ( ) ; timerNextSync = null ; } if ( save ) { Log . d ( LOG_TAG , STR_ ) ; saveData ( null ) ; } else { Log . d ( LOG_TAG , STR_ ) ; } Intent data = new Intent ( ) ; data . setAction ( Intent . ACTION_VIEW ) ; data . putExtra ( PARAM_NOTE , note ) ; data . putExtra ( PARAM_NOTE_POSITION , notePosition ) ; setResult ( RESULT_OK , data ) ; finish ( ) ; }
public static Uri addMessage ( ContentResolver resolver , String address , String body , String subject , Long date , boolean deliveryReport , long threadId ) { final Uri CONTENT_URI = Uri . parse ( STR_ ) ; return addMessageToUri ( resolver , CONTENT_URI , address , body , subject , date , BOOL_ , deliveryReport , threadId ) ; }
public static < T > void blockingSubscribePrint ( Observable < T > observable , String name ) { CountDownLatch latch = new CountDownLatch ( NUM_ ) ; subscribePrint ( observable . finallyDo ( null ) , name ) ; try { latch . await ( ) ; } catch ( InterruptedException e ) { } }
public static final double calcNiceNumber ( final double RANGE , final boolean ROUND ) { double niceFraction ; double exponent = Math . floor ( Math . log10 ( RANGE ) ) ; double fraction = RANGE / Math . pow ( NUM_ , exponent ) ; if ( ROUND ) { if ( Double . compare ( fraction , NUM_ ) < NUM_ ) { niceFraction = NUM_ ; } else if ( Double . compare ( fraction , NUM_ ) < NUM_ ) { niceFraction = NUM_ ; } else if ( Double . compare ( fraction , NUM_ ) < NUM_ ) { niceFraction = NUM_ ; } else { niceFraction = NUM_ ; } } else { if ( Double . compare ( fraction , NUM_ ) <= NUM_ ) { niceFraction = NUM_ ; } else if ( Double . compare ( fraction , NUM_ ) <= NUM_ ) { niceFraction = NUM_ ; } else if ( Double . compare ( fraction , NUM_ ) <= NUM_ ) { niceFraction = NUM_ ; } else { niceFraction = NUM_ ; } } return niceFraction . Math . pow ( NUM_ , exponent ) ; }
private final Object internalReplace ( Object k , Object v , Object cv ) { int h = spread ( k . hashCode ( ) ) ; Object oldVal = null ; for ( Node [ ] tab = table ; ; ) { Node f ; int i , fh ; Object fk ; if ( tab == null || ( f = tabAt ( tab , i = ( tab . length - NUM_ ) & h ) ) == null ) break ; else if ( ( fh = f . hash ) == MOVED ) { if ( ( fk = f . key ) instanceof TreeBin ) { TreeBin t = ( TreeBin ) fk ; boolean validated = BOOL_ ; boolean deleted = BOOL_ ; t . acquire ( NUM_ ) ; try { if ( tabAt ( tab , i ) == f ) { validated = BOOL_ ; TreeNode p = t . getTreeNode ( h , k , t . root ) ; if ( p != null ) { Object pv = p . val ; if ( cv == null || cv == pv || cv . equals ( pv ) ) { oldVal = pv ; if ( ( p . val = v ) == null ) { deleted = BOOL_ ; t . deleteTreeNode ( p ) ; } } } } } finally { t . release ( NUM_ ) ; } if ( validated ) { if ( deleted ) counter . add ( - NUM_ ) ; break ; } } else tab = ( Node [ ] ) fk ; } else if ( ( fh & HASH_BITS ) != h && f . next == null ) break ; else if ( ( fh & LOCKED ) != NUM_ ) { checkForResize ( ) ; f . tryAwaitLock ( tab , i ) ; } else if ( f . casHash ( fh , fh | LOCKED ) ) { boolean validated = BOOL_ ; boolean deleted = BOOL_ ; try { if ( tabAt ( tab , i ) == f ) { validated = BOOL_ ; for ( Node e = f , pred = null ; ; ) { Object ek , ev ; if ( ( e . hash & HASH_BITS ) == h && ( ( ev = e . val ) != null ) && ( ( ek = e . key ) == k || k . equals ( ek ) ) ) { if ( cv == null || cv == ev || cv . equals ( ev ) ) { oldVal = ev ; if ( ( e . val = v ) == null ) { deleted = BOOL_ ; Node en = e . next ; if ( pred != null ) pred . next = en ; else setTabAt ( tab , i , en ) ; } } break ; } pred = e ; if ( ( e = e . next ) == null ) break ; } } } finally { if ( ! f . casHash ( fh | LOCKED , fh ) ) { f . hash = fh ; synchronized ( f ) { f . notifyAll ( ) ; } ; } } if ( validated ) { if ( deleted ) counter . add ( - NUM_ ) ; break ; } } } return oldVal ; }
private static final boolean copyHeader ( String name , String fromReq , StringBuffer buf ) { int start = fromReq . indexOf ( name ) ; if ( start != - NUM_ ) { int end = fromReq . indexOf ( STR_ , start ) ; if ( end != - NUM_ ) { buf . append ( fromReq . subSequence ( start - NUM_ , end ) ) ; return BOOL_ ; } } return BOOL_ ; }
public void sendMetric ( final String name , final double value ) { logger . debug ( String . format ( STR_ , name , value ) ) ; if ( telemetryClient != null ) { telemetryClient . trackMetric ( name , value ) ; } }
default Document putAll ( Iterable < Field > fields , Predicate < CharSequence > acceptableFieldNames ) { for ( Field field : fields ) { if ( acceptableFieldNames . test ( field . getName ( ) ) ) { setValue ( field . getName ( ) , field . getValue ( ) ) ; } } return this ; }
public static URL findResourceBase ( String baseResource , ClassLoader loader ) { URL url = loader . getResource ( baseResource ) ; return findResourceBase ( url , baseResource ) ; }
public String toEPL ( EPStatementFormatter formatter ) { StringWriter writer = new StringWriter ( ) ; toEPL ( formatter , writer ) ; return writer . toString ( ) ; }
public boolean isSpecified ( int index ) { if ( ( index < NUM_ ) || ( index >= mLength ) ) { throw new ArrayIndexOutOfBoundsException ( STR_ ) ; } String str = mItems [ ( index << NUM_ ) + NUM_ ] ; return ( ( str != null ) ? ( str . charAt ( NUM_ ) == STR_ ) : BOOL_ ) ; }
public StatArchiveReader ( String archiveName ) throws IOException { this ( new File [ ] { new File ( archiveName ) } , null , BOOL_ ) ; }
private static void initAdbSocketAddr ( ) { try { sAdbServerPort = getAdbServerPort ( ) ; InetAddress hostAddr = InetAddress . getByName ( DEFAULT_ADB_HOST ) ; sSocketAddr = new InetSocketAddress ( hostAddr , sAdbServerPort ) ; } catch ( UnknownHostException e ) { } }
public int read ( long fileOffset , byte [ ] buffer , int offset , int length ) throws IOException { _file . seek ( fileOffset ) ; return _file . read ( buffer , offset , length ) ; }
private boolean matchesAnyTag ( String tagName ) { return tagNames . contains ( tagName ) ; }
default void shutdown ( ) { Platform . exit ( ) ; }
public boolean isExpanded ( int row ) { TreeUI tree = getUI ( ) ; if ( tree != null ) { TreePath path = tree . getPathForRow ( this , row ) ; if ( path != null ) { Boolean value = expandedState . get ( path ) ; return ( value != null && value . booleanValue ( ) ) ; } } return BOOL_ ; }
private static int labelEnd ( String s ) { int colonIndex = s . indexOf ( STR_ ) ; int semicolonIndex = s . indexOf ( STR_ ) ; if ( ( semicolonIndex == - NUM_ ) || ( colonIndex < semicolonIndex ) ) { return colonIndex ; } else { return - NUM_ ; } }
public void addListener ( AnimatorListener listener ) { if ( mListeners == null ) { mListeners = new ArrayList < AnimatorListener > ( ) ; } mListeners . add ( listener ) ; }
public HttpMethodInfo ( Method method , Object handler , Object [ ] args , MultivaluedMap < String , Object > formParameters , Response responder ) { this . method = method ; this . handler = handler ; this . args = Arrays . copyOf ( args , args . length ) ; this . formParameters = formParameters ; this . responder = responder ; }
public static boolean equals ( byte [ ] [ ] field1 , byte [ ] [ ] field2 ) { int index1 = NUM_ ; int length1 = field1 == null ? NUM_ : field1 . length ; int index2 = NUM_ ; int length2 = field2 == null ? NUM_ : field2 . length ; while ( BOOL_ ) { while ( index1 < length1 && field1 [ index1 ] == null ) { index1 ++ ; } while ( index2 < length2 && field2 [ index2 ] == null ) { index2 ++ ; } boolean atEndOf1 = index1 >= length1 ; boolean atEndOf2 = index2 >= length2 ; if ( atEndOf1 && atEndOf2 ) { return BOOL_ ; } else if ( atEndOf1 != atEndOf2 ) { return BOOL_ ; } else if ( ! Arrays . equals ( field1 [ index1 ] , field2 [ index2 ] ) ) { return BOOL_ ; } index1 ++ ; index2 ++ ; } }
private void drawText ( int x1 , int y1 , int s , boolean e_or_n , Graphics g ) { Color oldColor = g . getColor ( ) ; g . setPaintMode ( ) ; if ( m_FontColor == null ) { g . setColor ( Color . black ) ; } else { g . setColor ( m_FontColor ) ; } String st ; if ( e_or_n ) { Edge e = m_edges [ s ] . m_edge ; for ( int noa = NUM_ ; ( st = e . getLine ( noa ) ) != null ; noa ++ ) { g . drawString ( st , ( m_edges [ s ] . m_width - m_fontSize . stringWidth ( st ) ) / NUM_ + x1 , y1 + ( noa + NUM_ ) . m_fontSize . getHeight ( ) ) ; } } else { Node e = m_nodes [ s ] . m_node ; for ( int noa = NUM_ ; ( st = e . getLine ( noa ) ) != null ; noa ++ ) { g . drawString ( st , ( m_nodes [ s ] . m_width - m_fontSize . stringWidth ( st ) ) / NUM_ + x1 , y1 + ( noa + NUM_ ) . m_fontSize . getHeight ( ) ) ; } } g . setColor ( oldColor ) ; }
public void update ( List < Race > races ) { if ( currentRace == null ) { return ; } if ( races . contains ( currentRace ) ) { setRace ( races . get ( races . indexOf ( currentRace ) ) ) ; } }
public boolean required ( ) { return _parameterMetadata . contains ( Metadata . REQUIRED ) ; }
protected void sendDataToReceiver ( ResultReceiver receiver , Intent originalIntent , Serializable data ) { if ( receiver != null && data != null ) { Bundle bundle = new Bundle ( ) ; bundle . putParcelable ( ServiceReceiver . EXTRA_ORIGINAL_INTENT , originalIntent ) ; bundle . putSerializable ( ServiceReceiver . EXTRA_DATA , data ) ; receiver . send ( ServiceReceiver . STATUS_DATA , bundle ) ; } }
private static Object matchOrReplace ( Context cx , Scriptable scope , Scriptable thisObj , Object [ ] args , RegExpImpl reImpl , GlobData data , boolean forceFlat ) { NativeRegExp re ; String str = ScriptRuntime . toString ( thisObj ) ; data . str = str ; Scriptable topScope = ScriptableObject . getTopLevelScope ( scope ) ; if ( args . length == NUM_ ) { Object compiled = NativeRegExp . compileRE ( cx , STR_ , STR_ , BOOL_ ) ; re = new NativeRegExp ( topScope , compiled ) ; } else if ( args [ NUM_ ] instanceof NativeRegExp ) { re = ( NativeRegExp ) args [ NUM_ ] ; } else { String src = ScriptRuntime . toString ( args [ NUM_ ] ) ; String opt ; if ( data . optarg < args . length ) { args [ NUM_ ] = src ; opt = ScriptRuntime . toString ( args [ data . optarg ] ) ; } else { opt = null ; } Object compiled = NativeRegExp . compileRE ( cx , src , opt , forceFlat ) ; re = new NativeRegExp ( topScope , compiled ) ; } data . global = ( re . getFlags ( ) & NativeRegExp . JSREG_GLOB ) != NUM_ ; int [ ] indexp = { NUM_ } ; Object result = null ; if ( data . mode == RA_SEARCH ) { result = re . executeRegExp ( cx , scope , reImpl , str , indexp , NativeRegExp . TEST ) ; if ( result != null && result . equals ( Boolean . TRUE ) ) result = Integer . valueOf ( reImpl . leftContext . length ) ; else result = Integer . valueOf ( - NUM_ ) ; } else if ( data . global ) { re . lastIndex = NUM_ ; for ( int count = NUM_ ; indexp [ NUM_ ] <= str . length ( ) ; count ++ ) { result = re . executeRegExp ( cx , scope , reImpl , str , indexp , NativeRegExp . TEST ) ; if ( result == null || ! result . equals ( Boolean . TRUE ) ) break ; if ( data . mode == RA_MATCH ) { match_glob ( data , cx , scope , count , reImpl ) ; } else { if ( data . mode != RA_REPLACE ) Kit . codeBug ( ) ; SubString lastMatch = reImpl . lastMatch ; int leftIndex = data . leftIndex ; int leftlen = lastMatch . index - leftIndex ; data . leftIndex = lastMatch . index + lastMatch . length ; replace_glob ( data , cx , scope , reImpl , leftIndex , leftlen ) ; } if ( reImpl . lastMatch . length == NUM_ ) { if ( indexp [ NUM_ ] == str . length ( ) ) break ; indexp [ NUM_ ] ++ ; } } } else { result = re . executeRegExp ( cx , scope , reImpl , str , indexp , ( ( data . mode == RA_REPLACE ) ? NativeRegExp . TEST : NativeRegExp . MATCH ) ) ; } return result ; }
public void tableSwitch ( final int [ ] keys , final TableSwitchGenerator generator , final boolean useTable ) { for ( int i = NUM_ ; i < keys . length ; ++ i ) { if ( keys [ i ] < keys [ i - NUM_ ] ) { throw new IllegalArgumentException ( STR_ ) ; } } Label def = newLabel ( ) ; Label end = newLabel ( ) ; if ( keys . length > NUM_ ) { int len = keys . length ; int min = keys [ NUM_ ] ; int max = keys [ len - NUM_ ] ; int range = max - min + NUM_ ; if ( useTable ) { Label [ ] labels = new Label [ range ] ; Arrays . fill ( labels , def ) ; for ( int i = NUM_ ; i < len ; ++ i ) { labels [ keys [ i ] - min ] = newLabel ( ) ; } mv . visitTableSwitchInsn ( min , max , def , labels ) ; for ( int i = NUM_ ; i < range ; ++ i ) { Label label = labels [ i ] ; if ( label != def ) { mark ( label ) ; generator . generateCase ( i + min , end ) ; } } } else { Label [ ] labels = new Label [ len ] ; for ( int i = NUM_ ; i < len ; ++ i ) { labels [ i ] = newLabel ( ) ; } mv . visitLookupSwitchInsn ( def , keys , labels ) ; for ( int i = NUM_ ; i < len ; ++ i ) { mark ( labels [ i ] ) ; generator . generateCase ( keys [ i ] , end ) ; } } } mark ( def ) ; generator . generateDefault ( ) ; mark ( end ) ; }
public void print ( PrintWriter output , int w , int d ) { DecimalFormat format = new DecimalFormat ( ) ; format . setDecimalFormatSymbols ( new DecimalFormatSymbols ( Locale . US ) ) ; format . setMinimumIntegerDigits ( NUM_ ) ; format . setMaximumFractionDigits ( d ) ; format . setMinimumFractionDigits ( d ) ; format . setGroupingUsed ( BOOL_ ) ; print ( output , format , w + NUM_ ) ; }
public static < E > Set < E > newSetFromMap ( Map < E , Boolean > map ) { if ( map . isEmpty ( ) ) { return new SetFromMap < E > ( map ) ; } throw new IllegalArgumentException ( ) ; }
public void removeBiomeType ( BiomeDictionary . Type type ) { ArrayList < BiomeGenBase > entryList = new ArrayList < BiomeGenBase > ( ) ; entryList . addAll ( Arrays . asList ( BiomeDictionary . getBiomesForType ( type ) ) ) ; for ( BiomeGenBase biome : entryList ) { Iterator < BiomeEntry > iterator = allowedBiomes . iterator ( ) ; while ( iterator . hasNext ( ) ) { if ( BiomeDictionary . areBiomesEquivalent ( iterator . next ( ) . biome , biome ) ) iterator . remove ( ) ; } } }
static SizeRequirements calculateTiledRequirements ( LayoutIterator iter , SizeRequirements r ) { long minimum = NUM_ ; long maximum = NUM_ ; long preferred = NUM_ ; int lastMargin = NUM_ ; int totalSpacing = NUM_ ; int n = iter . getCount ( ) ; for ( int i = NUM_ ; i < n ; i ++ ) { iter . setIndex ( i ) ; int margin0 = lastMargin ; int margin1 = ( int ) iter . getLeadingCollapseSpan ( ) ; totalSpacing += Math . max ( margin0 , margin1 ) ; preferred += ( int ) iter . getPreferredSpan ( NUM_ ) ; minimum += iter . getMinimumSpan ( NUM_ ) ; maximum += iter . getMaximumSpan ( NUM_ ) ; lastMargin = ( int ) iter . getTrailingCollapseSpan ( ) ; } totalSpacing += lastMargin ; totalSpacing += NUM_ . iter . getBorderWidth ( ) ; minimum += totalSpacing ; preferred += totalSpacing ; maximum += totalSpacing ; if ( r == null ) { r = new SizeRequirements ( ) ; } r . minimum = ( minimum > Integer . MAX_VALUE ) ? Integer . MAX_VALUE : ( int ) minimum ; r . preferred = ( preferred > Integer . MAX_VALUE ) ? Integer . MAX_VALUE : ( int ) preferred ; r . maximum = ( maximum > Integer . MAX_VALUE ) ? Integer . MAX_VALUE : ( int ) maximum ; return r ; }
public static void writePaddedInteger ( Writer out , long value , int size ) throws IOException { int intValue = ( int ) value ; if ( intValue == value ) { writePaddedInteger ( out , intValue , size ) ; } else if ( size <= NUM_ ) { out . write ( Long . toString ( value ) ) ; } else { if ( value < NUM_ ) { out . write ( STR_ ) ; if ( value != Long . MIN_VALUE ) { value = - value ; } else { for ( ; size > NUM_ ; size -- ) { out . write ( STR_ ) ; } out . write ( STR_ ) ; return ; } } int digits = ( int ) ( Math . log ( value ) / LOG_10 ) + NUM_ ; for ( ; size > digits ; size -- ) { out . write ( STR_ ) ; } out . write ( Long . toString ( value ) ) ; } }
private static LDAPFilter createORFilter ( FilterSet filterSet ) throws LDAPException , IOException { List < JAXBElement < ? > > list = filterSet . getFilterGroup ( ) ; ArrayList < RawFilter > filters = new ArrayList < > ( list . size ( ) ) ; for ( JAXBElement < ? > filter : list ) { filters . add ( createFilter ( filter ) ) ; } return LDAPFilter . createORFilter ( filters ) ; }
private void sendBlob ( String index , byte [ ] blob ) { sendInstruction ( new GuacamoleInstruction ( STR_ , index , DatatypeConverter . printBase64Binary ( blob ) ) ) ; }
protected void defineLabels ( ) { labelsValues = calcLabels ( ) ; if ( handleValues ) labels = getLabelsFromValues ( ) ; else labels = getLabelsFromData ( ) ; nLabels = labels . size ( ) ; }
public static Set < Interval > mergeIntervalToSet ( Set < Interval > intervals , Interval intervalToMerge ) { LinkedHashSet < Interval > copyOfOriginalSet = new LinkedHashSet < > ( intervals ) ; copyOfOriginalSet . add ( intervalToMerge ) ; return mergeIntervalSet ( copyOfOriginalSet ) ; }
public static String dropWhile ( GString self , @ ClosureParams ( value = FromString . class , conflictResolutionStrategy = PickFirstResolver . class , options = { STR_ , STR_ } ) Closure condition ) { return dropWhile ( self . toString ( ) , condition ) ; }
public void addNode ( TopologicalNode node ) { nodeList . add ( node ) ; }
public void printText ( String text ) { view . print ( text , text . endsWith ( STR_ ) ) ; for ( ActionDelegate actionDelegate : actionDelegates ) { actionDelegate . onConsoleOutput ( this ) ; } }
@ Override public void trim ( ) { if ( counter < x . length ) { int [ ] y = new int [ counter ] ; System . arraycopy ( x , NUM_ , y , NUM_ , counter ) ; x = y ; resizeValues ( counter ) ; } }
private void divide ( int [ ] idx , double [ ] data , ArrayList < int [ ] > ret , int start , int end , int depth ) { if ( depth == NUM_ ) { int [ ] a = Arrays . copyOfRange ( idx , start , end ) ; Arrays . sort ( a ) ; ret . add ( a ) ; return ; } final int count = end - start ; if ( count == NUM_ ) { for ( int j = NUM_ << depth ; j > NUM_ ; -- j ) { ret . add ( new int [ NUM_ ] ) ; } return ; } double m = NUM_ ; for ( int i = start ; i < end ; i ++ ) { m += data [ i ] ; } m /= count ; int pos = Arrays . binarySearch ( data , start , end , m ) ; if ( pos >= NUM_ ) { final int opt = ( start + end ) > > NUM_ ; while ( data [ pos ] == m ) { if ( pos < opt ) { pos ++ ; } else if ( pos > opt ) { pos -- ; } else { break ; } } } else { pos = ( - pos - NUM_ ) ; } divide ( idx , data , ret , start , pos , depth - NUM_ ) ; divide ( idx , data , ret , pos , end , depth - NUM_ ) ; }
void assertThreadsStayAlive ( long millis , Thread ... threads ) { try { delay ( millis ) ; for ( Thread thread : threads ) assertTrue ( thread . isAlive ( ) ) ; } catch ( InterruptedException fail ) { threadFail ( STR_ ) ; } }
public AbstractWorkerManager ( String id ) { _id = id ; _status = new WorkerManagerStatus ( ) ; setExecutionMode ( EXECUTION_MODE . NON_SERIAL ) ; setupExecutor ( ) ; }
@ OnMessage public void onMessage ( String message , Session session ) { callInternal ( STR_ , session , message ) ; }
public final boolean insert_via ( BrdViaInfo p_via_info , PlaPointInt p_location , NetNosList p_net_no_arr , int p_trace_clearance_class_no , int [ ] p_trace_pen_halfwidth_arr , int p_max_recursion_depth , int p_max_via_recursion_depth , int p_pull_tight_accuracy , int p_pull_tight_time_limit ) { shove_fail_clear ( ) ; changed_area_clear ( ) ; boolean r_ok = shove_via_algo . shove_via_insert ( p_via_info , p_location , p_net_no_arr , p_trace_clearance_class_no , p_trace_pen_halfwidth_arr , p_max_recursion_depth , p_max_via_recursion_depth ) ; if ( ! r_ok ) return BOOL_ ; NetNosList opt_net_no_arr = p_max_recursion_depth <= NUM_ ? p_net_no_arr : NetNosList . EMPTY ; TimeLimitStoppable t_limit = new TimeLimitStoppable ( s_PREVENT_ENDLESS_LOOP ) ; changed_area_optimize ( opt_net_no_arr , p_pull_tight_accuracy , null , t_limit , null ) ; return BOOL_ ; }
boolean thresholdExceeded ( final Set < IBindingSet > distinctProjectionBuffer , final int distinctProjectionBufferThreshold , final List < IBindingSet > incomingBindingsBuffer , final int incomingBindingsBufferThreshold ) { return distinctProjectionBuffer . size ( ) >= distinctProjectionBufferThreshold || incomingBindingsBuffer . size ( ) >= incomingBindingsBufferThreshold ; }
public static byte [ ] toByteArray ( String str ) { int len = str . length ( ) ; StringTokenizer st = new StringTokenizer ( str , STR_ ) ; String [ ] newStrArray = new String [ st . countTokens ( ) ] ; int j = NUM_ ; while ( st . hasMoreTokens ( ) ) { newStrArray [ j ] = st . nextToken ( ) ; j ++ ; } byte [ ] ret = new byte [ newStrArray . length ] ; int tmp ; for ( int i = NUM_ ; i < newStrArray . length ; i ++ ) { tmp = Integer . parseInt ( newStrArray [ i ] , NUM_ ) ; ret [ i ] = ( byte ) ( tmp - NUM_ ) ; } return ret ; }
public static boolean nullEquals ( String s1 , String s2 ) { return ( s1 == null ? s2 == null : s1 . equals ( s2 ) ) ; }
private char [ ] fFormatDigits ( final double x ) { String sx ; int i , j , k ; final int n1In ; final int n2In ; int expon = NUM_ ; boolean minusSign = BOOL_ ; if ( x > NUM_ ) { sx = Double . toString ( x ) ; } else if ( x < NUM_ ) { sx = Double . toString ( - x ) ; minusSign = BOOL_ ; } else { sx = Double . toString ( x ) ; if ( sx . charAt ( NUM_ ) == STR_ ) { minusSign = BOOL_ ; sx = sx . substring ( NUM_ ) ; } } final int ePos = sx . indexOf ( STR_ ) ; final int rPos = sx . indexOf ( STR_ ) ; if ( rPos != - NUM_ ) { n1In = rPos ; } else if ( ePos != - NUM_ ) { n1In = ePos ; } else { n1In = sx . length ( ) ; } if ( rPos != - NUM_ ) { if ( ePos != - NUM_ ) { n2In = ePos - rPos - NUM_ ; } else { n2In = sx . length ( ) - rPos - NUM_ ; } } else { n2In = NUM_ ; } if ( ePos != - NUM_ ) { int ie = ePos + NUM_ ; expon = NUM_ ; if ( sx . charAt ( ie ) == STR_ ) { for ( ++ ie ; ie < sx . length ( ) ; ie ++ ) { if ( sx . charAt ( ie ) != STR_ ) { break ; } } if ( ie < sx . length ( ) ) { expon = - Integer . parseInt ( sx . substring ( ie ) ) ; } } else { if ( sx . charAt ( ie ) == STR_ ) { ++ ie ; } for ( ; ie < sx . length ( ) ; ie ++ ) { if ( sx . charAt ( ie ) != STR_ ) { break ; } } if ( ie < sx . length ( ) ) { expon = Integer . parseInt ( sx . substring ( ie ) ) ; } } } final int p ; if ( precisionSet ) { p = precision ; } else { p = defaultDigits - NUM_ ; } final char [ ] ca1 = sx . toCharArray ( ) ; final char [ ] ca2 = new char [ n1In + n2In ] ; final char [ ] ca3 ; final char [ ] ca4 ; final char [ ] ca5 ; for ( j = NUM_ ; j < n1In ; j ++ ) { ca2 [ j ] = ca1 [ j ] ; } i = j + NUM_ ; for ( k = NUM_ ; k < n2In ; j ++ , i ++ , k ++ ) { ca2 [ j ] = ca1 [ i ] ; } if ( n1In + expon <= NUM_ ) { ca3 = new char [ - expon + n2In ] ; for ( j = NUM_ , k = NUM_ ; k < ( - n1In - expon ) ; k ++ , j ++ ) { ca3 [ j ] = STR_ ; } for ( i = NUM_ ; i < ( n1In + n2In ) ; i ++ , j ++ ) { ca3 [ j ] = ca2 [ i ] ; } } else { ca3 = ca2 ; } boolean carry = BOOL_ ; if ( p < - expon + n2In ) { if ( expon < NUM_ ) { i = p ; } else { i = p + n1In ; } carry = checkForCarry ( ca3 , i ) ; if ( carry ) { carry = startSymbolicCarry ( ca3 , i - NUM_ , NUM_ ) ; } } if ( n1In + expon <= NUM_ ) { ca4 = new char [ NUM_ + p ] ; if ( ! carry ) { ca4 [ NUM_ ] = STR_ ; } else { ca4 [ NUM_ ] = STR_ ; } if ( alternateForm || ! precisionSet || precision != NUM_ ) { ca4 [ NUM_ ] = STR_ ; for ( i = NUM_ , j = NUM_ ; i < Math . min ( p , ca3 . length ) ; i ++ , j ++ ) { ca4 [ j ] = ca3 [ i ] ; } for ( ; j < ca4 . length ; j ++ ) { ca4 [ j ] = STR_ ; } } } else { if ( ! carry ) { if ( alternateForm || ! precisionSet || precision != NUM_ ) { ca4 = new char [ n1In + expon + p + NUM_ ] ; } else { ca4 = new char [ n1In + expon ] ; } j = NUM_ ; } else { if ( alternateForm || ! precisionSet || precision != NUM_ ) { ca4 = new char [ n1In + expon + p + NUM_ ] ; } else { ca4 = new char [ n1In + expon + NUM_ ] ; } ca4 [ NUM_ ] = STR_ ; j = NUM_ ; } for ( i = NUM_ ; i < Math . min ( n1In + expon , ca3 . length ) ; i ++ , j ++ ) { ca4 [ j ] = ca3 [ i ] ; } for ( ; i < n1In + expon ; i ++ , j ++ ) { ca4 [ j ] = STR_ ; } if ( alternateForm || ! precisionSet || precision != NUM_ ) { ca4 [ j ] = STR_ ; j ++ ; for ( k = NUM_ ; i < ca3 . length && k < p ; i ++ , j ++ , k ++ ) { ca4 [ j ] = ca3 [ i ] ; } for ( ; j < ca4 . length ; j ++ ) { ca4 [ j ] = STR_ ; } } } int nZeros = NUM_ ; if ( ! leftJustify && leadingZeros ) { int xThousands = NUM_ ; if ( thousands ) { int xlead = NUM_ ; if ( ca4 [ NUM_ ] == STR_ || ca4 [ NUM_ ] == STR_ || ca4 [ NUM_ ] == STR_ ) { xlead = NUM_ ; } int xdp = xlead ; for ( ; xdp < ca4 . length ; xdp ++ ) { if ( ca4 [ xdp ] == STR_ ) { break ; } } xThousands = ( xdp - xlead ) / NUM_ ; } if ( fieldWidthSet ) { nZeros = fieldWidth - ca4 . length ; } if ( ( ! minusSign && ( leadingSign || leadingSpace ) ) || minusSign ) { nZeros -- ; } nZeros -= xThousands ; if ( nZeros < NUM_ ) { nZeros = NUM_ ; } } j = NUM_ ; if ( ( ! minusSign && ( leadingSign || leadingSpace ) ) || minusSign ) { ca5 = new char [ ca4 . length + nZeros + NUM_ ] ; j ++ ; } else { ca5 = new char [ ca4 . length + nZeros ] ; } if ( ! minusSign ) { if ( leadingSign ) { ca5 [ NUM_ ] = STR_ ; } if ( leadingSpace ) { ca5 [ NUM_ ] = STR_ ; } } else { ca5 [ NUM_ ] = STR_ ; } for ( i = NUM_ ; i < nZeros ; i ++ , j ++ ) { ca5 [ j ] = STR_ ; } for ( i = NUM_ ; i < ca4 . length ; i ++ , j ++ ) { ca5 [ j ] = ca4 [ i ] ; } int lead = NUM_ ; if ( ca5 [ NUM_ ] == STR_ || ca5 [ NUM_ ] == STR_ || ca5 [ NUM_ ] == STR_ ) { lead = NUM_ ; } int dp = lead ; for ( ; dp < ca5 . length ; dp ++ ) { if ( ca5 [ dp ] == STR_ ) { break ; } } final int nThousands = ( dp - lead ) / NUM_ ; if ( dp < ca5 . length ) { ca5 [ dp ] = dfs . getDecimalSeparator ( ) ; } char [ ] ca6 = ca5 ; if ( thousands && nThousands > NUM_ ) { ca6 = new char [ ca5 . length + nThousands + lead ] ; ca6 [ NUM_ ] = ca5 [ NUM_ ] ; for ( i = lead , k = lead ; i < dp ; i ++ ) { if ( i > NUM_ && ( dp - i ) % NUM_ == NUM_ ) { ca6 [ k ] = dfs . getGroupingSeparator ( ) ; ca6 [ k + NUM_ ] = ca5 [ i ] ; k += NUM_ ; } else { ca6 [ k ] = ca5 [ i ] ; k ++ ; } } for ( ; i < ca5 . length ; i ++ , k ++ ) { ca6 [ k ] = ca5 [ i ] ; } } return ca6 ; }
int maxLength ( ) { FontMetrics fm = getFontMetrics ( getFont ( ) ) ; int m = NUM_ ; int end = items . size ( ) ; for ( int i = NUM_ ; i < end ; i ++ ) { int l = fm . stringWidth ( ( ( String ) items . elementAt ( i ) ) ) ; m = Math . max ( m , l ) ; } return m ; }
public void write ( final char chars [ ] , final int start , final int length ) throws java . io . IOException { if ( m_writer != null ) m_writer . write ( chars , start , length ) ; int lengthx3 = ( length << NUM_ ) + length ; if ( lengthx3 >= buf_length ) { flushBuffer ( ) ; setBufferSize ( NUM_ . lengthx3 ) ; } if ( lengthx3 > buf_length - count ) { flushBuffer ( ) ; } final int n = length + start ; for ( int i = start ; i < n ; i ++ ) { final char c = chars [ i ] ; if ( c < x80 ) buf [ count ++ ] = ( byte ) ( c ) ; else if ( c < x800 ) { buf [ count ++ ] = ( byte ) ( xc0 + ( c > > NUM_ ) ) ; buf [ count ++ ] = ( byte ) ( x80 + ( c & x3f ) ) ; } else { buf [ count ++ ] = ( byte ) ( xe0 + ( c > > NUM_ ) ) ; buf [ count ++ ] = ( byte ) ( x80 + ( ( c > > NUM_ ) & x3f ) ) ; buf [ count ++ ] = ( byte ) ( x80 + ( c & x3f ) ) ; } } }
public PlaPointInt round_to_the_left ( PlaDirection p_dir ) { PlaPointFloat dir = p_dir . to_float ( ) ; double rounded_x ; if ( dir . v_y > NUM_ ) { rounded_x = Math . floor ( v_x ) ; } else if ( dir . v_y < NUM_ ) { rounded_x = Math . ceil ( v_x ) ; } else { rounded_x = Math . round ( v_x ) ; } double rounded_y ; if ( dir . v_x > NUM_ ) { rounded_y = Math . ceil ( v_y ) ; } else if ( dir . v_x < NUM_ ) { rounded_y = Math . floor ( v_y ) ; } else { rounded_y = Math . round ( v_y ) ; } return new PlaPointInt ( rounded_x , rounded_y ) ; }
protected HttpHost determineProxy ( HttpHost target , HttpRequest request , HttpContext context ) throws HttpException { ProxySelector psel = this . proxySelector ; if ( psel == null ) psel = ProxySelector . getDefault ( ) ; if ( psel == null ) return null ; URI targetURI = null ; try { targetURI = new URI ( target . toURI ( ) ) ; } catch ( URISyntaxException usx ) { throw new HttpException ( STR_ + target , usx ) ; } List < Proxy > proxies = psel . select ( targetURI ) ; Proxy p = chooseProxy ( proxies , target , request , context ) ; HttpHost result = null ; if ( p . type ( ) == Proxy . Type . HTTP ) { if ( ! ( p . address ( ) instanceof InetSocketAddress ) ) { throw new HttpException ( STR_ + p . address ( ) ) ; } final InetSocketAddress isa = ( InetSocketAddress ) p . address ( ) ; result = new HttpHost ( getHost ( isa ) , isa . getPort ( ) ) ; } return result ; }
private void addReference ( final int sourcePosition , final int referencePosition ) { if ( srcAndRefPositions == null ) { srcAndRefPositions = new int [ NUM_ ] ; } if ( referenceCount >= srcAndRefPositions . length ) { int [ ] a = new int [ srcAndRefPositions . length + NUM_ ] ; System . arraycopy ( srcAndRefPositions , NUM_ , a , NUM_ , srcAndRefPositions . length ) ; srcAndRefPositions = a ; } srcAndRefPositions [ referenceCount ++ ] = sourcePosition ; srcAndRefPositions [ referenceCount ++ ] = referencePosition ; }
public Object [ ] toArray ( ) { return Arrays . copyOf ( elementData , size ) ; }
public boolean isRunning ( ) { return mThread != null && mThread . isAlive ( ) ; }
public static byte [ ] unwrapVCF ( File sourceFile , File tmpFile ) throws FileNotFoundException , IOException { ZipArchiveInputStream in = null ; FileOutputStream fos = null ; String hmacString = null ; try { in = new ZipArchiveInputStream ( new FileInputStream ( sourceFile ) ) ; ArchiveEntry entry ; in . getNextEntry ( ) ; fos = new FileOutputStream ( tmpFile ) ; IOUtils . copy ( in , fos ) ; entry = in . getNextEntry ( ) ; hmacString = entry . getName ( ) ; return Utils . hexToBytes ( hmacString ) ; } catch ( StringIndexOutOfBoundsException e ) { logger . error ( STR_ + hmacString + STR_ , e ) ; throw e ; } catch ( Exception e ) { logger . error ( STR_ , e ) ; throw e ; } finally { if ( fos != null ) { fos . flush ( ) ; fos . close ( ) ; } if ( in != null ) { in . close ( ) ; } } }
public boolean registerUser ( String username , String password , String uri ) throws DataAccessException { if ( checkUsernameExists ( username ) ) { return BOOL_ ; } storeUser ( username , password , uri ) ; return BOOL_ ; }
public SELECT ( @ NonNull String ... columns ) { if ( columns == null ) { throw new NullPointerException ( STR_ ) ; } if ( columns . length == NUM_ ) throw new IllegalArgumentException ( STR_ ) ; StringBuilder builder = new StringBuilder ( STR_ ) ; for ( int i = NUM_ ; i < columns . length ; i ++ ) { builder . append ( columns [ i ] ) ; if ( i != ( columns . length - NUM_ ) ) builder . append ( STR_ ) ; } sql = builder . toString ( ) ; }
public static synchronized MBeanInfo testCompliance ( final Class < ? > baseClass , Class < ? > mbeanInterface ) throws NotCompliantMBeanException { if ( mbeanInterface == null ) mbeanInterface = getStandardMBeanInterface ( baseClass ) ; ReflectUtil . checkPackageAccess ( mbeanInterface ) ; MBeanIntrospector < ? > introspector = StandardMBeanIntrospector . getInstance ( ) ; return getClassMBeanInfo ( introspector , baseClass , mbeanInterface ) ; }
public static Set < String > toStringSet ( TemplateSequenceModel seqModel ) throws TemplateModelException { Set < String > set = new HashSet < String > ( ) ; for ( int i = NUM_ ; i < seqModel . size ( ) ; i ++ ) { set . add ( getAsStringNonEscaping ( ( TemplateScalarModel ) seqModel . get ( i ) ) ) ; } return set ; }
public JKSSignatureToken ( InputStream ksStream , String ksPassword ) { try { keyStore = KeyStore . getInstance ( KeyStore . getDefaultType ( ) ) ; password = ( ksPassword == null ) ? null : ksPassword . toCharArray ( ) ; keyStore . load ( ksStream , password ) ; } catch ( Exception e ) { throw new DSSException ( e ) ; } finally { if ( ksStream != null ) { try { ksStream . close ( ) ; } catch ( IOException e ) { logger . error ( e . getMessage ( ) , e ) ; } } } }
protected void writeLocation ( String loc ) throws IOException { hadAnnotations |= ( loc != null ) ; locOut . writeObject ( loc ) ; }
protected int __offset ( int vtable_offset ) { int vtable = bb_pos - bb . getInt ( bb_pos ) ; return vtable_offset < bb . getShort ( vtable ) ? bb . getShort ( vtable + vtable_offset ) : NUM_ ; }
public static String selectText ( XPathExpression expr , Node context ) { try { return ( String ) expr . evaluate ( context , XPathConstants . STRING ) ; } catch ( XPathExpressionException e ) { throw new XmlException ( e ) ; } }
public static HttpHeaders toArmeria ( io . netty . handler . codec . http . HttpHeaders inHeaders ) { if ( inHeaders . isEmpty ( ) ) { return HttpHeaders . EMPTY_HEADERS ; } final HttpHeaders out = new DefaultHttpHeaders ( BOOL_ , inHeaders . size ( ) ) ; toArmeria ( inHeaders , out ) ; return out ; }
public static int calculateRMSLevel ( short [ ] audioData , int numframes ) { long lSum = NUM_ ; int numread = NUM_ ; for ( short s : audioData ) { lSum = lSum + s ; numread ++ ; if ( numread == numframes ) break ; } double dAvg = lSum / numframes ; double sumMeanSquare = NUM_ ; numread = NUM_ ; for ( short anAudioData : audioData ) { sumMeanSquare = sumMeanSquare + Math . pow ( anAudioData - dAvg , NUM_ ) ; numread ++ ; if ( numread == numframes ) break ; } double averageMeanSquare = sumMeanSquare / numframes ; return ( int ) ( Math . pow ( averageMeanSquare , NUM_ ) + NUM_ ) ; }
private void initProgram ( ) { glUseProgram ( this . program ) ; vec3ArrayUniform = glGetUniformLocation ( this . program , STR_ ) ; chosenUniform = glGetUniformLocation ( this . program , STR_ ) ; glUseProgram ( NUM_ ) ; }
public boolean engineContainsAlias ( String alias ) { return entries . containsKey ( alias . toLowerCase ( Locale . ENGLISH ) ) ; }
public void invertSelectedRelations ( ) { ISelection selection = viewer . getSelection ( ) ; if ( ! ( selection instanceof IStructuredSelection ) ) { return ; } IStructuredSelection structuredSelection = ( IStructuredSelection ) selection ; Collection < Relation > inverse = computeInverseRelations ( getTableRelations ( ) , structuredSelection ) ; StructuredSelection nextSelection = new StructuredSelection ( inverse . toArray ( ) ) ; viewer . setSelection ( nextSelection , BOOL_ ) ; }
public void testFloatValueNeg ( ) { String a = STR_ ; BigDecimal aNumber = new BigDecimal ( a ) ; float result = - NUM_ ; assertTrue ( STR_ , aNumber . floatValue ( ) == result ) ; }
public void bindKeyStore ( final KeyStoreService keyStoreService ) { this . keyStore = keyStoreService ; }
protected void drawConnectorCenters ( Canvas c ) { List < Connection > connections = mBlock . getAllConnections ( ) ; Paint paint = new Paint ( ) ; paint . setStyle ( Paint . Style . FILL ) ; for ( int i = NUM_ ; i < connections . size ( ) ; i ++ ) { Connection conn = connections . get ( i ) ; if ( conn . inDragMode ( ) ) { if ( conn . isConnected ( ) ) { paint . setColor ( Color . RED ) ; } else { paint . setColor ( Color . MAGENTA ) ; } } else { if ( conn . isConnected ( ) ) { paint . setColor ( Color . GREEN ) ; } else { paint . setColor ( Color . CYAN ) ; } } mTempWorkspacePoint . set ( conn . getPosition ( ) . x - mBlock . getPosition ( ) . x , conn . getPosition ( ) . y - mBlock . getPosition ( ) . y ) ; mHelper . workspaceToVirtualViewDelta ( mTempWorkspacePoint , mTempConnectionPosition ) ; if ( mHelper . useRtl ( ) ) { mTempConnectionPosition . x += mBlockViewSize . x ; } c . drawCircle ( mTempConnectionPosition . x , mTempConnectionPosition . y , NUM_ , paint ) ; } }
private static boolean isMerge ( InstructionHandle handle ) { if ( handle . hasTargeters ( ) ) { InstructionTargeter [ ] targeterList = handle . getTargeters ( ) ; for ( InstructionTargeter targeter : targeterList ) { if ( targeter instanceof BranchInstruction ) { return BOOL_ ; } } } return BOOL_ ; }
private synchronized void loadTrustManager ( ) { try { TrustManagerFactory tmf = TrustManagerFactory . getInstance ( X509_ALGORITHM ) ; tmf . init ( keystore ) ; for ( TrustManager trustManager : tmf . getTrustManagers ( ) ) { if ( trustManager instanceof X509TrustManager ) { defaultViPRTrustManager = ( X509TrustManager ) trustManager ; log . debug ( STR_ ) ; break ; } } log . info ( STR_ , defaultViPRTrustManager . getAcceptedIssuers ( ) . length ) ; } catch ( GeneralSecurityException e ) { log . error ( e . getMessage ( ) , e ) ; } }
private boolean isOutsideDocElem ( ) { return ( null == m_docFrag ) && m_elemStack . size ( ) == NUM_ && ( null == m_currentNode || m_currentNode . getNodeType ( ) == Node . DOCUMENT_NODE ) ; }
public ThreadPool ( String name , int poolSize ) { this . poolSize = poolSize ; this . poolName = name ; taskList = new LinkedList < Runnable > ( ) ; threads = new WorkerThread [ poolSize ] ; createThreads ( ) ; }
private static Object invokeOrDie ( final Method method , final Object object , final Object ... params ) { try { return method . invoke ( object , params ) ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( STR_ + STR_ , e ) ; } catch ( InvocationTargetException e ) { final Throwable cause = e . getCause ( ) ; if ( cause instanceof RuntimeException ) { throw ( RuntimeException ) cause ; } else if ( cause instanceof Error ) { throw ( Error ) cause ; } else { throw new RuntimeException ( STR_ , cause ) ; } } }
public void clear ( ) { this . normal = null ; this . depth = NUM_ ; }
public String name ( ) { return theName ; }
public final void addHelperTextColor ( @ ColorInt final int color ) { if ( ! helperTextColors . contains ( color ) ) { helperTextColors . add ( color ) ; verifyPasswordStrength ( ) ; } }
ListBasedTokenStream ( AttributeSource attributeSource , List < AttributeSource > tokens ) { super ( attributeSource . getAttributeFactory ( ) ) ; this . tokens = tokens ; addAttributes ( attributeSource ) ; }
@ SuppressWarnings ( STR_ ) protected Class resolveClass ( ObjectStreamClass classDesc ) throws IOException , ClassNotFoundException { String cname = classDesc . getName ( ) ; return ClassFinder . resolveClass ( cname , this . loader ) ; }
public Map < String , Object > makeValid ( Map < String , ? extends Object > source , String mode ) { return makeValid ( source , mode , BOOL_ , null ) ; }
public static int find ( byte [ ] a , int fromIndex , int toIndex , byte [ ] key ) { int result = - NUM_ ; int sublen = key . length ; int maxpos , first , sp = NUM_ ; maxpos = Math . min ( toIndex , a . length ) - sublen ; for ( first = fromIndex ; sp != sublen && first <= maxpos ; first ++ ) { first = find ( a , first , maxpos , key [ NUM_ ] ) ; if ( ( first < NUM_ ) || ( first > maxpos ) ) { break ; } for ( sp = NUM_ ; sp < sublen ; sp ++ ) { if ( a [ first + sp ] != key [ sp ] ) { sp = sublen ; } } } if ( sublen == NUM_ ) { result = NUM_ ; } else if ( sp == sublen ) { result = ( first - NUM_ ) ; } return result ; }
private void addSyntheticEdge ( Collection < GraphEdge > result , GraphEdge original , GraphNode head , GraphNode tail ) { result . add ( new GraphEdge ( head , tail , original . getRelation ( ) ) ) ; }
public void addStates ( State [ ] s ) { for ( int i = NUM_ ; i < s . length ; i ++ ) states . addElement ( s [ i ] ) ; }
private synchronized void readObject ( java . io . ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; init ( getMask ( actions ) ) ; }
public Tasker addTask ( Task task ) { tasks . add ( task ) ; lastAddedTask = task ; return this ; }
private void initComputeProgram ( ) { glUseProgram ( computeProgram ) ; IntBuffer workGroupSize = BufferUtils . createIntBuffer ( NUM_ ) ; glGetProgramiv ( computeProgram , GL_COMPUTE_WORK_GROUP_SIZE , workGroupSize ) ; workGroupSizeX = workGroupSize . get ( NUM_ ) ; workGroupSizeY = workGroupSize . get ( NUM_ ) ; timeUniform = glGetUniformLocation ( computeProgram , STR_ ) ; blendFactorUniform = glGetUniformLocation ( computeProgram , STR_ ) ; bounceCountUniform = glGetUniformLocation ( computeProgram , STR_ ) ; IntBuffer params = BufferUtils . createIntBuffer ( NUM_ ) ; int loc = glGetUniformLocation ( computeProgram , STR_ ) ; glGetUniformiv ( computeProgram , loc , params ) ; framebufferImageBinding = params . get ( NUM_ ) ; loc = glGetUniformLocation ( computeProgram , STR_ ) ; glGetUniformiv ( computeProgram , loc , params ) ; worldPositionImageBinding = params . get ( NUM_ ) ; loc = glGetUniformLocation ( computeProgram , STR_ ) ; glGetUniformiv ( computeProgram , loc , params ) ; worldNormalImageBinding = params . get ( NUM_ ) ; glUseProgram ( NUM_ ) ; }
public void sort ( ) { throwIfImmutable ( ) ; if ( ! sorted ) { Arrays . sort ( values , NUM_ , size ) ; sorted = BOOL_ ; } }
public static Object objectFromByteBuffer ( byte [ ] buffer ) throws Exception { if ( buffer == null ) return null ; ByteArrayInputStream inStream = new ByteArrayInputStream ( buffer ) ; ObjectInputStream in = new ObjectInputStreamExt ( inStream ) ; Object retval = in . readObject ( ) ; in . close ( ) ; return retval ; }
public String generateGroupName ( String policyName , Set < String > existingGroupNames , String parentGroupName ) { int count = NUM_ ; String format = null ; while ( count <= existingGroupNames . size ( ) ) { if ( NUM_ == count ) { format = String . format ( STR_ , policyName ) ; } else { format = String . format ( STR_ , policyName , count ) ; } String generatedGroupName = generate ( parentGroupName , format , SmisConstants . MASK_NAME_DELIMITER , SmisConstants . MAX_STORAGE_GROUP_NAME_LENGTH ) ; if ( ! existingGroupNames . contains ( generatedGroupName ) ) { return generatedGroupName ; } count ++ ; } return generate ( parentGroupName , String . format ( STR_ , policyName ) , SmisConstants . MASK_NAME_DELIMITER , SmisConstants . MAX_STORAGE_GROUP_NAME_LENGTH ) ; }
public static void assertColumnTypes ( ResultSet rs , int [ ] expectedTypes ) throws SQLException { ResultSetMetaData rsmd = rs . getMetaData ( ) ; int actualCols = rsmd . getColumnCount ( ) ; assertEquals ( STR_ , expectedTypes . length , rsmd . getColumnCount ( ) ) ; for ( int i = NUM_ ; i < actualCols ; i ++ ) { assertEquals ( STR_ + ( i + NUM_ ) , expectedTypes [ i ] , rsmd . getColumnType ( i + NUM_ ) ) ; } }
public DefaultActionGroup ( @ NotNull AnAction ... actions ) { this ( Arrays . asList ( actions ) ) ; }
public int add ( T dl , int row ) { _list . add ( row , dl ) ; fireTableRowsInserted ( row , row ) ; return row ; }
private void pushTerm ( BytesRef text ) throws IOException { int limit = Math . min ( lastTerm . length ( ) , text . length ) ; int pos = NUM_ ; while ( pos < limit && lastTerm . byteAt ( pos ) == text . bytes [ text . offset + pos ] ) { pos ++ ; } for ( int i = lastTerm . length ( ) - NUM_ ; i >= pos ; i -- ) { int prefixTopSize = pending . size ( ) - prefixStarts [ i ] ; if ( prefixTopSize >= minItemsInBlock ) { writeBlocks ( i + NUM_ , prefixTopSize ) ; prefixStarts [ i ] -= prefixTopSize - NUM_ ; } } if ( prefixStarts . length < text . length ) { prefixStarts = ArrayUtil . grow ( prefixStarts , text . length ) ; } for ( int i = pos ; i < text . length ; i ++ ) { prefixStarts [ i ] = pending . size ( ) ; } lastTerm . copyBytes ( text ) ; }
public NumericLiteral ( Object x ) { if ( x instanceof Number ) { m_number = ( Number ) x ; m_type = TypeLib . getPrimitiveType ( m_number . getClass ( ) ) ; } else { throw new IllegalArgumentException ( STR_ ) ; } }
private boolean isMineshafterPresent ( ) { try { Class . forName ( STR_ ) ; return BOOL_ ; } catch ( Exception e ) { return BOOL_ ; } }
@ SuppressLint ( STR_ ) @ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { int widthMode = MeasureSpec . getMode ( widthMeasureSpec ) ; int heightMode = MeasureSpec . getMode ( heightMeasureSpec ) ; int maxWidth = MeasureSpec . getSize ( widthMeasureSpec ) ; int maxHeight = MeasureSpec . getSize ( heightMeasureSpec ) ; if ( widthMode == MeasureSpec . UNSPECIFIED ) maxWidth = Integer . MAX_VALUE ; if ( heightMode == MeasureSpec . UNSPECIFIED ) maxHeight = Integer . MAX_VALUE ; int paddingLeft = getPaddingLeft ( ) ; int paddingTop = getPaddingTop ( ) ; int paddingRight = getPaddingRight ( ) ; int paddingBottom = getPaddingBottom ( ) ; int maxRightBound = maxWidth - paddingRight ; int maxBottomBound = maxHeight - paddingBottom ; int left ; int top ; int right ; int bottom ; int rightBound = paddingLeft ; int maxRightNoPadding = rightBound ; int bottomBound ; int lastMaxBottom = paddingTop ; int maxBottom = lastMaxBottom ; int childWidth ; int childHeight ; int lineStartIndex = NUM_ ; int lineEndIndex ; rectList . clear ( ) ; int childCount = getChildCount ( ) ; for ( int index = NUM_ ; index < childCount ; index ++ ) { final View child = getChildAt ( index ) ; child . measure ( MeasureSpec . UNSPECIFIED , MeasureSpec . UNSPECIFIED ) ; if ( child . getVisibility ( ) == View . GONE ) continue ; final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; childWidth = child . getMeasuredWidth ( ) ; childHeight = child . getMeasuredHeight ( ) ; left = rightBound + lp . leftMargin ; right = left + childWidth ; rightBound = right + lp . rightMargin ; if ( rightBound > maxRightBound ) { lineEndIndex = index ; adjustBaseLine ( maxBottom - lastMaxBottom , lineStartIndex , lineEndIndex ) ; if ( maxBottom >= maxBottomBound ) break ; if ( lineEndIndex == lineStartIndex ) { child . measure ( MeasureSpec . makeMeasureSpec ( maxWidth - paddingLeft - paddingRight - lp . leftMargin - lp . rightMargin , MeasureSpec . AT_MOST ) , MeasureSpec . UNSPECIFIED ) ; childWidth = child . getMeasuredWidth ( ) ; childHeight = child . getMeasuredHeight ( ) ; } left = paddingLeft + lp . leftMargin ; right = left + childWidth ; rightBound = right + lp . rightMargin ; lastMaxBottom = maxBottom ; top = lastMaxBottom + lp . topMargin ; bottom = top + childHeight ; bottomBound = bottom + lp . bottomMargin ; lineStartIndex = index ; } else { top = lastMaxBottom + lp . topMargin ; bottom = top + childHeight ; bottomBound = bottom + lp . bottomMargin ; } if ( rightBound > maxRightNoPadding ) maxRightNoPadding = rightBound ; if ( bottomBound > maxBottom ) maxBottom = bottomBound ; Rect rect = new Rect ( ) ; rect . left = left ; rect . top = top ; rect . right = right ; rect . bottom = bottom ; rectList . add ( rect ) ; } adjustBaseLine ( maxBottom - lastMaxBottom , lineStartIndex , rectList . size ( ) ) ; int measuredWidth ; int measuredHeight ; if ( widthMode == MeasureSpec . EXACTLY ) measuredWidth = maxWidth ; else measuredWidth = maxRightNoPadding + paddingRight ; if ( heightMode == MeasureSpec . EXACTLY ) measuredHeight = maxHeight ; else { measuredHeight = maxBottom + paddingBottom ; if ( heightMode == MeasureSpec . AT_MOST ) measuredHeight = measuredHeight > maxHeight ? maxHeight : measuredHeight ; } setMeasuredDimension ( measuredWidth , measuredHeight ) ; }
private final boolean compareAndSetHead ( Node update ) { return unsafe . compareAndSwapObject ( this , headOffset , null , update ) ; }
protected Set < DependencyKind > removeDependency ( Node n ) { Set < DependencyKind > removedKinds = new HashSet < > ( ) ; for ( DependencyKind dk : DependencyKind . values ( ) ) { Set < Node > depsByKind = deps . get ( dk ) ; if ( depsByKind == null ) continue ; if ( depsByKind . remove ( n ) ) { removedKinds . add ( dk ) ; } } return removedKinds ; }
public static < K , V > ConcurrentMap < K , V > newConcurrentMapWithAggressiveConcurrency ( ) { return new ConcurrentHashMap < > ( NUM_ , NUM_ , aggressiveConcurrencyLevel ) ; }
@ Override public boolean connectionAllowed ( String eventName ) { if ( m_listenee != null || ! eventName . equals ( STR_ ) ) { return BOOL_ ; } return BOOL_ ; }
protected char skipAllWhitespace ( Reader r ) throws IOException { char c ; do { c = ( char ) r . read ( ) ; } while ( Character . isWhitespace ( c ) && c != ( char ) - NUM_ ) ; return c ; }
public Iterator enumerateLiteralResultAttributes ( ) { return ( null == m_avts ) ? null : m_avts . iterator ( ) ; }
public Map < String , String > parse ( final String str , char separator ) { if ( str == null ) { return new HashMap < > ( ) ; } return parse ( str . toCharArray ( ) , separator ) ; }
public PriorityQueue ( Collection < ? extends E > c ) { if ( c instanceof PriorityQueue ) { getFromPriorityQueue ( ( PriorityQueue < ? extends E > ) c ) ; } else if ( c instanceof SortedSet ) { getFromSortedSet ( ( SortedSet < ? extends E > ) c ) ; } else { initSize ( c ) ; addAll ( c ) ; } }
private String resourceId ( ) { return subSchemaPath . isEmpty ( ) ? null : lastSchemaNodeName ( ) ; }
private long acquireWrite ( boolean interruptible , long deadline ) { WNode node = null , p ; for ( int spins = - NUM_ ; ; ) { long m , s , ns ; if ( ( m = ( s = state ) & ABITS ) == NUM_ ) { if ( U . compareAndSwapLong ( this , STATE , s , ns = s + WBIT ) ) return ns ; } else if ( spins < NUM_ ) spins = ( m == WBIT && wtail == whead ) ? SPINS : NUM_ ; else if ( spins > NUM_ ) { if ( LockSupport . nextSecondarySeed ( ) >= NUM_ ) -- spins ; } else if ( ( p = wtail ) == null ) { WNode hd = new WNode ( WMODE , null ) ; if ( U . compareAndSwapObject ( this , WHEAD , null , hd ) ) wtail = hd ; } else if ( node == null ) node = new WNode ( WMODE , p ) ; else if ( node . prev != p ) node . prev = p ; else if ( U . compareAndSwapObject ( this , WTAIL , p , node ) ) { p . next = node ; break ; } } for ( int spins = - NUM_ ; ; ) { WNode h , np , pp ; int ps ; if ( ( h = whead ) == p ) { if ( spins < NUM_ ) spins = HEAD_SPINS ; else if ( spins < MAX_HEAD_SPINS ) spins <<= NUM_ ; for ( int k = spins ; ; ) { long s , ns ; if ( ( ( s = state ) & ABITS ) == NUM_ ) { if ( U . compareAndSwapLong ( this , STATE , s , ns = s + WBIT ) ) { whead = node ; node . prev = null ; return ns ; } } else if ( LockSupport . nextSecondarySeed ( ) >= NUM_ && -- k <= NUM_ ) break ; } } else if ( h != null ) { WNode c ; Thread w ; while ( ( c = h . cowait ) != null ) { if ( U . compareAndSwapObject ( h , WCOWAIT , c , c . cowait ) && ( w = c . thread ) != null ) U . unpark ( w ) ; } } if ( whead == h ) { if ( ( np = node . prev ) != p ) { if ( np != null ) ( p = np ) . next = node ; } else if ( ( ps = p . status ) == NUM_ ) U . compareAndSwapInt ( p , WSTATUS , NUM_ , WAITING ) ; else if ( ps == CANCELLED ) { if ( ( pp = p . prev ) != null ) { node . prev = pp ; pp . next = node ; } } else { long time ; if ( deadline == NUM_ ) time = NUM_ ; else if ( ( time = deadline - System . nanoTime ( ) ) <= NUM_ ) return cancelWaiter ( node , node , BOOL_ ) ; Thread wt = Thread . currentThread ( ) ; U . putObject ( wt , PARKBLOCKER , this ) ; node . thread = wt ; if ( p . status < NUM_ && ( p != h || ( state & ABITS ) != NUM_ ) && whead == h && node . prev == p ) U . park ( BOOL_ , time ) ; node . thread = null ; U . putObject ( wt , PARKBLOCKER , null ) ; if ( interruptible && Thread . interrupted ( ) ) return cancelWaiter ( node , node , BOOL_ ) ; } } } }
@ Override public boolean isInitial ( ) { return init ; }
public static String denormalize ( final CharSequence self ) { if ( lineSeparator == null ) { final StringWriter sw = new StringWriter ( NUM_ ) ; try { final BufferedWriter bw = new BufferedWriter ( sw ) ; bw . newLine ( ) ; bw . flush ( ) ; lineSeparator = sw . toString ( ) ; } catch ( IOException ioe ) { lineSeparator = STR_ ; } } final int len = self . length ( ) ; if ( len < NUM_ ) { return self . toString ( ) ; } final StringBuilder sb = new StringBuilder ( ( NUM_ . len ) / NUM_ ) ; int i = NUM_ ; CharSequence cs = ( self instanceof GString ) ? self . toString ( ) : self ; while ( i < len ) { final char ch = cs . charAt ( i ++ ) ; switch ( ch ) { case STR_ : sb . append ( lineSeparator ) ; if ( ( i < len ) && ( cs . charAt ( i ) == STR_ ) ) { ++ i ; } break ; case STR_ : sb . append ( lineSeparator ) ; break ; default : sb . append ( ch ) ; break ; } } return sb . toString ( ) ; }
public static void performSaveAs ( String schemaPrefixFileName , String selFilePath , ContainerConfig containerConfig ) { try { File fileWithDefaultConfiguration = createContainerSchemaFile ( schemaPrefixFileName , selFilePath ) ; updateFile ( containerConfig , fileWithDefaultConfiguration . getPath ( ) , schemaPrefixFileName ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
public boolean isAborted ( ) { return isAborted . get ( ) ; }
public void append ( int key , E value ) { if ( mSize != NUM_ && key <= mKeys [ mSize - NUM_ ] ) { put ( key , value ) ; return ; } if ( mGarbage && mSize >= mKeys . length ) { gc ( ) ; } int pos = mSize ; if ( pos >= mKeys . length ) { int n = idealIntArraySize ( pos + NUM_ ) ; int [ ] nkeys = new int [ n ] ; Object [ ] nvalues = new Object [ n ] ; System . arraycopy ( mKeys , NUM_ , nkeys , NUM_ , mKeys . length ) ; System . arraycopy ( mValues , NUM_ , nvalues , NUM_ , mValues . length ) ; mKeys = nkeys ; mValues = nvalues ; } mKeys [ pos ] = key ; mValues [ pos ] = value ; mSize = pos + NUM_ ; }
public void testSkip ( ) throws IOException { byte [ ] data = new byte [ NUM_ . NUM_ ] ; byte [ ] gzipped = GZIPOutputStreamTest . gzip ( data ) ; GZIPInputStream in = new GZIPInputStream ( new ByteArrayInputStream ( gzipped ) ) ; long totalSkipped = NUM_ ; long count ; do { count = in . skip ( Long . MAX_VALUE ) ; totalSkipped += count ; } while ( count > NUM_ ) ; assertEquals ( data . length , totalSkipped ) ; in . close ( ) ; }
private Support_TestWebData ( String path , String type ) { File file = new File ( path ) ; testLength = file . length ( ) ; testLastModified = file . lastModified ( ) ; testName = file . getName ( ) ; testType = type ; testDir = file . isDirectory ( ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; FileInputStream in = null ; try { in = new FileInputStream ( file ) ; while ( in . available ( ) > NUM_ ) { out . write ( in . read ( ) ) ; } in . close ( ) ; out . flush ( ) ; test0Data = out . toByteArray ( ) ; out . close ( ) ; test0DataAvailable = BOOL_ ; return ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { try { if ( in != null ) { in . close ( ) ; } if ( out != null ) { out . close ( ) ; } } catch ( IOException e ) { } } }
public static void print ( boolean x ) { out . print ( x ) ; out . flush ( ) ; }
public IpcSharedMemorySpace ( String tokFileName , int writerPid , int readerPid , int size , boolean reader , IgniteLogger parent ) throws IgniteCheckedException { assert size > NUM_ : STR_ ; log = parent . getLogger ( IpcSharedMemorySpace . class ) ; opSize = size ; shmemPtr = IpcSharedMemoryUtils . allocateSystemResources ( tokFileName , size , DEBUG && log . isDebugEnabled ( ) ) ; shmemId = IpcSharedMemoryUtils . sharedMemoryId ( shmemPtr ) ; semId = IpcSharedMemoryUtils . semaphoreId ( shmemPtr ) ; isReader = reader ; this . tokFileName = tokFileName ; this . readerPid = readerPid ; this . writerPid = writerPid ; if ( DEBUG && log . isDebugEnabled ( ) ) log . debug ( STR_ + this ) ; }
@ Override public void close ( ) { try { if ( connection != null ) { connection . close ( ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
public Version addQualifier ( String qualifier ) { List < String > newQualifiers = new ArrayList < > ( this . qualifiers ) ; newQualifiers . add ( qualifier ) ; return new Version ( major , minor , patch , newQualifiers . toArray ( new String [ newQualifiers . size ( ) ] ) ) ; }
public int loadSigned16 ( int addr ) { return loadSigned16 ( addr , AccessSource . CODE ) ; }
public static String arrayToHexString ( byte [ ] array ) { return arrayToHexString ( array , NUM_ , array . length ) ; }
public static void unregisterBaggageHandler ( BaggageHandler handler ) { handlers . remove ( handler ) ; }
public DefaultHeatMapDataset ( int xSamples , int ySamples , double minX , double maxX , double minY , double maxY ) { if ( xSamples < NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } if ( ySamples < NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } if ( Double . isInfinite ( minX ) || Double . isNaN ( minX ) ) { throw new IllegalArgumentException ( STR_ ) ; } if ( Double . isInfinite ( maxX ) || Double . isNaN ( maxX ) ) { throw new IllegalArgumentException ( STR_ ) ; } if ( Double . isInfinite ( minY ) || Double . isNaN ( minY ) ) { throw new IllegalArgumentException ( STR_ ) ; } if ( Double . isInfinite ( maxY ) || Double . isNaN ( maxY ) ) { throw new IllegalArgumentException ( STR_ ) ; } this . xSamples = xSamples ; this . ySamples = ySamples ; this . minX = minX ; this . maxX = maxX ; this . minY = minY ; this . maxY = maxY ; this . zValues = new double [ xSamples ] [ ] ; for ( int x = NUM_ ; x < xSamples ; x ++ ) { this . zValues [ x ] = new double [ ySamples ] ; } }
public static void assertEqualsAnyOrder ( EventBean [ ] [ ] expected , EventBean [ ] [ ] actual ) { if ( compareArraySize ( expected , actual ) ) { return ; } int numMatches = NUM_ ; boolean [ ] foundReceived = new boolean [ actual . length ] ; for ( EventBean [ ] expectedObject : expected ) { boolean found = BOOL_ ; for ( int i = NUM_ ; i < actual . length ; i ++ ) { if ( foundReceived [ i ] ) { continue ; } boolean match = compareEqualsExactOrder ( actual [ i ] , expectedObject ) ; if ( match ) { found = BOOL_ ; numMatches ++ ; foundReceived [ i ] = BOOL_ ; break ; } } if ( ! found ) { log . error ( STR_ + Arrays . toString ( expectedObject ) ) ; log . error ( STR_ + Arrays . toString ( actual ) ) ; } ScopeTestHelper . assertTrue ( found ) ; } ScopeTestHelper . assertEquals ( numMatches , expected . length ) ; }
private void collectText ( ) { if ( textNodeCount > NUM_ ) { firstTextNode . setText ( textBuffer . toString ( ) ) ; } textNodeCount = NUM_ ; }
@ SuppressWarnings ( { STR_ , STR_ } ) public static < T extends Annotation > T unproxy ( T annotation ) { Function unproxyFunction = getUnproxyFunction ( annotation . annotationType ( ) ) ; return ( T ) unproxyFunction . apply ( annotation ) ; }
public static List < Node > parseExpression ( Context context , HashSet < String > configNamespaces , String text ) { return parseExpression ( context , configNamespaces , text , NUM_ , BOOL_ ) ; }
public void addTickMarkSection ( final Section SECTION ) { if ( null == SECTION ) return ; tickMarkSections . add ( SECTION ) ; Collections . sort ( tickMarkSections , new SectionComparator ( ) ) ; fireUpdateEvent ( REDRAW_EVENT ) ; }
protected static double calcQ_i ( double f , double lambda ) { return lambda . Math . exp ( - lambda . f ) ; }
void flush ( ) { printStream . flush ( ) ; }
public CharBuffer delete ( int start , int end ) { int length = length ( ) ; if ( start < NUM_ || end < start || length < start ) throw new StringIndexOutOfBoundsException ( ) ; end = Math . min ( length , end ) ; int tail = length - end ; char [ ] buffer = buffer ( ) ; for ( int i = NUM_ ; i < tail ; i ++ ) { buffer [ start + i ] = buffer [ end + i ] ; } length ( length - ( end - start ) ) ; return this ; }
public void addPlotter ( final Plotter plotter ) { plotters . add ( plotter ) ; }
Node < K , V > findNear ( K kkey , int rel ) { Comparable < ? super K > key = comparable ( kkey ) ; for ( ; ; ) { Node < K , V > b = findPredecessor ( key ) ; Node < K , V > n = b . next ; for ( ; ; ) { if ( n == null ) return ( ( rel & LT ) == NUM_ || b . isBaseHeader ( ) ) ? null : b ; Node < K , V > f = n . next ; if ( n != b . next ) break ; Object v = n . value ; if ( v == null ) { n . helpDelete ( b , f ) ; break ; } if ( v == n || b . value == null ) break ; int c = key . compareTo ( n . key ) ; if ( ( c == NUM_ && ( rel & EQ ) != NUM_ ) || ( c < NUM_ && ( rel & LT ) == NUM_ ) ) return n ; if ( c <= NUM_ && ( rel & LT ) != NUM_ ) return b . isBaseHeader ( ) ? null : b ; b = n ; n = f ; } } }
public void addListener ( SpeedrunsLiveListener listener ) { listeners . add ( listener ) ; }
public void writeExif ( Bitmap bmap , OutputStream exifOutStream ) throws IOException { if ( bmap == null || exifOutStream == null ) { throw new IllegalArgumentException ( NULL_ARGUMENT_STRING ) ; } OutputStream s = getExifWriterStream ( exifOutStream ) ; bmap . compress ( Bitmap . CompressFormat . JPEG , NUM_ , s ) ; s . flush ( ) ; }
public boolean find ( int start ) { if ( start < NUM_ || start > input . length ( ) ) { throw new IndexOutOfBoundsException ( STR_ + start + STR_ + input . length ( ) ) ; } synchronized ( this ) { matchFound = findImpl ( address , input , start , matchOffsets ) ; } return matchFound ; }
public int action ( String fault , String action ) { Integer current = get ( fault ) ; if ( current == null ) throw new IllegalArgumentException ( fault ) ; boolean no = action . startsWith ( STR_ ) ; if ( no ) action = action . substring ( NUM_ ) ; Integer bit = getAction ( action ) ; if ( bit == null ) throw new IllegalArgumentException ( action ) ; int old = current . intValue ( ) ; int mask = bit . intValue ( ) ; int n = ( old & ( ~ mask ) ) ; n = ( no ) ? n : ( n | mask ) ; put ( fault , new Integer ( n ) ) ; return n ; }
public static boolean containsWhitespace ( CharSequence str ) { if ( ! hasLength ( str ) ) { return BOOL_ ; } int strLen = str . length ( ) ; for ( int i = NUM_ ; i < strLen ; i ++ ) { if ( Character . isWhitespace ( str . charAt ( i ) ) ) { return BOOL_ ; } } return BOOL_ ; }
public boolean hasUnsupportedCriticalExtension ( ) { Set extns = getCriticalExtensionOIDs ( ) ; if ( extns == null ) { return BOOL_ ; } extns . remove ( RFC3280CertPathUtilities . ISSUING_DISTRIBUTION_POINT ) ; extns . remove ( RFC3280CertPathUtilities . DELTA_CRL_INDICATOR ) ; return ! extns . isEmpty ( ) ; }
public static < T > T decodeFromBase64 ( Coder < T > coder , String encodedValue ) throws CoderException { return decodeFromSafeStream ( coder , new ByteArrayInputStream ( Base64 . decodeBase64 ( encodedValue ) ) , Coder . Context . OUTER ) ; }
public void validate ( Set setData ) throws ValidationException { for ( Iterator iter = setData . iterator ( ) ; iter . hasNext ( ) ; ) { performValidation ( ( String ) iter . next ( ) ) ; } }
public String add ( Object ... values ) { double result = NUM_ ; for ( int i = NUM_ ; i < values . length ; i ++ ) { result += FunctionHandler . getDouble ( values [ i ] ) ; } return Double . toString ( result ) ; }
public List < String > listMyDBs ( String owner , boolean restricted ) { Connection conn = null ; try { conn = getConnection ( ) ; return listMyDBs ( conn , owner , restricted ) ; } catch ( Exception ex ) { logger . log ( Level . SEVERE , STR_ , ex ) ; } finally { DBUtils . close ( conn ) ; } return null ; }
public void put ( String key , long value ) { if ( key != null ) { urlParams . put ( key , String . valueOf ( value ) ) ; } }
public int compare ( Object o1 , Object o2 ) { return comparator . compare ( o1 , o2 ) ; }
public void addCheckBoxActionListener ( ActionListener al ) { m_enableDistributedExperiment . addActionListener ( al ) ; }
private Rect calcBounds ( int index , Paint paint ) { Rect bounds = new Rect ( ) ; CharSequence title = getTitle ( index ) ; bounds . right = ( int ) paint . measureText ( title , NUM_ , title . length ( ) ) ; bounds . bottom = ( int ) ( paint . descent ( ) - paint . ascent ( ) ) ; return bounds ; }
GF256Poly addOrSubtract ( GF256Poly other ) { if ( ! field . equals ( other . field ) ) { throw new IllegalArgumentException ( STR_ ) ; } if ( isZero ( ) ) { return other ; } if ( other . isZero ( ) ) { return this ; } int [ ] smallerCoefficients = this . coefficients ; int [ ] largerCoefficients = other . coefficients ; if ( smallerCoefficients . length > largerCoefficients . length ) { int [ ] temp = smallerCoefficients ; smallerCoefficients = largerCoefficients ; largerCoefficients = temp ; } int [ ] sumDiff = new int [ largerCoefficients . length ] ; int lengthDiff = largerCoefficients . length - smallerCoefficients . length ; System . arraycopy ( largerCoefficients , NUM_ , sumDiff , NUM_ , lengthDiff ) ; for ( int i = lengthDiff ; i < largerCoefficients . length ; i ++ ) { sumDiff [ i ] = GF256 . addOrSubtract ( smallerCoefficients [ i - lengthDiff ] , largerCoefficients [ i ] ) ; } return new GF256Poly ( field , sumDiff ) ; }
@ Override public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( type ) ; sb . append ( STR_ ) ; sb . append ( subType ) ; for ( String name : attributes . keySet ( ) ) { if ( inferredCharset && ATTR_CHARSET . equals ( name ) ) { continue ; } sb . append ( STR_ ) ; sb . append ( name ) ; sb . append ( STR_ ) ; String value = attributes . get ( name ) ; Matcher tokenMatcher = TOKEN_PATTERN . matcher ( value ) ; if ( tokenMatcher . matches ( ) ) { sb . append ( value ) ; } else { sb . append ( STR_ + value + STR_ ) ; } } return sb . toString ( ) ; }
public static long firstFieldOffset ( Class clazz ) { long minSize = roundUpTo8 ( headerSize ( clazz ) ) ; while ( clazz != Object . class ) { for ( Field f : clazz . getDeclaredFields ( ) ) { if ( ( f . getModifiers ( ) & Modifier . STATIC ) == NUM_ ) { long offset = unsafe . objectFieldOffset ( f ) ; if ( offset < minSize ) { minSize = offset ; } } } clazz = clazz . getSuperclass ( ) ; } return minSize ; }
private void fitImageToView ( ) { Drawable drawable = getDrawable ( ) ; if ( drawable == null || drawable . getIntrinsicWidth ( ) == NUM_ || drawable . getIntrinsicHeight ( ) == NUM_ ) { return ; } if ( matrix == null || prevMatrix == null ) { return ; } int drawableWidth = drawable . getIntrinsicWidth ( ) ; int drawableHeight = drawable . getIntrinsicHeight ( ) ; float scaleX = ( float ) viewWidth / drawableWidth ; float scaleY = ( float ) viewHeight / drawableHeight ; switch ( mScaleType ) { case CENTER : scaleX = scaleY = NUM_ ; break ; case CENTER_CROP : scaleX = scaleY = Math . max ( scaleX , scaleY ) ; break ; case CENTER_INSIDE : scaleX = scaleY = Math . min ( NUM_ , Math . min ( scaleX , scaleY ) ) ; case FIT_CENTER : scaleX = scaleY = Math . min ( scaleX , scaleY ) ; break ; case FIT_XY : break ; default : throw new UnsupportedOperationException ( STR_ ) ; } float redundantXSpace = viewWidth - ( scaleX . drawableWidth ) ; float redundantYSpace = viewHeight - ( scaleY . drawableHeight ) ; matchViewWidth = viewWidth - redundantXSpace ; matchViewHeight = viewHeight - redundantYSpace ; if ( ! isZoomed ( ) && ! imageRenderedAtLeastOnce ) { matrix . setScale ( scaleX , scaleY ) ; matrix . postTranslate ( redundantXSpace / NUM_ , redundantYSpace / NUM_ ) ; normalizedScale = NUM_ ; } else { if ( prevMatchViewWidth == NUM_ || prevMatchViewHeight == NUM_ ) { savePreviousImageValues ( ) ; } prevMatrix . getValues ( m ) ; m [ Matrix . MSCALE_X ] = matchViewWidth / drawableWidth . normalizedScale ; m [ Matrix . MSCALE_Y ] = matchViewHeight / drawableHeight . normalizedScale ; float transX = m [ Matrix . MTRANS_X ] ; float transY = m [ Matrix . MTRANS_Y ] ; float prevActualWidth = prevMatchViewWidth . normalizedScale ; float actualWidth = getImageWidth ( ) ; translateMatrixAfterRotate ( Matrix . MTRANS_X , transX , prevActualWidth , actualWidth , prevViewWidth , viewWidth , drawableWidth ) ; float prevActualHeight = prevMatchViewHeight . normalizedScale ; float actualHeight = getImageHeight ( ) ; translateMatrixAfterRotate ( Matrix . MTRANS_Y , transY , prevActualHeight , actualHeight , prevViewHeight , viewHeight , drawableHeight ) ; matrix . setValues ( m ) ; } fixTrans ( ) ; setImageMatrix ( matrix ) ; }
public static void w ( String tag , String msg , Object ... args ) { if ( sLevel > LEVEL_WARNING ) { return ; } if ( args . length > NUM_ ) { msg = String . format ( msg , args ) ; } Log . w ( tag , msg ) ; }
private int processPollFds ( ) throws IOException { if ( pollFds . get ( NUM_ ) . revents == POLLIN ) { byte [ ] buffer = new byte [ NUM_ ] ; while ( IoBridge . read ( wakeupIn , buffer , NUM_ , NUM_ ) > NUM_ ) { } } int readyKeyCount = NUM_ ; for ( int i = NUM_ ; i < pollFds . size ( ) ; ++ i ) { StructPollfd pollFd = pollFds . get ( i ) ; if ( pollFd . revents == NUM_ ) { continue ; } if ( pollFd . fd == null ) { break ; } SelectionKeyImpl key = ( SelectionKeyImpl ) pollFd . userData ; pollFd . fd = null ; pollFd . userData = null ; int ops = key . interestOpsNoCheck ( ) ; int selectedOps = NUM_ ; if ( ( pollFd . revents & POLLHUP ) != NUM_ ) { selectedOps |= ops ; } if ( ( pollFd . revents & POLLIN ) != NUM_ ) { selectedOps |= ops & ( OP_ACCEPT | OP_READ ) ; } if ( ( pollFd . revents & POLLOUT ) != NUM_ ) { if ( key . isConnected ( ) ) { selectedOps |= ops & OP_WRITE ; } else { selectedOps |= ops & OP_CONNECT ; } } if ( selectedOps != NUM_ ) { boolean wasSelected = mutableSelectedKeys . contains ( key ) ; if ( wasSelected && key . readyOps ( ) != selectedOps ) { key . setReadyOps ( key . readyOps ( ) | selectedOps ) ; ++ readyKeyCount ; } else if ( ! wasSelected ) { key . setReadyOps ( selectedOps ) ; mutableSelectedKeys . add ( key ) ; ++ readyKeyCount ; } } } return readyKeyCount ; }
public final V extractFirst ( ) { if ( size ( ) > NUM_ ) { if ( GWT . isScript ( ) ) { V ret = jsArray . get ( NUM_ ) ; jsArray . remove ( NUM_ ) ; return ret ; } else { return javaArray . remove ( NUM_ ) ; } } return null ; }
@ Override public void actionPerformed ( ActionEvent event ) { String command = event . getActionCommand ( ) ; if ( command . equals ( STR_ ) ) { attemptLabelFontSelection ( ) ; } else if ( command . equals ( STR_ ) ) { attemptModifyLabelPaint ( ) ; } else if ( command . equals ( STR_ ) ) { attemptTickLabelFontSelection ( ) ; } }
@ AndroidOnly ( STR_ ) public void test_unwrap_ByteBuffer$ByteBuffer_04 ( ) { String host = STR_ ; int port = NUM_ ; ByteBuffer bbs = ByteBuffer . allocate ( NUM_ ) ; ByteBuffer [ ] bbd = { ByteBuffer . allocate ( NUM_ ) , ByteBuffer . allocate ( NUM_ ) , ByteBuffer . allocate ( NUM_ ) } ; SSLEngine sse = getEngine ( host , port ) ; try { sse . unwrap ( bbs , bbd ) ; fail ( STR_ ) ; } catch ( IllegalStateException iobe ) { } catch ( Exception e ) { fail ( e + STR_ ) ; } }
public static void upgradeServerInstance ( SSOToken ssoToken , String instanceName , String instanceId , Map < String , String > upgradedValues ) throws SMSException , SSOException , ConfigurationException , IOException { ServiceConfig sc = getServerConfig ( ssoToken , instanceName ) ; if ( sc != null ) { Map map = sc . getAttributes ( ) ; map . remove ( ATTR_PARENT_SITE_ID ) ; Set newSet = getPropertiesSet ( upgradedValues ) ; map . put ( ATTR_SERVER_CONFIG , newSet ) ; sc . setAttributes ( map ) ; } else { throw new ConfigurationException ( STR_ + STR_ ) ; } }
public static < T > T instance ( Class < T > clazz ) { try { return clazz . newInstance ( ) ; } catch ( InstantiationException | IllegalAccessException e ) { throw new IllegalStateException ( e ) ; } }
private void pop ( final String desc ) { char c = desc . charAt ( NUM_ ) ; if ( c == STR_ ) { pop ( ( Type . getArgumentsAndReturnSizes ( desc ) > > NUM_ ) - NUM_ ) ; } else if ( c == STR_ || c == STR_ ) { pop ( NUM_ ) ; } else { pop ( NUM_ ) ; } }
public GenericSipMsrpSession createMsrpSession ( ContactId contact , String featureTag , String [ ] acceptTypes , String [ ] acceptWrappedTypes ) { if ( sLogger . isActivated ( ) ) { sLogger . info ( STR_ + contact ) ; } return new OriginatingSipMsrpSession ( this , contact , featureTag , mRcsSettings , System . currentTimeMillis ( ) , mContactManager , acceptTypes , acceptWrappedTypes ) ; }
public ForumPostConfig create ( ForumPostConfig config ) { config . addCredentials ( this ) ; String xml = POST ( this . url + STR_ , config . toXML ( ) ) ; Element root = parse ( xml ) ; if ( root == null ) { return null ; } try { ForumPostConfig post = new ForumPostConfig ( ) ; post . parseXML ( root ) ; return post ; } catch ( Exception exception ) { this . exception = SDKException . parseFailure ( exception ) ; throw this . exception ; } }
protected void drawMark ( Graphics2D g2 , float x , float y , Color color ) { Rectangle2D bounds = mark . getBounds2D ( ) ; float w = ( float ) bounds . getWidth ( ) ; float h = ( float ) bounds . getHeight ( ) ; x = x - ( w / NUM_ ) ; y = y - ( h / NUM_ ) ; g2 . translate ( x , y ) ; if ( color == null ) { if ( markFillPaint != null ) { g2 . setPaint ( markFillPaint ) ; g2 . fill ( mark ) ; } } else { g2 . setPaint ( color ) ; g2 . fill ( mark ) ; } g2 . setPaint ( markPaint ) ; g2 . setStroke ( markStroke ) ; g2 . draw ( mark ) ; g2 . translate ( - x , - y ) ; Rectangle2D rect = new Rectangle2D . Float ( x , y , w , h ) ; markBounds . add ( rect ) ; }
public void componentResized ( ComponentEvent e ) { if ( logger . isLoggable ( Level . FINE ) ) { logger . fine ( STR_ + getWidth ( ) + STR_ + getHeight ( ) ) ; } projection . setWidth ( getWidth ( ) ) ; projection . setHeight ( getHeight ( ) ) ; fireProjectionChanged ( ) ; }
public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; for ( StepPattern pat = this ; pat != null ; pat = pat . m_relativePathPattern ) { if ( pat != this ) buf . append ( STR_ ) ; buf . append ( Axis . getNames ( pat . m_axis ) ) ; buf . append ( STR_ ) ; if ( x000005000 == pat . m_whatToShow ) { buf . append ( STR_ ) ; } else if ( DTMFilter . SHOW_BYFUNCTION == pat . m_whatToShow ) { buf . append ( STR_ ) ; } else if ( DTMFilter . SHOW_ALL == pat . m_whatToShow ) { buf . append ( STR_ ) ; } else if ( DTMFilter . SHOW_TEXT == pat . m_whatToShow ) { buf . append ( STR_ ) ; } else if ( DTMFilter . SHOW_PROCESSING_INSTRUCTION == pat . m_whatToShow ) { buf . append ( STR_ ) ; if ( null != pat . m_name ) { buf . append ( pat . m_name ) ; } buf . append ( STR_ ) ; } else if ( DTMFilter . SHOW_COMMENT == pat . m_whatToShow ) { buf . append ( STR_ ) ; } else if ( null != pat . m_name ) { if ( DTMFilter . SHOW_ATTRIBUTE == pat . m_whatToShow ) { buf . append ( STR_ ) ; } if ( null != pat . m_namespace ) { buf . append ( STR_ ) ; buf . append ( pat . m_namespace ) ; buf . append ( STR_ ) ; } buf . append ( pat . m_name ) ; } else if ( DTMFilter . SHOW_ATTRIBUTE == pat . m_whatToShow ) { buf . append ( STR_ ) ; } else if ( ( DTMFilter . SHOW_DOCUMENT | DTMFilter . SHOW_DOCUMENT_FRAGMENT ) == pat . m_whatToShow ) { buf . append ( STR_ ) ; } else { buf . append ( STR_ + Integer . toHexString ( pat . m_whatToShow ) ) ; } if ( null != pat . m_predicates ) { for ( int i = NUM_ ; i < pat . m_predicates . length ; i ++ ) { buf . append ( STR_ ) ; buf . append ( pat . m_predicates [ i ] ) ; buf . append ( STR_ ) ; } } } return buf . toString ( ) ; }
public static String byteArrayToHexString ( byte [ ] block , int offset , int length ) { StringBuffer buf = new StringBuffer ( ) ; int len = block . length ; length = length + offset ; if ( ( len < length ) ) { length = len ; } for ( int i = NUM_ + offset ; i < length ; i ++ ) { byte2hex ( block [ i ] , buf ) ; if ( i < length - NUM_ ) { buf . append ( STR_ ) ; } } return buf . toString ( ) ; }
private void changeValue ( AbstractStorageLabel < Object > label , Object newValue ) { if ( ! Objects . equals ( label . getValue ( ) , newValue ) ) { synchronized ( labelEditListeners ) { for ( LabelEditListener listener : labelEditListeners ) { listener . preLabelValueChange ( label ) ; } } label . setValue ( newValue ) ; synchronized ( labelEditListeners ) { for ( LabelEditListener listener : labelEditListeners ) { listener . postLabelValueChange ( label ) ; } } } }
public void write ( byte [ ] b , int offset , int length ) throws IOException { if ( entry . getMethod ( ) == DEFLATED ) { if ( length > NUM_ ) { if ( ! def . finished ( ) ) { def . setInput ( b , offset , length ) ; while ( ! def . needsInput ( ) ) { deflate ( ) ; } } } } else { writeOut ( b , offset , length ) ; written += length ; } crc . update ( b , offset , length ) ; }
public void updatePoint ( float x , float y ) { if ( Math . sqrt ( x . x + y . y ) > NUM_ ) if ( listener != null ) { listener . onAngleChangedListener ( getAngle ( x , - y ) ) ; } }
public final void quietlyJoin ( ) { doJoin ( ) ; }
@ Override public int clampViewPositionHorizontal ( View child , int left , int dx ) { if ( mDraggedView == null ) { return NUM_ ; } final int leftBound = NUM_ - MAX_OVERFLOW - ( mColumnSizeSide / NUM_ ) ; final int rightBound = getWidth ( ) + MAX_OVERFLOW + ( mColumnSizeSide / NUM_ ) ; return Math . min ( Math . max ( left , leftBound ) , rightBound ) ; }
HttpRequestWrapper ( HttpServletRequest request ) { super ( request ) ; }
private int convertToPanelX ( double xval ) { double temp = ( xval - m_minX ) / m_rangeX ; temp = temp . m_panelWidth ; return ( int ) temp ; }
public void forward ( HttpServerRequest request ) { forward ( request , null ) ; }
private Set < String > primaryKeys ( PreparedStatement stmt , String owner , String tbl ) throws SQLException { Set < String > pkCols = new HashSet < > ( ) ; stmt . setString ( NUM_ , owner ) ; stmt . setString ( NUM_ , tbl ) ; try ( ResultSet pkRs = stmt . executeQuery ( ) ) { while ( pkRs . next ( ) ) pkCols . add ( pkRs . getString ( NUM_ ) ) ; } return pkCols ; }
public static long readUINT32 ( InputStream stream ) throws IOException { long result = NUM_ ; for ( int i = NUM_ ; i <= NUM_ ; i += NUM_ ) { result |= ( long ) stream . read ( ) << i ; } return result ; }
private Token toPrefixToken ( ILeafNode leaf ) { Lexer lexer = new InternalN4JSLexer ( ) ; String text = leaf . getText ( ) ; String prefix = text . substring ( NUM_ , endOffset - leaf . getTotalOffset ( ) ) ; ANTLRStringStream stream = new ANTLRStringStream ( prefix ) ; lexer . setCharStream ( stream ) ; Token nextToken = lexer . nextToken ( ) ; return new CommonToken ( nextToken . getType ( ) , nextToken . getText ( ) ) ; }
protected void add ( CSVRecord record ) { records . add ( Objects . requireNonNull ( record ) ) ; }
private void scheduledEnqueueSend ( ) { schedulerQueueSize . decrementAndGet ( ) ; scheduled . set ( BOOL_ ) ; enqueueSendWithErrorLogging ( ) ; }
private E awaitMatch ( Node s , Node pred , E e , boolean timed , long nanos ) { final long deadline = timed ? System . nanoTime ( ) + nanos : NUM_ ; Thread w = Thread . currentThread ( ) ; int spins = - NUM_ ; ThreadLocalRandom randomYields = null ; for ( ; ; ) { Object item = s . item ; if ( item != e ) { s . forgetContents ( ) ; return LinkedTransferQueue . < E > cast ( item ) ; } if ( ( w . isInterrupted ( ) || ( timed && nanos <= NUM_ ) ) && s . casItem ( e , s ) ) { unsplice ( pred , s ) ; return e ; } if ( spins < NUM_ ) { if ( ( spins = spinsFor ( pred , s . isData ) ) > NUM_ ) randomYields = ThreadLocalRandom . current ( ) ; } else if ( spins > NUM_ ) { -- spins ; if ( randomYields . nextInt ( CHAINED_SPINS ) == NUM_ ) Thread . yield ( ) ; } else if ( s . waiter == null ) { s . waiter = w ; } else if ( timed ) { nanos = deadline - System . nanoTime ( ) ; if ( nanos > NUM_ ) LockSupport . parkNanos ( this , nanos ) ; } else { LockSupport . park ( this ) ; } } }
public static String join ( char [ ] self , String separator ) { StringBuilder buffer = new StringBuilder ( ) ; boolean first = BOOL_ ; if ( separator == null ) separator = STR_ ; for ( char next : self ) { if ( first ) { first = BOOL_ ; } else { buffer . append ( separator ) ; } buffer . append ( next ) ; } return buffer . toString ( ) ; }
private < T > BindingAmp < T > findObjectBinding ( Key < T > key ) { Objects . requireNonNull ( key ) ; if ( key . qualifiers ( ) . length != NUM_ ) { throw new IllegalArgumentException ( ) ; } return ( BindingAmp ) findBinding ( Key . of ( Object . class , key . qualifiers ( ) [ NUM_ ] ) ) ; }
private void initComputeProgram ( ) { glUseProgram ( computeProgram ) ; IntBuffer workGroupSize = BufferUtils . createIntBuffer ( NUM_ ) ; glGetProgramiv ( computeProgram , GL_COMPUTE_WORK_GROUP_SIZE , workGroupSize ) ; workGroupSizeX = workGroupSize . get ( NUM_ ) ; workGroupSizeY = workGroupSize . get ( NUM_ ) ; timeUniform = glGetUniformLocation ( computeProgram , STR_ ) ; blendFactorUniform = glGetUniformLocation ( computeProgram , STR_ ) ; lightRadiusUniform = glGetUniformLocation ( computeProgram , STR_ ) ; IntBuffer props = BufferUtils . createIntBuffer ( NUM_ ) ; IntBuffer params = BufferUtils . createIntBuffer ( NUM_ ) ; props . put ( NUM_ , GL_BUFFER_BINDING ) ; int objectsResourceIndex = glGetProgramResourceIndex ( computeProgram , GL_SHADER_STORAGE_BLOCK , STR_ ) ; glGetProgramResourceiv ( computeProgram , GL_SHADER_STORAGE_BLOCK , objectsResourceIndex , props , null , params ) ; objectsSsboBinding = params . get ( NUM_ ) ; int trianglesResourceIndex = glGetProgramResourceIndex ( computeProgram , GL_SHADER_STORAGE_BLOCK , STR_ ) ; glGetProgramResourceiv ( computeProgram , GL_SHADER_STORAGE_BLOCK , trianglesResourceIndex , props , null , params ) ; trianglesSsboBinding = params . get ( NUM_ ) ; int loc = glGetUniformLocation ( computeProgram , STR_ ) ; glGetUniformiv ( computeProgram , loc , params ) ; framebufferImageBinding = params . get ( NUM_ ) ; loc = glGetUniformLocation ( computeProgram , STR_ ) ; glGetUniformiv ( computeProgram , loc , params ) ; worldPositionImageBinding = params . get ( NUM_ ) ; loc = glGetUniformLocation ( computeProgram , STR_ ) ; glGetUniformiv ( computeProgram , loc , params ) ; worldNormalImageBinding = params . get ( NUM_ ) ; glUseProgram ( NUM_ ) ; }
public boolean ifTaskCompletedSuccessOrFailureFromResponse ( ResponseOnSingeRequest myResponse ) { boolean isCompleted = BOOL_ ; try { if ( myResponse == null || myResponse . isFailObtainResponse ( ) ) { return isCompleted ; } String responseBody = myResponse . getResponseBody ( ) ; if ( responseBody . matches ( successRegex ) || responseBody . matches ( failureRegex ) ) { isCompleted = BOOL_ ; } } catch ( Exception t ) { logger . error ( STR_ + t ) ; } return isCompleted ; }
public void centerHorizontal ( ArrayList < Integer > nodes ) { if ( m_bNeedsUndoAction ) { addUndoAction ( new centerHorizontalAction ( nodes ) ) ; } int nMinY = - NUM_ ; int nMaxY = - NUM_ ; for ( int iNode = NUM_ ; iNode < nodes . size ( ) ; iNode ++ ) { int nY = getPositionY ( nodes . get ( iNode ) ) ; if ( nY < nMinY || iNode == NUM_ ) { nMinY = nY ; } if ( nY > nMaxY || iNode == NUM_ ) { nMaxY = nY ; } } for ( int iNode = NUM_ ; iNode < nodes . size ( ) ; iNode ++ ) { int nNode = nodes . get ( iNode ) ; m_nPositionY . set ( nNode , ( nMinY + nMaxY ) / NUM_ ) ; } }
protected void appendText ( final String text ) { if ( text != null ) { textBody . append ( text ) ; } }
public void onRestoreInstanceState ( Bundle savedInstanceState ) { mSelectedPositions . addAll ( savedInstanceState . getIntegerArrayList ( TAG ) ) ; Log . d ( TAG , STR_ + mSelectedPositions ) ; }
public Hour ( int hour , Day day ) { ParamChecks . nullNotPermitted ( day , STR_ ) ; this . hour = ( byte ) hour ; this . day = day ; peg ( Calendar . getInstance ( ) ) ; }
public void undo ( ) { if ( -- m_tempUndoIndex < NUM_ ) { m_tempUndoIndex = m_tempUndoFiles . length - NUM_ ; } if ( m_tempUndoFiles [ m_tempUndoIndex ] != null ) { AbstractFileLoader loader = ConverterUtils . getLoaderForFile ( m_tempUndoFiles [ m_tempUndoIndex ] ) ; try { loader . setFile ( m_tempUndoFiles [ m_tempUndoIndex ] ) ; setInstancesFromFile ( loader ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; m_Log . logMessage ( e . toString ( ) ) ; JOptionPane . showMessageDialog ( PreprocessPanel . this , STR_ + e . toString ( ) , STR_ , JOptionPane . ERROR_MESSAGE ) ; } m_tempUndoFiles [ m_tempUndoIndex ] = null ; } int temp = m_tempUndoIndex - NUM_ ; if ( temp < NUM_ ) { temp = m_tempUndoFiles . length - NUM_ ; } m_UndoBut . setEnabled ( m_tempUndoFiles [ temp ] != null ) ; }
public static boolean isConnectedUsingWifi ( ) { Context context = FeApp . getAppContext ( ) ; ConnectivityManager cm = ( ConnectivityManager ) context . getSystemService ( Context . CONNECTIVITY_SERVICE ) ; NetworkInfo ni = cm . getActiveNetworkInfo ( ) ; return ni != null && ni . isConnected ( ) == BOOL_ && ni . getType ( ) == ConnectivityManager . TYPE_WIFI ; }
public void close ( ) throws IOException { if ( writer != null ) writer . flushBuffer ( ) ; }
public boolean isEmpty ( ) { return extOrdering . isEmpty ( ) ; }
public Process ( final File file , final ProgressListener progressListener ) throws IOException , XMLException { this . processLocation = new FileProcessLocation ( file ) ; initContext ( ) ; Reader in = null ; try { in = new InputStreamReader ( new FileInputStream ( file ) , STR_ ) ; readProcess ( in , progressListener ) ; } catch ( IOException e ) { throw e ; } finally { if ( in != null ) { in . close ( ) ; } } }
public static String extractMusicIDFromMediaID ( @ NonNull String mediaID ) { int pos = mediaID . indexOf ( LEAF_SEPARATOR ) ; if ( pos >= NUM_ ) { return mediaID . substring ( pos + NUM_ ) ; } return null ; }
public void testGetScope ( ) throws Exception { Identity i = new IdentityStub ( STR_ ) ; assertNull ( i . getScope ( ) ) ; IdentityScope s = IdentityScope . getSystemScope ( ) ; Identity i2 = new IdentityStub ( STR_ , s ) ; assertSame ( s , i2 . getScope ( ) ) ; }
public Object [ ] buildParameters ( Object [ ] firstParameters , Method method , Class < ? extends Annotation > annotationType ) { int parametersLength = method . getParameterTypes ( ) . length ; if ( firstParameters . length > NUM_ && parametersLength < NUM_ ) { throw new RepositoryMethodException ( String . format ( STR_ , annotationType ) ) ; } int parametersToResolve = parametersLength - firstParameters . length ; Object [ ] additionalParameters = new Object [ parametersToResolve ] ; for ( int i = firstParameters . length ; i < parametersLength ; i ++ ) { additionalParameters [ i - firstParameters . length ] = parameterProvider . provide ( method , i ) ; } return concatenate ( firstParameters , additionalParameters ) ; }
@ Override public boolean contains ( S2Cell cell ) { return contains ( cell . id ( ) ) ; }
public SimplexNoiseGenerator ( Random rand ) { super ( rand ) ; offsetW = rand . nextDouble ( ) . NUM_ ; }
public static long [ ] values ( Long [ ] array ) { long [ ] dest = new long [ array . length ] ; for ( int i = NUM_ ; i < array . length ; i ++ ) { Long v = array [ i ] ; if ( v != null ) { dest [ i ] = v . longValue ( ) ; } } return dest ; }
@ Override public void processNewLines ( String [ ] lines ) { for ( String line : lines ) { if ( line . startsWith ( STR_ ) ) { continue ; } if ( line . contains ( STR_ ) ) { myIsFileMissing = BOOL_ ; return ; } String [ ] values = line . split ( LINE_SPLIT_REGEX ) ; if ( values . length < INDEX_OF_TX_BYTES ) { continue ; } try { int lineUid = Integer . parseInt ( values [ INDEX_OF_UID ] ) ; if ( myUid == lineUid ) { int tempRxBytes = Integer . parseInt ( values [ INDEX_OF_RX_BYTES ] ) ; int tempTxBytes = Integer . parseInt ( values [ INDEX_OF_TX_BYTES ] ) ; if ( tempRxBytes < NUM_ || tempTxBytes < NUM_ ) { LOG . warning ( String . format ( STR_ , tempRxBytes , tempTxBytes , line ) ) ; continue ; } myRxBytes += tempRxBytes ; myTxBytes += tempTxBytes ; } } catch ( NumberFormatException e ) { LOG . warning ( String . format ( STR_ , values [ INDEX_OF_UID ] , values [ INDEX_OF_RX_BYTES ] , values [ INDEX_OF_TX_BYTES ] , line ) ) ; } } }
protected void initLookup ( ) { m_lookup = new HashMap ( ) ; for ( int i = NUM_ ; i < m_names . length ; ++ i ) { m_lookup . put ( m_names [ i ] , new Integer ( i ) ) ; } }
public String toString ( ) { String str = STR_ ; String followedBy = STR_ ; int lastType = - NUM_ ; String lastString = STR_ ; int singlesCount = NUM_ ; for ( Enumeration e = formatConstraints . elements ( ) ; e . hasMoreElements ( ) ; ) { FormatConstraint constraint = ( FormatConstraint ) e . nextElement ( ) ; if ( constraint . count == FormatConstraint . COUNT_EXACTLY_ONE ) { if ( lastType != - NUM_ ) { if ( lastType != constraint . type ) { str += followedBy + singlesCount + lastString ; followedBy = STR_ ; singlesCount = NUM_ ; lastType = constraint . type ; lastString = constraint . toString ( ) ; } else { singlesCount ++ ; } } else { lastType = constraint . type ; lastString = constraint . toString ( ) ; singlesCount = NUM_ ; } } else { if ( lastType != - NUM_ ) { str += followedBy + singlesCount + lastString ; followedBy = STR_ ; lastType = - NUM_ ; singlesCount = NUM_ ; lastString = STR_ ; } str += followedBy + constraint . toString ( ) ; followedBy = STR_ ; } } if ( lastType != - NUM_ ) { str += followedBy + singlesCount + lastString ; } return str ; }
public void readData ( DataInput din ) throws IOException { din . readShort ( ) ; count = din . readUnsignedShort ( ) ; registers = new InputRegister [ count ] ; for ( int i = NUM_ ; i < count ; i ++ ) { registers [ i ] = new SimpleInputRegister ( din . readShort ( ) ) ; } }
public void adjustIndentation ( int delta ) { if ( delta < NUM_ ) { indentationLevel = Math . max ( NUM_ , indentationLevel + delta ) ; } else { indentationLevel += delta ; } }
public int capacity ( ) { return capacity . get ( ) ; }
protected static token do_code_string ( ) throws java . io . IOException { StringBuffer result = new StringBuffer ( ) ; advance ( ) ; advance ( ) ; while ( ! ( next_char == STR_ && next_char2 == STR_ ) ) { if ( next_char == EOF_CHAR ) { emit_error ( STR_ ) ; break ; } result . append ( new Character ( ( char ) next_char ) ) ; advance ( ) ; } advance ( ) ; advance ( ) ; return new str_token ( sym . CODE_STRING , result . toString ( ) ) ; }
public String random ( Object omin , Object omax ) { int min = FunctionHandler . getInt ( omin ) ; int max = FunctionHandler . getInt ( omax ) ; if ( max > min ) { return Integer . toString ( rnd . nextInt ( max - min ) + min ) ; } return STR_ ; }
public void test_reopen01 ( ) { final IRawStore store = new SimpleMemoryRawStore ( ) ; final BTree btree ; { IndexMetadata md = new IndexMetadata ( UUID . randomUUID ( ) ) ; md . setBranchingFactor ( NUM_ ) ; btree = BTree . create ( store , md ) ; } assertTrue ( btree . isOpen ( ) ) ; btree . close ( ) ; assertFalse ( btree . isOpen ( ) ) ; try { btree . close ( ) ; fail ( STR_ + IllegalStateException . class ) ; } catch ( IllegalStateException ex ) { if ( log . isInfoEnabled ( ) ) log . info ( STR_ + ex ) ; } assertNotNull ( btree . getRoot ( ) ) ; assertTrue ( btree . isOpen ( ) ) ; }
public static File searchPaths ( Iterable < ? extends File > paths , String relFile ) { for ( File path : paths ) { File f = new File ( path , relFile ) ; if ( f . exists ( ) ) { return path ; } } return null ; }
public boolean hasUnsupportedCriticalExtension ( ) { Set extns = getCriticalExtensionOIDs ( ) ; return extns != null && ! extns . isEmpty ( ) ; }
private static String doNormalize ( String filename , char separator , boolean keepSeparator ) { if ( filename == null ) { return null ; } int size = filename . length ( ) ; if ( size == NUM_ ) { return filename ; } int prefix = getPrefixLength ( filename ) ; if ( prefix < NUM_ ) { return null ; } char [ ] array = new char [ size + NUM_ ] ; filename . getChars ( NUM_ , filename . length ( ) , array , NUM_ ) ; char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ; for ( int i = NUM_ ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; } } boolean lastIsDirectory = BOOL_ ; if ( array [ size - NUM_ ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = BOOL_ ; } for ( int i = prefix + NUM_ ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - NUM_ ] == separator ) { System . arraycopy ( array , i , array , i - NUM_ , size - i ) ; size -- ; i -- ; } } for ( int i = prefix + NUM_ ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - NUM_ ] == STR_ && ( i == prefix + NUM_ || array [ i - NUM_ ] == separator ) ) { if ( i == size - NUM_ ) { lastIsDirectory = BOOL_ ; } System . arraycopy ( array , i + NUM_ , array , i - NUM_ , size - i ) ; size -= NUM_ ; i -- ; } } outer : for ( int i = prefix + NUM_ ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - NUM_ ] == STR_ && array [ i - NUM_ ] == STR_ && ( i == prefix + NUM_ || array [ i - NUM_ ] == separator ) ) { if ( i == prefix + NUM_ ) { return null ; } if ( i == size - NUM_ ) { lastIsDirectory = BOOL_ ; } int j ; for ( j = i - NUM_ ; j >= prefix ; j -- ) { if ( array [ j ] == separator ) { System . arraycopy ( array , i + NUM_ , array , j + NUM_ , size - i ) ; size -= i - j ; i = j + NUM_ ; continue outer ; } } System . arraycopy ( array , i + NUM_ , array , prefix , size - i ) ; size -= i + NUM_ - prefix ; i = prefix + NUM_ ; } } if ( size <= NUM_ ) { return STR_ ; } if ( size <= prefix ) { return new String ( array , NUM_ , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , NUM_ , size ) ; } return new String ( array , NUM_ , size - NUM_ ) ; }
@ Override public StringBuffer format ( double value , StringBuffer buffer , FieldPosition field ) { for ( int i = choiceLimits . length - NUM_ ; i >= NUM_ ; i -- ) { if ( choiceLimits [ i ] <= value ) { return buffer . append ( choiceFormats [ i ] ) ; } } return choiceFormats . length == NUM_ ? buffer : buffer . append ( choiceFormats [ NUM_ ] ) ; }
private void loadConfigurationFromJvmParameters ( ) { String repositoryProperty = System . getProperty ( REPOSITORY_PROPERTY ) ; if ( null != repositoryProperty ) { String [ ] repositoryIpHost = repositoryProperty . split ( STR_ ) ; if ( repositoryIpHost . length == NUM_ ) { String repositoryIp = repositoryIpHost [ NUM_ ] ; String repositoryPort = repositoryIpHost [ NUM_ ] ; if ( StringUtils . isNotBlank ( repositoryIp ) && StringUtils . isNotBlank ( repositoryPort ) ) { log . info ( STR_ + repositoryIp + STR_ + repositoryPort ) ; try { int port = Integer . parseInt ( repositoryPort ) ; setRepository ( repositoryIp , port ) ; } catch ( Exception e ) { log . warn ( STR_ , e ) ; } } } } String agentName = System . getProperty ( AGENT_NAME_PROPERTY ) ; if ( StringUtils . isNotBlank ( agentName ) ) { try { log . info ( STR_ + agentName ) ; setAgentName ( agentName ) ; } catch ( Exception e ) { log . warn ( STR_ , e ) ; } } else { try { setAgentName ( DEFAULT_AGENT_NAME ) ; } catch ( StorageException e ) { log . warn ( STR_ , e ) ; } } }
public boolean softSignin ( ) throws IOException { if ( url == null ) { throw new IllegalStateException ( STR_ ) ; } checkResolveHost ( ) ; if ( sessionId != null ) { if ( checkAuthorized ( getAuthCheckUrl ( sessionId ) ) ) { LOGGER . fine ( STR_ + sessionId ) ; return BOOL_ ; } else { sessionId = null ; } } long id = loadSessionId ( ) ; if ( id == NUM_ ) { return BOOL_ ; } boolean authorized = checkAuthorized ( getAuthCheckUrl ( id ) ) ; if ( authorized ) { LOGGER . info ( STR_ + id ) ; this . sessionId = id ; } return authorized ; }
private void testViewAlterAndCommandCache ( ) throws SQLException { deleteDb ( STR_ ) ; Connection conn = getConnection ( STR_ ) ; Statement stat = conn . createStatement ( ) ; stat . execute ( STR_ ) ; stat . execute ( STR_ ) ; stat . execute ( STR_ ) ; stat . execute ( STR_ ) ; stat . execute ( STR_ ) ; ResultSet rs = stat . executeQuery ( STR_ ) ; assertTrue ( rs . next ( ) ) ; assertEquals ( NUM_ , rs . getInt ( NUM_ ) ) ; stat . execute ( STR_ ) ; rs = stat . executeQuery ( STR_ ) ; assertTrue ( rs . next ( ) ) ; assertEquals ( NUM_ , rs . getInt ( NUM_ ) ) ; conn . close ( ) ; deleteDb ( STR_ ) ; }
protected static boolean approxUnit ( final StringBuilder sbuf , final int amount , final int size , final String name ) { int count = amount / size ; int remainder ; if ( count == NUM_ ) { return BOOL_ ; } remainder = amount - ( count . size ) ; if ( remainder >= ( size . NUM_ / NUM_ ) ) { count ++ ; sbuf . append ( count ) ; } else if ( remainder >= ( size . NUM_ / NUM_ ) ) { count ++ ; sbuf . append ( STR_ ) ; sbuf . append ( count ) ; } else if ( remainder >= ( size . NUM_ / NUM_ ) ) { sbuf . append ( STR_ ) ; sbuf . append ( count ) ; sbuf . append ( STR_ ) ; count = NUM_ ; } else if ( remainder >= ( size . NUM_ / NUM_ ) ) { sbuf . append ( STR_ ) ; sbuf . append ( count ) ; } else { sbuf . append ( count ) ; } sbuf . append ( STR_ ) ; sbuf . append ( Grammar . plnoun ( count , name ) ) ; return BOOL_ ; }
public static Element createElement ( Document doc , String tag , String nsURI , String prefix ) { String qName = ( prefix == null || prefix . length ( ) == NUM_ ) ? tag : prefix + STR_ + tag ; return doc . createElementNS ( nsURI , qName ) ; }
public static void modifyFile ( File file , Function < String , String > modifier ) throws IOException { String content = new String ( Files . toByteArray ( file ) , StandardCharsets . UTF_8 ) ; String result = modifier . apply ( content ) ; Files . write ( result . getBytes ( StandardCharsets . UTF_8 ) , file ) ; }
private void state2 ( ) throws IOException { int [ ] selectionIds = readList ( new File ( filePrefix + STR_ ) ) ; int [ ] archivedIds = readList ( new File ( filePrefix + STR_ ) ) ; int [ ] variationIds = new int [ lambda ] ; if ( selectionIds . length != mu ) { throw new IOException ( STR_ ) ; } updatePopulation ( archivedIds ) ; clearFile ( new File ( filePrefix + STR_ ) ) ; clearFile ( new File ( filePrefix + STR_ ) ) ; List < Solution > offspring = new ArrayList < Solution > ( ) ; for ( int i = NUM_ ; i < mu ; i += variation . getArity ( ) ) { Solution [ ] parents = new Solution [ variation . getArity ( ) ] ; for ( int j = NUM_ ; j < variation . getArity ( ) ; j ++ ) { parents [ j ] = solutions . get ( selectionIds [ i + j ] ) ; } offspring . addAll ( Arrays . asList ( variation . evolve ( parents ) ) ) ; } if ( offspring . size ( ) != lambda ) { throw new IOException ( STR_ ) ; } evaluateAll ( offspring ) ; for ( int i = NUM_ ; i < lambda ; i ++ ) { variationIds [ i ] = addToPopulation ( offspring . get ( i ) ) ; } writePopulation ( new File ( filePrefix + STR_ ) , variationIds ) ; }
public void testListOptions ( ) { if ( m_OptionTester . getOptionHandler ( ) != null ) { if ( ! m_OptionTester . checkListOptions ( ) ) fail ( STR_ ) ; } }
protected double LLToWorldReturningLon ( double lat , double lon , Point2D lp ) { double phi_deg = lat ; double phi = ProjMath . degToRad ( phi_deg ) ; double lamba_deg = lon ; double lamba = ProjMath . degToRad ( lamba_deg ) ; double dlamda = lamba - lamdaf ; if ( dlamda > Math . PI ) { dlamda -= MoreMath . TWO_PI_D ; } else if ( dlamda < - Math . PI ) { dlamda += MoreMath . TWO_PI_D ; } double e = ellps . ecc ; double r = NUM_ ; if ( ! MoreMath . approximately_equal ( Math . abs ( phi ) , MoreMath . HALF_PI , EPS10 ) ) { double t = lambTsfn ( phi , Math . sin ( phi ) , e ) ; r = ellps . radius . F . Math . pow ( t , n ) ; } double theta = n . dlamda ; double easting = falseEasting + r . Math . sin ( theta - alpha ) ; double northing = falseNorthing + rf - r . Math . cos ( theta - alpha ) ; lp . setLocation ( easting , northing ) ; return dlamda ; }
protected void notifySizeChanged ( float width , float height , int orientation ) { }
protected boolean removeTurntable ( LayoutTurntable o ) { if ( ! noWarnTurntable ) { int selectedValue = JOptionPane . showOptionDialog ( this , rb . getString ( STR_ ) , Bundle . getMessage ( STR_ ) , JOptionPane . YES_NO_CANCEL_OPTION , JOptionPane . QUESTION_MESSAGE , null , new Object [ ] { Bundle . getMessage ( STR_ ) , Bundle . getMessage ( STR_ ) , rb . getString ( STR_ ) } , Bundle . getMessage ( STR_ ) ) ; if ( selectedValue == NUM_ ) { return ( BOOL_ ) ; } if ( selectedValue == NUM_ ) { noWarnTurntable = BOOL_ ; } } if ( selectedObject == o ) { selectedObject = null ; } if ( prevSelectedObject == o ) { prevSelectedObject = null ; } for ( int j = NUM_ ; j < o . getNumberRays ( ) ; j ++ ) { TrackSegment t = o . getRayConnectOrdered ( j ) ; if ( t != null ) { substituteAnchor ( o . getRayCoordsIndexed ( j ) , o , t ) ; } } for ( int i = NUM_ ; i < turntableList . size ( ) ; i ++ ) { LayoutTurntable lx = turntableList . get ( i ) ; if ( lx == o ) { turntableList . remove ( i ) ; o . remove ( ) ; setDirty ( BOOL_ ) ; repaint ( ) ; return ( BOOL_ ) ; } } return ( BOOL_ ) ; }
@ Override public final void endElement ( final String ns , final String lName , final String qName ) throws SAXException { String name = lName == null || lName . length ( ) == NUM_ ? qName : lName ; Rule r = ( Rule ) RULES . match ( match ) ; if ( r != null ) { r . end ( name ) ; } int slash = match . lastIndexOf ( STR_ ) ; if ( slash >= NUM_ ) { match = match . substring ( NUM_ , slash ) ; } else { match = STR_ ; } }
public INDArray asMatrix ( BufferedImage image ) { if ( channels == NUM_ ) { return toBgr ( image ) ; } else { image = scalingIfNeed ( image , BOOL_ ) ; int w = image . getWidth ( ) ; int h = image . getHeight ( ) ; INDArray ret = Nd4j . create ( h , w ) ; for ( int i = NUM_ ; i < h ; i ++ ) { for ( int j = NUM_ ; j < w ; j ++ ) { ret . putScalar ( new int [ ] { i , j } , image . getRGB ( i , j ) ) ; } } return ret ; } }
public FileSystemUtils ( ) { super ( ) ; }
public int scheduledQueueSize ( ) { return schedulerQueueSize . get ( ) ; }
public DGeneralNameChooser ( JFrame parent , String title , GeneralName generalName ) { super ( parent , title , ModalityType . DOCUMENT_MODAL ) ; initComponents ( generalName ) ; }
public void destroyScene ( ) { clearAnimations ( ) ; clearCameras ( ) ; clearLights ( ) ; clearPlugins ( ) ; clearChildren ( ) ; clearFrameCallbacks ( ) ; }
private static Platform findPlatform ( ) { try { try { Class . forName ( STR_ ) ; } catch ( ClassNotFoundException e ) { Class . forName ( STR_ ) ; } OptionalMethod < Socket > setUseSessionTickets = new OptionalMethod < > ( null , STR_ , boolean . class ) ; OptionalMethod < Socket > setHostname = new OptionalMethod < > ( null , STR_ , String . class ) ; Method trafficStatsTagSocket = null ; Method trafficStatsUntagSocket = null ; OptionalMethod < Socket > getAlpnSelectedProtocol = null ; OptionalMethod < Socket > setAlpnProtocols = null ; try { Class < ? > trafficStats = Class . forName ( STR_ ) ; trafficStatsTagSocket = trafficStats . getMethod ( STR_ , Socket . class ) ; trafficStatsUntagSocket = trafficStats . getMethod ( STR_ , Socket . class ) ; try { Class . forName ( STR_ ) ; getAlpnSelectedProtocol = new OptionalMethod < > ( byte [ ] . class , STR_ ) ; setAlpnProtocols = new OptionalMethod < > ( null , STR_ , byte [ ] . class ) ; } catch ( ClassNotFoundException ignored ) { } } catch ( ClassNotFoundException | NoSuchMethodException ignored ) { } return new Android ( setUseSessionTickets , setHostname , trafficStatsTagSocket , trafficStatsUntagSocket , getAlpnSelectedProtocol , setAlpnProtocols ) ; } catch ( ClassNotFoundException ignored ) { } try { String negoClassName = STR_ ; Class < ? > negoClass = Class . forName ( negoClassName ) ; Class < ? > providerClass = Class . forName ( negoClassName + STR_ ) ; Class < ? > clientProviderClass = Class . forName ( negoClassName + STR_ ) ; Class < ? > serverProviderClass = Class . forName ( negoClassName + STR_ ) ; Method putMethod = negoClass . getMethod ( STR_ , SSLSocket . class , providerClass ) ; Method getMethod = negoClass . getMethod ( STR_ , SSLSocket . class ) ; Method removeMethod = negoClass . getMethod ( STR_ , SSLSocket . class ) ; return new JdkWithJettyBootPlatform ( putMethod , getMethod , removeMethod , clientProviderClass , serverProviderClass ) ; } catch ( ClassNotFoundException | NoSuchMethodException ignored ) { } return new Platform ( ) ; }
private void addLimitedMitreJoin ( LineSegment offset0 , LineSegment offset1 , double distance , double mitreLimit ) { Coordinate basePt = seg0 . p1 ; double ang0 = Angle . angle ( basePt , seg0 . p0 ) ; double ang1 = Angle . angle ( basePt , seg1 . p1 ) ; double angDiff = Angle . angleBetweenOriented ( seg0 . p0 , basePt , seg1 . p1 ) ; double angDiffHalf = angDiff / NUM_ ; double midAng = Angle . normalize ( ang0 + angDiffHalf ) ; double mitreMidAng = Angle . normalize ( midAng + Math . PI ) ; double mitreDist = mitreLimit . distance ; double bevelDelta = mitreDist . Math . abs ( Math . sin ( angDiffHalf ) ) ; double bevelHalfLen = distance - bevelDelta ; double bevelMidX = basePt . x + mitreDist . Math . cos ( mitreMidAng ) ; double bevelMidY = basePt . y + mitreDist . Math . sin ( mitreMidAng ) ; Coordinate bevelMidPt = new Coordinate ( bevelMidX , bevelMidY ) ; LineSegment mitreMidLine = new LineSegment ( basePt , bevelMidPt ) ; Coordinate bevelEndLeft = mitreMidLine . pointAlongOffset ( NUM_ , bevelHalfLen ) ; Coordinate bevelEndRight = mitreMidLine . pointAlongOffset ( NUM_ , - bevelHalfLen ) ; if ( side == Position . LEFT ) { segList . addPt ( bevelEndLeft ) ; segList . addPt ( bevelEndRight ) ; } else { segList . addPt ( bevelEndRight ) ; segList . addPt ( bevelEndLeft ) ; } }
static byte [ ] discardNonBase64 ( byte [ ] data ) { byte groomedData [ ] = new byte [ data . length ] ; int bytesCopied = NUM_ ; for ( int i = NUM_ ; i < data . length ; i ++ ) { if ( isBase64 ( data [ i ] ) ) { groomedData [ bytesCopied ++ ] = data [ i ] ; } } byte packedData [ ] = new byte [ bytesCopied ] ; System . arraycopy ( groomedData , NUM_ , packedData , NUM_ , bytesCopied ) ; return packedData ; }
public void testMultiplyDiffScalePosNeg ( ) { String a = STR_ ; int aScale = NUM_ ; String b = STR_ ; int bScale = - NUM_ ; String c = STR_ ; int cScale = NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal bNumber = new BigDecimal ( new BigInteger ( b ) , bScale ) ; BigDecimal result = aNumber . multiply ( bNumber ) ; assertEquals ( STR_ , c , result . toString ( ) ) ; assertEquals ( STR_ , cScale , result . scale ( ) ) ; }
private static long limitDuration ( long leaseDuration , long limit ) { if ( leaseDuration == Lease . ANY || leaseDuration > limit ) leaseDuration = limit ; else if ( leaseDuration < NUM_ ) throw new IllegalArgumentException ( STR_ ) ; return leaseDuration ; }
static String pathToCookiePath ( String path ) { if ( path == null ) { return STR_ ; } int lastSlash = path . lastIndexOf ( STR_ ) ; return path . substring ( NUM_ , lastSlash + NUM_ ) ; }
public static String formatSimpleDecimal ( double d ) { return simpleFormat . format ( d ) ; }
protected AbstractCategoryItemLabelGenerator ( String labelFormat , DateFormat formatter ) { ParamChecks . nullNotPermitted ( labelFormat , STR_ ) ; ParamChecks . nullNotPermitted ( formatter , STR_ ) ; this . labelFormat = labelFormat ; this . numberFormat = null ; this . percentFormat = NumberFormat . getPercentInstance ( ) ; this . dateFormat = formatter ; this . nullValueString = STR_ ; }
public void delItems ( int s , int e ) { boolean hsbWasVisible = hsbVis ; boolean vsbWasVisible = vsbVis ; int oldLastDisplayed = lastItemDisplayed ( ) ; if ( log . isLoggable ( PlatformLogger . Level . FINE ) ) { log . fine ( STR_ + s + STR_ + e ) ; } if ( log . isLoggable ( PlatformLogger . Level . FINEST ) ) { log . finest ( STR_ + oldLastDisplayed + STR_ + itemsInWindow ( ) + STR_ + items . size ( ) ) ; } if ( items . size ( ) == NUM_ ) { return ; } if ( s > e ) { int tmp = s ; s = e ; e = tmp ; } if ( s < NUM_ ) { s = NUM_ ; } if ( e >= items . size ( ) ) { e = items . size ( ) - NUM_ ; } boolean repaintNeeded = ( s >= getFirstVisibleItem ( ) && s <= getLastVisibleItem ( ) ) ; for ( int i = s ; i <= e ; i ++ ) { items . removeElementAt ( s ) ; int j = posInSel ( i ) ; if ( j != - NUM_ ) { int newsel [ ] = new int [ selected . length - NUM_ ] ; System . arraycopy ( selected , NUM_ , newsel , NUM_ , j ) ; System . arraycopy ( selected , j + NUM_ , newsel , j , selected . length - ( j + NUM_ ) ) ; selected = newsel ; } } int diff = ( e - s ) + NUM_ ; for ( int i = NUM_ ; i < selected . length ; i ++ ) { if ( selected [ i ] > e ) { selected [ i ] -= diff ; } } int options = PAINT_VSCROLL ; if ( getFocusIndex ( ) > e ) { setFocusIndex ( getFocusIndex ( ) - ( e - s + NUM_ ) ) ; options |= PAINT_FOCUS ; } else if ( getFocusIndex ( ) >= s && getFocusIndex ( ) <= e ) { int focusBound = ( items . size ( ) > NUM_ ) ? NUM_ : - NUM_ ; setFocusIndex ( Math . max ( s - NUM_ , focusBound ) ) ; options |= PAINT_FOCUS ; } if ( log . isLoggable ( PlatformLogger . Level . FINEST ) ) { log . finest ( STR_ + multipleSelections ) ; } if ( vsb . getValue ( ) >= s ) { if ( vsb . getValue ( ) <= e ) { vsb . setValue ( e + NUM_ - diff ) ; } else { vsb . setValue ( vsb . getValue ( ) - diff ) ; } } int oldMaxLength = maxLength ; maxLength = maxLength ( ) ; if ( maxLength != oldMaxLength ) { options |= PAINT_HSCROLL ; } layout ( ) ; repaintNeeded |= ( vsbWasVisible ^ vsbVis ) || ( hsbWasVisible ^ hsbVis ) ; if ( repaintNeeded ) { options |= PAINT_ALL ; } repaint ( s , oldLastDisplayed , options ) ; }
static long makeId ( SnmpOid oid ) { long id = NUM_ ; long [ ] arcs = oid . longValue ( BOOL_ ) ; id |= arcs [ NUM_ ] << NUM_ ; id |= arcs [ NUM_ ] << NUM_ ; id |= arcs [ NUM_ ] << NUM_ ; id |= arcs [ NUM_ ] << NUM_ ; id |= arcs [ NUM_ ] << NUM_ ; id |= arcs [ NUM_ ] << NUM_ ; id |= arcs [ NUM_ ] << NUM_ ; id |= arcs [ NUM_ ] ; return id ; }
private void cacheAttribute ( String attrId , byte [ ] [ ] values ) { String cacheKey = name + STR_ + attrId ; valueCache . put ( cacheKey , values ) ; }
void read ( Reader policy ) throws ParsingException , IOException { if ( ! ( policy instanceof BufferedReader ) ) { policy = new BufferedReader ( policy ) ; } st = new StreamTokenizer ( policy ) ; st . resetSyntax ( ) ; st . wordChars ( STR_ , STR_ ) ; st . wordChars ( STR_ , STR_ ) ; st . wordChars ( STR_ , STR_ ) ; st . wordChars ( STR_ , STR_ ) ; st . wordChars ( STR_ , STR_ ) ; st . wordChars ( STR_ , STR_ ) ; st . wordChars ( NUM_ + NUM_ , NUM_ ) ; st . whitespaceChars ( NUM_ , STR_ ) ; st . commentChar ( STR_ ) ; st . quoteChar ( STR_ ) ; st . quoteChar ( STR_ ) ; st . lowerCaseMode ( BOOL_ ) ; st . ordinaryChar ( STR_ ) ; st . slashSlashComments ( BOOL_ ) ; st . slashStarComments ( BOOL_ ) ; st . parseNumbers ( ) ; Hashtable < String , Vector < String > > processedPermissions = null ; lookahead = st . nextToken ( ) ; while ( lookahead != StreamTokenizer . TT_EOF ) { if ( peek ( STR_ ) ) { GrantEntry ge = parseGrantEntry ( processedPermissions ) ; if ( ge != null ) grantEntries . addElement ( ge ) ; } else { throw new ParsingException ( st . lineno ( ) , STR_ + STR_ ) ; } match ( STR_ ) ; } }
protected void injectIntoVolumeInformationContainer ( Map < String , StringSet > volumeInformation , String infoKey , String altKey , CIMInstance volumeInstance ) { Object value = getCIMPropertyValue ( volumeInstance , infoKey ) ; if ( null == value ) { value = getCIMPropertyValue ( volumeInstance , altKey ) ; } String charactersticName = SupportedVolumeInformation . getVolumeInformation ( infoKey ) ; if ( null != value && null != charactersticName ) { StringSet valueSet = new StringSet ( ) ; if ( value instanceof String ) { valueSet . add ( value . toString ( ) ) ; } else if ( value instanceof String [ ] ) { valueSet . addAll ( Arrays . asList ( ( String [ ] ) value ) ) ; } volumeInformation . put ( charactersticName , valueSet ) ; } }
@ Override public void onDetachedFromRecyclerView ( RecyclerView recyclerView ) { super . onDetachedFromRecyclerView ( recyclerView ) ; mAttachedRecyclerViewPool . remove ( recyclerView ) ; }
private void loadFile ( String filename , AbstractFileLoader ... loaders ) { ArffSortedTableModel model ; this . m_Filename = filename ; createTitle ( ) ; if ( filename . equals ( STR_ ) ) { model = null ; } else { model = new ArffSortedTableModel ( filename , loaders ) ; model . setShowAttributeIndex ( getShowAttributeIndex ( ) ) ; } m_TableArff . setModel ( model ) ; setChanged ( BOOL_ ) ; createName ( ) ; }
private void destinationTypeChanged ( ) { if ( m_Exp == null ) return ; String str = STR_ ; if ( m_ResultsDestinationCBox . getSelectedItem ( ) == DEST_DATABASE_TEXT ) { m_ResultsDestinationPathLabel . setText ( STR_ ) ; str = m_destinationDatabaseURL ; m_BrowseDestinationButton . setEnabled ( BOOL_ ) ; m_BrowseDestinationButton . setText ( STR_ ) ; } else { m_ResultsDestinationPathLabel . setText ( STR_ ) ; if ( m_ResultsDestinationCBox . getSelectedItem ( ) == DEST_ARFF_TEXT ) { int ind = m_destinationFilename . lastIndexOf ( STR_ ) ; if ( ind > - NUM_ ) { m_destinationFilename = m_destinationFilename . substring ( NUM_ , ind ) + STR_ ; } } if ( m_ResultsDestinationCBox . getSelectedItem ( ) == DEST_CSV_TEXT ) { int ind = m_destinationFilename . lastIndexOf ( STR_ ) ; if ( ind > - NUM_ ) { m_destinationFilename = m_destinationFilename . substring ( NUM_ , ind ) + STR_ ; } } str = m_destinationFilename ; if ( m_ResultsDestinationCBox . getSelectedItem ( ) == DEST_ARFF_TEXT ) { int ind = str . lastIndexOf ( STR_ ) ; if ( ind > - NUM_ ) { str = str . substring ( NUM_ , ind ) + STR_ ; } } if ( m_ResultsDestinationCBox . getSelectedItem ( ) == DEST_CSV_TEXT ) { int ind = str . lastIndexOf ( STR_ ) ; if ( ind > - NUM_ ) { str = str . substring ( NUM_ , ind ) + STR_ ; } } m_BrowseDestinationButton . setEnabled ( BOOL_ ) ; m_BrowseDestinationButton . setText ( STR_ ) ; } if ( m_ResultsDestinationCBox . getSelectedItem ( ) == DEST_DATABASE_TEXT ) { DatabaseResultListener drl = null ; try { drl = new DatabaseResultListener ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } drl . setDatabaseURL ( m_destinationDatabaseURL ) ; m_Exp . setResultListener ( drl ) ; } else { if ( m_ResultsDestinationCBox . getSelectedItem ( ) == DEST_ARFF_TEXT ) { InstancesResultListener irl = new InstancesResultListener ( ) ; if ( ! m_destinationFilename . equals ( STR_ ) ) { irl . setOutputFile ( new File ( m_destinationFilename ) ) ; } m_Exp . setResultListener ( irl ) ; } else if ( m_ResultsDestinationCBox . getSelectedItem ( ) == DEST_CSV_TEXT ) { CSVResultListener crl = new CSVResultListener ( ) ; if ( ! m_destinationFilename . equals ( STR_ ) ) { crl . setOutputFile ( new File ( m_destinationFilename ) ) ; } m_Exp . setResultListener ( crl ) ; } } m_ResultsDestinationPathTField . setText ( str ) ; m_Support . firePropertyChange ( STR_ , null , null ) ; }
public static InputStream tryGzipInput ( InputStream in ) throws IOException { if ( ! in . markSupported ( ) ) { PushbackInputStream pb = new PushbackInputStream ( in , NUM_ ) ; in = pb ; byte [ ] magic = { NUM_ , NUM_ } ; pb . read ( magic ) ; pb . unread ( magic ) ; if ( magic [ NUM_ ] == NUM_ && magic [ NUM_ ] == - NUM_ ) { return new GZIPInputStream ( pb ) ; } return in ; } in . mark ( NUM_ ) ; boolean isgzip = ( in . read ( ) == NUM_ && in . read ( ) == - NUM_ ) ; in . reset ( ) ; if ( isgzip ) { in = new GZIPInputStream ( in ) ; } return in ; }
@ Override public int hashCode ( ) { if ( location != null ) return location . hashCode ( ) ; else return NUM_ ; }
public static Query newPrefixQuery ( String field , InetAddress value , int prefixLength ) { if ( value == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( prefixLength < NUM_ || prefixLength > NUM_ . value . getAddress ( ) . length ) { throw new IllegalArgumentException ( STR_ + prefixLength + STR_ ) ; } byte lower [ ] = value . getAddress ( ) ; byte upper [ ] = value . getAddress ( ) ; for ( int i = prefixLength ; i < NUM_ . lower . length ; i ++ ) { int m = NUM_ << ( NUM_ - ( i & NUM_ ) ) ; lower [ i > > NUM_ ] &= ~ m ; upper [ i > > NUM_ ] |= m ; } try { return newRangeQuery ( field , InetAddress . getByAddress ( lower ) , InetAddress . getByAddress ( upper ) ) ; } catch ( UnknownHostException e ) { throw new AssertionError ( e ) ; } }
public static Subject createAMIdentitySubject ( PolicyManager pm , AMIdentity user ) throws PolicyException { SubjectTypeManager mgr = pm . getSubjectTypeManager ( ) ; Subject subject = mgr . getSubject ( STR_ ) ; Set < String > set = new HashSet < String > ( ) ; set . add ( user . getUniversalId ( ) ) ; subject . setValues ( set ) ; return subject ; }
private void doNormalCommandLineList ( List < String > commandLineList , List < String > jointOptions , Path classpath ) { commandLineList . add ( STR_ ) ; commandLineList . add ( classpath . toString ( ) ) ; if ( jointCompilation ) { commandLineList . add ( STR_ ) ; commandLineList . addAll ( jointOptions ) ; } if ( destDir != null ) { commandLineList . add ( STR_ ) ; commandLineList . add ( destDir . getPath ( ) ) ; } if ( encoding != null ) { commandLineList . add ( STR_ ) ; commandLineList . add ( encoding ) ; } if ( stacktrace ) { commandLineList . add ( STR_ ) ; } if ( parameters ) { commandLineList . add ( STR_ ) ; } if ( useIndy ) { commandLineList . add ( STR_ ) ; } if ( scriptBaseClass != null ) { commandLineList . add ( STR_ ) ; commandLineList . add ( scriptBaseClass ) ; } if ( configscript != null ) { commandLineList . add ( STR_ ) ; commandLineList . add ( configscript ) ; } }
private synchronized void loadHexImage ( IHex hex ) { hexTileset . assignMatch ( hex , boardview ) ; hexTileset . trackHexImages ( hex , tracker ) ; }
public void triangulate ( PointSet ps ) { _triangulations . clear ( ) ; _triangulations . add ( ps ) ; start ( ) ; }
public String base64UrlEncode ( byte [ ] data ) { String encodedData = new String ( Base64 . encode ( data , Base64 . URL_SAFE ) ) ; encodedData = encodedData . replace ( STR_ , STR_ ) ; encodedData = encodedData . replace ( STR_ , STR_ ) ; return encodedData ; }
private void writeJavaFieldSpec ( JavaFieldSpec spec , Document document , Element parentElement ) { Element parameter = document . createElement ( STR_ ) ; parameter . appendChild ( parentElement ) ; parameter . setAttribute ( STR_ , spec . getPackageName ( ) ) ; parameter . setAttribute ( STR_ , spec . getClassName ( ) ) ; parameter . setAttribute ( STR_ , spec . getFieldName ( ) ) ; }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; init ( getMask ( actions ) ) ; }
@ Override public synchronized void parse ( Reader reader , String baseURI ) throws IOException , RDFParseException , RDFHandlerException { if ( reader == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( baseURI == null ) { throw new IllegalArgumentException ( STR_ ) ; } InputSource inputSource = new InputSource ( reader ) ; inputSource . setSystemId ( baseURI ) ; parse ( inputSource ) ; }
private String excludeDestinationStatement ( String text ) { int idx = - NUM_ ; if ( ( idx = text . indexOf ( STR_ ) ) != - NUM_ ) { text = text . substring ( NUM_ , idx ) ; } return text ; }
static byte [ ] discardNonBase64 ( byte [ ] data ) { byte groomedData [ ] = new byte [ data . length ] ; int bytesCopied = NUM_ ; for ( int i = NUM_ ; i < data . length ; i ++ ) { if ( isBase64 ( data [ i ] ) ) { groomedData [ bytesCopied ++ ] = data [ i ] ; } } byte packedData [ ] = new byte [ bytesCopied ] ; System . arraycopy ( groomedData , NUM_ , packedData , NUM_ , bytesCopied ) ; return packedData ; }
protected static final String addEscapes ( String str ) { StringBuilder retval = new StringBuilder ( ) ; char ch ; for ( int i = NUM_ ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case NUM_ : continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < x20 || ch > x7e ) { String s = STR_ + Integer . toString ( ch , NUM_ ) ; retval . append ( STR_ + s . substring ( s . length ( ) - NUM_ , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; }
public static void addFile ( String s ) throws IOException { File f = new File ( s ) ; addFile ( f ) ; }
@ SafeVarargs public final void insert ( int rowIndex , T ... newItems ) { insert ( rowIndex , Arrays . asList ( newItems ) ) ; }
@ Deprecated public void put ( Collection < Integer > data ) { for ( Integer value : data ) { final int val = value . intValue ( ) ; min = val < min ? val : min ; max = val > max ? val : max ; } }
public IntBuffer majorVersionBuffer ( ) { int [ ] holder = new int [ NUM_ ] ; holder [ NUM_ ] = getMajorVersion ( ) ; IntBuffer ib = IntBuffer . wrap ( holder ) ; ib . limit ( NUM_ ) ; return ib ; }
public CreateIndexRequest source ( XContentBuilder source ) { return source ( source . bytes ( ) ) ; }
public static byte [ ] createDataToSign ( byte [ ] digest ) { byte [ ] prefix = getDigestInfoPrefix ( digest ) ; byte [ ] digestInfo = new byte [ prefix . length + digest . length ] ; System . arraycopy ( prefix , NUM_ , digestInfo , NUM_ , prefix . length ) ; System . arraycopy ( digest , NUM_ , digestInfo , prefix . length , digest . length ) ; return digestInfo ; }
public HttpRequest ifModifiedSince ( final long value ) { connection . setIfModifiedSince ( value ) ; return this ; }
public static String tmpJournal ( ) { final File file = Code . wrapThrow ( null ) ; file . deleteOnExit ( ) ; return file . getAbsolutePath ( ) ; }
public void push ( final float value ) { int bits = Float . floatToIntBits ( value ) ; if ( bits == NUM_ || bits == x3f800000 || bits == x40000000 ) { mv . visitInsn ( Opcodes . FCONST_0 + ( int ) value ) ; } else { mv . visitLdcInsn ( value ) ; } }
public static Object newInstance ( Class < ? > cl , int [ ] dims ) { if ( dims . length == NUM_ ) { dims = new int [ ] { NUM_ } ; } return Array . newInstance ( cl , dims ) ; }
private static void decodeAnsiX12Segment ( BitSource bits , StringBuilder result ) throws FormatException { int [ ] cValues = new int [ NUM_ ] ; do { if ( bits . available ( ) == NUM_ ) { return ; } int firstByte = bits . readBits ( NUM_ ) ; if ( firstByte == NUM_ ) { return ; } parseTwoBytes ( firstByte , bits . readBits ( NUM_ ) , cValues ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { int cValue = cValues [ i ] ; if ( cValue == NUM_ ) { result . append ( STR_ ) ; } else if ( cValue == NUM_ ) { result . append ( STR_ ) ; } else if ( cValue == NUM_ ) { result . append ( STR_ ) ; } else if ( cValue == NUM_ ) { result . append ( STR_ ) ; } else if ( cValue < NUM_ ) { result . append ( ( char ) ( cValue + NUM_ ) ) ; } else if ( cValue < NUM_ ) { result . append ( ( char ) ( cValue + NUM_ ) ) ; } else { throw FormatException . getFormatInstance ( ) ; } } } while ( bits . available ( ) > NUM_ ) ; }
public void playTogether ( Collection < Animator > items ) { if ( items != null && items . size ( ) > NUM_ ) { mNeedsSort = BOOL_ ; Builder builder = null ; for ( Animator anim : items ) { if ( builder == null ) { builder = play ( anim ) ; } else { builder . with ( anim ) ; } } } }
protected static void printErrorMessage ( Exception e ) { if ( e instanceof AbortException ) { LoggingConfiguration . setVerbose ( Level . VERBOSE ) ; LOG . verbose ( e . getMessage ( ) ) ; } else if ( e instanceof UnspecifiedParameterException ) { LOG . error ( e . getMessage ( ) ) ; } else if ( e instanceof ParameterException ) { LOG . error ( e . getMessage ( ) ) ; } else { LOG . exception ( e ) ; } }
public String requestStatistics ( ) { sb . setLength ( NUM_ ) ; makeStringBuffer ( sb ) ; return sb . toString ( ) ; }
private void applyL1Reg ( final double eta_t , Vec x ) { if ( lambda1 > NUM_ ) { l1U += eta_t . lambda1 ; for ( int k = NUM_ ; k < ws . length ; k ++ ) { final Vec w_k = ws [ k ] ; final double [ ] l1Q_k = l1Q [ k ] ; for ( IndexValue iv : x ) { final int i = iv . getIndex ( ) ; final double z = w_k . get ( i ) ; double newW_i = NUM_ ; if ( z > NUM_ ) newW_i = Math . max ( NUM_ , z - ( l1U + l1Q_k [ i ] ) ) ; else if ( z < NUM_ ) newW_i = Math . min ( NUM_ , z + ( l1U - l1Q_k [ i ] ) ) ; l1Q_k [ i ] += ( newW_i - z ) ; w_k . set ( i , newW_i ) ; } } } }
@ Override public void keyPressed ( KeyEvent e ) { synchronized ( keyLock ) { keysDown . add ( e . getKeyCode ( ) ) ; } }
public static String slurpURLNoExceptions ( URL u , String encoding ) { try { return slurpURL ( u , encoding ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } }
public static MoveParticipant [ ] loadMoveParticipants ( RefactoringStatus status , RefactoringProcessor processor , Object element , MoveArguments arguments , IParticipantDescriptorFilter filter , String [ ] affectedNatures , SharableParticipants shared ) { RefactoringParticipant [ ] participants = fgMoveExtensions . getParticipants ( status , processor , element , arguments , filter , affectedNatures , shared ) ; MoveParticipant [ ] result = new MoveParticipant [ participants . length ] ; System . arraycopy ( participants , NUM_ , result , NUM_ , participants . length ) ; return result ; }
private long [ ] determinePreferenceVector ( Relation < V > relation , ModifiableDBIDs [ ] neighborIDs , StringBuilder msg ) { if ( strategy . equals ( Strategy . APRIORI ) ) { return determinePreferenceVectorByApriori ( relation , neighborIDs , msg ) ; } else if ( strategy . equals ( Strategy . MAX_INTERSECTION ) ) { return determinePreferenceVectorByMaxIntersection ( neighborIDs , msg ) ; } else { throw new IllegalStateException ( STR_ ) ; } }
private void paintForegroundDisabled ( Graphics2D g , int width , int height ) { Shape s = decodeArrowPath ( width , height ) ; g . setPaint ( disabledColor ) ; g . fill ( s ) ; }
public void testFlipBitNegativeInside1 ( ) { byte aBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; int aSign = - NUM_ ; int number = NUM_ ; byte rBytes [ ] = { - NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger result = aNumber . flipBit ( number ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , - NUM_ , result . signum ( ) ) ; }
private void onUser ( @ NotNull TLAbsUser absUser ) { User currentUser = null ; User user = null ; if ( absUser instanceof TLUser ) { final TLUser tlUser = ( TLUser ) absUser ; if ( tlUser . isMutualContact ( ) ) { currentUser = ( User ) databaseManager . getUserById ( tlUser . getId ( ) ) ; user = onUserContact ( currentUser , tlUser ) ; } else if ( tlUser . isDeleted ( ) ) { currentUser = ( User ) databaseManager . getUserById ( tlUser . getId ( ) ) ; user = onUserDelete ( currentUser , tlUser ) ; } else if ( tlUser . isContact ( ) ) { currentUser = ( User ) databaseManager . getUserById ( tlUser . getId ( ) ) ; user = onUserRequest ( currentUser , tlUser ) ; } else if ( tlUser . isSelf ( ) || ! tlUser . isBot ( ) ) { currentUser = ( User ) databaseManager . getUserById ( tlUser . getId ( ) ) ; user = onUserForeign ( currentUser , tlUser ) ; } else { BotLogger . info ( LOGTAG , STR_ ) ; } } if ( ( currentUser == null ) && ( user != null ) ) { databaseManager . addUser ( user ) ; } else if ( user != null ) { databaseManager . updateUser ( user ) ; } }
@ Override public boolean hasNext ( ) { log . log ( Level . FINE , STR_ ) ; boolean result = ( nextEvent != null ) ; log . log ( Level . FINE , STR_ , result ) ; return result ; }
@ Override public void close ( ) { try { if ( connection != null ) { connection . close ( ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
public static XMPMeta extractXMPMeta ( InputStream is ) { List < Section > sections = parse ( is , BOOL_ ) ; if ( sections == null ) { return null ; } for ( Section section : sections ) { if ( hasXMPHeader ( section . data ) ) { int end = getXMPContentEnd ( section . data ) ; byte [ ] buffer = new byte [ end - XMP_HEADER_SIZE ] ; System . arraycopy ( section . data , XMP_HEADER_SIZE , buffer , NUM_ , buffer . length ) ; try { XMPMeta result = XMPMetaFactory . parseFromBuffer ( buffer ) ; return result ; } catch ( XMPException e ) { Log . d ( TAG , STR_ , e ) ; return null ; } } } return null ; }
private void initialize ( ModelValidator validator , MClient client ) { if ( client == null ) m_globalValidators . add ( validator ) ; m_validators . add ( validator ) ; validator . initialize ( this , client ) ; }
void crossOver ( BayesNetRepresentation other ) { boolean [ ] bits = new boolean [ m_bits . length ] ; for ( int i = NUM_ ; i < m_bits . length ; i ++ ) { bits [ i ] = m_bits [ i ] ; } int iCrossOverPoint = m_bits . length ; do { for ( int i = iCrossOverPoint ; i < m_bits . length ; i ++ ) { m_bits [ i ] = bits [ i ] ; } iCrossOverPoint = m_random . nextInt ( m_bits . length ) ; for ( int i = iCrossOverPoint ; i < m_bits . length ; i ++ ) { m_bits [ i ] = other . m_bits [ i ] ; } } while ( hasCycles ( ) ) ; calcGlobalScore ( ) ; }
public void reset ( ) { engineReset ( ) ; state = INITIAL ; }
public Perspective createUserPerspective ( final String name , final boolean show ) { Perspective perspective = model . addPerspective ( name , BOOL_ ) ; perspective . store ( context ) ; if ( show ) { showPerspective ( name ) ; } return perspective ; }
public static double phred ( double error ) { return - NUM_ . Math . log10 ( error ) ; }
public static String of ( CtClass type ) { StringBuffer sbuf = new StringBuffer ( ) ; toDescriptor ( sbuf , type ) ; return sbuf . toString ( ) ; }
public abstract String encode ( ) ;
@ SafeVarargs public final Token < TokenType > expect ( TokenType ... expected ) throws SimpleParserException { if ( hasType ( expected ) ) return this ; throw new SimpleParserException ( line , column , STR_ + Arrays . toString ( expected ) + STR_ + toString ( ) ) ; }
public void testUpdate3 ( ) { int newValue1 = - NUM_ ; int newValue2 = - NUM_ ; String updateQuery = STR_ + DatabaseCreator . TEST_TABLE1 + STR_ + newValue1 + STR_ + newValue2 ; try { int num = statement . executeUpdate ( updateQuery ) ; assertEquals ( STR_ , numberOfRecords , num ) ; String selectQuery = STR_ + DatabaseCreator . TEST_TABLE1 ; ResultSet result = statement . executeQuery ( selectQuery ) ; while ( result . next ( ) ) { } result . close ( ) ; } catch ( SQLException e ) { fail ( STR_ + e . getMessage ( ) ) ; } }
public void testSetNull ( ) throws Exception { PreparedStatement stmt = connection . prepareStatement ( STR_ ) ; try { stmt . setInt ( NUM_ , NUM_ ) ; stmt . setBytes ( NUM_ , null ) ; stmt . executeUpdate ( ) ; stmt . setInt ( NUM_ , NUM_ ) ; stmt . setBinaryStream ( NUM_ , null , NUM_ ) ; stmt . executeUpdate ( ) ; stmt . setInt ( NUM_ , NUM_ ) ; stmt . setString ( NUM_ , null ) ; stmt . executeUpdate ( ) ; } finally { stmt . close ( ) ; } }
@ Deprecated public boolean isAssignableFrom ( Type from ) { if ( from == null ) { return BOOL_ ; } if ( type . equals ( from ) ) { return BOOL_ ; } if ( type instanceof Class < ? > ) { return rawType . isAssignableFrom ( $Gson$Types . getRawType ( from ) ) ; } else if ( type instanceof ParameterizedType ) { return isAssignableFrom ( from , ( ParameterizedType ) type , new HashMap < String , Type > ( ) ) ; } else if ( type instanceof GenericArrayType ) { return rawType . isAssignableFrom ( $Gson$Types . getRawType ( from ) ) && isAssignableFrom ( from , ( GenericArrayType ) type ) ; } else { throw buildUnexpectedTypeError ( type , Class . class , ParameterizedType . class , GenericArrayType . class ) ; } }
EgDemandDetails insertPenalty ( final BigDecimal chqBouncePenalty , final Module module ) { EgDemandDetails demandDetail = null ; if ( chqBouncePenalty != null && chqBouncePenalty . compareTo ( BigDecimal . ZERO ) > NUM_ ) { final Installment currInstallment = getCurrentInstallment ( module ) ; final EgDemandReasonMaster egDemandReasonMaster = demandGenericDao . getDemandReasonMasterByCode ( DEMANDRSN_CODE_CHQ_BOUNCE_PENALTY , module ) ; if ( egDemandReasonMaster == null ) throw new ApplicationRuntimeException ( STR_ ) ; final EgDemandReason egDemandReason = demandGenericDao . getDmdReasonByDmdReasonMsterInstallAndMod ( egDemandReasonMaster , currInstallment , module ) ; if ( egDemandReason == null ) throw new ApplicationRuntimeException ( STR_ ) ; demandDetail = EgDemandDetails . fromReasonAndAmounts ( chqBouncePenalty , egDemandReason , BigDecimal . ZERO ) ; } return demandDetail ; }
public SampleInfo ( ByteBuffer bb ) throws IOException { numberOfChannels = bb . getInt ( ) ; sampleRate = bb . getInt ( ) ; coeffMin = bb . getFloat ( ) ; coeffRange = bb . getFloat ( ) ; postEmphasis = bb . getFloat ( ) ; residualFold = bb . getInt ( ) ; }
public void handleMaintenance ( Operation maintOp ) { performPendingRequestMaintenance ( ) ; checkAndScheduleSynchronization ( this . cachedGroupState . membershipUpdateTimeMicros ) ; maintOp . complete ( ) ; }
public void clear ( ) { oredCriteria . clear ( ) ; orderByClause = null ; distinct = BOOL_ ; }
public < T > T time ( Callable < T > event ) throws Exception { final long startTime = clock . tick ( ) ; try { return event . call ( ) ; } finally { update ( clock . tick ( ) - startTime ) ; } }
public static boolean isPostJDK7 ( String bytecodeVersion ) { return JDK7 . equals ( bytecodeVersion ) || JDK8 . equals ( bytecodeVersion ) ; }
public PutIndexTemplateRequest mapping ( String type , Object ... source ) { mapping ( type , PutMappingRequest . buildFromSimplifiedDef ( type , source ) ) ; return this ; }
private static char [ ] zzUnpackCMap ( String packed ) { char [ ] map = new char [ x10000 ] ; int i = NUM_ ; int j = NUM_ ; while ( i < NUM_ ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM_ ) ; } return map ; }
private InputStream findTemplate ( String path , String template ) { try { File file = new File ( path , template ) ; if ( file . canRead ( ) ) { return new BufferedInputStream ( new FileInputStream ( file . getAbsolutePath ( ) ) ) ; } else { return null ; } } catch ( FileNotFoundException fnfe ) { return null ; } }
@ Override public synchronized void initialize ( ) { if ( ! mRootDirectory . exists ( ) ) { if ( ! mRootDirectory . mkdirs ( ) ) { VolleyLog . e ( STR_ , mRootDirectory . getAbsolutePath ( ) ) ; } return ; } File [ ] files = mRootDirectory . listFiles ( ) ; if ( files == null ) { return ; } for ( File file : files ) { BufferedInputStream fis = null ; try { fis = new BufferedInputStream ( new FileInputStream ( file ) ) ; CacheHeader entry = CacheHeader . readHeader ( fis ) ; entry . size = file . length ( ) ; putEntry ( entry . key , entry ) ; } catch ( IOException e ) { if ( file != null ) { file . delete ( ) ; } } finally { try { if ( fis != null ) { fis . close ( ) ; } } catch ( IOException ignored ) { } } } }
public void addListener ( CircularProgressViewListener listener ) { if ( listener != null ) listeners . add ( listener ) ; }
public SiteStatusCheckThreadImpl ( ) { super ( ) ; urlCheckers = new HashMap ( ) ; }
@ Override public void render ( final int type , final Graphics2D g2 , final float scaling , final boolean isFormGlyph ) { glyphDisplay . setScalingValues ( NUM_ , NUM_ , scaling ) ; final float OLDglyphScale = glyphScale ; if ( isFormGlyph ) { glyphScale = scaling . glyphScale ; } AffineTransform aff = null ; if ( glyphScale != NUM_ ) { aff = g2 . getTransform ( ) ; g2 . scale ( glyphScale , glyphScale ) ; } glyphDisplay . setG2 ( g2 ) ; glyphDisplay . paint ( null , null , null ) ; if ( aff != null ) { g2 . setTransform ( aff ) ; } glyphScale = OLDglyphScale ; }
public void removeVetoableChangeListener ( String propertyName , VetoableChangeListener in_vcl ) { beanContextChildSupport . removeVetoableChangeListener ( propertyName , in_vcl ) ; }
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; }
public List < String > reset ( List < String > replace ) { ArrayList < String > copy = new ArrayList < String > ( retainedVars . size ( ) ) ; copy . addAll ( retainedVars ) ; retainedVars . clear ( ) ; if ( replace != null ) { retainedVars . addAll ( replace ) ; } return copy ; }
protected void release ( ) { AppContext tempAppContext = null ; synchronized ( grabReleaseSynchronizer ) { if ( usageCount > NUM_ ) { -- usageCount ; } else { synchronized ( threadGroupSynchronizer ) { tempAppContext = resetAppContext ( ) ; } } } if ( tempAppContext != null ) { try { tempAppContext . dispose ( ) ; } catch ( IllegalThreadStateException e ) { } } }
public synchronized void deleteAllTables ( ) { List < String > tableNames = new ArrayList < String > ( tableLookup . keySet ( ) ) ; for ( String s : tableNames ) { deleteTable ( s ) ; } }
public PetCategory findOne ( String id ) { log . debug ( STR_ , id ) ; PetCategory petCategory = petCategoryRepository . findOne ( UUID . fromString ( id ) ) ; return petCategory ; }
private void markRemovedDefaultSessionToken ( String site , String token ) { if ( removedDefaultTokens == null ) removedDefaultTokens = new HashMap < > ( NUM_ ) ; HashSet < String > removedSet = removedDefaultTokens . get ( site ) ; if ( removedSet == null ) { removedSet = new HashSet < > ( NUM_ ) ; removedDefaultTokens . put ( site , removedSet ) ; } removedSet . add ( token ) ; }
private Map < URI , Map < URI , Map < String , List < URI > > > > createDeviceToCGMapFromDescriptors ( List < VolumeDescriptor > addDescriptors , List < VolumeDescriptor > removeDescriptors ) { Map < URI , Map < URI , Map < String , List < URI > > > > deviceToCGMap = new HashMap < URI , Map < URI , Map < String , List < URI > > > > ( ) ; for ( VolumeDescriptor descr : addDescriptors ) { URI deviceURI = descr . getDeviceURI ( ) ; Map < URI , Map < String , List < URI > > > volumesToUpdateByCG = deviceToCGMap . get ( deviceURI ) ; if ( volumesToUpdateByCG == null ) { volumesToUpdateByCG = new HashMap < URI , Map < String , List < URI > > > ( ) ; deviceToCGMap . put ( deviceURI , volumesToUpdateByCG ) ; } URI consistencyGroupURI = descr . getConsistencyGroupURI ( ) ; Map < String , List < URI > > volumesToUpdate = volumesToUpdateByCG . get ( consistencyGroupURI ) ; if ( volumesToUpdate == null ) { volumesToUpdate = new HashMap < String , List < URI > > ( ) ; volumesToUpdateByCG . put ( consistencyGroupURI , volumesToUpdate ) ; } List < URI > volumesToAdd = volumesToUpdate . get ( ADD_VOLUMES_TO_CG_KEY ) ; if ( volumesToAdd == null ) { volumesToAdd = new ArrayList < URI > ( ) ; volumesToUpdate . put ( ADD_VOLUMES_TO_CG_KEY , volumesToAdd ) ; } volumesToAdd . add ( descr . getVolumeURI ( ) ) ; } for ( VolumeDescriptor descr : removeDescriptors ) { URI deviceURI = descr . getDeviceURI ( ) ; Map < URI , Map < String , List < URI > > > volumesToUpdateByCG = deviceToCGMap . get ( deviceURI ) ; if ( volumesToUpdateByCG == null ) { volumesToUpdateByCG = new HashMap < URI , Map < String , List < URI > > > ( ) ; deviceToCGMap . put ( deviceURI , volumesToUpdateByCG ) ; } URI consistencyGroupURI = descr . getConsistencyGroupURI ( ) ; Map < String , List < URI > > volumesToUpdate = volumesToUpdateByCG . get ( consistencyGroupURI ) ; if ( volumesToUpdate == null ) { volumesToUpdate = new HashMap < String , List < URI > > ( ) ; volumesToUpdateByCG . put ( consistencyGroupURI , volumesToUpdate ) ; } List < URI > volumesToRemove = volumesToUpdate . get ( REMOVE_VOLUMES_FROM_CG_KEY ) ; if ( volumesToRemove == null ) { volumesToRemove = new ArrayList < URI > ( ) ; volumesToUpdate . put ( REMOVE_VOLUMES_FROM_CG_KEY , volumesToRemove ) ; } volumesToRemove . add ( descr . getVolumeURI ( ) ) ; } return deviceToCGMap ; }
public Exchange ( final Request request , final Origin origin ) { this . currentRequest = request ; this . origin = origin ; this . timestamp = System . currentTimeMillis ( ) ; }
public static float computeDiscardAlpha ( float amount , float range ) { if ( Math . abs ( amount ) < NUM_ ) return NUM_ ; float t = amount / range ; t = MathUtils . clamp ( t , - NUM_ , NUM_ ) ; return NUM_ - Math . abs ( t ) ; }
public static final FileTime unixTimeToFileTime ( long utime ) { return FileTime . from ( utime , TimeUnit . SECONDS ) ; }
public static CipherTextIvMac encrypt ( String plaintext , SecretKeys secretKeys , String encoding ) throws UnsupportedEncodingException , GeneralSecurityException { return encrypt ( plaintext . getBytes ( encoding ) , secretKeys ) ; }
public void removeAddress ( AddressEntity address ) { addresses . remove ( address ) ; }
@ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { int widthSpecMode = MeasureSpec . getMode ( widthMeasureSpec ) ; int heightSpecMode = MeasureSpec . getMode ( heightMeasureSpec ) ; int parentWidth = MeasureSpec . getSize ( widthMeasureSpec ) ; int parentHeight = MeasureSpec . getSize ( heightMeasureSpec ) ; boolean resizeWidth = widthSpecMode != MeasureSpec . EXACTLY ; boolean resizeHeight = heightSpecMode != MeasureSpec . EXACTLY ; int width = parentWidth ; int height = parentHeight ; if ( sWidth > NUM_ && sHeight > NUM_ ) { if ( resizeWidth && resizeHeight ) { width = sWidth ( ) ; height = sHeight ( ) ; } else if ( resizeHeight ) { height = ( int ) ( ( ( ( double ) sHeight ( ) / ( double ) sWidth ( ) ) . width ) ) ; } else if ( resizeWidth ) { width = ( int ) ( ( ( ( double ) sWidth ( ) / ( double ) sHeight ( ) ) . height ) ) ; } } width = Math . max ( width , getSuggestedMinimumWidth ( ) ) ; height = Math . max ( height , getSuggestedMinimumHeight ( ) ) ; setMeasuredDimension ( width , height ) ; }
protected void fireEndElem ( String name ) throws org . xml . sax . SAXException { if ( m_tracer != null ) { flushMyWriter ( ) ; m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_ENDELEMENT , name , ( Attributes ) null ) ; } }
private boolean verifyMigrateFromProductHome ( String migrateFromProductHome ) throws InstallException { if ( migrateFromProductHome == null || migrateFromProductHome . length ( ) == NUM_ ) { Debug . log ( STR_ + STR_ ) ; Console . println ( LocalizedMessage . get ( LOC_HR_MSG_MIGRATE_NONE_FOUND ) ) ; return BOOL_ ; } if ( ! migrateFromProductHome . equals ( ConfigUtil . getHomePath ( ) ) ) { Debug . log ( STR_ + STR_ + migrateFromProductHome + STR_ + ConfigUtil . getHomePath ( ) ) ; String translateFile = migrateFromProductHome + MigrateFromInstFinderStore . getRelativeTranslateFile ( ) ; if ( ! FileUtils . isFileValid ( translateFile ) ) { Console . println ( LocalizedMessage . get ( LOC_HR_MSG_MIGRATE_NONE_FOUND ) ) ; return BOOL_ ; } } else { Debug . log ( STR_ + STR_ ) ; throw new InstallException ( LocalizedMessage . get ( LOC_DR_ERR_PRODUCT_ALREADY_MIGRATED ) ) ; } return BOOL_ ; }
public Spanned [ ] history ( ) { int i = NUM_ ; Spanned [ ] array = new Spanned [ history . size ( ) ] ; for ( String s : history ) { if ( s != null ) { array [ i ] = Html . fromHtml ( s ) ; i ++ ; } } return array ; }
public static String format ( String message , Object [ ] arguments ) { return MessageFormat . format ( message , arguments ) ; }
private void insertProsodySettings ( Utterance utterance , Element element ) { Element prosody = ( Element ) DomUtils . getAncestor ( element , MaryXML . PROSODY ) ; if ( prosody == null ) { return ; } Element voice = ( Element ) DomUtils . getAncestor ( element , MaryXML . VOICE ) ; if ( voice != null && DomUtils . isAncestor ( prosody , voice ) ) { return ; } Element paragraph = ( Element ) DomUtils . getAncestor ( element , MaryXML . PARAGRAPH ) ; if ( paragraph != null && DomUtils . isAncestor ( prosody , paragraph ) ) { return ; } for ( String att : PROSODY_ATTRIBUTES ) { String val = prosody . getAttribute ( att ) ; if ( ! val . equals ( STR_ ) ) { utterance . setString ( att , val ) ; } } }
public static boolean createFolder ( @ SuppressWarnings ( STR_ ) Context mContext , String path , String folderName ) { File SDCardRoot = new File ( path , folderName ) ; if ( ! SDCardRoot . exists ( ) ) { return SDCardRoot . mkdir ( ) ; } return BOOL_ ; }
private void translateMatrixAfterRotate ( int axis , float trans , float prevImageSize , float imageSize , int prevViewSize , int viewSize , int drawableSize ) { if ( imageSize < viewSize ) { m [ axis ] = ( viewSize - ( drawableSize . m [ Matrix . MSCALE_X ] ) ) . NUM_ ; } else if ( trans > NUM_ ) { m [ axis ] = - ( ( imageSize - viewSize ) . NUM_ ) ; } else { float percentage = ( Math . abs ( trans ) + ( NUM_ . prevViewSize ) ) / prevImageSize ; m [ axis ] = - ( ( percentage . imageSize ) - ( viewSize . NUM_ ) ) ; } }
private CharSequence createTickerText ( String title , String body ) { SpannableStringBuilder spannableStringBuilder = new SpannableStringBuilder ( ) ; spannableStringBuilder . append ( title ) ; spannableStringBuilder . append ( STR_ ) ; spannableStringBuilder . append ( body ) ; spannableStringBuilder . setSpan ( new StyleSpan ( android . graphics . Typeface . BOLD ) , NUM_ , title . length ( ) , Spannable . SPAN_INCLUSIVE_INCLUSIVE ) ; return spannableStringBuilder ; }
private void addProtocolIfNotExists ( Set < String > protocols , String protocolType ) { if ( ! protocols . contains ( protocolType ) ) { protocols . add ( protocolType ) ; } }
public String toString ( ) { StringBuilder result = new StringBuilder ( ) ; result . append ( STR_ ) ; result . append ( klazz . getName ( ) ) ; result . append ( STR_ ) ; for ( int i = NUM_ ; i < elements . length ; ++ i ) { if ( i != NUM_ ) { result . append ( STR_ ) ; } result . append ( elements [ i ] ) ; } result . append ( STR_ ) ; return result . toString ( ) ; }
void add ( Object key ) { table . put ( key , key ) ; }
public Configuration loadConfigFromResource ( Resource resource ) { PropertiesConfiguration result = new PropertiesConfiguration ( ) ; try { result . load ( resource . getInputStream ( ) ) ; return result ; } catch ( ConfigurationException | IOException e ) { LOG . error ( CONFIGURATION_LOAD_ERROR . format ( resource . getFilename ( ) ) , e ) ; throw new SystemConfigException ( CONFIGURATION_LOAD_ERROR . format ( resource . getFilename ( ) ) , e ) ; } }
public final void log ( String filename , int lineNumber , String method , String tag , int level , String message ) { final LogMessage lm = new LogMessage ( LogMessage . LOGMSG_TYPE_LOG , nextSequenceNumber . getAndIncrement ( ) ) ; lm . addInt16 ( level , LogMessage . PART_KEY_LEVEL ) ; if ( filename != null ) { lm . addString ( filename , LogMessage . PART_KEY_FILENAME ) ; if ( lineNumber != NUM_ ) lm . addInt32 ( lineNumber , LogMessage . PART_KEY_LINENUMBER ) ; } if ( method != null ) lm . addString ( method , LogMessage . PART_KEY_FUNCTIONNAME ) ; if ( tag != null && ! tag . isEmpty ( ) ) lm . addString ( tag , LogMessage . PART_KEY_TAG ) ; lm . addString ( message , LogMessage . PART_KEY_MESSAGE ) ; log ( lm ) ; }
protected Size2D drawVertical ( Graphics2D g2 , Rectangle2D chartArea ) { double startX ; double topSpace = NUM_ ; double bottomSpace = NUM_ ; double leftSpace = NUM_ ; double rightSpace = NUM_ ; double w = getWidth ( ) ; double h = getHeight ( ) ; RectangleInsets padding = getPadding ( ) ; if ( padding != null ) { topSpace = padding . calculateTopOutset ( h ) ; bottomSpace = padding . calculateBottomOutset ( h ) ; leftSpace = padding . calculateLeftOutset ( w ) ; rightSpace = padding . calculateRightOutset ( w ) ; } if ( getPosition ( ) == RectangleEdge . LEFT ) { startX = chartArea . getX ( ) + leftSpace ; } else { startX = chartArea . getMaxX ( ) - rightSpace - w ; } VerticalAlignment alignment = getVerticalAlignment ( ) ; double startY = NUM_ ; if ( alignment == VerticalAlignment . CENTER ) { startY = chartArea . getMinY ( ) + topSpace + chartArea . getHeight ( ) / NUM_ - h / NUM_ ; } else if ( alignment == VerticalAlignment . TOP ) { startY = chartArea . getMinY ( ) + topSpace ; } else if ( alignment == VerticalAlignment . BOTTOM ) { startY = chartArea . getMaxY ( ) - bottomSpace - h ; } g2 . drawImage ( this . image , ( int ) startX , ( int ) startY , ( int ) w , ( int ) h , null ) ; return new Size2D ( chartArea . getWidth ( ) + leftSpace + rightSpace , h + topSpace + bottomSpace ) ; }
private static final PublicKey constructPublicKey ( byte [ ] encodedKey , String encodedKeyAlgorithm ) throws InvalidKeyException , NoSuchAlgorithmException { PublicKey key = null ; try { KeyFactory keyFactory = KeyFactory . getInstance ( encodedKeyAlgorithm , SunJCE . getInstance ( ) ) ; X509EncodedKeySpec keySpec = new X509EncodedKeySpec ( encodedKey ) ; key = keyFactory . generatePublic ( keySpec ) ; } catch ( NoSuchAlgorithmException nsae ) { try { KeyFactory keyFactory = KeyFactory . getInstance ( encodedKeyAlgorithm ) ; X509EncodedKeySpec keySpec = new X509EncodedKeySpec ( encodedKey ) ; key = keyFactory . generatePublic ( keySpec ) ; } catch ( NoSuchAlgorithmException nsae2 ) { throw new NoSuchAlgorithmException ( STR_ + STR_ + encodedKeyAlgorithm + STR_ ) ; } catch ( InvalidKeySpecException ikse2 ) { InvalidKeyException ike = new InvalidKeyException ( STR_ ) ; ike . initCause ( ikse2 ) ; throw ike ; } } catch ( InvalidKeySpecException ikse ) { InvalidKeyException ike = new InvalidKeyException ( STR_ ) ; ike . initCause ( ikse ) ; throw ike ; } return key ; }
public int numHits ( String query ) throws ParseException , IOException { Integer count ; if ( ( count = ( Integer ) m_hitCountCache . get ( query ) ) == null ) { Hits hits = search ( query ) ; count = new Integer ( hits . length ( ) ) ; m_hitCountCache . put ( query , count ) ; } return count . intValue ( ) ; }
public static boolean expressionIsTrue ( double leftSide , Operator operator , double rightSide ) { final String expression = leftSide + operator . getMathematicalOperator ( ) + rightSide ; return expressionIsTrue ( expression ) ; }
public MockResponse addHeader ( String name , Object value ) { return addHeader ( name + STR_ + String . valueOf ( value ) ) ; }
@ Override public CompletableFuture < Optional < T > > max ( final Comparator < ? super T > comparator ) { return CompletableFuture . supplyAsync ( null , exec ) ; }
final public void println ( char v ) { Writer out = this . out ; if ( out == null ) return ; try { out . write ( v ) ; out . write ( _newline , NUM_ , _newline . length ) ; } catch ( IOException e ) { log . log ( Level . FINE , e . toString ( ) , e ) ; } }
public void test_write_correctRejection_emptyRecord ( ) { final IRawStore store = getStore ( ) ; try { try { store . write ( ByteBuffer . wrap ( new byte [ ] { } ) ) ; fail ( STR_ + IllegalArgumentException . class ) ; } catch ( IllegalArgumentException ex ) { if ( log . isInfoEnabled ( ) ) log . info ( STR_ + ex ) ; } try { final ByteBuffer buf = ByteBuffer . wrap ( new byte [ NUM_ ] ) ; buf . position ( buf . limit ( ) ) ; store . write ( buf ) ; fail ( STR_ + IllegalArgumentException . class ) ; } catch ( IllegalArgumentException ex ) { if ( log . isInfoEnabled ( ) ) log . info ( STR_ + ex ) ; } } finally { store . destroy ( ) ; } }
public synchronized void commit ( ) { synchronized ( mutex ) { Map < Column , Set < Interval > > temp = workingIntervals ; workingIntervals = Collections . synchronizedMap ( new LinkedHashMap < > ( ) ) ; availableIntervalsRef . set ( Collections . unmodifiableMap ( new LinkedHashMap < > ( temp ) ) ) ; super . columns = new LinkedHashSet < > ( temp . keySet ( ) ) ; } }
public void testUpdate7 ( ) { String updateQuery = STR_ + DatabaseCreator . TEST_TABLE1 + STR_ + DatabaseCreator . TEST_TABLE2 + STR_ ; try { int num = statement . executeUpdate ( updateQuery ) ; int expectedUpdated = NUM_ ; assertEquals ( STR_ , expectedUpdated , num ) ; String selectQuery = STR_ + DatabaseCreator . TEST_TABLE1 ; ResultSet result = statement . executeQuery ( selectQuery ) ; while ( result . next ( ) ) { } result . close ( ) ; } catch ( SQLException e ) { fail ( STR_ + e . getMessage ( ) ) ; } }
public static String extractIndentString ( String line , int tabWidth , int indentWidth ) { if ( tabWidth < NUM_ || indentWidth < NUM_ || line == null ) { throw new IllegalArgumentException ( ) ; } int size = line . length ( ) ; int end = NUM_ ; int spaceEquivs = NUM_ ; int characters = NUM_ ; for ( int i = NUM_ ; i < size ; i ++ ) { char c = line . charAt ( i ) ; if ( c == STR_ ) { spaceEquivs = calculateSpaceEquivalents ( tabWidth , spaceEquivs ) ; characters ++ ; } else if ( isIndentChar ( c ) ) { spaceEquivs ++ ; characters ++ ; } else { break ; } if ( spaceEquivs >= indentWidth ) { end += characters ; characters = NUM_ ; if ( indentWidth == NUM_ ) { spaceEquivs = NUM_ ; } else { spaceEquivs = spaceEquivs % indentWidth ; } } } if ( end == NUM_ ) { return Util . EMPTY_STRING ; } else if ( end == size ) { return line ; } else { return line . substring ( NUM_ , end ) ; } }
private static String doGetFullPath ( String filename , boolean includeSeparator ) { if ( filename == null ) { return null ; } int prefix = getPrefixLength ( filename ) ; if ( prefix < NUM_ ) { return null ; } if ( prefix >= filename . length ( ) ) { if ( includeSeparator ) { return getPrefix ( filename ) ; } else { return filename ; } } int index = indexOfLastSeparator ( filename ) ; if ( index < NUM_ ) { return filename . substring ( NUM_ , prefix ) ; } int end = index + ( includeSeparator ? NUM_ : NUM_ ) ; if ( end == NUM_ ) { end ++ ; } return filename . substring ( NUM_ , end ) ; }
private void preInsert ( MkMaxEntry q , MkMaxEntry nodeEntry , KNNHeap knns_q ) { if ( LOG . isDebugging ( ) ) { LOG . debugFine ( STR_ + q + STR_ + nodeEntry + STR_ ) ; } double knnDist_q = knns_q . getKNNDistance ( ) ; MkMaxTreeNode < O > node = getNode ( nodeEntry ) ; double knnDist_node = NUM_ ; if ( node . isLeaf ( ) ) { for ( int i = NUM_ ; i < node . getNumEntries ( ) ; i ++ ) { MkMaxEntry p = node . getEntry ( i ) ; double dist_pq = distance ( p . getRoutingObjectID ( ) , q . getRoutingObjectID ( ) ) ; if ( dist_pq <= knnDist_q ) { knns_q . insert ( dist_pq , p . getRoutingObjectID ( ) ) ; if ( knns_q . size ( ) >= getKmax ( ) ) { knnDist_q = knns_q . getKNNDistance ( ) ; q . setKnnDistance ( knnDist_q ) ; } } if ( dist_pq <= p . getKnnDistance ( ) ) { KNNList knns_p = knnq . getKNNForDBID ( p . getRoutingObjectID ( ) , getKmax ( ) - NUM_ ) ; if ( knns_p . size ( ) + NUM_ < getKmax ( ) ) { p . setKnnDistance ( Double . NaN ) ; } else { double knnDist_p = Math . max ( dist_pq , knns_p . getKNNDistance ( ) ) ; p . setKnnDistance ( knnDist_p ) ; } } knnDist_node = Math . max ( knnDist_node , p . getKnnDistance ( ) ) ; } } else { List < DoubleIntPair > entries = getSortedEntries ( node , q . getRoutingObjectID ( ) ) ; for ( DoubleIntPair distEntry : entries ) { MkMaxEntry dirEntry = node . getEntry ( distEntry . second ) ; double entry_knnDist = dirEntry . getKnnDistance ( ) ; if ( distEntry . second < entry_knnDist || distEntry . second < knnDist_q ) { preInsert ( q , dirEntry , knns_q ) ; knnDist_q = knns_q . getKNNDistance ( ) ; } knnDist_node = Math . max ( knnDist_node , dirEntry . getKnnDistance ( ) ) ; } } if ( LOG . isDebugging ( ) ) { LOG . debugFine ( nodeEntry + STR_ + knnDist_node ) ; } nodeEntry . setKnnDistance ( knnDist_node ) ; }
private static boolean addIfMatches ( List < String > container , String statusLine , char x , char y ) { if ( matches ( statusLine , x , y ) ) { final String filename = statusLine . substring ( NUM_ ) ; if ( ! container . contains ( filename ) ) { container . add ( filename ) ; } return BOOL_ ; } return BOOL_ ; }
public void testDivideRoundHalfDownNeg2 ( ) { String a = STR_ ; int aScale = NUM_ ; String b = STR_ ; int bScale = NUM_ ; String c = STR_ ; int resScale = - NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal bNumber = new BigDecimal ( new BigInteger ( b ) , bScale ) ; BigDecimal result = aNumber . divide ( bNumber , resScale , BigDecimal . ROUND_HALF_DOWN ) ; assertEquals ( STR_ , c , result . toString ( ) ) ; assertEquals ( STR_ , resScale , result . scale ( ) ) ; }
public static String encodeFromString ( String plain , String charset ) throws CoderException , UnsupportedEncodingException { return encode ( plain . getBytes ( charset ) ) ; }
public void slide ( SLIDE slide ) { if ( slide == SLIDE . UP ) { if ( ! isPanelShown ( ) ) { int position = NUM_ ; if ( items != null ) { position = items . size ( ) / NUM_ ; } slideUp ( position ) ; } } else { hidePanelPickerUI ( ) ; } }
public DrawerBuilder addStickyDrawerItems ( @ NonNull IDrawerItem ... stickyDrawerItems ) { if ( this . mStickyDrawerItems == null ) { this . mStickyDrawerItems = new ArrayList < > ( ) ; } Collections . addAll ( this . mStickyDrawerItems , IdDistributor . checkIds ( stickyDrawerItems ) ) ; return this ; }
public boolean isDebuggingFinest ( ) { return logger . isLoggable ( Level . FINEST ) ; }
private static void sort1 ( int [ ] x , int off , int len ) { if ( len < NUM_ ) { for ( int i = off ; i < len + off ; i ++ ) for ( int j = i ; j > off && x [ j - NUM_ ] > x [ j ] ; j -- ) swap ( x , j , j - NUM_ ) ; return ; } int m = off + ( len > > NUM_ ) ; if ( len > NUM_ ) { int l = off ; int n = off + len - NUM_ ; if ( len > NUM_ ) { int s = len / NUM_ ; l = med3 ( x , l , l + s , l + NUM_ . s ) ; m = med3 ( x , m - s , m , m + s ) ; n = med3 ( x , n - NUM_ . s , n - s , n ) ; } m = med3 ( x , l , m , n ) ; } int v = x [ m ] ; int a = off , b = a , c = off + len - NUM_ , d = c ; while ( BOOL_ ) { while ( b <= c && x [ b ] <= v ) { if ( x [ b ] == v ) swap ( x , a ++ , b ) ; b ++ ; } while ( c >= b && x [ c ] >= v ) { if ( x [ c ] == v ) swap ( x , c , d -- ) ; c -- ; } if ( b > c ) break ; swap ( x , b ++ , c -- ) ; } int s , n = off + len ; s = Math . min ( a - off , b - a ) ; vecswap ( x , off , b - s , s ) ; s = Math . min ( d - c , n - d - NUM_ ) ; vecswap ( x , b , n - s , s ) ; if ( ( s = b - a ) > NUM_ ) sort1 ( x , off , s ) ; if ( ( s = d - c ) > NUM_ ) sort1 ( x , n - s , s ) ; }
public void reset ( ) { ns . removeAllElements ( ) ; ks . setLength ( NUM_ ) ; cur = tt . root ; run ( ) ; }
@ LayoutlibDelegate static float sin ( float angle ) { return ( float ) Math . sin ( angle ) ; }
public static void renderFlattenedAnnotation ( final PdfObject form , final DynamicVectorRenderer current , final int pageNumber , final int rotation ) { final BufferedImage image = AnnotationFactory . getIcon ( form ) ; if ( image != null ) { final GraphicsState gs = new GraphicsState ( ) ; final int iconHeight = image . getHeight ( ) ; final int iconWidth = image . getWidth ( ) ; final float [ ] rect = form . getFloatArray ( PdfDictionary . Rect ) ; if ( form . getParameterConstant ( PdfDictionary . Subtype ) == PdfDictionary . Text ) { rect [ NUM_ ] = rect [ NUM_ ] + iconWidth ; rect [ NUM_ ] = rect [ NUM_ ] - iconHeight ; form . setFloatArray ( PdfDictionary . Rect , rect ) ; } switch ( rotation % NUM_ ) { case NUM_ : gs . CTM = new float [ ] [ ] { { iconWidth , NUM_ , NUM_ } , { NUM_ , iconHeight , NUM_ } , { NUM_ , NUM_ , NUM_ } } ; gs . x = rect [ NUM_ ] ; gs . y = rect [ NUM_ ] - iconHeight ; gs . CTM [ NUM_ ] [ NUM_ ] = rect [ NUM_ ] ; gs . CTM [ NUM_ ] [ NUM_ ] = rect [ NUM_ ] - iconHeight ; break ; case NUM_ : gs . CTM = new float [ ] [ ] { { NUM_ , iconWidth , NUM_ } , { - iconHeight , NUM_ , NUM_ } , { NUM_ , NUM_ , NUM_ } } ; gs . x = rect [ NUM_ ] + iconHeight ; gs . y = rect [ NUM_ ] ; gs . CTM [ NUM_ ] [ NUM_ ] = rect [ NUM_ ] + iconHeight ; gs . CTM [ NUM_ ] [ NUM_ ] = rect [ NUM_ ] ; break ; case NUM_ : gs . CTM = new float [ ] [ ] { { - iconWidth , NUM_ , NUM_ } , { NUM_ , - iconHeight , NUM_ } , { NUM_ , NUM_ , NUM_ } } ; gs . x = rect [ NUM_ ] ; gs . y = rect [ NUM_ ] + iconHeight ; gs . CTM [ NUM_ ] [ NUM_ ] = rect [ NUM_ ] ; gs . CTM [ NUM_ ] [ NUM_ ] = rect [ NUM_ ] + iconHeight ; break ; case NUM_ : gs . CTM = new float [ ] [ ] { { NUM_ , - iconWidth , NUM_ } , { iconHeight , NUM_ , NUM_ } , { NUM_ , NUM_ , NUM_ } } ; gs . x = rect [ NUM_ ] - iconHeight ; gs . y = rect [ NUM_ ] ; gs . CTM [ NUM_ ] [ NUM_ ] = rect [ NUM_ ] - iconHeight ; gs . CTM [ NUM_ ] [ NUM_ ] = rect [ NUM_ ] ; break ; } if ( form . getParameterConstant ( PdfDictionary . Subtype ) == PdfDictionary . Highlight ) { current . setGraphicsState ( GraphicsState . STROKE , gs . getAlpha ( GraphicsState . STROKE ) , PdfDictionary . Darken ) ; current . setGraphicsState ( GraphicsState . FILL , gs . getAlpha ( GraphicsState . FILL ) , PdfDictionary . Darken ) ; } current . drawImage ( pageNumber , image , gs , BOOL_ , form . getObjectRefAsString ( ) , - NUM_ ) ; if ( form . getParameterConstant ( PdfDictionary . Subtype ) == PdfDictionary . Highlight ) { current . setGraphicsState ( GraphicsState . STROKE , gs . getAlpha ( GraphicsState . STROKE ) , PdfDictionary . Normal ) ; current . setGraphicsState ( GraphicsState . FILL , gs . getAlpha ( GraphicsState . FILL ) , PdfDictionary . Normal ) ; } } }
public byte [ ] extractData ( byte [ ] stegoData , String stegoFileName , byte [ ] origSigData ) throws OpenStegoException { return null ; }
public static String makeRelatedSessionID ( String encryptedID , SessionID prototype ) throws SessionException { prototype . parseSessionString ( ) ; return makeSessionID ( encryptedID , prototype . getExtension ( ) , prototype . tail ) ; }
public static GeneralPath cardinalSpline ( float pts [ ] , int start , int npoints , float slack , boolean closed ) { GeneralPath path = new GeneralPath ( ) ; path . moveTo ( pts [ start ] , pts [ start + NUM_ ] ) ; return cardinalSpline ( path , pts , start , npoints , slack , closed , NUM_ , NUM_ ) ; }
public static Automaton determinize ( Automaton a , int maxDeterminizedStates ) { if ( a . isDeterministic ( ) ) { return a ; } if ( a . getNumStates ( ) <= NUM_ ) { return a ; } Automaton . Builder b = new Automaton . Builder ( ) ; SortedIntSet . FrozenIntSet initialset = new SortedIntSet . FrozenIntSet ( NUM_ , NUM_ ) ; b . createState ( ) ; LinkedList < SortedIntSet . FrozenIntSet > worklist = new LinkedList < > ( ) ; Map < SortedIntSet . FrozenIntSet , Integer > newstate = new HashMap < > ( ) ; worklist . add ( initialset ) ; b . setAccept ( NUM_ , a . isAccept ( NUM_ ) ) ; newstate . put ( initialset , NUM_ ) ; final PointTransitionSet points = new PointTransitionSet ( ) ; final SortedIntSet statesSet = new SortedIntSet ( NUM_ ) ; Transition t = new Transition ( ) ; while ( worklist . size ( ) > NUM_ ) { SortedIntSet . FrozenIntSet s = worklist . removeFirst ( ) ; for ( int i = NUM_ ; i < s . values . length ; i ++ ) { final int s0 = s . values [ i ] ; int numTransitions = a . getNumTransitions ( s0 ) ; a . initTransition ( s0 , t ) ; for ( int j = NUM_ ; j < numTransitions ; j ++ ) { a . getNextTransition ( t ) ; points . add ( t ) ; } } if ( points . count == NUM_ ) { continue ; } points . sort ( ) ; int lastPoint = - NUM_ ; int accCount = NUM_ ; final int r = s . state ; for ( int i = NUM_ ; i < points . count ; i ++ ) { final int point = points . points [ i ] . point ; if ( statesSet . upto > NUM_ ) { assert lastPoint != - NUM_ ; statesSet . computeHash ( ) ; Integer q = newstate . get ( statesSet ) ; if ( q == null ) { q = b . createState ( ) ; if ( q >= maxDeterminizedStates ) { throw new TooComplexToDeterminizeException ( a , maxDeterminizedStates ) ; } final SortedIntSet . FrozenIntSet p = statesSet . freeze ( q ) ; worklist . add ( p ) ; b . setAccept ( q , accCount > NUM_ ) ; newstate . put ( p , q ) ; } else { assert ( accCount > NUM_ ? BOOL_ : BOOL_ ) == b . isAccept ( q ) : STR_ + accCount + STR_ + b . isAccept ( q ) + STR_ + statesSet ; } b . addTransition ( r , q , lastPoint , point - NUM_ ) ; } int [ ] transitions = points . points [ i ] . ends . transitions ; int limit = points . points [ i ] . ends . next ; for ( int j = NUM_ ; j < limit ; j += NUM_ ) { int dest = transitions [ j ] ; statesSet . decr ( dest ) ; accCount -= a . isAccept ( dest ) ? NUM_ : NUM_ ; } points . points [ i ] . ends . next = NUM_ ; transitions = points . points [ i ] . starts . transitions ; limit = points . points [ i ] . starts . next ; for ( int j = NUM_ ; j < limit ; j += NUM_ ) { int dest = transitions [ j ] ; statesSet . incr ( dest ) ; accCount += a . isAccept ( dest ) ? NUM_ : NUM_ ; } lastPoint = point ; points . points [ i ] . starts . next = NUM_ ; } points . reset ( ) ; assert statesSet . upto == NUM_ : STR_ + statesSet . upto ; } Automaton result = b . finish ( ) ; assert result . isDeterministic ( ) ; return result ; }
public boolean matches ( String seq ) { return queue . regionMatches ( BOOL_ , pos , seq , NUM_ , seq . length ( ) ) ; }
private boolean findRoot ( final ODEStateInterpolator interpolator , final double ta , final double ga , final double tb , final double gb ) { check ( ga == NUM_ || gb == NUM_ || ( ga > NUM_ && gb < NUM_ ) || ( ga < NUM_ && gb > NUM_ ) ) ; final UnivariateFunction f = null ; double beforeRootT = Double . NaN , beforeRootG = Double . NaN ; double afterRootT = ta , afterRootG = NUM_ ; if ( ta == tb ) { beforeRootT = ta ; beforeRootG = ga ; afterRootT = shiftedBy ( beforeRootT , convergence ) ; afterRootG = f . value ( afterRootT ) ; } else if ( ga != NUM_ && gb == NUM_ ) { beforeRootT = tb ; beforeRootG = gb ; afterRootT = shiftedBy ( beforeRootT , convergence ) ; afterRootG = f . value ( afterRootT ) ; } else if ( ga != NUM_ ) { final double newGa = f . value ( ta ) ; if ( ga > NUM_ != newGa > NUM_ ) { beforeRootT = ta ; beforeRootG = newGa ; afterRootT = minTime ( shiftedBy ( beforeRootT , convergence ) , tb ) ; afterRootG = f . value ( afterRootT ) ; } } double loopT = ta , loopG = ga ; while ( ( afterRootG == NUM_ || afterRootG > NUM_ == g0Positive ) && strictlyAfter ( afterRootT , tb ) ) { if ( loopG == NUM_ ) { beforeRootT = loopT ; beforeRootG = loopG ; afterRootT = minTime ( shiftedBy ( beforeRootT , convergence ) , tb ) ; afterRootG = f . value ( afterRootT ) ; } else { if ( forward ) { final Interval interval = solver . solveInterval ( maxIterationCount , f , loopT , tb ) ; beforeRootT = interval . getLeftAbscissa ( ) ; beforeRootG = interval . getLeftValue ( ) ; afterRootT = interval . getRightAbscissa ( ) ; afterRootG = interval . getRightValue ( ) ; } else { final Interval interval = solver . solveInterval ( maxIterationCount , f , tb , loopT ) ; beforeRootT = interval . getRightAbscissa ( ) ; beforeRootG = interval . getRightValue ( ) ; afterRootT = interval . getLeftAbscissa ( ) ; afterRootG = interval . getLeftValue ( ) ; } } if ( beforeRootT == afterRootT ) { afterRootT = nextAfter ( afterRootT ) ; afterRootG = f . value ( afterRootT ) ; } check ( ( forward && afterRootT > beforeRootT ) || ( ! forward && afterRootT < beforeRootT ) ) ; loopT = afterRootT ; loopG = afterRootG ; } if ( afterRootG == NUM_ || afterRootG > NUM_ == g0Positive ) { return BOOL_ ; } else { check ( ! Double . isNaN ( beforeRootT ) && ! Double . isNaN ( beforeRootG ) ) ; increasing = ! g0Positive ; pendingEventTime = beforeRootT ; stopTime = beforeRootG == NUM_ ? beforeRootT : afterRootT ; pendingEvent = BOOL_ ; afterEvent = afterRootT ; afterG = afterRootG ; check ( afterG > NUM_ == increasing ) ; check ( increasing == gb >= ga ) ; return BOOL_ ; } }
public static int compare ( Comparable c1 , Comparable c2 , boolean nullGreater ) { if ( c1 == c2 ) { return NUM_ ; } else if ( c1 == null ) { return ( nullGreater ? NUM_ : - NUM_ ) ; } else if ( c2 == null ) { return ( nullGreater ? - NUM_ : NUM_ ) ; } return c1 . compareTo ( c2 ) ; }
public boolean checkRootBySuperUserApk ( ) { File suApk = new File ( SU_APK ) ; if ( suApk != null && suApk . exists ( ) ) { return BOOL_ ; } return BOOL_ ; }
int addExpression ( Expression expression ) ;
boolean trackMotionScroll ( int deltaY , int incrementalDeltaY ) { final int childCount = getChildCount ( ) ; if ( childCount == NUM_ ) { return BOOL_ ; } final int firstTop = getScrollChildTop ( ) ; final int lastBottom = getScrollChildBottom ( ) ; final Rect listPadding = mListPadding ; final int end = getHeight ( ) - listPadding . bottom ; final int spaceAbove = listPadding . top - getFillChildTop ( ) ; final int spaceBelow = getFillChildBottom ( ) - end ; final int height = getHeight ( ) - getPaddingBottom ( ) - getPaddingTop ( ) ; if ( deltaY < NUM_ ) { deltaY = Math . max ( - ( height - NUM_ ) , deltaY ) ; } else { deltaY = Math . min ( height - NUM_ , deltaY ) ; } if ( incrementalDeltaY < NUM_ ) { incrementalDeltaY = Math . max ( - ( height - NUM_ ) , incrementalDeltaY ) ; } else { incrementalDeltaY = Math . min ( height - NUM_ , incrementalDeltaY ) ; } final int firstPosition = mFirstPosition ; if ( firstPosition == NUM_ && firstTop >= listPadding . top && deltaY >= NUM_ ) { return BOOL_ ; } if ( firstPosition + childCount == mItemCount && lastBottom <= end && deltaY <= NUM_ ) { return BOOL_ ; } final boolean down = incrementalDeltaY < NUM_ ; final int headerViewsCount = getHeaderViewsCount ( ) ; final int footerViewsStart = mItemCount - getFooterViewsCount ( ) ; int start = NUM_ ; int count = NUM_ ; if ( down ) { final int top = listPadding . top - incrementalDeltaY ; for ( int i = NUM_ ; i < childCount ; i ++ ) { final View child = getChildAt ( i ) ; if ( child . getBottom ( ) >= top ) { break ; } else { count ++ ; int position = firstPosition + i ; if ( position >= headerViewsCount && position < footerViewsStart ) { mRecycler . addScrapView ( child ) ; if ( ViewDebug . TRACE_RECYCLER ) { ViewDebug . trace ( child , ViewDebug . RecyclerTraceType . MOVE_TO_SCRAP_HEAP , firstPosition + i , - NUM_ ) ; } } } } } else { final int bottom = getHeight ( ) - listPadding . bottom - incrementalDeltaY ; for ( int i = childCount - NUM_ ; i >= NUM_ ; i -- ) { final View child = getChildAt ( i ) ; if ( child . getTop ( ) <= bottom ) { break ; } else { start = i ; count ++ ; int position = firstPosition + i ; if ( position >= headerViewsCount && position < footerViewsStart ) { mRecycler . addScrapView ( child ) ; if ( ViewDebug . TRACE_RECYCLER ) { ViewDebug . trace ( child , ViewDebug . RecyclerTraceType . MOVE_TO_SCRAP_HEAP , firstPosition + i , - NUM_ ) ; } } } } } mMotionViewNewTop = mMotionViewOriginalTop + deltaY ; mBlockLayoutRequests = BOOL_ ; if ( count > NUM_ ) { detachViewsFromParent ( start , count ) ; } tryOffsetChildrenTopAndBottom ( incrementalDeltaY ) ; if ( down ) { mFirstPosition += count ; } invalidate ( ) ; final int absIncrementalDeltaY = Math . abs ( incrementalDeltaY ) ; if ( spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY ) { fillGap ( down ) ; } mBlockLayoutRequests = BOOL_ ; invokeOnItemScrollListener ( ) ; awakenScrollBars ( ) ; return BOOL_ ; }
public static < E > E syncRest ( final Iterator < ? extends Object > iterator , final Callable < E > task ) throws Exception { if ( iterator . hasNext ( ) ) { synchronized ( iterator . next ( ) ) { return syncRest ( iterator , task ) ; } } else { return task . call ( ) ; } }
private static Component findByName ( Container root , String componentName ) { if ( verbose ) { log ( STR_ + root + STR_ + componentName + STR_ ) ; } int count = root . getComponentCount ( ) ; for ( int iter = NUM_ ; iter < count ; iter ++ ) { Component c = root . getComponentAt ( iter ) ; String n = c . getName ( ) ; if ( n != null && n . equals ( componentName ) ) { return c ; } if ( c instanceof Container ) { c = findByName ( ( Container ) c , componentName ) ; if ( c != null ) { return c ; } } } return null ; }
public boolean isFingerprint ( ClassTemplate classTemplate ) { return fingerprintClass . equals ( classTemplate . getImplementingClass ( ) ) ; }
public void writeField ( final String name , final float value ) throws java . io . IOException { writeField ( name , Float . toString ( value ) ) ; }
private List extractColumnKeys ( String line ) { List keys = new java . util . ArrayList ( ) ; int fieldIndex = NUM_ ; int start = NUM_ ; for ( int i = NUM_ ; i < line . length ( ) ; i ++ ) { if ( line . charAt ( i ) == this . fieldDelimiter ) { if ( fieldIndex > NUM_ ) { String key = line . substring ( start , i ) ; keys . add ( removeStringDelimiters ( key ) ) ; } start = i + NUM_ ; fieldIndex ++ ; } } String key = line . substring ( start , line . length ( ) ) ; keys . add ( removeStringDelimiters ( key ) ) ; return keys ; }
protected void drawRhombus ( int x , int y , int w , int h , Color fillColor , Paint fillPaint , Color penColor , boolean shadow ) { int halfWidth = w / NUM_ ; int halfHeight = h / NUM_ ; Polygon rhombus = new Polygon ( ) ; rhombus . addPoint ( x + halfWidth , y ) ; rhombus . addPoint ( x + w , y + halfHeight ) ; rhombus . addPoint ( x + halfWidth , y + h ) ; rhombus . addPoint ( x , y + halfHeight ) ; drawPolygon ( rhombus , fillColor , fillPaint , penColor , shadow ) ; }
private void convertAndFillByteBufferListToByteArrayList ( List < byte [ ] > dictionaryValues , List < ByteBuffer > dictionaryValueBufferList ) { for ( ByteBuffer buffer : dictionaryValueBufferList ) { int length = buffer . limit ( ) ; byte [ ] value = new byte [ length ] ; buffer . get ( value , NUM_ , value . length ) ; dictionaryValues . add ( value ) ; } }
static Object instantiate ( Class < ? > sibling , String className ) throws InstantiationException , IllegalAccessException , ClassNotFoundException { ClassLoader cl = sibling . getClassLoader ( ) ; Class < ? > cls = ClassFinder . findClass ( className , cl ) ; return cls . newInstance ( ) ; }
private byte [ ] generateDerivedKey ( int bytesNeeded ) { byte [ ] buf = new byte [ digest . getDigestSize ( ) ] ; byte [ ] key = new byte [ bytesNeeded ] ; int offset = NUM_ ; for ( ; ; ) { digest . update ( password , NUM_ , password . length ) ; digest . update ( salt , NUM_ , salt . length ) ; digest . doFinal ( buf , NUM_ ) ; int len = ( bytesNeeded > buf . length ) ? buf . length : bytesNeeded ; System . arraycopy ( buf , NUM_ , key , offset , len ) ; offset += len ; bytesNeeded -= len ; if ( bytesNeeded == NUM_ ) { break ; } digest . reset ( ) ; digest . update ( buf , NUM_ , buf . length ) ; } return key ; }
public void testSystemRunFinalizationReturnsEvenIfQueueIsNonEmpty ( ) throws Exception { AtomicInteger count = new AtomicInteger ( ) ; AtomicBoolean keepGoing = new AtomicBoolean ( BOOL_ ) ; createChainedFinalizer ( count , keepGoing ) ; while ( count . get ( ) == NUM_ ) { Thread . sleep ( NUM_ ) ; FinalizationTester . induceFinalization ( ) ; } keepGoing . set ( BOOL_ ) ; assertTrue ( count . get ( ) > NUM_ ) ; }
public synchronized void show ( Bundle options ) { if ( DEBUG ) Log . d ( TAG , STR_ + mKeyguardView ) ; boolean enableScreenRotation = shouldEnableScreenRotation ( ) ; maybeCreateKeyguardLocked ( enableScreenRotation , BOOL_ , options ) ; maybeEnableScreenRotation ( enableScreenRotation ) ; final int visFlags = View . STATUS_BAR_DISABLE_HOME ; if ( DEBUG ) Log . v ( TAG , STR_ + Integer . toHexString ( visFlags ) + STR_ ) ; mKeyguardHost . setSystemUiVisibility ( visFlags ) ; mViewManager . updateViewLayout ( mKeyguardHost , mWindowLayoutParams ) ; mKeyguardHost . setVisibility ( View . VISIBLE ) ; mKeyguardView . show ( ) ; mKeyguardView . requestFocus ( ) ; }
public static int computeStringWidth ( FontMetrics fm , String str ) { return SwingUtilities2 . stringWidth ( null , fm , str ) ; }
private boolean passesSanityCheck ( AccessibilityEvent event ) { final CharSequence afterText = getEventText ( event ) ; final CharSequence beforeText = event . getBeforeText ( ) ; if ( ( event . getAddedCount ( ) == NUM_ ) && ( event . getRemovedCount ( ) == beforeText . length ( ) ) ) { return BOOL_ ; } if ( afterText == null || beforeText == null ) { return BOOL_ ; } final int diff = ( event . getAddedCount ( ) - event . getRemovedCount ( ) ) ; return ( ( beforeText . length ( ) + diff ) == afterText . length ( ) ) ; }
public void actionPerformed ( ActionEvent ae ) { String command = ae . getActionCommand ( ) ; if ( command == DisplayPaletteCmd ) { if ( Debug . debugging ( STR_ ) ) { Debug . output ( getName ( ) + STR_ ) ; } showPalette ( ) ; } else if ( command == HidePaletteCmd ) { if ( Debug . debugging ( STR_ ) ) { Debug . output ( getName ( ) + STR_ ) ; } hidePalette ( ) ; } else if ( command == DisplayPropertiesCmd ) { Inspector inspector = new Inspector ( ) ; inspector . inspectPropertyConsumer ( this ) ; } }
public static String toString ( LocalDate data ) { return data == null ? STR_ : data . format ( formatter ( STR_ ) ) ; }
@ JsonCreator public DataSourceMetadata ( @ JsonProperty ( STR_ ) String name , @ JsonProperty ( STR_ ) Map < String , String > properties , @ JsonProperty ( STR_ ) List < DataSegment > segments ) { this . name = name ; this . properties = Collections . unmodifiableMap ( properties ) ; this . segments = Collections . unmodifiableList ( segments ) ; }
public EMail createEMail ( String value ) { EmailField emailImpl = new EmailField ( ) ; try { emailImpl . setValue ( value ) ; } catch ( SdpException s ) { s . printStackTrace ( ) ; } return emailImpl ; }
public AddressLookup ( String serverUrl , String serialNo , String password ) { this . serverUrl = serverUrl . trim ( ) ; this . clientID = serialNo . trim ( ) ; this . accessCode = password . trim ( ) ; }
public void addChangeListener ( ChangeListener l ) { m_ChangeListeners . add ( l ) ; }
public Node ( String permission , boolean value , boolean override , long expireAt , String server , String world , ContextSet contexts ) { if ( permission == null || permission . equals ( STR_ ) ) { throw new IllegalArgumentException ( STR_ ) ; } if ( server != null && ( server . equalsIgnoreCase ( STR_ ) || server . equals ( STR_ ) ) ) { server = null ; } if ( world != null && world . equals ( STR_ ) ) { world = null ; } if ( world != null && server == null ) { server = STR_ ; } this . permission = permission ; this . value = value ; this . override = override ; this . expireAt = expireAt ; this . server = server ; this . world = world ; this . contexts = contexts == null ? ContextSet . empty ( ) : contexts . makeImmutable ( ) ; }
public Cell ( int rowspan , int colspan ) { this . rowspan = Math . max ( rowspan , NUM_ ) ; this . colspan = Math . max ( colspan , NUM_ ) ; }
private void initializeLocalAndTargetInfo ( ) throws Exception { targetSiteInfo = coordinator . getTargetInfo ( SiteInfo . class ) ; if ( targetSiteInfo == null ) { targetSiteInfo = new SiteInfo ( ) ; try { coordinator . setTargetInfo ( targetSiteInfo , BOOL_ ) ; log . info ( STR_ , targetSiteInfo ) ; } catch ( CoordinatorClientException e ) { log . info ( STR_ ) ; retrySleep ( ) ; throw e ; } } localVdcPropInfo = localRepository . getVdcPropertyInfo ( ) ; String localConfigVersion = localVdcPropInfo . getProperty ( VdcConfigUtil . VDC_CONFIG_VERSION ) ; coordinator . setNodeSessionScopeInfo ( new VdcConfigVersion ( localConfigVersion ) ) ; targetVdcPropInfo = loadVdcConfig ( ) ; if ( isGeoUpgradeFromPreYoda ( ) ) { log . info ( STR_ ) ; localVdcPropInfo . addProperty ( VdcConfigUtil . VDC_CONFIG_VERSION , String . valueOf ( targetSiteInfo . getVdcConfigVersion ( ) ) ) ; localRepository . setVdcPropertyInfo ( localVdcPropInfo ) ; } else { if ( localVdcPropInfo . getProperty ( VdcConfigUtil . VDC_CONFIG_VERSION ) == null ) { localVdcPropInfo = new PropertyInfoExt ( targetVdcPropInfo . getAllProperties ( ) ) ; localVdcPropInfo . addProperty ( VdcConfigUtil . VDC_CONFIG_VERSION , String . valueOf ( targetSiteInfo . getVdcConfigVersion ( ) ) ) ; localRepository . setVdcPropertyInfo ( localVdcPropInfo ) ; String vdc_ids = targetVdcPropInfo . getProperty ( VdcConfigUtil . VDC_IDS ) ; String [ ] vdcIds = vdc_ids . split ( STR_ ) ; if ( vdcIds . length > NUM_ ) { log . info ( STR_ ) ; reboot ( ) ; } } } targetPowerOffState = coordinator . getTargetInfo ( PowerOffState . class ) ; if ( targetPowerOffState == null ) { try { coordinator . setTargetInfo ( new PowerOffState ( PowerOffState . State . NONE ) ) ; targetPowerOffState = coordinator . getTargetInfo ( PowerOffState . class ) ; log . info ( STR_ , PowerOffState . State . NONE ) ; } catch ( CoordinatorClientException e ) { log . info ( STR_ ) ; retrySleep ( ) ; throw e ; } } }
@ Override public void openElement ( String tagName ) { XMLElement newElement = new XMLElement ( ) ; newElement . setName ( tagName ) ; current . addChild ( newElement ) ; stack . push ( current ) ; current = newElement ; }
public Format ( String pFormatString ) { String formatVars [ ] = pFormatString . split ( STR_ ) ; mId = Integer . parseInt ( formatVars [ NUM_ ] ) ; }
public boolean equals ( Object interval ) { if ( intervals == null ) { return BOOL_ ; } return intervals . contains ( interval ) ; }
public static String relativeToAbsolute ( String baseURL , String relativeURL ) { if ( relativeURL . startsWith ( STR_ ) ) { return getURLProtocol ( baseURL ) + STR_ + getURLHost ( baseURL ) + relativeURL ; } else { return getURLProtocol ( baseURL ) + STR_ + getURLHost ( baseURL ) + getURLBasePath ( baseURL ) + relativeURL ; } }
public void start ( ) { if ( setState ( EnumSet . of ( TaskState . INITIAL , TaskState . QUEUED ) , TaskState . RUNNING ) ) { DHT . logDebug ( STR_ + toString ( ) ) ; startTime = System . currentTimeMillis ( ) ; try { serializedUpdate . run ( ) ; } catch ( Exception e ) { DHT . log ( e , LogLevel . Error ) ; } } }
public JournalIndex ( final IRawStore store , final Checkpoint checkpoint , final IndexMetadata metadata , final boolean readOnly ) { super ( store , checkpoint , metadata , readOnly ) ; }
private void accesBreakpointInstruction ( ArrayList < Instruction > instructions , int lineNumber , int op , BPINSTRUCTION_STATUS status ) { for ( int i = NUM_ ; i < instructions . size ( ) ; i ++ ) { Instruction currInst = instructions . get ( i ) ; if ( op == NUM_ ) { if ( currInst instanceof MRJobInstruction ) { MRJobInstruction currMRInst = ( MRJobInstruction ) currInst ; if ( currMRInst . findMRInstructions ( lineNumber ) ) { BreakPointInstruction breakpoint = new BreakPointInstruction ( ) ; breakpoint . setLocation ( currInst ) ; breakpoint . setInstID ( instID ++ ) ; breakpoint . setBPInstructionLocation ( location ) ; instructions . add ( i , breakpoint ) ; DMLBreakpointManager . insertBreakpoint ( breakpoint , lineNumber ) ; return ; } } else if ( currInst instanceof CPInstruction || currInst instanceof SPInstruction ) { if ( currInst . getLineNum ( ) == lineNumber ) { BreakPointInstruction breakpoint = new BreakPointInstruction ( ) ; breakpoint . setLocation ( currInst ) ; breakpoint . setInstID ( instID ++ ) ; breakpoint . setBPInstructionLocation ( location ) ; instructions . add ( i , breakpoint ) ; DMLBreakpointManager . insertBreakpoint ( breakpoint , lineNumber ) ; return ; } } else if ( currInst instanceof BreakPointInstruction && currInst . getLineNum ( ) == lineNumber ) { BreakPointInstruction breakpoint = ( BreakPointInstruction ) currInst ; breakpoint . setBPInstructionStatus ( BPINSTRUCTION_STATUS . ENABLED ) ; breakpoint . setBPInstructionLocation ( location ) ; instructions . set ( i , breakpoint ) ; DMLBreakpointManager . updateBreakpoint ( lineNumber , status ) ; return ; } } else { if ( currInst instanceof BreakPointInstruction && currInst . getLineNum ( ) == lineNumber ) { if ( op == NUM_ ) { BreakPointInstruction breakpoint = ( BreakPointInstruction ) currInst ; breakpoint . setLocation ( currInst ) ; breakpoint . setInstID ( currInst . getInstID ( ) ) ; breakpoint . setBPInstructionStatus ( status ) ; breakpoint . setBPInstructionLocation ( location ) ; instructions . set ( i , breakpoint ) ; DMLBreakpointManager . updateBreakpoint ( lineNumber , status ) ; } else { instructions . remove ( i ) ; DMLBreakpointManager . removeBreakpoint ( lineNumber , status ) ; } return ; } } } }
private void closeFile ( ) { if ( plogStream != null ) { try { plogStream . close ( ) ; logger . info ( STR_ + plogFilename + STR_ ) ; } catch ( IOException e ) { logger . warn ( STR_ + plogFilename ) ; } finally { plogStream = null ; } } }
public void nextToken ( ) { previousLine = line ; previousColumn = column ; while ( pos < matcher . regionStart ( ) ) { if ( text . charAt ( pos ) == STR_ ) { ++ line ; column = NUM_ ; } else { ++ column ; } ++ pos ; } if ( matcher . regionStart ( ) == matcher . regionEnd ( ) ) { currentToken = STR_ ; } else { matcher . usePattern ( TOKEN ) ; if ( matcher . lookingAt ( ) ) { currentToken = matcher . group ( ) ; matcher . region ( matcher . end ( ) , matcher . regionEnd ( ) ) ; } else { currentToken = String . valueOf ( text . charAt ( pos ) ) ; matcher . region ( pos + NUM_ , matcher . regionEnd ( ) ) ; } skipWhitespace ( ) ; } }
private void parseFirstConsonant ( ) { Iterator iter = alFirstConsonants . iterator ( ) ; while ( iter . hasNext ( ) ) { String strFirstCon = ( String ) iter . next ( ) ; if ( strSyllable . startsWith ( strFirstCon , iCurPos ) ) { strFirstConsonant = strFirstCon ; iCurPos += strFirstCon . length ( ) ; return ; } } strFirstConsonant = ZERO ; }
private BuddyPanelController ( ) { buddyPanel = new JPanel ( ) ; buddyPanel . setLayout ( new SBoxLayout ( SBoxLayout . VERTICAL ) ) ; model = new BuddyListModel ( ) ; JList < Buddy > list = new BuddyPanel ( model ) ; buddyPanel . add ( list , SLayout . EXPAND_X ) ; }
private void removeGapsWithEdgeConcentration ( int nodesLevel [ ] ) { final int temp = m_nodes . size ( ) , temp2 = graphMatrix [ NUM_ ] . length ; int tempCnt = NUM_ ; for ( int n = NUM_ ; n < temp ; n ++ ) { for ( int i = NUM_ ; i < temp2 ; i ++ ) { if ( graphMatrix [ n ] [ i ] > NUM_ ) { if ( nodesLevel [ i ] > nodesLevel [ n ] + NUM_ ) { int tempLevel = nodesLevel [ n ] ; boolean tempNodePresent = BOOL_ ; int k = temp ; int tempnode = n ; while ( tempLevel < nodesLevel [ i ] - NUM_ ) { tempNodePresent = BOOL_ ; for ( ; k < graphMatrix . length ; k ++ ) { if ( graphMatrix [ tempnode ] [ k ] > NUM_ ) { tempNodePresent = BOOL_ ; break ; } } if ( tempNodePresent ) { tempnode = k ; k = k + NUM_ ; tempLevel ++ ; } else { if ( tempnode != n ) { tempnode = k - NUM_ ; } break ; } } if ( m_nodes . get ( tempnode ) . nodeType == SINGULAR_DUMMY ) { m_nodes . get ( tempnode ) . nodeType = PLURAL_DUMMY ; } if ( tempNodePresent ) { graphMatrix [ tempnode ] [ i ] = graphMatrix [ n ] [ i ] ; graphMatrix [ i ] [ tempnode ] = - graphMatrix [ n ] [ i ] ; graphMatrix [ n ] [ i ] = NUM_ ; graphMatrix [ i ] [ n ] = NUM_ ; continue ; } int len = graphMatrix . length ; int tempMatrix [ ] [ ] = new int [ graphMatrix . length + ( nodesLevel [ i ] - nodesLevel [ tempnode ] - NUM_ ) ] [ graphMatrix . length + ( nodesLevel [ i ] - nodesLevel [ tempnode ] - NUM_ ) ] ; int level = nodesLevel [ tempnode ] + NUM_ ; copyMatrix ( graphMatrix , tempMatrix ) ; String s1 = new String ( STR_ + tempCnt ++ ) ; m_nodes . add ( new GraphNode ( s1 , s1 , SINGULAR_DUMMY ) ) ; int temp3 [ ] = new int [ nodeLevels [ level ] . length + NUM_ ] ; System . arraycopy ( nodeLevels [ level ] , NUM_ , temp3 , NUM_ , nodeLevels [ level ] . length ) ; temp3 [ temp3 . length - NUM_ ] = m_nodes . size ( ) - NUM_ ; nodeLevels [ level ] = temp3 ; temp3 = new int [ m_nodes . size ( ) + NUM_ ] ; System . arraycopy ( nodesLevel , NUM_ , temp3 , NUM_ , nodesLevel . length ) ; temp3 [ m_nodes . size ( ) - NUM_ ] = level ; nodesLevel = temp3 ; level ++ ; int m ; for ( m = len ; m < len + nodesLevel [ i ] - nodesLevel [ tempnode ] - NUM_ - NUM_ ; m ++ ) { String s2 = new String ( STR_ + tempCnt ++ ) ; m_nodes . add ( new GraphNode ( s2 , s2 , SINGULAR_DUMMY ) ) ; temp3 = new int [ nodeLevels [ level ] . length + NUM_ ] ; System . arraycopy ( nodeLevels [ level ] , NUM_ , temp3 , NUM_ , nodeLevels [ level ] . length ) ; temp3 [ temp3 . length - NUM_ ] = m_nodes . size ( ) - NUM_ ; nodeLevels [ level ] = temp3 ; temp3 = new int [ m_nodes . size ( ) + NUM_ ] ; System . arraycopy ( nodesLevel , NUM_ , temp3 , NUM_ , nodesLevel . length ) ; temp3 [ m_nodes . size ( ) - NUM_ ] = level ; nodesLevel = temp3 ; level ++ ; tempMatrix [ m ] [ m + NUM_ ] = tempMatrix [ n ] [ i ] ; if ( m > len ) { tempMatrix [ m ] [ m - NUM_ ] = - NUM_ . tempMatrix [ n ] [ i ] ; } } tempMatrix [ m ] [ i ] = tempMatrix [ n ] [ i ] ; tempMatrix [ tempnode ] [ len ] = tempMatrix [ n ] [ i ] ; tempMatrix [ len ] [ tempnode ] = - NUM_ . tempMatrix [ n ] [ i ] ; tempMatrix [ i ] [ m ] = - NUM_ . tempMatrix [ n ] [ i ] ; if ( m > len ) { tempMatrix [ m ] [ m - NUM_ ] = - NUM_ . tempMatrix [ n ] [ i ] ; } tempMatrix [ n ] [ i ] = NUM_ ; tempMatrix [ i ] [ n ] = NUM_ ; graphMatrix = tempMatrix ; } else { graphMatrix [ i ] [ n ] = - NUM_ . graphMatrix [ n ] [ i ] ; } } } } }
public static byte [ ] asUnsignedByteArray ( BigInteger value ) { byte [ ] bytes = value . toByteArray ( ) ; if ( bytes [ NUM_ ] == NUM_ ) { byte [ ] tmp = new byte [ bytes . length - NUM_ ] ; System . arraycopy ( bytes , NUM_ , tmp , NUM_ , tmp . length ) ; return tmp ; } return bytes ; }
public static TestResult execJavac ( String toCompile , File dir , String jflexTestVersion ) { Project p = new Project ( ) ; Javac javac = new Javac ( ) ; Path path = new Path ( p , dir . toString ( ) ) ; javac . setProject ( p ) ; javac . setSrcdir ( path ) ; javac . setDestdir ( dir ) ; javac . setTarget ( javaVersion ) ; javac . setSource ( javaVersion ) ; javac . setSourcepath ( new Path ( p , STR_ ) ) ; javac . setIncludes ( toCompile ) ; Path classPath = javac . createClasspath ( ) ; classPath . setPath ( System . getProperty ( STR_ ) + STR_ + jflexTestVersion + STR_ + jflexTestVersion + STR_ ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; PrintStream outSafe = System . err ; System . setErr ( new PrintStream ( out ) ) ; try { javac . execute ( ) ; return new TestResult ( out . toString ( ) , BOOL_ ) ; } catch ( BuildException e ) { return new TestResult ( e + System . getProperty ( STR_ ) + out . toString ( ) , BOOL_ ) ; } finally { System . setErr ( outSafe ) ; } }
private final boolean parkAndCheckInterrupt ( ) { LockSupport . park ( this ) ; return Thread . interrupted ( ) ; }
public static CLPlatform [ ] listGPUPoweredPlatforms ( ) { CLPlatform [ ] platforms = listPlatforms ( ) ; List < CLPlatform > out = new ArrayList < CLPlatform > ( platforms . length ) ; for ( CLPlatform platform : platforms ) { if ( platform . listGPUDevices ( BOOL_ ) . length > NUM_ ) out . add ( platform ) ; } return out . toArray ( new CLPlatform [ out . size ( ) ] ) ; }
public ActionRequestHelper dependsOn ( ActionRequestHelper dependency ) { mDependencies . add ( dependency ) ; return this ; }
static boolean isDate ( Object obj ) { return obj instanceof Date && obj . getClass ( ) == Date . class ; }
public static String toXml ( final Config toConvert , Boolean prettyXml ) throws JAXBException , IOException { String retVal = STR_ ; try ( StringWriter writer = new StringWriter ( ) ) { toXml ( toConvert , writer , prettyXml ) ; retVal = writer . toString ( ) ; return retVal ; } }
private static List < Vector2D > buildQuadrilateral ( final Vector2D ... points ) { List < Vector2D > quadrilateral = new ArrayList < Vector2D > ( ) ; for ( Vector2D p : points ) { if ( ! quadrilateral . contains ( p ) ) { quadrilateral . add ( p ) ; } } return quadrilateral ; }
private void heapifyUp ( int twopos , Comparable < Object > cur ) { while ( twopos > NUM_ ) { final int parent = ( twopos - NUM_ ) > > > NUM_ ; Comparable < Object > par = twoheap [ parent ] ; if ( cur . compareTo ( par ) <= NUM_ ) { break ; } twoheap [ twopos ] = par ; twopos = parent ; } twoheap [ twopos ] = cur ; }
public void insert ( String key , char val ) { int len = key . length ( ) + NUM_ ; if ( freenode + len > eq . length ) { redimNodeArrays ( eq . length + BLOCK_SIZE ) ; } char strkey [ ] = new char [ len -- ] ; key . getChars ( NUM_ , len , strkey , NUM_ ) ; strkey [ len ] = NUM_ ; root = insert ( root , strkey , NUM_ , val ) ; }
void fullyUnlock ( ) { takeLock . unlock ( ) ; putLock . unlock ( ) ; }
private static boolean isSubFormat ( String filename ) { for ( String ext : SUB_EXTENSIONS ) { if ( filename . contains ( STR_ + ext ) ) { return BOOL_ ; } } return BOOL_ ; }
void write ( Environment env , DataOutputStream out , ConstantPool tab ) throws IOException { out . writeByte ( CONSTANT_NAMEANDTYPE ) ; out . writeShort ( tab . index ( name ) ) ; out . writeShort ( tab . index ( type ) ) ; }
public static void initializeProperties ( Properties properties , boolean reset , boolean withDefaults ) { Properties defaultProp = null ; if ( withDefaults ) { SSOToken appToken = AccessController . doPrivileged ( AdminTokenAction . getInstance ( ) ) ; defaultProp = ServerConfiguration . getDefaults ( appToken ) ; } PropertiesHolder oldProps ; PropertiesHolder newProps ; do { oldProps = propertiesHolderRef . get ( ) ; final Properties combined = new Properties ( ) ; if ( defaultProp != null ) { combined . putAll ( defaultProp ) ; } if ( ! reset ) { combined . putAll ( oldProps . properties ) ; } combined . putAll ( properties ) ; newProps = new PropertiesHolder ( Maps . fromProperties ( combined ) ) ; } while ( ! propertiesHolderRef . compareAndSet ( oldProps , newProps ) ) ; }
public void addNetworkListener ( final NetworkListener listener ) { networkListeners . add ( listener ) ; }
public static void appendContentPrefix ( HttpServletRequest request , Appendable urlBuffer ) throws IOException { appendContentPrefix ( request , urlBuffer , null ) ; }
public void addErrorListener ( final ErrorListener errorListener ) { if ( errorListeners == null ) { errorListeners = new ArrayList < ErrorListener > ( ) ; } errorListeners . add ( errorListener ) ; }
private void validateClassName ( String className ) { String nvalue = className . trim ( ) ; if ( ! nvalue . matches ( CLASS_RE ) ) { throw PropertyException . illegalPropertyValueException ( this , className ) ; } }
public static void importBaseTypes ( final CConnection connection , final int rawModuleId , final int moduleId ) throws SQLException { final String query = STR_ + CTableNames . BASE_TYPES_TABLE + STR_ + moduleId + STR_ + STR_ + String . format ( CTableNames . RAW_BASE_TYPES , rawModuleId ) ; connection . executeUpdate ( query , BOOL_ ) ; final String updateSequence = String . format ( STR_ + STR_ , CTableNames . BASE_TYPES_TABLE , CTableNames . BASE_TYPES_TABLE ) ; connection . executeQuery ( updateSequence , BOOL_ ) ; }
@ SuppressWarnings ( STR_ ) public Object readMatrixOld ( Element node ) throws Exception { weka . core . Matrix matrix ; weka . core . matrix . Matrix matrixNew ; if ( DEBUG ) { trace ( new Throwable ( ) , node . getAttribute ( ATT_NAME ) ) ; } m_CurrentNode = node ; matrixNew = ( weka . core . matrix . Matrix ) readMatrix ( node ) ; matrix = new weka . core . Matrix ( matrixNew . getArrayCopy ( ) ) ; return matrix ; }
public void recordFileSystemOperation ( DbClient dbClient , OperationTypeEnum opType , Operation . Status status , Object ... extParam ) { try { boolean opStatus = ( Operation . Status . ready == status ) ? BOOL_ : BOOL_ ; String evType ; evType = opType . getEvType ( opStatus ) ; String evDesc = opType . getDescription ( ) ; String opStage = AuditLogManager . AUDITOP_END ; _logger . info ( STR_ , opType . toString ( ) , evType . toString ( ) + STR_ + evDesc ) ; URI uri = ( URI ) extParam [ NUM_ ] ; recordBourneFileSystemEvent ( dbClient , evType , status , evDesc , uri ) ; auditFile ( dbClient , opType , opStatus , opStage , uri . toString ( ) ) ; } catch ( Exception e ) { _logger . error ( STR_ , opType . toString ( ) , e ) ; } }
public CoreTokenException ( int errorCode ) { this . errorCode = errorCode ; this . message = getLocalizedMessage ( Locale . getDefault ( ) ) ; }
public DExamineSsl ( JFrame parent , KseFrame kseFrame ) { super ( parent , res . getString ( STR_ ) , Dialog . ModalityType . DOCUMENT_MODAL ) ; this . kseFrame = kseFrame ; initComponents ( ) ; }
private static List < String > computeDynamicVMArgs ( IJavaProject javaProject ) { ArrayList < String > out = new ArrayList < String > ( ) ; String devJarPath = maybeGetDevJarPath ( javaProject ) ; if ( devJarPath . length ( ) > NUM_ ) { out . add ( STR_ + devJarPath + STR_ ) ; } return out ; }
static void normalize ( StringBuilder number ) { String normalizedNumber = normalize ( number . toString ( ) ) ; number . replace ( NUM_ , number . length ( ) , normalizedNumber ) ; }
public double [ ] skipTo ( final int index ) throws MathIllegalArgumentException { if ( index == NUM_ ) { Arrays . fill ( x , NUM_ ) ; } else { final int i = index - NUM_ ; final long grayCode = i ^ ( i > > NUM_ ) ; for ( int j = NUM_ ; j < dimension ; j ++ ) { long result = NUM_ ; for ( int k = NUM_ ; k <= BITS ; k ++ ) { final long shift = grayCode > > ( k - NUM_ ) ; if ( shift == NUM_ ) { break ; } final long ik = shift & NUM_ ; result ^= ik . direction [ j ] [ k ] ; } x [ j ] = result ; } } count = index ; return nextVector ( ) ; }
public void removeOrganizationConfiguration ( String orgName , String groupName , boolean checkLegacyMode ) throws SMSException , SSOException { if ( ( groupName == null ) || groupName . length ( ) == NUM_ ) { groupName = SMSUtils . DEFAULT ; } String orgdn = DNMapper . orgNameToDN ( orgName ) ; validateSCM ( ) ; String odn = scm . constructServiceConfigDN ( groupName , CreateServiceConfig . ORG_CONFIG_NODE , orgdn ) ; CachedSMSEntry cEntry = CachedSMSEntry . getInstance ( token , odn ) ; if ( cEntry . isNewEntry ( ) ) { return ; } if ( checkLegacyMode && ServiceManager . isCoexistenceMode ( ) && groupName . equalsIgnoreCase ( SMSUtils . DEFAULT ) ) { OrgConfigViaAMSDK amsdk = new OrgConfigViaAMSDK ( token , DNMapper . realmNameToAMSDKName ( orgdn ) , orgdn ) ; amsdk . unassignService ( serviceName ) ; } if ( ! cEntry . isNewEntry ( ) ) { SMSEntry entry = cEntry . getClonedSMSEntry ( ) ; entry . delete ( token ) ; cEntry . refresh ( entry ) ; } }
public void removeGroupListener ( final GroupListener listener ) { groupListeners . remove ( listener ) ; }
public SetChangelogMapping ( String source , String taskName , int changelogPartitionNumber ) { super ( source ) ; setType ( TYPE ) ; setKey ( taskName ) ; putMessageValue ( CHANGELOG_VALUE_KEY , String . valueOf ( changelogPartitionNumber ) ) ; }
@ Override protected String extractKey ( final String name ) { final String key = unescape ( name . substring ( NUM_ , name . length ( ) - NUM_ ) ) ; return key . equals ( STR_ ) ? null : key ; }
private static float spacing ( MotionEvent event ) { float x = event . getX ( NUM_ ) - event . getX ( NUM_ ) ; float y = event . getY ( NUM_ ) - event . getY ( NUM_ ) ; return ( float ) Math . sqrt ( x . x + y . y ) ; }
@ SuppressWarnings ( STR_ ) public static < K , V > void transformStringMap ( Map < String , String > original , Map < K , V > map , Class < K > keyClass , Class < V > valueClass ) throws PreferenceException { Method parseKeyMethod = findParseMethod ( keyClass ) ; Method parseValueMethod = findParseMethod ( valueClass ) ; if ( ( null != parseKeyMethod ) && ( null != parseValueMethod ) ) { for ( Map . Entry < String , String > toTransformEntry : original . entrySet ( ) ) { try { Object transformedKey = parseKeyMethod . invoke ( null , toTransformEntry . getKey ( ) ) ; Object transformedValue = parseValueMethod . invoke ( null , toTransformEntry . getValue ( ) ) ; if ( keyClass . isAssignableFrom ( transformedKey . getClass ( ) ) && valueClass . isAssignableFrom ( transformedValue . getClass ( ) ) ) { map . put ( ( K ) transformedKey , ( V ) transformedValue ) ; } } catch ( Exception e ) { throw new PreferenceException ( STR_ + keyClass . getName ( ) + STR_ + valueClass . getName ( ) + STR_ , e ) ; } } } else if ( null == parseKeyMethod ) { throw new PreferenceException ( STR_ + keyClass . getName ( ) + STR_ + valueClass . getName ( ) + STR_ + STR_ + keyClass . getName ( ) + STR_ ) ; } else { throw new PreferenceException ( STR_ + keyClass . getName ( ) + STR_ + valueClass . getName ( ) + STR_ + STR_ + valueClass . getName ( ) + STR_ ) ; } }
public boolean grabInput ( ) { if ( grabLog . isLoggable ( PlatformLogger . Level . FINE ) ) { grabLog . fine ( STR_ , this ) ; } XToolkit . awtLock ( ) ; try { if ( XAwtState . getGrabWindow ( ) == this && XAwtState . isManualGrab ( ) ) { grabLog . fine ( STR_ ) ; return BOOL_ ; } XBaseWindow prevGrabWindow = XAwtState . getGrabWindow ( ) ; final int eventMask = ( int ) ( XConstants . ButtonPressMask | XConstants . ButtonReleaseMask | XConstants . EnterWindowMask | XConstants . LeaveWindowMask | XConstants . PointerMotionMask | XConstants . ButtonMotionMask ) ; final int ownerEvents = NUM_ ; if ( ! XToolkit . getSunAwtDisableGrab ( ) ) { int ptrGrab = XlibWrapper . XGrabPointer ( XToolkit . getDisplay ( ) , getContentWindow ( ) , ownerEvents , eventMask , XConstants . GrabModeAsync , XConstants . GrabModeAsync , XConstants . None , ( XWM . isMotif ( ) ? XToolkit . arrowCursor : XConstants . None ) , XConstants . CurrentTime ) ; if ( ptrGrab != XConstants . GrabSuccess ) { XlibWrapper . XUngrabPointer ( XToolkit . getDisplay ( ) , XConstants . CurrentTime ) ; XAwtState . setGrabWindow ( null ) ; grabLog . fine ( STR_ ) ; return BOOL_ ; } int keyGrab = XlibWrapper . XGrabKeyboard ( XToolkit . getDisplay ( ) , getContentWindow ( ) , ownerEvents , XConstants . GrabModeAsync , XConstants . GrabModeAsync , XConstants . CurrentTime ) ; if ( keyGrab != XConstants . GrabSuccess ) { XlibWrapper . XUngrabPointer ( XToolkit . getDisplay ( ) , XConstants . CurrentTime ) ; XlibWrapper . XUngrabKeyboard ( XToolkit . getDisplay ( ) , XConstants . CurrentTime ) ; XAwtState . setGrabWindow ( null ) ; grabLog . fine ( STR_ ) ; return BOOL_ ; } } if ( prevGrabWindow != null ) { prevGrabWindow . ungrabInputImpl ( ) ; } XAwtState . setGrabWindow ( this ) ; grabLog . fine ( STR_ ) ; return BOOL_ ; } finally { XToolkit . awtUnlock ( ) ; } }
public ComponentManager ( Collection < Sequence > generalSeeds ) { Set < Sequence > seedSet = new LinkedHashSet < > ( generalSeeds . size ( ) ) ; seedSet . addAll ( generalSeeds ) ; this . gralSeeds = Collections . unmodifiableSet ( seedSet ) ; gralComponents = new SequenceCollection ( seedSet ) ; }
public synchronized void deleteObservers ( ) { observers . clear ( ) ; }
public static byte [ ] unsynchronize ( byte [ ] abySource ) { ByteArrayInputStream input = new ByteArrayInputStream ( abySource ) ; ByteArrayOutputStream output = new ByteArrayOutputStream ( abySource . length ) ; int count = NUM_ ; while ( input . available ( ) > NUM_ ) { int firstByte = input . read ( ) ; count ++ ; output . write ( firstByte ) ; if ( ( firstByte & MPEGFrameHeader . SYNC_BYTE1 ) == MPEGFrameHeader . SYNC_BYTE1 ) { if ( input . available ( ) > NUM_ ) { input . mark ( NUM_ ) ; int secondByte = input . read ( ) ; if ( ( secondByte & MPEGFrameHeader . SYNC_BYTE2 ) == MPEGFrameHeader . SYNC_BYTE2 ) { if ( logger . isLoggable ( Level . FINEST ) ) { logger . finest ( STR_ + count ) ; } output . write ( NUM_ ) ; } else if ( secondByte == NUM_ ) { if ( logger . isLoggable ( Level . FINEST ) ) { logger . finest ( STR_ + count ) ; } output . write ( NUM_ ) ; } input . reset ( ) ; } } } if ( ( abySource [ abySource . length - NUM_ ] & MPEGFrameHeader . SYNC_BYTE1 ) == MPEGFrameHeader . SYNC_BYTE1 ) { logger . finest ( STR_ ) ; output . write ( NUM_ ) ; } return output . toByteArray ( ) ; }
private byte [ ] calculateGeneralEncryptionKey ( byte [ ] userPassword , byte [ ] firstDocIdValue , int keyBitLength , int revision , byte [ ] oValue , int pValue , boolean encryptMetadata ) throws GeneralSecurityException { final byte [ ] paddedPassword = padPassword ( userPassword ) ; MessageDigest md5 = createMD5Digest ( ) ; md5 . reset ( ) ; md5 . update ( paddedPassword ) ; md5 . update ( oValue ) ; md5 . update ( ( byte ) ( pValue & xFF ) ) ; md5 . update ( ( byte ) ( ( pValue > > NUM_ ) & xFF ) ) ; md5 . update ( ( byte ) ( ( pValue > > NUM_ ) & xFF ) ) ; md5 . update ( ( byte ) ( pValue > > NUM_ ) ) ; if ( firstDocIdValue != null ) { md5 . update ( firstDocIdValue ) ; } if ( revision >= NUM_ && ! encryptMetadata ) { for ( int i = NUM_ ; i < NUM_ ; ++ i ) { md5 . update ( ( byte ) xFF ) ; } } byte [ ] hash = md5 . digest ( ) ; final int keyLen = revision == NUM_ ? NUM_ : ( keyBitLength / NUM_ ) ; final byte [ ] key = new byte [ keyLen ] ; if ( revision >= NUM_ ) { for ( int i = NUM_ ; i < NUM_ ; ++ i ) { md5 . update ( hash , NUM_ , key . length ) ; digestTo ( md5 , hash ) ; } } System . arraycopy ( hash , NUM_ , key , NUM_ , key . length ) ; return key ; }
public MessageCapture ( final Logger logger , final boolean captureEntity ) { this ( logger , captureEntity , BOOL_ ) ; }
public static final byte [ ] unzip ( byte [ ] in ) throws IOException { ByteArrayOutputStream outStream = new ByteArrayOutputStream ( EXPECTED_COMPRESSION_RATIO . in . length ) ; GZIPInputStream inStream = new GZIPInputStream ( new ByteArrayInputStream ( in ) ) ; byte [ ] buf = new byte [ BUF_SIZE ] ; while ( BOOL_ ) { int size = inStream . read ( buf ) ; if ( size <= NUM_ ) break ; outStream . write ( buf , NUM_ , size ) ; } outStream . close ( ) ; return outStream . toByteArray ( ) ; }
public static void insertIntoCombo ( JComboBox combo , Object item ) { MutableComboBoxModel model = ( MutableComboBoxModel ) combo . getModel ( ) ; if ( model . getSize ( ) == NUM_ ) { model . insertElementAt ( item , NUM_ ) ; return ; } Object o = model . getElementAt ( NUM_ ) ; if ( o . equals ( item ) ) { return ; } model . removeElement ( item ) ; model . insertElementAt ( item , NUM_ ) ; combo . setSelectedIndex ( NUM_ ) ; }
public synchronized Object co_entry_pause ( int thisCoroutine ) throws java . lang . NoSuchMethodException { if ( ! m_activeIDs . get ( thisCoroutine ) ) throw new java . lang . NoSuchMethodException ( ) ; while ( m_nextCoroutine != thisCoroutine ) { try { wait ( ) ; } catch ( java . lang . InterruptedException e ) { } } return m_yield ; }
private boolean pythonErrorIn ( String output ) { boolean isError = BOOL_ ; String [ ] outputMultiline = output . split ( STR_ ) ; Matcher errorMatcher ; for ( String row : outputMultiline ) { errorMatcher = errorInLastLine . matcher ( row ) ; if ( errorMatcher . find ( ) == BOOL_ ) { isError = BOOL_ ; break ; } } return isError ; }
public static String numberToString ( Number number ) throws JSONException { if ( number == null ) { throw new JSONException ( STR_ ) ; } double doubleValue = number . doubleValue ( ) ; JSON . checkDouble ( doubleValue ) ; if ( number . equals ( NEGATIVE_ZERO ) ) { return STR_ ; } long longValue = number . longValue ( ) ; if ( doubleValue == ( double ) longValue ) { return Long . toString ( longValue ) ; } return number . toString ( ) ; }
public static Map < String , String > strToMap ( String str , String delim , boolean trim , String pairsSeparator ) { if ( str == null ) return null ; Map < String , String > decodedMap = new HashMap < String , String > ( ) ; List < String > elements = split ( str , delim ) ; pairsSeparator = pairsSeparator == null ? STR_ : pairsSeparator ; for ( String s : elements ) { List < String > e = split ( s , pairsSeparator ) ; if ( e . size ( ) != NUM_ ) { continue ; } String name = e . get ( NUM_ ) ; String value = e . get ( NUM_ ) ; if ( trim ) { if ( name != null ) { name = name . trim ( ) ; } if ( value != null ) { value = value . trim ( ) ; } } try { decodedMap . put ( URLDecoder . decode ( name , STR_ ) , URLDecoder . decode ( value , STR_ ) ) ; } catch ( UnsupportedEncodingException e1 ) { Debug . logError ( e1 , module ) ; } } return decodedMap ; }
public void doStressTest ( TempTripleStore tmp , InferenceEngine inf , int ntrials , int D , int N ) { AbstractTripleStore store = inf . database ; assertSameGraphs ( tmp , store ) ; for ( int trial = NUM_ ; trial < ntrials ; trial ++ ) { MDC . put ( STR_ , STR_ + trial ) ; retractAndAssert ( inf , store , NUM_ , D , N ) ; assertSameGraphs ( tmp , store ) ; MDC . remove ( STR_ ) ; } }
public Set < T > keySet ( ) { return Collections . unmodifiableSet ( map . keySet ( ) ) ; }
public void onStart ( ) { if ( mAudioMirrorBuffer == null ) { mAudioMirrorBuffer = new byte [ NUM_ ] ; } if ( mStreamer != null ) { mStreamer . start ( ) ; } if ( mInsecureStreamer != null ) { mInsecureStreamer . start ( ) ; } }
@ SuppressWarnings ( STR_ ) public PropagationImp ( Stack < CompositeTransaction > lineage , boolean serial , long timeout ) { serial_ = serial ; lineage_ = ( Stack < CompositeTransaction > ) lineage . clone ( ) ; timeout_ = timeout ; }
public NativeRunner ( File eclipsec ) { this . eclipsec = Objects . requireNonNull ( eclipsec ) ; }
private static String indent ( final int height ) { return CoreBaseBOp . indent ( height ) ; }
public static Calendar reduceCalendar ( Calendar calendar ) { calendar . set ( Calendar . MILLISECOND , NUM_ ) ; calendar . set ( Calendar . SECOND , NUM_ ) ; calendar . set ( Calendar . MINUTE , NUM_ ) ; calendar . set ( Calendar . HOUR , NUM_ ) ; calendar . set ( Calendar . HOUR_OF_DAY , NUM_ ) ; return calendar ; }
public static String surround ( String string , String prefix , String suffix ) { if ( string . startsWith ( prefix ) == BOOL_ ) { string = prefix + string ; } if ( string . endsWith ( suffix ) == BOOL_ ) { string += suffix ; } return string ; }
public static Coordinate ptNotInList ( Coordinate [ ] testPts , Coordinate [ ] pts ) { for ( int i = NUM_ ; i < testPts . length ; i ++ ) { Coordinate testPt = testPts [ i ] ; if ( ! isInList ( testPt , pts ) ) return testPt ; } return null ; }
public static String trimOrPad ( String str , int length , char padChar ) { String result ; if ( str == null ) { result = STR_ ; } else { result = str ; } if ( result . length ( ) > length ) { return result . substring ( NUM_ , length ) ; } while ( result . length ( ) < length ) { result += padChar ; } return result ; }
void scheduleToTimerPool ( ) { if ( sessionPollerPool . isPollingEnabled ( ) ) { long timeoutTime = ( session . getLatestRefreshTime ( ) + ( session . getMaxIdleTime ( ) . NUM_ ) ) . NUM_ ; if ( sessionPollerPool . getCacheBasedPolling ( ) ) { timeoutTime = Math . min ( ( session . getLatestRefreshTime ( ) + ( session . getMaxCachingTime ( ) . NUM_ ) ) . NUM_ , timeoutTime ) ; } rescheduleIfWillTimeOutBeforeExecution ( timeoutTime ) ; } else { if ( ( sessionPollerPool . isSessionCleanupEnabled ( ) ) && willExpire ( session . getMaxSessionTime ( ) ) ) { long timeoutTime = ( session . getLatestRefreshTime ( ) + ( session . getMaxSessionTime ( ) . NUM_ ) ) . NUM_ ; rescheduleIfWillTimeOutBeforeExecution ( timeoutTime ) ; } } }
public void resetPolicy ( ) { mPreferences . putString ( PREF_LAST_RESPONSE , Integer . toString ( Policy . RETRY ) ) ; setRetryUntil ( DEFAULT_RETRY_UNTIL ) ; setMaxRetries ( DEFAULT_MAX_RETRIES ) ; setRetryCount ( Long . parseLong ( DEFAULT_RETRY_COUNT ) ) ; setValidityTimestamp ( DEFAULT_VALIDITY_TIMESTAMP ) ; mPreferences . commit ( ) ; }
public CipherParameters decrypt ( byte [ ] in , int keyLen ) { return decrypt ( in , NUM_ , in . length , keyLen ) ; }
private static void logOsInfo ( ) { Logger . appendLog ( STR_ + Cfg . getOs ( ) ) ; Logger . appendLog ( STR_ + Os . getOsName ( ) ) ; Logger . appendLog ( STR_ + Os . platform ( ) ) ; Logger . appendLog ( STR_ + System . getProperty ( STR_ ) ) ; Logger . appendLog ( STR_ + HostInfo . availableCpus ( ) ) ; Logger . appendLog ( STR_ + HostInfo . getMaxMemory ( ) + STR_ ) ; }
private void beforeValue ( ) throws JSONException { if ( stack . isEmpty ( ) ) { return ; } Scope context = peek ( ) ; if ( context == Scope . EMPTY_ARRAY ) { replaceTop ( Scope . NONEMPTY_ARRAY ) ; newline ( ) ; } else if ( context == Scope . NONEMPTY_ARRAY ) { out . append ( STR_ ) ; newline ( ) ; } else if ( context == Scope . DANGLING_KEY ) { out . append ( indent == null ? STR_ : STR_ ) ; replaceTop ( Scope . NONEMPTY_OBJECT ) ; } else if ( context != Scope . NULL ) { throw new JSONException ( STR_ ) ; } }
public static byte [ ] hash ( String input ) { if ( ! TextUtils . isEmpty ( input ) ) { try { byte [ ] inputBytes = input . getBytes ( STR_ ) ; return hash ( inputBytes ) ; } catch ( UnsupportedEncodingException e ) { Log . e ( TAG , STR_ + input + STR_ + e . getMessage ( ) , e ) ; } } return null ; }
public static String generateTransportZoneNativeGuid ( String transportType , String deviceType , String fabricId ) { return String . format ( STR_ , transportType , _deviceTypeMap . get ( deviceType ) , fabricId ) ; }
public void testAddServletWithNameAndJspFile ( ) throws Exception { String xml = WEBAPP_TEST_HEADER + STR_ + STR_ ; WebXml webXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( xml . getBytes ( STR_ ) ) , getEntityResolver ( ) ) ; WebXmlUtils . addJspFile ( webXml , STR_ , STR_ ) ; assertTrue ( WebXmlUtils . hasServlet ( webXml , STR_ ) ) ; }
@ Override public boolean equalsValue ( final Object other ) { return Objects . equals ( this . value , other ) ; }
public static void error ( String msg , Throwable t ) { debugInst . debug ( IDebug . ERROR , msg , t ) ; }
public void removeEventListener ( SIPTransactionEventListener oldListener ) { eventListeners . remove ( oldListener ) ; }
public static ExecutionSystem newExecutionSystem ( URI uri , Map < String , ? > env ) throws IOException { return newExecutionSystem ( uri , env , null ) ; }
public static boolean isCommand ( IElementType type ) { return type == SQFTypes . COMMAND_TOKEN || type == SQFTypes . COMMAND || type == SQFTypes . CASE || type == SQFTypes . CASE_COMMAND ; }
public void send ( XTraceReport report ) { outgoing . offer ( report ) ; }
@ Contract ( pure = BOOL_ ) public static boolean startsWithConcatenation ( @ NotNull String string , @ NotNull String ... prefixes ) { int offset = NUM_ ; for ( String prefix : prefixes ) { int prefixLen = prefix . length ( ) ; if ( ! string . regionMatches ( offset , prefix , NUM_ , prefixLen ) ) { return BOOL_ ; } offset += prefixLen ; } return BOOL_ ; }
private static int determineConsecutiveDigitCount ( CharSequence msg , int startpos ) { int count = NUM_ ; int len = msg . length ( ) ; int idx = startpos ; if ( idx < len ) { char ch = msg . charAt ( idx ) ; while ( isDigit ( ch ) && idx < len ) { count ++ ; idx ++ ; if ( idx < len ) { ch = msg . charAt ( idx ) ; } } } return count ; }
public void testOrderedByDatatype ( ) throws Exception { int lastType = Integer . MIN_VALUE ; while ( typeInfoRs . next ( ) ) { String name = typeInfoRs . getString ( STR_ ) ; int type = typeInfoRs . getInt ( STR_ ) ; assertTrue ( STR_ + type + STR_ + name + STR_ + lastType , type >= lastType ) ; lastType = type ; } }
private int measureShort ( int measureSpec ) { int result ; int specMode = MeasureSpec . getMode ( measureSpec ) ; int specSize = MeasureSpec . getSize ( measureSpec ) ; if ( specMode == MeasureSpec . EXACTLY ) { result = specSize ; } else { result = ( int ) ( NUM_ . mRadius + getPaddingTop ( ) + getPaddingBottom ( ) + NUM_ ) ; if ( specMode == MeasureSpec . AT_MOST ) { result = Math . min ( result , specSize ) ; } } return result ; }
public boolean fireMapMouseClicked ( MouseEvent evt ) { if ( DEBUG ) { logger . fine ( STR_ ) ; } clickHappened = BOOL_ ; boolean consumed = BOOL_ ; evt = new MapMouseEvent ( getParentMode ( ) , evt ) ; if ( priorityListener != null && evt . getClickCount ( ) > NUM_ ) { priorityListener . mouseClicked ( evt ) ; consumed = BOOL_ ; } priorityListener = null ; if ( proxy == null || evt . isShiftDown ( ) || ( proxyDistributionMask & PROXY_DISTRIB_MOUSE_CLICKED ) > NUM_ ) { Iterator < MapMouseListener > it = iterator ( ) ; while ( it . hasNext ( ) && ! consumed ) { MapMouseListener target = it . next ( ) ; consumed = target . mouseClicked ( evt ) && consumeEvents ; if ( consumed ) { priorityListener = target ; } } } boolean ignoreConsumed = ! consumed || ( consumed && ( ( proxyDistributionMask & PROXY_ACK_CONSUMED_MOUSE_CLICKED ) == NUM_ ) ) ; if ( proxy != null && ignoreConsumed && ! evt . isShiftDown ( ) ) { proxy . mouseClicked ( evt ) ; consumed = BOOL_ ; } return consumed ; }
public static String formatSqlValues ( String ... values ) { StringBuilder builder = new StringBuilder ( STR_ ) ; for ( int i = NUM_ ; i < values . length ; i ++ ) { if ( i > NUM_ ) { builder . append ( STR_ ) ; } builder . append ( STR_ ) ; builder . append ( escapeSqlString ( values [ i ] ) ) ; builder . append ( STR_ ) ; } builder . append ( STR_ ) ; return builder . toString ( ) ; }
private void emitClass ( DocComment comment ) { String tagName = ( comment . getType ( ) == DocComment . CLASS ) ? STR_ : STR_ ; xml . append ( STR_ ) ; xml . append ( tagName ) ; xml . append ( STR_ ) ; xml . append ( comment . getName ( ) ) ; xml . append ( STR_ ) ; xml . append ( comment . getFullname ( ) ) ; String sourcefile = comment . getSourceFile ( ) ; if ( sourcefile != null ) { xml . append ( STR_ ) ; xml . append ( sourcefile ) ; } xml . append ( STR_ ) ; xml . append ( comment . getNamespace ( ) ) ; xml . append ( STR_ ) ; xml . append ( comment . getAccess ( ) ) ; xml . append ( STR_ ) ; if ( comment . getType ( ) == DocComment . INTERFACE ) { String [ ] baseClasses = comment . getBaseclasses ( ) ; if ( baseClasses != null ) { xml . append ( STR_ ) ; for ( int i = NUM_ ; i < baseClasses . length ; i ++ ) { String baseclass = baseClasses [ i ] ; if ( baseclass != null ) { if ( i != NUM_ ) xml . append ( STR_ ) ; xml . append ( baseclass ) ; } } xml . append ( STR_ ) ; } } else { xml . append ( STR_ ) ; xml . append ( comment . getBaseClass ( ) ) ; xml . append ( STR_ ) ; String [ ] interfaces = comment . getInterfaces ( ) ; if ( interfaces != null ) { xml . append ( STR_ ) ; for ( int i = NUM_ ; i < interfaces . length ; i ++ ) { String inter = interfaces [ i ] ; if ( inter != null ) { if ( i != NUM_ ) xml . append ( STR_ ) ; xml . append ( inter ) ; } } xml . append ( STR_ ) ; } } xml . append ( STR_ ) ; xml . append ( comment . isFinal ( ) ) ; xml . append ( STR_ ) ; xml . append ( STR_ ) ; xml . append ( comment . isDynamic ( ) ) ; xml . append ( STR_ ) ; xml . append ( STR_ ) ; String desc = comment . getDescription ( ) ; if ( desc != null ) appendTag ( STR_ , comment . getDescription ( ) ) ; emitTags ( comment . getAllTags ( ) ) ; if ( comment . getMetadata ( ) != null ) emitMetadata ( comment . getMetadata ( ) ) ; xml . append ( STR_ ) ; xml . append ( tagName ) ; xml . append ( STR_ ) ; }
protected void paintContentBorderTopEdge ( Graphics g , int x , int y , int w , int h , boolean drawBroken , Rectangle selRect , boolean isContentBorderPainted ) { if ( isContentBorderPainted ) { g . setColor ( selectHighlight ) ; g . fillRect ( x , y , w - NUM_ , NUM_ ) ; } }
public void analyzeAllItAndWriteResults ( ) { RunResultsLoader runDir = new RunResultsLoader ( runDirectory , null ) ; PrintStream stream ; try { stream = new PrintStream ( new File ( outputDir + STR_ ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; return ; } String header = STR_ ; stream . println ( header ) ; double totalTTIt ; double [ ] avgRouteTTsIt ; int [ ] routeUsersIt ; for ( int i = NUM_ ; i <= lastIteration ; i ++ ) { log . info ( STR_ + i + STR_ + lastIteration + STR_ ) ; String eventsFilename = runDir . getEventsFilename ( i ) ; EventsManager eventsManager = new EventsManagerImpl ( ) ; TtAnalyzeBraess handler = new TtAnalyzeBraess ( ) ; eventsManager . addHandler ( handler ) ; MatsimEventsReader reader = new MatsimEventsReader ( eventsManager ) ; reader . readFile ( eventsFilename ) ; totalTTIt = handler . getTotalTT ( ) ; avgRouteTTsIt = handler . calculateAvgRouteTTs ( ) ; routeUsersIt = handler . getRouteUsers ( ) ; StringBuffer line = new StringBuffer ( ) ; line . append ( i + STR_ + totalTTIt ) ; for ( int j = NUM_ ; j < NUM_ ; j ++ ) { line . append ( STR_ + routeUsersIt [ j ] ) ; } for ( int j = NUM_ ; j < NUM_ ; j ++ ) { line . append ( STR_ + avgRouteTTsIt [ j ] ) ; } stream . println ( line . toString ( ) ) ; } stream . close ( ) ; log . info ( lastIteration + STR_ ) ; }
public int executeUpdate ( String sql ) throws SQLException { return Util . truncateAndConvertToInt ( executeLargeUpdate ( sql ) ) ; }
@ LayoutlibDelegate static long currentThreadTimeMillis ( ) { return System . currentTimeMillis ( ) ; }
public static Entry makeEntry ( List < String > ldifLines ) { return makeEntry ( ldifLines . toArray ( new String [ ldifLines . size ( ) ] ) ) ; }
void clearParserHighlights ( ) { for ( int i = NUM_ ; i < parserHighlights . size ( ) ; i ++ ) { Object tag = parserHighlights . get ( i ) ; if ( tag instanceof LayeredHighlightInfo ) { LayeredHighlightInfo lhi = ( LayeredHighlightInfo ) tag ; if ( lhi . width > NUM_ && lhi . height > NUM_ ) { textArea . repaint ( lhi . x , lhi . y , lhi . width , lhi . height ) ; } } else { HighlightInfo info = ( HighlightInfo ) tag ; TextUI ui = textArea . getUI ( ) ; ui . damageRange ( textArea , info . getStartOffset ( ) , info . getEndOffset ( ) ) ; } } parserHighlights . clear ( ) ; }
@ Override public final short readShort ( ) throws IOException { dis . readFully ( work , NUM_ , NUM_ ) ; return ( short ) ( ( work [ NUM_ ] & xff ) << NUM_ | ( work [ NUM_ ] & xff ) ) ; }
public void append ( char c [ ] ) { int maxlength = buffer . length - pos ; if ( c . length < maxlength ) { System . arraycopy ( c , NUM_ , buffer , pos , c . length ) ; pos += c . length ; } else { System . arraycopy ( c , NUM_ , buffer , pos , maxlength ) ; curr . next = new Entity ( buffer ) ; curr = curr . next ; length += buffer . length ; buffer = new char [ ( buffer . length > c . length - maxlength ) ? buffer . length : c . length - maxlength ] ; if ( c . length > maxlength ) { System . arraycopy ( c , maxlength , buffer , NUM_ , c . length - maxlength ) ; pos = c . length - maxlength ; } else { pos = NUM_ ; } } }
public static boolean hasPermission ( Security security , GenericValue userLogin , GenericValue orderHeader ) { if ( userLogin == null || orderHeader == null ) return BOOL_ ; if ( security . hasEntityPermission ( STR_ , STR_ , userLogin ) ) { return BOOL_ ; } else if ( security . hasEntityPermission ( STR_ , STR_ , userLogin ) ) { List < GenericValue > orderRoles = null ; try { orderRoles = orderHeader . getRelated ( STR_ , UtilMisc . toMap ( STR_ , userLogin . getString ( STR_ ) ) , null , BOOL_ ) ; } catch ( GenericEntityException e ) { Debug . logError ( e , STR_ , module ) ; } if ( UtilValidate . isNotEmpty ( orderRoles ) ) { return BOOL_ ; } } return BOOL_ ; }
private boolean isAnnotation ( ) { return implInterfaces . contains ( STR_ ) ; }
public final boolean isExceptionHandlerEquivalent ( BasicBlock other ) { if ( exceptionHandlers != other . exceptionHandlers ) { Enumeration < BasicBlock > e1 = getExceptionHandlers ( ) ; Enumeration < BasicBlock > e2 = other . getExceptionHandlers ( ) ; while ( e1 . hasMoreElements ( ) ) { if ( ! e2 . hasMoreElements ( ) ) return BOOL_ ; if ( e1 . nextElement ( ) != e2 . nextElement ( ) ) return BOOL_ ; } if ( e2 . hasMoreElements ( ) ) return BOOL_ ; } return BOOL_ ; }
public int hashCode ( ) { return name . hashCode ( ) ; }
public int checksum ( ) { return calculateChecksum ( compile_checksum . toString ( ) ) ; }
public boolean longLabel ( ) { return fState . longLabel ; }
public SecretBlock ( Mario player , Group parent , int stageZone , float xPos , float yPos , float yoloWidth , Image ... hitState ) { super ( BLOCK_COLLISION_DATA , xPos , yPos , NUM_ , NUM_ , ( Image ) null ) ; this . hitState = hitState [ NUM_ ] ; yoloView = new ImageView ( hitState [ NUM_ ] ) ; yoloView . setFitWidth ( yoloWidth ) ; this . parent = parent ; zone = stageZone ; }
private Socket openDataConnection ( String cmd ) throws sun . net . ftp . FtpProtocolException , IOException { Socket clientSocket ; if ( passiveMode ) { try { return openPassiveDataConnection ( cmd ) ; } catch ( sun . net . ftp . FtpProtocolException e ) { String errmsg = e . getMessage ( ) ; if ( ! errmsg . startsWith ( STR_ ) && ! errmsg . startsWith ( STR_ ) ) { throw e ; } } } ServerSocket portSocket ; InetAddress myAddress ; String portCmd ; if ( proxy != null && proxy . type ( ) == Proxy . Type . SOCKS ) { throw new sun . net . ftp . FtpProtocolException ( STR_ ) ; } portSocket = new ServerSocket ( NUM_ , NUM_ , server . getLocalAddress ( ) ) ; try { myAddress = portSocket . getInetAddress ( ) ; if ( myAddress . isAnyLocalAddress ( ) ) { myAddress = server . getLocalAddress ( ) ; } portCmd = STR_ + ( ( myAddress instanceof Inet6Address ) ? STR_ : STR_ ) + STR_ + myAddress . getHostAddress ( ) + STR_ + portSocket . getLocalPort ( ) + STR_ ; if ( ! issueCommand ( portCmd ) || ! issueCommand ( cmd ) ) { portCmd = STR_ ; byte [ ] addr = myAddress . getAddress ( ) ; for ( int i = NUM_ ; i < addr . length ; i ++ ) { portCmd = portCmd + ( addr [ i ] & xFF ) + STR_ ; } portCmd = portCmd + ( ( portSocket . getLocalPort ( ) > > > NUM_ ) & xff ) + STR_ + ( portSocket . getLocalPort ( ) & xff ) ; issueCommandCheck ( portCmd ) ; issueCommandCheck ( cmd ) ; } if ( connectTimeout >= NUM_ ) { portSocket . setSoTimeout ( connectTimeout ) ; } else { if ( defaultConnectTimeout > NUM_ ) { portSocket . setSoTimeout ( defaultConnectTimeout ) ; } } clientSocket = portSocket . accept ( ) ; if ( readTimeout >= NUM_ ) { clientSocket . setSoTimeout ( readTimeout ) ; } else { if ( defaultSoTimeout > NUM_ ) { clientSocket . setSoTimeout ( defaultSoTimeout ) ; } } } finally { portSocket . close ( ) ; } if ( useCrypto ) { try { clientSocket = sslFact . createSocket ( clientSocket , serverAddr . getHostName ( ) , serverAddr . getPort ( ) , BOOL_ ) ; } catch ( Exception ex ) { throw new IOException ( ex . getLocalizedMessage ( ) ) ; } } return clientSocket ; }
public static boolean installNormal ( Context context , String filePath ) { Intent i = new Intent ( Intent . ACTION_VIEW ) ; File file = new File ( filePath ) ; if ( ! file . exists ( ) || ! file . isFile ( ) || file . length ( ) <= NUM_ ) { return BOOL_ ; } i . setDataAndType ( Uri . parse ( STR_ + filePath ) , STR_ ) ; i . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; context . startActivity ( i ) ; return BOOL_ ; }
private void createInsertList ( final IItem item , List < IItem > tempList , List < IItem > insertList , int depth , int removed ) { if ( ! tempList . contains ( item ) ) { tempList . add ( item ) ; if ( depth == NUM_ ) { insertList . add ( item ) ; } if ( item . getItems ( ) != null ) { depth ++ ; for ( IItem child : item . getItems ( ) ) { createInsertList ( child , tempList , insertList , depth , removed ) ; } } } else { insertList . remove ( item ) ; removed ++ ; } }
@ SuppressWarnings ( STR_ ) public int readOutlineFileMetadata ( final PdfObject OutlinesObj , final PdfObjectReader currentPdfFile ) { final int count = OutlinesObj . getInt ( PdfDictionary . Count ) ; final PdfObject FirstObj = OutlinesObj . getDictionary ( PdfDictionary . First ) ; currentPdfFile . checkResolved ( FirstObj ) ; if ( FirstObj != null ) { final Element root = OutlineDataXML . createElement ( STR_ ) ; OutlineDataXML . appendChild ( root ) ; final int level = NUM_ ; readOutlineLevel ( root , currentPdfFile , FirstObj , level , BOOL_ ) ; } return count ; }
private int decodeRunLength ( int k ) { if ( ( k & NUM_ ) == NUM_ ) { return ( ( k > > > NUM_ ) & NUM_ ) ^ NUM_ ; } else { return Integer . numberOfLeadingZeros ( k << p + ( NUM_ - sp ) ) + NUM_ ; } }
private static byte [ ] streamToBytes ( InputStream in , int length ) throws IOException { byte [ ] bytes = new byte [ length ] ; int count ; int pos = NUM_ ; while ( pos < length && ( ( count = in . read ( bytes , pos , length - pos ) ) != - NUM_ ) ) { pos += count ; } if ( pos != length ) { throw new IOException ( STR_ + length + STR_ + pos + STR_ ) ; } return bytes ; }
private boolean decodeHandshake ( ByteBuffer socketBufferNew ) { ByteBuffer socketBuffer ; if ( tmpHandshakeBytes . capacity ( ) == NUM_ ) { socketBuffer = socketBufferNew ; } else { if ( tmpHandshakeBytes . remaining ( ) < socketBufferNew . remaining ( ) ) { ByteBuffer buf = ByteBuffer . allocate ( tmpHandshakeBytes . capacity ( ) + socketBufferNew . remaining ( ) ) ; tmpHandshakeBytes . flip ( ) ; buf . put ( tmpHandshakeBytes ) ; tmpHandshakeBytes = buf ; } tmpHandshakeBytes . put ( socketBufferNew ) ; tmpHandshakeBytes . flip ( ) ; socketBuffer = tmpHandshakeBytes ; } socketBuffer . mark ( ) ; try { if ( draft == null ) { HandshakeState isflashedgecase = isFlashEdgeCase ( socketBuffer ) ; if ( isflashedgecase == HandshakeState . MATCHED ) { try { write ( ByteBuffer . wrap ( Charsetfunctions . utf8Bytes ( wsl . getFlashPolicy ( this ) ) ) ) ; close ( CloseFrame . FLASHPOLICY , STR_ ) ; } catch ( InvalidDataException e ) { close ( CloseFrame . ABNORMAL_CLOSE , STR_ , BOOL_ ) ; } return BOOL_ ; } } HandshakeState handshakestate = null ; try { if ( role == Role . SERVER ) { if ( draft == null ) { for ( Draft d : knownDrafts ) { d = d . copyInstance ( ) ; try { d . setParseMode ( role ) ; socketBuffer . reset ( ) ; Handshakedata tmphandshake = d . translateHandshake ( socketBuffer ) ; if ( tmphandshake instanceof ClientHandshake == BOOL_ ) { flushAndClose ( CloseFrame . PROTOCOL_ERROR , STR_ , BOOL_ ) ; return BOOL_ ; } ClientHandshake handshake = ( ClientHandshake ) tmphandshake ; handshakestate = d . acceptHandshakeAsServer ( handshake ) ; if ( handshakestate == HandshakeState . MATCHED ) { resourceDescriptor = handshake . getResourceDescriptor ( ) ; ServerHandshakeBuilder response ; try { response = wsl . onWebsocketHandshakeReceivedAsServer ( this , d , handshake ) ; } catch ( InvalidDataException e ) { flushAndClose ( e . getCloseCode ( ) , e . getMessage ( ) , BOOL_ ) ; return BOOL_ ; } catch ( RuntimeException e ) { wsl . onWebsocketError ( this , e ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , e . getMessage ( ) , BOOL_ ) ; return BOOL_ ; } write ( d . createHandshake ( d . postProcessHandshakeResponseAsServer ( handshake , response ) , role ) ) ; draft = d ; open ( handshake ) ; return BOOL_ ; } } catch ( InvalidHandshakeException e ) { } } if ( draft == null ) { close ( CloseFrame . PROTOCOL_ERROR , STR_ ) ; } return BOOL_ ; } else { Handshakedata tmphandshake = draft . translateHandshake ( socketBuffer ) ; if ( tmphandshake instanceof ClientHandshake == BOOL_ ) { flushAndClose ( CloseFrame . PROTOCOL_ERROR , STR_ , BOOL_ ) ; return BOOL_ ; } ClientHandshake handshake = ( ClientHandshake ) tmphandshake ; handshakestate = draft . acceptHandshakeAsServer ( handshake ) ; if ( handshakestate == HandshakeState . MATCHED ) { open ( handshake ) ; return BOOL_ ; } else { close ( CloseFrame . PROTOCOL_ERROR , STR_ ) ; } return BOOL_ ; } } else if ( role == Role . CLIENT ) { draft . setParseMode ( role ) ; Handshakedata tmphandshake = draft . translateHandshake ( socketBuffer ) ; if ( tmphandshake instanceof ServerHandshake == BOOL_ ) { flushAndClose ( CloseFrame . PROTOCOL_ERROR , STR_ , BOOL_ ) ; return BOOL_ ; } ServerHandshake handshake = ( ServerHandshake ) tmphandshake ; handshakestate = draft . acceptHandshakeAsClient ( handshakerequest , handshake ) ; if ( handshakestate == HandshakeState . MATCHED ) { try { wsl . onWebsocketHandshakeReceivedAsClient ( this , handshakerequest , handshake ) ; } catch ( InvalidDataException e ) { flushAndClose ( e . getCloseCode ( ) , e . getMessage ( ) , BOOL_ ) ; return BOOL_ ; } catch ( RuntimeException e ) { wsl . onWebsocketError ( this , e ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , e . getMessage ( ) , BOOL_ ) ; return BOOL_ ; } open ( handshake ) ; return BOOL_ ; } else { close ( CloseFrame . PROTOCOL_ERROR , STR_ + draft + STR_ ) ; } } } catch ( InvalidHandshakeException e ) { close ( e ) ; } } catch ( IncompleteHandshakeException e ) { if ( tmpHandshakeBytes . capacity ( ) == NUM_ ) { socketBuffer . reset ( ) ; int newsize = e . getPreferedSize ( ) ; if ( newsize == NUM_ ) { newsize = socketBuffer . capacity ( ) + NUM_ ; } else { assert ( e . getPreferedSize ( ) >= socketBuffer . remaining ( ) ) ; } tmpHandshakeBytes = ByteBuffer . allocate ( newsize ) ; tmpHandshakeBytes . put ( socketBufferNew ) ; } else { tmpHandshakeBytes . position ( tmpHandshakeBytes . limit ( ) ) ; tmpHandshakeBytes . limit ( tmpHandshakeBytes . capacity ( ) ) ; } } return BOOL_ ; }
public NoDuplicateValueGlobalConstraint ( AbstractParameter < ? , ? > ... parameters ) { this . parameters = Arrays . asList ( parameters ) ; }
@ SuppressWarnings ( STR_ ) public RhythmOverlay inflateOverlay ( String configString ) { List < String > configStrings = Arrays . asList ( configString . split ( STR_ ) ) ; return inflateOverlayInternal ( configStrings , Collections . EMPTY_MAP , NUM_ ) ; }
public static RevocationHash bruteForceHash ( byte [ ] seed , byte [ ] target , int maxChildTries , int maxSiblingTries ) { for ( int i = NUM_ ; i < maxChildTries ; i ++ ) { for ( int j = NUM_ ; j < maxSiblingTries ; j ++ ) { RevocationHash test = HashDerivation . calculateRevocationHash ( seed , NUM_ , j ) ; if ( Arrays . equals ( test . getSecretHash ( ) , target ) ) { return new RevocationHash ( i , j , test . getSecret ( ) , test . getSecretHash ( ) ) ; } } seed = Tools . hashSecret ( seed ) ; } return null ; }
public FancyLoader ( ClassLoader parent ) { super ( parent ) ; try { mDexClass = parent . loadClass ( STR_ ) ; } catch ( ClassNotFoundException cnfe ) { } }
public boolean isSourceModified ( Resource resource ) { boolean modified = BOOL_ ; String fileName = resource . getName ( ) ; String path = ( String ) templatePaths . get ( fileName ) ; File currentFile = null ; for ( int i = NUM_ ; currentFile == null && i < paths . size ( ) ; i ++ ) { String testPath = ( String ) paths . get ( i ) ; File testFile = new File ( testPath , fileName ) ; if ( testFile . canRead ( ) ) { currentFile = testFile ; } } File file = new File ( path , fileName ) ; if ( currentFile == null || ! file . exists ( ) ) { } else if ( currentFile . equals ( file ) && file . canRead ( ) ) { modified = ( file . lastModified ( ) != resource . getLastModified ( ) ) ; } return modified ; }
protected void flip ( BufferCapabilities . FlipContents flipAction ) { if ( peer != null ) { Image backBuffer = getBackBuffer ( ) ; if ( backBuffer != null ) { peer . flip ( NUM_ , NUM_ , backBuffer . getWidth ( null ) , backBuffer . getHeight ( null ) , flipAction ) ; } } else { throw new IllegalStateException ( STR_ ) ; } }
protected void loadValue ( String sValue ) { try { value = Byte . parseByte ( sValue . trim ( ) ) ; } catch ( NumberFormatException nfe ) { revertToDefault ( ) ; } }
public static Map < String , String > allNamespaces ( SOAPElement ele ) { Map < String , String > nsList = new TreeMap < String , String > ( ) ; log . trace ( STR_ + ele . getNodeName ( ) ) ; allNamespaces ( ele , nsList ) ; log . trace ( STR_ + nsList ) ; return nsList ; }
public static byte [ ] toByteArray ( Bitmap bitmap , Bitmap . CompressFormat format , int quality ) { ByteArrayOutputStream out = null ; try { out = new ByteArrayOutputStream ( ) ; bitmap . compress ( format , quality , out ) ; return out . toByteArray ( ) ; } finally { CloseableUtils . close ( out ) ; } }
public void continueButtonActionPerformed ( java . awt . event . ActionEvent e ) { if ( testRunning && testSuspended ) { testSuspended = BOOL_ ; if ( wrapTest ) { statusText1 . setText ( STR_ ) ; statusText1 . setVisible ( BOOL_ ) ; } } }
@ HLEFunction ( nid = x9AC2EEAC , version = NUM_ ) public int sceNetAdhocPtpFlush ( @ CheckArgument ( STR_ ) int id , int timeout , int nonblock ) { return NUM_ ; }
public void reset ( ) { displayCache . clear ( ) ; cachedID . clear ( ) ; }
private void copyDirectory ( File source , File dest ) throws IOException { for ( File f : source . listFiles ( ) ) { File sourceFile = new File ( source , f . getName ( ) ) ; File destFile = new File ( dest , f . getName ( ) ) ; if ( f . isDirectory ( ) ) { destFile . mkdirs ( ) ; copyDirectory ( sourceFile , destFile ) ; } else copyFile ( sourceFile , destFile ) ; } }
private synchronized void rebuildJournal ( ) throws IOException { if ( mJournalWriter != null ) { mJournalWriter . close ( ) ; } Writer writer = new BufferedWriter ( new FileWriter ( mJournalFileTmp ) , IO_BUFFER_SIZE ) ; writer . write ( MAGIC ) ; writer . write ( STR_ ) ; writer . write ( VERSION_1 ) ; writer . write ( STR_ ) ; writer . write ( Integer . toString ( mAppVersion ) ) ; writer . write ( STR_ ) ; writer . write ( STR_ ) ; for ( CacheEntry cacheEntry : mLruEntries . values ( ) ) { if ( cacheEntry . isUnderEdit ( ) ) { writer . write ( sACTION_LIST [ ACTION_DIRTY ] + STR_ + cacheEntry . getKey ( ) + STR_ + cacheEntry . getSize ( ) + STR_ ) ; } else { writer . write ( sACTION_LIST [ ACTION_CLEAN ] + STR_ + cacheEntry . getKey ( ) + STR_ + cacheEntry . getSize ( ) + STR_ ) ; } } writer . close ( ) ; mJournalFileTmp . renameTo ( mJournalFile ) ; mJournalWriter = new BufferedWriter ( new FileWriter ( mJournalFile , BOOL_ ) , IO_BUFFER_SIZE ) ; }
private void recordLogData ( ) { try { int size = mRecordingData . size ( ) ; if ( size == NUM_ ) { return ; } Vector < String > recordingData = new Vector < > ( mRecordingData ) ; File logDir = Constants . getRecordDir ( this ) ; logDir . mkdirs ( ) ; File logFile = new File ( logDir , mRecordingFilename ) ; FileWriter logFileWriter = new FileWriter ( logFile , BOOL_ ) ; for ( int i = NUM_ ; i < size ; i ++ ) { logFileWriter . append ( recordingData . elementAt ( i ) + STR_ ) ; mRecordingData . removeElementAt ( NUM_ ) ; } recordingData . removeAllElements ( ) ; logFileWriter . close ( ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , STR_ + e . toString ( ) ) ; } }
private static List < Command > loadRewrites ( String str ) { assert str != null ; List < Command > commands = new ArrayList < > ( ) ; for ( String line : str . split ( STR_ ) ) { addLine ( commands , line ) ; } return commands ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( NUM_ ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
@ Override public StateConnection onCloseRead ( ) { ConnectionProtocol request = request ( ) ; if ( request != null ) { request . onCloseRead ( ) ; } _sequenceClose . set ( _sequenceRead . get ( ) ) ; if ( _sequenceFlush . get ( ) < _sequenceClose . get ( ) ) { _isClosePending . set ( BOOL_ ) ; if ( _sequenceFlush . get ( ) < _sequenceClose . get ( ) ) { return StateConnection . CLOSE_READ_S ; } else { _isClosePending . set ( BOOL_ ) ; return StateConnection . CLOSE ; } } else { return StateConnection . CLOSE ; } }
private Map < UUID , int [ ] > reducers ( Collection < ClusterNode > top , Map < UUID , Collection < HadoopInputSplit > > mappers , int reducerCnt ) { int totalWeight = NUM_ ; List < WeightedNode > nodes = new ArrayList < > ( top . size ( ) ) ; for ( ClusterNode node : top ) { Collection < HadoopInputSplit > split = mappers . get ( node . id ( ) ) ; int weight = reducerNodeWeight ( node , split != null ? split . size ( ) : NUM_ ) ; nodes . add ( new WeightedNode ( node . id ( ) , weight , weight ) ) ; totalWeight += weight ; } int totalAdjustedWeight = NUM_ ; for ( WeightedNode node : nodes ) { node . floatWeight = ( ( float ) node . weight . reducerCnt ) / totalWeight ; node . weight = Math . round ( node . floatWeight ) ; totalAdjustedWeight += node . weight ; } Collections . sort ( nodes ) ; if ( totalAdjustedWeight > reducerCnt ) { ListIterator < WeightedNode > iter = nodes . listIterator ( nodes . size ( ) - NUM_ ) ; while ( totalAdjustedWeight != reducerCnt ) { if ( ! iter . hasPrevious ( ) ) iter = nodes . listIterator ( nodes . size ( ) - NUM_ ) ; WeightedNode node = iter . previous ( ) ; if ( node . weight > NUM_ ) { node . weight -= NUM_ ; totalAdjustedWeight -- ; } } } else if ( totalAdjustedWeight < reducerCnt ) { ListIterator < WeightedNode > iter = nodes . listIterator ( NUM_ ) ; while ( totalAdjustedWeight != reducerCnt ) { if ( ! iter . hasNext ( ) ) iter = nodes . listIterator ( NUM_ ) ; WeightedNode node = iter . next ( ) ; if ( node . floatWeight > NUM_ ) { node . weight += NUM_ ; totalAdjustedWeight ++ ; } } } int idx = NUM_ ; Map < UUID , int [ ] > reducers = new HashMap < > ( nodes . size ( ) , NUM_ ) ; for ( WeightedNode node : nodes ) { if ( node . weight > NUM_ ) { int [ ] arr = new int [ node . weight ] ; for ( int i = NUM_ ; i < arr . length ; i ++ ) arr [ i ] = idx ++ ; reducers . put ( node . nodeId , arr ) ; } } return reducers ; }
public void httpRequest ( HttpRequestEvent e ) throws java . io . IOException { String request = e . getRequest ( ) ; if ( Debug . debugging ( STR_ ) ) { Debug . output ( STR_ + request + STR_ ) ; } if ( request . charAt ( NUM_ ) == STR_ ) { request = request . substring ( NUM_ , request . length ( ) ) ; } int index = NUM_ ; index = request . indexOf ( STR_ ) ; if ( index != - NUM_ ) { request = request . substring ( index + NUM_ , request . length ( ) ) ; Debug . message ( STR_ , STR_ ) ; } else { Debug . message ( STR_ , STR_ ) ; } try { iServer . handleRequest ( request , e . getOutputStream ( ) ) ; } catch ( IOException ioe ) { Debug . error ( STR_ + ioe . getMessage ( ) ) ; } catch ( MapRequestFormatException exception ) { String message = STR_ + exception . getMessage ( ) + STR_ + ErrorMessage ; HttpConnection . writeHttpResponse ( e . getOutputStream ( ) , HttpConnection . CONTENT_PLAIN , message ) ; } }
public void testConstructorBytesNegative2 ( ) { byte aBytes [ ] = { - NUM_ , NUM_ , NUM_ } ; byte rBytes [ ] = { - NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aBytes ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , - NUM_ , aNumber . signum ( ) ) ; }
public String format ( double val ) { DecimalFormat df = getDoubleFormat ( ) ; if ( df != null ) { return df . format ( val ) ; } return Double . toString ( val ) ; }
public void removePositions ( Collection < Integer > positions ) { ArrayList < Integer > positionsList = new ArrayList < Integer > ( positions ) ; Collections . sort ( positionsList ) ; Collections . reverse ( positionsList ) ; for ( int position : positionsList ) { mItems . remove ( position ) ; } notifyDataSetChanged ( ) ; }
private void resetShapeBounds ( ) { RoundRectangle2D . Double rrect = ( RoundRectangle2D . Double ) shape ; rrect . setRoundRect ( NUM_ , NUM_ , getBounds ( ) . width - NUM_ , getBounds ( ) . height - NUM_ , NUM_ , NUM_ ) ; }
public static Colour attemptToGetAsColour ( String part ) { Colour col = null ; try { col = Colour . valueOf ( part . toUpperCase ( ) ) ; } catch ( Exception e ) { } return col ; }
public final ArrayList < Move > removeNonOptimal ( Position pos , ArrayList < Move > moveList ) { ArrayList < Move > optimalMoves = new ArrayList < Move > ( ) ; ArrayList < Move > unknownMoves = new ArrayList < Move > ( ) ; final int MATE0 = NUM_ ; int bestScore = - NUM_ ; UndoInfo ui = new UndoInfo ( ) ; for ( Move m : moveList ) { pos . makeMove ( m , ui ) ; int pliesToDraw = Math . max ( NUM_ - pos . halfMoveClock , NUM_ ) ; GtbProbeResult res = gtbProbe ( pos ) ; pos . unMakeMove ( m , ui ) ; if ( res . result == GtbProbeResult . UNKNOWN ) { unknownMoves . add ( m ) ; } else { int wScore ; if ( res . result == GtbProbeResult . WMATE ) { if ( res . pliesToMate <= pliesToDraw ) wScore = MATE0 - res . pliesToMate ; else wScore = NUM_ ; } else if ( res . result == GtbProbeResult . BMATE ) { if ( res . pliesToMate <= pliesToDraw ) wScore = - ( MATE0 - res . pliesToMate ) ; else wScore = - NUM_ ; } else { wScore = NUM_ ; } int score = pos . whiteMove ? wScore : - wScore ; if ( score > bestScore ) { optimalMoves . clear ( ) ; optimalMoves . add ( m ) ; bestScore = score ; } else if ( score == bestScore ) { optimalMoves . add ( m ) ; } else { } } } for ( Move m : unknownMoves ) optimalMoves . add ( m ) ; return ( optimalMoves . size ( ) < moveList . size ( ) ) ? optimalMoves : null ; }
public int rank ( ) { double eps = Math . pow ( NUM_ , - NUM_ ) ; double tol = Math . max ( m , n ) . s [ NUM_ ] . eps ; int r = NUM_ ; for ( int i = NUM_ ; i < s . length ; i ++ ) { if ( s [ i ] > tol ) { r ++ ; } } return r ; }
protected void onPageScrolled ( int position , float offset , int offsetPixels ) { if ( mDecorChildCount > NUM_ ) { final int scrollX = getScrollX ( ) ; int paddingLeft = getPaddingLeft ( ) ; int paddingRight = getPaddingRight ( ) ; final int width = getWidth ( ) ; final int childCount = getChildCount ( ) ; for ( int i = NUM_ ; i < childCount ; i ++ ) { final View child = getChildAt ( i ) ; final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; if ( ! lp . isDecor ) continue ; final int hgrav = lp . gravity & Gravity . HORIZONTAL_GRAVITY_MASK ; int childLeft = NUM_ ; switch ( hgrav ) { default : childLeft = paddingLeft ; break ; case Gravity . LEFT : childLeft = paddingLeft ; paddingLeft += child . getWidth ( ) ; break ; case Gravity . CENTER_HORIZONTAL : childLeft = Math . max ( ( width - child . getMeasuredWidth ( ) ) / NUM_ , paddingLeft ) ; break ; case Gravity . RIGHT : childLeft = width - paddingRight - child . getMeasuredWidth ( ) ; paddingRight += child . getMeasuredWidth ( ) ; break ; } childLeft += scrollX ; final int childOffset = childLeft - child . getLeft ( ) ; if ( childOffset != NUM_ ) { child . offsetLeftAndRight ( childOffset ) ; } } } if ( mOnPageChangeListener != null ) { mOnPageChangeListener . onPageScrolled ( position , offset , offsetPixels ) ; } if ( mInternalPageChangeListener != null ) { mInternalPageChangeListener . onPageScrolled ( position , offset , offsetPixels ) ; } if ( mPageTransformer != null ) { final int scrollX = getScrollX ( ) ; final int childCount = getChildCount ( ) ; for ( int i = NUM_ ; i < childCount ; i ++ ) { final View child = getChildAt ( i ) ; final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; if ( lp . isDecor ) continue ; final float transformPos = ( float ) ( child . getLeft ( ) - scrollX ) / getClientWidth ( ) ; mPageTransformer . transformPage ( child , transformPos ) ; } } mCalledSuper = BOOL_ ; }
public static void executeRandomModifiableVariableModification ( ModifiableVariableHolder object ) { Field field = object . getRandomModifiableVariableField ( ) ; executeModifiableVariableModification ( object , field ) ; }
public static boolean save ( File file , String content ) { boolean result ; BufferedWriter writer ; writer = null ; try { writer = new BufferedWriter ( new FileWriter ( file ) ) ; writer . write ( content ) ; writer . flush ( ) ; result = BOOL_ ; } catch ( Exception e ) { e . printStackTrace ( ) ; result = BOOL_ ; } finally { if ( writer != null ) { try { writer . close ( ) ; } catch ( Exception e ) { } } } return result ; }
private void deleteOldTemp ( File fileCfg ) { BufferedReader reader = null ; try { int count = NUM_ ; reader = new BufferedReader ( new FileReader ( fileCfg ) ) ; String sLine ; while ( ( sLine = reader . readLine ( ) ) != null ) { File file = new File ( sLine ) ; if ( ! file . exists ( ) ) { continue ; } if ( file . delete ( ) ) { count ++ ; } else { hsDeleteOnExit . add ( file ) ; } } logDebug ( LogArea . CONFIG , STR_ , count , fileCfg . getAbsolutePath ( ) ) ; } catch ( IOException e ) { } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { } } } }
public void proposeTree ( ) throws OperatorFailedException { NodeRef i ; double oldMinAge , newMinAge , newRange , oldRange , newAge , q ; final int nodeCount = tree . getNodeCount ( ) ; do { i = tree . getNode ( MathUtils . nextInt ( nodeCount ) ) ; } while ( tree . getRoot ( ) == i ) ; final NodeRef iP = tree . getParent ( i ) ; NodeRef j = tree . getNode ( MathUtils . nextInt ( nodeCount ) ) ; NodeRef k = tree . getParent ( j ) ; while ( ( k != null && tree . getNodeHeight ( k ) <= tree . getNodeHeight ( i ) ) || ( i == j ) ) { j = tree . getNode ( MathUtils . nextInt ( nodeCount ) ) ; k = tree . getParent ( j ) ; } if ( j == tree . getRoot ( ) || iP == tree . getRoot ( ) ) { throw new OperatorFailedException ( STR_ ) ; } if ( k == iP || j == iP || k == i ) throw new OperatorFailedException ( STR_ ) ; final NodeRef CiP = getOtherChild ( tree , iP , i ) ; NodeRef PiP = tree . getParent ( iP ) ; newMinAge = Math . max ( tree . getNodeHeight ( i ) , tree . getNodeHeight ( j ) ) ; newRange = tree . getNodeHeight ( k ) - newMinAge ; newAge = newMinAge + ( MathUtils . nextDouble ( ) . newRange ) ; oldMinAge = Math . max ( tree . getNodeHeight ( i ) , tree . getNodeHeight ( CiP ) ) ; oldRange = tree . getNodeHeight ( PiP ) - oldMinAge ; q = newRange / Math . abs ( oldRange ) ; tree . beginTreeEdit ( ) ; if ( j == tree . getRoot ( ) ) { tree . removeChild ( iP , CiP ) ; tree . removeChild ( PiP , iP ) ; tree . addChild ( iP , j ) ; tree . addChild ( PiP , CiP ) ; tree . setRoot ( iP ) ; } else if ( iP == tree . getRoot ( ) ) { tree . removeChild ( k , j ) ; tree . removeChild ( iP , CiP ) ; tree . addChild ( iP , j ) ; tree . addChild ( k , iP ) ; tree . setRoot ( CiP ) ; } else { tree . removeChild ( k , j ) ; tree . removeChild ( iP , CiP ) ; tree . removeChild ( PiP , iP ) ; tree . addChild ( iP , j ) ; tree . addChild ( k , iP ) ; tree . addChild ( PiP , CiP ) ; } tree . setNodeHeight ( iP , newAge ) ; tree . endTreeEdit ( ) ; logq = Math . log ( q ) ; }
public void flush ( ) { final BigdataSailRepositoryConnection cxn = tlTx . get ( ) ; if ( cxn != null ) { Code . wrapThrow ( null ) ; } }
@ Override public BufferedImage JPEGToRGBImage ( final byte [ ] data , final int ww , final int hh , final int pX , final int pY ) { BufferedImage image = null ; Raster ras = JPEGDecoder . getRasterFromJPEG ( data , STR_ ) ; if ( ras != null ) { ras = cleanupRaster ( ras , pX , pY , componentCount ) ; final int w = ras . getWidth ( ) ; final int h = ras . getHeight ( ) ; final DataBufferByte rgb = ( DataBufferByte ) ras . getDataBuffer ( ) ; image = createImage ( w , h , rgb . getData ( ) ) ; } return image ; }
public void despawn ( VisibleObject object ) { despawn ( object , BOOL_ ) ; }
public String eventTopic ( String eventId ) { if ( eventId == null ) { eventId = STR_ ; } return evtTopic . replace ( STR_ , eventId ) ; }
public MatchResult match ( ) { if ( ! matchSuccessful ) { throw new IllegalStateException ( ) ; } return matcher . toMatchResult ( ) ; }
@ SuppressWarnings ( STR_ ) public static void createProjectConstraint ( ZipFile zip , Project aProject , RepositoryService aRepository ) throws IOException { for ( Enumeration zipEnumerate = zip . entries ( ) ; zipEnumerate . hasMoreElements ( ) ; ) { ZipEntry entry = ( ZipEntry ) zipEnumerate . nextElement ( ) ; String entryName = normalizeEntryName ( entry ) ; if ( entryName . startsWith ( CONSTRAINTS ) ) { String filename = FilenameUtils . getName ( entry . getName ( ) ) ; ConstraintSet constraintSet = new ConstraintSet ( ) ; constraintSet . setProject ( aProject ) ; constraintSet . setName ( filename ) ; aRepository . createConstraintSet ( constraintSet ) ; aRepository . writeConstraintSet ( constraintSet , zip . getInputStream ( entry ) ) ; LOG . info ( STR_ + filename + STR_ + aProject . getName ( ) + STR_ + aProject . getId ( ) + STR_ ) ; } } }
static synchronized void computePRF_SSLv3 ( byte [ ] out , byte [ ] secret , byte [ ] seed ) { if ( sha == null ) { init ( ) ; } int pos = NUM_ ; int iteration = NUM_ ; byte [ ] digest ; while ( pos < out . length ) { byte [ ] pref = new byte [ iteration ] ; Arrays . fill ( pref , ( byte ) ( NUM_ + iteration ++ ) ) ; sha . update ( pref ) ; sha . update ( secret ) ; sha . update ( seed ) ; md5 . update ( secret ) ; md5 . update ( sha . digest ( ) ) ; digest = md5 . digest ( ) ; if ( pos + NUM_ > out . length ) { System . arraycopy ( digest , NUM_ , out , pos , out . length - pos ) ; pos = out . length ; } else { System . arraycopy ( digest , NUM_ , out , pos , NUM_ ) ; pos += NUM_ ; } } }
public String decode ( String pString ) throws DecoderException { if ( pString == null ) { return null ; } try { return decode ( pString , getDefaultCharset ( ) ) ; } catch ( UnsupportedEncodingException e ) { throw new DecoderException ( e . getMessage ( ) ) ; } }
public Operation copyTo ( Extent target ) { BlockTransformExtent extent = new BlockTransformExtent ( original , transform , worldData . getBlockRegistry ( ) ) ; ForwardExtentCopy copy = new ForwardExtentCopy ( extent , original . getRegion ( ) , original . getOrigin ( ) , target , original . getOrigin ( ) ) ; copy . setTransform ( transform ) ; return copy ; }
@ CallerSensitive public Class < ? > forClass ( ) { if ( cl == null ) { return null ; } requireInitialized ( ) ; if ( System . getSecurityManager ( ) != null ) { Class < ? > caller = Reflection . getCallerClass ( ) ; if ( ReflectUtil . needsPackageAccessCheck ( caller . getClassLoader ( ) , cl . getClassLoader ( ) ) ) { ReflectUtil . checkPackageAccess ( cl ) ; } } return cl ; }
private void pathStyleHelper ( String style , String offset ) { if ( style == null ) { return ; } if ( style . equals ( STR_ ) ) { strokePaint . setPathEffect ( null ) ; return ; } StringTokenizer st = new StringTokenizer ( style , STR_ ) ; int count = st . countTokens ( ) ; float [ ] intervals = new float [ ( count & NUM_ ) == NUM_ ? count . NUM_ : count ] ; float max = NUM_ ; float current = NUM_ ; int i = NUM_ ; while ( st . hasMoreTokens ( ) ) { intervals [ i ++ ] = current = toFloat ( st . nextToken ( ) , current ) ; max += current ; } for ( int start = NUM_ ; i < intervals . length ; i ++ , start ++ ) { max += intervals [ i ] = intervals [ start ] ; } float off = NUM_ ; if ( offset != null ) { try { off = Float . parseFloat ( offset ) % max ; } catch ( NumberFormatException e ) { } } strokePaint . setPathEffect ( new DashPathEffect ( intervals , off ) ) ; }
private float colorToAngle ( int color ) { float [ ] colors = new float [ NUM_ ] ; Color . colorToHSV ( color , colors ) ; return ( float ) Math . toRadians ( - colors [ NUM_ ] ) ; }
private Size parseOldBoundedSize ( String token , boolean setMax ) { int semicolonIndex = token . indexOf ( STR_ ) ; String sizeToken1 = token . substring ( NUM_ , semicolonIndex ) ; String sizeToken2 = token . substring ( semicolonIndex + NUM_ , token . length ( ) - NUM_ ) ; Size size1 = parseAtomicSize ( sizeToken1 ) ; Size size2 = parseAtomicSize ( sizeToken2 ) ; if ( isConstant ( size1 ) ) { if ( size2 instanceof Sizes . ComponentSize ) { return new BoundedSize ( size2 , setMax ? null : size1 , setMax ? size1 : null ) ; } throw new IllegalArgumentException ( STR_ ) ; } if ( isConstant ( size2 ) ) { return new BoundedSize ( size1 , setMax ? null : size2 , setMax ? size2 : null ) ; } throw new IllegalArgumentException ( STR_ ) ; }
Builder addEncodedQueryParameter ( String encodedName , String encodedValue ) { if ( encodedName == null ) throw new IllegalArgumentException ( STR_ ) ; if ( encodedQueryNamesAndValues == null ) encodedQueryNamesAndValues = new ArrayList < > ( ) ; encodedQueryNamesAndValues . add ( canonicalize ( encodedName , QUERY_COMPONENT_ENCODE_SET , BOOL_ , BOOL_ ) ) ; encodedQueryNamesAndValues . add ( encodedValue != null ? canonicalize ( encodedValue , QUERY_COMPONENT_ENCODE_SET , BOOL_ , BOOL_ ) : null ) ; return this ; }
private static a createImageLink ( String AD_Language , String name , String js_command , boolean enabled , boolean pressed ) { a img = new a ( STR_ , createImage ( AD_Language , name ) ) ; if ( ! pressed || ! enabled ) img . setID ( STR_ ) ; else img . setID ( STR_ ) ; if ( js_command == null ) js_command = STR_ ; if ( js_command . length ( ) > NUM_ && enabled ) { if ( js_command . startsWith ( STR_ ) ) img . setOnClick ( js_command ) ; else img . setOnClick ( STR_ + name + STR_ + js_command + STR_ ) ; } img . setClass ( STR_ ) ; img . setOnMouseOver ( STR_ + name + STR_ ) ; img . setOnMouseOut ( STR_ ) ; img . setOnBlur ( STR_ ) ; return img ; }
public Namespace ( PrincipalUser creator , String qualifier , PrincipalUser owner , Set < PrincipalUser > users ) { super ( creator ) ; setQualifier ( qualifier ) ; setOwner ( owner ) ; if ( users != null && ! users . isEmpty ( ) ) { setUsers ( users ) ; } addUser ( owner ) ; }
public final int decrementAndGet ( ) { return unsafe . getAndAddInt ( this , valueOffset , - NUM_ ) - NUM_ ; }
public void update ( long dt , float ratioY ) { double step = NUM_ . Math . PI / POINTS_PER_CIRCLE ; angle += dt . BUBBLE_D_ANGLE ; float fromX = startX + ( float ) ( NUM_ . Math . sin ( angle ) ) ; float toX = fromX + size ; float fromY = this . fromY + dt . speed ; float toY = fromY + size ; centerY += dt . virtualSpeed ; getColor ( ) [ NUM_ ] = ( TOP_Y - centerY / TOP_Y ) ; vertexBuffer . put ( NUM_ , Utils . normalizeGl ( NUM_ , fromX , toX ) ) ; vertexBuffer . put ( NUM_ , Utils . normalizeGl ( centerY . ratioY , fromY , toY ) ) ; for ( int i = NUM_ ; i <= POINTS_PER_CIRCLE ; i ++ ) { vertexBuffer . put ( COORDS_PER_VERTEX . i , Utils . normalizeGl ( ( float ) Math . sin ( - Math . PI + step . i ) , fromX , toX ) ) ; vertexBuffer . put ( COORDS_PER_VERTEX . i + NUM_ , Utils . normalizeGl ( ( float ) Math . cos ( - Math . PI + step . i ) . ratioY , fromY , toY ) ) ; } this . fromY = fromY ; }
public final void clear ( ) { if ( GWT . isScript ( ) ) { jsArray . clear ( ) ; } else { javaArray . clear ( ) ; } }
void fullyLock ( ) { putLock . lock ( ) ; takeLock . lock ( ) ; }
@ Override public synchronized void clear ( ) { File [ ] files = mRootDirectory . listFiles ( ) ; if ( files != null ) { for ( File file : files ) { file . delete ( ) ; } } mEntries . clear ( ) ; VolleyLog . d ( STR_ ) ; }
private void updatePodcastPublicationDateAndLastMediaUrl ( Episode episode , Podcast podcast ) { Date podcastPublicationDate = podcast . getPublicationDate ( ) ; boolean episodePubDateIsMoreRecent = episode . getPublicationDate ( ) != null && ( podcastPublicationDate == null || podcastPublicationDate . before ( episode . getPublicationDate ( ) ) ) ; if ( episodePubDateIsMoreRecent ) { podcast . setPublicationDate ( episode . getPublicationDate ( ) ) ; podcast . setLastEpisodeMediaUrl ( episode . getMediaUrl ( ) ) ; } }
private void removeOurUIs ( ) { for ( String uiName : UI_LIST ) { uiDefaults . remove ( uiName + STR_ ) ; } }
public static < O > KNNQuery < O > precomputedKNNQuery ( Database database , Relation < O > relation , DistanceQuery < O > dq , int k ) { KNNQuery < O > knnq = database . getKNNQuery ( dq , k , DatabaseQuery . HINT_HEAVY_USE , DatabaseQuery . HINT_OPTIMIZED_ONLY , DatabaseQuery . HINT_NO_CACHE ) ; if ( knnq instanceof PreprocessorKNNQuery ) { return knnq ; } MaterializeKNNPreprocessor < O > preproc = new MaterializeKNNPreprocessor < > ( relation , dq . getDistanceFunction ( ) , k ) ; preproc . initialize ( ) ; return preproc . getKNNQuery ( dq , k ) ; }
public static SortedSet < Integer > adjustPosition ( Set < Integer > positions , int startPosition , int endPosition , int adjustBy ) { SortedSet < Integer > newPositions = new TreeSet < > ( ) ; for ( Integer entry : positions ) { int position = entry ; if ( position < startPosition || position > endPosition ) { newPositions . add ( position ) ; } else if ( adjustBy > NUM_ ) { newPositions . add ( position + adjustBy ) ; } else if ( adjustBy < NUM_ ) { if ( position > startPosition + adjustBy && position <= startPosition ) { ; } else { newPositions . add ( position + adjustBy ) ; } } } return newPositions ; }
private static void addId ( final StringBuilder buf , final byte [ ] id ) { buf . append ( STR_ ) ; boolean backslash = BOOL_ ; for ( final byte b : id ) { buf . append ( ( char ) ( b & xFF ) ) ; if ( b == STR_ && backslash ) { buf . append ( STR_ ) ; } else { backslash = b == STR_ ; } } buf . append ( STR_ ) ; }
private ResolvedMigration createAvailableMigration ( int version ) { ResolvedMigration migration = new ResolvedMigration ( ) ; migration . setVersion ( MigrationVersion . fromVersion ( Integer . toString ( version ) ) ) ; migration . setDescription ( STR_ ) ; migration . setScript ( STR_ ) ; migration . setType ( MigrationType . CQL ) ; return migration ; }
public void comment ( String data ) throws SAXException { m_docIsEmpty = BOOL_ ; final int length = data . length ( ) ; if ( length > m_charsBuff . length ) { m_charsBuff = new char [ length . NUM_ + NUM_ ] ; } data . getChars ( NUM_ , length , m_charsBuff , NUM_ ) ; comment ( m_charsBuff , NUM_ , length ) ; }
public boolean drawImage ( Image img , AffineTransform xform , ImageObserver observer ) { if ( img == null ) { return BOOL_ ; } if ( xform == null || xform . isIdentity ( ) ) { return drawImage ( img , NUM_ , NUM_ , null , observer ) ; } if ( isHiDPIImage ( img ) ) { final int w = img . getWidth ( null ) ; final int h = img . getHeight ( null ) ; final AffineTransform tx = new AffineTransform ( transform ) ; transform ( xform ) ; boolean result = drawHiDPIImage ( img , NUM_ , NUM_ , w , h , NUM_ , NUM_ , w , h , null , observer ) ; transform . setTransform ( tx ) ; invalidateTransform ( ) ; return result ; } try { return imagepipe . transformImage ( this , img , xform , observer ) ; } catch ( InvalidPipeException e ) { try { revalidateAll ( ) ; return imagepipe . transformImage ( this , img , xform , observer ) ; } catch ( InvalidPipeException e2 ) { return BOOL_ ; } } finally { surfaceData . markDirty ( ) ; } }
public void beginDisplay ( DisplayEvent event ) throws ModelControlException { super . beginDisplay ( event , BOOL_ ) ; resetButtonState ( TBL_BUTTON_DELETE ) ; AgentsModel model = ( AgentsModel ) getModel ( ) ; String agentType = getDisplayIDType ( ) ; Object [ ] param = { agentType } ; ptModel . setPageTitleText ( model . getLocalizedString ( STR_ + agentType ) ) ; ptModel . setPageTitleHelpMessage ( model . getLocalizedString ( STR_ + agentType + STR_ ) ) ; tblModel . setTitle ( MessageFormat . format ( model . getLocalizedString ( STR_ ) , param ) ) ; tblModel . setTitleLabel ( MessageFormat . format ( model . getLocalizedString ( STR_ ) , param ) ) ; tblModel . setSummary ( MessageFormat . format ( model . getLocalizedString ( STR_ ) , param ) ) ; tblGroupModel . setTitle ( MessageFormat . format ( model . getLocalizedString ( STR_ ) , param ) ) ; tblGroupModel . setTitleLabel ( MessageFormat . format ( model . getLocalizedString ( STR_ ) , param ) ) ; tblGroupModel . setSummary ( MessageFormat . format ( model . getLocalizedString ( STR_ ) , param ) ) ; getAgentNames ( ) ; CCButton b = ( CCButton ) getChild ( TBL_BUTTON_DELETE ) ; b . setDisabled ( BOOL_ ) ; b = ( CCButton ) getChild ( TBL_BUTTON_DELETE_GROUP ) ; b . setDisabled ( BOOL_ ) ; }
public void select_all ( ) { Arrays . fill ( sel_array , BOOL_ ) ; }
public NvpBuilder addRaw ( final String name , final String value ) { npv . put ( name , value ) ; return this ; }
@ Override public int length ( ) { return set . size ( ) ; }
public final long readUnsignedInt ( ) throws IOException { mPosition += NUM_ ; d . readFully ( w , NUM_ , NUM_ ) ; return ( ( long ) ( w [ NUM_ ] ) << NUM_ | ( w [ NUM_ ] & xff ) << NUM_ | ( w [ NUM_ ] & xff ) << NUM_ | ( w [ NUM_ ] & xff ) ) & X00000000FFFFFFFFL ; }
public List < CountryRO > viewAddressCountryOptions ( final ShoppingCart cart , final Shop shop , final String addressType ) { final List < Country > countries = addressBookFacade . getAllCountries ( shop . getCode ( ) , addressType ) ; return map ( countries , CountryRO . class , Country . class ) ; }
public void addPauseListener ( AnimatorPauseListener listener ) { if ( mPauseListeners == null ) { mPauseListeners = new ArrayList < AnimatorPauseListener > ( ) ; } mPauseListeners . add ( listener ) ; }
@ Override public void makeImmutable ( ) { if ( mutable ) { if ( attrs != null ) { Iterator iter = attrs . iterator ( ) ; while ( iter . hasNext ( ) ) { Attribute attr = ( Attribute ) iter . next ( ) ; attr . makeImmutable ( ) ; } attrs = Collections . unmodifiableList ( attrs ) ; } if ( encAttrs != null ) { encAttrs = Collections . unmodifiableList ( encAttrs ) ; } mutable = BOOL_ ; } }
@ Override public boolean batchFinished ( ) throws Exception { if ( getInputFormat ( ) == null ) { throw new IllegalStateException ( STR_ ) ; } Instances toFilter = getInputFormat ( ) ; if ( ! isFirstBatchDone ( ) ) { Instances toFilterIgnoringAttributes = removeIgnored ( toFilter ) ; File file = getSerializedClustererFile ( ) ; if ( ! file . isDirectory ( ) ) { ObjectInputStream ois = new ObjectInputStream ( new FileInputStream ( file ) ) ; m_ActualClusterer = ( Clusterer ) ois . readObject ( ) ; Instances header = null ; try { header = ( Instances ) ois . readObject ( ) ; } catch ( Exception e ) { } ois . close ( ) ; if ( ( header != null ) && ( ! header . equalHeaders ( toFilterIgnoringAttributes ) ) ) { throw new WekaException ( STR_ + header . equalHeadersMsg ( toFilterIgnoringAttributes ) ) ; } } else { m_ActualClusterer = AbstractClusterer . makeCopy ( m_Clusterer ) ; m_ActualClusterer . buildClusterer ( toFilterIgnoringAttributes ) ; } Instances filtered = new Instances ( toFilter , NUM_ ) ; ArrayList < String > nominal_values = new ArrayList < String > ( m_ActualClusterer . numberOfClusters ( ) ) ; for ( int i = NUM_ ; i < m_ActualClusterer . numberOfClusters ( ) ; i ++ ) { nominal_values . add ( STR_ + ( i + NUM_ ) ) ; } filtered . insertAttributeAt ( new Attribute ( STR_ , nominal_values ) , filtered . numAttributes ( ) ) ; setOutputFormat ( filtered ) ; } for ( int i = NUM_ ; i < toFilter . numInstances ( ) ; i ++ ) { convertInstance ( toFilter . instance ( i ) ) ; } flushInput ( ) ; m_NewBatch = BOOL_ ; m_FirstBatchDone = BOOL_ ; return ( numPendingOutput ( ) != NUM_ ) ; }
public void addComponent ( T component ) { components . add ( component ) ; }
public static UiResult openUrl ( URI uri ) { return openUrl ( uri . toString ( ) ) ; }
public final void invalidateLine ( int line ) { repaint ( NUM_ , textArea . lineToY ( line ) + fm . getMaxDescent ( ) + fm . getLeading ( ) , getWidth ( ) , fm . getHeight ( ) ) ; }
public ByteBandedRaster ( SampleModel sampleModel , Point origin ) { this ( sampleModel , sampleModel . createDataBuffer ( ) , new Rectangle ( origin . x , origin . y , sampleModel . getWidth ( ) , sampleModel . getHeight ( ) ) , origin , null ) ; }
private void initialize ( URI p_other ) { m_scheme = p_other . getScheme ( ) ; m_userinfo = p_other . getUserinfo ( ) ; m_host = p_other . getHost ( ) ; m_port = p_other . getPort ( ) ; m_path = p_other . getPath ( ) ; m_queryString = p_other . getQueryString ( ) ; m_fragment = p_other . getFragment ( ) ; }
public void playTogether ( Collection < Animator > items ) { if ( items != null && items . size ( ) > NUM_ ) { mNeedsSort = BOOL_ ; Builder builder = null ; for ( Animator anim : items ) { if ( builder == null ) { builder = play ( anim ) ; } else { builder . with ( anim ) ; } } } }
private E unlinkLast ( ) { Node < E > l = last ; if ( l == null ) return null ; Node < E > p = l . prev ; E item = l . item ; l . item = null ; l . prev = l ; last = p ; if ( p == null ) first = null ; else p . next = null ; -- count ; notFull . signal ( ) ; return item ; }
static boolean isRefreshNotificationRegistered ( NotificationListener client , RefreshNotificationType type ) { boolean isRegistered = BOOL_ ; Map < RefreshNotificationType , Integer > notifications = null ; synchronized ( refreshClients ) { notifications = ( Map < RefreshNotificationType , Integer > ) refreshClients . get ( client ) ; } if ( notifications != null ) { Integer timerNotificationId = notifications . get ( type ) ; if ( timerNotificationId != null ) { isRegistered = BOOL_ ; } } return isRegistered ; }
private Collection < String > readProcessOutput ( Process proc ) throws IOException { BufferedReader rdr = new BufferedReader ( new InputStreamReader ( proc . getInputStream ( ) ) ) ; Collection < String > res = new ArrayList < > ( ) ; String s ; while ( ( s = rdr . readLine ( ) ) != null ) res . add ( s ) ; return res ; }
public void fillHeaderAndFooter ( final HttpServletRequest request , final HttpServletResponse response , final Map < String , Object > dataModel ) throws Exception { fillHeader ( request , response , dataModel ) ; fillFooter ( dataModel ) ; }
public void addOperand ( ISpacePredicate operand ) { if ( _operandsList == null ) _operandsList = new ArrayList < ISpacePredicate > ( ) ; _operandsList . add ( operand ) ; }
public static String decode ( String s , Type t ) { if ( s == null ) { throw new IllegalArgumentException ( ) ; } final int n = s . length ( ) ; if ( n == NUM_ ) { return s ; } if ( s . indexOf ( STR_ ) < NUM_ ) { if ( t == Type . QUERY_PARAM ) { if ( s . indexOf ( STR_ ) < NUM_ ) { return s ; } } else { return s ; } } else { if ( n < NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } if ( s . charAt ( n - NUM_ ) == STR_ ) { throw new IllegalArgumentException ( STR_ + ( n - NUM_ ) ) ; } } if ( t == null ) { return decode ( s , n ) ; } switch ( t ) { case HOST : return decodeHost ( s , n ) ; case QUERY_PARAM : return decodeQueryParam ( s , n ) ; default : return decode ( s , n ) ; } }
public BigDecimal calculateTotalCollectedAmt ( final BillReceiptInfo bri , final List < EgBillDetails > billDetList ) throws InvalidAccountHeadException { return bri . getTotalAmount ( ) ; }
public void skip ( int count ) throws IOException { int skipCount = Math . min ( limit - position , count ) ; while ( BOOL_ ) { position += skipCount ; count -= skipCount ; if ( count == NUM_ ) break ; skipCount = Math . min ( count , capacity ) ; require ( skipCount ) ; } }
public void test_concurrent_modification_insert ( ) { final BTree btree ; { IndexMetadata md = new IndexMetadata ( UUID . randomUUID ( ) ) ; md . setBranchingFactor ( NUM_ ) ; btree = BTree . create ( new SimpleMemoryRawStore ( ) , md ) ; btree . insert ( NUM_ , STR_ ) ; btree . insert ( NUM_ , STR_ ) ; btree . insert ( NUM_ , STR_ ) ; } { ITupleCursor2 < String > cursor = newCursor ( btree ) ; assertEquals ( new TestTuple < String > ( NUM_ , STR_ ) , cursor . seek ( NUM_ ) ) ; assertEquals ( new TestTuple < String > ( NUM_ , STR_ ) , cursor . tuple ( ) ) ; btree . insert ( NUM_ , STR_ ) ; assertEquals ( TestKeyBuilder . asSortKey ( NUM_ ) , cursor . currentKey ( ) ) ; assertEquals ( new TestTuple < String > ( NUM_ , STR_ ) , cursor . tuple ( ) ) ; assertEquals ( new TestTuple < String > ( NUM_ , STR_ ) , cursor . prior ( ) ) ; assertEquals ( new TestTuple < String > ( NUM_ , STR_ ) , cursor . tuple ( ) ) ; btree . remove ( NUM_ ) ; assertEquals ( null , cursor . tuple ( ) ) ; assertEquals ( TestKeyBuilder . asSortKey ( NUM_ ) , cursor . currentKey ( ) ) ; assertEquals ( new TestTuple < String > ( NUM_ , STR_ ) , cursor . next ( ) ) ; btree . remove ( NUM_ ) ; assertEquals ( null , cursor . tuple ( ) ) ; assertEquals ( TestKeyBuilder . asSortKey ( NUM_ ) , cursor . currentKey ( ) ) ; btree . insert ( NUM_ , STR_ ) ; assertEquals ( TestKeyBuilder . asSortKey ( NUM_ ) , cursor . currentKey ( ) ) ; assertEquals ( null , cursor . tuple ( ) ) ; assertEquals ( new TestTuple < String > ( NUM_ , STR_ ) , cursor . next ( ) ) ; assertEquals ( new TestTuple < String > ( NUM_ , STR_ ) , cursor . tuple ( ) ) ; } }
public void removeAllIms ( ) { ims . clear ( ) ; }
static String escapeStringForASCII ( String s ) { String out = STR_ ; char [ ] cArray = s . toCharArray ( ) ; for ( int i = NUM_ ; i < cArray . length ; i ++ ) { char c = cArray [ i ] ; if ( c > NUM_ ) { out += STR_ ; String hex = Integer . toHexString ( c ) ; while ( hex . length ( ) < NUM_ ) hex = STR_ + hex ; out += hex ; } else if ( c == STR_ ) { out += STR_ ; } else if ( c == STR_ ) { out += STR_ ; } else if ( c == STR_ ) { out += STR_ ; } else if ( c == STR_ ) { out += STR_ ; } else if ( c == STR_ ) { out += STR_ ; } else if ( c == STR_ ) { out += STR_ ; } else { out += c ; } } return out ; }
public void copyReader ( String encoding , Reader r ) throws IOException { super . setContentEncoding ( encoding ) ; String s = readString ( r ) ; content = s . getBytes ( encoding ) ; }
private void clearDictionaryCache ( ) { Map < String , Dictionary > dictionaryCaches = surrogateKeyGen . getDictionaryCaches ( ) ; List < Dictionary > reverseDictionaries = new ArrayList < > ( dictionaryCaches . values ( ) ) ; for ( int i = NUM_ ; i < reverseDictionaries . size ( ) ; i ++ ) { Dictionary dictionary = reverseDictionaries . get ( i ) ; dictionary . clear ( ) ; } }
public static String toTypeString ( Object [ ] arguments , int maxSize ) { if ( arguments == null ) { return STR_ ; } StringBuilder argBuf = new StringBuilder ( ) ; for ( int i = NUM_ ; i < arguments . length ; i ++ ) { if ( maxSize != - NUM_ && argBuf . length ( ) > maxSize ) { argBuf . append ( STR_ ) ; break ; } else { if ( i > NUM_ ) { argBuf . append ( STR_ ) ; } argBuf . append ( arguments [ i ] != null ? typeName ( arguments [ i ] ) : STR_ ) ; } } return argBuf . toString ( ) ; }
public boolean renameFile ( File oldFile , File newFile ) { synchronized ( fileCache ) { if ( oldFile . renameTo ( newFile ) ) { validateFileCache ( ) ; return BOOL_ ; } return BOOL_ ; } }
public Future < ? > execute ( CameraCommand command ) { if ( mClosed ) { return Futures . immediateFuture ( null ) ; } synchronized ( mLock ) { if ( mExecutor == null ) { mExecutor = mExecutorProvider . get ( ) ; } checkNotNull ( mExecutor ) ; return mExecutor . submit ( new CommandRunnable ( command ) ) ; } }
public static EnumSet < KindName > kindNames ( int kind ) { EnumSet < KindName > kinds = EnumSet . noneOf ( KindName . class ) ; if ( ( kind & VAL ) != NUM_ ) kinds . add ( ( ( kind & VAL ) == VAR ) ? KindName . VAR : KindName . VAL ) ; if ( ( kind & MTH ) != NUM_ ) kinds . add ( KindName . METHOD ) ; if ( ( kind & TYP ) != NUM_ ) kinds . add ( KindName . CLASS ) ; if ( ( kind & PCK ) != NUM_ ) kinds . add ( KindName . PACKAGE ) ; return kinds ; }
public int length ( ) { return text . length ( ) ; }
public static String serializeDigestResponse ( Map < String , String > paramMap ) { StringBuilder sb = new StringBuilder ( STR_ ) ; boolean prefixComma = BOOL_ ; for ( Map . Entry < String , String > entry : paramMap . entrySet ( ) ) { if ( ! prefixComma ) { prefixComma = BOOL_ ; } else { sb . append ( STR_ ) ; } sb . append ( entry . getKey ( ) ) ; sb . append ( STR_ ) ; sb . append ( entry . getValue ( ) ) ; } return sb . toString ( ) ; }
public void populateCombos ( Activity activity , final Listener listener ) { List < String > services = getServices ( activity . getPackageManager ( ) ) ; populateCombos ( activity , services , listener ) ; }
protected JsonEncoding findEncoding ( MediaType mediaType , MultivaluedMap < String , Object > httpHeaders ) { return JsonEncoding . UTF8 ; }
static BufferedImage convertImage ( BufferedImage image ) { switch ( image . getType ( ) ) { case BufferedImage . TYPE_INT_ARGB_PRE : return image ; case BufferedImage . TYPE_4BYTE_ABGR : image . coerceData ( BOOL_ ) ; return image ; } BufferedImage convertedImage = new BufferedImage ( image . getWidth ( ) , image . getHeight ( ) , BufferedImage . TYPE_INT_ARGB_PRE ) ; Graphics2D g = convertedImage . createGraphics ( ) ; g . setColor ( new java . awt . Color ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; g . fillRect ( NUM_ , NUM_ , image . getWidth ( ) , image . getHeight ( ) ) ; g . drawImage ( image , NUM_ , NUM_ , null ) ; g . dispose ( ) ; return convertedImage ; }
public long start ( ) { startTime = System . currentTimeMillis ( ) ; return startTime ; }
public void next ( ) { if ( iterator . hasNext ( ) ) { View currentView = iterator . next ( ) ; if ( isUsingDefaultListener ( ) ) currentView . setOnClickListener ( null ) ; if ( iterator . nextIndex ( ) < mViews . size ( ) ) { View nextView = mViews . get ( iterator . nextIndex ( ) ) ; if ( isUsingDefaultListener ( ) ) nextView . setOnClickListener ( listener ) ; ControllerAnimator animator = getDefaultForwardAnimation ( ) ; animator . setOldView ( currentView ) ; animator . setNewView ( nextView ) ; currentView . startAnimation ( animator ) ; if ( iterator . nextIndex ( ) == mViews . size ( ) - NUM_ ) if ( hasControllerListener ( ) ) mListener . onEndReached ( ) ; } else { if ( mLoop ) { iterator = mViews . listIterator ( ) ; View nextView = mViews . get ( NUM_ ) ; if ( mUseDefaultListener ) nextView . setOnClickListener ( listener ) ; ControllerAnimator animator = getDefaultForwardAnimation ( ) ; animator . setOldView ( currentView ) ; animator . setNewView ( nextView ) ; currentView . startAnimation ( animator ) ; } } } }
private boolean isHHSign ( String str ) { boolean sign = BOOL_ ; try { char r = ( char ) Integer . parseInt ( str , NUM_ ) ; } catch ( NumberFormatException e ) { sign = BOOL_ ; } return sign ; }
public void simulateMethod ( SootMethod method , ReferenceVariable thisVar , ReferenceVariable returnVar , ReferenceVariable params [ ] ) { String subSignature = method . getSubSignature ( ) ; if ( subSignature . equals ( STR_ ) ) { sun_misc_Unsafe_allocateInstance ( method , thisVar , returnVar , params ) ; return ; } { defaultMethod ( method , thisVar , returnVar , params ) ; return ; } }
public void cacheResolvedMethod ( Class clas , Class [ ] types , Method method ) { if ( Interpreter . DEBUG ) Interpreter . debug ( STR_ + clas + STR_ + method ) ; SignatureKey sk = new SignatureKey ( clas , method . getName ( ) , types ) ; if ( Modifier . isStatic ( method . getModifiers ( ) ) ) resolvedStaticMethods . put ( sk , method ) ; else resolvedObjectMethods . put ( sk , method ) ; }
public void testSetBitTopPositive ( ) { byte aBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int number = NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger result = aNumber . setBit ( number ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
private void destroyBeans ( Map < String , Object > viewMap , Map < String , ViewScopeContextObject > contextMap ) { ArrayList < String > removalNameList = new ArrayList < > ( ) ; if ( contextMap != null ) { for ( Map . Entry < String , ViewScopeContextObject > entry : contextMap . entrySet ( ) ) { String passivationCapableId = entry . getKey ( ) ; Contextual contextual = beanManager . getPassivationCapableBean ( passivationCapableId ) ; ViewScopeContextObject contextObject = entry . getValue ( ) ; CreationalContext creationalContext = beanManager . createCreationalContext ( contextual ) ; contextual . destroy ( viewMap . get ( contextObject . getName ( ) ) , creationalContext ) ; removalNameList . add ( contextObject . getName ( ) ) ; } Iterator < String > removalNames = removalNameList . iterator ( ) ; while ( removalNames . hasNext ( ) ) { String name = removalNames . next ( ) ; viewMap . remove ( name ) ; } contextMap . clear ( ) ; } }
public static void close ( @ CheckForNull OutputStream outputStream ) { if ( outputStream == null ) { return ; } try { outputStream . close ( ) ; } catch ( IOException e ) { } }
@ Override public Node item ( int index ) { return ( nodes != null && index < nodes . size ( ) ) ? ( Node ) ( nodes . get ( index ) ) : null ; }
private int charToVisibleWidth ( char c , @ JdkConstants . FontStyle int fontType , int currentX ) { if ( c == STR_ ) { return NUM_ ; } if ( c == STR_ ) { return EditorUtil . nextTabStop ( currentX , this ) - currentX ; } return EditorUtil . charWidth ( c , fontType , this ) ; }
public static void createDir ( File target ) throws AdeUsageException { if ( ! target . exists ( ) && ! target . mkdir ( ) && ! target . exists ( ) ) { throw new AdeUsageException ( STR_ + target . getPath ( ) ) ; } }
public GTSEncoder ( long baseTimestamp ) { this . baseTimestamp = baseTimestamp ; this . stream = new ByteArrayOutputStream ( ) ; this . wrappingKey = null ; }
public static String encode ( final Coordinate [ ] coords ) { long lastLat = NUM_ ; long lastLng = NUM_ ; final StringBuffer result = new StringBuffer ( ) ; for ( final Coordinate point : coords ) { long lat = Math . round ( point . y . NUM_ ) ; long lng = Math . round ( point . x . NUM_ ) ; long dLat = lat - lastLat ; long dLng = lng - lastLng ; encode ( dLat , result ) ; encode ( dLng , result ) ; lastLat = lat ; lastLng = lng ; } return result . toString ( ) ; }
private void extractWeightValues ( List < Synapse > synapses ) { int exWeights = NUM_ ; int inWeights = NUM_ ; for ( Synapse s : synapses ) { double w = s . getStrength ( ) ; if ( w > NUM_ ) { exWeights ++ ; } else { inWeights ++ ; } } weights [ NUM_ ] = new double [ exWeights ] ; weights [ NUM_ ] = new double [ inWeights ] ; exWeights = NUM_ ; inWeights = NUM_ ; if ( weights [ NUM_ ] . length != NUM_ ) { for ( Synapse s : synapses ) { double w = s . getStrength ( ) ; if ( w > NUM_ ) { weights [ NUM_ ] [ exWeights ++ ] = w ; } else { weights [ NUM_ ] [ inWeights ++ ] = w ; } } } }
@ Override public void close ( ) { try { flush ( ) ; } catch ( AMLogException ale ) { Debug . error ( tableName + STR_ + ale . getMessage ( ) ) ; } if ( conn != null ) { try { conn . close ( ) ; } catch ( SQLException ce ) { Debug . error ( tableName + STR_ , ce ) ; } } stopBufferTimer ( ) ; }
public boolean contains ( List < Integer > hashes ) { Iterator < Integer > ni = hashes . iterator ( ) ; for ( int i = NUM_ ; i < hashFunctions ; ++ i ) { if ( ! testBit ( ( int ) ( ( ni . next ( ) & xFFFFFFFFL ) % ( filter . length . NUM_ ) ) ) ) { return BOOL_ ; } } return BOOL_ ; }
private void ensureCapacity ( int additionalData ) { if ( ( this . position + additionalData ) > this . byteBuffer . length ) { int newLength = ( int ) ( this . byteBuffer . length . NUM_ ) ; if ( newLength < ( this . byteBuffer . length + additionalData ) ) { newLength = this . byteBuffer . length + ( int ) ( additionalData . NUM_ ) ; } if ( newLength < this . byteBuffer . length ) { newLength = this . byteBuffer . length + additionalData ; } byte [ ] newBytes = new byte [ newLength ] ; System . arraycopy ( this . byteBuffer , NUM_ , newBytes , NUM_ , this . byteBuffer . length ) ; this . byteBuffer = newBytes ; } }
public boolean isValidNumber ( PhoneNumber number ) { String regionCode = getRegionCodeForNumber ( number ) ; return isValidNumberForRegion ( number , regionCode ) ; }
private String trimUrl ( String uri ) { if ( uri == null ) return STR_ ; if ( uri . endsWith ( STR_ ) ) uri = uri . substring ( NUM_ , uri . length ( ) - NUM_ ) ; return uri ; }
public Pair < Integer , List < Long > > next ( ) { try { classesProcessed ++ ; Integer key = iterator . next ( ) ; long pos = classificationBlockRMA2 . getPos ( key ) ; int count = classificationBlockRMA2 . getSum ( key ) ; classDumpReader . seek ( pos ) ; List < Long > list = new LinkedList < > ( ) ; for ( int i = NUM_ ; i < count ; i ++ ) list . add ( classDumpReader . readLong ( ) ) ; return new Pair < > ( key , list ) ; } catch ( Exception e ) { Basic . caught ( e ) ; error = BOOL_ ; return null ; } }
public static String addAlpha ( String originalColor , double alpha ) { long alphaFixed = Math . round ( alpha . NUM_ ) ; String alphaHex = Long . toHexString ( alphaFixed ) ; if ( alphaHex . length ( ) == NUM_ ) { alphaHex = STR_ + alphaHex ; } originalColor = originalColor . replace ( STR_ , STR_ + alphaHex ) ; return originalColor ; }
public void stop ( ) { server . stop ( NUM_ ) ; }
protected DateTimeData parse ( String str , int durationType ) throws SchemaDateTimeException { int len = str . length ( ) ; DateTimeData date = new DateTimeData ( str , this ) ; int start = NUM_ ; char c = str . charAt ( start ++ ) ; if ( c != STR_ && c != STR_ ) { throw new SchemaDateTimeException ( ) ; } else { date . utc = ( c == STR_ ) ? STR_ : NUM_ ; if ( c == STR_ && str . charAt ( start ++ ) != STR_ ) { throw new SchemaDateTimeException ( ) ; } } int negate = NUM_ ; if ( date . utc == STR_ ) { negate = - NUM_ ; } boolean designator = BOOL_ ; int endDate = indexOf ( str , start , len , STR_ ) ; if ( endDate == - NUM_ ) { endDate = len ; } else if ( durationType == YEARMONTHDURATION_TYPE ) { throw new SchemaDateTimeException ( ) ; } int end = indexOf ( str , start , endDate , STR_ ) ; if ( end != - NUM_ ) { if ( durationType == DAYTIMEDURATION_TYPE ) { throw new SchemaDateTimeException ( ) ; } date . year = negate . parseInt ( str , start , end ) ; start = end + NUM_ ; designator = BOOL_ ; } end = indexOf ( str , start , endDate , STR_ ) ; if ( end != - NUM_ ) { if ( durationType == DAYTIMEDURATION_TYPE ) { throw new SchemaDateTimeException ( ) ; } date . month = negate . parseInt ( str , start , end ) ; start = end + NUM_ ; designator = BOOL_ ; } end = indexOf ( str , start , endDate , STR_ ) ; if ( end != - NUM_ ) { if ( durationType == YEARMONTHDURATION_TYPE ) { throw new SchemaDateTimeException ( ) ; } date . day = negate . parseInt ( str , start , end ) ; start = end + NUM_ ; designator = BOOL_ ; } if ( len == endDate && start != len ) { throw new SchemaDateTimeException ( ) ; } if ( len != endDate ) { end = indexOf ( str , ++ start , len , STR_ ) ; if ( end != - NUM_ ) { date . hour = negate . parseInt ( str , start , end ) ; start = end + NUM_ ; designator = BOOL_ ; } end = indexOf ( str , start , len , STR_ ) ; if ( end != - NUM_ ) { date . minute = negate . parseInt ( str , start , end ) ; start = end + NUM_ ; designator = BOOL_ ; } end = indexOf ( str , start , len , STR_ ) ; if ( end != - NUM_ ) { date . second = negate . parseSecond ( str , start , end ) ; start = end + NUM_ ; designator = BOOL_ ; } if ( start != len || str . charAt ( -- start ) == STR_ ) { throw new SchemaDateTimeException ( ) ; } } if ( ! designator ) { throw new SchemaDateTimeException ( ) ; } return date ; }
final void copyIntoLocalState ( Operand [ ] _localState ) { localState = new Operand [ _localState . length ] ; System . arraycopy ( _localState , NUM_ , localState , NUM_ , _localState . length ) ; setLocalKnown ( ) ; }
@ SuppressWarnings ( STR_ ) private HashMap < String , DBObject > loadDBObjects ( Class objectClass ) { HashMap < String , DBObject > objectMap = new HashMap < String , DBObject > ( ) ; DBObject dbObject = new DBObject ( this , objectClass ) ; String objectToLoad = s_logger . localizeMessage ( STR_ ) ; String objectsToLoad = s_logger . localizeMessage ( STR_ ) ; String sqlLoadHeaders = null ; String sqlLoadContents = null ; if ( dbObject != null ) { objectToLoad = dbObject . getObjectType ( ) ; objectsToLoad = dbObject . getObjectTypes ( ) ; sqlLoadHeaders = dbObject . getLoadHeaderSQL ( ) ; sqlLoadContents = dbObject . getLoadContentSQL ( ) ; } s_logger . log ( Level . FINE , STR_ , new Object [ ] { objectsToLoad , getDirection ( ) } ) ; PreparedStatementWrapper stmtLoadHeaders = setPreparedStatement ( sqlLoadHeaders ) ; PreparedStatementWrapper stmtLoadContents = setPreparedStatement ( sqlLoadContents ) ; int counter = NUM_ ; if ( dbObject != null ) { String sql = dbObject . getLoadObjectSQL ( ) ; Statement stmt = setStatement ( ) ; ResultSet rs = executeQuery ( stmt , sql ) ; while ( getResultSetNext ( rs ) ) { String s = getResultSetString ( rs , STR_ ) ; if ( ! objectMap . containsKey ( s ) ) { DBObject obj = new DBObject ( this , objectClass , s ) ; obj . populate ( stmtLoadHeaders , stmtLoadContents ) ; if ( obj . isPopulated ( ) ) { objectMap . put ( s . toUpperCase ( ) , obj ) ; counter ++ ; } } } releaseResultSet ( rs ) ; releaseStatement ( stmt ) ; } releasePreparedStatement ( stmtLoadHeaders ) ; releasePreparedStatement ( stmtLoadContents ) ; if ( counter == NUM_ ) s_logger . log ( Level . FINE , STR_ , new Object [ ] { Integer . toString ( counter ) , objectToLoad } ) ; else s_logger . log ( Level . FINE , STR_ , new Object [ ] { Integer . toString ( counter ) , objectsToLoad } ) ; s_logger . flush ( ) ; return objectMap ; }
protected Object attemptReadResponse ( Connection cnx ) throws Exception { Message msg = createResponseMessage ( ) ; if ( msg != null ) { msg . setComms ( cnx . getSocket ( ) , cnx . getInputStream ( ) , cnx . getOutputStream ( ) , cnx . getCommBuffer ( ) , cnx . getStats ( ) ) ; if ( msg instanceof ChunkedMessage ) { try { return processResponse ( msg , cnx ) ; } finally { msg . unsetComms ( ) ; processSecureBytes ( cnx , msg ) ; } } else { try { msg . recv ( ) ; } finally { msg . unsetComms ( ) ; processSecureBytes ( cnx , msg ) ; } return processResponse ( msg , cnx ) ; } } else { return null ; } }
public synchronized boolean add ( E e , boolean hasNext ) { while ( mInternalQueue . size ( ) >= mMaxSize && ! mClosed ) { notifyAll ( ) ; try { wait ( TIMEOUT ) ; } catch ( InterruptedException e1 ) { mClosed = BOOL_ ; ProgramState . checkAbort ( ) ; throw new IllegalStateException ( STR_ , e1 ) ; } ProgramState . checkAbort ( ) ; } if ( mClosed ) { return BOOL_ ; } final boolean wasEmpty = mInternalQueue . isEmpty ( ) ; mHasNext = hasNext ; mInternalQueue . add ( e ) ; if ( wasEmpty ) { notifyAll ( ) ; } return BOOL_ ; }
public void addPart ( int index , PduPart part ) { if ( null == part ) { throw new NullPointerException ( ) ; } putPartToMaps ( part ) ; mParts . add ( index , part ) ; }
public StrBuilder insert ( int index , boolean value ) { validateIndex ( index ) ; if ( value ) { ensureCapacity ( size + NUM_ ) ; System . arraycopy ( buffer , index , buffer , index + NUM_ , size - index ) ; buffer [ index ++ ] = STR_ ; buffer [ index ++ ] = STR_ ; buffer [ index ++ ] = STR_ ; buffer [ index ] = STR_ ; size += NUM_ ; } else { ensureCapacity ( size + NUM_ ) ; System . arraycopy ( buffer , index , buffer , index + NUM_ , size - index ) ; buffer [ index ++ ] = STR_ ; buffer [ index ++ ] = STR_ ; buffer [ index ++ ] = STR_ ; buffer [ index ++ ] = STR_ ; buffer [ index ] = STR_ ; size += NUM_ ; } return this ; }
public boolean hasNatureAndWeapon ( Nature nature , String weapon ) { return this . nature == nature && ( ( weapon == null && this . weapon == null ) || ( weapon != null && weapon . equals ( this . weapon ) ) ) ; }
public void dump ( String infoMsg ) { storage . getOnlineMembers ( ) ; storage . getOfflineMembers ( ) ; storage . getOfflineAndEqualMembers ( ) ; storage . getMyInitializingID ( ) ; storage . getMyPersistentID ( ) ; final StringBuilder buf = new StringBuilder ( NUM_ ) ; if ( infoMsg != null ) { buf . append ( infoMsg ) ; buf . append ( STR_ ) ; } buf . append ( STR_ ) ; buf . append ( storage . getMyPersistentID ( ) ) ; buf . append ( STR_ ) ; buf . append ( storage . getMyInitializingID ( ) ) ; buf . append ( STR_ ) ; for ( PersistentMemberID id : storage . getOnlineMembers ( ) ) { buf . append ( STR_ ) ; buf . append ( id ) ; buf . append ( STR_ ) ; } buf . append ( STR_ ) ; for ( PersistentMemberID id : storage . getOfflineMembers ( ) ) { buf . append ( STR_ ) ; buf . append ( id ) ; buf . append ( STR_ ) ; } buf . append ( STR_ ) ; for ( PersistentMemberID id : storage . getOfflineAndEqualMembers ( ) ) { buf . append ( STR_ ) ; buf . append ( id ) ; buf . append ( STR_ ) ; } logger . debug ( buf . toString ( ) ) ; }
private Node < K , V > findNode ( Object key ) { if ( key == null ) throw new NullPointerException ( ) ; Comparator < ? super K > cmp = comparator ; outer : for ( ; ; ) { for ( Node < K , V > b = findPredecessor ( key , cmp ) , n = b . next ; ; ) { Object v ; int c ; if ( n == null ) break outer ; Node < K , V > f = n . next ; if ( n != b . next ) break ; if ( ( v = n . value ) == null ) { n . helpDelete ( b , f ) ; break ; } if ( b . value == null || v == n ) break ; if ( ( c = cpr ( cmp , key , n . key ) ) == NUM_ ) return n ; if ( c < NUM_ ) break outer ; b = n ; n = f ; } } return null ; }
static Sort parseSort ( long timestampSec , IndexState state , List < Object > fields , List < String > sortFieldNames , Map < String , FieldDef > dynamicFields ) { List < SortField > sortFields = new ArrayList < SortField > ( ) ; for ( Object _sub : fields ) { Request sub = ( Request ) _sub ; String fieldName = sub . getString ( STR_ ) ; SortField sf ; if ( sortFieldNames != null ) { sortFieldNames . add ( fieldName ) ; } if ( fieldName . equals ( STR_ ) ) { sf = SortField . FIELD_DOC ; } else if ( fieldName . equals ( STR_ ) ) { sf = SortField . FIELD_SCORE ; } else { FieldDef fd ; if ( dynamicFields != null ) { fd = dynamicFields . get ( fieldName ) ; } else { fd = null ; } if ( fd == null ) { fd = state . getField ( fieldName ) ; } if ( fd == null ) { sub . fail ( STR_ , STR_ + fieldName + STR_ ) ; fd = null ; } if ( fd . valueSource != null ) { sf = fd . valueSource . getSortField ( sub . getBoolean ( STR_ ) ) ; } else if ( fd . valueType == FieldDef . FieldValueType . LAT_LON ) { if ( fd . fieldType . docValuesType ( ) == DocValuesType . NONE ) { sub . fail ( STR_ , STR_ + fieldName + STR_ ) ; } Request sub2 = sub . getStruct ( STR_ ) ; sf = LatLonDocValuesField . newDistanceSort ( fieldName , sub2 . getDouble ( STR_ ) , sub2 . getDouble ( STR_ ) ) ; } else { if ( ( fd . fieldType != null && fd . fieldType . docValuesType ( ) == DocValuesType . NONE ) || ( fd . fieldType == null && fd . valueSource == null ) ) { sub . fail ( STR_ , STR_ + fieldName + STR_ ) ; } if ( fd . multiValued ) { String selectorString = sub . getEnum ( STR_ ) ; if ( fd . valueType == FieldDef . FieldValueType . ATOM ) { SortedSetSelector . Type selector ; if ( selectorString . equals ( STR_ ) ) { selector = SortedSetSelector . Type . MIN ; } else if ( selectorString . equals ( STR_ ) ) { selector = SortedSetSelector . Type . MAX ; } else if ( selectorString . equals ( STR_ ) ) { selector = SortedSetSelector . Type . MIDDLE_MIN ; } else if ( selectorString . equals ( STR_ ) ) { selector = SortedSetSelector . Type . MIDDLE_MAX ; } else { assert BOOL_ ; selector = null ; } sf = new SortedSetSortField ( fieldName , sub . getBoolean ( STR_ ) , selector ) ; } else if ( fd . valueType == FieldDef . FieldValueType . INT ) { sf = new SortedNumericSortField ( fieldName , SortField . Type . INT , sub . getBoolean ( STR_ ) , parseNumericSelector ( sub , selectorString ) ) ; } else if ( fd . valueType == FieldDef . FieldValueType . LONG ) { sf = new SortedNumericSortField ( fieldName , SortField . Type . LONG , sub . getBoolean ( STR_ ) , parseNumericSelector ( sub , selectorString ) ) ; } else if ( fd . valueType == FieldDef . FieldValueType . FLOAT ) { sf = new SortedNumericSortField ( fieldName , SortField . Type . FLOAT , sub . getBoolean ( STR_ ) , parseNumericSelector ( sub , selectorString ) ) ; } else if ( fd . valueType == FieldDef . FieldValueType . DOUBLE ) { sf = new SortedNumericSortField ( fieldName , SortField . Type . DOUBLE , sub . getBoolean ( STR_ ) , parseNumericSelector ( sub , selectorString ) ) ; } else { sub . fail ( STR_ , STR_ + fieldName + STR_ + fd . valueType ) ; assert BOOL_ ; sf = null ; } } else { SortField . Type sortType ; if ( fd . valueType == FieldDef . FieldValueType . ATOM ) { sortType = SortField . Type . STRING ; } else if ( fd . valueType == FieldDef . FieldValueType . LONG || fd . valueType == FieldDef . FieldValueType . DATE_TIME ) { sortType = SortField . Type . LONG ; } else if ( fd . valueType == FieldDef . FieldValueType . INT ) { sortType = SortField . Type . INT ; } else if ( fd . valueType == FieldDef . FieldValueType . DOUBLE ) { sortType = SortField . Type . DOUBLE ; } else if ( fd . valueType == FieldDef . FieldValueType . FLOAT ) { sortType = SortField . Type . FLOAT ; } else { sub . fail ( STR_ , STR_ + fieldName + STR_ + fd . valueType ) ; assert BOOL_ ; sortType = null ; } sf = new SortField ( fieldName , sortType , sub . getBoolean ( STR_ ) ) ; } } boolean hasMissingLast = sub . hasParam ( STR_ ) ; boolean missingLast = sub . getBoolean ( STR_ ) ; if ( fd . valueType == FieldDef . FieldValueType . ATOM ) { if ( missingLast ) { sf . setMissingValue ( SortField . STRING_LAST ) ; } else { sf . setMissingValue ( SortField . STRING_FIRST ) ; } } else if ( fd . valueType == FieldDef . FieldValueType . INT ) { sf . setMissingValue ( missingLast ? Integer . MAX_VALUE : Integer . MIN_VALUE ) ; } else if ( fd . valueType == FieldDef . FieldValueType . LONG ) { sf . setMissingValue ( missingLast ? Long . MAX_VALUE : Long . MIN_VALUE ) ; } else if ( fd . valueType == FieldDef . FieldValueType . FLOAT ) { sf . setMissingValue ( missingLast ? Float . POSITIVE_INFINITY : Float . NEGATIVE_INFINITY ) ; } else if ( fd . valueType == FieldDef . FieldValueType . DOUBLE ) { sf . setMissingValue ( missingLast ? Double . POSITIVE_INFINITY : Double . NEGATIVE_INFINITY ) ; } else if ( hasMissingLast ) { sub . fail ( STR_ , STR_ + fieldName + STR_ + sf . getType ( ) ) ; } } sortFields . add ( sf ) ; } return new Sort ( sortFields . toArray ( new SortField [ sortFields . size ( ) ] ) ) ; }
@ NotNull private Optional < TypeConversion > findConversionFromDbValue ( @ NotNull Type source , @ NotNull Type target ) { if ( isAssignable ( target , source ) ) return Optional . of ( TypeConversion . identity ( ) ) ; Optional < TypeConversion > directConversion = typeConversionRegistry . findConversionFromDbValue ( source , target ) ; if ( directConversion . isPresent ( ) ) return directConversion ; Optional < TypeConversion > arrayConversion = findArrayConversion ( source , target ) ; if ( arrayConversion . isPresent ( ) ) return arrayConversion ; Optional < TypeConversion > optionalConversion = findOptionalConversion ( source , target ) ; if ( optionalConversion . isPresent ( ) ) return optionalConversion ; Optional < TypeConversion > enumConversion = findEnumConversion ( target ) ; if ( enumConversion . isPresent ( ) ) return enumConversion ; return Optional . empty ( ) ; }
private boolean advanceApiUpTo ( TreeSet < AreaPanelInfo > sortedApiTree , AreaPanelInfo api , int time ) { AreaPanel ap = api . ap ( ) ; TimeTree rootTt = ap . getTimeTree ( ) ; TimeTree tt = rootTt . getEncompassigTimeTreeOrMaxTimeTreeBeforeTime ( time , BOOL_ ) ; if ( tt == null || tt . id == api . currTtId ) return BOOL_ ; sortedApiTree . remove ( api ) ; if ( api . setTt ( tt , Integer . MAX_VALUE ) ) sortedApiTree . add ( api ) ; return BOOL_ ; }
@ RequestMapping ( value = { STR_ , STR_ } , method = RequestMethod . POST ) @ ResponseBody public RestWrapper update ( @ ModelAttribute ( STR_ ) @ Valid UserRoles userRoles , BindingResult bindingResult , Principal principal ) { RestWrapper restWrapper = null ; if ( bindingResult . hasErrors ( ) ) { BindingResultError bindingResultError = new BindingResultError ( ) ; return bindingResultError . errorMessage ( bindingResult ) ; } try { com . wipro . ats . bdre . md . dao . jpa . UserRoles jpaUserRoles = new com . wipro . ats . bdre . md . dao . jpa . UserRoles ( ) ; jpaUserRoles . setUserRoleId ( userRoles . getUserRoleId ( ) ) ; jpaUserRoles . setRole ( userRoles . getRole ( ) ) ; Users users = new Users ( ) ; users . setUsername ( userRoles . getUsername ( ) ) ; jpaUserRoles . setUsers ( users ) ; userRolesDAO . update ( jpaUserRoles ) ; restWrapper = new RestWrapper ( userRoles , RestWrapper . OK ) ; LOGGER . info ( STR_ + userRoles . getUserRoleId ( ) + STR_ + principal . getName ( ) + userRoles ) ; } catch ( Exception e ) { LOGGER . error ( e ) ; restWrapper = new RestWrapper ( e . getMessage ( ) , RestWrapper . ERROR ) ; } return restWrapper ; }
private void sendRequestOption ( ) throws IOException { String request = STR_ + mParameters . host + STR_ + mParameters . port + mParameters . path + STR_ + addHeaders ( ) ; Log . i ( TAG , request . substring ( NUM_ , request . indexOf ( STR_ ) ) ) ; mOutputStream . write ( request . getBytes ( STR_ ) ) ; Response . parseResponse ( mBufferedReader ) ; }
@ Override public Result doComparisonTest ( final Properties properties ) throws Exception { final long timeout = Long . parseLong ( properties . getProperty ( TestOptions . TIMEOUT ) ) ; final int nresources = Integer . parseInt ( properties . getProperty ( TestOptions . NRESOURCES ) ) ; final int minLocks = Integer . parseInt ( properties . getProperty ( TestOptions . MIN_LOCKS ) ) ; final int maxLocks = Integer . parseInt ( properties . getProperty ( TestOptions . MAX_LOCKS ) ) ; final int ntrials = Integer . parseInt ( properties . getProperty ( TestOptions . NTRIALS ) ) ; final int keyLen = Integer . parseInt ( properties . getProperty ( TestOptions . KEYLEN ) ) ; final int nops = Integer . parseInt ( properties . getProperty ( TestOptions . NOPS ) ) ; final double failureRate = Double . parseDouble ( properties . getProperty ( TestOptions . FAILURE_RATE ) ) ; Result result = doConcurrentClientTest ( journal , timeout , nresources , minLocks , maxLocks , ntrials , keyLen , nops , failureRate ) ; return result ; }
public static void printThreadInfo ( PrintWriter stream , String title ) { final int STACK_DEPTH = NUM_ ; boolean contention = threadBean . isThreadContentionMonitoringEnabled ( ) ; long [ ] threadIds = threadBean . getAllThreadIds ( ) ; stream . println ( STR_ + title ) ; stream . println ( threadIds . length + STR_ ) ; for ( long tid : threadIds ) { ThreadInfo info = threadBean . getThreadInfo ( tid , STACK_DEPTH ) ; if ( info == null ) { stream . println ( STR_ ) ; continue ; } stream . println ( STR_ + getTaskName ( info . getThreadId ( ) , info . getThreadName ( ) ) + STR_ ) ; Thread . State state = info . getThreadState ( ) ; stream . println ( STR_ + state ) ; stream . println ( STR_ + info . getBlockedCount ( ) ) ; stream . println ( STR_ + info . getWaitedCount ( ) ) ; if ( contention ) { stream . println ( STR_ + info . getBlockedTime ( ) ) ; stream . println ( STR_ + info . getWaitedTime ( ) ) ; } if ( state == Thread . State . WAITING ) { stream . println ( STR_ + info . getLockName ( ) ) ; } else if ( state == Thread . State . BLOCKED ) { stream . println ( STR_ + info . getLockName ( ) ) ; stream . println ( STR_ + getTaskName ( info . getLockOwnerId ( ) , info . getLockOwnerName ( ) ) ) ; } stream . println ( STR_ ) ; for ( StackTraceElement frame : info . getStackTrace ( ) ) { stream . println ( STR_ + frame . toString ( ) ) ; } } stream . flush ( ) ; }
public void addDelete ( IResource delete ) { if ( fDelete == null ) fDelete = new ArrayList < IResource > ( NUM_ ) ; fDelete . add ( delete ) ; if ( fIgnoreCount == NUM_ ) { internalAdd ( new DeleteDescription ( delete ) ) ; } }
public static double max ( final double a , final double b ) { if ( a > b ) { return a ; } if ( a < b ) { return b ; } if ( a != b ) { return Double . NaN ; } long bits = Double . doubleToRawLongBits ( a ) ; if ( bits == x8000000000000000L ) { return b ; } return a ; }
public void addContainer ( ImageContainer container ) { mContainers . add ( container ) ; }
@ Override public void writeExternal ( ObjectOutput out ) throws IOException { super . writeExternal ( out ) ; out . writeObject ( approximation ) ; }
public void add ( String methodName , List < Expression > parameters ) { chain . add ( new DotExpressionItem ( methodName , parameters , BOOL_ ) ) ; }
public static Request request ( ) { return threadLocal . get ( ) ; }
public static String createHash ( String password ) throws NoSuchAlgorithmException , InvalidKeySpecException { return createHash ( password . toCharArray ( ) ) ; }
private void scheduleCommercial ( int length ) { Long delay = commercialDelay . getSettingValue ( ) ; if ( delay == null ) { setCommercialResult ( STR_ ) ; clearCommercialButtonsSelection ( ) ; } else { scheduledCommercialTime = System . currentTimeMillis ( ) + delay . NUM_ ; scheduledCommercialLength = length ; update ( ) ; } }
public int hashCode ( ) { long bits = Double . doubleToLongBits ( m00 ) ; bits = bits . NUM_ + Double . doubleToLongBits ( m01 ) ; bits = bits . NUM_ + Double . doubleToLongBits ( m02 ) ; bits = bits . NUM_ + Double . doubleToLongBits ( m10 ) ; bits = bits . NUM_ + Double . doubleToLongBits ( m11 ) ; bits = bits . NUM_ + Double . doubleToLongBits ( m12 ) ; return ( ( ( int ) bits ) ^ ( ( int ) ( bits > > NUM_ ) ) ) ; }
public void unsubscribe ( AWSIotMessage message ) throws AWSIotException { try { unsubscribeTopic ( message ) ; } catch ( AwsIotRetryableException e ) { if ( client . getMaxOfflineQueueSize ( ) > NUM_ && unsubscribeQueue . size ( ) < client . getMaxOfflineQueueSize ( ) ) { unsubscribeQueue . add ( message ) ; } else { LOGGER . info ( STR_ + message . getTopic ( ) ) ; throw new AWSIotException ( e ) ; } } }
public static boolean isDigitalUnix ( ) { return osName . indexOf ( STR_ ) > - NUM_ ; }
public void clientDisconnect ( ) { try { OutHttpApp responseStream = _responseStream ; if ( responseStream != null ) { responseStream . close ( ) ; } } catch ( Exception e ) { log . log ( Level . FINER , e . toString ( ) , e ) ; } ConnectionTcp conn = connTcp ( ) ; if ( conn != null ) { conn . clientDisconnect ( ) ; } killKeepalive ( STR_ ) ; }
public boolean endsWith ( Name n ) { if ( n instanceof CompoundName ) { return ( impl . endsWith ( n . size ( ) , n . getAll ( ) ) ) ; } else { return BOOL_ ; } }
private int calculateTotalHeight ( float starSize , int numberOfStars , float starsSeparation , boolean padding ) { return Math . round ( starSize ) + ( padding ? getPaddingTop ( ) + getPaddingBottom ( ) : NUM_ ) ; }
@ SuppressWarnings ( STR_ ) private static boolean isRegex ( String s ) { try { Pattern . compile ( s ) ; } catch ( PatternSyntaxException e ) { return BOOL_ ; } return BOOL_ ; }
private static boolean hasSpecializedHandlerIntents ( Context context , Intent intent ) { try { PackageManager pm = context . getPackageManager ( ) ; List < ResolveInfo > handlers = pm . queryIntentActivities ( intent , PackageManager . GET_RESOLVED_FILTER ) ; if ( handlers == null || handlers . size ( ) == NUM_ ) { return BOOL_ ; } for ( ResolveInfo resolveInfo : handlers ) { IntentFilter filter = resolveInfo . filter ; if ( filter == null ) continue ; if ( filter . countDataAuthorities ( ) == NUM_ || filter . countDataPaths ( ) == NUM_ ) continue ; if ( resolveInfo . activityInfo == null ) continue ; return BOOL_ ; } } catch ( RuntimeException e ) { Log . e ( TAG , STR_ ) ; } return BOOL_ ; }
public static void flush ( ) { clearBuffer ( ) ; try { out . flush ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
private String attachFooterToText ( String content ) throws MessagingException , IOException { StringBuilder builder = new StringBuilder ( content ) ; ensureTrailingCarriageReturn ( content , builder ) ; builder . append ( getFooterText ( ) ) ; return builder . toString ( ) ; }
public static Sentence make ( final Connective connective , final Sentence ... children2 ) { return make ( connective , Arrays . asList ( children2 ) ) ; }
public final void testIsStatePreserved1 ( ) { byte [ ] encodedKey = new byte [ ] { ( byte ) NUM_ , ( byte ) NUM_ , ( byte ) NUM_ , ( byte ) NUM_ } ; EncodedKeySpec meks = new MyEncodedKeySpec ( encodedKey ) ; encodedKey [ NUM_ ] = ( byte ) NUM_ ; byte [ ] ek = meks . getEncoded ( ) ; assertTrue ( ek [ NUM_ ] == ( byte ) NUM_ ) ; }
public synchronized void init ( ) { init = BOOL_ ; for ( String mapName : store . getMapNames ( ) ) { if ( mapName . startsWith ( STR_ ) ) { MVMap < Object , Integer > temp = openTempMap ( mapName ) ; store . removeMap ( temp ) ; } } synchronized ( undoLog ) { if ( undoLog . size ( ) > NUM_ ) { for ( Long key : undoLog . keySet ( ) ) { int transactionId = getTransactionId ( key ) ; openTransactions . set ( transactionId ) ; } } } }
public static TDoubleDoubleHashMap createCumulativeHistogram ( TDoubleDoubleHashMap histogram ) { double [ ] keys = histogram . keys ( ) ; Arrays . sort ( keys ) ; double sum = NUM_ ; for ( double key : keys ) { double val = histogram . get ( key ) ; sum += val ; histogram . put ( key , sum ) ; } return histogram ; }
public synchronized void updateIconsForPkg ( String packageName , UserHandleCompat user ) { removeIconsForPkg ( packageName , user ) ; try { PackageInfo info = mPackageManager . getPackageInfo ( packageName , PackageManager . GET_UNINSTALLED_PACKAGES ) ; long userSerial = mUserManager . getSerialNumberForUser ( user ) ; for ( LauncherActivityInfoCompat app : mLauncherApps . getActivityList ( packageName , user ) ) { addIconToDBAndMemCache ( app , info , userSerial ) ; } } catch ( NameNotFoundException e ) { Log . d ( TAG , STR_ , e ) ; return ; } }
protected DateTimeData parse ( String str ) throws SchemaDateTimeException { DateTimeData date = new DateTimeData ( str , this ) ; int len = str . length ( ) ; int end = indexOf ( str , NUM_ , len , STR_ ) ; int dateEnd = getDate ( str , NUM_ , end , date ) ; getTime ( str , end + NUM_ , len , date ) ; if ( dateEnd != end ) { throw new RuntimeException ( str + STR_ + STR_ ) ; } validateDateTime ( date ) ; saveUnnormalized ( date ) ; if ( date . utc != NUM_ && date . utc != STR_ ) { normalize ( date ) ; } return date ; }
void addAttributeValues ( String attrName , Set values ) throws SMSException { if ( attrName != null && values != null && ! values . isEmpty ( ) ) { Map attrs = getAttributes ( ) ; Set origValues = ( Set ) attrs . get ( attrName ) ; Set newValues = new HashSet ( values ) ; if ( origValues != null && ! origValues . isEmpty ( ) ) { newValues . addAll ( origValues ) ; } Map newAttrs = new HashMap ( ) ; newAttrs . put ( attrName , newValues ) ; setAttributes ( newAttrs ) ; } }
public void test_parkUntil_3 ( ) throws Exception { CyclicBarrier barrier = new CyclicBarrier ( NUM_ ) ; Parker parker = new Parker ( barrier , BOOL_ , NUM_ ) ; Thread parkerThread = new Thread ( parker ) ; UNSAFE . unpark ( parkerThread ) ; parkerThread . start ( ) ; parker . assertDurationIsInRange ( NUM_ ) ; parkerThread . join ( ) ; }
SegmentManager commitIndex ( long commitIndex ) { this . commitIndex = Math . max ( this . commitIndex , commitIndex ) ; return this ; }
public void finishFragments ( ) { for ( Fragment comment : closingFragments ) { finishFragment ( comment ) ; } closingFragments . clear ( ) ; }
private final void _writeUTF8Segments ( byte [ ] utf8 , int offset , int totalLen ) throws IOException , JsonGenerationException { do { int len = Math . min ( _outputMaxContiguous , totalLen ) ; _writeUTF8Segment ( utf8 , offset , len ) ; offset += len ; totalLen -= len ; } while ( totalLen > NUM_ ) ; }
public static String hexToStringNoException ( final String data ) { try { return ConversionUtils . arrayToString ( Hex . decodeHex ( data . toCharArray ( ) ) ) ; } catch ( DecoderException e ) { return STR_ ; } }
public Collection < Node > matchingScenariosAndExamples ( final Feature feature ) { final List < ScenarioDefinition > allScenarios = feature . getScenarioDefinitions ( ) ; final List < Node > matchingScenariosAndExamples = new LinkedList < Node > ( ) ; for ( final ScenarioDefinition scenario : allScenarios ) { final Set < Tag > allTagsForScenario = new HashSet < Tag > ( scenario . getTags ( ) ) ; allTagsForScenario . addAll ( feature . getTags ( ) ) ; if ( scenario instanceof ScenarioOutline ) { matchingScenariosAndExamples . addAll ( matchingExamples ( ( ScenarioOutline ) scenario , allTagsForScenario ) ) ; } else { if ( matches ( allTagsForScenario ) ) { matchingScenariosAndExamples . add ( scenario ) ; } } } return matchingScenariosAndExamples ; }
public static String rate2speed ( double rate ) { return NUMBER_FORMAT0 . format ( rate ) + STR_ + GENERAL_UNIT_KBPSEC ; }
public long next ( ) { long result = - NUM_ ; if ( cache < NUM_ && bufferElements > NUM_ ) { result = getNextFromBuffer ( ) ; bufferElements -- ; } else { result = cache ; cache = - NUM_ ; } if ( ! cs . isEmpty ( ) ) { long first = cs . first ( ) ; if ( result > first || result == - NUM_ ) { cs . remove ( first ) ; cache = result ; result = first ; } } if ( result == - NUM_ ) { throw new NoSuchElementException ( ) ; } Assert . check ( previous < result , EC . GENERAL ) ; previous = result ; readElements ++ ; return result ; }
public boolean isSetQueueSize ( ) { return __isset_bit_vector . get ( __QUEUESIZE_ISSET_ID ) ; }
public void requestContactCapabilities ( Set < ContactId > contacts ) throws RcsServiceNotRegisteredException , RcsServiceNotAvailableException , RcsGenericException { if ( mApi == null ) { throw new RcsServiceNotAvailableException ( ) ; } if ( contacts == null || contacts . isEmpty ( ) ) { throw new RcsIllegalArgumentException ( STR_ ) ; } try { mApi . requestContactCapabilities2 ( new ArrayList < > ( contacts ) ) ; } catch ( Exception e ) { RcsIllegalArgumentException . assertException ( e ) ; RcsServiceNotRegisteredException . assertException ( e ) ; throw new RcsGenericException ( e ) ; } }
private static String toString ( double coeff ) { final String c = Double . toString ( coeff ) ; if ( c . endsWith ( STR_ ) ) { return c . substring ( NUM_ , c . length ( ) - NUM_ ) ; } else { return c ; } }
public static final IndexCreatedEvent createTestIndexCreationStatusWithBulkDataHit ( ) { IndexCreatedEvent toReturn = new IndexCreatedEvent ( UUID . randomUUID ( ) , new Date ( ) , new Date ( ) , createTestIndexWithBulkDataHit ( ) , NUM_ , NUM_ ) ; toReturn . calculateValues ( ) ; return toReturn ; }
public boolean validate ( String value , String rule ) { return ( value . equalsIgnoreCase ( rule ) ) ; }
public String findURIFromDoc ( int owner ) { int n = m_sourceTree . size ( ) ; for ( int i = NUM_ ; i < n ; i ++ ) { SourceTree sTree = ( SourceTree ) m_sourceTree . elementAt ( i ) ; if ( owner == sTree . m_root ) return sTree . m_url ; } return null ; }
static public final int random ( int start , int end ) { return start + random . nextInt ( end - start + NUM_ ) ; }
private void pop ( final String desc ) { char c = desc . charAt ( NUM_ ) ; if ( c == STR_ ) { pop ( ( Type . getArgumentsAndReturnSizes ( desc ) > > NUM_ ) - NUM_ ) ; } else if ( c == STR_ || c == STR_ ) { pop ( NUM_ ) ; } else { pop ( NUM_ ) ; } }
public boolean offer ( E event , int taskId ) throws InterruptedException { assertNotDone ( ) ; if ( predicate . match ( event ) ) { this . matched [ taskId ] = BOOL_ ; for ( boolean match : matched ) { if ( ! match ) return BOOL_ ; } responseQueue . put ( new EventHolder ( event ) ) ; done = BOOL_ ; return BOOL_ ; } else return BOOL_ ; }
private void push ( final int type ) { if ( outputStack == null ) { outputStack = new int [ NUM_ ] ; } int n = outputStack . length ; if ( outputStackTop >= n ) { int [ ] t = new int [ Math . max ( outputStackTop + NUM_ , NUM_ . n ) ] ; System . arraycopy ( outputStack , NUM_ , t , NUM_ , n ) ; outputStack = t ; } outputStack [ outputStackTop ++ ] = type ; int top = owner . inputStackTop + outputStackTop ; if ( top > owner . outputStackMax ) { owner . outputStackMax = top ; } }
private static AlgorithmParameterSpec algorithmParameterSpec ( ) { final SecureRandom random = new SecureRandom ( ) ; final byte [ ] bytes = new byte [ CcAes . BLOCK ] ; random . nextBytes ( bytes ) ; return new IvParameterSpec ( bytes ) ; }
static ZoneOffsetTransitionRule readExternal ( DataInput in ) throws IOException { int data = in . readInt ( ) ; Month month = Month . of ( data > > > NUM_ ) ; int dom = ( ( data & ( NUM_ << NUM_ ) ) > > > NUM_ ) - NUM_ ; int dowByte = ( data & ( NUM_ << NUM_ ) ) > > > NUM_ ; DayOfWeek dow = dowByte == NUM_ ? null : DayOfWeek . of ( dowByte ) ; int timeByte = ( data & ( NUM_ << NUM_ ) ) > > > NUM_ ; TimeDefinition defn = TimeDefinition . values ( ) [ ( data & ( NUM_ << NUM_ ) ) > > > NUM_ ] ; int stdByte = ( data & ( NUM_ << NUM_ ) ) > > > NUM_ ; int beforeByte = ( data & ( NUM_ << NUM_ ) ) > > > NUM_ ; int afterByte = ( data & NUM_ ) ; LocalTime time = ( timeByte == NUM_ ? LocalTime . ofSecondOfDay ( in . readInt ( ) ) : LocalTime . of ( timeByte % NUM_ , NUM_ ) ) ; ZoneOffset std = ( stdByte == NUM_ ? ZoneOffset . ofTotalSeconds ( in . readInt ( ) ) : ZoneOffset . ofTotalSeconds ( ( stdByte - NUM_ ) . NUM_ ) ) ; ZoneOffset before = ( beforeByte == NUM_ ? ZoneOffset . ofTotalSeconds ( in . readInt ( ) ) : ZoneOffset . ofTotalSeconds ( std . getTotalSeconds ( ) + beforeByte . NUM_ ) ) ; ZoneOffset after = ( afterByte == NUM_ ? ZoneOffset . ofTotalSeconds ( in . readInt ( ) ) : ZoneOffset . ofTotalSeconds ( std . getTotalSeconds ( ) + afterByte . NUM_ ) ) ; return ZoneOffsetTransitionRule . of ( month , dom , dow , time , timeByte == NUM_ , defn , std , before , after ) ; }
protected boolean isTokenChar ( char ch ) { if ( Character . isLetterOrDigit ( ch ) ) return BOOL_ ; if ( Character . isISOControl ( ch ) ) return BOOL_ ; if ( isHttpSeparator ( ch ) ) return BOOL_ ; return BOOL_ ; }
public void drawLinesAndPoints ( Graphics2D g2d , ArrayList < ComparableLabel > orderedDateSet , HashMap < ComparableLabel , Integer > dataPoints , long yMaxMark ) { int sectionWidth = this . graphWidth / orderedDateSet . size ( ) ; int xOffset = sectionWidth / NUM_ ; int yPrevValue ; int yCurrentValue ; float prevOffsetPerc ; float currentOffsetPerc ; g2d . setColor ( this . lineColor ) ; for ( int i = NUM_ ; i < orderedDateSet . size ( ) ; i ++ ) { if ( i != NUM_ ) { yPrevValue = dataPoints . get ( orderedDateSet . get ( i - NUM_ ) ) ; yCurrentValue = dataPoints . get ( orderedDateSet . get ( i ) ) ; prevOffsetPerc = yPrevValue / ( float ) yMaxMark ; currentOffsetPerc = yCurrentValue / ( float ) yMaxMark ; g2d . drawLine ( this . graphLeft + ( i - NUM_ ) . sectionWidth + xOffset , this . graphBottom - Math . round ( prevOffsetPerc . this . graphHeight ) , this . graphLeft + i . sectionWidth + xOffset , Math . round ( this . graphBottom - currentOffsetPerc . this . graphHeight ) ) ; } else { yCurrentValue = dataPoints . get ( orderedDateSet . get ( i ) ) ; currentOffsetPerc = yCurrentValue / ( float ) yMaxMark ; g2d . fillOval ( this . graphLeft + ( i ) . sectionWidth + xOffset - this . pointRadius , this . graphBottom - Math . round ( currentOffsetPerc . this . graphHeight ) - this . pointRadius , this . pointRadius . NUM_ , this . pointRadius . NUM_ ) ; } } }
@ SuppressLint ( STR_ ) public void elementType ( String name , int model , int memberOf , int flags ) { ElementType e = new ElementType ( name , model , memberOf , flags , this ) ; theElementTypes . put ( name . toLowerCase ( ) , e ) ; if ( memberOf == M_ROOT ) theRoot = e ; }
public static String makeLogTag ( Class cls ) { return makeLogTag ( cls . getSimpleName ( ) ) ; }
final public void println ( String s ) { Writer out = this . out ; if ( out == null ) return ; try { if ( s == null ) out . write ( _nullChars , NUM_ , _nullChars . length ) ; else out . write ( s , NUM_ , s . length ( ) ) ; out . write ( _newline , NUM_ , _newline . length ) ; } catch ( IOException e ) { log . log ( Level . FINE , e . toString ( ) , e ) ; } }
private static URI refragUri ( URI uri , String frag ) throws URISyntaxException { return new URI ( uri . getScheme ( ) , uri . getSchemeSpecificPart ( ) , frag ) ; }
@ Override public void paint ( final PPaintContext ppc ) { final Paint paint = getPaint ( ) ; if ( paint != null ) { final Graphics2D g2 = ppc . getGraphics ( ) ; final PBounds bounds = getUnionOfChildrenBounds ( null ) ; if ( fillBackground ) { g2 . setPaint ( backgroundColor ) ; g2 . fillRect ( ( int ) bounds . getX ( ) - outlinePadding , ( int ) bounds . getY ( ) - outlinePadding , ( int ) bounds . getWidth ( ) + NUM_ . outlinePadding , ( int ) bounds . getHeight ( ) + NUM_ . outlinePadding ) ; } if ( drawOutline ) { g2 . setPaint ( lineColor ) ; g2 . drawRoundRect ( ( int ) bounds . getX ( ) - outlinePadding , ( int ) bounds . getY ( ) - outlinePadding , ( int ) bounds . getWidth ( ) + NUM_ . outlinePadding , ( int ) bounds . getHeight ( ) + NUM_ . outlinePadding , ROUNDING_WIDTH_HEIGHT , ROUNDING_WIDTH_HEIGHT ) ; } } }
public final synchronized byte [ ] toByteArray ( ) { ByteArrayOutputStream baos = null ; DataOutputStream dos = null ; try { baos = new ByteArrayOutputStream ( NUM_ ) ; dos = new DataOutputStream ( baos ) ; game . writeToStream ( dos ) ; dos . flush ( ) ; return baos . toByteArray ( ) ; } catch ( IOException e ) { return null ; } finally { if ( dos != null ) try { dos . close ( ) ; } catch ( IOException ex ) { } if ( baos != null ) try { baos . close ( ) ; } catch ( IOException ex ) { } } }
public void addImport ( @ NotNull PsiElement importable , @ NotNull PsiFile file , @ Nullable PyImportElement importElement ) { myImports . add ( new ImportCandidateHolder ( importable , file , importElement , null ) ) ; }
protected final void drawArrowHead ( Graphics2D g , int x , int y , int sgn ) { g . setStroke ( Strokes . getStroke ( StrokeType . SOLID , NUM_ ) ) ; int size = diagram ( ) . arrowSize ; switch ( headType ) { case CLOSED : Polygon p = new Polygon ( new int [ ] { x , x + sgn . size , x + sgn . size , x } , new int [ ] { y , y - size , y + size , y } , NUM_ ) ; g . fillPolygon ( p ) ; break ; case OPEN : g . drawLine ( x , y , x + sgn . size , y - size ) ; g . drawLine ( x , y , x + sgn . size , y + size ) ; break ; case ROUNDED : int left = sgn == - NUM_ ? x - NUM_ . size : x ; int top = y - size ; g . fillArc ( left , top , size . NUM_ , size . NUM_ , NUM_ , sgn . NUM_ ) ; } }
public void classLoaderInit ( DynamicClassLoader loader ) { EnvLoaderListener listener = _listenerRef . get ( ) ; if ( listener != null ) listener . classLoaderInit ( loader ) ; }
private Object [ ] unmarshalParametersChecked ( DeserializationChecker checker , Method method , MarshalInputStream in ) throws IOException , ClassNotFoundException { int callID = methodCallIDCount . getAndIncrement ( ) ; MyChecker myChecker = new MyChecker ( checker , method , callID ) ; in . setStreamChecker ( myChecker ) ; try { Class < ? > [ ] types = method . getParameterTypes ( ) ; Object [ ] values = new Object [ types . length ] ; for ( int i = NUM_ ; i < types . length ; i ++ ) { myChecker . setIndex ( i ) ; values [ i ] = unmarshalValue ( types [ i ] , in ) ; } myChecker . end ( callID ) ; return values ; } finally { in . setStreamChecker ( null ) ; } }
private void loadDataFromService ( ) { List < ExceptionSensorData > exData = null ; if ( ( null != fromDate ) && ( null != toDate ) ) { exData = dataAccessService . getUngroupedExceptionOverview ( template , limit , fromDate , toDate , resultComparator ) ; } else { exData = dataAccessService . getUngroupedExceptionOverview ( template , limit , resultComparator ) ; } exceptionSensorData . clear ( ) ; if ( null != exData ) { exceptionSensorData . addAll ( exData ) ; } }
public static String createResourceName ( String resource , Locale locale , boolean removeExtension ) { String resourceName = resource ; if ( removeExtension ) { if ( resourceName . endsWith ( STR_ ) ) { resourceName = resourceName . replace ( STR_ , STR_ ) ; } else if ( resourceName . endsWith ( STR_ ) ) { resourceName = resourceName . replace ( STR_ , STR_ ) ; } } if ( locale != null ) { if ( UtilValidate . isNotEmpty ( locale . toString ( ) ) ) { resourceName = resourceName + STR_ + locale ; } } return resourceName ; }
public static String toString ( Object [ ] objects , Displayable renderer ) { if ( objects == null ) return STR_ ; StringBuffer buffer = new StringBuffer ( NUM_ ) ; for ( int i = NUM_ ; i < objects . length ; i ++ ) { if ( i > NUM_ ) buffer . append ( STR_ ) ; buffer . append ( renderer . displayString ( objects [ i ] ) ) ; } return buffer . toString ( ) ; }
void drawIcon ( Graphics g , int ax , int ay , int aw , int ah , float align , Component c ) { int gap = isLeftToRight ? - ( img . getIconWidth ( ) + bulletgap ) : ( aw + bulletgap ) ; int x = ax + gap ; int y = Math . max ( ay , ay + ( int ) ( align . ah ) - img . getIconHeight ( ) ) ; img . paintIcon ( c , g , x , y ) ; }
public int syncQuery ( String query ) { long start = System . currentTimeMillis ( ) ; int modified = execute ( STR_ , UPDATE_COUNT_RESPONSE , query ) ; log . debug ( STR_ , System . currentTimeMillis ( ) - start , modified ) ; return modified ; }
public static void fullReset ( ) { resetRuntime ( ) ; synchronized ( readProperties ) { readProperties . clear ( ) ; } }
private BufferedImage toBufferedImage ( final Image image ) { if ( image instanceof BufferedImage ) { return ( BufferedImage ) image ; } if ( image instanceof VolatileImage ) { VolatileImage volatileImage = ( VolatileImage ) image ; return volatileImage . getSnapshot ( ) ; } GraphicsEnvironment graphicsEnvironment = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; GraphicsDevice graphicsDevice = graphicsEnvironment . getDefaultScreenDevice ( ) ; GraphicsConfiguration graphicsConfiguration = graphicsDevice . getDefaultConfiguration ( ) ; BufferedImage bufferedImage = graphicsConfiguration . createCompatibleImage ( image . getWidth ( null ) , image . getHeight ( null ) ) ; Graphics2D g = bufferedImage . createGraphics ( ) ; g . drawImage ( image , NUM_ , NUM_ , null ) ; g . dispose ( ) ; return bufferedImage ; }
public static void writeByteArrayToFile ( File file , byte [ ] data , boolean append ) throws IOException { OutputStream out = null ; try { out = openOutputStream ( file , append ) ; out . write ( data ) ; out . close ( ) ; } finally { IOUtils . closeQuietly ( out ) ; } }
public final boolean isCancelled ( ) { if ( cancelled ) { pass ( STR_ , cancelled ) ; } else { fail ( STR_ ) ; } return cancelled ; }
public void remove ( DirectedEdge de ) { outEdges . remove ( de ) ; }
@ Override public boolean eventGeneratable ( String eventName ) { if ( m_listenee == null ) { return BOOL_ ; } if ( ! eventName . equals ( STR_ ) && ! eventName . equals ( STR_ ) ) { return BOOL_ ; } if ( m_listenee instanceof DataSource ) { if ( m_listenee instanceof EventConstraints ) { EventConstraints ec = ( EventConstraints ) m_listenee ; return ec . eventGeneratable ( eventName ) ; } } if ( m_listenee instanceof TrainingSetProducer ) { if ( m_listenee instanceof EventConstraints ) { EventConstraints ec = ( EventConstraints ) m_listenee ; if ( ! eventName . equals ( STR_ ) ) { return BOOL_ ; } if ( ! ec . eventGeneratable ( STR_ ) ) { return BOOL_ ; } } } if ( m_listenee instanceof TestSetProducer ) { if ( m_listenee instanceof EventConstraints ) { EventConstraints ec = ( EventConstraints ) m_listenee ; if ( ! eventName . equals ( STR_ ) ) { return BOOL_ ; } if ( ! ec . eventGeneratable ( STR_ ) ) { return BOOL_ ; } } } return BOOL_ ; }
@ Override protected void onMessageOnProducerThread ( T msg ) { _lock . lock ( ) ; try { if ( _pending . isEmpty ( ) ) { _queue . schedule ( _flushRunnable , _interval , _timeUnit ) ; } _pending . add ( msg ) ; } finally { _lock . unlock ( ) ; } }
public Builder untilDate ( Date date ) { untilDate = QUERY_DATE . format ( date ) ; return this ; }
private boolean isInThumbRange ( float touchX , double normalizedThumbValue ) { return Math . abs ( touchX - normalizedToScreen ( normalizedThumbValue ) ) <= mThumbHalfWidth ; }
public static void cleanupAllFiles ( FileSystem fileSystem , String BaseUri ) throws IOException { try { if ( fileSystem != null ) { Path rootDir = new Path ( BaseUri ) ; FileStatus [ ] files = fileSystem . listStatus ( rootDir ) ; for ( FileStatus file : files ) { fileSystem . delete ( file . getPath ( ) , BOOL_ ) ; } } } catch ( Exception e ) { LOG . error ( STR_ ) ; } }
@ Override public boolean canBeCollidedWith ( ) { return BOOL_ ; }
public void update ( long duration , TimeUnit unit ) { update ( unit . toNanos ( duration ) ) ; }
public FileInputStream openRead ( ) throws FileNotFoundException { if ( mBackupName . exists ( ) ) { mBaseName . delete ( ) ; mBackupName . renameTo ( mBaseName ) ; } return new FileInputStream ( mBaseName ) ; }
public void submit ( String queueName , DispatcherTask dispatcherTask ) { synchronized ( syncRoot ) { DispatcherTaskRunner currentTaskRunner = currentTasksMap . get ( queueName ) ; if ( currentTaskRunner == null ) { currentTaskRunner = new DispatcherTaskRunner ( queueName , dispatcherTask ) ; currentTasksMap . put ( queueName , currentTaskRunner ) ; executorService . execute ( currentTaskRunner ) ; } else { enqueueNextTask ( queueName , dispatcherTask ) ; } } }
public static Executor createTaskDistributor ( ) { return Executors . newCachedThreadPool ( createThreadFactory ( Thread . NORM_PRIORITY , STR_ ) ) ; }
public void dump ( Writer writer ) { PrintWriter pw = new PrintWriter ( new BufferedWriter ( writer ) ) ; pw . println ( STR_ ) ; pw . println ( STR_ ) ; pw . println ( STR_ + ( int ) audioFormat . getSampleRate ( ) ) ; pw . println ( STR_ + samples . length / NUM_ ) ; pw . println ( STR_ + audioFormat . getChannels ( ) ) ; if ( samples != null ) { for ( int i = NUM_ ; i < samples . length ; i += NUM_ ) { pw . println ( WaveUtils . bytesToShort ( samples [ i ] , samples [ i + NUM_ ] ) ) ; } } pw . flush ( ) ; }
public void addFieldBuffered ( VEditor editor , GridField mField ) { wrap = mField != null ? ! mField . isSameLine ( ) : BOOL_ ; if ( prevEditor != null && prevField != null ) addField ( prevEditor , prevField ) ; prevEditor = editor ; prevField = mField ; }
public ExpandRoomFreespaceIncomplete add_incomplete_expansion_room ( ShapeTile p_shape , int p_layer , ShapeTile p_contained_shape ) { ExpandRoomFreespaceIncomplete new_room = new ExpandRoomFreespaceIncomplete ( p_shape , p_layer , p_contained_shape ) ; incomplete_expansion_rooms . add ( new_room ) ; return new_room ; }
static double computeDesiredEllipsoidMagnitude ( final PlanetModel planetModel , final double x , final double y , final double z ) { return NUM_ / Math . sqrt ( x . x . planetModel . inverseAbSquared + y . y . planetModel . inverseAbSquared + z . z . planetModel . inverseCSquared ) ; }
public static String trim ( CharSequence s ) { if ( s == null ) { return null ; } Matcher m = sTrimPattern . matcher ( s ) ; return m . replaceAll ( STR_ ) ; }
private void validateVNXFileSMISProviderMandatoryDetails ( StorageSystemRequestParam param ) { ArgValidator . checkFieldValidIP ( param . getSmisProviderIP ( ) , STR_ ) ; ArgValidator . checkFieldNotNull ( param . getSmisPortNumber ( ) , STR_ ) ; ArgValidator . checkFieldRange ( param . getSmisPortNumber ( ) , NUM_ , NUM_ , STR_ ) ; ArgValidator . checkFieldNotEmpty ( param . getSmisUserName ( ) , STR_ ) ; ArgValidator . checkFieldNotEmpty ( param . getSmisPassword ( ) , STR_ ) ; }
private static NSObject parseObject ( Node n ) throws ParseException , IOException { String type = n . getNodeName ( ) ; if ( type . equals ( STR_ ) ) { NSDictionary dict = new NSDictionary ( ) ; List < Node > children = filterElementNodes ( n . getChildNodes ( ) ) ; for ( int i = NUM_ ; i < children . size ( ) ; i += NUM_ ) { Node key = children . get ( i ) ; Node val = children . get ( i + NUM_ ) ; String keyString = getNodeTextContents ( key ) ; dict . put ( keyString , parseObject ( val ) ) ; } return dict ; } else if ( type . equals ( STR_ ) ) { List < Node > children = filterElementNodes ( n . getChildNodes ( ) ) ; NSArray array = new NSArray ( children . size ( ) ) ; for ( int i = NUM_ ; i < children . size ( ) ; i ++ ) { array . setValue ( i , parseObject ( children . get ( i ) ) ) ; } return array ; } else if ( type . equals ( STR_ ) ) { return new NSNumber ( BOOL_ ) ; } else if ( type . equals ( STR_ ) ) { return new NSNumber ( BOOL_ ) ; } else if ( type . equals ( STR_ ) ) { return new NSNumber ( getNodeTextContents ( n ) ) ; } else if ( type . equals ( STR_ ) ) { return new NSNumber ( getNodeTextContents ( n ) ) ; } else if ( type . equals ( STR_ ) ) { return new NSString ( getNodeTextContents ( n ) ) ; } else if ( type . equals ( STR_ ) ) { return new NSData ( getNodeTextContents ( n ) ) ; } else if ( type . equals ( STR_ ) ) { return new NSDate ( getNodeTextContents ( n ) ) ; } return null ; }
public void createAccrualBasedJournalEntriesAndReversalsForLoanCharges ( final Office office , final String currencyCode , final Integer accountTypeToBeDebited , final Integer accountTypeToBeCredited , final Long loanProductId , final Long loanId , final String transactionId , final Date transactionDate , final BigDecimal totalAmount , final Boolean isReversal , final List < ChargePaymentDTO > chargePaymentDTOs ) { GLAccount receivableAccount = getLinkedGLAccountForLoanCharges ( loanProductId , accountTypeToBeDebited , null ) ; final Map < GLAccount , BigDecimal > creditDetailsMap = new LinkedHashMap < > ( ) ; for ( final ChargePaymentDTO chargePaymentDTO : chargePaymentDTOs ) { final Long chargeId = chargePaymentDTO . getChargeId ( ) ; final GLAccount chargeSpecificAccount = getLinkedGLAccountForLoanCharges ( loanProductId , accountTypeToBeCredited , chargeId ) ; BigDecimal chargeSpecificAmount = chargePaymentDTO . getAmount ( ) ; if ( creditDetailsMap . containsKey ( chargeSpecificAccount ) ) { final BigDecimal existingAmount = creditDetailsMap . get ( chargeSpecificAccount ) ; chargeSpecificAmount = chargeSpecificAmount . add ( existingAmount ) ; } creditDetailsMap . put ( chargeSpecificAccount , chargeSpecificAmount ) ; } BigDecimal totalCreditedAmount = BigDecimal . ZERO ; for ( final Map . Entry < GLAccount , BigDecimal > entry : creditDetailsMap . entrySet ( ) ) { final GLAccount account = entry . getKey ( ) ; final BigDecimal amount = entry . getValue ( ) ; totalCreditedAmount = totalCreditedAmount . add ( amount ) ; if ( isReversal ) { createDebitJournalEntryForLoan ( office , currencyCode , account , loanId , transactionId , transactionDate , amount ) ; createCreditJournalEntryForLoan ( office , currencyCode , receivableAccount , loanId , transactionId , transactionDate , amount ) ; } else { createDebitJournalEntryForLoan ( office , currencyCode , receivableAccount , loanId , transactionId , transactionDate , amount ) ; createCreditJournalEntryForLoan ( office , currencyCode , account , loanId , transactionId , transactionDate , amount ) ; } } if ( totalAmount . compareTo ( totalCreditedAmount ) != NUM_ ) { throw new PlatformDataIntegrityException ( STR_ , STR_ , totalCreditedAmount , totalAmount ) ; } }
private ArtLocateResult calculate_next_trace ( boolean p_layer_changed , boolean p_at_fanout_end ) { Collection < PlaPointFloat > corner_list = new LinkedList < PlaPointFloat > ( ) ; corner_list . add ( current_from_point ) ; if ( ! p_at_fanout_end ) { PlaPointFloat adjusted_start_corner = adjust_start_corner ( ) ; if ( adjusted_start_corner != current_from_point ) { PlaPointFloat add_corner = calculate_additional_corner ( current_from_point , adjusted_start_corner , BOOL_ , angle_restriction ) ; corner_list . add ( add_corner ) ; corner_list . add ( adjusted_start_corner ) ; previous_from_point = current_from_point ; current_from_point = adjusted_start_corner ; } } PlaPointFloat prev_corner = current_from_point ; for ( int c_limit = NUM_ ; c_limit < NUM_ ; c_limit ++ ) { Collection < PlaPointFloat > next_corners = calculate_next_trace_corners ( ) ; if ( next_corners . isEmpty ( ) ) break ; for ( PlaPointFloat curr_next_corner : next_corners ) { if ( curr_next_corner == prev_corner ) continue ; corner_list . add ( curr_next_corner ) ; previous_from_point = current_from_point ; current_from_point = curr_next_corner ; prev_corner = curr_next_corner ; } } int next_layer = current_trace_layer ; if ( p_layer_changed ) { current_from_door_index = current_target_door_index + NUM_ ; ExpandRoomComplete next_room = backtrack_array [ current_from_door_index ] . next_room ; if ( next_room != null ) { next_layer = next_room . get_layer ( ) ; } } PlaPointIntAlist rounded_corner_list = new PlaPointIntAlist ( corner_list . size ( ) ) ; PlaPointInt prev_point = null ; for ( PlaPointFloat a_float : corner_list ) { PlaPointInt curr_point = a_float . round ( ) ; if ( curr_point . equals ( prev_point ) ) continue ; rounded_corner_list . add ( curr_point ) ; prev_point = curr_point ; } ArtLocateResult result = new ArtLocateResult ( rounded_corner_list , current_trace_layer ) ; current_trace_layer = next_layer ; return result ; }
public static < ValueT > ByteBuffer toByteBuffer ( ValueT obj ) throws IOException { byte [ ] bytes = null ; ByteArrayOutputStream bos = null ; ObjectOutputStream oos = null ; try { bos = new ByteArrayOutputStream ( ) ; oos = new ObjectOutputStream ( bos ) ; oos . writeObject ( obj ) ; oos . flush ( ) ; bytes = bos . toByteArray ( ) ; } finally { if ( oos != null ) { oos . close ( ) ; } if ( bos != null ) { bos . close ( ) ; } } return ByteBuffer . wrap ( bytes ) ; }
void writeBytes ( ChannelHandlerContext ctx , ByteBuf bytes ) ;
@ Override protected Sensor createNewSensor ( String systemName , String userName ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + systemName + STR_ + userName ) ; } Sensor s ; String sName = SerialAddress . normalizeSystemName ( systemName ) ; if ( sName . equals ( STR_ ) ) { log . error ( STR_ + systemName ) ; return null ; } s = getBySystemName ( sName ) ; if ( s != null ) { log . error ( STR_ + systemName ) ; return null ; } String altName = SerialAddress . convertSystemNameToAlternate ( sName ) ; s = getBySystemName ( altName ) ; if ( s != null ) { log . error ( STR_ + systemName + STR_ + altName + STR_ ) ; return null ; } int bit = SerialAddress . getBitFromSystemName ( sName ) ; if ( ( bit <= NUM_ ) || ( bit >= SENSORSPERNODE ) ) { log . error ( STR_ + Integer . toString ( bit ) + STR_ + Integer . toString ( SENSORSPERNODE - NUM_ ) ) ; return null ; } if ( userName == null ) { s = new SerialSensor ( sName ) ; } else { s = new SerialSensor ( sName , userName ) ; } SerialNode node = SerialAddress . getNodeFromSystemName ( sName ) ; if ( node == null ) { log . warn ( STR_ + sName + STR_ ) ; return s ; } node . registerSensor ( s , bit ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + s . getSystemName ( ) + STR_ + node ) ; } return s ; }
private double [ ] max ( double [ ] distances1 , double [ ] distances2 ) { if ( distances1 . length != distances2 . length ) { throw new RuntimeException ( STR_ ) ; } double [ ] result = new double [ distances1 . length ] ; for ( int i = NUM_ ; i < distances1 . length ; i ++ ) { result [ i ] = Math . max ( distances1 [ i ] , distances2 [ i ] ) ; } return result ; }
public void fill_shape ( PlaPointFloat [ ] p_points , Graphics p_g , Color p_color , double p_translucency_factor ) { if ( p_color == null ) return ; Graphics2D g2 = ( Graphics2D ) p_g ; Polygon draw_polygon = new Polygon ( ) ; for ( int index = NUM_ ; index < p_points . length ; index ++ ) { Point2D curr_corner = coordinate_transform . board_to_screen ( p_points [ index ] ) ; draw_polygon . addPoint ( ( int ) Math . round ( curr_corner . getX ( ) ) , ( int ) Math . round ( curr_corner . getY ( ) ) ) ; } g2 . setColor ( p_color ) ; set_translucency ( g2 , p_translucency_factor ) ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2 . fill ( draw_polygon ) ; }
public void writeExif ( InputStream jpegStream , OutputStream exifOutStream ) throws IOException { if ( jpegStream == null || exifOutStream == null ) { throw new IllegalArgumentException ( NULL_ARGUMENT_STRING ) ; } OutputStream s = getExifWriterStream ( exifOutStream ) ; doExifStreamIO ( jpegStream , s ) ; s . flush ( ) ; }
public void goToCurrentDay ( ) { int monthDifference = FlexibleCalendarHelper . getMonthDifference ( displayYear , displayMonth ) ; Calendar cal = Calendar . getInstance ( ) ; selectedDateItem . setDay ( cal . get ( Calendar . DAY_OF_MONTH ) ) ; selectedDateItem . setMonth ( cal . get ( Calendar . MONTH ) ) ; selectedDateItem . setYear ( cal . get ( Calendar . YEAR ) ) ; if ( disableAutoDateSelection ) { this . userSelectedItem = selectedDateItem . clone ( ) ; } if ( monthDifference != NUM_ ) { resetAdapters = BOOL_ ; if ( monthDifference < NUM_ ) { monthInfPagerAdapter . setFakeCount ( lastPosition ) ; monthInfPagerAdapter . notifyDataSetChanged ( ) ; } shouldOverrideComputedDate = BOOL_ ; moveToPosition ( monthDifference ) ; } else { FlexibleCalendarGridAdapter currentlyVisibleAdapter = monthViewPagerAdapter . getMonthAdapterAtPosition ( lastPosition % MonthViewPagerAdapter . VIEWS_IN_PAGER ) ; currentlyVisibleAdapter . notifyDataSetChanged ( ) ; } }
public static byte [ ] toIPv4AddressBytes ( int ipAddress ) { return new byte [ ] { ( byte ) ( ipAddress > > > NUM_ ) , ( byte ) ( ipAddress > > > NUM_ ) , ( byte ) ( ipAddress > > > NUM_ ) , ( byte ) ipAddress } ; }
public boolean isValidTemplate ( ) { return isValidTemplate ( template ) ; }
public Object take ( ) throws InterruptedException , ForceReattemptException { throw new UnsupportedOperationException ( ) ; }
private void destroy ( ) { if ( log . isLoggable ( Level . FINEST ) ) { log . finest ( this + STR_ ) ; } try { _socket . forceShutdown ( ) ; } catch ( Throwable e ) { } try { closeConnection ( ) ; } catch ( Throwable e ) { log . log ( Level . FINER , e . toString ( ) , e ) ; } _port . removeConnection ( this ) ; }
int atom ( ) throws RESyntaxException { int ret = node ( RE . OP_ATOM , NUM_ ) ; int lenAtom = NUM_ ; atomLoop : while ( idx < len ) { if ( ( idx + NUM_ ) < len ) { char c = pattern . charAt ( idx + NUM_ ) ; if ( pattern . charAt ( idx ) == STR_ ) { int idxEscape = idx ; escape ( ) ; if ( idx < len ) { c = pattern . charAt ( idx ) ; } idx = idxEscape ; } switch ( c ) { case STR_ : case STR_ : case STR_ : case STR_ : if ( lenAtom != NUM_ ) { break atomLoop ; } } } switch ( pattern . charAt ( idx ) ) { case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : break atomLoop ; case STR_ : case STR_ : case STR_ : case STR_ : if ( lenAtom == NUM_ ) { syntaxError ( STR_ ) ; } break atomLoop ; case STR_ : { int idxBeforeEscape = idx ; int c = escape ( ) ; if ( ( c & ESC_MASK ) == ESC_MASK ) { idx = idxBeforeEscape ; break atomLoop ; } emit ( ( char ) c ) ; lenAtom ++ ; } break ; default : emit ( pattern . charAt ( idx ++ ) ) ; lenAtom ++ ; break ; } } if ( lenAtom == NUM_ ) { internalError ( ) ; } instruction [ ret + RE . offsetOpdata ] = ( char ) lenAtom ; return ret ; }
@ Override public void drawItem ( Graphics2D g2 , CategoryItemRendererState state , Rectangle2D dataArea , CategoryPlot plot , CategoryAxis domainAxis , ValueAxis rangeAxis , CategoryDataset dataset , int row , int column , int pass ) { int visibleRow = state . getVisibleSeriesIndex ( row ) ; if ( visibleRow < NUM_ ) { return ; } Number dataValue = dataset . getValue ( row , column ) ; if ( dataValue == null ) { return ; } double value = dataValue . doubleValue ( ) ; PlotOrientation orientation = plot . getOrientation ( ) ; double barW0 = calculateBarW0 ( plot , orientation , dataArea , domainAxis , state , visibleRow , column ) ; RectangleEdge edge = plot . getRangeAxisEdge ( ) ; double barL = rangeAxis . valueToJava2D ( value , dataArea , edge ) ; Line2D line ; double x , y ; if ( orientation . isHorizontal ( ) ) { x = barL ; y = barW0 + state . getBarWidth ( ) / NUM_ ; line = new Line2D . Double ( barL , barW0 , barL , barW0 + state . getBarWidth ( ) ) ; } else { x = barW0 + state . getBarWidth ( ) / NUM_ ; y = barL ; line = new Line2D . Double ( barW0 , barL , barW0 + state . getBarWidth ( ) , barL ) ; } if ( state . getElementHinting ( ) ) { beginElementGroup ( g2 , dataset . getRowKey ( row ) , dataset . getColumnKey ( column ) ) ; } Stroke itemStroke = getItemStroke ( row , column ) ; Paint itemPaint = getItemPaint ( row , column ) ; g2 . setStroke ( itemStroke ) ; g2 . setPaint ( itemPaint ) ; g2 . draw ( line ) ; if ( state . getElementHinting ( ) ) { endElementGroup ( g2 ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; if ( generator != null && isItemLabelVisible ( row , column ) ) { drawItemLabel ( g2 , orientation , dataset , row , column , x , y , ( value < NUM_ ) ) ; } int datasetIndex = plot . indexOf ( dataset ) ; updateCrosshairValues ( state . getCrosshairState ( ) , dataset . getRowKey ( row ) , dataset . getColumnKey ( column ) , value , datasetIndex , barW0 , barL , orientation ) ; EntityCollection entities = state . getEntityCollection ( ) ; if ( entities != null ) { addItemEntity ( entities , dataset , row , column , line . getBounds ( ) ) ; } }
public static < T > UnaryOperator < List < T > > from ( Collection < String > commandLineUdids , Function < T , ICloud . MBSBackup > mbsBackup , Function < ICloud . MBSBackup , String > formatter , Printer out , InputStream in ) { return commandLineUdids . isEmpty ( ) ? new User ( mbsBackup , out , in , formatter ) : new Udid ( mbsBackup , out , in , new ArrayList < > ( commandLineUdids ) ) ; }
public boolean isNetworkConnected ( ) { ConnectivityManager connectivityManager = ( ConnectivityManager ) getSystemService ( CONNECTIVITY_SERVICE ) ; NetworkInfo networkInfo = connectivityManager . getActiveNetworkInfo ( ) ; return networkInfo != null && networkInfo . isConnectedOrConnecting ( ) ; }
@ Override public void onTabClosing ( long time , int id ) { reset ( ) ; forceAnimationToFinish ( ) ; TabModel model = mTabModelSelector . getModelForTabId ( id ) ; if ( model != null ) { mClosedTab = createLayoutTab ( id , model . isIncognito ( ) , NO_CLOSE_BUTTON , NO_TITLE ) ; mClosedTab . setBorderAlpha ( NUM_ ) ; mLayoutTabs = new LayoutTab [ ] { mClosedTab } ; updateCacheVisibleIds ( new LinkedList < Integer > ( Arrays . asList ( id ) ) ) ; } else { mLayoutTabs = null ; mClosedTab = null ; } super . onTabClosing ( time , id ) ; }
public void put ( String name , String supported , String authScheme , String level , boolean isDefault ) { SAMLv2AuthContext c = new SAMLv2AuthContext ( ) ; c . name = name ; c . supported = supported ; if ( authScheme . length ( ) != NUM_ && authScheme != null ) { int index = authScheme . lastIndexOf ( STR_ ) ; c . value = authScheme . substring ( index + NUM_ ) ; c . key = authScheme . substring ( NUM_ , index ) ; } else { c . value = STR_ ; c . key = STR_ ; } c . level = level ; c . isDefault = isDefault ; collections . put ( name , c ) ; }
public final void close ( LsServerPacket closePacket , boolean forced ) { synchronized ( guard ) { if ( isWriteDisabled ( ) ) { return ; } log . debug ( STR_ + closePacket + STR_ ) ; pendingClose = BOOL_ ; isForcedClosing = forced ; sendMsgQueue . clear ( ) ; sendMsgQueue . addLast ( closePacket ) ; enableWriteInterest ( ) ; } }
private void replaceCollapsedEdges ( ) { List newEdges = new ArrayList ( ) ; for ( Iterator it = edgeList . iterator ( ) ; it . hasNext ( ) ; ) { Edge e = ( Edge ) it . next ( ) ; if ( e . isCollapsed ( ) ) { it . remove ( ) ; newEdges . add ( e . getCollapsedEdge ( ) ) ; } } edgeList . addAll ( newEdges ) ; }
private int readAnnotationValue ( int v , final char [ ] buf , final String name , final AnnotationVisitor av ) { int i ; if ( av == null ) { switch ( b [ v ] & xFF ) { case STR_ : return v + NUM_ ; case STR_ : return readAnnotationValues ( v + NUM_ , buf , BOOL_ , null ) ; case STR_ : return readAnnotationValues ( v + NUM_ , buf , BOOL_ , null ) ; default : return v + NUM_ ; } } switch ( b [ v ++ ] & xFF ) { case STR_ : case STR_ : case STR_ : case STR_ : av . visit ( name , readConst ( readUnsignedShort ( v ) , buf ) ) ; v += NUM_ ; break ; case STR_ : av . visit ( name , ( byte ) readInt ( items [ readUnsignedShort ( v ) ] ) ) ; v += NUM_ ; break ; case STR_ : av . visit ( name , readInt ( items [ readUnsignedShort ( v ) ] ) == NUM_ ? Boolean . FALSE : Boolean . TRUE ) ; v += NUM_ ; break ; case STR_ : av . visit ( name , ( short ) readInt ( items [ readUnsignedShort ( v ) ] ) ) ; v += NUM_ ; break ; case STR_ : av . visit ( name , ( char ) readInt ( items [ readUnsignedShort ( v ) ] ) ) ; v += NUM_ ; break ; case STR_ : av . visit ( name , readUTF8 ( v , buf ) ) ; v += NUM_ ; break ; case STR_ : av . visitEnum ( name , readUTF8 ( v , buf ) , readUTF8 ( v + NUM_ , buf ) ) ; v += NUM_ ; break ; case STR_ : av . visit ( name , Type . getType ( readUTF8 ( v , buf ) ) ) ; v += NUM_ ; break ; case STR_ : v = readAnnotationValues ( v + NUM_ , buf , BOOL_ , av . visitAnnotation ( name , readUTF8 ( v , buf ) ) ) ; break ; case STR_ : int size = readUnsignedShort ( v ) ; v += NUM_ ; if ( size == NUM_ ) { return readAnnotationValues ( v - NUM_ , buf , BOOL_ , av . visitArray ( name ) ) ; } switch ( this . b [ v ++ ] & xFF ) { case STR_ : byte [ ] bv = new byte [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { bv [ i ] = ( byte ) readInt ( items [ readUnsignedShort ( v ) ] ) ; v += NUM_ ; } av . visit ( name , bv ) ; -- v ; break ; case STR_ : boolean [ ] zv = new boolean [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { zv [ i ] = readInt ( items [ readUnsignedShort ( v ) ] ) != NUM_ ; v += NUM_ ; } av . visit ( name , zv ) ; -- v ; break ; case STR_ : short [ ] sv = new short [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { sv [ i ] = ( short ) readInt ( items [ readUnsignedShort ( v ) ] ) ; v += NUM_ ; } av . visit ( name , sv ) ; -- v ; break ; case STR_ : char [ ] cv = new char [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { cv [ i ] = ( char ) readInt ( items [ readUnsignedShort ( v ) ] ) ; v += NUM_ ; } av . visit ( name , cv ) ; -- v ; break ; case STR_ : int [ ] iv = new int [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { iv [ i ] = readInt ( items [ readUnsignedShort ( v ) ] ) ; v += NUM_ ; } av . visit ( name , iv ) ; -- v ; break ; case STR_ : long [ ] lv = new long [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { lv [ i ] = readLong ( items [ readUnsignedShort ( v ) ] ) ; v += NUM_ ; } av . visit ( name , lv ) ; -- v ; break ; case STR_ : float [ ] fv = new float [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { fv [ i ] = Float . intBitsToFloat ( readInt ( items [ readUnsignedShort ( v ) ] ) ) ; v += NUM_ ; } av . visit ( name , fv ) ; -- v ; break ; case STR_ : double [ ] dv = new double [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { dv [ i ] = Double . longBitsToDouble ( readLong ( items [ readUnsignedShort ( v ) ] ) ) ; v += NUM_ ; } av . visit ( name , dv ) ; -- v ; break ; default : v = readAnnotationValues ( v - NUM_ , buf , BOOL_ , av . visitArray ( name ) ) ; } } return v ; }
public void timingEvent ( float fraction ) { current . x = ( int ) ( start . x + ( end . x - start . x ) . fraction ) ; current . y = ( int ) ( start . y + ( end . y - start . y ) . fraction ) ; track . setCarPosition ( current ) ; }
public SeaGlassTitlePane ( JRootPane rootPane , SeaGlassRootPaneUI ui ) { this . rootPane = rootPane ; this . rootPaneUI = ui ; rootParent = ( RootPaneContainer ) rootPane . getParent ( ) ; installTitlePane ( ) ; }
public String toString ( ) { StringBuilder s = new StringBuilder ( ) ; for ( Item item : this ) s . append ( item + STR_ ) ; return s . toString ( ) ; }
public void writeLong ( long value ) throws IOException { checkWritePrimitiveTypes ( ) ; primitiveTypes . writeLong ( value ) ; }
static public URL findContainerXML ( String _containerName ) { URL _containerNameURL = null ; String _containerNameFilePath = Constants . Container . CONTAINER_CONFIG_DIRECTORY + STR_ + _containerName + STR_ ; _containerNameURL = getResourceURL ( _containerNameFilePath ) ; if ( _containerNameURL != null ) { if ( _logger . isLoggable ( Level . INFO ) ) { _logger . info ( STR_ + _containerNameURL + STR_ ) ; } } return _containerNameURL ; }
public static List < String > expandWildcards ( Iterable < File > dirs , List < String > names , Backend forBackend ) { List < String > result = new ArrayList < String > ( names . size ( ) ) ; for ( String name : names ) { expandWildcard ( result , dirs , name , forBackend ) ; } return result ; }
public static Charset forName ( String charsetName ) { return forName ( charsetName , null ) ; }
public NSNumber ( int i ) { doubleValue = longValue = i ; type = INTEGER ; }
public static void dump ( String message , StackTraceElement [ ] stackTrace ) { dump ( message , Arrays . asList ( stackTrace ) ) ; }
public void execQuery ( String sql , ExecQueryCallbackFunctionIF aListener ) throws GenericEntityException { if ( _connection == null ) { getConnection ( ) ; } try { if ( Debug . verboseOn ( ) ) Debug . logVerbose ( STR_ + sql , module ) ; executeQuery ( sql ) ; boolean keepGoing = BOOL_ ; while ( keepGoing && _rs . next ( ) ) { keepGoing = aListener . processNextRow ( _rs ) ; } if ( _manualTX ) { _connection . commit ( ) ; } } catch ( SQLException sqle ) { Debug . logWarning ( STR_ + sql + STR_ , module ) ; Debug . logWarning ( sqle . getMessage ( ) , module ) ; throw new GenericEntityException ( STR_ + _sql , sqle ) ; } finally { close ( ) ; } }
private Name cacheName ( String sig ) { StringBuilder buf = new StringBuilder ( ) ; if ( sig . startsWith ( STR_ ) ) { buf = buf . append ( STR_ ) ; while ( sig . startsWith ( STR_ ) ) { buf = buf . append ( target . syntheticNameChar ( ) ) ; sig = sig . substring ( NUM_ ) ; } if ( sig . startsWith ( STR_ ) ) { sig = sig . substring ( NUM_ , sig . length ( ) - NUM_ ) ; } } else { buf = buf . append ( STR_ + target . syntheticNameChar ( ) ) ; } buf = buf . append ( sig . replace ( STR_ , target . syntheticNameChar ( ) ) ) ; return names . fromString ( buf . toString ( ) ) ; }
@ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case EipPackage . CONDITIONAL_ROUTE__CONDITION : return CONDITION_EDEFAULT == null ? condition != null : ! CONDITION_EDEFAULT . equals ( condition ) ; case EipPackage . CONDITIONAL_ROUTE__CHANNEL : return channel != null ; } return super . eIsSet ( featureID ) ; }
public static native String mapLibraryName ( String libname ) ;
public Matcher next ( ) throws IOException { readahead ( ) ; if ( matches == null ) { throw new NoSuchElementException ( ) ; } Matcher matcher = matches . next ( ) ; if ( discard ) { Pattern pattern = matcher . pattern ( ) ; for ( int n = NUM_ ; n < patterns . length ; n ++ ) { if ( patterns [ n ] == pattern ) { patterns [ n ] = null ; break ; } } } return matcher ; }
@ CalledOnlyBy ( AmidstThread . FRAGMENT_LOADER ) public void processQueues ( ) { Dimension dimension = dimensionSetting . get ( ) ; updateLayerManager ( dimension ) ; processRecycleQueue ( ) ; Fragment fragment ; while ( ( fragment = loadingQueue . poll ( ) ) != null ) { loadFragment ( dimension , fragment ) ; dimension = dimensionSetting . get ( ) ; updateLayerManager ( dimension ) ; processRecycleQueue ( ) ; } layerManager . clearInvalidatedLayers ( ) ; }
default FieldDeclaration addPrivateField ( Class < ? > typeClass , String name ) { return addField ( typeClass , name , Modifier . PRIVATE ) ; }
void ReconstructPrivateSubrs ( int Font , IndexBaseItem [ ] fdPrivateBase , OffsetItem [ ] fdSubrs ) { for ( int i = NUM_ ; i < fonts [ Font ] . fdprivateLengths . length ; i ++ ) { if ( fdSubrs [ i ] != null && fonts [ Font ] . PrivateSubrsOffset [ i ] >= NUM_ ) { OutputList . addLast ( new SubrMarkerItem ( fdSubrs [ i ] , fdPrivateBase [ i ] ) ) ; if ( NewLSubrsIndex [ i ] != null ) OutputList . addLast ( new RangeItem ( new RandomAccessFileOrArray ( rasFactory . createSource ( NewLSubrsIndex [ i ] ) ) , NUM_ , NewLSubrsIndex [ i ] . length ) ) ; } } }
public boolean matchChomp ( String seq ) { if ( matches ( seq ) ) { pos += seq . length ( ) ; return BOOL_ ; } else { return BOOL_ ; } }
public void initGL ( ) { mEglCore = new EglCore ( null , EglCore . FLAG_RECORDABLE | EglCore . FLAG_TRY_GLES3 ) ; mWindowSurface = new WindowSurface ( mEglCore , mSurfaceTexture ) ; mWindowSurface . makeCurrent ( ) ; mRecordSurface = new WindowSurface ( mEglCore , mMediaRecorder . getSurface ( ) , BOOL_ ) ; initGLComponents ( ) ; }
void clear ( ) { if ( mViewTypeCount == NUM_ ) { final ArrayList < View > scrap = mCurrentScrap ; final int scrapCount = scrap . size ( ) ; for ( int i = NUM_ ; i < scrapCount ; i ++ ) { removeDetachedView ( scrap . remove ( scrapCount - NUM_ - i ) , BOOL_ ) ; } } else { final int typeCount = mViewTypeCount ; for ( int i = NUM_ ; i < typeCount ; i ++ ) { final ArrayList < View > scrap = mScrapViews [ i ] ; final int scrapCount = scrap . size ( ) ; for ( int j = NUM_ ; j < scrapCount ; j ++ ) { removeDetachedView ( scrap . remove ( scrapCount - NUM_ - j ) , BOOL_ ) ; } } } if ( mTransientStateViews != null ) { mTransientStateViews . clear ( ) ; } }
protected void contributeTokenRequestParameters ( final QueryString bodyParameters ) { }
public int read ( char cbuf [ ] , int off , int len ) { int k ; if ( position >= document . getLength ( ) ) { return - NUM_ ; } k = len ; if ( ( position + k ) >= document . getLength ( ) ) k = document . getLength ( ) - ( int ) position ; if ( off + k >= cbuf . length ) k = cbuf . length - off ; try { document . getText ( ( int ) position , k , segment ) ; position += k ; System . arraycopy ( segment . array , segment . offset , cbuf , off , k ) ; return k ; } catch ( BadLocationException ble ) { return - NUM_ ; } }
Builder addLenient ( String line ) { int index = line . indexOf ( STR_ , NUM_ ) ; if ( index != - NUM_ ) { return addLenient ( line . substring ( NUM_ , index ) , line . substring ( index + NUM_ ) ) ; } else if ( line . startsWith ( STR_ ) ) { return addLenient ( STR_ , line . substring ( NUM_ ) ) ; } else { return addLenient ( STR_ , line ) ; } }
public static void mergeNodeChildren ( TreeNode node ) { DefaultMutableTreeNode masterNode = ( DefaultMutableTreeNode ) node ; for ( int i = NUM_ ; i < masterNode . getChildCount ( ) ; i ++ ) { DefaultMutableTreeNode child = ( DefaultMutableTreeNode ) masterNode . getChildAt ( i ) ; if ( ! child . isLeaf ( ) ) { MergeHelpUtilities . mergeNodeChildren ( DEFAULT_MERGE_TYPE , child ) ; } } }
public void testNegateNegative ( ) { String a = STR_ ; int aScale = NUM_ ; String c = STR_ ; int cScale = NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal cNumber = new BigDecimal ( new BigInteger ( c ) , cScale ) ; assertEquals ( STR_ , cNumber , aNumber . negate ( ) ) ; }
private static Object createAndBindItem ( ParameterAccess parameters , Class < ? > itemType ) { try { Object value = itemType . newInstance ( ) ; bind ( value , parameters ) ; return value ; } catch ( InstantiationException | IllegalAccessException e ) { throw new BindingException ( STR_ + itemType , e ) ; } }
public SimpleSetupPanel ( Experiment exp ) { this ( ) ; setExperiment ( exp ) ; }
public static void addListener ( Listener listener ) { listeners . addLast ( listener ) ; }
private static void processArgs ( String [ ] args ) { for ( int i = NUM_ ; i < args . length ; i ++ ) { String arg = args [ i ] ; if ( arg . equals ( STR_ ) ) { outputDir = args [ ++ i ] ; } else if ( arg . equals ( STR_ ) ) { unicodeData = args [ ++ i ] ; } else if ( arg . equals ( STR_ ) ) { language = args [ ++ i ] ; } else if ( arg . equals ( STR_ ) ) { country = args [ ++ i ] ; } else if ( arg . equals ( STR_ ) ) { valiant = args [ ++ i ] ; } else { usage ( ) ; } } localeName = getLocaleName ( ) ; }
public static boolean isZoningRequired ( DbClient dbClient , VirtualArray nh ) { if ( nh . getAutoSanZoning ( ) == BOOL_ ) { _log . info ( STR_ + nh . getLabel ( ) ) ; return BOOL_ ; } return NetworkUtil . areNetworkSystemDiscovered ( dbClient ) ; }
private void initXMLTree ( ) throws Exception { updateFilteredTokens ( ) ; ArrayList elements = getElements ( getFilteredTokens ( ) ) ; if ( elements . size ( ) > NUM_ ) { throw new Exception ( STR_ ) ; } setRootElement ( ( XMLElement ) elements . get ( NUM_ ) ) ; }
public boolean hasNameValue ( String name ) { return nameValueMap . containsKey ( name . toLowerCase ( ) ) ; }
public boolean startsWith ( CharSeq prefix ) { return str . startsWith ( prefix . str ) ; }
public boolean containsWindow ( Class < ? > windowClass ) { return ( getWindow ( windowClass ) != null ) ; }
protected final void firePropertyChange ( String propertyName , long oldValue , long newValue ) { firePropertyChange ( propertyName , Long . valueOf ( oldValue ) , Long . valueOf ( newValue ) ) ; }
public void fadeToLayer ( int index ) { mTransitionState = TRANSITION_STARTING ; Arrays . fill ( mIsLayerOn , BOOL_ ) ; mIsLayerOn [ index ] = BOOL_ ; invalidateSelf ( ) ; }
private void fitImageToView ( ) { Drawable drawable = getDrawable ( ) ; if ( drawable == null || drawable . getIntrinsicWidth ( ) == NUM_ || drawable . getIntrinsicHeight ( ) == NUM_ ) { return ; } if ( matrix == null || prevMatrix == null ) { return ; } int drawableWidth = drawable . getIntrinsicWidth ( ) ; int drawableHeight = drawable . getIntrinsicHeight ( ) ; float scaleX = ( float ) viewWidth / drawableWidth ; float scaleY = ( float ) viewHeight / drawableHeight ; switch ( mScaleType ) { case CENTER : scaleX = scaleY = NUM_ ; break ; case CENTER_CROP : scaleX = scaleY = Math . max ( scaleX , scaleY ) ; break ; case CENTER_INSIDE : scaleX = scaleY = Math . min ( NUM_ , Math . min ( scaleX , scaleY ) ) ; case FIT_CENTER : scaleX = scaleY = Math . min ( scaleX , scaleY ) ; break ; case FIT_XY : break ; default : throw new UnsupportedOperationException ( STR_ ) ; } float redundantXSpace = viewWidth - ( scaleX . drawableWidth ) ; float redundantYSpace = viewHeight - ( scaleY . drawableHeight ) ; matchViewWidth = viewWidth - redundantXSpace ; matchViewHeight = viewHeight - redundantYSpace ; if ( ! isZoomed ( ) && ! imageRenderedAtLeastOnce ) { matrix . setScale ( scaleX , scaleY ) ; matrix . postTranslate ( redundantXSpace / NUM_ , redundantYSpace / NUM_ ) ; normalizedScale = NUM_ ; } else { if ( prevMatchViewWidth == NUM_ || prevMatchViewHeight == NUM_ ) { savePreviousImageValues ( ) ; } prevMatrix . getValues ( m ) ; m [ Matrix . MSCALE_X ] = matchViewWidth / drawableWidth . normalizedScale ; m [ Matrix . MSCALE_Y ] = matchViewHeight / drawableHeight . normalizedScale ; float transX = m [ Matrix . MTRANS_X ] ; float transY = m [ Matrix . MTRANS_Y ] ; float prevActualWidth = prevMatchViewWidth . normalizedScale ; float actualWidth = getImageWidth ( ) ; translateMatrixAfterRotate ( Matrix . MTRANS_X , transX , prevActualWidth , actualWidth , prevViewWidth , viewWidth , drawableWidth ) ; float prevActualHeight = prevMatchViewHeight . normalizedScale ; float actualHeight = getImageHeight ( ) ; translateMatrixAfterRotate ( Matrix . MTRANS_Y , transY , prevActualHeight , actualHeight , prevViewHeight , viewHeight , drawableHeight ) ; matrix . setValues ( m ) ; } fixTrans ( ) ; setImageMatrix ( matrix ) ; }
public static int hashCode ( boolean [ ] field ) { return field == null || field . length == NUM_ ? NUM_ : Arrays . hashCode ( field ) ; }
public AbstractSurfaceObject ( AbstractSurfaceObject source ) { super ( source ) ; this . visible = source . visible ; this . uniqueId = nextUniqueId ( ) ; this . lastModifiedTime = System . currentTimeMillis ( ) ; this . enableBatchPicking = source . enableBatchPicking ; }
public SootMethodAndClass parseSootMethodString ( String parseString ) { if ( ! parseString . startsWith ( STR_ ) || ! parseString . endsWith ( STR_ ) ) { throw new IllegalArgumentException ( STR_ + parseString + STR_ ) ; } String name = STR_ ; String className = STR_ ; String returnType = STR_ ; Pattern pattern = Pattern . compile ( STR_ ) ; Matcher matcher = pattern . matcher ( parseString ) ; if ( matcher . find ( ) ) { className = matcher . group ( NUM_ ) ; } pattern = Pattern . compile ( STR_ ) ; matcher = pattern . matcher ( parseString ) ; if ( matcher . find ( ) ) { returnType = matcher . group ( NUM_ ) ; parseString = parseString . substring ( matcher . end ( NUM_ ) ) ; } pattern = Pattern . compile ( STR_ ) ; matcher = pattern . matcher ( parseString ) ; if ( matcher . find ( ) ) { name = matcher . group ( NUM_ ) ; } List < String > paramList = new ArrayList < String > ( ) ; pattern = Pattern . compile ( STR_ ) ; matcher = pattern . matcher ( parseString ) ; if ( matcher . find ( ) ) { String params = matcher . group ( NUM_ ) ; for ( String param : params . split ( STR_ ) ) paramList . add ( param . trim ( ) ) ; } return new SootMethodAndClass ( name , className , returnType , paramList ) ; }
private void createNewReviewTask ( TaskRepository repository , TaskData taskData ) throws CoreException { Repository repo = AppraisePluginUtils . getGitRepoForRepository ( repository ) ; AppraisePluginReviewClient client ; try { client = new AppraisePluginReviewClient ( repository ) ; } catch ( GitClientException e1 ) { throw new CoreException ( new Status ( IStatus . ERROR , AppraiseConnectorPlugin . PLUGIN_ID , STR_ ) ) ; } String currentBranch ; try { currentBranch = repo . getFullBranch ( ) ; } catch ( IOException e ) { throw new CoreException ( new Status ( IStatus . ERROR , AppraiseConnectorPlugin . PLUGIN_ID , STR_ , e ) ) ; } if ( MASTER_REF . equals ( currentBranch ) ) { throw new CoreException ( new Status ( IStatus . ERROR , AppraiseConnectorPlugin . PLUGIN_ID , STR_ ) ) ; } setAttributeValue ( taskData , schema . REQUESTER , repository . getUserName ( ) ) ; setAttributeValue ( taskData , schema . TARGET_REF , MASTER_REF ) ; setAttributeValue ( taskData , schema . REVIEW_REF , currentBranch ) ; RevCommit reviewCommit ; try { reviewCommit = client . getReviewCommit ( currentBranch , MASTER_REF ) ; } catch ( GitClientException e ) { throw new CoreException ( new Status ( IStatus . ERROR , AppraiseConnectorPlugin . PLUGIN_ID , STR_ , e ) ) ; } if ( reviewCommit == null ) { throw new CoreException ( new Status ( IStatus . INFO , AppraiseConnectorPlugin . PLUGIN_ID , STR_ + currentBranch ) ) ; } setAttributeValue ( taskData , schema . DESCRIPTION , reviewCommit . getFullMessage ( ) ) ; setAttributeValue ( taskData , schema . REVIEW_COMMIT , reviewCommit . getName ( ) ) ; try { List < DiffEntry > diffs = client . getReviewDiffs ( currentBranch , MASTER_REF ) ; populateDiffs ( repository , diffs , taskData ) ; } catch ( Exception e ) { throw new CoreException ( new Status ( IStatus . ERROR , AppraiseConnectorPlugin . PLUGIN_ID , STR_ , e ) ) ; } }
public boolean isCritical ( ) { return BOOL_ ; }
@ Override public void startup ( ) throws Exception { Log . d ( Mary . LOG , STR_ ) ; List < String > voiceNames = MaryProperties . getList ( STR_ ) ; for ( String voiceName : voiceNames ) { long time = System . currentTimeMillis ( ) ; Voice unitSelVoice = new UnitSelectionVoice ( voiceName , this ) ; Log . d ( Mary . LOG , STR_ + unitSelVoice + STR_ ) ; Voice . registerVoice ( unitSelVoice ) ; long newtime = System . currentTimeMillis ( ) - time ; Log . i ( Mary . LOG , STR_ + voiceName + STR_ + newtime + STR_ ) ; } Log . i ( Mary . LOG , STR_ ) ; }
public int findStartOfColumn ( int column ) { if ( column == mColumns ) return getSpaceUsed ( ) ; int currentColumn = NUM_ ; int currentCharIndex = NUM_ ; while ( BOOL_ ) { int newCharIndex = currentCharIndex ; char c = mText [ newCharIndex ++ ] ; boolean isHigh = Character . isHighSurrogate ( c ) ; int codePoint = isHigh ? Character . toCodePoint ( c , mText [ newCharIndex ++ ] ) : c ; int wcwidth = WcWidth . width ( codePoint ) ; if ( wcwidth > NUM_ ) { currentColumn += wcwidth ; if ( currentColumn == column ) { while ( newCharIndex < mSpaceUsed ) { if ( Character . isHighSurrogate ( mText [ newCharIndex ] ) ) { if ( WcWidth . width ( Character . toCodePoint ( mText [ newCharIndex ] , mText [ newCharIndex + NUM_ ] ) ) <= NUM_ ) { newCharIndex += NUM_ ; } else { break ; } } else if ( WcWidth . width ( mText [ newCharIndex ] ) <= NUM_ ) { newCharIndex ++ ; } else { break ; } } return newCharIndex ; } else if ( currentColumn > column ) { return currentCharIndex ; } } currentCharIndex = newCharIndex ; } }
private TripSchedule rerouteTripSchedule ( TripSchedule originalSchedule ) { TripSchedule schedule = originalSchedule . clone ( ) ; schedule . arrivals = new int [ newPatternLength ] ; schedule . departures = new int [ newPatternLength ] ; int prevOutputDeparture = NUM_ ; for ( int ss = NUM_ , ts = NUM_ ; ts < newPatternLength ; ss ++ , ts ++ ) { if ( ( ss == insertBeginIndex - NUM_ ) || ( ss == NUM_ && insertBeginIndex == NUM_ ) ) { int hopTime = originalSchedule . arrivals [ ss ] ; if ( ss > NUM_ ) hopTime -= originalSchedule . departures [ ss - NUM_ ] ; schedule . arrivals [ ts ] = prevOutputDeparture + hopTime ; schedule . departures [ ts ] = schedule . arrivals [ ts ] + dwellTimes [ NUM_ ] ; prevOutputDeparture = schedule . departures [ ts ] ; ts ++ ; for ( int hop = NUM_ , dwell = NUM_ ; dwell < dwellTimes . length ; hop ++ , dwell ++ ) { schedule . arrivals [ ts ] = prevOutputDeparture + hopTimes [ hop ] ; schedule . departures [ ts ] = schedule . arrivals [ ts ] + dwellTimes [ dwell ] ; prevOutputDeparture = schedule . departures [ ts ] ; ts ++ ; } ss = insertEndIndex + NUM_ ; if ( ts == newPatternLength ) break ; } int hopTime = originalSchedule . arrivals [ ss ] ; if ( ss > NUM_ ) hopTime -= originalSchedule . departures [ ss - NUM_ ] ; schedule . arrivals [ ts ] = prevOutputDeparture + hopTime ; int dwellTime = originalSchedule . departures [ ss ] - originalSchedule . arrivals [ ss ] ; schedule . departures [ ts ] = schedule . arrivals [ ts ] + dwellTime ; prevOutputDeparture = schedule . departures [ ts ] ; } int timeShift = originalSchedule . arrivals [ originalFixedPointStopIndex ] - schedule . arrivals [ newFixedPointStopIndex ] ; for ( int i = NUM_ ; i < newPatternLength ; i ++ ) { schedule . arrivals [ i ] += timeShift ; schedule . departures [ i ] += timeShift ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( STR_ , originalSchedule . arrivals ) ; LOG . debug ( STR_ , originalSchedule . departures ) ; LOG . debug ( STR_ , schedule . arrivals ) ; LOG . debug ( STR_ , schedule . departures ) ; } return schedule ; }
public static Color decode ( String color , Color defaultColor ) { if ( color == null ) { return defaultColor ; } Color c = getNamedColor ( color ) ; if ( c == null ) { try { c = Color . decode ( color ) ; } catch ( NumberFormatException ex ) { return defaultColor ; } } return c ; }
public static LinkedList < MaryModule > modulesRequiredForProcessing ( MaryDataType sourceType , MaryDataType targetType , Locale locale , Voice voice ) { if ( ! registrationComplete ) throw new IllegalStateException ( STR_ ) ; if ( sourceType == null ) throw new NullPointerException ( STR_ ) ; if ( targetType == null ) throw new NullPointerException ( STR_ ) ; LinkedList < MaryDataType > seenTypes = new LinkedList < MaryDataType > ( ) ; seenTypes . add ( sourceType ) ; return modulesRequiredForProcessing ( sourceType , targetType , locale , voice , seenTypes ) ; }
public double distance ( Vector o ) { return Math . sqrt ( NumberConversions . square ( x - o . x ) + NumberConversions . square ( y - o . y ) + NumberConversions . square ( z - o . z ) ) ; }
public static long calculateElapsedGC ( ) { long timeMillis = NUM_ ; for ( GarbageCollectorMXBean gcbean : gcbeans ) { timeMillis += gcbean . getCollectionTime ( ) ; } return timeMillis ; }
public static < V > int addDistinctList ( List < V > sourceList , List < V > entryList ) { if ( sourceList == null || isEmpty ( entryList ) ) { return NUM_ ; } int sourceCount = sourceList . size ( ) ; for ( V entry : entryList ) { if ( ! sourceList . contains ( entry ) ) { sourceList . add ( entry ) ; } } return sourceList . size ( ) - sourceCount ; }
public void startObject ( int numfields ) { notNested ( ) ; if ( vtable == null || vtable . length < numfields ) vtable = new int [ numfields ] ; vtable_in_use = numfields ; Arrays . fill ( vtable , NUM_ , vtable_in_use , NUM_ ) ; nested = BOOL_ ; object_start = offset ( ) ; }
private Map < String , String > produceStream ( String topic ) { List < ProducerRecord < String , String > > messages = new ArrayList < > ( EVENT_CNT ) ; Map < String , String > keyValMap = new HashMap < > ( ) ; for ( int evt = NUM_ ; evt < EVENT_CNT ; evt ++ ) { long runtime = System . currentTimeMillis ( ) ; String key = topic + STR_ + String . valueOf ( evt ) ; String msg = runtime + String . valueOf ( evt ) ; messages . add ( new ProducerRecord < > ( topic , key , msg ) ) ; keyValMap . put ( key , msg ) ; } kafkaBroker . sendMessages ( messages ) ; return keyValMap ; }
public static String stringOfChar ( char ch , int count ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = NUM_ ; i < count ; i ++ ) { buf . append ( ch ) ; } return buf . toString ( ) ; }
private void addConnectionView ( Connection connection ) { PlatformImpl . runAndWait ( null ) ; }
public static void trim ( CharSequence aText , int [ ] aSpan ) { int begin = aSpan [ NUM_ ] ; int end = aSpan [ NUM_ ] - NUM_ ; CharSequence data = aText ; while ( ( begin < ( data . length ( ) - NUM_ ) ) && trimChar ( data . charAt ( begin ) ) ) { begin ++ ; } while ( ( end > NUM_ ) && trimChar ( data . charAt ( end ) ) ) { end -- ; } end ++ ; aSpan [ NUM_ ] = begin ; aSpan [ NUM_ ] = end ; }
public void addScriptFinishedListener ( ScriptExecutionListener l ) { m_FinishedListeners . add ( l ) ; }
public void onConsumeFinished ( Purchase purchase , IabResult result ) ;
public void test_getPutByteArray ( ) { final int size = NUM_ ; final IDataRecord buf = new FixedByteArrayBuffer ( size ) ; assertEquals ( ( byte ) NUM_ , buf . getByte ( NUM_ ) ) ; assertEquals ( ( byte ) NUM_ , buf . getByte ( size - NUM_ ) ) ; final int pos = NUM_ ; for ( int i = NUM_ ; i < LIMIT ; i ++ ) { final byte [ ] expected = new byte [ r . nextInt ( size - NUM_ ) ] ; r . nextBytes ( expected ) ; buf . put ( pos , expected ) ; assertEquals ( NUM_ , BytesUtil . compareBytesWithLenAndOffset ( NUM_ , expected . length , expected , pos , expected . length , buf . array ( ) ) ) ; final byte [ ] actual = new byte [ expected . length ] ; buf . get ( pos , actual ) ; assertTrue ( BytesUtil . bytesEqual ( expected , actual ) ) ; } assertEquals ( ( byte ) NUM_ , buf . getByte ( NUM_ ) ) ; assertEquals ( ( byte ) NUM_ , buf . getByte ( pos + size - NUM_ ) ) ; }
public static double [ ] concatAllDouble ( double [ ] ... arrays ) { int totalLength = NUM_ ; final int subArrayCount = arrays . length ; for ( int i = NUM_ ; i < subArrayCount ; ++ i ) { totalLength += arrays [ i ] . length ; } double [ ] result = Arrays . copyOf ( arrays [ NUM_ ] , totalLength ) ; int offset = arrays [ NUM_ ] . length ; for ( int i = NUM_ ; i < subArrayCount ; ++ i ) { System . arraycopy ( arrays [ i ] , NUM_ , result , offset , arrays [ i ] . length ) ; offset += arrays [ i ] . length ; } return result ; }
private T [ ] ensureCapacity ( int minCapacity ) { if ( tmp . length < minCapacity ) { int newSize = minCapacity ; newSize |= newSize > > NUM_ ; newSize |= newSize > > NUM_ ; newSize |= newSize > > NUM_ ; newSize |= newSize > > NUM_ ; newSize |= newSize > > NUM_ ; newSize ++ ; if ( newSize < NUM_ ) newSize = minCapacity ; else newSize = Math . min ( newSize , a . length > > > NUM_ ) ; T [ ] newArray = ( T [ ] ) new Object [ newSize ] ; tmp = newArray ; } return tmp ; }
public synchronized void add ( String category , double minValue , double maxValue ) { super . add ( category , minValue ) ; mMaxValues . add ( maxValue ) ; }
public void CONT ( int sessionNumber ) throws Exception { this . maxSessionNumber = Math . max ( this . maxSessionNumber , sessionNumber ) ; testElements . add ( new ContinuationElement ( sessionNumber ) ) ; }
public static double calcRotationAngleInDegrees ( PointF centerPt , PointF targetPt ) { double theta = Math . atan2 ( targetPt . y - centerPt . y , targetPt . x - centerPt . x ) ; double angle = Math . toDegrees ( theta ) ; if ( angle < NUM_ ) { angle += NUM_ ; } return angle ; }
public int countIn ( CharSequence sequence ) { int count = NUM_ ; for ( int i = NUM_ ; i < sequence . length ( ) ; i ++ ) { if ( matches ( sequence . charAt ( i ) ) ) { count ++ ; } } return count ; }
public DeltaCRLIndicatorExtension ( int crlNum ) throws IOException { super ( PKIXExtensions . DeltaCRLIndicator_Id , BOOL_ , BigInteger . valueOf ( crlNum ) , NAME , LABEL ) ; }
public static void v ( String tag , String s , Object ... args ) { if ( LOG . VERBOSE >= LOGLEVEL ) Log . v ( tag , String . format ( s , args ) ) ; }
@ Override public SoftwarePIDController withTolerance ( double tolerance ) { target = target . withTolerance ( Math . abs ( tolerance ) ) ; return this ; }
protected final void dragDropFinished ( final boolean success , final int operations , final int x , final int y ) { DragSourceEvent event = new DragSourceDropEvent ( getDragSourceContext ( ) , operations & sourceActions , success , x , y ) ; EventDispatcher dispatcher = new EventDispatcher ( DISPATCH_FINISH , event ) ; SunToolkit . invokeLaterOnAppContext ( SunToolkit . targetToAppContext ( getComponent ( ) ) , dispatcher ) ; startSecondaryEventLoop ( ) ; setNativeContext ( NUM_ ) ; dragImage = null ; dragImageOffset = null ; }
@ Override public byte [ ] write ( InternalLog log ) throws IOException { final byte [ ] rowkey = RowkeyBuilder . buildRowkey ( log ) ; final Put p = new Put ( rowkey ) ; populateColumnValues ( p , log ) ; tbl . put ( p ) ; final List < byte [ ] > indexRowkeys = log . getIndexRowkeys ( ) ; if ( indexRowkeys != null ) { writeIndexes ( rowkey , indexRowkeys ) ; } return rowkey ; }
private void insertIntoDynamicTable ( int index , Header entry ) { headerList . add ( entry ) ; int delta = entry . hpackSize ; if ( index != - NUM_ ) { delta -= dynamicTable [ dynamicTableIndex ( index ) ] . hpackSize ; } if ( delta > maxDynamicTableByteCount ) { clearDynamicTable ( ) ; return ; } int bytesToRecover = ( dynamicTableByteCount + delta ) - maxDynamicTableByteCount ; int entriesEvicted = evictToRecoverBytes ( bytesToRecover ) ; if ( index == - NUM_ ) { if ( headerCount + NUM_ > dynamicTable . length ) { Header [ ] doubled = new Header [ dynamicTable . length . NUM_ ] ; System . arraycopy ( dynamicTable , NUM_ , doubled , dynamicTable . length , dynamicTable . length ) ; nextHeaderIndex = dynamicTable . length - NUM_ ; dynamicTable = doubled ; } index = nextHeaderIndex -- ; dynamicTable [ index ] = entry ; headerCount ++ ; } else { index += dynamicTableIndex ( index ) + entriesEvicted ; dynamicTable [ index ] = entry ; } dynamicTableByteCount += delta ; }
protected static String extractSecretAccessKey ( String s3uri ) { return s3uri . substring ( s3uri . indexOf ( STR_ , s3uri . indexOf ( STR_ ) + NUM_ ) + NUM_ , s3uri . indexOf ( STR_ ) ) ; }
private void dial ( String contactInformation , boolean makeTheCall , boolean usePhoneSpeaker ) { if ( contactInformation . equals ( STR_ ) ) { String lastRecipient = RecipientCmd . getLastRecipientNumber ( ) ; String lastRecipientName = RecipientCmd . getLastRecipientName ( ) ; if ( lastRecipient != null ) { doDial ( lastRecipientName , lastRecipient , makeTheCall , usePhoneSpeaker ) ; } else { send ( STR_ ) ; } } else { ResolvedContact resolvedContact = mContactsResolver . resolveContact ( contactInformation , ContactsResolver . TYPE_ALL ) ; if ( resolvedContact == null ) { send ( R . string . chat_no_match_for , contactInformation ) ; } else if ( resolvedContact . isDistinct ( ) ) { doDial ( resolvedContact . getName ( ) , resolvedContact . getNumber ( ) , makeTheCall , usePhoneSpeaker ) ; } else { askForMoreDetails ( resolvedContact . getCandidates ( ) ) ; } } }
public void addSafeClass ( SootClass clz ) { safeClasses . add ( clz . getName ( ) ) ; }
private boolean activeListHasRoom ( ) { int maxDownloads = NUM_ ; return mActiveList . size ( ) < maxDownloads ; }
public static final double parseTime ( final String time , final char separator ) { if ( time == null || time . length ( ) == NUM_ || time . equals ( STR_ ) ) { return Time . UNDEFINED_TIME ; } boolean isNegative = ( time . charAt ( NUM_ ) == STR_ ) ; String [ ] strings = ( isNegative ? StringUtils . explode ( time . substring ( NUM_ ) , separator ) : StringUtils . explode ( time , separator ) ) ; double seconds = NUM_ ; if ( strings . length == NUM_ ) { seconds = Math . abs ( Double . parseDouble ( strings [ NUM_ ] ) ) ; } else if ( strings . length == NUM_ ) { int h = Integer . parseInt ( strings [ NUM_ ] ) ; int m = Integer . parseInt ( strings [ NUM_ ] ) ; if ( ( m < NUM_ ) || ( m > NUM_ ) ) { throw new IllegalArgumentException ( STR_ + time ) ; } seconds = Math . abs ( h ) . NUM_ + m . NUM_ ; } else if ( strings . length == NUM_ ) { int h = Integer . parseInt ( strings [ NUM_ ] ) ; int m = Integer . parseInt ( strings [ NUM_ ] ) ; double s = Double . parseDouble ( strings [ NUM_ ] ) ; if ( ( m < NUM_ ) || ( m > NUM_ ) ) { throw new IllegalArgumentException ( STR_ + time ) ; } if ( ( s < NUM_ ) || ( s >= NUM_ ) ) { throw new IllegalArgumentException ( STR_ + time ) ; } seconds = Math . abs ( h ) . NUM_ + m . NUM_ + s ; } else { throw new IllegalArgumentException ( STR_ + time ) ; } if ( isNegative ) { seconds = - seconds ; } return seconds ; }
public boolean isRunning ( ) { return this . running ; }
protected static Map < String , Step > parse ( Class < ? extends RSLPStemmerBase > clazz , String resource ) { try { InputStream is = clazz . getResourceAsStream ( resource ) ; LineNumberReader r = new LineNumberReader ( new InputStreamReader ( is , StandardCharsets . UTF_8 ) ) ; Map < String , Step > steps = new HashMap < > ( ) ; String step ; while ( ( step = readLine ( r ) ) != null ) { Step s = parseStep ( r , step ) ; steps . put ( s . name , s ) ; } r . close ( ) ; return steps ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
public String betToString ( ) { final StringBuilder sb = new StringBuilder ( ) ; sb . append ( amount ) ; sb . append ( STR_ ) ; sb . append ( itemName ) ; sb . append ( STR_ ) ; sb . append ( target ) ; return sb . toString ( ) ; }
public void test_nonEmptyJournal ( ) throws IOException , InterruptedException , ExecutionException { final File out = File . createTempFile ( getName ( ) , Options . JNL ) ; try { final Journal src = getStore ( getProperties ( ) ) ; try { if ( ! ( src . getBufferStrategy ( ) instanceof IHABufferStrategy ) ) { return ; } src . write ( getRandomData ( NUM_ ) ) ; src . commit ( ) ; try { final ISnapshotFactory snapshotFactory = new MySnapshotFactory ( getName ( ) , BOOL_ ) ; final Future < ISnapshotResult > f = src . snapshot ( snapshotFactory ) ; final ISnapshotResult snapshotResult = f . get ( ) ; final File snapshotFile = snapshotResult . getFile ( ) ; try { final Journal tmp = openSnapshot ( snapshotResult ) ; assertEquals ( src . getRootBlockView ( ) , tmp . getRootBlockView ( ) ) ; tmp . destroy ( ) ; } finally { if ( snapshotFile . exists ( ) ) { snapshotFile . delete ( ) ; } } } catch ( IllegalArgumentException ex ) { log . info ( STR_ + ex ) ; } } finally { src . destroy ( ) ; } } finally { out . delete ( ) ; } }
private boolean checkMatchIp ( Map < String , Object > rows ) { boolean matchEther = BOOL_ ; String val = ( String ) rows . get ( StaticFlowEntryPusher . COLUMN_DL_TYPE ) ; if ( val != null ) { int type = NUM_ ; if ( val . startsWith ( STR_ ) ) { type = Integer . parseInt ( val . substring ( NUM_ ) , NUM_ ) ; } else { try { type = Integer . parseInt ( val ) ; } catch ( NumberFormatException e ) { } } if ( type == NUM_ ) matchEther = BOOL_ ; } if ( ( rows . containsKey ( StaticFlowEntryPusher . COLUMN_NW_DST ) || rows . containsKey ( StaticFlowEntryPusher . COLUMN_NW_SRC ) || rows . containsKey ( StaticFlowEntryPusher . COLUMN_NW_PROTO ) || rows . containsKey ( StaticFlowEntryPusher . COLUMN_NW_TOS ) ) && ( matchEther == BOOL_ ) ) return BOOL_ ; return BOOL_ ; }
public static double powQuick ( double value , double power ) { if ( USE_JDK_MATH ) { return STRICT_MATH ? StrictMath . pow ( value , power ) : Math . pow ( value , power ) ; } return FastMath . exp ( power . FastMath . logQuick ( value ) ) ; }
private String classToEntryPath ( Class < ? > clazz ) { String name = STR_ ; Class < ? > parent ; while ( ( parent = clazz . getEnclosingClass ( ) ) != null ) { name = STR_ + clazz . getSimpleName ( ) + name ; clazz = parent ; } return classNameToEntryPath ( clazz . getCanonicalName ( ) + name ) ; }
public static String write ( POSMikheevCounter counter ) { return POSBaseLineCounter . write ( counter ) ; }
private Map < String , AnnotationMirror > annosInPackage ( PackageElement packageElement ) { return createImportedAnnotationsMap ( ElementFilter . typesIn ( packageElement . getEnclosedElements ( ) ) ) ; }
public OsmElement pasteFrom ( ) { List < Way > ways = storage . getWays ( ) ; List < Node > nodes = storage . getNodes ( ) ; if ( mode == Mode . CUT ) { reset ( ) ; if ( ways != null && ways . size ( ) == NUM_ ) { Way w = ways . get ( NUM_ ) ; w . setState ( savedState ) ; for ( Node nd : w . getNodes ( ) ) { Log . d ( STR_ , STR_ + nd . getOsmId ( ) ) ; nd . setState ( savedNdState . get ( nd ) ) ; } return w ; } else if ( nodes != null && nodes . size ( ) == NUM_ ) { Node n = nodes . get ( NUM_ ) ; n . setState ( savedState ) ; return n ; } } else { if ( ways != null && ways . size ( ) == NUM_ ) { return ways . get ( NUM_ ) ; } else if ( nodes != null && nodes . size ( ) == NUM_ ) { return nodes . get ( NUM_ ) ; } } return null ; }
public final void updateCursor ( ) { updatePending . set ( BOOL_ ) ; updateCursorImpl ( ) ; }
public static boolean isMiddleMouseButton ( MouseEvent anEvent ) { return ( ( anEvent . getModifiersEx ( ) & InputEvent . BUTTON2_DOWN_MASK ) != NUM_ || anEvent . getButton ( ) == MouseEvent . BUTTON2 ) ; }
public void addSuccessMessage ( final String successMessage ) { successMessageList . add ( successMessage ) ; }
private void startStoppedChanged ( ) { clock . setStartStopped ( startStoppedCheckBox . isSelected ( ) ) ; changed = BOOL_ ; }
public void close ( ) throws IOException { try { Debug . message ( STR_ , STR_ ) ; if ( Debug . debugging ( STR_ ) ) { Thread . sleep ( NUM_ ) ; } if ( inputStream != null ) inputStream . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } inputStream = null ; }
public static Long nextLogSegmentSequenceNumber ( List < LogSegmentMetadata > segmentListDesc ) { int lastAssignedLogSegmentIdx = - NUM_ ; Long lastAssignedLogSegmentSeqNo = null ; Long nextLogSegmentSeqNo = null ; for ( int i = NUM_ ; i < segmentListDesc . size ( ) ; i ++ ) { LogSegmentMetadata metadata = segmentListDesc . get ( i ) ; if ( LogSegmentMetadata . supportsLogSegmentSequenceNo ( metadata . getVersion ( ) ) ) { lastAssignedLogSegmentSeqNo = metadata . getLogSegmentSequenceNumber ( ) ; lastAssignedLogSegmentIdx = i ; break ; } } if ( null != lastAssignedLogSegmentSeqNo ) { nextLogSegmentSeqNo = lastAssignedLogSegmentSeqNo + lastAssignedLogSegmentIdx + NUM_ ; } return nextLogSegmentSeqNo ; }
private void readBinary ( final LittleEndianDataInputStream dis ) throws IOException { RajLog . i ( STR_ ) ; dis . skip ( NUM_ ) ; int facetCount = dis . readInt ( ) ; float [ ] verticesArr = new float [ facetCount . NUM_ ] ; float [ ] normalsArr = new float [ facetCount . NUM_ ] ; int [ ] indicesArr = new int [ facetCount . NUM_ ] ; float [ ] tempNorms = new float [ NUM_ ] ; int vertPos = NUM_ , normPos = NUM_ ; for ( int i = NUM_ ; i < indicesArr . length ; i ++ ) indicesArr [ i ] = i ; while ( dis . available ( ) > NUM_ ) { for ( int j = NUM_ ; j < NUM_ ; j ++ ) { tempNorms [ j ] = dis . readFloat ( ) ; if ( Float . isNaN ( tempNorms [ j ] ) || Float . isInfinite ( tempNorms [ j ] ) ) { RajLog . w ( STR_ ) ; tempNorms [ NUM_ ] = NUM_ ; tempNorms [ NUM_ ] = NUM_ ; tempNorms [ NUM_ ] = NUM_ ; break ; } } for ( int j = NUM_ ; j < NUM_ ; j ++ ) { normalsArr [ normPos ++ ] = tempNorms [ NUM_ ] ; normalsArr [ normPos ++ ] = tempNorms [ NUM_ ] ; normalsArr [ normPos ++ ] = tempNorms [ NUM_ ] ; } for ( int j = NUM_ ; j < NUM_ ; j ++ ) verticesArr [ vertPos ++ ] = dis . readFloat ( ) ; dis . skip ( NUM_ ) ; } mRootObject . setData ( verticesArr , normalsArr , null , null , indicesArr , BOOL_ ) ; }
public static void assertSpecificLang ( String specificLang ) throws XMPException { if ( specificLang == null || specificLang . length ( ) == NUM_ ) { throw new XMPException ( STR_ , XMPError . BADPARAM ) ; } }
public int onBlockExploded ( ) { return ( int ) ( fuseTime / NUM_ + Math . random ( ) . fuseTime / NUM_ ) ; }
@ Override public boolean hasQueuedReaderThreads ( ) { return readerLock . hasQueuedThreads ( ) ; }
public long inactiveTimeMillis ( ) { return System . currentTimeMillis ( ) - lastTimeMillis ; }
public static void check ( boolean cond , Object value ) { if ( ! cond ) error ( String . valueOf ( value ) ) ; }
public void addDefinition ( ICOSDefinition cosDef ) throws UMSException { if ( ! ( cosDef instanceof DirectCOSDefinition ) ) { String msg = i18n . getString ( IUMSConstants . INVALID_COSDEFINITION ) ; throw new UMSException ( msg ) ; } String [ ] cosAttributes = cosDef . getCOSAttributes ( ) ; AbstractCollection aList = ( AbstractCollection ) Arrays . asList ( ICOSDefinition . qualifiers ) ; for ( int i = NUM_ ; i < cosAttributes . length ; i ++ ) { String cosAttribute = null ; String qualifier = null ; StringTokenizer st = new StringTokenizer ( cosAttributes [ i ] ) ; if ( st . hasMoreTokens ( ) ) { cosAttribute = st . nextToken ( ) ; } if ( cosAttribute == null ) { String msg = i18n . getString ( IUMSConstants . INVALID_COS_ATTRIBUTE_QUALIFIER ) ; throw new UMSException ( msg ) ; } if ( st . hasMoreTokens ( ) ) qualifier = st . nextToken ( ) ; if ( qualifier == null ) { qualifier = ICOSDefinition . qualifiers [ ICOSDefinition . DEFAULT ] ; cosDef . removeCOSAttribute ( cosAttribute ) ; cosDef . addCOSAttribute ( cosAttribute , ICOSDefinition . DEFAULT ) ; } if ( ! aList . contains ( qualifier ) ) { String msg = i18n . getString ( IUMSConstants . INVALID_COS_ATTRIBUTE_QUALIFIER ) ; throw new UMSException ( msg ) ; } } PersistentObject po = ( PersistentObject ) cosDef ; _parentObject . addChild ( po ) ; }
public static SourceDataQuality fromXML ( Element domElement ) { NodeList fields = domElement . getChildNodes ( ) ; int fieldsCount = fields . getLength ( ) ; String fieldName ; String fieldValueString ; Node fieldNode ; SourceDataQuality result = new SourceDataQuality ( ) ; for ( int i = NUM_ ; i != fieldsCount ; i ++ ) { fieldNode = fields . item ( i ) ; if ( fieldNode . getNodeType ( ) == Node . ELEMENT_NODE ) { fieldName = fieldNode . getNodeName ( ) ; Node fieldValueNode = fieldNode . getFirstChild ( ) ; if ( fieldValueNode != null ) { fieldValueString = fieldValueNode . getNodeValue ( ) ; } else { fieldValueString = STR_ ; } if ( fieldName . equals ( XML_ELEMENT_QUALITY_CODE ) ) { result . qualityCode = Short . parseShort ( fieldValueString ) ; } else if ( fieldName . equals ( XML_ELEMENT_QUALITY_DESC ) ) { result . description = fieldValueString ; } } } return result ; }
QName toQName ( Class < ? > outputClass ) { String localPart ; String namespaceUri ; if ( outputClass . isAnnotationPresent ( XmlRootElement . class ) ) { XmlRootElement annotation = outputClass . getAnnotation ( XmlRootElement . class ) ; localPart = annotation . name ( ) ; namespaceUri = annotation . namespace ( ) ; } else if ( outputClass . isAnnotationPresent ( XmlType . class ) ) { XmlType annotation = outputClass . getAnnotation ( XmlType . class ) ; localPart = annotation . name ( ) ; namespaceUri = annotation . namespace ( ) ; } else { throw new IllegalArgumentException ( STR_ + outputClass + STR_ + STR_ ) ; } if ( JAXB_DEFAULT_ANNOTATION_VALUE . equals ( localPart ) ) { localPart = ClassUtils . getShortNameAsProperty ( outputClass ) ; } if ( JAXB_DEFAULT_ANNOTATION_VALUE . equals ( namespaceUri ) ) { Package outputClassPackage = outputClass . getPackage ( ) ; if ( outputClassPackage != null && outputClassPackage . isAnnotationPresent ( XmlSchema . class ) ) { XmlSchema annotation = outputClassPackage . getAnnotation ( XmlSchema . class ) ; namespaceUri = annotation . namespace ( ) ; } else { namespaceUri = XMLConstants . NULL_NS_URI ; } } return new QName ( namespaceUri , localPart ) ; }
private void adjustBottom ( RectF rect , float bottom , RectF bounds , int viewHeight , float snapMargin , float aspectRatio , boolean leftMoves , boolean rightMoves ) { float newBottom = bottom ; if ( newBottom > viewHeight ) { newBottom = viewHeight + ( newBottom - viewHeight ) / NUM_ ; mTouchOffset . y -= ( newBottom - viewHeight ) / NUM_ ; } if ( newBottom > bounds . bottom ) { mTouchOffset . y -= ( newBottom - bounds . bottom ) / NUM_ ; } if ( bounds . bottom - newBottom < snapMargin ) { newBottom = bounds . bottom ; } if ( newBottom - rect . top < mMinCropHeight ) { newBottom = rect . top + mMinCropHeight ; } if ( newBottom - rect . top > mMaxCropHeight ) { newBottom = rect . top + mMaxCropHeight ; } if ( bounds . bottom - newBottom < snapMargin ) { newBottom = bounds . bottom ; } if ( aspectRatio > NUM_ ) { float newWidth = ( newBottom - rect . top ) . aspectRatio ; if ( newWidth < mMinCropWidth ) { newBottom = Math . min ( bounds . bottom , rect . top + mMinCropWidth / aspectRatio ) ; newWidth = ( newBottom - rect . top ) . aspectRatio ; } if ( newWidth > mMaxCropWidth ) { newBottom = Math . min ( bounds . bottom , rect . top + mMaxCropWidth / aspectRatio ) ; newWidth = ( newBottom - rect . top ) . aspectRatio ; } if ( leftMoves && rightMoves ) { newBottom = Math . min ( newBottom , Math . min ( bounds . bottom , rect . top + bounds . width ( ) / aspectRatio ) ) ; } else { if ( leftMoves && rect . right - newWidth < bounds . left ) { newBottom = Math . min ( bounds . bottom , rect . top + ( rect . right - bounds . left ) / aspectRatio ) ; newWidth = ( newBottom - rect . top ) . aspectRatio ; } if ( rightMoves && rect . left + newWidth > bounds . right ) { newBottom = Math . min ( newBottom , Math . min ( bounds . bottom , rect . top + ( bounds . right - rect . left ) / aspectRatio ) ) ; } } } rect . bottom = newBottom ; }
private static String generateJWT ( String secret , String jwtID , String iss , Integer ttl , Map < String , String > claims ) throws HmacException { try { return signJWT ( secret , jwtID , ttl , iss , claims ) ; } catch ( JOSEException e ) { e . printStackTrace ( ) ; throw new HmacException ( STR_ , e ) ; } }
public void exportSymbols ( String [ ] exportNames , Symbol [ ] symbols ) { if ( exportedSymbols == null ) { exportedSymbols = new ArrayList ( ) ; } for ( int i = NUM_ ; i < exportNames . length && i < symbols . length ; i ++ ) { exportedSymbols . add ( new ExportedSymbol ( symbols [ i ] , exportNames [ i ] ) ) ; } }
static boolean isFulfilling ( int m ) { return ( m & FULFILLING ) != NUM_ ; }
@ Override public synchronized void addDataSourceListener ( DataSourceListener dsl ) { m_dataSourceListeners . addElement ( dsl ) ; if ( m_format != null ) { DataSetEvent e = new DataSetEvent ( this , m_format ) ; dsl . acceptDataSet ( e ) ; } }
public static AnnotationMirror findEffectiveAnnotationInHierarchy ( final QualifierHierarchy qualifierHierarchy , final AnnotatedTypeMirror toSearch , final AnnotationMirror top ) { return findEffectiveAnnotationInHierarchy ( qualifierHierarchy , toSearch , top , BOOL_ ) ; }
public boolean toFail ( ) { LifecycleState state ; synchronized ( this ) { state = _state ; if ( state . isAfterDestroying ( ) ) { return BOOL_ ; } _state = FAILED ; _lastChangeTime = CurrentTime . currentTime ( ) ; } if ( _log != null && _log . isLoggable ( _level ) ) _log . log ( _level , STR_ + _name ) ; notifyListeners ( state , FAILED ) ; _failCount ++ ; return BOOL_ ; }
private static void read ( InputStream in , byte [ ] buf , int pos , int n ) throws IOException { int read = NUM_ ; int res = NUM_ ; while ( read < n ) { res = in . read ( buf , read + pos , n - read ) ; if ( res > NUM_ ) { read += res ; } else { throw new IOException ( STR_ + read + STR_ + n ) ; } } }
public double evaluate ( VectorInstance x , VectorInstance y ) throws Exception { VectorInstance diff = x . subtract ( y ) ; double result = - m_gamma . diff . dotProduct ( diff ) ; return Math . exp ( result ) ; }
void parseFinish ( ) { mChildren = mCurrentGroup . getChildren ( ) ; }
void cancelIncludedOnly ( ) { if ( ! _showAllInput ) { _inputAllButton . doClick ( ) ; } if ( ! _showAllOutput ) { _outputAllButton . doClick ( ) ; } if ( ! _showAllAlign ) { _alignAllButton . doClick ( ) ; } }
List < Entry > killAll ( boolean rootIncluded ) { List < Entry > killed = new ArrayList < > ( rootIncluded ? entries . size ( ) : entries . size ( ) - NUM_ ) ; Entry entry ; for ( int i = entries . size ( ) - NUM_ ; i > ( rootIncluded ? - NUM_ : NUM_ ) ; i -- ) { entry = entries . get ( i ) ; if ( entry . dead ) continue ; entry . dead = BOOL_ ; if ( i != NUM_ ) { killed . add ( entry ) ; } } return killed ; }
public static void createErrorDialog ( final String title , final String message ) { final Alert alert = new Alert ( AlertType . ERROR ) ; alert . setTitle ( title ) ; alert . setContentText ( message ) ; alert . setHeaderText ( null ) ; alert . showAndWait ( ) ; }
public static String checkIndexHeaderSuffix ( DataInput in , String expectedSuffix ) throws IOException { int suffixLength = in . readByte ( ) & xFF ; byte suffixBytes [ ] = new byte [ suffixLength ] ; in . readBytes ( suffixBytes , NUM_ , suffixBytes . length ) ; String suffix = new String ( suffixBytes , NUM_ , suffixBytes . length , StandardCharsets . UTF_8 ) ; if ( ! suffix . equals ( expectedSuffix ) ) { throw new CorruptIndexException ( STR_ + expectedSuffix + STR_ + suffix , in ) ; } return suffix ; }
protected void tag ( String tag , ArrayList names , ArrayList values , int nattr , boolean close ) { spacing ( ) ; m_out . print ( STR_ ) ; m_out . print ( tag ) ; for ( int i = NUM_ ; i < nattr ; ++ i ) { m_out . print ( STR_ ) ; m_out . print ( ( String ) names . get ( i ) ) ; m_out . print ( STR_ ) ; m_out . print ( STR_ ) ; escapeString ( ( String ) values . get ( i ) ) ; m_out . print ( STR_ ) ; } if ( close ) m_out . print ( STR_ ) ; m_out . print ( STR_ ) ; println ( ) ; if ( ! close ) { m_tagStack . add ( tag ) ; } }
public static String parseDiskString ( String input ) { String delims = STR_ ; String [ ] tokens = input . split ( delims ) ; return tokens [ NUM_ ] ; }
protected void drawCloud ( int x , int y , int w , int h , Color fillColor , Paint fillPaint , Color penColor , boolean shadow ) { GeneralPath path = new GeneralPath ( ) ; path . moveTo ( ( float ) ( x + NUM_ . w ) , ( float ) ( y + NUM_ . h ) ) ; path . curveTo ( ( float ) ( x + NUM_ . w ) , ( float ) ( y + NUM_ . h ) , ( float ) x , ( float ) ( y + NUM_ . h ) , ( float ) ( x + NUM_ . w ) , ( float ) ( y + NUM_ . h ) ) ; path . curveTo ( ( float ) x , ( float ) ( y + NUM_ . h ) , ( float ) ( x + NUM_ . w ) , ( float ) ( y + NUM_ . h ) , ( float ) ( x + NUM_ . w ) , ( float ) ( y + NUM_ . h ) ) ; path . curveTo ( ( float ) ( x + NUM_ . w ) , ( float ) ( y + h ) , ( float ) ( x + NUM_ . w ) , ( float ) ( y + h ) , ( float ) ( x + NUM_ . w ) , ( float ) ( y + NUM_ . h ) ) ; path . curveTo ( ( float ) ( x + w ) , ( float ) ( y + NUM_ . h ) , ( float ) ( x + w ) , ( float ) ( y + NUM_ . h ) , ( float ) ( x + NUM_ . w ) , ( float ) ( y + NUM_ . h ) ) ; path . curveTo ( ( float ) ( x + w ) , ( float ) ( y + NUM_ . h ) , ( float ) ( x + NUM_ . w ) , ( float ) ( y + NUM_ . h ) , ( float ) ( x + NUM_ . w ) , ( float ) ( y + NUM_ . h ) ) ; path . curveTo ( ( float ) ( x + NUM_ . w ) , ( float ) ( y + NUM_ . h ) , ( float ) ( x + NUM_ . w ) , ( float ) ( y + NUM_ . h ) , ( float ) ( x + NUM_ . w ) , ( float ) ( y + NUM_ . h ) ) ; path . closePath ( ) ; drawPath ( path , fillColor , fillPaint , penColor , shadow ) ; }
private static boolean isTrusted ( Object obj , TrustVerifier . Context ctx ) throws RemoteException { Object saved = state . get ( ) ; try { state . set ( obj ) ; return ctx . isTrustedObject ( obj ) ; } finally { state . set ( saved ) ; } }
public static PersistentSearchRequestControl newControl ( final boolean isCritical , final boolean changesOnly , final boolean returnECs , final PersistentSearchChangeType ... changeTypes ) { Reject . ifNull ( ( Object ) changeTypes ) ; return newControl ( isCritical , changesOnly , returnECs , Arrays . asList ( changeTypes ) ) ; }
public static Number multiply ( Character left , Character right ) { return multiply ( Integer . valueOf ( left ) , right ) ; }
public static String normalize ( final CharSequence self ) { final String s = self . toString ( ) ; int nx = s . indexOf ( STR_ ) ; if ( nx < NUM_ ) { return s ; } final int len = s . length ( ) ; final StringBuilder sb = new StringBuilder ( len ) ; int i = NUM_ ; do { sb . append ( s , i , nx ) ; sb . append ( STR_ ) ; if ( ( i = nx + NUM_ ) >= len ) break ; if ( s . charAt ( i ) == STR_ ) { if ( ++ i >= len ) break ; } nx = s . indexOf ( STR_ , i ) ; } while ( nx > NUM_ ) ; sb . append ( s , i , len ) ; return sb . toString ( ) ; }
public void addZoneChangeListener ( ZoneChangeListener listener ) { zoneChangeListeners . add ( listener ) ; }
public void write ( final int b ) throws IOException { if ( m_store == null ) { throw new IllegalStateException ( ERR_NO_STORE ) ; } if ( m_isSaved ) { throw new IllegalStateException ( ERR_ALREADY_SAVED ) ; } if ( m_count == m_blobThreshold && ! m_writingHdr ) { if ( m_blobHeader == null ) { m_blobHeader = new ArrayList < Integer > ( ) ; } final int curAddr = ( int ) m_store . alloc ( m_buf , m_count , m_context ) ; m_blobHeader . add ( curAddr ) ; m_count = NUM_ ; } m_buf [ m_count ++ ] = ( byte ) b ; m_bytesWritten ++ ; }
public StartListener ( Object resource ) { _resource = resource ; }
public List < T > asFlatList ( ) { List < T > list = new ArrayList < T > ( ) ; for ( int i = NUM_ ; i < getRowCount ( ) ; i ++ ) { for ( int j = NUM_ ; j < getColumnCount ( ) ; j ++ ) { list . add ( getLogicalValueAt ( i , j ) ) ; } } return list ; }
@ Beta public void reset ( ) { schedulersHook . set ( null ) ; }
public static String hashKeyForDisk ( String key ) { String cacheKey ; try { final MessageDigest mDigest = MessageDigest . getInstance ( STR_ ) ; mDigest . update ( key . getBytes ( ) ) ; cacheKey = bytesToHexString ( mDigest . digest ( ) ) ; } catch ( NoSuchAlgorithmException e ) { cacheKey = String . valueOf ( key . hashCode ( ) ) ; } return cacheKey ; }
public void recordTimestamp ( ) { long curTimestamp = System . currentTimeMillis ( ) ; if ( usedFields > NUM_ ) { long diff = curTimestamp - lastValue ; if ( usedFields == diffs . length ) { long removedValue = diffs [ curPosition ] ; diffs [ curPosition ] = diff ; calculateNewAverage ( removedValue , diff , BOOL_ ) ; shiftEnd ( ) ; } else { calculateNewAverage ( NUM_ , diff , BOOL_ ) ; diffs [ curPosition ] = diff ; shiftEnd ( ) ; } } else if ( lastValue != - NUM_ ) { long diff = curTimestamp - lastValue ; currentAverage = NUM_ ; diffs [ curPosition ] = diff ; calculateNewAverage ( NUM_ , diff , BOOL_ ) ; shiftEnd ( ) ; } lastValue = curTimestamp ; }
@ AfterMethod public void tearDown ( ) throws Exception { Throwable t = threadFailure . getAndSet ( null ) ; if ( t != null ) { if ( t instanceof Error ) throw ( Error ) t ; else if ( t instanceof RuntimeException ) throw ( RuntimeException ) t ; else if ( t instanceof Exception ) throw ( Exception ) t ; else { AssertionFailedError afe = new AssertionFailedError ( t . toString ( ) ) ; afe . initCause ( t ) ; throw afe ; } } if ( Thread . interrupted ( ) ) tearDownFail ( STR_ ) ; checkForkJoinPoolThreadLeaks ( ) ; }
public void parse ( String string ) { if ( string == null ) { throw new NullPointerException ( STR_ ) ; } int bufferSize = Math . max ( MIN_BUFFER_SIZE , Math . min ( DEFAULT_BUFFER_SIZE , string . length ( ) ) ) ; try { parse ( new StringReader ( string ) , bufferSize ) ; } catch ( IOException exception ) { throw new RuntimeException ( exception ) ; } }
protected double defaultMaxRadius ( ) { return Math . sqrt ( NUM_ ) ; }
public char [ ] toCharArray ( ) { char [ ] newValue = new char [ count ] ; System . arraycopy ( buf , NUM_ , newValue , NUM_ , count ) ; return newValue ; }
@ Override protected int sizePendingWorkers ( ) { return _pendingWorkers . size ( ) ; }
public void insert ( Component component , int index ) { if ( index < NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } int nitems = getComponentCount ( ) ; Vector < Component > tempItems = new Vector < Component > ( ) ; for ( int i = index ; i < nitems ; i ++ ) { tempItems . addElement ( getComponent ( index ) ) ; remove ( index ) ; } add ( component ) ; for ( Component tempItem : tempItems ) { add ( tempItem ) ; } }
public static List < String > unescape ( String source , char escapeChar , char [ ] specialCharacters , char splitCharacter , int splitLimit ) { List < String > result = new LinkedList < > ( ) ; StringBuilder b = new StringBuilder ( ) ; boolean readEscape = BOOL_ ; int indexCount = - NUM_ ; for ( char c : source . toCharArray ( ) ) { indexCount ++ ; if ( readEscape ) { boolean found = BOOL_ ; if ( c == splitCharacter ) { found = BOOL_ ; b . append ( c ) ; } else if ( c == escapeChar ) { found = BOOL_ ; b . append ( c ) ; } else { for ( char s : specialCharacters ) { if ( s == c ) { found = BOOL_ ; b . append ( c ) ; break ; } } } if ( ! found ) { throw new IllegalArgumentException ( STR_ + source + STR_ + c + STR_ ) ; } readEscape = BOOL_ ; } else if ( c == escapeChar ) { readEscape = BOOL_ ; } else if ( c == splitCharacter ) { readEscape = BOOL_ ; result . add ( b . toString ( ) ) ; if ( splitLimit != - NUM_ ) { if ( result . size ( ) == splitLimit - NUM_ ) { result . add ( source . substring ( indexCount + NUM_ ) ) ; return result ; } } b = new StringBuilder ( ) ; } else { readEscape = BOOL_ ; b . append ( c ) ; } } result . add ( b . toString ( ) ) ; return result ; }
protected int drawLegend ( Canvas canvas , DefaultRenderer renderer , String [ ] titles , int left , int right , int y , int width , int height , int legendSize , Paint paint , boolean calculate ) { float size = NUM_ ; if ( renderer . isShowLegend ( ) ) { float currentX = left ; float currentY = y + height - legendSize + size ; paint . setTextAlign ( Align . LEFT ) ; paint . setTextSize ( renderer . getLegendTextSize ( ) ) ; int sLength = Math . min ( titles . length , renderer . getSeriesRendererCount ( ) ) ; for ( int i = NUM_ ; i < sLength ; i ++ ) { SimpleSeriesRenderer r = renderer . getSeriesRendererAt ( i ) ; final float lineSize = getLegendShapeWidth ( i ) ; if ( r . isShowLegendItem ( ) ) { String text = titles [ i ] ; if ( titles . length == renderer . getSeriesRendererCount ( ) ) { paint . setColor ( r . getColor ( ) ) ; } else { paint . setColor ( Color . LTGRAY ) ; } float [ ] widths = new float [ text . length ( ) ] ; paint . getTextWidths ( text , widths ) ; float sum = NUM_ ; for ( float value : widths ) { sum += value ; } float extraSize = lineSize + NUM_ + sum ; float currentWidth = currentX + extraSize ; if ( i > NUM_ && getExceed ( currentWidth , renderer , right , width ) ) { currentX = left ; currentY += renderer . getLegendTextSize ( ) ; size += renderer . getLegendTextSize ( ) ; currentWidth = currentX + extraSize ; } if ( getExceed ( currentWidth , renderer , right , width ) ) { float maxWidth = right - currentX - lineSize - NUM_ ; if ( isVertical ( renderer ) ) { maxWidth = width - currentX - lineSize - NUM_ ; } int nr = paint . breakText ( text , BOOL_ , maxWidth , widths ) ; text = text . substring ( NUM_ , nr ) + STR_ ; } if ( ! calculate ) { drawLegendShape ( canvas , r , currentX , currentY , i , paint ) ; drawString ( canvas , text , currentX + lineSize + NUM_ , currentY + NUM_ , paint ) ; } currentX += extraSize ; } } } return Math . round ( size + renderer . getLegendTextSize ( ) ) ; }
@ Override public String append ( String path , InputStream is ) throws MalformedURLException , IOException , AuthenticationException { String resp = null ; ensureValidToken ( ) ; String spec = MessageFormat . format ( STR_ , URLUtil . encodePath ( path ) , this . principal ) ; String redirectUrl = null ; HttpURLConnection conn = authenticatedURL . openConnection ( new URL ( new URL ( httpfsUrl ) , spec ) , token ) ; conn . setRequestMethod ( STR_ ) ; conn . setInstanceFollowRedirects ( BOOL_ ) ; conn . connect ( ) ; logger . info ( STR_ + conn . getHeaderField ( STR_ ) ) ; resp = result ( conn , BOOL_ ) ; if ( conn . getResponseCode ( ) == NUM_ ) redirectUrl = conn . getHeaderField ( STR_ ) ; conn . disconnect ( ) ; if ( redirectUrl != null ) { conn = authenticatedURL . openConnection ( new URL ( redirectUrl ) , token ) ; conn . setRequestMethod ( STR_ ) ; conn . setDoOutput ( BOOL_ ) ; conn . setDoInput ( BOOL_ ) ; conn . setUseCaches ( BOOL_ ) ; conn . setRequestProperty ( STR_ , STR_ ) ; final int _SIZE = is . available ( ) ; conn . setRequestProperty ( STR_ , STR_ + _SIZE ) ; conn . setFixedLengthStreamingMode ( _SIZE ) ; conn . connect ( ) ; OutputStream os = conn . getOutputStream ( ) ; copy ( is , os ) ; is . close ( ) ; os . close ( ) ; resp = result ( conn , BOOL_ ) ; conn . disconnect ( ) ; } return resp ; }
public EconomyConcurrentHashMap ( Map < ? extends K , ? extends V > m , IHashEntryHandler < K , V > handler ) { this ( Math . max ( ( int ) ( m . size ( ) / DEFAULT_LOAD_FACTOR ) + NUM_ , DEFAULT_INITIAL_CAPACITY ) , DEFAULT_LOAD_FACTOR , DEFAULT_CONCURRENCY_LEVEL , handler ) ; putAll ( m ) ; }
void addRule ( String [ ] selector , AttributeSet declaration , boolean isLinked ) { int n = selector . length ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( selector [ NUM_ ] ) ; for ( int counter = NUM_ ; counter < n ; counter ++ ) { sb . append ( STR_ ) ; sb . append ( selector [ counter ] ) ; } String selectorName = sb . toString ( ) ; Style rule = getStyle ( selectorName ) ; if ( rule == null ) { Style altRule = addStyle ( selectorName , null ) ; synchronized ( this ) { SelectorMapping mapping = getRootSelectorMapping ( ) ; for ( int i = n - NUM_ ; i >= NUM_ ; i -- ) { mapping = mapping . getChildSelectorMapping ( selector [ i ] , BOOL_ ) ; } rule = mapping . getStyle ( ) ; if ( rule == null ) { rule = altRule ; mapping . setStyle ( rule ) ; refreshResolvedRules ( selectorName , selector , rule , mapping . getSpecificity ( ) ) ; } } } if ( isLinked ) { rule = getLinkedStyle ( rule ) ; } rule . addAttributes ( declaration ) ; }
public Builder appendReadData ( byte [ ] data ) { Assertions . checkState ( data != null && data . length > NUM_ ) ; segments . add ( new Segment ( data , null ) ) ; return this ; }
private boolean isLatestDssKeystore ( TSLParserResult parseResult ) { List < String > englishSchemeInformationURIs = parseResult . getEnglishSchemeInformationURIs ( ) ; return englishSchemeInformationURIs . contains ( ojUrl ) ; }
private synchronized void initResourceBundle ( String resourceBundleName ) { String current = this . resourceBundleName ; if ( current != null ) { if ( current . equals ( resourceBundleName ) ) { return ; } else { throw new IllegalArgumentException ( STR_ + resourceBundleName + STR_ + current + STR_ ) ; } } if ( resourceBundleName != null ) { this . resourceBundle = loadResourceBundle ( resourceBundleName ) ; this . resourceBundleName = resourceBundleName ; } }
public LayerGraphicWarehouseSupport ( ) { initDrawingAttributes ( ) ; graphics = new OMGraphicList ( ) ; graphics . setTraverseMode ( OMGraphicList . LAST_ADDED_ON_TOP ) ; }
public boolean matchesNamingConvension ( ) { return packageName . matches ( JAVA_PACKAGE_CONVENSION ) ; }
void rememberFactory ( String host , RMISocketFactory factory ) { synchronized ( successTable ) { while ( hostList . size ( ) >= MaxRememberedHosts ) { successTable . remove ( hostList . elementAt ( NUM_ ) ) ; hostList . removeElementAt ( NUM_ ) ; } hostList . addElement ( host ) ; successTable . put ( host , factory ) ; } }
public void put ( String key , long value ) { if ( key != null ) { urlParams . put ( key , String . valueOf ( value ) ) ; } }
public char next ( ) { return pos < in . length ( ) ? in . charAt ( pos ++ ) : STR_ ; }
private Map . Entry < K , V > doRemoveFirstEntry ( ) { for ( Node < K , V > b , n ; ; ) { if ( ( n = ( b = head . node ) . next ) == null ) return null ; Node < K , V > f = n . next ; if ( n != b . next ) continue ; Object v = n . value ; if ( v == null ) { n . helpDelete ( b , f ) ; continue ; } if ( ! n . casValue ( v , null ) ) continue ; if ( ! n . appendMarker ( f ) || ! b . casNext ( n , f ) ) findFirst ( ) ; clearIndexToFirst ( ) ; @ SuppressWarnings ( STR_ ) V vv = ( V ) v ; return new AbstractMap . SimpleImmutableEntry < K , V > ( n . key , vv ) ; } }
public ComputeTaskCancelledException ( Throwable cause ) { this ( cause . getMessage ( ) , cause ) ; }
public static int normalize ( char [ ] src , int srcStart , int srcLimit , char [ ] dest , int destStart , int destLimit , Mode mode , int options ) { int length = mode . normalize ( src , srcStart , srcLimit , dest , destStart , destLimit , options ) ; if ( length <= ( destLimit - destStart ) ) { return length ; } else { throw new IndexOutOfBoundsException ( Integer . toString ( length ) ) ; } }
private void removeObsoleteElements ( List < String > names , Map < String , View > sharedElements , List < String > elementsToRemove ) { if ( elementsToRemove . size ( ) > NUM_ ) { names . removeAll ( elementsToRemove ) ; for ( String elementToRemove : elementsToRemove ) { sharedElements . remove ( elementToRemove ) ; } } }
public boolean isHighlightWithInvisibleEdge ( ) { return highlightWithInvisibleEdge ; }
public void removeAction ( NetworkUpdateAction action ) { actionList . remove ( action ) ; for ( UpdateManagerListener listener : listeners ) { listener . actionRemoved ( action ) ; } }
public static double bufferDistanceError ( int quadSegs ) { double alpha = Math . PI / NUM_ / quadSegs ; return NUM_ - Math . cos ( alpha / NUM_ ) ; }
public Pair < String , String > next ( ) { try { currentHeaderPosition = nextHeaderPosition ; String readHeader = nextLine ; nextHeaderPosition += readHeader . length ( ) + endOfLineBytes ; readHeader = STR_ + readHeader . substring ( NUM_ ) ; String readSequence = r . readLine ( ) ; nextHeaderPosition += readSequence . length ( ) + endOfLineBytes ; String comments = r . readLine ( ) ; nextHeaderPosition += comments . length ( ) + endOfLineBytes ; if ( comments . startsWith ( STR_ ) ) { String qualityValues = r . readLine ( ) ; nextHeaderPosition += qualityValues . length ( ) + endOfLineBytes ; } nextLine = r . readLine ( ) ; return new Pair < > ( readHeader , readSequence ) ; } catch ( IOException e ) { Basic . caught ( e ) ; } return null ; }
public void add ( Character character ) { elements . add ( character == null ? JsonNull . INSTANCE : new JsonPrimitive ( character ) ) ; }
public static boolean isValidIfd ( int ifdId ) { return ifdId == IfdId . TYPE_IFD_0 || ifdId == IfdId . TYPE_IFD_1 || ifdId == IfdId . TYPE_IFD_EXIF || ifdId == IfdId . TYPE_IFD_INTEROPERABILITY || ifdId == IfdId . TYPE_IFD_GPS ; }
public void removeChild ( Group theGroup ) { mChildren . remove ( theGroup ) ; }
protected StoragePort checkPortExistsInDB ( String nativeGuid ) throws IOException { StoragePort port = null ; List < StoragePort > portInDB = CustomQueryUtility . getActiveStoragePortByNativeGuid ( _dbClient , nativeGuid ) ; if ( portInDB != null && ! portInDB . isEmpty ( ) ) { port = portInDB . get ( NUM_ ) ; } return port ; }
public void appendSplitElement ( Fragment aSplit ) { splits . add ( aSplit ) ; }
public Iterator enumerateLiteralResultAttributes ( ) { return ( null == m_avts ) ? null : m_avts . iterator ( ) ; }
public OsmHandler ( MapBuilder meConsumer ) { osmElementProcessor = new OsmElementProcessor ( null , meConsumer ) ; }
public void close ( ) throws IOException { flushBits ( ) ; out . close ( ) ; }
public RespokeDirectConnection directConnection ( ) { if ( null != directConnectionReference ) { return directConnectionReference . get ( ) ; } else { return null ; } }
private String appendNationalNumber ( String nationalNumber ) { int prefixBeforeNationalNumberLength = prefixBeforeNationalNumber . length ( ) ; if ( shouldAddSpaceAfterNationalPrefix && prefixBeforeNationalNumberLength > NUM_ && prefixBeforeNationalNumber . charAt ( prefixBeforeNationalNumberLength - NUM_ ) != SEPARATOR_BEFORE_NATIONAL_NUMBER ) { return new String ( prefixBeforeNationalNumber ) + SEPARATOR_BEFORE_NATIONAL_NUMBER + nationalNumber ; } else { return prefixBeforeNationalNumber + nationalNumber ; } }
public void cut ( ) { copy ( ) ; deleteSelectedObjects ( ) ; }
public void stop ( ) { setLedOn ( BOOL_ ) ; if ( null != blinkFuture ) { blinkFuture . cancel ( BOOL_ ) ; } if ( null != blinkService ) { blinkService . shutdownNow ( ) ; } }
public synchronized void release ( ) { index . clear ( ) ; }
public void configure ( ) { if ( cmdPrefix != null ) { prefix = cmdPrefix . split ( STR_ ) ; } }
protected void writeTransform ( AffineTransform t ) throws IOException { pageStream . matrix ( t ) ; }
public void testSignumPositive ( ) { String a = STR_ ; int aScale = NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; assertEquals ( STR_ , NUM_ , aNumber . signum ( ) ) ; }
public PainterChain prependPainter ( Painter p ) { Painter [ ] newChain = new Painter [ chain . length + NUM_ ] ; System . arraycopy ( chain , NUM_ , newChain , NUM_ , chain . length ) ; newChain [ NUM_ ] = p ; return new PainterChain ( newChain ) ; }
@ Nullable private Operator . Kind parseOperator ( TokenStream tokens ) { if ( tokens . has ( STR_ ) ) { tokens . next ( ) ; tokens . expect ( STR_ ) ; return Operator . Kind . EQUALS ; } if ( tokens . has ( STR_ ) ) { tokens . next ( ) ; tokens . expect ( STR_ ) ; return Operator . Kind . NOT_EQUALS ; } if ( tokens . has ( STR_ ) ) { tokens . next ( ) ; if ( tokens . has ( STR_ ) ) { tokens . next ( ) ; return Operator . Kind . LESS_EQUAL ; } return Operator . Kind . LESS ; } if ( tokens . has ( STR_ ) ) { tokens . next ( ) ; if ( tokens . has ( STR_ ) ) { tokens . next ( ) ; return Operator . Kind . GREATER_EQUAL ; } return Operator . Kind . GREATER ; } return null ; }
@ Override public boolean dragTo ( Selector obj , Selector destObj , int steps ) throws UiObjectNotFoundException , NotImplementedException { return dragTo ( device . findObject ( obj . toUiSelector ( ) ) , destObj , steps ) ; }
private void queueUpSyncs ( final Cursor contactsCursor ) { ContactSyncEntry syncEntry = null ; while ( contactsCursor . moveToNext ( ) ) { if ( syncEntry == null ) { syncEntry = new ContactSyncEntry ( UPLOAD_BATCH_SIZE ) ; } final String number = contactsCursor . getString ( contactsCursor . getColumnIndex ( ContactsContract . CommonDataKinds . Phone . NUMBER ) ) ; final String name = contactsCursor . getString ( contactsCursor . getColumnIndex ( ContactsContract . CommonDataKinds . Phone . DISPLAY_NAME ) ) ; if ( ! TextUtils . isEmpty ( number ) ) { syncEntry . addNumber ( numberToNational ( number ) ) ; syncEntry . addName ( name ) ; if ( syncEntry . isFull ( ) ) { Logger . d ( TAG , STR_ ) ; mSyncQueue . add ( syncEntry ) ; syncEntry = null ; } } } }
public synchronized void removeSeries ( int index ) { mSeries . remove ( index ) ; }
public static void addGlue ( JComponent b , int layout ) { b . add ( getAxis ( b , layout ) == BoxLayout . X_AXIS ? Box . createHorizontalGlue ( ) : Box . createVerticalGlue ( ) ) ; }
public static void writeResultToFile ( Result result , String fname ) throws Exception { PrintWriter outer = new PrintWriter ( new BufferedWriter ( new FileWriter ( fname ) ) ) ; outer . write ( result . toString ( ) ) ; outer . close ( ) ; }
protected void writeBlockletInfoToFile ( List < BlockletInfoColumnar > infoList , FileChannel channel , String filePath ) throws CarbonDataWriterException { try { long currentPosition = channel . size ( ) ; CarbonFooterWriter writer = new CarbonFooterWriter ( filePath ) ; FileFooter convertFileMeta = CarbonMetadataUtil . convertFileFooter ( infoList , localCardinality . length , localCardinality , thriftColumnSchemaList , segmentProperties ) ; fillBlockIndexInfoDetails ( infoList , convertFileMeta . getNum_rows ( ) , filePath , currentPosition ) ; writer . writeFooter ( convertFileMeta , currentPosition ) ; } catch ( IOException e ) { throw new CarbonDataWriterException ( STR_ , e ) ; } }
private static void renderTree ( Tree tree , int indent , boolean parentLabelNull , boolean firstSibling , boolean leftSiblingPreTerminal , boolean topLevel , StringBuilder sb ) { boolean suppressIndent = ( parentLabelNull || ( firstSibling && tree . isPreTerminal ( ) ) || ( leftSiblingPreTerminal && tree . isPreTerminal ( ) ) ) ; if ( suppressIndent ) { sb . append ( STR_ ) ; } else { if ( ! topLevel ) { sb . append ( STR_ ) ; } for ( int i = NUM_ ; i < indent ; i ++ ) { sb . append ( STR_ ) ; } } if ( tree . isLeaf ( ) || tree . isPreTerminal ( ) ) { renderFlat ( tree , sb ) ; return ; } sb . append ( STR_ ) ; sb . append ( tree . getLabel ( ) ) ; renderChildren ( tree . getChildren ( ) , indent + NUM_ , BOOL_ , sb ) ; sb . append ( STR_ ) ; }
public static StringBuffer replaceRegex ( StringBuffer original , String regex , String replace , boolean CASE_INSENSITIVE ) { int flags = NUM_ ; if ( CASE_INSENSITIVE ) flags = Pattern . CASE_INSENSITIVE ; Pattern p = Pattern . compile ( regex , flags ) ; Matcher m = p . matcher ( original ) ; StringBuffer newSB = new StringBuffer ( ) ; boolean result = m . find ( ) ; while ( result ) { m . appendReplacement ( newSB , replace ) ; result = m . find ( ) ; } m . appendTail ( newSB ) ; return newSB ; }
public boolean equalsChars ( String a , int ai , String b , int bi , boolean ignoreCase ) { char ca = a . charAt ( ai ) ; char cb = b . charAt ( bi ) ; if ( ignoreCase ) { ca = Character . toUpperCase ( ca ) ; cb = Character . toUpperCase ( cb ) ; } return ca == cb ; }
private void adjustBackingFileLength ( byte [ ] buffer , long index ) throws IOException { if ( buffer == null || buffer . length == NUM_ ) { throw new IOException ( STR_ ) ; } long newsize = fHeader . headerSize ( ) + ( index . CHUNK_ENC_SIZE ) + CHUNK_IV_SIZE + buffer . length + CHUNK_TLEN ; if ( newsize > realLength ( ) ) { backingRandomAccessFile . setLength ( newsize ) ; } }
private static Collection < Collection < DsnNetPin > > create_ordered_subnets ( Collection < DsnNetPin > p_pin_list ) { Collection < Collection < DsnNetPin > > result = new LinkedList < Collection < DsnNetPin > > ( ) ; if ( p_pin_list . isEmpty ( ) ) { return result ; } Iterator < DsnNetPin > it = p_pin_list . iterator ( ) ; DsnNetPin prev_pin = it . next ( ) ; while ( it . hasNext ( ) ) { DsnNetPin next_pin = it . next ( ) ; Set < DsnNetPin > curr_subnet_pin_list = new java . util . TreeSet < DsnNetPin > ( ) ; curr_subnet_pin_list . add ( prev_pin ) ; curr_subnet_pin_list . add ( next_pin ) ; result . add ( curr_subnet_pin_list ) ; prev_pin = next_pin ; } return result ; }
@ Override public void run ( int connID , String [ ] args ) { if ( args . length == NUM_ ) { server . sendServerChat ( connID , STR_ ) ; server . sendServerChat ( connID , STR_ ) ; server . sendServerChat ( connID , STR_ ) ; server . sendServerChat ( connID , STR_ ) ; server . sendServerChat ( connID , STR_ ) ; server . sendServerChat ( connID , STR_ ) ; server . sendServerChat ( connID , STR_ ) ; server . sendServerChat ( connID , STR_ ) ; server . sendServerChat ( connID , STR_ ) ; } try { if ( args . length > NUM_ ) { String cmd = args [ NUM_ ] ; if ( cmd . equalsIgnoreCase ( STR_ ) ) { if ( args . length > NUM_ ) { int id = Integer . parseInt ( args [ NUM_ ] ) ; server . sendServerChat ( connID , strListNetwork ( connID , id , BOOL_ ) ) ; } else { server . sendServerChat ( connID , strListNetworks ( connID , BOOL_ ) ) ; } } else if ( cmd . equalsIgnoreCase ( STR_ ) ) { if ( args . length > NUM_ ) { int id = Integer . parseInt ( args [ NUM_ ] ) ; server . sendServerChat ( connID , strListNetwork ( connID , id , BOOL_ ) ) ; } else { server . sendServerChat ( connID , strListNetworks ( connID , BOOL_ ) ) ; } } else if ( cmd . equalsIgnoreCase ( STR_ ) ) { debug ( connID , server ) ; } else if ( cmd . equalsIgnoreCase ( STR_ ) ) { if ( args . length > NUM_ ) { int id1 = Integer . parseInt ( args [ NUM_ ] ) ; int id2 = Integer . parseInt ( args [ NUM_ ] ) ; int id3 = Integer . parseInt ( args [ NUM_ ] ) ; server . sendServerChat ( connID , strLink3 ( connID , id1 , id2 , id3 ) ) ; } else if ( args . length > NUM_ ) { int id1 = Integer . parseInt ( args [ NUM_ ] ) ; int id2 = Integer . parseInt ( args [ NUM_ ] ) ; server . sendServerChat ( connID , strLink2 ( connID , id1 , id2 ) ) ; } } else if ( cmd . equalsIgnoreCase ( STR_ ) ) { if ( args . length > NUM_ ) { int id = Integer . parseInt ( args [ NUM_ ] ) ; server . sendServerChat ( connID , strUnlinkID ( connID , id ) ) ; } else { server . sendServerChat ( connID , strUnlinkAll ( connID ) ) ; } } else { String failstr = args [ NUM_ ] ; for ( int i = NUM_ ; i < args . length ; i ++ ) { failstr += STR_ + args [ i ] ; } server . sendServerChat ( connID , STR_ + failstr + STR_ ) ; } } } catch ( NumberFormatException nfe ) { server . sendServerChat ( connID , STR_ ) ; } catch ( NullPointerException npe ) { server . sendServerChat ( connID , STR_ ) ; } catch ( IndexOutOfBoundsException ioobe ) { server . sendServerChat ( connID , STR_ ) ; } }
private char [ ] parseEntityReference ( ) throws IOException { int pos = strpos ; if ( ( ch = readCh ( ) ) == STR_ ) { int n = NUM_ ; ch = readCh ( ) ; if ( ( ch >= STR_ ) && ( ch <= STR_ ) || ch == STR_ || ch == STR_ ) { if ( ( ch >= STR_ ) && ( ch <= STR_ ) ) { while ( ( ch >= STR_ ) && ( ch <= STR_ ) ) { n = ( n . NUM_ ) + ch - STR_ ; ch = readCh ( ) ; } } else { ch = readCh ( ) ; char lch = ( char ) Character . toLowerCase ( ch ) ; while ( ( lch >= STR_ ) && ( lch <= STR_ ) || ( lch >= STR_ ) && ( lch <= STR_ ) ) { if ( lch >= STR_ && lch <= STR_ ) { n = ( n . NUM_ ) + lch - STR_ ; } else { n = ( n . NUM_ ) + lch - STR_ + NUM_ ; } ch = readCh ( ) ; lch = ( char ) Character . toLowerCase ( ch ) ; } } switch ( ch ) { case STR_ : ln ++ ; ch = readCh ( ) ; lfCount ++ ; break ; case STR_ : ln ++ ; if ( ( ch = readCh ( ) ) == STR_ ) { ch = readCh ( ) ; crlfCount ++ ; } else { crCount ++ ; } break ; case STR_ : ch = readCh ( ) ; break ; } char data [ ] = mapNumericReference ( n ) ; return data ; } addString ( STR_ ) ; if ( ! parseIdentifier ( BOOL_ ) ) { error ( STR_ ) ; strpos = pos ; char data [ ] = { STR_ , STR_ } ; return data ; } } else if ( ! parseIdentifier ( BOOL_ ) ) { char data [ ] = { STR_ } ; return data ; } boolean semicolon = BOOL_ ; switch ( ch ) { case STR_ : ln ++ ; ch = readCh ( ) ; lfCount ++ ; break ; case STR_ : ln ++ ; if ( ( ch = readCh ( ) ) == STR_ ) { ch = readCh ( ) ; crlfCount ++ ; } else { crCount ++ ; } break ; case STR_ : semicolon = BOOL_ ; ch = readCh ( ) ; break ; } String nm = getString ( pos ) ; Entity ent = dtd . getEntity ( nm ) ; if ( ! strict && ( ent == null ) ) { ent = dtd . getEntity ( nm . toLowerCase ( ) ) ; } if ( ( ent == null ) || ! ent . isGeneral ( ) ) { if ( nm . length ( ) == NUM_ ) { error ( STR_ , nm ) ; return new char [ NUM_ ] ; } String str = STR_ + nm + ( semicolon ? STR_ : STR_ ) ; char b [ ] = new char [ str . length ( ) ] ; str . getChars ( NUM_ , b . length , b , NUM_ ) ; return b ; } return ent . getData ( ) ; }
private static String createJsMethodInvocationExpression ( String methodName , boolean isStatic , String ... paramNames ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( isStatic ? WND : THIS ) ; sb . append ( STR_ ) ; sb . append ( methodName ) ; sb . append ( STR_ ) ; for ( int i = NUM_ ; i < paramNames . length ; i ++ ) { if ( i != NUM_ ) { sb . append ( STR_ ) ; } sb . append ( paramNames [ i ] ) ; } sb . append ( STR_ ) ; return sb . toString ( ) ; }
public void doDoubleClickAction ( ) { doDoubleClickAction ( null ) ; }
public static Node serializableInstance ( ) { return new GraphNode ( STR_ ) ; }
protected void dropTables ( List < String > dropTableNames , SQLiteDatabase db ) { if ( dropTableNames != null && ! dropTableNames . isEmpty ( ) ) { String [ ] dropTableSQLS = new String [ dropTableNames . size ( ) ] ; for ( int i = NUM_ ; i < dropTableSQLS . length ; i ++ ) { dropTableSQLS [ i ] = generateDropTableSQL ( dropTableNames . get ( i ) ) ; } execute ( dropTableSQLS , db ) ; } }
private Segment createDiskSegment ( SegmentDescriptor descriptor ) { File segmentFile = SegmentFile . createSegmentFile ( name , storage . directory ( ) , descriptor . id ( ) , descriptor . version ( ) ) ; Buffer buffer = FileBuffer . allocate ( segmentFile , Math . min ( DEFAULT_BUFFER_SIZE , descriptor . maxSegmentSize ( ) ) , Integer . MAX_VALUE ) ; descriptor . copyTo ( buffer ) ; Segment segment = new Segment ( new SegmentFile ( segmentFile ) , buffer . slice ( ) , descriptor , createIndex ( descriptor ) , new OffsetPredicate ( ) , serializer . clone ( ) , this ) ; LOGGER . debug ( STR_ , segment ) ; return segment ; }
public Boolean exists ( String email ) { for ( Person person : people ) { if ( email . equals ( person . getEmail ( ) ) ) { return BOOL_ ; } } return BOOL_ ; }
public synchronized boolean removeAll ( Collection c ) { Object [ ] elements = getArray ( ) ; int len = elements . length ; if ( len != NUM_ ) { int newlen = NUM_ ; Object [ ] temp = new Object [ len ] ; for ( int i = NUM_ ; i < len ; ++ i ) { Object element = elements [ i ] ; if ( ! c . contains ( element ) ) temp [ newlen ++ ] = element ; } if ( newlen != len ) { setArray ( copyOfRange ( temp , NUM_ , newlen , Object [ ] . class ) ) ; return BOOL_ ; } } return BOOL_ ; }
public void assertURIEquals ( String assertID , String scheme , String path , String host , String file , String name , String query , String fragment , Boolean isAbsolute , String actual ) { assertNotNull ( assertID , actual ) ; String uri = actual ; int lastPound = actual . lastIndexOf ( STR_ ) ; String actualFragment = STR_ ; if ( lastPound != - NUM_ ) { uri = actual . substring ( NUM_ , lastPound ) ; actualFragment = actual . substring ( lastPound + NUM_ ) ; } if ( fragment != null ) { assertEquals ( assertID , fragment , actualFragment ) ; } int lastQuestion = uri . lastIndexOf ( STR_ ) ; String actualQuery = STR_ ; if ( lastQuestion != - NUM_ ) { uri = actual . substring ( NUM_ , lastQuestion ) ; actualQuery = actual . substring ( lastQuestion + NUM_ ) ; } if ( query != null ) { assertEquals ( assertID , query , actualQuery ) ; } int firstColon = uri . indexOf ( STR_ ) ; int firstSlash = uri . indexOf ( STR_ ) ; String actualPath = uri ; String actualScheme = STR_ ; if ( firstColon != - NUM_ && firstColon < firstSlash ) { actualScheme = uri . substring ( NUM_ , firstColon ) ; actualPath = uri . substring ( firstColon + NUM_ ) ; } if ( scheme != null ) { assertEquals ( assertID , scheme , actualScheme ) ; } if ( path != null ) { assertEquals ( assertID , path , actualPath ) ; } if ( host != null ) { String actualHost = STR_ ; if ( actualPath . startsWith ( STR_ ) ) { int termSlash = actualPath . indexOf ( STR_ , NUM_ ) ; actualHost = actualPath . substring ( NUM_ , termSlash ) ; } assertEquals ( assertID , host , actualHost ) ; } String actualFile = actualPath ; if ( file != null || name != null ) { int finalSlash = actualPath . lastIndexOf ( STR_ ) ; if ( finalSlash != - NUM_ ) { actualFile = actualPath . substring ( finalSlash + NUM_ ) ; } if ( file != null ) { assertEquals ( assertID , file , actualFile ) ; } } if ( name != null ) { String actualName = actualFile ; int finalPeriod = actualFile . lastIndexOf ( STR_ ) ; if ( finalPeriod != - NUM_ ) { actualName = actualFile . substring ( NUM_ , finalPeriod ) ; } assertEquals ( assertID , name , actualName ) ; } if ( isAbsolute != null ) { assertEquals ( assertID , isAbsolute . booleanValue ( ) , actualPath . startsWith ( STR_ ) || actualPath . startsWith ( STR_ ) ) ; } }
private double maxIgnoreNaN ( double a , double b ) { if ( Double . isNaN ( a ) ) { return b ; } if ( Double . isNaN ( b ) ) { return a ; } else { return Math . max ( a , b ) ; } }
public void crabDownDirBlockForModification ( BlockId blk ) { lockTbl . xLock ( blk , txNum ) ; writenIndexBlks . add ( blk ) ; }
private static void removeReferenceToConnection ( final HttpConnectionWithReference connection ) { synchronized ( REFERENCE_TO_CONNECTION_SOURCE ) { REFERENCE_TO_CONNECTION_SOURCE . remove ( connection . reference ) ; } }
public boolean matchesWord ( ) { return ! isEmpty ( ) && Character . isLetterOrDigit ( queue . charAt ( pos ) ) ; }
public VacuumEnvironment ( ) { Random r = new Random ( ) ; envState = new VacuumEnvironmentState ( NUM_ == r . nextInt ( NUM_ ) ? LocationState . Clean : LocationState . Dirty , NUM_ == r . nextInt ( NUM_ ) ? LocationState . Clean : LocationState . Dirty ) ; }
public void generate ( BatchEnvironment env , ClassDefinition cdef , File destDir ) { RemoteClass remoteClass = RemoteClass . forClass ( env , cdef ) ; if ( remoteClass == null ) return ; RMIGenerator gen ; try { gen = new RMIGenerator ( env , cdef , destDir , remoteClass , version ) ; } catch ( ClassNotFound e ) { env . error ( NUM_ , STR_ , e . name ) ; return ; } gen . generate ( ) ; }
public BaseViewHolder addOnLongClickListener ( int viewId ) { itemChildLongClickViewIds . add ( viewId ) ; return this ; }
public void remove ( final CreatureRespawnPoint point ) { respawnPoints . remove ( point ) ; }
public Photo ( File d , File f ) throws IOException , NumberFormatException { ExtendedExifInterface exif = new ExtendedExifInterface ( f . toString ( ) ) ; String lonStr = exif . getAttribute ( ExifInterface . TAG_GPS_LONGITUDE ) ; if ( lonStr == null ) { throw new IOException ( STR_ ) ; } float lonf = convertToDegree ( lonStr ) ; String lonRef = exif . getAttribute ( ExifInterface . TAG_GPS_LONGITUDE_REF ) ; if ( lonRef != null && ! lonRef . equals ( STR_ ) ) { lonf = - lonf ; } float latf = convertToDegree ( exif . getAttribute ( ExifInterface . TAG_GPS_LATITUDE ) ) ; String latRef = exif . getAttribute ( ExifInterface . TAG_GPS_LATITUDE_REF ) ; if ( latRef != null && ! latRef . equals ( STR_ ) ) { latf = - latf ; } lat = ( int ) ( latf . NUM_ ) ; lon = ( int ) ( lonf . NUM_ ) ; Log . d ( STR_ , STR_ + lat + STR_ + lon ) ; ref = d . getAbsolutePath ( ) + STR_ + f . getName ( ) ; String dir = exif . getAttribute ( ExtendedExifInterface . TAG_GPS_IMG_DIRECTION ) ; if ( dir != null ) { direction = ( int ) Double . parseDouble ( dir ) ; directionRef = exif . getAttribute ( ExtendedExifInterface . TAG_GPS_IMG_DIRECTION_REF ) ; Log . d ( STR_ , STR_ + dir + STR_ + direction + STR_ + directionRef ) ; } }
public static long bytesToLong ( final byte [ ] bytes ) { final ByteBuffer buffer = ByteBuffer . allocate ( NUM_ ) ; buffer . put ( bytes , NUM_ , NUM_ ) ; buffer . flip ( ) ; return buffer . getLong ( ) ; }
protected int unicodeEscapeLexer ( int c ) throws IOException { int ret = NUM_ ; c = in . read ( ) ; code . clear ( ) ; try { for ( int i = NUM_ ; i < NUM_ ; i ++ ) { c = in . read ( ) ; if ( isEndOfFile ( c ) || isEndOfLine ( c ) ) { throw new NumberFormatException ( STR_ ) ; } code . append ( ( char ) c ) ; } ret = Integer . parseInt ( code . toString ( ) , NUM_ ) ; } catch ( NumberFormatException e ) { throw new IOException ( STR_ + getLineNumber ( ) + STR_ + code . toString ( ) + STR_ + e . toString ( ) ) ; } return ret ; }
@ Override public void mouseEntered ( MouseEvent evt ) { delegate . mouseMoved ( evt ) ; }
public static String removeFormatting ( String line ) { int length = line . length ( ) ; StringBuilder buffer = new StringBuilder ( ) ; for ( int i = NUM_ ; i < length ; i ++ ) { char ch = line . charAt ( i ) ; if ( ch != STR_ && ch != STR_ && ch != STR_ && ch != STR_ ) buffer . append ( ch ) ; } return buffer . toString ( ) ; }
public void testNegPosFirstShorter ( ) { String numA = STR_ ; String numB = STR_ ; String res = STR_ ; BigInteger aNumber = new BigInteger ( numA ) ; BigInteger bNumber = new BigInteger ( numB ) ; BigInteger result = aNumber . xor ( bNumber ) ; assertTrue ( res . equals ( result . toString ( ) ) ) ; }
public void print ( ) { Object [ ] iterChargingTimes = chargingTimes . toArray ( ) ; Arrays . sort ( iterChargingTimes ) ; for ( int i = NUM_ ; i < iterChargingTimes . length ; i ++ ) { ChargeLog curItem = ( ChargeLog ) iterChargingTimes [ i ] ; curItem . print ( ) ; } }
public boolean isEmpty ( ) { return rdns . isEmpty ( ) ; }
private void writeLocalCSV ( MedtronicSensorRecord mostRecentData , Context context ) { try { if ( mostRecentData == null || mostRecentData . bGValue == null ) log . debug ( STR_ ) ; else log . debug ( STR_ + mostRecentData . bGValue ) ; ObjectOutputStream oos = new ObjectOutputStream ( new FileOutputStream ( new File ( context . getFilesDir ( ) , STR_ ) ) ) ; oos . writeObject ( mostRecentData ) ; oos . flush ( ) ; oos . close ( ) ; } catch ( Exception e ) { Log . e ( TAG , STR_ , e ) ; log . error ( STR_ , e ) ; } }
public ServiceConfig createOrganizationConfig ( String orgName , Map attrs ) throws SMSException , SSOException { validateSSM ( ) ; ServiceSchemaImpl ss = ssm . getSchema ( SchemaType . ORGANIZATION ) ; if ( ss == null ) { String [ ] args = { serviceName } ; throw ( new SMSException ( IUMSConstants . UMS_BUNDLE_NAME , STR_ , args ) ) ; } String orgdn = DNMapper . orgNameToDN ( orgName ) ; CreateServiceConfig . checkBaseNodesForOrg ( token , orgdn , serviceName , version ) ; String orgDN = scm . constructServiceConfigDN ( SMSUtils . DEFAULT , CreateServiceConfig . ORG_CONFIG_NODE , orgdn ) ; try { CachedSMSEntry cEntry = CachedSMSEntry . getInstance ( token , orgDN ) ; if ( cEntry . isDirty ( ) ) { cEntry . refresh ( ) ; } if ( cEntry . isNewEntry ( ) ) { CreateServiceConfig . createSubConfigEntry ( token , orgDN , ss , null , null , attrs , orgName ) ; if ( ServiceManager . isCoexistenceMode ( ) ) { String smsDN = DNMapper . orgNameToDN ( orgName ) ; OrgConfigViaAMSDK amsdk = new OrgConfigViaAMSDK ( token , DNMapper . realmNameToAMSDKName ( smsDN ) , smsDN ) ; amsdk . assignService ( serviceName ) ; } } else if ( attrs != null && ! attrs . isEmpty ( ) ) { ServiceConfig sc = getOrganizationConfig ( orgName , null ) ; sc . setAttributes ( attrs ) ; } } catch ( ServiceAlreadyExistsException slee ) { } return ( getOrganizationConfig ( orgName , null ) ) ; }
public void deleteAuthenticationDomain ( String realm , String cotName ) throws AMConsoleException { String [ ] param = { realm , cotName } ; logEvent ( STR_ , param ) ; try { CircleOfTrustManager manager = getCircleOfTrustManager ( ) ; manager . deleteCircleOfTrust ( realm , cotName ) ; logEvent ( STR_ , param ) ; } catch ( COTException e ) { String strError = getErrorString ( e ) ; String [ ] paramsEx = { realm , cotName , strError } ; logEvent ( STR_ , paramsEx ) ; throw new AMConsoleException ( strError ) ; } }
protected void addSourceCodeRemark ( TestSolution testSolution , Element element , String messageCode , EvidenceElement evidenceElement ) { if ( evidenceElement != null ) { Collection < EvidenceElement > evidenceElementList = new ArrayList < > ( ) ; evidenceElementList . add ( evidenceElement ) ; processRemarkService . addSourceCodeRemarkOnElement ( testSolution , element , messageCode , evidenceElementList ) ; } else { processRemarkService . addSourceCodeRemarkOnElement ( testSolution , element , messageCode ) ; } }
void eventPreModify ( ActionType type , long position , boolean isSingle ) { if ( type != currentActionType || ! isSingle || System . currentTimeMillis ( ) - previousTime > MERGE_TIME || ( type == ActionType . INSERT || type == ActionType . OVERWRITE ) && actionExclusiveEnd ( ) != position || type == ActionType . DELETE && actionPosition ( ) != position && actionPosition ( ) - NUM_ != position ) { startAction ( type , isSingle ) ; } else { isBackspace = actionPosition ( ) > position ; } if ( isSingle && type == ActionType . INSERT ) { updateNewRange ( position ) ; previousTime = System . currentTimeMillis ( ) ; } }
private byte [ ] decodePEM ( InputStream inStream , byte [ ] boundary_suffix ) throws IOException { int ch ; for ( int i = NUM_ ; i < PEM_BEGIN . length ; ++ i ) { if ( PEM_BEGIN [ i ] != ( ch = inStream . read ( ) ) ) { throw new IOException ( STR_ + ( ( boundary_suffix == null ) ? STR_ : new String ( boundary_suffix ) ) + STR_ ) ; } } if ( boundary_suffix == null ) { while ( ( ch = inStream . read ( ) ) != STR_ ) { if ( ch == - NUM_ ) { throw new IOException ( STR_ ) ; } } } else { for ( int i = NUM_ ; i < boundary_suffix . length ; i ++ ) { if ( boundary_suffix [ i ] != inStream . read ( ) ) { throw new IOException ( STR_ + new String ( boundary_suffix ) + STR_ ) ; } } if ( ( ch = inStream . read ( ) ) == STR_ ) { ch = inStream . read ( ) ; } if ( ch != STR_ ) { throw new IOException ( STR_ + STR_ ) ; } } int size = NUM_ ; byte [ ] buff = new byte [ size ] ; int index = NUM_ ; while ( ( ch = inStream . read ( ) ) != STR_ ) { if ( ch == - NUM_ ) { throw new IOException ( STR_ ) ; } buff [ index ++ ] = ( byte ) ch ; if ( index == size ) { byte [ ] newbuff = new byte [ size + NUM_ ] ; System . arraycopy ( buff , NUM_ , newbuff , NUM_ , size ) ; buff = newbuff ; size += NUM_ ; } } if ( buff [ index - NUM_ ] != STR_ ) { throw new IOException ( STR_ + STR_ ) ; } for ( int i = NUM_ ; i < PEM_END . length ; ++ i ) { if ( PEM_END [ i ] != inStream . read ( ) ) { throw badEnd ( boundary_suffix ) ; } } if ( boundary_suffix == null ) { while ( ( ( ch = inStream . read ( ) ) != - NUM_ ) && ( ch != STR_ ) && ( ch != STR_ ) ) { } } else { for ( int i = NUM_ ; i < boundary_suffix . length ; i ++ ) { if ( boundary_suffix [ i ] != inStream . read ( ) ) { throw badEnd ( boundary_suffix ) ; } } } inStream . mark ( NUM_ ) ; while ( ( ( ch = inStream . read ( ) ) != - NUM_ ) && ( ch == STR_ || ch == STR_ ) ) { inStream . mark ( NUM_ ) ; } inStream . reset ( ) ; buff = Base64 . decode ( buff , index ) ; if ( buff == null ) { throw new IOException ( STR_ ) ; } return buff ; }
void saveAsync ( DocumentEntity entity , Consumer < DocumentEntity > callBack ) throws ExecuteAsyncQueryException , UnsupportedOperationException ;
public boolean markSupported ( ) { return fInputStream . markSupported ( ) ; }
private static int encodeText ( CharSequence msg , int startpos , int count , StringBuilder sb , int initialSubmode ) { StringBuilder tmp = new StringBuilder ( count ) ; int submode = initialSubmode ; int idx = NUM_ ; while ( BOOL_ ) { char ch = msg . charAt ( startpos + idx ) ; switch ( submode ) { case SUBMODE_ALPHA : if ( isAlphaUpper ( ch ) ) { if ( ch == STR_ ) { tmp . append ( ( char ) NUM_ ) ; } else { tmp . append ( ( char ) ( ch - NUM_ ) ) ; } } else { if ( isAlphaLower ( ch ) ) { submode = SUBMODE_LOWER ; tmp . append ( ( char ) NUM_ ) ; continue ; } else if ( isMixed ( ch ) ) { submode = SUBMODE_MIXED ; tmp . append ( ( char ) NUM_ ) ; continue ; } else { tmp . append ( ( char ) NUM_ ) ; tmp . append ( ( char ) PUNCTUATION [ ch ] ) ; break ; } } break ; case SUBMODE_LOWER : if ( isAlphaLower ( ch ) ) { if ( ch == STR_ ) { tmp . append ( ( char ) NUM_ ) ; } else { tmp . append ( ( char ) ( ch - NUM_ ) ) ; } } else { if ( isAlphaUpper ( ch ) ) { tmp . append ( ( char ) NUM_ ) ; tmp . append ( ( char ) ( ch - NUM_ ) ) ; break ; } else if ( isMixed ( ch ) ) { submode = SUBMODE_MIXED ; tmp . append ( ( char ) NUM_ ) ; continue ; } else { tmp . append ( ( char ) NUM_ ) ; tmp . append ( ( char ) PUNCTUATION [ ch ] ) ; break ; } } break ; case SUBMODE_MIXED : if ( isMixed ( ch ) ) { tmp . append ( ( char ) MIXED [ ch ] ) ; } else { if ( isAlphaUpper ( ch ) ) { submode = SUBMODE_ALPHA ; tmp . append ( ( char ) NUM_ ) ; continue ; } else if ( isAlphaLower ( ch ) ) { submode = SUBMODE_LOWER ; tmp . append ( ( char ) NUM_ ) ; continue ; } else { if ( startpos + idx + NUM_ < count ) { char next = msg . charAt ( startpos + idx + NUM_ ) ; if ( isPunctuation ( next ) ) { submode = SUBMODE_PUNCTUATION ; tmp . append ( ( char ) NUM_ ) ; continue ; } } tmp . append ( ( char ) NUM_ ) ; tmp . append ( ( char ) PUNCTUATION [ ch ] ) ; } } break ; default : if ( isPunctuation ( ch ) ) { tmp . append ( ( char ) PUNCTUATION [ ch ] ) ; } else { submode = SUBMODE_ALPHA ; tmp . append ( ( char ) NUM_ ) ; continue ; } } idx ++ ; if ( idx >= count ) { break ; } } char h = NUM_ ; int len = tmp . length ( ) ; for ( int i = NUM_ ; i < len ; i ++ ) { boolean odd = ( i % NUM_ ) != NUM_ ; if ( odd ) { h = ( char ) ( ( h . NUM_ ) + tmp . charAt ( i ) ) ; sb . append ( h ) ; } else { h = tmp . charAt ( i ) ; } } if ( ( len % NUM_ ) != NUM_ ) { sb . append ( ( char ) ( ( h . NUM_ ) + NUM_ ) ) ; } return submode ; }
public String resolveParentRelationName ( String parentName , Object parent , String childName , Object child ) { return parentName ; }
public ByteColumn ( int nrows , int capacity , byte defaultValue ) { super ( byte . class , new Byte ( defaultValue ) ) ; if ( capacity < nrows ) { throw new IllegalArgumentException ( STR_ ) ; } m_values = new byte [ capacity ] ; Arrays . fill ( m_values , defaultValue ) ; m_size = nrows ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
public RelNode convertSelect ( SqlSelect select , boolean top ) { final SqlValidatorScope selectScope = validator . getWhereScope ( select ) ; final Blackboard bb = createBlackboard ( selectScope , null , top ) ; convertSelectImpl ( bb , select ) ; return bb . root ; }
public static Object executeScript ( String filePath , String functionName , Map < String , Object > context ) { return executeScript ( filePath , functionName , context , new Object [ ] { context } ) ; }
public XercesHTML2DocumentBuilderFactory ( DocumentBuilderSetting [ ] settings ) throws DOMTestIncompatibleException { super ( settings ) ; try { ClassLoader classLoader = ClassLoader . getSystemClassLoader ( ) ; Class htmlBuilderClass = classLoader . loadClass ( STR_ ) ; htmlBuilderConstructor = htmlBuilderClass . getConstructor ( NO_CLASSES ) ; getHTMLDocumentMethod = htmlBuilderClass . getMethod ( STR_ , NO_CLASSES ) ; Class htmlDOMImpl = classLoader . loadClass ( STR_ ) ; Method method = htmlDOMImpl . getMethod ( STR_ , NO_CLASSES ) ; domImpl = ( DOMImplementation ) method . invoke ( null , NO_OBJECTS ) ; Class saxFactoryClass = classLoader . loadClass ( STR_ ) ; factory = ( SAXParserFactory ) saxFactoryClass . newInstance ( ) ; } catch ( InvocationTargetException ex ) { throw new DOMTestIncompatibleException ( ex . getTargetException ( ) , null ) ; } catch ( Exception ex ) { throw new DOMTestIncompatibleException ( ex , null ) ; } if ( settings != null ) { for ( int i = NUM_ ; i < settings . length ; i ++ ) { } } try { factory . newSAXParser ( ) ; } catch ( ParserConfigurationException ex ) { throw new DOMTestIncompatibleException ( ex , null ) ; } catch ( SAXException ex ) { throw new DOMTestIncompatibleException ( ex , null ) ; } }
private static String formatSampleRate ( int rate ) { return MHZ_FORMATTER . format ( ( double ) rate / NUM_ ) ; }
public final boolean isClosed ( ) { return closed . get ( ) ; }
void start ( ) { this . running = BOOL_ ; Thread thread = new Thread ( this , STR_ + hashCode ( ) ) ; thread . setDaemon ( BOOL_ ) ; thread . start ( ) ; }
TypeSimplifier ( Types typeUtils , String packageName , Set < TypeMirror > types , TypeMirror base ) { this . typeUtils = typeUtils ; Set < TypeMirror > typesPlusBase = new TypeMirrorSet ( types ) ; if ( base != null ) { typesPlusBase . add ( base ) ; } Set < TypeMirror > referenced = referencedClassTypes ( typeUtils , typesPlusBase ) ; Set < TypeMirror > defined = nonPrivateDeclaredTypes ( typeUtils , base ) ; this . imports = findImports ( typeUtils , packageName , referenced , defined ) ; }
public static byte [ ] escape ( final byte [ ] bytes ) { final byte [ ] temp = new byte [ NUM_ . bytes . length ] ; int currentPosition = NUM_ ; for ( final byte b : bytes ) { if ( b == ESCAPE_CHAR ) { temp [ currentPosition ++ ] = ESCAPE_CHAR ; temp [ currentPosition ++ ] = REPLACEMENT_CHAR ; } else if ( b == DELIMITER ) { temp [ currentPosition ++ ] = ESCAPE_CHAR ; temp [ currentPosition ++ ] = ESCAPE_CHAR ; } else { temp [ currentPosition ++ ] = b ; } } final byte [ ] escaped = new byte [ currentPosition ] ; System . arraycopy ( temp , NUM_ , escaped , NUM_ , currentPosition ) ; return escaped ; }
public final native String name ( ) ;
protected void drawChartValuesText ( Canvas canvas , XYSeries series , XYSeriesRenderer renderer , Paint paint , List < Float > points , int seriesIndex , int startIndex ) { if ( points . size ( ) > NUM_ ) { float previousPointX = points . get ( NUM_ ) ; float previousPointY = points . get ( NUM_ ) ; for ( int k = NUM_ ; k < points . size ( ) ; k += NUM_ ) { if ( k == NUM_ ) { if ( Math . abs ( points . get ( NUM_ ) - points . get ( NUM_ ) ) > renderer . getDisplayChartValuesDistance ( ) || Math . abs ( points . get ( NUM_ ) - points . get ( NUM_ ) ) > renderer . getDisplayChartValuesDistance ( ) ) { drawText ( canvas , getLabel ( renderer . getChartValuesFormat ( ) , series . getY ( startIndex ) ) , points . get ( NUM_ ) , points . get ( NUM_ ) - renderer . getChartValuesSpacing ( ) , paint , NUM_ ) ; drawText ( canvas , getLabel ( renderer . getChartValuesFormat ( ) , series . getY ( startIndex + NUM_ ) ) , points . get ( NUM_ ) , points . get ( NUM_ ) - renderer . getChartValuesSpacing ( ) , paint , NUM_ ) ; previousPointX = points . get ( NUM_ ) ; previousPointY = points . get ( NUM_ ) ; } } else if ( k > NUM_ ) { if ( Math . abs ( points . get ( k ) - previousPointX ) > renderer . getDisplayChartValuesDistance ( ) || Math . abs ( points . get ( k + NUM_ ) - previousPointY ) > renderer . getDisplayChartValuesDistance ( ) ) { drawText ( canvas , getLabel ( renderer . getChartValuesFormat ( ) , series . getY ( startIndex + k / NUM_ ) ) , points . get ( k ) , points . get ( k + NUM_ ) - renderer . getChartValuesSpacing ( ) , paint , NUM_ ) ; previousPointX = points . get ( k ) ; previousPointY = points . get ( k + NUM_ ) ; } } } } else { for ( int k = NUM_ ; k < points . size ( ) ; k += NUM_ ) { drawText ( canvas , getLabel ( renderer . getChartValuesFormat ( ) , series . getY ( startIndex + k / NUM_ ) ) , points . get ( k ) , points . get ( k + NUM_ ) - renderer . getChartValuesSpacing ( ) , paint , NUM_ ) ; } } }
public static String toString ( Document hostDoc ) throws IOException { try { StringWriter out = new StringWriter ( ) ; DOMSource domSource = new DOMSource ( hostDoc ) ; StreamResult streamResult = new StreamResult ( out ) ; TransformerFactory tf = TransformerFactory . newInstance ( ) ; Transformer serializer = tf . newTransformer ( ) ; serializer . setOutputProperty ( OutputKeys . ENCODING , ENC . name ( ) ) ; serializer . setOutputProperty ( OutputKeys . METHOD , STR_ ) ; serializer . setOutputProperty ( OutputKeys . INDENT , STR_ ) ; serializer . setOutputProperty ( OutputKeys . DOCTYPE_PUBLIC , HtmlDomUtil . HTML_STRICT ) ; serializer . transform ( domSource , streamResult ) ; return out . toString ( ) ; } catch ( TransformerException e ) { IOException r = new IOException ( STR_ ) ; r . initCause ( e ) ; throw r ; } }
public MongoClient clientForMembers ( ServerAddress ... seeds ) { List < ServerAddress > addresses = new ArrayList < > ( ) ; for ( ServerAddress seedAddress : seeds ) { if ( seedAddress != null ) addresses . add ( seedAddress ) ; } return clientForMembers ( addresses ) ; }
public static boolean stringToBooleanValue ( String str ) throws ExpressionException { str = StringUtil . toLowerCase ( str . trim ( ) ) ; if ( str . equals ( STR_ ) || str . equals ( STR_ ) ) return BOOL_ ; else if ( str . equals ( STR_ ) || str . equals ( STR_ ) ) return BOOL_ ; throw new CasterException ( STR_ + str + STR_ ) ; }
public boolean hasMoreWork ( ) { return ! workList . isEmpty ( ) ; }
protected synchronized void engineSetSeed ( byte [ ] seed ) { if ( seed == null ) { throw new NullPointerException ( STR_ ) ; } if ( state == NEXT_BYTES ) { System . arraycopy ( copies , HASHCOPY_OFFSET , this . seed , HASH_OFFSET , EXTRAFRAME_OFFSET ) ; } state = SET_SEED ; if ( seed . length != NUM_ ) { updateSeed ( seed ) ; } }
public void generateClassFile ( OutputStream os ) { ClassWriter cw = new SootASMClassWriter ( ClassWriter . COMPUTE_FRAMES ) ; cv = cw ; generateByteCode ( ) ; try { os . write ( cw . toByteArray ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( STR_ , e ) ; } }
private static boolean useCompactFontFormat ( Map < String , Object > args , int compatibilityVersion ) { String value = ( String ) args . get ( EMBEDASCFF ) ; boolean useCFF = BOOL_ ; if ( compatibilityVersion < MxmlConfiguration . VERSION_4_0 ) useCFF = BOOL_ ; if ( value != null ) { useCFF = Boolean . parseBoolean ( value . trim ( ) ) ; } return useCFF ; }
public static void main ( String [ ] args ) { new GeneratorTester ( args ) ; }
private String mosesize ( String feature ) { if ( joshuaConfiguration . moses ) { if ( feature . startsWith ( STR_ ) || feature . startsWith ( STR_ ) ) return feature . replace ( STR_ , STR_ ) ; } return feature ; }
public static int calcTextHeight ( Paint paint , String demoText ) { Rect r = new Rect ( ) ; paint . getTextBounds ( demoText , NUM_ , demoText . length ( ) , r ) ; return r . height ( ) ; }
private void checkShutdown ( ) { synchronized ( mux ) { if ( isBeingShutdown ) throw new RejectedExecutionException ( STR_ ) ; } }
public void clear ( ) { oredCriteria . clear ( ) ; orderByClause = null ; distinct = BOOL_ ; }
private static final void checkQueueForDependenciesAndExecuteUnblockedTasks ( ) { List < ProgressThread > toRemove = new LinkedList < > ( ) ; synchronized ( LOCK ) { for ( ProgressThread pg : queuedThreads ) { if ( ! pg . isBlockedByDependencies ( ) ) { if ( ! pg . isWaiting ( ) ) { toRemove . add ( pg ) ; EXECUTOR . execute ( pg . makeWrapper ( ) ) ; } } } } for ( ProgressThread pg : toRemove ) { synchronized ( LOCK ) { queuedThreads . remove ( pg ) ; } } }
private static short CallShortMethodV ( JNIEnvironment env , int objJREF , int methodID , Address argAddress ) throws Exception { if ( traceJNI ) VM . sysWrite ( STR_ ) ; RuntimeEntrypoints . checkJNICountDownToGC ( ) ; try { Object obj = env . getJNIRef ( objJREF ) ; Object returnObj = JNIHelpers . invokeWithVarArg ( obj , methodID , argAddress , TypeReference . Short , BOOL_ ) ; return Reflection . unwrapShort ( returnObj ) ; } catch ( Throwable unexpected ) { if ( traceJNI ) unexpected . printStackTrace ( System . err ) ; env . recordException ( unexpected ) ; return NUM_ ; } }
public static void drawVerticalMarginIndicator ( Graphics2D g , String text , int x , int y1 , int y2 ) { if ( y1 > y2 ) { int temp = y1 ; y1 = y2 ; y2 = temp ; } if ( text == null ) { g . drawLine ( x , y1 , x , y2 ) ; g . drawLine ( x , y1 , x - CONNECTION_ARROW_SIZE , y1 + CONNECTION_ARROW_SIZE ) ; g . drawLine ( x , y1 , x + CONNECTION_ARROW_SIZE , y1 + CONNECTION_ARROW_SIZE ) ; g . drawLine ( x , y2 , x - CONNECTION_ARROW_SIZE , y2 - CONNECTION_ARROW_SIZE ) ; g . drawLine ( x , y2 , x + CONNECTION_ARROW_SIZE , y2 - CONNECTION_ARROW_SIZE ) ; return ; } Canvas c = new Canvas ( ) ; FontMetrics fm = c . getFontMetrics ( sFont ) ; g . setFont ( sFont ) ; int padding = NUM_ ; Rectangle2D bounds = fm . getStringBounds ( text , g ) ; int th = ( int ) bounds . getHeight ( ) ; int offset = NUM_ . CONNECTION_ARROW_SIZE ; int h = ( ( y2 - y1 ) - ( th + NUM_ . padding ) ) / NUM_ ; if ( h <= padding ) { g . drawLine ( x , y1 , x , y2 ) ; g . drawString ( text , ( int ) ( x - bounds . getWidth ( ) / NUM_ ) + offset , y2 - h - padding ) ; g . drawLine ( x - CONNECTION_ARROW_SIZE , y1 , x + CONNECTION_ARROW_SIZE , y1 ) ; g . drawLine ( x - CONNECTION_ARROW_SIZE , y2 , x + CONNECTION_ARROW_SIZE , y2 ) ; } else { g . drawLine ( x , y1 , x , y1 + h ) ; g . drawLine ( x , y2 - h , x , y2 ) ; g . drawString ( text , ( int ) ( x - bounds . getWidth ( ) / NUM_ ) , y2 - h - padding ) ; g . drawLine ( x , y1 , x - CONNECTION_ARROW_SIZE , y1 + CONNECTION_ARROW_SIZE ) ; g . drawLine ( x , y1 , x + CONNECTION_ARROW_SIZE , y1 + CONNECTION_ARROW_SIZE ) ; g . drawLine ( x , y2 , x - CONNECTION_ARROW_SIZE , y2 - CONNECTION_ARROW_SIZE ) ; g . drawLine ( x , y2 , x + CONNECTION_ARROW_SIZE , y2 - CONNECTION_ARROW_SIZE ) ; } }
public void fireIndexedPropertyChange ( String propertyName , int index , boolean oldValue , boolean newValue ) { if ( oldValue != newValue ) { fireIndexedPropertyChange ( propertyName , index , Boolean . valueOf ( oldValue ) , Boolean . valueOf ( newValue ) ) ; } }
protected void removeMarkers ( ) { for ( int i = markerImage . size ( ) ; i > NUM_ ; i -- ) { LocoIcon il = markerImage . get ( i - NUM_ ) ; if ( ( il != null ) && ( il . isActive ( ) ) ) { markerImage . remove ( i - NUM_ ) ; il . remove ( ) ; il . dispose ( ) ; setDirty ( BOOL_ ) ; } } super . removeMarkers ( ) ; repaint ( ) ; }
public IElementType captureString ( ) { CharSequence buffer = getBuffer ( ) ; int currentPosition = getTokenEnd ( ) ; setTokenStart ( currentPosition ) ; int bufferEnd = getBufferEnd ( ) ; char openQuote = buffer . charAt ( currentPosition ) ; char closeQuote = RegexBlock . getQuoteCloseChar ( openQuote ) ; boolean quotesDiffer = openQuote != closeQuote ; boolean isEscaped = BOOL_ ; int quotesDepth = NUM_ ; currentPosition ++ ; while ( currentPosition < bufferEnd ) { char currentChar = buffer . charAt ( currentPosition ) ; if ( ! isEscaped && quotesDepth == NUM_ && currentChar == closeQuote ) { break ; } if ( ! isEscaped && quotesDiffer ) { if ( currentChar == openQuote ) { quotesDepth ++ ; } else if ( currentChar == closeQuote ) { quotesDepth -- ; } } isEscaped = ! isEscaped && currentChar == STR_ ; currentPosition ++ ; } if ( currentPosition < bufferEnd ) { currentPosition ++ ; } setTokenEnd ( currentPosition ) ; PerlStringLexer stringLexer = getStringLexer ( ) ; popState ( ) ; preparsedTokensList . addAll ( lexCurrentToken ( stringLexer ) ) ; return getPreParsedToken ( ) ; }
public static String toLocalizedInteger ( long value ) { return NUMBER_FORMAT0 . format ( value ) ; }
public void testParseClientHandshake ( ) throws Exception { for ( int splitPos = NUM_ ; splitPos < NUM_ ; splitPos ++ ) { log . info ( STR_ + splitPos ) ; ByteBuffer tmp = clientHandshakePacket ( ) ; ByteBuffer [ ] split = split ( tmp , splitPos ) ; GridNioSession ses = new MockNioSession ( ) ; ses . addMeta ( MARSHALLER . ordinal ( ) , new GridClientOptimizedMarshaller ( ) ) ; GridTcpRestParser parser = new GridTcpRestParser ( BOOL_ ) ; Collection < GridClientMessage > lst = new ArrayList < > ( NUM_ ) ; for ( ByteBuffer buf : split ) { GridClientMessage r ; while ( buf . hasRemaining ( ) && ( r = parser . decode ( ses , buf ) ) != null ) lst . add ( r ) ; assertTrue ( STR_ , buf . remaining ( ) == NUM_ ) ; } assertEquals ( NUM_ , lst . size ( ) ) ; GridClientHandshakeRequest req = ( GridClientHandshakeRequest ) F . first ( lst ) ; assertNotNull ( req ) ; assertEquals ( U . bytesToShort ( new byte [ ] { NUM_ , NUM_ } , NUM_ ) , req . version ( ) ) ; } }
public void initialize ( Context context , HapticFeedbackController hapticFeedbackController , int initialHoursOfDay , int initialMinutes , boolean is24HourMode ) { if ( mTimeInitialized ) { Log . e ( TAG , STR_ ) ; return ; } mHapticFeedbackController = hapticFeedbackController ; mIs24HourMode = is24HourMode ; mHideAmPm = mAccessibilityManager . isTouchExplorationEnabled ( ) ? BOOL_ : mIs24HourMode ; mCircleView . initialize ( context , mHideAmPm ) ; mCircleView . invalidate ( ) ; if ( ! mHideAmPm ) { mAmPmCirclesView . initialize ( context , initialHoursOfDay < NUM_ ? AM : PM ) ; mAmPmCirclesView . invalidate ( ) ; } Resources res = context . getResources ( ) ; int [ ] hours = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int [ ] hours_24 = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int [ ] minutes = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; String [ ] hoursTexts = new String [ NUM_ ] ; String [ ] innerHoursTexts = new String [ NUM_ ] ; String [ ] minutesTexts = new String [ NUM_ ] ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { hoursTexts [ i ] = is24HourMode ? String . format ( STR_ , hours_24 [ i ] ) : String . format ( STR_ , hours [ i ] ) ; innerHoursTexts [ i ] = String . format ( STR_ , hours [ i ] ) ; minutesTexts [ i ] = String . format ( STR_ , minutes [ i ] ) ; } mHourRadialTextsView . initialize ( res , hoursTexts , ( is24HourMode ? innerHoursTexts : null ) , mHideAmPm , BOOL_ ) ; mHourRadialTextsView . invalidate ( ) ; mMinuteRadialTextsView . initialize ( res , minutesTexts , null , mHideAmPm , BOOL_ ) ; mMinuteRadialTextsView . invalidate ( ) ; setValueForItem ( HOUR_INDEX , initialHoursOfDay ) ; setValueForItem ( MINUTE_INDEX , initialMinutes ) ; int hourDegrees = ( initialHoursOfDay % NUM_ ) . HOUR_VALUE_TO_DEGREES_STEP_SIZE ; mHourRadialSelectorView . initialize ( context , mHideAmPm , is24HourMode , BOOL_ , hourDegrees , isHourInnerCircle ( initialHoursOfDay ) ) ; int minuteDegrees = initialMinutes . MINUTE_VALUE_TO_DEGREES_STEP_SIZE ; mMinuteRadialSelectorView . initialize ( context , mHideAmPm , BOOL_ , BOOL_ , minuteDegrees , BOOL_ ) ; mTimeInitialized = BOOL_ ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; String childData ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; nameNode = elementList . item ( NUM_ ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; child . deleteData ( NUM_ , NUM_ ) ; childData = child . getData ( ) ; assertEquals ( STR_ , STR_ , childData ) ; }
void checkFrameValue ( final Object value ) { if ( value == Opcodes . TOP || value == Opcodes . INTEGER || value == Opcodes . FLOAT || value == Opcodes . LONG || value == Opcodes . DOUBLE || value == Opcodes . NULL || value == Opcodes . UNINITIALIZED_THIS ) { return ; } if ( value instanceof String ) { checkInternalName ( ( String ) value , STR_ ) ; return ; } if ( ! ( value instanceof Label ) ) { throw new IllegalArgumentException ( STR_ + value ) ; } else { usedLabels . add ( ( Label ) value ) ; } }
protected void sqrtLayout ( VisualTable labels ) { Rectangle2D b = getLayoutBounds ( ) ; double breadth = getBreadth ( b ) ; double span = m_hi - m_lo ; double splo = MathLib . safeSqrt ( m_prevlo ) ; double spspan = MathLib . safeSqrt ( m_prevhi ) - splo ; double vlo = Math . pow ( NUM_ , Math . floor ( MathLib . safeLog10 ( m_lo ) ) ) ; double slo = MathLib . safeSqrt ( m_lo ) ; double sspan = MathLib . safeSqrt ( m_hi ) - slo ; Iterator iter = labels . tuples ( ) ; while ( iter . hasNext ( ) ) { VisualItem item = ( VisualItem ) iter . next ( ) ; reset ( item ) ; double v = item . getDouble ( VALUE ) ; double x = span == NUM_ ? NUM_ : ( ( MathLib . safeSqrt ( v ) - slo ) / sspan ) . breadth ; set ( item , x , b ) ; } Index index = labels . index ( VALUE ) ; double step = getLinearStep ( span , breadth / span ) ; if ( step == NUM_ ) step = NUM_ ; int r ; for ( double x , v = vlo ; v <= m_hi ; v += step ) { x = ( ( MathLib . safeSqrt ( v ) - slo ) / sspan ) . breadth ; if ( x < - NUM_ ) { continue ; } else if ( ( r = index . get ( v ) ) >= NUM_ ) { VisualItem item = labels . getItem ( r ) ; item . setVisible ( BOOL_ ) ; item . setEndVisible ( BOOL_ ) ; } else { VisualItem item = labels . addItem ( ) ; item . set ( LABEL , m_nf . format ( v ) ) ; item . setDouble ( VALUE , v ) ; double f = spspan == NUM_ ? NUM_ : ( ( MathLib . safeSqrt ( v ) - splo ) / spspan ) ; if ( f <= NUM_ || f >= NUM_ ) { item . setStartVisible ( BOOL_ ) ; } set ( item , f . breadth , b ) ; set ( item , x , b ) ; } } }
public static Template create ( String value ) { if ( Settings . isFunction ( value ) ) { return new FunctionalTemplate ( value ) ; } if ( Graph . isRelational ( value ) ) { try { return new RelationalTemplate ( value ) ; } catch ( Exception e ) { log . warning ( STR_ + value + STR_ ) ; return new StringTemplate ( value ) ; } } else if ( RegexTemplate . isPossibleRegex ( value ) ) { try { if ( ArithmeticTemplate . isArithmeticExpression ( value ) ) { return new ArithmeticTemplate ( value ) ; } return new RegexTemplate ( value ) ; } catch ( PatternSyntaxException e ) { log . warning ( STR_ + value + STR_ ) ; return new StringTemplate ( value ) ; } } else { return new StringTemplate ( value ) ; } }
protected boolean customShouldTakeFocus ( ) { if ( customArea instanceof Label ) { return BOOL_ ; } if ( customArea instanceof CLabel ) { return ( customArea . getStyle ( ) & SWT . NO_FOCUS ) > NUM_ ; } return BOOL_ ; }
public void init ( PrivateKey key ) { try { if ( signature != null ) { signature . initSign ( key ) ; } else if ( cipher != null ) { cipher . init ( Cipher . ENCRYPT_MODE , key ) ; } } catch ( InvalidKeyException e ) { throw new AlertException ( AlertProtocol . BAD_CERTIFICATE , new SSLException ( STR_ , e ) ) ; } }
private Map < String , List < Zone > > selectZonesForInitiatorsAndPorts ( NetworkLite network , Map < String , List < Zone > > wwnToZones , Map < String , StoragePort > initiatorPortsMap ) { Map < String , List < Zone > > filteredMap = new HashMap < String , List < Zone > > ( ) ; Zone zone = null ; List < Zone > zones = null ; for ( String initiatorWwn : wwnToZones . keySet ( ) ) { for ( String portWwn : initiatorPortsMap . keySet ( ) ) { zone = _networkScheduler . selectExistingZoneForInitiatorPort ( network , initiatorWwn , portWwn , wwnToZones . get ( initiatorWwn ) ) ; if ( zone != null ) { zones = filteredMap . get ( initiatorWwn ) ; if ( zones == null ) { zones = new ArrayList < > ( ) ; filteredMap . put ( initiatorWwn , zones ) ; } zones . add ( zone ) ; } } } return filteredMap ; }
public static boolean isExtension ( String filename , Collection < String > extensions ) { if ( filename == null ) return BOOL_ ; if ( extensions == null || extensions . isEmpty ( ) ) return indexOfExtension ( filename ) == - NUM_ ; String fileExt = getExtension ( filename ) ; for ( String extension : extensions ) { if ( fileExt . equals ( extension ) ) return BOOL_ ; } return BOOL_ ; }
private void writeJarPostResource ( Element postResourceEl , String path ) { postResourceEl . setAttribute ( STR_ , JAR_RESOURCE_SET ) ; postResourceEl . setAttribute ( STR_ , path . replace ( STR_ , STR_ ) ) ; }
public void closeFile ( ) throws IOException { file . close ( ) ; file = null ; }
public TypedEventListener ( EventListener < E > wrappedListener , Class < E > eventClass ) { this . eventClass = eventClass ; this . wrappedListener = wrappedListener ; }
public static List < ? extends Node > childNodeList ( Node node ) { if ( node == null ) return null ; List < Node > nodes = new LinkedList < Node > ( ) ; do { if ( node . getNodeType ( ) == Node . ELEMENT_NODE || node . getNodeType ( ) == Node . COMMENT_NODE ) { nodes . add ( node ) ; } } while ( ( node = node . getNextSibling ( ) ) != null ) ; return nodes ; }
public static Corleone context ( String jobContext ) { if ( jobContext == null || jobContext . equals ( STR_ ) ) { throw new IllegalArgumentException ( STR_ ) ; } contexts . clear ( ) ; contexts . add ( jobContext ) ; return getInstance ( ) ; }
protected final void init ( ) throws NoGlyphException { char [ ] codes = chars . toCharArray ( ) ; indices = new int [ codes . length ] ; advances = new int [ codes . length ] ; double maxAscent = NUM_ ; double maxDescent = NUM_ ; double scale = size . SWFConstants . TWIPS / NUM_ ; for ( int i = NUM_ ; i < codes . length ; i ++ ) { int code = ( int ) codes [ i ] ; int [ ] index = new int [ NUM_ ] ; FontDefinition . Glyph glyph = getGlyph ( code , index ) ; indices [ i ] = index [ NUM_ ] ; if ( glyph != null ) { Shape shape = glyph . getShape ( ) ; double [ ] outline = shape . getBoundingRectangle ( ) ; double x1 = outline [ NUM_ ] . scale ; double y1 = outline [ NUM_ ] . scale ; double x2 = outline [ NUM_ ] . scale ; double y2 = outline [ NUM_ ] . scale ; if ( maxAscent < - y1 ) { maxAscent = - y1 ; } if ( maxDescent < y2 ) { maxDescent = y2 ; } double advance = glyph . getAdvance ( ) . scale ; if ( advance == NUM_ ) { advance = x2 - x1 ; } if ( i < codes . length - NUM_ ) { advance += ( fontDef . getKerningOffset ( code , ( int ) codes [ i + NUM_ ] ) . scale ) ; } totalAdvance += advance ; advances [ i ] = ( int ) ( advance . SWFConstants . TWIPS ) ; if ( i == NUM_ ) { leftMargin = - y1 ; } if ( i == codes . length - NUM_ ) { rightMargin = x2 - advance ; } } } ascent = fontDef . getAscent ( ) . scale ; if ( ascent == NUM_ ) { ascent = maxAscent ; } descent = fontDef . getDescent ( ) . scale ; if ( descent == NUM_ ) { descent = maxDescent ; } }
public static double info ( int counts [ ] ) { int total = NUM_ ; double x = NUM_ ; for ( int count : counts ) { x -= xlogx ( count ) ; total += count ; } return x + xlogx ( total ) ; }
public void addMethod ( SootMethod m ) { checkLevel ( SIGNATURES ) ; if ( m . isDeclared ( ) ) throw new RuntimeException ( STR_ + m . getName ( ) ) ; if ( subSigToMethods . get ( m . getNumberedSubSignature ( ) ) != null ) { throw new RuntimeException ( STR_ + m . getSubSignature ( ) + STR_ + this + STR_ ) ; } subSigToMethods . put ( m . getNumberedSubSignature ( ) , m ) ; methodList . add ( m ) ; m . setDeclared ( BOOL_ ) ; m . setDeclaringClass ( this ) ; }
public void addSwipeListener ( SwipeListener listener ) { if ( mListeners == null ) { mListeners = new ArrayList < SwipeListener > ( ) ; } mListeners . add ( listener ) ; }
public void clear ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { for ( Node < E > f = first ; f != null ; ) { f . item = null ; Node < E > n = f . next ; f . prev = null ; f . next = null ; f = n ; } first = last = null ; count = NUM_ ; notFull . signalAll ( ) ; } finally { lock . unlock ( ) ; } }
private void addReplicationFactor ( Operation op ) { op . addRequestHeader ( Operation . REPLICATION_QUORUM_HEADER , Operation . REPLICATION_QUORUM_HEADER_VALUE_ALL ) ; }
private static Frame showInitialSplash ( ) { Frame splashFrame = null ; Image image = null ; URL imageURL = getChosenSplashURL ( ) ; if ( imageURL != null ) { try { image = ImageIO . read ( imageURL ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } if ( image != null ) { splashFrame = AWTSplashWindow . splash ( image ) ; } } return splashFrame ; }
protected void decodeLineSuffix ( PushbackInputStream inStream , OutputStream outStream ) throws IOException { int c ; while ( BOOL_ ) { c = inStream . read ( ) ; if ( c == - NUM_ ) { throw new CEStreamExhausted ( ) ; } if ( c == STR_ ) { break ; } if ( c == STR_ ) { c = inStream . read ( ) ; if ( ( c != STR_ ) && ( c != - NUM_ ) ) { inStream . unread ( c ) ; } break ; } } }
public void addTransaction ( SIPServerTransaction serverTransaction ) throws IOException { if ( isLoggingEnabled ( ) ) stackLogger . logDebug ( STR_ + serverTransaction ) ; serverTransaction . map ( ) ; addTransactionHash ( serverTransaction ) ; }
private float spacing ( MotionEvent event ) { float x = event . getX ( NUM_ ) - event . getX ( NUM_ ) ; float y = event . getY ( NUM_ ) - event . getY ( NUM_ ) ; return ( float ) Math . sqrt ( x . x + y . y ) ; }
public boolean containsPoly ( SootMethod method ) { return getMethod ( method ) != null ; }
public JKTagMapping ( final String sourceQName , final String targetQName , final JKNamespace namespace ) { logger . info ( String . format ( STR_ , sourceQName , targetQName ) ) ; this . sourceQName = sourceQName ; this . targetQName = targetQName ; this . namespace = namespace ; this . auto = BOOL_ ; }
private void selectAttributeSetInstance ( ) { int m_warehouse_id = getM_Warehouse_ID ( ) ; int m_product_id = getM_Product_ID ( ) ; if ( m_product_id <= NUM_ ) return ; MProduct product = MProduct . get ( getCtx ( ) , m_product_id ) ; MWarehouse wh = MWarehouse . get ( getCtx ( ) , m_warehouse_id ) ; String title = product . get_Translation ( MProduct . COLUMNNAME_Name ) + STR_ + wh . get_Translation ( MWarehouse . COLUMNNAME_Name ) ; PAttributeInstance pai = new PAttributeInstance ( m_frame , title , m_warehouse_id , NUM_ , m_product_id , NUM_ ) ; if ( pai . getM_AttributeSetInstance_ID ( ) != - NUM_ ) { fAttrSetInstance_ID . setText ( pai . getM_AttributeSetInstanceName ( ) ) ; fAttrSetInstance_ID . setValue ( new Integer ( pai . getM_AttributeSetInstance_ID ( ) ) ) ; } else { fAttrSetInstance_ID . setValue ( Integer . valueOf ( NUM_ ) ) ; } }
private void ensureFileOpen ( ) { if ( savingDisabled ) { Log . e ( TAG , STR_ ) ; return ; } if ( saveFileStream != null ) return ; File saveFile = new File ( ctx . getFilesDir ( ) , SAVEFILE ) ; try { FileOutputStream fileOutput = null ; DataOutputStream out = null ; if ( saveFile . exists ( ) ) { fileOutput = ctx . openFileOutput ( SAVEFILE , Context . MODE_APPEND ) ; out = new DataOutputStream ( new BufferedOutputStream ( fileOutput ) ) ; } else { fileOutput = ctx . openFileOutput ( SAVEFILE , Context . MODE_PRIVATE ) ; out = new DataOutputStream ( new BufferedOutputStream ( fileOutput ) ) ; out . writeInt ( TrackPoint . FORMAT_VERSION ) ; savedTrackPoints = NUM_ ; } saveFileStream = out ; } catch ( Exception e ) { markSavingBroken ( STR_ , e ) ; } }
public void test_canonicalizingCache ( ) { final Properties properties = getProperties ( ) ; properties . setProperty ( AbstractTransactionService . Options . MIN_RELEASE_AGE , STR_ ) ; final Journal journal = new Journal ( properties ) ; try { final long commitTime0 = journal . commit ( ) ; assertTrue ( commitTime0 != NUM_ ) ; final ICommitRecord commitRecord0 = journal . getCommitRecord ( commitTime0 ) ; assertEquals ( commitRecord0 , journal . getCommitRecord ( ) ) ; journal . write ( ByteBuffer . wrap ( new byte [ ] { NUM_ , NUM_ , NUM_ } ) ) ; final long commitTime1 = journal . commit ( ) ; assertTrue ( commitTime1 != NUM_ ) ; final ICommitRecord commitRecord1 = journal . getCommitRecord ( commitTime1 ) ; assertEquals ( commitRecord1 , journal . getCommitRecord ( ) ) ; assertTrue ( commitRecord0 == journal . getCommitRecord ( commitTime1 - NUM_ ) ) ; assertTrue ( commitRecord1 == journal . getCommitRecord ( commitTime1 + NUM_ ) ) ; assertTrue ( commitRecord1 == journal . getCommitRecord ( commitTime1 + NUM_ ) ) ; } finally { journal . destroy ( ) ; } }
public static void print ( Object x ) { out . print ( x ) ; out . flush ( ) ; }
@ Override public void stop ( Runnable arg0 ) { stop ( ) ; arg0 . run ( ) ; }
protected int read ( InputStream inputStream , byte [ ] buffer , char divider ) throws IOException { int index = NUM_ ; do { byte readByte = ( byte ) ( x000000FF & inputStream . read ( ) ) ; if ( readByte == - NUM_ || readByte == ( byte ) divider ) { return index ; } buffer [ index ] = readByte ; index ++ ; } while ( index < buffer . length ) ; return index ; }
private static void generateGraphFile ( TransMeta transMeta , String graphFile ) throws GraphGeneratorException { DataOutputStream dos = null ; try { String xml = transMeta . getXML ( ) ; dos = new DataOutputStream ( new FileOutputStream ( new File ( graphFile ) ) ) ; dos . write ( xml . getBytes ( CarbonCommonConstants . DEFAULT_CHARSET ) ) ; } catch ( KettleException kettelException ) { throw new GraphGeneratorException ( STR_ , kettelException ) ; } catch ( FileNotFoundException e ) { throw new GraphGeneratorException ( STR_ , e ) ; } catch ( UnsupportedEncodingException ue ) { throw new GraphGeneratorException ( STR_ , ue ) ; } catch ( IOException ioe ) { throw new GraphGeneratorException ( STR_ , ioe ) ; } finally { if ( dos != null ) { try { dos . close ( ) ; } catch ( IOException e ) { e . getMessage ( ) ; } } } }
public static void closeOutputStream ( OutputStream stream , String tag ) { if ( stream != null ) { try { stream . close ( ) ; } catch ( IOException e ) { Log . e ( tag , STR_ + e ) ; } } }
private void testMultiStatement ( ) { MVStore s = MVStore . open ( null ) ; TransactionStore ts = new TransactionStore ( s ) ; ts . init ( ) ; Transaction tx ; TransactionMap < String , String > m ; long startUpdate ; tx = ts . begin ( ) ; startUpdate = tx . setSavepoint ( ) ; m = tx . openMap ( STR_ ) ; m . setSavepoint ( startUpdate ) ; startUpdate = tx . setSavepoint ( ) ; m . setSavepoint ( startUpdate ) ; assertTrue ( m . trySet ( STR_ , STR_ , BOOL_ ) ) ; assertTrue ( m . trySet ( STR_ , STR_ , BOOL_ ) ) ; assertNull ( m . get ( STR_ ) ) ; assertNull ( m . get ( STR_ ) ) ; startUpdate = tx . setSavepoint ( ) ; m . setSavepoint ( startUpdate ) ; assertEquals ( STR_ , m . get ( STR_ ) ) ; assertEquals ( STR_ , m . get ( STR_ ) ) ; assertEquals ( STR_ , m . get ( STR_ ) ) ; assertTrue ( m . trySet ( STR_ , null , BOOL_ ) ) ; assertTrue ( m . trySet ( STR_ , STR_ , BOOL_ ) ) ; assertEquals ( STR_ , m . get ( STR_ ) ) ; assertTrue ( m . trySet ( STR_ , null , BOOL_ ) ) ; assertTrue ( m . trySet ( STR_ , STR_ , BOOL_ ) ) ; assertEquals ( STR_ , m . get ( STR_ ) ) ; assertEquals ( STR_ , m . get ( STR_ ) ) ; assertNull ( m . get ( STR_ ) ) ; startUpdate = tx . setSavepoint ( ) ; m . setSavepoint ( startUpdate ) ; assertNull ( m . get ( STR_ ) ) ; assertEquals ( STR_ , m . get ( STR_ ) ) ; assertEquals ( STR_ , m . get ( STR_ ) ) ; startUpdate = tx . setSavepoint ( ) ; m . setSavepoint ( startUpdate ) ; assertTrue ( m . trySet ( STR_ , null , BOOL_ ) ) ; assertTrue ( m . trySet ( STR_ , STR_ , BOOL_ ) ) ; assertTrue ( m . trySet ( STR_ , null , BOOL_ ) ) ; assertFalse ( m . trySet ( STR_ , STR_ , BOOL_ ) ) ; tx . rollbackToSavepoint ( startUpdate ) ; startUpdate = tx . setSavepoint ( ) ; m . setSavepoint ( startUpdate ) ; assertNull ( m . get ( STR_ ) ) ; assertEquals ( STR_ , m . get ( STR_ ) ) ; assertEquals ( STR_ , m . get ( STR_ ) ) ; tx . commit ( ) ; ts . close ( ) ; s . close ( ) ; }
public void addPropertyChangeListener ( String propertyName , PropertyChangeListener in_pcl ) { beanContextChildSupport . addPropertyChangeListener ( propertyName , in_pcl ) ; }
public void createEntityConfig ( String realm , FederationConfigElement config ) throws WSFederationMetaException { String federationId = config . getFederationID ( ) ; if ( federationId == null ) { debug . error ( STR_ + STR_ ) ; String [ ] data = { realm } ; LogUtil . error ( Level . INFO , LogUtil . NO_ENTITY_ID_CREATE_ENTITY_CONFIG , data , null ) ; throw new WSFederationMetaException ( STR_ , null ) ; } if ( realm == null ) { realm = STR_ ; } String [ ] objs = { federationId , realm } ; try { Map attrs = WSFederationMetaUtils . convertJAXBToAttrMap ( ATTR_ENTITY_CONFIG , config ) ; Map oldAttrs = configInst . getConfiguration ( realm , federationId ) ; if ( oldAttrs == null ) { LogUtil . error ( Level . INFO , LogUtil . NO_ENTITY_DESCRIPTOR_CREATE_ENTITY_CONFIG , objs , null ) ; throw new WSFederationMetaException ( STR_ , objs ) ; } Set oldValues = ( Set ) oldAttrs . get ( ATTR_ENTITY_CONFIG ) ; if ( oldValues != null && ! oldValues . isEmpty ( ) ) { LogUtil . error ( Level . INFO , LogUtil . ENTITY_CONFIG_EXISTS , objs , null ) ; throw new WSFederationMetaException ( STR_ , objs ) ; } configInst . setConfiguration ( realm , federationId , attrs ) ; LogUtil . access ( Level . INFO , LogUtil . ENTITY_CONFIG_CREATED , objs , null ) ; SPSSOConfigElement spconfig = getSPSSOConfig ( realm , federationId ) ; if ( spconfig != null ) { addToCircleOfTrust ( spconfig , realm , federationId ) ; } IDPSSOConfigElement idpconfig = getIDPSSOConfig ( realm , federationId ) ; if ( idpconfig != null ) { addToCircleOfTrust ( idpconfig , realm , federationId ) ; } } catch ( ConfigurationException e ) { debug . error ( STR_ , e ) ; String [ ] data = { e . getMessage ( ) , federationId , realm } ; LogUtil . error ( Level . INFO , LogUtil . CONFIG_ERROR_CREATE_ENTITY_CONFIG , data , null ) ; throw new WSFederationMetaException ( e ) ; } catch ( JAXBException jaxbe ) { debug . error ( STR_ , jaxbe ) ; LogUtil . error ( Level . INFO , LogUtil . CREATE_INVALID_ENTITY_CONFIG , objs , null ) ; throw new WSFederationMetaException ( STR_ , objs ) ; } }
public boolean isExpired ( ) { return this . ttl < System . currentTimeMillis ( ) ; }
private void loadUserInfoIntoActionBar ( ) { if ( ! TextUtils . isEmpty ( mWithUserImage ) ) { Utils . loadCircularImage ( getActivity ( ) , mWithImageView , mWithUserImage , AvatarBitmapTransformation . AvatarSize . NORMAL ) ; } }
public static Direction directionForArrowKey ( KeyEvent e ) { int index = Math . max ( NUM_ , Math . min ( e . getKeyCode ( ) , KeyEvent . VK_DOWN ) - KeyEvent . VK_LEFT ) ; return Direction . values ( ) [ index ] ; }
public TraceGraph ( Collection < Span > spans ) { this . spansByParent = new SpansByParent ( spans ) ; this . spansByTracerId = new SpansByTracerId ( spans ) ; }
public boolean isPersistent ( ) { return m_persist ; }
public static java . util . Date toDate ( String monthStr , String dayStr , String yearStr , String hourStr , String minuteStr , String secondStr ) { int month , day , year , hour , minute , second ; try { month = Integer . parseInt ( monthStr ) ; day = Integer . parseInt ( dayStr ) ; year = Integer . parseInt ( yearStr ) ; hour = Integer . parseInt ( hourStr ) ; minute = Integer . parseInt ( minuteStr ) ; second = Integer . parseInt ( secondStr ) ; } catch ( Exception e ) { return null ; } return toDate ( month , day , year , hour , minute , second ) ; }
protected void handleMesosFailure ( String taskId ) { int attempt = TaskUtils . getAttemptForTaskId ( taskId ) ; BaseContainer container = containersInfo . get ( TaskUtils . getContainerIndexForTaskId ( taskId ) ) ; boolean hasAttemptsLeft = attempt < container . retries ; if ( hasAttemptsLeft ) { LOG . warning ( String . format ( STR_ , container . name , attempt + NUM_ ) ) ; String newTaskId = TaskUtils . getTaskId ( container . name , attempt + NUM_ ) ; scheduleNewTask ( newTaskId ) ; } else { LOG . severe ( STR_ + attempt ) ; } }
private void updateLtp ( SingleChannelElement sce ) { IndividualChannelStream ics = sce . ics ; float saved [ ] = sce . saved ; float savedLtp [ ] = sce . coeffs ; final float lwindow [ ] = ics . useKbWindow [ NUM_ ] ? ff_aac_kbd_long_1024 : ff_sine_1024 ; final float swindow [ ] = ics . useKbWindow [ NUM_ ] ? ff_aac_kbd_short_128 : ff_sine_128 ; if ( ics . windowSequence [ NUM_ ] == EIGHT_SHORT_SEQUENCE ) { System . arraycopy ( saved , NUM_ , savedLtp , NUM_ , NUM_ ) ; Arrays . fill ( savedLtp , NUM_ , NUM_ + NUM_ , NUM_ ) ; FloatDSP . vectorFmulReverse ( savedLtp , NUM_ , ac . bufMdct , NUM_ , swindow , NUM_ , NUM_ ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { savedLtp [ i + NUM_ ] = ac . bufMdct [ NUM_ - i ] . swindow [ NUM_ - i ] ; } } else if ( ics . windowSequence [ NUM_ ] == LONG_START_SEQUENCE ) { System . arraycopy ( ac . bufMdct , NUM_ , savedLtp , NUM_ , NUM_ ) ; Arrays . fill ( savedLtp , NUM_ , NUM_ + NUM_ , NUM_ ) ; FloatDSP . vectorFmulReverse ( savedLtp , NUM_ , ac . bufMdct , NUM_ , swindow , NUM_ , NUM_ ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { savedLtp [ i + NUM_ ] = ac . bufMdct [ NUM_ - i ] . swindow [ NUM_ - i ] ; } } else { FloatDSP . vectorFmulReverse ( savedLtp , NUM_ , ac . bufMdct , NUM_ , lwindow , NUM_ , NUM_ ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { savedLtp [ i + NUM_ ] = ac . bufMdct [ NUM_ - i ] . lwindow [ NUM_ - i ] ; } } System . arraycopy ( sce . ltpState , NUM_ , sce . ltpState , NUM_ , NUM_ ) ; System . arraycopy ( sce . ret , NUM_ , sce . ltpState , NUM_ , NUM_ ) ; System . arraycopy ( savedLtp , NUM_ , sce . ltpState , NUM_ , NUM_ ) ; }
public static File findConfigInWorkingDirectory ( ) { for ( final String suffix : SUFFIXES ) { final File configFile = new File ( System . getProperty ( STR_ ) , PREFIX + suffix ) ; if ( configFile . isFile ( ) ) { return configFile ; } } return null ; }
@ Override public void drawRangeMarker ( Graphics2D g2 , XYPlot plot , ValueAxis rangeAxis , Marker marker , Rectangle2D dataArea ) { if ( marker instanceof ValueMarker ) { ValueMarker vm = ( ValueMarker ) marker ; double value = vm . getValue ( ) ; Range range = rangeAxis . getRange ( ) ; if ( ! range . contains ( value ) ) { return ; } double v = rangeAxis . valueToJava2D ( value , dataArea , plot . getRangeAxisEdge ( ) ) ; PlotOrientation orientation = plot . getOrientation ( ) ; Line2D line = null ; if ( orientation == PlotOrientation . HORIZONTAL ) { line = new Line2D . Double ( v , dataArea . getMinY ( ) , v , dataArea . getMaxY ( ) ) ; } else if ( orientation == PlotOrientation . VERTICAL ) { line = new Line2D . Double ( dataArea . getMinX ( ) , v , dataArea . getMaxX ( ) , v ) ; } else { throw new IllegalStateException ( STR_ ) ; } final Composite originalComposite = g2 . getComposite ( ) ; g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , marker . getAlpha ( ) ) ) ; g2 . setPaint ( marker . getPaint ( ) ) ; g2 . setStroke ( marker . getStroke ( ) ) ; g2 . draw ( line ) ; String label = marker . getLabel ( ) ; RectangleAnchor anchor = marker . getLabelAnchor ( ) ; if ( label != null ) { Font labelFont = marker . getLabelFont ( ) ; g2 . setFont ( labelFont ) ; Point2D coords = calculateRangeMarkerTextAnchorPoint ( g2 , orientation , dataArea , line . getBounds2D ( ) , marker . getLabelOffset ( ) , LengthAdjustmentType . EXPAND , anchor ) ; Rectangle2D r = TextUtils . calcAlignedStringBounds ( label , g2 , ( float ) coords . getX ( ) , ( float ) coords . getY ( ) , marker . getLabelTextAnchor ( ) ) ; g2 . setPaint ( marker . getLabelBackgroundColor ( ) ) ; g2 . fill ( r ) ; g2 . setPaint ( marker . getLabelPaint ( ) ) ; TextUtilities . drawAlignedString ( label , g2 , ( float ) coords . getX ( ) , ( float ) coords . getY ( ) , marker . getLabelTextAnchor ( ) ) ; } g2 . setComposite ( originalComposite ) ; } else if ( marker instanceof IntervalMarker ) { IntervalMarker im = ( IntervalMarker ) marker ; double start = im . getStartValue ( ) ; double end = im . getEndValue ( ) ; Range range = rangeAxis . getRange ( ) ; if ( ! ( range . intersects ( start , end ) ) ) { return ; } double start2d = rangeAxis . valueToJava2D ( start , dataArea , plot . getRangeAxisEdge ( ) ) ; double end2d = rangeAxis . valueToJava2D ( end , dataArea , plot . getRangeAxisEdge ( ) ) ; double low = Math . min ( start2d , end2d ) ; double high = Math . max ( start2d , end2d ) ; PlotOrientation orientation = plot . getOrientation ( ) ; Rectangle2D rect = null ; if ( orientation == PlotOrientation . HORIZONTAL ) { low = Math . max ( low , dataArea . getMinX ( ) ) ; high = Math . min ( high , dataArea . getMaxX ( ) ) ; rect = new Rectangle2D . Double ( low , dataArea . getMinY ( ) , high - low , dataArea . getHeight ( ) ) ; } else if ( orientation == PlotOrientation . VERTICAL ) { low = Math . max ( low , dataArea . getMinY ( ) ) ; high = Math . min ( high , dataArea . getMaxY ( ) ) ; rect = new Rectangle2D . Double ( dataArea . getMinX ( ) , low , dataArea . getWidth ( ) , high - low ) ; } final Composite originalComposite = g2 . getComposite ( ) ; g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , marker . getAlpha ( ) ) ) ; Paint p = marker . getPaint ( ) ; if ( p instanceof GradientPaint ) { GradientPaint gp = ( GradientPaint ) p ; GradientPaintTransformer t = im . getGradientPaintTransformer ( ) ; if ( t != null ) { gp = t . transform ( gp , rect ) ; } g2 . setPaint ( gp ) ; } else { g2 . setPaint ( p ) ; } g2 . fill ( rect ) ; if ( im . getOutlinePaint ( ) != null && im . getOutlineStroke ( ) != null ) { if ( orientation == PlotOrientation . VERTICAL ) { Line2D line = new Line2D . Double ( ) ; double x0 = dataArea . getMinX ( ) ; double x1 = dataArea . getMaxX ( ) ; g2 . setPaint ( im . getOutlinePaint ( ) ) ; g2 . setStroke ( im . getOutlineStroke ( ) ) ; if ( range . contains ( start ) ) { line . setLine ( x0 , start2d , x1 , start2d ) ; g2 . draw ( line ) ; } if ( range . contains ( end ) ) { line . setLine ( x0 , end2d , x1 , end2d ) ; g2 . draw ( line ) ; } } else { Line2D line = new Line2D . Double ( ) ; double y0 = dataArea . getMinY ( ) ; double y1 = dataArea . getMaxY ( ) ; g2 . setPaint ( im . getOutlinePaint ( ) ) ; g2 . setStroke ( im . getOutlineStroke ( ) ) ; if ( range . contains ( start ) ) { line . setLine ( start2d , y0 , start2d , y1 ) ; g2 . draw ( line ) ; } if ( range . contains ( end ) ) { line . setLine ( end2d , y0 , end2d , y1 ) ; g2 . draw ( line ) ; } } } String label = marker . getLabel ( ) ; RectangleAnchor anchor = marker . getLabelAnchor ( ) ; if ( label != null ) { Font labelFont = marker . getLabelFont ( ) ; g2 . setFont ( labelFont ) ; Point2D coords = calculateRangeMarkerTextAnchorPoint ( g2 , orientation , dataArea , rect , marker . getLabelOffset ( ) , marker . getLabelOffsetType ( ) , anchor ) ; Rectangle2D r = TextUtils . calcAlignedStringBounds ( label , g2 , ( float ) coords . getX ( ) , ( float ) coords . getY ( ) , marker . getLabelTextAnchor ( ) ) ; g2 . setPaint ( marker . getLabelBackgroundColor ( ) ) ; g2 . fill ( r ) ; g2 . setPaint ( marker . getLabelPaint ( ) ) ; TextUtilities . drawAlignedString ( label , g2 , ( float ) coords . getX ( ) , ( float ) coords . getY ( ) , marker . getLabelTextAnchor ( ) ) ; } g2 . setComposite ( originalComposite ) ; } }
protected boolean attemptToAddWord ( Word word ) { double additionalLength = word . getWordWidth ( ) ; additionalLength += ! words . isEmpty ( ) ? spaceSize : NUM_ ; if ( currentLineLength + additionalLength <= maxLength || maxLength == - NUM_ ) { words . add ( word ) ; currentLineLength += additionalLength ; return BOOL_ ; } else { return BOOL_ ; } }
@ Override public boolean onPreferenceClick ( Preference preference ) { if ( preference == mPlayExample ) { getSampleText ( ) ; return BOOL_ ; } return BOOL_ ; }
public void readWwwAuthenticateHeader ( String header ) { if ( header != null ) { mIsDigestAuthentication = header . startsWith ( HttpDigestMd5Authentication . HTTP_DIGEST_SCHEMA ) ; if ( ! mIsDigestAuthentication ) { return ; } String value = getValue ( header , STR_ ) ; mDigest . setRealm ( value ) ; value = getValue ( header , STR_ ) ; mDigest . setOpaque ( value ) ; value = getValue ( header , STR_ ) ; mDigest . setQop ( value ) ; value = getValue ( header , STR_ ) ; mDigest . setNextnonce ( value ) ; } }
public static String valueOf ( Boolean value ) { return value != null ? String . valueOf ( value ) : null ; }
public void testSendReceive ( ) throws Exception { messages . clear ( ) ; for ( int i = NUM_ ; i < data . length ; i ++ ) { Message message = session . createTextMessage ( data [ i ] ) ; message . setStringProperty ( STR_ , data [ i ] ) ; message . setIntProperty ( STR_ , i ) ; if ( verbose ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( STR_ + message + STR_ + data [ i ] ) ; } } sendToProducer ( producer , producerDestination , message ) ; messageSent ( ) ; } assertMessagesAreReceived ( ) ; LOG . info ( STR_ + data . length + STR_ ) ; }
public void addLive ( boolean live ) { query . append ( STR_ + live ) ; }
public static String toString ( URI uri , Charset encoding ) throws IOException { return toString ( uri . toURL ( ) , Charsets . toCharset ( encoding ) ) ; }
public boolean exists ( String key ) { return exists ( key , BOOL_ ) ; }
public AllocationSite ( int line , int column ) { synchronized ( sites ) { this . id = sites . size ( ) ; sites . add ( this ) ; } this . line = line ; this . column = column ; }
public boolean drawImage ( Image img , AffineTransform xform , ImageObserver obs ) { return mGraphics . drawImage ( img , xform , obs ) ; }
public final static int parseInt ( char [ ] digitChars , int offset , int len ) { int num = digitChars [ offset ] - STR_ ; len += offset ; if ( ++ offset < len ) { num = ( num . NUM_ ) + ( digitChars [ offset ] - STR_ ) ; if ( ++ offset < len ) { num = ( num . NUM_ ) + ( digitChars [ offset ] - STR_ ) ; if ( ++ offset < len ) { num = ( num . NUM_ ) + ( digitChars [ offset ] - STR_ ) ; if ( ++ offset < len ) { num = ( num . NUM_ ) + ( digitChars [ offset ] - STR_ ) ; if ( ++ offset < len ) { num = ( num . NUM_ ) + ( digitChars [ offset ] - STR_ ) ; if ( ++ offset < len ) { num = ( num . NUM_ ) + ( digitChars [ offset ] - STR_ ) ; if ( ++ offset < len ) { num = ( num . NUM_ ) + ( digitChars [ offset ] - STR_ ) ; if ( ++ offset < len ) { num = ( num . NUM_ ) + ( digitChars [ offset ] - STR_ ) ; } } } } } } } } return num ; }
public ActivityMonitorSample ( ) { initComponents ( ) ; ownerARadio . setActionCommand ( STR_ ) ; ownerBRadio . setActionCommand ( STR_ ) ; ownerCRadio . setActionCommand ( STR_ ) ; indicatorA . setActivityOwner ( STR_ ) ; indicatorB . setActivityOwner ( STR_ ) ; indicatorC . setActivityOwner ( STR_ ) ; JActivityWindow . getInstance ( ) ; }
public static LatLon [ ] greatCircleExtremeLocations ( LatLon location , Angle azimuth ) { if ( location == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( azimuth == null ) { throw new IllegalArgumentException ( STR_ ) ; } double lat0 = location . getLatitude ( ) . radians ; double az = azimuth . radians ; double tanDistance = - Math . tan ( lat0 ) / Math . cos ( az ) ; double distance = Math . atan ( tanDistance ) ; Angle extremeDistance1 = Angle . fromRadians ( distance + ( Math . PI / NUM_ ) ) ; Angle extremeDistance2 = Angle . fromRadians ( distance - ( Math . PI / NUM_ ) ) ; return new LatLon [ ] { greatCircleEndPosition ( location , azimuth , extremeDistance1 ) , greatCircleEndPosition ( location , azimuth , extremeDistance2 ) } ; }
private void initCheckbox ( CheckBoxPreference checkbox , boolean checked , boolean enabled ) { checkbox . setChecked ( checked ) ; checkbox . setEnabled ( enabled ) ; }
private void paintCheckIconEnabledAndSelected ( Graphics2D g , int width , int height ) { Shape s = shapeGenerator . createCheckMark ( NUM_ , NUM_ , width , height ) ; g . setPaint ( iconEnabledSelected ) ; g . fill ( s ) ; }
public static int findURISplitIndex ( String uri ) { int uriLength = uri . length ( ) ; int idx = uriLength - NUM_ ; for ( ; idx >= NUM_ ; idx -- ) { if ( ! TurtleUtil . isNameChar ( uri . charAt ( idx ) ) ) { break ; } } idx ++ ; for ( ; idx < uriLength ; idx ++ ) { if ( TurtleUtil . isNameStartChar ( uri . charAt ( idx ) ) ) { break ; } } if ( ! TurtleUtil . isNameEndChar ( uri . charAt ( uriLength - NUM_ ) ) ) { return - NUM_ ; } if ( idx > NUM_ && idx < uriLength ) { return idx ; } return - NUM_ ; }
private void writeLog ( String cmd ) { try { if ( m_writer == null ) { File file = File . createTempFile ( STR_ , STR_ ) ; m_writer = new PrintWriter ( new FileWriter ( file ) ) ; log . info ( file . toString ( ) ) ; } m_writer . println ( cmd ) ; m_writer . flush ( ) ; } catch ( Exception e ) { log . severe ( e . toString ( ) ) ; } }
public void reload ( String why ) { mFullPhotoPaths = mRootDir . list ( MediaScanner . JPG_FILENAME_FILTER ) ; if ( ( mFullPhotoPaths != null ) && ( mFullPhotoPaths . length == NUM_ ) ) { mFullPhotoPaths = null ; Log . i ( Global . LOG_CONTEXT , mDebugPrefix + why + STR_ + mRootDir + STR_ + NUM_ ) ; } else if ( mFullPhotoPaths != null ) { if ( Global . debugEnabled ) { Log . i ( Global . LOG_CONTEXT , mDebugPrefix + why + STR_ + mRootDir + STR_ + mFullPhotoPaths . length ) ; } String parentDirString = mRootDir . getAbsolutePath ( ) ; for ( int i = NUM_ ; i < mFullPhotoPaths . length ; i ++ ) { mFullPhotoPaths [ i ] = parentDirString + STR_ + mFullPhotoPaths [ i ] ; } } }
DNSRecord ( String name , DNSRecordType type , DNSRecordClass recordClass , boolean unique , int ttl ) { super ( name , type , recordClass , unique ) ; this . _ttl = ttl ; this . _created = System . currentTimeMillis ( ) ; }
public static String block ( Stream < String > rows ) { return block ( rows . collect ( joining ( nl ( ) ) ) ) ; }
protected void addContentSpecToElement ( XMLElementDecl elementDecl ) { if ( ( fDepth == NUM_ || ( fDepth == NUM_ && elementDecl . type == XMLElementDecl . TYPE_MIXED ) ) && fNodeIndexStack != null ) { if ( elementDecl . type == XMLElementDecl . TYPE_MIXED ) { int pcdata = addUniqueLeafNode ( null ) ; if ( fNodeIndexStack [ NUM_ ] == - NUM_ ) { fNodeIndexStack [ NUM_ ] = pcdata ; } else { fNodeIndexStack [ NUM_ ] = addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_CHOICE , pcdata , fNodeIndexStack [ NUM_ ] ) ; } } setContentSpecIndex ( fCurrentElementIndex , fNodeIndexStack [ fDepth ] ) ; } }
private void growSpine ( ) { spine = new int [ ( spine . length << NUM_ ) + NUM_ ] ; threshold = ( int ) ( spine . length . loadFactor ) ; Arrays . fill ( spine , - NUM_ ) ; for ( int i = NUM_ ; i < size ; i ++ ) { insert ( objs [ i ] , i ) ; } }
public void reconnect ( ) { if ( opened && ! allowConnectionRecovery ) { return ; } reconnectwait thread = new reconnectwait ( ) ; thread . start ( ) ; try { thread . join ( ) ; } catch ( InterruptedException e ) { log . error ( STR_ + e . getMessage ( ) ) ; } if ( ! opened ) { log . error ( STR_ ) ; } else { log . info ( STR_ + getCurrentPortName ( ) ) ; resetupConnection ( ) ; } }
public Collection < GridPortRecord > records ( ) { synchronized ( recs ) { return Collections . unmodifiableCollection ( new ArrayList < > ( recs ) ) ; } }
@ Override public String toString ( ) { return buf . toString ( ) ; }
public boolean hasChangeEvent ( String name ) { if ( var != null ) { List < MetaData > mdList = var . getMetaData ( StandardDefs . MD_CHANGEEVENT ) ; if ( mdList != null ) { for ( int i = NUM_ , size = mdList . size ( ) ; i < size ; i ++ ) { MetaData md = mdList . get ( i ) ; if ( name . equals ( md . getValue ( NUM_ ) ) ) { return BOOL_ ; } } } } return BOOL_ ; }
protected void resetXML11 ( ) throws XNIException { int count = fXML11Components . size ( ) ; for ( int i = NUM_ ; i < count ; i ++ ) { XMLComponent c = ( XMLComponent ) fXML11Components . get ( i ) ; c . reset ( this ) ; } }
public float distanceToOtherCircle ( Circle circle ) { return ( float ) Math . abs ( Math . sqrt ( Math . pow ( circle . center . x - center . x , NUM_ ) + Math . pow ( circle . center . y - center . y , NUM_ ) ) ) ; }
public SimpleCommand ( String commandName , String ... args ) { this ( commandName , ( Argument ) null ) ; ArrayList < Argument > argList = new ArrayList < Argument > ( ) ; for ( String arg : args ) argList . add ( new Argument ( arg ) ) ; _arguments = argList . toArray ( new Argument [ NUM_ ] ) ; }
public String convertToLowerCase ( String table ) { return table . toLowerCase ( ) ; }
public PickingGraphMousePlugin ( int selectionModifiers , int addToSelectionModifiers ) { super ( selectionModifiers ) ; this . addToSelectionModifiers = addToSelectionModifiers ; this . lensPaintable = new LensPaintable ( ) ; this . cursor = Cursor . getPredefinedCursor ( Cursor . HAND_CURSOR ) ; }
public int [ ] breadthFirstSearch ( int intialValue , IBFSTraversable < N > traversable , int firstValue , IIntegerBfsNextValueIterator < N > nextValueIterator , List < Integer > sourcesIndex ) { int [ ] results = new int [ nodes . length ] ; Arrays . fill ( results , intialValue ) ; boolean [ ] alreadyScanned = new boolean [ nodes . length ] ; Arrays . fill ( alreadyScanned , BOOL_ ) ; Set < Integer > currentNodesIndex = new HashSet < > ( sourcesIndex ) ; iterativeIntegerBreadthFirstSearch ( results , alreadyScanned , currentNodesIndex , firstValue , NUM_ , traversable , nextValueIterator ) ; return results ; }
public ViewRefRender ( ViewRender < T > view , Class < T > type , int priority ) { Objects . requireNonNull ( view ) ; _view = view ; _type = type ; _priority = priority ; }
public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( argNum < NUM_ ) reportWrongNumberArgs ( ) ; }
private boolean announce ( String [ ] groups ) { if ( dataPackets == null || ! lastLocator . equals ( myLocator ) || ! Arrays . equals ( lastGroups , groups ) ) { List < DatagramPacket > packets = new ArrayList < DatagramPacket > ( ) ; Discovery disco ; try { disco = getDiscovery ( multicastAnnouncementConstraints . chooseProtocolVersion ( ) ) ; } catch ( DiscoveryProtocolException e ) { throw new AssertionError ( e ) ; } EncodeIterator ei = disco . encodeMulticastAnnouncement ( new MulticastAnnouncement ( announcementSeqNo ++ , myLocator . getHost ( ) , myLocator . getPort ( ) , groups , myServiceID ) , multicastAnnouncementConstraints . getMulticastMaxPacketSize ( DEFAULT_MAX_PACKET_SIZE ) , multicastAnnouncementConstraints . getUnfulfilledConstraints ( ) ) ; while ( ei . hasNext ( ) ) { try { packets . addAll ( Arrays . asList ( ei . next ( ) ) ) ; } catch ( Exception e ) { logger . log ( ( e instanceof UnsupportedConstraintException ) ? Levels . HANDLED : Level . INFO , STR_ + STR_ , e ) ; } } lastLocator = myLocator ; lastGroups = groups ; dataPackets = packets . toArray ( new DatagramPacket [ packets . size ( ) ] ) ; } try { send ( dataPackets ) ; } catch ( InterruptedIOException e ) { return BOOL_ ; } return BOOL_ ; }
public DrawingAttributes ( ) { propertyChangeSupport = new PropertyChangeSupport ( this ) ; }
public void close ( ) { scanner . close ( ) ; }
static void createPolicyTree ( String configName , String configId , ServiceConfigManager scm , String org ) throws NoPermissionException , PolicyException , SSOException { try { ServiceConfig pConfig = scm . getOrganizationConfig ( org , null ) ; if ( pConfig == null ) { scm . createOrganizationConfig ( org , null ) ; pConfig = scm . getOrganizationConfig ( org , null ) ; } pConfig . addSubConfig ( configName , configId , NUM_ , null ) ; } catch ( ServiceAlreadyExistsException se ) { if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + configName + STR_ + configId + STR_ + org ) ; } } catch ( SMSException e ) { String [ ] objs = { org } ; if ( e . getExceptionCode ( ) == SMSException . STATUS_NO_PERMISSION ) { throw ( new NoPermissionException ( ResBundleUtils . rbName , STR_ , null ) ) ; } else { throw ( new PolicyException ( ResBundleUtils . rbName , STR_ , objs , e ) ) ; } } }
private void rollbackMethodForCreateSnapshot ( boolean isSnapshotCreated , boolean isDummyLunPathAdded , HDSApiClient hdsApiClient , StorageSystem storage , URI snapshot ) throws Exception { if ( isDummyLunPathAdded ) { log . info ( STR_ ) ; hdsProtectionOperations . removeDummyLunPath ( storage , snapshot ) ; } if ( isSnapshotCreated ) { log . info ( STR_ ) ; BlockSnapshot snapshotObj = dbClient . queryObject ( BlockSnapshot . class , snapshot ) ; String systemObjectID = HDSUtils . getSystemObjectID ( storage ) ; String logicalUnitObjId = HDSUtils . getLogicalUnitObjectId ( snapshotObj . getNativeId ( ) , storage ) ; hdsApiClient . deleteSnapshotVolume ( systemObjectID , logicalUnitObjId , storage . getModel ( ) ) ; } }
public static int convertStringToTimeSeconds ( String time ) { int result = NUM_ ; if ( time . endsWith ( STR_ ) ) { int hoursToAdd = Integer . valueOf ( StringUtils . remove ( time , STR_ ) ) ; result = ( NUM_ . NUM_ ) . hoursToAdd ; } else if ( time . endsWith ( STR_ ) ) { int minsToAdd = Integer . valueOf ( StringUtils . remove ( time , STR_ ) ) ; result = NUM_ . minsToAdd ; } else if ( time . endsWith ( STR_ ) ) { int secsToAdd = Integer . valueOf ( StringUtils . remove ( time , STR_ ) ) ; result = secsToAdd ; } return result ; }
public void detach ( AppCompatActivity activity ) { attrViewMaps . remove ( activity . hashCode ( ) ) ; }
public void readPrefs ( SharedPreferences settings , ActionFactory factory ) { boolean visible = BOOL_ ; String actionId = settings . getString ( STR_ + name + STR_ , STR_ ) ; mainAction = factory . getAction ( actionId ) ; if ( mainAction != null ) visible = BOOL_ ; menuActions . clear ( ) ; for ( int i = NUM_ ; i < maxMenuActions ; i ++ ) { actionId = settings . getString ( STR_ + name + STR_ + ( i + NUM_ ) , STR_ ) ; UIAction a = factory . getAction ( actionId ) ; if ( a != null ) visible = BOOL_ ; menuActions . add ( a ) ; } if ( button != null ) button . setVisibility ( visible ? View . VISIBLE : View . GONE ) ; }
public boolean addToActiveList ( DownloadInfoRunnable downloadInfoRunnable ) { return activeListHasRoom ( ) && mActiveList . add ( downloadInfoRunnable ) ; }
private void addExprToTLA ( TLAExpr expr ) { Vector sv = expr . toStringVector ( ) ; Vector exprMapping = expr . toMappingVector ( ) ; int indent = tlacodeNextLine . length ( ) ; int nextLine = NUM_ ; if ( indent != NUM_ ) { MappingObject . shiftMappingVector ( exprMapping , indent ) ; tlacodeNextLine = tlacodeNextLine + ( ( String ) sv . elementAt ( NUM_ ) ) ; mappingVectorNextLine . addAll ( ( Vector ) exprMapping . elementAt ( NUM_ ) ) ; nextLine = NUM_ ; if ( sv . size ( ) > NUM_ ) { endCurrentLineOfTLA ( ) ; } } if ( sv . size ( ) > NUM_ ) { String spaces = NSpaces ( indent ) ; while ( nextLine < sv . size ( ) - NUM_ ) { tlacode . addElement ( spaces + ( ( String ) sv . elementAt ( nextLine ) ) ) ; mappingVector . addElement ( ( Vector ) exprMapping . elementAt ( nextLine ) ) ; nextLine ++ ; } tlacodeNextLine = spaces + ( ( String ) sv . elementAt ( nextLine ) ) ; mappingVectorNextLine = ( Vector ) exprMapping . elementAt ( nextLine ) ; } else if ( indent == NUM_ ) { tlacodeNextLine = tlacodeNextLine + ( ( String ) sv . elementAt ( NUM_ ) ) ; mappingVectorNextLine . addAll ( ( Vector ) exprMapping . elementAt ( NUM_ ) ) ; } }
private boolean isUpperCaseCamelCaseHunk ( String hunk ) { if ( hunk . length ( ) < NUM_ ) return BOOL_ ; for ( int i = NUM_ ; i < hunk . length ( ) ; i ++ ) { if ( ! isLegalChar ( hunk . charAt ( i ) ) ) return BOOL_ ; } return BOOL_ ; }
void addFillComponents ( Container panel , int [ ] cols , int [ ] rows ) { Dimension filler = new Dimension ( NUM_ , NUM_ ) ; boolean filled_cell_11 = BOOL_ ; CellConstraints cc = new CellConstraints ( ) ; if ( cols . length > NUM_ && rows . length > NUM_ ) { if ( cols [ NUM_ ] == NUM_ && rows [ NUM_ ] == NUM_ ) { panel . add ( Box . createRigidArea ( filler ) , cc . xy ( NUM_ , NUM_ ) ) ; filled_cell_11 = BOOL_ ; } } for ( int index = NUM_ ; index < cols . length ; index ++ ) { if ( cols [ index ] == NUM_ && filled_cell_11 ) { continue ; } panel . add ( Box . createRigidArea ( filler ) , cc . xy ( cols [ index ] , NUM_ ) ) ; } for ( int index = NUM_ ; index < rows . length ; index ++ ) { if ( rows [ index ] == NUM_ && filled_cell_11 ) { continue ; } panel . add ( Box . createRigidArea ( filler ) , cc . xy ( NUM_ , rows [ index ] ) ) ; } }
public void type ( String string ) { for ( int i = NUM_ ; i < string . length ( ) ; i ++ ) { char c = string . charAt ( i ) ; type ( c ) ; } }
public boolean providesIdentifier ( ) { return BOOL_ ; }
static void removeRedundantAffix ( TranslatorUtils . IContain iContain , List < String > strList ) { if ( strList . size ( ) <= NUM_ ) { return ; } int w = NUM_ ; for ( String str : strList ) { if ( w == NUM_ || ! iContain . containFunc ( str , strList . get ( w - NUM_ ) ) ) { strList . set ( w , str ) ; w ++ ; } } strList = strList . subList ( NUM_ , w ) ; }
public static int nextInt ( int n ) { Random random = getRandom ( ) ; int value = random . nextInt ( n ) ; if ( ! _isTest ) _freeRandomList . free ( random ) ; return value ; }
protected void doResumeUpdates ( ) { Calendar cal = Calendar . getInstance ( Locale . getDefault ( ) ) ; mFirstDayOfWeek = cal . getFirstDayOfWeek ( ) - NUM_ ; mShowWeekNumber = BOOL_ ; updateHeader ( ) ; goTo ( mSelectedDay . toMillis ( BOOL_ ) , BOOL_ , BOOL_ , BOOL_ ) ; mAdapter . setSelectedDay ( mSelectedDay ) ; mTodayUpdater . run ( ) ; }
private void storeLastUsed ( ) { put ( LAST_USE , ( int ) ( System . currentTimeMillis ( ) / NUM_ ) ) ; }
private boolean canContain ( ElementContainmentInfo child , ElementContainmentInfo top , int topIndex ) { int childTypes = child . types ; int contents = top . contents ; int transparencyAllowed = childTypes & ( top . transparentToContents & ~ contents ) ; for ( int containerIndex = topIndex - NUM_ ; transparencyAllowed != NUM_ ; -- containerIndex ) { if ( containerIndex < NUM_ ) { contents |= transparencyAllowed ; break ; } ElementContainmentInfo container = openElements . get ( containerIndex ) ; contents |= transparencyAllowed & container . contents ; transparencyAllowed = transparencyAllowed & container . transparentToContents & ~ contents ; } return ( contents & childTypes ) != NUM_ ; }
public static int [ ] extractArcs ( ASN1ObjectIdentifier oid ) throws InvalidObjectIdException { String oidStr = oid . getId ( ) ; StringTokenizer strTokCnt = new StringTokenizer ( oidStr , STR_ , BOOL_ ) ; int arcCount = strTokCnt . countTokens ( ) ; StringTokenizer strTok = new StringTokenizer ( oidStr , STR_ , BOOL_ ) ; boolean expectDelimiter = BOOL_ ; int [ ] arcs = new int [ arcCount ] ; int i = NUM_ ; while ( strTok . hasMoreTokens ( ) ) { String token = strTok . nextToken ( ) ; if ( expectDelimiter && ( ! token . equals ( STR_ ) || ! strTok . hasMoreTokens ( ) ) ) { throw new InvalidObjectIdException ( res . getString ( STR_ ) ) ; } else if ( ! expectDelimiter ) { try { arcs [ i ] = Integer . parseInt ( token ) ; if ( arcs [ i ] < NUM_ ) { throw new InvalidObjectIdException ( res . getString ( STR_ ) ) ; } i ++ ; } catch ( NumberFormatException ex ) { throw new InvalidObjectIdException ( res . getString ( STR_ ) ) ; } } expectDelimiter = ! expectDelimiter ; } return arcs ; }
public void testIsDuplicateString ( ) { int count = NUM_ ; ActiveMQMessageAudit audit = new ActiveMQMessageAudit ( ) ; IdGenerator idGen = new IdGenerator ( ) ; List < String > list = new ArrayList < > ( ) ; for ( int i = NUM_ ; i < count ; i ++ ) { String id = idGen . generateId ( ) ; list . add ( id ) ; assertFalse ( audit . isDuplicate ( id ) ) ; } List < String > windowList = list . subList ( list . size ( ) - NUM_ - audit . getAuditDepth ( ) , list . size ( ) - NUM_ ) ; for ( String id : windowList ) { assertTrue ( STR_ + id , audit . isDuplicate ( id ) ) ; } }
protected void updateStatsForConditionalDensityEstimator ( ConditionalDensityEstimator classifier , Instance classMissing , double classValue ) throws Exception { if ( m_PriorEstimator == null ) { setNumericPriorsFromBuffer ( ) ; } m_SumSchemeEntropy -= classifier . logDensity ( classMissing , classValue ) . classMissing . weight ( ) / Utils . log2 ; m_SumPriorEntropy -= m_PriorEstimator . logDensity ( classValue ) . classMissing . weight ( ) / Utils . log2 ; }
@ Override public boolean accept ( File f ) { if ( f != null ) { if ( f . isDirectory ( ) ) { return BOOL_ ; } String extension = getExtension ( f ) ; if ( extension != null && filters . get ( getExtension ( f ) ) != null ) { return BOOL_ ; } ; } return BOOL_ ; }
public void testCase3 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte rBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int bSign = - NUM_ ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . add ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
@ Override public PollResult startPoll ( PollController conn ) { if ( ! _lifecycle . isActive ( ) ) { log . warning ( this + STR_ ) ; return PollResult . CLOSED ; } SocketBar socket = conn . getSocket ( ) ; if ( socket == null ) { log . warning ( this + STR_ + conn ) ; return PollResult . CLOSED ; } SelectableChannel selChannel = socket . selectableChannel ( ) ; if ( selChannel == null ) { log . warning ( this + STR_ + socket ) ; return PollResult . CLOSED ; } _connectionCount . incrementAndGet ( ) ; _activeCount . incrementAndGet ( ) ; _registerQueue . offer ( conn ) ; return PollResult . START ; }
@ Override public void incrementAccessCount ( ) { accessCount . incrementAndGet ( ) ; }
public ClusterPolicy createClusterPolicy ( String clusterMemberName ) throws CreateException { long time1 = System . currentTimeMillis ( ) ; if ( _clusterPolicies == null ) { _clusterMemberNames = getClusterMemberNames ( ) ; if ( _clusterMemberNames != null && _clusterMemberNames . length > NUM_ ) { _clusterPolicies = new HashMap < String , ClusterPolicy > ( ) ; ClusterPolicy [ ] tempPolicy = new ClusterPolicy [ _clusterMemberNames . length ] ; for ( int i = NUM_ ; i < _clusterMemberNames . length ; i ++ ) tempPolicy [ i ] = createClusterPolicyInternal ( _clusterMemberNames [ i ] ) ; ArrayList < ReplicationPolicy > selectedReplPolicies = new ArrayList < ReplicationPolicy > ( _clusterMemberNames . length ) ; List < String > selectedReplGroupNames = new ArrayList < String > ( _clusterMemberNames . length ) ; for ( int i = NUM_ ; i < tempPolicy . length ; i ++ ) if ( tempPolicy [ i ] . m_ReplicationPolicy != null && ! selectedReplGroupNames . contains ( tempPolicy [ i ] . m_ReplicationPolicy . m_ReplicationGroupName ) ) { selectedReplPolicies . add ( tempPolicy [ i ] . m_ReplicationPolicy ) ; selectedReplGroupNames . add ( tempPolicy [ i ] . m_ReplicationPolicy . m_ReplicationGroupName ) ; } if ( selectedReplPolicies . isEmpty ( ) ) selectedReplPolicies = null ; else selectedReplPolicies . trimToSize ( ) ; for ( int i = NUM_ ; i < _clusterMemberNames . length ; i ++ ) { tempPolicy [ i ] . m_ReplicationGroups = selectedReplPolicies ; _clusterPolicies . put ( _clusterMemberNames [ i ] , tempPolicy [ i ] ) ; } } } ClusterPolicy result = _clusterPolicies . get ( clusterMemberName ) ; if ( result == null ) result = createClusterPolicyInternal ( clusterMemberName ) ; long time2 = System . currentTimeMillis ( ) ; if ( _logger . isLoggable ( Level . FINE ) ) { _logger . fine ( STR_ + clusterMemberName + STR_ + ( time2 - time1 ) + STR_ ) ; } return result ; }
public static boolean compareDoubles ( double a , double b ) { if ( Double . isNaN ( a ) && Double . isNaN ( b ) ) return BOOL_ ; if ( ! Double . isInfinite ( a ) && ! Double . isInfinite ( b ) ) return Math . abs ( a - b ) <= EPSILON ; return a == b ; }
public static byte [ ] bitmapToByte ( Bitmap b ) { ByteArrayOutputStream o = new ByteArrayOutputStream ( ) ; b . compress ( Bitmap . CompressFormat . PNG , NUM_ , o ) ; return o . toByteArray ( ) ; }
public ConfigureCoerceiveParsingDialog_NB ( CoerciveParsing coerciveParsing ) { this . coerciveParsing = coerciveParsing ; initComponents ( ) ; final IterateModel numberOfTagsIterator = coerciveParsing . getNumberOfTagsIterator ( ) ; configureIterateModel_NB2 . setStartAt ( String . valueOf ( numberOfTagsIterator . getStartAt ( ) ) ) ; configureIterateModel_NB2 . setStopAt ( String . valueOf ( numberOfTagsIterator . getStopAt ( ) ) ) ; configureIterateModel_NB2 . setIncrement ( String . valueOf ( numberOfTagsIterator . getIncrement ( ) ) ) ; configureIterateModel_NB2 . setIterateStrategie ( numberOfTagsIterator . getIterateStrategie ( ) ) ; List < String > tagNames = Arrays . asList ( coerciveParsing . getTagNames ( ) ) ; configureStringList_NB1 . setStringList ( tagNames ) ; }
public static double logOfBase ( double number , int base ) { return Math . log ( number ) / Math . log ( base ) ; }
public Entry editEntry ( User user , String id , String note , String quotation , boolean isPublic , Long modTime , boolean isAdmin , Errors errors ) { if ( modTime == null ) { Errors . add ( errors , errorMessages . errorModTimeIsNull ( ) ) ; return null ; } if ( user == null ) { Errors . add ( errors , errorMessages . errorUserIsNull ( ) ) ; return null ; } if ( id != null && ! idGenerator . isIdWellFormed ( id ) ) { Errors . add ( errors , errorMessages . errorIdIsInvalid ( ) ) ; return null ; } final Entry entry = getEntryById ( id ) ; if ( entry == null ) { Errors . add ( errors , errorMessages . errorTheEntryCouldNotBeFound ( ) ) ; return null ; } if ( ! canUserModifyEntry ( user , entry , isAdmin ) ) { Errors . add ( errors , errorMessages . errorTheUserIsNotEntitledToModifyTheEntry ( ) ) ; return null ; } if ( note != null ) { note = cleanUpText ( note ) ; } if ( entry . isNotebook ( ) ) { entry . setNotebookTitle ( note ) ; } else if ( entry . isSource ( ) ) { entry . setSourceTitle ( note ) ; } else { entry . setNote ( note ) ; } entry . setModTime ( modTime ) ; entry . setIsPublic ( isPublic ) ; if ( entry . getCreateTime ( ) > modTime . longValue ( ) ) { modTime = entry . getCreateTime ( ) ; } if ( entry . isQuotation ( ) ) { if ( quotation != null ) { quotation = cleanUpText ( quotation ) ; entry . setQuotation ( quotation ) ; } } return entry ; }
public FileSaverDescriptor ( @ NotNull String title , @ NotNull String description , String ... extensions ) { super ( BOOL_ , BOOL_ , BOOL_ , BOOL_ , BOOL_ , BOOL_ ) ; setTitle ( title ) ; setDescription ( description ) ; this . extensions = Arrays . asList ( extensions ) ; }
protected int readBlock ( ) { blockSize = read ( ) ; int n = NUM_ ; if ( blockSize > NUM_ ) { try { int count ; while ( n < blockSize ) { count = blockSize - n ; rawData . get ( block , n , count ) ; n += count ; } } catch ( final Exception e ) { Log . w ( TAG , STR_ , e ) ; status = STATUS_FORMAT_ERROR ; } } return n ; }
public void addRun ( final Run run ) { runs . add ( run ) ; run . setId ( runIdCounter ++ ) ; }
void copyInto ( Converter [ ] converters ) { System . arraycopy ( iConverters , NUM_ , converters , NUM_ , iConverters . length ) ; }
@ Override public boolean addOutputSensor ( String sensorName , int state ) { OutputSensor outputSensor = new OutputSensor ( sensorName ) ; if ( ! outputSensor . setState ( state ) ) { return BOOL_ ; } _outputSensorList . add ( outputSensor ) ; return BOOL_ ; }
public void init ( SocketChannel channel ) { _channel = channel ; _readBuffer . clear ( ) ; _readBuffer . flip ( ) ; _needsFlush = BOOL_ ; }
public void reset ( ) { Timber . i ( STR_ ) ; mCurrentPlayer . reset ( ) ; mNextPlayer . reset ( ) ; mQueue = Collections . emptyList ( ) ; mQueueIndex = NUM_ ; mRequestedSeekPosition = NUM_ ; mPlayWhenPrepared = BOOL_ ; }
@ Override public Expected < T > ifPresent ( final Consumer < ? super T > consumer ) { if ( this . value != null ) consumer . accept ( this . value ) ; return this ; }
protected void sendIntensity ( double intensity ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + intensity + STR_ + STR_ + lastOutputStep + STR_ + maxDimStep ) ; } int newStep = ( int ) Math . round ( intensity . maxDimStep ) ; if ( ( newStep < NUM_ ) || ( newStep > maxDimStep ) ) { log . error ( STR_ + newStep + STR_ + intensity ) ; } if ( newStep == NUM_ ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + intensity + STR_ ) ; } return ; } X10Sequence out = new X10Sequence ( ) ; out . addExtData ( housecode , devicecode , X10Sequence . EXTCMD_DIM , newStep ) ; tc . sendX10Sequence ( out , null ) ; lastOutputStep = newStep ; if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + intensity + STR_ + X10Sequence . houseValueToText ( housecode ) + STR_ + devicecode + STR_ + newStep ) ; } }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
public static float readFloat ( ) { return scanner . nextFloat ( ) ; }
public GlowScheduler ( GlowServer server , WorldScheduler worlds ) { this . server = server ; this . worlds = worlds ; inTickTaskCondition = worlds . getAdvanceCondition ( ) ; tickEndRun = null ; primaryThread = Thread . currentThread ( ) ; }
public void test_fill$IIII ( ) { int val = Integer . MAX_VALUE ; int d [ ] = new int [ NUM_ ] ; Arrays . fill ( d , NUM_ , d . length , val ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) assertTrue ( STR_ , ! ( d [ i ] == val ) ) ; for ( int i = NUM_ ; i < d . length ; i ++ ) assertTrue ( STR_ , d [ i ] == val ) ; try { Arrays . fill ( d , NUM_ , NUM_ , val ) ; fail ( STR_ ) ; } catch ( IllegalArgumentException e ) { } try { Arrays . fill ( d , - NUM_ , NUM_ , val ) ; fail ( STR_ ) ; } catch ( ArrayIndexOutOfBoundsException e ) { } try { Arrays . fill ( d , NUM_ , d . length + NUM_ , val ) ; fail ( STR_ ) ; } catch ( ArrayIndexOutOfBoundsException e ) { } }
private int calculateLayoutWidth ( int widthSize , int mode ) { initResourcesIfNecessary ( ) ; itemsLayout . setLayoutParams ( new LayoutParams ( LayoutParams . WRAP_CONTENT , LayoutParams . WRAP_CONTENT ) ) ; itemsLayout . measure ( MeasureSpec . makeMeasureSpec ( widthSize , MeasureSpec . UNSPECIFIED ) , MeasureSpec . makeMeasureSpec ( NUM_ , MeasureSpec . UNSPECIFIED ) ) ; int width = itemsLayout . getMeasuredWidth ( ) ; if ( mode == MeasureSpec . EXACTLY ) { width = widthSize ; } else { width += NUM_ . PADDING ; width = Math . max ( width , getSuggestedMinimumWidth ( ) ) ; if ( mode == MeasureSpec . AT_MOST && widthSize < width ) { width = widthSize ; } } itemsLayout . measure ( MeasureSpec . makeMeasureSpec ( width - NUM_ . PADDING , MeasureSpec . EXACTLY ) , MeasureSpec . makeMeasureSpec ( NUM_ , MeasureSpec . UNSPECIFIED ) ) ; return width ; }
public void delete ( ) throws IOException { close ( ) ; Utils . deleteContents ( directory ) ; }
@ Override public boolean execute ( @ NotNull PsiElement pe , @ NotNull ResolveState state ) { if ( pe instanceof PsiVariable ) { final PsiVariable pvar = ( PsiVariable ) pe ; if ( ! myStaticSensitiveFlag || ! myStaticScopeFlag || pvar . hasModifierProperty ( PsiModifier . STATIC ) ) { if ( check ( pvar , state ) ) { myResultList . add ( pvar ) ; } } } return BOOL_ ; }
public void characters ( char [ ] ch , int start , int length ) throws SAXException { try { stopTerminator ( ) ; if ( w == null ) return ; int end = start + length ; for ( int i = start ; i < end ; i ++ ) { char c = ch [ i ] ; switch ( c ) { case STR_ : w . write ( STR_ ) ; break ; case STR_ : w . write ( STR_ ) ; break ; case STR_ : w . write ( STR_ ) ; break ; case STR_ : case STR_ : case STR_ : w . write ( c ) ; break ; default : if ( canEncode ( c ) ) { w . write ( c ) ; } else { w . write ( STR_ ) ; w . write ( Integer . toString ( c ) ) ; w . write ( STR_ ) ; } break ; } } } catch ( IOException e ) { throw new SAXException ( e ) ; } }
public static String toHumanReadableString ( final String iso8601Duration ) { String str = STR_ ; if ( iso8601Duration . matches ( STR_ ) ) { str = STR_ ; } else { String hours = getHours ( iso8601Duration ) , minutes = getMinutes ( iso8601Duration ) , seconds = getSeconds ( iso8601Duration ) ; if ( hours != null ) { str = hours ; if ( minutes != null && minutes . length ( ) == NUM_ ) { minutes = STR_ + minutes ; } } if ( str . isEmpty ( ) ) str = minutes ; else str += STR_ + minutes ; if ( str . isEmpty ( ) ) str = seconds ; else str += STR_ + seconds ; } return str ; }
@ Override public IChatMessage sendMessage ( final String text ) throws RemoteException { if ( TextUtils . isEmpty ( text ) ) { throw new ServerApiIllegalArgumentException ( STR_ ) ; } int messageLength = text . length ( ) ; int maxMessageLength = mRcsSettings . getMaxGroupChatMessageLength ( ) ; if ( messageLength > maxMessageLength ) { throw new ServerApiIllegalArgumentException ( STR_ + messageLength + STR_ + maxMessageLength + STR_ ) ; } if ( ! isAllowedToSendMessage ( ) ) { throw new ServerApiPermissionDeniedException ( STR_ ) ; } try { mImService . removeGroupChatComposingStatus ( mChatId ) ; long timestamp = System . currentTimeMillis ( ) ; final ChatMessage msg = ChatUtils . createTextMessage ( null , text , timestamp , timestamp ) ; ChatMessagePersistedStorageAccessor persistedStorage = new ChatMessagePersistedStorageAccessor ( mMessagingLog , msg . getMessageId ( ) , msg . getRemoteContact ( ) , text , msg . getMimeType ( ) , mChatId , Direction . OUTGOING ) ; addOutgoingGroupChatMessage ( msg , Content . Status . QUEUED , Content . ReasonCode . UNSPECIFIED ) ; if ( ! mChatService . isGroupChatActive ( mChatId ) ) { mChatService . setGroupChatStateAndReasonCode ( mChatId , GroupChat . State . STARTED , GroupChat . ReasonCode . UNSPECIFIED ) ; } mImService . tryToDequeueGroupChatMessagesAndGroupFileTransfers ( mChatId ) ; return new ChatMessageImpl ( persistedStorage ) ; } catch ( ServerApiBaseException e ) { if ( ! e . shouldNotBeLogged ( ) ) { sLogger . error ( ExceptionUtil . getFullStackTrace ( e ) ) ; } throw e ; } catch ( Exception e ) { sLogger . error ( ExceptionUtil . getFullStackTrace ( e ) ) ; throw new ServerApiGenericException ( e ) ; } }
public java . lang . String toString ( ) { return toString ( value ) ; }
void remove ( TcpServerThread t ) { running . remove ( t ) ; }
public DockNodeEventHandler ( Node node ) { this . node = node ; }
private int readSourceToLog ( Settings settings ) { String sourceToLog = settings . get ( INDEX_INDEXING_SLOWLOG_MAX_SOURCE_CHARS_TO_LOG , STR_ ) ; try { return Integer . parseInt ( sourceToLog , NUM_ ) ; } catch ( NumberFormatException e ) { return Booleans . parseBoolean ( sourceToLog , BOOL_ ) ? Integer . MAX_VALUE : NUM_ ; } }
private void deleteCurrentLicenseFileOnDisk ( ) { File licenseFile = new File ( LicenseConstants . LICENSE_FILE_PATH ) ; if ( licenseFile . exists ( ) ) { licenseFile . delete ( ) ; } }
@ Deprecated public static NetworkParameters testNet ( ) { return TestNet3Params . get ( ) ; }
@ Override public void run ( ) { synchronized ( mSync ) { mRequestStop = BOOL_ ; mRequestDrain = NUM_ ; mSync . notify ( ) ; } final boolean isRunning = BOOL_ ; boolean localRequestStop ; boolean localRequestDrain ; while ( isRunning ) { synchronized ( mSync ) { localRequestStop = mRequestStop ; localRequestDrain = ( mRequestDrain > NUM_ ) ; if ( localRequestDrain ) mRequestDrain -- ; } if ( localRequestStop ) { drain ( ) ; signalEndOfInputStream ( ) ; drain ( ) ; release ( ) ; break ; } if ( localRequestDrain ) { drain ( ) ; } else { synchronized ( mSync ) { try { mSync . wait ( ) ; } catch ( final InterruptedException e ) { break ; } } } } if ( DEBUG ) Log . d ( TAG , STR_ ) ; synchronized ( mSync ) { mRequestStop = BOOL_ ; mIsCapturing = BOOL_ ; } }
public final void readFromStream ( DataInputStream dis , int version ) throws IOException , ChessParseError { event = dis . readUTF ( ) ; site = dis . readUTF ( ) ; date = dis . readUTF ( ) ; round = dis . readUTF ( ) ; white = dis . readUTF ( ) ; black = dis . readUTF ( ) ; startPos = TextIO . readFEN ( dis . readUTF ( ) ) ; currentPos = new Position ( startPos ) ; timeControl = dis . readUTF ( ) ; if ( version >= NUM_ ) { whiteTimeControl = dis . readUTF ( ) ; blackTimeControl = dis . readUTF ( ) ; } else { whiteTimeControl = STR_ ; blackTimeControl = STR_ ; } int nTags = dis . readInt ( ) ; tagPairs . clear ( ) ; for ( int i = NUM_ ; i < nTags ; i ++ ) { TagPair tp = new TagPair ( ) ; tp . tagName = dis . readUTF ( ) ; tp . tagValue = dis . readUTF ( ) ; tagPairs . add ( tp ) ; } rootNode = new Node ( ) ; Node . readFromStream ( dis , rootNode ) ; currentNode = rootNode ; int pathLen = dis . readInt ( ) ; for ( int i = NUM_ ; i < pathLen ; i ++ ) goForward ( dis . readInt ( ) ) ; updateListener ( ) ; }
public Rect updateFastScrollerBounds ( BaseRecyclerView rv , int lastTouchY ) { mInvalidateRect . set ( mBgBounds ) ; if ( isVisible ( ) ) { int edgePadding = rv . getMaxScrollbarWidth ( ) ; int bgPadding = ( mBgOriginalSize - mTextBounds . height ( ) ) / NUM_ ; int bgHeight = mBgOriginalSize ; int bgWidth = Math . max ( mBgOriginalSize , mTextBounds . width ( ) + ( NUM_ . bgPadding ) ) ; if ( Utilities . isRtl ( mRes ) ) { mBgBounds . left = rv . getBackgroundPadding ( ) . left + ( NUM_ . rv . getMaxScrollbarWidth ( ) ) ; mBgBounds . right = mBgBounds . left + bgWidth ; } else { mBgBounds . right = rv . getWidth ( ) - rv . getBackgroundPadding ( ) . right - ( NUM_ . rv . getMaxScrollbarWidth ( ) ) ; mBgBounds . left = mBgBounds . right - bgWidth ; } mBgBounds . top = lastTouchY - ( int ) ( FAST_SCROLL_OVERLAY_Y_OFFSET_FACTOR . bgHeight ) ; mBgBounds . top = Math . max ( edgePadding , Math . min ( mBgBounds . top , rv . getHeight ( ) - edgePadding - bgHeight ) ) ; mBgBounds . bottom = mBgBounds . top + bgHeight ; } else { mBgBounds . setEmpty ( ) ; } mInvalidateRect . union ( mBgBounds ) ; return mInvalidateRect ; }
public DNetscapeCaPolicyUrl ( JDialog parent ) { super ( parent ) ; setTitle ( res . getString ( STR_ ) ) ; initComponents ( ) ; }
public boolean textboxKeyTyped ( char p_146201_1_ , int p_146201_2_ ) { if ( ! isFocused ) return BOOL_ ; else if ( GuiScreen . func_175278_g ( p_146201_2_ ) ) { setCursorPositionEnd ( ) ; setSelectionPos ( NUM_ ) ; return BOOL_ ; } else if ( GuiScreen . func_175280_f ( p_146201_2_ ) ) { GuiScreen . setClipboardString ( getSelectedText ( ) ) ; return BOOL_ ; } else if ( GuiScreen . func_175279_e ( p_146201_2_ ) ) { if ( isEnabled ) writeText ( GuiScreen . getClipboardString ( ) ) ; return BOOL_ ; } else if ( GuiScreen . func_175277_d ( p_146201_2_ ) ) { GuiScreen . setClipboardString ( getSelectedText ( ) ) ; if ( isEnabled ) writeText ( STR_ ) ; return BOOL_ ; } else switch ( p_146201_2_ ) { case NUM_ : if ( GuiScreen . isCtrlKeyDown ( ) ) { if ( isEnabled ) deleteWords ( - NUM_ ) ; } else if ( isEnabled ) deleteFromCursor ( - NUM_ ) ; return BOOL_ ; case NUM_ : if ( GuiScreen . isShiftKeyDown ( ) ) setSelectionPos ( NUM_ ) ; else setCursorPositionZero ( ) ; return BOOL_ ; case NUM_ : if ( GuiScreen . isShiftKeyDown ( ) ) { if ( GuiScreen . isCtrlKeyDown ( ) ) setSelectionPos ( getNthWordFromPos ( - NUM_ , getSelectionEnd ( ) ) ) ; else setSelectionPos ( getSelectionEnd ( ) - NUM_ ) ; } else if ( GuiScreen . isCtrlKeyDown ( ) ) setCursorPosition ( getNthWordFromCursor ( - NUM_ ) ) ; else moveCursorBy ( - NUM_ ) ; return BOOL_ ; case NUM_ : if ( GuiScreen . isShiftKeyDown ( ) ) { if ( GuiScreen . isCtrlKeyDown ( ) ) setSelectionPos ( getNthWordFromPos ( NUM_ , getSelectionEnd ( ) ) ) ; else setSelectionPos ( getSelectionEnd ( ) + NUM_ ) ; } else if ( GuiScreen . isCtrlKeyDown ( ) ) setCursorPosition ( getNthWordFromCursor ( NUM_ ) ) ; else moveCursorBy ( NUM_ ) ; return BOOL_ ; case NUM_ : if ( GuiScreen . isShiftKeyDown ( ) ) setSelectionPos ( text . length ( ) ) ; else setCursorPositionEnd ( ) ; return BOOL_ ; case NUM_ : if ( GuiScreen . isCtrlKeyDown ( ) ) { if ( isEnabled ) deleteWords ( NUM_ ) ; } else if ( isEnabled ) deleteFromCursor ( NUM_ ) ; return BOOL_ ; default : if ( EmailAllowedCharacters . isAllowedCharacter ( p_146201_1_ ) ) { if ( isEnabled ) writeText ( Character . toString ( p_146201_1_ ) ) ; return BOOL_ ; } else return BOOL_ ; } }
protected int match_bitap ( String text , String pattern , int loc ) { assert ( Match_MaxBits == NUM_ || pattern . length ( ) <= Match_MaxBits ) : STR_ ; Map < Character , Integer > s = match_alphabet ( pattern ) ; double score_threshold = Match_Threshold ; int best_loc = text . indexOf ( pattern , loc ) ; if ( best_loc != - NUM_ ) { score_threshold = Math . min ( match_bitapScore ( NUM_ , best_loc , loc , pattern ) , score_threshold ) ; best_loc = text . lastIndexOf ( pattern , loc + pattern . length ( ) ) ; if ( best_loc != - NUM_ ) { score_threshold = Math . min ( match_bitapScore ( NUM_ , best_loc , loc , pattern ) , score_threshold ) ; } } int matchmask = NUM_ << ( pattern . length ( ) - NUM_ ) ; best_loc = - NUM_ ; int bin_min , bin_mid ; int bin_max = pattern . length ( ) + text . length ( ) ; int [ ] last_rd = new int [ NUM_ ] ; for ( int d = NUM_ ; d < pattern . length ( ) ; d ++ ) { bin_min = NUM_ ; bin_mid = bin_max ; while ( bin_min < bin_mid ) { if ( match_bitapScore ( d , loc + bin_mid , loc , pattern ) <= score_threshold ) { bin_min = bin_mid ; } else { bin_max = bin_mid ; } bin_mid = ( bin_max - bin_min ) / NUM_ + bin_min ; } bin_max = bin_mid ; int start = Math . max ( NUM_ , loc - bin_mid + NUM_ ) ; int finish = Math . min ( loc + bin_mid , text . length ( ) ) + pattern . length ( ) ; int [ ] rd = new int [ finish + NUM_ ] ; rd [ finish + NUM_ ] = ( NUM_ << d ) - NUM_ ; for ( int j = finish ; j >= start ; j -- ) { int charMatch ; if ( text . length ( ) <= j - NUM_ || ! s . containsKey ( text . charAt ( j - NUM_ ) ) ) { charMatch = NUM_ ; } else { charMatch = s . get ( text . charAt ( j - NUM_ ) ) ; } if ( d == NUM_ ) { rd [ j ] = ( ( rd [ j + NUM_ ] << NUM_ ) | NUM_ ) & charMatch ; } else { rd [ j ] = ( ( ( rd [ j + NUM_ ] << NUM_ ) | NUM_ ) & charMatch ) | ( ( ( last_rd [ j + NUM_ ] | last_rd [ j ] ) << NUM_ ) | NUM_ ) | last_rd [ j + NUM_ ] ; } if ( ( rd [ j ] & matchmask ) != NUM_ ) { double score = match_bitapScore ( d , j - NUM_ , loc , pattern ) ; if ( score <= score_threshold ) { score_threshold = score ; best_loc = j - NUM_ ; if ( best_loc > loc ) { start = Math . max ( NUM_ , NUM_ . loc - best_loc ) ; } else { break ; } } } } if ( match_bitapScore ( d + NUM_ , loc , loc , pattern ) > score_threshold ) { break ; } last_rd = rd ; } return best_loc ; }
public static Path createDirectory ( final Path parent , final String folderName ) { final File file = new File ( parent . toFile ( ) , folderName ) ; if ( ! file . exists ( ) ) { if ( ! file . mkdir ( ) ) { throw new RuntimeException ( STR_ + parent + STR_ + folderName + STR_ ) ; } } file . deleteOnExit ( ) ; return file . toPath ( ) ; }
public static boolean isWindows8 ( ) { return osName . indexOf ( STR_ ) > - NUM_ && ( osVersion . equals ( STR_ ) || osVersion . equals ( STR_ ) ) ; }
protected Set < FunctionInterface > findUnusedFunctions ( Set < UnitInterface > units ) { Set < FunctionInterface > allFunctions = new HashSet < FunctionInterface > ( ) ; Set < FunctionInterface > usedFunctions = new HashSet < FunctionInterface > ( ) ; for ( UnitInterface unit : units ) { List < FunctionInterface > unitFunctions = getUnitFunctions ( unit ) ; allFunctions . addAll ( unitFunctions ) ; for ( FunctionInterface unitFunction : unitFunctions ) { for ( FunctionInterface usedFunction : unitFunction . getCalledFunctions ( ) ) { usedFunctions . add ( usedFunction ) ; } } } allFunctions . removeAll ( usedFunctions ) ; return allFunctions ; }
private static void addItemsToList ( int startIndex , int endIndex ) { for ( int i = startIndex ; i < endIndex ; i ++ ) { values . add ( new Integer ( i ) ) ; } }
public static synchronized List < Proxy > noProxyList ( ) { if ( noProxyList == null ) { ArrayList < Proxy > list = new ArrayList < Proxy > ( NUM_ ) ; list . add ( Proxy . NO_PROXY ) ; noProxyList = Collections . unmodifiableList ( list ) ; } return noProxyList ; }
public void addIncludes ( String [ ] definitions ) { addStrings ( INCLUDES , definitions ) ; addStrings ( linker_more , INCLUDES , definitions ) ; newLinkerOptionsAfterCompile . add ( INCLUDES ) ; }
protected void add ( double value , int group ) { if ( ( group < NUM_ ) || ( group >= numberOfGroups ) ) { throw new IllegalArgumentException ( ) ; } data . add ( new RankedObservation ( value , group ) ) ; }
public void tallyVariant ( VcfHeader header , VcfRecord rec ) { tallyVariant ( rec , header . getSampleNames ( ) ) ; }
public int read ( byte [ ] b , int off , int len ) throws IOException { if ( closed ) { throw new IOException ( STR_ ) ; } if ( eof ) { return - NUM_ ; } if ( pos >= chunkSize ) { nextChunk ( ) ; if ( eof ) { return - NUM_ ; } } len = Math . min ( len , chunkSize - pos ) ; int count = in . read ( b , off , len ) ; pos += count ; return count ; }
public LDIFEntryReader ( final String ... ldifLines ) { super ( Arrays . asList ( ldifLines ) ) ; }
public void updatePresonInfo ( ) { this . leftPerson = person2LeavingPersonInfo . get ( this . personId ) ; this . enteredPerson = person2EnteringPersonInfo . get ( this . personId ) ; }
public MyMap remove ( int position ) { MyMap mm = null ; if ( position >= NUM_ && position < getItemCount ( ) ) { mm = myMaps . remove ( position ) ; notifyItemRemoved ( position ) ; } return mm ; }
public void presentLicenses ( boolean preAccept ) { LicenseSet licenses = licenseModule . getRequiredLicenses ( ) ; if ( preAccept ) { licenses . acceptAll ( ) ; } else { for ( License license : licenses ) { if ( license . isAccepted ( ) ) { continue ; } user . show ( STR_ ) ; user . show ( license . getLicenseText ( ) ) ; String input = user . ask ( STR_ ) ; if ( input != null && YES . startsWith ( input . toLowerCase ( ) ) ) { license . accept ( ) ; } else { license . reject ( ) ; } } } }
public void addGeoKey ( XTIFFField geoKey ) { geoKeyIndex . put ( new Integer ( geoKey . getTag ( ) ) , geoKey ) ; hasGeoKeys = BOOL_ ; }
public static GeoTimeSerie detect ( GeoTimeSerie gts , int alphabetSize , int wordLen , int windowLen , Collection < String > patterns , boolean standardizePAA ) throws WarpScriptException { GeoTimeSerie gtsPatterns = GTSHelper . bSAX ( gts , alphabetSize , wordLen , windowLen , standardizePAA ) ; GTSHelper . sort ( gtsPatterns ) ; GeoTimeSerie detected = new GeoTimeSerie ( gts . lastbucket , gts . bucketcount , gts . bucketspan , NUM_ ) ; detected . setMetadata ( gts . getMetadata ( ) ) ; int lastidx = - NUM_ ; for ( int i = NUM_ ; i < gtsPatterns . values ; i ++ ) { if ( ! patterns . contains ( gtsPatterns . stringValues [ i ] ) ) { continue ; } for ( int j = NUM_ ; j < windowLen ; j ++ ) { if ( i + j > lastidx ) { lastidx = i + j ; GTSHelper . setValue ( detected , GTSHelper . tickAtIndex ( gts , lastidx ) , GTSHelper . locationAtIndex ( gts , lastidx ) , GTSHelper . elevationAtIndex ( gts , lastidx ) , GTSHelper . valueAtIndex ( gts , lastidx ) , BOOL_ ) ; } } } return detected ; }
private StringBuilder debugDumpCandidates ( StringBuilder msg , List < ? extends Itemset > candidates , VectorFieldTypeInformation < BitVector > meta ) { msg . append ( STR_ ) ; for ( Itemset itemset : candidates ) { msg . append ( STR_ ) ; itemset . appendTo ( msg , meta ) ; msg . append ( STR_ ) ; } return msg ; }
public static final void writeBooleanArrayXml ( boolean [ ] val , String name , XmlSerializer out ) throws XmlPullParserException , java . io . IOException { if ( val == null ) { out . startTag ( null , STR_ ) ; out . endTag ( null , STR_ ) ; return ; } out . startTag ( null , STR_ ) ; if ( name != null ) { out . attribute ( null , STR_ , name ) ; } final int N = val . length ; out . attribute ( null , STR_ , Integer . toString ( N ) ) ; for ( int i = NUM_ ; i < N ; i ++ ) { out . startTag ( null , STR_ ) ; out . attribute ( null , STR_ , Boolean . toString ( val [ i ] ) ) ; out . endTag ( null , STR_ ) ; } out . endTag ( null , STR_ ) ; }
public void addOutboundRule ( final OutboundRule outboundRule ) { outboundRule . setId ( outboundRuleIdCounter ++ ) ; outboundRules . add ( outboundRule ) ; }
public Skype ( String username , String password ) { this . username = username ; this . password = password ; }
private void stopDrag ( MotionEvent ev ) { mTouchMode = TOUCH_MODE_IDLE ; final boolean commitChange = ev . getAction ( ) == MotionEvent . ACTION_UP && isEnabled ( ) ; final boolean oldState = isChecked ( ) ; final boolean newState ; if ( commitChange ) { mVelocityTracker . computeCurrentVelocity ( NUM_ ) ; final float xvel = mVelocityTracker . getXVelocity ( ) ; if ( Math . abs ( xvel ) > mMinFlingVelocity ) { newState = ViewUtils . isLayoutRtl ( this ) ? ( xvel < NUM_ ) : ( xvel > NUM_ ) ; } else { newState = getTargetCheckedState ( ) ; } } else { newState = oldState ; } if ( newState != oldState ) { playSoundEffect ( SoundEffectConstants . CLICK ) ; } setChecked ( newState ) ; cancelSuperTouch ( ev ) ; }
private void addFlags ( int newflags ) { flags = getLayoutFlags ( ) | newflags ; }
public static String matchCertificate ( KeyStore keyStore , X509Certificate cert ) throws CryptoException { try { for ( Enumeration aliases = keyStore . aliases ( ) ; aliases . hasMoreElements ( ) ; ) { String alias = ( String ) aliases . nextElement ( ) ; if ( keyStore . isCertificateEntry ( alias ) ) { X509Certificate compCert = X509CertUtil . convertCertificate ( keyStore . getCertificate ( alias ) ) ; if ( cert . equals ( compCert ) ) { return alias ; } } } return null ; } catch ( KeyStoreException ex ) { throw new CryptoException ( res . getString ( STR_ ) , ex ) ; } }
void purgeLastArticles ( int amountToPurge ) { if ( ! isDBAvailable ( ) ) return ; long time = System . currentTimeMillis ( ) ; String query = STR_ + TABLE_ARTICLES + STR_ + ( Utils . ARTICLE_LIMIT - amountToPurge + STR_ ) ; safelyDeleteArticles ( query , null ) ; Log . d ( TAG , STR_ + ( System . currentTimeMillis ( ) - time ) + STR_ ) ; }
public void reclaimViews ( List < View > views ) { int childCount = getChildCount ( ) ; RecyclerListener listener = mRecycler . mRecyclerListener ; for ( int i = NUM_ ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; TwoWayAbsListView . LayoutParams lp = ( TwoWayAbsListView . LayoutParams ) child . getLayoutParams ( ) ; if ( lp != null && mRecycler . shouldRecycleViewType ( lp . viewType ) ) { views . add ( child ) ; if ( listener != null ) { listener . onMovedToScrapHeap ( child ) ; } } } mRecycler . reclaimScrapViews ( views ) ; removeAllViewsInLayout ( ) ; }
ProxyVerifier ( TxnManager serverProxy , Uuid proxyID ) { if ( ! ( serverProxy instanceof RemoteMethodControl ) ) { throw new UnsupportedOperationException ( STR_ ) ; } else if ( ! ( serverProxy instanceof TrustEquivalence ) ) { throw new UnsupportedOperationException ( STR_ + STR_ ) ; } else if ( proxyID == null ) { throw new IllegalArgumentException ( STR_ ) ; } this . serverProxy = ( RemoteMethodControl ) serverProxy ; this . proxyID = proxyID ; }
public void paint ( Graphics g ) { g . translate ( NUM_ , translateY ) ; super . paint ( g ) ; }
private void beforeKey ( ) throws JSONException { Scope context = peek ( ) ; if ( context == Scope . NONEMPTY_OBJECT ) { out . append ( STR_ ) ; } else if ( context != Scope . EMPTY_OBJECT ) { throw new JSONException ( STR_ ) ; } newline ( ) ; replaceTop ( Scope . DANGLING_KEY ) ; }
public static void transfer ( InputStream in , OutputStream out , int bufferSize ) throws IOException { byte [ ] buffer = new byte [ bufferSize ] ; int bytesRead ; while ( ( bytesRead = in . read ( buffer ) ) != - NUM_ ) { out . write ( buffer , NUM_ , bytesRead ) ; } }
public void testFileDirectory ( ) throws Exception { Properties properties = loadProperties ( STR_ ) ; assertEquals ( STR_ , properties . getProperty ( STR_ ) ) ; }
private static long addAndCheck ( long a , long b , Localizable pattern ) throws MathRuntimeException { final long result = a + b ; if ( ! ( ( a ^ b ) < NUM_ || ( a ^ result ) >= NUM_ ) ) { throw new MathRuntimeException ( pattern , a , b ) ; } return result ; }
private void serializeCompactRDFGeneralQualifier ( int indent , XMPNode node ) throws IOException , XMPException { write ( STR_ ) ; writeNewline ( ) ; serializeCanonicalRDFProperty ( node , BOOL_ , BOOL_ , indent + NUM_ ) ; for ( Iterator iq = node . iterateQualifier ( ) ; iq . hasNext ( ) ; ) { XMPNode qualifier = ( XMPNode ) iq . next ( ) ; serializeCanonicalRDFProperty ( qualifier , BOOL_ , BOOL_ , indent + NUM_ ) ; } }
private JCheckBox addCheckbox ( String text , Container container ) { JCheckBox checkbox = new JCheckBox ( text ) ; checkbox . setAlignmentX ( Component . LEFT_ALIGNMENT ) ; checkbox . setBorder ( BorderFactory . createEmptyBorder ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; container . add ( checkbox ) ; return checkbox ; }
@ Override public void drawBackground ( Graphics2D g2 , CategoryPlot plot , Rectangle2D dataArea ) { float x0 = ( float ) dataArea . getX ( ) ; float x1 = x0 + ( float ) Math . abs ( this . xOffset ) ; float x3 = ( float ) dataArea . getMaxX ( ) ; float x2 = x3 - ( float ) Math . abs ( this . xOffset ) ; float y0 = ( float ) dataArea . getMaxY ( ) ; float y1 = y0 - ( float ) Math . abs ( this . yOffset ) ; float y3 = ( float ) dataArea . getMinY ( ) ; float y2 = y3 + ( float ) Math . abs ( this . yOffset ) ; GeneralPath clip = new GeneralPath ( ) ; clip . moveTo ( x0 , y0 ) ; clip . lineTo ( x0 , y2 ) ; clip . lineTo ( x1 , y3 ) ; clip . lineTo ( x3 , y3 ) ; clip . lineTo ( x3 , y1 ) ; clip . lineTo ( x2 , y0 ) ; clip . closePath ( ) ; Composite originalComposite = g2 . getComposite ( ) ; g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , plot . getBackgroundAlpha ( ) ) ) ; Paint backgroundPaint = plot . getBackgroundPaint ( ) ; if ( backgroundPaint != null ) { g2 . setPaint ( backgroundPaint ) ; g2 . fill ( clip ) ; } GeneralPath leftWall = new GeneralPath ( ) ; leftWall . moveTo ( x0 , y0 ) ; leftWall . lineTo ( x0 , y2 ) ; leftWall . lineTo ( x1 , y3 ) ; leftWall . lineTo ( x1 , y1 ) ; leftWall . closePath ( ) ; g2 . setPaint ( getWallPaint ( ) ) ; g2 . fill ( leftWall ) ; GeneralPath bottomWall = new GeneralPath ( ) ; bottomWall . moveTo ( x0 , y0 ) ; bottomWall . lineTo ( x1 , y1 ) ; bottomWall . lineTo ( x3 , y1 ) ; bottomWall . lineTo ( x2 , y0 ) ; bottomWall . closePath ( ) ; g2 . setPaint ( getWallPaint ( ) ) ; g2 . fill ( bottomWall ) ; g2 . setPaint ( Color . lightGray ) ; Line2D corner = new Line2D . Double ( x0 , y0 , x1 , y1 ) ; g2 . draw ( corner ) ; corner . setLine ( x1 , y1 , x1 , y3 ) ; g2 . draw ( corner ) ; corner . setLine ( x1 , y1 , x3 , y1 ) ; g2 . draw ( corner ) ; Image backgroundImage = plot . getBackgroundImage ( ) ; if ( backgroundImage != null ) { Rectangle2D adjusted = new Rectangle2D . Double ( dataArea . getX ( ) + getXOffset ( ) , dataArea . getY ( ) , dataArea . getWidth ( ) - getXOffset ( ) , dataArea . getHeight ( ) - getYOffset ( ) ) ; plot . drawBackgroundImage ( g2 , adjusted ) ; } g2 . setComposite ( originalComposite ) ; }
public void push ( ) { state . cliprgn = g . getClipBounds ( ) ; stack . push ( state ) ; state = ( GraphicsState ) state . clone ( ) ; }
public static void dropIndex ( Connection conn , String schema , String table ) throws SQLException { init ( conn ) ; PreparedStatement prep = conn . prepareStatement ( STR_ + SCHEMA + STR_ ) ; prep . setString ( NUM_ , schema ) ; prep . setString ( NUM_ , table ) ; ResultSet rs = prep . executeQuery ( ) ; if ( ! rs . next ( ) ) { return ; } int indexId = rs . getInt ( NUM_ ) ; prep = conn . prepareStatement ( STR_ + SCHEMA + STR_ ) ; prep . setInt ( NUM_ , indexId ) ; prep . execute ( ) ; createOrDropTrigger ( conn , schema , table , BOOL_ ) ; prep = conn . prepareStatement ( STR_ + SCHEMA + STR_ ) ; while ( BOOL_ ) { prep . setInt ( NUM_ , indexId ) ; int deleted = prep . executeUpdate ( ) ; if ( deleted == NUM_ ) { break ; } } prep = conn . prepareStatement ( STR_ + SCHEMA + STR_ + STR_ + SCHEMA + STR_ ) ; while ( BOOL_ ) { int deleted = prep . executeUpdate ( ) ; if ( deleted == NUM_ ) { break ; } } }
public E peek ( ) { if ( isEmpty ( ) ) { return null ; } return elements [ NUM_ ] ; }
public synchronized int add ( IAudioProcessor processor ) { processors . add ( processor ) ; buildFinalProcessor ( ) ; return processors . indexOf ( processor ) ; }
public ScriptBuilder data ( int index , byte [ ] data ) { byte [ ] copy = Arrays . copyOf ( data , data . length ) ; int opcode ; if ( data . length == NUM_ ) { opcode = OP_0 ; } else if ( data . length == NUM_ ) { byte b = data [ NUM_ ] ; if ( b >= NUM_ && b <= NUM_ ) opcode = Script . encodeToOpN ( b ) ; else opcode = NUM_ ; } else if ( data . length < OP_PUSHDATA1 ) { opcode = data . length ; } else if ( data . length < NUM_ ) { opcode = OP_PUSHDATA1 ; } else if ( data . length < NUM_ ) { opcode = OP_PUSHDATA2 ; } else { throw new RuntimeException ( STR_ ) ; } return addChunk ( index , new ScriptChunk ( opcode , copy ) ) ; }
public void initialize ( Map configParams ) { String delimiterConfig = ( String ) configParams . get ( PolicyConfig . RESOURCE_COMPARATOR_DELIMITER ) ; if ( delimiterConfig != null ) { this . delimiter = delimiterConfig ; } String caseConfig = ( String ) configParams . get ( PolicyConfig . RESOURCE_COMPARATOR_CASE_SENSITIVE ) ; if ( caseConfig != null ) { if ( caseConfig . equals ( STR_ ) ) { this . caseSensitive = BOOL_ ; } else if ( caseConfig . equals ( STR_ ) ) { this . caseSensitive = BOOL_ ; } else { this . caseSensitive = BOOL_ ; } } String wildcardConfig = ( String ) configParams . get ( PolicyConfig . RESOURCE_COMPARATOR_WILDCARD ) ; if ( wildcardConfig != null ) { this . wildcard = wildcardConfig ; } String oneLevelWildcardConfig = ( String ) configParams . get ( PolicyConfig . RESOURCE_COMPARATOR_ONE_LEVEL_WILDCARD ) ; if ( oneLevelWildcardConfig != null ) { this . oneLevelWildcard = oneLevelWildcardConfig ; } if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + STR_ + delimiter + STR_ + wildcard + STR_ + oneLevelWildcard + STR_ + caseConfig ) ; } oneLevelWildcardLength = oneLevelWildcard . length ( ) ; wildcardLength = wildcard . length ( ) ; if ( oneLevelWildcard . indexOf ( wildcard ) != - NUM_ ) { wildcardEmbedded = BOOL_ ; } else { wildcardEmbedded = BOOL_ ; } if ( wildcard . indexOf ( oneLevelWildcard ) != - NUM_ ) { oneLevelWildcardEmbedded = BOOL_ ; } else { oneLevelWildcardEmbedded = BOOL_ ; } if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + wildcardEmbedded + STR_ + oneLevelWildcardEmbedded ) ; } return ; }
protected void deleteLeastUsedEntry ( ) { try { poolLock . lock ( ) ; BasicPoolEntry entry = freeConnections . remove ( ) ; if ( entry != null ) { deleteEntry ( entry ) ; } else if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ ) ; } } finally { poolLock . unlock ( ) ; } }
private String convertLessThanOneThousand ( int number ) { String soFar ; if ( number % NUM_ < NUM_ ) { soFar = numNames [ number % NUM_ ] ; number /= NUM_ ; } else { soFar = numNames [ number % NUM_ ] ; number /= NUM_ ; String s = Integer . toString ( number ) ; if ( s . endsWith ( STR_ ) && ! soFar . equals ( STR_ ) ) soFar = STR_ + soFar . trim ( ) ; else if ( soFar . equals ( STR_ ) ) soFar = tensNames [ number % NUM_ ] + soFar ; else soFar = tensNames [ number % NUM_ ] + STR_ + soFar ; number /= NUM_ ; } if ( number == NUM_ ) return tensNames [ number % NUM_ ] + soFar ; if ( number > NUM_ ) soFar = STR_ + soFar ; if ( number == NUM_ && ! soFar . equals ( STR_ ) ) number = NUM_ ; return numNames [ number ] + STR_ + soFar ; }
public static boolean isEmbeddedBase64Image ( String uri ) { return ( uri != null && uri . startsWith ( STR_ ) ) ; }
void changeState ( int newState ) { int oldState ; synchronized ( stateLock ) { if ( state == newState ) return ; oldState = state ; state = newState ; stateLock . notifyAll ( ) ; } sendStateChangeNotification ( oldState , newState ) ; }
private int parseLinkLabel ( ) { String m = match ( LINK_LABEL ) ; return m == null ? NUM_ : m . length ( ) ; }
private static void insertCommentsInNode ( Node node , List < Comment > commentsToAttribute ) { if ( commentsToAttribute . size ( ) == NUM_ ) return ; List < Node > children = node . getChildrenNodes ( ) ; PositionUtils . sortByBeginPosition ( children ) ; for ( Node child : children ) { List < Comment > commentsInsideChild = new LinkedList < Comment > ( ) ; for ( Comment c : commentsToAttribute ) { if ( PositionUtils . nodeContains ( child , c , _doNotConsiderAnnotationsAsNodeStartForCodeAttribution ) ) { commentsInsideChild . add ( c ) ; } } commentsToAttribute . removeAll ( commentsInsideChild ) ; insertCommentsInNode ( child , commentsInsideChild ) ; } List < Comment > attributedComments = new LinkedList < Comment > ( ) ; for ( Comment comment : commentsToAttribute ) { if ( comment . isLineComment ( ) ) { for ( Node child : children ) { if ( child . getEndLine ( ) == comment . getBeginLine ( ) ) { if ( attributeLineCommentToNodeOrChild ( child , comment . asLineComment ( ) ) ) { attributedComments . add ( comment ) ; } } } } } Comment previousComment = null ; attributedComments = new LinkedList < Comment > ( ) ; List < Node > childrenAndComments = new LinkedList < Node > ( ) ; childrenAndComments . addAll ( children ) ; childrenAndComments . addAll ( commentsToAttribute ) ; PositionUtils . sortByBeginPosition ( childrenAndComments , _doNotConsiderAnnotationsAsNodeStartForCodeAttribution ) ; for ( Node thing : childrenAndComments ) { if ( thing instanceof Comment ) { previousComment = ( Comment ) thing ; if ( ! previousComment . isOrphan ( ) ) { previousComment = null ; } } else { if ( previousComment != null && ! thing . hasComment ( ) ) { if ( ! _doNotAssignCommentsPreceedingEmptyLines || ! thereAreLinesBetween ( previousComment , thing ) ) { thing . setComment ( previousComment ) ; attributedComments . add ( previousComment ) ; previousComment = null ; } } } } commentsToAttribute . removeAll ( attributedComments ) ; for ( Comment c : commentsToAttribute ) { if ( c . isOrphan ( ) ) { node . addOrphanComment ( c ) ; } } }
public static String readFileAsString ( File file ) throws FileNotFoundException { return readFileAsString ( file . getAbsolutePath ( ) ) ; }
protected void onException ( final WroRuntimeException e ) { throw e ; }
public synchronized void checkAccess ( LicenseCheckerCallback callback ) { if ( mPolicy . allowAccess ( ) ) { Log . i ( TAG , STR_ ) ; callback . allow ( Policy . LICENSED ) ; } else { LicenseValidator validator = new LicenseValidator ( mPolicy , new NullDeviceLimiter ( ) , callback , generateNonce ( ) , mPackageName , mVersionCode ) ; if ( mService == null ) { Log . i ( TAG , STR_ ) ; try { boolean bindResult = mContext . bindService ( new Intent ( new String ( Base64 . decode ( STR_ ) ) ) , this , Context . BIND_AUTO_CREATE ) ; if ( bindResult ) { mPendingChecks . offer ( validator ) ; } else { Log . e ( TAG , STR_ ) ; handleServiceConnectionError ( validator ) ; } } catch ( SecurityException e ) { callback . applicationError ( LicenseCheckerCallback . ERROR_MISSING_PERMISSION ) ; } catch ( Base64DecoderException e ) { e . printStackTrace ( ) ; } } else { mPendingChecks . offer ( validator ) ; runChecks ( ) ; } } }
public void close ( ) { if ( ! isOpen ) return ; Log . d ( TAG , STR_ ) ; loadingLock . lock ( ) ; try { save ( ) ; if ( saveFileStream != null ) { SavingHelper . close ( saveFileStream ) ; saveFileStream = null ; } savingDisabled = BOOL_ ; isOpen = BOOL_ ; Log . i ( TAG , STR_ ) ; } finally { loadingLock . unlock ( ) ; } }
protected int selectOperator ( ) { lastUpdate ++ ; if ( ( lastUpdate >= UPDATE_WINDOW ) || ( probabilities == null ) ) { lastUpdate = NUM_ ; probabilities = getOperatorProbabilities ( ) ; } double rand = PRNG . nextDouble ( ) ; double sum = NUM_ ; for ( int i = NUM_ ; i < operators . size ( ) ; i ++ ) { sum += probabilities [ i ] ; if ( sum > rand ) { return i ; } } throw new IllegalStateException ( ) ; }
@ Override public List chunkString ( String sToChunk ) { Integer [ ] iRes = splitPointsByDelimiterList ( sToChunk , getDelimiters ( ) ) ; String [ ] sRes = splitStringByDelimiterPoints ( sToChunk , iRes ) ; return Arrays . asList ( sRes ) ; }
public static String convertBooleanArrToString ( Boolean [ ] noDictionaryDimsMapping ) { StringBuilder builder = new StringBuilder ( ) ; int index = NUM_ ; for ( ; index < noDictionaryDimsMapping . length ; index ++ ) { builder . append ( noDictionaryDimsMapping [ index ] ) ; builder . append ( CarbonCommonConstants . COMA_SPC_CHARACTER ) ; } int lastIndex = builder . lastIndexOf ( CarbonCommonConstants . COMA_SPC_CHARACTER ) ; String str = - NUM_ != lastIndex ? builder . substring ( NUM_ , lastIndex ) : builder . toString ( ) ; return str ; }
public ByteBuffer decodeBufferToByteBuffer ( String inputString ) throws IOException { return ByteBuffer . wrap ( decodeBuffer ( inputString ) ) ; }
public void clear ( ) { m_Model . clear ( ) ; setButtons ( null ) ; }
public static int brighter ( int c ) { int r = red ( c ) , g = green ( c ) , b = blue ( c ) ; int i = ( int ) ( NUM_ / ( NUM_ - scale ) ) ; if ( r == NUM_ && g == NUM_ && b == NUM_ ) { return rgba ( i , i , i , alpha ( c ) ) ; } if ( r > NUM_ && r < i ) r = i ; if ( g > NUM_ && g < i ) g = i ; if ( b > NUM_ && b < i ) b = i ; return rgba ( Math . min ( NUM_ , ( int ) ( r / scale ) ) , Math . min ( NUM_ , ( int ) ( g / scale ) ) , Math . min ( NUM_ , ( int ) ( b / scale ) ) , alpha ( c ) ) ; }
public void shutdown ( ) { running = BOOL_ ; if ( networkThreads != null ) { for ( NetworkThread n : networkThreads ) { n . stopped = BOOL_ ; } } networkThreads = null ; synchronized ( LOCK ) { LOCK . notifyAll ( ) ; } }
public SerialMessage ( byte [ ] a ) { super ( String . valueOf ( a ) ) ; setBinary ( BOOL_ ) ; }
@ Override @ SuppressWarnings ( STR_ ) public void completed ( int bytesTransferred , boolean canInvokeDirect ) { if ( bytesTransferred == NUM_ ) { bytesTransferred = - NUM_ ; } else { updateBuffers ( bytesTransferred ) ; } releaseBuffers ( ) ; synchronized ( result ) { if ( result . isDone ( ) ) return ; enableReading ( ) ; if ( scatteringRead ) { result . setResult ( ( V ) Long . valueOf ( bytesTransferred ) ) ; } else { result . setResult ( ( V ) Integer . valueOf ( bytesTransferred ) ) ; } } if ( canInvokeDirect ) { Invoker . invokeUnchecked ( result ) ; } else { Invoker . invoke ( result ) ; } }
public void writeGolomb ( int divisor , int value ) { int q = value / divisor ; for ( int i = NUM_ ; i < q ; i ++ ) { writeBit ( NUM_ ) ; } writeBit ( NUM_ ) ; int r = value - q . divisor ; int bit = NUM_ - Integer . numberOfLeadingZeros ( divisor - NUM_ ) ; if ( r < ( ( NUM_ << bit ) - divisor ) ) { bit -- ; } else { r += ( NUM_ << bit ) - divisor ; } for ( ; bit >= NUM_ ; bit -- ) { writeBit ( ( r > > > bit ) & NUM_ ) ; } }
public void addForce ( Force f ) { if ( f . isItemForce ( ) ) { if ( iforces . length == iflen ) { Force [ ] newf = new Force [ iflen + NUM_ ] ; System . arraycopy ( iforces , NUM_ , newf , NUM_ , iforces . length ) ; iforces = newf ; } iforces [ iflen ++ ] = f ; } if ( f . isSpringForce ( ) ) { if ( sforces . length == sflen ) { Force [ ] newf = new Force [ sflen + NUM_ ] ; System . arraycopy ( sforces , NUM_ , newf , NUM_ , sforces . length ) ; sforces = newf ; } sforces [ sflen ++ ] = f ; } }
private static MetricValue number_to_metric_value_ ( Number elem ) { if ( elem == null ) return MetricValue . EMPTY ; final String num = elem . toString ( ) ; try { return MetricValue . fromIntValue ( Long . parseLong ( num ) ) ; } catch ( NumberFormatException ex ) { } try { return MetricValue . fromDblValue ( Double . parseDouble ( num ) ) ; } catch ( NumberFormatException ex ) { } return MetricValue . fromStrValue ( num ) ; }
public boolean overlaps ( String sequence , int start , int end ) { if ( start == MISSING || end == MISSING || end < start ) { throw new IllegalArgumentException ( ) ; } if ( ! mSequence . equals ( sequence ) ) { return BOOL_ ; } if ( ( mEnd != MISSING && start >= mEnd ) || ( end <= mStart ) ) { return BOOL_ ; } return BOOL_ ; }
public OkapiBM25 ( double k1 , double b ) { if ( Double . isNaN ( k1 ) || Double . isInfinite ( k1 ) || k1 < NUM_ ) throw new IllegalArgumentException ( STR_ + k1 ) ; this . k1 = k1 ; if ( Double . isNaN ( b ) || b < NUM_ || b > NUM_ ) throw new IllegalArgumentException ( STR_ + b ) ; this . b = b ; }
protected void prepare ( ) { for ( ProcessInfoParameter para : getParameter ( ) ) { String name = para . getParameterName ( ) ; if ( para . getParameter ( ) == null ) ; else if ( name . equals ( PARAM_M_Warehouse_ID ) ) p_M_Warehouse_ID = para . getParameterAsInt ( ) ; else log . log ( Level . SEVERE , STR_ + name ) ; } p_C_Invoice_ID = getRecord_ID ( ) ; }
public boolean isConfigured ( ) { LOG . debug ( STR_ + url ) ; return url != null && ! url . isEmpty ( ) ; }
public static String [ ] commaDelimitedListToStringArray ( String str ) { return delimitedListToStringArray ( str , STR_ ) ; }
@ Override public byte [ ] readByteArray ( String filePath , long offset , int length ) { FileChannel fileChannel = updateCache ( filePath ) ; ByteBuffer byteBffer = read ( fileChannel , length , offset ) ; return byteBffer . array ( ) ; }
private static void FatalError ( JNIEnvironment env , Address messageAddress ) { if ( traceJNI ) VM . sysWrite ( STR_ ) ; RuntimeEntrypoints . checkJNICountDownToGC ( ) ; try { VM . sysWrite ( JNIGenericHelpers . createStringFromC ( messageAddress ) ) ; System . exit ( EXIT_STATUS_JNI_TROUBLE ) ; } catch ( Throwable unexpected ) { if ( traceJNI ) unexpected . printStackTrace ( System . err ) ; System . exit ( EXIT_STATUS_RECURSIVELY_SHUTTING_DOWN ) ; } }
public boolean makeBackupFile ( String directory , File file ) { if ( file == null ) { log . info ( STR_ ) ; } else if ( file . canWrite ( ) ) { String backupFullName = directory + File . separator + createFileNameWithDate ( file . getName ( ) ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + backupFullName ) ; } File backupFile = findFile ( backupFullName ) ; if ( backupFile != null ) { if ( backupFile . delete ( ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + backupFullName ) ; } } } else { backupFile = new File ( backupFullName ) ; } File parentDir = backupFile . getParentFile ( ) ; if ( ! parentDir . exists ( ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + parentDir . getName ( ) ) ; } if ( ! parentDir . mkdirs ( ) ) { log . error ( STR_ ) ; return BOOL_ ; } } if ( file . renameTo ( new File ( backupFullName ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + backupFullName ) ; } } else { if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + backupFullName ) ; } return BOOL_ ; } } return BOOL_ ; }
public final void pushPair ( int v1 , int v2 ) { if ( null == m_map ) { m_map = new int [ m_blocksize ] ; m_mapSize = m_blocksize ; } else { if ( ( m_firstFree + NUM_ ) >= m_mapSize ) { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , NUM_ , newMap , NUM_ , m_firstFree ) ; m_map = newMap ; } } m_map [ m_firstFree ] = v1 ; m_map [ m_firstFree + NUM_ ] = v2 ; m_firstFree += NUM_ ; }
public void removeStorage ( ) throws BackupException { logger . debug ( STR_ + dataDirSpec . getAbsolutePath ( ) ) ; processHelper . exec ( STR_ , rmCmd ) ; }
private void appendContainerConfig ( DockerSlaveTemplate slaveTemplate , CreateContainerCmd containerConfig ) { Map < String , String > labels = containerConfig . getLabels ( ) ; if ( labels == null ) { labels = new HashMap < > ( ) ; } labels . put ( DOCKER_CLOUD_LABEL , getDisplayName ( ) ) ; labels . put ( DOCKER_TEMPLATE_LABEL , slaveTemplate . getId ( ) ) ; containerConfig . withLabels ( labels ) ; }
public void deleteUsers ( Set users ) throws AMException , SSOException { Iterator iter = users . iterator ( ) ; while ( iter . hasNext ( ) ) { String userDN = ( String ) iter . next ( ) ; AMUser user = new AMUserImpl ( super . token , userDN ) ; user . delete ( ) ; } }
@ Override public boolean accept ( File file ) { String name = file . getName ( ) ; for ( String wildcard : wildcards ) { if ( FilenameUtils . wildcardMatch ( name , wildcard , caseSensitivity ) ) { return BOOL_ ; } } return BOOL_ ; }
public void removeRegion ( Region r ) { regions . remove ( r ) ; }
public static void silentCloseInputStream ( InputStream is ) { try { if ( is != null ) { is . close ( ) ; } } catch ( IOException e ) { log . w ( LOG_TAG , STR_ , e ) ; } }
@ Override public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { if ( requestID == null && localName . equals ( STR_ ) ) { requestID = attributes . getValue ( STR_ ) ; } super . startElement ( uri , localName , qName , attributes ) ; }
public void stop ( int timeout ) throws InterruptedException { if ( ! isclosed . compareAndSet ( BOOL_ , BOOL_ ) ) { return ; } List < WebSocket > socketsToClose = null ; synchronized ( connections ) { socketsToClose = new ArrayList < WebSocket > ( connections ) ; } for ( WebSocket ws : socketsToClose ) { ws . close ( CloseFrame . GOING_AWAY ) ; } synchronized ( this ) { if ( selectorthread != null ) { if ( Thread . currentThread ( ) != selectorthread ) { } if ( selectorthread != Thread . currentThread ( ) ) { if ( socketsToClose . size ( ) > NUM_ ) selectorthread . join ( timeout ) ; selectorthread . interrupt ( ) ; selectorthread . join ( ) ; } } } }
public Storage ( ) { this ( new File ( getTemporaryStorageDirectoryString ( ) ) ) ; }
@ RequiresPermission ( Manifest . permission . CAMERA ) public CameraSource start ( ) throws IOException { synchronized ( mCameraLock ) { if ( mCamera != null ) { return this ; } mCamera = createCamera ( ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . HONEYCOMB ) { mDummySurfaceTexture = new SurfaceTexture ( DUMMY_TEXTURE_NAME ) ; mCamera . setPreviewTexture ( mDummySurfaceTexture ) ; } else { mDummySurfaceView = new SurfaceView ( mContext ) ; mCamera . setPreviewDisplay ( mDummySurfaceView . getHolder ( ) ) ; } mCamera . startPreview ( ) ; isSafeToTakePicture = BOOL_ ; mProcessingThread = new Thread ( mFrameProcessor ) ; mFrameProcessor . setActive ( BOOL_ ) ; mProcessingThread . start ( ) ; } return this ; }
public void addBreakpointListener ( final BreakpointListener listener ) { breakpointListeners . add ( listener ) ; }
public void update ( Graphics g ) { if ( isShowing ( ) ) { if ( ! ( peer instanceof LightweightPeer ) ) { g . clearRect ( NUM_ , NUM_ , width , height ) ; } paint ( g ) ; } }
private void releaseWaiters ( int phase ) { QNode q ; Thread t ; AtomicReference < QNode > head = ( phase & NUM_ ) == NUM_ ? evenQ : oddQ ; while ( ( q = head . get ( ) ) != null && q . phase != ( int ) ( root . state > > > PHASE_SHIFT ) ) { if ( head . compareAndSet ( q , q . next ) && ( t = q . thread ) != null ) { q . thread = null ; LockSupport . unpark ( t ) ; } } }
public static DateFormat toDateTimeFormat ( String dateTimeFormat , TimeZone tz , Locale locale ) { DateFormat df = null ; if ( UtilValidate . isEmpty ( dateTimeFormat ) ) { df = DateFormat . getDateTimeInstance ( DateFormat . SHORT , DateFormat . MEDIUM , locale ) ; } else { df = new SimpleDateFormat ( dateTimeFormat , locale == null ? Locale . getDefault ( ) : locale ) ; } df . setTimeZone ( tz ) ; return df ; }
public static void printStackTrace ( Throwable e ) { try { Debug . printStackTrace ( e ) ; } catch ( Throwable f ) { e . printStackTrace ( ) ; } }
@ Override public Void visitType ( TypeElement e , Void p ) { scan ( e . getTypeParameters ( ) , p ) ; checkCamelCase ( e , BOOL_ ) ; super . visitType ( e , p ) ; return null ; }
public Block ( boolean multiPush ) { this ( multiPush , STR_ , null , Arrays . asList ( STR_ , STR_ ) ) ; }
private double Poisson ( double x ) { return Math . exp ( - m_Lambda + ( x . Math . log ( m_Lambda ) ) - logFac ( x ) ) ; }
protected Expression findExpression ( String source ) { if ( source != null && source . length ( ) > NUM_ ) { source = source . trim ( ) ; if ( source . length ( ) == NUM_ ) { return null ; } String leftSide = source ; String rightSide = null ; Connector op = findOp ( leftSide ) ; if ( op != null ) { rightSide = op . getRightSide ( leftSide ) ; leftSide = leftSide . substring ( NUM_ , op . sourceLoc ) ; Expression leftExpression = findExpression ( leftSide ) ; Expression rightExpression = findExpression ( rightSide ) ; if ( leftExpression != null ) { op . addExpr ( leftExpression ) ; } if ( rightExpression != null ) { op . addExpr ( rightExpression ) ; } return op ; } op = findMiniOp ( leftSide ) ; if ( op != null ) { rightSide = op . getRightSide ( leftSide ) ; leftSide = leftSide . substring ( NUM_ , op . sourceLoc ) ; Expression leftExpression = findExpression ( leftSide ) ; Expression rightExpression = findExpression ( rightSide ) ; if ( leftExpression != null ) { op . addExpr ( leftExpression ) ; } if ( rightExpression != null ) { op . addExpr ( rightExpression ) ; } return op ; } if ( logger . isLoggable ( Level . FINER ) ) { logger . finer ( STR_ + source ) ; } return findMathOp ( source ) ; } return null ; }
void putChannel ( final StoredClientChannel channel ) { putChannel ( channel , BOOL_ ) ; }
private void deleteFilesInDir ( File dir ) { for ( File child : dir . listFiles ( ) ) { child . delete ( ) ; } }
@ SuppressWarnings ( STR_ ) public static void pipeInputToOutputStream ( InputStream in , File fileOut , boolean ignoreErrors ) throws IOException { if ( fileOut == null ) { logger . error ( STR_ ) ; if ( ! ignoreErrors ) { throw new IOException ( STR_ ) ; } } else { File parent = fileOut . getParentFile ( ) ; if ( parent != null && ! parent . exists ( ) ) { parent . mkdirs ( ) ; } OutputStream fileStream = null ; try { fileStream = new FileOutputStream ( fileOut ) ; pipeInputToOutputStream ( in , fileStream , BOOL_ , ignoreErrors ) ; } catch ( IOException e ) { if ( fileStream != null ) { try { fileStream . close ( ) ; } catch ( IOException ex ) { logger . error ( STR_ , ex . getMessage ( ) ) ; } } if ( ! ignoreErrors ) { throw e ; } } } }
@ SuppressLint ( STR_ ) void release ( ) { assert ( mProcessingThread . getState ( ) == State . TERMINATED ) ; mDetector . release ( ) ; mDetector = null ; }
public static String trimLeadingCharacter ( String str , char leadingCharacter ) { if ( ! hasLength ( str ) ) { return str ; } StringBuilder sb = new StringBuilder ( str ) ; while ( sb . length ( ) > NUM_ && sb . charAt ( NUM_ ) == leadingCharacter ) { sb . deleteCharAt ( NUM_ ) ; } return sb . toString ( ) ; }
public E take ( ) throws InterruptedException { final ReentrantLock lock = this . lock ; lock . lockInterruptibly ( ) ; long t = now ( ) ; TenantQueue . Item item = null ; try { for ( ; ; ) { TenantQueue q = nextQueue ( t ) ; if ( q == null ) available . await ( ) ; else { long delay = q . next - t ; if ( delay <= NUM_ ) { item = q . poll ( t ) ; return item == null ? null : item . element ; } else if ( leader != null ) available . await ( ) ; else { Thread thisThread = Thread . currentThread ( ) ; leader = thisThread ; try { available . awaitNanos ( delay ) ; } finally { if ( leader == thisThread ) leader = null ; } } } t = System . nanoTime ( ) ; } } finally { if ( leader == null && hasNext ( ) ) available . signal ( ) ; lock . unlock ( ) ; done ( item , t ) ; } }
public boolean threadSafeTimeout ( long delayTime , TimeUnit unit , Action0 action ) { boolean scheduled = BOOL_ ; Thread currentThread = Thread . currentThread ( ) ; if ( currentThread . equals ( dutyThread ) ) { timerWheel . newTimeout ( delayTime , unit , null ) ; } else { scheduled = actions . offer ( null ) ; } return scheduled ; }
void submit ( ProcessAndDisplayImageTask task ) { initExecutorsIfNeed ( ) ; taskExecutorForCachedImages . execute ( task ) ; }
void addAttributeSelection ( String exp ) { int index = exp . indexOf ( STR_ ) ; String value = null ; int constraint = AttString . EQUALS ; if ( index != - NUM_ ) { if ( index == NUM_ ) { setTagId ( TAG_CSS_ILLEGAL_SELECTOR ) ; return ; } int opIndex = index ; char c = exp . charAt ( index - NUM_ ) ; if ( c == STR_ ) { constraint = AttString . CONTAINS_WORD ; opIndex -- ; } else if ( c == STR_ ) { constraint = AttString . BEGINS_WITH ; opIndex -- ; } value = exp . substring ( index + NUM_ ) ; if ( ( ( value . startsWith ( STR_ ) ) && ( value . endsWith ( STR_ ) ) ) || ( ( value . startsWith ( STR_ ) ) && ( value . endsWith ( STR_ ) ) ) ) { value = value . substring ( NUM_ , value . length ( ) - NUM_ ) ; } exp = exp . substring ( NUM_ , opIndex ) ; } if ( attributeSelections == null ) { attributeSelections = new Vector ( ) ; } attributeSelections . addElement ( new AttString ( exp , constraint , value ) ) ; }
private void createLeftOver ( ) { int lineLengthBytes = currentLastBytePos + NUM_ ; if ( lineLengthBytes > NUM_ ) { leftOver = new byte [ lineLengthBytes ] ; System . arraycopy ( data , NUM_ , leftOver , NUM_ , lineLengthBytes ) ; } else { leftOver = null ; } currentLastBytePos = - NUM_ ; }
public Value sample ( ) { int index = sampler . nextInt ( actionValues . size ( ) ) ; if ( actionValuesAsArray == null ) { actionValuesAsArray = actionValues . toArray ( new Value [ actionValues . size ( ) ] ) ; } return actionValuesAsArray [ index ] ; }
@ Override public void channelClosed ( ChannelHandlerContext channelHandlerContext , ChannelStateEvent channelStateEvent ) throws Exception { curr_conns . decrementAndGet ( ) ; channelGroup . remove ( channelHandlerContext . getChannel ( ) ) ; }
private static void configureHeadLessSimulation ( ) { System . setProperty ( STR_ , STR_ ) ; GAMA . setHeadLessMode ( ) ; }
public static boolean isNextWindow ( URI id ) { return id == null || NEXT . equals ( id ) ; }
public static boolean isVisible ( Class < ? > clazz , ClassLoader classLoader ) { if ( classLoader == null ) { return BOOL_ ; } try { Class < ? > actualClass = classLoader . loadClass ( clazz . getName ( ) ) ; return ( clazz == actualClass ) ; } catch ( ClassNotFoundException ex ) { return BOOL_ ; } }
public byte [ ] remove ( QueueEvent event ) throws KeeperException , InterruptedException { TimerContext time = stats . time ( dir + STR_ ) ; try { String path = event . getId ( ) ; String responsePath = dir + STR_ + response_prefix + path . substring ( path . lastIndexOf ( STR_ ) + NUM_ ) ; if ( zookeeper . exists ( responsePath , BOOL_ ) ) { zookeeper . setData ( responsePath , event . getBytes ( ) , BOOL_ ) ; } byte [ ] data = zookeeper . getData ( path , null , null , BOOL_ ) ; zookeeper . delete ( path , - NUM_ , BOOL_ ) ; return data ; } finally { time . stop ( ) ; } }
public PropertyXMLBuilder ( ServiceSchema serviceSchema , AMModel model , Set attributeSchemas ) throws SMSException , SSOException { this . model = model ; this . serviceName = serviceSchema . getServiceName ( ) ; getServiceResourceBundle ( serviceSchema ) ; if ( serviceBundle != null ) { mapTypeToAttributeSchema = new HashMap ( attributeSchemas . size ( ) . NUM_ ) ; mapTypeToAttributeSchema . put ( NULL_TYPE , attributeSchemas ) ; } }
public boolean is ( String arg , boolean allowAbbr ) { if ( name . equalsIgnoreCase ( arg ) ) { return BOOL_ ; } if ( allowAbbr && arg . length ( ) == NUM_ ) { if ( arg . charAt ( NUM_ ) == c ) { return BOOL_ ; } } return BOOL_ ; }
static public void addAll ( List < String > list , String [ ] array ) { for ( String item : array ) list . add ( item ) ; }
void remove ( SuperCardToast superCardToast ) { mList . remove ( superCardToast ) ; }
public void test_vmstat_header_and_data_parse ( ) { final Pattern pattern = VMStatCollector . pattern ; final String header = STR_ ; final String data = STR_ ; { final String [ ] fields = pattern . split ( header . trim ( ) , NUM_ ) ; for ( int i = NUM_ ; i < fields . length ; i ++ ) { if ( log . isInfoEnabled ( ) ) log . info ( STR_ + i + STR_ + fields [ i ] + STR_ ) ; } assertField ( header , fields , NUM_ , STR_ ) ; assertField ( header , fields , NUM_ , STR_ ) ; assertField ( header , fields , NUM_ , STR_ ) ; assertField ( header , fields , NUM_ , STR_ ) ; assertField ( header , fields , NUM_ , STR_ ) ; assertField ( header , fields , NUM_ , STR_ ) ; assertField ( header , fields , NUM_ , STR_ ) ; assertField ( header , fields , NUM_ , STR_ ) ; } { final String [ ] fields = pattern . split ( data . trim ( ) , NUM_ ) ; assertField ( data , fields , NUM_ , STR_ ) ; assertField ( data , fields , NUM_ , STR_ ) ; assertField ( data , fields , NUM_ , STR_ ) ; assertField ( data , fields , NUM_ , STR_ ) ; assertField ( data , fields , NUM_ , STR_ ) ; assertField ( data , fields , NUM_ , STR_ ) ; assertField ( data , fields , NUM_ , STR_ ) ; assertField ( data , fields , NUM_ , STR_ ) ; } }
public static SecretKeys generateKeyFromPassword ( String password , String salt ) throws GeneralSecurityException { return generateKeyFromPassword ( password , Base64 . decode ( salt , BASE64_FLAGS ) ) ; }
private String partiallyEscapeAssertionValue ( String assertionValue ) { StringBuilder sb = new StringBuilder ( assertionValue . length ( ) ) ; for ( int j = NUM_ ; j < assertionValue . length ( ) ; j ++ ) { char c = assertionValue . charAt ( j ) ; if ( c == STR_ ) { sb . append ( c ) ; } else { sb . append ( Filter . escapeAssertionValue ( String . valueOf ( c ) ) ) ; } } return sb . toString ( ) ; }
protected boolean filterLeftoverView ( ViewGroup parent , int childIndex ) { parent . removeViewAt ( childIndex ) ; return BOOL_ ; }
protected boolean declAlreadyDeclared ( String prefix ) { int startDecls = m_contextIndexes . peek ( ) ; java . util . Vector prefixMappings = m_prefixMappings ; int nDecls = prefixMappings . size ( ) ; for ( int i = startDecls ; i < nDecls ; i += NUM_ ) { String prefixDecl = ( String ) prefixMappings . elementAt ( i ) ; if ( prefixDecl == null ) continue ; if ( prefixDecl . equals ( prefix ) ) return BOOL_ ; } return BOOL_ ; }
@ Override public void step ( MessageLogger logger ) { try { addAgent ( ) ; env . step ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
public static AttackStatus calculatePhysicalStatus ( Creature attacker , Creature attacked , boolean isMainHand ) { return calculatePhysicalStatus ( attacker , attacked , isMainHand , NUM_ , NUM_ , BOOL_ , BOOL_ ) ; }
public T vertexProcessor ( final BiConsumer < Vertex , Map < String , Object > > vertexProcessor ) { this . vertexProcessor = Optional . ofNullable ( vertexProcessor ) ; return extendingClass . cast ( this ) ; }
synchronized boolean release ( ) { d ( STR_ ) ; if ( state == BUSY ) { state = IDLE ; idleSince = System . currentTimeMillis ( ) ; return BOOL_ ; } else { return BOOL_ ; } }
private void validateReplicaAvailability ( Slice slice , String shard , String collectionName , int count ) { if ( slice != null ) { Collection < Replica > allReplicasForShard = slice . getReplicas ( ) ; if ( allReplicasForShard == null ) { throw new SolrException ( SolrException . ErrorCode . BAD_REQUEST , STR_ + shard + STR_ + collectionName ) ; } if ( allReplicasForShard . size ( ) == NUM_ ) { throw new SolrException ( SolrException . ErrorCode . BAD_REQUEST , STR_ + shard + STR_ + collectionName + STR_ ) ; } if ( allReplicasForShard . size ( ) <= count ) { throw new SolrException ( SolrException . ErrorCode . BAD_REQUEST , STR_ + shard + STR_ + collectionName + STR_ + count + STR_ + allReplicasForShard . size ( ) + STR_ ) ; } } }
default ClassDeclaration asClass ( ) { throw new UnsupportedOperationException ( String . format ( STR_ , this ) ) ; }
private static String partitionSpecToName ( Map < String , String > spec ) { StringBuilder sb = new StringBuilder ( ) ; for ( Map . Entry < String , String > entry : spec . entrySet ( ) ) { if ( sb . length ( ) != NUM_ ) { sb . append ( STR_ ) ; } sb . append ( entry . getKey ( ) + STR_ + entry . getValue ( ) ) ; } return sb . toString ( ) ; }
public static InputStream toInputStream ( CharSequence input , Charset encoding ) { return toInputStream ( input . toString ( ) , encoding ) ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
public void testHitEndAfterFind ( ) { hitEndTest ( BOOL_ , STR_ , STR_ , STR_ , BOOL_ ) ; hitEndTest ( BOOL_ , STR_ , STR_ , STR_ , BOOL_ ) ; hitEndTest ( BOOL_ , STR_ , STR_ , STR_ , BOOL_ ) ; hitEndTest ( BOOL_ , STR_ , STR_ , STR_ , BOOL_ ) ; hitEndTest ( BOOL_ , STR_ , STR_ , STR_ , BOOL_ ) ; hitEndTest ( BOOL_ , STR_ , STR_ , STR_ , BOOL_ ) ; String floatRegex = getHexFloatRegex ( ) ; hitEndTest ( BOOL_ , STR_ , floatRegex , Double . toHexString ( - NUM_ ) , BOOL_ ) ; hitEndTest ( BOOL_ , STR_ , floatRegex , STR_ + Double . toHexString ( Double . NaN ) + STR_ , BOOL_ ) ; hitEndTest ( BOOL_ , STR_ , floatRegex , Double . toHexString ( - NUM_ ) + STR_ , BOOL_ ) ; hitEndTest ( BOOL_ , STR_ , floatRegex , STR_ + Double . toHexString ( Double . MIN_VALUE ) + STR_ , BOOL_ ) ; hitEndTest ( BOOL_ , STR_ , STR_ , STR_ , BOOL_ ) ; hitEndTest ( BOOL_ , STR_ , STR_ , STR_ , BOOL_ ) ; }
@ Modifying @ Transactional public void deleteCheque ( @ PathVariable Long chequeID ) { chequeRepository . delete ( chequeID ) ; photoRepository . deleteByChequeId ( chequeID . toString ( ) ) ; }
public static synchronized double partialCorrelation ( TetradMatrix submatrix ) { try { TetradMatrix inverse = submatrix . inverse ( ) ; double a = - NUM_ . inverse . get ( NUM_ , NUM_ ) ; double v0 = inverse . get ( NUM_ , NUM_ ) ; double v1 = inverse . get ( NUM_ , NUM_ ) ; double b = Math . sqrt ( v0 . v1 ) ; return a / b ; } catch ( Exception e ) { e . printStackTrace ( ) ; return Double . NaN ; } }
public void addColumn ( String name , String expr ) { Expression ex = ExpressionParser . parse ( expr ) ; Throwable t = ExpressionParser . getError ( ) ; if ( t != null ) { throw new RuntimeException ( t ) ; } else { addColumn ( name , ex ) ; } }
public void addPutAndGetTimeNanos ( long duration ) { putTimeNanos . addAndGet ( duration ) ; getTimeNanos . addAndGet ( duration ) ; if ( delegate != null ) delegate . addPutAndGetTimeNanos ( duration ) ; }
private float checkSaturationValid ( final float val ) { float tempval = val ; if ( val > NUM_ ) { tempval = NUM_ ; } if ( val < NUM_ ) { tempval = NUM_ ; } return tempval ; }
String parse ( String cellStr , int layoutConstant ) { return cellStr . split ( LayoutConstants . CELL_PTRN ) [ layoutConstant ] ; }
public void pseudoPropertyChange ( String propName , Object old , Object n ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + getSystemName ( ) + STR_ + propName + STR_ + n . toString ( ) ) ; } firePropertyChange ( propName , old , n ) ; }
public static String runCmd ( File directory , List < String > cmd , String errorMessage ) throws Exception { ProcessBuilder pb = new ProcessBuilder ( cmd ) ; pb . directory ( directory ) ; pb . redirectErrorStream ( BOOL_ ) ; Process p = pb . start ( ) ; String s ; StringBuilder sb = new StringBuilder ( ) ; BufferedReader stdout = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; while ( ( s = stdout . readLine ( ) ) != null ) { logger . info ( s ) ; sb . append ( s ) ; sb . append ( STR_ ) ; } String sbs = sb . toString ( ) ; int exitValue = p . waitFor ( ) ; if ( exitValue != NUM_ ) throw new Exception ( errorMessage + STR_ + exitValue + STR_ + sbs ) ; return sbs ; }
@ Override public SelectableChannel selectableChannel ( ) { return socketChannel ; }
public void test_ConstructorIIIIII ( ) { Date d1 = new Date ( NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ ) ; Date d2 = new Date ( NUM_ + d1 . getTimezoneOffset ( ) . NUM_ . NUM_ + NUM_ . NUM_ . NUM_ + NUM_ . NUM_ + NUM_ ) ; assertTrue ( STR_ , d1 . equals ( d2 ) ) ; }
public static String fromTag ( ByteArrayTag tag ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( ARRAY_START ) ; boolean start = BOOL_ ; for ( byte value : tag . getValue ( ) ) { ByteTag b = new ByteTag ( value ) ; if ( start ) { start = BOOL_ ; } else { builder . append ( ELEMENT_SEPERATOR ) ; } builder . append ( fromTag ( b ) ) ; } builder . append ( ARRAY_END ) ; return builder . toString ( ) ; }
@ Override protected void addChooserFilters ( JFileChooser chooser ) { javax . swing . filechooser . FileNameExtensionFilter filter = new javax . swing . filechooser . FileNameExtensionFilter ( Bundle . getMessage ( STR_ , STR_ ) , STR_ , STR_ ) ; chooser . addChoosableFileFilter ( new javax . swing . filechooser . FileNameExtensionFilter ( STR_ , STR_ ) ) ; chooser . addChoosableFileFilter ( new javax . swing . filechooser . FileNameExtensionFilter ( STR_ , STR_ ) ) ; chooser . addChoosableFileFilter ( filter ) ; chooser . setFileFilter ( filter ) ; }
public static DateTime parseRfc822 ( String str ) throws ParseException { Date date ; synchronized ( dateTimeFormat822 ) { try { date = dateTimeFormat822 . parse ( str ) ; } catch ( java . text . ParseException e ) { throw new ParseException ( e ) ; } } return new DateTime ( date ) ; }
public void testEmptyIndex ( ) throws Exception { IndexSearcher empty = newSearcher ( new MultiReader ( ) ) ; Query query = new TermQuery ( new Term ( STR_ , STR_ ) ) ; Sort sort = new Sort ( ) ; TopDocs td = empty . search ( query , NUM_ , sort , BOOL_ , BOOL_ ) ; assertEquals ( NUM_ , td . totalHits ) ; sort . setSort ( SortField . FIELD_DOC ) ; td = empty . search ( query , NUM_ , sort , BOOL_ , BOOL_ ) ; assertEquals ( NUM_ , td . totalHits ) ; sort . setSort ( new SortField ( STR_ , SortField . Type . INT ) , SortField . FIELD_DOC ) ; td = empty . search ( query , NUM_ , sort , BOOL_ , BOOL_ ) ; assertEquals ( NUM_ , td . totalHits ) ; sort . setSort ( new SortField ( STR_ , SortField . Type . STRING , BOOL_ ) , SortField . FIELD_DOC ) ; td = empty . search ( query , NUM_ , sort , BOOL_ , BOOL_ ) ; assertEquals ( NUM_ , td . totalHits ) ; sort . setSort ( new SortField ( STR_ , SortField . Type . STRING_VAL , BOOL_ ) , SortField . FIELD_DOC ) ; td = empty . search ( query , NUM_ , sort , BOOL_ , BOOL_ ) ; assertEquals ( NUM_ , td . totalHits ) ; sort . setSort ( new SortField ( STR_ , SortField . Type . FLOAT ) , new SortField ( STR_ , SortField . Type . STRING ) ) ; td = empty . search ( query , NUM_ , sort , BOOL_ , BOOL_ ) ; assertEquals ( NUM_ , td . totalHits ) ; }
public Model validateModel ( Dataset dataset , URI shapesGraphURI , Resource minSeverity , boolean validateShapes , Function < RDFNode , String > labelFunction , ProgressMonitor monitor ) throws InterruptedException { if ( dataset . getDefaultModel ( ) == null ) { throw new IllegalArgumentException ( STR_ ) ; } Model shapesModel = dataset . getNamedModel ( shapesGraphURI . toString ( ) ) ; if ( monitor != null ) { monitor . subTask ( STR_ ) ; } List < Property > constraintProperties = SHACLUtil . getAllConstraintProperties ( validateShapes ) ; Map < Resource , List < SHConstraint > > map = buildShape2ConstraintsMap ( shapesModel , dataset . getDefaultModel ( ) , constraintProperties , validateShapes ) ; if ( monitor != null ) { monitor . subTask ( STR_ ) ; } if ( monitor != null ) { monitor . beginTask ( STR_ + map . size ( ) + STR_ , map . size ( ) ) ; } Model results = JenaUtil . createMemoryModel ( ) ; results . setNsPrefixes ( dataset . getDefaultModel ( ) ) ; for ( Resource shape : map . keySet ( ) ) { for ( SHConstraint constraint : map . get ( shape ) ) { validateConstraintForShape ( dataset , shapesGraphURI , minSeverity , constraint , shape , results , labelFunction , monitor ) ; if ( monitor != null ) { monitor . worked ( NUM_ ) ; if ( monitor . isCanceled ( ) ) { throw new InterruptedException ( ) ; } } } } return results ; }
public PdfPage addAnnotation ( PdfAnnotation annotation ) { return addAnnotation ( - NUM_ , annotation , BOOL_ ) ; }
public static String findPreferredIDP ( String realm , HttpServletRequest request ) { if ( request == null ) { return null ; } String succinctID = request . getParameter ( IFSConstants . PROVIDER_ID_KEY ) ; if ( ( succinctID == null ) || succinctID . length ( ) == NUM_ ) { debug . message ( STR_ ) ; return null ; } succinctID = succinctID . trim ( ) ; String preferredSuccinctId = null ; StringTokenizer st = new StringTokenizer ( succinctID , STR_ ) ; while ( st . hasMoreTokens ( ) ) { preferredSuccinctId = st . nextToken ( ) ; if ( ( preferredSuccinctId . length ( ) < NUM_ ) && st . hasMoreTokens ( ) ) { preferredSuccinctId = preferredSuccinctId + STR_ + st . nextToken ( ) ; } } preferredSuccinctId = SAMLUtils . byteArrayToString ( Base64 . decode ( preferredSuccinctId ) ) ; return getProviderIDFromSuccinctID ( realm , preferredSuccinctId ) ; }
private void checkAndCreateDirectory ( final String directoryName ) { try { final File dir = new File ( directoryName ) ; if ( ! dir . exists ( ) && dir . mkdirs ( ) ) { _logger . debug ( STR_ ) ; } } catch ( Exception ex ) { _logger . error ( STR_ , ex . getMessage ( ) ) ; } }
@ SafeVarargs public final AssertSubscriber < T > assertValuesWith ( Consumer < T > ... expectations ) { if ( ! valuesStorage ) { throw new IllegalStateException ( STR_ ) ; } final int expectedValueCount = expectations . length ; if ( expectedValueCount != values . size ( ) ) { throw new AssertionError ( STR_ + expectedValueCount + STR_ + valueCount , null ) ; } for ( int i = NUM_ ; i < expectedValueCount ; i ++ ) { Consumer < T > consumer = expectations [ i ] ; T actualValue = values . get ( i ) ; consumer . accept ( actualValue ) ; } return this ; }
private boolean journalRebuildRequired ( ) { final int REDUNDANT_OP_COMPACT_THRESHOLD = NUM_ ; return redundantOpCount >= REDUNDANT_OP_COMPACT_THRESHOLD && redundantOpCount >= lruEntries . size ( ) ; }
public int findEventPositionNearestTime ( Time time , long id ) { if ( mRowInfo == null ) { return NUM_ ; } long millis = time . toMillis ( BOOL_ ) ; long minDistance = Integer . MAX_VALUE ; long idFoundMinDistance = Integer . MAX_VALUE ; int minIndex = NUM_ ; int idFoundMinIndex = NUM_ ; int eventInTimeIndex = - NUM_ ; int allDayEventInTimeIndex = - NUM_ ; int allDayEventDay = NUM_ ; int minDay = NUM_ ; boolean idFound = BOOL_ ; int len = mRowInfo . size ( ) ; for ( int index = NUM_ ; index < len ; index ++ ) { RowInfo row = mRowInfo . get ( index ) ; if ( row . mType == TYPE_DAY ) { continue ; } if ( row . mEventId == id ) { if ( row . mEventStartTimeMilli == millis ) { return index ; } long distance = Math . abs ( millis - row . mEventStartTimeMilli ) ; if ( distance < idFoundMinDistance ) { idFoundMinDistance = distance ; idFoundMinIndex = index ; } idFound = BOOL_ ; } if ( ! idFound ) { if ( millis >= row . mEventStartTimeMilli && millis <= row . mEventEndTimeMilli ) { if ( row . mAllDay ) { if ( allDayEventInTimeIndex == - NUM_ ) { allDayEventInTimeIndex = index ; allDayEventDay = row . mDay ; } } else if ( eventInTimeIndex == - NUM_ ) { eventInTimeIndex = index ; } } else if ( eventInTimeIndex == - NUM_ ) { long distance = Math . abs ( millis - row . mEventStartTimeMilli ) ; if ( distance < minDistance ) { minDistance = distance ; minIndex = index ; minDay = row . mDay ; } } } } if ( idFound ) { return idFoundMinIndex ; } if ( eventInTimeIndex != - NUM_ ) { return eventInTimeIndex ; } else if ( allDayEventInTimeIndex != - NUM_ && minDay != allDayEventDay ) { return allDayEventInTimeIndex ; } return minIndex ; }
final public void println ( float v ) { String s = String . valueOf ( v ) ; write ( s , NUM_ , s . length ( ) ) ; println ( ) ; }
private static TranslationResult extractRegister ( final ITranslationEnvironment environment , final long offset , final String subRegister ) throws InternalTranslationException { final ArrayList < ReilInstruction > instructions = new ArrayList < ReilInstruction > ( ) ; final String parentRegister = getParentRegister ( subRegister ) ; final OperandSize archSize = environment . getArchitectureSize ( ) ; if ( isHigher8BitRegister ( subRegister ) ) { final String maskResult = environment . getNextVariableString ( ) ; final String shiftResult = environment . getNextVariableString ( ) ; instructions . add ( ReilHelpers . createAnd ( offset , archSize , parentRegister , OperandSize . WORD , STR_ , OperandSize . WORD , maskResult ) ) ; instructions . add ( ReilHelpers . createBsh ( offset + NUM_ , OperandSize . WORD , maskResult , OperandSize . WORD , STR_ , OperandSize . BYTE , shiftResult ) ) ; return new TranslationResult ( shiftResult , OperandSize . BYTE , TranslationResultType . REGISTER , null , instructions , offset ) ; } else { final OperandSize subRegisterSize = getRegisterSize ( subRegister ) ; final String mask = String . valueOf ( TranslationHelpers . getAllBitsMask ( subRegisterSize ) ) ; final String result = environment . getNextVariableString ( ) ; instructions . add ( ReilHelpers . createAnd ( offset , archSize , parentRegister , subRegisterSize , mask , subRegisterSize , result ) ) ; return new TranslationResult ( result , subRegisterSize , TranslationResultType . REGISTER , null , instructions , offset ) ; } }
public void onLoginFailure ( Map requestParamsMap , HttpServletRequest req , HttpServletResponse res ) throws AuthenticationException { debug . message ( STR_ ) ; }
public Interceptor [ ] buildMethodInterceptors ( Method method ) { Interceptors before = method . getAnnotation ( Interceptors . class ) ; return before != null ? createInterceptors ( before ) : NULL_INTERCEPTOR_ARRAY ; }
protected String buildQualifierRegex ( String qualifierValue ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( STR_ ) ; sb . append ( qualifierValue ) ; sb . append ( STR_ ) ; return sb . toString ( ) ; }
private static void lookForChanges ( DataObject left , DataObject right , HashMap < String , Change > changes , Set < String > included , Set < String > excluded , Set < String > contained ) { Class refClass = left . getClass ( ) ; Method [ ] methods = refClass . getMethods ( ) ; for ( Method method : methods ) { boolean contain = BOOL_ ; Name nameAnn = method . getAnnotation ( Name . class ) ; if ( nameAnn == null ) { continue ; } String key = nameAnn . value ( ) ; if ( contained != null && contained . contains ( key ) ) { contain = BOOL_ ; } else if ( included != null && ! included . contains ( key ) ) { continue ; } if ( excluded . contains ( key ) ) { continue ; } Class type = method . getReturnType ( ) ; try { Object obja = method . invoke ( left ) ; Object objb = method . invoke ( right ) ; if ( type == StringSet . class ) { if ( contain ) { analyzeNewStringSetContainsOldStringSetValues ( ( StringSet ) obja , ( StringSet ) objb , key , changes ) ; } else { analyzeStringSets ( ( StringSet ) obja , ( StringSet ) objb , key , changes ) ; } } else if ( type == StringMap . class ) { analyzeStringMaps ( ( StringMap ) obja , ( StringMap ) objb , key , changes ) ; } else if ( type == StringSetMap . class ) { analyzeStringSetMaps ( ( StringSetMap ) obja , ( StringSetMap ) objb , key , changes ) ; } else { if ( ! isEqual ( obja , objb ) ) { Change change = new Change ( key , obja , objb , nameAnn . value ( ) ) ; changes . put ( key , change ) ; } } } catch ( IllegalAccessException ex ) { throw new ServiceCodeException ( ServiceCode . UNFORSEEN_ERROR , ex , ex . getMessage ( ) , new String [ ] { } ) ; } catch ( InvocationTargetException ex ) { throw new ServiceCodeException ( ServiceCode . UNFORSEEN_ERROR , ex , ex . getMessage ( ) , new String [ ] { } ) ; } } }
static void removeAllPhis ( IR ir ) { for ( Instruction s = ir . firstInstructionInCodeOrder ( ) , sentinel = ir . lastInstructionInCodeOrder ( ) , nextInstr = null ; s != sentinel ; s = nextInstr ) { nextInstr = s . nextInstructionInCodeOrder ( ) ; if ( Phi . conforms ( s ) ) s . remove ( ) ; } }
protected int countToken ( String token , String target ) { int tokenIndex = NUM_ ; int count = NUM_ ; while ( tokenIndex != - NUM_ ) { tokenIndex = target . indexOf ( token , tokenIndex ) ; if ( tokenIndex > - NUM_ ) { tokenIndex ++ ; count ++ ; } } return count ; }
private Map < TestCase , Set < TestFitnessFunction > > initializeCoverageMapFromTests ( List < TestCase > tests ) { Map < TestCase , Set < TestFitnessFunction > > testToGoals = new LinkedHashMap < > ( ) ; for ( TestCase test : tests ) { testToGoals . put ( test , filterSupportedGoals ( new LinkedHashSet < > ( test . getCoveredGoals ( ) ) ) ) ; } return testToGoals ; }
public Interceptor [ ] buildRouteInterceptors ( Interceptor [ ] defaultInters , Interceptor [ ] resourceInters , Class < ? extends Resource > resourceClass , Interceptor [ ] methodInters , Method method ) { List < Interceptor > allInters = new ArrayList < Interceptor > ( ) ; for ( Interceptor defaultInter : defaultInters ) { allInters . add ( defaultInter ) ; } for ( Interceptor resourceInter : resourceInters ) { allInters . add ( resourceInter ) ; } for ( Interceptor methodInter : methodInters ) { allInters . add ( methodInter ) ; } Class < ? extends Interceptor > [ ] resourceClears = getResourceClears ( resourceClass ) ; Class < ? extends Interceptor > [ ] methodClears = getMethodClears ( method ) ; if ( ( resourceClears != null && resourceClears . length > NUM_ ) || ( methodClears != null && methodClears . length > NUM_ ) ) { for ( int i = NUM_ ; i < allInters . size ( ) ; i ++ ) { i = clearInterceptor ( allInters , resourceClears , i ) ; i = clearInterceptor ( allInters , methodClears , i ) ; } } return allInters . toArray ( new Interceptor [ allInters . size ( ) ] ) ; }
public static boolean checkGMLFootprint ( String footprint ) { try { Configuration configuration = new GMLConfiguration ( ) ; Parser parser = new Parser ( configuration ) ; Geometry geom = ( Geometry ) parser . parse ( new InputSource ( new StringReader ( footprint ) ) ) ; if ( ! geom . isEmpty ( ) && ! geom . isValid ( ) ) { logger . error ( STR_ ) ; return BOOL_ ; } } catch ( Exception e ) { logger . error ( STR_ + e . getMessage ( ) ) ; return BOOL_ ; } return BOOL_ ; }
public static void main ( String [ ] args ) { double preBuffer = Double . parseDouble ( args [ NUM_ ] ) ; double postBuffer = Double . parseDouble ( args [ NUM_ ] ) ; run ( args [ NUM_ ] , args [ NUM_ ] , args [ NUM_ ] , args [ NUM_ ] , preBuffer , postBuffer ) ; }
public static double quantile ( double p , double k , double theta , double shift ) { return Math . exp ( GammaDistribution . quantile ( p , k , theta ) ) + shift ; }
public static CipherParameters makePBEMacParameters ( BCPBEKey pbeKey , AlgorithmParameterSpec spec ) { if ( ( spec == null ) || ! ( spec instanceof PBEParameterSpec ) ) { throw new IllegalArgumentException ( STR_ ) ; } PBEParameterSpec pbeParam = ( PBEParameterSpec ) spec ; PBEParametersGenerator generator = makePBEGenerator ( pbeKey . getType ( ) , pbeKey . getDigest ( ) ) ; byte [ ] key = pbeKey . getEncoded ( ) ; CipherParameters param ; if ( pbeKey . shouldTryWrongPKCS12 ( ) ) { key = new byte [ NUM_ ] ; } generator . init ( key , pbeParam . getSalt ( ) , pbeParam . getIterationCount ( ) ) ; param = generator . generateDerivedMacParameters ( pbeKey . getKeySize ( ) ) ; for ( int i = NUM_ ; i != key . length ; i ++ ) { key [ i ] = NUM_ ; } return param ; }
public OrionEditorInit ( final TextEditorConfiguration configuration , final CodeAssistantFactory codeAssistantFactory , final QuickAssistAssistant quickAssist , final OrionEditorPresenter textEditor ) { this . configuration = configuration ; this . codeAssistantFactory = codeAssistantFactory ; this . quickAssist = quickAssist ; this . textEditor = textEditor ; }
final void putByte ( int offset , byte value ) { unsafe . putByte ( offset + address , value ) ; }
public final void addValidationError ( String error ) { validationErrors . add ( error ) ; }
public static void parseOptionSettingTo ( String optionSetting , Map < String , String > dst ) { int eqIndex = optionSetting . indexOf ( STR_ ) ; if ( eqIndex == - NUM_ ) { throw new InternalError ( STR_ + optionSetting ) ; } dst . put ( optionSetting . substring ( NUM_ , eqIndex ) , optionSetting . substring ( eqIndex + NUM_ ) ) ; }
public BigInteger generateClientCredentials ( byte [ ] salt , byte [ ] identity , byte [ ] password ) { this . x = SRP6Util . calculateX ( digest , N , salt , identity , password ) ; this . a = selectPrivateValue ( ) ; this . A = g . modPow ( a , N ) ; return A ; }
public void build ( SolrCore core , SolrIndexSearcher searcher ) throws IOException { LOG . info ( STR_ + name + STR_ ) ; dictionary = dictionaryFactory . create ( core , searcher ) ; lookup . build ( dictionary ) ; if ( storeDir != null ) { File target = getStoreFile ( ) ; if ( ! lookup . store ( new FileOutputStream ( target ) ) ) { LOG . error ( STR_ ) ; } else { LOG . info ( STR_ + target . getAbsolutePath ( ) ) ; } } }
public void start ( String json ) { guidedTourSteps . clear ( ) ; GuidedTourConfiguration configuration = dtoFactory . createDtoFromJson ( json , GuidedTourConfiguration . class ) ; log . setDebugMode ( configuration . getDebugMode ( ) ) ; this . guidedTourSteps = configuration . getSteps ( ) ; this . tourName = configuration . getName ( ) ; if ( this . tourName == null || tourName . isEmpty ( ) ) { tourName = STR_ ; } this . hasWelcomeStep = configuration . getHasWelcomeStep ( ) ; startTour ( ) ; }
private void connect ( ) throws IOException { JMXServiceURL jmxUrl = new JMXServiceURL ( String . format ( fmtUrl , host , port ) ) ; Map < String , Object > env = new HashMap < String , Object > ( ) ; if ( username != null ) { String [ ] creds = { username , password } ; env . put ( JMXConnector . CREDENTIALS , creds ) ; } env . put ( STR_ , getRMIClientSocketFactory ( ) ) ; jmxc = JMXConnectorFactory . connect ( jmxUrl , env ) ; mbeanServerConn = jmxc . getMBeanServerConnection ( ) ; try { ObjectName name = new ObjectName ( ssObjName ) ; ssProxy = JMX . newMBeanProxy ( mbeanServerConn , name , StorageServiceMBean . class ) ; name = new ObjectName ( MessagingService . MBEAN_NAME ) ; msProxy = JMX . newMBeanProxy ( mbeanServerConn , name , MessagingServiceMBean . class ) ; name = new ObjectName ( StreamManagerMBean . OBJECT_NAME ) ; streamProxy = JMX . newMBeanProxy ( mbeanServerConn , name , StreamManagerMBean . class ) ; name = new ObjectName ( CompactionManager . MBEAN_OBJECT_NAME ) ; compactionProxy = JMX . newMBeanProxy ( mbeanServerConn , name , CompactionManagerMBean . class ) ; name = new ObjectName ( FailureDetector . MBEAN_NAME ) ; fdProxy = JMX . newMBeanProxy ( mbeanServerConn , name , FailureDetectorMBean . class ) ; name = new ObjectName ( CacheService . MBEAN_NAME ) ; cacheService = JMX . newMBeanProxy ( mbeanServerConn , name , CacheServiceMBean . class ) ; name = new ObjectName ( StorageProxy . MBEAN_NAME ) ; spProxy = JMX . newMBeanProxy ( mbeanServerConn , name , StorageProxyMBean . class ) ; name = new ObjectName ( HintedHandOffManager . MBEAN_NAME ) ; hhProxy = JMX . newMBeanProxy ( mbeanServerConn , name , HintedHandOffManagerMBean . class ) ; name = new ObjectName ( GCInspector . MBEAN_NAME ) ; gcProxy = JMX . newMBeanProxy ( mbeanServerConn , name , GCInspectorMXBean . class ) ; name = new ObjectName ( Gossiper . MBEAN_NAME ) ; gossProxy = JMX . newMBeanProxy ( mbeanServerConn , name , GossiperMBean . class ) ; } catch ( MalformedObjectNameException e ) { throw new RuntimeException ( STR_ , e ) ; } memProxy = ManagementFactory . newPlatformMXBeanProxy ( mbeanServerConn , ManagementFactory . MEMORY_MXBEAN_NAME , MemoryMXBean . class ) ; runtimeProxy = ManagementFactory . newPlatformMXBeanProxy ( mbeanServerConn , ManagementFactory . RUNTIME_MXBEAN_NAME , RuntimeMXBean . class ) ; }
private static void runRandomTest ( final int wordLength , final int bytePadding , final int wordCount ) { final long seed = randomLong ( ) ; final Random random = new Random ( seed ) ; final Random verificationRandom = new Random ( seed ) ; final long wordMask ; if ( wordLength == NUM_ ) { wordMask = ~ NUM_ ; } else { wordMask = ( NUM_ << wordLength ) - NUM_ ; } final BigEndianAscendingWordSerializer serializer = new BigEndianAscendingWordSerializer ( wordLength , wordCount , bytePadding ) ; for ( int i = NUM_ ; i < wordCount ; i ++ ) { final long value = random . nextLong ( ) & wordMask ; serializer . writeWord ( value ) ; } final byte [ ] bytes = serializer . getBytes ( ) ; final BigEndianAscendingWordDeserializer deserializer = new BigEndianAscendingWordDeserializer ( wordLength , bytePadding , bytes ) ; assertEquals ( deserializer . totalWordCount ( ) , wordCount ) ; for ( int i = NUM_ ; i < wordCount ; i ++ ) { assertEquals ( deserializer . readWord ( ) , ( verificationRandom . nextLong ( ) & wordMask ) ) ; } }
public void addListener ( T listener ) { if ( listener == null ) { throw new NullPointerException ( ) ; } listeners . add ( listener ) ; }
public static MaildirMessageName createUniqueName ( MaildirFolder parentFolder , long size ) { String timestamp = String . valueOf ( System . currentTimeMillis ( ) ) ; timestamp = timestamp . substring ( NUM_ , timestamp . length ( ) - NUM_ ) ; StringBuilder uniquePart = new StringBuilder ( ) ; uniquePart . append ( Integer . toHexString ( random . nextInt ( ) ) ) ; uniquePart . append ( timestamp . substring ( timestamp . length ( ) - NUM_ ) ) ; uniquePart . append ( processName ) ; uniquePart . append ( getNextDeliveryNumber ( ) ) ; String sizeString = STR_ + String . valueOf ( size ) ; String fullName = timestamp + STR_ + uniquePart . toString ( ) + STR_ + currentHostname + sizeString ; MaildirMessageName uniqueName = new MaildirMessageName ( parentFolder , fullName ) ; uniqueName . timestamp = timestamp ; uniqueName . uniqueString = uniquePart . toString ( ) ; uniqueName . hostname = currentHostname ; uniqueName . sizeString = sizeString ; uniqueName . isSplit = BOOL_ ; uniqueName . size = size ; return uniqueName ; }
private float clampMag ( float value , float absMin , float absMax ) { final float absValue = Math . abs ( value ) ; if ( absValue < absMin ) return NUM_ ; if ( absValue > absMax ) return value > NUM_ ? absMax : - absMax ; return value ; }
@ Override public void handleClick ( int x , int y , PlotRenderingInfo info ) { }
private void adjustBCIndex ( Instruction barrier ) { NormalMethod source = barrier . position ( ) . method ; if ( source . isForOsrSpecialization ( ) ) { barrier . adjustBytecodeIndex ( - source . getOsrPrologueLength ( ) ) ; } }
@ Override public String toString ( ) { StringBuilder risul = new StringBuilder ( NUM_ ) ; risul . append ( STR_ ) ; risul . append ( STR_ ) ; return risul . toString ( ) ; }
public static long [ ] interpose ( long [ ] vector , int vectorLen , int offset , int len ) { long [ ] updated = create ( vectorLen + len ) ; int idx = offset > > NUM_ ; System . arraycopy ( vector , NUM_ , updated , NUM_ , idx ) ; if ( idx < vector . length ) { int delta = offset & NUM_ ; updated [ idx ] |= vector [ idx ] & maskBelow ( delta ) ; } copy ( vector , offset , updated , offset + len , vectorLen - offset ) ; return updated ; }
public static File createTemporaryDirectory ( String prefix ) { while ( BOOL_ ) { String candidateName = prefix + TEMPORARY_DIRECTORY_PRNG . nextInt ( ) ; File result = new File ( System . getProperty ( STR_ ) , candidateName ) ; if ( result . mkdir ( ) ) { return result ; } } }
Task < Void > synchronizeAllAuthDataAsync ( ) { Map < String , Map < String , String > > authData ; synchronized ( mutex ) { if ( ! isCurrentUser ( ) ) { return Task . forResult ( null ) ; } authData = getAuthData ( ) ; } List < Task < Void > > tasks = new ArrayList < > ( authData . size ( ) ) ; for ( String authType : authData . keySet ( ) ) { tasks . add ( synchronizeAuthDataAsync ( authType ) ) ; } return Task . whenAll ( tasks ) ; }
public static Element createElementInEncryptionSpace ( Document doc , String elementName ) { if ( doc == null ) { throw new RuntimeException ( STR_ ) ; } if ( ( xencPrefix == null ) || ( xencPrefix . length ( ) == NUM_ ) ) { return doc . createElementNS ( EncryptionConstants . EncryptionSpecNS , elementName ) ; } return doc . createElementNS ( EncryptionConstants . EncryptionSpecNS , xencPrefix + STR_ + elementName ) ; }
void scrapActiveViews ( ) { final View [ ] activeViews = mActiveViews ; final boolean multipleScraps = mViewTypeCount > NUM_ ; ArrayList < View > scrapViews = mCurrentScrap ; final int count = activeViews . length ; for ( int i = count - NUM_ ; i >= NUM_ ; i -- ) { final View victim = activeViews [ i ] ; if ( victim != null ) { final LayoutParams lp = ( LayoutParams ) victim . getLayoutParams ( ) ; activeViews [ i ] = null ; final boolean scrapHasTransientState = ViewCompat . hasTransientState ( victim ) ; int viewType = lp . viewType ; if ( ! shouldRecycleViewType ( viewType ) || scrapHasTransientState ) { if ( viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER || scrapHasTransientState ) { removeDetachedView ( victim , BOOL_ ) ; } if ( scrapHasTransientState ) { if ( mTransientStateViews == null ) { mTransientStateViews = new SparseArrayCompat < View > ( ) ; } mTransientStateViews . put ( mFirstActivePosition + i , victim ) ; } continue ; } if ( multipleScraps ) { scrapViews = mScrapViews [ viewType ] ; } lp . position = mFirstActivePosition + i ; scrapViews . add ( victim ) ; } } pruneScrapViews ( ) ; }
private void drawWind ( Canvas canvas , float y , float xOffset ) { float cof = ( mScreenWidth + xOffset ) / ( LOADING_ANIMATION_COEFFICIENT / SLOW_DOWN_ANIMATION_COEFFICIENT ) ; float time = mLoadingAnimationTime ; if ( mLastAnimationTime - mLoadingAnimationTime > NUM_ ) { mInverseDirection = BOOL_ ; time = ( LOADING_ANIMATION_COEFFICIENT / SLOW_DOWN_ANIMATION_COEFFICIENT ) - mLoadingAnimationTime ; } else { mNewWindSet = BOOL_ ; mInverseDirection = BOOL_ ; } float x = ( mScreenWidth - ( time . cof ) ) + xOffset - mWindLineWidth ; float xEnd = x + mWindLineWidth ; canvas . drawLine ( x , y , xEnd , y , mWindPaint ) ; }
private boolean hasProxySettings ( Properties settings ) { String proxyHost = settings . getProperty ( STR_ , null ) ; return proxyHost != null && proxyHost . length ( ) > NUM_ ; }
public boolean equalsDefault ( ) { return ( Double . doubleToLongBits ( value ) == NUM_ ) ; }
public static Map < String , String > parseKeyAndValueToMap ( String source , boolean ignoreSpace ) { return parseKeyAndValueToMap ( source , DEFAULT_KEY_AND_VALUE_SEPARATOR , DEFAULT_KEY_AND_VALUE_PAIR_SEPARATOR , ignoreSpace ) ; }
@ Override protected void onSizeChanged ( int w , int h , int oldw , int oldh ) { super . onSizeChanged ( w , h , oldw , oldh ) ; setupBounds ( w , h ) ; setupPaints ( ) ; invalidate ( ) ; }
private void needNewBuffer ( int newcount ) { if ( currentBufferIndex < buffers . size ( ) - NUM_ ) { filledBufferSum += currentBuffer . length ; currentBufferIndex ++ ; currentBuffer = buffers . get ( currentBufferIndex ) ; } else { int newBufferSize ; if ( currentBuffer == null ) { newBufferSize = newcount ; filledBufferSum = NUM_ ; } else { newBufferSize = Math . max ( currentBuffer . length << NUM_ , newcount - filledBufferSum ) ; filledBufferSum += currentBuffer . length ; } currentBufferIndex ++ ; currentBuffer = new byte [ newBufferSize ] ; buffers . add ( currentBuffer ) ; } }
@ Nullable public static WebsiteAddress create ( String originOrHostOrPattern ) { if ( originOrHostOrPattern == null || originOrHostOrPattern . isEmpty ( ) ) { return null ; } if ( originOrHostOrPattern . startsWith ( ANY_SUBDOMAIN_PATTERN ) ) { String origin = null ; String scheme = null ; String host = originOrHostOrPattern . substring ( ANY_SUBDOMAIN_PATTERN . length ( ) ) ; boolean omitProtocolAndPort = BOOL_ ; return new WebsiteAddress ( originOrHostOrPattern , origin , scheme , host , omitProtocolAndPort ) ; } if ( originOrHostOrPattern . indexOf ( SCHEME_SUFFIX ) != - NUM_ ) { Uri uri = Uri . parse ( originOrHostOrPattern ) ; String origin = trimTrailingBackslash ( originOrHostOrPattern ) ; boolean omitProtocolAndPort = HTTP_SCHEME . equals ( uri . getScheme ( ) ) && ( uri . getPort ( ) == - NUM_ || uri . getPort ( ) == NUM_ ) ; return new WebsiteAddress ( originOrHostOrPattern , origin , uri . getScheme ( ) , uri . getHost ( ) , omitProtocolAndPort ) ; } String origin = null ; String scheme = null ; boolean omitProtocolAndPort = BOOL_ ; return new WebsiteAddress ( originOrHostOrPattern , origin , scheme , originOrHostOrPattern , omitProtocolAndPort ) ; }
public void test_filter_001 ( ) throws IOException { final File basefile = File . createTempFile ( getName ( ) , STR_ ) ; try { final String basename = basefile . toString ( ) ; final NameAndExtensionFilter logFilter = new NameAndExtensionFilter ( basename , STR_ ) ; assertSameFiles ( new File [ ] { } , logFilter . getFiles ( ) ) ; } finally { basefile . delete ( ) ; } }
public void resetTeleMissileAttacks ( ) { pendingTeleMissileAttacks . removeAllElements ( ) ; }
public int addPadding ( byte [ ] in , int inOff ) { byte code = ( byte ) ( in . length - inOff ) ; while ( inOff < ( in . length - NUM_ ) ) { in [ inOff ] = ( byte ) random . nextInt ( ) ; inOff ++ ; } in [ inOff ] = code ; return code ; }
public void addCommands ( PDFPage page , Matrix extra ) { synchronized ( commands ) { addPush ( ) ; if ( extra != null ) { addXform ( extra ) ; } commands . addAll ( page . getCommands ( ) ) ; addPop ( ) ; } updateImages ( ) ; }
public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; char [ ] separator = { STR_ , STR_ } ; int n = rows . length ; for ( int i = NUM_ ; i < n ; i ++ ) { separator [ NUM_ ] = STR_ ; for ( int j = NUM_ ; j <= i ; j ++ ) { sb . append ( separator ) ; sb . append ( rows [ i ] [ j ] ) ; separator [ NUM_ ] = STR_ ; } sb . append ( STR_ ) ; sb . append ( STR_ ) ; } return sb . toString ( ) ; }
public void addLast ( StatementSequence statements ) { if ( statements != null ) { sequence . addAll ( statements . sequence ) ; } }
private void notifyActivityStateChanged ( Bundle bundle ) { if ( ! mRecords . isEmpty ( ) ) { Log . d ( TAG , STR_ + mRecords . size ( ) ) ; synchronized ( mRecords ) { Iterator < Record > iterator = mRecords . iterator ( ) ; while ( iterator . hasNext ( ) ) { Record record = ( Record ) iterator . next ( ) ; FmRadioListener listener = record . mCallback ; if ( listener == null ) { iterator . remove ( ) ; return ; } listener . onCallBack ( bundle ) ; } } } }
public double elasticity ( final double spot ) { final double val = value ( ) ; final double del = delta ( spot ) ; if ( val > Constants . QL_EPSILON ) return del / val . spot ; else if ( Math . abs ( del ) < Constants . QL_EPSILON ) return NUM_ ; else if ( del > NUM_ ) return Double . MAX_VALUE ; else return Double . MIN_VALUE ; }
private byte [ ] entityToBytes ( HttpEntity entity , Request request ) throws IOException , ServerError { PoolingByteArrayOutputStream bytes = new PoolingByteArrayOutputStream ( mPool , ( int ) entity . getContentLength ( ) ) ; byte [ ] buffer = null ; try { InputStream in = entity . getContent ( ) ; if ( in == null ) { throw new ServerError ( ) ; } buffer = mPool . getBuf ( NUM_ ) ; int progress = NUM_ ; int count ; while ( ( count = in . read ( buffer ) ) != - NUM_ ) { bytes . write ( buffer , NUM_ , count ) ; progress += count ; request . progressUpdate ( progress ) ; } return bytes . toByteArray ( ) ; } finally { try { entity . consumeContent ( ) ; } catch ( IOException e ) { VinciLog . d ( STR_ ) ; } mPool . returnBuf ( buffer ) ; bytes . close ( ) ; } }
@ Override public Foo fetchByUuid_First ( String uuid , OrderByComparator < Foo > orderByComparator ) { List < Foo > list = findByUuid ( uuid , NUM_ , NUM_ , orderByComparator ) ; if ( ! list . isEmpty ( ) ) { return list . get ( NUM_ ) ; } return null ; }
public static float roundDecimal ( float value ) { return roundDecimal ( value , Math . log10 ( INT_PRECISION ) ) ; }
@ AssistedInject public RunnerImpl ( @ NotNull RunnerLocalizationConstant locale , @ NotNull RunnerCounter runnerCounter , @ NotNull GetEnvironmentsUtil util , @ NotNull @ Assisted RunOptions runOptions , @ NotNull @ Assisted Scope environmentScope , @ Nullable @ Assisted String environmentName ) { this . runOptions = runOptions ; this . ram = runOptions . getMemorySize ( ) ; this . title = RUNNER_NAME + runnerCounter . getRunnerNumber ( ) + ( environmentName == null ? STR_ : STR_ + getCorrectName ( environmentName ) ) ; this . activeTab = locale . runnerTabConsole ( ) ; this . status = IN_QUEUE ; this . scope = environmentScope ; creationTime = System . currentTimeMillis ( ) ; String environmentId = runOptions . getEnvironmentId ( ) ; if ( environmentId == null || environmentId . startsWith ( STR_ ) ) { this . type = util . getType ( ) ; } else { this . type = util . getCorrectCategoryName ( runOptions . getEnvironmentId ( ) ) ; } if ( environmentId != null ) { runOptions . setEnvironmentId ( environmentId ) ; } }
public String globalInfo ( ) { return STR_ + STR_ ; }
public static boolean isWindowsMe ( ) { return osName . indexOf ( STR_ ) > - NUM_ && osVersion . equals ( STR_ ) ; }
private String dateToString ( Date input ) { if ( input == null ) { return null ; } else { return input . toString ( ) ; } }
private static int componentSize ( Component component , FormSpec formSpec , int cellSize , FormLayout . Measure minMeasure , FormLayout . Measure prefMeasure ) { if ( formSpec == null ) { return prefMeasure . sizeOf ( component ) ; } else if ( formSpec . getSize ( ) == Sizes . MINIMUM ) { return minMeasure . sizeOf ( component ) ; } else if ( formSpec . getSize ( ) == Sizes . PREFERRED ) { return prefMeasure . sizeOf ( component ) ; } else { return Math . min ( cellSize , prefMeasure . sizeOf ( component ) ) ; } }
protected synchronized void start ( long curPrimaryGen ) throws IOException { if ( state . equals ( STR_ ) == BOOL_ ) { throw new IllegalStateException ( STR_ ) ; } message ( STR_ ) ; try { String segmentsFileName = SegmentInfos . getLastCommitSegmentsFileName ( dir ) ; long maxPendingGen = - NUM_ ; for ( String fileName : dir . listAll ( ) ) { if ( fileName . startsWith ( IndexFileNames . PENDING_SEGMENTS ) ) { long gen = Long . parseLong ( fileName . substring ( IndexFileNames . PENDING_SEGMENTS . length ( ) + NUM_ ) , Character . MAX_RADIX ) ; if ( gen > maxPendingGen ) { maxPendingGen = gen ; } } } SegmentInfos infos ; if ( segmentsFileName == null ) { infos = new SegmentInfos ( ) ; message ( STR_ ) ; } else { message ( STR_ + segmentsFileName ) ; infos = SegmentInfos . readCommit ( dir , segmentsFileName ) ; message ( STR_ + infos . toString ( ) + STR_ + infos . getVersion ( ) ) ; Collection < String > indexFiles = infos . files ( BOOL_ ) ; lastCommitFiles . add ( segmentsFileName ) ; lastCommitFiles . addAll ( indexFiles ) ; deleter . incRef ( lastCommitFiles ) ; lastNRTFiles . addAll ( indexFiles ) ; deleter . incRef ( lastNRTFiles ) ; message ( STR_ + lastCommitFiles ) ; message ( STR_ + lastNRTFiles ) ; } message ( STR_ + Arrays . toString ( dir . listAll ( ) ) ) ; deleter . deleteUnknownFiles ( segmentsFileName ) ; message ( STR_ + Arrays . toString ( dir . listAll ( ) ) ) ; String s = infos . getUserData ( ) . get ( PRIMARY_GEN_KEY ) ; long myPrimaryGen ; if ( s == null ) { assert infos . size ( ) == NUM_ ; myPrimaryGen = - NUM_ ; } else { myPrimaryGen = Long . parseLong ( s ) ; } message ( STR_ + myPrimaryGen ) ; boolean doCommit ; if ( infos . size ( ) > NUM_ && myPrimaryGen != - NUM_ && myPrimaryGen != curPrimaryGen ) { assert myPrimaryGen < curPrimaryGen ; final long initSyncStartNS = System . nanoTime ( ) ; message ( STR_ + myPrimaryGen + STR_ + curPrimaryGen + STR_ ) ; CopyJob job = null ; message ( STR_ + segmentsFileName ) ; assert deleter . getRefCount ( segmentsFileName ) == NUM_ ; deleter . decRef ( Collections . singleton ( segmentsFileName ) ) ; if ( dir instanceof FSDirectory && ( ( FSDirectory ) dir ) . checkPendingDeletions ( ) ) { throw new RuntimeException ( STR_ + segmentsFileName + STR_ ) ; } boolean didRemove = lastCommitFiles . remove ( segmentsFileName ) ; assert didRemove ; while ( BOOL_ ) { job = newCopyJob ( STR_ + name ( ) + STR_ + infos . getVersion ( ) , null , null , BOOL_ , null ) ; job . start ( ) ; message ( STR_ + job . getCopyState ( ) . version ) ; try { job . runBlocking ( ) ; job . finish ( ) ; break ; } catch ( IOException ioe ) { job . cancel ( STR_ , ioe ) ; if ( ioe . getMessage ( ) . contains ( STR_ ) ) { message ( STR_ + ioe + STR_ ) ; } else { throw ioe ; } } } lastPrimaryGen = job . getCopyState ( ) . primaryGen ; byte [ ] infosBytes = job . getCopyState ( ) . infosBytes ; SegmentInfos syncInfos = SegmentInfos . readCommit ( dir , new BufferedChecksumIndexInput ( new ByteArrayIndexInput ( STR_ , job . getCopyState ( ) . infosBytes ) ) , job . getCopyState ( ) . gen ) ; syncInfos . updateGeneration ( infos ) ; infos = syncInfos ; assert infos . getVersion ( ) == job . getCopyState ( ) . version ; message ( STR_ + infos . getVersion ( ) + STR_ + infos . toString ( ) ) ; message ( STR_ + job . getFileNames ( ) ) ; deleter . incRef ( job . getFileNames ( ) ) ; message ( STR_ + lastNRTFiles ) ; deleter . decRef ( lastNRTFiles ) ; lastNRTFiles . clear ( ) ; lastNRTFiles . addAll ( job . getFileNames ( ) ) ; message ( STR_ + lastNRTFiles ) ; lastFileMetaData = job . getCopyState ( ) . files ; message ( String . format ( Locale . ROOT , STR_ , id , ( System . nanoTime ( ) - initSyncStartNS ) / NUM_ , bytesToString ( job . getTotalBytesCopied ( ) ) , job . getCopyState ( ) . version ) ) ; doCommit = BOOL_ ; } else { doCommit = BOOL_ ; lastPrimaryGen = curPrimaryGen ; message ( STR_ ) ; } if ( infos . getGeneration ( ) < maxPendingGen ) { message ( STR_ + infos . getGeneration ( ) + STR_ + maxPendingGen ) ; infos . setNextWriteGeneration ( maxPendingGen ) ; } sendNewReplica ( ) ; mgr = new SegmentInfosSearcherManager ( dir , this , infos , searcherFactory ) ; IndexSearcher searcher = mgr . acquire ( ) ; try { int hitCount = searcher . count ( new TermQuery ( new Term ( STR_ , STR_ ) ) ) ; message ( STR_ + hitCount + STR_ + ( ( DirectoryReader ) searcher . getIndexReader ( ) ) . getVersion ( ) ) ; } finally { mgr . release ( searcher ) ; } if ( doCommit ) { commit ( ) ; } message ( STR_ ) ; state = STR_ ; } catch ( Throwable t ) { if ( t . getMessage ( ) . startsWith ( STR_ ) == BOOL_ ) { message ( STR_ ) ; t . printStackTrace ( printStream ) ; } else { dir . close ( ) ; } IOUtils . reThrow ( t ) ; } }
public static boolean isSameElementType ( ASTNode node1 , ASTNode node2 ) { return node1 != null && node2 != null && node1 . getElementType ( ) == node1 . getElementType ( ) ; }
@ Override public LogMessage readNextLogMessage ( ) { try { if ( reader == null ) { return null ; } while ( BOOL_ ) { String line = reader . readLine ( ) ; if ( line == null ) { close ( ) ; if ( currentLog != null && matchRegex ( currentLog ) ) { incrementLogCount ( currentLog ) ; return currentLog ; } return null ; } fileLineNumber ++ ; LogMessage nextLog = null ; if ( parser != null ) { nextLog = parser . parseLine ( line , request ) ; } else { for ( LogParser parser : parserTable ) { nextLog = parser . parseLine ( line , request ) ; if ( ! nextLog . isContinuation ( ) ) { this . parser = parser ; break ; } } if ( nextLog == null || nextLog . isContinuation ( ) ) { status . appendInfo ( this . filePath , fileLineNumber ) ; continue ; } } if ( nextLog . isContinuation ( ) ) { if ( currentLog != null ) { currentLog . appendMessage ( LogUtil . stringToBytes ( line ) ) ; } } else if ( nextLog . isRejected ( ) ) { if ( currentLog != null ) { LogMessage returnedLog = currentLog ; currentLog = null ; if ( matchRegex ( returnedLog ) ) { incrementLogCount ( returnedLog ) ; return returnedLog ; } } } else if ( nextLog . isRejectedLast ( ) ) { if ( currentLog != null ) { LogMessage returnedLog = currentLog ; currentLog = null ; if ( matchRegex ( returnedLog ) ) { incrementLogCount ( returnedLog ) ; return returnedLog ; } } break ; } else { if ( currentLog != null ) { LogMessage returnedLog = currentLog ; currentLog = nextLog ; if ( returnedLog . isHeader ( ) && currentLog . isHeader ( ) ) { continue ; } if ( matchRegex ( returnedLog ) ) { incrementLogCount ( returnedLog ) ; return returnedLog ; } } else { currentLog = nextLog ; } } } } catch ( IOException e ) { status . appendErrFileName ( filePath ) ; } return null ; }
public void appendDataTo ( StringBuilder stringBuilder ) { stringBuilder . append ( buffer ) ; }
private static boolean hasResponseBody ( int requestMethod , int responseCode ) { return requestMethod != Request . Method . HEAD && ! ( HttpStatus . SC_CONTINUE <= responseCode && responseCode < HttpStatus . SC_OK ) && responseCode != HttpStatus . SC_NO_CONTENT && responseCode != HttpStatus . SC_NOT_MODIFIED ; }
private void loadBinary ( DataInputStream is ) throws IOException { if ( is . readInt ( ) != MAGIC ) { throw new Error ( STR_ ) ; } if ( is . readInt ( ) != VERSION ) { throw new Error ( STR_ ) ; } continuityWeight = is . readInt ( ) ; optimalCoupling = is . readInt ( ) ; extendSelections = is . readInt ( ) ; joinMethod = is . readInt ( ) ; joinWeightShift = is . readInt ( ) ; int weightLength = is . readInt ( ) ; joinWeights = new int [ weightLength ] ; for ( int i = NUM_ ; i < joinWeights . length ; i ++ ) { joinWeights [ i ] = is . readInt ( ) ; } int unitsLength = is . readInt ( ) ; units = new DatabaseClusterUnit [ unitsLength ] ; for ( int i = NUM_ ; i < units . length ; i ++ ) { units [ i ] = new DatabaseClusterUnit ( is ) ; } int unitTypesLength = is . readInt ( ) ; unitTypes = new UnitType [ unitTypesLength ] ; for ( int i = NUM_ ; i < unitTypes . length ; i ++ ) { unitTypes [ i ] = new UnitType ( is ) ; } sts = new SampleSet ( is ) ; mcep = new SampleSet ( is ) ; int numCarts = is . readInt ( ) ; cartMap = new HashMap ( ) ; for ( int i = NUM_ ; i < numCarts ; i ++ ) { String name = Utilities . getString ( is ) ; CART cart = CARTImpl . loadBinary ( is ) ; cartMap . put ( name , cart ) ; if ( defaultCart == null ) { defaultCart = cart ; } } }
public static String toString ( long l ) { if ( l < NUMBERS_MIN || l > NUMBERS_MAX ) { return Long . toString ( l , NUM_ ) ; } return NUMBERS [ ( int ) l ] ; }
@ Override public synchronized void reset ( ) { pos = NUM_ ; }
private static char [ ] zzUnpackCMap ( String packed ) { char [ ] map = new char [ x10000 ] ; int i = NUM_ ; int j = NUM_ ; while ( i < NUM_ ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM_ ) ; } return map ; }
public static int readSingleByte ( InputStream in ) throws IOException { byte [ ] buffer = new byte [ NUM_ ] ; int result = in . read ( buffer , NUM_ , NUM_ ) ; return ( result != - NUM_ ) ? buffer [ NUM_ ] & xff : - NUM_ ; }
public static void write ( File file , CharSequence data ) throws IOException { write ( file , data , Charset . defaultCharset ( ) , BOOL_ ) ; }
protected boolean isIDPProxyEnabled ( FSAuthnRequest authnRequest ) throws FSException { if ( authnRequest . getMinorVersion ( ) != IFSConstants . FF_12_PROTOCOL_MINOR_VERSION ) { return BOOL_ ; } FSScoping scoping = authnRequest . getScoping ( ) ; if ( scoping != null && scoping . getProxyCount ( ) == NUM_ ) { return BOOL_ ; } String enabledString = IDFFMetaUtils . getFirstAttributeValueFromConfig ( spConfig , IFSConstants . ENABLE_IDP_PROXY ) ; if ( enabledString != null && enabledString . equalsIgnoreCase ( STR_ ) ) { return BOOL_ ; } else { return BOOL_ ; } }
private void compileProlog ( ObjectId prolog , File tempDir ) throws IOException , CompileException { File tempRules = copyToTempFile ( prolog , tempDir ) ; try { Compiler comp = new Compiler ( ) ; comp . prologToJavaSource ( tempRules . getPath ( ) , tempDir . getPath ( ) ) ; } finally { tempRules . delete ( ) ; } }
public Spring removeAllListeners ( ) { mListeners . clear ( ) ; return this ; }
public SelectionInputDialog ( Window owner , String key , boolean editable , T [ ] selectionValues , T initialSelectionValue , InputValidator < T > inputValidator , Object ... keyArguments ) { this ( owner , key , selectionValues , initialSelectionValue , inputValidator , keyArguments ) ; comboBox . setEditable ( editable ) ; }
public void build ( SolrCore core , SolrIndexSearcher searcher ) throws IOException { LOG . info ( STR_ ) ; dictionary = dictionaryFactory . create ( core , searcher ) ; lookup . build ( dictionary ) ; if ( storeDir != null ) { File target = new File ( storeDir , factory . storeFileName ( ) ) ; if ( ! lookup . store ( new FileOutputStream ( target ) ) ) { LOG . error ( STR_ ) ; } else { LOG . info ( STR_ + target . getAbsolutePath ( ) ) ; } } }
public static String convertClassNameToResourcePath ( String className ) { Assert . notNull ( className , STR_ ) ; return className . replace ( STR_ , STR_ ) ; }
public URI ( String scheme , String schemeSpecificPart , String fragment ) throws URISyntaxException { StringBuilder uri = new StringBuilder ( ) ; if ( scheme != null ) { uri . append ( scheme ) ; uri . append ( STR_ ) ; } if ( schemeSpecificPart != null ) { ALL_LEGAL_ENCODER . appendEncoded ( uri , schemeSpecificPart ) ; } if ( fragment != null ) { uri . append ( STR_ ) ; ALL_LEGAL_ENCODER . appendEncoded ( uri , fragment ) ; } parseURI ( uri . toString ( ) , BOOL_ ) ; }
private int addToPopulation ( Solution solution ) { int id = nextFreeId ( ) ; solutions . put ( id , solution ) ; return id ; }
public byte [ ] toByteArray ( ) { return Arrays . copyOf ( buf , cnt ) ; }
public void createDiskAsync ( final String projectId , final DiskCreateSpec diskCreateSpec , final FutureCallback < Task > responseCallback ) throws IOException { final String path = String . format ( STR_ , getBasePath ( ) , projectId ) ; createObjectAsync ( path , serializeObjectAsJson ( diskCreateSpec ) , responseCallback ) ; }
@ Override public boolean domainMatch ( final String host , final String domain ) { return host . endsWith ( domain ) ; }
public synchronized void disableAttribute ( String name ) { enabledAttributes . removeElement ( name ) ; }
public Criteria createCriteria ( ) { Criteria criteria = createCriteriaInternal ( ) ; if ( oredCriteria . size ( ) == NUM_ ) { oredCriteria . add ( criteria ) ; } return criteria ; }
public void push ( final Handle handle ) { mv . visitLdcInsn ( handle ) ; }
@ Deprecated public static String encodePostBody ( Bundle parameters , String boundary ) { if ( parameters == null ) return STR_ ; StringBuilder sb = new StringBuilder ( ) ; for ( String key : parameters . keySet ( ) ) { Object parameter = parameters . get ( key ) ; if ( ! ( parameter instanceof String ) ) { continue ; } sb . append ( STR_ + key + STR_ + ( String ) parameter ) ; sb . append ( STR_ + STR_ + boundary + STR_ ) ; } return sb . toString ( ) ; }
public static IFitsHeader lookup ( String key ) { int keyLength = key . length ( ) ; if ( keyLength > NUM_ && Character . isDigit ( key . charAt ( keyLength - NUM_ ) ) ) { StringBuilder builder = new StringBuilder ( ) ; for ( int index = NUM_ ; index < keyLength ; index ++ ) { char character = key . charAt ( index ) ; if ( Character . isDigit ( character ) ) { if ( builder . charAt ( builder . length ( ) - NUM_ ) != STR_ ) { builder . append ( STR_ ) ; } } else { builder . append ( character ) ; } } return STANDARD_KEYS . get ( builder . toString ( ) ) ; } return STANDARD_KEYS . get ( key ) ; }
private static void assertChangeEvents ( Collection < PortChangeEvent > earlyEvents , Collection < PortChangeEvent > lateEvents , Collection < PortChangeEvent > anytimeEvents , Collection < PortChangeEvent > actualEvents ) { String inputDesc = String . format ( STR_ + STR_ , earlyEvents , lateEvents , anytimeEvents , actualEvents ) ; Collection < PortChangeEvent > early = new ArrayList < PortChangeEvent > ( earlyEvents ) ; Collection < PortChangeEvent > late = new ArrayList < PortChangeEvent > ( lateEvents ) ; Collection < PortChangeEvent > any = new ArrayList < PortChangeEvent > ( anytimeEvents ) ; for ( PortChangeEvent ev : early ) { assertFalse ( STR_ , late . contains ( ev ) ) ; assertFalse ( STR_ , any . contains ( ev ) ) ; } for ( PortChangeEvent ev : late ) { assertFalse ( STR_ , early . contains ( ev ) ) ; assertFalse ( STR_ , any . contains ( ev ) ) ; } for ( PortChangeEvent ev : any ) { assertFalse ( STR_ , early . contains ( ev ) ) ; assertFalse ( STR_ , late . contains ( ev ) ) ; } for ( PortChangeEvent a : actualEvents ) { if ( early . remove ( a ) ) { continue ; } if ( any . remove ( a ) ) { continue ; } if ( late . remove ( a ) ) { if ( ! early . isEmpty ( ) ) { fail ( a + STR_ + STR_ + inputDesc ) ; } else { continue ; } } fail ( a + STR_ + inputDesc ) ; } if ( ! early . isEmpty ( ) ) fail ( STR_ + early + STR_ + inputDesc ) ; if ( ! late . isEmpty ( ) ) fail ( STR_ + late + STR_ + inputDesc ) ; if ( ! any . isEmpty ( ) ) fail ( STR_ + any + STR_ + inputDesc ) ; }
@ Override public void write ( Kryo kryo , Output output ) { int size = index . size ( ) ; output . writeInt ( size + NUM_ , BOOL_ ) ; for ( int i = NUM_ ; i < size ; ++ i ) { String s = index . get ( i ) ; if ( s == null ) { throw new RuntimeException ( STR_ + Integer . toString ( i ) ) ; } output . writeString ( s ) ; } }
public final ObjectProperty < Control > toggleNodeProperty ( ) { return this . toggleNode ; }
private static int decodeOctets ( int i , ByteBuffer bb , StringBuilder sb ) { if ( bb . limit ( ) == NUM_ && ( bb . get ( NUM_ ) & xFF ) < x80 ) { sb . append ( ( char ) bb . get ( NUM_ ) ) ; return i + NUM_ ; } else { CharBuffer cb = UTF_8_CHARSET . decode ( bb ) ; sb . append ( cb . toString ( ) ) ; return i + bb . limit ( ) . NUM_ - NUM_ ; } }
public ArrayFieldVector ( FieldVector < T > v1 , T [ ] v2 ) throws NullArgumentException { MathUtils . checkNotNull ( v1 ) ; MathUtils . checkNotNull ( v2 ) ; field = v1 . getField ( ) ; final T [ ] v1Data = ( v1 instanceof ArrayFieldVector ) ? ( ( ArrayFieldVector < T > ) v1 ) . data : v1 . toArray ( ) ; data = MathArrays . buildArray ( field , v1Data . length + v2 . length ) ; System . arraycopy ( v1Data , NUM_ , data , NUM_ , v1Data . length ) ; System . arraycopy ( v2 , NUM_ , data , v1Data . length , v2 . length ) ; }
public void reverse ( ) { final ArrayList < Animator > animators = mAnimatedVectorState . mAnimators ; final int size = animators . size ( ) ; for ( int i = NUM_ ; i < size ; i ++ ) { final Animator animator = animators . get ( i ) ; if ( canReverse ( animator ) ) { reverse ( animator ) ; } else { Log . w ( LOG_TAG , STR_ ) ; } } }
public void start ( ) { if ( sLogger . isActivated ( ) ) { sLogger . info ( STR_ ) ; } mCleanupExecutor = Executors . newSingleThreadExecutor ( ) ; if ( ! mObserverIsRegistered ) { mContactsContractObserver = new ContactsContractObserver ( new Handler ( ) ) ; mContactsContractCursor = mContentResolver . query ( Phone . CONTENT_URI , null , null , null , null ) ; CursorUtil . assertCursorIsNotNull ( mContactsContractCursor , Phone . CONTENT_URI ) ; mContactsContractCursor . registerContentObserver ( mContactsContractObserver ) ; mObserverIsRegistered = BOOL_ ; } }
protected final void fireVetoableChange ( String propertyName , double oldValue , double newValue ) throws PropertyVetoException { fireVetoableChange ( propertyName , Double . valueOf ( oldValue ) , Double . valueOf ( newValue ) ) ; }
public void onSinksReceived ( String sourceUrn , List < MediaSink > sinks ) { mSinks . put ( sourceUrn , sinks ) ; nativeOnSinksReceived ( mNativeMediaRouterAndroid , sourceUrn , sinks . size ( ) ) ; }
public User toEntity ( UserDTO dto ) { return toEntity ( dto , NUM_ ) ; }
protected void writeExternalForeignKeyDropStmt ( Table table , ForeignKey foreignKey , StringBuilder ddl ) { writeTableAlterStmt ( table , ddl ) ; ddl . append ( STR_ ) ; printIdentifier ( getForeignKeyName ( table , foreignKey ) , ddl ) ; printEndOfStatement ( ddl ) ; }
public void obtain ( long timeout_ms ) throws IOException , InterruptedException , TimeoutException { Long quit_time = System . currentTimeMillis ( ) + timeout_ms ; if ( fileLock != null && fileLock . isValid ( ) ) { return ; } do { try { fileLock = fileToLock . tryLock ( ) ; return ; } catch ( OverlappingFileLockException e ) { Thread . sleep ( NUM_ ) ; } } while ( System . currentTimeMillis ( ) < quit_time ) ; throw new TimeoutException ( ) ; }
@ Deprecated public void pointToData ( Data o ) throws FitsException { o . fillHeader ( this ) ; }
@ NotNull protected VirtualFile [ ] collectAffectedFiles ( @ NotNull Project project , @ NotNull VirtualFile [ ] files ) { List < VirtualFile > affectedFiles = new ArrayList < VirtualFile > ( files . length ) ; ProjectLevelVcsManager projectLevelVcsManager = ProjectLevelVcsManager . getInstance ( project ) ; for ( VirtualFile file : files ) { if ( ! file . isDirectory ( ) && projectLevelVcsManager . getVcsFor ( file ) instanceof GitVcs ) { affectedFiles . add ( file ) ; } else if ( file . isDirectory ( ) && isRecursive ( ) ) { addChildren ( project , affectedFiles , file ) ; } } return VfsUtilCore . toVirtualFileArray ( affectedFiles ) ; }
public void updatePosition ( Particle particle , long elapsedTime ) { Vector3f speed = particle . getSpeed ( ) ; float delta = elapsedTime / NUM_ ; float dx = speed . x . delta ; float dy = speed . y . delta ; float dz = speed . z . delta ; Vector3f pos = particle . getPosition ( ) ; particle . setPosition ( pos . x + dx , pos . y + dy , pos . z + dz ) ; }
protected void update ( int length ) { tickLabelValues . clear ( ) ; tickLabels . clear ( ) ; tickLabelPositions . clear ( ) ; if ( scale . isLogScaleEnabled ( ) ) { updateTickLabelForLogScale ( length ) ; } else { updateTickLabelForLinearScale ( length ) ; } updateTickVisibility ( ) ; updateTickLabelMaxLengthAndHeight ( ) ; }
private static boolean isWithinBounds ( VisualPosition targetPosition , VisualPosition startPosition , VisualPosition endPosition ) { return targetPosition . line >= startPosition . line && targetPosition . line <= endPosition . line && targetPosition . column >= startPosition . column && targetPosition . column <= endPosition . column ; }
static public void assertStatementIndicesConsistent ( final AbstractTripleStore db , final int maxerrors ) { if ( log . isInfoEnabled ( ) ) log . info ( STR_ ) ; final AtomicInteger nerrs = new AtomicInteger ( NUM_ ) ; final int from , to ; if ( db . getSPOKeyArity ( ) == NUM_ ) { from = SPOKeyOrder . FIRST_TRIPLE_INDEX ; to = SPOKeyOrder . LAST_TRIPLE_INDEX ; } else { from = SPOKeyOrder . FIRST_QUAD_INDEX ; to = SPOKeyOrder . LAST_QUAD_INDEX ; } for ( int i = from ; i <= to ; i ++ ) { for ( int j = from ; j <= to ; j ++ ) { if ( i <= j ) { continue ; } assertSameStatements ( db , SPOKeyOrder . valueOf ( i ) , SPOKeyOrder . valueOf ( j ) , nerrs , maxerrors ) ; } } assertEquals ( NUM_ , nerrs . get ( ) ) ; }
public void show ( @ IdRes final int itemId ) { map . add ( itemId ) ; navigation . invalidateBadge ( itemId ) ; }
public Options put ( String option , Integer value ) { if ( value == null ) { return remove ( option ) ; } options . put ( option , value . toString ( ) ) ; return this ; }
private int determineTargetPage ( int currentPage , float pageOffset , int velocity , int deltaX ) { int targetPage ; if ( Math . abs ( deltaX ) > flingDistance && Math . abs ( velocity ) > minimumVelocity ) { if ( virtualPos < NUM_ ) { targetPage = velocity > NUM_ ? currentPage : currentPage + NUM_ ; } else { targetPage = velocity > NUM_ ? currentPage + NUM_ : currentPage ; } } else { final float truncator = currentPage >= currentItem ? NUM_ : NUM_ ; targetPage = ( int ) ( currentPage + pageOffset + truncator ) ; } if ( items . size ( ) > NUM_ ) { final ItemInfo firstItem = items . get ( NUM_ ) ; final ItemInfo lastItem = items . get ( items . size ( ) - NUM_ ) ; targetPage = Math . max ( firstItem . position , Math . min ( targetPage , lastItem . position ) ) ; } if ( targetPage > currentPage && onCardChangeListener != null ) { onCardChangeListener . onCardDismissed ( currentPage , virtualPos > NUM_ ) ; } return targetPage ; }
protected String form ( ObjectMatrix1D matrix , int index , Former formatter ) { Object value = matrix . get ( index ) ; if ( value == null ) return STR_ ; return String . valueOf ( value ) ; }
public void clone ( Vector3f source ) { System . arraycopy ( source . points , NUM_ , points , NUM_ , NUM_ ) ; }
public void disable ( BluetoothAdapter adapter ) { int mask = ( BluetoothReceiver . STATE_TURNING_OFF_FLAG | BluetoothReceiver . STATE_OFF_FLAG | BluetoothReceiver . SCAN_MODE_NONE_FLAG ) ; long start = - NUM_ ; BluetoothReceiver receiver = getBluetoothReceiver ( mask ) ; int state = adapter . getState ( ) ; switch ( state ) { case BluetoothAdapter . STATE_OFF : assertFalse ( adapter . isEnabled ( ) ) ; removeReceiver ( receiver ) ; return ; case BluetoothAdapter . STATE_TURNING_ON : assertFalse ( adapter . isEnabled ( ) ) ; start = System . currentTimeMillis ( ) ; break ; case BluetoothAdapter . STATE_ON : assertTrue ( adapter . isEnabled ( ) ) ; start = System . currentTimeMillis ( ) ; assertTrue ( adapter . disable ( ) ) ; break ; case BluetoothAdapter . STATE_TURNING_OFF : assertFalse ( adapter . isEnabled ( ) ) ; mask = NUM_ ; break ; default : removeReceiver ( receiver ) ; fail ( String . format ( STR_ , state ) ) ; } long s = System . currentTimeMillis ( ) ; while ( System . currentTimeMillis ( ) - s < ENABLE_DISABLE_TIMEOUT ) { state = adapter . getState ( ) ; if ( state == BluetoothAdapter . STATE_OFF && ( receiver . getFiredFlags ( ) & mask ) == mask ) { assertFalse ( adapter . isEnabled ( ) ) ; long finish = receiver . getCompletedTime ( ) ; if ( start != - NUM_ && finish != - NUM_ ) { writeOutput ( String . format ( STR_ , ( finish - start ) ) ) ; } else { writeOutput ( STR_ ) ; } removeReceiver ( receiver ) ; return ; } sleep ( POLL_TIME ) ; } int firedFlags = receiver . getFiredFlags ( ) ; removeReceiver ( receiver ) ; fail ( String . format ( STR_ , state , BluetoothAdapter . STATE_OFF , firedFlags , mask ) ) ; }
public static String toRegex ( String glob , String separator ) { checkNotNull ( separator , STR_ ) ; checkArgument ( separator . length ( ) == NUM_ , STR_ , separator ) ; return toRegex ( glob , separator . charAt ( NUM_ ) ) ; }
protected void forceNoLoss ( boolean value ) { }
public static String [ ] splitWithoutEscaped ( String str , char separatorChar , boolean retainEmpty ) { int len = str . length ( ) ; if ( len == NUM_ ) { return new String [ NUM_ ] ; } List < String > list = new ArrayList < String > ( ) ; int i = NUM_ ; int start = NUM_ ; boolean match = BOOL_ ; while ( i < len ) { if ( str . charAt ( i ) == STR_ ) { match = BOOL_ ; i += NUM_ ; } else if ( str . charAt ( i ) == separatorChar ) { if ( retainEmpty || match ) { list . add ( str . substring ( start , i ) ) ; match = BOOL_ ; } start = ++ i ; } else { match = BOOL_ ; i ++ ; } } if ( retainEmpty || match ) { list . add ( str . substring ( start , i ) ) ; } return list . toArray ( new String [ list . size ( ) ] ) ; }
private static HashMap < BasicBlockPair , HashSet < Register > > findSplitPoints ( IR ir , LiveAnalysis live , LSTGraph lst ) { HashMap < BasicBlockPair , HashSet < Register > > result = new HashMap < BasicBlockPair , HashSet < Register > > ( NUM_ ) ; for ( Enumeration < GraphNode > e = lst . enumerateNodes ( ) ; e . hasMoreElements ( ) ; ) { LSTNode node = ( LSTNode ) e . nextElement ( ) ; BasicBlock header = node . getHeader ( ) ; BitVector loop = node . getLoop ( ) ; if ( loop == null ) continue ; for ( Enumeration < BasicBlock > in = header . getIn ( ) ; in . hasMoreElements ( ) ; ) { BasicBlock bb = in . nextElement ( ) ; if ( loop . get ( bb . getNumber ( ) ) ) continue ; HashSet < Register > liveRegisters = live . getLiveRegistersOnEdge ( bb , header ) ; for ( Register r : liveRegisters ) { if ( r . isSymbolic ( ) ) { HashSet < Register > s = findOrCreateSplitSet ( result , bb , header ) ; s . add ( r ) ; } } } for ( int i = NUM_ ; i < loop . length ( ) ; i ++ ) { if ( loop . get ( i ) ) { BasicBlock bb = ir . getBasicBlock ( i ) ; for ( Enumeration < BasicBlock > out = bb . getNormalOut ( ) ; out . hasMoreElements ( ) ; ) { BasicBlock dest = out . nextElement ( ) ; if ( loop . get ( dest . getNumber ( ) ) ) continue ; HashSet < Register > liveRegisters = live . getLiveRegistersOnEdge ( bb , dest ) ; for ( Register r : liveRegisters ) { if ( r . isSymbolic ( ) ) { HashSet < Register > s = findOrCreateSplitSet ( result , bb , dest ) ; s . add ( r ) ; } } } } } } addEntriesForInfrequentBlocks ( ir , live , result ) ; return result ; }
public void testSplitEscapedSemicolons ( ) { Properties inner = PropertyUtils . splitPropertiesOnSemicolon ( PropertyUtils . escapeBackSlashesIfNotNull ( STR_ ) ) ; assertEquals ( NUM_ , inner . size ( ) ) ; assertEquals ( STR_ , inner . getProperty ( STR_ ) ) ; assertEquals ( STR_ , inner . getProperty ( STR_ ) ) ; assertEquals ( STR_ , inner . getProperty ( STR_ ) ) ; assertEquals ( STR_ , inner . getProperty ( STR_ ) ) ; }
public static void removeObjectAtOffset ( Object [ ] sourceArray , Object [ ] destinationArray , int offset ) { System . arraycopy ( sourceArray , NUM_ , destinationArray , NUM_ , offset ) ; System . arraycopy ( sourceArray , offset + NUM_ , destinationArray , offset , sourceArray . length - offset - NUM_ ) ; }
@ SuppressWarnings ( STR_ ) public DictionaryAdapter ( Context context , File dbPath , String dbName , String defaultTable ) { mContext = context ; mDbName = dbName ; mDefaultTable = defaultTable ; mDbPath = dbPath ; mDbFile = new File ( dbPath , mDbName ) ; if ( mDbFile . exists ( ) ) { open ( ) ; } }
public boolean isTabAssociatedWithNonDestroyedActivity ( boolean isIncognito , int tabId ) { List < WeakReference < Activity > > activities = ApplicationStatus . getRunningActivities ( ) ; for ( WeakReference < Activity > ref : activities ) { Activity activity = ref . get ( ) ; if ( activity != null && isValidActivity ( isIncognito , activity . getIntent ( ) ) && getTabIdFromIntent ( activity . getIntent ( ) ) == tabId && ! isActivityDestroyed ( activity ) ) { return BOOL_ ; } } return BOOL_ ; }
HttpStreamWrapper ( HttpStream stream ) throws IOException { _stream = stream ; }
public boolean handleFile ( File file ) { if ( DEBUG ) { logger . fine ( STR_ + file . getAbsolutePath ( ) ) ; } filenames . add ( file ) ; return BOOL_ ; }
public boolean looksLikeNumberComing ( ) { if ( n >= s . length ( ) ) return BOOL_ ; return Character . isDigit ( s . charAt ( n ) ) ; }
public PartialHull ( IPoint first , IPoint second ) { points . add ( first ) ; points . add ( second ) ; }
public void addSwipeListener ( SwipeListener listener ) { if ( mListeners == null ) { mListeners = new ArrayList < SwipeListener > ( ) ; } mListeners . add ( listener ) ; }
public short readShort ( ) throws IOException { return primitiveTypes . readShort ( ) ; }
public void print ( int inum ) { print ( String . valueOf ( inum ) ) ; }
public static < NodeType extends IViewNode < ? > > ZyProximityNode < ? > createProximityNode ( final Graph2D graph , final ZyGraphNode < ? > attachedNode , final int degree , final boolean isIncoming ) { Preconditions . checkNotNull ( graph , STR_ ) ; Preconditions . checkNotNull ( attachedNode , STR_ ) ; final ZyLabelContent labelcontent = new ZyLabelContent ( null ) ; labelcontent . addLineContent ( new ZyLineContent ( String . valueOf ( degree ) , new Font ( STR_ , Font . PLAIN , NUM_ ) , null ) ) ; final ZyProximityNodeRealizer < NodeType > r = new ZyProximityNodeRealizer < NodeType > ( labelcontent ) ; final Node node = graph . createNode ( r ) ; @ SuppressWarnings ( STR_ ) final ZyProximityNode < NodeType > infoNode = new ZyProximityNode < NodeType > ( node , r , ( ZyGraphNode < NodeType > ) attachedNode , isIncoming ) ; final ZyNodeData < ZyProximityNode < NodeType > > data = new ZyNodeData < ZyProximityNode < NodeType > > ( infoNode ) ; r . setUserData ( data ) ; return infoNode ; }
public static boolean isZoningRequired ( DbClient dbClient , URI varrayUri ) { if ( varrayUri != null ) { VirtualArray nh = dbClient . queryObject ( VirtualArray . class , varrayUri ) ; if ( nh != null ) { return isZoningRequired ( dbClient , nh ) ; } } return BOOL_ ; }
public void reply ( List < String > responseHeaders , boolean out ) throws IOException { assert ( ! Thread . holdsLock ( SpdyStream . this ) ) ; boolean outFinished = BOOL_ ; synchronized ( this ) { if ( responseHeaders == null ) { throw new NullPointerException ( STR_ ) ; } if ( isLocallyInitiated ( ) ) { throw new IllegalStateException ( STR_ ) ; } if ( this . responseHeaders != null ) { throw new IllegalStateException ( STR_ ) ; } this . responseHeaders = responseHeaders ; if ( ! out ) { this . out . finished = BOOL_ ; outFinished = BOOL_ ; } } connection . writeSynReply ( id , outFinished , responseHeaders ) ; }
protected CCAnimation ( String name , float delay , ArrayList < CCSpriteFrame > frames ) { delay_ = delay ; name_ = name ; frames_ = new ArrayList < CCSpriteFrame > ( ) ; if ( frames != null ) frames_ . addAll ( frames ) ; }
private void navigateToDump ( ) { TreePath currentPath = tree . getSelectionPath ( ) ; tree . setSelectionPath ( currentPath . getParentPath ( ) ) ; tree . scrollPathToVisible ( currentPath . getParentPath ( ) ) ; }
public synchronized void addMessages ( ArrayList < SmsMmsMessage > newMessages ) { if ( newMessages != null ) { messages . addAll ( NUM_ , newMessages ) ; UpdateMessageCount ( ) ; } }
public static Cache . Entry makeRandomCacheEntry ( byte [ ] data , boolean isExpired , boolean needsRefresh ) { Random random = new Random ( ) ; Cache . Entry entry = new Cache . Entry ( ) ; if ( data != null ) { entry . data = data ; } else { entry . data = new byte [ random . nextInt ( NUM_ ) ] ; } entry . etag = String . valueOf ( random . nextLong ( ) ) ; entry . serverDate = random . nextLong ( ) ; entry . ttl = isExpired ? NUM_ : Long . MAX_VALUE ; entry . softTtl = needsRefresh ? NUM_ : Long . MAX_VALUE ; return entry ; }
public int swap ( ) { if ( ! egl . eglSwapBuffers ( eglDisplay , eglSurface ) ) { return egl . eglGetError ( ) ; } return EGL10 . EGL_SUCCESS ; }
public static List < Window > windows ( String words , int windowSize ) { StringTokenizer tokenizer = new StringTokenizer ( words ) ; List < String > list = new ArrayList < String > ( ) ; while ( tokenizer . hasMoreTokens ( ) ) list . add ( tokenizer . nextToken ( ) ) ; return windows ( list , windowSize ) ; }
public static String buildPath ( JsonPath jsonPath ) { List < String > urlParts = new LinkedList < > ( ) ; JsonPath currentJsonPath = jsonPath ; String pathPart ; do { if ( currentJsonPath instanceof RelationshipsPath ) { pathPart = RELATIONSHIP_MARK + SEPARATOR + currentJsonPath . getElementName ( ) ; } else if ( currentJsonPath instanceof FieldPath ) { pathPart = currentJsonPath . getElementName ( ) ; } else { pathPart = currentJsonPath . getElementName ( ) ; if ( currentJsonPath . getIds ( ) != null ) { pathPart += SEPARATOR + mergeIds ( currentJsonPath . getIds ( ) ) ; } } urlParts . add ( pathPart ) ; currentJsonPath = currentJsonPath . getParentResource ( ) ; } while ( currentJsonPath != null ) ; Collections . reverse ( urlParts ) ; return SEPARATOR + StringUtils . join ( SEPARATOR , urlParts ) + SEPARATOR ; }
protected void groupFrames ( Vector < Frame > frames , Vector < Group > groups , boolean isDchum ) throws MakeTocException { Frame frame ; Group group ; int groupCount ; int nFrames = frames . size ( ) ; Debug . message ( STR_ , STR_ ) ; for ( int i = NUM_ ; i < nFrames ; i ++ ) { Debug . message ( STR_ , STR_ ) ; frame = ( Frame ) frames . elementAt ( i ) ; if ( ! frame . marked ) { groupCount = groups . size ( ) ; group = new Group ( ) ; group . left = maxSide / NUM_ ; group . right = group . left + NUM_ ; group . top = maxSide / NUM_ ; group . bottom = group . top + NUM_ ; group . horiz_pos [ group . top ] = frame . top ; group . horiz_pos [ group . bottom ] = frame . bottom ; group . vert_pos [ group . left ] = frame . left ; group . vert_pos [ group . right ] = frame . right ; group . h_interval = frame . h_interval ; group . v_interval = frame . v_interval ; group . h_resolution = frame . h_resolution ; group . v_resolution = frame . v_resolution ; group . scale = frame . scale ; group . zone = frame . zone ; group . cib = frame . cib ; group . cdted = frame . cdted ; frame . x = group . left ; frame . y = group . top ; frame . group = groupCount ; frame . marked = BOOL_ ; Debug . message ( STR_ , STR_ + groupCount + STR_ + i + STR_ + frame . filename + STR_ ) ; if ( ! isDchum ) { for ( int j = NUM_ ; j < nFrames ; j ++ ) { if ( i == j ) { Debug . message ( STR_ , STR_ + i + STR_ ) ; continue ; } Frame f = ( Frame ) frames . elementAt ( j ) ; if ( addFrameToGroup ( group , f , groupCount ) ) { Debug . message ( STR_ , STR_ + j + STR_ + groupCount ) ; continue ; } } } Debug . message ( STR_ , STR_ + groupCount + STR_ ) ; groups . add ( group ) ; } fireProgressUpdate ( ProgressEvent . UPDATE , STR_ , i , nFrames ) ; } if ( Debug . debugging ( STR_ ) ) { Debug . output ( STR_ + groups . size ( ) ) ; } }
private static Object add ( final Object array , final int index , final Object element , final Class < ? > clss ) { if ( array == null ) { if ( index != NUM_ ) { throw new IndexOutOfBoundsException ( STR_ + index + STR_ ) ; } Object joinedArray = Array . newInstance ( clss , NUM_ ) ; Array . set ( joinedArray , NUM_ , element ) ; return joinedArray ; } int length = Array . getLength ( array ) ; if ( index > length || index < NUM_ ) { throw new IndexOutOfBoundsException ( STR_ + index + STR_ + length ) ; } Object result = Array . newInstance ( clss , length + NUM_ ) ; System . arraycopy ( array , NUM_ , result , NUM_ , index ) ; Array . set ( result , index , element ) ; if ( index < length ) { System . arraycopy ( array , index , result , index + NUM_ , length - index ) ; } return result ; }
public double doubleValue ( ) { return d . doubleValue ( ) ; }
public String toMatlab ( ) { StringBuffer result ; int i ; int n ; result = new StringBuffer ( ) ; result . append ( STR_ ) ; for ( i = NUM_ ; i < getRowDimension ( ) ; i ++ ) { if ( i > NUM_ ) { result . append ( STR_ ) ; } for ( n = NUM_ ; n < getColumnDimension ( ) ; n ++ ) { if ( n > NUM_ ) { result . append ( STR_ ) ; } result . append ( Double . toString ( get ( i , n ) ) ) ; } } result . append ( STR_ ) ; return result . toString ( ) ; }
public FileInputReader ( File f ) throws IOException { if ( Debug . debugging ( STR_ ) ) { Debug . output ( STR_ + f . getAbsolutePath ( ) ) ; } name = f . getName ( ) ; absolutePath = f . getAbsolutePath ( ) ; inputFile = init ( f ) ; }
public static ObjectOutputStream newObjectOutputStream ( Path self ) throws IOException { return new ObjectOutputStream ( Files . newOutputStream ( self ) ) ; }
@ Override public Set < K > keySet ( ) { HashSet < K > set = new HashSet < K > ( ) ; for ( Segment < K , V > s : segments ) { set . addAll ( s . keySet ( ) ) ; } return set ; }
private void updateBaseMatrix ( Drawable d ) { ImageView imageView = getImageView ( ) ; if ( null == imageView || null == d ) { return ; } final float viewWidth = imageView . getWidth ( ) ; final float viewHeight = imageView . getHeight ( ) ; final int drawableWidth = d . getIntrinsicWidth ( ) ; final int drawableHeight = d . getIntrinsicHeight ( ) ; mBaseMatrix . reset ( ) ; final float widthScale = viewWidth / drawableWidth ; final float heightScale = viewHeight / drawableHeight ; if ( mScaleType == ScaleType . CENTER ) { mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth ) / NUM_ , ( viewHeight - drawableHeight ) / NUM_ ) ; } else if ( mScaleType == ScaleType . CENTER_CROP ) { float scale = Math . max ( widthScale , heightScale ) ; mBaseMatrix . postScale ( scale , scale ) ; mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth . scale ) / NUM_ , ( viewHeight - drawableHeight . scale ) / NUM_ ) ; } else if ( mScaleType == ScaleType . CENTER_INSIDE ) { float scale = Math . min ( NUM_ , Math . min ( widthScale , heightScale ) ) ; mBaseMatrix . postScale ( scale , scale ) ; mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth . scale ) / NUM_ , ( viewHeight - drawableHeight . scale ) / NUM_ ) ; } else { RectF mTempSrc = new RectF ( NUM_ , NUM_ , drawableWidth , drawableHeight ) ; RectF mTempDst = new RectF ( NUM_ , NUM_ , viewWidth , viewHeight ) ; switch ( mScaleType ) { case FIT_CENTER : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . CENTER ) ; break ; case FIT_START : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . START ) ; break ; case FIT_END : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . END ) ; break ; case FIT_XY : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . FILL ) ; break ; default : break ; } } resetMatrix ( ) ; }
public void add ( final CertificateValidity certificateValidity ) { certificateValidityList . add ( certificateValidity ) ; }
public void addPolicyListener ( PolicyListener policyListener ) { policyCache . addPolicyListener ( policyListener ) ; }
public static Result verify ( String sid , String code ) { String id = STR_ + sid ; Code c = ( Code ) Cache . get ( id ) ; if ( c == null ) { log . warn ( STR_ + sid ) ; return Result . badcode ; } else if ( ! X . isSame ( code , c . code ) ) { log . warn ( STR_ + c . code + STR_ + code ) ; return Result . badcode ; } else if ( c . expired < System . currentTimeMillis ( ) ) { log . warn ( STR_ + c . expired ) ; return Result . expired ; } return Result . ok ; }
private ScriptEngine newScriptEngine ( File file ) throws ScriptException { String filename = file . getName ( ) ; int index = filename . lastIndexOf ( STR_ ) ; if ( ( index < NUM_ ) || ( index >= filename . length ( ) - NUM_ ) ) { throw new ScriptException ( STR_ ) ; } String extension = filename . substring ( index + NUM_ ) ; ScriptEngineManager manager = new ScriptEngineManager ( ) ; ScriptEngine engine = manager . getEngineByExtension ( extension ) ; if ( engine == null ) { throw new ScriptException ( STR_ + extension ) ; } return engine ; }
protected static INaviRawModule findRawModule ( final int rawModuleId , final List < INaviRawModule > rawModules ) { Preconditions . checkArgument ( rawModuleId > NUM_ , STR_ , rawModuleId ) ; Preconditions . checkNotNull ( rawModules , STR_ ) ; for ( final INaviRawModule rawModule : rawModules ) { if ( rawModule . getId ( ) == rawModuleId ) { return rawModule ; } } throw new IllegalStateException ( STR_ ) ; }
public static Object extractTypeChecked ( List < Object > args , int i , Class clazz , Function < List < Object > , Object > extractFunc ) { if ( args . size ( ) < i + NUM_ ) { return null ; } else if ( clazz . isInstance ( args . get ( i ) ) ) { return extractFunc . apply ( args ) ; } else { return null ; } }
@ Override public JapaneseDate dateYearDay ( int prolepticYear , int dayOfYear ) { return new JapaneseDate ( LocalDate . ofYearDay ( prolepticYear , dayOfYear ) ) ; }
private Pair < Entry , char [ ] > recoverEntry ( KeyStore ks , String alias , char [ ] pstore , char [ ] pkey ) throws Exception { if ( ks . containsAlias ( alias ) == BOOL_ ) { MessageFormat form = new MessageFormat ( rb . getString ( STR_ ) ) ; Object [ ] source = { alias } ; throw new Exception ( form . format ( source ) ) ; } PasswordProtection pp = null ; Entry entry ; try { entry = ks . getEntry ( alias , pp ) ; pkey = null ; } catch ( UnrecoverableEntryException une ) { if ( P11KEYSTORE . equalsIgnoreCase ( ks . getType ( ) ) || KeyStoreUtil . isWindowsKeyStore ( ks . getType ( ) ) ) { throw une ; } if ( pkey != null ) { pp = new PasswordProtection ( pkey ) ; entry = ks . getEntry ( alias , pp ) ; } else { try { pp = new PasswordProtection ( pstore ) ; entry = ks . getEntry ( alias , pp ) ; pkey = pstore ; } catch ( UnrecoverableEntryException une2 ) { if ( P12KEYSTORE . equalsIgnoreCase ( ks . getType ( ) ) ) { throw une2 ; } else { pkey = getKeyPasswd ( alias , null , null ) ; pp = new PasswordProtection ( pkey ) ; entry = ks . getEntry ( alias , pp ) ; } } } } return Pair . of ( entry , pkey ) ; }
URLClassLoader newLoader ( URL base ) { return new URLClassLoader ( new URL [ ] { base } ) ; }
public void testMinUnequal1 ( ) { String a = STR_ ; int aScale = NUM_ ; String b = STR_ ; int bScale = NUM_ ; String c = STR_ ; int cScale = NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal bNumber = new BigDecimal ( new BigInteger ( b ) , bScale ) ; BigDecimal cNumber = new BigDecimal ( new BigInteger ( c ) , cScale ) ; assertEquals ( STR_ , cNumber , aNumber . min ( bNumber ) ) ; }
public Wiser ( ) { this . server = new SMTPServer ( new SimpleMessageListenerAdapter ( this ) ) ; }
protected static int [ ] concat ( @ Nullable int [ ] arr , int ... obj ) { int [ ] newArr ; if ( arr == null || arr . length == NUM_ ) newArr = obj ; else { newArr = Arrays . copyOf ( arr , arr . length + obj . length ) ; System . arraycopy ( obj , NUM_ , newArr , arr . length , obj . length ) ; } return newArr ; }
public void truckCamera ( float size ) { moveToPosition ( - ( float ) ( targetXoff + ( size . Math . sin ( Math . toRadians ( zrot - NUM_ ) ) ) ) , - ( float ) ( targetYoff + ( size . Math . cos ( Math . toRadians ( zrot - NUM_ ) ) ) ) ) ; }
public static byte [ ] decode2 ( String encoded ) { if ( encoded == null ) { return null ; } char [ ] base64Data = encoded . toCharArray ( ) ; int len = removeWhiteSpace ( base64Data ) ; if ( len % FOURBYTE != NUM_ ) { return null ; } int numberQuadruple = ( len / FOURBYTE ) ; if ( numberQuadruple == NUM_ ) { return new byte [ NUM_ ] ; } byte decodedData [ ] = null ; byte b1 = NUM_ , b2 = NUM_ , b3 = NUM_ , b4 = NUM_ ; char d1 = NUM_ , d2 = NUM_ , d3 = NUM_ , d4 = NUM_ ; int i = NUM_ ; int encodedIndex = NUM_ ; int dataIndex = NUM_ ; decodedData = new byte [ ( numberQuadruple ) . NUM_ ] ; for ( ; i < numberQuadruple - NUM_ ; i ++ ) { if ( ! isData ( ( d1 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d2 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d3 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d4 = base64Data [ dataIndex ++ ] ) ) ) { return null ; } b1 = base64Alphabet [ d1 ] ; b2 = base64Alphabet [ d2 ] ; b3 = base64Alphabet [ d3 ] ; b4 = base64Alphabet [ d4 ] ; decodedData [ encodedIndex ++ ] = ( byte ) ( b1 << NUM_ | b2 > > NUM_ ) ; decodedData [ encodedIndex ++ ] = ( byte ) ( ( ( b2 & xf ) << NUM_ ) | ( ( b3 > > NUM_ ) & xf ) ) ; decodedData [ encodedIndex ++ ] = ( byte ) ( b3 << NUM_ | b4 ) ; } if ( ! isData ( ( d1 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d2 = base64Data [ dataIndex ++ ] ) ) ) { return null ; } b1 = base64Alphabet [ d1 ] ; b2 = base64Alphabet [ d2 ] ; d3 = base64Data [ dataIndex ++ ] ; d4 = base64Data [ dataIndex ++ ] ; if ( ! isData ( ( d3 ) ) || ! isData ( ( d4 ) ) ) { if ( isPad ( d3 ) && isPad ( d4 ) ) { if ( ( b2 & xf ) != NUM_ ) { return null ; } byte [ ] tmp = new byte [ i . NUM_ + NUM_ ] ; System . arraycopy ( decodedData , NUM_ , tmp , NUM_ , i . NUM_ ) ; tmp [ encodedIndex ] = ( byte ) ( b1 << NUM_ | b2 > > NUM_ ) ; return tmp ; } else if ( ! isPad ( d3 ) && isPad ( d4 ) ) { b3 = base64Alphabet [ d3 ] ; if ( ( b3 & x3 ) != NUM_ ) { return null ; } byte [ ] tmp = new byte [ i . NUM_ + NUM_ ] ; System . arraycopy ( decodedData , NUM_ , tmp , NUM_ , i . NUM_ ) ; tmp [ encodedIndex ++ ] = ( byte ) ( b1 << NUM_ | b2 > > NUM_ ) ; tmp [ encodedIndex ] = ( byte ) ( ( ( b2 & xf ) << NUM_ ) | ( ( b3 > > NUM_ ) & xf ) ) ; return tmp ; } else { return null ; } } else { b3 = base64Alphabet [ d3 ] ; b4 = base64Alphabet [ d4 ] ; decodedData [ encodedIndex ++ ] = ( byte ) ( b1 << NUM_ | b2 > > NUM_ ) ; decodedData [ encodedIndex ++ ] = ( byte ) ( ( ( b2 & xf ) << NUM_ ) | ( ( b3 > > NUM_ ) & xf ) ) ; decodedData [ encodedIndex ++ ] = ( byte ) ( b3 << NUM_ | b4 ) ; } return decodedData ; }
public void shutdown ( ) { scheduledExecutorService . shutdownNow ( ) ; }
public Builder clear ( ) { localeBuilder . clear ( ) ; return this ; }
public static String deflate ( String previous , String current ) { if ( previous == null ) return current ; StringBuilder buf = new StringBuilder ( ) ; int start1 = NUM_ ; int start2 = NUM_ ; while ( start1 < previous . length ( ) && start2 < current . length ( ) ) { int end1 = start1 ; int end2 = start2 ; while ( end1 <= previous . length ( ) && end2 <= current . length ( ) ) { int c1 = ( end1 < previous . length ( ) ? previous . charAt ( end1 ) : STR_ ) ; int c2 = ( end2 < current . length ( ) ? current . charAt ( end2 ) : STR_ ) ; if ( c1 == c2 ) { if ( c1 == STR_ ) { buf . append ( STR_ ) ; break ; } else { end1 ++ ; end2 ++ ; } } else { while ( end1 < previous . length ( ) && previous . charAt ( end1 ) != STR_ ) { end1 ++ ; } while ( end2 < current . length ( ) && current . charAt ( end2 ) != STR_ ) { end2 ++ ; } for ( int i = start2 ; i < end2 ; i ++ ) buf . append ( current . charAt ( i ) ) ; break ; } } start1 = end1 + NUM_ ; start2 = end2 + NUM_ ; if ( start2 < current . length ( ) ) buf . append ( STR_ ) ; } return buf . toString ( ) ; }
protected int splitListIndex ( List < Pair < Double , Integer > > S ) { return S . size ( ) / NUM_ ; }
public static void e ( String tag , String msg , Object ... args ) { if ( sLevel > LEVEL_ERROR ) { return ; } if ( args . length > NUM_ ) { msg = String . format ( msg , args ) ; } Log . e ( tag , msg ) ; }
public static synchronized void addPropertyChangeListener ( PropertyChangeListener l ) { if ( ! listeners . contains ( l ) ) { listeners . add ( l ) ; } }
private static void cleanDirectory ( File path ) { if ( path == null ) return ; if ( path . exists ( ) ) { for ( File f : path . listFiles ( ) ) { if ( f . isDirectory ( ) ) cleanDirectory ( f ) ; f . delete ( ) ; } } }
private GridCacheVersion minVersion ( Iterable < IgniteTxEntry > entries , GridCacheVersion min , IgniteInternalTx tx ) { for ( IgniteTxEntry txEntry : entries ) { GridCacheEntryEx cached = txEntry . cached ( ) ; assert txEntry . isRead ( ) || ! cached . obsolete ( tx . xidVersion ( ) ) : STR_ + cached + STR_ + tx + STR_ ; for ( GridCacheMvccCandidate cand : cached . remoteMvccSnapshot ( ) ) if ( min == null || cand . version ( ) . isLess ( min ) ) min = cand . version ( ) ; } return min ; }
public DimensionedScalar ( String fieldValue ) throws IllegalArgumentException { super ( STR_ , STR_ ) ; Matcher matcher = PATTERN . matcher ( fieldValue ) ; if ( matcher . find ( ) ) { String name = matcher . group ( NUM_ ) ; String dimensions = matcher . group ( NUM_ ) ; String value = matcher . group ( NUM_ ) ; setName ( name ) ; setValue ( value ) ; this . dimensions = new Dimensions ( dimensions ) ; } else { throw new DictionaryException ( STR_ + fieldValue + STR_ ) ; } }
public void characters ( char ch [ ] , int start , int length ) throws SAXException { m_valueBuffer . append ( ch , start , length ) ; }
protected void initialize ( Properties p ) { }
public void add ( int index , int element ) { checkRangeIncludingEndpoint ( index ) ; ensureCapacity ( size + NUM_ ) ; int numtomove = size - index ; System . arraycopy ( array , index , array , index + NUM_ , numtomove ) ; array [ index ] = element ; size ++ ; }
public MultiplexManager ( DataStore ... dataStores ) { this . dataStores = Arrays . asList ( dataStores ) ; }
public boolean matchesRawNamePattern ( Object item ) { String prefix = patternMatcher . getPattern ( ) ; String text = getElementName ( item ) ; if ( text == null ) return BOOL_ ; int textLength = text . length ( ) ; int prefixLength = prefix . length ( ) ; if ( textLength < prefixLength ) { return BOOL_ ; } for ( int i = prefixLength - NUM_ ; i >= NUM_ ; i -- ) { if ( Character . toLowerCase ( prefix . charAt ( i ) ) != Character . toLowerCase ( text . charAt ( i ) ) ) return BOOL_ ; } return BOOL_ ; }
public static @ Nonnull < T > T valueOrDefault ( @ Nullable T value , @ Nonnull T defaultValue ) { return value == null ? defaultValue : value ; }
protected abstract int compareToLastMsg ( Pair < K , V > tupleKeyValue , Pair < byte [ ] , byte [ ] > lastReceivedKeyValue ) ;
public void paintComponent ( Graphics g ) { g . drawImage ( track , NUM_ , NUM_ , null ) ; Graphics2D g2d = ( Graphics2D ) g . create ( ) ; g2d . translate ( carPosition . x , carPosition . y ) ; g2d . rotate ( Math . toRadians ( carRotation ) ) ; g2d . translate ( - ( carPosition . x ) , - ( carPosition . y ) ) ; g2d . drawImage ( car , carPosition . x - carWHalf , carPosition . y - carHHalf , null ) ; }
public static java . sql . Time toSqlTime ( String time ) { java . util . Date newDate = toDate ( STR_ , time ) ; if ( newDate != null ) { return new java . sql . Time ( newDate . getTime ( ) ) ; } else { return null ; } }
private void parseMenu ( XmlPullParser parser , AttributeSet attrs , SublimeMenu menu ) throws XmlPullParserException , IOException { MenuState menuState = new MenuState ( menu ) ; int eventType = parser . getEventType ( ) ; String tagName ; boolean lookingForEndOfUnknownTag = BOOL_ ; String unknownTagName = null ; do { if ( eventType == XmlPullParser . START_TAG ) { tagName = parser . getName ( ) ; if ( tagName . equals ( XML_MENU ) ) { eventType = parser . next ( ) ; break ; } throw new RuntimeException ( STR_ + tagName ) ; } eventType = parser . next ( ) ; } while ( eventType != XmlPullParser . END_DOCUMENT ) ; boolean reachedEndOfMenu = BOOL_ ; while ( ! reachedEndOfMenu ) { switch ( eventType ) { case XmlPullParser . START_TAG : if ( lookingForEndOfUnknownTag ) { break ; } tagName = parser . getName ( ) ; if ( tagName . equals ( XML_GROUP ) ) { if ( menuState . groupId != MenuState . defaultGroupId ) { throw new RuntimeException ( STR_ + STR_ ) ; } menuState . readGroup ( attrs ) ; menuState . addGroup ( ) ; } else if ( tagName . equals ( XML_TEXT ) || tagName . equals ( XML_TEXT_WITH_BADGE ) || tagName . equals ( XML_CHECKBOX ) || tagName . equals ( XML_SWITCH ) ) { menuState . readMenuItem ( attrs , tagName ) ; } else if ( tagName . equals ( XML_SEPARATOR ) ) { menuState . readMenuItem ( attrs , tagName ) ; } else if ( tagName . equals ( XML_GROUP_HEADER ) ) { if ( menuState . groupId == MenuState . defaultGroupId ) { throw new RuntimeException ( STR_ + STR_ ) ; } menuState . readMenuItem ( attrs , tagName ) ; } else if ( tagName . equals ( XML_MENU ) ) { throw new RuntimeException ( STR_ + STR_ + STR_ ) ; } else { lookingForEndOfUnknownTag = BOOL_ ; unknownTagName = tagName ; } break ; case XmlPullParser . END_TAG : tagName = parser . getName ( ) ; if ( lookingForEndOfUnknownTag && tagName . equals ( unknownTagName ) ) { lookingForEndOfUnknownTag = BOOL_ ; unknownTagName = null ; } else if ( tagName . equals ( XML_GROUP ) ) { if ( menuState . isGroupCollapsible ( ) && menuState . groupHeadersAdded != NUM_ ) { if ( menuState . groupHeadersAdded < NUM_ ) { throw new RuntimeException ( STR_ + STR_ ) ; } else { throw new RuntimeException ( STR_ + STR_ + menuState . groupHeadersAdded + STR_ ) ; } } menuState . resetGroup ( ) ; } else if ( tagName . equals ( XML_TEXT ) || tagName . equals ( XML_TEXT_WITH_BADGE ) || tagName . equals ( XML_CHECKBOX ) || tagName . equals ( XML_SWITCH ) || tagName . equals ( XML_GROUP_HEADER ) || tagName . equals ( XML_SEPARATOR ) ) { if ( ! menuState . hasAddedItem ( ) ) { menuState . addItem ( ) ; } } else if ( tagName . equals ( XML_MENU ) ) { reachedEndOfMenu = BOOL_ ; } break ; case XmlPullParser . END_DOCUMENT : throw new RuntimeException ( STR_ ) ; } eventType = parser . next ( ) ; } }
public static double crossTrackDistanceRad ( double lat1 , double lon1 , double lat2 , double lon2 , double latQ , double lonQ ) { final double dlon12 = lon2 - lon1 ; final double dlon1Q = lonQ - lon1 ; final double dlat1Q = latQ - lat1 ; final double clat1 = Math . cos ( lat1 ) , slat1 = MathUtil . cosToSin ( lat1 , clat1 ) ; final double clatQ = Math . cos ( latQ ) , slatQ = MathUtil . cosToSin ( latQ , clatQ ) ; final double clat2 = Math . cos ( lat2 ) , slat2 = MathUtil . cosToSin ( lat2 , clat2 ) ; final double slat = Math . sin ( dlat1Q . NUM_ ) ; final double slon = Math . sin ( dlon1Q . NUM_ ) ; final double a = slat . slat + slon . slon . clat1 . clatQ ; final double angDist1Q = NUM_ . Math . atan2 ( Math . sqrt ( a ) , Math . sqrt ( NUM_ - a ) ) ; final double sdlon12 = Math . sin ( dlon12 ) , cdlon12 = MathUtil . sinToCos ( dlon12 , sdlon12 ) ; final double sdlon1Q = Math . sin ( dlon1Q ) , cdlon1Q = MathUtil . sinToCos ( dlon1Q , sdlon1Q ) ; final double yE = sdlon12 . clat2 ; final double yQ = sdlon1Q . clatQ ; final double xE = clat1 . slat2 - slat1 . clat2 . cdlon12 ; final double xQ = clat1 . slatQ - slat1 . clatQ . cdlon1Q ; final double crs12 = Math . atan2 ( yE , xE ) ; final double crs1Q = Math . atan2 ( yQ , xQ ) ; return Math . asin ( Math . sin ( angDist1Q ) . Math . sin ( crs1Q - crs12 ) ) ; }
public String chooseServerAlias ( String keyType , Principal [ ] issuers , Socket socket ) { return defaultX509KM . chooseServerAlias ( keyType , issuers , socket ) ; }
public static double pdf ( double x , double shape , double scale , double factor ) { if ( x <= NUM_ ) return NUM_ ; final double a = Math . exp ( shape . Math . log ( scale ) - ( shape + NUM_ ) . Math . log ( x ) - ( scale / x ) - GammaFunction . lnGamma ( shape ) ) ; return factor . a ; }
public String charge ( Properties ctx , int WindowNo , GridTab mTab , GridField mField , Object value ) { Integer C_Charge_ID = ( Integer ) value ; if ( C_Charge_ID == null || C_Charge_ID . intValue ( ) == NUM_ ) return STR_ ; String sql = STR_ ; PreparedStatement pstmt = null ; ResultSet rs = null ; try { pstmt = DB . prepareStatement ( sql , null ) ; pstmt . setInt ( NUM_ , C_Charge_ID . intValue ( ) ) ; rs = pstmt . executeQuery ( ) ; if ( rs . next ( ) ) { mTab . setValue ( STR_ , rs . getBigDecimal ( NUM_ ) ) ; } } catch ( SQLException e ) { log . log ( Level . SEVERE , sql , e ) ; return e . getLocalizedMessage ( ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } return tax ( ctx , WindowNo , mTab , mField , value ) ; }
protected Array < Actor > parse ( ) { actors = GdxArrays . newArray ( Actor . class ) ; invokePreListeners ( actors ) ; final StringBuilder builder = new StringBuilder ( ) ; while ( templateReader . hasNextCharacter ( ) ) { final char character = templateReader . nextCharacter ( ) ; if ( character == syntax . getArgumentOpening ( ) ) { processArgument ( ) ; } else if ( character == syntax . getTagOpening ( ) ) { if ( isNextCharacterCommentOpening ( ) ) { processComment ( ) ; continue ; } if ( currentParentTag != null ) { currentParentTag . handleDataBetweenTags ( builder ) ; } Strings . clearBuilder ( builder ) ; processTag ( builder ) ; } else { builder . append ( character ) ; } } if ( currentParentTag != null ) { throwError ( STR_ + currentParentTag . getTagName ( ) + STR_ ) ; } invokePortListeners ( actors ) ; return actors ; }
public void testABandCBbrokerNetwork ( ) throws Exception { bridgeBrokers ( STR_ , STR_ ) ; bridgeBrokers ( STR_ , STR_ ) ; startAllBrokers ( ) ; Destination dest = createDestination ( STR_ , BOOL_ ) ; MessageConsumer clientA = createConsumer ( STR_ , dest ) ; MessageConsumer clientB = createConsumer ( STR_ , dest ) ; MessageConsumer clientC = createConsumer ( STR_ , dest ) ; Thread . sleep ( NUM_ ) ; sendMessages ( STR_ , dest , MESSAGE_COUNT ) ; sendMessages ( STR_ , dest , MESSAGE_COUNT ) ; sendMessages ( STR_ , dest , MESSAGE_COUNT ) ; MessageIdList msgsA = getConsumerMessages ( STR_ , clientA ) ; MessageIdList msgsB = getConsumerMessages ( STR_ , clientB ) ; MessageIdList msgsC = getConsumerMessages ( STR_ , clientC ) ; msgsA . waitForMessagesToArrive ( MESSAGE_COUNT ) ; msgsB . waitForMessagesToArrive ( MESSAGE_COUNT . NUM_ ) ; msgsC . waitForMessagesToArrive ( MESSAGE_COUNT ) ; assertEquals ( MESSAGE_COUNT , msgsA . getMessageCount ( ) ) ; assertEquals ( MESSAGE_COUNT . NUM_ , msgsB . getMessageCount ( ) ) ; assertEquals ( MESSAGE_COUNT , msgsC . getMessageCount ( ) ) ; }
public void flush ( ) throws IOException { WspUtil . writeUint8 ( os_ , x01 ) ; writePublicIdentifier ( os_ , publicID_ ) ; WspUtil . writeUintvar ( os_ , WapConstants . MIB_ENUM_UTF_8 ) ; writeStringTable ( os_ ) ; wbxmlBody_ . close ( ) ; wbxmlBody_ . writeTo ( os_ ) ; os_ . flush ( ) ; }
public static void discard ( ) { current . remove ( ) ; }
private Token toASIToken ( ILeafNode leaf ) { if ( leaf . isHidden ( ) ) { return newSemicolonToken ( leaf ) ; } else { if ( ! leafNodes . hasNext ( ) ) { int tokenType = tokenTypeMapper . getInternalTokenType ( leaf ) ; int semicolonTokenType = tokenTypeMapper . getInternalTokenType ( semicolon ) ; if ( tokenType == semicolonTokenType ) { return new CommonToken ( semicolonTokenType , leaf . getText ( ) ) ; } if ( leaf . getTotalEndOffset ( ) == endOffset ) { leafNodes = Iterators . emptyIterator ( ) ; return new CommonToken ( tokenType , leaf . getText ( ) ) ; } next = new CommonToken ( semicolonTokenType , leaf . getText ( ) ) ; return new CommonToken ( tokenType , leaf . getText ( ) ) ; } else if ( leaf . getGrammarElement ( ) == rightCurlyInBlock || leaf . getGrammarElement ( ) == rightCurlyInArrowExpression ) { int tokenType = tokenTypeMapper . getInternalTokenType ( leaf ) ; next = new CommonToken ( tokenType ) ; return new CommonToken ( tokenTypeMapper . getInternalTokenType ( semicolon ) , leaf . getText ( ) ) ; } else { return newSemicolonToken ( leaf ) ; } } }
@ Override public PacketBuffer write ( PacketBuffer buf ) { values . forEach ( null ) ; return buf ; }
public final void registerFileType ( @ NotNull FileType type , @ NonNls @ Nullable String ... defaultAssociatedExtensions ) { List < FileNameMatcher > matchers = new ArrayList < FileNameMatcher > ( ) ; if ( defaultAssociatedExtensions != null ) { for ( String extension : defaultAssociatedExtensions ) { matchers . add ( new ExtensionFileNameMatcher ( extension ) ) ; } } registerFileType ( type , matchers ) ; }
public int parseInt ( String localeFormattedInteger ) { return Integer . parseInt ( localeFormattedInteger ) ; }
public static RequestSecurityTokenResponse parseXML ( String xml ) throws WSFederationException { Document doc = XMLUtils . toDOMDocument ( xml , debug ) ; Element root = doc . getDocumentElement ( ) ; return new RequestSecurityTokenResponse ( root ) ; }
@ Override public void requestResources ( SamzaResourceRequest resourceRequest ) { final int DEFAULT_PRIORITY = NUM_ ; log . info ( STR_ + resourceRequest . getPreferredHost ( ) + STR_ + resourceRequest . getContainerID ( ) ) ; int memoryMb = resourceRequest . getMemoryMB ( ) ; int cpuCores = resourceRequest . getNumCores ( ) ; String containerLabel = yarnConfig . getContainerLabel ( ) ; String preferredHost = resourceRequest . getPreferredHost ( ) ; Resource capability = Resource . newInstance ( memoryMb , cpuCores ) ; Priority priority = Priority . newInstance ( DEFAULT_PRIORITY ) ; AMRMClient . ContainerRequest issuedRequest ; if ( preferredHost . equals ( STR_ ) ) { log . info ( STR_ + preferredHost ) ; issuedRequest = new AMRMClient . ContainerRequest ( capability , null , null , priority , BOOL_ , containerLabel ) ; } else { log . info ( STR_ + preferredHost ) ; issuedRequest = new AMRMClient . ContainerRequest ( capability , new String [ ] { preferredHost } , null , priority , BOOL_ , containerLabel ) ; } synchronized ( lock ) { requestsMap . put ( resourceRequest , issuedRequest ) ; amClient . addContainerRequest ( issuedRequest ) ; } }
private Collection < ExtractedItemsCollection > filterItemsByLevel ( Player player , List < ExtractedItemsCollection > itemsCollections ) { int playerLevel = player . getLevel ( ) ; Collection < ExtractedItemsCollection > result = new ArrayList < ExtractedItemsCollection > ( ) ; for ( ExtractedItemsCollection collection : itemsCollections ) { if ( collection . getMinLevel ( ) > playerLevel ) { continue ; } if ( collection . getMaxLevel ( ) > NUM_ && collection . getMaxLevel ( ) < playerLevel ) { continue ; } result . add ( collection ) ; } return result ; }
private String printDFormat ( String sx ) { int nLeadingZeros = NUM_ ; int nBlanks = NUM_ , n = NUM_ ; int i = NUM_ ; final int jFirst ; final boolean neg = sx . charAt ( NUM_ ) == STR_ ; if ( sx . equals ( STR_ ) && precisionSet && precision == NUM_ ) { sx = STR_ ; } if ( ! neg ) { if ( precisionSet && sx . length ( ) < precision ) { nLeadingZeros = precision - sx . length ( ) ; } } else { if ( precisionSet && ( sx . length ( ) - NUM_ ) < precision ) { nLeadingZeros = precision - sx . length ( ) + NUM_ ; } } if ( nLeadingZeros < NUM_ ) { nLeadingZeros = NUM_ ; } if ( fieldWidthSet ) { nBlanks = fieldWidth - nLeadingZeros - sx . length ( ) ; if ( ! neg && ( leadingSign || leadingSpace ) ) { nBlanks -- ; } } if ( nBlanks < NUM_ ) { nBlanks = NUM_ ; } if ( leadingSign ) { n ++ ; } else if ( leadingSpace ) { n ++ ; } n += nBlanks ; n += nLeadingZeros ; n += sx . length ( ) ; final char [ ] ca = new char [ n ] ; if ( leftJustify ) { if ( neg ) { ca [ i ++ ] = STR_ ; } else if ( leadingSign ) { ca [ i ++ ] = STR_ ; } else if ( leadingSpace ) { ca [ i ++ ] = STR_ ; } final char [ ] csx = sx . toCharArray ( ) ; jFirst = neg ? NUM_ : NUM_ ; for ( int j = NUM_ ; j < nLeadingZeros ; i ++ , j ++ ) { ca [ i ] = STR_ ; } for ( int j = jFirst ; j < csx . length ; j ++ , i ++ ) { ca [ i ] = csx [ j ] ; } for ( int j = NUM_ ; j < nBlanks ; i ++ , j ++ ) { ca [ i ] = STR_ ; } } else { if ( ! leadingZeros ) { for ( i = NUM_ ; i < nBlanks ; i ++ ) { ca [ i ] = STR_ ; } if ( neg ) { ca [ i ++ ] = STR_ ; } else if ( leadingSign ) { ca [ i ++ ] = STR_ ; } else if ( leadingSpace ) { ca [ i ++ ] = STR_ ; } } else { if ( neg ) { ca [ i ++ ] = STR_ ; } else if ( leadingSign ) { ca [ i ++ ] = STR_ ; } else if ( leadingSpace ) { ca [ i ++ ] = STR_ ; } for ( int j = NUM_ ; j < nBlanks ; j ++ , i ++ ) { ca [ i ] = STR_ ; } } for ( int j = NUM_ ; j < nLeadingZeros ; j ++ , i ++ ) { ca [ i ] = STR_ ; } final char [ ] csx = sx . toCharArray ( ) ; jFirst = neg ? NUM_ : NUM_ ; for ( int j = jFirst ; j < csx . length ; j ++ , i ++ ) { ca [ i ] = csx [ j ] ; } } return new String ( ca ) ; }
private void drawHost ( Graphics2D g2 ) { Coord loc = node . getLocation ( ) ; if ( drawCoverage && node . isRadioActive ( ) ) { ArrayList < NetworkInterface > interfaces = new ArrayList < NetworkInterface > ( ) ; interfaces . addAll ( node . getInterfaces ( ) ) ; for ( NetworkInterface ni : interfaces ) { double range = ni . getTransmitRange ( ) ; Ellipse2D . Double coverage ; coverage = new Ellipse2D . Double ( scale ( loc . getX ( ) - range ) , scale ( loc . getY ( ) - range ) , scale ( range . NUM_ ) , scale ( range . NUM_ ) ) ; g2 . setColor ( rangeColor ) ; g2 . draw ( coverage ) ; } } if ( drawConnections ) { g2 . setColor ( conColor ) ; Coord c1 = node . getLocation ( ) ; ArrayList < Connection > conList = new ArrayList < Connection > ( ) ; conList . addAll ( node . getConnections ( ) ) ; for ( Connection c : conList ) { DTNHost otherNode = c . getOtherNode ( node ) ; Coord c2 ; if ( otherNode == null ) { continue ; } c2 = otherNode . getLocation ( ) ; g2 . drawLine ( scale ( c1 . getX ( ) ) , scale ( c1 . getY ( ) ) , scale ( c2 . getX ( ) ) , scale ( c2 . getY ( ) ) ) ; } } g2 . setColor ( hostColor ) ; g2 . drawRect ( scale ( loc . getX ( ) - NUM_ ) , scale ( loc . getY ( ) - NUM_ ) , scale ( NUM_ ) , scale ( NUM_ ) ) ; if ( isHighlighted ( ) ) { g2 . setColor ( highlightedNodeColor ) ; g2 . fillRect ( scale ( loc . getX ( ) ) - NUM_ , scale ( loc . getY ( ) ) - NUM_ , NUM_ , NUM_ ) ; } if ( drawNodeName ) { g2 . setColor ( hostNameColor ) ; g2 . drawString ( node . toString ( ) , scale ( loc . getX ( ) ) , scale ( loc . getY ( ) ) ) ; } }
public static int binarySearchFloor ( long [ ] a , long key , boolean inclusive , boolean stayInBounds ) { int index = Arrays . binarySearch ( a , key ) ; index = index < NUM_ ? - ( index + NUM_ ) : ( inclusive ? index : ( index - NUM_ ) ) ; return stayInBounds ? Math . max ( NUM_ , index ) : index ; }
public boolean add ( symbol sym ) throws internal_error { Object previous ; not_null ( sym ) ; previous = _all . put ( sym . name ( ) , sym ) ; return previous == null ; }
protected static final String addEscapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = NUM_ ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case NUM_ : continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < x20 || ch > x7e ) { String s = STR_ + Integer . toString ( ch , NUM_ ) ; retval . append ( STR_ + s . substring ( s . length ( ) - NUM_ , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; }
public final int size ( ) { if ( GWT . isScript ( ) ) { return jsArray . size ( ) ; } else { return javaArray . size ( ) ; } }
public static long longFromBase64 ( String value ) { int pos = NUM_ ; long longVal = base64Values [ value . charAt ( pos ++ ) ] ; int len = value . length ( ) ; while ( pos < len ) { longVal <<= NUM_ ; longVal |= base64Values [ value . charAt ( pos ++ ) ] ; } return longVal ; }
public List < LocalTime > bottom ( int n ) { List < LocalTime > bottom = new ArrayList < > ( ) ; int [ ] values = data . toIntArray ( ) ; IntArrays . parallelQuickSort ( values ) ; for ( int i = NUM_ ; i < n && i < values . length ; i ++ ) { bottom . add ( PackedLocalTime . asLocalTime ( values [ i ] ) ) ; } return bottom ; }
public double SumOutlinkAuthorityScore ( Page page ) { List < String > outLinks = page . getOutlinks ( ) ; double authScore = NUM_ ; for ( int i = NUM_ ; i < outLinks . size ( ) ; i ++ ) { Page outLink = pTable . get ( outLinks . get ( i ) ) ; if ( outLink != null ) { authScore += outLink . authority ; } } return authScore ; }
public synchronized void end ( ) { graphicsToBeDrawn . close ( ) ; if ( currentGraphics != null ) { graphicsDrawn . append ( currentGraphics ) ; } graphicsDrawn . closeWhenEmpty ( ) ; if ( printerJobThread != null && printerJobThread . isAlive ( ) ) { try { printerJobThread . join ( ) ; } catch ( InterruptedException e ) { } } }
public List < FileStatus > browse ( String filePath ) throws Exception { LOG . info ( STR_ + filePath + STR_ + hdfsEndPoint ) ; FileSystem hdfsFileSystem = null ; FileStatus [ ] listStatus ; try { Configuration config = createConfig ( ) ; hdfsFileSystem = getFileSystem ( config ) ; Path path = new Path ( filePath ) ; listStatus = hdfsFileSystem . listStatus ( path ) ; } catch ( Exception ex ) { LOG . error ( STR_ + filePath , ex . getMessage ( ) ) ; throw new Exception ( STR_ + ex . getMessage ( ) ) ; } finally { if ( hdfsFileSystem != null ) hdfsFileSystem . close ( ) ; } return Arrays . asList ( listStatus ) ; }
public void append ( CharSequence s ) { text . append ( s ) ; }
public EipModelWizardInitialObjectCreationPage ( String pageId ) { super ( pageId ) ; }
private void unwrapData ( ) throws IgniteCheckedException , SSLException { if ( log . isDebugEnabled ( ) ) log . debug ( STR_ ) ; inNetBuf . flip ( ) ; SSLEngineResult res = unwrap0 ( ) ; inNetBuf . compact ( ) ; checkStatus ( res ) ; renegotiateIfNeeded ( res ) ; }
public boolean isAttributeSpecified ( int attributeHandle ) { int type = getNodeType ( attributeHandle ) ; if ( DTM . ATTRIBUTE_NODE == type ) { Attr attr = ( Attr ) getNode ( attributeHandle ) ; return attr . getSpecified ( ) ; } return BOOL_ ; }
private static void checkPermission ( ) throws SecurityException { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) { sm . checkPermission ( new JodaTimePermission ( STR_ ) ) ; } }
private void storePassword ( String password ) { if ( isStore && sharedState != null ) { sharedState . put ( getPwdKey ( ) , password ) ; } }
public void or ( Criteria criteria ) { oredCriteria . add ( criteria ) ; }
void deleteChild ( PolicyNode childNode ) { if ( isImmutable ) { throw new IllegalStateException ( STR_ ) ; } mChildren . remove ( childNode ) ; }
void addFillComponents ( Container panel , int [ ] cols , int [ ] rows ) { Dimension filler = new Dimension ( NUM_ , NUM_ ) ; boolean filled_cell_11 = BOOL_ ; CellConstraints cc = new CellConstraints ( ) ; if ( cols . length > NUM_ && rows . length > NUM_ ) { if ( cols [ NUM_ ] == NUM_ && rows [ NUM_ ] == NUM_ ) { panel . add ( Box . createRigidArea ( filler ) , cc . xy ( NUM_ , NUM_ ) ) ; filled_cell_11 = BOOL_ ; } } for ( int index = NUM_ ; index < cols . length ; index ++ ) { if ( cols [ index ] == NUM_ && filled_cell_11 ) { continue ; } panel . add ( Box . createRigidArea ( filler ) , cc . xy ( cols [ index ] , NUM_ ) ) ; } for ( int index = NUM_ ; index < rows . length ; index ++ ) { if ( rows [ index ] == NUM_ && filled_cell_11 ) { continue ; } panel . add ( Box . createRigidArea ( filler ) , cc . xy ( NUM_ , rows [ index ] ) ) ; } }
public void testFloatValuePlusZero ( ) { String a = STR_ ; BigDecimal aNumber = new BigDecimal ( a ) ; int zero = NUM_ ; float result = aNumber . floatValue ( ) ; assertTrue ( STR_ , Float . floatToIntBits ( result ) == zero ) ; }
public ExternalProcessResult awaitTerminationAndResult ( int timeoutMs , boolean destroyOnError ) throws InterruptedException , TimeoutException , OperationCancellation , IOException { awaitTermination ( timeoutMs , destroyOnError ) ; return new ExternalProcessResult ( process . exitValue ( ) , getStdOutBytes ( ) , getStdErrBytes ( ) ) ; }
public void refreshInheritedMethods ( Set modifiedSuperExpandos ) { for ( Iterator i = modifiedSuperExpandos . iterator ( ) ; i . hasNext ( ) ; ) { ExpandoMetaClass superExpando = ( ExpandoMetaClass ) i . next ( ) ; if ( superExpando != this ) { refreshInheritedMethods ( superExpando ) ; } } }
public static List < Fragment > parsePlaceholder ( String parseString ) throws PlaceholderParseException { List < Fragment > result = new ArrayList < Fragment > ( ) ; int currOutputIndex = NUM_ ; int currSearchIndex = NUM_ ; while ( BOOL_ ) { if ( currSearchIndex == parseString . length ( ) ) { break ; } int startIndex = parseString . indexOf ( STR_ , currSearchIndex ) ; if ( startIndex == - NUM_ ) { if ( currOutputIndex < parseString . length ( ) ) { String endString = parseString . substring ( currOutputIndex , parseString . length ( ) ) ; TextFragment textFragment = new TextFragment ( endString ) ; result . add ( textFragment ) ; } break ; } if ( startIndex > NUM_ ) { String textSoFar = parseString . substring ( currOutputIndex , startIndex ) ; if ( textSoFar . length ( ) != NUM_ ) { result . add ( new TextFragment ( textSoFar ) ) ; } } if ( ( startIndex > NUM_ ) && ( parseString . charAt ( startIndex - NUM_ ) == STR_ ) ) { currOutputIndex = startIndex + NUM_ ; currSearchIndex = startIndex + NUM_ ; continue ; } int endIndex = parseString . indexOf ( STR_ , startIndex ) ; if ( endIndex == - NUM_ ) { throw new PlaceholderParseException ( STR_ + parseString . substring ( startIndex , parseString . length ( ) ) + STR_ ) ; } String between = parseString . substring ( startIndex + NUM_ , endIndex ) ; ParameterFragment parameterFragment = new ParameterFragment ( between ) ; result . add ( parameterFragment ) ; currOutputIndex = endIndex + NUM_ ; currSearchIndex = endIndex ; } LinkedList < Fragment > fragments = new LinkedList < Fragment > ( ) ; fragments . add ( result . get ( NUM_ ) ) ; for ( int i = NUM_ ; i < result . size ( ) ; i ++ ) { Fragment fragment = result . get ( i ) ; if ( ! ( result . get ( i ) instanceof TextFragment ) ) { fragments . add ( fragment ) ; continue ; } if ( ! ( fragments . getLast ( ) instanceof TextFragment ) ) { fragments . add ( fragment ) ; continue ; } TextFragment textFragment = ( TextFragment ) fragments . getLast ( ) ; fragments . removeLast ( ) ; fragments . add ( new TextFragment ( textFragment . getValue ( ) + fragment . getValue ( ) ) ) ; } return fragments ; }
@ Override protected void failed ( ) { relation . setCanceled ( BOOL_ ) ; super . failed ( ) ; }
private void routeSingleGetRequest ( RequestAndResponse requestAndResponse , String uri ) throws IOException , ServletException { if ( uri . startsWith ( STR_ ) ) { handleHtmlShowNotebooks ( requestAndResponse ) ; } else if ( uri . startsWith ( STR_ ) ) { handleHtmlShowQuotations ( requestAndResponse ) ; } else if ( uri . startsWith ( STR_ ) ) { handleHtmlShowSources ( requestAndResponse ) ; } else if ( uri . startsWith ( STR_ ) ) { handleHtmlShowSource ( requestAndResponse ) ; } else if ( uri . startsWith ( STR_ ) ) { handleHtmlShowNotebook ( requestAndResponse ) ; } else if ( uri . startsWith ( STR_ ) ) { handleHtmlSearch ( requestAndResponse ) ; } else if ( uri . equals ( STR_ ) ) { handleHtmlBasicHelp ( requestAndResponse ) ; } else if ( uri . equals ( STR_ ) ) { handleHtmlAdvancedHelp ( requestAndResponse ) ; } else if ( uri . startsWith ( STR_ ) ) { handleHtmlHelp ( requestAndResponse ) ; } else if ( uri . equals ( STR_ ) ) { handleHtmlUserBackupForm ( requestAndResponse ) ; } else if ( uri . equals ( STR_ ) ) { handleHtmlUserRestoreForm ( requestAndResponse ) ; } else if ( uri . startsWith ( STR_ ) ) { handleHtmlShowAccount ( requestAndResponse ) ; } else if ( uri . startsWith ( STR_ ) ) { handleHtmlShowAccounts ( requestAndResponse ) ; } else if ( uri . equals ( STR_ ) ) { handleHtmlShutdownForm ( requestAndResponse ) ; } else if ( uri . equals ( STR_ ) ) { handleHtmlClearForm ( requestAndResponse ) ; } else if ( uri . equals ( STR_ ) ) { handleHtmlOnlineBackupForm ( requestAndResponse ) ; } else if ( uri . equals ( STR_ ) ) { handleHtmlCheckForErrorsForm ( requestAndResponse ) ; } else if ( uri . equals ( STR_ ) ) { handleHtmlShowDBBackups ( requestAndResponse ) ; } else if ( uri . equals ( STR_ ) ) { handleHtmlOfflineDbBackupForm ( requestAndResponse ) ; } else if ( uri . equals ( STR_ ) ) { handleJsonShowEntry ( requestAndResponse ) ; } else if ( uri . equals ( STR_ ) ) { handleJsonShowEntryParent ( requestAndResponse ) ; } else if ( uri . equals ( STR_ ) ) { handleJsonShowEntryChildren ( requestAndResponse ) ; } else if ( uri . equals ( STR_ ) ) { handleJsonSearchNotes ( requestAndResponse ) ; } else if ( uri . equals ( STR_ ) ) { handleHtmlNewNotebookForm ( requestAndResponse ) ; } else if ( uri . equals ( STR_ ) ) { handleHtmlNothing ( requestAndResponse ) ; } else if ( uri . equals ( STR_ ) ) { handleHtmlCouldNotCreateNote ( requestAndResponse ) ; } else if ( uri . equals ( STR_ ) ) { handleHtmlShowRestoreDbBackupCommand ( requestAndResponse ) ; } else if ( uri . equals ( STR_ ) ) { handleHtmlShowSignedOut ( requestAndResponse ) ; } else if ( uri . startsWith ( STR_ ) ) { handleHtmlChangePassword ( requestAndResponse ) ; } else if ( uri . startsWith ( STR_ ) ) { handleHtmlChangeAccount ( requestAndResponse ) ; } else if ( uri . startsWith ( STR_ ) ) { handleHtmlCloseAccount ( requestAndResponse ) ; } else if ( uri . equals ( STR_ ) ) { handleJsonIsSignedIn ( requestAndResponse ) ; } else if ( uri . equals ( STR_ ) ) { handleHtmlUserRestoreFrame ( requestAndResponse ) ; } else { returnHtml404 ( requestAndResponse ) ; } }
private void changeAnnotationDocumentState ( SourceDocument aSourceDocument , User aUser , AnnotationDocumentStateTransition aAnnotationDocumentStateTransition ) { AnnotationDocument annotationDocument = repository . getAnnotationDocument ( aSourceDocument , aUser ) ; annotationDocument . setState ( AnnotationDocumentStateTransition . transition ( aAnnotationDocumentStateTransition ) ) ; try { repository . createAnnotationDocument ( annotationDocument ) ; } catch ( IOException e ) { LOG . info ( STR_ ) ; } }
boolean removeEdge ( SparseEdge e ) { boolean removedEdge = edges . remove ( e ) ; boolean removedNeighbour = neighbours . remove ( e . getOpposite ( this ) ) ; if ( removedEdge && removedNeighbour ) return BOOL_ ; else if ( ! removedEdge && ! removedNeighbour ) return BOOL_ ; else throw new RuntimeException ( STR_ ) ; }
protected void longKeyPress ( int keyCode ) { }
public boolean hasDescendant ( Pattern pattern ) { Queue < BNode > nodesToProcess = new LinkedList < BNode > ( ) ; nodesToProcess . add ( this ) ; while ( ! nodesToProcess . isEmpty ( ) ) { BNode currentNode = nodesToProcess . poll ( ) ; for ( BNode descendantNode : currentNode . getOutputNodes ( ) ) { Matcher matcher = pattern . matcher ( descendantNode . getId ( ) ) ; if ( matcher . matches ( ) ) { return BOOL_ ; } if ( ! nodesToProcess . contains ( descendantNode ) ) { nodesToProcess . add ( descendantNode ) ; } } } return BOOL_ ; }
public int fileWrite ( long handle , byte [ ] buffer , int offset , int count ) { if ( ( offset | count ) < NUM_ || offset > buffer . length || buffer . length - offset < count ) { throw new ArrayIndexOutOfBoundsException ( STR_ + buffer . length + STR_ + offset + STR_ + count ) ; } if ( count == NUM_ ) { return NUM_ ; } byte [ ] data = buffer ; if ( offset > NUM_ ) { data = new byte [ count ] ; System . arraycopy ( buffer , offset , data , NUM_ , count ) ; } IntOut bytesWrittenOut = new IntOut ( ) ; try { checkResult ( LibIMobileDevice . afc_file_write ( getRef ( ) , handle , data , count , bytesWrittenOut ) ) ; int bytesWritten = bytesWrittenOut . getValue ( ) ; return bytesWritten ; } finally { bytesWrittenOut . delete ( ) ; } }
private static void generateFiles ( ) { String [ ] classNames ; ResourceBundle rules , info ; info = ResourceBundle . getBundle ( STR_ , new Locale ( language , country , valiant ) , BreakIteratorRBControl . INSTANCE ) ; classNames = info . getStringArray ( STR_ ) ; rules = ResourceBundle . getBundle ( STR_ , new Locale ( language , country , valiant ) , BreakIteratorRBControl . INSTANCE ) ; if ( info . containsKey ( STR_ ) ) { generateDataFile ( info . getString ( STR_ ) , rules . getString ( STR_ ) , classNames [ NUM_ ] ) ; } if ( info . containsKey ( STR_ ) ) { generateDataFile ( info . getString ( STR_ ) , rules . getString ( STR_ ) , classNames [ NUM_ ] ) ; } if ( info . containsKey ( STR_ ) ) { generateDataFile ( info . getString ( STR_ ) , rules . getString ( STR_ ) , classNames [ NUM_ ] ) ; } if ( info . containsKey ( STR_ ) ) { generateDataFile ( info . getString ( STR_ ) , rules . getString ( STR_ ) , classNames [ NUM_ ] ) ; } }
public static boolean isCglibProxy ( Object object ) { return ClassUtils . isCglibProxyClass ( object . getClass ( ) ) ; }
private float [ ] calculateImageIndents ( ) { mTempMatrix . reset ( ) ; mTempMatrix . setRotate ( - getCurrentAngle ( ) ) ; float [ ] unrotatedImageCorners = Arrays . copyOf ( mCurrentImageCorners , mCurrentImageCorners . length ) ; float [ ] unrotatedCropBoundsCorners = RectUtils . getCornersFromRect ( mCropRect ) ; mTempMatrix . mapPoints ( unrotatedImageCorners ) ; mTempMatrix . mapPoints ( unrotatedCropBoundsCorners ) ; RectF unrotatedImageRect = RectUtils . trapToRect ( unrotatedImageCorners ) ; RectF unrotatedCropRect = RectUtils . trapToRect ( unrotatedCropBoundsCorners ) ; float deltaLeft = unrotatedImageRect . left - unrotatedCropRect . left ; float deltaTop = unrotatedImageRect . top - unrotatedCropRect . top ; float deltaRight = unrotatedImageRect . right - unrotatedCropRect . right ; float deltaBottom = unrotatedImageRect . bottom - unrotatedCropRect . bottom ; float indents [ ] = new float [ NUM_ ] ; indents [ NUM_ ] = ( deltaLeft > NUM_ ) ? deltaLeft : NUM_ ; indents [ NUM_ ] = ( deltaTop > NUM_ ) ? deltaTop : NUM_ ; indents [ NUM_ ] = ( deltaRight < NUM_ ) ? deltaRight : NUM_ ; indents [ NUM_ ] = ( deltaBottom < NUM_ ) ? deltaBottom : NUM_ ; mTempMatrix . reset ( ) ; mTempMatrix . setRotate ( getCurrentAngle ( ) ) ; mTempMatrix . mapPoints ( indents ) ; return indents ; }
public void testBug10630 ( ) throws Exception { Connection conn2 = null ; Statement stmt2 = null ; try { conn2 = getConnectionWithProps ( ( Properties ) null ) ; stmt2 = conn2 . createStatement ( ) ; conn2 . close ( ) ; stmt2 . getWarnings ( ) ; fail ( STR_ ) ; } catch ( SQLException sqlEx ) { assertEquals ( SQLError . SQL_STATE_ILLEGAL_ARGUMENT , sqlEx . getSQLState ( ) ) ; } finally { if ( stmt2 != null ) { stmt2 . close ( ) ; } if ( conn2 != null ) { conn2 . close ( ) ; } } }
public static boolean equals ( boolean [ ] field1 , boolean [ ] field2 ) { if ( field1 == null || field1 . length == NUM_ ) { return field2 == null || field2 . length == NUM_ ; } else { return Arrays . equals ( field1 , field2 ) ; } }
public void toFront ( final WorkflowAnnotation anno ) { if ( anno == null ) { throw new IllegalArgumentException ( STR_ ) ; } synchronized ( lock ) { if ( annotationsDrawOrder . remove ( anno ) ) { annotationsDrawOrder . add ( anno ) ; } if ( annotationsEventOrder . remove ( anno ) ) { annotationsEventOrder . add ( NUM_ , anno ) ; } } }
public synchronized void addFrame ( final Image image , final long frameDuration ) { totalDuration += frameDuration ; frames . add ( new AnimFrame ( image , totalDuration ) ) ; }
public static String printCodePointAsString ( int codePoint ) { StringBuilder builder = new StringBuilder ( NUM_ ) ; builder . append ( STR_ ) ; try { printStringCodePoint ( builder , codePoint ) ; } catch ( IOException e ) { throw new Error ( e ) ; } builder . append ( STR_ ) ; return builder . toString ( ) ; }
private void cleanupMinidumpFile ( ) { if ( ! CrashFileManager . tryMarkAsUploaded ( mFileToUpload ) ) { Log . w ( TAG , STR_ + mFileToUpload + STR_ ) ; if ( ! mFileToUpload . delete ( ) ) { Log . w ( TAG , STR_ + mFileToUpload ) ; } } }
boolean closeOutbound ( ) throws SSLException { if ( sslEngine == null || sslEngine . isOutboundDone ( ) ) { return BOOL_ ; } sslEngine . closeOutbound ( ) ; createOutNetBuffer ( NUM_ ) ; SSLEngineResult result ; for ( ; ; ) { result = sslEngine . wrap ( emptyBuffer . buf ( ) , outNetBuffer . buf ( ) ) ; if ( result . getStatus ( ) == SSLEngineResult . Status . BUFFER_OVERFLOW ) { outNetBuffer . capacity ( outNetBuffer . capacity ( ) << NUM_ ) ; outNetBuffer . limit ( outNetBuffer . capacity ( ) ) ; } else { break ; } } if ( result . getStatus ( ) != SSLEngineResult . Status . CLOSED ) { throw new SSLException ( STR_ + result ) ; } outNetBuffer . flip ( ) ; return BOOL_ ; }
@ Nullable private static Bitmap extractThumbnail ( Bitmap source , int width , int height ) { return extractThumbnail ( source , width , height , OPTIONS_NONE ) ; }
private void writePkgInfo ( ) throws BuildException { File pkgInfo = new File ( mContentsDir , STR_ ) ; PrintWriter writer = null ; try { writer = new PrintWriter ( new BufferedWriter ( new FileWriter ( pkgInfo ) ) ) ; writer . print ( bundleProperties . getCFBundlePackageType ( ) ) ; writer . println ( bundleProperties . getCFBundleSignature ( ) ) ; writer . flush ( ) ; } catch ( IOException ex ) { throw new BuildException ( STR_ + ex ) ; } finally { mFileUtils . close ( writer ) ; } }
public EventBean [ ] toArray ( ) { if ( firstEvent == null ) { return new EventBean [ NUM_ ] ; } if ( additionalEvents == null ) { return new EventBean [ ] { firstEvent } ; } EventBean [ ] events = new EventBean [ NUM_ + additionalEvents . size ( ) ] ; events [ NUM_ ] = firstEvent ; int count = NUM_ ; for ( EventBean theEvent : additionalEvents ) { events [ count ] = theEvent ; count ++ ; } return events ; }
private byte [ ] decode ( DerInputStream in ) throws IOException { DerValue val = in . getDerValue ( ) ; byte [ ] derEncoding = val . toByteArray ( ) ; derEncoding [ NUM_ ] = DerValue . tag_SetOf ; DerInputStream derIn = new DerInputStream ( derEncoding ) ; DerValue [ ] derVals = derIn . getSet ( NUM_ , BOOL_ ) ; PKCS9Attribute attrib ; ObjectIdentifier oid ; boolean reuseEncoding = BOOL_ ; for ( int i = NUM_ ; i < derVals . length ; i ++ ) { try { attrib = new PKCS9Attribute ( derVals [ i ] ) ; } catch ( ParsingException e ) { if ( ignoreUnsupportedAttributes ) { reuseEncoding = BOOL_ ; continue ; } else { throw e ; } } oid = attrib . getOID ( ) ; if ( attributes . get ( oid ) != null ) throw new IOException ( STR_ + oid ) ; if ( permittedAttributes != null && ! permittedAttributes . containsKey ( oid ) ) throw new IOException ( STR_ + oid + STR_ ) ; attributes . put ( oid , attrib ) ; } return reuseEncoding ? derEncoding : generateDerEncoding ( ) ; }
StringVector processPREFIX_LIST ( StylesheetHandler handler , String uri , String name , String rawName , String value ) throws org . xml . sax . SAXException { StringTokenizer tokenizer = new StringTokenizer ( value , STR_ ) ; int nStrings = tokenizer . countTokens ( ) ; StringVector strings = new StringVector ( nStrings ) ; for ( int i = NUM_ ; i < nStrings ; i ++ ) { String prefix = tokenizer . nextToken ( ) ; String url = handler . getNamespaceForPrefix ( prefix ) ; if ( prefix . equals ( Constants . ATTRVAL_DEFAULT_PREFIX ) || url != null ) strings . addElement ( prefix ) ; else throw new org . xml . sax . SAXException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CANT_RESOLVE_NSPREFIX , new Object [ ] { prefix } ) ) ; } return strings ; }
@ Override public CategoricalResults clone ( ) { CategoricalResults copy = new CategoricalResults ( n ) ; copy . probabilities = Arrays . copyOf ( probabilities , probabilities . length ) ; return copy ; }
private static StringBuilder dump ( StringBuilder _lbuffer , long value ) { for ( int j = NUM_ ; j < NUM_ ; j ++ ) { _lbuffer . append ( _hexcodes [ ( int ) ( value > > _shifts [ j ] ) & NUM_ ] ) ; } return _lbuffer ; }
private boolean typeSpecialChar ( char c ) { switch ( c ) { case STR_ : controller . keyPress ( KeyEvent . VK_TAB ) ; controller . keyRelease ( KeyEvent . VK_TAB ) ; return BOOL_ ; case STR_ : controller . keyPress ( KeyEvent . VK_ENTER ) ; controller . keyRelease ( KeyEvent . VK_ENTER ) ; return BOOL_ ; default : return BOOL_ ; } }
protected static boolean eq ( Object o1 , Object o2 ) { return o1 == null ? o2 == null : o1 . equals ( o2 ) ; }
public static boolean hasMimeType ( String mimeType ) { if ( mimeType == null || mimeType . isEmpty ( ) ) { return BOOL_ ; } return mimeTypeToExtensionMap . containsKey ( mimeType ) ; }
public Iterable < Notification > skip ( @ Nonnull final Iterable < Notification > notifications , final long startId , final boolean inclusive , final int limitSize ) { Objects . requireNonNull ( notifications ) ; final int position = indexOf ( notifications , startId ) ; if ( position == - NUM_ ) { return Iterables . limit ( notifications , limitSize ) ; } if ( inclusive ) { return Iterables . limit ( Iterables . skip ( notifications , position ) , limitSize ) ; } return Iterables . limit ( Iterables . skip ( notifications , position + NUM_ ) , limitSize ) ; }
public boolean writeData ( PdxWriter writer , Object obj ) { if ( isRelevant ( obj . getClass ( ) ) ) { writeData ( writer , obj , getClassInfo ( obj . getClass ( ) ) ) ; return BOOL_ ; } return BOOL_ ; }
protected final void writeC ( ByteBuffer buf , int value ) { buf . put ( ( byte ) value ) ; }
public boolean isEmpty ( ) { return priorityQueue . isEmpty ( ) ; }
public ViterbiPoint ( Item item ) { this . item = item ; }
protected void paintContentBorderBottomEdge ( Graphics g , int x , int y , int w , int h , boolean drawBroken , Rectangle selRect , boolean isContentBorderPainted ) { if ( isContentBorderPainted ) { g . setColor ( darkShadow ) ; g . fillRect ( x , y + h - NUM_ , w - NUM_ , NUM_ ) ; } }
private void emitListAdd ( Method method , String fieldName , StringBuilder builder ) { builder . append ( STR_ ) ; builder . append ( getListAdderName ( fieldName ) ) ; builder . append ( STR_ ) ; builder . append ( getTypeArgumentImplName ( ( ParameterizedType ) method . getGenericReturnType ( ) , NUM_ ) ) ; builder . append ( STR_ ) ; builder . append ( getEnsureName ( fieldName ) ) ; builder . append ( STR_ ) ; builder . append ( fieldName ) ; builder . append ( STR_ ) ; builder . append ( STR_ ) ; }
public RSAPublicKey parsePEMPublicKey ( String pem ) throws GeneralSecurityException { try { byte [ ] bs = decodeAsciiArmoredPEM ( pem ) ; ByteBuffer data = ByteBuffer . wrap ( bs ) ; final ASN1Object ob = asn1Parser . parseASN1 ( data ) ; final List < ASN1Object > seq = asn1ObjectToSequence ( ob , NUM_ ) ; final BigInteger modulus = asn1ObjectToBigInt ( seq . get ( NUM_ ) ) ; final BigInteger exponent = asn1ObjectToBigInt ( seq . get ( NUM_ ) ) ; return createKeyFromModulusAndExponent ( modulus , exponent ) ; } catch ( IllegalArgumentException e ) { throw new InvalidKeyException ( ) ; } }
public static < T > ParallelPublisher < T > from ( Publisher < ? extends T > source , boolean ordered , int parallelism ) { return from ( source , ordered , parallelism , Px . bufferSize ( ) , Px . defaultQueueSupplier ( Px . bufferSize ( ) ) ) ; }
public void addToQueue ( Var var ) { addToQueue ( Collections . singleton ( var ) ) ; }
public String canonicalize ( String simpleURL ) { String resultURL = simpleURL ; if ( simpleURL . startsWith ( STR_ ) ) { resultURL = STR_ + simpleURL ; } else if ( simpleURL . startsWith ( STR_ ) ) { resultURL = STR_ + simpleURL ; } else if ( simpleURL . startsWith ( STR_ ) ) { resultURL = STR_ + simpleURL ; } else if ( ! hasProtocolName ( simpleURL ) ) { if ( isSimpleHostName ( simpleURL ) ) { simpleURL = STR_ + simpleURL + STR_ ; } resultURL = STR_ + simpleURL ; } return resultURL ; }
public String read ( String filename ) throws IOException { return ProcFile . readFile ( String . format ( STR_ , pid , filename ) ) ; }
private long calculateAnimationDuration ( float initialVelocity , float displacement ) { return MathUtils . clamp ( Math . round ( Math . abs ( NUM_ . displacement / initialVelocity ) ) , MINIMUM_ANIMATION_DURATION_MS , MAXIMUM_ANIMATION_DURATION_MS ) ; }
@ RequestProcessing ( value = STR_ , method = HTTPRequestMethod . GET ) @ Before ( adviceClass = { StopwatchStartAdvice . class , AnonymousViewCheck . class , UserBlockCheck . class } ) @ After ( adviceClass = StopwatchEndAdvice . class ) public void showHomePoints ( final HTTPRequestContext context , final HttpServletRequest request , final HttpServletResponse response , final String userName ) throws Exception { final JSONObject user = ( JSONObject ) request . getAttribute ( User . USER ) ; request . setAttribute ( Keys . TEMAPLTE_DIR_NAME , Symphonys . get ( STR_ ) ) ; final AbstractFreeMarkerRenderer renderer = new SkinRenderer ( ) ; context . setRenderer ( renderer ) ; renderer . setTemplateName ( STR_ ) ; final Map < String , Object > dataModel = renderer . getDataModel ( ) ; filler . fillHeaderAndFooter ( request , response , dataModel ) ; String pageNumStr = request . getParameter ( STR_ ) ; if ( Strings . isEmptyOrNull ( pageNumStr ) || ! Strings . isNumeric ( pageNumStr ) ) { pageNumStr = STR_ ; } final int pageNum = Integer . valueOf ( pageNumStr ) ; final int pageSize = Symphonys . getInt ( STR_ ) ; final int windowSize = Symphonys . getInt ( STR_ ) ; fillHomeUser ( dataModel , user ) ; avatarQueryService . fillUserAvatarURL ( user ) ; final String followingId = user . optString ( Keys . OBJECT_ID ) ; dataModel . put ( Follow . FOLLOWING_ID , followingId ) ; final JSONObject userPointsResult = pointtransferQueryService . getUserPoints ( user . optString ( Keys . OBJECT_ID ) , pageNum , pageSize ) ; final List < JSONObject > userPoints = CollectionUtils . < JSONObject > jsonArrayToList ( userPointsResult . optJSONArray ( Keys . RESULTS ) ) ; dataModel . put ( Common . USER_HOME_POINTS , userPoints ) ; final boolean isLoggedIn = ( Boolean ) dataModel . get ( Common . IS_LOGGED_IN ) ; if ( isLoggedIn ) { final JSONObject currentUser = ( JSONObject ) dataModel . get ( Common . CURRENT_USER ) ; final String followerId = currentUser . optString ( Keys . OBJECT_ID ) ; final boolean isFollowing = followQueryService . isFollowing ( followerId , user . optString ( Keys . OBJECT_ID ) ) ; dataModel . put ( Common . IS_FOLLOWING , isFollowing ) ; } user . put ( UserExt . USER_T_CREATE_TIME , new Date ( user . getLong ( Keys . OBJECT_ID ) ) ) ; final int pointsCnt = userPointsResult . optInt ( Pagination . PAGINATION_RECORD_COUNT ) ; final int pageCount = ( int ) Math . ceil ( ( double ) pointsCnt / ( double ) pageSize ) ; final List < Integer > pageNums = Paginator . paginate ( pageNum , pageSize , pageCount , windowSize ) ; if ( ! pageNums . isEmpty ( ) ) { dataModel . put ( Pagination . PAGINATION_FIRST_PAGE_NUM , pageNums . get ( NUM_ ) ) ; dataModel . put ( Pagination . PAGINATION_LAST_PAGE_NUM , pageNums . get ( pageNums . size ( ) - NUM_ ) ) ; } dataModel . put ( Pagination . PAGINATION_CURRENT_PAGE_NUM , pageNum ) ; dataModel . put ( Pagination . PAGINATION_PAGE_COUNT , pageCount ) ; dataModel . put ( Pagination . PAGINATION_PAGE_NUMS , pageNums ) ; }
private static double norm ( final double [ ] v ) { double agg = NUM_ ; for ( int i = NUM_ ; i < v . length ; i ++ ) { agg += ( v [ i ] . v [ i ] ) ; } return Math . sqrt ( agg ) ; }
private int measureHeight ( int measureSpec ) { float result ; int specMode = MeasureSpec . getMode ( measureSpec ) ; int specSize = MeasureSpec . getSize ( measureSpec ) ; if ( specMode == MeasureSpec . EXACTLY ) { result = specSize ; } else { result = mPaintSelected . getStrokeWidth ( ) + getPaddingTop ( ) + getPaddingBottom ( ) ; if ( specMode == MeasureSpec . AT_MOST ) { result = Math . min ( result , specSize ) ; } } return ( int ) ( ( float ) Math . ceil ( result ) ) ; }
public void layout ( Container container ) { Map < Location , Drawable > comps = getComponentsByLocation ( container ) ; Drawable north = comps . get ( Location . NORTH ) ; Drawable northEast = comps . get ( Location . NORTH_EAST ) ; Drawable east = comps . get ( Location . EAST ) ; Drawable southEast = comps . get ( Location . SOUTH_EAST ) ; Drawable south = comps . get ( Location . SOUTH ) ; Drawable southWest = comps . get ( Location . SOUTH_WEST ) ; Drawable west = comps . get ( Location . WEST ) ; Drawable northWest = comps . get ( Location . NORTH_WEST ) ; Drawable center = comps . get ( Location . CENTER ) ; double widthWest = getMaxWidth ( northWest , west , southWest ) ; double widthEast = getMaxWidth ( northEast , east , southEast ) ; double heightNorth = getMaxHeight ( northWest , north , northEast ) ; double heightSouth = getMaxHeight ( southWest , south , southEast ) ; double gapEast = ( widthEast > NUM_ ) ? getGapX ( ) : NUM_ ; double gapWest = ( widthWest > NUM_ ) ? getGapX ( ) : NUM_ ; double gapNorth = ( heightNorth > NUM_ ) ? getGapY ( ) : NUM_ ; double gapSouth = ( heightSouth > NUM_ ) ? getGapY ( ) : NUM_ ; Rectangle2D bounds = container . getBounds ( ) ; Insets2D insets = container . getInsets ( ) ; if ( insets == null ) { insets = new Insets2D . Double ( ) ; } double xWest = bounds . getMinX ( ) + insets . getLeft ( ) - gapWest - widthWest ; double xCenter = bounds . getMinX ( ) + insets . getLeft ( ) ; double xEast = bounds . getMaxX ( ) - insets . getRight ( ) + gapEast ; double yNorth = bounds . getMinY ( ) + insets . getTop ( ) - gapNorth - heightNorth ; double yCenter = bounds . getMinY ( ) + insets . getTop ( ) ; double ySouth = bounds . getMaxY ( ) - insets . getBottom ( ) + gapSouth ; layoutComponent ( northWest , xWest , yNorth , widthWest , heightNorth ) ; layoutComponent ( north , xCenter , yNorth , bounds . getWidth ( ) - insets . getHorizontal ( ) , heightNorth ) ; layoutComponent ( northEast , xEast , yNorth , widthEast , heightNorth ) ; layoutComponent ( east , xEast , yCenter , widthEast , bounds . getHeight ( ) - insets . getVertical ( ) ) ; layoutComponent ( southEast , xEast , ySouth , widthEast , heightSouth ) ; layoutComponent ( south , xCenter , ySouth , bounds . getWidth ( ) - insets . getHorizontal ( ) , heightSouth ) ; layoutComponent ( southWest , xWest , ySouth , widthWest , heightSouth ) ; layoutComponent ( west , xWest , yCenter , widthWest , bounds . getHeight ( ) - insets . getVertical ( ) ) ; layoutComponent ( center , xCenter + getGapX ( ) , yCenter + getGapY ( ) , bounds . getWidth ( ) - insets . getHorizontal ( ) - NUM_ . getGapX ( ) , bounds . getHeight ( ) - insets . getVertical ( ) - NUM_ . getGapY ( ) ) ; }
void fullyUnlock ( ) { takeLock . unlock ( ) ; putLock . unlock ( ) ; }
public void add ( int i , int data ) { if ( _length + NUM_ > _capacity ) ensureCapacity ( _length + NUM_ ) ; System . arraycopy ( _buffer , i , _buffer , i + NUM_ , _length - i ) ; _buffer [ i ] = ( byte ) data ; _length += NUM_ ; }
private double mean ( double [ ] vec ) { double result = NUM_ ; for ( int i = NUM_ ; i < vec . length ; i ++ ) result += vec [ i ] ; return result / vec . length ; }
private Sprite ( float xPos , float yPos , float xVel , float yVel , Image ... sprites ) { if ( sprites != null ) spriteFrame = new ImageView ( sprites [ NUM_ ] ) ; playerStates . addAll ( Arrays . asList ( sprites ) ) ; spriteFrame . setTranslateX ( xPos ) ; spriteFrame . setTranslateY ( yPos ) ; this . xPos = xPos ; this . yPos = yPos ; this . xVel = xVel ; this . yVel = yVel ; }
public void close ( ) { out . close ( ) ; }
protected static SyncToken createSyncToken ( String dateString , @ Nullable String uuid ) { try { return new SyncToken ( DB_DATE_FORMAT . parse ( dateString ) , uuid ) ; } catch ( ParseException e ) { throw new RuntimeException ( e ) ; } }
private static boolean equalsHandlesNulls ( Object a , Object b ) { return a == b || ( a != null && a . equals ( b ) ) ; }
public void init ( String flagzDirectory ) throws FlagException , EtcdFlagFieldUpdaterException { this . directoryPrefix = MoreObjects . firstNonNull ( flagzDirectory , directoryFlag . get ( ) ) ; client = new EtcdClient ( uris . toArray ( new URI [ uris . size ( ) ] ) ) ; client . setRetryHandler ( retryPolicy ) ; initialSetAllFlagz ( ) ; }
public static void closeEL ( InputStream is ) { try { if ( is != null ) is . close ( ) ; } catch ( Throwable t ) { } }
public void testRandom ( ) { ExtremityMonitor monitor = new ExtremityMonitor ( ) ; Random random = new Random ( NUM_ ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { monitor . update ( random . nextDouble ( ) ) ; } assertTrue ( monitor . getMin ( ) < NUM_ ) ; assertTrue ( monitor . getMax ( ) < NUM_ ) ; assertTrue ( monitor . getMin ( ) >= NUM_ ) ; assertTrue ( monitor . getMax ( ) > NUM_ ) ; }
public static String replace ( String str , char oldChar , String newStr ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = NUM_ ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ch == oldChar ) { buf . append ( newStr ) ; } else { buf . append ( ch ) ; } } return buf . toString ( ) ; }
@ Action ( value = STR_ ) @ ValidationErrorPage ( value = ERROR ) @ SkipValidation public String newform ( ) { setLoginDept ( ) ; SimpleDateFormat sdf = new SimpleDateFormat ( STR_ ) ; try { cutOffDate = sdf . parse ( collectionsUtil . getAppConfigValue ( CollectionConstants . MODULE_NAME_COLLECTIONS_CONFIG , CollectionConstants . APPCONFIG_VALUE_COLLECTIONDATAENTRYCUTOFFDATE ) ) ; } catch ( ParseException e ) { LOGGER . error ( getText ( STR_ ) + e . getMessage ( ) ) ; } return NEW ; }
public TypeDeclaration canonicalize ( ) { List < Type > sts = getSatisfiedTypes ( ) ; if ( sts . isEmpty ( ) ) { return unit . getAnythingDeclaration ( ) ; } else if ( sts . size ( ) == NUM_ ) { Type st = sts . get ( NUM_ ) ; if ( st . isExactlyNothing ( ) ) { return unit . getNothingDeclaration ( ) ; } } for ( Type st : sts ) { if ( st . isUnion ( ) ) { List < Type > caseTypes = st . getCaseTypes ( ) ; List < Type > ulist = new ArrayList < Type > ( caseTypes . size ( ) ) ; for ( Type ct : caseTypes ) { List < Type > ilist = new ArrayList < Type > ( sts . size ( ) ) ; for ( Type pt : sts ) { if ( pt == st ) { addToIntersection ( ilist , ct , unit ) ; } else { addToIntersection ( ilist , pt , unit ) ; } } Type it = canonicalIntersection ( ilist , unit ) ; addToUnion ( ulist , it ) ; } TypeDeclaration result = new UnionType ( unit ) ; result . setCaseTypes ( ulist ) ; return result ; } } return this ; }
public static void openOtherUri ( final String url , final Activity activity ) { Intent intent = new Intent ( Intent . ACTION_VIEW , Uri . parse ( url ) ) ; activity . startActivity ( intent ) ; }
public static boolean waitForAllActiveAndLiveReplicas ( ZkStateReader zkStateReader , int timeoutInMs ) { return waitForAllActiveAndLiveReplicas ( zkStateReader , null , timeoutInMs ) ; }
public synchronized void addElement ( E object ) { if ( elementCount == elementData . length ) { growByOne ( ) ; } elementData [ elementCount ++ ] = object ; modCount ++ ; }
private void updateBaseMatrix ( Drawable d ) { ImageView imageView = getImageView ( ) ; if ( null == imageView || null == d ) { return ; } final float viewWidth = getImageViewWidth ( imageView ) ; final float viewHeight = getImageViewHeight ( imageView ) ; final int drawableWidth = d . getIntrinsicWidth ( ) ; final int drawableHeight = d . getIntrinsicHeight ( ) ; mBaseMatrix . reset ( ) ; final float widthScale = viewWidth / drawableWidth ; final float heightScale = viewHeight / drawableHeight ; if ( mScaleType == ScaleType . CENTER ) { mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth ) / NUM_ , ( viewHeight - drawableHeight ) / NUM_ ) ; } else if ( mScaleType == ScaleType . CENTER_CROP ) { float scale = Math . max ( widthScale , heightScale ) ; mBaseMatrix . postScale ( scale , scale ) ; mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth . scale ) / NUM_ , ( viewHeight - drawableHeight . scale ) / NUM_ ) ; } else if ( mScaleType == ScaleType . CENTER_INSIDE ) { float scale = Math . min ( NUM_ , Math . min ( widthScale , heightScale ) ) ; mBaseMatrix . postScale ( scale , scale ) ; mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth . scale ) / NUM_ , ( viewHeight - drawableHeight . scale ) / NUM_ ) ; } else { RectF mTempSrc = new RectF ( NUM_ , NUM_ , drawableWidth , drawableHeight ) ; RectF mTempDst = new RectF ( NUM_ , NUM_ , viewWidth , viewHeight ) ; if ( ( int ) mBaseRotation % NUM_ != NUM_ ) { mTempSrc = new RectF ( NUM_ , NUM_ , drawableHeight , drawableWidth ) ; } switch ( mScaleType ) { case FIT_CENTER : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . CENTER ) ; break ; case FIT_START : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . START ) ; break ; case FIT_END : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . END ) ; break ; case FIT_XY : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . FILL ) ; break ; default : break ; } } resetMatrix ( ) ; }
public boolean checkForRp ( ) { return NullColumnValueGetter . isNotNullValue ( getRpCopyName ( ) ) ; }
ExternalProblem ( Process process ) { this ( process . getInputStream ( ) , process . getOutputStream ( ) ) ; RedirectStream . redirect ( process . getErrorStream ( ) , System . err ) ; }
public static List < String > splitPath ( File file ) { List < String > output = new ArrayList < > ( ) ; File current = file ; while ( current != null ) { output . add ( current . getName ( ) ) ; current = current . getParentFile ( ) ; } Collections . reverse ( output ) ; return output ; }
private static StsdData parseStsd ( ParsableByteArray stsd , int trackId , long durationUs , int rotationDegrees , String language , boolean isQuickTime ) { stsd . setPosition ( Atom . FULL_HEADER_SIZE ) ; int numberOfEntries = stsd . readInt ( ) ; StsdData out = new StsdData ( numberOfEntries ) ; for ( int i = NUM_ ; i < numberOfEntries ; i ++ ) { int childStartPosition = stsd . getPosition ( ) ; int childAtomSize = stsd . readInt ( ) ; Assertions . checkArgument ( childAtomSize > NUM_ , STR_ ) ; int childAtomType = stsd . readInt ( ) ; if ( childAtomType == Atom . TYPE_avc1 || childAtomType == Atom . TYPE_avc3 || childAtomType == Atom . TYPE_encv || childAtomType == Atom . TYPE_mp4v || childAtomType == Atom . TYPE_hvc1 || childAtomType == Atom . TYPE_hev1 || childAtomType == Atom . TYPE_s263 || childAtomType == Atom . TYPE_vp08 || childAtomType == Atom . TYPE_vp09 ) { parseVideoSampleEntry ( stsd , childAtomType , childStartPosition , childAtomSize , trackId , durationUs , rotationDegrees , out , i ) ; } else if ( childAtomType == Atom . TYPE_mp4a || childAtomType == Atom . TYPE_enca || childAtomType == Atom . TYPE_ac_3 || childAtomType == Atom . TYPE_ec_3 || childAtomType == Atom . TYPE_dtsc || childAtomType == Atom . TYPE_dtse || childAtomType == Atom . TYPE_dtsh || childAtomType == Atom . TYPE_dtsl || childAtomType == Atom . TYPE_samr || childAtomType == Atom . TYPE_sawb || childAtomType == Atom . TYPE_lpcm || childAtomType == Atom . TYPE_sowt ) { parseAudioSampleEntry ( stsd , childAtomType , childStartPosition , childAtomSize , trackId , durationUs , language , isQuickTime , out , i ) ; } else if ( childAtomType == Atom . TYPE_TTML ) { out . mediaFormat = MediaFormat . createTextFormat ( Integer . toString ( trackId ) , MimeTypes . APPLICATION_TTML , MediaFormat . NO_VALUE , durationUs , language ) ; } else if ( childAtomType == Atom . TYPE_tx3g ) { out . mediaFormat = MediaFormat . createTextFormat ( Integer . toString ( trackId ) , MimeTypes . APPLICATION_TX3G , MediaFormat . NO_VALUE , durationUs , language ) ; } else if ( childAtomType == Atom . TYPE_wvtt ) { out . mediaFormat = MediaFormat . createTextFormat ( Integer . toString ( trackId ) , MimeTypes . APPLICATION_MP4VTT , MediaFormat . NO_VALUE , durationUs , language ) ; } else if ( childAtomType == Atom . TYPE_stpp ) { out . mediaFormat = MediaFormat . createTextFormat ( Integer . toString ( trackId ) , MimeTypes . APPLICATION_TTML , MediaFormat . NO_VALUE , durationUs , language , NUM_ ) ; } stsd . setPosition ( childStartPosition + childAtomSize ) ; } return out ; }
protected boolean isCompatible ( Taxa taxa , List < Taxon > availableTaxa ) { for ( int i = NUM_ ; i < taxa . getTaxonCount ( ) ; i ++ ) { Taxon taxon = taxa . getTaxon ( i ) ; if ( ! availableTaxa . contains ( taxon ) ) { return BOOL_ ; } } return BOOL_ ; }
protected int drawLabelText ( Object nativeGraphics , int textDecoration , boolean rtl , boolean isTickerRunning , boolean endsWith3Points , Object nativeFont , int txtW , int textSpaceW , int shiftText , String text , int x , int y , int fontHeight ) { if ( ( ! isTickerRunning ) || rtl ) { if ( txtW > textSpaceW && textSpaceW > NUM_ ) { if ( rtl ) { if ( ( ! isTickerRunning ) && endsWith3Points ) { String points = STR_ ; int pointsW = stringWidth ( nativeFont , points ) ; drawString ( nativeGraphics , nativeFont , points , shiftText + x , y , textDecoration , fontHeight ) ; clipRect ( nativeGraphics , pointsW + shiftText + x , y , textSpaceW - pointsW , fontHeight ) ; } x = x - txtW + textSpaceW ; } else if ( endsWith3Points ) { String points = STR_ ; int index = NUM_ ; int widest = charWidth ( nativeFont , STR_ ) ; int pointsW = stringWidth ( nativeFont , points ) ; int textLen = text . length ( ) ; while ( fastCharWidthCheck ( text , index , textSpaceW - pointsW , widest , nativeFont ) && index < textLen ) { index ++ ; } text = text . substring ( NUM_ , Math . min ( textLen , Math . max ( NUM_ , index - NUM_ ) ) ) + points ; txtW = stringWidth ( nativeFont , text ) ; } } } drawString ( nativeGraphics , nativeFont , text , shiftText + x , y , textDecoration , fontHeight ) ; return Math . min ( txtW , textSpaceW ) ; }
public boolean hasMapObjects ( ) { return mapObjects != null && ! mapObjects . isEmpty ( ) ; }
public void performActions ( ) throws Throwable { for ( Throwing . Runnable action : actions ) { action . run ( ) ; } }
public java . util . Collection < ObjectReference > dumpThreadRoots ( int width ) { return Collections . emptyList ( ) ; }
protected void addFieldNameTranslation ( EmbeddableMapping embeddableMapping , String overrideName , DatabaseField overrideField , MappingAccessor aggregatesAccessor ) { DatabaseMapping aggregatesMapping = aggregatesAccessor . getMapping ( ) ; DatabaseField aggregatesMappingField = aggregatesMapping . getField ( ) ; if ( aggregatesAccessor . isId ( ) ) { updatePrimaryKeyField ( aggregatesAccessor , overrideField ) ; } if ( overrideName . contains ( STR_ ) ) { embeddableMapping . addNestedFieldTranslation ( overrideName , overrideField , aggregatesMappingField . getName ( ) ) ; } else { embeddableMapping . addFieldTranslation ( overrideField , aggregatesMappingField . getName ( ) ) ; } }
public Dimension minimumLayoutSize ( Container target ) { synchronized ( target . getTreeLock ( ) ) { Dimension dim = new Dimension ( NUM_ , NUM_ ) ; if ( ( chart != null ) && chart . isVisible ( ) ) { Dimension d = chart . getMinimumSize ( ) ; dim . width = d . width ; dim . height = d . height ; } if ( ( xLabel != null ) && xLabel . isVisible ( ) ) { Dimension d = xLabel . getMinimumSize ( ) ; dim . width = Math . max ( d . width , dim . width ) ; dim . height += d . height + vgap ; } if ( ( yLabel != null ) && yLabel . isVisible ( ) ) { Dimension d = yLabel . getMinimumSize ( ) ; dim . width += d . width + hgap ; dim . height = Math . max ( d . height , dim . height ) ; } if ( ( title != null ) && title . isVisible ( ) ) { Dimension d = title . getMinimumSize ( ) ; dim . width = Math . max ( d . width , dim . width ) ; dim . height += d . height + vgap ; } Insets insets = target . getInsets ( ) ; dim . width += insets . left + insets . right ; dim . height += insets . top + insets . bottom ; return dim ; } }
private void checkResourceChange ( final Resource resource , final Group group , final Callback callback , final AtomicBoolean isChanged ) throws Exception { if ( isChanged ( resource , group . getName ( ) ) ) { isChanged . compareAndSet ( BOOL_ , BOOL_ ) ; callback . onResourceChanged ( resource ) ; lifecycleCallback . onResourceChanged ( resource ) ; } }
public javax2 . sip . address . TelURL createTelURL ( String uri ) throws ParseException { if ( uri == null ) throw new NullPointerException ( STR_ ) ; String telUrl = STR_ + uri ; try { StringMsgParser smp = new StringMsgParser ( ) ; TelURLImpl timp = ( TelURLImpl ) smp . parseUrl ( telUrl ) ; return ( TelURL ) timp ; } catch ( ParseException ex ) { throw new ParseException ( ex . getMessage ( ) , NUM_ ) ; } }
public EvoSVMModel ( ExampleSet exampleSet , List < SupportVector > supportVectors , Kernel kernel , double bias ) { super ( exampleSet , ExampleSetUtilities . SetsCompareOption . ALLOW_SUPERSET , ExampleSetUtilities . TypesCompareOption . ALLOW_SAME_PARENTS ) ; this . supportVectors = supportVectors ; if ( supportVectors == null || supportVectors . size ( ) == NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } this . kernel = kernel ; this . bias = bias ; if ( this . kernel instanceof DotKernel ) { this . weights = new double [ getNumberOfAttributes ( ) ] ; for ( int i = NUM_ ; i < getNumberOfSupportVectors ( ) ; i ++ ) { SupportVector sv = getSupportVector ( i ) ; if ( sv != null ) { double [ ] x = sv . getX ( ) ; double alpha = sv . getAlpha ( ) ; double y = sv . getY ( ) ; for ( int j = NUM_ ; j < weights . length ; j ++ ) { weights [ j ] += y . alpha . x [ j ] ; } } else { this . weights = null ; break ; } } } }
private synchronized boolean _restart ( ) throws ServletException { if ( singelton != null ) singelton . reset ( ) ; initEngine ( ) ; System . gc ( ) ; return BOOL_ ; }
public Sorter ( ) { useDefaultVisual ( ) ; setLayout ( new BorderLayout ( ) ) ; add ( m_visual , BorderLayout . CENTER ) ; m_env = Environment . getSystemWide ( ) ; m_stopRequested = new AtomicBoolean ( BOOL_ ) ; }
public String toString ( ) { return Character . toString ( getValue ( ) ) ; }
public static double logpdf ( double x , double mu , double shape ) { if ( ! ( x > NUM_ ) || x == Double . POSITIVE_INFINITY ) { return Double . NEGATIVE_INFINITY ; } final double v = ( x - mu ) / mu ; return v < Double . MAX_VALUE ? NUM_ . Math . log ( shape / ( MathUtil . TWOPI . x . x . x ) ) - shape . v . v / ( NUM_ . x ) : Double . NEGATIVE_INFINITY ; }
@ Override public final short readShort ( ) throws IOException { dis . readFully ( work , NUM_ , NUM_ ) ; return ( short ) ( ( work [ NUM_ ] & xff ) << NUM_ | ( work [ NUM_ ] & xff ) ) ; }
public static Format generateFormat ( String codec ) { return ( Format ) SUPPORTED_CODECS . get ( codec . toLowerCase ( ) ) ; }
public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { int start_old = start ; if ( m_inEntityRef ) return ; if ( m_elemContext . m_startTagOpen ) { closeStartTag ( ) ; m_elemContext . m_startTagOpen = BOOL_ ; } else if ( m_needToCallStartDocument ) { startDocumentInternal ( ) ; m_needToCallStartDocument = BOOL_ ; } try { final int limit = start + length ; boolean wasDash = BOOL_ ; if ( m_cdataTagOpen ) closeCDATA ( ) ; if ( shouldIndent ( ) ) indent ( ) ; final java . io . Writer writer = m_writer ; writer . write ( COMMENT_BEGIN ) ; for ( int i = start ; i < limit ; i ++ ) { if ( wasDash && ch [ i ] == STR_ ) { writer . write ( ch , start , i - start ) ; writer . write ( STR_ ) ; start = i + NUM_ ; } wasDash = ( ch [ i ] == STR_ ) ; } if ( length > NUM_ ) { final int remainingChars = ( limit - start ) ; if ( remainingChars > NUM_ ) writer . write ( ch , start , remainingChars ) ; if ( ch [ limit - NUM_ ] == STR_ ) writer . write ( STR_ ) ; } writer . write ( COMMENT_END ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } m_startNewLine = BOOL_ ; if ( m_tracer != null ) super . fireCommentEvent ( ch , start_old , length ) ; }
public OptionalInt maxByInt ( IntUnaryOperator keyExtractor ) { int [ ] result = collect ( null , null , null ) ; return result [ NUM_ ] == NUM_ ? OptionalInt . of ( result [ NUM_ ] ) : OptionalInt . empty ( ) ; }
public T findByCommitCounter ( final long commitCounter ) { if ( commitCounter < NUM_ ) throw new IllegalArgumentException ( ) ; final Lock lock = readLock ( ) ; lock . lock ( ) ; try { @ SuppressWarnings ( STR_ ) final ITupleIterator < T > itr = rangeIterator ( null , null , NUM_ , IRangeQuery . DEFAULT | IRangeQuery . REVERSE , null ) ; while ( itr . hasNext ( ) ) { final ITuple < T > t = itr . next ( ) ; final T r = t . getObject ( ) ; final IRootBlockView rb = r . getRootBlock ( ) ; if ( rb . getCommitCounter ( ) <= commitCounter ) { return r ; } } return null ; } finally { lock . unlock ( ) ; } }
private void startAnimation ( ) { ValueAnimator animator = ValueAnimator . ofFloat ( NUM_ ) ; ArrayList < NameValuesHolder > nameValueList = ( ArrayList < NameValuesHolder > ) mPendingAnimations . clone ( ) ; mPendingAnimations . clear ( ) ; int propertyMask = NUM_ ; int propertyCount = nameValueList . size ( ) ; for ( int i = NUM_ ; i < propertyCount ; ++ i ) { NameValuesHolder nameValuesHolder = nameValueList . get ( i ) ; propertyMask |= nameValuesHolder . mNameConstant ; } mAnimatorMap . put ( animator , new PropertyBundle ( propertyMask , nameValueList ) ) ; animator . addUpdateListener ( mAnimatorEventListener ) ; animator . addListener ( mAnimatorEventListener ) ; if ( mStartDelaySet ) { animator . setStartDelay ( mStartDelay ) ; } if ( mDurationSet ) { animator . setDuration ( mDuration ) ; } if ( mInterpolatorSet ) { animator . setInterpolator ( mInterpolator ) ; } animator . start ( ) ; }
public static String traceExcetion ( Throwable ex ) { final Writer result = new StringWriter ( ) ; final PrintWriter printWriter = new PrintWriter ( result ) ; ex . printStackTrace ( printWriter ) ; String stacktrace = result . toString ( ) ; Log . e ( TAG , STR_ + stacktrace ) ; return stacktrace ; }
public static Pair < String , String > split ( String varName ) { int splitIndex = varName . indexOf ( STR_ ) ; if ( splitIndex < NUM_ ) { return null ; } String left = varName . substring ( NUM_ , splitIndex ) ; String right = varName . substring ( splitIndex + NUM_ ) ; if ( left == null || left . length ( ) == NUM_ || right == null || right . length ( ) == NUM_ ) { return null ; } return Pair . of ( left , right ) ; }
public void onChildThreadResumeEnd ( ) { _threadCount . getAndDecrement ( ) ; wake ( ) ; }
public static void registerTransportMBean ( String containerName ) { MBeanServer mBeanServer = getMBeanServer ( containerName ) ; if ( mBeanServer == null ) return ; TransportProtocolMonitorMBean transportConnectionsInfoMBean = new TransportProtocolMonitor ( ) ; ObjectName objName = TransportConstants . createTransportMBeanObjectName ( containerName ) ; if ( ! mBeanServer . isRegistered ( objName ) ) { try { mBeanServer . registerMBean ( transportConnectionsInfoMBean , objName ) ; } catch ( InstanceAlreadyExistsException e ) { if ( _logger . isLoggable ( Level . CONFIG ) ) { _logger . config ( alreadyRegistredTransportMBeanMessage + containerName + STR_ ) ; } } catch ( NotCompliantMBeanException e ) { if ( _logger . isLoggable ( Level . WARNING ) ) { _logger . log ( Level . SEVERE , failedTransportMBeanRegistrationMessagePrefix + containerName + STR_ , e ) ; } } catch ( MBeanRegistrationException e ) { if ( _logger . isLoggable ( Level . SEVERE ) ) { _logger . log ( Level . SEVERE , failedTransportMBeanRegistrationMessagePrefix + containerName + STR_ , e ) ; } } if ( _logger . isLoggable ( Level . CONFIG ) ) { _logger . config ( successfulTransportMBeanRegistrationMessage + containerName + STR_ ) ; } } else { if ( _logger . isLoggable ( Level . CONFIG ) ) { _logger . config ( alreadyRegistredTransportMBeanMessage ) ; } } }
public static int update ( String where , Object [ ] args , V sets , Class < ? extends Bean > t ) { Table mapping = ( Table ) t . getAnnotation ( Table . class ) ; if ( mapping == null ) { if ( log . isErrorEnabled ( ) ) log . error ( STR_ + t + STR_ ) ; return - NUM_ ; } if ( ! X . isEmpty ( mapping . name ( ) ) ) { return updateTable ( mapping . name ( ) , where , args , sets ) ; } return - NUM_ ; }
private void stopVideoFadingEdgesScreenTimer ( ) { if ( null != mVideoFadingEdgesTimer ) { mVideoFadingEdgesTimer . cancel ( ) ; mVideoFadingEdgesTimer = null ; mVideoFadingEdgesTimerTask = null ; } }
public void removeListener ( final TimeoutEventListener listener ) { listeners . remove ( listener ) ; }
protected static void processGenericPropertiesCreatorProps ( File propsFile ) { try { Properties expProps = new Properties ( ) ; BufferedInputStream bi = new BufferedInputStream ( new FileInputStream ( propsFile ) ) ; expProps . load ( bi ) ; bi . close ( ) ; bi = null ; Properties GPCInputProps = GenericPropertiesCreator . getGlobalInputProperties ( ) ; Set < Object > keys = expProps . keySet ( ) ; Iterator < Object > keysI = keys . iterator ( ) ; while ( keysI . hasNext ( ) ) { String key = ( String ) keysI . next ( ) ; String existingVal = GPCInputProps . getProperty ( key , STR_ ) ; if ( existingVal . length ( ) > NUM_ ) { String newVal = expProps . getProperty ( key ) ; if ( existingVal . indexOf ( newVal ) < NUM_ ) { newVal = existingVal + STR_ + newVal ; GPCInputProps . put ( key , newVal ) ; } } else { String newVal = expProps . getProperty ( key ) ; GPCInputProps . put ( key , newVal ) ; } } } catch ( Exception ex ) { } }
private synchronized void addTableLockObject ( AbsoluteTableIdentifier absoluteTableIdentifier ) { if ( null == tableLockMap . get ( absoluteTableIdentifier ) ) { tableLockMap . put ( absoluteTableIdentifier , new Object ( ) ) ; } }
private static String randomElement ( ArrayList < String > list ) { int index = random . nextInt ( list . size ( ) ) ; return list . get ( index ) ; }
public static < T > void updateMappingToImmutableSet ( Map < T , Set < AnnotationMirror > > map , T key , Set < AnnotationMirror > newQual ) { Set < AnnotationMirror > result = AnnotationUtils . createAnnotationSet ( ) ; if ( ! map . containsKey ( key ) ) { result . addAll ( newQual ) ; } else { result . addAll ( map . get ( key ) ) ; result . addAll ( newQual ) ; } map . put ( key , Collections . unmodifiableSet ( result ) ) ; }
public static void join ( final AsyncInvocation < ? > async , final long timeoutMilliseconds ) { join ( async . getThread ( ) , timeoutMilliseconds ) ; }
void define ( MemberDefinition field , int slot , int from , int to ) { if ( from >= to ) { return ; } for ( int i = NUM_ ; i < len ; i ++ ) { if ( ( locals [ i ] . field == field ) && ( locals [ i ] . slot == slot ) && ( from <= locals [ i ] . to ) && ( to >= locals [ i ] . from ) ) { locals [ i ] . from = Math . min ( locals [ i ] . from , from ) ; locals [ i ] . to = Math . max ( locals [ i ] . to , to ) ; return ; } } if ( len == locals . length ) { LocalVariable newlocals [ ] = new LocalVariable [ len . NUM_ ] ; System . arraycopy ( locals , NUM_ , newlocals , NUM_ , len ) ; locals = newlocals ; } locals [ len ++ ] = new LocalVariable ( field , slot , from , to ) ; }
protected Connection openConnection ( boolean autocommit ) throws SQLException { Connection conn = dataSrc . getConnection ( ) ; conn . setAutoCommit ( autocommit ) ; return conn ; }
public void error ( XPathContext xctxt , String msg , Object [ ] args ) throws javax . xml . transform . TransformerException { java . lang . String fmsg = XSLMessages . createXPATHMessage ( msg , args ) ; if ( null != xctxt ) { ErrorListener eh = xctxt . getErrorListener ( ) ; TransformerException te = new TransformerException ( fmsg , this ) ; eh . fatalError ( te ) ; } }
public void mousePressed ( MouseEvent e ) { int nclicks = SwingUtilities2 . getAdjustedClickCount ( getComponent ( ) , e ) ; if ( SwingUtilities . isLeftMouseButton ( e ) ) { if ( e . isConsumed ( ) ) { shouldHandleRelease = BOOL_ ; } else { shouldHandleRelease = BOOL_ ; adjustCaretAndFocus ( e ) ; if ( nclicks == NUM_ && SwingUtilities2 . canEventAccessSystemClipboard ( e ) ) { selectWord ( e ) ; } } } }
public static byte [ ] decode ( String str , int flags ) { return decode ( str . getBytes ( ) , flags ) ; }
public Object apply ( String source , int lineNo , int columnNo , Object funcBody , Vector paramNames , Vector arguments ) throws BSFException { Object object = eval ( source , lineNo , columnNo , funcBody ) ; if ( object instanceof Closure ) { Closure closure = ( Closure ) object ; return closure . call ( arguments . toArray ( ) ) ; } return object ; }
public Set keySet ( ) { return totalKeySet ( ) ; }
public void output ( List list , Writer out ) throws IOException { printContentRange ( out , list , NUM_ , list . size ( ) , NUM_ , createNamespaceStack ( ) ) ; out . flush ( ) ; }
public boolean consumeEncumbranceBudget ( final Map < String , Object > detailsMap ) { if ( detailsMap == null ) throw new ValidationException ( Arrays . asList ( new ValidationError ( STR_ , STR_ ) ) ) ; detailsMap . put ( Constants . CONSUMEORRELEASE , BOOL_ ) ; final BigDecimal bd = getDetails ( detailsMap ) ; return bd . intValue ( ) == NUM_ ; }
private int [ ] mod ( int [ ] a , int [ ] f ) { int df = computeDegree ( f ) ; if ( df == - NUM_ ) { throw new ArithmeticException ( STR_ ) ; } int [ ] result = new int [ a . length ] ; int hc = headCoefficient ( f ) ; hc = field . inverse ( hc ) ; System . arraycopy ( a , NUM_ , result , NUM_ , result . length ) ; while ( df <= computeDegree ( result ) ) { int [ ] q ; int coeff = field . mult ( headCoefficient ( result ) , hc ) ; q = multWithMonomial ( f , computeDegree ( result ) - df ) ; q = multWithElement ( q , coeff ) ; result = add ( q , result ) ; } return result ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = enumToVector ( super . listOptions ( ) ) ; result . addElement ( new Option ( STR_ + defaultNumClusters ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ + defaultMinInstNum ( ) + STR_ + defaultMaxInstNum ( ) + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ + defaultMinRadius ( ) + STR_ + defaultMaxRadius ( ) + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ + defaultDistMult ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ + defaultNumCycles ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ + defaultNoiseRate ( ) + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
public static void appendHexJavaScriptRepresentation ( StringBuilder sb , char c ) { sb . append ( STR_ ) ; String val = Integer . toHexString ( c ) ; for ( int j = val . length ( ) ; j < NUM_ ; j ++ ) { sb . append ( STR_ ) ; } sb . append ( val ) ; }
private void printBootstrapMap ( ) { LOG . info ( STR_ ) ; for ( Integer i : chainMap . keySet ( ) ) { LOG . info ( String . format ( STR_ , i , chainMap . get ( i ) ) ) ; } }
public Vector < Option > enumToVector ( Enumeration < Option > enu ) { Vector < Option > options = new Vector < Option > ( ) ; options . addAll ( Collections . list ( enu ) ) ; return options ; }
private void addToken ( int token ) { try { fTokens [ fTokenCount ] = token ; } catch ( ArrayIndexOutOfBoundsException ex ) { int [ ] oldList = fTokens ; fTokens = new int [ fTokenCount << NUM_ ] ; System . arraycopy ( oldList , NUM_ , fTokens , NUM_ , fTokenCount ) ; fTokens [ fTokenCount ] = token ; } fTokenCount ++ ; }
private P filterLargeValueSets ( FilterSpec fs , MetaDataObject rootMeta , F root , boolean forceEntityBased , JoinType defaultPredicateJoinType ) { ArrayList < FilterSpec > specs = new ArrayList < > ( ) ; List < ? > list = new ArrayList < > ( ( Collection < ? > ) fs . getValue ( ) ) ; for ( int i = NUM_ ; i < list . size ( ) ; i += ORACLE_PARAM_LIMIT ) { int nextOffset = i + Math . min ( list . size ( ) - i , ORACLE_PARAM_LIMIT ) ; List < ? > batchList = list . subList ( i , nextOffset ) ; specs . add ( new FilterSpec ( fs . getAttributePath ( ) , fs . getOperator ( ) , batchList ) ) ; } FilterSpec orSpec = FilterSpec . or ( specs ) ; return filterSpecListToPredicate ( rootMeta , root , orSpec , forceEntityBased , defaultPredicateJoinType ) ; }
protected void addTags ( E data , Builder builder ) { PlatformIdent platformIdent = cachedDataService . getPlatformIdentForId ( data . getPlatformIdent ( ) ) ; builder . tag ( Series . TAG_AGENT_ID , String . valueOf ( data . getPlatformIdent ( ) ) ) ; if ( null != platformIdent ) { builder . tag ( Series . TAG_AGENT_NAME , platformIdent . getAgentName ( ) ) ; } }
public int compare ( String s1 , String s2 ) { final Matcher match1 = MATCH_ID_PATTERN . matcher ( s1 ) ; final Matcher match2 = MATCH_ID_PATTERN . matcher ( s2 ) ; final boolean match1matches = match1 . matches ( ) ; final boolean match2matches = match2 . matches ( ) ; if ( match1matches ^ match2matches ) { return ( match1matches ) ? NUM_ : - NUM_ ; } else if ( match1matches && match2matches ) { int signature1 = Integer . parseInt ( match1 . group ( NUM_ ) ) ; int signature2 = Integer . parseInt ( match2 . group ( NUM_ ) ) ; int comparison = ( signature1 < signature2 ) ? - NUM_ : ( signature1 > signature2 ) ? NUM_ : NUM_ ; if ( comparison == NUM_ ) { int start1 = Integer . parseInt ( match1 . group ( NUM_ ) ) ; int start2 = Integer . parseInt ( match2 . group ( NUM_ ) ) ; comparison = ( start1 < start2 ) ? - NUM_ : ( start1 > start2 ) ? NUM_ : NUM_ ; } if ( comparison == NUM_ ) { int end1 = Integer . parseInt ( match1 . group ( NUM_ ) ) ; int end2 = Integer . parseInt ( match2 . group ( NUM_ ) ) ; comparison = ( end1 < end2 ) ? - NUM_ : ( end1 > end2 ) ? NUM_ : NUM_ ; } return comparison ; } else { int seqLength1 = s1 . length ( ) , n2 = s2 . length ( ) ; for ( int i1 = NUM_ , i2 = NUM_ ; i1 < seqLength1 && i2 < n2 ; i1 ++ , i2 ++ ) { char c1 = s1 . charAt ( i1 ) ; char c2 = s2 . charAt ( i2 ) ; if ( c1 != c2 ) { c1 = Character . toUpperCase ( c1 ) ; c2 = Character . toUpperCase ( c2 ) ; if ( c1 != c2 ) { c1 = Character . toLowerCase ( c1 ) ; c2 = Character . toLowerCase ( c2 ) ; if ( c1 != c2 ) { return c1 - c2 ; } } } } return seqLength1 - n2 ; } }
private static int loadBuildNumber ( Context context , PackageManager packageManager ) { try { ApplicationInfo appInfo = packageManager . getApplicationInfo ( context . getPackageName ( ) , PackageManager . GET_META_DATA ) ; Bundle metaData = appInfo . metaData ; if ( metaData != null ) { return metaData . getInt ( BUNDLE_BUILD_NUMBER , NUM_ ) ; } } catch ( PackageManager . NameNotFoundException e ) { L . e ( STR_ ) ; e . printStackTrace ( ) ; } return NUM_ ; }
public static LeftRegularBipartiteGraphSegment buildRandomLeftRegularBipartiteGraph ( int leftSize , int rightSize , int leftDegree , Random random ) { LeftRegularBipartiteGraphSegment leftRegularBipartiteGraphSegment = new LeftRegularBipartiteGraphSegment ( leftSize / NUM_ , leftDegree , rightSize / NUM_ , leftSize / NUM_ , NUM_ , Integer . MAX_VALUE , new IdentityEdgeTypeMask ( ) , new NullStatsReceiver ( ) ) ; LongSet addedIds = new LongOpenHashSet ( leftDegree ) ; for ( int i = NUM_ ; i < leftSize ; i ++ ) { addedIds . clear ( ) ; for ( int j = NUM_ ; j < leftDegree ; j ++ ) { long idToAdd ; do { idToAdd = random . nextInt ( rightSize ) ; } while ( addedIds . contains ( idToAdd ) ) ; addedIds . add ( idToAdd ) ; leftRegularBipartiteGraphSegment . addEdge ( i , idToAdd , ( byte ) NUM_ ) ; } } return leftRegularBipartiteGraphSegment ; }
@ Override public void addFocusables ( ArrayList < View > views , int direction , int focusableMode ) { final int focusableCount = views . size ( ) ; final int descendantFocusability = getDescendantFocusability ( ) ; if ( descendantFocusability != FOCUS_BLOCK_DESCENDANTS ) { for ( int i = NUM_ ; i < getChildCount ( ) ; i ++ ) { final View child = getChildAt ( i ) ; if ( child . getVisibility ( ) == VISIBLE ) { ItemInfo ii = infoForChild ( child ) ; if ( ii != null && ii . position == mCurItem ) { child . addFocusables ( views , direction , focusableMode ) ; } } } } if ( descendantFocusability != FOCUS_AFTER_DESCENDANTS || ( focusableCount == views . size ( ) ) ) { if ( ! isFocusable ( ) ) { return ; } if ( ( focusableMode & FOCUSABLES_TOUCH_MODE ) == FOCUSABLES_TOUCH_MODE && isInTouchMode ( ) && ! isFocusableInTouchMode ( ) ) { return ; } if ( views != null ) { views . add ( this ) ; } } }
protected HttpURLConnection configureRequest ( final HttpURLConnection request ) { if ( credentials != null ) request . setRequestProperty ( HEADER_AUTHORIZATION , credentials ) ; request . setRequestProperty ( HEADER_USER_AGENT , userAgent ) ; request . setRequestProperty ( HEADER_ACCEPT , getHeaderAccept ( ) ) ; return request ; }
public static String convertToTitle ( int n ) { if ( n <= NUM_ ) return STR_ ; StringBuilder title = new StringBuilder ( ) ; while ( n > NUM_ ) { n -- ; int r = n % NUM_ ; title . insert ( NUM_ , ( char ) ( STR_ + r ) ) ; n = n / NUM_ ; } return title . toString ( ) ; }
private char readEscapeCharacter ( ) throws JSONException { char escaped = in . charAt ( pos ++ ) ; switch ( escaped ) { case STR_ : if ( pos + NUM_ > in . length ( ) ) { throw syntaxError ( STR_ ) ; } String hex = in . substring ( pos , pos + NUM_ ) ; pos += NUM_ ; return ( char ) Integer . parseInt ( hex , NUM_ ) ; case STR_ : return STR_ ; case STR_ : return STR_ ; case STR_ : return STR_ ; case STR_ : return STR_ ; case STR_ : return STR_ ; case STR_ : case STR_ : case STR_ : default : return escaped ; } }
static public void process ( String input , String output , String packFileName ) { process ( new Settings ( ) , input , output , packFileName ) ; }
private ReplicatorRuntimeConf ( String serviceName ) { replicatorHomeDir = locateReplicatorHomeDir ( ) ; replicatorLogDir = locateReplicatorLogDir ( ) ; replicatorConfDir = locateReplicatorConfDir ( ) ; replicatorProperties = new File ( locateReplicatorConfDir ( ) , STR_ + serviceName + STR_ ) ; if ( ! replicatorProperties . isFile ( ) || ! replicatorProperties . canRead ( ) ) { throw new ServerRuntimeException ( STR_ + replicatorProperties ) ; } replicatorDynamicProperties = new File ( replicatorConfDir , STR_ + serviceName + STR_ ) ; replicatorDynamicRole = new File ( replicatorConfDir , STR_ + serviceName + STR_ ) ; this . clearDynamicProperties = Boolean . parseBoolean ( System . getProperty ( CLEAR_DYNAMIC_PROPERTIES ) ) ; }
private String toLocalNumber ( double n ) { return mDecimalFormat . format ( n ) ; }
public void simulateMethod ( SootMethod method , ReferenceVariable thisVar , ReferenceVariable returnVar , ReferenceVariable params [ ] ) { String subSignature = method . getSubSignature ( ) ; if ( subSignature . equals ( STR_ ) ) { java_security_AccessController_doPrivileged ( method , thisVar , returnVar , params ) ; return ; } else if ( subSignature . equals ( STR_ ) ) { java_security_AccessController_doPrivileged ( method , thisVar , returnVar , params ) ; return ; } else if ( subSignature . equals ( STR_ ) ) { java_security_AccessController_doPrivileged ( method , thisVar , returnVar , params ) ; return ; } else if ( subSignature . equals ( STR_ ) ) { java_security_AccessController_doPrivileged ( method , thisVar , returnVar , params ) ; return ; } else if ( subSignature . equals ( STR_ ) ) { java_security_AccessController_getStackAccessControlContext ( method , thisVar , returnVar , params ) ; return ; } else if ( subSignature . equals ( STR_ ) ) { java_security_AccessController_getInheritedAccessControlContext ( method , thisVar , returnVar , params ) ; return ; } else { defaultMethod ( method , thisVar , returnVar , params ) ; return ; } }
protected final void refreshLoadingViewsSize ( ) { final int maximumPullScroll = ( int ) ( getMaximumPullScroll ( ) . NUM_ ) ; int pLeft = getPaddingLeft ( ) ; int pTop = getPaddingTop ( ) ; int pRight = getPaddingRight ( ) ; int pBottom = getPaddingBottom ( ) ; switch ( getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setWidth ( maximumPullScroll ) ; pLeft = - maximumPullScroll ; } else { pLeft = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setWidth ( maximumPullScroll ) ; pRight = - maximumPullScroll ; } else { pRight = NUM_ ; } break ; case VERTICAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setHeight ( maximumPullScroll ) ; pTop = - maximumPullScroll ; } else { pTop = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setHeight ( maximumPullScroll ) ; pBottom = - maximumPullScroll ; } else { pBottom = NUM_ ; } break ; } if ( DEBUG ) { Log . d ( LOG_TAG , String . format ( STR_ , pLeft , pTop , pRight , pBottom ) ) ; } setPadding ( pLeft , pTop , pRight , pBottom ) ; }
public static long [ ] asLongArray ( final List < Long > l ) { final long [ ] a = new long [ l . size ( ) ] ; for ( int i = NUM_ ; i < a . length ; i ++ ) { a [ i ] = l . get ( i ) ; } return a ; }
private void updateMenuState ( ) { m_appendAnd . setEnabled ( m_criteriumNode . allowAppend ( CAndCriterium . class ) ) ; m_appendOr . setEnabled ( m_criteriumNode . allowAppend ( COrCriterium . class ) ) ; m_appendNot . setEnabled ( m_criteriumNode . allowAppend ( CNotCriterium . class ) ) ; m_insertAnd . setEnabled ( m_criteriumNode . allowInsert ( CAndCriterium . class ) ) ; m_insertOr . setEnabled ( m_criteriumNode . allowInsert ( COrCriterium . class ) ) ; m_insertNot . setEnabled ( m_criteriumNode . allowInsert ( CNotCriterium . class ) ) ; m_conditionSubmenu . setEnabled ( m_criteriumNode . allowAppend ( CConditionCriterium . class ) ) ; m_remove . setEnabled ( ! m_criteriumNode . isRoot ( ) ) ; m_removeAll . setEnabled ( m_criteriumNode . getChildCount ( ) != NUM_ ) ; }
public void testPutGetRemove ( ) throws Exception { initStore ( NUM_ ) ; Set < Integer > exp ; try { exp = runPutGetRemoveMultithreaded ( NUM_ , NUM_ ) ; } finally { shutdownStore ( ) ; } Map < Integer , String > map = delegate . getMap ( ) ; Collection < Integer > extra = new HashSet < > ( map . keySet ( ) ) ; extra . removeAll ( exp ) ; assertTrue ( STR_ + extra , extra . isEmpty ( ) ) ; Collection < Integer > missing = new HashSet < > ( exp ) ; missing . removeAll ( map . keySet ( ) ) ; assertTrue ( STR_ + missing , missing . isEmpty ( ) ) ; for ( Integer key : exp ) assertEquals ( STR_ + key , STR_ + key , map . get ( key ) ) ; }
public static String formatListToString ( List < String > list ) { String result = STR_ ; for ( String s : list ) result += s + STR_ ; result = result . trim ( ) ; return result . toUpperCase ( ) ; }
@ Override public void removeNotificationListener ( NotificationListener listener ) throws ListenerNotFoundException { if ( SNMP_ADAPTOR_LOGGER . isLoggable ( Level . FINEST ) ) { SNMP_ADAPTOR_LOGGER . logp ( Level . FINEST , dbgTag , STR_ , STR_ + listener ) ; } notifBroadcaster . removeNotificationListener ( listener ) ; }
public static boolean isNewer ( long ts1 , long size1 , long ts2 , long size2 ) { return ts1 > ts2 || ( ts1 == ts2 && size1 < size2 ) ; }
private static void d_ucumm ( double [ ] a , double [ ] agg , double [ ] c , int m , int n , int rl , int ru ) { double [ ] cprods = ( agg != null ) ? agg : new double [ n ] ; if ( agg == null ) Arrays . fill ( cprods , NUM_ ) ; for ( int i = rl , aix = rl . n ; i < ru ; i ++ , aix += n ) { productAgg ( a , cprods , aix , NUM_ , n ) ; System . arraycopy ( cprods , NUM_ , c , aix , n ) ; } }
public static List < ModuleSpec > expandSpecWildcards ( File dir , List < ModuleSpec > modules , Backend forBackend ) { List < File > dirs = new ArrayList < File > ( ) ; dirs . add ( dir ) ; return expandSpecWildcards ( dirs , modules , forBackend ) ; }
private void $$$setupUI$$$ ( ) { myContentPanel = new JPanel ( ) ; myContentPanel . setLayout ( new GridLayoutManager ( NUM_ , NUM_ , new Insets ( NUM_ , NUM_ , NUM_ , NUM_ ) , - NUM_ , - NUM_ ) ) ; myYoursRadioButton = new JRadioButton ( ) ; myYoursRadioButton . setSelected ( BOOL_ ) ; myYoursRadioButton . setText ( STR_ ) ; myYoursRadioButton . setMnemonic ( STR_ ) ; myYoursRadioButton . setDisplayedMnemonicIndex ( NUM_ ) ; myContentPanel . add ( myYoursRadioButton , new GridConstraints ( NUM_ , NUM_ , NUM_ , NUM_ , GridConstraints . ANCHOR_WEST , GridConstraints . FILL_NONE , GridConstraints . SIZEPOLICY_CAN_SHRINK | GridConstraints . SIZEPOLICY_CAN_GROW , GridConstraints . SIZEPOLICY_FIXED , null , null , null , NUM_ , BOOL_ ) ) ; myTheirsRadioButton = new JRadioButton ( ) ; myTheirsRadioButton . setText ( STR_ ) ; myTheirsRadioButton . setMnemonic ( STR_ ) ; myTheirsRadioButton . setDisplayedMnemonicIndex ( NUM_ ) ; myContentPanel . add ( myTheirsRadioButton , new GridConstraints ( NUM_ , NUM_ , NUM_ , NUM_ , GridConstraints . ANCHOR_WEST , GridConstraints . FILL_NONE , GridConstraints . SIZEPOLICY_CAN_SHRINK | GridConstraints . SIZEPOLICY_CAN_GROW , GridConstraints . SIZEPOLICY_FIXED , null , null , null , NUM_ , BOOL_ ) ) ; myUseCustomRadioButton = new JRadioButton ( ) ; myUseCustomRadioButton . setText ( STR_ ) ; myUseCustomRadioButton . setMnemonic ( STR_ ) ; myUseCustomRadioButton . setDisplayedMnemonicIndex ( NUM_ ) ; myContentPanel . add ( myUseCustomRadioButton , new GridConstraints ( NUM_ , NUM_ , NUM_ , NUM_ , GridConstraints . ANCHOR_WEST , GridConstraints . FILL_NONE , GridConstraints . SIZEPOLICY_CAN_SHRINK | GridConstraints . SIZEPOLICY_CAN_GROW , GridConstraints . SIZEPOLICY_FIXED , null , null , null , NUM_ , BOOL_ ) ) ; myCustomPathTextField = new JTextField ( ) ; myCustomPathTextField . setEnabled ( BOOL_ ) ; myContentPanel . add ( myCustomPathTextField , new GridConstraints ( NUM_ , NUM_ , NUM_ , NUM_ , GridConstraints . ANCHOR_WEST , GridConstraints . FILL_BOTH , GridConstraints . SIZEPOLICY_WANT_GROW , GridConstraints . SIZEPOLICY_FIXED , null , new Dimension ( NUM_ , - NUM_ ) , null , NUM_ , BOOL_ ) ) ; final Spacer spacer1 = new Spacer ( ) ; myContentPanel . add ( spacer1 , new GridConstraints ( NUM_ , NUM_ , NUM_ , NUM_ , GridConstraints . ANCHOR_CENTER , GridConstraints . FILL_VERTICAL , NUM_ , GridConstraints . SIZEPOLICY_WANT_GROW , null , null , null , NUM_ , BOOL_ ) ) ; myErrorLabel = new JLabel ( ) ; myErrorLabel . setForeground ( new Color ( - NUM_ ) ) ; myErrorLabel . setText ( STR_ ) ; myContentPanel . add ( myErrorLabel , new GridConstraints ( NUM_ , NUM_ , NUM_ , NUM_ , GridConstraints . ANCHOR_WEST , GridConstraints . FILL_NONE , GridConstraints . SIZEPOLICY_CAN_GROW , GridConstraints . SIZEPOLICY_FIXED , null , null , null , NUM_ , BOOL_ ) ) ; ButtonGroup buttonGroup ; buttonGroup = new ButtonGroup ( ) ; buttonGroup . add ( myYoursRadioButton ) ; buttonGroup . add ( myTheirsRadioButton ) ; buttonGroup . add ( myUseCustomRadioButton ) ; }
private static String reportListContents ( Collection < ProcessErrorStateInfo > errList ) { if ( errList == null ) return null ; StringBuilder builder = new StringBuilder ( ) ; Iterator < ProcessErrorStateInfo > iter = errList . iterator ( ) ; while ( iter . hasNext ( ) ) { ProcessErrorStateInfo entry = iter . next ( ) ; String condition ; switch ( entry . condition ) { case ActivityManager . ProcessErrorStateInfo . CRASHED : condition = STR_ ; break ; case ActivityManager . ProcessErrorStateInfo . NOT_RESPONDING : condition = STR_ ; break ; default : condition = STR_ ; break ; } builder . append ( String . format ( STR_ , entry . processName , condition , entry . shortMsg ) ) ; if ( entry . condition == ActivityManager . ProcessErrorStateInfo . CRASHED ) { builder . append ( String . format ( STR_ , entry . stackTrace ) ) ; } builder . append ( STR_ ) ; } return builder . toString ( ) ; }
public void parseArguments ( final String [ ] rawArguments , Properties argumentProperties ) throws ArgumentException { boolean inTrailingArgs = BOOL_ ; final int numArguments = rawArguments . length ; for ( int i = NUM_ ; i < numArguments ; i ++ ) { final String arg = rawArguments [ i ] ; if ( inTrailingArgs ) { trailingArguments . add ( arg ) ; if ( maxTrailingArguments > NUM_ && trailingArguments . size ( ) > maxTrailingArguments ) { final LocalizableMessage message = ERR_ARGPARSER_TOO_MANY_TRAILING_ARGS . get ( maxTrailingArguments ) ; throw new ArgumentException ( message ) ; } continue ; } if ( arg . equals ( STR_ ) ) { inTrailingArgs = BOOL_ ; } else if ( arg . startsWith ( STR_ ) ) { String argName = arg . substring ( NUM_ ) ; String argValue = null ; final int equalPos = argName . indexOf ( STR_ ) ; if ( equalPos == NUM_ ) { throw new ArgumentException ( ERR_ARGPARSER_LONG_ARG_WITHOUT_NAME . get ( arg ) ) ; } else if ( equalPos > NUM_ ) { argValue = argName . substring ( equalPos + NUM_ ) ; argName = argName . substring ( NUM_ , equalPos ) ; } final String origArgName = argName ; argName = formatLongIdentifier ( argName ) ; final Argument a = longIDMap . get ( argName ) ; if ( a == null ) { if ( OPTION_LONG_HELP . equals ( argName ) ) { writeToUsageOutputStream ( getUsage ( ) ) ; return ; } else if ( OPTION_LONG_PRODUCT_VERSION . equals ( argName ) ) { printVersion ( ) ; return ; } else { throw new ArgumentException ( ERR_ARGPARSER_NO_ARGUMENT_WITH_LONG_ID . get ( origArgName ) ) ; } } else { a . setPresent ( BOOL_ ) ; if ( isUsageArgument ( a ) ) { writeToUsageOutputStream ( getUsage ( ) ) ; return ; } } if ( a . needsValue ( ) ) { if ( argValue == null ) { if ( ( i + NUM_ ) == numArguments ) { throw new ArgumentException ( ERR_ARGPARSER_NO_VALUE_FOR_ARGUMENT_WITH_LONG_ID . get ( origArgName ) ) ; } argValue = rawArguments [ ++ i ] ; } final LocalizableMessageBuilder invalidReason = new LocalizableMessageBuilder ( ) ; if ( ! a . valueIsAcceptable ( argValue , invalidReason ) ) { throw new ArgumentException ( ERR_ARGPARSER_VALUE_UNACCEPTABLE_FOR_LONG_ID . get ( argValue , origArgName , invalidReason ) ) ; } if ( a . hasValue ( ) && ! a . isMultiValued ( ) ) { throw new ArgumentException ( ERR_ARGPARSER_NOT_MULTIVALUED_FOR_LONG_ID . get ( origArgName ) ) ; } a . addValue ( argValue ) ; } else if ( argValue != null ) { throw new ArgumentException ( ERR_ARGPARSER_ARG_FOR_LONG_ID_DOESNT_TAKE_VALUE . get ( origArgName ) ) ; } } else if ( arg . startsWith ( STR_ ) ) { if ( arg . equals ( STR_ ) ) { throw new ArgumentException ( ERR_ARGPARSER_INVALID_DASH_AS_ARGUMENT . get ( ) ) ; } final char argCharacter = arg . charAt ( NUM_ ) ; String argValue ; if ( arg . length ( ) > NUM_ ) { argValue = arg . substring ( NUM_ ) ; } else { argValue = null ; } final Argument a = shortIDMap . get ( argCharacter ) ; if ( a == null ) { if ( argCharacter == STR_ ) { writeToUsageOutputStream ( getUsage ( ) ) ; return ; } else if ( versionHandler != null && argCharacter == OPTION_SHORT_PRODUCT_VERSION && ! shortIDMap . containsKey ( OPTION_SHORT_PRODUCT_VERSION ) ) { printVersion ( ) ; return ; } else { throw new ArgumentException ( ERR_ARGPARSER_NO_ARGUMENT_WITH_SHORT_ID . get ( argCharacter ) ) ; } } else { a . setPresent ( BOOL_ ) ; if ( isUsageArgument ( a ) ) { writeToUsageOutputStream ( getUsage ( ) ) ; return ; } } if ( a . needsValue ( ) ) { if ( argValue == null ) { if ( ( i + NUM_ ) == numArguments ) { throw new ArgumentException ( ERR_ARGPARSER_NO_VALUE_FOR_ARGUMENT_WITH_SHORT_ID . get ( argCharacter ) ) ; } argValue = rawArguments [ ++ i ] ; } final LocalizableMessageBuilder invalidReason = new LocalizableMessageBuilder ( ) ; if ( ! a . valueIsAcceptable ( argValue , invalidReason ) ) { throw new ArgumentException ( ERR_ARGPARSER_VALUE_UNACCEPTABLE_FOR_SHORT_ID . get ( argValue , argCharacter , invalidReason ) ) ; } if ( a . hasValue ( ) && ! a . isMultiValued ( ) ) { throw new ArgumentException ( ERR_ARGPARSER_NOT_MULTIVALUED_FOR_SHORT_ID . get ( argCharacter ) ) ; } a . addValue ( argValue ) ; } else if ( argValue != null ) { final int valueLength = argValue . length ( ) ; for ( int j = NUM_ ; j < valueLength ; j ++ ) { final char c = argValue . charAt ( j ) ; final Argument b = shortIDMap . get ( c ) ; if ( b == null ) { throw new ArgumentException ( ERR_ARGPARSER_NO_ARGUMENT_WITH_SHORT_ID . get ( argCharacter ) ) ; } else if ( b . needsValue ( ) ) { throw new ArgumentException ( ERR_ARGPARSER_CANT_MIX_ARGS_WITH_VALUES . get ( argCharacter , argValue , c ) ) ; } else { b . setPresent ( BOOL_ ) ; if ( isUsageArgument ( b ) ) { writeToUsageOutputStream ( getUsage ( ) ) ; return ; } } } } } else if ( allowsTrailingArguments ) { inTrailingArgs = BOOL_ ; trailingArguments . add ( arg ) ; } else { throw new ArgumentException ( ERR_ARGPARSER_DISALLOWED_TRAILING_ARGUMENT . get ( arg ) ) ; } } if ( allowsTrailingArguments && minTrailingArguments > NUM_ && trailingArguments . size ( ) < minTrailingArguments ) { throw new ArgumentException ( ERR_ARGPARSER_TOO_FEW_TRAILING_ARGUMENTS . get ( minTrailingArguments ) ) ; } if ( argumentProperties == null ) { argumentProperties = checkExternalProperties ( ) ; } normalizeArguments ( argumentProperties , argumentList ) ; }
public void testGetIssuerNames ( ) { X509CRLSelector selector = new X509CRLSelector ( ) ; byte [ ] iss1 = new byte [ ] { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte [ ] iss2 = new byte [ ] { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; assertNull ( STR_ , selector . getIssuerNames ( ) ) ; try { selector . addIssuerName ( iss1 ) ; selector . addIssuerName ( iss2 ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; fail ( STR_ ) ; } Collection < Object > result = selector . getIssuerNames ( ) ; assertEquals ( STR_ , NUM_ , result . size ( ) ) ; }
@ Override public boolean start ( ) throws IOException { LOG . info ( STR_ , initialCheckpointGenerator ) ; try { KinesisReaderCheckpoint initialCheckpoint = initialCheckpointGenerator . generate ( kinesis ) ; List < ShardRecordsIterator > iterators = newArrayList ( ) ; for ( ShardCheckpoint checkpoint : initialCheckpoint ) { iterators . add ( checkpoint . getShardRecordsIterator ( kinesis ) ) ; } shardIterators = new RoundRobin < > ( iterators ) ; } catch ( TransientKinesisException e ) { throw new IOException ( e ) ; } return advance ( ) ; }
@ Override public XADataSource createXADataSource ( Properties properties ) throws SQLException { Properties propertiesCopy = new Properties ( ) ; if ( properties != null ) { propertiesCopy . putAll ( properties ) ; } rejectUnsupportedOptions ( propertiesCopy ) ; rejectPoolingOptions ( propertiesCopy ) ; JdbcDataSource dataSource = new JdbcDataSource ( ) ; setupH2DataSource ( dataSource , propertiesCopy ) ; return dataSource ; }
public static double toDegrees ( double x ) { if ( Double . isInfinite ( x ) || x == NUM_ ) { return x ; } final double facta = NUM_ ; final double factb = NUM_ ; double xa = doubleHighPart ( x ) ; double xb = x - xa ; return xb . factb + xb . facta + xa . factb + xa . facta ; }
public void addHeaderView ( View v ) { addHeaderView ( v , null , BOOL_ ) ; }
public static boolean isAbsolutePath ( String systemId ) { if ( systemId == null ) return BOOL_ ; final File file = new File ( systemId ) ; return file . isAbsolute ( ) ; }
void initDemandAndCollectionMap ( final List < String > prepareFieldNames , final Map < String , BigDecimal > demand , final Map < String , BigDecimal > collection , final Map < String , BigDecimal > rebates ) { if ( prepareFieldNames != null && ! prepareFieldNames . isEmpty ( ) ) for ( final String fieldName : prepareFieldNames ) { demand . put ( fieldName , BigDecimal . ZERO ) ; collection . put ( fieldName , BigDecimal . ZERO ) ; rebates . put ( fieldName , BigDecimal . ZERO ) ; } }
protected Instance specifier ( int i ) { return m_Specifiers . get ( i ) ; }
public ShapedCraftingRecipe ( Item nominalOutput , RecipeFunction recipeFunction , String format , boolean mirrored , ItemIngredient ... ingredients ) { this . nominalOutput = nominalOutput ; String [ ] formatLines = format . split ( STR_ ) ; int numIngredients = NUM_ ; int width = NUM_ ; for ( String formatLine : formatLines ) { width = Math . max ( width , formatLine . length ( ) ) ; for ( char c : formatLine . toCharArray ( ) ) { if ( c == STR_ ) { continue ; } else if ( c >= STR_ && c <= STR_ ) { numIngredients ++ ; } else { throw new IllegalArgumentException ( STR_ + format + STR_ + c ) ; } } } this . width = width ; this . height = formatLines . length ; this . posx = new int [ numIngredients ] ; this . posy = new int [ numIngredients ] ; this . ingredients = new ItemIngredient [ numIngredients ] ; this . mirrored = mirrored ; int ingredientIndex = NUM_ ; for ( int y = NUM_ ; y < this . height ; y ++ ) { String formatLine = formatLines [ y ] ; for ( int x = NUM_ ; x < formatLine . length ( ) ; x ++ ) { char c = formatLine . charAt ( x ) ; if ( c == STR_ ) { continue ; } this . posx [ ingredientIndex ] = x ; this . posy [ ingredientIndex ] = y ; this . ingredients [ ingredientIndex ] = ingredients [ c - STR_ ] ; ingredientIndex ++ ; } } this . recipeFunction = recipeFunction ; this . lastIngredientIndexOnFirstLine = getLastIngredientIndexOnFirstLine ( ) ; }
public void writeTag ( String tag , Font value ) { startTag ( tag ) ; writeTag ( STR_ , value . getName ( ) ) ; int style = value . getStyle ( ) ; if ( ( style & Font . BOLD ) != NUM_ && ( style & Font . ITALIC ) != NUM_ ) { writeTag ( STYLE , STR_ ) ; } else if ( ( style & Font . BOLD ) != NUM_ ) { writeTag ( STYLE , STR_ ) ; } else if ( ( style & Font . ITALIC ) != NUM_ ) { writeTag ( STYLE , STR_ ) ; } else { writeTag ( STYLE , STR_ ) ; } writeTag ( STR_ , value . getSize ( ) ) ; closeTag ( ) ; }
private void internalWrite ( byte [ ] b , int off , int len , boolean finish ) throws IOException { coder . output = embiggen ( coder . output , coder . maxOutputSize ( len ) ) ; if ( ! coder . process ( b , off , len , finish ) ) { throw new Base64DataException ( STR_ ) ; } out . write ( coder . output , NUM_ , coder . op ) ; }
private Socket connect ( String host , String portString ) throws IOException { int port = NUM_ ; Socket sock = null ; boolean DEBUG = Debug . debugging ( STR_ ) ; try { port = Integer . parseInt ( portString , NUM_ ) ; } catch ( NumberFormatException e ) { if ( DEBUG ) Debug . output ( STR_ + host + STR_ + portString ) ; throw new IOException ( STR_ + portString ) ; } if ( DEBUG ) Debug . output ( STR_ + host + STR_ + port ) ; try { sock = new Socket ( host , port ) ; } catch ( IOException e ) { if ( sock != null ) sock . close ( ) ; if ( DEBUG ) { Debug . output ( STR_ + host + STR_ + port + STR_ + e ) ; } throw e ; } return sock ; }
@ Override public boolean batchFinished ( ) { if ( getInputFormat ( ) == null ) { throw new IllegalStateException ( STR_ ) ; } Instances toFilter = getInputFormat ( ) ; int cutOff = ( int ) Math . round ( toFilter . numInstances ( ) . m_Percentage / NUM_ ) ; if ( m_Inverse ) { for ( int i = NUM_ ; i < cutOff ; i ++ ) { push ( toFilter . instance ( i ) ) ; } } else { for ( int i = cutOff ; i < toFilter . numInstances ( ) ; i ++ ) { push ( toFilter . instance ( i ) ) ; } } flushInput ( ) ; m_NewBatch = BOOL_ ; m_FirstBatchDone = BOOL_ ; return ( numPendingOutput ( ) != NUM_ ) ; }
public void computeParameters ( ) { if ( ellps == null ) { ellps = Ellipsoid . WGS_84 ; } if ( mode == MODE_BELGIUM ) { alpha = NUM_ ; } else { alpha = NUM_ ; } double phi1 = ProjMath . degToRad ( lambert_sp_one ) ; double phi2 = ProjMath . degToRad ( lambert_sp_two ) ; double phif = ProjMath . degToRad ( referenceLatitude ) ; double e = ellps . ecc ; double sinphi ; sinphi = Math . sin ( phi1 ) ; double m1 = lambMsfn ( sinphi , Math . cos ( phi1 ) , e ) ; double t1 = lambTsfn ( phi1 , sinphi , e ) ; if ( MoreMath . approximately_equal ( phi1 , phi2 , EPS10 ) ) { n = sinphi ; } else { sinphi = Math . sin ( phi2 ) ; double m2 = lambMsfn ( sinphi , Math . cos ( phi2 ) , e ) ; double t2 = lambTsfn ( phi2 , sinphi , e ) ; n = Math . log ( m1 / m2 ) / Math . log ( t1 / t2 ) ; } F = m1 / ( n . Math . pow ( t1 , n ) ) ; if ( MoreMath . approximately_equal ( phi1 , phi2 , EPS10 ) ) { rf = NUM_ ; } else { rf = ellps . radius . F . Math . pow ( lambTsfn ( phif , Math . sin ( phif ) , e ) , n ) ; } lamdaf = ProjMath . degToRad ( centralMeridian ) ; locationCenterXPixel = ( ( double ) getWidth ( ) / NUM_ ) ; locationCenterYPixel = ( ( double ) getHeight ( ) / NUM_ ) ; locationPixelsPerLambert = ( double ) getPPM ( ) / getScale ( ) ; LatLonPoint origin = new LatLonPoint . Double ( referenceLatitude , centralMeridian ) ; Point2D lp = LLToWorld ( origin . getY ( ) , origin . getX ( ) , new Point2D . Double ( ) ) ; locationOriginX = lp . getX ( ) ; locationOriginY = lp . getY ( ) ; LatLonPoint center = getCenter ( ) ; lp = LLToWorld ( center . getY ( ) , center . getX ( ) , lp ) ; locationCenterXLambert = lp . getX ( ) ; locationCenterYLambert = lp . getY ( ) ; locationOriginXfPixel = locationCenterXPixel + ( locationOriginX - locationCenterXLambert ) . locationPixelsPerLambert ; locationOriginYfPixel = locationCenterYPixel - ( locationOriginY - locationCenterYLambert ) . locationPixelsPerLambert ; if ( Debug . debugging ( STR_ ) ) { Debug . output ( STR_ + locationCenterXLambert + STR_ + locationCenterYLambert ) ; Debug . output ( STR_ + locationOriginX + STR_ + locationOriginY ) ; } }
protected OkHttpClient configureHttpClient ( ) { final OkHttpClient . Builder builder = new OkHttpClient . Builder ( ) ; final CookieManager cookieManager = new CookieManager ( ) ; cookieManager . setCookiePolicy ( CookiePolicy . ACCEPT_ALL ) ; builder . cookieJar ( new JavaNetCookieJar ( cookieManager ) ) ; builder . connectTimeout ( NUM_ , TimeUnit . SECONDS ) ; builder . writeTimeout ( NUM_ , TimeUnit . SECONDS ) ; builder . readTimeout ( NUM_ , TimeUnit . SECONDS ) ; return builder . build ( ) ; }
public String parseFile ( File file ) { log . config ( file . getAbsolutePath ( ) ) ; String line = null ; try { BufferedReader in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , Ini . getCharset ( ) ) , NUM_ ) ; String errMsg = STR_ ; int lineNo = NUM_ ; while ( ( line = in . readLine ( ) ) != null && errMsg . length ( ) == NUM_ ) { errMsg = parseLine ( line , lineNo ) ; lineNo ++ ; } line = null ; in . close ( ) ; if ( errMsg . length ( ) != NUM_ ) return errMsg ; } catch ( Exception ioe ) { String s = ioe . getLocalizedMessage ( ) ; if ( s == null || s . length ( ) == NUM_ ) s = ioe . toString ( ) ; return STR_ + line + STR_ + s ; } return STR_ ; }
public static Test suite ( ) throws Exception { return suite ( BOOL_ ) ; }
public void load ( Element element , Object o ) { log . error ( STR_ ) ; }
public OMRaster ( double lt , double ln , int offset_x1 , int offset_y1 , ImageIcon ii ) { this ( lt , ln , offset_x1 , offset_y1 , ii . getImage ( ) ) ; }
private synchronized boolean startDequeue ( ) { int threads = Math . min ( queue . size ( ) , maxThreads ) ; for ( int i = NUM_ ; i < threads ; i ++ ) { ResourceThread t = ( ResourceThread ) queue . firstElement ( ) ; queue . removeElementAt ( NUM_ ) ; running . addElement ( t ) ; threadCount ++ ; } for ( Enumeration e = running . elements ( ) ; e . hasMoreElements ( ) ; ) { ResourceThread t = ( ResourceThread ) e . nextElement ( ) ; t . go ( ) ; } return ( threads > NUM_ ) ; }
public void propertyChange ( PropertyChangeEvent evt ) { String name = evt . getPropertyName ( ) ; if ( name == STR_ || name == STR_ ) { invalidateWidthCache ( ) ; fireColumnMarginChanged ( ) ; } }
static WorkQueue commonSubmitterQueue ( ) { ForkJoinPool p ; WorkQueue [ ] ws ; int m ; Submitter z ; return ( ( z = submitters . get ( ) ) != null && ( p = commonPool ) != null && ( ws = p . workQueues ) != null && ( m = ws . length - NUM_ ) >= NUM_ ) ? ws [ m & z . seed & SQMASK ] : null ; }
public static void assertEquals ( Object object1 , Object object2 ) { checkAssertion ( object1 . equals ( object2 ) , null ) ; }
protected final void refreshLoadingViewsSize ( ) { final int maximumPullScroll = ( int ) ( getMaximumPullScroll ( ) . NUM_ ) ; int pLeft = getPaddingLeft ( ) ; int pTop = getPaddingTop ( ) ; int pRight = getPaddingRight ( ) ; int pBottom = getPaddingBottom ( ) ; switch ( getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setWidth ( maximumPullScroll ) ; pLeft = - maximumPullScroll ; } else { pLeft = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setWidth ( maximumPullScroll ) ; pRight = - maximumPullScroll ; } else { pRight = NUM_ ; } break ; case VERTICAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setHeight ( maximumPullScroll ) ; pTop = - maximumPullScroll ; } else { pTop = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setHeight ( maximumPullScroll ) ; pBottom = - maximumPullScroll ; } else { pBottom = NUM_ ; } break ; } if ( DEBUG ) { Log . d ( LOG_TAG , String . format ( STR_ , pLeft , pTop , pRight , pBottom ) ) ; } setPadding ( pLeft , pTop , pRight , pBottom ) ; }
public static String flagNames ( long flags ) { StringBuilder sbuf = new StringBuilder ( ) ; int i = NUM_ ; long f = flags & StandardFlags ; while ( f != NUM_ ) { if ( ( f & NUM_ ) != NUM_ ) { sbuf . append ( STR_ ) ; sbuf . append ( flagName [ i ] ) ; } f = f > > NUM_ ; i ++ ; } return sbuf . toString ( ) ; }
public String formatSQL ( Object obj , Object expr ) { String sql = null ; if ( expr instanceof String ) { sql = ( String ) expr ; if ( log . isLoggable ( Level . FINEST ) ) { log . finest ( STR_ + sql ) ; } } else if ( obj != null ) { sql = toString ( obj ) ; if ( sql != null ) { if ( sql . startsWith ( STR_ ) ) { sql = sql . replaceFirst ( STR_ , STR_ ) ; } sql = sql . replaceAll ( STR_ , BINARY_SQL_MARKER ) ; } if ( log . isLoggable ( Level . FINEST ) ) { log . finest ( STR_ + sql ) ; } } return sql ; }
public void indent ( ) { indent . append ( STR_ ) ; }
public void addFakeView ( View childView ) { childView . layout ( NUM_ , NUM_ , getWidth ( ) , childView . getMeasuredHeight ( ) ) ; views . add ( childView ) ; }
public void compileProjects ( List < File > projects , IssueAcceptor issueAcceptor ) throws N4JSCompileException { compileProjects ( Arrays . asList ( new File ( STR_ ) ) , projects , Collections . emptyList ( ) , issueAcceptor ) ; }
protected final void print_contact_info ( ObjectInfoPanel p_window , java . util . Locale p_locale ) { Collection < BrdItem > contacts = get_normal_contacts ( ) ; if ( contacts . isEmpty ( ) ) return ; GuiResources resources = r_board . newGuiResources ( STR_ ) ; p_window . append ( STR_ + resources . getString ( STR_ ) + STR_ ) ; Integer contact_count = contacts . size ( ) ; p_window . append_items ( contact_count . toString ( ) , resources . getString ( STR_ ) , contacts ) ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
@ SuppressWarnings ( STR_ ) public Promise < Result , Progress > resolve ( Result result ) { List < DoneCallback < Result > > doneCallbacks ; List < AlwaysCallback > alwaysCallbacks ; synchronized ( this ) { validateInPendingState ( ) ; mState = STATE_RESOLVED ; printStateChanged ( STR_ ) ; mResult = result ; doneCallbacks = mCallbacks . cloneDoneCallbacks ( ) ; alwaysCallbacks = mCallbacks . cloneAlwaysCallbacks ( ) ; clearCallbacks ( ) ; } if ( doneCallbacks . size ( ) > NUM_ || alwaysCallbacks . size ( ) > NUM_ ) { triggerAllDones ( doneCallbacks ) ; triggerAllAlways ( alwaysCallbacks ) ; } return this ; }
private void adjustNameAndPosition ( Node node , int deltaX , int deltaY ) { String originalName = node . getName ( ) ; String uniqueName = nextUniqueName ( originalName ) ; if ( ! uniqueName . equals ( originalName ) ) { node . setName ( uniqueName ) ; node . setCenterX ( node . getCenterX ( ) + deltaX ) ; node . setCenterY ( node . getCenterY ( ) + deltaY ) ; } }
private void createSnapshot ( BlockSnapshot snapshot , Snap unitySnap , StorageSystem storage , DbClient dbClient ) { snapshot . setNativeId ( unitySnap . getId ( ) ) ; snapshot . setNativeGuid ( NativeGUIDGenerator . generateNativeGuid ( storage , snapshot ) ) ; snapshot . setDeviceLabel ( unitySnap . getName ( ) ) ; snapshot . setIsSyncActive ( BOOL_ ) ; snapshot . setInactive ( BOOL_ ) ; snapshot . setCreationTime ( Calendar . getInstance ( ) ) ; snapshot . setWWN ( unitySnap . getAttachedWWN ( ) ) ; snapshot . setAllocatedCapacity ( unitySnap . getSize ( ) ) ; snapshot . setProvisionedCapacity ( unitySnap . getSize ( ) ) ; dbClient . createObject ( snapshot ) ; }
public void save ( ) throws IOException { if ( ! props . isEmpty ( ) ) { ConfigurationUtil . saveConfigurationProperties ( props , propsFile , BOOL_ ) ; } ConfigurationUtil . saveConfigurationProperties ( props , new File ( propsFile . getParentFile ( ) , propsFile . getName ( ) + STR_ ) , BOOL_ ) ; }
public static int len ( String list , String delimiter , boolean ignoreEmpty ) { if ( delimiter . length ( ) == NUM_ ) return len ( list , delimiter . charAt ( NUM_ ) , ignoreEmpty ) ; char [ ] del = delimiter . toCharArray ( ) ; int len = StringUtil . length ( list ) ; if ( len == NUM_ ) return NUM_ ; int count = NUM_ ; int last = NUM_ ; char c ; for ( int i = NUM_ ; i < len ; i ++ ) { c = list . charAt ( i ) ; for ( int y = NUM_ ; y < del . length ; y ++ ) { if ( c == del [ y ] ) { if ( ! ignoreEmpty || last < i ) count ++ ; last = i + NUM_ ; break ; } } } if ( ! ignoreEmpty || last < len ) count ++ ; return count ; }
public synchronized void flush ( ) throws IOException { checkNotClosed ( ) ; trimToSize ( ) ; journalWriter . flush ( ) ; }
public String buildUri ( String representationId , int segmentNumber , int bandwidth , long time ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = NUM_ ; i < identifierCount ; i ++ ) { builder . append ( urlPieces [ i ] ) ; if ( identifiers [ i ] == REPRESENTATION_ID ) { builder . append ( representationId ) ; } else if ( identifiers [ i ] == NUMBER_ID ) { builder . append ( String . format ( Locale . US , identifierFormatTags [ i ] , segmentNumber ) ) ; } else if ( identifiers [ i ] == BANDWIDTH_ID ) { builder . append ( String . format ( Locale . US , identifierFormatTags [ i ] , bandwidth ) ) ; } else if ( identifiers [ i ] == TIME_ID ) { builder . append ( String . format ( Locale . US , identifierFormatTags [ i ] , time ) ) ; } } builder . append ( urlPieces [ identifierCount ] ) ; return builder . toString ( ) ; }
static void dispose ( long pData , long pConfigInfo ) { OGLRenderQueue rq = OGLRenderQueue . getInstance ( ) ; rq . lock ( ) ; try { OGLContext . setScratchSurface ( pConfigInfo ) ; RenderBuffer buf = rq . getBuffer ( ) ; rq . ensureCapacityAndAlignment ( NUM_ , NUM_ ) ; buf . putInt ( DISPOSE_SURFACE ) ; buf . putLong ( pData ) ; rq . flushNow ( ) ; } finally { rq . unlock ( ) ; } }
private void writeKanjiResourceFile ( File file ) throws IOException { FileOutputStream output = null ; KanjiEscapeOutputStream kanji = null ; OutputStreamWriter writer = null ; BufferedWriter w = null ; try { output = new FileOutputStream ( file ) ; kanji = new KanjiEscapeOutputStream ( output ) ; writer = new OutputStreamWriter ( kanji ) ; w = new BufferedWriter ( writer ) ; w . write ( _sb . toString ( ) ) ; } finally { Util . close ( w ) ; Util . close ( writer ) ; Util . close ( kanji ) ; Util . close ( output ) ; } }
public ScannerException ( File file , ErrorMessages message ) { this ( file , ErrorMessages . get ( message ) , message , - NUM_ , - NUM_ ) ; }
void renderNormal ( ) { glEnable ( GL_DEPTH_TEST ) ; glUseProgram ( this . normalProgram ) ; glUniformMatrix4fv ( viewMatrixUniform , BOOL_ , viewMatrix . get ( matrixBuffer ) ) ; glUniformMatrix4fv ( projMatrixUniform , BOOL_ , projMatrix . get ( matrixBuffer ) ) ; glUniformMatrix3fv ( normalMatrixUniform , BOOL_ , normalMatrix . get ( matrixBuffer ) ) ; glBindFramebufferEXT ( GL_FRAMEBUFFER_EXT , fbo ) ; glClear ( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT ) ; glBindBuffer ( GL_ARRAY_BUFFER , this . cubeVbo ) ; glEnableVertexAttribArray ( NUM_ ) ; glVertexAttribPointer ( NUM_ , NUM_ , GL_FLOAT , BOOL_ , NUM_ , NUM_ ) ; glEnableVertexAttribArray ( NUM_ ) ; glVertexAttribPointer ( NUM_ , NUM_ , GL_FLOAT , BOOL_ , NUM_ , normalsOffset ) ; glDrawArrays ( GL_TRIANGLES , NUM_ , numVertices ) ; glDisableVertexAttribArray ( NUM_ ) ; glDisableVertexAttribArray ( NUM_ ) ; glBindBuffer ( GL_ARRAY_BUFFER , NUM_ ) ; glBindFramebufferEXT ( GL_FRAMEBUFFER_EXT , NUM_ ) ; glUseProgram ( NUM_ ) ; }
private < T extends CWLResource > List < T > lookForResources ( CWLResourceType type , Class < T > clazz ) { List < T > resources = getRequirements ( type , clazz ) ; if ( resources == null || resources . size ( ) == NUM_ ) { resources = getHints ( type , clazz ) ; } return resources ; }
private void calcYValueSum ( ) { mYValueSum = NUM_ ; for ( int i = NUM_ ; i < mYVals . size ( ) ; i ++ ) { Entry e = mYVals . get ( i ) ; if ( e != null ) mYValueSum += Math . abs ( e . getVal ( ) ) ; } }
@ Override public boolean release ( int decrement ) { if ( isEmpty ) { return BOOL_ ; } if ( decrement < NUM_ ) { throw new IllegalStateException ( String . format ( STR_ , decrement , toVerboseString ( ) ) ) ; } final int refCnt = ledger . decrement ( decrement ) ; if ( BaseAllocator . DEBUG ) { historicalLog . recordEvent ( STR_ , decrement , refCnt + decrement ) ; } if ( refCnt < NUM_ ) { throw new IllegalStateException ( String . format ( STR_ , id , toVerboseString ( ) ) ) ; } return refCnt == NUM_ ; }
public static void checkArgument ( boolean expression , Object errorMessage ) { if ( ! expression ) { throw new IllegalArgumentException ( String . valueOf ( errorMessage ) ) ; } }
int listSize ( ) { int result = memSize ( ) ; for ( Iterator it = iterator ( ) ; it . hasNext ( ) ; ) { ASTNode child = ( ASTNode ) it . next ( ) ; result += child . treeSize ( ) ; } return result ; }
public ConnectionTcp findConnectionByThreadId ( long threadId ) { for ( PortTcp listener : getPorts ( ) ) { ConnectionTcp conn = listener . findConnectionByThreadId ( threadId ) ; if ( conn != null ) return conn ; } return null ; }
public static RepositoryMetaData readFrom ( StreamInput in ) throws IOException { String name = in . readString ( ) ; String type = in . readString ( ) ; Settings settings = Settings . readSettingsFromStream ( in ) ; return new RepositoryMetaData ( name , type , settings ) ; }
public static boolean isPrimitiveDatatype ( IRI datatype ) { return datatype . equals ( XMLSchema . DURATION ) || datatype . equals ( XMLSchema . DATETIME ) || datatype . equals ( XMLSchema . TIME ) || datatype . equals ( XMLSchema . DATE ) || datatype . equals ( XMLSchema . GYEARMONTH ) || datatype . equals ( XMLSchema . GYEAR ) || datatype . equals ( XMLSchema . GMONTHDAY ) || datatype . equals ( XMLSchema . GDAY ) || datatype . equals ( XMLSchema . GMONTH ) || datatype . equals ( XMLSchema . STRING ) || datatype . equals ( XMLSchema . BOOLEAN ) || datatype . equals ( XMLSchema . BASE64BINARY ) || datatype . equals ( XMLSchema . HEXBINARY ) || datatype . equals ( XMLSchema . FLOAT ) || datatype . equals ( XMLSchema . DECIMAL ) || datatype . equals ( XMLSchema . DOUBLE ) || datatype . equals ( XMLSchema . ANYURI ) || datatype . equals ( XMLSchema . QNAME ) || datatype . equals ( XMLSchema . NOTATION ) ; }
protected void appendLine ( JComponent c ) { c . setAlignmentX ( NUM_ ) ; contents . add ( c ) ; }
private void addLinks ( final SpannableString string , final long accountId , final long extraId , final int type , final boolean sensitive , final OnLinkClickListener listener , final int highlightOption ) { switch ( type ) { case LINK_TYPE_MENTION : { addMentionOrListLinks ( string , accountId , extraId , highlightOption , listener ) ; break ; } case LINK_TYPE_HASHTAG : { addHashtagLinks ( string , accountId , extraId , listener , highlightOption ) ; break ; } case LINK_TYPE_LINK : { final URLSpan [ ] spans = string . getSpans ( NUM_ , string . length ( ) , URLSpan . class ) ; for ( final URLSpan span : spans ) { final int start = string . getSpanStart ( span ) ; final int end = string . getSpanEnd ( span ) ; if ( start < NUM_ || end > string . length ( ) || start > end ) { continue ; } string . removeSpan ( span ) ; applyLink ( span . getURL ( ) , start , end , string , accountId , extraId , LINK_TYPE_LINK , sensitive , highlightOption , listener ) ; } final List < Extractor . Entity > urls = mExtractor . extractURLsWithIndices ( ParseUtils . parseString ( string ) ) ; for ( final Extractor . Entity entity : urls ) { final int start = entity . getStart ( ) , end = entity . getEnd ( ) ; if ( entity . getType ( ) != Extractor . Entity . Type . URL || string . getSpans ( start , end , URLSpan . class ) . length > NUM_ ) { continue ; } applyLink ( entity . getValue ( ) , start , end , string , accountId , extraId , LINK_TYPE_LINK , sensitive , highlightOption , listener ) ; } break ; } case LINK_TYPE_STATUS : { final URLSpan [ ] spans = string . getSpans ( NUM_ , string . length ( ) , URLSpan . class ) ; for ( final URLSpan span : spans ) { final Matcher matcher = PATTERN_TWITTER_STATUS . matcher ( span . getURL ( ) ) ; if ( matcher . matches ( ) ) { final int start = string . getSpanStart ( span ) ; final int end = string . getSpanEnd ( span ) ; final String url = matcherGroup ( matcher , GROUP_ID_TWITTER_STATUS_STATUS_ID ) ; string . removeSpan ( span ) ; applyLink ( url , start , end , string , accountId , extraId , LINK_TYPE_STATUS , sensitive , highlightOption , listener ) ; } } break ; } case LINK_TYPE_CASHTAG : { addCashtagLinks ( string , accountId , extraId , listener , highlightOption ) ; break ; } default : { return ; } } }
public void postProcess ( ) { if ( foreignColumnName != null ) { foreignAutoRefresh = BOOL_ ; } if ( foreignAutoRefresh && maxForeignAutoRefreshLevel == DatabaseField . NO_MAX_FOREIGN_AUTO_REFRESH_LEVEL_SPECIFIED ) { maxForeignAutoRefreshLevel = DatabaseField . DEFAULT_MAX_FOREIGN_AUTO_REFRESH_LEVEL ; } }
public boolean contains ( Node s ) { runTo ( - NUM_ ) ; if ( null == m_map ) return BOOL_ ; for ( int i = NUM_ ; i < m_firstFree ; i ++ ) { Node node = m_map [ i ] ; if ( ( null != node ) && node . equals ( s ) ) return BOOL_ ; } return BOOL_ ; }
private void persistNewTemp ( File fileCfg ) { if ( hsDeleteOnExit . size ( ) == NUM_ ) { logDebug ( LogArea . CONFIG , STR_ ) ; fileCfg . delete ( ) ; return ; } logDebug ( LogArea . CONFIG , STR_ , hsDeleteOnExit . size ( ) , fileCfg . getAbsolutePath ( ) ) ; BufferedWriter writer = null ; try { writer = new BufferedWriter ( new FileWriter ( fileCfg ) ) ; for ( File file : hsDeleteOnExit ) { if ( ! file . delete ( ) ) { String f = file . getCanonicalPath ( ) ; writer . write ( f ) ; writer . newLine ( ) ; logWarn ( LogArea . JAR , STR_ , f ) ; } } } catch ( IOException e ) { } finally { if ( writer != null ) { try { writer . close ( ) ; } catch ( IOException e ) { } } } }
public static double clamp ( double value , double low , double high ) { return Math . min ( Math . max ( value , low ) , high ) ; }
public void addWritten ( byte [ ] value ) { writeSetLock . lock ( ) ; writeSet . add ( new TimestampValuePair ( ets , value ) ) ; writeSetLock . unlock ( ) ; }
public void load ( Entity unit ) throws IllegalArgumentException { if ( ! canLoad ( unit ) ) { throw new IllegalArgumentException ( STR_ + unit . getShortName ( ) + STR_ ) ; } currentSpace -= NUM_ ; troops . addElement ( unit . getId ( ) ) ; }
private void processWorkerExit ( Worker w , boolean completedAbruptly ) { if ( completedAbruptly ) decrementWorkerCount ( ) ; final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { completedTaskCount += w . completedTasks ; workers . remove ( w ) ; } finally { mainLock . unlock ( ) ; } tryTerminate ( ) ; int c = ctl . get ( ) ; if ( runStateLessThan ( c , STOP ) ) { if ( ! completedAbruptly ) { int min = allowCoreThreadTimeOut ? NUM_ : corePoolSize ; if ( min == NUM_ && ! workQueue . isEmpty ( ) ) min = NUM_ ; if ( workerCountOf ( c ) >= min ) return ; } addWorker ( null , BOOL_ ) ; } }
public void finish ( ) throws IOException { if ( ! def . finished ( ) ) { def . finish ( ) ; while ( ! def . finished ( ) ) { int len = def . deflate ( buf , NUM_ , buf . length ) ; if ( def . finished ( ) && len <= buf . length - TRAILER_SIZE ) { writeTrailer ( buf , len ) ; len = len + TRAILER_SIZE ; out . write ( buf , NUM_ , len ) ; return ; } if ( len > NUM_ ) out . write ( buf , NUM_ , len ) ; } byte [ ] trailer = new byte [ TRAILER_SIZE ] ; writeTrailer ( trailer , NUM_ ) ; out . write ( trailer ) ; } }
public boolean free ( T obj ) { AtomicInteger topRef = _top ; while ( BOOL_ ) { final int top = topRef . get ( ) ; if ( _capacity <= top ) { return BOOL_ ; } boolean isFree = _freeStack . compareAndSet ( top , null , obj ) ; topRef . compareAndSet ( top , top + NUM_ ) ; if ( isFree ) { return BOOL_ ; } } }
public static boolean hasBinding ( Injector injector , Key < ? > key ) { Binding < ? > binding = getBinding ( injector , key ) ; return binding != null ; }
private OpenReplicatorManagerMBean createInternalService ( String serviceName ) throws ReplicatorException { logger . info ( STR_ + serviceName ) ; try { OpenReplicatorManager orm = new OpenReplicatorManager ( serviceName ) ; orm . setRmiHost ( managerRMIHost ) ; orm . setRmiPort ( managerRMIPort ) ; orm . setHostTimeZone ( hostTimeZone ) ; orm . setReplicatorTimeZone ( replicatorTimeZone ) ; orm . advertiseInternal ( ) ; orm . setSecurityInfo ( this . securityInfo ) ; return ( OpenReplicatorManagerMBean ) orm ; } catch ( Exception e ) { throw new ReplicatorException ( String . format ( STR_ , serviceName ) , e ) ; } }
public static CheckIndex . Status checkIndex ( Directory dir ) throws IOException { return checkIndex ( dir , BOOL_ ) ; }
static void policyChanged ( String serviceTypeName , PolicyEvent pe ) { if ( DEBUG . messageEnabled ( ) ) { DEBUG . message ( STR_ + serviceTypeName ) ; } resourceNamesMap . remove ( serviceTypeName ) ; Cache resourceNamesCache = ( Cache ) resourceNamesMap . get ( serviceTypeName ) ; if ( ( resourceNamesCache == null ) || ( resourceNamesCache . isEmpty ( ) ) ) { return ; } try { DEBUG . error ( STR_ ) ; ServiceTypeManager stm = ServiceTypeManager . getServiceTypeManager ( ) ; ServiceType serviceType = stm . getServiceType ( serviceTypeName ) ; Set resourceNamesToRemove = new HashSet ( ) ; synchronized ( resourceNamesCache ) { Enumeration resourceNames = resourceNamesCache . keys ( ) ; while ( resourceNames . hasMoreElements ( ) ) { String resourceName = ( String ) resourceNames . nextElement ( ) ; if ( resourceNamesToRemove . contains ( resourceName ) ) { continue ; } Set affectedResourceNames = pe . getResourceNames ( ) ; Iterator iter = affectedResourceNames . iterator ( ) ; while ( iter . hasNext ( ) ) { String affectedResourceName = ( String ) iter . next ( ) ; if ( serviceType . compare ( resourceName , affectedResourceName ) != ResourceMatch . NO_MATCH ) { resourceNamesToRemove . add ( resourceName ) ; } } } Iterator iter1 = resourceNamesToRemove . iterator ( ) ; while ( iter1 . hasNext ( ) ) { String resourceNameToRemove = ( String ) iter1 . next ( ) ; resourceNamesCache . remove ( resourceNameToRemove ) ; } } } catch ( SSOException e ) { DEBUG . error ( STR_ , e ) ; } catch ( PolicyException pex ) { DEBUG . error ( STR_ , pex ) ; } if ( DEBUG . messageEnabled ( ) ) { DEBUG . message ( STR_ + serviceTypeName + STR_ + resourceNamesMap . get ( serviceTypeName ) ) ; } }
private void startHideAnimations ( ) { animationPlaying = BOOL_ ; lightAnimationLayout ( ) ; if ( buttonType . equals ( ButtonType . CIRCLE ) ) { if ( hideOrderType . equals ( OrderType . DEFAULT ) ) { for ( int i = NUM_ ; i < buttonNum ; i ++ ) { setHideAnimation ( dots [ i ] , circleButtons [ i ] , endLocations [ i ] , startLocations [ i ] , i ) ; } } else if ( hideOrderType . equals ( OrderType . REVERSE ) ) { for ( int i = NUM_ ; i < buttonNum ; i ++ ) { setHideAnimation ( dots [ i ] , circleButtons [ i ] , endLocations [ i ] , startLocations [ i ] , buttonNum - i - NUM_ ) ; } } else if ( hideOrderType . equals ( OrderType . RANDOM ) ) { Random random = new Random ( ) ; boolean [ ] used = new boolean [ buttonNum ] ; for ( int i = NUM_ ; i < buttonNum ; i ++ ) used [ i ] = BOOL_ ; int count = NUM_ ; while ( BOOL_ ) { int i = random . nextInt ( buttonNum ) ; if ( ! used [ i ] ) { used [ i ] = BOOL_ ; setHideAnimation ( dots [ count ] , circleButtons [ count ] , endLocations [ count ] , startLocations [ count ] , i ) ; count ++ ; if ( count == buttonNum ) break ; } } } } else if ( buttonType . equals ( ButtonType . HAM ) ) { if ( hideOrderType . equals ( OrderType . DEFAULT ) ) { for ( int i = NUM_ ; i < buttonNum ; i ++ ) { setHideAnimation ( bars [ i ] , hamButtons [ i ] , endLocations [ i ] , startLocations [ i ] , i ) ; } } else if ( hideOrderType . equals ( OrderType . REVERSE ) ) { for ( int i = NUM_ ; i < buttonNum ; i ++ ) { setHideAnimation ( bars [ i ] , hamButtons [ i ] , endLocations [ i ] , startLocations [ i ] , buttonNum - i - NUM_ ) ; } } else if ( hideOrderType . equals ( OrderType . RANDOM ) ) { Random random = new Random ( ) ; boolean [ ] used = new boolean [ buttonNum ] ; for ( int i = NUM_ ; i < buttonNum ; i ++ ) used [ i ] = BOOL_ ; int count = NUM_ ; while ( BOOL_ ) { int i = random . nextInt ( buttonNum ) ; if ( ! used [ i ] ) { used [ i ] = BOOL_ ; setHideAnimation ( bars [ count ] , hamButtons [ count ] , endLocations [ count ] , startLocations [ count ] , i ) ; count ++ ; if ( count == buttonNum ) break ; } } } } }
public TaggedOutputStream ( OutputStream proxy ) { super ( proxy ) ; }
public List < MType > build ( ) { isClean = BOOL_ ; if ( ! isMessagesListMutable && builders == null ) { return messages ; } boolean allMessagesInSync = BOOL_ ; if ( ! isMessagesListMutable ) { for ( int i = NUM_ ; i < messages . size ( ) ; i ++ ) { Message message = messages . get ( i ) ; SingleFieldBuilder < MType , BType , IType > builder = builders . get ( i ) ; if ( builder != null ) { if ( builder . build ( ) != message ) { allMessagesInSync = BOOL_ ; break ; } } } if ( allMessagesInSync ) { return messages ; } } ensureMutableMessageList ( ) ; for ( int i = NUM_ ; i < messages . size ( ) ; i ++ ) { messages . set ( i , getMessage ( i , BOOL_ ) ) ; } messages = Collections . unmodifiableList ( messages ) ; isMessagesListMutable = BOOL_ ; return messages ; }
public static void putShort ( long addr , short val ) { if ( UNALIGNED ) UNSAFE . putShort ( addr , val ) ; else putShortByByte ( addr , val , BIG_ENDIAN ) ; }
public static byte [ ] hashTwice ( byte [ ] input , int offset , int length ) { MessageDigest digest = newDigest ( ) ; digest . update ( input , offset , length ) ; return digest . digest ( digest . digest ( ) ) ; }
public PronounceableFSM ( URL url , boolean scanFromFront ) throws IOException { this . scanFromFront = scanFromFront ; InputStream is = Utilities . getInputStream ( url ) ; loadText ( is ) ; is . close ( ) ; }
private char [ ] applyFloatPadding ( final char [ ] ca4 , final boolean noDigits ) { char [ ] ca5 = ca4 ; if ( fieldWidthSet ) { int i ; int j ; final int nBlanks ; if ( leftJustify ) { nBlanks = fieldWidth - ca4 . length ; if ( nBlanks > NUM_ ) { ca5 = new char [ ca4 . length + nBlanks ] ; for ( i = NUM_ ; i < ca4 . length ; i ++ ) { ca5 [ i ] = ca4 [ i ] ; } for ( j = NUM_ ; j < nBlanks ; j ++ , i ++ ) { ca5 [ i ] = STR_ ; } } } else if ( ! leadingZeros || noDigits ) { nBlanks = fieldWidth - ca4 . length ; if ( nBlanks > NUM_ ) { ca5 = new char [ ca4 . length + nBlanks ] ; for ( i = NUM_ ; i < nBlanks ; i ++ ) { ca5 [ i ] = STR_ ; } for ( j = NUM_ ; j < ca4 . length ; i ++ , j ++ ) { ca5 [ i ] = ca4 [ j ] ; } } } else if ( leadingZeros ) { nBlanks = fieldWidth - ca4 . length ; if ( nBlanks > NUM_ ) { ca5 = new char [ ca4 . length + nBlanks ] ; i = NUM_ ; j = NUM_ ; if ( ca4 [ NUM_ ] == STR_ ) { ca5 [ NUM_ ] = STR_ ; i ++ ; j ++ ; } for ( int k = NUM_ ; k < nBlanks ; i ++ , k ++ ) { ca5 [ i ] = STR_ ; } for ( ; j < ca4 . length ; i ++ , j ++ ) { ca5 [ i ] = ca4 [ j ] ; } } } } return ca5 ; }
public Object put ( String key , Object value ) { final int len = key . length ( ) ; if ( len > m_charBuffer . length ) { m_charBuffer = new char [ len ] ; } Node node = m_Root ; for ( int i = NUM_ ; i < len ; i ++ ) { Node nextNode = node . m_nextChar [ Character . toLowerCase ( key . charAt ( i ) ) ] ; if ( nextNode != null ) { node = nextNode ; } else { for ( ; i < len ; i ++ ) { Node newNode = new Node ( ) ; if ( m_lowerCaseOnly ) { node . m_nextChar [ Character . toLowerCase ( key . charAt ( i ) ) ] = newNode ; } else { node . m_nextChar [ Character . toUpperCase ( key . charAt ( i ) ) ] = newNode ; node . m_nextChar [ Character . toLowerCase ( key . charAt ( i ) ) ] = newNode ; } node = newNode ; } break ; } } Object ret = node . m_Value ; node . m_Value = value ; return ret ; }
@ Override public void makeImmutable ( ) { if ( isMutable ) { if ( authnStatements != null ) { int length = authnStatements . size ( ) ; for ( int i = NUM_ ; i < length ; i ++ ) { AuthnStatement authn = ( AuthnStatement ) authnStatements . get ( i ) ; authn . makeImmutable ( ) ; } authnStatements = Collections . unmodifiableList ( authnStatements ) ; } if ( authzDecisionStatements != null ) { int length = authzDecisionStatements . size ( ) ; for ( int i = NUM_ ; i < length ; i ++ ) { AuthzDecisionStatement authz = ( AuthzDecisionStatement ) authzDecisionStatements . get ( i ) ; authz . makeImmutable ( ) ; } authzDecisionStatements = Collections . unmodifiableList ( authzDecisionStatements ) ; } if ( attributeStatements != null ) { int length = attributeStatements . size ( ) ; for ( int i = NUM_ ; i < length ; i ++ ) { AttributeStatement attr = ( AttributeStatement ) attributeStatements . get ( i ) ; attr . makeImmutable ( ) ; } attributeStatements = Collections . unmodifiableList ( attributeStatements ) ; } if ( statements != null ) { statements = Collections . unmodifiableList ( statements ) ; } if ( conditions != null ) { conditions . makeImmutable ( ) ; } if ( issuer != null ) { issuer . makeImmutable ( ) ; } if ( subject != null ) { subject . makeImmutable ( ) ; } if ( advice != null ) { advice . makeImmutable ( ) ; } isMutable = BOOL_ ; } }
@ Override public String findLibrary ( String name ) { String systemName = System . mapLibraryName ( name ) ; ArrayList < Loader > loaders = getLoaders ( ) ; for ( int i = NUM_ ; i < loaders . size ( ) ; i ++ ) { Loader loader = loaders . get ( i ) ; Path path = loader . getPath ( systemName ) ; if ( path != null && path . canRead ( ) ) { return path . getNativePath ( ) ; } path = loader . getPath ( STR_ + systemName ) ; if ( path != null && path . canRead ( ) ) { return path . getNativePath ( ) ; } } for ( int i = NUM_ ; i < _nativePath . size ( ) ; i ++ ) { Path path = _nativePath . get ( i ) ; if ( path . canRead ( ) ) return path . getNativePath ( ) ; } return super . findLibrary ( name ) ; }
public void removeComponentListener ( final ComponentUpdateListener listener ) { componentListeners . remove ( listener ) ; }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case NUM_ : return APPKEY ; case NUM_ : return SEND_TIME ; case NUM_ : return LOAD_INFO ; case NUM_ : return STATUS ; default : return null ; } }
public static boolean isEmpty ( CharSequence text ) { return text == null || text . length ( ) == NUM_ ; }
protected byte [ ] assertEncodeDecode ( final IGangliaMetadataMessage decl , final IGangliaMessage expected ) { if ( expected == null ) throw new IllegalArgumentException ( ) ; final XDROutputBuffer xdr = new XDROutputBuffer ( IGangliaDefaults . BUFFER_SIZE ) ; final GangliaMessageEncoder31 messageEncoder = new GangliaMessageEncoder31 ( ) ; final GangliaMessageDecoder31 messageDecoder = new GangliaMessageDecoder31 ( ) ; if ( expected . isMetricRequest ( ) ) { messageEncoder . writeRequest ( xdr , ( IGangliaRequestMessage ) expected ) ; } else if ( expected . isMetricMetadata ( ) ) { messageEncoder . writeMetadata ( xdr , ( IGangliaMetadataMessage ) expected ) ; } else if ( expected . isMetricValue ( ) ) { if ( decl == null ) throw new IllegalArgumentException ( STR_ ) ; messageEncoder . writeMetric ( xdr , decl , ( IGangliaMetricMessage ) expected ) ; } else { throw new AssertionError ( ) ; } final IGangliaMessage actual = messageDecoder . decode ( xdr . getBuffer ( ) , NUM_ , xdr . getLength ( ) ) ; assertEquals ( STR_ , expected , actual ) ; final byte [ ] actualData = new byte [ xdr . getLength ( ) ] ; System . arraycopy ( xdr . getBuffer ( ) , NUM_ , actualData , NUM_ , actualData . length ) ; return actualData ; }
private boolean isIndexable ( String term ) { return ( term . length ( ) < NUM_ ) && ( term . length ( ) > NUM_ ) ; }
private void sendResponse ( String status , String mime , Properties header , InputStream data ) { try { if ( status == null ) throw new Error ( STR_ ) ; OutputStream out = mySocket . getOutputStream ( ) ; PrintWriter pw = new PrintWriter ( out ) ; pw . print ( STR_ + status + STR_ ) ; if ( mime != null ) pw . print ( STR_ + mime + STR_ ) ; if ( header == null || header . getProperty ( STR_ ) == null ) pw . print ( STR_ + gmtFrmt . format ( new Date ( ) ) + STR_ ) ; if ( header != null ) { Enumeration e = header . keys ( ) ; while ( e . hasMoreElements ( ) ) { String key = ( String ) e . nextElement ( ) ; String value = header . getProperty ( key ) ; pw . print ( key + STR_ + value + STR_ ) ; } } pw . print ( STR_ ) ; pw . flush ( ) ; if ( data != null ) { byte [ ] buff = new byte [ NUM_ ] ; while ( BOOL_ ) { int read = data . read ( buff , NUM_ , NUM_ ) ; if ( read <= NUM_ ) break ; out . write ( buff , NUM_ , read ) ; } } out . flush ( ) ; out . close ( ) ; if ( data != null ) data . close ( ) ; } catch ( IOException ioe ) { try { mySocket . close ( ) ; } catch ( Throwable t ) { } } }
public static String decode ( String encoded , AMEncryption encr ) { if ( checkCaller ( ) ) { try { ISSecurityPermission isp = new ISSecurityPermission ( STR_ , STR_ ) ; if ( securityManager != null ) { securityManager . checkPermission ( isp ) ; } } catch ( SecurityException e ) { Debug debug = Debug . getInstance ( STR_ ) ; debug . error ( STR_ + STR_ , e ) ; return null ; } } if ( encoded == null || encoded . length ( ) == NUM_ ) { return ( null ) ; } byte [ ] encData = null ; encData = Base64 . decode ( encoded . trim ( ) ) ; if ( encData == null ) { return null ; } byte [ ] rawData = encr . decrypt ( encData ) ; if ( rawData == null ) { return ( null ) ; } String answer = null ; try { answer = new String ( rawData , STR_ ) ; } catch ( UnsupportedEncodingException uue ) { Debug debug = Debug . getInstance ( STR_ ) ; debug . error ( STR_ , uue ) ; answer = new String ( rawData ) ; } return ( answer ) ; }
protected void waitForShutdownSignal ( ) throws InterruptedException { if ( mutexWaiting == null ) mutexWaiting = new Object ( ) ; try { synchronized ( mutexWaiting ) { mutexWaiting . wait ( ) ; } } catch ( InterruptedException e ) { if ( ! shutdown ) throw e ; } }
public void addConnection ( Connection connection ) { if ( connection == null ) throw new IllegalArgumentException ( STR_ ) ; synchronized ( connectionsLock ) { Connection [ ] newConnections = new Connection [ connections . length + NUM_ ] ; newConnections [ NUM_ ] = connection ; System . arraycopy ( connections , NUM_ , newConnections , NUM_ , connections . length ) ; connections = newConnections ; } connection . addListener ( invokeListener ) ; if ( TRACE ) trace ( STR_ , STR_ + connection ) ; }
private void writeAttribute ( java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( namespace . equals ( STR_ ) ) { xmlWriter . writeAttribute ( attName , attValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } }
private static int convertToInt ( String value , int defaultValue ) { String trim = value . trim ( ) ; if ( trim . length ( ) == NUM_ ) { return defaultValue ; } return Integer . parseInt ( trim ) ; }
public ChainIterable < T > addItem ( @ NotNull T item ) { return ( ChainIterable < T > ) super . add ( Collections . < T > singleton ( item ) ) ; }
private void updateStateView ( int itCount , Collection < Individual < Double > > gen ) { Platform . runLater ( null ) ; simPaneCtrl . waitAfterStep ( ) ; }
@ Override public void run ( ) { try { for ( ; ; ) { int n = portGetn ( port , bufferAddress , MAX_EVENT_COUNT ) ; assert n > NUM_ ; long address = bufferAddress ; for ( int i = NUM_ ; i < n ; i ++ ) { boolean shutdown = processEvent ( address ) ; if ( shutdown ) return ; address += SIZEOF_PORT_EVENT ; } } } catch ( UnixException x ) { x . printStackTrace ( ) ; } }
@ Override public List < String > allKeys ( ) { List < String > nameFiles = new ArrayList < > ( ) ; File [ ] files = cacheDirectory . listFiles ( ) ; if ( files == null ) return nameFiles ; for ( File file : files ) { if ( file . isFile ( ) ) { nameFiles . add ( file . getName ( ) ) ; } } return nameFiles ; }
public DialogueRecorder ( DialogueSystem system ) { this . settings = system . getSettings ( ) ; }
private String generateUniqueFutureId ( ) { return String . valueOf ( mIdCounter . getAndIncrement ( ) ) ; }
private static final void rescheduleMissedAlarms ( ContentResolver cr , Context context , AlarmManagerInterface manager ) { long now = System . currentTimeMillis ( ) ; long ancient = now - DateUtils . DAY_IN_MILLIS ; String [ ] projection = new String [ ] { CalendarContract . CalendarAlerts . ALARM_TIME } ; if ( Build . VERSION . SDK_INT >= NUM_ && ContextCompat . checkSelfPermission ( context , Manifest . permission . READ_CALENDAR ) != PackageManager . PERMISSION_GRANTED ) { Log . d ( TAG , STR_ ) ; return ; } Cursor cursor = cr . query ( CalendarAlerts . CONTENT_URI , projection , WHERE_RESCHEDULE_MISSED_ALARMS , ( new String [ ] { Long . toString ( now ) , Long . toString ( ancient ) , Long . toString ( now ) } ) , SORT_ORDER_ALARMTIME_ASC ) ; if ( cursor == null ) { return ; } if ( DEBUG ) { Log . d ( TAG , STR_ + cursor . getCount ( ) ) ; } try { long alarmTime = - NUM_ ; while ( cursor . moveToNext ( ) ) { long newAlarmTime = cursor . getLong ( NUM_ ) ; if ( alarmTime != newAlarmTime ) { if ( DEBUG ) { Log . w ( TAG , STR_ + newAlarmTime ) ; } AlertUtils . scheduleAlarm ( context , manager , newAlarmTime ) ; alarmTime = newAlarmTime ; } } } finally { cursor . close ( ) ; } }
public void addName ( String name ) { m_names . add ( name ) ; }
@ Override default CompletableFuture < OptionalDouble > minDouble ( final ToDoubleFunction < ? super T > fn ) { return CompletableFuture . supplyAsync ( null , getExec ( ) ) ; }
private boolean toState ( LifecycleState newState ) { LifecycleState state ; synchronized ( this ) { state = _state ; _state = newState ; _lastChangeTime = CurrentTime . currentTime ( ) ; } if ( _log != null && _log . isLoggable ( _lowLevel ) ) { _log . log ( _lowLevel , newState + STR_ + _name ) ; } notifyListeners ( state , newState ) ; return BOOL_ ; }
public boolean initDialog ( ) { log . config ( STR_ ) ; gbc . anchor = GridBagConstraints . NORTHWEST ; gbc . weightx = NUM_ ; gbc . weighty = NUM_ ; gbc . gridy = m_line ++ ; gbc . gridx = NUM_ ; gbc . gridwidth = NUM_ ; gbc . insets = nullInset ; gbc . fill = GridBagConstraints . HORIZONTAL ; centerPanel . add ( Box . createVerticalStrut ( NUM_ ) , gbc ) ; MClient client = MClient . get ( Env . getCtx ( ) ) ; String ASPFilter = STR_ ; if ( client . isUseASP ( ) ) ASPFilter = STR_ + STR_ + STR_ + STR_ + STR_ + client . getAD_Client_ID ( ) + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + client . getAD_Client_ID ( ) + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + client . getAD_Client_ID ( ) + STR_ + STR_ + STR_ + STR_ + STR_ ; String sql = null ; if ( Env . isBaseLanguage ( Env . getCtx ( ) , STR_ ) ) sql = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + ASPFilter + STR_ ; else sql = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + Env . getAD_Language ( Env . getCtx ( ) ) + STR_ + STR_ + ASPFilter + STR_ ; boolean hasFields = BOOL_ ; try { PreparedStatement pstmt = DB . prepareStatement ( sql , null ) ; pstmt . setInt ( NUM_ , m_processInfo . getAD_Process_ID ( ) ) ; ResultSet rs = pstmt . executeQuery ( ) ; while ( rs . next ( ) ) { hasFields = BOOL_ ; createField ( rs ) ; } rs . close ( ) ; pstmt . close ( ) ; } catch ( SQLException e ) { log . log ( Level . SEVERE , sql , e ) ; } if ( m_mFields . size ( ) != m_mFields2 . size ( ) || m_mFields . size ( ) != m_vEditors . size ( ) || m_mFields2 . size ( ) != m_vEditors2 . size ( ) ) log . log ( Level . SEVERE , STR_ ) ; if ( hasFields ) { gbc . gridy = m_line ++ ; centerPanel . add ( Box . createVerticalStrut ( NUM_ ) , gbc ) ; gbc . gridx = NUM_ ; centerPanel . add ( Box . createHorizontalStrut ( NUM_ ) , gbc ) ; AEnv . positionCenterWindow ( m_frame , this ) ; } else dispose ( ) ; return hasFields ; }
@ Override protected String dateToString ( DateTimeData date ) { StringBuffer message = new StringBuffer ( NUM_ ) ; message . append ( STR_ ) ; message . append ( STR_ ) ; append ( message , date . month , NUM_ ) ; append ( message , ( char ) date . utc , NUM_ ) ; return message . toString ( ) ; }
private void addTest ( Test newTest ) { if ( m_RuleList == null ) { m_RuleList = new ArrayList < Test > ( ) ; } m_RuleList . add ( newTest ) ; }
public void swap ( int i , int j ) { x . assertTrue ( i < list . size ( ) ) ; x . assertTrue ( j < list . size ( ) ) ; list . set ( i , list . set ( j , list . get ( i ) ) ) ; }
private List < NameValuePair > buildIPTParameters ( Ipt ipt , String organisationKey ) { List < NameValuePair > data = new ArrayList < NameValuePair > ( ) ; if ( ipt != null && organisationKey != null ) { data . add ( new BasicNameValuePair ( STR_ , StringUtils . trimToEmpty ( organisationKey ) ) ) ; data . add ( new BasicNameValuePair ( STR_ , StringUtils . trimToEmpty ( ipt . getName ( ) ) ) ) ; data . add ( new BasicNameValuePair ( STR_ , StringUtils . trimToEmpty ( ipt . getDescription ( ) ) ) ) ; data . add ( new BasicNameValuePair ( STR_ , StringUtils . trimToEmpty ( ipt . getPrimaryContactType ( ) ) ) ) ; data . add ( new BasicNameValuePair ( STR_ , StringUtils . trimToEmpty ( ipt . getPrimaryContactName ( ) ) ) ) ; data . add ( new BasicNameValuePair ( STR_ , StringUtils . trimToEmpty ( ipt . getPrimaryContactEmail ( ) ) ) ) ; data . add ( new BasicNameValuePair ( STR_ , SERVICE_TYPE_RSS ) ) ; data . add ( new BasicNameValuePair ( STR_ , getRssFeedURL ( ) ) ) ; } else { log . debug ( STR_ ) ; } return data ; }
public static < T , U extends Closeable > T withCloseable ( U self , @ ClosureParams ( value = FirstParam . class ) Closure < T > action ) throws IOException { try { T result = action . call ( self ) ; Closeable temp = self ; self = null ; temp . close ( ) ; return result ; } finally { DefaultGroovyMethodsSupport . closeWithWarning ( self ) ; } }
public static boolean isMatch ( String actualString , LinkedList patterns , char wildCard ) { boolean matched = BOOL_ ; for ( ListIterator iter = patterns . listIterator ( NUM_ ) ; iter . hasNext ( ) ; ) { if ( isMatch ( actualString , ( String ) iter . next ( ) , wildCard ) ) { matched = BOOL_ ; break ; } } return matched ; }
public synchronized void addServer ( ServerLocation location , String [ ] groups , ServerLoad initialLoad , long loadPollInterval ) { serverGroupMap . put ( location , groups ) ; LoadHolder connectionLoad = new LoadHolder ( location , initialLoad . getConnectionLoad ( ) , initialLoad . getLoadPerConnection ( ) , loadPollInterval ) ; addGroups ( connectionLoadMap , groups , connectionLoad ) ; LoadHolder queueLoad = new LoadHolder ( location , initialLoad . getSubscriptionConnectionLoad ( ) , initialLoad . getLoadPerSubscriptionConnection ( ) , loadPollInterval ) ; addGroups ( queueLoadMap , groups , queueLoad ) ; updateLoad ( location , initialLoad ) ; }
public void addLeaf ( CatalogTreeLeaf leaf ) { _leaves . add ( leaf ) ; }
private static String stampToString ( long tstamp , String formatMask ) { StringBuilder sb = new StringBuilder ( NUM_ ) ; Formatter fmt = new Formatter ( sb , Locale . US ) ; int [ ] pieces = new int [ NUMIDX ] ; ComponentTime . unpackBits ( tstamp , pieces ) ; fmt . format ( formatMask , pieces [ YIDX ] , pieces [ MIDX ] , pieces [ DIDX ] , pieces [ HIDX ] , pieces [ IIDX ] , pieces [ SIDX ] , pieces [ UIDX ] ) ; fmt . close ( ) ; return ( sb . toString ( ) ) ; }
public HttpRequest contentLength ( final String value ) { return contentLength ( Integer . parseInt ( value ) ) ; }
public boolean draw ( Canvas canvas ) { update ( ) ; final float centerX = mBounds . centerX ( ) ; final float centerY = mBounds . height ( ) - mRadius ; canvas . scale ( NUM_ , Math . min ( mGlowScaleY , NUM_ ) . mBaseGlowScale , centerX , NUM_ ) ; final float displacement = Math . max ( NUM_ , Math . min ( mDisplacement , NUM_ ) ) - NUM_ ; float translateX = mBounds . width ( ) . displacement / NUM_ ; mPaint . setAlpha ( ( int ) ( xff . mGlowAlpha ) ) ; canvas . drawCircle ( centerX + translateX , centerY , mRadius , mPaint ) ; boolean oneLastFrame = BOOL_ ; if ( mState == STATE_RECEDE && mGlowScaleY == NUM_ ) { mState = STATE_IDLE ; oneLastFrame = BOOL_ ; } return mState != STATE_IDLE || oneLastFrame ; }
public VNXeCommandJob modifyLunAsync ( LunModifyParam param , String resourceId ) { StringBuilder urlBld = new StringBuilder ( URL_RESOURCE ) ; urlBld . append ( resourceId ) ; urlBld . append ( URL_LUN_MODIFY_ACTION ) ; _url = urlBld . toString ( ) ; return postRequestAsync ( param ) ; }
public String replace ( CharSequence target , CharSequence replacement ) { if ( target == null ) { throw new NullPointerException ( STR_ ) ; } if ( replacement == null ) { throw new NullPointerException ( STR_ ) ; } String ts = target . toString ( ) ; int index = indexOf ( ts , NUM_ ) ; if ( index == - NUM_ ) return this ; String rs = replacement . toString ( ) ; StringBuilder buffer = new StringBuilder ( count ) ; int tl = target . length ( ) ; int tail = NUM_ ; do { buffer . append ( value , offset + tail , index - tail ) ; buffer . append ( rs ) ; tail = index + tl ; } while ( ( index = indexOf ( ts , tail ) ) != - NUM_ ) ; buffer . append ( value , offset + tail , count - tail ) ; return buffer . toString ( ) ; }
public void delete ( ) throws IOException { close ( ) ; deleteContents ( directory ) ; }
public boolean similarTo ( Object o ) { if ( o == null ) { return BOOL_ ; } if ( ! ( o instanceof SemanticConcept ) ) { return BOOL_ ; } SemanticConcept otherConcept = ( SemanticConcept ) o ; HashSet < Integer > synset_intersection = new HashSet < Integer > ( this . synsets ) ; synset_intersection . retainAll ( otherConcept . synsets ) ; if ( ! synset_intersection . isEmpty ( ) ) { return BOOL_ ; } HashSet < String > concept_intersection = new HashSet < String > ( this . concepts ) ; concept_intersection . retainAll ( otherConcept . concepts ) ; return ! concept_intersection . isEmpty ( ) ; }
public void jGoogleAnalyticsTracker ( final String eventType , final String version , final String trackerId ) { final JGoogleAnalyticsTracker tracker = new JGoogleAnalyticsTracker ( STR_ , version , trackerId ) ; final FocusPoint focusPoint = new FocusPoint ( eventType . toLowerCase ( ) ) ; tracker . trackAsynchronously ( focusPoint ) ; }
protected final Tuple addInternal ( Tuple t ) { if ( m_tuples . add ( t ) ) { return t ; } else { return null ; } }
public void put ( Song song ) { if ( ! mSongs . contains ( song ) ) { mSongs . add ( song ) ; } }
@ NotNull public PsiQuery childrenNamed ( @ NotNull final Class < ? extends PsiNamedElement > clazz , @ NotNull final String name ) { final List < PsiElement > result = new ArrayList < PsiElement > ( ) ; for ( final PsiElement element : myPsiElements ) { for ( final PsiNamedElement child : PsiTreeUtil . findChildrenOfType ( element , clazz ) ) { if ( name . equals ( child . getName ( ) ) ) { result . add ( child ) ; } } } return new PsiQuery ( result . toArray ( new PsiElement [ result . size ( ) ] ) ) ; }
private void emitMapPut ( Method method , String fieldName , StringBuilder builder ) { builder . append ( STR_ ) ; builder . append ( getMapPutterName ( fieldName ) ) ; builder . append ( STR_ ) ; builder . append ( getTypeArgumentImplName ( ( ParameterizedType ) method . getGenericReturnType ( ) , NUM_ ) ) ; builder . append ( STR_ ) ; builder . append ( getEnsureName ( fieldName ) ) ; builder . append ( STR_ ) ; builder . append ( fieldName ) ; builder . append ( STR_ ) ; builder . append ( STR_ ) ; }
@ Override public boolean equals ( Object o ) { return o . hashCode ( ) == hashCode ( ) ; }
@ Override public String toString ( ) { if ( getUserObject ( ) instanceof TvShow ) { TvShow tvShow = ( TvShow ) getUserObject ( ) ; return tvShow . getTitle ( ) ; } return super . toString ( ) ; }
private ArrayList < String > parseJson ( String text ) { text = text . substring ( text . indexOf ( STR_ ) + SIZE_OF_EVENTS , text . indexOf ( STR_ ) ) ; ArrayList < String > events = new ArrayList < String > ( ) ; if ( text . isEmpty ( ) ) { return events ; } int startIndex = NUM_ , endIndex = NUM_ ; while ( endIndex != - NUM_ ) { endIndex = text . indexOf ( STR_ , startIndex + DELIMITER_SIZE ) ; String eventText = ( endIndex == - NUM_ ? text . substring ( startIndex ) : text . substring ( startIndex , endIndex ) ) ; Pattern pattern = Pattern . compile ( STR_ ) ; Matcher matcher = pattern . matcher ( eventText ) ; eventText = matcher . replaceAll ( STR_ ) ; pattern = Pattern . compile ( STR_ ) ; matcher = pattern . matcher ( eventText ) ; if ( matcher . find ( ) ) { eventText = matcher . replaceFirst ( matcher . group ( NUM_ ) + STR_ ) ; } eventText = STR_ + eventText ; startIndex = endIndex + NUM_ ; events . add ( eventText ) ; } Collections . reverse ( events ) ; return events ; }
@ Override public void removeTableModelListener ( TableModelListener l ) { m_Listeners . remove ( l ) ; }
public StrBuilder replace ( int startIndex , int endIndex , String replaceStr ) { endIndex = validateRange ( startIndex , endIndex ) ; int insertLen = ( replaceStr == null ? NUM_ : replaceStr . length ( ) ) ; replaceImpl ( startIndex , endIndex , endIndex - startIndex , replaceStr , insertLen ) ; return this ; }
public static void addPermissionRecursive ( Path path , PosixFilePermission permission ) throws IOException { changePermissionsRecursive ( path , PermissionChange . ADD , Collections . singleton ( permission ) ) ; }
private void runTimeoutTask ( ) { while ( isActive ( ) ) { reapTimeouts ( ) ; try { Thread . sleep ( _timeoutReapInterval ) ; } catch ( Exception e ) { } } }
public IDevice learnEntity ( long macAddress , Short vlan , Integer ipv4Address , Long switchDPID , Integer switchPort , boolean processUpdates ) { List < IDeviceListener > listeners = deviceListeners . getOrderedListeners ( ) ; if ( ! processUpdates ) { deviceListeners . clearListeners ( ) ; } VlanVid v ; IPv4Address i ; DatapathId d ; OFPort p ; if ( vlan != null && vlan . shortValue ( ) <= NUM_ ) vlan = null ; if ( ipv4Address != null && ipv4Address == NUM_ ) ipv4Address = null ; if ( vlan == null ) { v = VlanVid . ofVlan ( - NUM_ ) ; } else { v = VlanVid . ofVlan ( vlan ) ; } if ( ipv4Address == null ) { i = IPv4Address . NONE ; } else { i = IPv4Address . of ( ipv4Address ) ; } if ( switchDPID == null ) { d = DatapathId . of ( NUM_ ) ; } else { d = DatapathId . of ( switchDPID . longValue ( ) ) ; } if ( switchPort == null ) { p = OFPort . ZERO ; } else { p = OFPort . of ( switchPort ) ; } IDevice res = learnDeviceByEntity ( new Entity ( MacAddress . of ( macAddress ) , v , i , d , p , new Date ( ) ) ) ; if ( listeners != null ) { for ( IDeviceListener listener : listeners ) { deviceListeners . addListener ( STR_ , listener ) ; } } return res ; }
public static boolean isValidTypeSignature ( String sig , boolean allowVoid ) { int len = sig . length ( ) ; return checkTypeSignature ( sig , NUM_ , len , allowVoid ) == len ; }
public void testCase19 ( ) { byte aBytes [ ] = { - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int bSign = - NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . remainder ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public static boolean hasVisibleChildren ( ActionGroup group , PresentationFactory factory , ActionManager actionManager , PerspectiveManager perspectiveManager ) { ActionEvent event = new ActionEvent ( factory . getPresentation ( group ) , actionManager , perspectiveManager ) ; for ( Action anAction : group . getChildren ( event ) ) { if ( anAction == null ) { Log . error ( Utils . class , STR_ + group + STR_ + factory . getPresentation ( group ) ) ; continue ; } if ( anAction instanceof Separator ) { continue ; } final Presentation presentation = factory . getPresentation ( anAction ) ; anAction . update ( new ActionEvent ( presentation , actionManager , perspectiveManager ) ) ; if ( anAction instanceof ActionGroup ) { ActionGroup childGroup = ( ActionGroup ) anAction ; if ( childGroup . isPopup ( ) ) { if ( ! presentation . isVisible ( ) ) { continue ; } } if ( hasVisibleChildren ( childGroup , factory , actionManager , perspectiveManager ) ) { return BOOL_ ; } } else if ( presentation . isVisible ( ) ) { return BOOL_ ; } } return BOOL_ ; }
private static void checkArgReferences ( String typeSnippet , int numberOfArgs ) { Matcher argRefMatcher = ARG_REF_PATTERN . matcher ( typeSnippet ) ; while ( argRefMatcher . find ( ) ) { int index = Integer . parseInt ( argRefMatcher . group ( NUM_ ) , NUM_ ) - NUM_ ; Preconditions . checkArgument ( index >= NUM_ , STR_ , argRefMatcher . group ( NUM_ ) ) ; Preconditions . checkArgument ( index < numberOfArgs , STR_ , argRefMatcher . group ( NUM_ ) ) ; } }
public void randomize ( ) { randomizeIncomingWeights ( ) ; normalizeIncomingWeights ( ) ; }
public static void saveAsImage ( int x , int y , int width , int height , String path , CompressFormat compressFormat , int quality ) throws FileNotFoundException { Bitmap bmp = getPixelsFromBuffer ( x , y , width , height ) ; try { File file = new File ( path ) ; try { file . createNewFile ( ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } FileOutputStream fos = new FileOutputStream ( file ) ; bmp . compress ( compressFormat , quality , fos ) ; try { fos . flush ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } try { fos . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } catch ( FileNotFoundException e ) { throw ( e ) ; } }
private boolean isFileValid ( File file , String methodName ) { if ( file == null ) { Log . printConcatLine ( name , STR_ , methodName , STR_ ) ; return BOOL_ ; } String fileName = file . getName ( ) ; if ( fileName == null || fileName . length ( ) == NUM_ ) { Log . printConcatLine ( name , STR_ + methodName , STR_ ) ; return BOOL_ ; } return BOOL_ ; }
public void removeSrcClass ( SootClass clz ) { srcClasses . remove ( clz . getName ( ) ) ; }
private void updateRange ( double value ) { mMinValue = Math . min ( mMinValue , value ) ; mMaxValue = Math . max ( mMaxValue , value ) ; }
JSONStringer close ( Scope empty , Scope nonempty , String closeBracket ) throws JSONException { Scope context = peek ( ) ; if ( context != nonempty && context != empty ) { throw new JSONException ( STR_ ) ; } stack . remove ( stack . size ( ) - NUM_ ) ; if ( context == nonempty ) { newline ( ) ; } out . append ( closeBracket ) ; return this ; }
public void append ( byte [ ] bytes ) { append ( bytes , NUM_ , bytes . length ) ; }
public static boolean enoughSpaceOnPhone ( long updateSize ) { return getRealSizeOnPhone ( ) > updateSize ; }
public void cancelButtonActionPerformed ( ) { editMode = BOOL_ ; curNode = null ; addButton . setVisible ( BOOL_ ) ; editButton . setVisible ( BOOL_ ) ; deleteButton . setVisible ( BOOL_ ) ; doneButton . setVisible ( BOOL_ ) ; updateButton . setVisible ( BOOL_ ) ; cancelButton . setVisible ( BOOL_ ) ; nodeAddrField . setVisible ( BOOL_ ) ; nodeAddrStatic . setVisible ( BOOL_ ) ; statusText1 . setText ( stdStatus1 ) ; statusText2 . setText ( stdStatus2 ) ; statusText3 . setText ( stdStatus3 ) ; }
public void addAttribute ( AttributedCharacterIterator . Attribute attribute , Object value ) { if ( attribute == null ) { throw new NullPointerException ( STR_ ) ; } if ( text . isEmpty ( ) ) { throw new IllegalArgumentException ( STR_ ) ; } List < Range > ranges = attributeMap . get ( attribute ) ; if ( ranges == null ) { ranges = new ArrayList < Range > ( NUM_ ) ; attributeMap . put ( attribute , ranges ) ; } else { ranges . clear ( ) ; } ranges . add ( new Range ( NUM_ , text . length ( ) , value ) ) ; }
private Object stringToValue ( Object oldValue , String newValue ) throws ReplicatorException { if ( oldValue instanceof String ) { return newValue ; } else if ( oldValue instanceof Integer ) { return Integer . valueOf ( newValue ) ; } else if ( oldValue instanceof SerialBlob ) { try { return DatabaseHelper . getSafeBlob ( newValue . getBytes ( ) ) ; } catch ( SQLException e ) { throw new ReplicatorException ( STR_ + e , e ) ; } } else { return newValue ; } }
public void addNodesInDocOrder ( DTMIterator iterator , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; int node ; while ( DTM . NULL != ( node = iterator . nextNode ( ) ) ) { addNodeInDocOrder ( node , support ) ; } }
public String toZString ( ) { StringBuilder buffer = new StringBuilder ( NUM_ ) ; try { printZ ( buffer ) ; } catch ( IOException e ) { throw new RuntimeException ( STR_ , e ) ; } return buffer . toString ( ) ; }
public TrieDictionary < T > build ( int baseId ) { byte [ ] trieBytes = buildTrieBytes ( baseId ) ; TrieDictionary < T > r = new TrieDictionary < T > ( trieBytes ) ; return r ; }
public void recordState ( DialogueState state , String name ) { states . put ( name , state ) ; if ( ! listModel . contains ( name ) ) { int position = name . contains ( CURRENT ) ? NUM_ : Math . min ( NUM_ , listModel . size ( ) ) ; listModel . add ( position , name ) ; } }
public int writeUTF8 ( final CharSequence chars , int off , int len ) { if ( len > remaining ( ) ) { return writeUTF8Slow ( chars , off , len ) ; } final Block block = current ; int limit = block . limit ; char ch = STR_ ; int octets = NUM_ ; while ( len > NUM_ ) { ch = chars . charAt ( off ) ; if ( ch >= UTF8_2_OCTET_MIN_VALUE ) { break ; } block . data [ limit ++ ] = ( byte ) ch ; octets ++ ; off ++ ; len -- ; } block . limit = limit ; if ( len > NUM_ ) { if ( ch < UTF8_3_OCTET_MIN_VALUE ) { return octets + writeUTF8UpTo2Byte ( chars , off , len ) ; } if ( ch >= LOW_SURROGATE_FIRST && ch <= LOW_SURROGATE_LAST ) { throw new IllegalArgumentException ( STR_ + ch ) ; } if ( ch >= HIGH_SURROGATE_FIRST && ch <= HIGH_SURROGATE_LAST ) { return octets + writeUTF8Slow ( chars , off , len ) ; } return octets + writeUTF8UpTo3Byte ( chars , off , len ) ; } return octets ; }
public GeoServerWPSClient ( GeoServerConnection connection ) { this . connection = connection ; }
protected ConnectionStateSSLv3 ( SSLSessionImpl session ) { try { CipherSuite cipherSuite = session . cipherSuite ; boolean is_exportabe = cipherSuite . isExportable ( ) ; hash_size = cipherSuite . getMACLength ( ) ; int key_size = ( is_exportabe ) ? cipherSuite . keyMaterial : cipherSuite . expandedKeyMaterial ; int iv_size = cipherSuite . ivSize ; block_size = cipherSuite . getBlockSize ( ) ; String algName = cipherSuite . getBulkEncryptionAlgorithm ( ) ; String hashName = cipherSuite . getHashName ( ) ; if ( logger != null ) { logger . println ( STR_ ) ; logger . println ( STR_ + session . getCipherSuite ( ) ) ; logger . println ( STR_ + algName ) ; logger . println ( STR_ + hashName ) ; logger . println ( STR_ + hash_size ) ; logger . println ( STR_ + block_size ) ; logger . println ( STR_ + iv_size ) ; logger . println ( STR_ + key_size ) ; } byte [ ] clientRandom = session . clientRandom ; byte [ ] serverRandom = session . serverRandom ; byte [ ] key_block = new byte [ NUM_ . hash_size + NUM_ . key_size + NUM_ . iv_size ] ; byte [ ] seed = new byte [ clientRandom . length + serverRandom . length ] ; System . arraycopy ( serverRandom , NUM_ , seed , NUM_ , serverRandom . length ) ; System . arraycopy ( clientRandom , NUM_ , seed , serverRandom . length , clientRandom . length ) ; PRF . computePRF_SSLv3 ( key_block , session . master_secret , seed ) ; byte [ ] client_mac_secret = new byte [ hash_size ] ; byte [ ] server_mac_secret = new byte [ hash_size ] ; byte [ ] client_key = new byte [ key_size ] ; byte [ ] server_key = new byte [ key_size ] ; boolean is_client = ! session . isServer ; System . arraycopy ( key_block , NUM_ , client_mac_secret , NUM_ , hash_size ) ; System . arraycopy ( key_block , hash_size , server_mac_secret , NUM_ , hash_size ) ; System . arraycopy ( key_block , NUM_ . hash_size , client_key , NUM_ , key_size ) ; System . arraycopy ( key_block , NUM_ . hash_size + key_size , server_key , NUM_ , key_size ) ; IvParameterSpec clientIV = null ; IvParameterSpec serverIV = null ; if ( is_exportabe ) { if ( logger != null ) { logger . println ( STR_ ) ; } MessageDigest md5 = MessageDigest . getInstance ( STR_ ) ; md5 . update ( client_key ) ; md5 . update ( clientRandom ) ; md5 . update ( serverRandom ) ; client_key = md5 . digest ( ) ; md5 . update ( server_key ) ; md5 . update ( serverRandom ) ; md5 . update ( clientRandom ) ; server_key = md5 . digest ( ) ; key_size = cipherSuite . expandedKeyMaterial ; if ( block_size != NUM_ ) { md5 . update ( clientRandom ) ; md5 . update ( serverRandom ) ; clientIV = new IvParameterSpec ( md5 . digest ( ) , NUM_ , iv_size ) ; md5 . update ( serverRandom ) ; md5 . update ( clientRandom ) ; serverIV = new IvParameterSpec ( md5 . digest ( ) , NUM_ , iv_size ) ; } } else if ( block_size != NUM_ ) { clientIV = new IvParameterSpec ( key_block , NUM_ . hash_size + NUM_ . key_size , iv_size ) ; serverIV = new IvParameterSpec ( key_block , NUM_ . hash_size + NUM_ . key_size + iv_size , iv_size ) ; } if ( logger != null ) { logger . println ( STR_ + is_exportabe ) ; logger . println ( STR_ ) ; logger . print ( session . master_secret ) ; logger . println ( STR_ ) ; logger . print ( clientRandom ) ; logger . println ( STR_ ) ; logger . print ( serverRandom ) ; logger . println ( STR_ ) ; logger . print ( client_mac_secret ) ; logger . println ( STR_ ) ; logger . print ( server_mac_secret ) ; logger . println ( STR_ ) ; logger . print ( client_key , NUM_ , key_size ) ; logger . println ( STR_ ) ; logger . print ( server_key , NUM_ , key_size ) ; if ( clientIV != null ) { logger . println ( STR_ ) ; logger . print ( clientIV . getIV ( ) ) ; logger . println ( STR_ ) ; logger . print ( serverIV . getIV ( ) ) ; } else { logger . println ( STR_ ) ; } } if ( algName == null ) { encCipher = new NullCipher ( ) ; decCipher = new NullCipher ( ) ; } else { encCipher = Cipher . getInstance ( algName ) ; decCipher = Cipher . getInstance ( algName ) ; if ( is_client ) { encCipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( client_key , NUM_ , key_size , algName ) , clientIV ) ; decCipher . init ( Cipher . DECRYPT_MODE , new SecretKeySpec ( server_key , NUM_ , key_size , algName ) , serverIV ) ; } else { encCipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( server_key , NUM_ , key_size , algName ) , serverIV ) ; decCipher . init ( Cipher . DECRYPT_MODE , new SecretKeySpec ( client_key , NUM_ , key_size , algName ) , clientIV ) ; } } messageDigest = MessageDigest . getInstance ( hashName ) ; if ( is_client ) { mac_write_secret = client_mac_secret ; mac_read_secret = server_mac_secret ; } else { mac_write_secret = server_mac_secret ; mac_read_secret = client_mac_secret ; } if ( hashName . equals ( STR_ ) ) { pad_1 = SSLv3Constants . MD5pad1 ; pad_2 = SSLv3Constants . MD5pad2 ; } else { pad_1 = SSLv3Constants . SHApad1 ; pad_2 = SSLv3Constants . SHApad2 ; } } catch ( Exception e ) { e . printStackTrace ( ) ; throw new AlertException ( AlertProtocol . INTERNAL_ERROR , new SSLProtocolException ( STR_ ) ) ; } }
static boolean verifyZipFile ( File file ) { try { ZipFile zipFile = new ZipFile ( file ) ; try { zipFile . close ( ) ; return BOOL_ ; } catch ( IOException e ) { Log . w ( TAG , STR_ + file . getAbsolutePath ( ) ) ; } } catch ( ZipException ex ) { Log . w ( TAG , STR_ + file . getAbsolutePath ( ) + STR_ , ex ) ; } catch ( IOException ex ) { Log . w ( TAG , STR_ + file . getAbsolutePath ( ) , ex ) ; } return BOOL_ ; }
long cleanup ( long now ) { int inUseConnectionCount = NUM_ ; int idleConnectionCount = NUM_ ; RealConnection longestIdleConnection = null ; long longestIdleDurationNs = Long . MIN_VALUE ; synchronized ( this ) { for ( Iterator < RealConnection > i = connections . iterator ( ) ; i . hasNext ( ) ; ) { RealConnection connection = i . next ( ) ; if ( pruneAndGetAllocationCount ( connection , now ) > NUM_ ) { inUseConnectionCount ++ ; continue ; } idleConnectionCount ++ ; long idleDurationNs = now - connection . idleAtNanos ; if ( idleDurationNs > longestIdleDurationNs ) { longestIdleDurationNs = idleDurationNs ; longestIdleConnection = connection ; } } if ( longestIdleDurationNs >= this . keepAliveDurationNs || idleConnectionCount > this . maxIdleConnections ) { connections . remove ( longestIdleConnection ) ; } else if ( idleConnectionCount > NUM_ ) { return keepAliveDurationNs - longestIdleDurationNs ; } else if ( inUseConnectionCount > NUM_ ) { return keepAliveDurationNs ; } else { cleanupRunning = BOOL_ ; return - NUM_ ; } } closeQuietly ( longestIdleConnection . socket ( ) ) ; return NUM_ ; }
public boolean compare ( Object expected , Object current ) { if ( current != null ) { equal = current . equals ( expected ) ; } else if ( expected != null ) { equal = expected . equals ( NUM_ ) ; } return equal ; }
private static byte [ ] generateSeed ( ) { try { ByteArrayOutputStream seedBuffer = new ByteArrayOutputStream ( ) ; DataOutputStream seedBufferOut = new DataOutputStream ( seedBuffer ) ; seedBufferOut . writeLong ( System . currentTimeMillis ( ) ) ; seedBufferOut . writeLong ( System . nanoTime ( ) ) ; seedBufferOut . writeInt ( Process . myPid ( ) ) ; seedBufferOut . writeInt ( Process . myUid ( ) ) ; seedBufferOut . write ( BUILD_FINGERPRINT_AND_DEVICE_SERIAL ) ; seedBufferOut . close ( ) ; return seedBuffer . toByteArray ( ) ; } catch ( IOException e ) { throw new SecurityException ( STR_ , e ) ; } }
boolean needToCheckExclude ( ) { return BOOL_ ; }
public static byte [ ] decode ( String hexa ) throws CoderException { if ( hexa == null ) { throw new CoderException ( STR_ ) ; } if ( ( hexa . length ( ) % NUM_ ) != NUM_ ) { throw new CoderException ( STR_ ) ; } int tamArray = hexa . length ( ) / NUM_ ; byte [ ] retorno = new byte [ tamArray ] ; for ( int i = NUM_ ; i < tamArray ; i ++ ) { retorno [ i ] = hexToByte ( hexa . substring ( i . NUM_ , i . NUM_ + NUM_ ) ) ; } return retorno ; }
private List < UserNamespaceAuthorization > createUserNamespaceAuthorizationsFromEntities ( List < UserNamespaceAuthorizationEntity > userNamespaceAuthorizationEntities ) { List < UserNamespaceAuthorization > userNamespaceAuthorizations = new ArrayList < > ( ) ; for ( UserNamespaceAuthorizationEntity userNamespaceAuthorizationEntity : userNamespaceAuthorizationEntities ) { userNamespaceAuthorizations . add ( createUserNamespaceAuthorizationFromEntity ( userNamespaceAuthorizationEntity ) ) ; } return userNamespaceAuthorizations ; }
private void readHeader ( ) throws OpenStegoException { this . dataHeader = new DCTDataHeader ( this , this . config ) ; }
@ Override public synchronized void reset ( ) { pos = NUM_ ; }
protected < T extends KeySpec > T engineGetKeySpec ( Key key , Class < T > keySpec ) throws InvalidKeySpecException { BigInteger p , q , g , x , y ; if ( key != null ) { if ( keySpec == null ) { throw new NullPointerException ( STR_ ) ; } if ( key instanceof DSAPrivateKey ) { DSAPrivateKey privateKey = ( DSAPrivateKey ) key ; if ( keySpec . equals ( DSAPrivateKeySpec . class ) ) { x = privateKey . getX ( ) ; DSAParams params = privateKey . getParams ( ) ; p = params . getP ( ) ; q = params . getQ ( ) ; g = params . getG ( ) ; return ( T ) ( new DSAPrivateKeySpec ( x , p , q , g ) ) ; } if ( keySpec . equals ( PKCS8EncodedKeySpec . class ) ) { return ( T ) ( new PKCS8EncodedKeySpec ( key . getEncoded ( ) ) ) ; } throw new InvalidKeySpecException ( STR_ ) ; } if ( key instanceof DSAPublicKey ) { DSAPublicKey publicKey = ( DSAPublicKey ) key ; if ( keySpec . equals ( DSAPublicKeySpec . class ) ) { y = publicKey . getY ( ) ; DSAParams params = publicKey . getParams ( ) ; p = params . getP ( ) ; q = params . getQ ( ) ; g = params . getG ( ) ; return ( T ) ( new DSAPublicKeySpec ( y , p , q , g ) ) ; } if ( keySpec . equals ( X509EncodedKeySpec . class ) ) { return ( T ) ( new X509EncodedKeySpec ( key . getEncoded ( ) ) ) ; } throw new InvalidKeySpecException ( STR_ ) ; } } throw new InvalidKeySpecException ( STR_ ) ; }
protected void drawText ( String text1 , String text2 , int x , int y , Canvas c ) { if ( textPaint == null ) { Paint p = new Paint ( ) ; p . setTypeface ( RobotoLightTypeface . getInstance ( context ) ) ; p . setColor ( textColor ) ; p . setTextSize ( NUM_ . pixelDensity ) ; this . textPaint = p ; } float w = textPaint . measureText ( text1 , NUM_ , text1 . length ( ) ) ; int offset = ( int ) w / NUM_ ; c . drawText ( text1 , x - offset , y + ( NUM_ . pixelDensity ) , textPaint ) ; w = textPaint . measureText ( text2 , NUM_ , text2 . length ( ) ) ; offset = ( int ) w / NUM_ ; c . drawText ( text2 , x - offset , y + ( NUM_ . pixelDensity ) , textPaint ) ; }
public boolean isLessThenOrEqualTo ( Percent Percent ) { assertDefined ( ) ; BigDecimal thisValue = notNull ( this ) ; BigDecimal parameter = notNull ( Percent ) ; return ( thisValue . compareTo ( parameter ) <= NUM_ ) ; }
public Object clone ( ) throws CloneNotSupportedException { PredicatedNodeTest clone = ( PredicatedNodeTest ) super . clone ( ) ; if ( ( null != this . m_proximityPositions ) && ( this . m_proximityPositions == clone . m_proximityPositions ) ) { clone . m_proximityPositions = new int [ this . m_proximityPositions . length ] ; System . arraycopy ( this . m_proximityPositions , NUM_ , clone . m_proximityPositions , NUM_ , this . m_proximityPositions . length ) ; } if ( clone . m_lpi == this ) clone . m_lpi = ( LocPathIterator ) clone ; return clone ; }
public static boolean pointOutsidePrefSize ( JTable table , int row , int column , Point p ) { if ( table . convertColumnIndexToModel ( column ) != NUM_ || row == - NUM_ ) { return BOOL_ ; } TableCellRenderer tcr = table . getCellRenderer ( row , column ) ; Object value = table . getValueAt ( row , column ) ; Component cell = tcr . getTableCellRendererComponent ( table , value , BOOL_ , BOOL_ , row , column ) ; Dimension itemSize = cell . getPreferredSize ( ) ; Rectangle cellBounds = table . getCellRect ( row , column , BOOL_ ) ; cellBounds . width = itemSize . width ; cellBounds . height = itemSize . height ; assert ( p . x >= cellBounds . x && p . y >= cellBounds . y ) ; return p . x > cellBounds . x + cellBounds . width || p . y > cellBounds . y + cellBounds . height ; }
public Builder addSourceFolder ( @ NonNull File folder ) { foldersToScan . add ( folder ) ; return this ; }
public Method suspendSRDFGroupMethod ( final URI systemURI , final RemoteDirectorGroup group , final List < URI > sourceVolumes , final List < URI > targetVolumes ) { return new Workflow . Method ( SUSPEND_SRDF_GROUP_METHOD , systemURI , group , sourceVolumes , targetVolumes ) ; }
private void fieldGoalAtt ( Team offense , Team defense ) { double fgDistRatio = Math . pow ( ( NUM_ - gameYardLine ) / NUM_ , NUM_ ) ; double fgAccRatio = Math . pow ( ( NUM_ - gameYardLine ) / NUM_ , NUM_ ) ; double fgDistChance = ( getHFadv ( ) + offense . getK ( NUM_ ) . ratKickPow - fgDistRatio . NUM_ ) ; double fgAccChance = ( getHFadv ( ) + offense . getK ( NUM_ ) . ratKickAcc - fgAccRatio . NUM_ ) ; if ( fgDistChance > NUM_ && fgAccChance . Math . random ( ) > NUM_ ) { if ( gamePoss ) { homeScore += NUM_ ; HomeKStats [ NUM_ ] ++ ; HomeKStats [ NUM_ ] ++ ; } else { awayScore += NUM_ ; AwayKStats [ NUM_ ] ++ ; AwayKStats [ NUM_ ] ++ ; } gameEventLog += getEventPrefix ( ) + offense . abbr + STR_ + offense . getK ( NUM_ ) . name + STR_ + ( NUM_ - gameYardLine ) + STR_ ; addPointsQuarter ( NUM_ ) ; offense . getK ( NUM_ ) . statsFGMade ++ ; offense . getK ( NUM_ ) . statsFGAtt ++ ; if ( ! playingOT ) kickOff ( offense ) ; else resetForOT ( ) ; } else { gameEventLog += getEventPrefix ( ) + offense . abbr + STR_ + offense . getK ( NUM_ ) . name + STR_ + ( NUM_ - gameYardLine ) + STR_ ; offense . getK ( NUM_ ) . statsFGAtt ++ ; if ( ! playingOT ) { gameYardLine = Math . max ( NUM_ - gameYardLine , NUM_ ) ; gameDown = NUM_ ; gameYardsNeed = NUM_ ; if ( gamePoss ) { HomeKStats [ NUM_ ] ++ ; } else { AwayKStats [ NUM_ ] ++ ; } gamePoss = ! gamePoss ; } else resetForOT ( ) ; } gameTime -= NUM_ ; }
public static final byte [ ] unzip ( byte [ ] in ) throws IOException { ByteArrayOutputStream outStream = new ByteArrayOutputStream ( EXPECTED_COMPRESSION_RATIO . in . length ) ; GZIPInputStream inStream = new GZIPInputStream ( new ByteArrayInputStream ( in ) ) ; byte [ ] buf = new byte [ BUF_SIZE ] ; while ( BOOL_ ) { int size = inStream . read ( buf ) ; if ( size <= NUM_ ) break ; outStream . write ( buf , NUM_ , size ) ; } outStream . close ( ) ; return outStream . toByteArray ( ) ; }
@ Override public double calculateM ( double delta , double epsilon ) { double i = NUM_ ; while ( conf ( i , delta ) > epsilon / NUM_ ) { i = i + NUM_ ; } if ( i > NUM_ ) { i = i - NUM_ ; } while ( conf ( i , delta ) > ( epsilon / NUM_ ) ) { i ++ ; } return Math . ceil ( i ) ; }
public static ServerSocket createServerSocket ( int port , InetAddress bindAddress ) throws IOException { ServerSocket socket = null ; if ( SysProperties . ENABLE_ANONYMOUS_TLS ) { removeAnonFromLegacyAlgorithms ( ) ; } setKeystore ( ) ; ServerSocketFactory f = SSLServerSocketFactory . getDefault ( ) ; SSLServerSocket secureSocket ; if ( bindAddress == null ) { secureSocket = ( SSLServerSocket ) f . createServerSocket ( port ) ; } else { secureSocket = ( SSLServerSocket ) f . createServerSocket ( port , NUM_ , bindAddress ) ; } secureSocket . setEnabledProtocols ( disableSSL ( secureSocket . getEnabledProtocols ( ) ) ) ; if ( SysProperties . ENABLE_ANONYMOUS_TLS ) { String [ ] list = enableAnonymous ( secureSocket . getEnabledCipherSuites ( ) , secureSocket . getSupportedCipherSuites ( ) ) ; secureSocket . setEnabledCipherSuites ( list ) ; } socket = secureSocket ; return socket ; }
public void printBytes ( byte [ ] data , int offset , int length ) throws IOException { int i ; for ( ; length >= NUM_ ; length -= NUM_ ) { int chunk = ( ( ( data [ offset ] & xff ) << NUM_ ) + ( ( data [ offset + NUM_ ] & xff ) << NUM_ ) + ( data [ offset + NUM_ ] & xff ) ) ; os . write ( base64encode ( chunk > > NUM_ ) ) ; os . write ( base64encode ( chunk > > NUM_ ) ) ; os . write ( base64encode ( chunk > > NUM_ ) ) ; os . write ( base64encode ( chunk ) ) ; offset += NUM_ ; } if ( length == NUM_ ) { int chunk = ( ( data [ offset ] & xff ) << NUM_ ) + ( data [ offset + NUM_ ] & xff ) ; os . write ( base64encode ( chunk > > NUM_ ) ) ; os . write ( base64encode ( chunk > > NUM_ ) ) ; os . write ( base64encode ( chunk ) ) ; os . write ( STR_ ) ; } else if ( length == NUM_ ) { int chunk = data [ offset ] & xff ; os . write ( base64encode ( chunk > > NUM_ ) ) ; os . write ( base64encode ( chunk ) ) ; os . write ( STR_ ) ; os . write ( STR_ ) ; } }
public void deleteVVset ( String nativeId ) throws Exception { _log . info ( STR_ ) ; ClientResponse clientResp = null ; final String path = MessageFormat . format ( URI_DELETE_CG , nativeId ) ; _log . info ( STR_ + path ) ; try { clientResp = delete ( path ) ; if ( clientResp == null ) { _log . error ( STR_ ) ; throw new HP3PARException ( STR_ ) ; } else if ( clientResp . getStatus ( ) != NUM_ ) { String errResp = getResponseDetails ( clientResp ) ; throw new HP3PARException ( errResp ) ; } else { _log . info ( STR_ ) ; } } catch ( Exception e ) { throw e ; } finally { if ( clientResp != null ) { clientResp . close ( ) ; } _log . info ( STR_ ) ; } }
public void accept ( final AnnotationVisitor av ) { if ( av != null ) { if ( values != null ) { for ( int i = NUM_ ; i < values . size ( ) ; i += NUM_ ) { String name = ( String ) values . get ( i ) ; Object value = values . get ( i + NUM_ ) ; accept ( av , name , value ) ; } } av . visitEnd ( ) ; } }
private int findKeyCommentIndex ( String keyName ) { for ( int i = NUM_ ; i < keyValComments . size ( ) ; i ++ ) { String t = keyValComments . get ( i ) ; String targetedKey = STR_ + keyName + STR_ ; if ( t . startsWith ( targetedKey ) ) { return i ; } } if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + keyName ) ; } return - NUM_ ; }
public boolean isExpired ( ) { return ( cookieExpiryDate != null && cookieExpiryDate . getTime ( ) <= System . currentTimeMillis ( ) ) ; }
public static void closeQuietly ( Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( RuntimeException rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } }
public static boolean isAddToHomeIntentSupported ( Context context ) { PackageManager pm = context . getPackageManager ( ) ; Intent i = new Intent ( INSTALL_SHORTCUT ) ; List < ResolveInfo > receivers = pm . queryBroadcastReceivers ( i , PackageManager . GET_INTENT_FILTERS ) ; return ! receivers . isEmpty ( ) ; }
public RoundedIconGenerator ( int iconWidthPx , int iconHeightPx , int cornerRadiusPx , int backgroundColor , float textSizePx ) { mIconWidthPx = iconWidthPx ; mIconHeightPx = iconHeightPx ; mCornerRadiusPx = cornerRadiusPx ; mBackgroundRect = new RectF ( NUM_ , NUM_ , mIconWidthPx , mIconHeightPx ) ; mBackgroundPaint = new Paint ( Paint . ANTI_ALIAS_FLAG ) ; mBackgroundPaint . setColor ( backgroundColor ) ; mTextPaint = new TextPaint ( Paint . ANTI_ALIAS_FLAG ) ; mTextPaint . setColor ( Color . WHITE ) ; mTextPaint . setFakeBoldText ( BOOL_ ) ; mTextPaint . setTextSize ( textSizePx ) ; FontMetrics textFontMetrics = mTextPaint . getFontMetrics ( ) ; mTextHeight = ( float ) Math . ceil ( textFontMetrics . bottom - textFontMetrics . top ) ; mTextYOffset = - textFontMetrics . top ; }
InMemoryEntryStore ( ) { entries = Maps . newHashMap ( ) ; topLevelEntries = Sets . newHashSet ( ) ; children = HashMultimap . create ( ) ; }
public void persistConnection ( Connection connection ) throws PersistenceException { MqttConnectOptions conOpts = connection . getConnectionOptions ( ) ; MqttMessage lastWill = conOpts . getWillMessage ( ) ; SQLiteDatabase db = getWritableDatabase ( ) ; ContentValues values = new ContentValues ( ) ; values . put ( COLUMN_HOST , connection . getHostName ( ) ) ; values . put ( COLUMN_port , connection . getPort ( ) ) ; values . put ( COLUMN_client_ID , connection . getId ( ) ) ; values . put ( COLUMN_ssl , connection . isSSL ( ) ) ; values . put ( COLUMN_KEEP_ALIVE , conOpts . getKeepAliveInterval ( ) ) ; values . put ( COLUMN_TIME_OUT , conOpts . getConnectionTimeout ( ) ) ; values . put ( COLUMN_USER_NAME , conOpts . getUserName ( ) ) ; values . put ( COLUMN_TOPIC , conOpts . getWillDestination ( ) ) ; char [ ] password = conOpts . getPassword ( ) ; values . put ( COLUMN_CLEAN_SESSION , conOpts . isCleanSession ( ) ? NUM_ : NUM_ ) ; values . put ( COLUMN_PASSWORD , password != null ? String . valueOf ( password ) : null ) ; values . put ( COLUMN_MESSAGE , lastWill != null ? new String ( lastWill . getPayload ( ) ) : null ) ; values . put ( COLUMN_QOS , lastWill != null ? lastWill . getQos ( ) : NUM_ ) ; if ( lastWill == null ) { values . put ( COLUMN_RETAINED , NUM_ ) ; } else { values . put ( COLUMN_RETAINED , lastWill . isRetained ( ) ? NUM_ : NUM_ ) ; } long newRowId = db . insert ( TABLE_CONNECTIONS , null , values ) ; db . close ( ) ; if ( newRowId == - NUM_ ) { throw new PersistenceException ( STR_ + connection . handle ( ) ) ; } else { connection . assignPersistenceId ( newRowId ) ; } }
public ClassAnnotator ( URL [ ] codebase , Properties props ) { if ( props != null ) properties . putAll ( props ) ; setAnnotationURLs ( codebase ) ; }
public int next ( ) { return mix ( gen . getAndIncrement ( ) ) ; }
public CholeskyDecomposition ( Matrix Arg ) { double [ ] [ ] A = Arg . getArray ( ) ; n = Arg . getRowDimension ( ) ; L = new double [ n ] [ n ] ; isspd = ( Arg . getColumnDimension ( ) == n ) ; for ( int j = NUM_ ; j < n ; j ++ ) { double [ ] Lrowj = L [ j ] ; double d = NUM_ ; for ( int k = NUM_ ; k < j ; k ++ ) { double [ ] Lrowk = L [ k ] ; double s = NUM_ ; for ( int i = NUM_ ; i < k ; i ++ ) { s += Lrowk [ i ] . Lrowj [ i ] ; } Lrowj [ k ] = s = ( A [ j ] [ k ] - s ) / L [ k ] [ k ] ; d = d + s . s ; isspd = isspd & ( A [ k ] [ j ] == A [ j ] [ k ] ) ; } d = A [ j ] [ j ] - d ; isspd = isspd & ( d > NUM_ ) ; L [ j ] [ j ] = Math . sqrt ( Math . max ( d , NUM_ ) ) ; for ( int k = j + NUM_ ; k < n ; k ++ ) { L [ j ] [ k ] = NUM_ ; } } }
public InputStream put ( final URLConnection connection , final boolean flushCacheOnClose ) { final String key = getKey ( connection ) ; if ( key == null ) return null ; if ( ! isCacheable ( ( HttpURLConnection ) connection ) ) try { cache . remove ( key ) ; return null ; } catch ( IOException e ) { return null ; } String etag = connection . getHeaderField ( HEADER_ETAG ) ; if ( etag == null || etag . length ( ) == NUM_ ) return null ; Editor editor ; try { editor = cache . edit ( key ) ; } catch ( IOException e ) { return null ; } if ( editor == null ) return null ; try { editor . set ( ETAG , etag ) ; } catch ( IOException e ) { try { editor . abort ( ) ; } catch ( IOException ignored ) { } return null ; } InputStream input ; try { input = connection . getInputStream ( ) ; if ( ! ( input instanceof InflaterInputStream ) && ENCODING_GZIP . equals ( connection . getHeaderField ( HEADER_CONTENT_ENCODING ) ) ) input = new GZIPInputStream ( input ) ; } catch ( IOException e ) { return null ; } OutputStream output ; try { output = editor . newOutputStream ( BODY ) ; } catch ( IOException e ) { return null ; } if ( output != null ) return new CacheStream ( input , output , editor , this , flushCacheOnClose ) ; else return null ; }
public static String [ ] parseTitle ( String title ) { String v [ ] = { STR_ , STR_ } ; if ( title == null ) return v ; Pattern p = Pattern . compile ( STR_ , Pattern . CASE_INSENSITIVE ) ; Matcher m = p . matcher ( title ) ; if ( m . find ( ) ) { v [ NUM_ ] = m . group ( NUM_ ) ; v [ NUM_ ] = m . group ( NUM_ ) ; } else { v [ NUM_ ] = title ; } return v ; }
public String sel ( ) { return mSelection . toString ( ) ; }
public double calculateExcitatoryRatio ( ) { excitatoryRatio = exSynapseSet . size ( ) / ( double ) size ( ) ; if ( Double . isNaN ( excitatoryRatio ) ) { return NUM_ ; } return excitatoryRatio ; }
public void rootRemoved ( ISVNRepositoryLocation root ) { Iterator it = listeners . iterator ( ) ; while ( it . hasNext ( ) ) { IRepositoryListener listener = ( IRepositoryListener ) it . next ( ) ; listener . repositoryRemoved ( root ) ; } }
public synchronized void insert ( double _priority , Object _data ) { numElements ++ ; if ( numElements == queue . length ) { PriorityQueueNode [ ] tmp = new PriorityQueueNode [ ( int ) ( queue . length . NUM_ ) ] ; System . arraycopy ( queue , NUM_ , tmp , NUM_ , queue . length ) ; for ( int i = queue . length ; i < tmp . length ; i ++ ) { tmp [ i ] = new PriorityQueueNode ( ) ; } queue = tmp ; } queue [ numElements ] . data = _data ; queue [ numElements ] . priority = _priority ; reheapify ( numElements ) ; }
protected String wrapLinuxCommand ( String command ) throws IOException , InterruptedException { String setGroup = STR_ + getGid ( ) + STR_ + getGid ( ) + STR_ + getGid ( ) + STR_ ; String setUser = STR_ + getUid ( ) + STR_ + getUid ( ) + STR_ + getGid ( ) + STR_ ; String chownCommand = STR_ ; return setGroup + STR_ + setUser + STR_ + chownCommand + STR_ + command + STR_ + chownCommand ; }
public AbstractDMLQuery parseSqlQuery ( SQLQuery sqlQuery , ISpaceProxy space ) throws SQLException { AbstractDMLQuery query = ( AbstractDMLQuery ) getQueryFromCache ( getUniqueKey ( sqlQuery ) ) ; try { if ( query == null ) { if ( _logger . isLoggable ( Level . FINE ) ) { _logger . fine ( STR_ ) ; } SqlParser parser = initParser ( sqlQuery . getQuery ( ) ) ; query = parse ( parser ) ; query . setTableName ( sqlQuery . getTypeName ( ) ) ; query . validateQuery ( space ) ; if ( ! query . isPrepared ( ) && ! query . containsSubQueries ( ) ) query . build ( ) ; addQueryToCache ( getUniqueKey ( sqlQuery ) , query ) ; if ( ! query . isPrepared ( ) ) return query ; } query = query . clone ( ) ; return query ; } catch ( SQLException sqlEx ) { if ( _logger . isLoggable ( Level . FINE ) ) { _logger . log ( Level . FINE , STR_ + sqlQuery . getQuery ( ) + STR_ , sqlEx ) ; } throw sqlEx ; } catch ( Throwable t ) { if ( _logger . isLoggable ( Level . FINE ) ) { _logger . log ( Level . FINE , STR_ + sqlQuery . getQuery ( ) + STR_ , t ) ; } SQLException sqlEx = new SQLException ( STR_ + sqlQuery . getQuery ( ) + STR_ + t , STR_ , - NUM_ ) ; sqlEx . initCause ( t ) ; throw sqlEx ; } }
private int indexOfElementInLevel ( int element , int level [ ] ) throws Exception { for ( int i = NUM_ ; i < level . length ; i ++ ) { if ( level [ i ] == element ) { return i ; } } throw new Exception ( STR_ + m_nodes . get ( element ) . ID + STR_ + STR_ ) ; }
public int size ( ) { return _attrs . size ( ) ; }
public String consumeTagName ( ) { int start = pos ; while ( ! isEmpty ( ) && ( matchesWord ( ) || matchesAny ( STR_ , STR_ , STR_ ) ) ) pos ++ ; return queue . substring ( start , pos ) ; }
public void deepSort ( int [ ] setFeatureSequence ) { featureSequence = setFeatureSequence ; numberOfLeaves = NUM_ ; tree = new MaryNode ( NUM_ , featureVectors . length ) ; sortNode ( NUM_ , tree ) ; }
public void removeListeners ( ) { listeners . clear ( ) ; }
public String decrypt ( String sCipherText ) { int nLen = ( sCipherText . length ( ) > > NUM_ ) & ~ NUM_ ; if ( nLen < BlowfishECB . BLOCKSIZE ) return null ; byte [ ] cbciv = new byte [ BlowfishECB . BLOCKSIZE ] ; int nNumOfBytes = BinConverter . binHexToBytes ( sCipherText , cbciv , NUM_ , NUM_ , BlowfishECB . BLOCKSIZE ) ; if ( nNumOfBytes < BlowfishECB . BLOCKSIZE ) return null ; m_bfish . setCBCIV ( cbciv ) ; nLen -= BlowfishECB . BLOCKSIZE ; if ( nLen == NUM_ ) return STR_ ; byte [ ] buf = new byte [ nLen ] ; nNumOfBytes = BinConverter . binHexToBytes ( sCipherText , buf , BlowfishECB . BLOCKSIZE . NUM_ , NUM_ , nLen ) ; if ( nNumOfBytes < nLen ) return null ; m_bfish . decrypt ( buf ) ; int nPadByte = buf [ buf . length - NUM_ ] & x0ff ; if ( ( nPadByte > NUM_ ) || ( nPadByte < NUM_ ) ) nPadByte = NUM_ ; nNumOfBytes -= nPadByte ; if ( nNumOfBytes < NUM_ ) return STR_ ; return BinConverter . byteArrayToUNCString ( buf , NUM_ , nNumOfBytes ) ; }
public static double L_RankLoss ( int y [ ] , int r [ ] ) { int L = y . length ; ArrayList < Integer > tI = new ArrayList < Integer > ( ) ; ArrayList < Integer > fI = new ArrayList < Integer > ( ) ; for ( int j = NUM_ ; j < L ; j ++ ) { if ( y [ j ] == NUM_ ) { tI . add ( j ) ; } else { fI . add ( j ) ; } } if ( ! tI . isEmpty ( ) && ! fI . isEmpty ( ) ) { int c = NUM_ ; for ( int k : tI ) { for ( int l : fI ) { if ( position ( k , r ) < position ( l , r ) ) { c ++ ; } } } return ( double ) c / ( double ) ( tI . size ( ) . fI . size ( ) ) ; } else { return NUM_ ; } }
private double addRecursively ( ArrayList < double [ ] > hull , Hierarchy < Cluster < Model > > hier , Cluster < Model > clus ) { final DBIDs ids = clus . getIDs ( ) ; double weight = ids . size ( ) ; for ( DBIDIter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { double [ ] projP = proj . fastProjectDataToRenderSpace ( rel . get ( iter ) ) ; if ( projP [ NUM_ ] != projP [ NUM_ ] || projP [ NUM_ ] != projP [ NUM_ ] ) { continue ; } hull . add ( projP ) ; } for ( Iter < Cluster < Model > > iter = hier . iterChildren ( clus ) ; iter . valid ( ) ; iter . advance ( ) ) { weight += NUM_ . addRecursively ( hull , hier , iter . get ( ) ) ; } return weight ; }
public void attributeUpdate ( PrintServiceAttributeEvent psae ) { log . fine ( STR_ + psae ) ; }
public static boolean decodeToFile ( String dataToDecode , String filename ) { boolean success = BOOL_ ; Base64 . OutputStream bos = null ; try { bos = new Base64 . OutputStream ( new java . io . FileOutputStream ( filename ) , Base64 . DECODE ) ; bos . write ( dataToDecode . getBytes ( PREFERRED_ENCODING ) ) ; success = BOOL_ ; } catch ( java . io . IOException e ) { success = BOOL_ ; } finally { try { bos . close ( ) ; } catch ( Exception e ) { } } return success ; }
public void evict ( ) throws Exception { assertOpen ( ) ; boolean isEmpty ; synchronized ( this ) { isEmpty = pool . isEmpty ( ) ; } if ( ! isEmpty ) { if ( softMinEvictableIdleTimeMillis > NUM_ ) { int numToEvict = getNumIdle ( ) - getMinIdle ( ) ; evict ( System . currentTimeMillis ( ) - softMinEvictableIdleTimeMillis , numToEvict ) ; } if ( minEvictableIdleTimeMillis > NUM_ ) { int numToEvict = getNumIdle ( ) ; evict ( System . currentTimeMillis ( ) - minEvictableIdleTimeMillis , numToEvict ) ; } } }
protected void generateRandomPopulation ( int population_size ) { logger . debug ( STR_ ) ; for ( int i = NUM_ ; i < population_size ; i ++ ) { T individual = chromosomeFactory . getChromosome ( ) ; for ( FitnessFunction < ? > fitnessFunction : this . fitnessFunctions ) { individual . addFitness ( fitnessFunction ) ; } population . add ( individual ) ; if ( isFinished ( ) ) break ; } logger . debug ( STR_ + population . size ( ) + STR_ ) ; }
public Session ( ) { long uptime = System . currentTimeMillis ( ) ; mMainHandler = new Handler ( Looper . getMainLooper ( ) ) ; mTimestamp = ( uptime / NUM_ ) << NUM_ & ( ( ( uptime - ( ( uptime / NUM_ ) . NUM_ ) ) > > NUM_ ) / NUM_ ) ; mOrigin = STR_ ; try { sSignal . await ( ) ; } catch ( InterruptedException e ) { } }
public List < Visitante > listar ( ) { List < Visitante > dados = new ArrayList < > ( ) ; try { String sql = STR_ ; stm = conector . prepareStatement ( sql ) ; rs = stm . executeQuery ( sql ) ; while ( rs . next ( ) ) { dados . add ( new Visitante ( rs . getInt ( NUM_ ) , rs . getString ( NUM_ ) , rs . getString ( NUM_ ) , rs . getString ( NUM_ ) , rs . getString ( NUM_ ) , rs . getString ( NUM_ ) , Tempo . toDate ( rs . getTimestamp ( NUM_ ) ) , rs . getString ( NUM_ ) , rs . getString ( NUM_ ) ) ) ; } stm . close ( ) ; rs . close ( ) ; } catch ( SQLException ex ) { Mensagem . erro ( STR_ + ex ) ; } return dados ; }
private void assertAllFromTbl1 ( Statement stmt , String [ ] ones , short [ ] twos ) throws SQLException { ResultSet rs = stmt . executeQuery ( STR_ ) ; int i = NUM_ ; for ( ; rs . next ( ) ; i ++ ) { assertTrue ( i < ones . length ) ; assertEquals ( ones [ i ] , rs . getString ( STR_ ) ) ; assertEquals ( twos [ i ] , rs . getShort ( STR_ ) ) ; } assertTrue ( i == ones . length ) ; }
@ Override public Writer append ( char value ) { builder . append ( value ) ; return this ; }
private void insertBefore ( Instruction [ ] list , Instruction s ) { for ( Instruction x : list ) { s . insertBefore ( x ) ; } }
public static Builder newBuilder ( ) { return new Builder ( ) ; }
public int countArray ( String [ ] array ) { return array . length ; }
private void processUnprocessed ( ) { boolean clean_processings = Boolean . getBoolean ( STR_ ) ; logger . info ( STR_ + STR_ + clean_processings + STR_ ) ; productService . processUnprocessed ( ! clean_processings ) ; }
public double [ ] popy ( double x_ [ ] ) { return popY ( new double [ ] [ ] { x_ } ) [ NUM_ ] ; }
public void gotoFrame ( int frameNumber ) throws IOException { print ( STR_ , new String [ ] { Integer . toString ( frameNumber ) } ) ; }
private void pop ( final String desc ) { char c = desc . charAt ( NUM_ ) ; if ( c == STR_ ) { pop ( ( Type . getArgumentsAndReturnSizes ( desc ) > > NUM_ ) - NUM_ ) ; } else if ( c == STR_ || c == STR_ ) { pop ( NUM_ ) ; } else { pop ( NUM_ ) ; } }
public void delete ( String name ) throws IOException { if ( name . equalsIgnoreCase ( SUBJECT_NAME ) ) { names = null ; } else { throw new IOException ( STR_ + STR_ ) ; } encodeThis ( ) ; }
public void pushElemAttributeSet ( ElemAttributeSet attrSet ) { m_attrSetStack . push ( attrSet ) ; }
private void finishScrollStacks ( ) { cancelAnimation ( this , Property . STACK_SNAP ) ; final int currentModelIndex = getTabStackIndex ( ) ; float delta = Math . abs ( currentModelIndex + mRenderedScrollOffset ) ; float target = - currentModelIndex ; if ( delta != NUM_ ) { long duration = FLING_MIN_DURATION + ( long ) Math . abs ( delta . getFullScrollDistance ( ) / mFlingSpeed ) ; addToAnimation ( this , Property . STACK_SNAP , mRenderedScrollOffset , target , duration , NUM_ ) ; } else { setProperty ( Property . STACK_SNAP , target ) ; if ( mTemporarySelectedStack != null ) { mTabModelSelector . selectModel ( mTemporarySelectedStack ) ; mTemporarySelectedStack = null ; } } }
public GeoDistanceBuilder addUnboundedFrom ( String key , double from ) { ranges . add ( new Range ( key , from , null ) ) ; return this ; }
private void sendResponse ( Document doc , MessageFactory messageFactory , String contentType , HttpServletResponse res ) throws IOException , SOAPException { SOAPMessage reply = messageFactory . createMessage ( ) ; SOAPHeader header = reply . getSOAPHeader ( ) ; header . detachNode ( ) ; SOAPBody replyBody = reply . getSOAPBody ( ) ; res . setHeader ( STR_ , contentType ) ; replyBody . addDocument ( doc ) ; reply . saveChanges ( ) ; OutputStream os = res . getOutputStream ( ) ; reply . writeTo ( os ) ; os . flush ( ) ; }
public static String replaceChars ( String str , String oldchars , char newchar ) { int pos = indexOfChars ( str , oldchars ) ; if ( pos == - NUM_ ) { return str ; } StringBuilder buf = new StringBuilder ( str ) ; do { buf . setCharAt ( pos , newchar ) ; pos = indexOfChars ( str , oldchars , pos + NUM_ ) ; } while ( pos != - NUM_ ) ; return buf . toString ( ) ; }
public final CharSequence yytext ( ) { return zzBuffer . subSequence ( zzStartRead , zzMarkedPos ) ; }
public static String canonicalizePath ( String path , boolean discardRelativePrefix ) { int segmentStart = NUM_ ; int deletableSegments = NUM_ ; for ( int i = NUM_ ; i <= path . length ( ) ; ) { int nextSegmentStart ; if ( i == path . length ( ) ) { nextSegmentStart = i ; } else if ( path . charAt ( i ) == STR_ ) { nextSegmentStart = i + NUM_ ; } else { i ++ ; continue ; } if ( i == segmentStart + NUM_ && path . regionMatches ( segmentStart , STR_ , NUM_ , NUM_ ) ) { path = path . substring ( NUM_ , segmentStart ) + path . substring ( nextSegmentStart ) ; i = segmentStart ; } else if ( i == segmentStart + NUM_ && path . regionMatches ( segmentStart , STR_ , NUM_ , NUM_ ) ) { if ( deletableSegments > NUM_ || discardRelativePrefix ) { deletableSegments -- ; int prevSegmentStart = path . lastIndexOf ( STR_ , segmentStart - NUM_ ) + NUM_ ; path = path . substring ( NUM_ , prevSegmentStart ) + path . substring ( nextSegmentStart ) ; i = segmentStart = prevSegmentStart ; } else { i ++ ; segmentStart = i ; } } else { if ( i > NUM_ ) { deletableSegments ++ ; } i ++ ; segmentStart = i ; } } return path ; }
public InMemoryMessageExchangeStore ( final NetworkConfig config , TokenProvider tokenProvider ) { if ( config == null ) { throw new NullPointerException ( STR_ ) ; } if ( tokenProvider == null ) { throw new NullPointerException ( STR_ ) ; } this . tokenProvider = tokenProvider ; this . config = config ; }
public static void next ( ) { try { if ( musicPlaybackService != null ) { musicPlaybackService . next ( ) ; } } catch ( final RemoteException ignored ) { } }
public long startstack ( ) { return Long . parseLong ( fields [ NUM_ ] ) ; }
private void drawBitmapWithStroke ( Canvas canvas , Bitmap bitmap , int centerX , int centerY , float radius , Paint drawPaint ) { drawPaint . setStyle ( Paint . Style . FILL ) ; float strokeRadius = radius + mRadiusStrokeWidth ; drawPaint . setXfermode ( new PorterDuffXfermode ( PorterDuff . Mode . CLEAR ) ) ; canvas . drawCircle ( centerX , centerY , strokeRadius , drawPaint ) ; drawPaint . setXfermode ( null ) ; final int halfBitmapWidth = bitmap . getWidth ( ) / NUM_ ; final int halfBitmapHeight = bitmap . getHeight ( ) / NUM_ ; BitmapShader bitmapShader = new BitmapShader ( bitmap , Shader . TileMode . REPEAT , Shader . TileMode . REPEAT ) ; Matrix shaderMatrix = new Matrix ( ) ; float minSize = bitmap . getWidth ( ) > bitmap . getHeight ( ) ? bitmap . getHeight ( ) : bitmap . getWidth ( ) ; float scale = radius . NUM_ / minSize ; shaderMatrix . setScale ( scale , scale ) ; shaderMatrix . postTranslate ( centerX - ( halfBitmapWidth . scale ) , centerY - ( halfBitmapHeight . scale ) ) ; bitmapShader . setLocalMatrix ( shaderMatrix ) ; drawPaint . setShader ( bitmapShader ) ; canvas . drawCircle ( centerX , centerY , radius , drawPaint ) ; drawPaint . setShader ( null ) ; }
SNode awaitFulfill ( SNode s , boolean timed , long nanos ) { final long deadline = timed ? System . nanoTime ( ) + nanos : NUM_ ; Thread w = Thread . currentThread ( ) ; int spins = ( shouldSpin ( s ) ? ( timed ? maxTimedSpins : maxUntimedSpins ) : NUM_ ) ; for ( ; ; ) { if ( w . isInterrupted ( ) ) s . tryCancel ( ) ; SNode m = s . match ; if ( m != null ) return m ; if ( timed ) { nanos = deadline - System . nanoTime ( ) ; if ( nanos <= NUM_ ) { s . tryCancel ( ) ; continue ; } } if ( spins > NUM_ ) spins = shouldSpin ( s ) ? ( spins - NUM_ ) : NUM_ ; else if ( s . waiter == null ) s . waiter = w ; else if ( ! timed ) LockSupport . park ( this ) ; else if ( nanos > spinForTimeoutThreshold ) LockSupport . parkNanos ( this , nanos ) ; } }
public MqttDevice mqttDevice ( ) { return mqttDevice ; }
public AbbaLockingDetector startCollecting ( ) { thread = new Thread ( this , STR_ ) ; thread . setDaemon ( BOOL_ ) ; thread . start ( ) ; return this ; }
public void addSwipeListener ( SwipeListener listener ) { if ( mListeners == null ) { mListeners = new ArrayList < SwipeListener > ( ) ; } mListeners . add ( listener ) ; }
protected Object readObjectOverride ( ) throws OptionalDataException , ClassNotFoundException , IOException { if ( input == null ) { return null ; } throw new IOException ( ) ; }
public float toMeters ( double pixels ) { return ( float ) ( pixels . METERS_PER_PIXELS ) ; }
public static String searchRemoveFromCategory ( HttpServletRequest request , HttpServletResponse response ) { Delegator delegator = ( Delegator ) request . getAttribute ( STR_ ) ; String productCategoryId = request . getParameter ( STR_ ) ; String errMsg = null ; try { boolean beganTransaction = TransactionUtil . begin ( DEFAULT_TX_TIMEOUT ) ; try { EntityListIterator eli = getProductSearchResults ( request ) ; if ( eli == null ) { errMsg = UtilProperties . getMessage ( resource , STR_ , UtilHttp . getLocale ( request ) ) ; request . setAttribute ( STR_ , errMsg ) ; return STR_ ; } int numRemoved = NUM_ ; GenericValue searchResultView = null ; while ( ( searchResultView = eli . next ( ) ) != null ) { String productId = searchResultView . getString ( STR_ ) ; numRemoved += delegator . removeByAnd ( STR_ , UtilMisc . toMap ( STR_ , productCategoryId , STR_ , productId ) ) ; } eli . close ( ) ; Map < String , String > messageMap = UtilMisc . toMap ( STR_ , Integer . toString ( numRemoved ) ) ; errMsg = UtilProperties . getMessage ( resource , STR_ , messageMap , UtilHttp . getLocale ( request ) ) ; request . setAttribute ( STR_ , errMsg ) ; } catch ( GenericEntityException e ) { Map < String , String > messageMap = UtilMisc . toMap ( STR_ , e . toString ( ) ) ; errMsg = UtilProperties . getMessage ( resource , STR_ , messageMap , UtilHttp . getLocale ( request ) ) ; Debug . logError ( e , errMsg , module ) ; request . setAttribute ( STR_ , errMsg ) ; TransactionUtil . rollback ( beganTransaction , errMsg , e ) ; return STR_ ; } finally { TransactionUtil . commit ( beganTransaction ) ; } } catch ( GenericTransactionException e ) { Map < String , String > messageMap = UtilMisc . toMap ( STR_ , e . toString ( ) ) ; errMsg = UtilProperties . getMessage ( resource , STR_ , messageMap , UtilHttp . getLocale ( request ) ) ; Debug . logError ( e , errMsg , module ) ; request . setAttribute ( STR_ , errMsg ) ; return STR_ ; } return STR_ ; }
boolean addToBuffer ( char c ) throws IOException { int len = sb . length ( ) ; if ( len == NUM_ && c != CHAR_LT ) return BOOL_ ; sb . append ( c ) ; if ( ++ len >= minTagLen ) { boolean isClosingTag = ( len >= NUM_ && sb . charAt ( NUM_ ) == CHAR_SL ) ; String substr ; if ( isClosingTag ) substr = sb . substring ( NUM_ ) ; else substr = sb . substring ( NUM_ ) ; for ( int i = NUM_ ; i < EXCLUDE_TAGS . length ; i ++ ) { if ( substr . equalsIgnoreCase ( EXCLUDE_TAGS [ i ] ) ) { if ( isClosingTag ) { depthDec ( i ) ; printBuffer ( ) ; lastChar = NUM_ ; } else { depthInc ( i ) ; } } } } return BOOL_ ; }
public static double length ( double x , double y , double z ) { return Math . sqrt ( x . x + y . y + z . z ) ; }
public static < T > T jsonToObject ( String jsonString , Class < T > klass ) { T objectFromJson = null ; try { GfJsonObject jsonObject = new GfJsonObject ( jsonString ) ; objectFromJson = klass . newInstance ( ) ; Method [ ] declaredMethods = klass . getDeclaredMethods ( ) ; Map < String , Method > methodsMap = new HashMap < String , Method > ( ) ; for ( Method method : declaredMethods ) { methodsMap . put ( method . getName ( ) , method ) ; } int noOfFields = jsonObject . size ( ) ; Iterator < String > keys = jsonObject . keys ( ) ; while ( keys . hasNext ( ) ) { String key = keys . next ( ) ; Method method = methodsMap . get ( STR_ + capitalize ( key ) ) ; if ( method != null ) { Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; if ( parameterTypes . length == NUM_ ) { Class < ? > parameterType = parameterTypes [ NUM_ ] ; Object value = jsonObject . get ( key ) ; if ( isPrimitiveOrWrapper ( parameterType ) ) { value = getPrimitiveOrWrapperValue ( parameterType , value ) ; } else if ( isArray ( parameterType ) ) { value = toArray ( value , parameterType ) ; } else if ( isList ( parameterType ) ) { value = toList ( value , parameterType ) ; } else if ( isMap ( parameterType ) ) { value = toMap ( value , parameterType ) ; } else if ( isSet ( parameterType ) ) { value = toSet ( value , parameterType ) ; } else { value = jsonToObject ( value . toString ( ) , parameterType ) ; } method . invoke ( objectFromJson , new Object [ ] { value } ) ; noOfFields -- ; } } } if ( noOfFields != NUM_ ) { throw new IllegalArgumentException ( STR_ + jsonString + STR_ + klass ) ; } } catch ( InstantiationException e ) { throw new IllegalArgumentException ( STR_ + klass , e ) ; } catch ( IllegalAccessException e ) { throw new IllegalArgumentException ( STR_ + klass , e ) ; } catch ( GfJsonException e ) { throw new IllegalArgumentException ( STR_ + klass , e ) ; } catch ( IllegalArgumentException e ) { throw new IllegalArgumentException ( STR_ + klass , e ) ; } catch ( InvocationTargetException e ) { throw new IllegalArgumentException ( STR_ + klass , e ) ; } return objectFromJson ; }
private Cache createCache ( ) throws CacheException { final Properties props = new Properties ( ) ; props . setProperty ( LOCATORS , STR_ ) ; props . setProperty ( MCAST_PORT , STR_ ) ; return CacheFactory . create ( DistributedSystem . connect ( props ) ) ; }
public AttributeListPanel ( ) { m_Table . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; m_Table . setColumnSelectionAllowed ( BOOL_ ) ; m_Table . setPreferredScrollableViewportSize ( new Dimension ( NUM_ , NUM_ ) ) ; setLayout ( new BorderLayout ( ) ) ; add ( new JScrollPane ( m_Table ) , BorderLayout . CENTER ) ; }
protected String [ ] [ ] toArray ( ) { int i ; int n ; int ii ; int nn ; int x ; int y ; String [ ] [ ] result ; String [ ] [ ] tmpResult ; int cols ; int rows ; boolean valueExists ; rows = getVisibleRowCount ( ) ; if ( getShowAverage ( ) ) { rows ++ ; } cols = getVisibleColCount ( ) ; if ( getShowStdDev ( ) ) { cols = cols . NUM_ ; } else { cols = cols . NUM_ ; } result = new String [ rows + NUM_ ] [ cols + NUM_ ] ; result [ NUM_ ] [ NUM_ ] = trimString ( STR_ , getRowNameWidth ( ) ) ; x = NUM_ ; for ( ii = NUM_ ; ii < getColCount ( ) ; ii ++ ) { i = getDisplayCol ( ii ) ; if ( getColHidden ( i ) ) { continue ; } result [ NUM_ ] [ x ] = trimString ( removeFilterName ( getColName ( i ) ) , getColNameWidth ( ) ) ; x ++ ; if ( getShowStdDev ( ) ) { result [ NUM_ ] [ x ] = STR_ ; x ++ ; } result [ NUM_ ] [ x ] = STR_ ; x ++ ; } y = NUM_ ; for ( ii = NUM_ ; ii < getRowCount ( ) ; ii ++ ) { i = getDisplayRow ( ii ) ; if ( ! getRowHidden ( i ) ) { result [ y ] [ NUM_ ] = trimString ( removeFilterName ( getRowName ( i ) ) , getRowNameWidth ( ) ) ; y ++ ; } } y = NUM_ ; for ( ii = NUM_ ; ii < getRowCount ( ) ; ii ++ ) { i = getDisplayRow ( ii ) ; if ( getRowHidden ( i ) ) { continue ; } x = NUM_ ; for ( nn = NUM_ ; nn < getColCount ( ) ; nn ++ ) { n = getDisplayCol ( nn ) ; if ( getColHidden ( n ) ) { continue ; } valueExists = ( ! Double . isNaN ( getMean ( n , i ) ) ) ; if ( ! valueExists ) { result [ y ] [ x ] = STR_ ; } else { result [ y ] [ x ] = doubleToString ( getMean ( n , i ) , getMeanPrec ( ) ) ; } x ++ ; if ( getShowStdDev ( ) ) { if ( ! valueExists ) { result [ y ] [ x ] = STR_ ; } else if ( Double . isInfinite ( getStdDev ( n , i ) ) ) { result [ y ] [ x ] = STR_ ; } else { result [ y ] [ x ] = doubleToString ( getStdDev ( n , i ) , getStdDevPrec ( ) ) ; } x ++ ; } if ( ! valueExists ) { result [ y ] [ x ] = STR_ ; } else { switch ( getSignificance ( n , i ) ) { case SIGNIFICANCE_TIE : result [ y ] [ x ] = TIE_STRING ; break ; case SIGNIFICANCE_WIN : result [ y ] [ x ] = WIN_STRING ; break ; case SIGNIFICANCE_LOSS : result [ y ] [ x ] = LOSS_STRING ; break ; } } x ++ ; } y ++ ; } if ( getShowAverage ( ) ) { y = result . length - NUM_ ; x = NUM_ ; result [ y ] [ NUM_ ] = STR_ ; x ++ ; for ( ii = NUM_ ; ii < getColCount ( ) ; ii ++ ) { i = getDisplayCol ( ii ) ; if ( getColHidden ( i ) ) { continue ; } result [ y ] [ x ] = doubleToString ( getAverage ( i ) , getMeanPrec ( ) ) ; x ++ ; if ( getShowStdDev ( ) ) { result [ y ] [ x ] = STR_ ; x ++ ; } result [ y ] [ x ] = STR_ ; x ++ ; } } y = result . length - NUM_ ; x = NUM_ ; result [ y ] [ NUM_ ] = LEFT_PARENTHESES + WIN_STRING + STR_ + TIE_STRING + STR_ + LOSS_STRING + RIGHT_PARENTHESES ; x ++ ; for ( ii = NUM_ ; ii < getColCount ( ) ; ii ++ ) { i = getDisplayCol ( ii ) ; if ( getColHidden ( i ) ) { continue ; } result [ y ] [ x ] = STR_ ; x ++ ; if ( getShowStdDev ( ) ) { result [ y ] [ x ] = STR_ ; x ++ ; } result [ y ] [ x ] = LEFT_PARENTHESES + getSignificanceCount ( i , SIGNIFICANCE_WIN ) + STR_ + getSignificanceCount ( i , SIGNIFICANCE_TIE ) + STR_ + getSignificanceCount ( i , SIGNIFICANCE_LOSS ) + RIGHT_PARENTHESES ; x ++ ; } tmpResult = new String [ result . length ] [ result [ NUM_ ] . length - NUM_ ] ; x = NUM_ ; for ( i = NUM_ ; i < result [ NUM_ ] . length ; i ++ ) { if ( ( ( i == NUM_ ) && ( getShowStdDev ( ) ) ) || ( ( i == NUM_ ) && ( ! getShowStdDev ( ) ) ) ) { continue ; } for ( n = NUM_ ; n < result . length ; n ++ ) { tmpResult [ n ] [ x ] = result [ n ] [ i ] ; } x ++ ; } result = tmpResult ; return result ; }
private Environment ( ) { throw ContractUtils . unreachable ( ) ; }
public void removePhoto ( PhotoEntity photo ) { photos . remove ( photo ) ; }
public static int binarySearch ( double [ ] array , int startIndex , int endIndex , double value ) { checkIndexForBinarySearch ( array . length , startIndex , endIndex ) ; long longBits = Double . doubleToLongBits ( value ) ; int low = startIndex , mid = - NUM_ , high = endIndex - NUM_ ; while ( low <= high ) { mid = ( low + high ) > > > NUM_ ; if ( lessThan ( array [ mid ] , value ) ) { low = mid + NUM_ ; } else if ( longBits == Double . doubleToLongBits ( array [ mid ] ) ) { return mid ; } else { high = mid - NUM_ ; } } if ( mid < NUM_ ) { int insertPoint = endIndex ; for ( int index = startIndex ; index < endIndex ; index ++ ) { if ( value < array [ index ] ) { insertPoint = index ; } } return - insertPoint - NUM_ ; } return - mid - ( lessThan ( value , array [ mid ] ) ? NUM_ : NUM_ ) ; }
public static void compute ( double minScore , double topPercent , double maxExpected , float minPercentIdentity , IReadBlock readBlock , String classificationName , BitSet activeMatchesForClassification ) { activeMatchesForClassification . clear ( ) ; for ( int i = NUM_ ; i < readBlock . getNumberOfAvailableMatchBlocks ( ) ; i ++ ) { final IMatchBlock matchBlock = readBlock . getMatchBlock ( i ) ; if ( ! matchBlock . isIgnore ( ) && matchBlock . getBitScore ( ) >= minScore && matchBlock . getExpected ( ) <= maxExpected && matchBlock . getPercentIdentity ( ) >= minPercentIdentity ) { if ( matchBlock . getId ( classificationName ) > NUM_ ) activeMatchesForClassification . set ( i ) ; } } float bestScore = NUM_ ; for ( int i = activeMatchesForClassification . nextSetBit ( NUM_ ) ; i != - NUM_ ; i = activeMatchesForClassification . nextSetBit ( i + NUM_ ) ) { final IMatchBlock matchBlock = readBlock . getMatchBlock ( i ) ; float score = matchBlock . getBitScore ( ) ; if ( score > bestScore ) bestScore = score ; } applyTopPercentFilter ( topPercent , bestScore , minPercentIdentity , readBlock , activeMatchesForClassification ) ; }
public E [ ] toArray ( E [ ] a ) { if ( a . length != array . length ( ) ) { throw new ElasticsearchGenerationException ( STR_ ) ; } for ( int i = NUM_ ; i < array . length ( ) ; i ++ ) { a [ i ] = array . get ( i ) ; } return a ; }
synchronized public void failOn ( Failure fail ) { if ( failures == null ) { failures = new ArrayList < > ( ) ; } failures . add ( fail ) ; }
public void dump_stack ( ) { if ( stack == null ) { debug_message ( STR_ ) ; return ; } debug_message ( STR_ ) ; for ( int i = NUM_ ; i < stack . size ( ) ; i ++ ) { debug_message ( STR_ + ( ( symbol ) stack . elementAt ( i ) ) . sym + STR_ + ( ( symbol ) stack . elementAt ( i ) ) . parse_state ) ; } debug_message ( STR_ ) ; }
private static Set < String > createCategoriesSet ( Set < String > categories ) { Set < String > result = new HashSet < > ( ) ; for ( String cat : categories ) { result . add ( StringUtil . toLowerCase ( cat ) ) ; } return result ; }
public void loadListener ( String serverKey ) throws GenericServiceException { Server server = servers . get ( serverKey ) ; if ( server == null ) throw new GenericServiceException ( STR_ ) ; loadListener ( serverKey , server ) ; }
public void upload ( File file , long restartAt , FTPDataTransferListener listener ) throws IllegalStateException , FileNotFoundException , IOException , FTPIllegalReplyException , FTPException , FTPDataTransferException , FTPAbortedException { if ( ! file . exists ( ) ) { throw new FileNotFoundException ( file . getAbsolutePath ( ) ) ; } InputStream inputStream = null ; try { inputStream = new FileInputStream ( file ) ; } catch ( IOException e ) { throw new FTPDataTransferException ( e ) ; } try { upload ( file . getName ( ) , inputStream , restartAt , restartAt , listener ) ; } catch ( IllegalStateException e ) { throw e ; } catch ( IOException e ) { throw e ; } catch ( FTPIllegalReplyException e ) { throw e ; } catch ( FTPException e ) { throw e ; } catch ( FTPDataTransferException e ) { throw e ; } catch ( FTPAbortedException e ) { throw e ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public SSLSocket createSSLSocket ( Socket socket ) throws IOException { SSLSocketFactory sf = ( ( SSLSocketFactory ) SSLSocketFactory . getDefault ( ) ) ; InetSocketAddress remoteAddress = ( InetSocketAddress ) socket . getRemoteSocketAddress ( ) ; SSLSocket s = ( SSLSocket ) ( sf . createSocket ( socket , remoteAddress . getHostName ( ) , socket . getPort ( ) , BOOL_ ) ) ; s . setUseClientMode ( BOOL_ ) ; s . setEnabledCipherSuites ( s . getSupportedCipherSuites ( ) ) ; return s ; }
private String formatNode ( RightThreadedBinaryNode < T > node ) { RightThreadedBinaryNode < T > n ; StringBuilder response = new StringBuilder ( STR_ ) ; if ( ( n = node . getLeftSon ( ) ) != null ) { response . append ( formatNode ( n ) ) ; } response . append ( node . toString ( ) ) ; if ( ( n = node . getRightSon ( ) ) != null ) { response . append ( formatNode ( n ) ) ; } response . append ( STR_ ) ; return response . toString ( ) ; }
public static void unregisterMBean ( Class < ? > mbeanInterface ) { MBeanServer mbs = ManagementFactory . getPlatformMBeanServer ( ) ; try { ObjectName name = generateMBeanObjectName ( mbeanInterface ) ; if ( mbs . isRegistered ( name ) ) { logger . info ( STR_ + name . toString ( ) ) ; mbs . unregisterMBean ( name ) ; } else { logger . warn ( STR_ + name . toString ( ) ) ; } } catch ( Exception e ) { throw new ServerRuntimeException ( STR_ + mbeanInterface , e ) ; } }
public void writeExif ( InputStream jpegStream , String exifOutFileName ) throws FileNotFoundException , IOException { if ( jpegStream == null || exifOutFileName == null ) { throw new IllegalArgumentException ( NULL_ARGUMENT_STRING ) ; } OutputStream s = null ; try { s = getExifWriterStream ( exifOutFileName ) ; doExifStreamIO ( jpegStream , s ) ; s . flush ( ) ; } catch ( IOException e ) { closeSilently ( s ) ; throw e ; } s . close ( ) ; }
public void sort ( Comparator < ? super T > comparator ) { synchronized ( mLock ) { if ( mOriginalValues != null ) { Collections . sort ( mOriginalValues , comparator ) ; } else { Collections . sort ( mObjects , comparator ) ; } } if ( mNotifyOnChange ) notifyDataSetChanged ( ) ; }
static boolean causedByRDE ( DiskAccessException dae ) { boolean result = BOOL_ ; if ( dae != null ) { Throwable cause = dae . getCause ( ) ; while ( cause != null ) { if ( cause instanceof RegionDestroyedException ) { result = BOOL_ ; break ; } cause = cause . getCause ( ) ; } } return result ; }
public JsonArray add ( String value ) { values . add ( Json . value ( value ) ) ; return this ; }
public MagicVariablesArgumentsBundle ( @ NonNull Map < String , String > arguments , @ NonNull Map < String , String > variables , String layerName , @ NonNull DisplayMetrics metrics ) { super ( arguments , metrics ) ; mVariables = variables ; mLayerNamePrefix = STR_ + layerName . replace ( STR_ , STR_ ) + STR_ ; }
@ HLEUnimplemented @ HLEFunction ( nid = xCFE9E999 , version = NUM_ ) public int sceUsbCamSetupVideoEx ( pspUsbCamSetupVideoExParam usbCamSetupVideoExParam , TPointer workArea , int workAreaSize ) { this . workArea = workArea . getAddress ( ) ; this . workAreaSize = workAreaSize ; resolution = convertResolutionExToResolution ( usbCamSetupVideoExParam . resolution ) ; frameRate = usbCamSetupVideoExParam . framerate ; whiteBalance = usbCamSetupVideoExParam . wb ; saturation = usbCamSetupVideoExParam . saturation ; brightness = usbCamSetupVideoExParam . brightness ; contrast = usbCamSetupVideoExParam . contrast ; sharpness = usbCamSetupVideoExParam . sharpness ; imageEffectMode = usbCamSetupVideoExParam . effectmode ; frameSize = usbCamSetupVideoExParam . framesize ; evLevel = usbCamSetupVideoExParam . evlevel ; if ( ! setupVideo ( ) ) { log . warn ( String . format ( STR_ ) ) ; return SceKernelErrors . ERROR_USBCAM_NOT_READY ; } return NUM_ ; }
public List < User > loadAllDeepFromCursor ( Cursor cursor ) { int count = cursor . getCount ( ) ; List < User > list = new ArrayList < User > ( count ) ; if ( cursor . moveToFirst ( ) ) { if ( identityScope != null ) { identityScope . lock ( ) ; identityScope . reserveRoom ( count ) ; } try { do { list . add ( loadCurrentDeep ( cursor , BOOL_ ) ) ; } while ( cursor . moveToNext ( ) ) ; } finally { if ( identityScope != null ) { identityScope . unlock ( ) ; } } } return list ; }
public static Date convertISO8601toDate ( String dateString ) throws ParseException { DateFormat dateFormat = new SimpleDateFormat ( STR_ ) ; Date date = dateFormat . parse ( dateString ) ; return date ; }
public static Document createDOM ( InputStream is ) throws ParserConfigurationException , SAXException , IOException { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; dbf . setValidating ( BOOL_ ) ; dbf . setIgnoringComments ( BOOL_ ) ; dbf . setIgnoringElementContentWhitespace ( BOOL_ ) ; dbf . setNamespaceAware ( BOOL_ ) ; dbf . setFeature ( XMLConstants . FEATURE_SECURE_PROCESSING , BOOL_ ) ; dbf . setFeature ( DISALLOW_DOCTYPE_DECL , BOOL_ ) ; dbf . setFeature ( EXTERNAL_GENERAL_ENTITIES , BOOL_ ) ; dbf . setFeature ( EXTERNAL_PARAMETER_ENTITIES , BOOL_ ) ; dbf . setFeature ( LOAD_EXTERNAL_DTD , BOOL_ ) ; DocumentBuilder db = null ; db = dbf . newDocumentBuilder ( ) ; db . setEntityResolver ( new NullResolver ( ) ) ; db . setErrorHandler ( new SamlParserErrorHandler ( ) ) ; return db . parse ( is ) ; }
public String toString ( ) { return Double . toString ( getValue ( ) ) ; }
public void resetCount ( ) { msgCnt . set ( NUM_ ) ; }
public void scheduleAtFixedRate ( TimerTask task , Date when , long period ) { if ( period <= NUM_ || when . getTime ( ) < NUM_ ) { throw new IllegalArgumentException ( ) ; } long delay = when . getTime ( ) - System . currentTimeMillis ( ) ; scheduleImpl ( task , delay , period , BOOL_ ) ; }
void decodeAttributeBody ( byte [ ] attributeValue , char offset , char length ) throws StunException { realm = new byte [ length ] ; System . arraycopy ( attributeValue , offset , realm , NUM_ , length ) ; }
public static void copyAssets ( Context context , String assetsFilename , File file , String mode ) throws IOException , InterruptedException { String abi = Build . CPU_ABI ; String libraryName ; if ( abi . equalsIgnoreCase ( STR_ ) ) { libraryName = STR_ ; } else if ( abi . equalsIgnoreCase ( STR_ ) ) { libraryName = STR_ ; } else if ( abi . contains ( STR_ ) ) { libraryName = STR_ ; } else { return ; } AssetManager manager = context . getAssets ( ) ; final InputStream is = manager . open ( libraryName + STR_ + assetsFilename ) ; copyFile ( file , is , mode ) ; }
public boolean is_same ( Object obj ) { if ( this == obj ) return BOOL_ ; if ( obj == null ) return BOOL_ ; if ( getClass ( ) != obj . getClass ( ) ) return BOOL_ ; HouseNumber other = ( HouseNumber ) obj ; if ( number == null ) { if ( name == null ) { if ( other . name != null ) return BOOL_ ; } else if ( ! name . equals ( other . name ) ) return BOOL_ ; } else if ( ! number . equals ( other . number ) ) return BOOL_ ; if ( street == null ) { if ( other . street != null ) return BOOL_ ; } else if ( ! street . equals ( other . street ) ) return BOOL_ ; return BOOL_ ; }
public static double nextUp ( double d ) { if ( d == Double . POSITIVE_INFINITY ) return d ; else { d += NUM_ ; return Double . longBitsToDouble ( Double . doubleToRawLongBits ( d ) + ( ( d >= NUM_ ) ? + NUM_ : - NUM_ ) ) ; } }
public int threeWayDistance ( Key k1 , Key k2 ) { byte [ ] h0 = hash ; byte [ ] h1 = k1 . hash ; byte [ ] h2 = k2 . hash ; int mmi = mismatch ( h1 , h2 ) ; if ( mmi == - NUM_ ) return NUM_ ; int h = Byte . toUnsignedInt ( h0 [ mmi ] ) ; int a = Byte . toUnsignedInt ( h1 [ mmi ] ) ; int b = Byte . toUnsignedInt ( h2 [ mmi ] ) ; return Integer . compareUnsigned ( a ^ h , b ^ h ) ; }
static byte [ ] discardWhitespace ( byte [ ] data ) { byte groomedData [ ] = new byte [ data . length ] ; int bytesCopied = NUM_ ; for ( int i = NUM_ ; i < data . length ; i ++ ) { switch ( data [ i ] ) { case ( byte ) STR_ : case ( byte ) STR_ : case ( byte ) STR_ : case ( byte ) STR_ : break ; default : groomedData [ bytesCopied ++ ] = data [ i ] ; } } byte packedData [ ] = new byte [ bytesCopied ] ; System . arraycopy ( groomedData , NUM_ , packedData , NUM_ , bytesCopied ) ; return packedData ; }
public AsyncSelector ( ) throws IOException { this ( Selector . open ( ) ) ; }
public void removeChildAt ( int index ) { if ( ( index < NUM_ ) || ( children == null ) || ( index >= children . size ( ) ) ) { throw new ArrayIndexOutOfBoundsException ( ) ; } Element child = ( Element ) children . get ( index ) ; child . setParent ( null ) ; children . remove ( index ) ; }
private LinkedList < Diff > diff_bisectSplit ( String text1 , String text2 , int x , int y , long deadline ) { String text1a = text1 . substring ( NUM_ , x ) ; String text2a = text2 . substring ( NUM_ , y ) ; String text1b = text1 . substring ( x ) ; String text2b = text2 . substring ( y ) ; LinkedList < Diff > diffs = diff_main ( text1a , text2a , BOOL_ , deadline ) ; LinkedList < Diff > diffsb = diff_main ( text1b , text2b , BOOL_ , deadline ) ; diffs . addAll ( diffsb ) ; return diffs ; }
private void paint ( Painter p , SynthContext ctx , Graphics g , int x , int y , int w , int h , AffineTransform transform ) { if ( p != null ) { if ( g instanceof Graphics2D ) { Graphics2D gfx = ( Graphics2D ) g ; if ( transform != null ) { gfx . transform ( transform ) ; } gfx . translate ( x , y ) ; p . paint ( gfx , ctx . getComponent ( ) , w , h ) ; gfx . translate ( - x , - y ) ; if ( transform != null ) { try { gfx . transform ( transform . createInverse ( ) ) ; } catch ( NoninvertibleTransformException e ) { e . printStackTrace ( ) ; } } } else { BufferedImage img = new BufferedImage ( w , h , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D gfx = img . createGraphics ( ) ; if ( transform != null ) { gfx . transform ( transform ) ; } p . paint ( gfx , ctx . getComponent ( ) , w , h ) ; gfx . dispose ( ) ; g . drawImage ( img , x , y , null ) ; img = null ; } } }
static void loadDirectory ( File file , ModuleCandidate candidate ) throws IOException { File [ ] files = file . listFiles ( ) ; if ( files != null ) for ( File f : files ) loadSubDirectory ( file , f , candidate ) ; }
public static boolean hasSuppressed ( @ Nullable Throwable t , @ Nullable Class < ? extends Throwable > cls ) { if ( t == null || cls == null ) return BOOL_ ; if ( t . getSuppressed ( ) != null ) { for ( Throwable th : t . getSuppressed ( ) ) { if ( cls . isAssignableFrom ( th . getClass ( ) ) ) return BOOL_ ; if ( hasSuppressed ( th , cls ) ) return BOOL_ ; } } return BOOL_ ; }
static int writeVarLong ( OutputStream out , long x ) throws IOException { int len = NUM_ ; while ( ( x & ~ x7f ) != NUM_ ) { out . write ( ( byte ) ( x80 | ( x & x7f ) ) ) ; x >>>= NUM_ ; len ++ ; } out . write ( ( byte ) x ) ; return ++ len ; }
protected void engineUpdate ( byte b ) throws SignatureException { messageDigest . update ( b ) ; needsReset = BOOL_ ; }
private void writeObject ( java . io . ObjectOutputStream s ) throws java . io . IOException { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { s . defaultWriteObject ( ) ; for ( Node < E > p = first ; p != null ; p = p . next ) s . writeObject ( p . item ) ; s . writeObject ( null ) ; } finally { lock . unlock ( ) ; } }
private boolean checkIfInitiatorForRPBeforeMigration ( Initiator initiator ) { if ( initiator == null ) { return BOOL_ ; } boolean isRP = BOOL_ ; if ( NullColumnValueGetter . isNullValue ( initiator . getHostName ( ) ) || ! NullColumnValueGetter . isNullURI ( initiator . getHost ( ) ) ) { isRP = BOOL_ ; } log . debug ( STR_ + ( isRP ? STR_ : STR_ ) ) ; return isRP ; }
@ Override public Collection < SerialMessage > initialize ( boolean refresh ) { ArrayList < SerialMessage > result = new ArrayList < SerialMessage > ( ) ; if ( isSupportRequestSupported == BOOL_ && ( refresh == BOOL_ || initialiseDone == BOOL_ ) && getVersion ( ) > NUM_ ) { result . add ( getSupportedMessage ( ) ) ; } return result ; }
public static Object [ ] sortCopy ( Object [ ] objects , Comparer comparer ) { int len = objects . length ; Object [ ] copy = new Object [ len ] ; System . arraycopy ( objects , NUM_ , copy , NUM_ , len ) ; sort ( copy , comparer ) ; return copy ; }
public static DMLConfig readConfigurationFile ( String configPath ) throws ParseException , FileNotFoundException { DMLConfig config = new DMLConfig ( ) ; if ( configPath != null ) { try { config = new DMLConfig ( configPath , BOOL_ ) ; } catch ( FileNotFoundException fnfe ) { LOG . error ( STR_ + configPath + STR_ ) ; throw fnfe ; } catch ( ParseException e ) { throw e ; } } else { try { config = new DMLConfig ( DEFAULT_SYSTEMML_CONFIG_FILEPATH , BOOL_ ) ; } catch ( FileNotFoundException fnfe ) { LOG . info ( STR_ + STR_ ) ; config = new DMLConfig ( ) ; } catch ( ParseException e ) { throw e ; } } return config ; }
default B withDefault ( String key , int value ) { return withDefault ( key , Integer . toString ( value ) ) ; }
private String [ ] combineResultsFromMultipleReads ( String [ ] buffer , String [ ] lastRead ) { String [ ] t = new String [ buffer . length + lastRead . length ] ; System . arraycopy ( buffer , NUM_ , t , NUM_ , buffer . length ) ; System . arraycopy ( lastRead , NUM_ , t , buffer . length , lastRead . length ) ; return t ; }
private static boolean isRetina ( ) { if ( SystemInfo . isAppleJvm ) { return hasAppleRetinaDevice ( ) ; } if ( SystemInfo . isMac ) { GraphicsEnvironment e = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; GraphicsDevice [ ] devices = e . getScreenDevices ( ) ; for ( GraphicsDevice device : devices ) { if ( isOracleMacRetinaDevice ( device ) ) { return BOOL_ ; } } } return BOOL_ ; }
protected void scanCompilationUnits ( final List < ICompilationUnit > us ) throws IllegalArgumentException , CoreException { progressMonitor . beginTask ( STR_ , us . size ( ) ) ; for ( final ICompilationUnit ¢ : us ) scanCompilationUnit ( ¢ , newSubMonitor ( progressMonitor ) ) ; progressMonitor . done ( ) ; }
public void pOln ( Object o ) throws IOException { pO ( o . toString ( ) ) ; pln ( ) ; }
private void drawCombat ( final Graphics2D g2d , final int x , final int y , final int width , final int height ) { Rectangle2D wrect = entity . getArea ( ) ; final Rectangle srect = new Rectangle ( ( int ) ( wrect . getX ( ) . IGameScreen . SIZE_UNIT_PIXELS ) , ( int ) ( wrect . getY ( ) . IGameScreen . SIZE_UNIT_PIXELS ) , ( int ) ( wrect . getWidth ( ) . IGameScreen . SIZE_UNIT_PIXELS ) , ( int ) ( wrect . getHeight ( ) . IGameScreen . SIZE_UNIT_PIXELS ) ) ; int circleHeight = ( int ) ( ( srect . height - NUM_ ) / SQRT2 ) ; circleHeight = Math . max ( circleHeight , srect . height - IGameScreen . SIZE_UNIT_PIXELS / NUM_ ) ; if ( entity . isAttacking ( User . get ( ) ) ) { g2d . setColor ( RING_COLOR_ORANGE ) ; g2d . drawOval ( srect . x - NUM_ , srect . y + srect . height - circleHeight , srect . width , circleHeight ) ; g2d . drawOval ( srect . x , srect . y + srect . height - circleHeight , srect . width , circleHeight ) ; g2d . drawOval ( srect . x + NUM_ , srect . y + srect . height - circleHeight , srect . width , circleHeight ) ; drawShadedOval ( g2d , srect . x + NUM_ , srect . y + srect . height - circleHeight + NUM_ , srect . width - NUM_ , circleHeight - NUM_ , RING_COLOR_ORANGE , BOOL_ , BOOL_ ) ; } if ( entity . isBeingAttacked ( ) ) { Color lineColor ; g2d . setColor ( RING_COLOR_RED ) ; if ( entity . isAttacking ( User . get ( ) ) ) { lineColor = RING_COLOR_RED ; drawShadedOval ( g2d , srect . x - NUM_ , srect . y + srect . height - circleHeight - NUM_ , srect . width + NUM_ , circleHeight + NUM_ , RING_COLOR_RED , BOOL_ , BOOL_ ) ; } else { lineColor = RING_COLOR_DARK_RED ; g2d . drawOval ( srect . x - NUM_ , srect . y + srect . height - circleHeight , srect . width , circleHeight ) ; g2d . drawOval ( srect . x , srect . y + srect . height - circleHeight , srect . width , circleHeight ) ; g2d . drawOval ( srect . x + NUM_ , srect . y + srect . height - circleHeight , srect . width , circleHeight ) ; drawShadedOval ( g2d , srect . x + NUM_ , srect . y + srect . height - circleHeight + NUM_ , srect . width - NUM_ , circleHeight - NUM_ , RING_COLOR_RED , BOOL_ , BOOL_ ) ; drawShadedOval ( g2d , srect . x - NUM_ , srect . y + srect . height - circleHeight - NUM_ , srect . width + NUM_ , circleHeight + NUM_ , RING_COLOR_ORANGE , BOOL_ , BOOL_ ) ; } EnumSet < Direction > directions = EnumSet . noneOf ( Direction . class ) ; for ( Entity attacker : entity . getAttackers ( ) ) { directions . add ( Direction . getAreaDirectionTowardsArea ( entity . getArea ( ) , attacker . getArea ( ) ) ) ; } drawArrows ( g2d , srect . x - NUM_ , srect . y + srect . height - circleHeight - NUM_ , srect . width + NUM_ , circleHeight + NUM_ , directions , lineColor ) ; } else if ( entity . isAttacking ( User . get ( ) ) ) { drawShadedOval ( g2d , srect . x - NUM_ , srect . y + srect . height - circleHeight - NUM_ , srect . width + NUM_ , circleHeight + NUM_ , RING_COLOR_ORANGE , BOOL_ , BOOL_ ) ; } drawAttack ( g2d , x , y , width , height ) ; if ( entity . isDefending ( ) ) { final int sx = srect . x + srect . width - ICON_OFFSET ; final int sy = y + height - NUM_ . ICON_OFFSET ; switch ( entity . getResolution ( ) ) { case BLOCKED : blockedSprite . draw ( g2d , sx , sy ) ; break ; case MISSED : missedSprite . draw ( g2d , sx , sy ) ; break ; case HIT : hitSprite . draw ( g2d , sx , sy ) ; break ; default : } } }
public ActivityResolveInfo ( ResolveInfo resolveInfo ) { this . resolveInfo = resolveInfo ; }
private static Pair < String , String > postIndexedLSR ( final long offset , final ITranslationEnvironment environment , final List < ReilInstruction > instructions , final String registerNodeValue1 , final String registerNodeValue2 , final String immediateNodeValue ) { final String address = environment . getNextVariableString ( ) ; final String tmpVar1 = environment . getNextVariableString ( ) ; final String tmpVar2 = environment . getNextVariableString ( ) ; final String index = environment . getNextVariableString ( ) ; long baseOffset = offset ; instructions . add ( ReilHelpers . createStr ( baseOffset ++ , dw , registerNodeValue1 , dw , address ) ) ; instructions . add ( ReilHelpers . createBsh ( baseOffset ++ , dw , registerNodeValue2 , dw , STR_ + immediateNodeValue , qw , tmpVar1 ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , qw , tmpVar1 , dw , dWordBitMask , dw , index ) ) ; instructions . add ( ReilHelpers . createAdd ( baseOffset ++ , dw , registerNodeValue1 , dw , index , dw , tmpVar2 ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , dw , tmpVar2 , dw , dWordBitMask , dw , registerNodeValue1 ) ) ; return new Pair < String , String > ( address , registerNodeValue1 ) ; }
private void endFormals ( ) { if ( hasFormals ) { hasFormals = BOOL_ ; buf . append ( STR_ ) ; } }
public boolean nextIsSep ( ) { if ( Character . isLetterOrDigit ( str . charAt ( currentPosition ) ) ) return BOOL_ ; else return BOOL_ ; }
private String extractProjectNameFromUri ( @ NotNull String uri ) { int indexFinishProjectName = uri . lastIndexOf ( STR_ ) ; int indexStartProjectName = uri . lastIndexOf ( STR_ ) != - NUM_ ? uri . lastIndexOf ( STR_ ) + NUM_ : ( uri . lastIndexOf ( STR_ ) + NUM_ ) ; if ( indexStartProjectName != NUM_ && indexStartProjectName < indexFinishProjectName ) { return uri . substring ( indexStartProjectName , indexFinishProjectName ) ; } if ( indexStartProjectName != NUM_ ) { return uri . substring ( indexStartProjectName ) ; } return STR_ ; }
public final void addReference ( Object ref ) { refSet . add ( ref ) ; }
private void resetNotes2 ( ) { if ( errorInStatus2 ) { if ( editMode ) { statusText1 . setText ( editStatus2 ) ; } else { statusText2 . setText ( stdStatus2 ) ; } errorInStatus2 = BOOL_ ; } }
public RequirementsBuilder addRequireProperty ( String name , RequirementsBuilder builder ) { addProperty ( name , builder ) ; requiredProperties . add ( name ) ; return this ; }
private Cell detectAndAddHit ( float x , float y ) { final Cell cell = checkForNewHit ( x , y ) ; if ( cell != null ) { Cell fillInGapCell = null ; final ArrayList < Cell > pattern = mPattern ; if ( ! pattern . isEmpty ( ) ) { final Cell lastCell = pattern . get ( pattern . size ( ) - NUM_ ) ; int dRow = cell . row - lastCell . row ; int dColumn = cell . column - lastCell . column ; int fillInRow = lastCell . row ; int fillInColumn = lastCell . column ; if ( Math . abs ( dRow ) == NUM_ && Math . abs ( dColumn ) != NUM_ ) { fillInRow = lastCell . row + ( ( dRow > NUM_ ) ? NUM_ : - NUM_ ) ; } if ( Math . abs ( dColumn ) == NUM_ && Math . abs ( dRow ) != NUM_ ) { fillInColumn = lastCell . column + ( ( dColumn > NUM_ ) ? NUM_ : - NUM_ ) ; } fillInGapCell = Cell . of ( fillInRow , fillInColumn ) ; } if ( fillInGapCell != null && ! mPatternDrawLookup [ fillInGapCell . row ] [ fillInGapCell . column ] ) { addCellToPattern ( fillInGapCell ) ; } addCellToPattern ( cell ) ; if ( mEnableHapticFeedback ) { performHapticFeedback ( HapticFeedbackConstants . VIRTUAL_KEY , HapticFeedbackConstants . FLAG_IGNORE_VIEW_SETTING | HapticFeedbackConstants . FLAG_IGNORE_GLOBAL_SETTING ) ; } return cell ; } return null ; }
public HeadRule ( String dir , String rule ) { String [ ] tmp = P_TAGSETS . split ( rule ) ; int i , size = tmp . length ; b_r2l = dir . equals ( DIR_RIGHT_TO_LEFT ) ; a_tagSets = new HeadTagSet [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) a_tagSets [ i ] = new HeadTagSet ( tmp [ i ] ) ; }
public void testNegPosFirstShorter ( ) { byte aBytes [ ] = { - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { - NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ } ; int aSign = - NUM_ ; int bSign = NUM_ ; byte rBytes [ ] = { - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . or ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , - NUM_ , result . signum ( ) ) ; }
@ Override public < T > Future < T > submit ( Callable < T > task ) { synchronized ( this ) { active . incrementAndGet ( ) ; long timeout = NUM_ ; while ( queue . remainingCapacity ( ) == NUM_ ) { try { if ( timeout <= giveupTime ) { Thread . sleep ( DEFAULT_SLEEP ) ; timeout += DEFAULT_SLEEP ; } else { throw new RuntimeException ( STR_ ) ; } } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } } return super . submit ( task ) ; } }
public void testSubtractMathContextDiffScalePosNeg ( ) { String a = STR_ ; int aScale = NUM_ ; String b = STR_ ; int bScale = - NUM_ ; String c = STR_ ; int cScale = - NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal bNumber = new BigDecimal ( new BigInteger ( b ) , bScale ) ; MathContext mc = new MathContext ( NUM_ , RoundingMode . DOWN ) ; BigDecimal result = aNumber . subtract ( bNumber , mc ) ; assertEquals ( STR_ , c , result . toString ( ) ) ; assertEquals ( STR_ , cScale , result . scale ( ) ) ; }
protected XSQLDA allocateXSqlDa ( RowDescriptor rowDescriptor ) { if ( rowDescriptor == null || rowDescriptor . getCount ( ) == NUM_ ) { final XSQLDA xSqlDa = new XSQLDA ( NUM_ ) ; xSqlDa . sqld = xSqlDa . sqln = NUM_ ; return xSqlDa ; } final XSQLDA xSqlDa = new XSQLDA ( rowDescriptor . getCount ( ) ) ; for ( int idx = NUM_ ; idx < rowDescriptor . getCount ( ) ; idx ++ ) { final FieldDescriptor fieldDescriptor = rowDescriptor . getFieldDescriptor ( idx ) ; final XSQLVAR xSqlVar = xSqlDa . sqlvar [ idx ] ; xSqlVar . sqltype = ( short ) ( fieldDescriptor . getType ( ) | NUM_ ) ; xSqlVar . sqlsubtype = ( short ) fieldDescriptor . getSubType ( ) ; xSqlVar . sqlscale = ( short ) fieldDescriptor . getScale ( ) ; xSqlVar . sqllen = ( short ) fieldDescriptor . getLength ( ) ; xSqlVar . sqlind = new ShortByReference ( ) ; final int requiredDataSize = fieldDescriptor . isVarying ( ) ? fieldDescriptor . getLength ( ) + NUM_ : fieldDescriptor . getLength ( ) + NUM_ ; xSqlVar . sqldata = new Memory ( requiredDataSize ) ; } return xSqlDa ; }
public static void overwrite ( long [ ] vector , long val , int offset , int len ) { int idx = offset > > NUM_ ; int bitIdx = offset & NUM_ ; int truncatedValLen = Math . min ( len , NUM_ - bitIdx ) ; vector [ idx ] &= ~ ( maskBelow ( truncatedValLen ) << bitIdx ) ; vector [ idx ] |= val << bitIdx ; if ( len != truncatedValLen ) { long mask = maskBelow ( len - truncatedValLen ) ; vector [ idx + NUM_ ] &= ~ mask ; vector [ idx + NUM_ ] |= ( val > > > truncatedValLen ) ; } }
public static boolean isEmpty ( String string ) { if ( null == string ) return BOOL_ ; return string . equals ( EMPTY ) ; }
public void addScrollViewListener ( WXScrollViewListener scrollViewListener ) { if ( ! mScrollViewListeners . contains ( scrollViewListener ) ) { mScrollViewListeners . add ( scrollViewListener ) ; } }
Callbacks tryGetCallbacks ( Callbacks oldCallbacks ) { synchronized ( mLock ) { if ( mStopped ) { return null ; } if ( mCallbacks == null ) { return null ; } final Callbacks callbacks = mCallbacks . get ( ) ; if ( callbacks != oldCallbacks ) { return null ; } if ( callbacks == null ) { Log . w ( TAG , STR_ ) ; return null ; } return callbacks ; } }
public void beginUpdateMemoryUsed ( long bytesUsed , boolean willSendEvent ) ;
@ Override public Point translateJava2DToScreen ( Point2D java2DPoint ) { Insets insets = getInsets ( ) ; int x = ( int ) ( java2DPoint . getX ( ) . this . scaleX + insets . left ) ; int y = ( int ) ( java2DPoint . getY ( ) . this . scaleY + insets . top ) ; return new Point ( x , y ) ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
protected FastMap < String > readDeclaredProperties ( WidgetCreatorContext context ) { FastMap < String > declaredProperties = new FastMap < String > ( ) ; String backColor = context . readWidgetProperty ( STR_ ) ; if ( backColor != null && backColor . length ( ) > NUM_ ) { declaredProperties . put ( STR_ , backColor ) ; } String fontName = context . readWidgetProperty ( STR_ ) ; if ( fontName != null && fontName . length ( ) > NUM_ ) { declaredProperties . put ( STR_ , fontName ) ; } String fontSize = context . readWidgetProperty ( STR_ ) ; if ( fontSize != null && fontSize . length ( ) > NUM_ ) { declaredProperties . put ( STR_ , fontSize ) ; } String foreColor = context . readWidgetProperty ( STR_ ) ; if ( foreColor != null && foreColor . length ( ) > NUM_ ) { declaredProperties . put ( STR_ , foreColor ) ; } String justification = context . readWidgetProperty ( STR_ ) ; if ( justification != null && justification . length ( ) > NUM_ ) { declaredProperties . put ( STR_ , justification ) ; } String bold = context . readWidgetProperty ( STR_ ) ; if ( bold != null && bold . length ( ) > NUM_ ) { declaredProperties . put ( STR_ , bold ) ; } String italic = context . readWidgetProperty ( STR_ ) ; if ( italic != null && italic . length ( ) > NUM_ ) { declaredProperties . put ( STR_ , italic ) ; } String subscript = context . readWidgetProperty ( STR_ ) ; if ( subscript != null && subscript . length ( ) > NUM_ ) { declaredProperties . put ( STR_ , subscript ) ; } String superscript = context . readWidgetProperty ( STR_ ) ; if ( superscript != null && superscript . length ( ) > NUM_ ) { declaredProperties . put ( STR_ , superscript ) ; } String underline = context . readWidgetProperty ( STR_ ) ; if ( underline != null && underline . length ( ) > NUM_ ) { declaredProperties . put ( STR_ , underline ) ; } String strikethrough = context . readWidgetProperty ( STR_ ) ; if ( strikethrough != null && strikethrough . length ( ) > NUM_ ) { declaredProperties . put ( STR_ , strikethrough ) ; } return declaredProperties ; }
private void updateTrafficProjections ( ) { List < AirMapTraffic > updated = new ArrayList < > ( ) ; for ( AirMapTraffic traffic : allTraffic ) { if ( traffic . getGroundSpeedKt ( ) > - NUM_ && traffic . getTrueHeading ( ) > - NUM_ ) { allTraffic . remove ( traffic ) ; Coordinate projected = projectedCoordinate ( traffic ) ; traffic . setCoordinate ( projected ) ; traffic . setShowAlert ( BOOL_ ) ; allTraffic . add ( traffic ) ; updated . add ( traffic ) ; } } notifyUpdated ( updated ) ; }
public static void logStackTrace ( Level level , Throwable throwable ) { logStackTrace ( level , throwable , null ) ; }
public static float computeContrastBetweenColors ( int bg , int fg ) { float bgR = Color . red ( bg ) / NUM_ ; float bgG = Color . green ( bg ) / NUM_ ; float bgB = Color . blue ( bg ) / NUM_ ; bgR = ( bgR < NUM_ ) ? bgR / NUM_ : ( float ) Math . pow ( ( bgR + NUM_ ) / NUM_ , NUM_ ) ; bgG = ( bgG < NUM_ ) ? bgG / NUM_ : ( float ) Math . pow ( ( bgG + NUM_ ) / NUM_ , NUM_ ) ; bgB = ( bgB < NUM_ ) ? bgB / NUM_ : ( float ) Math . pow ( ( bgB + NUM_ ) / NUM_ , NUM_ ) ; float bgL = NUM_ . bgR + NUM_ . bgG + NUM_ . bgB ; float fgR = Color . red ( fg ) / NUM_ ; float fgG = Color . green ( fg ) / NUM_ ; float fgB = Color . blue ( fg ) / NUM_ ; fgR = ( fgR < NUM_ ) ? fgR / NUM_ : ( float ) Math . pow ( ( fgR + NUM_ ) / NUM_ , NUM_ ) ; fgG = ( fgG < NUM_ ) ? fgG / NUM_ : ( float ) Math . pow ( ( fgG + NUM_ ) / NUM_ , NUM_ ) ; fgB = ( fgB < NUM_ ) ? fgB / NUM_ : ( float ) Math . pow ( ( fgB + NUM_ ) / NUM_ , NUM_ ) ; float fgL = NUM_ . fgR + NUM_ . fgG + NUM_ . fgB ; return Math . abs ( ( fgL + NUM_ ) / ( bgL + NUM_ ) ) ; }
@ Override public int read ( ) throws IOException { int ch = super . read ( ) ; if ( ch != - NUM_ ) { branch . write ( ch ) ; } return ch ; }
private SublimeBaseMenuItem addInternal ( int group , int id , CharSequence title , CharSequence hint , SublimeBaseMenuItem . ItemType itemType , boolean valueProvidedAsync , CharSequence badgeText , boolean showsIconSpace , boolean addedByUser ) { SublimeBaseMenuItem item ; boolean isGroupHeader = BOOL_ ; switch ( itemType ) { case SEPARATOR : item = new SublimeSeparatorMenuItem ( this , group , id ) ; break ; case BADGE : item = new SublimeTextWithBadgeMenuItem ( this , group , id , title , hint , valueProvidedAsync , badgeText , showsIconSpace ) ; break ; case SWITCH : item = new SublimeSwitchMenuItem ( this , group , id , title , hint , valueProvidedAsync , showsIconSpace ) ; break ; case CHECKBOX : item = new SublimeCheckboxMenuItem ( this , group , id , title , hint , valueProvidedAsync , showsIconSpace ) ; break ; case GROUP_HEADER : isGroupHeader = BOOL_ ; item = new SublimeGroupHeaderMenuItem ( this , group , id , title , hint , valueProvidedAsync , showsIconSpace ) ; break ; default : item = new SublimeTextMenuItem ( this , group , id , title , hint , valueProvidedAsync , showsIconSpace ) ; break ; } checkExistenceOfGroup ( group ) ; if ( isGroupHeader ) { checkIfGroupHeaderAlreadyExistsForGroup ( group ) ; int index = findGroupIndex ( group ) ; if ( index >= NUM_ ) { mItems . add ( index , item ) ; } else { mItems . add ( item ) ; } } else if ( addedByUser ) { if ( group != NO_GROUP_ID ) { int lastGroupIndex = findLastGroupIndex ( group ) ; mItems . add ( lastGroupIndex == mItems . size ( ) ? lastGroupIndex : lastGroupIndex + NUM_ , item ) ; } else { mItems . add ( item ) ; } } else { mItems . add ( item ) ; } onItemsChanged ( ) ; return item ; }
public static String decodeBCD ( final short bcd ) { return String . format ( STR_ , ( bcd & xFF00 ) > > NUM_ , bcd & x00FF ) ; }
public void drawBackground ( Graphics g ) { g . fillRect ( NUM_ , NUM_ , getWidth ( ) , getHeight ( ) ) ; }
public void put ( int key , int value ) { int i = binarySearch ( mKeys , NUM_ , mSize , key ) ; if ( i >= NUM_ ) { mValues [ i ] = value ; } else { i = ~ i ; if ( mSize >= mKeys . length ) { int n = Math . max ( mSize + NUM_ , mKeys . length . NUM_ ) ; int [ ] nkeys = new int [ n ] ; int [ ] nvalues = new int [ n ] ; System . arraycopy ( mKeys , NUM_ , nkeys , NUM_ , mKeys . length ) ; System . arraycopy ( mValues , NUM_ , nvalues , NUM_ , mValues . length ) ; mKeys = nkeys ; mValues = nvalues ; } if ( mSize - i != NUM_ ) { System . arraycopy ( mKeys , i , mKeys , i + NUM_ , mSize - i ) ; System . arraycopy ( mValues , i , mValues , i + NUM_ , mSize - i ) ; } mKeys [ i ] = key ; mValues [ i ] = value ; mSize ++ ; } }
public void addLayoutEditor ( LayoutEditor panel ) { if ( panels . size ( ) > NUM_ ) { for ( int i = NUM_ ; i < panels . size ( ) ; i ++ ) { LayoutEditor ed = panels . get ( i ) ; if ( ed == panel ) { return ; } } } panels . add ( panel ) ; }
void triggerWildcardExpander ( final Collection < File > allFiles , final WildcardContext wildcardContext ) throws IOException { LOG . debug ( STR_ , allFiles ) ; if ( allFiles . isEmpty ( ) ) { final String message = String . format ( STR_ , wildcardContext . getWildcard ( ) ) ; LOG . warn ( message ) ; throw new IOException ( message ) ; } if ( wildcardExpanderHandler != null ) { try { wildcardExpanderHandler . apply ( allFiles ) ; } catch ( final IOException e ) { throw e ; } catch ( final Exception e ) { LOG . debug ( STR_ , e ) ; throw new IOException ( STR_ + e . getMessage ( ) ) ; } } }
@ POST @ Consumes ( { MediaType . APPLICATION_XML , MediaType . APPLICATION_JSON } ) @ Produces ( { MediaType . APPLICATION_XML , MediaType . APPLICATION_JSON } ) @ CheckPermission ( roles = { Role . TENANT_ADMIN } ) @ Path ( STR_ ) public IpInterfaceRestRep createIpInterface ( @ PathParam ( STR_ ) URI id , IpInterfaceCreateParam createParam ) throws DatabaseException { Host host = queryObject ( Host . class , id , BOOL_ ) ; validateIpInterfaceData ( createParam , null ) ; IpInterface ipInterface = new IpInterface ( ) ; ipInterface . setHost ( host . getId ( ) ) ; ipInterface . setId ( URIUtil . createId ( IpInterface . class ) ) ; populateIpInterface ( createParam , ipInterface ) ; _dbClient . createObject ( ipInterface ) ; auditOp ( OperationTypeEnum . CREATE_HOST_IPINTERFACE , BOOL_ , null , ipInterface . auditParameters ( ) ) ; return map ( ipInterface ) ; }
protected List < IEditProposal > collectEditProposals ( ) { List < IEditProposal > proposals = new ArrayList < IEditProposal > ( ) ; View selectedView = getSelectedView ( ) ; if ( selectedView != null ) { if ( proposalProviders != null ) { for ( IEditProposalProvider provider : proposalProviders ) { for ( IEditProposal editProposal : provider . getProposals ( selectedView ) ) { if ( editProposal . isApplicable ( ) ) proposals . add ( editProposal ) ; } } } } return proposals ; }
public ExtensionQuery ( String pluginId , String extensionPointName , String attributeName ) { this . pluginId = extensionPointName . contains ( STR_ ) ? null : pluginId ; this . extensionPointName = extensionPointName ; this . attributeName = attributeName ; }
private void ensureNamespaceExists ( Result result ) { DockerImage image = DockerImage . fromImageName ( result . name ) ; if ( image . getNamespace ( ) == null ) { result . name = String . format ( STR_ , DEFAULT_NAMESPACE , image . getRepository ( ) ) ; } }
public static < K , V > Map < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 , K k5 , V v5 ) { Map map = of ( ) ; map . put ( k1 , v1 ) ; map . put ( k2 , v2 ) ; map . put ( k3 , v3 ) ; map . put ( k4 , v4 ) ; map . put ( k5 , v5 ) ; return map ; }
public void testFilteredClassifier ( ) { Instances data ; int i ; if ( m_FilteredClassifier == null ) { return ; } try { data = getFilteredClassifierData ( ) ; m_FilteredClassifier . buildClassifier ( data ) ; for ( i = NUM_ ; i < data . numInstances ( ) ; i ++ ) { m_FilteredClassifier . classifyInstance ( data . instance ( i ) ) ; } } catch ( Exception e ) { fail ( STR_ + e . toString ( ) ) ; } }
public static String upperFirstChar ( String string ) { if ( string == null ) return null ; if ( string . length ( ) <= NUM_ ) return string . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( string ) ; sb . setCharAt ( NUM_ , Character . toUpperCase ( sb . charAt ( NUM_ ) ) ) ; return sb . toString ( ) ; }
protected int chooseRandomIndexBasedOnProportions ( double [ ] proportionArray , Random random ) { double probSum ; double val ; int index ; double sum ; probSum = Utils . sum ( proportionArray ) ; val = random . nextDouble ( ) . probSum ; index = NUM_ ; sum = NUM_ ; while ( ( sum <= val ) && ( index < proportionArray . length ) ) { sum += proportionArray [ index ++ ] ; } return index - NUM_ ; }
private void checkWidth ( final int [ ] rect ) { final int x1 = rect [ NUM_ ] ; final int y2 = rect [ NUM_ ] ; final int y1 = y2 + rect [ NUM_ ] ; final int x2 = x1 + rect [ NUM_ ] ; if ( x1 < pageX1 ) { pageX1 = x1 ; } if ( x2 > pageX2 ) { pageX2 = x2 ; } if ( y1 > pageY1 ) { pageY1 = y1 ; } if ( y2 < pageY2 ) { pageY2 = y2 ; } }
@ NotNull public static Map < RadComponent , List < RadComponent > > groupSiblings ( @ NotNull List < ? extends RadComponent > components ) { Map < RadComponent , List < RadComponent > > siblingLists = new HashMap < RadComponent , List < RadComponent > > ( ) ; if ( components . isEmpty ( ) ) { return siblingLists ; } if ( components . size ( ) == NUM_ ) { RadComponent component = components . get ( NUM_ ) ; siblingLists . put ( component . getParent ( ) , Collections . singletonList ( component ) ) ; return siblingLists ; } for ( RadComponent component : components ) { RadComponent parent = component . getParent ( ) ; List < RadComponent > children = siblingLists . get ( parent ) ; if ( children == null ) { children = new ArrayList < RadComponent > ( ) ; siblingLists . put ( parent , children ) ; } children . add ( component ) ; } return siblingLists ; }
private int countNonNewline ( String str , int off , int len ) { for ( int cnt = NUM_ ; cnt < len ; cnt ++ ) { final int pos = off + cnt ; if ( str . charAt ( pos ) == UNIX_NEWLINE ) { return cnt ; } if ( str . charAt ( pos ) == CARRIAGE_RETURN ) { return cnt ; } } return len ; }
private static int convertSpanToSparseGrid ( int curIx , int span , TreeSet < Integer > indexes ) { int lastIx = curIx + span ; int retSpan = NUM_ ; for ( Integer ix : indexes ) { if ( ix <= curIx ) continue ; if ( ix >= lastIx ) break ; retSpan ++ ; } return retSpan ; }
@ Override public boolean equals ( Object otherRules ) { if ( this == otherRules ) { return BOOL_ ; } if ( otherRules instanceof ZoneRules ) { ZoneRules other = ( ZoneRules ) otherRules ; return Arrays . equals ( standardTransitions , other . standardTransitions ) && Arrays . equals ( standardOffsets , other . standardOffsets ) && Arrays . equals ( savingsInstantTransitions , other . savingsInstantTransitions ) && Arrays . equals ( wallOffsets , other . wallOffsets ) && Arrays . equals ( lastRules , other . lastRules ) ; } return BOOL_ ; }
public String description ( ) { StringBuilder sb = new StringBuilder ( ) ; if ( isCombo ( ) ) { int i = NUM_ ; for ( NewComboLeg leg : m_comboLegs ) { if ( i ++ > NUM_ ) { sb . append ( STR_ ) ; } sb . append ( leg . toString ( ) ) ; } } else { sb . append ( m_symbol ) ; app ( sb , m_secType ) ; app ( sb , m_exchange ) ; if ( m_exchange != null && m_exchange . equals ( STR_ ) && m_primaryExch != null ) { app ( sb , m_primaryExch ) ; } app ( sb , m_expiry ) ; if ( m_strike != NUM_ ) { app ( sb , m_strike ) ; } if ( m_right != Right . None ) { app ( sb , m_right ) ; } } return sb . toString ( ) ; }
public void addClaimedSignerRole ( final String claimedSignerRole ) { if ( ( claimedSignerRole == null ) || ( claimedSignerRole . length ( ) == NUM_ ) ) { throw new NullPointerException ( STR_ ) ; } if ( claimedSignerRoles == null ) { claimedSignerRoles = new ArrayList < String > ( ) ; } claimedSignerRoles . add ( claimedSignerRole ) ; }
@ SuppressWarnings ( STR_ ) @ GwtIncompatible ( STR_ ) public static < K extends Object , V extends Object > void writeMap ( Map < K , V > map , ObjectOutputStream stream ) throws IOException { stream . writeInt ( map . size ( ) ) ; for ( Map . Entry < K , V > entry : map . entrySet ( ) ) { stream . writeObject ( entry . getKey ( ) ) ; stream . writeObject ( entry . getValue ( ) ) ; } }
protected void sleep ( int sleepMillis , int sleepNanos ) throws InterruptedException { Thread . sleep ( sleepMillis , sleepNanos ) ; }
public static void restorePreviousOutAndErrStream ( ) { if ( ! alreadyMuted ) { return ; } System . setOut ( latestOut ) ; System . setErr ( latestErr ) ; alreadyMuted = BOOL_ ; }
public static BigInteger CRT ( List < BigInteger > congs , List < BigInteger > moduli ) { BigInteger [ ] cs = ArrayConverter . convertListToArray ( congs ) ; BigInteger [ ] ms = ArrayConverter . convertListToArray ( moduli ) ; return CRT ( cs , ms ) ; }
private int measureHeight ( int measureSpec ) { int result = NUM_ ; int specMode = MeasureSpec . getMode ( measureSpec ) ; int specSize = MeasureSpec . getSize ( measureSpec ) ; mAscent = ( int ) mTextPaint . ascent ( ) ; if ( specMode == MeasureSpec . EXACTLY ) { result = specSize ; } else { result = ( int ) ( - mAscent + mTextPaint . descent ( ) ) + getPaddingTop ( ) + getPaddingBottom ( ) ; if ( specMode == MeasureSpec . AT_MOST ) { result = Math . min ( result , specSize ) ; } } return result ; }
public ByteVector putByteArray ( final byte [ ] b , final int off , final int len ) { if ( length + len > data . length ) { enlarge ( len ) ; } if ( b != null ) { System . arraycopy ( b , off , data , length , len ) ; } length += len ; return this ; }
public void testCase17 ( ) { byte aBytes [ ] = { - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int bSign = NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . remainder ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
protected < T extends TaskServiceDocument < E > , E extends Enum < E > > T waitForTaskCompletion ( String documentSelfLink , Class < T > type ) throws Throwable { return waitForPropertyValue ( documentSelfLink , type , TaskServiceDocument . FIELD_NAME_TASK_STAGE , Arrays . asList ( TaskStage . FINISHED , TaskStage . FAILED , TaskStage . CANCELLED ) , BOOL_ , waitForStageChangeCountLonger ( ) ) ; }
public Action ( String content , int priority ) { this . content = content . trim ( ) ; this . priority = priority ; }
private List < EndIsland > findSurroundingIslands ( int chunkX , int chunkY , int chunksPerFragmentX , int chunksPerFragmentY ) { List < EndIsland > result = new LinkedList < EndIsland > ( ) ; for ( int y = - SURROUNDING_CHUNKS ; y <= chunksPerFragmentY + SURROUNDING_CHUNKS ; y ++ ) { for ( int x = - SURROUNDING_CHUNKS ; x <= chunksPerFragmentX + SURROUNDING_CHUNKS ; x ++ ) { EndIsland island = tryCreateEndIsland ( chunkX + x , chunkY + y ) ; if ( island != null ) { result . add ( island ) ; } } } return result ; }
private static boolean calculateGap ( Rectangle a , Rectangle b , Rectangle gap ) { if ( a . intersects ( b ) ) { gap . width = NUM_ ; return BOOL_ ; } int ax1 = a . x ; int ax2 = a . x + a . width ; int ay1 = a . y ; int ay2 = a . y + a . height ; int bx1 = b . x ; int bx2 = b . x + b . width ; int by1 = b . y ; int by2 = b . y + b . height ; int xOverlap = Math . min ( ax2 , bx2 ) - Math . max ( ax1 , bx1 ) ; int yOverlap = Math . min ( ay2 , by2 ) - Math . max ( ay1 , by1 ) ; if ( xOverlap <= NUM_ && yOverlap <= NUM_ ) { gap . width = NUM_ ; return BOOL_ ; } if ( xOverlap > NUM_ ) { gap . x = Math . max ( ax1 , bx1 ) ; gap . y = ( ay1 > by1 ) ? by2 : ay2 ; gap . width = xOverlap ; gap . height = - yOverlap ; } if ( yOverlap > NUM_ ) { gap . x = ( ax1 > bx1 ) ? bx2 : ax2 ; gap . y = Math . max ( ay1 , by1 ) ; gap . width = - xOverlap ; gap . height = yOverlap ; } return BOOL_ ; }
public boolean nextTile ( ) throws ModelControlException { boolean movedToRow = super . nextTile ( ) ; if ( movedToRow ) { curTile = getTileIndex ( ) ; setDisplayFieldValue ( TXT_PARENT_INDEX , parentIdx ) ; setDisplayFieldValue ( TXT_CHOICE , choices [ curTile ] ) ; setDisplayFieldValue ( TXT_INDEX , Integer . toString ( curTile ) ) ; } return movedToRow ; }
private boolean journalRebuildRequired ( ) { final int REDUNDANT_OP_COMPACT_THRESHOLD = NUM_ ; return redundantOpCount >= REDUNDANT_OP_COMPACT_THRESHOLD && redundantOpCount >= lruEntries . size ( ) ; }
public boolean hasMyomerBooster ( ) { for ( Mounted mEquip : getMisc ( ) ) { MiscType mtype = ( MiscType ) mEquip . getType ( ) ; if ( mtype . hasFlag ( MiscType . F_MASC ) && ! mEquip . isInoperable ( ) ) { return BOOL_ ; } } return BOOL_ ; }
public static boolean isIntentAvailable ( Context context , String action ) { final PackageManager packageManager = context . getPackageManager ( ) ; final Intent intent = new Intent ( action ) ; Log . d ( MP_TAG , STR_ + action ) ; List < ResolveInfo > list = packageManager . queryIntentServices ( intent , PackageManager . MATCH_DEFAULT_ONLY ) ; return list . size ( ) > NUM_ ; }
@ KnownFailure ( STR_ ) public void test_wrap_02 ( ) throws SSLException { String host = STR_ ; int port = NUM_ ; ByteBuffer bb = ByteBuffer . allocate ( NUM_ ) ; ByteBuffer [ ] bbA = { ByteBuffer . allocate ( NUM_ ) , ByteBuffer . allocate ( NUM_ ) , ByteBuffer . allocate ( NUM_ ) } ; SSLEngine sse = getEngine ( host , port ) ; sse . setUseClientMode ( BOOL_ ) ; try { sse . wrap ( bbA , - NUM_ , NUM_ , bb ) ; fail ( STR_ ) ; } catch ( IndexOutOfBoundsException iobe ) { } try { sse . wrap ( bbA , NUM_ , - NUM_ , bb ) ; fail ( STR_ ) ; } catch ( IndexOutOfBoundsException iobe ) { } try { sse . wrap ( bbA , bbA . length + NUM_ , bbA . length , bb ) ; fail ( STR_ ) ; } catch ( IndexOutOfBoundsException iobe ) { } try { sse . wrap ( bbA , NUM_ , bbA . length + NUM_ , bb ) ; fail ( STR_ ) ; } catch ( IndexOutOfBoundsException iobe ) { } }
private void sendCONNECTRequest ( ) throws IOException { int port = url . getPort ( ) ; requests . set ( NUM_ , HTTP_CONNECT + STR_ + connectRequestURI ( url ) + STR_ + httpVersion , null ) ; requests . setIfNotSet ( STR_ , userAgent ) ; String host = url . getHost ( ) ; if ( port != - NUM_ && port != url . getDefaultPort ( ) ) { host += STR_ + String . valueOf ( port ) ; } requests . setIfNotSet ( STR_ , host ) ; requests . setIfNotSet ( STR_ , acceptString ) ; if ( http . getHttpKeepAliveSet ( ) ) { requests . setIfNotSet ( STR_ , STR_ ) ; } setPreemptiveProxyAuthentication ( requests ) ; if ( logger . isLoggable ( PlatformLogger . Level . FINE ) ) { logger . fine ( requests . toString ( ) ) ; } http . writeRequests ( requests , null ) ; }
private boolean isSelfSigned ( X509Certificate cert ) { return signedBy ( cert , cert ) ; }
@ RequestMapping ( value = { STR_ , STR_ } , method = RequestMethod . PUT ) @ ResponseBody public RestWrapper insert ( @ ModelAttribute ( STR_ ) @ Valid UserRoles userRoles , BindingResult bindingResult , Principal principal ) { RestWrapper restWrapper = null ; if ( bindingResult . hasErrors ( ) ) { BindingResultError bindingResultError = new BindingResultError ( ) ; return bindingResultError . errorMessage ( bindingResult ) ; } try { com . wipro . ats . bdre . md . dao . jpa . UserRoles jpaUserRoles = new com . wipro . ats . bdre . md . dao . jpa . UserRoles ( ) ; jpaUserRoles . setUserRoleId ( userRoles . getUserRoleId ( ) ) ; jpaUserRoles . setRole ( userRoles . getRole ( ) ) ; Users users = new Users ( ) ; users . setUsername ( userRoles . getUsername ( ) ) ; jpaUserRoles . setUsers ( users ) ; Integer userRolesId = userRolesDAO . insert ( jpaUserRoles ) ; userRoles . setUserRoleId ( userRolesId ) ; restWrapper = new RestWrapper ( userRoles , RestWrapper . OK ) ; LOGGER . info ( STR_ + userRoles . getUserRoleId ( ) + STR_ + principal . getName ( ) + userRoles ) ; } catch ( Exception e ) { LOGGER . error ( e ) ; restWrapper = new RestWrapper ( e . getMessage ( ) , RestWrapper . ERROR ) ; } return restWrapper ; }
public Set < WordToken > nearestWords ( final int distance , final WordToken ... start ) { return nearestWords ( distance , null , Arrays . asList ( start ) ) ; }
public DERUTCTime ( Date time ) { SimpleDateFormat dateF = new SimpleDateFormat ( STR_ ) ; dateF . setTimeZone ( new SimpleTimeZone ( NUM_ , STR_ ) ) ; this . time = Strings . toByteArray ( dateF . format ( time ) ) ; }
public void add ( String category , String [ ] titles , double [ ] values ) { mCategories . add ( category ) ; mTitles . add ( titles ) ; mValues . add ( values ) ; }
public void rewind ( ) { synchronized ( used ) { for ( ParameterPair pair : used ) { current . addParameter ( pair . option , pair . value ) ; } used . clear ( ) ; } }
public List < Interval > merge ( List < Interval > intervals ) { List < Interval > res = new ArrayList < > ( ) ; if ( intervals == null || intervals . size ( ) == NUM_ ) { return res ; } Collections . sort ( intervals , null ) ; Interval prev = null ; for ( Interval i : intervals ) { if ( prev == null || prev . end < i . start ) { res . add ( i ) ; prev = i ; } else if ( i . end > prev . end ) { prev . end = i . end ; } } return res ; }
private String formatType ( Object typeRep ) { StringTokenizer tokenizer = new StringTokenizer ( typeRep . toString ( ) , STR_ , BOOL_ ) ; StringBuilder sb = new StringBuilder ( ) ; while ( tokenizer . hasMoreTokens ( ) ) { String token = tokenizer . nextToken ( ) ; if ( token . length ( ) == NUM_ || token . lastIndexOf ( STR_ ) == - NUM_ ) sb . append ( token ) ; else { int index = token . lastIndexOf ( STR_ ) ; sb . append ( token . substring ( index + NUM_ ) ) ; } } return sb . toString ( ) ; }
@ NotNull public static String sha1 ( @ NotNull File keyStoreFile ) throws Exception { return sha1 ( keyStoreFile , null , null ) ; }
@ Override protected void onSizeChanged ( int w , int h , int oldw , int oldh ) { super . onSizeChanged ( w , h , oldw , oldh ) ; setupBounds ( w , h ) ; setupPaints ( ) ; invalidate ( ) ; }
@ Override public void panDomainAxes ( double panRange , PlotRenderingInfo info , Point2D source ) { XYPlot subplot = findSubplot ( info , source ) ; if ( subplot == null ) { return ; } if ( ! subplot . isDomainPannable ( ) ) { return ; } PlotRenderingInfo subplotInfo = info . getSubplotInfo ( info . getSubplotIndex ( source ) ) ; if ( subplotInfo == null ) { return ; } for ( int i = NUM_ ; i < subplot . getDomainAxisCount ( ) ; i ++ ) { ValueAxis domainAxis = subplot . getDomainAxis ( i ) ; if ( domainAxis != null ) { domainAxis . pan ( panRange ) ; } } }
private void init ( ) { startController = new PourStartController ( ) ; startController . setCheckView ( this ) ; waveController = new WaveController ( ) ; waveController . setCheckView ( this ) ; PourFinishController finishController = new PourFinishController ( ) ; finishController . setCheckView ( this ) ; TickController tickController = new TickController ( ) ; tickController . setCheckView ( this ) ; List < BaseController > finishControllers = new ArrayList < > ( ) ; finishControllers . add ( finishController ) ; finishControllers . add ( tickController ) ; this . finishControllers = finishControllers ; }
private JLabel createIconLabel ( JCheckBox checkBox ) { checkBox . setOpaque ( BOOL_ ) ; checkBox . setSize ( checkBox . getMinimumSize ( ) ) ; Image image = new BufferedImage ( checkBox . getWidth ( ) , checkBox . getHeight ( ) , Transparency . TRANSLUCENT ) ; Graphics g = image . getGraphics ( ) ; checkBox . paint ( g ) ; g . dispose ( ) ; return new JLabel ( new ImageIcon ( image ) ) ; }
public void closeWindow ( ) { WindowEvent ev = new WindowEvent ( frame , WindowEvent . WINDOW_CLOSING ) ; frame . dispatchEvent ( ev ) ; }
private void populateHostData ( Host host , HostParam param ) { if ( param . getName ( ) != null ) { host . setLabel ( param . getName ( ) ) ; } if ( param . getHostName ( ) != null ) { host . setHostName ( param . getHostName ( ) ) ; } if ( param . getCluster ( ) != null ) { host . setCluster ( param . getCluster ( ) ) ; } if ( param . getOsVersion ( ) != null ) { host . setOsVersion ( param . getOsVersion ( ) ) ; } if ( param . getUserName ( ) != null ) { host . setUsername ( param . getUserName ( ) ) ; } if ( param . getPassword ( ) != null ) { host . setPassword ( param . getPassword ( ) ) ; } if ( param . getPortNumber ( ) != null ) { host . setPortNumber ( param . getPortNumber ( ) ) ; } if ( param . getUseSsl ( ) != null ) { host . setUseSSL ( param . getUseSsl ( ) ) ; } if ( param . getType ( ) != null ) { host . setType ( param . getType ( ) ) ; } if ( param . getDiscoverable ( ) != null ) { host . setDiscoverable ( param . getDiscoverable ( ) ) ; } if ( param . getVcenterDataCenter ( ) != null ) { host . setVcenterDataCenter ( NullColumnValueGetter . isNullURI ( param . getVcenterDataCenter ( ) ) ? NullColumnValueGetter . getNullURI ( ) : param . getVcenterDataCenter ( ) ) ; } Cluster cluster = null ; if ( ! NullColumnValueGetter . isNullURI ( param . getCluster ( ) ) ) { cluster = queryObject ( Cluster . class , param . getCluster ( ) , BOOL_ ) ; if ( ! NullColumnValueGetter . isNullURI ( cluster . getVcenterDataCenter ( ) ) ) { host . setVcenterDataCenter ( cluster . getVcenterDataCenter ( ) ) ; } if ( ! NullColumnValueGetter . isNullURI ( cluster . getProject ( ) ) ) { host . setProject ( cluster . getProject ( ) ) ; } } if ( param . getBootVolume ( ) != null ) { host . setBootVolumeId ( NullColumnValueGetter . isNullURI ( param . getBootVolume ( ) ) ? NullColumnValueGetter . getNullURI ( ) : param . getBootVolume ( ) ) ; } }
@ Nullable public AvdInfo createOrUpdateAvd ( @ Nullable AvdInfo currentInfo , @ NotNull String avdName , @ NotNull Device device , @ NotNull SystemImageDescription systemImageDescription , @ NotNull ScreenOrientation orientation , boolean isCircular , @ Nullable String sdCard , @ Nullable File skinFolder , @ NotNull Map < String , String > hardwareProperties , boolean createSnapshot ) { if ( ! initIfNecessary ( ) ) { return null ; } File avdFolder ; try { if ( currentInfo != null ) { avdFolder = new File ( currentInfo . getDataFolderPath ( ) ) ; } else { avdFolder = AvdInfo . getDefaultAvdFolder ( myAvdManager , avdName , myFileOp , BOOL_ ) ; } } catch ( AndroidLocation . AndroidLocationException e ) { IJ_LOG . error ( STR_ + avdName , e ) ; return null ; } Dimension resolution = device . getScreenSize ( orientation ) ; assert resolution != null ; String skinName = null ; if ( skinFolder == null && isCircular ) { skinFolder = getRoundSkin ( systemImageDescription ) ; } if ( FileUtil . filesEqual ( skinFolder , AvdWizardUtils . NO_SKIN ) ) { skinFolder = null ; } if ( skinFolder == null ) { skinName = String . format ( STR_ , Math . round ( resolution . getWidth ( ) ) , Math . round ( resolution . getHeight ( ) ) ) ; } if ( orientation == ScreenOrientation . LANDSCAPE ) { hardwareProperties . put ( HardwareProperties . HW_INITIAL_ORIENTATION , ScreenOrientation . LANDSCAPE . getShortDisplayValue ( ) . toLowerCase ( Locale . ROOT ) ) ; } if ( currentInfo != null && ! avdName . equals ( currentInfo . getName ( ) ) ) { boolean success = myAvdManager . moveAvd ( currentInfo , avdName , currentInfo . getDataFolderPath ( ) , SDK_LOG ) ; if ( ! success ) { return null ; } } return myAvdManager . createAvd ( avdFolder , avdName , systemImageDescription . getSystemImage ( ) , skinFolder , skinName , sdCard , hardwareProperties , device . getBootProps ( ) , createSnapshot , BOOL_ , currentInfo != null , SDK_LOG ) ; }
public void engineDeleteEntry ( String alias ) throws KeyStoreException { synchronized ( entries ) { entries . remove ( alias . toLowerCase ( Locale . ENGLISH ) ) ; } }
public DisjointSets ( int numElements ) { array = new int [ numElements ] ; Arrays . fill ( array , - NUM_ ) ; }
public final void printClusters ( PrintWriter out , List < ClusterData > clusterData , int [ ] matIndexToMsgInternalId ) throws AdeException { if ( m_finalClusters == null ) { updateClusters ( clusterData , matIndexToMsgInternalId ) ; } for ( Map . Entry < String , Collection < Integer > > entry : m_finalClusters . entrySet ( ) ) { final String n = entry . getKey ( ) ; final Collection < Integer > c = entry . getValue ( ) ; out . printf ( STR_ , n ) ; for ( int m : c ) { out . printf ( STR_ , matIndexToMsgInternalId [ m ] ) ; } out . println ( ) ; } }
protected void addToGUI ( JPanel gui , JTextField b , String cmd ) { b . setActionCommand ( cmd ) ; b . addActionListener ( this ) ; gui . add ( b ) ; }
public synchronized void remove ( int index ) { mCategories . remove ( index ) ; mValues . remove ( index ) ; }
static TokenStream wrap ( String fieldName , Analyzer indexAnalyzer , String content , char splitChar ) throws IOException { if ( indexAnalyzer . getOffsetGap ( fieldName ) != NUM_ ) { throw new IllegalArgumentException ( STR_ + fieldName + STR_ ) ; } int splitCharIdx = content . indexOf ( splitChar ) ; if ( splitCharIdx == - NUM_ ) { return indexAnalyzer . tokenStream ( fieldName , content ) ; } TokenStream subTokenStream = indexAnalyzer . tokenStream ( fieldName , content . substring ( NUM_ , splitCharIdx ) ) ; return new MultiValueTokenStream ( subTokenStream , fieldName , indexAnalyzer , content , splitChar , splitCharIdx ) ; }
public final boolean check_trace ( Polyline p_polyline , int p_half_width , int p_layer , NetNosList p_net_no_arr , int p_clearance_class_no , int p_max_recursion_depth , int p_max_via_recursion_depth , int p_max_spring_over_recursion_depth ) { AwtreeShapeSearch search_tree = search_tree_manager . get_default_tree ( ) ; int compensated_half_width = p_half_width + search_tree . get_clearance_compensation ( p_clearance_class_no , p_layer ) ; ArrayList < ShapeTile > trace_shapes = p_polyline . offset_shapes ( compensated_half_width , NUM_ , p_polyline . corner_count ( ) ) ; for ( int index = NUM_ ; index < trace_shapes . size ( ) ; ++ index ) { ShapeTile curr_trace_shape = trace_shapes . get ( index ) ; BrdFromSide from_side = new BrdFromSide ( p_polyline , index + NUM_ , curr_trace_shape ) ; boolean check_shove_ok = shove_trace_algo . shove_trace_check ( curr_trace_shape , from_side , null , p_layer , p_net_no_arr , p_clearance_class_no , p_max_recursion_depth , p_max_via_recursion_depth , p_max_spring_over_recursion_depth , null ) ; if ( ! check_shove_ok ) return BOOL_ ; } return BOOL_ ; }
public static void delete ( File fileOrFolder ) throws IOException { if ( fileOrFolder != null ) delete ( fileOrFolder . toPath ( ) ) ; }
public static double [ ] expandArrayD ( int bufferSize , double [ ] currentArray ) { if ( currentArray == null ) { return new double [ bufferSize . NUM_ ] ; } int length = currentArray . length ; double [ ] ret = new double [ length + bufferSize . NUM_ ] ; System . arraycopy ( currentArray , NUM_ , ret , NUM_ , length ) ; return ret ; }
@ SuppressWarnings ( STR_ ) public void postProcessBeanFactory ( ConfigurableListableBeanFactory configurableListableBeanFactory ) { if ( configurableListableBeanFactory . containsBean ( sessionFactoryBeanName ) ) { BeanDefinition sessionFactoryBeanDefinition = configurableListableBeanFactory . getBeanDefinition ( sessionFactoryBeanName ) ; MutablePropertyValues propertyValues = sessionFactoryBeanDefinition . getPropertyValues ( ) ; if ( mappingResources != null ) { PropertyValue propertyValue = propertyValues . getPropertyValue ( STR_ ) ; if ( propertyValue == null ) { propertyValue = new PropertyValue ( STR_ , new ArrayList ( ) ) ; propertyValues . addPropertyValue ( propertyValue ) ; } List existingMappingResources = ( List ) propertyValue . getValue ( ) ; existingMappingResources . addAll ( mappingResources ) ; } if ( annotatedClasses != null ) { PropertyValue propertyValue = propertyValues . getPropertyValue ( STR_ ) ; if ( propertyValue == null ) { propertyValue = new PropertyValue ( STR_ , new ArrayList ( ) ) ; propertyValues . addPropertyValue ( propertyValue ) ; } List existingMappingResources = ( List ) propertyValue . getValue ( ) ; existingMappingResources . addAll ( annotatedClasses ) ; } if ( configLocations != null ) { PropertyValue propertyValue = propertyValues . getPropertyValue ( STR_ ) ; if ( propertyValue == null ) { propertyValue = new PropertyValue ( STR_ , new ArrayList ( ) ) ; propertyValues . addPropertyValue ( propertyValue ) ; } List existingConfigLocations = ( List ) propertyValue . getValue ( ) ; existingConfigLocations . addAll ( configLocations ) ; } if ( hibernateProperties != null ) { PropertyValue propertyValue = propertyValues . getPropertyValue ( STR_ ) ; if ( propertyValue == null ) { propertyValue = new PropertyValue ( STR_ , new Properties ( ) ) ; propertyValues . addPropertyValue ( propertyValue ) ; } Properties existingHibernateProperties = ( Properties ) propertyValue . getValue ( ) ; existingHibernateProperties . putAll ( hibernateProperties ) ; } } else { throw new NoSuchBeanDefinitionException ( STR_ + sessionFactoryBeanName + STR_ + STR_ ) ; } }
public long skipBytes ( long n ) throws IOException { long count = NUM_ ; long gotsofar = NUM_ ; if ( inputStream == null ) { reopen ( ) ; if ( inputStream == null ) { reopen ( ) ; throw new IOException ( STR_ ) ; } } while ( count < n ) { gotsofar = inputStream . skip ( n - count ) ; if ( gotsofar == NUM_ ) { Debug . error ( STR_ + n + STR_ ) ; break ; } count += gotsofar ; } count ( ( int ) count ) ; return count ; }
private void createLock ( ) throws IOException { synchronized ( LockableFileWriter . class ) { if ( ! lockFile . createNewFile ( ) ) { throw new IOException ( STR_ + lockFile . getAbsolutePath ( ) + STR_ ) ; } lockFile . deleteOnExit ( ) ; } }
public void handleTblDSAttributeMapListHrefActionRequest ( RequestInvocationEvent event ) throws ModelControlException { try { Map values = getValues ( ) ; onBeforeSaveProfile ( values ) ; setPageSessionAttribute ( PROPERTY_ATTRIBUTE , ( HashMap ) values ) ; WSPPServiceDSAttributeMapListEditViewBean vb = ( WSPPServiceDSAttributeMapListEditViewBean ) getViewBean ( WSPPServiceDSAttributeMapListEditViewBean . class ) ; unlockPageTrail ( ) ; passPgSessionMap ( vb ) ; vb . populateValues ( ( String ) getDisplayFieldValue ( STR_ ) ) ; vb . forwardTo ( getRequestContext ( ) ) ; } catch ( AMConsoleException e ) { setInlineAlertMessage ( CCAlert . TYPE_ERROR , STR_ , e . getMessage ( ) ) ; forwardTo ( ) ; } }
private V doGet ( Object key ) { if ( key == null ) throw new NullPointerException ( ) ; Comparator < ? super K > cmp = comparator ; outer : for ( ; ; ) { for ( Node < K , V > b = findPredecessor ( key , cmp ) , n = b . next ; ; ) { Object v ; int c ; if ( n == null ) break outer ; Node < K , V > f = n . next ; if ( n != b . next ) break ; if ( ( v = n . value ) == null ) { n . helpDelete ( b , f ) ; break ; } if ( b . value == null || v == n ) break ; if ( ( c = cpr ( cmp , key , n . key ) ) == NUM_ ) { @ SuppressWarnings ( STR_ ) V vv = ( V ) v ; return vv ; } if ( c < NUM_ ) break outer ; b = n ; n = f ; } } return null ; }
void handleSwfLoadedEvent ( SwfLoadedEvent e ) { dumpSwfLoadedLine ( e ) ; }
private void quickReply ( ) { quickReplySmsMessage = smsPopupPager . getActiveMessage ( ) ; quickReply ( quickReplySmsMessage . getReplyText ( ) ) ; }
@ Override protected synchronized void write ( long offset , byte [ ] b ) throws IOException { if ( byteBuffer != null ) { byteBuffer . position ( ( int ) offset ) ; byteBuffer . put ( b ) ; } else { throw new IOException ( STR_ + getPath ( ) + STR_ ) ; } }
public boolean hasChanged ( ) { return System . identityHashCode ( config ) != initialHash ; }
void fixCompatibility ( View root ) { Queue < View > queue = new LinkedList < View > ( ) ; queue . add ( root ) ; View view = null ; while ( ( view = queue . poll ( ) ) != null ) { if ( view instanceof ViewGroup ) { ViewGroup group = ( ViewGroup ) view ; for ( int i = NUM_ ; i < group . getChildCount ( ) ; i ++ ) { queue . add ( group . getChildAt ( i ) ) ; } } } }
protected abstract Set < SocketAddress > bindInternal ( List < ? extends SocketAddress > localAddresses ) throws Exception ;
public void substituteHeader ( int state , String header ) throws AuthLoginException { if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + state + STR_ + header ) ; } if ( state > stateLength ) { throw new AuthLoginException ( bundleName , STR_ , new Object [ ] { new Integer ( state ) } ) ; } Callback [ ] ext = getCallback ( state ) ; if ( ext . length <= NUM_ ) { throw new AuthLoginException ( bundleName , STR_ , null ) ; } if ( ( header != null ) && ( header . length ( ) != NUM_ ) ) { PagePropertiesCallback pc = ( PagePropertiesCallback ) ( ( Callback [ ] ) internal . get ( state - NUM_ ) ) [ NUM_ ] ; pc . setHeader ( header ) ; } }
public static Service createService ( PatternTimetable timetable ) { Calendar calendar = new Calendar ( ) ; calendar . monday = timetable . monday ? NUM_ : NUM_ ; calendar . tuesday = timetable . tuesday ? NUM_ : NUM_ ; calendar . wednesday = timetable . wednesday ? NUM_ : NUM_ ; calendar . thursday = timetable . thursday ? NUM_ : NUM_ ; calendar . friday = timetable . friday ? NUM_ : NUM_ ; calendar . saturday = timetable . saturday ? NUM_ : NUM_ ; calendar . sunday = timetable . sunday ? NUM_ : NUM_ ; StringBuilder nameBuilder = new StringBuilder ( STR_ ) ; nameBuilder . append ( timetable . monday ? STR_ : STR_ ) ; nameBuilder . append ( timetable . monday ? STR_ : STR_ ) ; nameBuilder . append ( timetable . monday ? STR_ : STR_ ) ; nameBuilder . append ( timetable . monday ? STR_ : STR_ ) ; nameBuilder . append ( timetable . monday ? STR_ : STR_ ) ; nameBuilder . append ( timetable . monday ? STR_ : STR_ ) ; nameBuilder . append ( timetable . monday ? STR_ : STR_ ) ; Service service = new Service ( nameBuilder . toString ( ) ) ; calendar . start_date = NUM_ ; calendar . end_date = NUM_ ; service . calendar = calendar ; return service ; }
public boolean remove ( ImageInfo object ) { final int location = getLocation ( object ) ; final boolean removed = data . remove ( object ) ; notifyItemRemoved ( location ) ; return removed ; }
public T allowedUsers ( User ... users ) { List < User > usersList = Arrays . asList ( users ) ; this . userPredicate = null ; return instance ( ) ; }
VPlexDistributedDeviceInfo findDistributedDevice ( String deviceName ) throws VPlexApiException { return findDistributedDevice ( deviceName , BOOL_ ) ; }
@ SuppressWarnings ( STR_ ) public static < T extends Packet > void registerOutListener ( final Class < T > type , Player player , Predicate < T > listener ) { NetworkManagerWrapper wrapper = wrapNetworkManager ( player ) ; wrapper . registerOutgoingListener ( type , listener ) ; }
static CopyState readCopyState ( DataInput in ) throws IOException { byte [ ] infosBytes = new byte [ in . readVInt ( ) ] ; in . readBytes ( infosBytes , NUM_ , infosBytes . length ) ; long gen = in . readVLong ( ) ; long version = in . readVLong ( ) ; Map < String , FileMetaData > files = readFilesMetaData ( in ) ; int count = in . readVInt ( ) ; Set < String > completedMergeFiles = new HashSet < > ( ) ; for ( int i = NUM_ ; i < count ; i ++ ) { completedMergeFiles . add ( in . readString ( ) ) ; } long primaryGen = in . readVLong ( ) ; return new CopyState ( files , version , gen , infosBytes , completedMergeFiles , primaryGen , null ) ; }
public void notifyTasks ( ) { if ( tracker . shouldInterruptTask ( ) ) { for ( Thread t : threadMap . values ( ) ) { t . interrupt ( ) ; } } }
public RequestParams ( Object ... keysAndValues ) { int len = keysAndValues . length ; if ( len % NUM_ != NUM_ ) throw new IllegalArgumentException ( STR_ ) ; for ( int i = NUM_ ; i < len ; i += NUM_ ) { String key = String . valueOf ( keysAndValues [ i ] ) ; String val = String . valueOf ( keysAndValues [ i + NUM_ ] ) ; put ( key , val ) ; } }
public boolean confirmOverwrite ( final File file ) { String message = STR_ + file . getName ( ) + STR_ ; Object [ ] options = { STR_ , STR_ } ; return JOptionPane . YES_OPTION == JOptionPane . showOptionDialog ( null , message , STR_ , JOptionPane . DEFAULT_OPTION , JOptionPane . WARNING_MESSAGE , null , options , options [ NUM_ ] ) ; }
public TvShowUpdateDatasourceTask ( String datasource ) { super ( BUNDLE . getString ( STR_ ) + STR_ + datasource + STR_ ) ; tvShowList = TvShowList . getInstance ( ) ; dataSources = new ArrayList < > ( NUM_ ) ; dataSources . add ( datasource ) ; }
public int findLine ( int offset ) { int line = lineStarts . length - NUM_ ; while ( ( lineStarts [ line ] > offset ) && ( line > NUM_ ) ) { line -- ; } return line ; }
public void clear ( ) { Set < Sensor > oldSelection = new HashSet < Sensor > ( selection ) ; selection . clear ( ) ; if ( ! oldSelection . isEmpty ( ) ) { fireSelectionChanged ( oldSelection , selection ) ; } }
public Object newNonMovableArray ( Class < ? > componentType , int length ) { return Array . newInstance ( componentType , length ) ; }
private void loadFileRecursively ( String path , Map < String , ThriftFileElement > loadedFiles ) throws IOException { ThriftFileElement element = null ; File dir = null ; File file = findFirstExisting ( path , null ) ; if ( file != null ) { file = file . getCanonicalFile ( ) ; if ( loadedFiles . containsKey ( file . getAbsolutePath ( ) ) ) { return ; } dir = file . getParentFile ( ) ; element = loadSingleFile ( file . getParentFile ( ) , file . getName ( ) ) ; } if ( element == null ) { throw new FileNotFoundException ( STR_ + path + STR_ + includePaths ) ; } loadedFiles . put ( file . getAbsolutePath ( ) , element ) ; ImmutableList < IncludeElement > includes = element . includes ( ) ; if ( includes . size ( ) > NUM_ ) { includePaths . addFirst ( dir ) ; for ( IncludeElement include : includes ) { if ( ! include . isCpp ( ) ) { loadFileRecursively ( include . path ( ) , loadedFiles ) ; } } includePaths . removeFirst ( ) ; } }
public void assureProxyOk ( ) { if ( socket . isClosed ( ) ) { restart ( ) ; } }
@ Override public boolean add ( IMessage message ) { return add ( message , BOOL_ ) ; }
public Key ( byte [ ] hash ) { if ( hash . length != SHA1_HASH_LENGTH ) { throw new IllegalArgumentException ( STR_ + hash . length ) ; } System . arraycopy ( hash , NUM_ , this . hash , NUM_ , SHA1_HASH_LENGTH ) ; }
public static int [ ] concatAllInt ( int [ ] ... arrays ) { int totalLength = NUM_ ; final int subArrayCount = arrays . length ; for ( int i = NUM_ ; i < subArrayCount ; ++ i ) { totalLength += arrays [ i ] . length ; } int [ ] result = Arrays . copyOf ( arrays [ NUM_ ] , totalLength ) ; int offset = arrays [ NUM_ ] . length ; for ( int i = NUM_ ; i < subArrayCount ; ++ i ) { System . arraycopy ( arrays [ i ] , NUM_ , result , offset , arrays [ i ] . length ) ; offset += arrays [ i ] . length ; } return result ; }
private static RoadPermission roadFlagComparision ( Way iosmWay , String newTag , String newValue , EnumSet < EdgeStore . EdgeFlag > forwardExpected , EnumSet < EdgeStore . EdgeFlag > backwardExpected ) { Way osmWay = new Way ( ) ; StringJoiner stringJoiner = new StringJoiner ( STR_ ) ; for ( OSMEntity . Tag tag : iosmWay . tags ) { osmWay . addTag ( tag . key , tag . value ) ; stringJoiner . add ( tag . key + STR_ + tag . value ) ; } if ( newTag != null && newValue != null ) { osmWay . addTag ( newTag , newValue ) ; stringJoiner . add ( newTag + STR_ + newValue ) ; } Set < EdgeStore . EdgeFlag > forwardFiltered ; Set < EdgeStore . EdgeFlag > backwardFiltered ; RoadPermission roadPermission = traversalPermissionLabeler . getPermissions ( osmWay ) ; forwardFiltered = filterFlags ( roadPermission . forward ) ; backwardFiltered = filterFlags ( roadPermission . backward ) ; String tags = STR_ + stringJoiner . toString ( ) ; assertEquals ( tags , forwardExpected , forwardFiltered ) ; assertEquals ( tags , backwardExpected , backwardFiltered ) ; return roadPermission ; }
public void beginDisplay ( DisplayEvent event ) throws ModelControlException { IdentitySubjectModel subjectModel = getSubjectModel ( ) ; PolicyModel model = ( PolicyModel ) getModel ( ) ; super . beginDisplay ( event ) ; if ( ! canModify ) { Map mapValues = getDefaultValues ( ) ; if ( ( mapValues != null ) && ! mapValues . isEmpty ( ) ) { Set values = ( Set ) mapValues . get ( AMIdentityMembershipCondition . AM_IDENTITY_NAME ) ; Set identityNames = helper . getAMIdentityNames ( model . getUserSSOToken ( ) , values ) ; propertySheetModel . setValue ( VALUES_MULTIPLE_CHOICE_VALUE , AMAdminUtils . getString ( identityNames , STR_ , BOOL_ ) ) ; } } else { CCDropDownMenu menu = ( CCDropDownMenu ) getChild ( FILTER_TYPE ) ; Map supportedEntityTypes = model . getSupportedEntityTypes ( realmName ) ; OptionList entityTypes = createOptionList ( supportedEntityTypes ) ; entityTypes . add ( NUM_ , STR_ , STR_ ) ; menu . setOptions ( entityTypes ) ; menu . setValue ( STR_ ) ; CCAddRemove child = ( CCAddRemove ) getChild ( VALUES_MULTIPLE_CHOICE_VALUE ) ; child . restoreStateData ( ) ; if ( ! submitCycle ) { helper . setSelectedIdentities ( child , model . getUserSSOToken ( ) , model . getUserLocale ( ) , this , getDefaultValues ( ) ) ; } else { OptionList possible = helper . createOptionList ( model . getUserSSOToken ( ) , model . getUserLocale ( ) , this , getPossibleValues ( subjectModel , realmName ) ) ; OptionList selected = addRemoveModel . getSelectedOptionList ( ) ; List selectedIds = AMAdminUtils . toList ( selected ) ; child . resetStateData ( ) ; addRemoveModel . setAvailableOptionList ( possible ) ; addRemoveModel . setSelectedOptionList ( helper . createOptionList ( model . getUserSSOToken ( ) , model . getUserLocale ( ) , this , selectedIds ) ) ; } } }
public byte [ ] readBytes ( ) throws IOException { int len = readInt ( ) ; if ( len == - NUM_ ) { return null ; } byte [ ] b = DataUtils . newBytes ( len ) ; in . readFully ( b ) ; return b ; }
protected int chunkSize ( int n ) { int power = ( n == NUM_ || n == NUM_ ) ? initialChunkPower : Math . min ( initialChunkPower + n - NUM_ , AbstractSpinedBuffer . MAX_CHUNK_POWER ) ; return NUM_ << power ; }
public String useRelativePathTipText ( ) { return STR_ ; }
public Joiner join ( Class < ? extends DataObject > clazz , String alias , URI ... ids ) { return join ( clazz , alias , new ArrayList < URI > ( Arrays . asList ( ids ) ) ) ; }
public void closeFile ( ) { closeFile ( BOOL_ ) ; }
public List < Interface > showInterface ( ) throws NetworkDeviceControllerException { List < Interface > interfaces = new ArrayList < Interface > ( ) ; SSHPrompt [ ] prompts = { SSHPrompt . POUND , SSHPrompt . GREATER_THAN } ; StringBuilder buf = new StringBuilder ( ) ; SSHPrompt prompt = sendWaitFor ( MDSDialogProperties . getString ( STR_ ) , NUM_ , prompts , buf ) ; String [ ] lines = getLines ( buf ) ; String [ ] regex = { MDSDialogProperties . getString ( STR_ ) , MDSDialogProperties . getString ( STR_ ) , MDSDialogProperties . getString ( STR_ ) , MDSDialogProperties . getString ( STR_ ) , MDSDialogProperties . getString ( STR_ ) , MDSDialogProperties . getString ( STR_ ) } ; String [ ] groups = new String [ NUM_ ] ; Interface intf = null ; for ( String line : lines ) { int index = match ( line , regex , groups ) ; switch ( index ) { case NUM_ : intf = new Interface ( groups [ NUM_ ] ) ; intf . setStatus ( groups [ NUM_ ] ) ; interfaces . add ( intf ) ; break ; case NUM_ : intf . setDescription ( groups [ NUM_ ] ) ; break ; case NUM_ : intf . setWwpn ( groups [ NUM_ ] ) ; break ; case NUM_ : intf . setMode ( groups [ NUM_ ] ) ; intf . setFcid ( groups [ NUM_ ] ) ; break ; case NUM_ : intf . setVsan ( groups [ NUM_ ] ) ; break ; case NUM_ : intf . setMode ( groups [ NUM_ ] ) ; break ; } } return interfaces ; }
protected void clearDataLists ( int obdService ) { switch ( obdService ) { case OBD_SVC_DATA : case OBD_SVC_FREEZEFRAME : pidSupported . clear ( ) ; PidPvs . clear ( ) ; break ; case OBD_SVC_READ_CODES : case OBD_SVC_PENDINGCODES : case OBD_SVC_PERMACODES : tCodes . clear ( ) ; break ; case OBD_SVC_VEH_INFO : pidSupported . clear ( ) ; VidPvs . clear ( ) ; break ; } }
public QuadEdge makeEdge ( Vertex o , Vertex d ) { QuadEdge q = QuadEdge . makeEdge ( o , d ) ; quadEdges . add ( q ) ; return q ; }
public static void sortSeqs ( List < String > seqs ) { Collections . sort ( seqs , null ) ; }
default B with ( String key , long value ) { return with ( key , Long . toString ( value ) ) ; }
private void listDirectory ( File directory , RelativeDirectory subdirectory , Set < JavaFileObject . Kind > fileKinds , boolean recurse , ListBuffer < JavaFileObject > resultList ) { File d = subdirectory . getFile ( directory ) ; if ( ! caseMapCheck ( d , subdirectory ) ) return ; File [ ] files = d . listFiles ( ) ; if ( files == null ) return ; if ( sortFiles != null ) Arrays . sort ( files , sortFiles ) ; for ( File f : files ) { String fname = f . getName ( ) ; if ( f . isDirectory ( ) ) { if ( recurse && SourceVersion . isIdentifier ( fname ) ) { listDirectory ( directory , new RelativeDirectory ( subdirectory , fname ) , fileKinds , recurse , resultList ) ; } } else { if ( isValidFile ( fname , fileKinds ) ) { JavaFileObject fe = new RegularFileObject ( this , fname , new File ( d , fname ) ) ; resultList . append ( fe ) ; } } } }
private Shape decodeEdge ( int width , int height ) { path . reset ( ) ; path . moveTo ( width - NUM_ , NUM_ ) ; path . lineTo ( width - NUM_ , height - NUM_ ) ; path . lineTo ( width - NUM_ , height - NUM_ ) ; path . lineTo ( NUM_ , height - NUM_ ) ; return path ; }
public void dispose ( ) throws IabAsyncInProgressException { synchronized ( mAsyncInProgressLock ) { if ( mAsyncInProgress ) { throw new IabAsyncInProgressException ( STR_ + STR_ + mAsyncOperation + STR_ ) ; } } logDebug ( STR_ ) ; mSetupDone = BOOL_ ; if ( mServiceConn != null ) { logDebug ( STR_ ) ; if ( mContext != null ) mContext . unbindService ( mServiceConn ) ; } mDisposed = BOOL_ ; mContext = null ; mServiceConn = null ; mService = null ; mPurchaseListener = null ; }
private void testScenario ( String aConfiguration , boolean anExpectingAnException , List < Method > aMethodsToCall ) throws Exception { if ( aMethodsToCall . isEmpty ( ) ) { testScenario ( aConfiguration , anExpectingAnException , ( Method ) null ) ; } else { for ( Method myMethod : aMethodsToCall ) { testScenario ( aConfiguration , anExpectingAnException , myMethod ) ; } } }
private static File createReserveDiskCacheDir ( Context context ) { File cacheDir = StorageUtils . getCacheDirectory ( context , BOOL_ ) ; File individualDir = new File ( cacheDir , STR_ ) ; if ( individualDir . exists ( ) || individualDir . mkdir ( ) ) { cacheDir = individualDir ; } return cacheDir ; }
public boolean hasBeenCalled ( String resourceName ) { return uris . contains ( resourceName ) ; }
@ Override public void readExternal ( ObjectInput in ) throws IOException , ClassNotFoundException { super . readExternal ( in ) ; isLeaf = in . readBoolean ( ) ; numEntries = in . readInt ( ) ; }
public ObjIdMap ( ) { this ( NUM_ , NUM_ ) ; }
public Criteria or ( ) { Criteria criteria = createCriteriaInternal ( ) ; oredCriteria . add ( criteria ) ; return criteria ; }
public static ConnectionFactory newFailoverConnectionPool ( Set < LDAPURL > servers , String username , char [ ] password , int maxSize , int heartBeatInterval , String heartBeatTimeUnit , Options ldapOptions ) { List < ConnectionFactory > factories = new ArrayList < ConnectionFactory > ( servers . size ( ) ) ; for ( LDAPURL ldapurl : servers ) { ConnectionFactory cf = Connections . newFixedConnectionPool ( newConnectionFactory ( ldapurl , username , password , heartBeatInterval , heartBeatTimeUnit , ldapOptions ) , maxSize ) ; factories . add ( cf ) ; } return loadBalanceFactories ( factories ) ; }
public boolean isCritical ( ) { return BOOL_ ; }
public PrintfFormat ( final String fmtArg ) throws IllegalArgumentException { this ( Locale . getDefault ( ) , fmtArg ) ; }
public static void initCause ( Throwable throwable , Throwable cause ) { if ( INIT_CAUSE_METHOD != null ) { try { INIT_CAUSE_METHOD . invoke ( throwable , new Object [ ] { cause } ) ; } catch ( Exception e ) { } } }
public MessagePropertyKey ( String description , Integer ordinal ) { this . description = description ; this . ordinal = ordinal ; }
private Node addWaiter ( Node mode ) { Node node = new Node ( Thread . currentThread ( ) , mode ) ; Node pred = tail ; if ( pred != null ) { node . prev = pred ; if ( compareAndSetTail ( pred , node ) ) { pred . next = node ; return node ; } } enq ( node ) ; return node ; }
private void assertBounded ( SortedSet < String > deserialized , boolean bounded ) { if ( bounded ) { try { deserialized . add ( STR_ ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } else { assertTrue ( deserialized . add ( STR_ ) ) ; assertTrue ( deserialized . remove ( STR_ ) ) ; } }
public void paintBorder ( Component c , Graphics g , int x , int y , int width , int height ) { JComponent comp = ( c instanceof JComponent ) ? ( JComponent ) c : null ; if ( g instanceof Graphics2D ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . translate ( x , y ) ; paint ( g2 , comp , width , height ) ; g2 . translate ( - x , - y ) ; } else { BufferedImage img = new BufferedImage ( IMG_SIZE , IMG_SIZE , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g2 = ( Graphics2D ) img . getGraphics ( ) ; paint ( g2 , comp , width , height ) ; g2 . dispose ( ) ; ImageScalingHelper . paint ( g , x , y , width , height , img , INSETS , INSETS , ImageScalingHelper . PaintType . PAINT9_STRETCH , ImageScalingHelper . PAINT_ALL ) ; } }
@ SuppressWarnings ( { STR_ , STR_ } ) public static LineByLineFileInputOperator restoreCheckPoint ( LineByLineFileInputOperator checkPointOper , ByteArrayOutputStream bos ) throws Exception { Kryo kryo = new Kryo ( ) ; Input lInput = new Input ( bos . toByteArray ( ) ) ; LineByLineFileInputOperator oper = kryo . readObject ( lInput , checkPointOper . getClass ( ) ) ; lInput . close ( ) ; return oper ; }
private static byte [ ] readClass ( final InputStream is , boolean close ) throws IOException { if ( is == null ) { throw new IOException ( STR_ ) ; } try { byte [ ] b = new byte [ is . available ( ) ] ; int len = NUM_ ; while ( BOOL_ ) { int n = is . read ( b , len , b . length - len ) ; if ( n == - NUM_ ) { if ( len < b . length ) { byte [ ] c = new byte [ len ] ; System . arraycopy ( b , NUM_ , c , NUM_ , len ) ; b = c ; } return b ; } len += n ; if ( len == b . length ) { int last = is . read ( ) ; if ( last < NUM_ ) { return b ; } byte [ ] c = new byte [ b . length + NUM_ ] ; System . arraycopy ( b , NUM_ , c , NUM_ , len ) ; c [ len ++ ] = ( byte ) last ; b = c ; } } } finally { if ( close ) { is . close ( ) ; } } }
private static synchronized boolean isSupportedImpl ( HttpCallerInfo hci ) { if ( supported == null ) { supported = new HashMap < String , Boolean > ( ) ; cache = new HashMap < String , Negotiator > ( ) ; } String hostname = hci . host ; hostname = hostname . toLowerCase ( ) ; if ( supported . containsKey ( hostname ) ) { return supported . get ( hostname ) ; } Negotiator neg = Negotiator . getNegotiator ( hci ) ; if ( neg != null ) { supported . put ( hostname , BOOL_ ) ; cache . put ( hostname , neg ) ; return BOOL_ ; } else { supported . put ( hostname , BOOL_ ) ; return BOOL_ ; } }
public CProjectConfiguration ( final INaviProject project , final ListenerProvider < IProjectListener > listeners , final SQLProvider provider , final int projectId , final String name , final String description , final Date creationDate , final Date modificationDate , final List < DebuggerTemplate > assignedDebuggers ) { m_project = project ; m_listeners = listeners ; m_provider = provider ; m_id = projectId ; m_name = name ; m_description = description ; m_creationDate = new Date ( creationDate . getTime ( ) ) ; m_modificationDate = new Date ( modificationDate . getTime ( ) ) ; m_assignedDebuggers = new ArrayList < DebuggerTemplate > ( assignedDebuggers ) ; }
public Shape chartToScreenShape ( Shape s ) { GeneralPath p = new GeneralPath ( ) ; Transform inverse = Transform . makeTranslation ( getAbsoluteX ( ) , getAbsoluteY ( ) ) ; if ( currentTransform != null ) { inverse . concatenate ( currentTransform ) ; } p . append ( s . getPathIterator ( inverse ) , BOOL_ ) ; return p ; }
@ Override public void addShutdownWindow ( final Window window ) { if ( m_isShutDown ) { closeWindow ( window ) ; return ; } synchronized ( this ) { if ( m_isShutDown ) { closeWindow ( window ) ; return ; } m_windowsToCloseOnShutdown . add ( window ) ; } }
public PerformanceLogger ( ) { time1 = System . currentTimeMillis ( ) ; }
public AuthRequest authenticate ( List discoveries , String returnToUrl ) throws ConsumerException , MessageException { return authenticate ( discoveries , returnToUrl , returnToUrl ) ; }
public Hash ( String hex ) { if ( hex . length ( ) != NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } this . bytes = ByteUtils . reverse ( ByteUtils . fromHex ( hex ) ) ; }
private String [ ] diff_halfMatchI ( String longtext , String shorttext , int i ) { String seed = longtext . substring ( i , i + longtext . length ( ) / NUM_ ) ; int j = - NUM_ ; String best_common = STR_ ; String best_longtext_a = STR_ , best_longtext_b = STR_ ; String best_shorttext_a = STR_ , best_shorttext_b = STR_ ; while ( ( j = shorttext . indexOf ( seed , j + NUM_ ) ) != - NUM_ ) { int prefixLength = diff_commonPrefix ( longtext . substring ( i ) , shorttext . substring ( j ) ) ; int suffixLength = diff_commonSuffix ( longtext . substring ( NUM_ , i ) , shorttext . substring ( NUM_ , j ) ) ; if ( best_common . length ( ) < suffixLength + prefixLength ) { best_common = shorttext . substring ( j - suffixLength , j ) + shorttext . substring ( j , j + prefixLength ) ; best_longtext_a = longtext . substring ( NUM_ , i - suffixLength ) ; best_longtext_b = longtext . substring ( i + prefixLength ) ; best_shorttext_a = shorttext . substring ( NUM_ , j - suffixLength ) ; best_shorttext_b = shorttext . substring ( j + prefixLength ) ; } } if ( best_common . length ( ) . NUM_ >= longtext . length ( ) ) { return new String [ ] { best_longtext_a , best_longtext_b , best_shorttext_a , best_shorttext_b , best_common } ; } else { return null ; } }
public boolean isNumericalRun ( String pin ) { final int len = pin . length ( ) ; int prevDigit = Character . digit ( pin . charAt ( NUM_ ) , NUM_ ) ; int prevDiff = Integer . MAX_VALUE ; boolean isRun = BOOL_ ; for ( int i = NUM_ ; isRun && i < len ; i ++ ) { final int digit = Character . digit ( pin . charAt ( i ) , NUM_ ) ; final int diff = digit - prevDigit ; if ( prevDiff != Integer . MAX_VALUE && diff != prevDiff ) { isRun = BOOL_ ; } prevDiff = diff ; prevDigit = digit ; } return isRun ; }
@ Override protected void onSizeChanged ( int w , int h , int oldw , int oldh ) { super . onSizeChanged ( w , h , oldw , oldh ) ; setupBounds ( w , h ) ; setupPaints ( ) ; invalidate ( ) ; }
public static int uriType ( String uri ) { if ( uri . indexOf ( STR_ ) != - NUM_ ) { return ABS_URI ; } else if ( uri . startsWith ( STR_ ) ) { return ROOT_REL_URI ; } else { return NOROOT_REL_URI ; } }
public Map < String , Object > convertDataToObjects ( Map < String , String > data ) { Map < String , Object > results = new HashMap < > ( ) ; if ( data != null ) { for ( String key : data . keySet ( ) ) { results . put ( key , data . get ( key ) ) ; } } return results ; }
public static void addGlue ( JComponent b , boolean horiz ) { b . add ( horiz ? Box . createHorizontalGlue ( ) : Box . createVerticalGlue ( ) ) ; }
public static boolean isResourceReference ( String str ) { return str . startsWith ( BIG_QUOTE_LEFT ) && str . endsWith ( BIG_QUOTE_RIGHT ) && str . charAt ( NUM_ ) == AT . charAt ( NUM_ ) ; }
public boolean leave ( ) throws KeeperException , InterruptedException { zooKeeper . delete ( rootPath + STR_ + name , NUM_ ) ; while ( BOOL_ ) { synchronized ( mutex ) { List < String > list = zooKeeper . getChildren ( rootPath , BOOL_ ) ; if ( list . size ( ) > NUM_ ) { mutex . wait ( ) ; } else { return BOOL_ ; } } } }
public Enumeration < ? extends Principal > members ( ) { Vector < Principal > v = new Vector < Principal > ( NUM_ ) ; v . addElement ( this ) ; return v . elements ( ) ; }
public SelectClause addWithAsProvidedName ( String propertyName , String asName ) { selectList . add ( new SelectClauseExpression ( new PropertyValueExpression ( propertyName ) , asName ) ) ; return this ; }
public void addInterface ( String interfaceName ) { short interfaceIndex = itsConstantPool . addClass ( interfaceName ) ; itsInterfaces . add ( Short . valueOf ( interfaceIndex ) ) ; }
public static String cutFromIndexOf ( String string , String substring ) { int i = string . indexOf ( substring ) ; if ( i != - NUM_ ) { string = string . substring ( i ) ; } return string ; }
private Response requestHttpGetFromRegistry ( String url ) throws RegistryException { try { Response resp = http . get ( url ) ; if ( resp != null && resp . content != null ) { return resp ; } else { throw new RegistryException ( TYPE . BAD_RESPONSE , STR_ ) ; } } catch ( ClassCastException e ) { throw new RegistryException ( TYPE . BAD_RESPONSE , e ) ; } catch ( ConnectException e ) { throw new RegistryException ( TYPE . PROXY , e ) ; } catch ( UnknownHostException e ) { try { http . get ( STR_ ) ; } catch ( Exception e1 ) { throw new RegistryException ( TYPE . NO_INTERNET , e1 ) ; } throw new RegistryException ( TYPE . SITE_DOWN , e ) ; } catch ( IOException e ) { throw new RegistryException ( TYPE . IO_ERROR , e ) ; } catch ( URISyntaxException e ) { throw new RegistryException ( TYPE . BAD_REQUEST , STR_ + ( ( url != null ) ? url : STR_ ) ) ; } }
public void testIterator ( ) throws InterruptedException { LinkedBlockingQueue q = populatedQueue ( SIZE ) ; Iterator it = q . iterator ( ) ; while ( it . hasNext ( ) ) { assertEquals ( it . next ( ) , q . take ( ) ) ; } }
public static Builder newBuilder ( ) { return new Builder ( ) ; }
public void init ( RemoteAuthenticatedUser currentUser ) { this . currentUser = currentUser ; }
public static void invokeFinalize ( Object o ) throws Throwable { o . finalize ( ) ; }
private void removeTvShow ( TvShow tvShow ) { synchronized ( root ) { TvShowTreeNode child = ( TvShowTreeNode ) nodeMap . get ( tvShow ) ; DefaultMutableTreeNode parent = root ; if ( child != null ) { int index = getIndexOfChild ( parent , child ) ; nodeMap . remove ( tvShow ) ; for ( TvShowEpisode episode : new ArrayList < > ( tvShow . getEpisodes ( ) ) ) { nodeMap . remove ( episode ) ; episode . removePropertyChangeListener ( propertyChangeListener ) ; } tvShow . removePropertyChangeListener ( propertyChangeListener ) ; child . removeAllChildren ( ) ; child . removeFromParent ( ) ; if ( index > - NUM_ ) { TreeModelEvent event = new TreeModelEvent ( this , parent . getPath ( ) , new int [ ] { index } , new Object [ ] { child } ) ; for ( TreeModelListener listener : listeners ) { try { listener . treeNodesRemoved ( event ) ; } catch ( NullPointerException | ArrayIndexOutOfBoundsException npe ) { } } } } } }
private ComplianceFeature checkEncryptPolicy ( org . wso2 . emm . agent . beans . Operation operation ) { boolean encryptStatus = ( devicePolicyManager . getStorageEncryptionStatus ( ) != devicePolicyManager . ENCRYPTION_STATUS_UNSUPPORTED && devicePolicyManager . getStorageEncryptionStatus ( ) != devicePolicyManager . ENCRYPTION_STATUS_INACTIVE ) ; if ( ( operation . isEnabled ( ) && encryptStatus ) || ( ! operation . isEnabled ( ) && ! encryptStatus ) ) { policy . setCompliance ( BOOL_ ) ; } else { policy . setCompliance ( BOOL_ ) ; policy . setMessage ( resources . getString ( R . string . error_encrypt_policy ) ) ; } return policy ; }
public static int instanceOf ( Object o , Class < ? > c ) { if ( o == null ) return FALSE ; return c . isAssignableFrom ( o . getClass ( ) ) ? TRUE : FALSE ; }
@ Override public void add ( int location , E object ) { insertElementAt ( object , location ) ; }
private long cacheResponseAge ( ) { long apparentReceivedAge = servedDate != null ? Math . max ( NUM_ , receivedResponseMillis - servedDate . getTime ( ) ) : NUM_ ; long receivedAge = ageSeconds != - NUM_ ? Math . max ( apparentReceivedAge , SECONDS . toMillis ( ageSeconds ) ) : apparentReceivedAge ; long responseDuration = receivedResponseMillis - sentRequestMillis ; long residentDuration = nowMillis - receivedResponseMillis ; return receivedAge + responseDuration + residentDuration ; }
@ Override public Void call ( ) throws Exception { MulticastSocket datagramSocket = null ; ExecutorService service = null ; try { datagramSocket = new MulticastSocket ( port ) ; datagramSocket . joinGroup ( group ) ; service = Executors . newSingleThreadScheduledExecutor ( new DaemonThreadFactory ( STR_ ) ) ; final byte [ ] buffer = new byte [ BUFFER_SIZE ] ; final DatagramPacket packet = new DatagramPacket ( buffer , NUM_ , buffer . length ) ; listening = BOOL_ ; while ( BOOL_ ) { try { datagramSocket . receive ( packet ) ; if ( Thread . interrupted ( ) ) { break ; } final IGangliaMessage msg = decodeRecord ( packet . getData ( ) , packet . getOffset ( ) , packet . getLength ( ) ) ; if ( msg != null ) { service . submit ( new DispatchTask ( handler , msg ) ) ; } } catch ( Throwable t ) { log . warn ( t , t ) ; } } return ( Void ) null ; } finally { if ( service != null ) { service . shutdown ( ) ; } if ( datagramSocket != null ) { datagramSocket . close ( ) ; } listening = BOOL_ ; } }
private static int arrayIndex ( int i ) { return ( i > > SHIFT_PER_WORD ) ; }
protected static void invalidateSwitchPoints ( ) { if ( LOG_ENABLED ) { LOG . info ( STR_ ) ; } synchronized ( IndyInterface . class ) { SwitchPoint old = switchPoint ; switchPoint = new SwitchPoint ( ) ; SwitchPoint . invalidateAll ( new SwitchPoint [ ] { old } ) ; } }
public VdcConfig toConfigParam ( Properties vdcInfo ) { log . info ( STR_ , vdcInfo . getProperty ( GeoServiceJob . VDC_SHORT_ID ) ) ; VdcConfig vdcConfig = new VdcConfig ( ) ; vdcConfig . setId ( URIUtil . uri ( vdcInfo . getProperty ( GeoServiceJob . OPERATED_VDC_ID ) ) ) ; vdcConfig . setShortId ( vdcInfo . getProperty ( GeoServiceJob . VDC_SHORT_ID ) ) ; vdcConfig . setSecretKey ( vdcInfo . getProperty ( GeoServiceJob . VDC_SECRETE_KEY ) ) ; String name = vdcInfo . getProperty ( GeoServiceJob . VDC_NAME ) ; if ( ( name != null ) && ( ! name . isEmpty ( ) ) ) { vdcConfig . setName ( name ) ; } String description = vdcInfo . getProperty ( GeoServiceJob . VDC_DESCRIPTION ) ; if ( ( description != null ) && ( ! description . isEmpty ( ) ) ) { vdcConfig . setDescription ( description ) ; } String endPnt = vdcInfo . getProperty ( GeoServiceJob . VDC_API_ENDPOINT ) ; if ( endPnt != null ) { vdcConfig . setApiEndpoint ( endPnt ) ; } vdcConfig . setGeoCommandEndpoint ( vdcInfo . getProperty ( GeoServiceJob . VDC_GEOCOMMAND_ENDPOINT ) ) ; vdcConfig . setGeoDataEndpoint ( vdcInfo . getProperty ( GeoServiceJob . VDC_GEODATA_ENDPOINT ) ) ; return vdcConfig ; }
protected OSXAdapter ( String proxySignature , Object target , Method handler ) { this . proxySignature = proxySignature ; this . targetObject = target ; this . targetMethod = handler ; }
private double prediction ( Instance inst ) { double [ ] normalizedInstance = normalizedInstance ( inst ) ; double normalizedPrediction = prediction ( normalizedInstance ) ; return denormalizedPrediction ( normalizedPrediction ) ; }
protected Object finish ( Map settings ) throws WizardException { return provider . finish ( settings ) ; }
public boolean isValidAttachmentPoint ( DatapathId switchDPID , OFPort switchPort ) { if ( topology . isAttachmentPointPort ( switchDPID , switchPort ) == BOOL_ ) return BOOL_ ; if ( suppressAPs . contains ( new SwitchPort ( switchDPID , switchPort ) ) ) return BOOL_ ; return BOOL_ ; }
protected void fireClusterChange ( long timestamp , String type , String message ) { if ( listeners != null && ! listeners . isEmpty ( ) ) { ClusterEvent event = new ClusterEvent ( this , timestamp , type , message ) ; Vector targets ; synchronized ( this ) { targets = ( Vector ) listeners . clone ( ) ; } Enumeration e = targets . elements ( ) ; while ( e . hasMoreElements ( ) ) { ClusterEventListener l = ( ClusterEventListener ) e . nextElement ( ) ; l . changeCluster ( event ) ; } } }
public BatchedImageRequest ( Request < ? > request , ImageContainer container ) { mRequest = request ; mContainers . add ( container ) ; }
public void delete ( ) throws IOException { close ( ) ; deleteContents ( directory ) ; }
public int rgbFor ( int pixel ) { return surfaceType . rgbFor ( pixel , colorModel ) ; }
private boolean checkForCarry ( final char [ ] ca1 , final int icarry ) { boolean carry = BOOL_ ; if ( icarry < ca1 . length ) { if ( ca1 [ icarry ] == STR_ || ca1 [ icarry ] == STR_ || ca1 [ icarry ] == STR_ || ca1 [ icarry ] == STR_ ) { carry = BOOL_ ; } else if ( ca1 [ icarry ] == STR_ ) { int ii = icarry + NUM_ ; for ( ; ii < ca1 . length ; ii ++ ) { if ( ca1 [ ii ] != STR_ ) { break ; } } carry = ii < ca1 . length ; if ( ! carry && icarry > NUM_ ) { carry = ( ca1 [ icarry - NUM_ ] == STR_ || ca1 [ icarry - NUM_ ] == STR_ || ca1 [ icarry - NUM_ ] == STR_ || ca1 [ icarry - NUM_ ] == STR_ || ca1 [ icarry - NUM_ ] == STR_ ) ; } } } return carry ; }
protected void addBottomComponent ( Component bottomComponent ) { c . weighty = NUM_ ; layout . setConstraints ( bottomComponent , c ) ; contentPanel . add ( bottomComponent ) ; }
public static boolean deleteDirectoryFiles ( Set < String > inputFilePathsAndNames ) { if ( ( inputFilePathsAndNames == null ) ) { return BOOL_ ; } boolean didSuccessfullyDeleteAllFiles = BOOL_ ; try { for ( String filePathAndName : inputFilePathsAndNames ) { File file = new File ( filePathAndName ) ; if ( ! file . isDirectory ( ) ) { boolean deleteSuccess = deleteFile ( filePathAndName ) ; if ( ! deleteSuccess ) { logger . debug ( STR_ + filePathAndName + STR_ ) ; didSuccessfullyDeleteAllFiles = BOOL_ ; } } } } catch ( Exception e ) { logger . debug ( e . toString ( ) + System . lineSeparator ( ) + StackTrace . getStringFromStackTrace ( e ) ) ; return BOOL_ ; } return didSuccessfullyDeleteAllFiles ; }
public static File createTempDir ( File dir , boolean cleanup ) throws IOException { if ( ! dir . mkdirs ( ) && ! dir . exists ( ) ) { throw new IOException ( String . format ( STR_ , dir . toString ( ) ) ) ; } if ( cleanup ) { addCleanupHook ( dir . toPath ( ) ) ; } return dir ; }
public void emitInit ( ) { out . append ( STR_ ) ; out . append ( constName ( ) ) ; out . append ( STR_ ) ; out . append ( name ) ; out . append ( STR_ ) ; nl ( ) ; nextChunk ( ) ; }
public static String readCookieIgnoreSpecialCharacters ( HttpServletRequest request , String cookieName ) { String cs = request . getHeader ( STR_ ) ; if ( cs == null ) return null ; int start = cs . indexOf ( cookieName ) ; if ( start < NUM_ ) return null ; cs = cs . substring ( start + NUM_ + cookieName . length ( ) ) ; int end = cs . indexOf ( STR_ ) ; if ( end > NUM_ ) { cs = cs . substring ( NUM_ , end ) ; } return cs ; }
protected final void merge ( @ NotNull Set < LocalResourceRepository > visited , @ NotNull ResourceType type , @ NotNull SetMultimap < String , String > seenQualifiers , @ NotNull ListMultimap < String , ResourceItem > result ) { if ( visited . contains ( this ) ) { return ; } visited . add ( this ) ; doMerge ( visited , type , seenQualifiers , result ) ; }
private byte [ ] translateTransferableString ( String str , long format ) throws IOException { Long lFormat = Long . valueOf ( format ) ; String charset = getBestCharsetForTextFormat ( lFormat , null ) ; String eoln = ( String ) nativeEOLNs . get ( lFormat ) ; if ( eoln != null ) { int length = str . length ( ) ; StringBuffer buffer = new StringBuffer ( length . NUM_ ) ; for ( int i = NUM_ ; i < length ; i ++ ) { if ( str . startsWith ( eoln , i ) ) { buffer . append ( eoln ) ; i += eoln . length ( ) - NUM_ ; continue ; } char c = str . charAt ( i ) ; if ( c == STR_ ) { buffer . append ( eoln ) ; } else { buffer . append ( c ) ; } } str = buffer . toString ( ) ; } byte [ ] bytes = str . getBytes ( charset ) ; Integer terminators = ( Integer ) nativeTerminators . get ( lFormat ) ; if ( terminators != null ) { int numTerminators = terminators . intValue ( ) ; byte [ ] terminatedBytes = new byte [ bytes . length + numTerminators ] ; System . arraycopy ( bytes , NUM_ , terminatedBytes , NUM_ , bytes . length ) ; for ( int i = bytes . length ; i < terminatedBytes . length ; i ++ ) { terminatedBytes [ i ] = x0 ; } bytes = terminatedBytes ; } return bytes ; }
private byte [ ] createPreviewBuffer ( Size previewSize ) { int bitsPerPixel = ImageFormat . getBitsPerPixel ( ImageFormat . NV21 ) ; long sizeInBits = previewSize . getHeight ( ) . previewSize . getWidth ( ) . bitsPerPixel ; int bufferSize = ( int ) Math . ceil ( sizeInBits / NUM_ ) + NUM_ ; byte [ ] byteArray = new byte [ bufferSize ] ; ByteBuffer buffer = ByteBuffer . wrap ( byteArray ) ; if ( ! buffer . hasArray ( ) || ( buffer . array ( ) != byteArray ) ) { throw new IllegalStateException ( STR_ ) ; } mBytesToByteBuffer . put ( byteArray , buffer ) ; return byteArray ; }
public void add ( int pos , Box b ) { children . add ( pos , b ) ; b . parent = this ; b . elderParent = elderParent ; }
public Position createPosition ( int offset ) throws BadLocationException { while ( queue . poll ( ) != null ) { unusedMarks ++ ; } if ( unusedMarks > Math . max ( NUM_ , ( marks . size ( ) / NUM_ ) ) ) { removeUnusedMarks ( ) ; } int g0 = getGapStart ( ) ; int g1 = getGapEnd ( ) ; int index = ( offset < g0 ) ? offset : offset + ( g1 - g0 ) ; search . index = index ; int sortIndex = findSortIndex ( search ) ; MarkData m ; StickyPosition position ; if ( sortIndex < marks . size ( ) && ( m = marks . elementAt ( sortIndex ) ) . index == index && ( position = m . getPosition ( ) ) != null ) { } else { position = new StickyPosition ( ) ; m = new MarkData ( index , position , queue ) ; position . setMark ( m ) ; marks . insertElementAt ( m , sortIndex ) ; } return position ; }
public static String pad ( String string , int n , String padding , boolean right ) { if ( n < NUM_ ) { n = NUM_ ; } if ( n < string . length ( ) ) { return string . substring ( NUM_ , n ) ; } else if ( n == string . length ( ) ) { return string ; } char paddingChar ; if ( padding == null || padding . length ( ) == NUM_ ) { paddingChar = STR_ ; } else { paddingChar = padding . charAt ( NUM_ ) ; } StringBuilder buff = new StringBuilder ( n ) ; n -= string . length ( ) ; if ( right ) { buff . append ( string ) ; } for ( int i = NUM_ ; i < n ; i ++ ) { buff . append ( paddingChar ) ; } if ( ! right ) { buff . append ( string ) ; } return buff . toString ( ) ; }
private final void resetDTX ( AffineTransform at ) { fsref = null ; dtx = at ; invdtx = null ; if ( ! dtx . isIdentity ( ) ) { try { invdtx = dtx . createInverse ( ) ; } catch ( NoninvertibleTransformException e ) { } } if ( gti != null ) { gti . strikesRef = null ; } }
public static void addActivityListener ( ActivityListener listener ) { if ( listener != null ) { startTracking ( ) ; listeners . add ( listener ) ; } }
public void addMutedUsername ( final String username , final Date muteTill ) { if ( isUsernameMuted ( username ) ) { removeMutedUsername ( username ) ; } Timestamp muteTillTs = null ; if ( muteTill != null ) { muteTillTs = new Timestamp ( muteTill . getTime ( ) ) ; } s_logger . fine ( STR_ + username ) ; final Connection con = Database . getConnection ( ) ; try { final PreparedStatement ps = con . prepareStatement ( STR_ ) ; ps . setString ( NUM_ , username ) ; ps . setTimestamp ( NUM_ , muteTillTs ) ; ps . execute ( ) ; ps . close ( ) ; con . commit ( ) ; } catch ( final SQLException sqle ) { if ( sqle . getErrorCode ( ) == NUM_ ) { s_logger . info ( STR_ + username + STR_ + sqle . getMessage ( ) ) ; return ; } s_logger . log ( Level . SEVERE , STR_ + username , sqle ) ; throw new IllegalStateException ( sqle . getMessage ( ) ) ; } finally { DbUtil . closeConnection ( con ) ; } }
private Response < Bitmap > doParse ( NetworkResponse response ) { byte [ ] data = response . data ; Log . d ( STR_ , STR_ ) ; BitmapFactory . Options decodeOptions = new BitmapFactory . Options ( ) ; Bitmap bitmap = null ; Log . d ( STR_ , STR_ ) ; decodeOptions . inJustDecodeBounds = BOOL_ ; BitmapFactory . decodeByteArray ( data , NUM_ , data . length , decodeOptions ) ; int actualWidth = decodeOptions . outWidth ; int actualHeight = decodeOptions . outHeight ; int desiredWidth = getResizedDimension ( mMaxWidth , mMaxHeight , actualWidth , actualHeight , mScaleType ) ; int desiredHeight = getResizedDimension ( mMaxHeight , mMaxWidth , actualHeight , actualWidth , mScaleType ) ; decodeOptions . inJustDecodeBounds = BOOL_ ; decodeOptions . inSampleSize = findBestSampleSize ( actualWidth , actualHeight , desiredWidth , desiredHeight ) ; Bitmap tempBitmap = BitmapFactory . decodeByteArray ( data , NUM_ , data . length , decodeOptions ) ; if ( tempBitmap != null && ( tempBitmap . getWidth ( ) > desiredWidth || tempBitmap . getHeight ( ) > desiredHeight ) ) { bitmap = Bitmap . createScaledBitmap ( tempBitmap , desiredWidth , desiredHeight , BOOL_ ) ; tempBitmap . recycle ( ) ; } else { bitmap = tempBitmap ; } if ( bitmap == null ) { return Response . error ( new ParseError ( response ) ) ; } else { return Response . success ( bitmap , HttpHeaderParser . parseCacheHeaders ( response ) ) ; } }
public void applyComponentOrientation ( ComponentOrientation o ) { possiblyFixCursor ( o . isLeftToRight ( ) ) ; super . applyComponentOrientation ( o ) ; }
public boolean isEmpty ( ) { return mSelectedWidgets . isEmpty ( ) ; }
public void close ( ) throws IOException { if ( ! closed ) { try { finish ( ) ; } finally { out . close ( ) ; closed = BOOL_ ; } } }
protected abstract C newParcelableAdapterInstance ( List < Object > items ) ;
public static void nextBytes ( byte [ ] bytes ) { wasAccessed = BOOL_ ; for ( int i = NUM_ ; i < bytes . length ; ) for ( int rnd = nextInt ( ) , n = Math . min ( bytes . length - i , NUM_ ) ; n -- > NUM_ ; rnd >>= NUM_ ) bytes [ i ++ ] = ( byte ) rnd ; }
protected void drawLowFarOut ( double aRadius , Graphics2D g2 , double xx , double m ) { double side = aRadius . NUM_ ; g2 . draw ( new Line2D . Double ( xx - side , m - side , xx + side , m - side ) ) ; g2 . draw ( new Line2D . Double ( xx - side , m - side , xx , m ) ) ; g2 . draw ( new Line2D . Double ( xx + side , m - side , xx , m ) ) ; }
public boolean isJavaLibraryClass ( ) { if ( name . startsWith ( STR_ ) || name . startsWith ( STR_ ) || name . startsWith ( STR_ ) || name . startsWith ( STR_ ) || name . startsWith ( STR_ ) || name . startsWith ( STR_ ) ) return BOOL_ ; return BOOL_ ; }
private Set < ObjectName > objectNamesFromFilteredNamedObjects ( Set < NamedObject > list , QueryExp query ) { Set < ObjectName > result = new HashSet < ObjectName > ( ) ; if ( query == null ) { for ( NamedObject no : list ) { result . add ( no . getName ( ) ) ; } } else { final MBeanServer oldServer = QueryEval . getMBeanServer ( ) ; query . setMBeanServer ( server ) ; try { for ( NamedObject no : list ) { boolean res ; try { res = query . apply ( no . getName ( ) ) ; } catch ( Exception e ) { res = BOOL_ ; } if ( res ) { result . add ( no . getName ( ) ) ; } } } finally { query . setMBeanServer ( oldServer ) ; } } return result ; }
private boolean checkTouchSlop ( View child , float dx , float dy ) { if ( child == null ) { return BOOL_ ; } final boolean checkHorizontal = mCallback . getViewHorizontalDragRange ( child ) > NUM_ ; final boolean checkVertical = mCallback . getViewVerticalDragRange ( child ) > NUM_ ; if ( checkHorizontal && checkVertical ) { return dx . dx + dy . dy > mTouchSlop . mTouchSlop ; } else if ( checkHorizontal ) { return Math . abs ( dx ) > mTouchSlop ; } else if ( checkVertical ) { return Math . abs ( dy ) > mTouchSlop ; } return BOOL_ ; }
private Element createEndPoint ( String name , String attrBinding , String attrLocation , String attrResponseLocation ) throws DOMException { if ( name == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( attrBinding == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( attrLocation == null ) { throw new IllegalArgumentException ( STR_ ) ; } Element endPt = doc . createElement ( name ) ; endPt . setAttribute ( SAMLNames . BINDING , attrBinding ) ; endPt . setAttribute ( SAMLNames . LOCATION , attrLocation ) ; if ( attrResponseLocation != null ) { endPt . setAttribute ( SAMLNames . RESPLOC , attrResponseLocation ) ; } return endPt ; }
void putFile ( String relativePath , Codebase codebase ) { try { File dest = new File ( rootDirectory . getAbsolutePath ( ) , relativePath ) ; File src = codebase . getFile ( relativePath ) ; boolean srcExists = filesystem . exists ( src ) ; boolean destExists = filesystem . exists ( dest ) ; boolean srcExecutable = filesystem . isExecutable ( src ) ; boolean destExecutable = filesystem . isExecutable ( dest ) ; if ( ! srcExists && ! destExists ) { throw new MoeProblem ( STR_ , relativePath , src , dest ) ; } if ( ! srcExists ) { util . runSvnCommandWithWorkingDirectory ( rootDirectory . getAbsolutePath ( ) , STR_ , relativePath ) ; return ; } try { filesystem . makeDirsForFile ( dest ) ; filesystem . copyFile ( src , dest ) ; } catch ( IOException e ) { throw new MoeProblem ( e . getMessage ( ) ) ; } if ( ! destExists ) { util . runSvnCommandWithWorkingDirectory ( rootDirectory . getAbsolutePath ( ) , STR_ , STR_ , relativePath ) ; } String mimeType = guessMimeType ( relativePath ) ; if ( mimeType != null ) { try { util . runSvnCommandWithWorkingDirectory ( rootDirectory . getAbsolutePath ( ) , STR_ , STR_ , mimeType , relativePath ) ; } catch ( CommandRunner . CommandException e ) { ui . message ( STR_ , relativePath ) ; } } if ( destExecutable != srcExecutable ) { if ( srcExecutable ) { util . runSvnCommandWithWorkingDirectory ( rootDirectory . getAbsolutePath ( ) , STR_ , STR_ , STR_ , relativePath ) ; } else { util . runSvnCommandWithWorkingDirectory ( rootDirectory . getAbsolutePath ( ) , STR_ , STR_ , relativePath ) ; } } } catch ( CommandRunner . CommandException e ) { throw new MoeProblem ( STR_ + e . stderr ) ; } }
public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( toString ( getClass ( ) ) ) ; buffer . append ( STR_ ) ; buffer . append ( isUseDefault ( ) ) ; buffer . append ( STR_ ) ; buffer . append ( useLocaleFormat ) ; if ( pattern != null ) { buffer . append ( STR_ ) ; buffer . append ( pattern ) ; } if ( locale != null ) { buffer . append ( STR_ ) ; buffer . append ( locale ) ; } buffer . append ( STR_ ) ; return buffer . toString ( ) ; }
public void test_multipleResourceLocking_resources10_locktries10 ( ) throws Exception { final Properties properties = new Properties ( ) ; properties . setProperty ( TestOptions . NTHREADS , STR_ ) ; properties . setProperty ( TestOptions . NTASKS , STR_ ) ; properties . setProperty ( TestOptions . NRESOURCES , STR_ ) ; properties . setProperty ( TestOptions . MIN_LOCKS , STR_ ) ; properties . setProperty ( TestOptions . MAX_LOCKS , STR_ ) ; properties . setProperty ( TestOptions . MAX_LOCK_TRIES , STR_ ) ; properties . setProperty ( TestOptions . PREDECLARE_LOCKS , STR_ ) ; properties . setProperty ( TestOptions . SORT_LOCK_REQUESTS , STR_ ) ; properties . setProperty ( TestOptions . TIMEOUT , Long . toString ( NUM_ . NUM_ ) ) ; doComparisonTest ( properties ) ; }
public void startElement ( String namespaceURI , String localName , String qName , Attributes atts ) throws org . xml . sax . SAXException { throw new StopParseException ( ) ; }
public synchronized byte [ ] toByteArray ( ) { byte [ ] newArray = new byte [ count ] ; System . arraycopy ( buf , NUM_ , newArray , NUM_ , count ) ; return newArray ; }
Calendar toCalendar ( String value , String pattern , Locale locale ) { Calendar calendar = null ; try { DateFormat format = ( locale == null ) ? new SimpleDateFormat ( pattern ) : new SimpleDateFormat ( pattern , locale ) ; format . setLenient ( BOOL_ ) ; format . parse ( value ) ; calendar = format . getCalendar ( ) ; } catch ( Exception e ) { fail ( STR_ + value + STR_ + pattern + STR_ + e . toString ( ) ) ; } return calendar ; }
private byte [ ] convertBitmapToBytes ( final Bitmap bitmap ) { int size = bitmap . getRowBytes ( ) . bitmap . getHeight ( ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( size ) ; try { if ( bitmap . compress ( Bitmap . CompressFormat . PNG , NUM_ , out ) ) { return out . toByteArray ( ) ; } if ( sLogger . isActivated ( ) ) { sLogger . debug ( STR_ ) ; } return null ; } finally { CloseableUtils . tryToClose ( out ) ; } }
private static void saveTemplate ( File parentDir , FileTemplateBase template , final String lineSeparator ) throws IOException { final File templateFile = new File ( parentDir , encodeFileName ( template . getName ( ) , template . getExtension ( ) ) ) ; FileOutputStream fileOutputStream ; try { fileOutputStream = new FileOutputStream ( templateFile ) ; } catch ( FileNotFoundException e ) { FileUtil . delete ( templateFile ) ; fileOutputStream = new FileOutputStream ( templateFile ) ; } OutputStreamWriter outputStreamWriter = new OutputStreamWriter ( fileOutputStream , CharsetToolkit . UTF8_CHARSET ) ; String content = template . getText ( ) ; if ( ! lineSeparator . equals ( STR_ ) ) { content = StringUtil . convertLineSeparators ( content , lineSeparator ) ; } outputStreamWriter . write ( content ) ; outputStreamWriter . close ( ) ; fileOutputStream . close ( ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( NUM_ ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
public void addComposite ( TransformTreeNode node ) { parts . add ( node ) ; }
protected static void postProcessFlood ( IHex [ ] hexSet , int modifier ) { int n ; IHex field ; ITerrainFactory f = Terrains . getTerrainFactory ( ) ; for ( n = NUM_ ; n < hexSet . length ; n ++ ) { field = hexSet [ n ] ; int elev = field . getLevel ( ) - modifier ; if ( ( elev == NUM_ ) && ! ( field . containsTerrain ( Terrains . WATER ) ) && ! ( field . containsTerrain ( Terrains . PAVEMENT ) ) ) { field . addTerrain ( f . createTerrain ( Terrains . SWAMP , NUM_ ) ) ; } else if ( elev < NUM_ ) { if ( elev < - NUM_ ) { elev = - NUM_ ; } field . removeAllTerrains ( ) ; field . addTerrain ( f . createTerrain ( Terrains . WATER , - elev ) ) ; field . setLevel ( modifier ) ; } } }
public ModuleHandle addModule ( String moduleName , String sessionKey ) { String sanitizedModuleName = generateUniqueNameIfNullOrEmpty ( moduleName , STR_ ) ; ModuleHandle moduleHandle = new ModuleHandle ( sanitizedModuleName , sessionKey ) ; synchronized ( privateInstanceLock ) { modules . add ( moduleHandle ) ; } setTerminated ( BOOL_ ) ; return moduleHandle ; }
private static void expand2DigitNumber ( String numberString , WordRelation wordRelation , Item tokenItem ) { if ( numberString . charAt ( NUM_ ) == STR_ ) { if ( numberString . charAt ( NUM_ ) == STR_ ) { } else { String number = digit2num [ numberString . charAt ( NUM_ ) - STR_ ] ; wordRelation . addWord ( tokenItem , number ) ; } } else if ( numberString . charAt ( NUM_ ) == STR_ ) { String number = digit2enty [ numberString . charAt ( NUM_ ) - STR_ ] ; wordRelation . addWord ( tokenItem , number ) ; } else if ( numberString . charAt ( NUM_ ) == STR_ ) { String number = digit2teen [ numberString . charAt ( NUM_ ) - STR_ ] ; wordRelation . addWord ( tokenItem , number ) ; } else { String enty = digit2enty [ numberString . charAt ( NUM_ ) - STR_ ] ; wordRelation . addWord ( tokenItem , enty ) ; expandDigits ( numberString . substring ( NUM_ , numberString . length ( ) ) , wordRelation , tokenItem ) ; } }
protected int indexOf ( String buffer , int start , int end , char ch ) { for ( int i = start ; i < end ; i ++ ) { if ( buffer . charAt ( i ) == ch ) { return i ; } } return - NUM_ ; }
public Factory ( JavacMessages messages , String prefix ) { this . prefix = prefix ; this . formatter = new BasicDiagnosticFormatter ( messages ) ; defaultErrorFlags = EnumSet . of ( DiagnosticFlag . MANDATORY ) ; }
@ Override protected boolean isFrontierEmpty ( ) { cleanUpFrontier ( ) ; updateMetrics ( frontier . size ( ) ) ; return frontier . isEmpty ( ) ; }
public void testSetObject_int_Object_int_int ( ) throws SQLException { PreparedStatement ps = null ; try { String query = STR_ ; ps = conn . prepareStatement ( query ) ; Statement st = null ; try { ps . setObject ( NUM_ , Integer . MAX_VALUE , Types . INTEGER , Integer . MAX_VALUE ) ; ps . execute ( ) ; st = conn . createStatement ( ) ; st . execute ( STR_ + Integer . MAX_VALUE ) ; ResultSet rs = st . getResultSet ( ) ; assertEquals ( NUM_ , getCount ( rs ) ) ; } finally { try { st . close ( ) ; } catch ( Exception ee ) { } } query = STR_ ; ps = conn . prepareStatement ( query ) ; try { ps . setObject ( NUM_ , STR_ , Types . CHAR , Integer . MIN_VALUE ) ; ps . execute ( ) ; st = conn . createStatement ( ) ; st . execute ( STR_ ) ; ResultSet rs = st . getResultSet ( ) ; assertEquals ( NUM_ , getCount ( rs ) ) ; } finally { try { st . close ( ) ; } catch ( Exception ee ) { } } query = STR_ ; ps = conn . prepareStatement ( query ) ; BigDecimal bd2 = new BigDecimal ( STR_ ) ; ps . setObject ( NUM_ , bd2 , Types . DECIMAL , NUM_ ) ; ps . execute ( ) ; query = STR_ ; ps = conn . prepareStatement ( query ) ; Date d = new Date ( NUM_ ) ; try { ps . setObject ( NUM_ , d , Types . DATE , - NUM_ ) ; ps . execute ( ) ; st = conn . createStatement ( ) ; st . execute ( STR_ + d . getTime ( ) + STR_ ) ; ResultSet rs = st . getResultSet ( ) ; assertEquals ( NUM_ , getCount ( rs ) ) ; } finally { try { st . close ( ) ; } catch ( Exception ee ) { } } query = STR_ ; ps = conn . prepareStatement ( query ) ; try { ps . setObject ( NUM_ , STR_ , Types . BLOB , NUM_ ) ; ps . execute ( ) ; } finally { try { st . close ( ) ; } catch ( Exception ee ) { } } } finally { try { ps . close ( ) ; } catch ( Exception ee ) { } } try { ps . setObject ( NUM_ , STR_ , Types . CHAR , Integer . MIN_VALUE ) ; fail ( STR_ ) ; } catch ( SQLException e ) { } }
@ Override public boolean isEnabled ( ) { if ( ( attributeSelectionPanel != null ) && ! isValueOnly ( ) ) { return attributeSelectionPanel . isEnabled ( ) ; } else { if ( this . crsComboBox != null ) { return crsComboBox . isEnabled ( ) ; } } return BOOL_ ; }
@ Override public synchronized void initialize ( ) { if ( ! mRootDirectory . exists ( ) ) { if ( ! mRootDirectory . mkdirs ( ) ) { VolleyLog . e ( STR_ , mRootDirectory . getAbsolutePath ( ) ) ; } return ; } File [ ] files = mRootDirectory . listFiles ( ) ; if ( files == null ) { return ; } for ( File file : files ) { BufferedInputStream fis = null ; try { fis = new BufferedInputStream ( new FileInputStream ( file ) ) ; CacheHeader entry = CacheHeader . readHeader ( fis ) ; entry . size = file . length ( ) ; putEntry ( entry . key , entry ) ; } catch ( IOException e ) { if ( file != null ) { file . delete ( ) ; } } finally { try { if ( fis != null ) { fis . close ( ) ; } } catch ( IOException ignored ) { } } } }
public static double variance ( double [ ] x , double mean ) { double var = NUM_ ; int count = x . length ; for ( double aX : x ) { if ( Double . isNaN ( aX ) ) { count -- ; } else { double diff = aX - mean ; var += diff . diff ; } } if ( count < NUM_ ) { count = NUM_ ; } else { count = count - NUM_ ; } return var / ( double ) count ; }
private void stashRequestUser ( RequestAndResponse requestAndResponse ) { if ( requestAndResponse . wasUserAlreadyStashed ) { return ; } requestAndResponse . wasUserAlreadyStashed = BOOL_ ; final User user = dbLogic . getUserById ( getEffectiveUserId ( requestAndResponse ) ) ; if ( user != null ) { requestAndResponse . userIsAdmin = user . getIsAdmin ( ) ; requestAndResponse . userIsAccountClosed = user . getIsAccountClosed ( ) ; requestAndResponse . userOptions = user . getOptions ( ) ; } else { requestAndResponse . userOptions = STR_ ; } }
@ Override public void sendLocationList ( ) { List < Location > locationList = lm . getLocationsByNameList ( ) ; ArrayList < Attribute > location ; for ( Location loc : locationList ) { location = new ArrayList < Attribute > ( NUM_ ) ; location . add ( new Attribute ( LOCATIONS , loc ) ) ; try { sendMessage ( location ) ; } catch ( IOException ioe ) { log . debug ( STR_ + loc . getName ( ) ) ; } } }
protected void serializeText ( Text node ) throws SAXException { if ( fNextIsRaw ) { fNextIsRaw = BOOL_ ; fSerializer . processingInstruction ( javax . xml . transform . Result . PI_DISABLE_OUTPUT_ESCAPING , STR_ ) ; dispatachChars ( node ) ; fSerializer . processingInstruction ( javax . xml . transform . Result . PI_ENABLE_OUTPUT_ESCAPING , STR_ ) ; } else { boolean bDispatch = BOOL_ ; if ( ( fFeatures & WELLFORMED ) != NUM_ ) { isTextWellFormed ( node ) ; } boolean isElementContentWhitespace = BOOL_ ; if ( fIsLevel3DOM ) { isElementContentWhitespace = node . isElementContentWhitespace ( ) ; } if ( isElementContentWhitespace ) { if ( ( fFeatures & ELEM_CONTENT_WHITESPACE ) != NUM_ ) { bDispatch = BOOL_ ; } } else { bDispatch = BOOL_ ; } if ( ! applyFilter ( node , NodeFilter . SHOW_TEXT ) ) { return ; } if ( bDispatch ) { dispatachChars ( node ) ; } } }
@ Override public boolean isInsideSoftWrap ( @ NotNull VisualPosition visual ) { return isInsideSoftWrap ( visual , BOOL_ ) ; }
static public InputStream findClusterXML ( String _clusterXML ) { String schemaNameToBeUsed = _clusterXML ; InputStream schemaInputStream ; String schemaFilePath = Constants . Container . CONTAINER_CONFIG_DIRECTORY + STR_ + schemaNameToBeUsed + ClusterXML . CLUSTER_XML_FILE_SUFFIX ; schemaInputStream = getResourceStream ( schemaFilePath ) ; if ( schemaInputStream != null ) { if ( _logger . isLoggable ( Level . INFO ) ) { _logger . info ( STR_ + getResourceURL ( schemaNameToBeUsed ) + STR_ ) ; } return schemaInputStream ; } else { String defaultSchemaFileName = Constants . Container . CONTAINER_CONFIG_DIRECTORY + STR_ + Constants . Schemas . DEFAULT_SCHEMA + ClusterXML . CLUSTER_XML_FILE_SUFFIX ; schemaInputStream = getResourceStream ( defaultSchemaFileName ) ; if ( schemaInputStream != null ) { if ( _logger . isLoggable ( Level . WARNING ) ) { _logger . warning ( STR_ + schemaFilePath + STR_ + getResourceURL ( defaultSchemaFileName ) + STR_ ) ; } return schemaInputStream ; } else { if ( _logger . isLoggable ( Level . WARNING ) ) { _logger . warning ( STR_ + defaultSchemaFileName ) ; } } } return schemaInputStream ; }
public boolean isValid ( World world ) { return BOOL_ ; }
public void clear ( ) { Arrays . fill ( ritems , NUM_ , rsize , null ) ; Arrays . fill ( pitems , NUM_ , psize , null ) ; rsize = NUM_ ; psize = NUM_ ; }
private ParsePosition next ( final ParsePosition pos ) { pos . setIndex ( pos . getIndex ( ) + NUM_ ) ; return pos ; }
public final AC growPrio ( int p ) { return growPrio ( p , curIx ) ; }
private int flush ( int offset ) { try { _os . write ( _buffer , NUM_ , offset ) ; _offset = NUM_ ; return NUM_ ; } catch ( IOException e ) { throw new H3ExceptionOut ( e ) ; } }
protected String generateSectionLabel ( PieDataset dataset , Comparable key ) { String result = null ; if ( dataset != null ) { Object [ ] items = createItemArray ( dataset , key ) ; result = MessageFormat . format ( this . labelFormat , items ) ; } return result ; }
public synchronized void removeGraphListener ( GraphListener cl ) { m_graphListeners . remove ( cl ) ; }
public void exec ( String description , String [ ] baseCommand ) throws BackupException { exec ( description , baseCommand , null , null , null , BOOL_ , BOOL_ ) ; }
public int increment ( int offset ) { CharSequence txt = getText ( ) ; int i ; if ( txt != null ) { try { i = Integer . parseInt ( txt . toString ( ) ) ; } catch ( NumberFormatException e ) { i = NUM_ ; } } else { i = NUM_ ; } i = i + offset ; setText ( String . valueOf ( i ) ) ; return i ; }
public static ServiceConfiguration create ( InputStream inStream ) throws IOException , IllegalArgumentException { try { checkNotNull ( inStream ) ; Properties properties = new Properties ( ) ; properties . load ( inStream ) ; return ( create ( properties ) ) ; } finally { if ( inStream != null ) { inStream . close ( ) ; } } }
private void expand ( int i ) { if ( count + i <= buf . length ) { return ; } byte [ ] newbuf = mPool . getBuf ( ( count + i ) . NUM_ ) ; System . arraycopy ( buf , NUM_ , newbuf , NUM_ , count ) ; mPool . returnBuf ( buf ) ; buf = newbuf ; }
protected int [ ] splitSentence ( String sentence ) { String [ ] w = sentence . split ( STR_ ) ; int [ ] words = new int [ w . length ] ; for ( int i = NUM_ ; i < w . length ; i ++ ) words [ i ] = Vocabulary . id ( w [ i ] ) ; return words ; }
public static boolean isFailure ( List < Action > actions ) { return actions . isEmpty ( ) ; }
public void addToDictionary ( String s ) { if ( ! getAutoComplete ( ) ) return ; if ( dict == null ) { setUp ( ) ; this . dict = createDefaultDictionary ( ) ; } dict . addEntry ( s . trim ( ) ) ; }
public static int [ ] [ ] deep_copy ( int M [ ] [ ] ) { int [ ] [ ] C = new int [ M . length ] [ ] ; for ( int i = NUM_ ; i < C . length ; i ++ ) { C [ i ] = Arrays . copyOf ( M [ i ] , M [ i ] . length ) ; } return C ; }
public final boolean checkTag ( int identifier ) { return Arrays . binarySearch ( identifiers [ NUM_ ] , identifier ) >= NUM_ ; }
public void waitForMessageToArrive ( ) { LOG . info ( STR_ ) ; long start = System . currentTimeMillis ( ) ; synchronized ( messages ) { try { while ( hasReceivedMessage ( ) ) { messages . wait ( NUM_ ) ; } } catch ( InterruptedException e ) { LOG . info ( STR_ + e ) ; } } long end = System . currentTimeMillis ( ) - start ; LOG . info ( STR_ + end + STR_ ) ; }
public Date ( String date ) { String [ ] fields = date . split ( STR_ ) ; if ( fields . length != NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } month = Integer . parseInt ( fields [ NUM_ ] ) ; day = Integer . parseInt ( fields [ NUM_ ] ) ; year = Integer . parseInt ( fields [ NUM_ ] ) ; if ( ! isValid ( month , day , year ) ) throw new IllegalArgumentException ( STR_ ) ; }
public static void copy ( File src , File dst ) throws IOException { if ( src . isDirectory ( ) ) { ensureDirectoryExists ( dst ) ; String [ ] filesList = src . list ( ) ; for ( String file : filesList ) { File srcFile = new File ( src , file ) ; File destFile = new File ( dst , file ) ; copy ( srcFile , destFile ) ; } } else { copyFile ( src , dst ) ; } }
public MapObjects ( PokemonGo api ) { this . api = api ; }
@ Override public byte [ ] read ( int length ) throws IOException { if ( length > available ( ) ) { throw new EndOfBufferException ( ) ; } byte [ ] res = new byte [ length ] ; System . arraycopy ( buffer , read_pos , res , NUM_ , length ) ; read_pos = read_pos + length ; return res ; }
public String encode ( String pString ) throws EncoderException { if ( pString == null ) { return null ; } try { return encode ( pString , getDefaultCharset ( ) ) ; } catch ( UnsupportedEncodingException e ) { throw new EncoderException ( e . getMessage ( ) ) ; } }
public void testSortsAccordingNumberOfAttributes ( ) throws Exception { XppDom dom1 = XppFactory . buildDom ( STR_ ) ; XppDom dom2 = XppFactory . buildDom ( STR_ ) ; assertEquals ( - NUM_ , comparator . compare ( dom1 , dom2 ) ) ; assertEquals ( STR_ , xpath . get ( ) ) ; assertEquals ( NUM_ , comparator . compare ( dom2 , dom1 ) ) ; assertEquals ( STR_ , xpath . get ( ) ) ; }
static void incrementKeepAliveCount ( ) { synchronized ( keepAliveLock ) { keepAliveCount ++ ; if ( reaper == null ) { reaper = AccessController . doPrivileged ( new NewThreadAction ( new Reaper ( ) , STR_ , BOOL_ ) ) ; reaper . start ( ) ; } if ( gcLatencyRequest == null ) { gcLatencyRequest = GC . requestLatency ( gcInterval ) ; } } }
static MethodHandle makeCollectArguments ( MethodHandle target , MethodHandle collector , int collectArgPos , boolean retainOriginalArgs ) { MethodType targetType = target . type ( ) ; MethodType collectorType = collector . type ( ) ; int collectArgCount = collectorType . parameterCount ( ) ; Class < ? > collectValType = collectorType . returnType ( ) ; int collectValCount = ( collectValType == void . class ? NUM_ : NUM_ ) ; MethodType srcType = targetType . dropParameterTypes ( collectArgPos , collectArgPos + collectValCount ) ; if ( ! retainOriginalArgs ) { srcType = srcType . insertParameterTypes ( collectArgPos , collectorType . parameterList ( ) ) ; } MethodType lambdaType = srcType . invokerType ( ) ; Name [ ] names = arguments ( NUM_ , lambdaType ) ; final int collectNamePos = names . length - NUM_ ; final int targetNamePos = names . length - NUM_ ; Name [ ] collectorArgs = Arrays . copyOfRange ( names , NUM_ + collectArgPos , NUM_ + collectArgPos + collectArgCount ) ; names [ collectNamePos ] = new Name ( collector , ( Object [ ] ) collectorArgs ) ; Name [ ] targetArgs = new Name [ targetType . parameterCount ( ) ] ; int inputArgPos = NUM_ ; int targetArgPos = NUM_ ; int chunk = collectArgPos ; System . arraycopy ( names , inputArgPos , targetArgs , targetArgPos , chunk ) ; inputArgPos += chunk ; targetArgPos += chunk ; if ( collectValType != void . class ) { targetArgs [ targetArgPos ++ ] = names [ collectNamePos ] ; } chunk = collectArgCount ; if ( retainOriginalArgs ) { System . arraycopy ( names , inputArgPos , targetArgs , targetArgPos , chunk ) ; targetArgPos += chunk ; } inputArgPos += chunk ; chunk = targetArgs . length - targetArgPos ; System . arraycopy ( names , inputArgPos , targetArgs , targetArgPos , chunk ) ; assert ( inputArgPos + chunk == collectNamePos ) ; names [ targetNamePos ] = new Name ( target , ( Object [ ] ) targetArgs ) ; LambdaForm form = new LambdaForm ( STR_ , lambdaType . parameterCount ( ) , names ) ; return SimpleMethodHandle . make ( srcType , form ) ; }
public InSpacePredicate ( Object ... values ) { _inValues = new HashSet < Object > ( ) ; for ( Object value : values ) { _inValues . add ( value ) ; } }
private static void delete ( File f ) { if ( f . isDirectory ( ) ) { for ( File c : f . listFiles ( ) ) { delete ( c ) ; } } if ( ! f . delete ( ) ) { PrintStream err = System . err ; err . println ( STR_ + f ) ; } }
protected List < String > prepareSortKeyStatements ( List < SortKey > sortKeys ) { List < String > keys = new ArrayList < String > ( ) ; for ( int i = NUM_ ; i < sortKeys . size ( ) ; i ++ ) { SortKey sortKey = sortKeys . get ( i ) ; keys . add ( explicitMapping . getDbColumnName ( sortKey . getField ( ) ) + ( sortKey . isAscendingOrder ( ) ? STR_ : STR_ ) ) ; } return keys ; }
public static String experimenterToString ( OFInstructionExperimenter inst , Logger log ) { return Long . toString ( inst . getExperimenter ( ) ) ; }
@ SuppressLint ( STR_ ) public void elementType ( String name , int model , int memberOf , int flags ) { ElementType e = new ElementType ( name , model , memberOf , flags , this ) ; theElementTypes . put ( name . toLowerCase ( ) , e ) ; if ( memberOf == M_ROOT ) theRoot = e ; }
public static void printMagnitudes ( ) { printMagnitudes ( System . out ) ; }
private Optional < CuratorFramework > createClient ( String zookeeperUrl ) { if ( StringUtils . isNotBlank ( zookeeperUrl ) ) { CuratorFramework client = ConfigurationsUtils . getClient ( zookeeperUrl ) ; client . start ( ) ; return Optional . of ( client ) ; } else { return Optional . empty ( ) ; } }
public static String addCvDescription ( String toolTip , String cvDescription , String mask ) { String descString = cvDescription ; String temp = getMaskDescription ( mask ) ; if ( temp . length ( ) > NUM_ ) { descString = descString + STR_ + temp ; } if ( PaneProgFrame . getShowCvNumbers ( ) && ( descString != null ) ) { if ( toolTip == null ) { toolTip = descString ; } else { toolTip = addTextHTMLaware ( toolTip , STR_ + descString + STR_ ) ; } } else if ( toolTip == null ) { toolTip = STR_ ; } return toolTip ; }
public final static int readRawUntil ( final StringBuilder out , final String in , final int start , final char end ) { int pos = start ; while ( pos < in . length ( ) ) { final char ch = in . charAt ( pos ) ; if ( ch == end ) { break ; } out . append ( ch ) ; pos ++ ; } return ( pos == in . length ( ) ) ? - NUM_ : pos ; }
private static void convertToHTML40 ( AttributeSet from , MutableAttributeSet to ) { Enumeration keys = from . getAttributeNames ( ) ; String value = STR_ ; while ( keys . hasMoreElements ( ) ) { Object key = keys . nextElement ( ) ; if ( key instanceof CSS . Attribute ) { value = value + STR_ + key + STR_ + from . getAttribute ( key ) + STR_ ; } else { to . addAttribute ( key , from . getAttribute ( key ) ) ; } } if ( value . length ( ) > NUM_ ) { to . addAttribute ( HTML . Attribute . STYLE , value ) ; } }
public synchronized void close ( ) throws IOException { if ( in == null ) return ; in . close ( ) ; in = null ; buf = null ; }
private static SSLSocketFactory trustAllHosts ( HttpsURLConnection connection ) { SSLSocketFactory oldFactory = connection . getSSLSocketFactory ( ) ; try { SSLContext sc = SSLContext . getInstance ( STR_ ) ; sc . init ( null , trustAllCerts , new java . security . SecureRandom ( ) ) ; SSLSocketFactory newFactory = sc . getSocketFactory ( ) ; connection . setSSLSocketFactory ( newFactory ) ; } catch ( Exception e ) { LOG . e ( LOG_TAG , e . getMessage ( ) , e ) ; } return oldFactory ; }
public void updateAmount ( ) { setAmt ( getTotalAmount ( ) ) ; }
public void testCreationUnique ( ) { Instances data ; ArrayList < Attribute > atts ; String relName ; relName = STR_ ; atts = new ArrayList < Attribute > ( ) ; atts . add ( new Attribute ( STR_ ) ) ; atts . add ( new Attribute ( STR_ ) ) ; atts . add ( new Attribute ( STR_ , STR_ ) ) ; atts . add ( new Attribute ( STR_ , new ArrayList < String > ( Arrays . asList ( new String [ ] { STR_ , STR_ , STR_ } ) ) ) ) ; atts . add ( new Attribute ( STR_ , new ArrayList < String > ( Arrays . asList ( new String [ ] { STR_ , STR_ } ) ) ) ) ; atts . add ( new Attribute ( STR_ , ( ArrayList < String > ) null ) ) ; data = new Instances ( relName , atts , NUM_ ) ; assertEquals ( STR_ , relName , data . relationName ( ) ) ; assertEquals ( STR_ , atts . size ( ) , data . numAttributes ( ) ) ; }
private void updateLegends ( ) { if ( m_span == null ) { m_span = new JPanel ( ) ; } JPanel padder = new JPanel ( ) ; JPanel padd2 = new JPanel ( ) ; m_span . setPreferredSize ( new Dimension ( m_span . getPreferredSize ( ) . width , ( m_plots . size ( ) + NUM_ ) . NUM_ ) ) ; m_span . setMaximumSize ( new Dimension ( m_span . getPreferredSize ( ) . width , ( m_plots . size ( ) + NUM_ ) . NUM_ ) ) ; LegendEntry tmp ; GridBagLayout gb = new GridBagLayout ( ) ; GridBagLayout gb2 = new GridBagLayout ( ) ; GridBagConstraints constraints = new GridBagConstraints ( ) ; m_span . removeAll ( ) ; padder . setLayout ( gb ) ; m_span . setLayout ( gb2 ) ; constraints . anchor = GridBagConstraints . CENTER ; constraints . gridx = NUM_ ; constraints . gridy = NUM_ ; constraints . weightx = NUM_ ; constraints . fill = GridBagConstraints . HORIZONTAL ; constraints . gridwidth = NUM_ ; constraints . gridheight = NUM_ ; constraints . insets = new Insets ( NUM_ , NUM_ , NUM_ , NUM_ ) ; padder . add ( m_span , constraints ) ; constraints . gridx = NUM_ ; constraints . gridy = NUM_ ; constraints . weightx = NUM_ ; constraints . fill = GridBagConstraints . BOTH ; constraints . gridwidth = NUM_ ; constraints . gridheight = NUM_ ; constraints . weighty = NUM_ ; constraints . insets = new Insets ( NUM_ , NUM_ , NUM_ , NUM_ ) ; padder . add ( padd2 , constraints ) ; constraints . weighty = NUM_ ; setViewportView ( padder ) ; constraints . anchor = GridBagConstraints . CENTER ; constraints . gridx = NUM_ ; constraints . gridy = NUM_ ; constraints . weightx = NUM_ ; constraints . fill = GridBagConstraints . HORIZONTAL ; constraints . gridwidth = NUM_ ; constraints . gridheight = NUM_ ; constraints . weighty = NUM_ ; constraints . insets = new Insets ( NUM_ , NUM_ , NUM_ , NUM_ ) ; for ( int i = NUM_ ; i < m_plots . size ( ) ; i ++ ) { tmp = new LegendEntry ( m_plots . get ( i ) , i ) ; constraints . gridy = i ; m_span . add ( tmp , constraints ) ; } }
public String evaluate ( XPathContext xctxt , int context , org . apache . xml . utils . PrefixResolver nsNode ) throws javax . xml . transform . TransformerException { if ( null != m_simpleString ) { return m_simpleString ; } else if ( null != m_parts ) { final FastStringBuffer buf = getBuffer ( ) ; String out = null ; int n = m_parts . size ( ) ; try { for ( int i = NUM_ ; i < n ; i ++ ) { AVTPart part = ( AVTPart ) m_parts . elementAt ( i ) ; part . evaluate ( xctxt , buf , context , nsNode ) ; } out = buf . toString ( ) ; } finally { if ( USE_OBJECT_POOL ) { StringBufferPool . free ( buf ) ; } else { buf . setLength ( NUM_ ) ; } } return out ; } else { return STR_ ; } }
public static byte [ ] readDex ( File file ) throws IOException { return readDex ( file . toPath ( ) ) ; }
public void addUpdateListener ( AnimatorUpdateListener listener ) { if ( mUpdateListeners == null ) { mUpdateListeners = new ArrayList < AnimatorUpdateListener > ( ) ; } mUpdateListeners . add ( listener ) ; }
public void runCommercial ( String stream , int length ) { if ( stream == null || stream . isEmpty ( ) ) { commercialResult ( stream , STR_ , TwitchApi . RequestResult . FAILED ) ; } else { String channel = STR_ + stream ; if ( isChannelOpen ( channel ) ) { g . printLine ( channel , STR_ + length + STR_ ) ; } else { g . printLine ( STR_ + length + STR_ + stream + STR_ ) ; } api . runCommercial ( stream , settings . getString ( STR_ ) , length ) ; } }
public void addSubTree ( int index , List < Node > children ) { List < NodeDescriptor > nodeDescriptors = convertTreeNodesHelper ( children ) ; roots . addChildren ( index , nodeDescriptors ) ; List < Node > nodes = new ArrayList < > ( ) ; for ( NodeDescriptor child : nodeDescriptors ) { nodes . add ( child . getNode ( ) ) ; } if ( ! nodes . isEmpty ( ) ) { fireEvent ( new StoreAddEvent ( index , nodes ) ) ; } }
void generateWhile ( Tree . WhileStatement that ) { Tree . WhileClause whileClause = that . getWhileClause ( ) ; List < VarHolder > vars = specialConditionsAndBlock ( whileClause . getConditionList ( ) , whileClause . getBlock ( ) , STR_ , BOOL_ ) ; for ( VarHolder v : vars ) { v . forget ( ) ; } }
public static double igamma ( double a , double x ) { double coef = ( Math . exp ( - x ) . Math . pow ( x , a ) ) / gamma ( a ) ; double sum = NUM_ ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { sum += ( gamma ( a ) / gamma ( a + NUM_ + ( double ) i ) ) . Math . pow ( x , ( double ) i ) ; } return ( coef . sum ) ; }
public void initializeActiveSlotsList ( String slots ) { if ( activeSlotsList == null ) { activeSlotsList = new ArrayList < String > ( ) ; } for ( String s : slots . split ( STR_ ) ) { activeSlotsList . add ( s ) ; } }
private static String convertActionTypeToIntent ( RamlActionType actionType , boolean isTargetCollection ) { switch ( actionType ) { case DELETE : return STR_ ; case GET : return STR_ ; case POST : if ( isTargetCollection ) { return STR_ ; } case PUT : return STR_ ; case PATCH : return STR_ ; default : return STR_ ; } }
public static String hide ( final String key ) { return isHidden ( key ) ? key : HIDDEN_PREFIX . concat ( key ) ; }
private synchronized IMqttToken removeMqttToken ( Bundle data ) { String activityToken = data . getString ( MqttServiceConstants . CALLBACK_ACTIVITY_TOKEN ) ; if ( activityToken != null ) { int tokenNumber = Integer . parseInt ( activityToken ) ; IMqttToken token = tokenMap . get ( tokenNumber ) ; tokenMap . delete ( tokenNumber ) ; return token ; } return null ; }
public static boolean isExplicitAllType ( String [ ] types ) { return types != null && types . length == NUM_ && ALL . equals ( types [ NUM_ ] ) ; }
private String readUntil ( char [ ] delimiter , boolean returnText ) throws IOException , XmlPullParserException { int start = position ; StringBuilder result = null ; if ( returnText && text != null ) { result = new StringBuilder ( ) ; result . append ( text ) ; } search : while ( BOOL_ ) { if ( position + delimiter . length > limit ) { if ( start < position && returnText ) { if ( result == null ) { result = new StringBuilder ( ) ; } result . append ( buffer , start , position - start ) ; } if ( ! fillBuffer ( delimiter . length ) ) { checkRelaxed ( UNEXPECTED_EOF ) ; type = COMMENT ; return null ; } start = position ; } for ( int i = NUM_ ; i < delimiter . length ; i ++ ) { if ( buffer [ position + i ] != delimiter [ i ] ) { position ++ ; continue search ; } } break ; } int end = position ; position += delimiter . length ; if ( ! returnText ) { return null ; } else if ( result == null ) { return stringPool . get ( buffer , start , end - start ) ; } else { result . append ( buffer , start , end - start ) ; return result . toString ( ) ; } }
public boolean exists ( String key ) { return exists ( key , BOOL_ ) ; }
private Config ( ) { throw new AssertionError ( STR_ ) ; }
public boolean isLeaf ( ) { return children == null || children . isEmpty ( ) ; }
public static void drawShadow ( final Rectangle2D rect , final Graphics2D g2 ) { Graphics2D g2S = ( Graphics2D ) g2 . create ( ) ; Rectangle2D shadow = new Rectangle2D . Double ( rect . getX ( ) + NUM_ , rect . getY ( ) + ProcessDrawer . HEADER_HEIGHT + NUM_ , rect . getWidth ( ) , rect . getHeight ( ) - ProcessDrawer . HEADER_HEIGHT ) ; GeneralPath bottom = new GeneralPath ( ) ; bottom . moveTo ( shadow . getX ( ) , rect . getMaxY ( ) ) ; bottom . lineTo ( rect . getMaxX ( ) , rect . getMaxY ( ) ) ; bottom . lineTo ( shadow . getMaxX ( ) , shadow . getMaxY ( ) ) ; bottom . lineTo ( shadow . getMinX ( ) , shadow . getMaxY ( ) ) ; bottom . closePath ( ) ; g2S . setPaint ( new GradientPaint ( ( float ) rect . getX ( ) , ( float ) rect . getMaxY ( ) , Color . gray , ( float ) rect . getX ( ) , ( float ) shadow . getMaxY ( ) , TRANSPARENT_GRAY ) ) ; g2S . fill ( bottom ) ; GeneralPath right = new GeneralPath ( ) ; right . moveTo ( rect . getMaxX ( ) , shadow . getMinY ( ) ) ; right . lineTo ( shadow . getMaxX ( ) , shadow . getMinY ( ) ) ; right . lineTo ( shadow . getMaxX ( ) , shadow . getMaxY ( ) ) ; right . lineTo ( rect . getMaxX ( ) , rect . getMaxY ( ) ) ; right . closePath ( ) ; g2S . setPaint ( new GradientPaint ( ( float ) rect . getMaxX ( ) , ( float ) shadow . getY ( ) , Color . gray , ( float ) shadow . getMaxX ( ) , ( float ) shadow . getY ( ) , TRANSPARENT_GRAY ) ) ; g2S . fill ( right ) ; g2S . dispose ( ) ; }
@ Override public void addFocusables ( ArrayList < View > views , int direction , int focusableMode ) { final int focusableCount = views . size ( ) ; final int descendantFocusability = getDescendantFocusability ( ) ; if ( descendantFocusability != FOCUS_BLOCK_DESCENDANTS ) { for ( int i = NUM_ ; i < getChildCount ( ) ; i ++ ) { final View child = getChildAt ( i ) ; if ( child . getVisibility ( ) == VISIBLE ) { ItemInfo ii = infoForChild ( child ) ; if ( ii != null && ii . position == mCurItem ) { child . addFocusables ( views , direction , focusableMode ) ; } } } } if ( descendantFocusability != FOCUS_AFTER_DESCENDANTS || ( focusableCount == views . size ( ) ) ) { if ( ! isFocusable ( ) ) { return ; } if ( ( focusableMode & FOCUSABLES_TOUCH_MODE ) == FOCUSABLES_TOUCH_MODE && isInTouchMode ( ) && ! isFocusableInTouchMode ( ) ) { return ; } if ( views != null ) { views . add ( this ) ; } } }
private boolean isValid ( CharSequence text ) { for ( int i = NUM_ ; i < text . length ( ) ; i ++ ) { char c = text . charAt ( i ) ; boolean valid = c == x9 || c == xA || c == xD || ( c >= x20 && c <= xd7ff ) || ( c >= xe000 && c <= xfffd ) ; if ( ! valid ) { return BOOL_ ; } } return BOOL_ ; }
public static void interrupt ( final Thread thread ) { if ( thread != null ) { thread . interrupt ( ) ; } }
private void writeObject ( java . io . ObjectOutputStream s ) throws java . io . IOException { s . defaultWriteObject ( ) ; s . writeInt ( attrs . size ( ) ) ; Enumeration < Attribute > attrEnum = attrs . elements ( ) ; while ( attrEnum . hasMoreElements ( ) ) { s . writeObject ( attrEnum . nextElement ( ) ) ; } }
public static Container east ( Component east ) { return Container . encloseIn ( new BorderLayout ( ) , east , BorderLayout . EAST ) ; }
public static Object [ ] putAll ( ) { Region region = cache . getRegion ( Region . SEPARATOR + REGION_NAME ) ; assertNotNull ( region ) ; try { Map map = new LinkedHashMap ( ) ; map . put ( PUTALL_KEY1 , PUTALL_VALUE1 ) ; map . put ( PUTALL_KEY2 , PUTALL_VALUE2 ) ; map . put ( PUTALL_KEY3 , PUTALL_VALUE3 ) ; map . put ( PUTALL_KEY4 , PUTALL_VALUE4 ) ; map . put ( PUTALL_KEY5 , PUTALL_VALUE5 ) ; region . putAll ( map , STR_ ) ; EventID [ ] evids = new EventID [ NUM_ ] ; evids [ NUM_ ] = putAlleventId1 ; evids [ NUM_ ] = putAlleventId2 ; evids [ NUM_ ] = putAlleventId3 ; evids [ NUM_ ] = putAlleventId4 ; evids [ NUM_ ] = putAlleventId5 ; assertNotNull ( evids [ NUM_ ] ) ; assertNotNull ( evids [ NUM_ ] ) ; assertNotNull ( evids [ NUM_ ] ) ; assertNotNull ( evids [ NUM_ ] ) ; assertNotNull ( evids [ NUM_ ] ) ; return evids ; } catch ( Exception e ) { fail ( STR_ + e ) ; } return null ; }
public void loadLayout ( File oFile , boolean newTab ) { loadLayout ( oFile , newTab , BOOL_ ) ; }
public void track ( File file , Object marker , FileDeleteStrategy deleteStrategy ) { if ( file == null ) { throw new NullPointerException ( STR_ ) ; } addTracker ( file . getPath ( ) , marker , deleteStrategy ) ; }
public static String separatorsToUnix ( String path ) { if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == - NUM_ ) { return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; }
public boolean hasParameter ( String name ) { return _parameters . hasParameter ( name ) ; }
@ Override public long freeMemory ( long windowId ) throws IOException { long size = keyStream . dataSizeUpToWindow ( windowId ) + valueStream . dataSizeUpToWindow ( windowId ) ; windowsForFreeMemory . add ( windowId ) ; return size ; }
public static boolean isSQL99NonReservedKeyword ( String identifier ) { if ( identifier == null ) { throw new NullPointerException ( STR_ ) ; } return Arrays . binarySearch ( SQL99_NON_RESERVED , identifier . toUpperCase ( ) ) >= NUM_ ; }
@ SuppressWarnings ( STR_ ) public static < T > void sort ( List < T > list , Comparator < ? super T > comparator ) { T [ ] array = list . toArray ( ( T [ ] ) new Object [ list . size ( ) ] ) ; Arrays . sort ( array , comparator ) ; int i = NUM_ ; ListIterator < T > it = list . listIterator ( ) ; while ( it . hasNext ( ) ) { it . next ( ) ; it . set ( array [ i ++ ] ) ; } }
@ Override public long handleCommit ( final long commitTime ) { if ( error != null ) throw new IndexInconsistentError ( error ) ; final IRootBlockView view = journal . getRootBlockView ( ) ; final ByteBuffer rbv = view . asReadOnlyBuffer ( ) ; final ByteBuffer bb = ByteBuffer . allocate ( rbv . capacity ( ) ) ; for ( int i = NUM_ ; i < rbv . capacity ( ) ; i ++ ) { bb . put ( rbv . get ( ) ) ; } bb . flip ( ) ; return journal . write ( bb ) ; }
public boolean isAppendTaskName ( ) { return appendTaskName ; }
public static final String toString ( String str ) { if ( str == null ) return STR_ ; ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; toByteArray ( buffer , str ) ; return buffer . toString ( ) ; }
public static Cache . Entry makeRandomCacheEntry ( byte [ ] data , boolean isExpired , boolean needsRefresh ) { Random random = new Random ( ) ; Cache . Entry entry = new Cache . Entry ( ) ; if ( data != null ) { entry . data = data ; } else { entry . data = new byte [ random . nextInt ( NUM_ ) ] ; } entry . etag = String . valueOf ( random . nextLong ( ) ) ; entry . lastModified = random . nextLong ( ) ; entry . ttl = isExpired ? NUM_ : Long . MAX_VALUE ; entry . softTtl = needsRefresh ? NUM_ : Long . MAX_VALUE ; return entry ; }
public static double max ( double [ ] data ) { double max = Double . NaN ; for ( int i = NUM_ ; i < data . length ; i ++ ) { if ( Double . isNaN ( data [ i ] ) ) continue ; if ( Double . isNaN ( max ) || data [ i ] > max ) max = data [ i ] ; } return max ; }
private static boolean isStartElement ( String line ) { int first = line . lastIndexOf ( STR_ ) ; int last = line . lastIndexOf ( STR_ ) ; if ( last < first ) { return BOOL_ ; } else { int firstEnd = line . lastIndexOf ( STR_ ) ; int lastEnd = line . lastIndexOf ( STR_ ) ; if ( ( firstEnd != first ) && ( ( lastEnd + NUM_ ) != last ) ) { return BOOL_ ; } } return BOOL_ ; }
long readLong ( ) throws IOException { return ( ( ( long ) _is . read ( ) << NUM_ ) | ( ( long ) _is . read ( ) << NUM_ ) | ( ( long ) _is . read ( ) << NUM_ ) | ( ( long ) _is . read ( ) << NUM_ ) | ( ( long ) _is . read ( ) << NUM_ ) | ( ( long ) _is . read ( ) << NUM_ ) | ( ( long ) _is . read ( ) << NUM_ ) | ( ( long ) _is . read ( ) ) ) ; }
@ Override public Instance remove ( int index ) { return m_Instances . remove ( index ) ; }
protected static String extractAccessKey ( String s3uri ) { return s3uri . substring ( s3uri . indexOf ( STR_ ) + NUM_ , s3uri . indexOf ( STR_ , s3uri . indexOf ( STR_ ) + NUM_ ) ) ; }
public boolean doTransaction ( DB db , Object threadstate ) throws WorkloadException { boolean ret = BOOL_ ; long st = System . nanoTime ( ) ; String op = operationchooser . nextString ( ) ; if ( op . compareTo ( STR_ ) == NUM_ ) { ret = doTransactionRead ( db ) ; } else if ( op . compareTo ( STR_ ) == NUM_ ) { ret = doTransactionUpdate ( db ) ; } else if ( op . compareTo ( STR_ ) == NUM_ ) { ret = doTransactionInsert ( db ) ; } else if ( op . compareTo ( STR_ ) == NUM_ ) { ret = doTransactionScan ( db ) ; } else { ret = doTransactionReadModifyWrite ( db ) ; } long en = System . nanoTime ( ) ; _measurements . measure ( _operations . get ( op ) , ( int ) ( ( en - st ) / NUM_ ) ) ; if ( ret ) _measurements . reportReturnCode ( _operations . get ( op ) , - NUM_ ) ; else { _measurements . reportReturnCode ( _operations . get ( op ) , NUM_ ) ; } actualopcount . addAndGet ( NUM_ ) ; return ret ; }
public ToStringHelper addValue ( boolean value ) { return addHolder ( String . valueOf ( value ) ) ; }
public static void copyExcept ( Object src , Object dst , int oldSize , int removeIndex ) { if ( removeIndex > NUM_ && oldSize > NUM_ ) { System . arraycopy ( src , NUM_ , dst , NUM_ , removeIndex ) ; } if ( removeIndex < oldSize ) { System . arraycopy ( src , removeIndex + NUM_ , dst , removeIndex , oldSize - removeIndex - NUM_ ) ; } }
public SiteMonitor ( String [ ] urlList ) { siteUrlList = urlList ; }
private Set unionIPRange ( byte [ ] ipWithSubmask1 , byte [ ] ipWithSubmask2 ) { Set set = new HashSet ( ) ; if ( Arrays . areEqual ( ipWithSubmask1 , ipWithSubmask2 ) ) { set . add ( ipWithSubmask1 ) ; } else { set . add ( ipWithSubmask1 ) ; set . add ( ipWithSubmask2 ) ; } return set ; }
public Optional < BlazeVertex > vertex ( final String vertexId ) { try ( final CloseableIterator < Vertex > it = vertices ( vertexId ) ) { final Optional < BlazeVertex > v = it . hasNext ( ) ? Optional . of ( ( BlazeVertex ) it . next ( ) ) : Optional . empty ( ) ; if ( it . hasNext ( ) ) { throw new IllegalStateException ( STR_ + vertexId ) ; } return v ; } }
public static long addAndGet ( AtomicLong current , long toAdd ) { long u , r ; do { r = current . get ( ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } u = addCap ( r , toAdd ) ; } while ( ! current . compareAndSet ( r , u ) ) ; return u ; }
private void start ( HttpServletRequest request , HttpServletResponse response ) throws IOException { String label = request . getParameter ( STR_ ) ; String detail = request . getParameter ( STR_ ) ; MonKey key = getMonKey ( label , detail , DEFAULT_UNITS ) ; startMon ( key ) ; PrintWriter out = response . getWriter ( ) ; out . println ( OK + STR_ + label ) ; }
public double norm ( ) { double sum = NUM_ ; for ( int i = NUM_ ; i < components . length ; i ++ ) sum += components [ i ] . components [ i ] ; return Math . sqrt ( sum ) ; }
public static double P_Harmonic ( int Y [ ] [ ] , int Ypred [ ] [ ] ) { int allMissings = NUM_ ; int N = Y . length ; double loss = NUM_ ; for ( int i = NUM_ ; i < N ; i ++ ) { if ( allMissing ( Y [ i ] ) ) { allMissings ++ ; continue ; } double curLoss = P_Harmonic ( Y [ i ] , Ypred [ i ] ) ; if ( Double . isNaN ( curLoss ) ) { allMissings ++ ; continue ; } loss += curLoss ; } return loss / ( double ) ( N - allMissings ) ; }
public void writeEntry ( CCacheOutputStream cos ) throws IOException { cos . write16 ( adType ) ; cos . write32 ( adData . length ) ; cos . write ( adData , NUM_ , adData . length ) ; }
public CloseableAnimatedBitmap ( List < Bitmap > bitmaps , List < Integer > durations , ResourceReleaser < Bitmap > resourceReleaser ) { Preconditions . checkNotNull ( bitmaps ) ; Preconditions . checkState ( bitmaps . size ( ) >= NUM_ , STR_ ) ; mBitmaps = new ArrayList < > ( ) ; mBitmapReferences = new ArrayList < > ( ) ; for ( Bitmap bitmap : bitmaps ) { mBitmapReferences . add ( CloseableReference . of ( bitmap , resourceReleaser ) ) ; mBitmaps . add ( bitmap ) ; } mDurations = Preconditions . checkNotNull ( durations ) ; Preconditions . checkState ( mDurations . size ( ) == mBitmaps . size ( ) , STR_ ) ; }
public static String readLabelFile ( String entrySeparator , boolean ensureInitialBoundary , String trfname ) throws IOException { BufferedReader lab = new BufferedReader ( new FileReader ( trfname ) ) ; try { XwavesLabelfileReader xlds = new XwavesLabelfileReader ( trfname ) ; String result = StringUtils . join ( entrySeparator , xlds . getLabelSymbols ( ) ) ; if ( ensureInitialBoundary && result . charAt ( NUM_ ) != STR_ ) { result = STR_ + entrySeparator + result ; } return result ; } finally { lab . close ( ) ; } }
ConverterSet add ( Converter converter , Converter [ ] removed ) { Converter [ ] converters = iConverters ; int length = converters . length ; for ( int i = NUM_ ; i < length ; i ++ ) { Converter existing = converters [ i ] ; if ( converter . equals ( existing ) ) { if ( removed != null ) { removed [ NUM_ ] = null ; } return this ; } if ( converter . getSupportedType ( ) == existing . getSupportedType ( ) ) { Converter [ ] copy = new Converter [ length ] ; for ( int j = NUM_ ; j < length ; j ++ ) { if ( j != i ) { copy [ j ] = converters [ j ] ; } else { copy [ j ] = converter ; } } if ( removed != null ) { removed [ NUM_ ] = existing ; } return new ConverterSet ( copy ) ; } } Converter [ ] copy = new Converter [ length + NUM_ ] ; System . arraycopy ( converters , NUM_ , copy , NUM_ , length ) ; copy [ length ] = converter ; if ( removed != null ) { removed [ NUM_ ] = null ; } return new ConverterSet ( copy ) ; }
private void parse ( ) throws SAXException { XStream xstream = ( XStream ) properties . get ( CONFIGURED_XSTREAM_PROPERTY ) ; if ( xstream == null ) { xstream = new XStream ( ) ; } final List < ? > source = ( List < ? > ) properties . get ( SOURCE_OBJECT_LIST_PROPERTY ) ; if ( source == null || source . isEmpty ( ) ) { throw new SAXException ( STR_ + SOURCE_OBJECT_LIST_PROPERTY + STR_ ) ; } try { startDocument ( BOOL_ ) ; for ( final Object name : source ) { xstream . marshal ( name , this ) ; } endDocument ( BOOL_ ) ; } catch ( final StreamException e ) { if ( e . getCause ( ) instanceof SAXException ) { throw ( SAXException ) e . getCause ( ) ; } else { throw new SAXException ( e ) ; } } }
private SortedMap < MessageUid , MaildirMessageName > truncateMap ( Map < MessageUid , MaildirMessageName > map , MessageUid from , MessageUid to ) { TreeMap < MessageUid , MaildirMessageName > sortedMap ; if ( map instanceof TreeMap < ? , ? > ) sortedMap = ( TreeMap < MessageUid , MaildirMessageName > ) map ; else sortedMap = new TreeMap < MessageUid , MaildirMessageName > ( map ) ; if ( to != null ) return sortedMap . subMap ( from , to . next ( ) ) ; return sortedMap . tailMap ( from ) ; }
public void dumpIndex ( boolean showBounds ) throws IOException { byte ixRecord [ ] = new byte [ SPATIAL_INDEX_RECORD_LENGTH ] ; int recNum = NUM_ ; if ( shpFileName == null ) { return ; } BinaryBufferedFile ssx = new BinaryBufferedFile ( ssx ( shpFileName ) ) ; ssx . seek ( NUM_ ) ; while ( BOOL_ ) { int result = ssx . read ( ixRecord , NUM_ , SPATIAL_INDEX_RECORD_LENGTH ) ; if ( result <= NUM_ ) { logger . info ( STR_ + recNum + STR_ ) ; break ; } else { recNum ++ ; int offset = readBEInt ( ixRecord , NUM_ ) ; int length = readBEInt ( ixRecord , NUM_ ) ; logger . info ( STR_ + recNum + STR_ + offset + STR_ + length + ( showBounds ? ( STR_ + readLEDouble ( ixRecord , NUM_ ) + STR_ + readLEDouble ( ixRecord , NUM_ ) + STR_ + readLEDouble ( ixRecord , NUM_ ) + STR_ + readLEDouble ( ixRecord , NUM_ ) ) : STR_ ) ) ; } } ssx . close ( ) ; }
private static boolean compareParam ( String jdiffParam , Type reflectionParamType ) { if ( jdiffParam == null ) { return BOOL_ ; } String reflectionParam = typeToString ( reflectionParamType ) ; if ( jdiffParam . equals ( reflectionParam ) ) { return BOOL_ ; } int jdiffParamEndOffset = jdiffParam . indexOf ( STR_ ) ; int reflectionParamEndOffset = reflectionParam . indexOf ( STR_ ) ; if ( jdiffParamEndOffset != - NUM_ && reflectionParamEndOffset != - NUM_ ) { jdiffParam = jdiffParam . substring ( NUM_ , jdiffParamEndOffset ) ; reflectionParam = reflectionParam . substring ( NUM_ , reflectionParamEndOffset ) ; return jdiffParam . equals ( reflectionParam ) ; } return BOOL_ ; }
public static void randomNumber ( int [ ] num , int n ) { for ( int j = NUM_ ; j < n ; j ++ ) { num [ j ] = ( int ) ( Math . random ( ) . NUM_ ) ; } }
private static String escapeJSON ( String text ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( STR_ ) ; for ( int index = NUM_ ; index < text . length ( ) ; index ++ ) { char chr = text . charAt ( index ) ; switch ( chr ) { case STR_ : case STR_ : builder . append ( STR_ ) ; builder . append ( chr ) ; break ; case STR_ : builder . append ( STR_ ) ; break ; case STR_ : builder . append ( STR_ ) ; break ; case STR_ : builder . append ( STR_ ) ; break ; case STR_ : builder . append ( STR_ ) ; break ; default : if ( chr < STR_ ) { String t = STR_ + Integer . toHexString ( chr ) ; builder . append ( STR_ + t . substring ( t . length ( ) - NUM_ ) ) ; } else { builder . append ( chr ) ; } break ; } } builder . append ( STR_ ) ; return builder . toString ( ) ; }
public void writeTo ( OutputStream out ) throws IOException { ByteString [ ] cachedFlushBuffers ; byte [ ] cachedBuffer ; int cachedBufferPos ; synchronized ( this ) { cachedFlushBuffers = flushedBuffers . toArray ( new ByteString [ flushedBuffers . size ( ) ] ) ; cachedBuffer = buffer ; cachedBufferPos = bufferPos ; } for ( ByteString byteString : cachedFlushBuffers ) { byteString . writeTo ( out ) ; } out . write ( copyArray ( cachedBuffer , cachedBufferPos ) ) ; }
private void checkHeadingsHierarchy ( Elements elements , TestSolutionHandler testSolutionHandler ) { if ( elements . isEmpty ( ) ) { testSolutionHandler . addTestSolution ( TestSolution . NOT_APPLICABLE ) ; return ; } TestSolution checkResult = TestSolution . PASSED ; Iterator < Element > iter = elements . iterator ( ) ; Element element = iter . next ( ) ; int indexOfReference = getHeaderIndex ( element ) ; int currentIndex ; int previousIndex = indexOfReference ; Element elementOfReference = element ; Element previousElement = element ; while ( iter . hasNext ( ) ) { element = iter . next ( ) ; currentIndex = getHeaderIndex ( element ) ; if ( currentIndex != - NUM_ ) { if ( currentIndex - previousIndex >= NUM_ ) { checkResult = TestSolution . FAILED ; addSourceCodeRemark ( TestSolution . FAILED , element , HEADER_NOT_HIERARCHICALLY_WELL_DEFINED_MSG , getEvidenceElement ( PREVIOUS_H_TAG_INDEX_EE , getEvidenceElementMsg ( previousIndex , previousElement ) ) ) ; } else if ( currentIndex < indexOfReference ) { checkResult = TestSolution . FAILED ; addSourceCodeRemark ( TestSolution . FAILED , element , HEADER_NOT_HIERARCHICALLY_WELL_DEFINED_MSG , getEvidenceElement ( FIRST_H_TAG_INDEX_EE , getEvidenceElementMsg ( indexOfReference , elementOfReference ) ) ) ; } previousIndex = currentIndex ; previousElement = element ; } } testSolutionHandler . addTestSolution ( checkResult ) ; }
public Iterator < JsonElement > iterator ( ) { return elements . iterator ( ) ; }
public void mouseWheelMoved ( MouseWheelEvent e ) { boolean accepted = checkModifiers ( e ) ; if ( accepted == BOOL_ ) { VisualizationViewer < ? , ? > vv = ( VisualizationViewer < ? , ? > ) e . getSource ( ) ; Point2D mouse = e . getPoint ( ) ; Point2D center = vv . getCenter ( ) ; int amount = e . getWheelRotation ( ) ; if ( zoomAtMouse ) { if ( amount > NUM_ ) { scaler . scale ( vv , in , mouse ) ; } else if ( amount < NUM_ ) { scaler . scale ( vv , out , mouse ) ; } } else { if ( amount > NUM_ ) { scaler . scale ( vv , in , center ) ; } else if ( amount < NUM_ ) { scaler . scale ( vv , out , center ) ; } } e . consume ( ) ; vv . repaint ( ) ; } }
public File createNewFolder ( File containingDir ) throws IOException { if ( containingDir == null ) { throw new IOException ( STR_ ) ; } File newFolder = createFileObject ( containingDir , newFolderString ) ; int i = NUM_ ; while ( newFolder . exists ( ) && i < NUM_ ) { newFolder = createFileObject ( containingDir , MessageFormat . format ( newFolderNextString , new Integer ( i ) ) ) ; i ++ ; } if ( newFolder . exists ( ) ) { throw new IOException ( STR_ + newFolder . getAbsolutePath ( ) ) ; } else { newFolder . mkdirs ( ) ; } return newFolder ; }
protected void assertFuncEquals ( final String ... inputs ) throws Exception { SolrQueryRequest req = req ( ) ; try { assertFuncEquals ( req , inputs ) ; } finally { req . close ( ) ; } }
private void handleStartElement ( XMLStreamReader parser , Set < Node > childrenFound , Handler handler , Map < String , Object > values , Stack < Set < String > > stack , boolean recordStarted ) throws IOException , XMLStreamException { Node n = getMatchingNode ( parser , childNodes ) ; Map < String , Object > decends = new HashMap < > ( ) ; if ( n != null ) { childrenFound . add ( n ) ; n . parse ( parser , handler , values , stack , recordStarted ) ; return ; } Node dn = this ; do { if ( dn . wildCardNodes != null ) { n = getMatchingNode ( parser , dn . wildCardNodes ) ; if ( n != null ) { childrenFound . add ( n ) ; n . parse ( parser , handler , values , stack , recordStarted ) ; break ; } for ( Node nn : dn . wildCardNodes ) decends . put ( nn . name , nn ) ; } dn = dn . wildAncestor ; } while ( dn != null ) ; if ( n == null ) { int count = NUM_ ; while ( count != NUM_ ) { int token = parser . next ( ) ; if ( token == START_ELEMENT ) { Node nn = ( Node ) decends . get ( parser . getLocalName ( ) ) ; if ( nn != null ) { childrenFound . add ( nn ) ; nn . parse ( parser , handler , values , stack , recordStarted ) ; } else count ++ ; } else if ( token == END_ELEMENT ) count -- ; } } }
public boolean equivalent ( IMFMarkerType other ) { if ( other == null ) { return BOOL_ ; } boolean result = BOOL_ ; result &= offset . equals ( other . getOffset ( ) ) ; result &= label . equivalent ( other . getLabel ( ) ) ; return result ; }
public static Discretization discretize ( double [ ] _data , double [ ] cutoffs , String variableName , List < String > categories ) { if ( cutoffs == null ) { throw new NullPointerException ( ) ; } for ( int i = NUM_ ; i < cutoffs . length - NUM_ ; i ++ ) { if ( ! ( cutoffs [ i ] <= cutoffs [ i + NUM_ ] ) ) { throw new NullPointerException ( STR_ ) ; } } if ( variableName == null ) { throw new NullPointerException ( ) ; } int numCategories = cutoffs . length + NUM_ ; if ( categories != null && categories . size ( ) != numCategories ) { throw new IllegalArgumentException ( STR_ + STR_ + STR_ ) ; } DiscreteVariable variable ; if ( categories == null ) { variable = new DiscreteVariable ( variableName , numCategories ) ; } else { variable = new DiscreteVariable ( variableName , categories ) ; } int [ ] discreteData = new int [ _data . length ] ; loop : for ( int i = NUM_ ; i < _data . length ; i ++ ) { if ( Double . isNaN ( _data [ i ] ) ) { discreteData [ i ] = DiscreteVariable . MISSING_VALUE ; continue ; } for ( int j = NUM_ ; j < cutoffs . length ; j ++ ) { if ( _data [ i ] > Double . NEGATIVE_INFINITY && _data [ i ] < Double . POSITIVE_INFINITY && _data [ i ] < cutoffs [ j ] ) { discreteData [ i ] = j ; continue loop ; } } discreteData [ i ] = cutoffs . length ; } return new Discretization ( variable , discreteData ) ; }
public static ArrayList < Long > loadWorkspaceScreensDb ( Context context ) { final ContentResolver contentResolver = context . getContentResolver ( ) ; final Uri screensUri = LauncherSettings . WorkspaceScreens . CONTENT_URI ; final Cursor sc = contentResolver . query ( screensUri , null , null , null , LauncherSettings . WorkspaceScreens . SCREEN_RANK ) ; ArrayList < Long > screenIds = new ArrayList < Long > ( ) ; try { final int idIndex = sc . getColumnIndexOrThrow ( LauncherSettings . WorkspaceScreens . _ID ) ; while ( sc . moveToNext ( ) ) { try { screenIds . add ( sc . getLong ( idIndex ) ) ; } catch ( Exception e ) { Launcher . addDumpLog ( TAG , STR_ + STR_ + e , BOOL_ ) ; } } } finally { if ( sc != null ) { sc . close ( ) ; } } return screenIds ; }
private boolean renderOutput ( Node node , InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ResourceNotFoundException { String arg = STR_ ; if ( node == null ) { rsvc . error ( STR_ ) ; return BOOL_ ; } Object value = node . value ( context ) ; if ( value == null ) { rsvc . error ( STR_ ) ; return BOOL_ ; } arg = value . toString ( ) ; Resource resource = null ; try { resource = rsvc . getContent ( arg , getInputEncoding ( context ) ) ; } catch ( ResourceNotFoundException rnfe ) { rsvc . error ( STR_ + arg + STR_ + context . getCurrentTemplateName ( ) + STR_ + getLine ( ) + STR_ + getColumn ( ) + STR_ ) ; throw rnfe ; } catch ( Exception e ) { rsvc . error ( STR_ + arg + STR_ + context . getCurrentTemplateName ( ) + STR_ + getLine ( ) + STR_ + getColumn ( ) + STR_ + e ) ; } if ( resource == null ) return BOOL_ ; writer . write ( ( String ) resource . getData ( ) ) ; return BOOL_ ; }
protected String e ( String s ) throws Exception { return fmt . format ( parser . parse ( s , null ) ) ; }
public static boolean equals ( boolean [ ] field1 , boolean [ ] field2 ) { if ( field1 == null || field1 . length == NUM_ ) { return field2 == null || field2 . length == NUM_ ; } else { return Arrays . equals ( field1 , field2 ) ; } }
public void changeState ( ) { linked = ! linked ; link = linked ? linkedImIc . getImage ( ) : unlinkedImIc . getImage ( ) ; repaint ( ) ; }
public static Geometry bufferBySegments ( Geometry g , double distance ) { Geometry segs = LineHandlingFunctions . extractSegments ( g ) ; double posDist = Math . abs ( distance ) ; Geometry segBuf = bufferByComponents ( segs , posDist ) ; if ( distance < NUM_ ) return g . difference ( segBuf ) ; return g . union ( segBuf ) ; }
public void recordEndTime ( ) { int msDiff = ( int ) ( System . currentTimeMillis ( ) - _currentRequestStartTime . get ( ) ) ; _log . info ( STR_ , msDiff ) ; updateOrResetReqRspAvgLstHr ( updateOrResetReqRspAvgLstMin ( msDiff , BOOL_ ) , BOOL_ ) ; updateMinMaxReqRspMs ( msDiff ) ; if ( msDiff >= SUSPISCIOUS_RSP_TIME_MS ) { _alertLog . warn ( MessageFormat . format ( STR_ , msDiff ) ) ; } _currentRequestStartTime . remove ( ) ; }
private boolean isAccessibleUserToKibana ( Set < String > filters ) { if ( filters . contains ( STR_ ) ) { return BOOL_ ; } return BOOL_ ; }
public boolean clear ( ) { try { list . clear ( ) ; fireTableDataChanged ( ) ; } catch ( Exception e ) { return BOOL_ ; } return BOOL_ ; }
public static final int typeIndex ( Class type ) { Class [ ] list = primitiveTypes ; int n = list . length ; for ( int i = NUM_ ; i < n ; i ++ ) if ( list [ i ] == type ) return i ; throw new RuntimeException ( STR_ + type . getName ( ) ) ; }
public boolean load ( File fi ) throws JmriConfigureXmlException { return load ( fi , BOOL_ ) ; }
public String parameterToString ( Object param ) { if ( param == null ) { return STR_ ; } else if ( param instanceof Date ) { return formatDate ( ( Date ) param ) ; } else if ( param instanceof Collection ) { StringBuilder b = new StringBuilder ( ) ; for ( Object o : ( Collection ) param ) { if ( b . length ( ) > NUM_ ) { b . append ( STR_ ) ; } b . append ( String . valueOf ( o ) ) ; } return b . toString ( ) ; } else { return String . valueOf ( param ) ; } }
public void testBug66947 ( ) throws Exception { Connection con = null ; try { Properties props = new Properties ( ) ; props . setProperty ( STR_ , STR_ ) ; props . setProperty ( STR_ , STR_ ) ; props . setProperty ( STR_ , STR_ ) ; con = getConnectionWithProps ( props ) ; PreparedStatement ps1_1 ; PreparedStatement ps1_2 ; String query = STR_ ; ps1_1 = con . prepareStatement ( query ) ; ps1_1 . execute ( ) ; ps1_1 . close ( ) ; ps1_2 = con . prepareStatement ( query ) ; assertSame ( STR_ , ps1_1 , ps1_2 ) ; ps1_2 . execute ( ) ; ps1_2 . close ( ) ; ps1_2 . close ( ) ; ps1_1 = con . prepareStatement ( query ) ; assertNotSame ( STR_ , ps1_2 , ps1_1 ) ; ps1_1 . execute ( ) ; ps1_1 . close ( ) ; ps1_1 . close ( ) ; PreparedStatement ps2_1 ; PreparedStatement ps2_2 ; PreparedStatement ps3_1 ; PreparedStatement ps3_2 ; ps1_1 = con . prepareStatement ( STR_ ) ; ps1_1 . execute ( ) ; ps1_1 . close ( ) ; ps2_1 = con . prepareStatement ( STR_ ) ; ps2_1 . execute ( ) ; ps2_1 . close ( ) ; ps3_1 = con . prepareStatement ( STR_ ) ; ps3_1 . execute ( ) ; ps3_1 . close ( ) ; ps1_2 = con . prepareStatement ( STR_ ) ; assertNotSame ( STR_ , ps1_1 , ps1_2 ) ; ps2_2 = con . prepareStatement ( STR_ ) ; assertSame ( STR_ , ps2_1 , ps2_2 ) ; ps3_2 = con . prepareStatement ( STR_ ) ; assertSame ( STR_ , ps3_1 , ps3_2 ) ; } finally { if ( con != null ) { con . close ( ) ; } } }
public synchronized void flush ( ) throws IOException { checkNotClosed ( ) ; trimToSize ( ) ; trimToFileCount ( ) ; journalWriter . flush ( ) ; }
private final String [ ] _expandSeenNames ( String [ ] oldShared ) { int len = oldShared . length ; String [ ] newShared ; if ( len == NUM_ ) { newShared = _smileBufferRecycler . allocSeenNamesBuffer ( ) ; if ( newShared == null ) { newShared = new String [ SmileBufferRecycler . DEFAULT_NAME_BUFFER_LENGTH ] ; } } else if ( len == SmileConstants . MAX_SHARED_NAMES ) { newShared = oldShared ; _seenNameCount = NUM_ ; } else { int newSize = ( len == SmileBufferRecycler . DEFAULT_STRING_VALUE_BUFFER_LENGTH ) ? NUM_ : SmileConstants . MAX_SHARED_NAMES ; newShared = new String [ newSize ] ; System . arraycopy ( oldShared , NUM_ , newShared , NUM_ , oldShared . length ) ; } return newShared ; }
public void addRequestProperty ( String key , String value ) { if ( connected ) throw new IllegalStateException ( STR_ ) ; if ( key == null ) throw new NullPointerException ( STR_ ) ; if ( requests == null ) requests = new MessageHeader ( ) ; requests . add ( key , value ) ; }
ServerMember update ( Address clientAddress , Instant time ) { if ( clientAddress != null ) { this . clientAddress = clientAddress ; if ( time . isAfter ( updated ) ) { this . updated = Assert . notNull ( time , STR_ ) ; } } return this ; }
public static boolean isOrgLevelOnly ( int AD_Client_ID , int AD_Table_ID ) { Boolean share = isShared ( AD_Client_ID , AD_Table_ID ) ; if ( share != null ) return ! share . booleanValue ( ) ; return BOOL_ ; }
public Runnable decrementAsRunnable ( ) { return mDecrementRunnable ; }
@ Override public void actionPerformed ( ActionEvent event ) { String command = event . getActionCommand ( ) ; if ( command . equals ( STR_ ) ) { attemptModifyBackgroundPaint ( ) ; } }
public byte [ ] serializeToBuffer ( Object o ) throws IOException { ByteArrayOutputStream bufOut = new ByteArrayOutputStream ( ) ; try { serialize ( bufOut , o ) ; bufOut . flush ( ) ; return bufOut . toByteArray ( ) ; } finally { bufOut . close ( ) ; } }
ModulePointer resolve ( String modName ) { return ( ModulePointer ) context . get ( modName ) ; }
public void startElement ( String namespaceURI , String localName , String name , Attributes atts ) throws org . xml . sax . SAXException { ElemContext elemContext = m_elemContext ; if ( elemContext . m_startTagOpen ) { closeStartTag ( ) ; elemContext . m_startTagOpen = BOOL_ ; } else if ( m_cdataTagOpen ) { closeCDATA ( ) ; m_cdataTagOpen = BOOL_ ; } else if ( m_needToCallStartDocument ) { startDocumentInternal ( ) ; m_needToCallStartDocument = BOOL_ ; } if ( m_needToOutputDocTypeDecl ) { String n = name ; if ( n == null || n . length ( ) == NUM_ ) { n = localName ; } outputDocTypeDecl ( n ) ; } if ( null != namespaceURI && namespaceURI . length ( ) > NUM_ ) { super . startElement ( namespaceURI , localName , name , atts ) ; return ; } try { ElemDesc elemDesc = getElemDesc2 ( name ) ; int elemFlags = elemDesc . getFlags ( ) ; if ( m_doIndent ) { boolean isBlockElement = ( elemFlags & ElemDesc . BLOCK ) != NUM_ ; if ( m_ispreserve ) m_ispreserve = BOOL_ ; else if ( ( null != elemContext . m_elementName ) && ( ! m_inBlockElem || isBlockElement ) ) { m_startNewLine = BOOL_ ; indent ( ) ; } m_inBlockElem = ! isBlockElement ; } if ( atts != null ) addAttributes ( atts ) ; m_isprevtext = BOOL_ ; final java . io . Writer writer = m_writer ; writer . write ( STR_ ) ; writer . write ( name ) ; if ( m_tracer != null ) firePseudoAttributes ( ) ; if ( ( elemFlags & ElemDesc . EMPTY ) != NUM_ ) { m_elemContext = elemContext . push ( ) ; m_elemContext . m_elementName = name ; m_elemContext . m_elementDesc = elemDesc ; return ; } else { elemContext = elemContext . push ( namespaceURI , localName , name ) ; m_elemContext = elemContext ; elemContext . m_elementDesc = elemDesc ; elemContext . m_isRaw = ( elemFlags & ElemDesc . RAW ) != NUM_ ; } if ( ( elemFlags & ElemDesc . HEADELEM ) != NUM_ ) { closeStartTag ( ) ; elemContext . m_startTagOpen = BOOL_ ; if ( ! m_omitMetaTag ) { if ( m_doIndent ) indent ( ) ; writer . write ( STR_ ) ; String encoding = getEncoding ( ) ; String encode = Encodings . getMimeEncoding ( encoding ) ; writer . write ( encode ) ; writer . write ( STR_ ) ; } } } catch ( IOException e ) { throw new SAXException ( e ) ; } }
public void addCertStore ( CertStore store ) { if ( store == null ) { return ; } if ( certStores == null ) { certStores = new ArrayList < CertStore > ( ) ; } certStores . add ( store ) ; }
public NarClassLoader ( final File narWorkingDirectory ) throws ClassNotFoundException , IOException { super ( new URL [ NUM_ ] ) ; this . narWorkingDirectory = narWorkingDirectory ; updateClasspath ( narWorkingDirectory ) ; }
public Block block ( ) { return block ; }
public static TypeBinding [ ] substitute ( Substitution substitution , TypeBinding [ ] originalTypes ) { if ( originalTypes == null ) return null ; TypeBinding [ ] substitutedTypes = originalTypes ; for ( int i = NUM_ , length = originalTypes . length ; i < length ; i ++ ) { TypeBinding originalType = originalTypes [ i ] ; TypeBinding substitutedParameter = substitute ( substitution , originalType ) ; if ( substitutedParameter != originalType ) { if ( substitutedTypes == originalTypes ) { System . arraycopy ( originalTypes , NUM_ , substitutedTypes = new TypeBinding [ length ] , NUM_ , i ) ; } substitutedTypes [ i ] = substitutedParameter ; } else if ( substitutedTypes != originalTypes ) { substitutedTypes [ i ] = originalType ; } } return substitutedTypes ; }
private boolean checkIfScrolling ( float [ ] lastPoints , MotionEvent ev ) { float [ ] point = new float [ NUM_ ] ; point [ NUM_ ] = ev . getRawX ( ) ; point [ NUM_ ] = ev . getRawY ( ) ; float delta = getDistance ( lastPoints , point ) ; return Math . abs ( delta ) > mSlop ; }
public void testMergeOneFilterIntoDocumentWithSameFilter ( ) throws Exception { String srcXml = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; WebXml srcWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( srcXml . getBytes ( STR_ ) ) , null ) ; WebXml mergeWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( srcXml . getBytes ( STR_ ) ) , null ) ; WebXmlMerger merger = new WebXmlMerger ( srcWebXml ) ; merger . mergeFilters ( mergeWebXml ) ; assertTrue ( WebXmlUtils . hasFilter ( srcWebXml , STR_ ) ) ; }
public Edge ( S src , Symbol symbol , S dest ) { this . src = src ; this . symbol = symbol ; this . dest = dest ; this . srcItem = src . getFirstItem ( ) ; this . hashCache = calcHashCode ( ) ; }
public void push ( final Type value ) { if ( value == null ) { mv . visitInsn ( Opcodes . ACONST_NULL ) ; } else { switch ( value . getSort ( ) ) { case Type . BOOLEAN : mv . visitFieldInsn ( Opcodes . GETSTATIC , STR_ , STR_ , CLDESC ) ; break ; case Type . CHAR : mv . visitFieldInsn ( Opcodes . GETSTATIC , STR_ , STR_ , CLDESC ) ; break ; case Type . BYTE : mv . visitFieldInsn ( Opcodes . GETSTATIC , STR_ , STR_ , CLDESC ) ; break ; case Type . SHORT : mv . visitFieldInsn ( Opcodes . GETSTATIC , STR_ , STR_ , CLDESC ) ; break ; case Type . INT : mv . visitFieldInsn ( Opcodes . GETSTATIC , STR_ , STR_ , CLDESC ) ; break ; case Type . FLOAT : mv . visitFieldInsn ( Opcodes . GETSTATIC , STR_ , STR_ , CLDESC ) ; break ; case Type . LONG : mv . visitFieldInsn ( Opcodes . GETSTATIC , STR_ , STR_ , CLDESC ) ; break ; case Type . DOUBLE : mv . visitFieldInsn ( Opcodes . GETSTATIC , STR_ , STR_ , CLDESC ) ; break ; default : mv . visitLdcInsn ( value ) ; } } }
public ExtendedTextLabel createExtended ( Font font , CoreMetrics lm , Decoration decorator , int start , int limit ) { if ( start >= limit || start < lineStart || limit > lineLimit ) { throw new IllegalArgumentException ( STR_ + start + STR_ + limit ) ; } int level = lineBidi == null ? NUM_ : lineBidi . getLevelAt ( start - lineStart ) ; int linedir = ( lineBidi == null || lineBidi . baseIsLeftToRight ( ) ) ? NUM_ : NUM_ ; int layoutFlags = flags & ~ x9 ; if ( ( level & x1 ) != NUM_ ) layoutFlags |= NUM_ ; if ( ( linedir & x1 ) != NUM_ ) layoutFlags |= NUM_ ; TextSource source = new StandardTextSource ( text , start , limit - start , lineStart , lineLimit - lineStart , level , layoutFlags , font , frc , lm ) ; return new ExtendedTextSourceLabel ( source , decorator ) ; }
public static String rightPad ( String s , int minLength , char filling ) { int ln = s . length ( ) ; if ( minLength <= ln ) { return s ; } StringBuilder res = new StringBuilder ( minLength ) ; res . append ( s ) ; int dif = minLength - ln ; for ( int i = NUM_ ; i < dif ; i ++ ) { res . append ( filling ) ; } return res . toString ( ) ; }
public final boolean isSupported ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; }
public void clear ( ) { fullyLock ( ) ; try { for ( Node < E > p , h = head ; ( p = h . next ) != null ; h = p ) { h . next = h ; p . item = null ; } head = last ; if ( count . getAndSet ( NUM_ ) == capacity ) notFull . signal ( ) ; } finally { fullyUnlock ( ) ; } }
private static String readQuotedDescriptor ( final SubstringReader reader , final boolean allowCompatChars ) throws DecodeException { int length = NUM_ ; reader . skipWhitespaces ( ) ; try { char c = reader . read ( ) ; if ( c != STR_ ) { throw DecodeException . error ( ERR_ATTR_SYNTAX_EXPECTED_QUOTE_AT_POS1 . get ( reader . pos ( ) - NUM_ , c ) ) ; } reader . mark ( ) ; while ( ( c = reader . read ( ) ) != STR_ ) { if ( length == NUM_ && ! isAlpha ( c ) ) { throw DecodeException . error ( ERR_ATTR_SYNTAX_ILLEGAL_CHAR_IN_STRING_OID1 . get ( c , reader . pos ( ) - NUM_ ) ) ; } if ( ! isKeyChar ( c , allowCompatChars ) ) { throw DecodeException . error ( ERR_ATTR_SYNTAX_ILLEGAL_CHAR_IN_STRING_OID1 . get ( c , reader . pos ( ) - NUM_ ) ) ; } length ++ ; } reader . reset ( ) ; final String descr = reader . read ( length ) ; reader . read ( ) ; return descr ; } catch ( final StringIndexOutOfBoundsException e ) { throw DecodeException . error ( ERR_ATTR_SYNTAX_TRUNCATED_VALUE1 . get ( ) ) ; } }
public String toCSV ( ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( STR_ ) ; builder . append ( STR_ ) ; for ( T predicted : classes ) { builder . append ( String . format ( STR_ , predicted ) ) ; } builder . append ( STR_ ) ; String firstColumnLabel = STR_ ; for ( T actual : classes ) { builder . append ( firstColumnLabel ) ; firstColumnLabel = STR_ ; builder . append ( String . format ( STR_ , actual ) ) ; for ( T predicted : classes ) { builder . append ( getCount ( actual , predicted ) ) ; builder . append ( STR_ ) ; } builder . append ( getActualTotal ( actual ) ) ; builder . append ( STR_ ) ; } builder . append ( STR_ ) ; for ( T predicted : classes ) { builder . append ( getPredictedTotal ( predicted ) ) ; builder . append ( STR_ ) ; } builder . append ( STR_ ) ; return builder . toString ( ) ; }
public void testCase9 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int bSign = NUM_ ; byte rBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . subtract ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( NUM_ , result . signum ( ) ) ; }
public Object assignIdValue ( Object data , Number val , ObjectCache objectCache ) throws SQLException { Object idVal = dataPersister . convertIdNumber ( val ) ; if ( idVal == null ) { throw new SQLException ( STR_ + dataPersister + STR_ + this ) ; } else { assignField ( data , idVal , BOOL_ , objectCache ) ; return idVal ; } }
public static void writeSwappedInteger ( OutputStream output , int value ) throws IOException { output . write ( ( byte ) ( ( value > > NUM_ ) & xff ) ) ; output . write ( ( byte ) ( ( value > > NUM_ ) & xff ) ) ; output . write ( ( byte ) ( ( value > > NUM_ ) & xff ) ) ; output . write ( ( byte ) ( ( value > > NUM_ ) & xff ) ) ; }
public final boolean isOpen ( ) { return closed . get ( ) == BOOL_ ; }
public static Map < String , Object > performFindList ( DispatchContext dctx , Map < String , Object > context ) { Integer viewSize = ( Integer ) context . get ( STR_ ) ; if ( viewSize == null ) viewSize = Integer . valueOf ( NUM_ ) ; context . put ( STR_ , viewSize ) ; Integer viewIndex = ( Integer ) context . get ( STR_ ) ; if ( viewIndex == null ) viewIndex = Integer . valueOf ( NUM_ ) ; context . put ( STR_ , viewIndex ) ; Map < String , Object > result = performFind ( dctx , context ) ; int start = viewIndex . intValue ( ) . viewSize . intValue ( ) ; List < GenericValue > list = null ; Integer listSize = NUM_ ; try { EntityListIterator it = ( EntityListIterator ) result . get ( STR_ ) ; list = it . getPartialList ( start + NUM_ , viewSize ) ; listSize = it . getResultsSizeAfterPartialList ( ) ; it . close ( ) ; } catch ( Exception e ) { Debug . logInfo ( STR_ + e , module ) ; } result . put ( STR_ , listSize ) ; result . put ( STR_ , list ) ; result . remove ( STR_ ) ; return result ; }
public static String soapToString ( SOAPElement element ) { return domToString ( element . getOwnerDocument ( ) ) ; }
@ Override public void close ( ) throws IOException { try { out . close ( ) ; } finally { lockFile . delete ( ) ; } }
public static void init ( Context context ) { if ( cameraManager == null ) { cameraManager = new CameraManager ( context ) ; } }
@ Override public boolean equals ( Object x , Object y ) throws HibernateException { if ( x == null ) { return y == null ; } return x . equals ( y ) ; }
@ Override public final void writeBoolean ( boolean v ) throws IOException { dis . writeBoolean ( v ) ; }
public void train ( Set < String > sFileNames ) { Iterator < String > iFile = sFileNames . iterator ( ) ; while ( iFile . hasNext ( ) ) { String sText = utils . loadFileToString ( iFile . next ( ) ) ; train ( sText ) ; } }
public void testFindSpringOpenLdapWithLimit ( ) { LdapProxy proxy = getLdapOpenLdap ( ) ; List result = null ; int limit = NUM_ ; try { result = proxy . find ( getLdapSearchVO ( STR_ , limit , STR_ , STR_ , null , LdapScopeConstants . SCOPE_SUBTREE ) ) ; } catch ( Exception e ) { } assertNotNull ( result ) ; if ( result != null ) { assertEquals ( limit , result . size ( ) ) ; } }
public PrintfFormat ( String fmtArg ) throws IllegalArgumentException { this ( Locale . getDefault ( ) , fmtArg ) ; }
public final void append ( FastStringBuffer value ) { if ( value == null ) return ; int strlen = value . length ( ) ; if ( NUM_ == strlen ) return ; int copyfrom = NUM_ ; char [ ] chunk = m_array [ m_lastChunk ] ; int available = m_chunkSize - m_firstFree ; while ( strlen > NUM_ ) { if ( available > strlen ) available = strlen ; int sourcechunk = ( copyfrom + value . m_chunkSize - NUM_ ) > > > value . m_chunkBits ; int sourcecolumn = copyfrom & value . m_chunkMask ; int runlength = value . m_chunkSize - sourcecolumn ; if ( runlength > available ) runlength = available ; System . arraycopy ( value . m_array [ sourcechunk ] , sourcecolumn , m_array [ m_lastChunk ] , m_firstFree , runlength ) ; if ( runlength != available ) System . arraycopy ( value . m_array [ sourcechunk + NUM_ ] , NUM_ , m_array [ m_lastChunk ] , m_firstFree + runlength , available - runlength ) ; strlen -= available ; copyfrom += available ; if ( strlen > NUM_ ) { int i = m_array . length ; if ( m_lastChunk + NUM_ == i ) { char [ ] [ ] newarray = new char [ i + NUM_ ] [ ] ; System . arraycopy ( m_array , NUM_ , newarray , NUM_ , i ) ; m_array = newarray ; } chunk = m_array [ ++ m_lastChunk ] ; if ( chunk == null ) { if ( m_lastChunk == NUM_ << m_rebundleBits && m_chunkBits < m_maxChunkBits ) { m_innerFSB = new FastStringBuffer ( this ) ; } chunk = m_array [ m_lastChunk ] = new char [ m_chunkSize ] ; } available = m_chunkSize ; m_firstFree = NUM_ ; } } m_firstFree += available ; }
public static void writeFixInt32 ( final OutputStream output , final int val ) throws IOException { output . write ( ( val > > > NUM_ ) & xFF ) ; output . write ( ( val > > > NUM_ ) & xFF ) ; output . write ( ( val > > > NUM_ ) & xFF ) ; output . write ( val & xFF ) ; }
public static void queueCubeLoad ( ICubicWorld world , CubeIO loader , CubeProviderServer cache , int x , int y , int z , Consumer < Cube > runnable ) { QueuedCube key = new QueuedCube ( x , y , z , world ) ; AsyncCubeIOProvider task = cubeTasks . get ( key ) ; if ( task == null ) { task = new AsyncCubeIOProvider ( key , loader ) ; task . addCallback ( runnable ) ; cubeTasks . put ( key , task ) ; pool . execute ( task ) ; } else { task . addCallback ( runnable ) ; } Column loadedColumn ; if ( ( loadedColumn = cache . getLoadedColumn ( x , z ) ) == null ) { cache . asyncGetColumn ( x , z , IProviderExtras . Requirement . LIGHT , null ) ; } else { task . setColumn ( loadedColumn ) ; } }
public static boolean isObjectAvailableNow ( final boolean enabled , final Date availableFrom , final Date availableTo , final Date now ) { if ( ! enabled ) { return BOOL_ ; } if ( availableFrom != null && now . before ( availableFrom ) ) { return BOOL_ ; } if ( availableTo != null && now . after ( availableTo ) ) { return BOOL_ ; } return BOOL_ ; }
public void buttonClicked ( ActionEvent e ) ;
private long loadLargestMessageId ( ) { ReleaseMessage releaseMessage = releaseMessageRepository . findTopByOrderByIdDesc ( ) ; return releaseMessage == null ? NUM_ : releaseMessage . getId ( ) ; }
public void removeChangeListener ( ChangeListener l ) { if ( listeners == null ) return ; listeners . remove ( l ) ; }
public static RequestLog dump ( ) { RequestLog current = RLOG . get ( ) ; RequestLog copy = new RequestLog ( current ) ; current . clear ( ) ; RLOG . remove ( ) ; return copy ; }
public static String urlDecode ( String str ) { try { return ( URLDecoder . decode ( str , STR_ ) ) ; } catch ( Exception e ) { return ( STR_ ) ; } }
public void testThenAcceptBoth_exceptionalCompletion ( ) throws Throwable { for ( ExecutionMode m : ExecutionMode . values ( ) ) for ( boolean fFirst : new boolean [ ] { BOOL_ , BOOL_ } ) for ( boolean failFirst : new boolean [ ] { BOOL_ , BOOL_ } ) for ( Integer v1 : new Integer [ ] { NUM_ , null } ) { final CompletableFuture < Integer > f = new CompletableFuture < > ( ) ; final CompletableFuture < Integer > g = new CompletableFuture < > ( ) ; final CFException ex = new CFException ( ) ; final SubtractAction r1 = new SubtractAction ( m ) ; final SubtractAction r2 = new SubtractAction ( m ) ; final SubtractAction r3 = new SubtractAction ( m ) ; final CompletableFuture < Integer > fst = fFirst ? f : g ; final CompletableFuture < Integer > snd = ! fFirst ? f : g ; final Callable < Boolean > complete1 = failFirst ? null : null ; final Callable < Boolean > complete2 = failFirst ? null : null ; final CompletableFuture < Void > h1 = m . thenAcceptBoth ( f , g , r1 ) ; assertTrue ( complete1 . call ( ) ) ; final CompletableFuture < Void > h2 = m . thenAcceptBoth ( f , g , r2 ) ; checkIncomplete ( h1 ) ; checkIncomplete ( h2 ) ; assertTrue ( complete2 . call ( ) ) ; final CompletableFuture < Void > h3 = m . thenAcceptBoth ( f , g , r3 ) ; checkCompletedWithWrappedException ( h1 , ex ) ; checkCompletedWithWrappedException ( h2 , ex ) ; checkCompletedWithWrappedException ( h3 , ex ) ; r1 . assertNotInvoked ( ) ; r2 . assertNotInvoked ( ) ; r3 . assertNotInvoked ( ) ; checkCompletedNormally ( failFirst ? snd : fst , v1 ) ; checkCompletedExceptionally ( failFirst ? fst : snd , ex ) ; } }
protected DefaultListModel stringToModel ( String s ) { DefaultListModel result ; String tmpStr ; int i ; boolean quote ; String [ ] find ; String [ ] replace ; int index ; result = new DefaultListModel ( ) ; find = new String [ ] { STR_ , STR_ , STR_ , STR_ } ; replace = new String [ ] { STR_ , STR_ , STR_ , STR_ } ; for ( i = NUM_ ; i < find . length ; i ++ ) { tmpStr = STR_ ; while ( s . length ( ) > NUM_ ) { index = s . indexOf ( find [ i ] ) ; if ( index > - NUM_ ) { tmpStr += s . substring ( NUM_ , index ) + replace [ i ] ; s = s . substring ( index + NUM_ ) ; } else { tmpStr += s ; s = STR_ ; } } s = tmpStr ; } quote = BOOL_ ; tmpStr = STR_ ; for ( i = NUM_ ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == STR_ ) { quote = ! quote ; tmpStr += STR_ + s . charAt ( i ) ; } else if ( s . charAt ( i ) == STR_ ) { if ( quote ) { tmpStr += STR_ + s . charAt ( i ) ; } else { if ( tmpStr . startsWith ( STR_ ) ) { tmpStr = tmpStr . substring ( NUM_ , tmpStr . length ( ) - NUM_ ) ; } result . addElement ( tmpStr ) ; tmpStr = STR_ ; } } else { tmpStr += STR_ + s . charAt ( i ) ; } } if ( ! tmpStr . equals ( STR_ ) ) { if ( tmpStr . startsWith ( STR_ ) ) { tmpStr = tmpStr . substring ( NUM_ , tmpStr . length ( ) - NUM_ ) ; } result . addElement ( tmpStr ) ; } return result ; }
public void testGetTables ( ) throws Exception { DatabaseMetaData dmd = con . getMetaData ( ) ; ResultSet rs = dmd . getTables ( null , null , null , null ) ; assertNotNull ( rs ) ; rs . close ( ) ; }
public void addAll ( Collection < ? extends T > collection ) { if ( mEventDelegate != null ) mEventDelegate . addData ( collection == null ? NUM_ : collection . size ( ) ) ; if ( collection != null && collection . size ( ) != NUM_ ) { synchronized ( mLock ) { mObjects . addAll ( collection ) ; } } if ( mNotifyOnChange ) notifyDataSetChanged ( ) ; }
public static void resetCurrentFileList ( String logName ) { currentFileList . remove ( PREFIX + logName ) ; }
void initComposeState ( ) { m_composeState = new ComposeState ( ) ; }
@ Override public abstract List < JToolBar > createToolBars ( Application a , @ Nullable View p ) ;
public static Date parseDate ( String dateValue ) throws DateParseException { return parseDate ( dateValue , null , null ) ; }
public RegexFileFilter ( String pattern , IOCase caseSensitivity ) { if ( pattern == null ) { throw new IllegalArgumentException ( STR_ ) ; } int flags = NUM_ ; if ( caseSensitivity != null && ! caseSensitivity . isCaseSensitive ( ) ) { flags = Pattern . CASE_INSENSITIVE ; } this . pattern = Pattern . compile ( pattern , flags ) ; }
public static synchronized ResultSet executeQuery ( String sqlStatement ) { logger . trace ( String . format ( STR_ , sqlStatement ) ) ; ResultSet R = null ; final Statement S = getStatement ( ) ; if ( S == null ) { logger . error ( STR_ ) ; return null ; } try { R = S . executeQuery ( sqlStatement ) ; logger . trace ( STR_ + ( null == R ) ) ; return R ; } catch ( Throwable t ) { surfaceThrowable ( String . format ( STR_ , sqlStatement ) , t ) ; cleanup ( S , R ) ; } return null ; }
public void write ( byte [ ] buf ) throws IOException { output . write ( buf ) ; bytesWritten += buf . length ; }
public static String urlEncode ( @ Nullable String s ) { if ( s == null ) { return STR_ ; } try { return URLEncoder . encode ( s , STR_ ) ; } catch ( UnsupportedEncodingException e ) { throw new AssertionError ( STR_ ) ; } }
protected static boolean checkRawModulesTables ( final CConnection connection , final String databaseName , final int rawModuleId ) { Preconditions . checkNotNull ( connection , STR_ ) ; Preconditions . checkNotNull ( databaseName , STR_ ) ; Preconditions . checkArgument ( rawModuleId > NUM_ , STR_ , rawModuleId ) ; final ImmutableSet < String > rawTableNames = ImmutableSet . of ( String . format ( CTableNames . RAW_ADDRESS_COMMENTS_TABLE , rawModuleId ) , String . format ( CTableNames . RAW_ADDRESS_REFERENCES_TABLE , rawModuleId ) , String . format ( CTableNames . RAW_BASE_TYPES , rawModuleId ) , String . format ( CTableNames . RAW_BASIC_BLOCK_INSTRUCTIONS_TABLE , rawModuleId ) , String . format ( CTableNames . RAW_BASIC_BLOCKS_TABLE , rawModuleId ) , String . format ( CTableNames . RAW_CALLGRAPH_TABLE , rawModuleId ) , String . format ( CTableNames . RAW_CONTROL_FLOW_GRAPHS_TABLE , rawModuleId ) , String . format ( CTableNames . RAW_EXPRESSION_NODES_TABLE , rawModuleId ) , String . format ( CTableNames . RAW_EXPRESSION_SUBSTITUTIONS_TABLE , rawModuleId ) , String . format ( CTableNames . RAW_EXPRESSION_TREE_NODES_TABLE , rawModuleId ) , String . format ( CTableNames . RAW_EXPRESSION_TREES_TABLE , rawModuleId ) , String . format ( CTableNames . RAW_EXPRESSION_TYPES_TABLE , rawModuleId ) , String . format ( CTableNames . RAW_FUNCTIONS_TABLE , rawModuleId ) , String . format ( CTableNames . RAW_INSTRUCTIONS_TABLE , rawModuleId ) , String . format ( CTableNames . RAW_OPERANDS_TABLE , rawModuleId ) , String . format ( CTableNames . RAW_SECTIONS , rawModuleId ) , String . format ( CTableNames . RAW_EXPRESSION_TYPE_INSTANCES , rawModuleId ) , String . format ( CTableNames . RAW_TYPE_INSTACES , rawModuleId ) , String . format ( CTableNames . RAW_TYPES , rawModuleId ) ) ; final Pair < CConnection , String > cacheKey = new Pair < > ( connection , databaseName ) ; if ( PostgreSQLDatabaseFunctions . queryCache ( cacheKey , rawTableNames ) ) { return BOOL_ ; } else { if ( ! PostgreSQLDatabaseFunctions . fillCache ( cacheKey ) ) { return BOOL_ ; } return PostgreSQLDatabaseFunctions . queryCache ( cacheKey , rawTableNames ) ; } }
public Currency read ( String symbol ) { return Currency . getInstance ( symbol ) ; }
public static float parseFloat ( String s ) { if ( POSITIVE_INFINITY . equals ( s ) ) { return Float . POSITIVE_INFINITY ; } else if ( NEGATIVE_INFINITY . equals ( s ) ) { return Float . NEGATIVE_INFINITY ; } else if ( NaN . equals ( s ) ) { return Float . NaN ; } else { s = trimPlusSign ( s ) ; return Float . parseFloat ( s ) ; } }
public Object newInstance ( Class javaContentInterface ) throws JAXBException { if ( javaContentInterface == null ) { throw new JAXBException ( Messages . format ( Messages . CI_NOT_NULL ) ) ; } try { Class c = gi . getDefaultImplementation ( javaContentInterface ) ; if ( c == null ) throw new JAXBException ( Messages . format ( Messages . MISSING_INTERFACE , javaContentInterface ) ) ; return c . newInstance ( ) ; } catch ( Exception e ) { throw new JAXBException ( e ) ; } }
public void requestPasswordForShareViaLink ( boolean createShare ) { SharePasswordDialogFragment dialog = SharePasswordDialogFragment . newInstance ( mFile , createShare ) ; dialog . show ( getFragmentManager ( ) , SharePasswordDialogFragment . PASSWORD_FRAGMENT ) ; }
private void forceOutOfMemory ( ) { ArrayList junk = new ArrayList ( ) ; for ( ; ; ) { junk . add ( new long [ NUM_ ] ) ; } }
@ Override public synchronized void put ( String key , Entry entry ) { pruneIfNeeded ( entry . data . length ) ; File file = getFileForKey ( key ) ; try { BufferedOutputStream fos = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; CacheHeader e = new CacheHeader ( key , entry ) ; boolean success = e . writeHeader ( fos ) ; if ( ! success ) { fos . close ( ) ; VolleyLog . d ( STR_ , file . getAbsolutePath ( ) ) ; throw new IOException ( ) ; } fos . write ( entry . data ) ; fos . close ( ) ; putEntry ( key , e ) ; return ; } catch ( IOException e ) { } boolean deleted = file . delete ( ) ; if ( ! deleted ) { VolleyLog . d ( STR_ , file . getAbsolutePath ( ) ) ; } }
public void intersection ( Rectangle2D r ) { if ( status == INVALID ) return ; if ( status == EMPTY ) { setClip ( r ) ; status = INUSE ; return ; } clip [ NUM_ ] = Math . max ( clip [ NUM_ ] , r . getMinX ( ) ) ; clip [ NUM_ ] = Math . max ( clip [ NUM_ ] , r . getMinY ( ) ) ; clip [ NUM_ ] = Math . min ( clip [ NUM_ ] , r . getMaxX ( ) ) ; clip [ NUM_ ] = Math . min ( clip [ NUM_ ] , r . getMaxY ( ) ) ; }
public boolean canGetInt ( ) { return canGet ( int . class ) ; }
private Node addConditionWaiter ( ) { Node t = lastWaiter ; if ( t != null && t . waitStatus != Node . CONDITION ) { unlinkCancelledWaiters ( ) ; t = lastWaiter ; } Node node = new Node ( Thread . currentThread ( ) , Node . CONDITION ) ; if ( t == null ) firstWaiter = node ; else t . nextWaiter = node ; lastWaiter = node ; return node ; }
@ TCB static String stripBannedCodeunits ( String s ) { int safeLimit = longestPrefixOfGoodCodeunits ( s ) ; if ( safeLimit < NUM_ ) { return s ; } StringBuilder sb = new StringBuilder ( s ) ; stripBannedCodeunits ( sb , safeLimit ) ; return sb . toString ( ) ; }
public static void assertLinewiseEquals ( String message , String expected , String actual ) { try ( Scanner expectedScanner = new Scanner ( expected ) ; Scanner actualScanner = new Scanner ( actual ) ) { String expectedLine = null ; String actualLine = null ; int lineCounter = NUM_ ; while ( expectedScanner . hasNextLine ( ) ) { expectedLine = expectedScanner . nextLine ( ) ; if ( actualScanner . hasNextLine ( ) ) { actualLine = actualScanner . nextLine ( ) ; } else { fail ( STR_ + lineCounter + STR_ + expectedLine ) ; } assertEquals ( STR_ + lineCounter + STR_ + message + STR_ + expected + STR_ + actual , expectedLine , actualLine ) ; ++ lineCounter ; } } }
private void warning ( String msg , Throwable th ) { warning ( msg ) ; th . printStackTrace ( ) ; }
void addFillComponents ( Container panel , int [ ] cols , int [ ] rows ) { Dimension filler = new Dimension ( NUM_ , NUM_ ) ; boolean filled_cell_11 = BOOL_ ; CellConstraints cc = new CellConstraints ( ) ; if ( cols . length > NUM_ && rows . length > NUM_ ) { if ( cols [ NUM_ ] == NUM_ && rows [ NUM_ ] == NUM_ ) { panel . add ( Box . createRigidArea ( filler ) , cc . xy ( NUM_ , NUM_ ) ) ; filled_cell_11 = BOOL_ ; } } for ( int index = NUM_ ; index < cols . length ; index ++ ) { if ( cols [ index ] == NUM_ && filled_cell_11 ) { continue ; } panel . add ( Box . createRigidArea ( filler ) , cc . xy ( cols [ index ] , NUM_ ) ) ; } for ( int index = NUM_ ; index < rows . length ; index ++ ) { if ( rows [ index ] == NUM_ && filled_cell_11 ) { continue ; } panel . add ( Box . createRigidArea ( filler ) , cc . xy ( NUM_ , rows [ index ] ) ) ; } }
public String fullForm ( final String str , final String lowString ) { String ret = lowString ; PrefixEntry found = prefixMap . get ( str ) ; if ( found != null ) { ret = found . prefixSingular + ret ; } else { for ( PrefixEntry entry : prefixEndList ) { if ( str . endsWith ( entry . keyword ) ) { ret = Grammar . addPrefixIfNotAlreadyThere ( ret , entry . prefixSingular , entry . prefixPlural ) ; break ; } } } return ret ; }
public void clearPasswordExpirationWarnedTime ( ) { operations . add ( PasswordPolicyStateOperationType . CLEAR_PASSWORD_EXPIRATION_WARNED_TIME ) ; }
private static Locale strip ( Locale locale ) { String language = locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; String variant = locale . getVariant ( ) ; if ( ! variant . isEmpty ( ) ) { variant = STR_ ; } else if ( ! country . isEmpty ( ) ) { country = STR_ ; } else if ( ! language . isEmpty ( ) ) { language = STR_ ; } else { return null ; } return new Locale ( language , country , variant ) ; }
private void appendTimeZone ( StringBuffer buffer , int count , boolean generalTimeZone ) { if ( generalTimeZone ) { TimeZone tz = calendar . getTimeZone ( ) ; boolean daylight = ( calendar . get ( Calendar . DST_OFFSET ) != NUM_ ) ; int style = count < NUM_ ? TimeZone . SHORT : TimeZone . LONG ; if ( ! formatData . customZoneStrings ) { buffer . append ( tz . getDisplayName ( daylight , style , formatData . locale ) ) ; return ; } String custom = TimeZoneNames . getDisplayName ( formatData . zoneStrings , tz . getID ( ) , daylight , style ) ; if ( custom != null ) { buffer . append ( custom ) ; return ; } } appendNumericTimeZone ( buffer , count , generalTimeZone ) ; }
public void removeListeners ( ) { if ( globalListener != null ) { try { InvokerHelper . invokeMethod ( currentObject , STR_ , globalListener ) ; } catch ( Exception e ) { } globalListener = null ; } if ( localListener != null ) { try { InvokerHelper . invokeMethod ( currentObject , STR_ , new Object [ ] { propertyName , localListener } ) ; } catch ( Exception e ) { } localListener = null ; } if ( syntheticFullBinding != null ) { syntheticFullBinding . unbind ( ) ; } }
public static String padLeft ( String str , int totalChars ) { if ( str == null ) str = STR_ ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = NUM_ ; i < totalChars - str . length ( ) ; i ++ ) { sb . append ( STR_ ) ; } sb . append ( str ) ; return sb . toString ( ) ; }
public void showScores ( boolean flag ) { mShowScores = flag ; SwingUtilities . invokeLater ( null ) ; }
public static void write ( File file , CharSequence data , boolean append ) throws IOException { write ( file , data , Charset . defaultCharset ( ) , append ) ; }
protected double kernelHelper ( int n , char [ ] s , int endIndexS , char [ ] t , int endIndexT ) { if ( n <= NUM_ ) { return getReturnValue ( n ) ; } if ( Math . min ( endIndexS + NUM_ , endIndexT + NUM_ ) < n ) { return getReturnValue ( n ) ; } int adr = NUM_ ; if ( m_useRecursionCache ) { adr = m_multX . n + m_multY . endIndexS + m_multZ . endIndexT ; if ( cachekhK [ adr % maxCache ] == adr + NUM_ ) { return cachekh [ adr % maxCache ] ; } } double result = NUM_ ; result = m_lambda . kernelHelper ( n , s , endIndexS - NUM_ , t , endIndexT ) + kernelHelper2 ( n , s , endIndexS , t , endIndexT ) ; if ( m_useRecursionCache ) { cachekhK [ adr % maxCache ] = adr + NUM_ ; cachekh [ adr % maxCache ] = result ; } return result ; }
protected Connection openH2Connection ( boolean autocommit ) throws SQLException { System . setProperty ( STR_ , STR_ ) ; String dbName = STR_ ; Connection conn = DriverManager . getConnection ( STR_ + dbName + STR_ ) ; conn . setAutoCommit ( autocommit ) ; return conn ; }
private void emitClear ( String fieldName , StringBuilder builder ) { builder . append ( STR_ ) ; builder . append ( getClearName ( fieldName ) ) ; builder . append ( STR_ ) ; builder . append ( getEnsureName ( fieldName ) ) ; builder . append ( STR_ ) ; builder . append ( fieldName ) ; builder . append ( STR_ ) ; builder . append ( STR_ ) ; }
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; }
protected void startRecoarding ( ) { coordinates . clear ( ) ; enabled = BOOL_ ; }
public void addInputMethodListener ( InputMethodListener l ) { m_textPane . addInputMethodListener ( l ) ; }
public void addFooterView ( View v , Object data , boolean isSelectable ) { FixedViewInfo info = new FixedViewInfo ( ) ; info . view = v ; info . data = data ; info . isSelectable = isSelectable ; mFooterViewInfos . add ( info ) ; if ( mAdapter != null && mObserver != null ) { mObserver . onChanged ( ) ; } }
public static void load ( String url ) { String driver = getDriver ( url ) ; if ( driver != null ) { loadUserClass ( driver ) ; } }
public void addDocument ( Document d ) { if ( ! m_readMode ) { try { writer . addDocument ( d ) ; m_hitCountCache . clear ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { throw new IllegalStateException ( STR_ + STR_ ) ; } }
protected void putCommand ( final Class commandClass , final String [ ] names ) { Check . isTrue ( names . length > NUM_ , STR_ ) ; _commandsToCanonicalNames . put ( commandClass , names [ NUM_ ] ) ; for ( int i = NUM_ ; i < names . length ; i ++ ) { _aliasesToCommands . put ( names [ i ] , commandClass ) ; } }
protected void writeColumnAutoIncrementStmt ( Table table , Column column , StringBuilder ddl ) { ddl . append ( STR_ ) ; }
private void SaveGCMData ( ) { try { SharedPreferences preferences = getSharedPreferences ( ) ; SharedPreferences . Editor editor = preferences . edit ( ) ; editor . putString ( PREFS_PUSHER_APP_ID_KEY , mPusherAppId ) ; editor . putString ( PREFS_PUSHER_URL_KEY , mPusherUrl ) ; editor . putString ( PREFS_PUSHER_FILE_TAG_KEY , mPusherBaseFileTag ) ; editor . commit ( ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , STR_ + e . getLocalizedMessage ( ) ) ; } }
final void runWorker ( Worker w ) { Thread wt = Thread . currentThread ( ) ; Runnable task = w . firstTask ; w . firstTask = null ; w . unlock ( ) ; boolean completedAbruptly = BOOL_ ; try { while ( task != null || ( task = getTask ( ) ) != null ) { w . lock ( ) ; if ( ( runStateAtLeast ( ctl . get ( ) , STOP ) || ( Thread . interrupted ( ) && runStateAtLeast ( ctl . get ( ) , STOP ) ) ) && ! wt . isInterrupted ( ) ) wt . interrupt ( ) ; try { beforeExecute ( wt , task ) ; Throwable thrown = null ; try { task . run ( ) ; } catch ( RuntimeException x ) { thrown = x ; throw x ; } catch ( Error x ) { thrown = x ; throw x ; } catch ( Throwable x ) { thrown = x ; throw new Error ( x ) ; } finally { afterExecute ( task , thrown ) ; } } finally { task = null ; w . completedTasks ++ ; w . unlock ( ) ; } } completedAbruptly = BOOL_ ; } finally { processWorkerExit ( w , completedAbruptly ) ; } }
public void writeBlockLight ( ByteBuf output ) { output . writeBytes ( blockLight . getHandle ( ) ) ; }
private static final boolean compareAndSetWaitStatus ( Node node , int expect , int update ) { return unsafe . compareAndSwapInt ( node , waitStatusOffset , expect , update ) ; }
public String search ( ) throws Exception { executeQuery ( ) ; return SUCCESS ; }
public String next ( Pattern pattern ) { checkOpen ( ) ; checkNotNull ( pattern ) ; matchSuccessful = BOOL_ ; saveCurrentStatus ( ) ; if ( ! setTokenRegion ( ) ) { recoverPreviousStatus ( ) ; throw new NoSuchElementException ( ) ; } matcher . usePattern ( pattern ) ; if ( ! matcher . matches ( ) ) { recoverPreviousStatus ( ) ; throw new InputMismatchException ( ) ; } matchSuccessful = BOOL_ ; return matcher . group ( ) ; }
public void addNewDuration ( long duration ) { callsNumber . incrementAndGet ( ) ; total . addAndGet ( duration ) ; synchronized ( lock ) { if ( duration < minimum . longValue ( ) ) { minimum . set ( duration ) ; } if ( duration > maximum . longValue ( ) ) { maximum . set ( duration ) ; } } }
private void paintBackgroundSolid ( Graphics2D g , JComponent c , int x , int y , int width , int height ) { Color color = c . getBackground ( ) ; if ( type == CommonControlState . DISABLED ) { color = new Color ( color . getRed ( ) , color . getGreen ( ) , color . getBlue ( ) , x80 ) ; } Shape s = shapeGenerator . createRoundRectangle ( x - NUM_ , y - NUM_ , width + NUM_ , height + NUM_ , CornerSize . BORDER ) ; g . setPaint ( color ) ; g . fill ( s ) ; if ( isPaintLineSeperators ( c ) ) { paintLineSeparator ( g , c , width , height ) ; } }
public static void addAttributeDefaultValues ( String serviceName , String subSchemaName , String schemaType , String attributeName , Set defaultValues ) throws UpgradeException { String classMethod = STR_ ; if ( debug . messageEnabled ( ) ) { debug . message ( classMethod + STR_ ) ; debug . message ( STR_ + serviceName + STR_ + attributeName ) ; } ServiceSchema ss = getServiceSchema ( serviceName , subSchemaName , schemaType ) ; try { Map attributeDefaults = ss . getAttributeDefaults ( ) ; Set oldAttrValues = ( Set ) attributeDefaults . get ( attributeName ) ; Set newAttrValues = ( ( oldAttrValues == null ) || oldAttrValues . isEmpty ( ) ) ? new HashSet ( ) : new HashSet ( oldAttrValues ) ; newAttrValues . addAll ( defaultValues ) ; ss . setAttributeDefaults ( attributeName , newAttrValues ) ; } catch ( SSOException ssoe ) { throw new UpgradeException ( STR_ ) ; } catch ( SMSException sme ) { throw new UpgradeException ( STR_ + STR_ ) ; } }
private String encodeProduct ( ) { StringBuffer tokens = new StringBuffer ( ) ; ListIterator it = productTokens . listIterator ( ) ; while ( it . hasNext ( ) ) { tokens . append ( ( String ) it . next ( ) ) ; } return tokens . toString ( ) ; }
public boolean isMetadataModifiedSinceLastPublication ( ) { return metadataModifiedSinceLastPublication ; }
public Options resourceDirs ( List < File > value ) { resourceDirs . clear ( ) ; resourceDirs . addAll ( value ) ; return this ; }
private final String _decodeShortUnicodeName ( int len ) throws IOException , JsonParseException { int outPtr = NUM_ ; char [ ] outBuf = _textBuffer . emptyAndGetCurrentSegment ( ) ; int inPtr = _inputPtr ; _inputPtr += len ; final int [ ] codes = SmileConstants . sUtf8UnitLengths ; final byte [ ] inBuf = _inputBuffer ; for ( int end = inPtr + len ; inPtr < end ; ) { int i = inBuf [ inPtr ++ ] & xFF ; int code = codes [ i ] ; if ( code != NUM_ ) { switch ( code ) { case NUM_ : i = ( ( i & x1F ) << NUM_ ) | ( inBuf [ inPtr ++ ] & x3F ) ; break ; case NUM_ : i = ( ( i & x0F ) << NUM_ ) | ( ( inBuf [ inPtr ++ ] & x3F ) << NUM_ ) | ( inBuf [ inPtr ++ ] & x3F ) ; break ; case NUM_ : i = ( ( i & x07 ) << NUM_ ) | ( ( inBuf [ inPtr ++ ] & x3F ) << NUM_ ) | ( ( inBuf [ inPtr ++ ] & x3F ) << NUM_ ) | ( inBuf [ inPtr ++ ] & x3F ) ; i -= x10000 ; outBuf [ outPtr ++ ] = ( char ) ( xD800 | ( i > > NUM_ ) ) ; i = xDC00 | ( i & x3FF ) ; break ; default : _reportError ( STR_ + Integer . toHexString ( i ) + STR_ ) ; } } outBuf [ outPtr ++ ] = ( char ) i ; } _textBuffer . setCurrentLength ( outPtr ) ; return _textBuffer . contentsAsString ( ) ; }
private static ClassNode makeType ( ClassNode cn , boolean usingClass ) { if ( usingClass ) { ClassNode clazzType = CLASS_Type . getPlainNodeReference ( ) ; clazzType . setGenericsTypes ( new GenericsType [ ] { new GenericsType ( cn ) } ) ; return clazzType ; } else { return cn ; } }
void pushImportURL ( String hrefUrl ) { m_importStack . push ( hrefUrl ) ; }
protected String toMessage ( Map < String , String > results ) { StringBuilder builder = new StringBuilder ( ) ; if ( results != null ) { for ( Map . Entry < String , String > entry : results . entrySet ( ) ) { builder . append ( entry . getKey ( ) + STR_ + entry . getValue ( ) + STR_ ) ; } } return builder . toString ( ) ; }
public TestTree sort ( ) { Collections . sort ( suites ) ; suites . forEach ( null ) ; return this ; }
public static EventBean [ ] addToArray ( EventBean [ ] array , Collection < EventBean > eventsToAdd ) { EventBean [ ] newArray = new EventBean [ array . length + eventsToAdd . size ( ) ] ; System . arraycopy ( array , NUM_ , newArray , NUM_ , array . length ) ; int counter = array . length ; for ( EventBean eventToAdd : eventsToAdd ) { newArray [ counter ++ ] = eventToAdd ; } return newArray ; }
public synchronized void add ( String name , long threadId ) { if ( mFinished ) { throw new IllegalStateException ( STR_ ) ; } mMarkers . add ( new Marker ( name , threadId , SystemClock . elapsedRealtime ( ) ) ) ; }
public static String replace ( String a , String b , String c ) { StringBuilder result = new StringBuilder ( c . length ( ) ) ; int i = NUM_ ; int j = c . indexOf ( a ) ; while ( j >= i ) { result . append ( c . substring ( i , j ) ) ; result . append ( b ) ; i = j + a . length ( ) ; j = c . indexOf ( a , i ) ; } result . append ( c . substring ( i , c . length ( ) ) ) ; return result . toString ( ) ; }
protected void onPageScrolled ( int position , float offset , int offsetPixels ) { if ( mDecorChildCount > NUM_ ) { final int scrollY = getScrollY ( ) ; int paddingTop = getPaddingTop ( ) ; int paddingBottom = getPaddingBottom ( ) ; final int height = getHeight ( ) ; final int childCount = getChildCount ( ) ; for ( int i = NUM_ ; i < childCount ; i ++ ) { final View child = getChildAt ( i ) ; final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; if ( ! lp . isDecor ) continue ; final int vgrav = lp . gravity & Gravity . VERTICAL_GRAVITY_MASK ; int childTop = NUM_ ; switch ( vgrav ) { default : childTop = paddingTop ; break ; case Gravity . TOP : childTop = paddingTop ; paddingTop += child . getHeight ( ) ; break ; case Gravity . CENTER_VERTICAL : childTop = Math . max ( ( height - child . getMeasuredHeight ( ) ) / NUM_ , paddingTop ) ; break ; case Gravity . BOTTOM : childTop = height - paddingBottom - child . getMeasuredHeight ( ) ; paddingBottom += child . getMeasuredHeight ( ) ; break ; } childTop += scrollY ; final int childOffset = childTop - child . getTop ( ) ; if ( childOffset != NUM_ ) { child . offsetTopAndBottom ( childOffset ) ; } } } dispatchOnPageScrolled ( position , offset , offsetPixels ) ; if ( mPageTransformer != null ) { final int scrollY = getScrollY ( ) ; final int childCount = getChildCount ( ) ; for ( int i = NUM_ ; i < childCount ; i ++ ) { final View child = getChildAt ( i ) ; final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; if ( lp . isDecor ) continue ; final float transformPos = ( float ) ( child . getTop ( ) - scrollY ) / getClientHeight ( ) ; mPageTransformer . transformPage ( child , transformPos ) ; } } mCalledSuper = BOOL_ ; }
private void reflectMemberVariablesInFinalButton ( ) { final boolean lastPageReached = ( viewPager . getCurrentItem ( ) + NUM_ ) == pages . size ( ) ; final boolean buttonShouldBeInvisible = ! lastPageReached || finalButtonDisabled ; final boolean buttonIsCurrentlyInvisible = finalButton . getVisibility ( ) == View . INVISIBLE ; final boolean shouldUpdateButton = buttonShouldBeInvisible != buttonIsCurrentlyInvisible ; if ( shouldUpdateButton ) { final Animator buttonAnimator = buttonShouldBeInvisible ? buttonAnimatorFactory . newFinalButtonDisappearAnimator ( finalButton ) : buttonAnimatorFactory . newFinalButtonAppearAnimator ( finalButton ) ; if ( buttonShouldBeInvisible ) { disableButton ( buttonAnimator , finalButton ) ; } else { enableButton ( buttonAnimator , finalButton ) ; } } }
public void testDecoder6 ( ) { boolean res ; String originalAppIdName = mAppIdName ; int originalContentTypeValue = mContentTypeValue ; Random rd = new Random ( ) ; for ( int i = NUM_ ; i < OMA_APPLICATION_ID_NAMES . length ; i ++ ) { mAppIdName = OMA_APPLICATION_ID_NAMES [ i ] ; mContentTypeValue = rd . nextInt ( x0FFF ) ; byte [ ] pdu = createPDU ( NUM_ ) ; WspTypeDecoder pduDecoder = new WspTypeDecoder ( pdu ) ; res = pduDecoder . seekXWapApplicationId ( mWspHeaderStart , mWspHeaderStart + mWspHeaderLen - NUM_ ) ; assertTrue ( res ) ; int index = ( int ) pduDecoder . getValue32 ( ) ; res = pduDecoder . decodeXWapApplicationId ( index ) ; assertTrue ( res ) ; Log . d ( LOG_TAG , STR_ + mAppIdName + STR_ + pduDecoder . getValueString ( ) + STR_ ) ; assertTrue ( mAppIdName . equals ( pduDecoder . getValueString ( ) ) ) ; } mAppIdName = originalAppIdName ; mContentTypeValue = originalContentTypeValue ; }
public final void removeAll ( ) { actionList . clear ( ) ; constraintsList . clear ( ) ; needSorting = BOOL_ ; }
private static boolean isWritable ( @ NonNull final File file ) { boolean isExisting = file . exists ( ) ; try { FileOutputStream output = new FileOutputStream ( file , BOOL_ ) ; try { output . close ( ) ; } catch ( IOException e ) { } } catch ( java . io . FileNotFoundException e ) { return BOOL_ ; } boolean result = file . canWrite ( ) ; if ( ! isExisting ) { file . delete ( ) ; } return result ; }
private RelyingParty validateRelyingParty ( HttpServletRequest request , String tenantName ) { Validate . notNull ( request , STR_ ) ; Validate . notEmpty ( tenantName , STR_ ) ; DefaultIdmAccessorFactory idmFactory = new DefaultIdmAccessorFactory ( ) ; Validate . notNull ( idmFactory , STR_ ) ; IdmAccessor idmAccessor = idmFactory . getIdmAccessor ( ) ; idmAccessor . setTenant ( tenantName ) ; String encodedEntityId = request . getParameter ( Shared . RELYINGPARTY_ENTITYID ) ; if ( encodedEntityId == null || encodedEntityId . isEmpty ( ) ) { logger . error ( STR_ ) ; return null ; } String rpEntityId = new String ( Base64 . decode ( encodedEntityId ) ) ; RelyingParty rp = idmAccessor . getRelyingPartyByUrl ( rpEntityId ) ; if ( rp != null ) { return rp ; } else { logger . error ( STR_ + rpEntityId ) ; return null ; } }
public void rotateZ ( double theta ) { Matrix3D tmp = new Matrix3D ( ) ; double c = Math . cos ( theta ) ; double s = Math . sin ( theta ) ; tmp . set ( NUM_ , NUM_ , c ) ; tmp . set ( NUM_ , NUM_ , - s ) ; tmp . set ( NUM_ , NUM_ , s ) ; tmp . set ( NUM_ , NUM_ , c ) ; preMultiply ( tmp ) ; }
public ServiceHost startFactory ( Service instanceService ) { final Class < ? extends Service > serviceClass = instanceService . getClass ( ) ; return startFactory ( serviceClass , null ) ; }
void wakeOut ( ) { OnAvailable outFlow = _outFlow ; if ( outFlow == null ) { return ; } if ( _creditsIn <= _queue . head ( ) ) { return ; } StateOutPipe stateOld ; StateOutPipe stateNew ; do { stateOld = _stateOutRef . get ( ) ; if ( ! stateOld . isFull ( ) ) { return ; } stateNew = stateOld . toWake ( ) ; } while ( ! _stateOutRef . compareAndSet ( stateOld , stateNew ) ) ; try ( OutboxAmp outbox = OutboxAmp . currentOrCreate ( _outRef . services ( ) ) ) { Objects . requireNonNull ( outbox ) ; PipeWakeOutMessage < T > msg = new PipeWakeOutMessage < > ( outbox , _outRef , this , outFlow ) ; outbox . offer ( msg ) ; } }
public ConstraintMap createAssignmentConstraints ( final AnnotatedTypeMirror assignedTo , final AnnotatedTypeMirror boxedReturnType , final AnnotatedExecutableType methodType , final Set < AFConstraint > afArgumentConstraints , final Map < TypeVariable , AnnotatedTypeMirror > inferredArgs , final Set < TypeVariable > targets , final AnnotatedTypeFactory typeFactory ) { final LinkedList < AFConstraint > assignmentAfs = new LinkedList < > ( ) ; for ( AnnotatedTypeVariable typeParam : methodType . getTypeVariables ( ) ) { final TypeVariable target = typeParam . getUnderlyingType ( ) ; final AnnotatedTypeMirror inferredType = inferredArgs . get ( target ) ; if ( inferredType != null ) { assignmentAfs . add ( new A2F ( inferredType , typeParam . getUpperBound ( ) ) ) ; assignmentAfs . add ( new F2A ( typeParam . getLowerBound ( ) , inferredType ) ) ; } else { assignmentAfs . add ( new F2A ( typeParam , typeParam . getUpperBound ( ) ) ) ; assignmentAfs . add ( new A2F ( typeParam . getLowerBound ( ) , typeParam ) ) ; } } for ( AFConstraint argConstraint : afArgumentConstraints ) { if ( argConstraint instanceof F2A ) { assignmentAfs . add ( argConstraint ) ; } } LinkedList < AFConstraint > substitutedAssignmentConstraints = new LinkedList < > ( ) ; for ( AFConstraint afConstraint : assignmentAfs ) { substitutedAssignmentConstraints . add ( afConstraint . substitute ( inferredArgs ) ) ; } final AnnotatedTypeMirror substitutedReturnType = TypeArgInferenceUtil . substitute ( inferredArgs , boxedReturnType ) ; substitutedAssignmentConstraints . add ( new F2A ( substitutedReturnType , assignedTo ) ) ; final Set < AFConstraint > reducedConstraints = new LinkedHashSet < > ( ) ; reduceAfConstraints ( typeFactory , reducedConstraints , substitutedAssignmentConstraints , targets ) ; final Set < TUConstraint > tuAssignmentConstraints = afToTuConstraints ( reducedConstraints , targets ) ; addConstraintsBetweenTargets ( tuAssignmentConstraints , targets , BOOL_ , typeFactory ) ; return constraintMapBuilder . build ( targets , tuAssignmentConstraints , typeFactory ) ; }
public static int columnsNumber ( char c , int x , int prevX , int plainSpaceSize ) { if ( c != STR_ ) { return NUM_ ; } int result = ( x - prevX ) / plainSpaceSize ; if ( ( x - prevX ) % plainSpaceSize > NUM_ ) { result ++ ; } return result ; }
private Optional ( T value ) { this . value = Objects . requireNonNull ( value ) ; }
public KafkaMessageListenerContainer ( ConsumerFactory < K , V > consumerFactory , ContainerProperties containerProperties , TopicPartitionInitialOffset ... topicPartitions ) { super ( containerProperties ) ; Assert . notNull ( consumerFactory , STR_ ) ; this . consumerFactory = consumerFactory ; if ( topicPartitions != null ) { this . topicPartitions = Arrays . copyOf ( topicPartitions , topicPartitions . length ) ; } else { this . topicPartitions = containerProperties . getTopicPartitions ( ) ; } }
public void engineDeleteEntry ( String alias ) throws KeyStoreException { Key k = ( Key ) keys . remove ( alias ) ; Certificate c = ( Certificate ) certs . remove ( alias ) ; if ( c != null ) { chainCerts . remove ( new CertId ( c . getPublicKey ( ) ) ) ; } if ( k != null ) { String id = ( String ) localIds . remove ( alias ) ; if ( id != null ) { c = ( Certificate ) keyCerts . remove ( id ) ; } if ( c != null ) { chainCerts . remove ( new CertId ( c . getPublicKey ( ) ) ) ; } } }
private String toString ( Matcher m , int group ) { return ( group == NUM_ ) ? STR_ : m . group ( group ) ; }
public PlaLineInt translate_by ( PlaVectorInt p_vector ) { if ( p_vector . equals ( PlaVectorInt . ZERO ) ) return this ; PlaPointInt new_a = point_a . translate_by ( p_vector ) ; PlaPointInt new_b = point_b . translate_by ( p_vector ) ; return new PlaLineInt ( new_a , new_b ) ; }
@ SuppressWarnings ( STR_ ) final void reject ( Runnable command ) { handler . rejectedExecution ( command , this ) ; }
private int calculateMenuMargin ( ) { WindowManager wm = ( WindowManager ) getSystemService ( Context . WINDOW_SERVICE ) ; Display display = wm . getDefaultDisplay ( ) ; Point size = new Point ( ) ; display . getSize ( size ) ; int height = size . y ; return ( int ) Math . round ( height . MENU_MARGIN_RELATIVE_MODIFIER ) ; }
public void addRam ( AttackAction ea ) { pendingRams . addElement ( ea ) ; processGameEvent ( new GameNewActionEvent ( this , ea ) ) ; }
public static List < Integer > createColors ( Resources r , int [ ] colors ) { List < Integer > result = new ArrayList < Integer > ( ) ; for ( int i : colors ) { result . add ( r . getColor ( i ) ) ; } return result ; }
public void testConfigFileProperty ( ) throws Exception { File configHome = new File ( configuration . getHome ( ) ) ; assertTrue ( STR_ , configHome . exists ( ) && configHome . isDirectory ( ) ) ; File existingFile = createFile ( configHome , STR_ , STR_ ) ; assertEquals ( STR_ , readFile ( existingFile ) ) ; String fileName = STR_ ; String fileContents = STR_ ; File file = createFile ( configFileDirectory , fileName , fileContents ) ; FileConfig configFile = new FileConfig ( ) ; configFile . setFile ( getAbsolutePath ( file ) ) ; configFile . setToFile ( STR_ ) ; configFile . setOverwrite ( BOOL_ ) ; configFile . setConfigfile ( BOOL_ ) ; configuration . setProperty ( STR_ , STR_ ) ; configuration . setConfigFileProperty ( configFile ) ; configuration . doConfigure ( null ) ; File copiedFile = new File ( configuration . getHome ( ) + STR_ ) ; assertTrue ( STR_ , copiedFile . exists ( ) ) ; assertEquals ( STR_ , readFile ( copiedFile ) ) ; }
protected byte [ ] generateSalt ( ) { return HEADER . getBytes ( Constants . UTF8 ) ; }
public void addListener ( final ProjectorListener projectorListener ) { if ( listeners == null ) { listeners = new ArrayList < ProjectorListener > ( ) ; } listeners . add ( projectorListener ) ; }
protected TupleExpr selectNextTupleExpr ( List < TupleExpr > expressions , Map < TupleExpr , Double > cardinalityMap , Map < TupleExpr , List < Var > > varsMap , Map < Var , Integer > varFreqMap , Set < String > boundVars ) { TupleExpr result = null ; if ( expressions . size ( ) > NUM_ ) { double lowestCardinality = Double . POSITIVE_INFINITY ; for ( TupleExpr tupleExpr : expressions ) { double cardinality = getTupleExprCardinality ( tupleExpr , cardinalityMap , varsMap , varFreqMap , boundVars ) ; if ( cardinality < lowestCardinality || result == null ) { lowestCardinality = cardinality ; result = tupleExpr ; } } } else { result = expressions . get ( NUM_ ) ; } return result ; }
public static void writeBcdNumber ( OutputStream os , String number ) throws IOException { int bcd = x00 ; int n = NUM_ ; for ( int i = NUM_ ; i < number . length ( ) ; i ++ ) { switch ( number . charAt ( i ) ) { case STR_ : bcd |= x00 ; break ; case STR_ : bcd |= x10 ; break ; case STR_ : bcd |= x20 ; break ; case STR_ : bcd |= x30 ; break ; case STR_ : bcd |= x40 ; break ; case STR_ : bcd |= x50 ; break ; case STR_ : bcd |= x60 ; break ; case STR_ : bcd |= x70 ; break ; case STR_ : bcd |= x80 ; break ; case STR_ : bcd |= x90 ; break ; case STR_ : bcd |= xA0 ; break ; case STR_ : bcd |= xB0 ; break ; case STR_ : bcd |= xC0 ; break ; case STR_ : bcd |= xE0 ; break ; } n ++ ; if ( n == NUM_ ) { os . write ( bcd ) ; n = NUM_ ; bcd = x00 ; } else { bcd >>= NUM_ ; } } if ( n == NUM_ ) { bcd |= xF0 ; os . write ( bcd ) ; } }
public void addMessage ( String message ) { messages . addLast ( message ) ; if ( messages . size ( ) > MAX_HISTORY ) { messages . removeFirst ( ) ; } pointer = messages . size ( ) ; }
@ VisibleForTesting protected void startExecutor ( final int container ) { LOG . info ( STR_ + container ) ; final Process containerExecutor = startExecutorProcess ( container ) ; processToContainer . put ( containerExecutor , container ) ; LOG . info ( STR_ + container ) ; startExecutorMonitor ( container , containerExecutor ) ; }
public static Date stringToDate ( String s , DateFormat formatter ) { try { return formatter . parse ( s ) ; } catch ( ParseException e ) { return null ; } }
public void accept ( AbstractReporter r ) { r . testStart ( this ) ; r . browserInfoEntry ( browserInfoEntry ) ; Iterator < LogEntry > entryIterator = logEntries . iterator ( ) ; while ( entryIterator . hasNext ( ) ) { LogEntry entry = entryIterator . next ( ) ; if ( ! entryIterator . hasNext ( ) ) { entry . setLast ( BOOL_ ) ; } visit ( entry , r ) ; } r . testEnd ( this ) ; }
private void loadLatestExtensionVersions ( ) { try { List < Extension > all = registryManager . getExtensions ( ) ; if ( ! all . isEmpty ( ) ) { setLatestExtensionVersions ( getLatestVersions ( all ) ) ; } } catch ( RegistryException e ) { String msg = RegistryException . logRegistryException ( e . getType ( ) , this ) ; warnings . addStartupError ( msg ) ; LOG . error ( msg ) ; msg = getText ( STR_ , new String [ ] { cfg . getRegistryUrl ( ) } ) ; warnings . addStartupError ( msg ) ; LOG . error ( msg ) ; } finally { if ( getLatestExtensionVersions ( ) == null ) { setLatestExtensionVersions ( new ArrayList < Extension > ( ) ) ; } } }
protected void startNode ( Node node ) throws org . xml . sax . SAXException { if ( node instanceof Locator ) { Locator loc = ( Locator ) node ; fLocator . setColumnNumber ( loc . getColumnNumber ( ) ) ; fLocator . setLineNumber ( loc . getLineNumber ( ) ) ; fLocator . setPublicId ( loc . getPublicId ( ) ) ; fLocator . setSystemId ( loc . getSystemId ( ) ) ; } else { fLocator . setColumnNumber ( NUM_ ) ; fLocator . setLineNumber ( NUM_ ) ; } switch ( node . getNodeType ( ) ) { case Node . DOCUMENT_TYPE_NODE : serializeDocType ( ( DocumentType ) node , BOOL_ ) ; break ; case Node . COMMENT_NODE : serializeComment ( ( Comment ) node ) ; break ; case Node . DOCUMENT_FRAGMENT_NODE : break ; case Node . DOCUMENT_NODE : break ; case Node . ELEMENT_NODE : serializeElement ( ( Element ) node , BOOL_ ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : serializePI ( ( ProcessingInstruction ) node ) ; break ; case Node . CDATA_SECTION_NODE : serializeCDATASection ( ( CDATASection ) node ) ; break ; case Node . TEXT_NODE : serializeText ( ( Text ) node ) ; break ; case Node . ENTITY_REFERENCE_NODE : serializeEntityReference ( ( EntityReference ) node , BOOL_ ) ; break ; default : } }
@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( NUM_ ) ; format ( ( getYear ( ) + NUM_ ) , NUM_ , sb ) ; sb . append ( STR_ ) ; format ( ( getMonth ( ) + NUM_ ) , NUM_ , sb ) ; sb . append ( STR_ ) ; format ( getDate ( ) , NUM_ , sb ) ; return sb . toString ( ) ; }
public void testClearBitNegativeInside2 ( ) { byte aBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; int aSign = - NUM_ ; int number = NUM_ ; byte rBytes [ ] = { - NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , - NUM_ , - NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger result = aNumber . clearBit ( number ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , - NUM_ , result . signum ( ) ) ; }
public void testCompareGreaterScale2 ( ) { String a = STR_ ; int aScale = NUM_ ; String b = STR_ ; int bScale = NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal bNumber = new BigDecimal ( new BigInteger ( b ) , bScale ) ; int result = - NUM_ ; assertEquals ( STR_ , result , aNumber . compareTo ( bNumber ) ) ; }
public int read ( ) throws IOException { int val ; if ( ( val = is . read ( ) ) < NUM_ ) { return - NUM_ ; } if ( bo == STR_ ) { val = ( char ) ( ( val << NUM_ ) | ( is . read ( ) & xff ) ) ; } else { val = ( char ) ( ( is . read ( ) << NUM_ ) | ( val & xff ) ) ; } return val ; }
public void cancelAutoCompletion ( ) { if ( inCompletion ) { textField . setText ( textBefore ) ; textField . setCaretPosition ( caretPosBefore ) ; prevCompletion = null ; prevCompletionIndex = NUM_ ; inCompletion = BOOL_ ; } }
private void translateMatrixAfterRotate ( int axis , float trans , float prevImageSize , float imageSize , int prevViewSize , int viewSize , int drawableSize ) { if ( imageSize < viewSize ) { m [ axis ] = ( viewSize - ( drawableSize . m [ Matrix . MSCALE_X ] ) ) . NUM_ ; } else if ( trans > NUM_ ) { m [ axis ] = - ( ( imageSize - viewSize ) . NUM_ ) ; } else { float percentage = ( Math . abs ( trans ) + ( NUM_ . prevViewSize ) ) / prevImageSize ; m [ axis ] = - ( ( percentage . imageSize ) - ( viewSize . NUM_ ) ) ; } }
public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return result . elements ( ) ; }
public ClientPropertiesBuilder withProxyHostName ( String proxyHostName ) { properties . setProperty ( CLIENT_SERVICE_PROXY_HOST_NAME , proxyHostName ) ; return this ; }
public static void verifySetterMethods ( Class < ? > clazz , MappedField ... fields ) { String methodName = null ; String fieldName = null ; Class < ? > fieldType = null ; try { for ( MappedField field : fields ) { fieldName = field . getName ( ) ; fieldType = field . getType ( ) ; String customSet = field . setMethod ( ) ; if ( ! isNull ( customSet ) && ! customSet . equals ( Constants . DEFAULT_ACCESSOR_VALUE ) ) try { clazz . getMethod ( customSet , fieldType ) ; field . setMethod ( customSet ) ; continue ; } catch ( Exception e ) { Error . customMethod ( STR_ , customSet , clazz ) ; } methodName = mSet ( fieldName ) ; clazz . getMethod ( methodName , fieldType ) ; field . setMethod ( methodName ) ; } } catch ( Exception e ) { Error . method ( methodName , fieldName , clazz ) ; } }
private E dequeue ( ) { final Object [ ] items = this . items ; @ SuppressWarnings ( STR_ ) E x = ( E ) items [ takeIndex ] ; items [ takeIndex ] = null ; takeIndex = inc ( takeIndex ) ; count -- ; if ( itrs != null ) itrs . elementDequeued ( ) ; notFull . signal ( ) ; return x ; }
static public String randomPositiveFloat ( int whole , int decimal ) { StringBuilder output = new StringBuilder ( ) ; output . append ( rnd . nextInt ( NUM_ ) + NUM_ ) ; for ( int i = NUM_ ; i < whole - NUM_ ; i ++ ) { output . append ( rnd . nextInt ( NUM_ ) ) ; } output . append ( STR_ ) ; for ( int i = NUM_ ; i < decimal ; i ++ ) { output . append ( rnd . nextInt ( NUM_ ) ) ; } return output . toString ( ) ; }
public static Variation attemptToGetAsVariant ( String part ) { try { StoneTypes var = StoneTypes . valueOf ( part . toUpperCase ( ) ) ; if ( var != null ) { Variation bv = new Variation ( ) ; bv . setValue ( var . value ( ) ) ; return bv ; } } catch ( Exception e ) { } try { WoodTypes var = WoodTypes . valueOf ( part . toUpperCase ( ) ) ; if ( var != null ) { Variation bv = new Variation ( ) ; bv . setValue ( var . value ( ) ) ; return bv ; } } catch ( Exception e ) { } try { FlowerTypes var = FlowerTypes . fromValue ( part ) ; if ( var != null ) { Variation bv = new Variation ( ) ; bv . setValue ( var . value ( ) ) ; return bv ; } } catch ( Exception e ) { } try { EntityTypes var = EntityTypes . fromValue ( part ) ; if ( var != null ) { Variation bv = new Variation ( ) ; bv . setValue ( var . value ( ) ) ; return bv ; } } catch ( Exception e ) { } try { MonsterEggTypes var = MonsterEggTypes . fromValue ( part ) ; if ( var != null ) { Variation bv = new Variation ( ) ; bv . setValue ( var . value ( ) ) ; return bv ; } } catch ( Exception e ) { } try { ShapeTypes var = ShapeTypes . fromValue ( part ) ; if ( var != null ) { Variation bv = new Variation ( ) ; bv . setValue ( var . value ( ) ) ; return bv ; } } catch ( Exception e ) { } try { HalfTypes var = HalfTypes . fromValue ( part ) ; if ( var != null ) { Variation bv = new Variation ( ) ; bv . setValue ( var . value ( ) ) ; return bv ; } } catch ( Exception e ) { } return null ; }
public void resetTextBoxIndexesExcept ( Set < Integer > excludedList ) { Set < Integer > unusedTextBoxIndexes = new HashSet < Integer > ( points . getTextBoxIndexes ( ) ) ; unusedTextBoxIndexes . removeAll ( excludedList ) ; for ( Integer index : unusedTextBoxIndexes ) { points . removeTextBox ( index ) ; } }
public IDevice learnEntity ( long macAddress , Short vlan , Integer ipv4Address , Long switchDPID , Integer switchPort , boolean processUpdates ) { List < IDeviceListener > listeners = deviceListeners . getOrderedListeners ( ) ; if ( ! processUpdates ) { deviceListeners . clearListeners ( ) ; } if ( vlan != null && vlan . shortValue ( ) <= NUM_ ) vlan = null ; if ( ipv4Address != null && ipv4Address == NUM_ ) ipv4Address = null ; IDevice res = learnDeviceByEntity ( new Entity ( macAddress , vlan , ipv4Address , switchDPID , switchPort , new Date ( ) ) ) ; if ( listeners != null ) { for ( IDeviceListener listener : listeners ) { deviceListeners . addListener ( STR_ , listener ) ; } } return res ; }
public double [ ] levelZeroData ( ) { List < Buffer > levelZeroBuffers = bufferMap . get ( NUM_ ) ; int length = NUM_ ; for ( Buffer buffer : levelZeroBuffers ) { if ( ! buffer . hasCapacity ( ) ) { length += buffer . size ; } else { length += buffer . next ; } } int pos = NUM_ ; int currLen ; final double [ ] out = new double [ length ] ; for ( Buffer buffer : levelZeroBuffers ) { if ( ! buffer . hasCapacity ( ) ) { currLen = buffer . size ; } else { currLen = buffer . next ; } System . arraycopy ( buffer . data , NUM_ , out , pos , currLen ) ; pos += currLen ; } return out ; }
private void addReference ( final int sourcePosition , final int referencePosition ) { if ( srcAndRefPositions == null ) { srcAndRefPositions = new int [ NUM_ ] ; } if ( referenceCount >= srcAndRefPositions . length ) { int [ ] a = new int [ srcAndRefPositions . length + NUM_ ] ; System . arraycopy ( srcAndRefPositions , NUM_ , a , NUM_ , srcAndRefPositions . length ) ; srcAndRefPositions = a ; } srcAndRefPositions [ referenceCount ++ ] = sourcePosition ; srcAndRefPositions [ referenceCount ++ ] = referencePosition ; }
public String [ ] showVersion ( ) throws NetworkDeviceControllerException { String [ ] returnVal = new String [ NUM_ ] ; SSHPrompt [ ] prompts = { SSHPrompt . MDS_POUND , SSHPrompt . MDS_GREATER_THAN } ; StringBuilder buf = new StringBuilder ( ) ; SSHPrompt prompt = sendWaitFor ( MDSDialogProperties . getString ( STR_ ) , NUM_ , prompts , buf ) ; String [ ] lines = getLines ( buf ) ; String [ ] regex = { MDSDialogProperties . getString ( STR_ ) , MDSDialogProperties . getString ( STR_ ) , MDSDialogProperties . getString ( STR_ ) } ; String [ ] groups = new String [ NUM_ ] ; for ( String line : lines ) { int index = match ( line , regex , groups ) ; switch ( index ) { case NUM_ : returnVal [ NUM_ ] = groups [ NUM_ ] ; break ; case NUM_ : returnVal [ NUM_ ] = groups [ NUM_ ] ; break ; case NUM_ : returnVal [ NUM_ ] = groups [ NUM_ ] ; break ; } } return returnVal ; }
public static int countMatches ( String string , char c ) { int n = NUM_ ; for ( char tc : string . toCharArray ( ) ) { if ( c == tc ) n ++ ; } return n ; }
private ImageIcon addColor ( ImageIcon icon , Color color ) { if ( icon == null || color == null ) { return icon ; } BufferedImage newImage = new BufferedImage ( icon . getIconWidth ( ) , icon . getIconWidth ( ) , BufferedImage . TYPE_INT_ARGB ) ; Graphics g = newImage . getGraphics ( ) ; g . setColor ( color ) ; g . drawImage ( icon . getImage ( ) , NUM_ , NUM_ , color , null ) ; g . dispose ( ) ; return new ImageIcon ( newImage ) ; }
public static byte [ ] readAllLimited ( InputStream inStr , int limit ) throws IOException { ByteArrayOutputStream buf = new ByteArrayOutputStream ( ) ; pipeAllLimited ( inStr , limit , buf ) ; return buf . toByteArray ( ) ; }
protected String searchFor ( final String target , String start ) { return searchFor ( target , null , start ) ; }
private int validatePreloadOrder ( CacheConfiguration [ ] cfgs ) throws IgniteCheckedException { int maxOrder = NUM_ ; for ( CacheConfiguration cfg : cfgs ) { int rebalanceOrder = cfg . getRebalanceOrder ( ) ; if ( rebalanceOrder > NUM_ ) { if ( cfg . getCacheMode ( ) == LOCAL ) throw new IgniteCheckedException ( STR_ + STR_ + U . maskName ( cfg . getName ( ) ) ) ; if ( cfg . getRebalanceMode ( ) == CacheRebalanceMode . NONE ) throw new IgniteCheckedException ( STR_ + STR_ + U . maskName ( cfg . getName ( ) ) + STR_ + cfg . getRebalanceMode ( ) + STR_ + cfg . getRebalanceOrder ( ) + STR_ ) ; maxOrder = Math . max ( maxOrder , rebalanceOrder ) ; } else if ( rebalanceOrder < NUM_ ) throw new IgniteCheckedException ( STR_ + STR_ + U . maskName ( cfg . getName ( ) ) + STR_ + rebalanceOrder + STR_ ) ; } return maxOrder ; }
public void execute ( ) { mPlayer . setLoopMode ( mDoLoop ) ; mThread = new Thread ( this , STR_ ) ; mThread . start ( ) ; }
@ Override public void removeEnvVar ( EnvVar envVar ) { if ( envVar != null ) { envVarList . remove ( envVar ) ; } }
static private String calcThreshold ( double scoreThreshold , double lambda ) { final double logProbThreshold = Math . log ( NUM_ - scoreThreshold / NUM_ ) ; int maxNum = NUM_ ; if ( calcLogProb ( maxNum , lambda ) > logProbThreshold ) { return STR_ ; } int minNum = NUM_ ; while ( minNum < maxNum ) { final int midNum = ( maxNum + minNum ) / NUM_ ; final boolean passThreshold = calcLogProb ( midNum , lambda ) <= logProbThreshold ; if ( passThreshold ) { maxNum = midNum ; } else { if ( midNum == minNum ) { break ; } minNum = midNum ; } } return Integer . toString ( maxNum ) ; }
private Scope peek ( ) throws JSONException { if ( stack . isEmpty ( ) ) { throw new JSONException ( STR_ ) ; } return stack . get ( stack . size ( ) - NUM_ ) ; }
public void testIsSigned ( ) { try { assertFalse ( rsmd . isSigned ( NUM_ ) ) ; } catch ( SQLException e1 ) { fail ( STR_ + e1 . getMessage ( ) ) ; e1 . printStackTrace ( ) ; } try { rsmd . isSigned ( NUM_ ) ; fail ( STR_ ) ; } catch ( SQLException e ) { } }
public static int indexOfLastSeparator ( String filename ) { if ( filename == null ) return - NUM_ ; int lastUnixPos = filename . lastIndexOf ( UNIX_SEPARATOR ) ; int lastWindowsPos = filename . lastIndexOf ( WINDOWS_SEPARATOR ) ; return Math . max ( lastUnixPos , lastWindowsPos ) ; }
public static boolean pointInView ( View v , float localX , float localY , float slop ) { return localX >= - slop && localY >= - slop && localX < ( v . getWidth ( ) + slop ) && localY < ( v . getHeight ( ) + slop ) ; }
@ Category ( FlakyTest . class ) @ Test public void test_FPAmetadataFetch ( ) { final Host host = Host . getHost ( NUM_ ) ; VM server1 = host . getVM ( NUM_ ) ; VM server2 = host . getVM ( NUM_ ) ; VM server3 = host . getVM ( NUM_ ) ; VM server4 = host . getVM ( NUM_ ) ; Boolean simpleFPR = BOOL_ ; final int portLocator = AvailablePort . getRandomAvailablePort ( AvailablePort . SOCKET ) ; final String hostLocator = NetworkUtils . getServerHostName ( server1 . getHost ( ) ) ; final String locator = hostLocator + STR_ + portLocator + STR_ ; server3 . invoke ( null ) ; try { List < FixedPartitionAttributes > fpaList = new ArrayList < FixedPartitionAttributes > ( ) ; fpaList . add ( FixedPartitionAttributes . createFixedPartition ( STR_ , BOOL_ , NUM_ ) ) ; fpaList . add ( FixedPartitionAttributes . createFixedPartition ( STR_ , BOOL_ , NUM_ ) ) ; Integer port1 = ( Integer ) server1 . invoke ( null ) ; fpaList . clear ( ) ; fpaList . add ( FixedPartitionAttributes . createFixedPartition ( STR_ , BOOL_ , NUM_ ) ) ; Integer port2 = ( Integer ) server2 . invoke ( null ) ; fpaList . clear ( ) ; createClientWithLocator ( hostLocator , portLocator ) ; putIntoPartitionedRegionsThreeQs ( ) ; getFromPartitionedRegionsFor3Qs ( ) ; Wait . pause ( NUM_ ) ; server1 . invoke ( null ) ; server2 . invoke ( null ) ; int totalBucketOnServer = NUM_ ; totalBucketOnServer += ( Integer ) server1 . invoke ( null ) ; totalBucketOnServer += ( Integer ) server2 . invoke ( null ) ; int currentRedundancy = NUM_ ; verifyMetadata ( totalBucketOnServer , currentRedundancy ) ; updateIntoSinglePRFor3Qs ( ) ; fpaList . clear ( ) ; fpaList . add ( FixedPartitionAttributes . createFixedPartition ( STR_ , BOOL_ , NUM_ ) ) ; fpaList . add ( FixedPartitionAttributes . createFixedPartition ( STR_ , BOOL_ , NUM_ ) ) ; fpaList . add ( FixedPartitionAttributes . createFixedPartition ( STR_ , BOOL_ , NUM_ ) ) ; fpaList . add ( FixedPartitionAttributes . createFixedPartition ( STR_ , BOOL_ , NUM_ ) ) ; Integer port4 = ( Integer ) server4 . invoke ( null ) ; Wait . pause ( NUM_ ) ; putIntoPartitionedRegions ( ) ; getFromPartitionedRegions ( ) ; Wait . pause ( NUM_ ) ; server1 . invoke ( null ) ; server2 . invoke ( null ) ; server4 . invoke ( null ) ; totalBucketOnServer = NUM_ ; totalBucketOnServer += ( Integer ) server1 . invoke ( null ) ; totalBucketOnServer += ( Integer ) server2 . invoke ( null ) ; totalBucketOnServer += ( Integer ) server4 . invoke ( null ) ; updateIntoSinglePR ( ) ; } finally { server3 . invoke ( null ) ; } }
private static Type [ ] unrollBounds ( final Map < TypeVariable < ? > , Type > typeArguments , final Type [ ] bounds ) { Type [ ] result = bounds ; int i = NUM_ ; for ( ; i < result . length ; i ++ ) { final Type unrolled = unrollVariables ( typeArguments , result [ i ] ) ; if ( unrolled == null ) { result = ArrayUtils . remove ( result , i -- ) ; } else { result [ i ] = unrolled ; } } return result ; }
public void deleteQuota ( String id ) throws IsilonException { delete ( _baseUrl . resolve ( URI_QUOTAS ) , id , STR_ ) ; }
public Criteria or ( ) { Criteria criteria = createCriteriaInternal ( ) ; oredCriteria . add ( criteria ) ; return criteria ; }
public static Map < String , String > createBasicAuthHeader ( String username , String password , Map < String , String > headerMap ) { if ( headerMap == null ) headerMap = new HashMap < > ( ) ; String credentials = username + STR_ + password ; String base64EncodedCredentials = Base64 . encodeToString ( credentials . getBytes ( ) , Base64 . NO_WRAP ) ; headerMap . put ( STR_ , STR_ + base64EncodedCredentials ) ; return headerMap ; }
private void addExtentEntry ( ) { extentModel . addNewEntry ( ) ; removeExtentButton . setEnabled ( BOOL_ ) ; }
private TransportNetwork checkCached ( String networkId ) { try { String filename = networkId + STR_ + R5Version . version + STR_ ; File cacheLocation = new File ( cacheDir , networkId + STR_ + R5Version . version + STR_ ) ; if ( cacheLocation . exists ( ) ) LOG . info ( STR_ , cacheLocation ) ; else { LOG . info ( STR_ , cacheLocation ) ; if ( sourceBucket != null ) { LOG . info ( STR_ ) ; S3Object tn ; try { tn = s3 . getObject ( sourceBucket , filename ) ; } catch ( AmazonServiceException ex ) { LOG . info ( STR_ ) ; return null ; } cacheDir . mkdirs ( ) ; LOG . info ( STR_ , cacheLocation ) ; FileOutputStream fos = new FileOutputStream ( cacheLocation ) ; InputStream is = tn . getObjectContent ( ) ; try { ByteStreams . copy ( is , fos ) ; } finally { is . close ( ) ; fos . close ( ) ; } } else { LOG . info ( STR_ ) ; return null ; } } LOG . info ( STR_ , cacheLocation ) ; FileInputStream fis = new FileInputStream ( cacheLocation ) ; try { return TransportNetwork . read ( fis ) ; } finally { fis . close ( ) ; } } catch ( Exception e ) { LOG . error ( STR_ , e ) ; return null ; } }
public int countTokens ( ) { int count = NUM_ ; boolean inToken = BOOL_ ; for ( int i = position , length = string . length ( ) ; i < length ; i ++ ) { if ( delimiters . indexOf ( string . charAt ( i ) , NUM_ ) >= NUM_ ) { if ( returnDelimiters ) count ++ ; if ( inToken ) { count ++ ; inToken = BOOL_ ; } } else { inToken = BOOL_ ; } } if ( inToken ) count ++ ; return count ; }
void readFile ( File file ) throws org . jdom2 . JDOMException , java . io . IOException { XmlFile xf = new XmlFile ( ) { } ; xf . rootFromFile ( file ) ; }
public boolean isAllGranted ( ) { int count = NUM_ ; for ( int i = NUM_ ; i < mPerms . size ( ) ; i ++ ) { if ( mPerms . get ( mUserPermission . get ( i ) ) == PackageManager . PERMISSION_GRANTED ) count ++ ; } return count == mPerms . size ( ) ; }
protected void execute ( Runnable evt ) { executor . execute ( evt ) ; }
private void sendNextMessageOverNetwork ( ) throws Exception { RawData raw = outgoing . take ( ) ; if ( raw == null ) throw new NullPointerException ( ) ; sendNext ( raw ) ; }
@ Override protected void onSizeChanged ( int w , int h , int oldw , int oldh ) { super . onSizeChanged ( w , h , oldw , oldh ) ; setupBounds ( w , h ) ; setupPaints ( ) ; invalidate ( ) ; }
public void addAttributeFor ( final Field field ) { fieldToUseAsAttribute . add ( field ) ; }
public boolean isSessionToken ( String token ) { synchronized ( sessionTokens ) { return sessionTokens . contains ( token ) ; } }
public static double rootMeansSquaredError ( double [ ] real , double [ ] predicted ) { double ret = NUM_ ; for ( int i = NUM_ ; i < real . length ; i ++ ) { ret += Math . pow ( ( real [ i ] - predicted [ i ] ) , NUM_ ) ; } return Math . sqrt ( ret / real . length ) ; }
public void export ( ByteBuffer buf ) { buf . putInt ( seqId ) ; if ( info . isRowBlockEnabled ( ) ) buf . putInt ( nRows ) ; export ( primaryKey , buf ) ; for ( ByteArray cb : cellBlocks ) { export ( cb , buf ) ; } }
private HashMap < String , Object > createAccDetailmap ( String glcode , BigDecimal debitAmount , BigDecimal creditAmount ) { HashMap < String , Object > accountdetailmap = new HashMap < String , Object > ( ) ; accountdetailmap . put ( VoucherConstant . GLCODE , glcode ) ; accountdetailmap . put ( VoucherConstant . DEBITAMOUNT , debitAmount ) ; accountdetailmap . put ( VoucherConstant . CREDITAMOUNT , creditAmount ) ; accountdetailmap . put ( VoucherConstant . FUNCTIONCODE , getFunctionaryCode ( ) ) ; return accountdetailmap ; }
private void rotateRight ( Node < K , V > root ) { Node < K , V > pivot = root . left ; Node < K , V > right = root . right ; Node < K , V > pivotLeft = pivot . left ; Node < K , V > pivotRight = pivot . right ; root . left = pivotRight ; if ( pivotRight != null ) { pivotRight . parent = root ; } replaceInParent ( root , pivot ) ; pivot . right = root ; root . parent = pivot ; root . height = Math . max ( right != null ? right . height : NUM_ , pivotRight != null ? pivotRight . height : NUM_ ) + NUM_ ; pivot . height = Math . max ( root . height , pivotLeft != null ? pivotLeft . height : NUM_ ) + NUM_ ; }
private void updateRadioLinks ( ) { m_advanceDataSetFirst . setEnabled ( m_GeneratorPropertyPanel . getEditorActive ( ) ) ; m_advanceIteratorFirst . setEnabled ( m_GeneratorPropertyPanel . getEditorActive ( ) ) ; if ( m_Exp != null ) { if ( ! m_GeneratorPropertyPanel . getEditorActive ( ) ) { m_Exp . setAdvanceDataSetFirst ( BOOL_ ) ; } else { m_Exp . setAdvanceDataSetFirst ( m_advanceDataSetFirst . isSelected ( ) ) ; } } }
public void update ( long value ) { count . incrementAndGet ( ) ; sample . update ( value ) ; setMax ( value ) ; setMin ( value ) ; sum . getAndAdd ( value ) ; updateVariance ( value ) ; }
@ Override public void drawSeries ( Canvas canvas , Paint paint , List < Float > points , XYSeriesRenderer renderer , float yAxisValue , int seriesIndex , int startIndex ) { paint . setColor ( renderer . getColor ( ) ) ; paint . setStyle ( Style . FILL ) ; int length = points . size ( ) ; XYValueSeries series = ( XYValueSeries ) mDataset . getSeriesAt ( seriesIndex ) ; double max = series . getMaxValue ( ) ; double coef = MAX_BUBBLE_SIZE / max ; for ( int i = NUM_ ; i < length ; i += NUM_ ) { double size = series . getValue ( startIndex + i / NUM_ ) . coef + MIN_BUBBLE_SIZE ; drawCircle ( canvas , paint , points . get ( i ) , points . get ( i + NUM_ ) , ( float ) size ) ; } }
public static void checkClassSignature ( final String signature ) { int pos = NUM_ ; if ( getChar ( signature , NUM_ ) == STR_ ) { pos = checkFormalTypeParameters ( signature , pos ) ; } pos = checkClassTypeSignature ( signature , pos ) ; while ( getChar ( signature , pos ) == STR_ ) { pos = checkClassTypeSignature ( signature , pos ) ; } if ( pos != signature . length ( ) ) { throw new IllegalArgumentException ( signature + STR_ + pos ) ; } }
public static byte [ ] select ( String appId , String suffix ) { String cardletAid = FIDESMO_AID_PREFIX + appId + suffix ; return select ( cardletAid ) ; }
public List < Properties > findAvailableProperties ( String uri ) throws IOException { _resourcesNotLoaded . clear ( ) ; String fulluri = _path + uri ; List < Properties > properties = new ArrayList < > ( ) ; Enumeration < URL > resources = getResources ( fulluri ) ; while ( resources . hasMoreElements ( ) ) { URL url = resources . nextElement ( ) ; try { Properties props = loadProperties ( url ) ; properties . add ( props ) ; } catch ( Exception notAvailable ) { _resourcesNotLoaded . add ( url . toExternalForm ( ) ) ; } } return properties ; }
void internalAddRootEntry ( ProjectComparisonEntry entry ) { entries . add ( entry ) ; }
public static Source fromURL ( URL url , Charset cs ) throws IOException { URI uri ; try { uri = url . toURI ( ) ; } catch ( URISyntaxException e ) { throw new IOException ( STR_ , e ) ; } try ( InputStream is = url . openStream ( ) ) { return fromStream ( is , uri , cs ) ; } }
public synchronized void addZoomListener ( ZoomListener listener ) { mZoomListeners . add ( listener ) ; }
public void testMergeOneServletIntoDocumentWithAnotherServlet ( ) throws Exception { String srcXml = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; WebXml srcWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( srcXml . getBytes ( STR_ ) ) , null ) ; String mergeXml = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; WebXml mergeWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( mergeXml . getBytes ( STR_ ) ) , null ) ; WebXmlMerger merger = new WebXmlMerger ( srcWebXml ) ; merger . merge ( mergeWebXml ) ; assertTrue ( WebXmlUtils . hasServlet ( srcWebXml , STR_ ) ) ; assertTrue ( WebXmlUtils . hasServlet ( srcWebXml , STR_ ) ) ; }
public RE extractRE ( ) throws InterruptedException { arden ( ) ; if ( ! coeffs . isEmpty ( ) ) { throw new RuntimeException ( STR_ ) ; } return unionREs ( terms ) ; }
@ Deprecated public static void runFinalizersOnExit ( boolean run ) { finalizeOnExit = run ; }
public void addResult ( AMIdentity id , Map attrs ) { searchResults . add ( id ) ; resultsMap . put ( id , attrs ) ; }
public < T extends IntentionAction & LocalQuickFix > void registerBatchFix ( @ NotNull T fix , @ Nullable TextRange range , @ Nullable final HighlightDisplayKey key ) { if ( range == null ) { range = new TextRange ( myStartOffset , myEndOffset ) ; } if ( myBatchFixes == null ) { myBatchFixes = new ArrayList < QuickFixInfo > ( ) ; } myBatchFixes . add ( new QuickFixInfo ( fix , range , key ) ) ; }
protected void createFile ( ZipEntry entry ) { IPath pathname = new Path ( entry . getName ( ) ) ; ZipEntry parent ; if ( pathname . segmentCount ( ) == NUM_ ) { parent = root ; } else { parent = ( ZipEntry ) directoryEntryCache . get ( pathname . removeLastSegments ( NUM_ ) ) ; } addToChildren ( parent , entry ) ; }
public void testHasAttributes1 ( ) throws Throwable { Document doc ; NodeList addrList ; Node addrNode ; boolean state ; doc = ( Document ) load ( STR_ , builder ) ; addrList = doc . getElementsByTagName ( STR_ ) ; addrNode = addrList . item ( NUM_ ) ; state = addrNode . hasAttributes ( ) ; assertFalse ( STR_ , state ) ; }
public void startDocument ( XMLLocator locator , String encoding , NamespaceContext namespaceContext , Augmentations augs ) throws XNIException { fNamespaceContext = namespaceContext ; try { if ( fDocumentHandler != null ) { if ( locator != null ) { fDocumentHandler . setDocumentLocator ( new LocatorProxy ( locator ) ) ; } fDocumentHandler . startDocument ( ) ; } if ( fContentHandler != null ) { if ( locator != null ) { fContentHandler . setDocumentLocator ( new LocatorProxy ( locator ) ) ; } fContentHandler . startDocument ( ) ; } } catch ( SAXException e ) { throw new XNIException ( e ) ; } }
@ Override public String dumpWindowHierarchy ( boolean compressed ) { device . setCompressedLayoutHeirarchy ( compressed ) ; try { ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; device . dumpWindowHierarchy ( os ) ; os . close ( ) ; return os . toString ( STR_ ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { device . setCompressedLayoutHeirarchy ( BOOL_ ) ; } return null ; }
public void registerObserver ( RuleChangesObserver observer ) { observers . add ( observer ) ; }
private void sendUpdateHeartbeats ( ) { HeartbeatServiceLocal heartbeat = _bartender . getHeartbeatLocal ( ) ; if ( heartbeat != null ) { heartbeat . updateHeartbeats ( ) ; } }
public void serialize ( String name , byte [ ] message , OutputStream out ) throws IOException { byte [ ] header = new byte [ NUM_ + COMMAND_LEN + NUM_ + NUM_ ] ; uint32ToByteArrayBE ( params . getPacketMagic ( ) , header , NUM_ ) ; for ( int i = NUM_ ; i < name . length ( ) && i < COMMAND_LEN ; i ++ ) { header [ NUM_ + i ] = ( byte ) ( name . codePointAt ( i ) & xFF ) ; } Utils . uint32ToByteArrayLE ( message . length , header , NUM_ + COMMAND_LEN ) ; byte [ ] hash = doubleDigest ( message ) ; System . arraycopy ( hash , NUM_ , header , NUM_ + COMMAND_LEN + NUM_ , NUM_ ) ; out . write ( header ) ; out . write ( message ) ; if ( log . isDebugEnabled ( ) ) log . debug ( STR_ , name , bytesToHexString ( header ) + bytesToHexString ( message ) ) ; }
public SSLEngine initSslEngine ( boolean client ) throws Exception { KeyStore keyStore = loadKeystore ( properties . sslKeyStorePath ( ) , properties . sslKeyStorePassword ( ) ) ; KeyManagerFactory keyManagerFactory = KeyManagerFactory . getInstance ( KeyManagerFactory . getDefaultAlgorithm ( ) ) ; keyManagerFactory . init ( keyStore , keyStoreKeyPass ( properties ) ) ; KeyStore trustStore ; if ( properties . sslTrustStorePath ( ) != null ) { LOGGER . debug ( STR_ ) ; trustStore = loadKeystore ( properties . sslTrustStorePath ( ) , properties . sslTrustStorePassword ( ) ) ; } else { trustStore = keyStore ; LOGGER . debug ( STR_ ) ; } TrustManagerFactory trustManagerFactory = TrustManagerFactory . getInstance ( TrustManagerFactory . getDefaultAlgorithm ( ) ) ; trustManagerFactory . init ( trustStore ) ; KeyManager [ ] keyManagers = keyManagerFactory . getKeyManagers ( ) ; TrustManager [ ] trustManagers = trustManagerFactory . getTrustManagers ( ) ; SSLContext sslContext = SSLContext . getInstance ( STR_ ) ; sslContext . init ( keyManagers , trustManagers , null ) ; SSLEngine sslEngine = sslContext . createSSLEngine ( ) ; sslEngine . setUseClientMode ( client ) ; sslEngine . setWantClientAuth ( BOOL_ ) ; sslEngine . setEnabledProtocols ( sslEngine . getSupportedProtocols ( ) ) ; sslEngine . setEnabledCipherSuites ( sslEngine . getSupportedCipherSuites ( ) ) ; sslEngine . setEnableSessionCreation ( BOOL_ ) ; return sslEngine ; }
public GetBufferedRandomAccessSource ( IRandomAccessSource source ) { this . source = source ; this . getBuffer = new byte [ ( int ) Math . min ( Math . max ( source . length ( ) / NUM_ , NUM_ ) , NUM_ ) ] ; this . getBufferStart = - NUM_ ; this . getBufferEnd = - NUM_ ; }
public ArgParser ( String pName ) { programName = pName ; args = new Vector ( ) ; args . add ( new HelpArg ( ) ) ; }
public void testSetBitZero ( ) { byte aBytes [ ] = { NUM_ } ; int aSign = NUM_ ; int number = NUM_ ; byte rBytes [ ] = { NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger result = aNumber . setBit ( number ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public static String convertBooleanArrToString ( Boolean [ ] noDictionaryDimsMapping ) { StringBuilder builder = new StringBuilder ( ) ; int index = NUM_ ; for ( ; index < noDictionaryDimsMapping . length ; index ++ ) { builder . append ( noDictionaryDimsMapping [ index ] ) ; builder . append ( CarbonCommonConstants . COMA_SPC_CHARACTER ) ; } int lastIndex = builder . lastIndexOf ( CarbonCommonConstants . COMA_SPC_CHARACTER ) ; String str = - NUM_ != lastIndex ? builder . substring ( NUM_ , lastIndex ) : builder . toString ( ) ; return str ; }
@ Override protected void drawAxisLine ( Graphics2D g2 , double cursor , Rectangle2D dataArea , RectangleEdge edge ) { Line2D axisLine = null ; double c = cursor ; if ( edge == RectangleEdge . TOP ) { axisLine = new Line2D . Double ( dataArea . getX ( ) , c , dataArea . getMaxX ( ) , c ) ; } else if ( edge == RectangleEdge . BOTTOM ) { axisLine = new Line2D . Double ( dataArea . getX ( ) , c , dataArea . getMaxX ( ) , c ) ; } else if ( edge == RectangleEdge . LEFT ) { axisLine = new Line2D . Double ( c , dataArea . getY ( ) , c , dataArea . getMaxY ( ) ) ; } else if ( edge == RectangleEdge . RIGHT ) { axisLine = new Line2D . Double ( c , dataArea . getY ( ) , c , dataArea . getMaxY ( ) ) ; } g2 . setPaint ( getAxisLinePaint ( ) ) ; g2 . setStroke ( getAxisLineStroke ( ) ) ; Object saved = g2 . getRenderingHint ( RenderingHints . KEY_STROKE_CONTROL ) ; g2 . setRenderingHint ( RenderingHints . KEY_STROKE_CONTROL , RenderingHints . VALUE_STROKE_NORMALIZE ) ; g2 . draw ( axisLine ) ; g2 . setRenderingHint ( RenderingHints . KEY_STROKE_CONTROL , saved ) ; boolean drawUpOrRight = BOOL_ ; boolean drawDownOrLeft = BOOL_ ; if ( this . positiveArrowVisible ) { if ( this . inverted ) { drawDownOrLeft = BOOL_ ; } else { drawUpOrRight = BOOL_ ; } } if ( this . negativeArrowVisible ) { if ( this . inverted ) { drawUpOrRight = BOOL_ ; } else { drawDownOrLeft = BOOL_ ; } } if ( drawUpOrRight ) { double x = NUM_ ; double y = NUM_ ; Shape arrow = null ; if ( edge == RectangleEdge . TOP || edge == RectangleEdge . BOTTOM ) { x = dataArea . getMaxX ( ) ; y = cursor ; arrow = this . rightArrow ; } else if ( edge == RectangleEdge . LEFT || edge == RectangleEdge . RIGHT ) { x = cursor ; y = dataArea . getMinY ( ) ; arrow = this . upArrow ; } AffineTransform transformer = new AffineTransform ( ) ; transformer . setToTranslation ( x , y ) ; Shape shape = transformer . createTransformedShape ( arrow ) ; g2 . fill ( shape ) ; g2 . draw ( shape ) ; } if ( drawDownOrLeft ) { double x = NUM_ ; double y = NUM_ ; Shape arrow = null ; if ( edge == RectangleEdge . TOP || edge == RectangleEdge . BOTTOM ) { x = dataArea . getMinX ( ) ; y = cursor ; arrow = this . leftArrow ; } else if ( edge == RectangleEdge . LEFT || edge == RectangleEdge . RIGHT ) { x = cursor ; y = dataArea . getMaxY ( ) ; arrow = this . downArrow ; } AffineTransform transformer = new AffineTransform ( ) ; transformer . setToTranslation ( x , y ) ; Shape shape = transformer . createTransformedShape ( arrow ) ; g2 . fill ( shape ) ; g2 . draw ( shape ) ; } }
public static void saveXStream ( File saveTo , Object model , Instances header ) throws Exception { Vector < Object > v = new Vector < Object > ( ) ; v . add ( model ) ; if ( header != null ) { v . add ( header ) ; } v . trimToSize ( ) ; XStream . write ( saveTo . getAbsolutePath ( ) , v ) ; }
private void sortAndCollapse ( ) { Collections . sort ( mSpans ) ; mAddsSinceSort = NUM_ ; Iterator iter = mSpans . iterator ( ) ; Span span = null ; if ( iter . hasNext ( ) ) { span = ( Span ) iter . next ( ) ; } while ( iter . hasNext ( ) ) { Span nextSpan = ( Span ) iter . next ( ) ; if ( span . subsume ( nextSpan ) ) { iter . remove ( ) ; } else { span = nextSpan ; } } }
public int splitRandomly ( ArrayModifiableDBIDs ind , int begin , int end , DoubleDataStore tpro , Random rand ) { final int nele = end - begin ; DBIDArrayIter it = ind . iter ( ) ; double rs = tpro . doubleValue ( it . seek ( begin + rand . nextInt ( nele ) ) ) ; int minInd = begin , maxInd = end - NUM_ ; while ( minInd < maxInd ) { double currEle = tpro . doubleValue ( it . seek ( minInd ) ) ; if ( currEle > rs ) { while ( minInd < maxInd && tpro . doubleValue ( it . seek ( maxInd ) ) > rs ) { maxInd -- ; } if ( minInd == maxInd ) { break ; } ind . swap ( minInd , maxInd ) ; maxInd -- ; } minInd ++ ; } if ( minInd == end - NUM_ ) { minInd = ( begin + end ) > > > NUM_ ; } return minInd ; }
public static String noPrefix ( String path , String prefix ) { Objects . requireNonNull ( path , STR_ ) ; Objects . requireNonNull ( prefix , STR_ ) ; return path . startsWith ( prefix ) ? path . substring ( prefix . length ( ) ) : path ; }
protected void publish ( ) throws MqttException , IOException { sampleClientPub = new SampleAsyncCallback ( url , clientIdPub , cleanSession , quietMode , userName , password ) ; if ( sampleClientPub != null ) { String topic = STR_ ; int qos = NUM_ ; String message = STR_ ; try { sampleClientPub . publish ( topic , qos , message . getBytes ( ) ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; } } }
public void remove ( IAdaptable a ) { children . remove ( a ) ; }
public static IntStream concat ( IntStream a , IntStream b ) { Objects . requireNonNull ( a ) ; Objects . requireNonNull ( b ) ; Spliterator . OfInt split = new Streams . ConcatSpliterator . OfInt ( a . spliterator ( ) , b . spliterator ( ) ) ; IntStream stream = StreamSupport . intStream ( split , a . isParallel ( ) || b . isParallel ( ) ) ; return stream . onClose ( Streams . composedClose ( a , b ) ) ; }
public boolean equals ( String expected , String actual ) { return framework . equals ( expected , actual ) ; }
public LoginConfiguration forceAuth ( String forceAuthReqParam ) { forceAuth = Boolean . parseBoolean ( forceAuthReqParam ) ; return this ; }
public UserConfig fetch ( UserConfig config ) { config . addCredentials ( this ) ; String xml = POST ( this . url + STR_ , config . toXML ( ) ) ; Element root = parse ( xml ) ; if ( root == null ) { return null ; } try { UserConfig user = new UserConfig ( ) ; user . parseXML ( root ) ; return user ; } catch ( Exception exception ) { this . exception = SDKException . parseFailure ( exception ) ; throw this . exception ; } }
@ MethodDesc ( description = STR_ , usage = STR_ ) public void stop ( ) throws Exception { try { handleEventSynchronous ( new StopEvent ( ) ) ; if ( doneLatch != null ) { doneLatch . countDown ( ) ; } } catch ( Exception e ) { logger . error ( STR_ , e ) ; throw new Exception ( e . toString ( ) ) ; } }
public void dispose ( ) throws IabAsyncInProgressException { synchronized ( mAsyncInProgressLock ) { if ( mAsyncInProgress ) { throw new IabAsyncInProgressException ( STR_ + STR_ + mAsyncOperation + STR_ ) ; } } logDebug ( STR_ ) ; mSetupDone = BOOL_ ; if ( mServiceConn != null ) { logDebug ( STR_ ) ; if ( mContext != null ) mContext . unbindService ( mServiceConn ) ; } mDisposed = BOOL_ ; mContext = null ; mServiceConn = null ; mService = null ; mPurchaseListener = null ; }
@ Override public void pushMessageAsync ( Message msg ) throws org . apache . thrift . TException { pushMessageSync ( msg ) ; return ; }
public boolean writeCharacteristic ( String address , String serviceUUID , String characteristicUUID , byte [ ] value ) { BluetoothGatt bluetoothGatt = mBluetoothGattMap . get ( address ) ; if ( bluetoothGatt != null ) { BluetoothGattService service = bluetoothGatt . getService ( UUID . fromString ( serviceUUID ) ) ; BluetoothGattCharacteristic characteristic = service . getCharacteristic ( UUID . fromString ( characteristicUUID ) ) ; characteristic . setValue ( value ) ; return bluetoothGatt . writeCharacteristic ( characteristic ) ; } return BOOL_ ; }
public String linkForMessage ( ProtoElement element ) { if ( isExternalFile ( element . getFile ( ) ) ) { String fullName = element . getFullName ( ) ; return String . format ( STR_ , fullName , fullName ) ; } else { String simpleName = element . getSimpleName ( ) ; return String . format ( STR_ , simpleName , simpleName ) ; } }
public static < T > ArrayList < T > read ( InputStream fileStream , String charsetName , ITransformer < String , T > transformer ) throws FileNotFoundException { Scanner scanner = new Scanner ( fileStream , charsetName ) ; ArrayList < T > list = new ArrayList < > ( ) ; while ( scanner . hasNextLine ( ) ) { String line = scanner . nextLine ( ) ; list . add ( transformer . transform ( line ) ) ; } scanner . close ( ) ; return list ; }
public boolean remove ( JsonElement element ) { return elements . remove ( element ) ; }
public TSink < byte [ ] > sendBytes ( TStream < byte [ ] > stream ) { Objects . requireNonNull ( stream , STR_ ) ; return sendBinary ( stream , null ) ; }
private void sortBrokerItems ( BrokerItem [ ] brokerItems , int sortType ) { Arrays . sort ( brokerItems , BrokerItem . getComparatoryByType ( sortType ) ) ; }
protected boolean needToEscapeXMLSpecialCharacters ( String hostEntityID , String remoteEntityID , String realm ) { return BOOL_ ; }
private void updatePathConstraints ( TestChromosome test ) { List < BranchCondition > pathCondition = ConcolicExecution . getSymbolicPath ( test ) ; pathConditions . put ( test , pathCondition ) ; }
public void test_journal_oneIndexNoData ( ) throws IOException , InterruptedException , ExecutionException { final File out = File . createTempFile ( getName ( ) , Options . JNL ) ; try { final Journal src = getStore ( getProperties ( ) ) ; try { final String NAME = STR_ ; src . registerIndex ( new IndexMetadata ( NAME , UUID . randomUUID ( ) ) ) ; src . commit ( ) ; final Future < Journal > f = src . compact ( out ) ; final Journal newJournal = f . get ( ) ; try { assertNotNull ( newJournal . getIndex ( NAME ) ) ; AbstractBTreeTestCase . assertSameBTree ( src . getIndex ( NAME ) , newJournal . getIndex ( NAME ) ) ; } finally { newJournal . destroy ( ) ; } } finally { src . destroy ( ) ; } } finally { out . delete ( ) ; } }
public static boolean p2pLoader ( ClassLoader ldr ) { return ldr instanceof GridDeploymentInfo ; }
private static String removeSubTrailers ( String decodedSubject ) { int subStringStart = NUM_ ; int subStringEnd = decodedSubject . length ( ) ; int originalSize = decodedSubject . length ( ) ; int curPos = originalSize - NUM_ ; while ( BOOL_ ) { char c = decodedSubject . charAt ( curPos -- ) ; if ( c == WS ) { subStringEnd -- ; } else { if ( subStringEnd > FWD_PARENS . length ( ) && decodedSubject . endsWith ( FWD_PARENS ) ) { subStringEnd -= FWD_PARENS . length ( ) ; } break ; } } decodedSubject = decodedSubject . substring ( subStringStart , subStringEnd ) ; return decodedSubject ; }
public Criteria or ( ) { Criteria criteria = createCriteriaInternal ( ) ; oredCriteria . add ( criteria ) ; return criteria ; }
boolean nextSource ( ) throws IOException { if ( mSourceIt . hasNext ( ) ) { final InputStream is = mSourceIt . next ( ) ; if ( is == null ) { mSource = null ; return BOOL_ ; } else { mSource = new BufferedInputStream ( is , FileUtils . BUFFERED_STREAM_SIZE ) ; } mSourceClosed = BOOL_ ; mInputBufferPosition = NUM_ ; mInputBufferLength = NUM_ ; mBufferLength = NUM_ ; mBufferPosition = NUM_ ; return BOOL_ ; } if ( mSource != null ) { mSource . close ( ) ; } mSource = null ; return BOOL_ ; }
public static byte [ ] bitmapToBytes ( Bitmap bm ) { byte [ ] bytes = null ; if ( bm != null ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; bm . compress ( Bitmap . CompressFormat . PNG , NUM_ , baos ) ; bytes = baos . toByteArray ( ) ; } return bytes ; }
public static String inflate ( String name ) { return inflate ( name , gPrefix ) ; }
public void addPriorityHandler ( WarningHandler handler ) { _priorityHandlers . add ( handler ) ; }
private synchronized void readObject ( java . io . ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; init ( getMask ( actions ) ) ; }
public void printLenString ( String v ) throws IOException { if ( v == null ) { os . write ( NUM_ ) ; os . write ( NUM_ ) ; } else { int len = v . length ( ) ; os . write ( len > > NUM_ ) ; os . write ( len ) ; printString ( v , NUM_ , len ) ; } }
private float clampMag ( float value , float absMin , float absMax ) { final float absValue = Math . abs ( value ) ; if ( absValue < absMin ) return NUM_ ; if ( absValue > absMax ) return value > NUM_ ? absMax : - absMax ; return value ; }
private void writeAttr ( String name , String val ) throws IOException { writeAttr ( name , val , BOOL_ ) ; }
final private String syntaxDef2SyntaxDesc ( Attributes attrs ) throws NamingException { StringBuffer syntaxDesc = new StringBuffer ( STR_ ) ; Attribute attr = null ; int count = NUM_ ; attr = attrs . get ( NUMERICOID_ID ) ; if ( attr != null ) { syntaxDesc . append ( writeNumericOID ( attr ) ) ; count ++ ; } else { throw new ConfigurationException ( STR_ + STR_ ) ; } attr = attrs . get ( DESC_ID ) ; if ( attr != null ) { syntaxDesc . append ( writeQDString ( attr ) ) ; count ++ ; } if ( count < attrs . size ( ) ) { String attrId = null ; for ( NamingEnumeration < ? extends Attribute > ae = attrs . getAll ( ) ; ae . hasMoreElements ( ) ; ) { attr = ae . next ( ) ; attrId = attr . getID ( ) ; if ( attrId . equals ( NUMERICOID_ID ) || attrId . equals ( DESC_ID ) ) { continue ; } else { syntaxDesc . append ( writeQDStrings ( attr ) ) ; } } } syntaxDesc . append ( STR_ ) ; return syntaxDesc . toString ( ) ; }
@ Override public void write ( Buffer buffer , boolean isEnd ) throws IOException { if ( _s == null ) { buffer . free ( ) ; return ; } try { _needsFlush = BOOL_ ; if ( buffer . isDirect ( ) ) { _totalWriteBytes += buffer . length ( ) ; _s . write ( buffer . direct ( ) ) ; return ; } _totalWriteBytes += buffer . length ( ) ; while ( buffer . length ( ) > NUM_ ) { _writeBuffer . clear ( ) ; buffer . read ( _writeBuffer ) ; _writeBuffer . flip ( ) ; _s . write ( _writeBuffer ) ; } } catch ( IOException e ) { IOException exn = ClientDisconnectException . create ( this + STR_ + e , e ) ; try { close ( ) ; } catch ( IOException e1 ) { } throw exn ; } finally { buffer . free ( ) ; } }
private static void skipMemberValue ( int tag , ByteBuffer buf ) { switch ( tag ) { case STR_ : buf . getInt ( ) ; break ; case STR_ : skipAnnotation ( buf , BOOL_ ) ; break ; case STR_ : skipArray ( buf ) ; break ; default : buf . getShort ( ) ; } }
protected void recursiveNestedJoin ( EventBean lookupEvent , int nestingOrderIndex , EventBean [ ] currentPath , Collection < EventBean [ ] > result , ExprEvaluatorContext exprEvaluatorContext ) { List < EventBean [ ] > nestedResult = new LinkedList < EventBean [ ] > ( ) ; ExecNode nestedExecNode = childNodes . get ( nestingOrderIndex ) ; nestedExecNode . process ( lookupEvent , currentPath , nestedResult , exprEvaluatorContext ) ; boolean isLastStream = ( nestingOrderIndex == nestingOrderLength - NUM_ ) ; if ( ! isLastStream ) { for ( EventBean [ ] row : nestedResult ) { EventBean lookup = row [ nestedStreams [ nestingOrderIndex ] ] ; recursiveNestedJoin ( lookup , nestingOrderIndex + NUM_ , row , result , exprEvaluatorContext ) ; } return ; } for ( EventBean [ ] row : nestedResult ) { result . add ( row ) ; } }
public String generateMinimalMATSimConfig ( ) { Config config = new Config ( ) ; ConfigGroup ippcm = config . createModule ( MatrixBasedPtRouterConfigGroup . GROUP_NAME ) ; ippcm . addParam ( MatrixBasedPtRouterConfigGroup . PT_STOPS , this . ptStops ) ; ippcm . addParam ( MatrixBasedPtRouterConfigGroup . USING_PT_STOPS , STR_ ) ; ippcm . addParam ( MatrixBasedPtRouterConfigGroup . PT_TRAVEL_TIMES_AND_DISTANCES_SWITCH , this . useTravelTimesAndDistances ) ; ChangeModeConfigGroup changeModeConfig = ConfigUtils . addOrGetModule ( config , ChangeModeConfigGroup . CONFIG_MODULE , ChangeModeConfigGroup . class ) ; String [ ] str = { STR_ , STR_ } ; changeModeConfig . setModes ( str ) ; return writeConfigFile ( config ) ; }
public RecordedRequest takeRequest ( ) throws InterruptedException { return requestQueue . take ( ) ; }
private int convertLocationToColumn ( int x , int y ) { if ( cellWidth > NUM_ ) { if ( layoutOrientation == JList . VERTICAL ) { return NUM_ ; } Insets insets = list . getInsets ( ) ; int col ; if ( isLeftToRight ) { col = ( x - insets . left ) / cellWidth ; } else { col = ( list . getWidth ( ) - x - insets . right - NUM_ ) / cellWidth ; } if ( col < NUM_ ) { return NUM_ ; } else if ( col >= columnCount ) { return columnCount - NUM_ ; } return col ; } return NUM_ ; }
public static List < File > findFilesInDir ( File directory , FilenameFilter filter ) { Vector < File > files = new Vector < File > ( ) ; File [ ] entries = directory . listFiles ( ) ; for ( File entry : entries ) { if ( filter == null || filter . accept ( directory , entry . getName ( ) ) ) { files . add ( entry ) ; } if ( entry . isDirectory ( ) ) { files . addAll ( findFilesInDir ( entry , filter ) ) ; } } return files ; }
public String generateDrop ( String table ) { StringBuffer result = new StringBuffer ( ) ; result . append ( STR_ ) ; result . append ( table ) ; result . append ( STR_ ) ; return result . toString ( ) ; }
private void registerChildListeners ( ) { Iterator < PropertyChangeListener > iter = fChildListeners . iterator ( ) ; while ( iter . hasNext ( ) ) { PropertyChangeListener listener = iter . next ( ) ; listener . register ( ) ; } }
boolean isScrollOutOfBounds ( ) { return Float . compare ( getScrollAmountOutOfBounds ( mStackScrollP ) , NUM_ ) != NUM_ ; }
private void refreshIndexForDimensionFields ( String rowId , DimensionRow dimensionRow , DimensionRow dimensionRowOld ) { try { for ( DimensionField field : dimension . getDimensionFields ( ) ) { if ( field == dimension . getKey ( ) ) { continue ; } if ( dimensionRowOld != null ) { String oldRowValue = dimensionRowOld . get ( field ) ; String oldRowValueKey = DimensionStoreKeyUtils . getRowKey ( field . getName ( ) , oldRowValue ) ; String oldRowValuesKeysJson = keyValueStore . get ( oldRowValueKey ) ; String [ ] oldRowValueSKeys = objectMapper . readValue ( oldRowValuesKeysJson , String [ ] . class ) ; Set < String > oldRowValuesKeySet = new LinkedHashSet < > ( Arrays . asList ( oldRowValueSKeys ) ) ; oldRowValuesKeySet . remove ( rowId ) ; if ( oldRowValuesKeySet . isEmpty ( ) ) { keyValueStore . remove ( oldRowValueKey ) ; } else { String updatedOldRowValueSKeys = objectMapper . writeValueAsString ( oldRowValuesKeySet ) ; keyValueStore . put ( oldRowValueKey , updatedOldRowValueSKeys ) ; } } String rowValue = dimensionRow . get ( field ) ; String rowValueKey = DimensionStoreKeyUtils . getRowKey ( field . getName ( ) , rowValue ) ; String rowValueSKeys = keyValueStore . get ( rowValueKey ) ; Set < String > rowValueSKeySet = new LinkedHashSet < > ( ) ; if ( rowValueSKeys != null ) { rowValueSKeySet . addAll ( Arrays . asList ( objectMapper . readValue ( rowValueSKeys , String [ ] . class ) ) ) ; } rowValueSKeySet . add ( rowId ) ; String updatedRowValueSKeys = objectMapper . writeValueAsString ( rowValueSKeySet ) ; keyValueStore . put ( rowValueKey , updatedRowValueSKeys ) ; } } catch ( IOException e ) { LOG . error ( STR_ , e ) ; throw new RuntimeException ( e ) ; } }
public List < Instruction > reduceInstructions ( final List < Instruction > instructions ) { lock . lock ( ) ; try { this . instructions = instructions ; stackSizeSimulator . buildStackSizes ( instructions ) ; return reduceInstructionsInternal ( instructions ) ; } finally { lock . unlock ( ) ; } }
protected boolean isLockedLocally ( UUID newOwnerID ) { return thisNode . equals ( getOwnerNode ( ) ) || thisNode . equals ( newOwnerID ) ; }
private boolean tryToMove ( float deltaY ) { if ( ( deltaY > NUM_ && mCurrentPos == NUM_ ) ) { if ( DEBUG ) { Log . d ( LOG_TAG , String . format ( STR_ ) ) ; } return BOOL_ ; } if ( ( deltaY < NUM_ && mCurrentPos == - mHeaderHeight ) ) { if ( DEBUG ) { Log . d ( LOG_TAG , String . format ( STR_ ) ) ; } return BOOL_ ; } int to = mCurrentPos + ( int ) deltaY ; if ( to < - mHeaderHeight ) { if ( DEBUG ) { Log . d ( LOG_TAG , String . format ( STR_ ) ) ; } to = - mHeaderHeight ; } if ( to > NUM_ ) { if ( DEBUG ) { Log . d ( LOG_TAG , String . format ( STR_ ) ) ; } to = NUM_ ; } return moveTo ( to ) ; }
public void testCompareNegNeg2 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = - NUM_ ; int bSign = - NUM_ ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; assertEquals ( NUM_ , aNumber . compareTo ( bNumber ) ) ; }
public void deletePoint ( int position ) { int renderType = poly . getRenderType ( ) ; Projection proj = getProjection ( ) ; boolean needToHookUp = BOOL_ ; if ( position <= NUM_ && isEnclosed ( ) ) { enclose ( BOOL_ ) ; needToHookUp = BOOL_ ; } if ( renderType == OMGraphic . RENDERTYPE_LATLON ) { Debug . message ( STR_ , STR_ ) ; if ( proj != null ) { double [ ] ll = poly . getLatLonArray ( ) ; double [ ] newll = new double [ ll . length - NUM_ ] ; int actualPosition = ( position == Integer . MAX_VALUE ? ll . length : position . NUM_ ) ; if ( actualPosition >= ll . length ) { System . arraycopy ( ll , NUM_ , newll , NUM_ , ll . length - NUM_ ) ; position = ( ll . length - NUM_ ) / NUM_ ; } else if ( actualPosition <= NUM_ ) { System . arraycopy ( ll , NUM_ , newll , NUM_ , ll . length - NUM_ ) ; position = NUM_ ; } else { System . arraycopy ( ll , NUM_ , newll , NUM_ , actualPosition ) ; System . arraycopy ( ll , actualPosition + NUM_ , newll , actualPosition , ll . length - actualPosition - NUM_ ) ; } poly . setLocation ( newll , poly . getUnits ( ) ) ; } } else { Debug . message ( STR_ , STR_ ) ; int currentLength = poly . xs . length ; int [ ] newxs = new int [ currentLength - NUM_ ] ; int [ ] newys = new int [ currentLength - NUM_ ] ; if ( position >= currentLength ) { System . arraycopy ( poly . xs , NUM_ , newxs , NUM_ , currentLength - NUM_ ) ; System . arraycopy ( poly . ys , NUM_ , newys , NUM_ , currentLength - NUM_ ) ; position = currentLength - NUM_ ; } else if ( position <= NUM_ ) { System . arraycopy ( poly . xs , NUM_ , newxs , NUM_ , currentLength - NUM_ ) ; System . arraycopy ( poly . ys , NUM_ , newys , NUM_ , currentLength - NUM_ ) ; position = NUM_ ; } else { System . arraycopy ( poly . xs , NUM_ , newxs , NUM_ , position ) ; System . arraycopy ( poly . xs , position + NUM_ , newxs , position , currentLength - position - NUM_ ) ; System . arraycopy ( poly . ys , NUM_ , newys , NUM_ , position ) ; System . arraycopy ( poly . ys , position + NUM_ , newys , position , currentLength - position - NUM_ ) ; } if ( poly . getRenderType ( ) == OMGraphic . RENDERTYPE_OFFSET ) { poly . setLocation ( poly . lat , poly . lon , poly . getUnits ( ) , newxs , newys ) ; } else { poly . setLocation ( newxs , newys ) ; } } if ( proj != null ) { poly . regenerate ( proj ) ; } GrabPoint gp = ( GrabPoint ) polyGrabPoints . remove ( position ) ; if ( gpo != null && gp != null ) { gpo . removeGrabPoint ( gp ) ; } if ( needToHookUp ) { enclose ( BOOL_ ) ; } }
@ Override public boolean deleteLeftWord ( ) { mInputConnection . beginBatchEdit ( ) ; if ( mInputConnection . getSelectedText ( NUM_ ) != null ) { mInputConnection . commitText ( STR_ , NUM_ ) ; } else { CharSequence beforeCursor = mInputConnection . getTextBeforeCursor ( MAX_DELETABLE_CONTEXT , NUM_ ) ; if ( beforeCursor != null ) { int beforeCursorLength = beforeCursor . length ( ) ; Matcher m = WHITESPACE_AND_TOKEN . matcher ( beforeCursor ) ; int lastIndex = NUM_ ; while ( m . find ( ) ) { lastIndex = beforeCursorLength == m . end ( ) ? m . start ( ) : m . end ( ) ; } if ( lastIndex > NUM_ ) { mInputConnection . deleteSurroundingText ( beforeCursorLength - lastIndex , NUM_ ) ; } else if ( beforeCursorLength < MAX_DELETABLE_CONTEXT ) { mInputConnection . deleteSurroundingText ( beforeCursorLength , NUM_ ) ; } } } mInputConnection . endBatchEdit ( ) ; return BOOL_ ; }
public static double cdf ( double val , double rate ) { if ( val < NUM_ ) { return NUM_ ; } return NUM_ - Math . exp ( - rate . val ) ; }
public static DataSet readContinuous ( File file , char delimiter ) throws IOException { return readInContinuousData ( file , delimiter , Collections . singleton ( STR_ ) ) ; }
public static String generateNativeGuidForStoragePortFromIndication ( String sourceInstanceSystemName , String portNetworkId ) { String [ ] splitedString = sourceInstanceSystemName . split ( Constants . PATH_DELIMITER_REGEX ) ; return String . format ( STR_ , splitedString [ NUM_ ] , splitedString [ NUM_ ] , portNetworkId ) ; }
protected boolean arePathsContiguous ( TreePath [ ] paths ) { if ( rowMapper == null || paths . length < NUM_ ) return BOOL_ ; else { BitSet bitSet = new BitSet ( NUM_ ) ; int anIndex , counter , min ; int pathCount = paths . length ; int validCount = NUM_ ; TreePath [ ] tempPath = new TreePath [ NUM_ ] ; tempPath [ NUM_ ] = paths [ NUM_ ] ; min = rowMapper . getRowsForPaths ( tempPath ) [ NUM_ ] ; for ( counter = NUM_ ; counter < pathCount ; counter ++ ) { if ( paths [ counter ] != null ) { tempPath [ NUM_ ] = paths [ counter ] ; int [ ] rows = rowMapper . getRowsForPaths ( tempPath ) ; if ( rows == null ) { return BOOL_ ; } anIndex = rows [ NUM_ ] ; if ( anIndex == - NUM_ || anIndex < ( min - pathCount ) || anIndex > ( min + pathCount ) ) return BOOL_ ; if ( anIndex < min ) min = anIndex ; if ( ! bitSet . get ( anIndex ) ) { bitSet . set ( anIndex ) ; validCount ++ ; } } } int maxCounter = validCount + min ; for ( counter = min ; counter < maxCounter ; counter ++ ) if ( ! bitSet . get ( counter ) ) return BOOL_ ; } return BOOL_ ; }
public FastStringReader ( String s ) { this . str = s ; this . length = s . length ( ) ; }
private static int arrayIndex ( int i ) { return ( i > > SHIFT_PER_WORD ) ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
static void updateStyle ( JTextComponent c , SeaGlassContext context , String prefix ) { SeaGlassStyle style = ( SeaGlassStyle ) context . getStyle ( ) ; Color color = c . getCaretColor ( ) ; if ( color == null || color instanceof UIResource ) { c . setCaretColor ( ( Color ) style . get ( context , prefix + STR_ ) ) ; } Color fg = c . getForeground ( ) ; if ( fg == null || fg instanceof UIResource ) { fg = style . getColorForState ( context , ColorType . TEXT_FOREGROUND ) ; if ( fg != null ) { c . setForeground ( fg ) ; } } Object ar = style . get ( context , prefix + STR_ ) ; if ( ar instanceof Number ) { c . putClientProperty ( STR_ , ar ) ; } context . setComponentState ( SELECTED | FOCUSED ) ; Color s = c . getSelectionColor ( ) ; if ( s == null || s instanceof UIResource ) { c . setSelectionColor ( style . getColor ( context , ColorType . TEXT_BACKGROUND ) ) ; } Color sfg = c . getSelectedTextColor ( ) ; if ( sfg == null || sfg instanceof UIResource ) { c . setSelectedTextColor ( style . getColor ( context , ColorType . TEXT_FOREGROUND ) ) ; } context . setComponentState ( DISABLED ) ; Color dfg = c . getDisabledTextColor ( ) ; if ( dfg == null || dfg instanceof UIResource ) { c . setDisabledTextColor ( style . getColor ( context , ColorType . TEXT_FOREGROUND ) ) ; } Insets margin = c . getMargin ( ) ; if ( margin == null || margin instanceof UIResource ) { margin = ( Insets ) style . get ( context , prefix + STR_ ) ; if ( margin == null ) { margin = SeaGlassLookAndFeel . EMPTY_UIRESOURCE_INSETS ; } c . setMargin ( margin ) ; } Caret caret = c . getCaret ( ) ; if ( caret instanceof UIResource ) { Object o = style . get ( context , prefix + STR_ ) ; if ( o != null && o instanceof Integer ) { Integer rate = ( Integer ) o ; caret . setBlinkRate ( rate . intValue ( ) ) ; } } }
@ SuppressLint ( STR_ ) @ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { int widthMode = MeasureSpec . getMode ( widthMeasureSpec ) ; int heightMode = MeasureSpec . getMode ( heightMeasureSpec ) ; int maxWidth = MeasureSpec . getSize ( widthMeasureSpec ) ; int maxHeight = MeasureSpec . getSize ( heightMeasureSpec ) ; if ( widthMode == MeasureSpec . UNSPECIFIED ) maxWidth = Integer . MAX_VALUE ; if ( heightMode == MeasureSpec . UNSPECIFIED ) maxHeight = Integer . MAX_VALUE ; int paddingLeft = getPaddingLeft ( ) ; int paddingTop = getPaddingTop ( ) ; int paddingRight = getPaddingRight ( ) ; int paddingBottom = getPaddingBottom ( ) ; int maxRightBound = maxWidth - paddingRight ; int maxBottomBound = maxHeight - paddingBottom ; int left ; int top ; int right ; int bottom ; int rightBound = paddingLeft ; int maxRightNoPadding = rightBound ; int bottomBound ; int lastMaxBottom = paddingTop ; int maxBottom = lastMaxBottom ; int childWidth ; int childHeight ; int lineStartIndex = NUM_ ; int lineEndIndex = NUM_ ; rectList . clear ( ) ; int childCount = getChildCount ( ) ; for ( int index = NUM_ ; index < childCount ; index ++ ) { final View child = getChildAt ( index ) ; child . measure ( MeasureSpec . UNSPECIFIED , MeasureSpec . UNSPECIFIED ) ; if ( child . getVisibility ( ) == View . GONE ) continue ; final AutoWrapLayout . LayoutParams lp = ( AutoWrapLayout . LayoutParams ) child . getLayoutParams ( ) ; childWidth = child . getMeasuredWidth ( ) ; childHeight = child . getMeasuredHeight ( ) ; left = rightBound + lp . leftMargin ; right = left + childWidth ; rightBound = right + lp . rightMargin ; if ( rightBound > maxRightBound ) { lineEndIndex = index ; adjustBaseLine ( maxBottom - lastMaxBottom , lineStartIndex , lineEndIndex ) ; if ( maxBottom >= maxBottomBound ) break ; if ( lineEndIndex == lineStartIndex ) { child . measure ( MeasureSpec . makeMeasureSpec ( maxWidth - paddingLeft - paddingRight - lp . leftMargin - lp . rightMargin , MeasureSpec . AT_MOST ) , MeasureSpec . UNSPECIFIED ) ; childWidth = child . getMeasuredWidth ( ) ; childHeight = child . getMeasuredHeight ( ) ; } left = paddingLeft + lp . leftMargin ; right = left + childWidth ; rightBound = right + lp . rightMargin ; lastMaxBottom = maxBottom ; top = lastMaxBottom + lp . topMargin ; bottom = top + childHeight ; bottomBound = bottom + lp . bottomMargin ; lineStartIndex = index ; } else { top = lastMaxBottom + lp . topMargin ; bottom = top + childHeight ; bottomBound = bottom + lp . bottomMargin ; } if ( rightBound > maxRightNoPadding ) maxRightNoPadding = rightBound ; if ( bottomBound > maxBottom ) maxBottom = bottomBound ; Rect rect = new Rect ( ) ; rect . left = left ; rect . top = top ; rect . right = right ; rect . bottom = bottom ; rectList . add ( rect ) ; } adjustBaseLine ( maxBottom - lastMaxBottom , lineStartIndex , rectList . size ( ) ) ; int measuredWidth ; int measuredHeight ; if ( widthMode == MeasureSpec . EXACTLY ) measuredWidth = maxWidth ; else measuredWidth = maxRightNoPadding + paddingRight ; if ( heightMode == MeasureSpec . EXACTLY ) measuredHeight = maxHeight ; else { measuredHeight = maxBottom + paddingBottom ; if ( heightMode == MeasureSpec . AT_MOST ) measuredHeight = measuredHeight > maxHeight ? maxHeight : measuredHeight ; } setMeasuredDimension ( measuredWidth , measuredHeight ) ; }
public final void wait ( ) throws java . lang . InterruptedException { wait ( NUM_ ) ; }
public QueryStringQueryBuilder field ( String field , float boost ) { if ( fields == null ) { fields = new ArrayList < > ( ) ; } fields . add ( field ) ; if ( fieldsBoosts == null ) { fieldsBoosts = new ObjectFloatHashMap < > ( ) ; } fieldsBoosts . put ( field , boost ) ; return this ; }
public static String nowDateString ( String format ) { SimpleDateFormat df = new SimpleDateFormat ( format ) ; return df . format ( new Date ( ) ) ; }
protected void initStreamBufferSize ( ) { String streamBufferSizeParam = getInitParameter ( STR_ ) ; setStreamBufferSize ( ( streamBufferSizeParam == null ) ? DEFAULT_STREAM_BUFFER_SIZE : Integer . parseInt ( streamBufferSizeParam ) ) ; if ( isDebug ( ) ) { log ( STR_ + getStreamBufferSize ( ) ) ; } }
public void registerSensor ( Sensor s , int i ) { if ( ( i < NUM_ ) || ( i > ( ( numInputCards ( ) . bitsPerCard ) - NUM_ ) ) || ( i > MAXSENSORS ) ) { log . error ( STR_ + Integer . toString ( i + NUM_ ) ) ; return ; } hasActiveSensors = BOOL_ ; if ( sensorArray [ i ] == null ) { sensorArray [ i ] = s ; if ( lastUsedSensor < i ) { lastUsedSensor = i ; } } else { log . warn ( STR_ + Integer . toString ( ( getNodeAddress ( ) . SerialSensorManager . SENSORSPERUA ) + i + NUM_ ) ) ; } }
public static Number asNumber ( String value , Supplier < Number > defaultValueProvider ) { if ( value != null ) { try { return Short . valueOf ( value ) ; } catch ( NumberFormatException e1 ) { try { return Integer . valueOf ( value ) ; } catch ( NumberFormatException e2 ) { try { return Long . valueOf ( value ) ; } catch ( NumberFormatException e3 ) { try { return Float . valueOf ( value ) ; } catch ( NumberFormatException e4 ) { try { return Double . valueOf ( value ) ; } catch ( NumberFormatException e5 ) { try { return new BigInteger ( value ) ; } catch ( NumberFormatException e6 ) { try { return new BigDecimal ( value ) ; } catch ( NumberFormatException e7 ) { } } } } } } } } return defaultValueProvider != null ? defaultValueProvider . get ( ) : null ; }
public final void sample ( ) { long sum = _sum . getAndSet ( NUM_ ) ; int count = _count . getAndSet ( NUM_ ) ; if ( count != NUM_ ) _value = sum / ( double ) count ; else _value = NUM_ ; }
private String applyReplacement ( final BidiMap replacement , String contents ) { for ( Object key : replacement . keySet ( ) ) { String attributeName = ( String ) key ; String attributeInitials = ( String ) replacement . get ( key ) ; contents = contents . replaceAll ( JSONSerialisation . jsonAttributeName ( attributeName ) , JSONSerialisation . jsonAttributeName ( attributeInitials ) ) ; } return contents ; }
public KeyImpl ( KerberosPrincipal principal , char [ ] password , String algorithm ) { try { PrincipalName princ = new PrincipalName ( principal . getName ( ) ) ; EncryptionKey key = new EncryptionKey ( password , princ . getSalt ( ) , algorithm ) ; this . keyBytes = key . getBytes ( ) ; this . keyType = key . getEType ( ) ; } catch ( KrbException e ) { throw new IllegalArgumentException ( e . getMessage ( ) ) ; } }
public static AnnotationBinding [ ] addStandardAnnotations ( AnnotationBinding [ ] recordedAnnotations , long annotationTagBits , LookupEnvironment env ) { int count = NUM_ ; if ( ( annotationTagBits & TagBits . AnnotationTargetMASK ) != NUM_ ) count ++ ; if ( ( annotationTagBits & TagBits . AnnotationRetentionMASK ) != NUM_ ) count ++ ; if ( ( annotationTagBits & TagBits . AnnotationDeprecated ) != NUM_ ) count ++ ; if ( ( annotationTagBits & TagBits . AnnotationDocumented ) != NUM_ ) count ++ ; if ( ( annotationTagBits & TagBits . AnnotationInherited ) != NUM_ ) count ++ ; if ( ( annotationTagBits & TagBits . AnnotationOverride ) != NUM_ ) count ++ ; if ( ( annotationTagBits & TagBits . AnnotationSuppressWarnings ) != NUM_ ) count ++ ; if ( ( annotationTagBits & TagBits . AnnotationPolymorphicSignature ) != NUM_ ) count ++ ; if ( ( annotationTagBits & TagBits . AnnotationSafeVarargs ) != NUM_ ) count ++ ; if ( count == NUM_ ) return recordedAnnotations ; int index = recordedAnnotations . length ; AnnotationBinding [ ] result = new AnnotationBinding [ index + count ] ; System . arraycopy ( recordedAnnotations , NUM_ , result , NUM_ , index ) ; if ( ( annotationTagBits & TagBits . AnnotationTargetMASK ) != NUM_ ) result [ index ++ ] = buildTargetAnnotation ( annotationTagBits , env ) ; if ( ( annotationTagBits & TagBits . AnnotationRetentionMASK ) != NUM_ ) result [ index ++ ] = buildRetentionAnnotation ( annotationTagBits , env ) ; if ( ( annotationTagBits & TagBits . AnnotationDeprecated ) != NUM_ ) result [ index ++ ] = buildMarkerAnnotation ( TypeConstants . JAVA_LANG_DEPRECATED , env ) ; if ( ( annotationTagBits & TagBits . AnnotationDocumented ) != NUM_ ) result [ index ++ ] = buildMarkerAnnotation ( TypeConstants . JAVA_LANG_ANNOTATION_DOCUMENTED , env ) ; if ( ( annotationTagBits & TagBits . AnnotationInherited ) != NUM_ ) result [ index ++ ] = buildMarkerAnnotation ( TypeConstants . JAVA_LANG_ANNOTATION_INHERITED , env ) ; if ( ( annotationTagBits & TagBits . AnnotationOverride ) != NUM_ ) result [ index ++ ] = buildMarkerAnnotation ( TypeConstants . JAVA_LANG_OVERRIDE , env ) ; if ( ( annotationTagBits & TagBits . AnnotationSuppressWarnings ) != NUM_ ) result [ index ++ ] = buildMarkerAnnotation ( TypeConstants . JAVA_LANG_SUPPRESSWARNINGS , env ) ; if ( ( annotationTagBits & TagBits . AnnotationPolymorphicSignature ) != NUM_ ) result [ index ++ ] = buildMarkerAnnotationForMemberType ( TypeConstants . JAVA_LANG_INVOKE_METHODHANDLE_$_POLYMORPHICSIGNATURE , env ) ; if ( ( annotationTagBits & TagBits . AnnotationSafeVarargs ) != NUM_ ) result [ index ++ ] = buildMarkerAnnotation ( TypeConstants . JAVA_LANG_SAFEVARARGS , env ) ; return result ; }
@ Override public String toString ( ) { String result = STR_ ; result += getCompatibilityState ( ) ; if ( m_Instances == null ) { result += STR_ ; } else { result += STR_ + Utils . backQuoteChars ( m_Instances . relationName ( ) ) ; } return result ; }
public static void process ( List < Packages > pkgList ) throws Exception { init ( ) ; String [ ] temps = templates . split ( STR_ ) ; String [ ] vmFiles = new String [ temps . length ] ; for ( int i = NUM_ ; i < temps . length ; i ++ ) { vmFiles [ i ] = temps [ i ] + STR_ ; } for ( Packages pkg : pkgList ) { for ( String vmFile : vmFiles ) { generator ( vmFile , pkg ) ; } } }
public boolean check ( final Direction dir , final boolean facing ) { if ( this . dir != dir ) { return BOOL_ ; } if ( this . facing != facing ) { return BOOL_ ; } final long now = System . currentTimeMillis ( ) ; if ( now >= expiration ) { return BOOL_ ; } expiration = now + DELAY ; return BOOL_ ; }
private void parse ( String path ) throws Exception { if ( path != null ) { count = path . length ( ) ; data = new char [ count ] ; path . getChars ( NUM_ , count , data , NUM_ ) ; } path ( ) ; }
public void recordVariable ( String typeDesc , String varName , int varNo , SymbolTable tbl ) throws CompileError { char c ; int dim = NUM_ ; while ( ( c = typeDesc . charAt ( dim ) ) == STR_ ) ++ dim ; int type = MemberResolver . descToType ( c ) ; String cname = null ; if ( type == CLASS ) { if ( dim == NUM_ ) cname = typeDesc . substring ( NUM_ , typeDesc . length ( ) - NUM_ ) ; else cname = typeDesc . substring ( dim + NUM_ , typeDesc . length ( ) - NUM_ ) ; } Declarator decl = new Declarator ( type , cname , dim , varNo , new Symbol ( varName ) ) ; tbl . append ( varName , decl ) ; }
protected synchronized void readDontVerify ( ) throws IOException , FileEncryptionException { if ( backingRandomAccessFile . length ( ) < headerSize ( ) ) { throw new FileEncryptionException ( STR_ ) ; } long oldpos = backingRandomAccessFile . getFilePointer ( ) ; backingRandomAccessFile . seek ( NUM_ ) ; byte [ ] header_data = new byte [ headerSize ( ) - FileHeader . AUTH_TAG_SIZE ] ; backingRandomAccessFile . read ( header_data ) ; backingRandomAccessFile . seek ( oldpos ) ; DataInputStream istream = new DataInputStream ( new ByteArrayInputStream ( header_data ) ) ; byte [ ] tmpmagic = new byte [ PANBOX_FILE_MAGIC . length ] ; istream . read ( tmpmagic ) ; if ( ! Arrays . equals ( tmpmagic , PANBOX_FILE_MAGIC ) ) { throw new FileEncryptionException ( STR_ ) ; } byte [ ] tmpversion = new byte [ PANBOX_FILE_VERSION . length ] ; istream . read ( tmpversion ) ; if ( ! Arrays . equals ( tmpversion , PANBOX_FILE_VERSION ) ) { throw new FileEncryptionException ( STR_ + PANBOX_FILE_VERSION . toString ( ) ) ; } this . shareKeyVersion = istream . readInt ( ) ; istream . close ( ) ; }
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; }
private boolean isMediaTypeSupported ( String media ) { for ( int i = NUM_ ; i < SUPPORTED_MEDIA_TYPES . length ; i ++ ) { if ( media . equalsIgnoreCase ( SUPPORTED_MEDIA_TYPES [ i ] ) ) { return BOOL_ ; } } return BOOL_ ; }
private void export_dependencies ( JCas jcas ) { dependencies = new LinkedHashMap < Token , List < Dependency > > ( ) ; List < Token > nonGoverned = new ArrayList < Token > ( nodes . keySet ( ) ) ; for ( Dependency dependency : select ( jcas , Dependency . class ) ) { Token governor = dependency . getGovernor ( ) ; Token dependent = dependency . getDependent ( ) ; List < Dependency > l = dependencies . get ( governor ) ; if ( l == null ) { dependencies . put ( governor , new ArrayList < Dependency > ( ) ) ; l = dependencies . get ( governor ) ; } l . add ( dependency ) ; nonGoverned . remove ( dependent ) ; } for ( Token t : nonGoverned ) { traverseDependents ( t , STR_ , - NUM_ ) ; writeToFile ( STR_ , componentId , STR_ , STR_ , STR_ ) ; componentId ++ ; } }
public static char [ ] fix83600 ( char [ ] signature ) { if ( signature == null || signature . length < NUM_ ) return signature ; return Signature . removeCapture ( signature ) ; }
public static boolean isNetworkAvailable ( Context context ) { ConnectivityManager connectivityManager = ( ConnectivityManager ) context . getSystemService ( Context . CONNECTIVITY_SERVICE ) ; NetworkInfo info = connectivityManager . getActiveNetworkInfo ( ) ; return info != null && info . isConnected ( ) ; }
public static String randomRegexpishString ( Random r ) { return randomRegexpishString ( r , NUM_ ) ; }
public List < ExpectedPartitionValueEntity > createExpectedPartitionValueEntities ( String partitionKeyGroupName , List < String > expectedPartitionValues ) { PartitionKeyGroupEntity partitionKeyGroupEntity = partitionKeyGroupDao . getPartitionKeyGroupByName ( partitionKeyGroupName ) ; if ( partitionKeyGroupEntity == null ) { partitionKeyGroupEntity = partitionKeyGroupDaoTestHelper . createPartitionKeyGroupEntity ( partitionKeyGroupName ) ; } List < ExpectedPartitionValueEntity > expectedPartitionValueEntities = new ArrayList < > ( ) ; for ( String expectedPartitionValue : expectedPartitionValues ) { ExpectedPartitionValueEntity expectedPartitionValueEntity = new ExpectedPartitionValueEntity ( ) ; expectedPartitionValueEntity . setPartitionKeyGroup ( partitionKeyGroupEntity ) ; expectedPartitionValueEntity . setPartitionValue ( expectedPartitionValue ) ; expectedPartitionValueEntities . add ( expectedPartitionValueDao . saveAndRefresh ( expectedPartitionValueEntity ) ) ; } return expectedPartitionValueEntities ; }
public String toString ( ) { return text ( ) ; }
public static LowMemoryWatcher register ( @ NotNull Runnable runnable ) { return new LowMemoryWatcher ( runnable ) ; }
public void writeData ( DataOutput dout ) throws IOException { dout . write ( getMessage ( ) ) ; }
public Object extractHardRef ( Object o ) { SoftReference w = ( SoftReference ) o ; if ( w != null ) { return w . get ( ) ; } return null ; }
public static String formatLong ( long number ) { return intFormat . format ( number ) ; }
public static void uncontribute ( ComponentAddon component ) { contributedComponents . remove ( component ) ; if ( currentAddon != null ) { component . uninitialize ( currentAddon ) ; } }
public synchronized int copyDirect ( int pageId , OutputStream out ) throws IOException { byte [ ] buffer = new byte [ pageSize ] ; if ( pageId >= pageCount ) { return - NUM_ ; } file . seek ( ( long ) pageId << pageSizeShift ) ; file . readFullyDirect ( buffer , NUM_ , pageSize ) ; readCount ++ ; out . write ( buffer , NUM_ , pageSize ) ; return pageId + NUM_ ; }
public void writeRawBytes ( final byte [ ] value , int offset , int length ) throws IOException { if ( limit - position >= length ) { System . arraycopy ( value , offset , buffer , position , length ) ; position += length ; } else { throw new OutOfSpaceException ( position , limit ) ; } }
private void assertBackupStatus ( final BackupStatus backupStatus ) { Map < DistributedMember , Set < PersistentID > > backupMap = backupStatus . getBackedUpDiskStores ( ) ; assertFalse ( backupMap . isEmpty ( ) ) ; for ( DistributedMember member : backupMap . keySet ( ) ) { for ( PersistentID id : backupMap . get ( member ) ) { assertNotNull ( id . getHost ( ) ) ; assertNotNull ( id . getUUID ( ) ) ; assertNotNull ( id . getDirectory ( ) ) ; } } }
@ RequestMapping ( value = STR_ ) public void metadataError ( Locale locale , @ PathVariable ( value = STR_ ) String tenant , HttpServletResponse response ) throws IOException { logger . info ( STR_ , locale . toString ( ) , tenant ) ; metadataDefaultTenantBindingError ( locale , response ) ; }
public synchronized void checkState ( State ... requiredStates ) throws IllegalStateException { for ( State requiredState : requiredStates ) { if ( requiredState . equals ( currentState ) ) { return ; } } throw new IllegalStateException ( String . format ( Locale . US , STR_ , Lists . newArrayList ( requiredStates ) , currentState ) ) ; }
public void sortMovies ( ) { synchronized ( movies ) { Utils . sortList ( movies , MOVIE_SET_COMPARATOR ) ; movieIds . clear ( ) ; for ( Movie movie : movies ) { movieIds . add ( movie . getDbId ( ) ) ; } } firePropertyChange ( STR_ , null , movies ) ; }
public KeyValueListParser ( String pairDelimiterRegex , String keyValDelimiterRegex ) { pairDelimiter = Pattern . compile ( pairDelimiterRegex ) ; keyValDelimiter = Pattern . compile ( keyValDelimiterRegex ) ; }
private synchronized boolean pollStatsBroker ( Destination queue ) { statsMessageListener . setDestination ( queue ) ; Timestamp timestamp = new Timestamp ( System . currentTimeMillis ( ) ) ; LOGGER . debug ( STR_ + getQueueName ( queue ) + STR_ + timestamp ) ; jmsTemplate . execute ( STATS_BROKER_DESTINATION + getQueueName ( queue ) , new ProducerCallbackImpl ( statsQueue ) ) ; try { Thread . sleep ( NUM_ . NUM_ ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } return statsMessageListener . getStats ( ) != null ; }
public File makeAcceptable ( File pathname ) { if ( accept ( pathname ) ) { return pathname ; } else { return new File ( pathname . getPath ( ) + STR_ + defaultExtension ) ; } }
private static int handleDpadVertical ( int iconIndex , int cntX , int cntY , int [ ] [ ] matrix , int increment ) { int newIconIndex = NOOP ; if ( matrix == null ) { throw new IllegalStateException ( STR_ ) ; } int xPos = - NUM_ ; int yPos = - NUM_ ; for ( int i = NUM_ ; i < cntX ; i ++ ) { for ( int j = NUM_ ; j < cntY ; j ++ ) { if ( matrix [ i ] [ j ] == iconIndex ) { xPos = i ; yPos = j ; } } } if ( DEBUG ) { Log . v ( TAG , String . format ( STR_ , xPos , yPos , iconIndex ) ) ; } for ( int y = yPos + increment ; NUM_ <= y && y < cntY && NUM_ <= y ; y += increment ) { if ( ( newIconIndex = inspectMatrix ( xPos , y , cntX , cntY , matrix ) ) != NOOP && newIconIndex != ALL_APPS_COLUMN ) { return newIconIndex ; } } int nextXPos1 ; int nextXPos2 ; boolean haveCrossedAllAppsColumn1 = BOOL_ ; boolean haveCrossedAllAppsColumn2 = BOOL_ ; int y = - NUM_ ; for ( int coeff = NUM_ ; coeff < cntX ; coeff ++ ) { nextXPos1 = xPos + coeff . increment ; nextXPos2 = xPos - coeff . increment ; y = yPos + increment . coeff ; if ( inspectMatrix ( nextXPos1 , y , cntX , cntY , matrix ) == ALL_APPS_COLUMN ) { haveCrossedAllAppsColumn1 = BOOL_ ; } if ( inspectMatrix ( nextXPos2 , y , cntX , cntY , matrix ) == ALL_APPS_COLUMN ) { haveCrossedAllAppsColumn2 = BOOL_ ; } for ( ; NUM_ <= y && y < cntY ; y = y + increment ) { int offset1 = haveCrossedAllAppsColumn1 && y < cntY - NUM_ ? increment : NUM_ ; newIconIndex = inspectMatrix ( nextXPos1 + offset1 , y , cntX , cntY , matrix ) ; if ( newIconIndex != NOOP ) { return newIconIndex ; } int offset2 = haveCrossedAllAppsColumn2 && y < cntY - NUM_ ? - increment : NUM_ ; newIconIndex = inspectMatrix ( nextXPos2 + offset2 , y , cntX , cntY , matrix ) ; if ( newIconIndex != NOOP ) { return newIconIndex ; } } } return newIconIndex ; }
private static boolean edgeIntersectsCellBoundary ( S2Point a , S2Point b , S2Cell cell ) { S2Point [ ] vertices = new S2Point [ NUM_ ] ; for ( int i = NUM_ ; i < NUM_ ; ++ i ) { vertices [ i ] = cell . getVertex ( i ) ; } for ( int i = NUM_ ; i < NUM_ ; ++ i ) { S2Point fromPoint = vertices [ i ] ; S2Point toPoint = vertices [ ( i + NUM_ ) % NUM_ ] ; if ( lenientCrossing ( a , b , fromPoint , toPoint ) ) { return BOOL_ ; } } return BOOL_ ; }
private void generateLegalTimesTree ( ) { int k0 = KeyEvent . KEYCODE_0 ; int k1 = KeyEvent . KEYCODE_1 ; int k2 = KeyEvent . KEYCODE_2 ; int k3 = KeyEvent . KEYCODE_3 ; int k4 = KeyEvent . KEYCODE_4 ; int k5 = KeyEvent . KEYCODE_5 ; int k6 = KeyEvent . KEYCODE_6 ; int k7 = KeyEvent . KEYCODE_7 ; int k8 = KeyEvent . KEYCODE_8 ; int k9 = KeyEvent . KEYCODE_9 ; mLegalTimesTree = new Node ( ) ; if ( mIs24HourMode ) { Node minuteFirstDigit = new Node ( k0 , k1 , k2 , k3 , k4 , k5 ) ; Node minuteSecondDigit = new Node ( k0 , k1 , k2 , k3 , k4 , k5 , k6 , k7 , k8 , k9 ) ; minuteFirstDigit . addChild ( minuteSecondDigit ) ; Node firstDigit = new Node ( k0 , k1 ) ; mLegalTimesTree . addChild ( firstDigit ) ; Node secondDigit = new Node ( k0 , k1 , k2 , k3 , k4 , k5 ) ; firstDigit . addChild ( secondDigit ) ; secondDigit . addChild ( minuteFirstDigit ) ; Node thirdDigit = new Node ( k6 , k7 , k8 , k9 ) ; secondDigit . addChild ( thirdDigit ) ; secondDigit = new Node ( k6 , k7 , k8 , k9 ) ; firstDigit . addChild ( secondDigit ) ; secondDigit . addChild ( minuteFirstDigit ) ; firstDigit = new Node ( k2 ) ; mLegalTimesTree . addChild ( firstDigit ) ; secondDigit = new Node ( k0 , k1 , k2 , k3 ) ; firstDigit . addChild ( secondDigit ) ; secondDigit . addChild ( minuteFirstDigit ) ; secondDigit = new Node ( k4 , k5 ) ; firstDigit . addChild ( secondDigit ) ; secondDigit . addChild ( minuteSecondDigit ) ; firstDigit = new Node ( k3 , k4 , k5 , k6 , k7 , k8 , k9 ) ; mLegalTimesTree . addChild ( firstDigit ) ; firstDigit . addChild ( minuteFirstDigit ) ; } else { Node ampm = new Node ( getAmOrPmKeyCode ( AM ) , getAmOrPmKeyCode ( PM ) ) ; Node firstDigit = new Node ( k1 ) ; mLegalTimesTree . addChild ( firstDigit ) ; firstDigit . addChild ( ampm ) ; Node secondDigit = new Node ( k0 , k1 , k2 ) ; firstDigit . addChild ( secondDigit ) ; secondDigit . addChild ( ampm ) ; Node thirdDigit = new Node ( k0 , k1 , k2 , k3 , k4 , k5 ) ; secondDigit . addChild ( thirdDigit ) ; thirdDigit . addChild ( ampm ) ; Node fourthDigit = new Node ( k0 , k1 , k2 , k3 , k4 , k5 , k6 , k7 , k8 , k9 ) ; thirdDigit . addChild ( fourthDigit ) ; fourthDigit . addChild ( ampm ) ; thirdDigit = new Node ( k6 , k7 , k8 , k9 ) ; secondDigit . addChild ( thirdDigit ) ; thirdDigit . addChild ( ampm ) ; secondDigit = new Node ( k3 , k4 , k5 ) ; firstDigit . addChild ( secondDigit ) ; thirdDigit = new Node ( k0 , k1 , k2 , k3 , k4 , k5 , k6 , k7 , k8 , k9 ) ; secondDigit . addChild ( thirdDigit ) ; thirdDigit . addChild ( ampm ) ; firstDigit = new Node ( k2 , k3 , k4 , k5 , k6 , k7 , k8 , k9 ) ; mLegalTimesTree . addChild ( firstDigit ) ; firstDigit . addChild ( ampm ) ; secondDigit = new Node ( k0 , k1 , k2 , k3 , k4 , k5 ) ; firstDigit . addChild ( secondDigit ) ; thirdDigit = new Node ( k0 , k1 , k2 , k3 , k4 , k5 , k6 , k7 , k8 , k9 ) ; secondDigit . addChild ( thirdDigit ) ; thirdDigit . addChild ( ampm ) ; } }
protected void updateOverlayContents ( LookAt lookAt , Camera camera ) { latView . setText ( formatLatitude ( lookAt . latitude ) ) ; lonView . setText ( formatLongitude ( lookAt . longitude ) ) ; altView . setText ( formatAltitude ( camera . altitude ) ) ; }
public String jsTypeName ( TypeRef typeRef ) { switch ( typeRef . getKind ( ) ) { case TYPE_MESSAGE : return STR_ ; case TYPE_ENUM : return STR_ ; default : { String name = PRIMITIVE_TYPE_NAMES . get ( typeRef . getKind ( ) ) ; if ( ! Strings . isNullOrEmpty ( name ) ) { return name ; } throw new IllegalArgumentException ( STR_ + typeRef . getKind ( ) ) ; } } }
@ Override public synchronized void put ( String key , Entry entry ) { pruneIfNeeded ( entry . data . length ) ; File file = getFileForKey ( key ) ; try { BufferedOutputStream fos = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; CacheHeader e = new CacheHeader ( key , entry ) ; boolean success = e . writeHeader ( fos ) ; if ( ! success ) { fos . close ( ) ; VolleyLog . d ( STR_ , file . getAbsolutePath ( ) ) ; throw new IOException ( ) ; } fos . write ( entry . data ) ; fos . close ( ) ; putEntry ( key , e ) ; return ; } catch ( IOException e ) { } boolean deleted = file . delete ( ) ; if ( ! deleted ) { VolleyLog . d ( STR_ , file . getAbsolutePath ( ) ) ; } }
public StateMachine createStateMachine ( StateMachineDefinition stateMachineDefinition ) { final Map < EventDefinition , EventData > eventDataMap = stateMachineDefinition . getEventDataMap ( ) ; Set < Event > allEvents = createAllEvents ( eventDataMap ) ; Set < StateDefinition > stateDefinitions = stateMachineDefinition . getStates ( ) ; Set < State > states = new HashSet < > ( ) ; for ( StateDefinition stateDefinition : stateDefinitions ) { State state = convertStateDefinitionToState ( stateDefinition ) ; states . add ( state ) ; } StateMachine stateMachine = new StateMachine ( stateMachineDefinition . getVersion ( ) , stateMachineDefinition . getName ( ) , stateMachineDefinition . getDescription ( ) , states , stateMachineDefinition . getCorrelationId ( ) ) ; stateMachinesDAO . create ( stateMachine ) ; for ( Event event : allEvents ) { event . setStateMachineInstanceId ( stateMachine . getId ( ) ) ; eventPersistenceService . persistEvent ( event ) ; } for ( State state : stateMachine . getStates ( ) ) { auditDAO . create ( new AuditRecord ( stateMachine . getId ( ) , state . getId ( ) , NUM_ , Status . initialized , null , null ) ) ; } return stateMachine ; }
protected void sqrtLayout ( VisualTable labels ) { Rectangle2D b = getLayoutBounds ( ) ; double breadth = getBreadth ( b ) ; double span = m_hi - m_lo ; double splo = MathLib . safeSqrt ( m_prevlo ) ; double spspan = MathLib . safeSqrt ( m_prevhi ) - splo ; double vlo = Math . pow ( NUM_ , Math . floor ( MathLib . safeLog10 ( m_lo ) ) ) ; double slo = MathLib . safeSqrt ( m_lo ) ; double sspan = MathLib . safeSqrt ( m_hi ) - slo ; Iterator iter = labels . tuples ( ) ; while ( iter . hasNext ( ) ) { VisualItem item = ( VisualItem ) iter . next ( ) ; reset ( item ) ; double v = item . getDouble ( VALUE ) ; double x = span == NUM_ ? NUM_ : ( ( MathLib . safeSqrt ( v ) - slo ) / sspan ) . breadth ; set ( item , x , b ) ; } Index index = labels . index ( VALUE ) ; double step = getLinearStep ( span , breadth / span ) ; if ( step == NUM_ ) step = NUM_ ; int r ; for ( double x , v = vlo ; v <= m_hi ; v += step ) { x = ( ( MathLib . safeSqrt ( v ) - slo ) / sspan ) . breadth ; if ( x < - NUM_ ) { continue ; } else if ( ( r = index . get ( v ) ) >= NUM_ ) { VisualItem item = labels . getItem ( r ) ; item . setVisible ( BOOL_ ) ; item . setEndVisible ( BOOL_ ) ; } else { VisualItem item = labels . addItem ( ) ; item . set ( LABEL , m_nf . format ( v ) ) ; item . setDouble ( VALUE , v ) ; double f = spspan == NUM_ ? NUM_ : ( ( MathLib . safeSqrt ( v ) - splo ) / spspan ) ; if ( f <= NUM_ || f >= NUM_ ) { item . setStartVisible ( BOOL_ ) ; } set ( item , f . breadth , b ) ; set ( item , x , b ) ; } } }
public void dispose ( ) { clearListeners ( ) ; if ( attributes != null ) { attributes . clear ( ) ; } removed ( null ) ; }
private void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject ( ) ; registrarID = new ServiceID ( in ) ; if ( server == null ) { throw new InvalidObjectException ( STR_ ) ; } }
public Shape triangle_right ( float x , float y , float height ) { m_path . reset ( ) ; m_path . moveTo ( x , y + height ) ; m_path . lineTo ( x + height , y + height / NUM_ ) ; m_path . lineTo ( x , y ) ; m_path . closePath ( ) ; return m_path ; }
public static terminal find ( String with_name ) { if ( with_name == null ) return null ; else return ( terminal ) _all . get ( with_name ) ; }
public LayoutBlock createNewLayoutBlock ( String systemName , String userName ) { LayoutBlock block = null ; if ( userName == null || userName . equals ( STR_ ) ) { log . error ( STR_ ) ; return null ; } block = getByUserName ( userName ) ; if ( block != null ) { return null ; } String sName = STR_ ; if ( systemName == null ) { boolean found = BOOL_ ; while ( found ) { sName = STR_ + blkNum ; blkNum ++ ; block = getBySystemName ( sName ) ; if ( block == null ) { found = BOOL_ ; } } } else { block = getBySystemName ( ( systemName . toUpperCase ( ) ) ) ; if ( block != null ) { return null ; } sName = systemName . toUpperCase ( ) ; } block = new LayoutBlock ( sName , userName ) ; register ( block ) ; return block ; }
@ Override public void modifyNonstaticJPedalParameters ( final Map values ) throws PdfException { options . set ( values ) ; if ( values . containsKey ( JPedalSettings . DISPLAY_BACKGROUND ) ) { } }
public static String escapeRegex ( final String regex ) { Matcher match = REGEX_CHARS . matcher ( regex ) ; return match . replaceAll ( STR_ ) ; }
public CharBuffer ( String string ) { int length = string . length ( ) ; int capacity = length + MIN_CAPACITY ; init ( new char [ capacity ] , NUM_ , length ) ; string . getChars ( NUM_ , length , buffer ( ) , NUM_ ) ; }
private void updatePromoVisibility ( float percentage ) { if ( isPromoAvailable ( ) ) { mPromoVisible = BOOL_ ; mPromoHeightPx = Math . round ( MathUtils . clamp ( percentage . mPromoContentHeightPx , NUM_ , mPromoContentHeightPx ) ) ; mPromoOpacity = percentage ; } else { mPromoVisible = BOOL_ ; mPromoHeightPx = NUM_ ; mPromoOpacity = NUM_ ; } }
private ValueGeometry ( byte [ ] bytes , Geometry geometry ) { this . bytes = bytes ; this . geometry = geometry ; this . hashCode = Arrays . hashCode ( bytes ) ; }
@ Override public void do_after_propagation ( ) { for ( HeapInsIntervalManager im : new_pts . values ( ) ) { im . flush ( ) ; } new_pts = new HashMap < AllocNode , HeapInsIntervalManager > ( ) ; }
static boolean isExist ( String libName , int version ) { String file = _targetSoFile ( libName , version ) ; File a = new File ( file ) ; return a . exists ( ) ; }
private void finishCommon ( ) { if ( ! unknownSubjects . isEmpty ( ) ) { if ( statements . isEmpty ( ) && restoredStatements . isEmpty ( ) ) { throw new BadSubjectException ( unknownSubjects . keySet ( ) , uris ) ; } else { log . info ( STR_ , unknownSubjects . keySet ( ) , uris . entityData ( ) , uris . entity ( ) ) ; } } if ( revisionId == null ) { throw new ContainedException ( STR_ + statements ) ; } if ( lastModified == null ) { throw new ContainedException ( STR_ + statements ) ; } for ( Pair < URI , Literal > dataStatement : dataStatements ) { statements . add ( new StatementImpl ( entityUriImpl , dataStatement . getLeft ( ) , dataStatement . getRight ( ) ) ) ; } statements . addAll ( restoredStatements ) ; }
public static final void showGUIMessage ( final String user_message , final BufferedImage image , final String title ) { if ( image == null ) { return ; } final ImagePanel display = new ImagePanel ( image ) ; display . setLayout ( new BorderLayout ( ) ) ; if ( user_message != null ) { display . add ( new JLabel ( user_message ) , BorderLayout . SOUTH ) ; } final int width = image . getWidth ( ) ; final int height = image . getHeight ( ) ; display . setSize ( new Dimension ( width + NUM_ , height + NUM_ ) ) ; JOptionPane . showConfirmDialog ( contentPane , display , title , JOptionPane . DEFAULT_OPTION , JOptionPane . PLAIN_MESSAGE ) ; }
@ Override public Path call ( ) throws Exception { final Set < FileVisitOption > options ; if ( followLinks ) { options = EnumSet . of ( FileVisitOption . FOLLOW_LINKS ) ; } else { options = EnumSet . noneOf ( FileVisitOption . class ) ; } logger . info ( String . format ( STR_ , path ) ) ; try { Files . walkFileTree ( path , options , maxDepth , this ) ; } catch ( IOException e ) { logger . log ( Level . SEVERE , String . format ( STR_ , path ) , e ) ; throw e ; } logger . info ( String . format ( STR_ , path ) ) ; return path ; }
private void baselineLayout ( int origin , int size ) { int ascent ; int descent ; if ( baselineAnchoredToTop ) { ascent = prefAscent ; descent = size - ascent ; } else { ascent = size - prefDescent ; descent = prefDescent ; } for ( Spring spring : springs ) { Alignment alignment = spring . getAlignment ( ) ; if ( alignment == null || alignment == Alignment . BASELINE ) { int baseline = spring . getBaseline ( ) ; if ( baseline >= NUM_ ) { int springMax = spring . getMaximumSize ( VERTICAL ) ; int springPref = spring . getPreferredSize ( VERTICAL ) ; int height = springPref ; int y ; switch ( spring . getBaselineResizeBehavior ( ) ) { case CONSTANT_ASCENT : y = origin + ascent - baseline ; height = Math . min ( descent , springMax - baseline ) + baseline ; break ; case CONSTANT_DESCENT : height = Math . min ( ascent , springMax - springPref + baseline ) + ( springPref - baseline ) ; y = origin + ascent + ( springPref - baseline ) - height ; break ; default : y = origin + ascent - baseline ; break ; } spring . setSize ( VERTICAL , y , height ) ; } else { setChildSize ( spring , VERTICAL , origin , size ) ; } } else { setChildSize ( spring , VERTICAL , origin , size ) ; } } }
public static int readInt ( final JSONArray jsonArray , final int index , final boolean required , final boolean notNull ) throws JSONException { if ( required ) { return jsonArray . getInt ( index ) ; } if ( notNull && jsonArray . isNull ( index ) ) { throw new JSONException ( String . format ( Locale . US , NULL_VALUE_FORMAT_ARRAY , index ) ) ; } int value = NUM_ ; if ( ! jsonArray . isNull ( index ) ) { value = jsonArray . getInt ( index ) ; } return value ; }
public void addPropertyChangeListener ( PropertyChangeListener pcl ) { m_pcSupport . addPropertyChangeListener ( pcl ) ; }
private void unregisterDependent ( Preference dependent ) { if ( mDependents != null ) { mDependents . remove ( dependent ) ; } }
private void validateStoragePolicySelection ( StoragePolicySelection storagePolicySelection ) { Assert . notNull ( storagePolicySelection , STR_ ) ; businessObjectDataHelper . validateBusinessObjectDataKey ( storagePolicySelection . getBusinessObjectDataKey ( ) , BOOL_ , BOOL_ ) ; storagePolicyHelper . validateStoragePolicyKey ( storagePolicySelection . getStoragePolicyKey ( ) ) ; Assert . notNull ( storagePolicySelection . getStoragePolicyVersion ( ) , STR_ ) ; }
@ Override public String toString ( ) { StringBuffer text = new StringBuffer ( ) ; if ( m_cobwebTree == null ) { return STR_ ; } else { m_cobwebTree . dumpTree ( NUM_ , text ) ; return STR_ + m_numberMerges + STR_ + m_numberSplits + STR_ + numberOfClusters ( ) + STR_ + text . toString ( ) + STR_ ; } }
public static Object toArray ( Collection < ? > collection , Class < ? > componentType ) { if ( componentType . isPrimitive ( ) ) { Object array = Array . newInstance ( componentType , collection . size ( ) ) ; int index = NUM_ ; for ( Object value : collection ) { Array . set ( array , index ++ , value ) ; } return array ; } return collection . toArray ( ( Object [ ] ) Array . newInstance ( componentType , collection . size ( ) ) ) ; }
GradleException formatViolationsFor ( Formatter formatter , List < File > problemFiles ) throws IOException { return new GradleException ( DiffMessageFormatter . messageFor ( this , formatter , problemFiles ) ) ; }
public void labelDistances ( Hypergraph < V , E > graph , V root ) { labelDistances ( graph , Collections . singleton ( root ) ) ; }
public static java . lang . String toString ( float d ) { float m = Math . abs ( d ) ; if ( d == POSITIVE_INFINITY ) { return STR_ ; } else if ( d == NEGATIVE_INFINITY ) { return STR_ ; } else if ( d == NUM_ ) { return STR_ ; } else if ( m >= NUM_ && m < NUM_ ) { String str = toStringImpl ( d , BOOL_ ) ; char [ ] chars = str . toCharArray ( ) ; int i = chars . length - NUM_ ; char c ; while ( i >= NUM_ && ( c = chars [ i ] ) == STR_ ) { i -- ; } if ( i < NUM_ || str . indexOf ( STR_ ) == - NUM_ ) { return str ; } else if ( chars [ i ] == STR_ || chars [ i ] == STR_ ) { i ++ ; } return str . substring ( NUM_ , i + NUM_ ) ; } else { return toStringImpl ( d , BOOL_ ) ; } }
public int position ( ) { return lineBuffer == null ? NUM_ : lineBuffer . length ( ) ; }
public BatchedImageRequest ( Request < ? > request , ImageContainer container ) { mRequest = request ; mContainers . add ( container ) ; }
public void addFrequency ( Frequency frequency ) { frequencies . add ( frequency ) ; }
public final static HeaderElement parseHeaderElement ( final String value , HeaderValueParser parser ) throws ParseException { if ( value == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( parser == null ) parser = SaveHeaderValueParser . DEFAULT ; CharArrayBuffer buffer = new CharArrayBuffer ( value . length ( ) ) ; buffer . append ( value ) ; SaveParserCursor cursor = new SaveParserCursor ( NUM_ , value . length ( ) ) ; return parser . parseHeaderElement ( buffer , cursor ) ; }
public static List < Interval > sliceIntervals ( Interval interval , TimeGrain timeGrain ) { DateTime intervalEnd = interval . getEnd ( ) ; DateTime sliceStart = interval . getStart ( ) ; DateTime periodStart = timeGrain . roundFloor ( sliceStart ) ; if ( ! sliceStart . equals ( periodStart ) ) { LOG . info ( STR_ , interval , timeGrain , periodStart ) ; throw new IllegalArgumentException ( STR_ + periodStart ) ; } List < Interval > intervalSlices = new ArrayList < > ( ) ; while ( sliceStart . isBefore ( intervalEnd ) ) { DateTime sliceEnd = DateTimeUtils . addTimeGrain ( sliceStart , timeGrain ) ; Interval slicedInterval = new Interval ( sliceStart , sliceEnd ) ; if ( ! interval . contains ( slicedInterval ) ) { LOG . info ( STR_ , interval , timeGrain ) ; throw new IllegalArgumentException ( STR_ ) ; } intervalSlices . add ( slicedInterval ) ; sliceStart = sliceEnd ; } LOG . debug ( STR_ , interval , intervalSlices . size ( ) , timeGrain ) ; return intervalSlices ; }
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; }
public void testHasAttributes1 ( ) throws Throwable { Document doc ; NodeList addrList ; Node addrNode ; boolean state ; doc = ( Document ) load ( STR_ , builder ) ; addrList = doc . getElementsByTagName ( STR_ ) ; addrNode = addrList . item ( NUM_ ) ; state = addrNode . hasAttributes ( ) ; assertFalse ( STR_ , state ) ; }
public boolean isGerund ( ) { return typeString . startsWith ( VERB_GERUND ) ; }
protected void error ( String msg , Exception e ) throws org . xml . sax . SAXException { SAXSourceLocator locator = getLocator ( ) ; ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; TransformerException pe ; if ( ! ( e instanceof TransformerException ) ) { pe = ( null == e ) ? new TransformerException ( msg , locator ) : new TransformerException ( msg , locator , e ) ; } else pe = ( TransformerException ) e ; if ( null != handler ) { try { handler . error ( pe ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } else throw new org . xml . sax . SAXException ( pe ) ; }
private JsonObject createRequest ( Map < String , Object > headers , String uri , HttpMethod method , JsonObject payload ) { JsonObject request = new JsonObject ( ) ; JsonArray jsonHeaders = new JsonArray ( ) ; headers . forEach ( null ) ; request . put ( STR_ , jsonHeaders ) ; request . put ( STR_ , uri ) ; request . put ( STR_ , method . toString ( ) ) ; request . put ( STR_ , payload ) ; return request ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; nameNode = elementList . item ( NUM_ ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; { boolean success = BOOL_ ; try { child . replaceData ( - NUM_ , NUM_ , STR_ ) ; } catch ( DOMException ex ) { success = ( ex . code == DOMException . INDEX_SIZE_ERR ) ; } assertTrue ( STR_ , success ) ; } }
private long downloadTlogFiles ( File tmpTlogDir , long latestGeneration ) throws Exception { LOG . info ( STR_ + tlogFilesToDownload ) ; tlogFilesDownloaded = Collections . synchronizedList ( new ArrayList < > ( ) ) ; long bytesDownloaded = NUM_ ; boolean status = tmpTlogDir . mkdirs ( ) ; if ( ! status ) { throw new SolrException ( SolrException . ErrorCode . SERVER_ERROR , STR_ + tmpTlogDir . getName ( ) ) ; } for ( Map < String , Object > file : tlogFilesToDownload ) { String saveAs = ( String ) ( file . get ( ALIAS ) == null ? file . get ( NAME ) : file . get ( ALIAS ) ) ; localFileFetcher = new LocalFsFileFetcher ( tmpTlogDir , file , saveAs , TLOG_FILE , latestGeneration ) ; currentFile = file ; localFileFetcher . fetchFile ( ) ; bytesDownloaded += localFileFetcher . getBytesDownloaded ( ) ; tlogFilesDownloaded . add ( new HashMap < > ( file ) ) ; } return bytesDownloaded ; }
static WindowsFileAttributes readAttributes ( long handle ) throws WindowsException { NativeBuffer buffer = NativeBuffers . getNativeBuffer ( SIZEOF_FILE_INFORMATION ) ; try { long address = buffer . address ( ) ; GetFileInformationByHandle ( handle , address ) ; int reparseTag = NUM_ ; int fileAttrs = unsafe . getInt ( address + OFFSETOF_FILE_INFORMATION_ATTRIBUTES ) ; if ( isReparsePoint ( fileAttrs ) ) { int size = MAXIMUM_REPARSE_DATA_BUFFER_SIZE ; NativeBuffer reparseBuffer = NativeBuffers . getNativeBuffer ( size ) ; try { DeviceIoControlGetReparsePoint ( handle , reparseBuffer . address ( ) , size ) ; reparseTag = ( int ) unsafe . getLong ( reparseBuffer . address ( ) ) ; } finally { reparseBuffer . release ( ) ; } } return fromFileInformation ( address , reparseTag ) ; } finally { buffer . release ( ) ; } }
protected void addAllForReplay ( Collection < Participant > participants ) { Iterator < Participant > it = participants . iterator ( ) ; while ( it . hasNext ( ) ) { Participant p = it . next ( ) ; replayCompletion ( p ) ; } }
public static JPanel createCheckbox ( String boxlabel , String [ ] buttons , boolean [ ] checked , ActionListener al ) { JPanel jp = createPaletteJPanel ( boxlabel ) ; for ( int j = NUM_ ; j < buttons . length ; j ++ ) { JCheckBox jcb = new JCheckBox ( buttons [ j ] ) ; jcb . setActionCommand ( Integer . toString ( j ) ) ; if ( al != null ) jcb . addActionListener ( al ) ; jcb . setSelected ( checked [ j ] ) ; jp . add ( jcb ) ; } return jp ; }
public static void copy ( DimensionsEvent aeDest , DimensionsEvent aeSrc ) { GPOMutable destAggs = aeDest . getAggregates ( ) ; GPOMutable srcAggs = aeSrc . getAggregates ( ) ; if ( srcAggs . getFieldsBoolean ( ) != null ) { System . arraycopy ( srcAggs . getFieldsBoolean ( ) , NUM_ , destAggs . getFieldsBoolean ( ) , NUM_ , srcAggs . getFieldsBoolean ( ) . length ) ; } if ( srcAggs . getFieldsCharacter ( ) != null ) { System . arraycopy ( srcAggs . getFieldsCharacter ( ) , NUM_ , destAggs . getFieldsCharacter ( ) , NUM_ , srcAggs . getFieldsCharacter ( ) . length ) ; } if ( srcAggs . getFieldsString ( ) != null ) { System . arraycopy ( srcAggs . getFieldsString ( ) , NUM_ , destAggs . getFieldsString ( ) , NUM_ , srcAggs . getFieldsString ( ) . length ) ; } if ( srcAggs . getFieldsShort ( ) != null ) { System . arraycopy ( srcAggs . getFieldsShort ( ) , NUM_ , destAggs . getFieldsShort ( ) , NUM_ , srcAggs . getFieldsShort ( ) . length ) ; } if ( srcAggs . getFieldsInteger ( ) != null ) { System . arraycopy ( srcAggs . getFieldsInteger ( ) , NUM_ , destAggs . getFieldsInteger ( ) , NUM_ , srcAggs . getFieldsInteger ( ) . length ) ; } if ( srcAggs . getFieldsLong ( ) != null ) { System . arraycopy ( srcAggs . getFieldsLong ( ) , NUM_ , destAggs . getFieldsLong ( ) , NUM_ , srcAggs . getFieldsLong ( ) . length ) ; } if ( srcAggs . getFieldsFloat ( ) != null ) { System . arraycopy ( srcAggs . getFieldsFloat ( ) , NUM_ , destAggs . getFieldsFloat ( ) , NUM_ , srcAggs . getFieldsFloat ( ) . length ) ; } if ( srcAggs . getFieldsDouble ( ) != null ) { System . arraycopy ( srcAggs . getFieldsDouble ( ) , NUM_ , destAggs . getFieldsDouble ( ) , NUM_ , srcAggs . getFieldsDouble ( ) . length ) ; } }
public static double assignProbabilitiesToInstances ( Relation < ? extends NumberVector > relation , List < ? extends EMClusterModel < ? > > models , WritableDataStore < double [ ] > probClusterIGivenX ) { final int k = models . size ( ) ; double emSum = NUM_ ; for ( DBIDIter iditer = relation . iterDBIDs ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { NumberVector vec = relation . get ( iditer ) ; double [ ] probabilities = new double [ k ] ; { int i = NUM_ ; for ( EMClusterModel < ? > m : models ) { probabilities [ i ] = m . estimateDensity ( vec ) ; ++ i ; } } double priorProbability = NUM_ ; for ( int i = NUM_ ; i < k ; i ++ ) { priorProbability += probabilities [ i ] ; } double logP = Math . max ( Math . log ( priorProbability ) , MIN_LOGLIKELIHOOD ) ; emSum += ( logP == logP ) ? logP : NUM_ ; double [ ] clusterProbabilities = new double [ k ] ; if ( priorProbability > NUM_ ) { for ( int i = NUM_ ; i < k ; i ++ ) { clusterProbabilities [ i ] = probabilities [ i ] / priorProbability ; } } probClusterIGivenX . put ( iditer , clusterProbabilities ) ; } return emSum / relation . size ( ) ; }
public static String separatorsToUnix ( String path ) { if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == - NUM_ ) { return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; }
public static String asString ( URI value ) { return value != null ? value . toString ( ) : null ; }
public Kernel ( int offset , double [ ] values ) { this . values = Arrays . copyOf ( values , values . length ) ; this . offset = offset ; }
private void initializeWorkList ( ) { for ( GVCongruenceClass c : B ) { if ( c . size ( ) == NUM_ ) { continue ; } Iterator < ValueGraphVertex > i = c . iterator ( ) ; ValueGraphVertex first = i . next ( ) ; while ( i . hasNext ( ) ) { ValueGraphVertex v = i . next ( ) ; if ( ! checkCongruence ( first , v ) ) { workList . push ( c ) ; break ; } } } }
@ Override protected void beforeModelLinked ( EObject model , IDiagnosticConsumer diagnosticsConsumer ) { ImportedNamesAdapter adapter = ImportedNamesAdapter . find ( model . eResource ( ) ) ; if ( adapter != null ) adapter . clear ( ) ; UnionMemberScope . clearCachedComposedMembers ( model ) ; }
protected abstract void addFile ( String relativeFilename ) throws CommandException ;
public void treeExpanded ( TreeExpansionEvent event ) { inspectorWindow . updateView ( Director . ALL ) ; }
public void convertInfixToPostfix ( String infixExp ) throws Exception { m_originalInfix = infixExp ; infixExp = Utils . removeSubstring ( infixExp , STR_ ) ; infixExp = Utils . replaceSubstring ( infixExp , STR_ , STR_ ) ; infixExp = Utils . replaceSubstring ( infixExp , STR_ , STR_ ) ; infixExp = Utils . replaceSubstring ( infixExp , STR_ , STR_ ) ; infixExp = Utils . replaceSubstring ( infixExp , STR_ , STR_ ) ; infixExp = Utils . replaceSubstring ( infixExp , STR_ , STR_ ) ; infixExp = Utils . replaceSubstring ( infixExp , STR_ , STR_ ) ; infixExp = Utils . replaceSubstring ( infixExp , STR_ , STR_ ) ; infixExp = Utils . replaceSubstring ( infixExp , STR_ , STR_ ) ; infixExp = Utils . replaceSubstring ( infixExp , STR_ , STR_ ) ; infixExp = Utils . replaceSubstring ( infixExp , STR_ , STR_ ) ; StringTokenizer tokenizer = new StringTokenizer ( infixExp , OPERATORS , BOOL_ ) ; m_postFixExpVector = new Vector < ExpressionComponent > ( ) ; while ( tokenizer . hasMoreTokens ( ) ) { String tok = tokenizer . nextToken ( ) ; if ( tok . length ( ) > NUM_ ) { handleOperand ( tok ) ; } else { if ( isOperator ( tok . charAt ( NUM_ ) ) ) { handleOperator ( tok ) ; } else { handleOperand ( tok ) ; } } m_previousTok = tok ; } while ( ! m_operatorStack . empty ( ) ) { String popop = ( String ) ( m_operatorStack . pop ( ) ) ; if ( popop . charAt ( NUM_ ) == STR_ || popop . charAt ( NUM_ ) == STR_ ) { throw new Exception ( STR_ ) ; } m_postFixExpVector . addElement ( new Operator ( popop . charAt ( NUM_ ) ) ) ; } }
public boolean hasItem ( T object ) { synchronized ( mLock ) { return source . contains ( object ) ; } }
private static boolean versionMatches ( Integer v1 , int v2 ) { if ( v1 == null || v1 == NUM_ || v2 == NUM_ ) { return BOOL_ ; } return v1 . equals ( v2 ) ; }
protected void onFailedClosingUrlConnection ( URLConnection urlConnection , IOException cause ) { }
private void onSchemaComplexType ( Element schemaComplexType , DatatypeElementFactory elementFactory ) { Iterator < Element > iter = schemaComplexType . elementIterator ( XSD_ATTRIBUTE ) ; while ( iter . hasNext ( ) ) { Element xsdAttribute = iter . next ( ) ; String name = xsdAttribute . attributeValue ( STR_ ) ; QName qname = getQName ( name ) ; XSDatatype dataType = dataTypeForXsdAttribute ( xsdAttribute ) ; if ( dataType != null ) { elementFactory . setAttributeXSDatatype ( qname , dataType ) ; } } Element schemaSequence = schemaComplexType . element ( XSD_SEQUENCE ) ; if ( schemaSequence != null ) { onChildElements ( schemaSequence , elementFactory ) ; } Element schemaChoice = schemaComplexType . element ( XSD_CHOICE ) ; if ( schemaChoice != null ) { onChildElements ( schemaChoice , elementFactory ) ; } Element schemaAll = schemaComplexType . element ( XSD_ALL ) ; if ( schemaAll != null ) { onChildElements ( schemaAll , elementFactory ) ; } }
private void pushAnnotatorsRef ( String values ) { annotatorsRef . push ( annotatorsRef . peek ( ) ) ; setAnnotatorsRef ( values ) ; }
public String versionCompact ( ) { return properties . getProperty ( STR_ ) ; }
private void sequenceQuery ( QueryEntry entry , ServerSessionContext session , CompletableFuture < QueryResponse > future ) { if ( entry . getSequence ( ) > session . getCommandSequence ( ) ) { session . registerSequenceQuery ( entry . getSequence ( ) , null ) ; } else { indexQuery ( entry , future ) ; } }
private boolean expungeStaleEntries ( ) { if ( size == NUM_ ) return BOOL_ ; Object r ; boolean result = BOOL_ ; while ( ( r = queue . poll ( ) ) != null ) { result = BOOL_ ; Entry e = ( Entry ) r ; int h = e . hash ; int i = indexFor ( h , table . length ) ; Entry prev = table [ i ] ; Entry p = prev ; while ( p != null ) { Entry next = p . next ; if ( p == e ) { if ( prev == e ) table [ i ] = next ; else prev . next = next ; e . next = null ; size -- ; break ; } prev = p ; p = next ; } } return result ; }
public static < T > List < T > rest ( List < T > l ) { return l . subList ( NUM_ , l . size ( ) ) ; }
public static List < Integer > createRanges ( int ... startEnds ) { assert startEnds . length % NUM_ == NUM_ ; ArrayList < Integer > ret = new ArrayList < Integer > ( ) ; for ( int si = NUM_ ; si < startEnds . length ; si ++ ) { final int start = startEnds [ si ++ ] ; final int end = startEnds [ si ] ; assert end >= start ; ret . ensureCapacity ( ret . size ( ) + ( ( end - start ) + NUM_ ) ) ; for ( int i = start ; i <= end ; i ++ ) { ret . add ( new Integer ( i ) ) ; } } return ret ; }
@ After public void tearDown ( ) { webClient . closeAllWindows ( ) ; }
public void findAndUndo ( Object someObj ) { if ( someObj instanceof com . bbn . openmap . MapBean ) { logger . fine ( STR_ ) ; MapBean map = getMapBean ( ) ; if ( map != null && map == ( MapBean ) someObj ) { setMapBean ( null ) ; } } }
public Timestamp recalculateEstimatedCompletionDate ( Long priority , Timestamp startDate ) { if ( exist ( ) ) { getProductionRunRoutingTasks ( ) ; if ( quantity == null ) getQuantity ( ) ; Timestamp endDate = null ; for ( Iterator < GenericValue > iter = productionRunRoutingTasks . iterator ( ) ; iter . hasNext ( ) ; ) { GenericValue routingTask = iter . next ( ) ; if ( priority . compareTo ( routingTask . getLong ( STR_ ) ) <= NUM_ ) { long totalTime = ProductionRun . getEstimatedTaskTime ( routingTask , quantity , dispatcher ) ; endDate = TechDataServices . addForward ( TechDataServices . getTechDataCalendar ( routingTask ) , startDate , totalTime ) ; routingTask . set ( STR_ , startDate ) ; routingTask . set ( STR_ , endDate ) ; startDate = endDate ; } } return endDate ; } else { return null ; } }
public void addDocumentType ( DocumentType documentType ) { mDocumentTypes . add ( documentType ) ; }
public boolean tableExists ( DatabaseMetaData dbMetaData , String tableName ) throws SQLException { return ( tableExistsCaseSensitive ( dbMetaData , tableName ) || tableExistsCaseSensitive ( dbMetaData , tableName . toUpperCase ( Locale . US ) ) || tableExistsCaseSensitive ( dbMetaData , tableName . toLowerCase ( Locale . US ) ) ) ; }
public void testHasAttributes1 ( ) throws Throwable { Document doc ; Element element ; NodeList elementList ; boolean hasAttributes ; doc = ( Document ) load ( STR_ , builder ) ; elementList = doc . getElementsByTagName ( STR_ ) ; element = ( Element ) elementList . item ( NUM_ ) ; hasAttributes = element . hasAttributes ( ) ; assertFalse ( STR_ , hasAttributes ) ; elementList = doc . getElementsByTagName ( STR_ ) ; element = ( Element ) elementList . item ( NUM_ ) ; hasAttributes = element . hasAttributes ( ) ; assertTrue ( STR_ , hasAttributes ) ; }
private static Position nextTokenPos ( Position pos , Token [ ] [ ] spec ) { if ( pos == null ) { return null ; } int nextItem = pos . item + NUM_ ; if ( ( nextItem < spec [ pos . line ] . length ) && ( ( pos . line < pcalEnd . line ) || ( nextItem < pcalEnd . item ) ) ) { return new Position ( pos . line , nextItem ) ; } int nextLine = pos . line + NUM_ ; while ( ( nextLine < spec . length ) && ( spec [ nextLine ] . length == NUM_ ) ) { nextLine ++ ; } if ( ( nextLine < spec . length ) && ( ( nextLine < pcalEnd . line ) || ( ( nextLine == pcalEnd . line ) && ( NUM_ < pcalEnd . item ) ) ) ) { return new Position ( nextLine , NUM_ ) ; } return null ; }
public void update ( GL10 gl ) { if ( taskQueue . size ( ) > NUM_ ) { GLResorceTask res ; while ( ( res = taskQueue . poll ( ) ) != null ) { res . perform ( gl ) ; } } }
private void checkIfDirectoriesExist ( File [ ] disk_dirs ) { DiskStoreFactoryImpl . checkIfDirectoriesExist ( disk_dirs ) ; }
private static byte [ ] readClass ( final InputStream is , boolean close ) throws IOException { if ( is == null ) { throw new IOException ( STR_ ) ; } try { byte [ ] b = new byte [ is . available ( ) ] ; int len = NUM_ ; while ( BOOL_ ) { int n = is . read ( b , len , b . length - len ) ; if ( n == - NUM_ ) { if ( len < b . length ) { byte [ ] c = new byte [ len ] ; System . arraycopy ( b , NUM_ , c , NUM_ , len ) ; b = c ; } return b ; } len += n ; if ( len == b . length ) { int last = is . read ( ) ; if ( last < NUM_ ) { return b ; } byte [ ] c = new byte [ b . length + NUM_ ] ; System . arraycopy ( b , NUM_ , c , NUM_ , len ) ; c [ len ++ ] = ( byte ) last ; b = c ; } } } finally { if ( close ) { is . close ( ) ; } } }
public void addPortToAlreadyAllocatedContext ( StoragePort port , StorageHADomain haDomain , StorageSystem . Type arrayType , String switchName ) { String engine = getEngine ( port , haDomain , arrayType ) ; if ( engine != null ) { _alreadyAllocatedEngines . add ( engine ) ; } String directorType = getDirectorType ( arrayType , haDomain ) ; if ( directorType != null ) { _alreadyAllocatedDirectorTypes . add ( directorType ) ; } String director = getDirector ( port , haDomain ) ; if ( director != null ) { _alreadyAllocatedDirectors . add ( director ) ; } String cpu = getCpu ( port , haDomain , arrayType ) ; if ( cpu != null ) { _alreadyAllocatedCpus . add ( cpu ) ; } if ( switchName != null ) { _alreadyAllocatedSwitches . add ( switchName ) ; } }
@ Override public void drawSeries ( Canvas canvas , Paint paint , List < Float > points , XYSeriesRenderer renderer , float yAxisValue , int seriesIndex , int startIndex ) { paint . setColor ( renderer . getColor ( ) ) ; paint . setStyle ( Style . FILL ) ; int length = points . size ( ) ; XYValueSeries series = ( XYValueSeries ) mDataset . getSeriesAt ( seriesIndex ) ; double max = series . getMaxValue ( ) ; double coef = MAX_BUBBLE_SIZE / max ; for ( int i = NUM_ ; i < length ; i += NUM_ ) { double size = series . getValue ( startIndex + i / NUM_ ) . coef + MIN_BUBBLE_SIZE ; drawCircle ( canvas , paint , points . get ( i ) , points . get ( i + NUM_ ) , ( float ) size ) ; } }
public String convert ( ) { if ( s == null ) { try { ByteArrayInputStream bs = new ByteArrayInputStream ( bytes ) ; DataInputStream d = new DataInputStream ( bs ) ; String buf = d . readUTF ( ) ; sHashCode = buf . hashCode ( ) ; return buf ; } catch ( IOException e ) { return STR_ ; } } return s ; }
public static void writeListOfLongs ( List list , boolean hasLongIDs , DataOutput out ) throws IOException { if ( list == null ) { out . writeInt ( - NUM_ ) ; } else { out . writeInt ( list . size ( ) ) ; out . writeBoolean ( hasLongIDs ) ; for ( Iterator it = list . iterator ( ) ; it . hasNext ( ) ; ) { Long l = ( Long ) it . next ( ) ; if ( hasLongIDs ) { out . writeLong ( l . longValue ( ) ) ; } else { out . writeInt ( ( int ) l . longValue ( ) ) ; } } } }
public boolean isDefined ( Object attrName ) { return table . containsKey ( attrName ) ; }
private void showPreloadingStage ( ) { Stage preloadingStage = new Stage ( StageStyle . UNDECORATED ) ; preloadingStage . initOwner ( primaryStage ) ; preloadingStage . setScene ( new PreloadingScene ( ) ) ; preloadingStage . show ( ) ; primaryStage . setOnShowing ( null ) ; }
@ Override public void clear ( ) { if ( elementCount > NUM_ ) { elementCount = NUM_ ; Arrays . fill ( elementData , null ) ; modCount ++ ; while ( referenceQueue . poll ( ) != null ) { } } }
public V remove ( Object key ) { int hash = hash ( key . hashCode ( ) ) ; Segment < K , V > s = segmentForHash ( hash ) ; return s == null ? null : s . remove ( key , hash , null ) ; }
public void test_copyStream_fullBlock ( ) throws IOException { final String id = STR_ ; final int version = NUM_ ; Random r = new Random ( ) ; final byte [ ] expected = new byte [ BLOCK_SIZE ] ; r . nextBytes ( expected ) ; assertEquals ( STR_ , expected . length , repo . copyStream ( id , version , new ByteArrayInputStream ( expected ) ) ) ; assertEquals ( STR_ , NUM_ , repo . getBlockCount ( id , version ) ) ; assertSameIterator ( STR_ , new Long [ ] { NUM_ } , repo . blocks ( id , version ) ) ; assertEquals ( STR_ , expected , read ( repo . inputStream ( id , version ) ) ) ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; String badString ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; nameNode = elementList . item ( NUM_ ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; { boolean success = BOOL_ ; try { badString = child . substringData ( - NUM_ , NUM_ ) ; } catch ( DOMException ex ) { success = ( ex . code == DOMException . INDEX_SIZE_ERR ) ; } assertTrue ( STR_ , success ) ; } }
private static int ipToBytes ( String ip , byte [ ] bytes , boolean mustHave4 ) throws IPMatcherException { String [ ] parts = ip . split ( STR_ ) ; if ( parts . length > NUM_ || mustHave4 && parts . length != NUM_ ) { throw new IPMatcherException ( STR_ + ip ) ; } try { for ( int i = NUM_ ; i < parts . length ; i ++ ) { int p = Integer . parseInt ( parts [ i ] ) ; if ( p < NUM_ || p > NUM_ ) { throw new IPMatcherException ( STR_ + ip ) ; } bytes [ i ] = ( byte ) ( p < NUM_ ? p : p - NUM_ ) ; } } catch ( NumberFormatException nfe ) { throw new IPMatcherException ( STR_ + ip , nfe ) ; } return parts . length ; }
protected void reply ( RequestContext context , String key , String message ) { try { HttpServletRequest request = context . getRequest ( ) ; String filename = request . getRemoteAddr ( ) ; end ( filename , key , message ) ; } catch ( Exception e ) { } }
protected void addHeaders ( HttpURLConnection connection , String tenantId ) { if ( tenantId == null ) { tenantId = PropertyUtil . getProperty ( PropertyUtil . HAWKULAR_TENANT ) ; } if ( tenantId != null ) { connection . setRequestProperty ( HAWKULAR_TENANT , tenantId ) ; } if ( authorization == null && username != null ) { String authString = username + STR_ + password ; String encoded = encoder . encodeToString ( authString . getBytes ( ) ) ; authorization = STR_ + encoded ; } if ( authorization != null ) { connection . setRequestProperty ( STR_ , authorization ) ; } }
public void addLongSelectionListener ( SelectionListener listener ) { if ( listener == null ) throw new IllegalArgumentException ( ) ; if ( hexEditControl == null ) { if ( listOfLongListeners == null ) listOfLongListeners = new ArrayList < > ( ) ; listOfLongListeners . add ( listener ) ; } else { hexEditControl . addLongSelectionListener ( listener ) ; } }
public void println ( ) throws IOException { out . write ( strategy . getPrinterNewline ( ) ) ; newLine = BOOL_ ; }
@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( STR_ ) ; boolean firstTime = BOOL_ ; for ( Entry < Integer , String > entry : mCapabilities . entrySet ( ) ) { if ( firstTime ) { firstTime = BOOL_ ; } else { sb . append ( STR_ ) ; } sb . append ( entry . getKey ( ) ) ; sb . append ( STR_ ) ; sb . append ( entry . getValue ( ) ) ; sb . append ( STR_ ) ; return mCapabilities . toString ( ) ; } return sb . toString ( ) ; }
protected final void refreshLoadingViewsSize ( ) { final int maximumPullScroll = ( int ) ( getMaximumPullScroll ( ) . NUM_ ) ; int pLeft = getPaddingLeft ( ) ; int pTop = getPaddingTop ( ) ; int pRight = getPaddingRight ( ) ; int pBottom = getPaddingBottom ( ) ; switch ( getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setWidth ( maximumPullScroll ) ; pLeft = - maximumPullScroll ; } else { pLeft = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setWidth ( maximumPullScroll ) ; pRight = - maximumPullScroll ; } else { pRight = NUM_ ; } break ; case VERTICAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setHeight ( maximumPullScroll ) ; pTop = - maximumPullScroll ; } else { pTop = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setHeight ( maximumPullScroll ) ; pBottom = - maximumPullScroll ; } else { pBottom = NUM_ ; } break ; } if ( DEBUG ) { Log . d ( LOG_TAG , String . format ( STR_ , pLeft , pTop , pRight , pBottom ) ) ; } setPadding ( pLeft , pTop , pRight , pBottom ) ; }
public Debug ( String clientID , ClientComms comms ) { this . clientID = clientID ; this . comms = comms ; log . setResourceName ( clientID ) ; }
protected String alterCase ( String value ) { switch ( getCase ( ) ) { case UPPERCASE : return value . toUpperCase ( ) ; case LOWERCASE : return value . toLowerCase ( ) ; default : return value ; } }
private boolean isAckRequired ( ) { return this . ackRequired ; }
@ Override public synchronized String toString ( ) { if ( elementCount == NUM_ ) { return STR_ ; } int length = elementCount - NUM_ ; StringBuffer buffer = new StringBuffer ( elementCount . NUM_ ) ; buffer . append ( STR_ ) ; for ( int i = NUM_ ; i < length ; i ++ ) { if ( elementData [ i ] == this ) { buffer . append ( STR_ ) ; } else { buffer . append ( elementData [ i ] ) ; } buffer . append ( STR_ ) ; } if ( elementData [ length ] == this ) { buffer . append ( STR_ ) ; } else { buffer . append ( elementData [ length ] ) ; } buffer . append ( STR_ ) ; return buffer . toString ( ) ; }
void addReporter ( String textReporter , int xx , int yy ) { ReporterIcon l = new ReporterIcon ( this ) ; l . setReporter ( textReporter ) ; l . setLocation ( xx , yy ) ; l . setSize ( l . getPreferredSize ( ) . width , l . getPreferredSize ( ) . height ) ; l . setDisplayLevel ( LABELS ) ; setDirty ( BOOL_ ) ; putItem ( l ) ; }
private void drawSelectionRectangle ( Graphics2D g2 ) { if ( this . selectionRectangle != null ) { if ( this . fillSelectionRectangle ) { g2 . setPaint ( this . selectionFillPaint ) ; g2 . fill ( selectionRectangle ) ; } else { g2 . setPaint ( this . selectionOutlinePaint ) ; g2 . draw ( selectionRectangle ) ; } } }
private int measureShort ( int measureSpec ) { int result ; int specMode = MeasureSpec . getMode ( measureSpec ) ; int specSize = MeasureSpec . getSize ( measureSpec ) ; if ( specMode == MeasureSpec . EXACTLY ) { result = specSize ; } else { result = ( int ) ( NUM_ . mRadius + getPaddingTop ( ) + getPaddingBottom ( ) + NUM_ ) ; if ( specMode == MeasureSpec . AT_MOST ) { result = Math . min ( result , specSize ) ; } } return result ; }
public ConversionException ( final Throwable cause ) { super ( cause . getMessage ( ) ) ; this . cause = cause ; }
private boolean hasConnectivityToAllSystems ( Initiator initiator , Collection < URI > storageSystems , ExportGroup exportGroup ) { return hasConnectivityToAllSystems ( initiator , storageSystems , null , exportGroup ) ; }
@ Override public boolean onTouchEvent ( MotionEvent event ) { if ( ! isEnabled ( ) ) return BOOL_ ; int pointerIndex ; final int action = event . getAction ( ) ; switch ( action & MotionEvent . ACTION_MASK ) { case MotionEvent . ACTION_DOWN : mActivePointerId = event . getPointerId ( event . getPointerCount ( ) - NUM_ ) ; pointerIndex = event . findPointerIndex ( mActivePointerId ) ; mDownMotionX = event . getX ( pointerIndex ) ; pressedThumb = evalPressedThumb ( mDownMotionX ) ; if ( pressedThumb == null ) return super . onTouchEvent ( event ) ; setPressed ( BOOL_ ) ; invalidate ( ) ; onStartTrackingTouch ( ) ; trackTouchEvent ( event ) ; attemptClaimDrag ( ) ; break ; case MotionEvent . ACTION_MOVE : if ( pressedThumb != null ) { if ( mIsDragging ) { trackTouchEvent ( event ) ; } else { pointerIndex = event . findPointerIndex ( mActivePointerId ) ; final float x = event . getX ( pointerIndex ) ; if ( Math . abs ( x - mDownMotionX ) > mScaledTouchSlop ) { setPressed ( BOOL_ ) ; invalidate ( ) ; onStartTrackingTouch ( ) ; trackTouchEvent ( event ) ; attemptClaimDrag ( ) ; } } if ( notifyWhileDragging && listener != null ) { listener . onRangeSeekBarValuesChanged ( this , getSelectedMinValue ( ) , getSelectedMaxValue ( ) ) ; } } break ; case MotionEvent . ACTION_UP : if ( mIsDragging ) { trackTouchEvent ( event ) ; onStopTrackingTouch ( ) ; setPressed ( BOOL_ ) ; } else { onStartTrackingTouch ( ) ; trackTouchEvent ( event ) ; onStopTrackingTouch ( ) ; } pressedThumb = null ; invalidate ( ) ; if ( listener != null ) { listener . onRangeSeekBarValuesChanged ( this , getSelectedMinValue ( ) , getSelectedMaxValue ( ) ) ; } break ; case MotionEvent . ACTION_POINTER_DOWN : { final int index = event . getPointerCount ( ) - NUM_ ; mDownMotionX = event . getX ( index ) ; mActivePointerId = event . getPointerId ( index ) ; invalidate ( ) ; break ; } case MotionEvent . ACTION_POINTER_UP : onSecondaryPointerUp ( event ) ; invalidate ( ) ; break ; case MotionEvent . ACTION_CANCEL : if ( mIsDragging ) { onStopTrackingTouch ( ) ; setPressed ( BOOL_ ) ; } invalidate ( ) ; break ; } return BOOL_ ; }
private Derivation < TK , FV > constructDerivation ( Derivation < TK , FV > markedNode , int sourceInputId , FeatureExtractor < TK , FV > featurizer , Scorer < FV > scorer , SearchHeuristic < TK , FV > heuristic , OutputSpace < TK , FV > outputSpace ) { final List < Derivation < TK , FV > > nodes = new LinkedList < > ( ) ; Derivation < TK , FV > p = markedNode ; while ( p != null ) { nodes . add ( NUM_ , p ) ; p = p . parent ; } p = markedNode . bestChild ; while ( p != null ) { nodes . add ( p ) ; p = p . bestChild ; } Derivation < TK , FV > goalHyp = null ; for ( Derivation < TK , FV > node : nodes ) { goalHyp = goalHyp == null ? node : new Derivation < > ( sourceInputId , node . rule , goalHyp . length , goalHyp , featurizer , scorer , heuristic , outputSpace ) ; } return goalHyp ; }
public void testPlusMathContextPositive ( ) { String a = STR_ ; int aScale = NUM_ ; int precision = NUM_ ; RoundingMode rm = RoundingMode . FLOOR ; MathContext mc = new MathContext ( precision , rm ) ; String c = STR_ ; int cScale = NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal res = aNumber . plus ( mc ) ; assertEquals ( STR_ , c , res . toString ( ) ) ; assertEquals ( STR_ , cScale , res . scale ( ) ) ; }
public void testRadix24Neg ( ) { String value = STR_ ; int radix = NUM_ ; BigInteger aNumber = new BigInteger ( value , radix ) ; String result = aNumber . toString ( radix ) ; assertTrue ( result . equals ( value ) ) ; }
private static IAbstractNode convertOr ( final CommonTree ast ) throws RecognitionException { final List < IAbstractNode > children = new ArrayList < IAbstractNode > ( ) ; for ( final Object childObject : ast . getChildren ( ) ) { children . add ( convert ( ( CommonTree ) childObject ) ) ; } return new CAbstractOrExpression ( children ) ; }
public JDialog displayPanelInWindow ( final JPanel panel , String title ) { JDialog frame = new GenericJDialog ( ) ; frame . setContentPane ( panel ) ; frame . pack ( ) ; frame . setTitle ( title ) ; frame . setVisible ( BOOL_ ) ; return frame ; }
public JSONTokener ( Reader reader ) { this . reader = reader . markSupported ( ) ? reader : new BufferedReader ( reader ) ; this . eof = BOOL_ ; this . usePrevious = BOOL_ ; this . previous = NUM_ ; this . index = NUM_ ; this . character = NUM_ ; this . line = NUM_ ; }
public static void compress ( ) { String s = BinaryStdIn . readString ( ) ; char [ ] input = s . toCharArray ( ) ; int [ ] freq = new int [ R ] ; for ( int i = NUM_ ; i < input . length ; i ++ ) freq [ input [ i ] ] ++ ; Node root = buildTrie ( freq ) ; String [ ] st = new String [ R ] ; buildCode ( st , root , STR_ ) ; writeTrie ( root ) ; BinaryStdOut . write ( input . length ) ; for ( int i = NUM_ ; i < input . length ; i ++ ) { String code = st [ input [ i ] ] ; for ( int j = NUM_ ; j < code . length ( ) ; j ++ ) { if ( code . charAt ( j ) == STR_ ) { BinaryStdOut . write ( BOOL_ ) ; } else if ( code . charAt ( j ) == STR_ ) { BinaryStdOut . write ( BOOL_ ) ; } else throw new IllegalStateException ( STR_ ) ; } } BinaryStdOut . close ( ) ; }
public Builder withTokenizer ( Class < ? extends TokenizerFactory > factory , Map < String , String > params ) throws IOException { Objects . requireNonNull ( factory , STR_ ) ; tokenizer . set ( applyResourceLoader ( newFactoryClassInstance ( factory , applyDefaultParams ( params ) ) ) ) ; componentsAdded = BOOL_ ; return this ; }
protected double computeAzimuthLabelOffset ( double radius , double maxRadius ) { return Math . asin ( AZIMUTH_LABEL_OFFSET . maxRadius / radius ) ; }
protected void addResource ( List defaults , String bundleName ) { ResourceBundle bundle = ResourceBundle . getBundle ( bundleName ) ; for ( Enumeration keys = bundle . getKeys ( ) ; keys . hasMoreElements ( ) ; ) { String key = ( String ) keys . nextElement ( ) ; defaults . add ( key ) ; defaults . add ( bundle . getObject ( key ) ) ; } }
public void displayChanged ( ) { executeDisplayChangedOnEDT ( getGraphicsConfiguration ( ) ) ; }
@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; Calendar dateTime = new GregorianCalendar ( GMT ) ; long localTime = value ; if ( tzShift != null ) { localTime += tzShift . longValue ( ) . NUM_ ; } dateTime . setTimeInMillis ( localTime ) ; try { appendInt ( sb , dateTime . get ( Calendar . YEAR ) , NUM_ ) ; sb . append ( STR_ ) ; appendInt ( sb , dateTime . get ( Calendar . MONTH ) + NUM_ , NUM_ ) ; sb . append ( STR_ ) ; appendInt ( sb , dateTime . get ( Calendar . DAY_OF_MONTH ) , NUM_ ) ; if ( ! dateOnly ) { sb . append ( STR_ ) ; appendInt ( sb , dateTime . get ( Calendar . HOUR_OF_DAY ) , NUM_ ) ; sb . append ( STR_ ) ; appendInt ( sb , dateTime . get ( Calendar . MINUTE ) , NUM_ ) ; sb . append ( STR_ ) ; appendInt ( sb , dateTime . get ( Calendar . SECOND ) , NUM_ ) ; if ( dateTime . isSet ( Calendar . MILLISECOND ) ) { sb . append ( STR_ ) ; appendInt ( sb , dateTime . get ( Calendar . MILLISECOND ) , NUM_ ) ; } } if ( tzShift != null ) { if ( tzShift . intValue ( ) == NUM_ ) { sb . append ( STR_ ) ; } else { int absTzShift = tzShift . intValue ( ) ; if ( tzShift > NUM_ ) { sb . append ( STR_ ) ; } else { sb . append ( STR_ ) ; absTzShift = - absTzShift ; } int tzHours = absTzShift / NUM_ ; int tzMinutes = absTzShift % NUM_ ; appendInt ( sb , tzHours , NUM_ ) ; sb . append ( STR_ ) ; appendInt ( sb , tzMinutes , NUM_ ) ; } } } catch ( ArrayIndexOutOfBoundsException e ) { throw new RuntimeException ( e ) ; } return sb . toString ( ) ; }
private static Stream < Method > extractMethods ( Class clazz ) { try { Method [ ] methods = clazz . getMethods ( ) ; if ( methods . length > NUM_ ) { return Stream . of ( methods ) ; } } catch ( Exception | Error e ) { LOG . warn ( STR_ , clazz , e ) ; } return Stream . empty ( ) ; }
@ Override public void updateServerAddress ( Application application , String dockerManagerIP , String serverPort , String serverManagerPort ) { String suffixCloudUnit = application . getSuffixCloudUnitIO ( ) ; JedisPool pool = null ; Jedis jedis = null ; try { pool = new JedisPool ( new JedisPoolConfig ( ) , redisIp , Integer . parseInt ( redisPort ) , NUM_ ) ; jedis = pool . getResource ( ) ; String subNameSpace = concatSubNameSpace ( application ) ; String key = subNameSpace + suffixCloudUnit ; String frontend = STR_ + key . toLowerCase ( ) ; jedis . lset ( frontend , NUM_ , STR_ + dockerManagerIP + STR_ + serverPort ) ; String frontendServerManager = STR_ + key . toLowerCase ( ) ; jedis . lset ( frontendServerManager , NUM_ , STR_ + dockerManagerIP + STR_ + serverManagerPort ) ; } catch ( JedisConnectionException | UnsupportedEncodingException e ) { logger . error ( STR_ , e ) ; } finally { if ( jedis != null ) { pool . destroy ( ) ; } } }
protected void remove ( int itemPosition ) { if ( itemPosition >= NUM_ && itemPosition < getItemCount ( ) ) { list . remove ( itemPosition ) ; } }
protected String chooseRandomEnemys ( ) { final List < String > enemyList = new LinkedList < String > ( enemyForces . keySet ( ) ) ; final int enemySize = enemyList . size ( ) ; final int position = Rand . rand ( enemySize ) ; return enemyList . get ( position ) ; }
public boolean isRouteToDestValid ( Block protecting , Block destination ) { if ( protecting == destination ) { log . debug ( STR_ ) ; if ( getAdjacency ( protecting ) != null ) { return BOOL_ ; } } else if ( getValidRoute ( protecting , destination ) != null ) { return BOOL_ ; } return BOOL_ ; }
public void sortPools ( List < StoragePool > storagePools ) { _portMetricsProcessor . computeStoragePoolsAvgPortMetrics ( storagePools ) ; Collections . sort ( storagePools , _storagePoolComparator ) ; }
public RhythmGroup addOverlays ( Collection < RhythmOverlay > overlays ) { mOverlays . addAll ( overlays ) ; if ( mCurrentOverlayIndex == NO_OVERLAY ) { selectOverlay ( NUM_ ) ; } return this ; }
public static Resource forPath ( final String path ) throws UnknownResourceException { Resource resource ; if ( path . startsWith ( ClasspathResource . PREFIX + STR_ ) ) { resource = new ClasspathResource ( path ) ; } else if ( path . startsWith ( FileResource . PREFIX + STR_ ) ) { resource = new FileResource ( path ) ; } else { resource = forPath ( FileResource . PREFIX + STR_ + path ) ; } return resource ; }
private static boolean isOlderThanLeopard ( ) { String version = System . getProperty ( STR_ ) ; StringTokenizer tk = new StringTokenizer ( version , STR_ ) ; int major = Integer . parseInt ( tk . nextToken ( ) ) ; int minor = Integer . parseInt ( tk . nextToken ( ) ) ; return major == NUM_ && minor < NUM_ ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
public static String xmlContentEscape ( String s ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = NUM_ ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; switch ( c ) { case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : break ; default : sb . append ( c ) ; } } return sb . toString ( ) ; }
private void feedForward ( Vec input , List < Vec > activations , List < Vec > derivatives ) { Vec x = input ; for ( int i = NUM_ ; i < Ws . size ( ) ; i ++ ) { Matrix W_i = Ws . get ( i ) ; Vec b_i = bs . get ( i ) ; Vec a_i = activations . get ( i ) ; a_i . zeroOut ( ) ; W_i . multiply ( x , NUM_ , a_i ) ; a_i . mutableAdd ( b_i ) ; a_i . applyFunction ( f ) ; Vec d_i = derivatives . get ( i ) ; a_i . copyTo ( d_i ) ; d_i . applyFunction ( f . getD ( ) ) ; x = a_i ; } }
private File findFile ( File directory , String name ) throws FileNotFoundException { File file = new File ( directory , name ) ; if ( file . exists ( ) ) { return file ; } for ( String child : directory . list ( ) ) { if ( child . equalsIgnoreCase ( name ) ) { return new File ( directory , child ) ; } } throw new FileNotFoundException ( STR_ + file ) ; }
public static boolean compareResults ( SolrClient controlClient , SolrClient cloudClient ) throws SolrServerException , IOException { return compareResults ( controlClient , cloudClient , null , null ) ; }
public ArrayList < String > GetElementList ( String xPathExpression ) { try { ArrayList < String > values = new ArrayList < String > ( ) ; List < ? > nodeList = XPath . selectNodes ( this . xmlDocument , xPathExpression ) ; Iterator < ? > iter = nodeList . iterator ( ) ; while ( iter . hasNext ( ) ) { org . jdom . Element element = ( org . jdom . Element ) iter . next ( ) ; values . add ( element . getText ( ) ) ; } return values ; } catch ( Exception ex ) { LOG . error ( STR_ + ex . getMessage ( ) , ex ) ; return null ; } }
public static CLContext createContextFromCurrentGL ( ) { RuntimeException first = null ; for ( CLPlatform platform : listPlatforms ( ) ) { try { CLContext ctx = platform . createContextFromCurrentGL ( ) ; if ( ctx != null ) return ctx ; } catch ( RuntimeException ex ) { if ( first == null ) first = ex ; } } throw new RuntimeException ( STR_ , first ) ; }
public void collapseTree ( ) { for ( int i = NUM_ ; i < tree . getRowCount ( ) ; ++ i ) { tree . collapseRow ( i ) ; } }
static void queuePlayerCapeReplacement ( AbstractClientPlayer player ) { final String displayName = player . getDisplayNameString ( ) ; Logger . info ( STR_ , displayName ) ; THREAD_POOL . submit ( null ) ; }
public void removeVetoableChangeListener ( VetoableChangeListener listener ) { if ( listener != null ) { synchronized ( this ) { if ( vetoableSupport != null ) { vetoableSupport . removeVetoableChangeListener ( listener ) ; } } } }
public StreamThroughput ( String statusMessagePrefix ) { m_instanceCount = NUM_ ; m_sampleCount = NUM_ ; m_numSamples = NUM_ ; m_cumulativeTime = NUM_ ; m_startTime = System . currentTimeMillis ( ) ; m_statusMessagePrefix = statusMessagePrefix ; }
protected void parseCommand ( final String ... args ) { for ( String arg : args ) { final Command command = Command . valueOfName ( arg ) ; if ( command != null ) { setCommand ( command ) ; break ; } } }
@ RequestMapping ( value = STR_ , method = RequestMethod . PUT ) public ResponseEntity < Bookmark > editBookmark ( @ PathVariable ( value = STR_ ) String username , @ PathVariable ( value = STR_ ) int bookmarkId , @ RequestBody String json ) throws IOException , BookmarkNotFoundException , IllegalAccessException , InvocationTargetException { Optional < Bookmark > optional = bookmarksRepository . findByIdAndUserUsername ( bookmarkId , username ) ; if ( optional . isPresent ( ) ) { ObjectMapper mapper = new ObjectMapper ( ) ; Map < String , String > changeMap = mapper . readValue ( json , HashMap . class ) ; Bookmark bookmark = optional . get ( ) ; BeanUtils . populate ( bookmark , changeMap ) ; bookmark = bookmarksRepository . save ( bookmark ) ; return new ResponseEntity < > ( bookmark , HttpStatus . OK ) ; } else { throw new BookmarkNotFoundException ( STR_ + bookmarkId ) ; } }
private Rect calcBounds ( int index , Paint paint ) { Rect bounds = new Rect ( ) ; CharSequence title = getTitle ( index ) ; bounds . right = ( int ) paint . measureText ( title , NUM_ , title . length ( ) ) ; bounds . bottom = ( int ) ( paint . descent ( ) - paint . ascent ( ) ) ; return bounds ; }
public static String convertFromUtf32 ( int [ ] text , int startPos , int endPos ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = startPos ; i < endPos ; i ++ ) { sb . append ( convertFromUtf32ToCharArray ( text [ i ] ) ) ; } return sb . toString ( ) ; }
public void createBounds ( ) { if ( isEmpty ( ) || hasSingleElement ( ) ) { mBounds = null ; return ; } int l = Integer . MAX_VALUE ; int t = Integer . MAX_VALUE ; int r = NUM_ ; int b = NUM_ ; for ( Selection . Element selection : getElements ( ) ) { ConstraintWidget w = selection . widget ; l = Math . min ( w . getDrawX ( ) , l ) ; t = Math . min ( w . getDrawY ( ) , t ) ; r = Math . max ( w . getDrawRight ( ) , r ) ; b = Math . max ( w . getDrawBottom ( ) , b ) ; } ConstraintWidget bounds = new ConstraintWidget ( l , t , r - l , b - t ) ; bounds . setCompanionWidget ( WidgetCompanion . create ( bounds ) ) ; mBounds = new Element ( bounds ) ; updateOriginFromBounds ( ) ; }
protected static void recordPattern ( BitArray row , int start , int [ ] counters ) throws NotFoundException { int numCounters = counters . length ; Arrays . fill ( counters , NUM_ , numCounters , NUM_ ) ; int end = row . getSize ( ) ; if ( start >= end ) { throw NotFoundException . getNotFoundInstance ( ) ; } boolean isWhite = ! row . get ( start ) ; int counterPosition = NUM_ ; int i = start ; while ( i < end ) { if ( row . get ( i ) ^ isWhite ) { counters [ counterPosition ] ++ ; } else { counterPosition ++ ; if ( counterPosition == numCounters ) { break ; } else { counters [ counterPosition ] = NUM_ ; isWhite = ! isWhite ; } } i ++ ; } if ( ! ( counterPosition == numCounters || ( counterPosition == numCounters - NUM_ && i == end ) ) ) { throw NotFoundException . getNotFoundInstance ( ) ; } }
public static Object [ ] findMethodWithListParameters ( Object service , String methodName , List < ? > args ) { Object [ ] arguments = new Object [ args . size ( ) ] ; for ( int i = NUM_ ; i < args . size ( ) ; i ++ ) { arguments [ i ] = args . get ( i ) ; } return findMethodWithListParameters ( service , methodName , arguments ) ; }
static int firstIllegalCharacter ( String source ) { for ( int i = NUM_ ; i < source . length ( ) ; i ++ ) { if ( isLegal ( source . charAt ( i ) ) == BOOL_ ) { return i ; } } return - NUM_ ; }
private CoderResult decodeByteBufferToCharacterBuffer ( boolean endOfInput ) throws DecodingException { buffer . flip ( ) ; return decodeMoreBytesToCharacterBuffer ( endOfInput ) ; }
protected void newFastClockMinute ( ) { for ( int i = delayedTrains . size ( ) - NUM_ ; i >= NUM_ ; i -- ) { ActiveTrain at = delayedTrains . get ( i ) ; if ( ( ! at . getStarted ( ) ) && at . getDelayedStart ( ) != ActiveTrain . NODELAY ) { if ( at . getDelayedStart ( ) == ActiveTrain . TIMEDDELAY ) { if ( isFastClockTimeGE ( at . getDepartureTimeHr ( ) , at . getDepartureTimeMin ( ) ) ) { at . setStarted ( ) ; delayedTrains . remove ( i ) ; if ( _AutoAllocate ) { autoAllocate . scanAllocationRequestList ( allocationRequests ) ; } } } } else if ( at . getStarted ( ) && at . getStatus ( ) == ActiveTrain . READY && at . reachedRestartPoint ( ) ) { if ( isFastClockTimeGE ( at . getRestartDepartHr ( ) , at . getRestartDepartMin ( ) ) ) { at . restart ( ) ; delayedTrains . remove ( i ) ; if ( _AutoAllocate ) { autoAllocate . scanAllocationRequestList ( allocationRequests ) ; } } } } }
public void add ( final CreatureRespawnPoint point ) { respawnPoints . add ( point ) ; }
private void loadOrgAccessRole ( ArrayList < OrgAccess > list ) { PreparedStatement pstmt = null ; ResultSet rs = null ; String sql = STR_ + STR_ ; try { pstmt = DB . prepareStatement ( sql , get_TrxName ( ) ) ; pstmt . setInt ( NUM_ , getAD_Role_ID ( ) ) ; rs = pstmt . executeQuery ( ) ; while ( rs . next ( ) ) { MRoleOrgAccess oa = new MRoleOrgAccess ( getCtx ( ) , rs , get_TrxName ( ) ) ; loadOrgAccessAdd ( list , new OrgAccess ( oa . getAD_Client_ID ( ) , oa . getAD_Org_ID ( ) , oa . isReadOnly ( ) ) ) ; } } catch ( Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } finally { DB . close ( rs , pstmt ) ; } }
public void testBytesAsSource ( ) throws Exception { String JSON = STR_ ; byte [ ] b = JSON . getBytes ( STR_ ) ; int offset = NUM_ ; int len = b . length ; byte [ ] src = new byte [ offset + len + offset ] ; System . arraycopy ( b , NUM_ , src , offset , len ) ; JsonFactory jf = new JsonFactory ( ) ; JsonParser jp = jf . createJsonParser ( src , offset , len ) ; assertToken ( JsonToken . START_ARRAY , jp . nextToken ( ) ) ; assertToken ( JsonToken . VALUE_NUMBER_INT , jp . nextToken ( ) ) ; assertEquals ( NUM_ , jp . getIntValue ( ) ) ; assertToken ( JsonToken . VALUE_NUMBER_INT , jp . nextToken ( ) ) ; assertEquals ( NUM_ , jp . getIntValue ( ) ) ; assertToken ( JsonToken . VALUE_NUMBER_INT , jp . nextToken ( ) ) ; assertEquals ( NUM_ , jp . getIntValue ( ) ) ; assertToken ( JsonToken . VALUE_NUMBER_INT , jp . nextToken ( ) ) ; assertEquals ( NUM_ , jp . getIntValue ( ) ) ; assertToken ( JsonToken . END_ARRAY , jp . nextToken ( ) ) ; assertNull ( jp . nextToken ( ) ) ; jp . close ( ) ; }
public java . security . cert . Certificate engineGenerateCertificate ( InputStream in ) throws CertificateException { if ( currentStream == null ) { currentStream = in ; sData = null ; sDataObjectCount = NUM_ ; } else if ( currentStream != in ) { currentStream = in ; sData = null ; sDataObjectCount = NUM_ ; } try { if ( sData != null ) { if ( sDataObjectCount != sData . size ( ) ) { return getCertificate ( ) ; } else { sData = null ; sDataObjectCount = NUM_ ; return null ; } } PushbackInputStream pis = new PushbackInputStream ( in ) ; int tag = pis . read ( ) ; if ( tag == - NUM_ ) { return null ; } pis . unread ( tag ) ; if ( tag != x30 ) { return readPEMCertificate ( pis ) ; } else { return readDERCertificate ( new ASN1InputStream ( pis ) ) ; } } catch ( Exception e ) { throw new ExCertificateException ( e ) ; } }
public String toString ( Object value ) { return toPrettyString ( value ) ; }
@ Override public List < Period > generateRollingPeriods ( DateTimeUnit dateTimeUnit ) { Calendar cal = getCalendar ( ) ; dateTimeUnit . setDay ( NUM_ ) ; dateTimeUnit = cal . minusMonths ( dateTimeUnit , NUM_ ) ; List < Period > periods = Lists . newArrayList ( ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { periods . add ( createPeriod ( dateTimeUnit , cal ) ) ; dateTimeUnit = cal . plusMonths ( dateTimeUnit , NUM_ ) ; } return periods ; }
@ SuppressWarnings ( STR_ ) public synchronized T findCounter ( Enum < ? > counterKey ) throws IllegalAccessException , InstantiationException { T counter = cache . get ( counterKey ) ; if ( counter == null ) { counter = counterType . newInstance ( ) ; cache . put ( counterKey , counter ) ; } return counter ; }
public static Uri addMessageToUri ( ContentResolver resolver , Uri uri , String address , String body , String subject , Long date , boolean read , boolean deliveryReport , long threadId ) { ContentValues values = new ContentValues ( NUM_ ) ; values . put ( Sms . ADDRESS , address ) ; if ( date != null ) { values . put ( Sms . DATE , date ) ; } values . put ( Sms . READ , read ? Integer . valueOf ( NUM_ ) : Integer . valueOf ( NUM_ ) ) ; values . put ( Sms . SUBJECT , subject ) ; values . put ( Sms . BODY , body ) ; if ( deliveryReport ) { values . put ( Sms . STATUS , Sms . STATUS_PENDING ) ; } if ( threadId != - NUM_ ) { values . put ( Sms . THREAD_ID , threadId ) ; } return resolver . insert ( uri , values ) ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; String childData ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; nameNode = elementList . item ( NUM_ ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; childData = child . getData ( ) ; assertEquals ( STR_ , STR_ , childData ) ; }
protected void engineSetMode ( String mode ) { if ( ! mode . equalsIgnoreCase ( STR_ ) ) { throw new IllegalArgumentException ( STR_ + mode ) ; } }
@ SuppressWarnings ( STR_ ) private void expungeStaleEntries ( ) { synchronized ( sync ) { ListWeakReference r ; while ( ( r = ( ListWeakReference ) queue . poll ( ) ) != null ) { ListEntry le = r . getListEntry ( ) ; int i = list . indexOf ( le ) ; if ( i != - NUM_ ) { list . remove ( i ) ; } } } }
protected void work ( final IResource resource , final List < WorkItem > resources , IProgressMonitor monitor ) { IPreferenceStore store = FindbugsPlugin . getPluginPreferences ( getProject ( ) ) ; boolean runAsJob = store . getBoolean ( FindBugsConstants . KEY_RUN_ANALYSIS_AS_EXTRA_JOB ) ; FindBugsJob fbJob = new StartedFromBuilderJob ( STR_ + resource . getName ( ) + STR_ , resource , resources ) ; if ( runAsJob ) { if ( DEBUG ) { FindbugsPlugin . log ( STR_ ) ; } FindBugsJob . cancelSimilarJobs ( fbJob ) ; if ( DEBUG ) { FindbugsPlugin . log ( STR_ ) ; } fbJob . scheduleAsSystem ( ) ; if ( DEBUG ) { FindbugsPlugin . log ( STR_ ) ; } } else { if ( DEBUG ) { FindbugsPlugin . log ( STR_ ) ; } fbJob . run ( monitor ) ; if ( DEBUG ) { FindbugsPlugin . log ( STR_ ) ; } } }
public void fireVetoableChange ( String name , Object oldValue , Object newValue ) throws PropertyVetoException { super . fireVetoableChange ( name , oldValue , newValue ) ; beanContextChildSupport . fireVetoableChange ( name , oldValue , newValue ) ; }
@ Override public void onFullBackup ( FullBackupDataOutput output ) throws IOException { if ( mVolumes != null ) { if ( DEBUG ) Slog . i ( TAG , STR_ + mVolumes . length + STR_ ) ; HashSet < String > externalFilesDirFilter = new HashSet < String > ( ) ; final File externalAndroidRoot = new File ( Environment . getExternalStorageDirectory ( ) , Environment . DIRECTORY_ANDROID ) ; externalFilesDirFilter . add ( externalAndroidRoot . getCanonicalPath ( ) ) ; for ( int i = NUM_ ; i < mVolumes . length ; i ++ ) { StorageVolume v = mVolumes [ i ] ; String domain = FullBackup . SHARED_PREFIX + i ; fullBackupFileTree ( null , domain , v . getPath ( ) , externalFilesDirFilter , output ) ; } } }
public static void removeConnectionList ( Integer tab ) { TABBED_CONNECTIONS . remove ( tab . intValue ( ) ) ; }
public static String separatorsToWindows ( String path ) { if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == - NUM_ ) { return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; }
public void translateAndAppendPending ( int backoff ) throws UnsupportedEncodingException { int bufferEnd = current - backoff ; int len = bufferEnd - complete ; output . append ( new String ( input , offset + complete , len , charset ) ) ; complete = bufferEnd ; }
@ Override public Trie optimize ( Trie orig ) { List < CharSequence > cmds = orig . cmds ; List < Row > rows = new ArrayList < > ( ) ; List < Row > orows = orig . rows ; int remap [ ] = new int [ orows . size ( ) ] ; for ( int j = orows . size ( ) - NUM_ ; j >= NUM_ ; j -- ) { liftUp ( orows . get ( j ) , orows ) ; } Arrays . fill ( remap , - NUM_ ) ; rows = removeGaps ( orig . root , orows , new ArrayList < Row > ( ) , remap ) ; return new Trie ( orig . forward , remap [ orig . root ] , cmds , rows ) ; }
private Handler < Void > installAfterHandler ( final HttpServerRequest request , final Buffer buffer , final List < Listener > afterListener ) { Handler < Void > afterHandler = null ; return afterHandler ; }
private void tryShutdown ( ) { if ( isClosing ( ) && isOkToClose ( ) ) shutdown ( closeFuture . get ( ) ) ; }
public StorageEntity createStorageEntity ( String storageName , StoragePlatformEntity storagePlatformEntity , List < Attribute > attributes ) { StorageEntity storageEntity = new StorageEntity ( ) ; storageEntity . setName ( storageName ) ; storageEntity . setStoragePlatform ( storagePlatformEntity ) ; if ( ! CollectionUtils . isEmpty ( attributes ) ) { List < StorageAttributeEntity > attributeEntities = new ArrayList < > ( ) ; storageEntity . setAttributes ( attributeEntities ) ; for ( Attribute attribute : attributes ) { StorageAttributeEntity attributeEntity = new StorageAttributeEntity ( ) ; attributeEntities . add ( attributeEntity ) ; attributeEntity . setStorage ( storageEntity ) ; attributeEntity . setName ( attribute . getName ( ) ) ; attributeEntity . setValue ( attribute . getValue ( ) ) ; } } return storageDao . saveAndRefresh ( storageEntity ) ; }
public void displayInfoLine ( String infoLine , int labelDesignator ) { if ( infoLineHolder != null ) { setLabel ( ( infoLine != null && infoLine . length ( ) > NUM_ ) ? infoLine : fudgeString , labelDesignator ) ; } }
public Console format ( String format , Object ... args ) { Formatter f = new Formatter ( writer ) ; f . format ( format , args ) ; f . flush ( ) ; return this ; }
@ After public void tearDown ( ) { webClient . closeAllWindows ( ) ; }
public void testSignerStringIdentityScope ( ) throws Exception { Signer s = new SignerStub ( STR_ , IdentityScope . getSystemScope ( ) ) ; assertNotNull ( s ) ; assertEquals ( STR_ , s . getName ( ) ) ; assertSame ( IdentityScope . getSystemScope ( ) , s . getScope ( ) ) ; assertNull ( s . getPrivateKey ( ) ) ; try { Signer s2 = new SignerStub ( STR_ , IdentityScope . getSystemScope ( ) ) ; fail ( STR_ ) ; } catch ( KeyManagementException e ) { } Signer s2 = new SignerStub ( null ) ; assertNull ( s2 . getName ( ) ) ; }
private static void decodeAnsiX12Segment ( BitSource bits , StringBuilder result ) throws FormatException { int [ ] cValues = new int [ NUM_ ] ; do { if ( bits . available ( ) == NUM_ ) { return ; } int firstByte = bits . readBits ( NUM_ ) ; if ( firstByte == NUM_ ) { return ; } parseTwoBytes ( firstByte , bits . readBits ( NUM_ ) , cValues ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { int cValue = cValues [ i ] ; if ( cValue == NUM_ ) { result . append ( STR_ ) ; } else if ( cValue == NUM_ ) { result . append ( STR_ ) ; } else if ( cValue == NUM_ ) { result . append ( STR_ ) ; } else if ( cValue == NUM_ ) { result . append ( STR_ ) ; } else if ( cValue < NUM_ ) { result . append ( ( char ) ( cValue + NUM_ ) ) ; } else if ( cValue < NUM_ ) { result . append ( ( char ) ( cValue + NUM_ ) ) ; } else { throw FormatException . getFormatInstance ( ) ; } } } while ( bits . available ( ) > NUM_ ) ; }
public TSink < byte [ ] > sendBytes ( TStream < byte [ ] > stream ) { Objects . requireNonNull ( stream , STR_ ) ; return sendBinary ( stream , null ) ; }
public static Object invokeStaticMethod ( BshClassManager bcm , Class clas , String methodName , Object [ ] args ) throws ReflectError , UtilEvalError , InvocationTargetException { Interpreter . debug ( STR_ ) ; Method method = resolveExpectedJavaMethod ( bcm , clas , null , methodName , args , BOOL_ ) ; return invokeMethod ( method , null , args ) ; }
private void fitImageToView ( ) { Drawable drawable = getDrawable ( ) ; if ( drawable == null || drawable . getIntrinsicWidth ( ) == NUM_ || drawable . getIntrinsicHeight ( ) == NUM_ ) { return ; } if ( matrix == null || prevMatrix == null ) { return ; } int drawableWidth = drawable . getIntrinsicWidth ( ) ; int drawableHeight = drawable . getIntrinsicHeight ( ) ; float scaleX = ( float ) viewWidth / drawableWidth ; float scaleY = ( float ) viewHeight / drawableHeight ; switch ( mScaleType ) { case CENTER : scaleX = scaleY = NUM_ ; break ; case CENTER_CROP : scaleX = scaleY = Math . max ( scaleX , scaleY ) ; break ; case CENTER_INSIDE : scaleX = scaleY = Math . min ( NUM_ , Math . min ( scaleX , scaleY ) ) ; case FIT_CENTER : scaleX = scaleY = Math . min ( scaleX , scaleY ) ; break ; case FIT_XY : break ; default : throw new UnsupportedOperationException ( STR_ ) ; } float redundantXSpace = viewWidth - ( scaleX . drawableWidth ) ; float redundantYSpace = viewHeight - ( scaleY . drawableHeight ) ; matchViewWidth = viewWidth - redundantXSpace ; matchViewHeight = viewHeight - redundantYSpace ; if ( ! isZoomed ( ) && ! imageRenderedAtLeastOnce ) { matrix . setScale ( scaleX , scaleY ) ; matrix . postTranslate ( redundantXSpace / NUM_ , redundantYSpace / NUM_ ) ; normalizedScale = NUM_ ; } else { if ( prevMatchViewWidth == NUM_ || prevMatchViewHeight == NUM_ ) { savePreviousImageValues ( ) ; } prevMatrix . getValues ( m ) ; m [ Matrix . MSCALE_X ] = matchViewWidth / drawableWidth . normalizedScale ; m [ Matrix . MSCALE_Y ] = matchViewHeight / drawableHeight . normalizedScale ; float transX = m [ Matrix . MTRANS_X ] ; float transY = m [ Matrix . MTRANS_Y ] ; float prevActualWidth = prevMatchViewWidth . normalizedScale ; float actualWidth = getImageWidth ( ) ; translateMatrixAfterRotate ( Matrix . MTRANS_X , transX , prevActualWidth , actualWidth , prevViewWidth , viewWidth , drawableWidth ) ; float prevActualHeight = prevMatchViewHeight . normalizedScale ; float actualHeight = getImageHeight ( ) ; translateMatrixAfterRotate ( Matrix . MTRANS_Y , transY , prevActualHeight , actualHeight , prevViewHeight , viewHeight , drawableHeight ) ; matrix . setValues ( m ) ; } fixTrans ( ) ; setImageMatrix ( matrix ) ; }
protected AbstractRegexNPAnnotator ( String pattern , boolean caseSensitive , double confidence ) { this ( Pattern . compile ( pattern , caseSensitive ? NUM_ : Pattern . CASE_INSENSITIVE ) , NUM_ , confidence ) ; }
private static void removeLoopSafepoint ( StructuredGraph graph ) { LoopBeginNode loopBegin = findFirstLoop ( graph ) ; loopBegin . disableSafepoint ( ) ; }
protected abstract void bindItem ( DataBoundViewHolder < T > holder , int position , List < Object > payloads ) ;
public void testCase7 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int bSign = NUM_ ; byte rBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . add ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public synchronized void add ( double minValue , double maxValue ) { super . add ( minValue ) ; mMaxValues . add ( maxValue ) ; }
public static Date daysBefore ( Date dateInst , int numDays ) { if ( ( numDays <= NUM_ ) || ( dateInst == null ) ) { throw new IllegalArgumentException ( ) ; } final Calendar cal = new GregorianCalendar ( ) ; cal . setTime ( dateInst ) ; cal . add ( Calendar . DAY_OF_YEAR , - numDays ) ; return cal . getTime ( ) ; }
public final int remainingCapacity ( ) { return Math . max ( NUM_ , capacity - cache . size ( ) ) ; }
public static byte [ ] decode ( String encoded ) { if ( encoded == null ) { return null ; } char [ ] base64Data = encoded . toCharArray ( ) ; int len = removeWhiteSpace ( base64Data ) ; if ( len % FOURBYTE != NUM_ ) { return null ; } int numberQuadruple = ( len / FOURBYTE ) ; if ( numberQuadruple == NUM_ ) { return new byte [ NUM_ ] ; } byte decodedData [ ] = null ; byte b1 = NUM_ , b2 = NUM_ , b3 = NUM_ , b4 = NUM_ ; char d1 = NUM_ , d2 = NUM_ , d3 = NUM_ , d4 = NUM_ ; int i = NUM_ ; int encodedIndex = NUM_ ; int dataIndex = NUM_ ; decodedData = new byte [ ( numberQuadruple ) . NUM_ ] ; for ( ; i < numberQuadruple - NUM_ ; i ++ ) { if ( ! isData ( ( d1 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d2 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d3 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d4 = base64Data [ dataIndex ++ ] ) ) ) { return null ; } b1 = base64Alphabet [ d1 ] ; b2 = base64Alphabet [ d2 ] ; b3 = base64Alphabet [ d3 ] ; b4 = base64Alphabet [ d4 ] ; decodedData [ encodedIndex ++ ] = ( byte ) ( b1 << NUM_ | b2 > > NUM_ ) ; decodedData [ encodedIndex ++ ] = ( byte ) ( ( ( b2 & xf ) << NUM_ ) | ( ( b3 > > NUM_ ) & xf ) ) ; decodedData [ encodedIndex ++ ] = ( byte ) ( b3 << NUM_ | b4 ) ; } if ( ! isData ( ( d1 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d2 = base64Data [ dataIndex ++ ] ) ) ) { return null ; } b1 = base64Alphabet [ d1 ] ; b2 = base64Alphabet [ d2 ] ; d3 = base64Data [ dataIndex ++ ] ; d4 = base64Data [ dataIndex ++ ] ; if ( ! isData ( ( d3 ) ) || ! isData ( ( d4 ) ) ) { if ( isPad ( d3 ) && isPad ( d4 ) ) { if ( ( b2 & xf ) != NUM_ ) { return null ; } byte [ ] tmp = new byte [ i . NUM_ + NUM_ ] ; System . arraycopy ( decodedData , NUM_ , tmp , NUM_ , i . NUM_ ) ; tmp [ encodedIndex ] = ( byte ) ( b1 << NUM_ | b2 > > NUM_ ) ; return tmp ; } else if ( ! isPad ( d3 ) && isPad ( d4 ) ) { b3 = base64Alphabet [ d3 ] ; if ( ( b3 & x3 ) != NUM_ ) { return null ; } byte [ ] tmp = new byte [ i . NUM_ + NUM_ ] ; System . arraycopy ( decodedData , NUM_ , tmp , NUM_ , i . NUM_ ) ; tmp [ encodedIndex ++ ] = ( byte ) ( b1 << NUM_ | b2 > > NUM_ ) ; tmp [ encodedIndex ] = ( byte ) ( ( ( b2 & xf ) << NUM_ ) | ( ( b3 > > NUM_ ) & xf ) ) ; return tmp ; } else { return null ; } } else { b3 = base64Alphabet [ d3 ] ; b4 = base64Alphabet [ d4 ] ; decodedData [ encodedIndex ++ ] = ( byte ) ( b1 << NUM_ | b2 > > NUM_ ) ; decodedData [ encodedIndex ++ ] = ( byte ) ( ( ( b2 & xf ) << NUM_ ) | ( ( b3 > > NUM_ ) & xf ) ) ; decodedData [ encodedIndex ++ ] = ( byte ) ( b3 << NUM_ | b4 ) ; } return decodedData ; }
@ Override public void writeExternal ( ObjectOutput out ) throws IOException { super . writeExternal ( out ) ; out . writeObject ( conservativeApproximation ) ; }
int putData ( Object data ) throws FitsException { long lsize = ArrayFuncs . computeLSize ( data ) ; if ( lsize > Integer . MAX_VALUE ) { throw new FitsException ( STR_ ) ; } int size = ( int ) lsize ; expandHeap ( size ) ; ByteArrayOutputStream bo = new ByteArrayOutputStream ( size ) ; try { BufferedDataOutputStream o = new BufferedDataOutputStream ( bo ) ; o . writeArray ( data ) ; o . flush ( ) ; o . close ( ) ; } catch ( IOException e ) { throw new FitsException ( STR_ , e ) ; } System . arraycopy ( bo . toByteArray ( ) , NUM_ , this . heap , this . heapSize , size ) ; int oldOffset = this . heapSize ; this . heapSize += size ; return oldOffset ; }
public void paint ( Graphics g ) { try { super . paint ( g ) ; } catch ( Exception e ) { } int focusedRow = getFocusedRow ( BOOL_ ) ; if ( focusedRow != - NUM_ && focusedRow < getRowCount ( ) ) { Border rowBorder = UIManager . getBorder ( STR_ ) ; if ( rowBorder != null ) { Rectangle rect = getCellRect ( focusedRow , NUM_ , BOOL_ ) ; rect . width = getWidth ( ) ; rowBorder . paintBorder ( this , g , rect . x , rect . y , rect . width , rect . height ) ; } } }
private void add ( final JLabel label , final JTextField field ) { panel . add ( label ) ; panel . add ( field ) ; if ( previous == null ) { layout . putConstraint ( SpringLayout . NORTH , panel , - SPACING , SpringLayout . NORTH , label ) ; } else { layout . putConstraint ( SpringLayout . NORTH , label , SPACING , SpringLayout . SOUTH , previous ) ; } layout . putConstraint ( SpringLayout . WEST , panel , - SPACING , SpringLayout . WEST , label ) ; layout . putConstraint ( SpringLayout . SOUTH , panel , SPACING , SpringLayout . SOUTH , label ) ; layout . putConstraint ( SpringLayout . EAST , field , - SPACING , SpringLayout . EAST , panel ) ; layout . putConstraint ( SpringLayout . WEST , field , - ( TEXT_FIELD_WIDTH + SPACING ) , SpringLayout . EAST , panel ) ; layout . putConstraint ( SpringLayout . SOUTH , field , SPACING , SpringLayout . SOUTH , label ) ; previous = label ; }
private void onTrackPointStart ( Attributes attributes ) { latitude = attributes . getValue ( ATTRIBUTE_LAT ) ; longitude = attributes . getValue ( ATTRIBUTE_LON ) ; altitude = null ; time = null ; }
public static byte [ ] combine ( final List < byte [ ] > dataChunks ) { int totalSize = NUM_ ; for ( final byte [ ] dataPart : dataChunks ) { totalSize += dataPart . length ; } final byte [ ] data = new byte [ totalSize ] ; int index = NUM_ ; for ( final byte [ ] dataPart : dataChunks ) { System . arraycopy ( dataPart , NUM_ , data , index , dataPart . length ) ; index += dataPart . length ; } return data ; }
public void commit ( IResource [ ] resources , String comment , boolean keepLocks , IProgressMonitor monitor ) throws TeamException { if ( monitor == null ) { monitor = new NullProgressMonitor ( ) ; } Map table = getProviderMapping ( resources ) ; Set keySet = table . keySet ( ) ; monitor . beginTask ( STR_ , keySet . size ( ) . NUM_ ) ; monitor . setTaskName ( Policy . bind ( STR_ ) ) ; Iterator iterator = keySet . iterator ( ) ; while ( iterator . hasNext ( ) ) { IProgressMonitor subMonitor = new SubProgressMonitor ( monitor , NUM_ ) ; SVNTeamProvider provider = ( SVNTeamProvider ) iterator . next ( ) ; List list = ( List ) table . get ( provider ) ; IResource [ ] providerResources = ( IResource [ ] ) list . toArray ( new IResource [ list . size ( ) ] ) ; provider . checkin ( providerResources , comment , keepLocks , IResource . DEPTH_INFINITE , subMonitor ) ; } }
public boolean canSpawnWorkers ( ) { boolean canSpawnWorker = BOOL_ ; if ( verboseLogLevel > NUM_ ) { Utilities . verboseLog ( STR_ + gridName + STR_ + tier + STR_ + maxTierDepth + STR_ + lifeRemaining ( ) + STR_ + maximumLifeMillis ) ; } if ( ! gridName . equals ( STR_ ) ) { return BOOL_ ; } if ( clusterState != null ) { Long timeSinceClusterLastUpdatedClusterState = System . currentTimeMillis ( ) - clusterState . getLastUpdated ( ) ; Utilities . verboseLog ( STR_ + timeSinceClusterLastUpdatedClusterState ) ; if ( timeSinceClusterLastUpdatedClusterState > NUM_ . gridCheckInterval . NUM_ ) { Utilities . verboseLog ( STR_ + clusterState . toString ( ) ) ; return BOOL_ ; } } else { return BOOL_ ; } if ( tier == maxTierDepth ) { return BOOL_ ; } if ( lifeRemaining ( ) < ( maximumLifeMillis . NUM_ ) ) { return BOOL_ ; } switch ( tier ) { case NUM_ : canSpawnWorker = BOOL_ ; break ; case NUM_ : canSpawnWorker = BOOL_ ; break ; case NUM_ : canSpawnWorker = BOOL_ ; break ; case NUM_ : canSpawnWorker = BOOL_ ; break ; default : if ( gridThrottle ) { canSpawnWorker = BOOL_ ; } else { canSpawnWorker = BOOL_ ; } } return canSpawnWorker ; }
public boolean equals ( Object object ) { if ( object == null || ! ( object instanceof SessionID ) ) { return BOOL_ ; } SessionID another = ( SessionID ) object ; return encryptedString . equals ( another . encryptedString ) ; }
public static boolean areIdentical ( String playerIdent , OfflinePlayer compareTo ) { return playerIdent . equals ( getIdentificationForAsString ( compareTo ) ) ; }
Builder addLenient ( String name , String value ) { namesAndValues . add ( name ) ; namesAndValues . add ( value . trim ( ) ) ; return this ; }
protected String stringWithoutHeader ( ) { StringBuffer text = new StringBuffer ( ) ; for ( int i = NUM_ ; i < numInstances ( ) ; i ++ ) { text . append ( instance ( i ) ) ; if ( i < numInstances ( ) - NUM_ ) { text . append ( STR_ ) ; } } return text . toString ( ) ; }
protected boolean isAlwaysNonNull ( Value v ) { return BOOL_ ; }
public final < T > void removeInternal ( List < T > list , int position ) { if ( hasHeaderView ( ) && position == NUM_ ) return ; if ( enableLoadMore ( ) && position == getItemCount ( ) - NUM_ ) return ; if ( list . size ( ) > NUM_ ) { synchronized ( mLock ) { list . remove ( hasHeaderView ( ) ? position - NUM_ : position ) ; } removeNotifyExternal ( position ) ; notifyItemRemoved ( position ) ; } }
public AMPrimaryMastHeadViewBean ( String name ) { super ( name ) ; }
public boolean consumedGesture ( ) { return reacted ; }
private void initializeLayer ( List < Neuron > layer , NeuronUpdateRule nodeType , int nodes ) { for ( int i = NUM_ ; i < nodes ; i ++ ) { Neuron node = new Neuron ( getParentNetwork ( ) , nodeType ) ; layer . add ( node ) ; } }
public static double angle ( Coordinate p ) { return Math . atan2 ( p . y , p . x ) ; }
public void fireNeuronMoved ( final Neuron moved ) { for ( NeuronListener listener : neuronListeners ) { listener . neuronMoved ( new NetworkEvent < Neuron > ( this , moved ) ) ; } }
public IOUtils ( ) { super ( ) ; }
public static X509Certificate createCertificateFromBytes ( byte [ ] certBytes ) { X509Certificate cert = null ; CertificateFactory certFactory ; try { certFactory = CertificateFactory . getInstance ( STR_ ) ; InputStream in = new ByteArrayInputStream ( certBytes ) ; cert = ( X509Certificate ) certFactory . generateCertificate ( in ) ; } catch ( CertificateException e ) { logger . warn ( STR_ + STR_ , e ) ; } return cert ; }
void handleSelectionChanged ( String selection ) { if ( mDidExpandSelection ) { mDidExpandSelection = BOOL_ ; return ; } if ( selection == null || selection . isEmpty ( ) ) { scheduleInvalidTapNotification ( ) ; if ( mSelectionType == SelectionType . TAP ) { resetSelectionStates ( ) ; return ; } } if ( selection != null && ! selection . isEmpty ( ) ) { unscheduleInvalidTapNotification ( ) ; } mSelectedText = selection ; if ( mWasTapGestureDetected ) { mSelectionType = SelectionType . TAP ; handleSelection ( selection , mSelectionType ) ; mWasTapGestureDetected = BOOL_ ; } else { mHandler . handleSelectionModification ( selection , mX , mY ) ; } }
public TermsAckParser parse ( ) throws ParserConfigurationException , SAXException , ParseFailureException { try { SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; SAXParser parser = factory . newSAXParser ( ) ; parser . parse ( mInputSource , this ) ; return this ; } catch ( IOException e ) { throw new ParseFailureException ( STR_ , e ) ; } }
public static String format ( final String value , String ... params ) { validate ( value , NULL_STRING_PREDICATE , NULL_STRING_MSG_SUPPLIER ) ; Pattern p = Pattern . compile ( STR_ ) ; Matcher m = p . matcher ( value ) ; String result = value ; while ( m . find ( ) ) { int paramNumber = Integer . parseInt ( m . group ( NUM_ ) ) ; if ( params == null || paramNumber >= params . length ) { throw new IllegalArgumentException ( STR_ + m . group ( ) ) ; } result = result . replace ( m . group ( ) , params [ paramNumber ] ) ; } return result ; }
public Builder server ( String server ) { if ( server . endsWith ( STR_ ) == BOOL_ ) { server = server + STR_ ; } this . server = server ; return this ; }
private ResponsePacket executeCount ( QueryTemplatePacket template , IJSpace space , Transaction txn ) throws SQLException { try { template . setRouting ( getRouting ( ) ) ; template . setExplainPlan ( getExplainPlan ( ) ) ; int count = space . count ( template , txn , getReadModifier ( ) ) ; ResponsePacket response = new ResponsePacket ( ) ; Object [ ] [ ] values = new Object [ NUM_ ] [ NUM_ ] ; values [ NUM_ ] [ NUM_ ] = count ; ResultEntry result = new ResultEntry ( new String [ ] { getCountColumnName ( ) } , new String [ ] { getCountColumnLabel ( ) } , new String [ ] { STR_ } , values ) ; response . setResultEntry ( result ) ; return response ; } catch ( Exception e ) { if ( _logger . isLoggable ( Level . SEVERE ) ) { _logger . log ( Level . SEVERE , e . getMessage ( ) , e ) ; } throw new SQLException ( STR_ + e , STR_ , - NUM_ ) ; } }
void deriveConfidenceValue ( double baseCount ) { if ( Utils . isMissingValue ( m_confidence ) && ! Utils . isMissingValue ( baseCount ) && baseCount > NUM_ ) { m_confidence = m_recordCount / baseCount ; } }
public ModifiableSolrParams add ( String name , String ... val ) { String [ ] old = vals . put ( name , val ) ; if ( old != null ) { if ( val == null || val . length < NUM_ ) { String [ ] both = new String [ old . length + NUM_ ] ; System . arraycopy ( old , NUM_ , both , NUM_ , old . length ) ; both [ old . length ] = null ; vals . put ( name , both ) ; } else { String [ ] both = new String [ old . length + val . length ] ; System . arraycopy ( old , NUM_ , both , NUM_ , old . length ) ; System . arraycopy ( val , NUM_ , both , old . length , val . length ) ; vals . put ( name , both ) ; } } return this ; }
private AStarNode jump ( int nextX , int nextY , int nextZ , int px , int pz ) { int y = nextY ; int dist = currentNode . getG ( ) + ( Math . abs ( nextX - currentNode . x ) + Math . abs ( y - currentNode . y ) + Math . abs ( nextZ - currentNode . z ) ) ; int dx = nextX - px ; int dz = nextZ - pz ; int py = y ; y = getGroundNodeHeight ( nextX , py , nextZ ) ; if ( y == NUM_ ) { return null ; } else if ( targetNode . x == nextX && targetNode . z == nextZ && targetNode . y == y || dist >= MAX_SKIP_DISTANCE ) { return new AStarNode ( nextX , y , nextZ , dist , currentNode , targetNode ) ; } int nxY = ( dx != NUM_ ) ? getGroundNodeHeight ( nextX + dx , y , nextZ ) : NUM_ ; int nzY = ( dz != NUM_ ) ? getGroundNodeHeight ( nextX , y , nextZ + dz ) : NUM_ ; if ( dx != NUM_ && dz != NUM_ ) { if ( ( getGroundNodeHeight ( nextX - dx , y , nextZ + dz ) != NUM_ && getGroundNodeHeight ( nextX - dx , py , nextZ ) == NUM_ ) || ( getGroundNodeHeight ( nextX + dx , y , nextZ - dz ) != NUM_ && getGroundNodeHeight ( nextX , py , nextZ - dz ) == NUM_ ) ) { return new AStarNode ( nextX , y , nextZ , dist , currentNode , targetNode ) ; } } else { if ( dx != NUM_ ) { if ( nxY != y || ( getGroundNodeHeight ( nextX , y , nextZ + NUM_ ) == NUM_ && getGroundNodeHeight ( nextX + dx , nxY , nextZ + NUM_ ) != NUM_ ) || ( getGroundNodeHeight ( nextX , y , nextZ - NUM_ ) == NUM_ && getGroundNodeHeight ( nextX + dx , nxY , nextZ - NUM_ ) != NUM_ ) ) { return new AStarNode ( nextX , y , nextZ , dist , currentNode , targetNode ) ; } } else { if ( nzY != y || ( getGroundNodeHeight ( nextX + NUM_ , y , nextZ ) == NUM_ && getGroundNodeHeight ( nextX + NUM_ , nzY , nextZ + dz ) != NUM_ ) || ( getGroundNodeHeight ( nextX - NUM_ , y , nextZ ) == NUM_ && getGroundNodeHeight ( nextX - NUM_ , nzY , nextZ + dz ) != NUM_ ) ) { return new AStarNode ( nextX , y , nextZ , dist , currentNode , targetNode ) ; } } } if ( dx != NUM_ && dz != NUM_ ) { AStarNode jx = jump ( nextX + dx , y , nextZ , nextX , nextZ ) ; AStarNode jy = jump ( nextX , y , nextZ + dz , nextX , nextZ ) ; if ( jx != null || jy != null ) { return new AStarNode ( nextX , y , nextZ , dist , currentNode , targetNode ) ; } } if ( nxY != NUM_ || nzY != NUM_ ) { return jump ( nextX + dx , y , nextZ + dz , nextX , nextZ ) ; } else { return null ; } }
public ByteArrayDataSource ( InputStream is , String type ) { try { ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; int ch ; while ( ( ch = is . read ( ) ) != - NUM_ ) { os . write ( ch ) ; } m_data = os . toByteArray ( ) ; } catch ( IOException ioex ) { log . log ( Level . WARNING , STR_ , ioex ) ; } if ( type != null && type . length ( ) > NUM_ ) m_type = type ; }
Object toType ( String value , String pattern , Locale locale ) { Calendar calendar = toCalendar ( value , pattern , locale ) ; return toType ( calendar ) ; }
public void addLimitLine ( LimitLine l ) { mLimitLines . add ( l ) ; if ( mLimitLines . size ( ) > NUM_ ) { Log . e ( STR_ , STR_ ) ; } }
public void readData ( DataInput din ) throws IOException { function = din . readUnsignedShort ( ) ; data = ( short ) ( din . readShort ( ) & xFFFF ) ; }
int readResults ( final byte [ ] b , final int bPos , final int bAvail , final Context context ) { if ( context . buffer != null ) { final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; context . readPos += len ; if ( context . readPos >= context . pos ) { context . buffer = null ; } return len ; } return context . eof ? EOF : NUM_ ; }
public static int inflate ( byte [ ] previous , int previousLength , byte [ ] current , int currentLength , byte [ ] result ) { if ( previous == null ) { System . arraycopy ( current , NUM_ , result , NUM_ , currentLength ) ; return currentLength ; } int length = NUM_ ; int start1 = NUM_ ; int start2 = NUM_ ; while ( start1 < previousLength && start2 < currentLength ) { int end1 = start1 ; while ( end1 < previousLength && previous [ end1 ] != STR_ ) { end1 ++ ; } int end2 = start2 ; while ( end2 < currentLength && current [ end2 ] != STR_ ) { end2 ++ ; } if ( current [ start2 ] == STR_ && end2 == start2 + NUM_ ) { for ( int i = start1 ; i < end1 ; i ++ ) result [ length ++ ] = previous [ i ] ; } else { for ( int i = start2 ; i < end2 ; i ++ ) result [ length ++ ] = current [ i ] ; } if ( end2 < currentLength ) result [ length ++ ] = STR_ ; start1 = end1 + NUM_ ; start2 = end2 + NUM_ ; } return length ; }
public Object [ ] toArray ( ) { final Object [ ] items = this . items ; final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { final int count = this . count ; Object [ ] a = new Object [ count ] ; int n = items . length - takeIndex ; if ( count <= n ) { System . arraycopy ( items , takeIndex , a , NUM_ , count ) ; } else { System . arraycopy ( items , takeIndex , a , NUM_ , n ) ; System . arraycopy ( items , NUM_ , a , n , count - n ) ; } return a ; } finally { lock . unlock ( ) ; } }
public void addContainer ( ImageContainer container ) { mContainers . add ( container ) ; }
public IOUtils ( ) { super ( ) ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; String childData ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; nameNode = elementList . item ( NUM_ ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; child . replaceData ( NUM_ , NUM_ , STR_ ) ; childData = child . getData ( ) ; assertEquals ( STR_ , STR_ , childData ) ; }
private void Legends ( List < String > legends_list , List < Integer > color_code_list ) { textPaint . setColor ( Color . BLACK ) ; textPaint . setTextSize ( NUM_ ) ; int left = ( int ) ( graphwidth . NUM_ ) ; for ( int i = NUM_ ; i < legends_list . size ( ) ; i ++ ) { String label = legends_list . get ( i ) ; float text_width = textPaint . measureText ( label , NUM_ , label . length ( ) ) ; int color = color_code_list . get ( i ) ; if ( ! ( ( graphwidth - legendLeft ) > ( text_width + NUM_ ) ) ) { legendTop -= NUM_ ; legendLeft = left ; } addLegends ( canvas , color , legendTop , legendLeft , legendRight , legendBottom , label ) ; legendLeft += ( ( int ) text_width + NUM_ ) ; } }
private void fetchMetadata ( TableMapLogEvent tableEvent ) throws SQLException , ReplicatorException { if ( metadataCache == null ) metadataCache = new TableMetadataCache ( NUM_ ) ; Table table = metadataCache . retrieve ( tableEvent . getDatabaseName ( ) , tableEvent . getTableName ( ) ) ; if ( table == null || table . getTableId ( ) != tableEvent . getTableId ( ) ) { prepareMetadataConnection ( ) ; table = metadataConnection . findTable ( tableEvent . getDatabaseName ( ) , tableEvent . getTableName ( ) , BOOL_ ) ; if ( table != null ) { table . setTableId ( tableEvent . getTableId ( ) ) ; metadataCache . store ( table ) ; } } else if ( logger . isDebugEnabled ( ) ) logger . debug ( STR_ + tableEvent . getDatabaseName ( ) + STR_ + tableEvent . getTableName ( ) + STR_ ) ; if ( table == null ) { logger . warn ( STR_ + tableEvent . getDatabaseName ( ) + STR_ + tableEvent . getTableName ( ) ) ; } else { tableEvent . setTable ( table ) ; } }
public String encode ( ) { StringBuffer sb = new StringBuffer ( ) ; encode ( sb ) ; return sb . toString ( ) ; }
@ Override public int read ( byte [ ] buf , int offset , int len ) throws IOException { int available = _available ; if ( available > NUM_ ) { len = Math . min ( len , available ) ; len = _next . read ( buf , offset , len ) ; if ( len > NUM_ ) { _available -= len ; } } else if ( available == NUM_ ) { _available = readChunkLength ( ) ; if ( _available > NUM_ ) { len = Math . min ( len , _available ) ; len = _next . read ( buf , offset , len ) ; if ( len > NUM_ ) _available -= len ; } else { _available = - NUM_ ; len = - NUM_ ; } } else { len = - NUM_ ; } return len ; }
@ Override public void flush ( ) { FlushTask task ; synchronized ( logRecords ) { task = new FlushTask ( new ArrayList < String > ( logRecords ) ) ; logRecords . clear ( ) ; } task . run ( ) ; }
public static ArrayList < Page > pageCreatorButtons ( ArrayList < Page > pages , Item manualType ) { ArrayList < Page > newPages = new ArrayList < > ( ) ; int pageAmount = pages . size ( ) ; int times = NUM_ ; while ( pageAmount > NUM_ ) { ArrayList < Page > pagesTemp = new ArrayList < > ( ) ; pagesTemp . addAll ( pages . subList ( NUM_ . times , ( pageAmount > NUM_ ? NUM_ + NUM_ . times : NUM_ . times + pageAmount ) ) ) ; int height = NUM_ ; ArrayList < ManualWidgetBase > widgets = new ArrayList < > ( ) ; for ( Page page : pagesTemp ) { widgets . add ( new ButtonWidget ( NUM_ , NUM_ + height , page ) ) ; height += NUM_ ; } newPages . add ( new Page ( STR_ + times , ( ArrayList < ManualWidgetBase > ) widgets . clone ( ) , BOOL_ , manualType ) ) ; widgets . clear ( ) ; pagesTemp . clear ( ) ; pageAmount -= NUM_ ; times ++ ; } return newPages ; }
public void testPosPosFirstLonger ( ) { byte aBytes [ ] = { - NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ } ; byte bBytes [ ] = { - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int bSign = NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . and ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
protected List < String > createNewExportMaskWorkflowForInitiators ( List < URI > initiatorURIs , ExportGroup exportGroup , Workflow workflow , Map < URI , Integer > volumeMap , StorageSystem storage , String token , String previousStep ) throws Exception { List < String > newSteps = new ArrayList < > ( ) ; if ( ! initiatorURIs . isEmpty ( ) ) { Map < String , List < URI > > computeResourceToInitiators = mapInitiatorsToComputeResource ( exportGroup , initiatorURIs ) ; for ( Map . Entry < String , List < URI > > resourceEntry : computeResourceToInitiators . entrySet ( ) ) { String computeKey = resourceEntry . getKey ( ) ; List < URI > computeInitiatorURIs = resourceEntry . getValue ( ) ; _log . info ( String . format ( STR_ , computeKey ) ) ; GenExportMaskCreateWorkflowResult result = generateDeviceSpecificExportMaskCreateWorkFlow ( workflow , previousStep , storage , exportGroup , computeInitiatorURIs , volumeMap , token ) ; previousStep = result . getStepId ( ) ; newSteps . add ( previousStep ) ; } } if ( newSteps . isEmpty ( ) && previousStep != null ) { newSteps . add ( previousStep ) ; } return newSteps ; }
public boolean isLessThen ( Percent Percent ) { assertDefined ( ) ; BigDecimal thisValue = notNull ( this ) ; BigDecimal parameter = notNull ( Percent ) ; return ( thisValue . compareTo ( parameter ) < NUM_ ) ; }
@ Override public URI toEdgeURI ( final Object key ) { return toURI ( key . toString ( ) ) ; }
short readShort ( ) throws IOException { mDexFile . readFully ( tmpBuf , NUM_ , NUM_ ) ; if ( isBigEndian ) { return ( short ) ( ( tmpBuf [ NUM_ ] & xff ) | ( ( tmpBuf [ NUM_ ] & xff ) << NUM_ ) ) ; } else { return ( short ) ( ( tmpBuf [ NUM_ ] & xff ) | ( ( tmpBuf [ NUM_ ] & xff ) << NUM_ ) ) ; } }
public static List < INaviProject > loadProjects ( final AbstractSQLProvider provider , final DebuggerTemplateManager debuggerManager ) throws CouldntLoadDataException { PostgreSQLDatabaseFunctions . checkArguments ( provider , debuggerManager ) ; final CConnection connection = provider . getConnection ( ) ; final List < INaviProject > projects = new ArrayList < > ( ) ; if ( ! PostgreSQLHelpers . hasTable ( connection , CTableNames . PROJECTS_TABLE ) ) { return projects ; } String query = STR_ + STR_ + CTableNames . ADDRESS_SPACES_TABLE + STR_ + CTableNames . PROJECTS_TABLE + STR_ + STR_ + CTableNames . PROJECTS_TABLE ; try ( ResultSet resultSet = connection . executeQuery ( query , BOOL_ ) ) { while ( resultSet . next ( ) ) { final int projectId = resultSet . getInt ( STR_ ) ; final String name = PostgreSQLHelpers . readString ( resultSet , STR_ ) ; final String description = PostgreSQLHelpers . readString ( resultSet , STR_ ) ; final int addressSpaceCount = resultSet . getInt ( STR_ ) ; final Timestamp creationDate = resultSet . getTimestamp ( STR_ ) ; final Timestamp modificationDate = resultSet . getTimestamp ( STR_ ) ; final List < DebuggerTemplate > debuggers = PostgreSQLDatabaseFunctions . getAssignedDebuggers ( connection , projectId , debuggerManager ) ; projects . add ( new CProject ( projectId , name , description == null ? STR_ : description , creationDate , modificationDate , addressSpaceCount , debuggers , provider ) ) ; } } catch ( final SQLException e ) { throw new CouldntLoadDataException ( e ) ; } return new ArrayList < INaviProject > ( projects ) ; }
public String syllabify ( String phoneString ) { LinkedList < String > phoneList = splitIntoAllophones ( phoneString ) ; syllabify ( phoneList ) ; StringBuilder sb = new StringBuilder ( ) ; for ( String p : phoneList ) { if ( sb . length ( ) > NUM_ ) sb . append ( STR_ ) ; sb . append ( p ) ; } return sb . toString ( ) ; }
@ Override protected Node removeFromFrontier ( ) { cleanUpFrontier ( ) ; Node result = frontier . remove ( ) ; updateMetrics ( frontier . size ( ) ) ; setExplored ( result ) ; return result ; }
public static boolean isFile ( String path ) { File f = new File ( path ) ; return f . isFile ( ) ; }
public boolean equals ( Object object ) { if ( ! ( object instanceof ObjectInstance ) ) { return BOOL_ ; } ObjectInstance val = ( ObjectInstance ) object ; if ( ! name . equals ( val . getObjectName ( ) ) ) return BOOL_ ; if ( className == null ) return ( val . getClassName ( ) == null ) ; return className . equals ( val . getClassName ( ) ) ; }
public ZookeeperEmbedded ( int port ) { this . port = port ; this . logDir = new File ( System . getProperty ( STR_ ) , STR_ + port ) ; }
public BasicCondition ( String variable , Value value , Relation relation ) { this . variable = Template . create ( variable ) ; this . templateValue = Template . create ( value . toString ( ) ) ; this . groundValue = value ; this . relation = relation ; }
public static Set < String > readStopwordsPath ( Path path , boolean lowercase ) throws IOException { return readStopwordsInputStream ( Files . newInputStream ( path ) , lowercase ) ; }
@ Override public String toString ( ) { StringBuilder sRep = new StringBuilder ( ) ; sRep . append ( STR_ ) ; sRep . append ( articleID ) ; sRep . append ( STR_ ) ; sRep . append ( revisionCounter ) ; sRep . append ( STR_ ) ; sRep . append ( timeStamp ) ; sRep . append ( STR_ ) ; sRep . append ( revisionId ) ; if ( revisionText != null ) { sRep . append ( STR_ ) ; sRep . append ( revisionText . length ( ) ) ; } sRep . append ( STR_ ) ; return sRep . toString ( ) ; }
private void breakBarrier ( ) { generation . broken = BOOL_ ; count = parties ; trip . signalAll ( ) ; }
public List < Entry > filter ( List < Entry > points , double tolerance ) { if ( tolerance <= NUM_ ) return points ; keep = new boolean [ points . size ( ) ] ; switch ( mType ) { case DOUGLAS_PEUCKER : return reduceWithDouglasPeuker ( points , tolerance ) ; case NONE : return points ; default : return points ; } }
protected void sendLogEvent ( String component , String message , Callback < Object > callback ) { String syslogMessage = String . format ( Locale . US , STR_ , getSysLogFormattedDate ( ) , utils . getApplicationName ( context ) , component , message ) ; sendDataOverUDP ( syslogMessage , callback ) ; }
public static < T extends Throwable > T writeStackTraces ( T throwable , StreamOutput out ) throws IOException { StackTraceElement [ ] stackTrace = throwable . getStackTrace ( ) ; out . writeVInt ( stackTrace . length ) ; for ( StackTraceElement element : stackTrace ) { out . writeString ( element . getClassName ( ) ) ; out . writeOptionalString ( element . getFileName ( ) ) ; out . writeString ( element . getMethodName ( ) ) ; out . writeVInt ( element . getLineNumber ( ) ) ; } Throwable [ ] suppressed = throwable . getSuppressed ( ) ; out . writeVInt ( suppressed . length ) ; for ( Throwable t : suppressed ) { out . writeThrowable ( t ) ; } return throwable ; }
public DistributedLogMultiStreamWriter build ( ) { Preconditions . checkArgument ( ( null != _streams && ! _streams . isEmpty ( ) ) , STR_ ) ; Preconditions . checkNotNull ( _client , STR_ ) ; Preconditions . checkNotNull ( _codec , STR_ ) ; Preconditions . checkArgument ( _firstSpeculativeTimeoutMs > NUM_ && _firstSpeculativeTimeoutMs <= _maxSpeculativeTimeoutMs && _speculativeBackoffMultiplier > NUM_ && _maxSpeculativeTimeoutMs < _requestTimeoutMs , STR_ ) ; return new DistributedLogMultiStreamWriter ( _streams , _client , Math . min ( _bufferSize , MAX_LOGRECORDSET_SIZE ) , _flushIntervalMicros , _requestTimeoutMs , _firstSpeculativeTimeoutMs , _maxSpeculativeTimeoutMs , _speculativeBackoffMultiplier , _codec , _ticker , _executorService ) ; }
public static String numberToString ( Number number ) throws JSONException { if ( number == null ) { throw new JSONException ( STR_ ) ; } testValidity ( number ) ; String string = number . toString ( ) ; if ( string . indexOf ( STR_ ) > NUM_ && string . indexOf ( STR_ ) < NUM_ && string . indexOf ( STR_ ) < NUM_ ) { while ( string . endsWith ( STR_ ) ) { string = string . substring ( NUM_ , string . length ( ) - NUM_ ) ; } if ( string . endsWith ( STR_ ) ) { string = string . substring ( NUM_ , string . length ( ) - NUM_ ) ; } } return string ; }
private ImageElement ( int AD_PrintFormatItem_ID ) { loadAttachment ( AD_PrintFormatItem_ID ) ; }
public ThreadRegisterValues ( final ThreadRegisters values ) { m_tid = values . getTid ( ) ; for ( final RegisterValue value : values . getRegisters ( ) ) { m_values . add ( new Register ( value ) ) ; } }
public LauncherDiscoveryRequestBuilder configurationParameters ( Map < String , String > configurationParameters ) { Preconditions . notNull ( configurationParameters , STR_ ) ; configurationParameters . forEach ( null ) ; return this ; }
public boolean isTriggered ( ) { return checkbox . isSelected ( ) ; }
public void addAll ( int index , int [ ] data ) { int dataLen = data . length ; if ( dataLen == NUM_ ) { return ; } int newcap = size + ( int ) ( dataLen . NUM_ ) + NUM_ ; ensureCapacity ( newcap ) ; System . arraycopy ( array , index , array , index + dataLen , size - index ) ; System . arraycopy ( data , NUM_ , array , index , dataLen ) ; size += dataLen ; }
public int read ( byte [ ] b ) throws java . io . IOException { return read ( b , NUM_ , b . length ) ; }
public static void e ( String tag , String msg , Object ... args ) { if ( sLevel > LEVEL_ERROR ) { return ; } if ( args . length > NUM_ ) { msg = String . format ( msg , args ) ; } Log . e ( tag , msg ) ; }
private static float calculateScore ( final int [ ] playCounts ) { if ( playCounts == null ) { return NUM_ ; } float score = NUM_ ; for ( int i = NUM_ ; i < Math . min ( playCounts . length , NUM_WEEKS ) ; i ++ ) { score += playCounts [ i ] . getScoreMultiplierForWeek ( i ) ; } return score ; }
public void removeScanningCallback ( OneSheeldScanningCallback scanningCallback ) { if ( scanningCallback != null && scanningCallbacks . contains ( scanningCallback ) ) scanningCallbacks . remove ( scanningCallback ) ; }
public void paintRect ( Graphics g , JComponent c , int x , int y , int w , int h ) { Rectangle bounds = c . getBounds ( ) ; check ( bounds ) ; g . drawImage ( m_backImage , x , y , x + w , h + y , x , y , x + w , y + h , c ) ; }
@ Override public final void sample ( ) { _value = _acquireCount . get ( ) - _releaseCount . get ( ) ; }
private void writeAttribute ( java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( namespace . equals ( STR_ ) ) { xmlWriter . writeAttribute ( attName , attValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } }
private boolean isPageBreak ( int row ) { for ( int i = NUM_ ; i < m_pageBreak . size ( ) ; i ++ ) { Integer rr = ( Integer ) m_pageBreak . get ( i ) ; if ( rr . intValue ( ) + NUM_ == row ) return BOOL_ ; else if ( rr . intValue ( ) > row ) return BOOL_ ; } return BOOL_ ; }
public ExecutorService shutdown ( ) { pool . shutdown ( ) ; return pool ; }
public static boolean isPropositionSymbolIdentifierPart ( char ch ) { return Character . isJavaIdentifierPart ( ch ) ; }
public static void o ( Zdiagmat D ) { o ( D , Parameters . OutputFieldWidth , Parameters . OutputFracPlaces ) ; }
public int search ( String txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int skip ; for ( int i = NUM_ ; i <= N - M ; i += skip ) { skip = NUM_ ; for ( int j = M - NUM_ ; j >= NUM_ ; j -- ) { if ( pat . charAt ( j ) != txt . charAt ( i + j ) ) { skip = Math . max ( NUM_ , j - right [ txt . charAt ( i + j ) ] ) ; break ; } } if ( skip == NUM_ ) return i ; } return N ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( NUM_ ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return newVector . elements ( ) ; }
public String toChars ( int [ ] indices ) { StringBuilder s = new StringBuilder ( indices . length ) ; for ( int i = NUM_ ; i < indices . length ; i ++ ) s . append ( toChar ( indices [ i ] ) ) ; return s . toString ( ) ; }
public static final String trunc ( final String str , final int length ) { if ( str == null ) { return str ; } if ( str . length ( ) <= length ) { return str ; } return str . substring ( NUM_ , length ) ; }
public void clearTransactions ( int fromHeight ) { lock . lock ( ) ; try { if ( fromHeight == NUM_ ) { unspent . clear ( ) ; spent . clear ( ) ; pending . clear ( ) ; dead . clear ( ) ; transactions . clear ( ) ; } else { throw new UnsupportedOperationException ( ) ; } } finally { lock . unlock ( ) ; } }
@ Override public boolean load ( final Player player , final List < String > args ) { groovyBinding . setVariable ( STR_ , player ) ; if ( args != null ) { groovyBinding . setVariable ( STR_ , args . toArray ( new String [ args . size ( ) ] ) ) ; } else { groovyBinding . setVariable ( STR_ , new String [ NUM_ ] ) ; } final GroovyShell interp = new GroovyShell ( groovyBinding ) ; boolean ret = BOOL_ ; preExecute ( player , args ) ; try { final File f = new File ( groovyScript ) ; interp . evaluate ( f ) ; } catch ( final Exception e ) { logger . error ( STR_ + groovyScript , e ) ; setMessage ( e . getMessage ( ) ) ; ret = BOOL_ ; } catch ( final Error e ) { logger . error ( STR_ + groovyScript , e ) ; setMessage ( e . getMessage ( ) ) ; ret = BOOL_ ; } postExecute ( player , args , ret ) ; return ( ret ) ; }
private void startAnimation ( ) { ValueAnimator animator = ValueAnimator . ofFloat ( NUM_ ) ; ArrayList < NameValuesHolder > nameValueList = ( ArrayList < NameValuesHolder > ) mPendingAnimations . clone ( ) ; mPendingAnimations . clear ( ) ; int propertyMask = NUM_ ; int propertyCount = nameValueList . size ( ) ; for ( int i = NUM_ ; i < propertyCount ; ++ i ) { NameValuesHolder nameValuesHolder = nameValueList . get ( i ) ; propertyMask |= nameValuesHolder . mNameConstant ; } mAnimatorMap . put ( animator , new PropertyBundle ( propertyMask , nameValueList ) ) ; animator . addUpdateListener ( mAnimatorEventListener ) ; animator . addListener ( mAnimatorEventListener ) ; if ( mStartDelaySet ) { animator . setStartDelay ( mStartDelay ) ; } if ( mDurationSet ) { animator . setDuration ( mDuration ) ; } if ( mInterpolatorSet ) { animator . setInterpolator ( mInterpolator ) ; } animator . start ( ) ; }
private void cleanDirtyRegion ( float eventX , float eventY ) { dirtyRect . left = Math . min ( lastTouchX , eventX ) ; dirtyRect . right = Math . max ( lastTouchX , eventX ) ; dirtyRect . top = Math . min ( lastTouchY , eventY ) ; dirtyRect . bottom = Math . max ( lastTouchY , eventY ) ; }
public Sort ( String [ ] fields ) { this ( fields , new boolean [ fields . length ] ) ; Arrays . fill ( m_ascend , BOOL_ ) ; }
@ Override public boolean wasSuccessful ( ) { return isFinished ( ) && getCurrentPoints ( ) >= successThreashold ; }
void startLocatingPhone ( ) { Intent intent = new Intent ( sContext , LocationService . class ) ; intent . setAction ( LocationService . START_SERVICE ) ; intent . putExtra ( STR_ , this . mAnswerTo ) ; sContext . startService ( intent ) ; }
public void deleteResourceConfig ( String clusterName , ResourceType resourceType , String dsName ) throws ConfigurationException { if ( getClusterHome ( ) == null ) { throw new ConfigurationException ( STR_ ) ; } File resources = getDir ( getResourceConfigDirName ( getClusterHome ( ) , clusterName , resourceType ) ) ; String delFileName = resources . getAbsolutePath ( ) + File . separator + dsName + STR_ ; delFile ( delFileName ) ; }
public BusMovement ( BusMovement proto ) { super ( proto ) ; this . controlSystem = proto . controlSystem ; this . id = nextID ++ ; controlSystem . registerBus ( this ) ; startMode = BOOL_ ; }
private int removeNext ( ) { if ( lastUsageDates . isEmpty ( ) ) { return INVALID_SIZE ; } Long oldestUsage = null ; File mostLongUsedFile = null ; Set < Entry < File , Long > > entries = lastUsageDates . entrySet ( ) ; synchronized ( lastUsageDates ) { for ( Entry < File , Long > entry : entries ) { if ( mostLongUsedFile == null ) { mostLongUsedFile = entry . getKey ( ) ; oldestUsage = entry . getValue ( ) ; } else { Long lastValueUsage = entry . getValue ( ) ; if ( lastValueUsage < oldestUsage ) { oldestUsage = lastValueUsage ; mostLongUsedFile = entry . getKey ( ) ; } } } } int fileSize = NUM_ ; if ( mostLongUsedFile != null ) { if ( mostLongUsedFile . exists ( ) ) { fileSize = getSize ( mostLongUsedFile ) ; if ( mostLongUsedFile . delete ( ) ) { lastUsageDates . remove ( mostLongUsedFile ) ; } } else { lastUsageDates . remove ( mostLongUsedFile ) ; } } return fileSize ; }
private static char [ ] zzUnpackCMap ( String packed ) { char [ ] map = new char [ x10000 ] ; int i = NUM_ ; int j = NUM_ ; while ( i < NUM_ ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM_ ) ; } return map ; }
private void createGui ( ) { for ( final IResultsPanel panel : m_factory ) { m_tabbedPane . addTab ( panel . getTitle ( ) , panel . getComponent ( ) ) ; } add ( m_tabbedPane , BorderLayout . CENTER ) ; m_tabbedPane . setVisible ( BOOL_ ) ; }
public static float generateRandomFloatBetween ( float lowerLimit , float upperLimit ) { return lowerLimit + ( ( upperLimit - lowerLimit ) . _r . nextFloat ( ) ) ; }
public SGenItemProviderAdapterFactory ( ) { supportedTypes . add ( IEditingDomainItemProvider . class ) ; supportedTypes . add ( IStructuredItemContentProvider . class ) ; supportedTypes . add ( ITreeItemContentProvider . class ) ; supportedTypes . add ( IItemLabelProvider . class ) ; supportedTypes . add ( IItemPropertySource . class ) ; }
private void kdRangeSearch ( int left , int right , int axis , O query , ModifiableDoubleDBIDList res , DBIDArrayIter iter , double radius ) { if ( right - left <= leafsize ) { for ( iter . seek ( left ) ; iter . getOffset ( ) < right ; iter . advance ( ) ) { double dist = norm . distance ( query , relation . get ( iter ) ) ; countObjectAccess ( ) ; countDistanceComputation ( ) ; if ( dist <= radius ) { res . add ( dist , iter ) ; } } return ; } final int middle = ( left + right ) > > > NUM_ ; O split = relation . get ( iter . seek ( middle ) ) ; countObjectAccess ( ) ; final double delta = split . doubleValue ( axis ) - query . doubleValue ( axis ) ; final boolean onleft = ( delta >= NUM_ ) ; final boolean onright = ( delta <= NUM_ ) ; final boolean close = ( Math . abs ( delta ) <= radius ) ; final int next = ( axis + NUM_ ) % dims ; if ( close ) { double dist = norm . distance ( query , split ) ; countDistanceComputation ( ) ; if ( dist <= radius ) { assert ( iter . getOffset ( ) == middle ) ; res . add ( dist , iter ) ; } } if ( left < middle && ( onleft || close ) ) { kdRangeSearch ( left , middle , next , query , res , iter , radius ) ; } if ( middle + NUM_ < right && ( onright || close ) ) { kdRangeSearch ( middle + NUM_ , right , next , query , res , iter , radius ) ; } }
private void handleStartElement ( XMLStreamReader parser , Set < Node > childrenFound , Handler handler , Map < String , Object > values , Stack < Set < String > > stack , boolean recordStarted ) throws IOException , XMLStreamException { Node n = getMatchingNode ( parser , childNodes ) ; Map < String , Object > decends = new HashMap < > ( ) ; if ( n != null ) { childrenFound . add ( n ) ; n . parse ( parser , handler , values , stack , recordStarted ) ; return ; } Node dn = this ; do { if ( dn . wildCardNodes != null ) { n = getMatchingNode ( parser , dn . wildCardNodes ) ; if ( n != null ) { childrenFound . add ( n ) ; n . parse ( parser , handler , values , stack , recordStarted ) ; break ; } for ( Node nn : dn . wildCardNodes ) decends . put ( nn . name , nn ) ; } dn = dn . wildAncestor ; } while ( dn != null ) ; if ( n == null ) { int count = NUM_ ; while ( count != NUM_ ) { int token = parser . next ( ) ; if ( token == START_ELEMENT ) { Node nn = ( Node ) decends . get ( parser . getLocalName ( ) ) ; if ( nn != null ) { childrenFound . add ( nn ) ; nn . parse ( parser , handler , values , stack , recordStarted ) ; } else count ++ ; } else if ( token == END_ELEMENT ) count -- ; } } }
private void connect ( ) { if ( ! connected ) { updateInfo ( ) ; String connectString = STR_ + connectAddress + STR_ + connectPort ; if ( clientId == null || clientId . length ( ) < NUM_ ) { out ( getDate ( ) + Messages . MqttClientView_15 + connectString + Messages . MqttClientView_16 ) ; return ; } try { if ( firstConnect ) { mqttClient = new MqttClient ( connectString , clientId ) ; mqttClient . setCallback ( this ) ; firstConnect = BOOL_ ; } } catch ( MqttException e ) { out ( getDate ( ) + Messages . MqttClientView_17 + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } connOpts = new MqttConnectOptions ( ) ; connOpts . setCleanSession ( cleanStart ) ; connOpts . setConnectionTimeout ( NUM_ ) ; connOpts . setKeepAliveInterval ( keepAlive ) ; if ( username . length ( ) > NUM_ && password . length ( ) > NUM_ ) { connOpts . setPassword ( password . toCharArray ( ) ) ; connOpts . setUserName ( username ) ; } if ( useWill ) { if ( willTopic == null || willTopic . equals ( STR_ ) ) { out ( Messages . MqttClientView_19 ) ; return ; } connOpts . setWill ( mqttClient . getTopic ( willTopic ) , willMessage . getBytes ( ) , willQos , willRetain ) ; } try { out ( getDate ( ) + Messages . MqttClientView_20 + connectString ) ; mqttClient . connect ( connOpts ) ; connected = BOOL_ ; out ( getDate ( ) + Messages . MqttClientView_21 + clientId ) ; } catch ( MqttException e ) { out ( getDate ( ) + Messages . MqttClientView_22 + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } } else { out ( Messages . MqttClientView_23 ) ; } }
static void checkTypeRefAndPath ( int typeRef , TypePath typePath ) { int mask = NUM_ ; switch ( typeRef > > > NUM_ ) { case TypeReference . CLASS_TYPE_PARAMETER : case TypeReference . METHOD_TYPE_PARAMETER : case TypeReference . METHOD_FORMAL_PARAMETER : mask = xFFFF0000 ; break ; case TypeReference . FIELD : case TypeReference . METHOD_RETURN : case TypeReference . METHOD_RECEIVER : case TypeReference . LOCAL_VARIABLE : case TypeReference . RESOURCE_VARIABLE : case TypeReference . INSTANCEOF : case TypeReference . NEW : case TypeReference . CONSTRUCTOR_REFERENCE : case TypeReference . METHOD_REFERENCE : mask = xFF000000 ; break ; case TypeReference . CLASS_EXTENDS : case TypeReference . CLASS_TYPE_PARAMETER_BOUND : case TypeReference . METHOD_TYPE_PARAMETER_BOUND : case TypeReference . THROWS : case TypeReference . EXCEPTION_PARAMETER : mask = xFFFFFF00 ; break ; case TypeReference . CAST : case TypeReference . CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT : case TypeReference . METHOD_INVOCATION_TYPE_ARGUMENT : case TypeReference . CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT : case TypeReference . METHOD_REFERENCE_TYPE_ARGUMENT : mask = xFF0000FF ; break ; default : throw new IllegalArgumentException ( STR_ + Integer . toHexString ( typeRef > > > NUM_ ) ) ; } if ( ( typeRef & ~ mask ) != NUM_ ) { throw new IllegalArgumentException ( STR_ + Integer . toHexString ( typeRef ) ) ; } if ( typePath != null ) { for ( int i = NUM_ ; i < typePath . getLength ( ) ; ++ i ) { int step = typePath . getStep ( i ) ; if ( step != TypePath . ARRAY_ELEMENT && step != TypePath . INNER_TYPE && step != TypePath . TYPE_ARGUMENT && step != TypePath . WILDCARD_BOUND ) { throw new IllegalArgumentException ( STR_ + i + STR_ + typePath ) ; } if ( step != TypePath . TYPE_ARGUMENT && typePath . getStepArgument ( i ) != NUM_ ) { throw new IllegalArgumentException ( STR_ + i + STR_ + typePath ) ; } } } }
synchronized void addTracer ( Tracer tracer ) { if ( curTracers . add ( tracer ) ) { LOG . trace ( toString ( ) + STR_ + tracer . toString ( ) ) ; } }
private void grow ( ) { int newCap = ( entries . length << NUM_ ) + NUM_ ; Object [ ] newEntries = new Object [ newCap ] ; System . arraycopy ( entries , NUM_ , newEntries , NUM_ , size ) ; entries = newEntries ; }
public void damage ( double value ) { setValue ( Math . max ( NUM_ , getValue ( ) - value ) ) ; }
@ Ignore ( STR_ ) @ Test public void testConcurrentEventsOnEmptyRegion ( ) { versionTestConcurrentEventsOnEmptyRegion ( ) ; }
public Graph ( ) { roots = new ArrayList < Node > ( ) ; nodes = new ArrayList < Node > ( ) ; string = STR_ ; }
private static String trimVersion ( String apiVersion ) { if ( apiVersion == null ) { return null ; } else { String [ ] versionParts = apiVersion . split ( STR_ ) ; return versionParts [ versionParts . length - NUM_ ] ; } }
private Inventory queryInventory ( boolean querySkuDetails , List < String > moreItemSkus ) throws IabException { checkNotDisposed ( ) ; checkSetupDone ( STR_ ) ; try { Inventory inv = new Inventory ( ) ; int r = queryPurchases ( inv , ITEM_TYPE_INAPP ) ; if ( r != BILLING_RESPONSE_RESULT_OK ) { throw new IabException ( r , STR_ ) ; } if ( querySkuDetails ) { r = querySkuDetails ( ITEM_TYPE_INAPP , inv , moreItemSkus ) ; if ( r != BILLING_RESPONSE_RESULT_OK ) { throw new IabException ( r , STR_ ) ; } } if ( mSubscriptionsSupported ) { r = queryPurchases ( inv , ITEM_TYPE_SUBS ) ; if ( r != BILLING_RESPONSE_RESULT_OK ) { throw new IabException ( r , STR_ ) ; } if ( querySkuDetails ) { r = querySkuDetails ( ITEM_TYPE_SUBS , inv , moreItemSkus ) ; if ( r != BILLING_RESPONSE_RESULT_OK ) { throw new IabException ( r , STR_ ) ; } } } return inv ; } catch ( RemoteException e ) { throw new IabException ( IABHELPER_REMOTE_EXCEPTION , STR_ , e ) ; } catch ( JSONException e ) { throw new IabException ( IABHELPER_BAD_RESPONSE , STR_ , e ) ; } }
@ Override public void incomingObject ( IAnalyzedInterval analyzedInterval ) throws AdeException { if ( ! m_percentilesWithEmptyIntervals && analyzedInterval . getNumUniqueMessageIds ( ) == NUM_ ) { return ; } final double rawScore = calcRawScore ( analyzedInterval ) ; if ( ! SeenHugeLogProb ( analyzedInterval ) ) { m_rawScores . add ( rawScore ) ; ++ m_intervalCount ; } }
public static String readFileAsString ( File file , String encoding ) throws IOException { ByteBuffer buffer = readFile ( file ) ; if ( null == encoding ) { encoding = STR_ ; } String converted = new String ( buffer . array ( ) , encoding ) ; return converted ; }
public EmBayesEstimatorEditor ( EmBayesEstimatorWrapper emBayesEstWrapper ) { this ( emBayesEstWrapper . getEstimateBayesIm ( ) , emBayesEstWrapper . getDataSet ( ) ) ; }
private boolean saveDataToDisk ( boolean exit , boolean complete , String updatedSaveName ) { return saveDataToDisk ( exit , complete , updatedSaveName , BOOL_ ) ; }
public static final void writeMapXml ( Map val , String name , XmlSerializer out , WriteMapCallback callback ) throws XmlPullParserException , java . io . IOException { if ( val == null ) { out . startTag ( null , STR_ ) ; out . endTag ( null , STR_ ) ; return ; } out . startTag ( null , STR_ ) ; if ( name != null ) { out . attribute ( null , STR_ , name ) ; } writeMapXml ( val , out , callback ) ; out . endTag ( null , STR_ ) ; }
public boolean needPreloadKey ( int idx ) { return preloadKeys != null && preloadKeys . get ( idx ) ; }
public int generateChallengeToken ( InetSocketAddress address ) { int token = random . nextInt ( ) ; challengeTokens . put ( address , token ) ; return token ; }
@ Override public void perform ( IR ir ) { for ( Enumeration < BasicBlock > e = ir . getBasicBlocks ( ) ; e . hasMoreElements ( ) ; ) { BasicBlock bb = e . nextElement ( ) ; if ( bb . isEmpty ( ) ) continue ; container . counter2 ++ ; if ( bb . getInfrequent ( ) ) { container . counter1 ++ ; if ( ir . options . FREQ_FOCUS_EFFORT ) continue ; } for ( Enumeration < Instruction > ie = bb . forwardInstrEnumerator ( ) ; ie . hasMoreElements ( ) ; ) { Instruction s = ie . nextElement ( ) ; if ( TypeCheck . conforms ( s ) && ( invertNullAndTypeChecks ( s ) || pushTypeCheckBelowIf ( s , ir ) ) ) { ie = bb . forwardInstrEnumerator ( ) ; } } } }
void addFillComponents ( Container panel , int [ ] cols , int [ ] rows ) { Dimension filler = new Dimension ( NUM_ , NUM_ ) ; boolean filled_cell_11 = BOOL_ ; CellConstraints cc = new CellConstraints ( ) ; if ( cols . length > NUM_ && rows . length > NUM_ ) { if ( cols [ NUM_ ] == NUM_ && rows [ NUM_ ] == NUM_ ) { panel . add ( Box . createRigidArea ( filler ) , cc . xy ( NUM_ , NUM_ ) ) ; filled_cell_11 = BOOL_ ; } } for ( int index = NUM_ ; index < cols . length ; index ++ ) { if ( cols [ index ] == NUM_ && filled_cell_11 ) { continue ; } panel . add ( Box . createRigidArea ( filler ) , cc . xy ( cols [ index ] , NUM_ ) ) ; } for ( int index = NUM_ ; index < rows . length ; index ++ ) { if ( rows [ index ] == NUM_ && filled_cell_11 ) { continue ; } panel . add ( Box . createRigidArea ( filler ) , cc . xy ( NUM_ , rows [ index ] ) ) ; } }
public Object pack ( ) { if ( collection ) { List l = ( List ) value ; if ( Types . isArray ( type ) ) { Object [ ] o = ( Object [ ] ) Array . newInstance ( itemType , l . size ( ) ) ; l . toArray ( o ) ; return o ; } } return value ; }
public void removeRequest ( InterruptRequest interruptRequest ) { synchronized ( interruptRequestQueue ) { interruptRequestQueue . remove ( interruptRequest ) ; } }
@ Override public final void onHeatmapFailed ( ) { updatePending = BOOL_ ; }
@ SuppressLint ( STR_ ) @ Nullable public static Drawable inflate ( boolean forceSystemHandlingWhenPossible , @ NonNull Resources resources , @ DrawableRes int id ) { boolean systemHandling = isSystemHandling ( forceSystemHandlingWhenPossible ) ; Log . d ( LOG_TAG , String . format ( STR_ , Integer . toHexString ( id ) , systemHandling ) ) ; if ( systemHandling ) { return resources . getDrawable ( id , null ) ; } try { return VectorDrawable . create ( resources , id ) ; } catch ( Resources . NotFoundException e ) { return null ; } }
public static long objectFieldOffset ( Field field ) { return UNSAFE . objectFieldOffset ( field ) ; }
public void addAnnotation ( String annotation , double x , double y ) { mAnnotations . add ( annotation ) ; mStringXY . put ( x , y ) ; }
protected synchronized void write ( long offset , byte [ ] b ) throws IOException { if ( byteBuffer != null ) { byteBuffer . position ( ( int ) offset ) ; byteBuffer . put ( b ) ; } else { throw new IOException ( STR_ + getPath ( ) + STR_ ) ; } }
public static byte [ ] ivCipherConcat ( byte [ ] iv , byte [ ] cipherText ) { byte [ ] combined = new byte [ iv . length + cipherText . length ] ; System . arraycopy ( iv , NUM_ , combined , NUM_ , iv . length ) ; System . arraycopy ( cipherText , NUM_ , combined , iv . length , cipherText . length ) ; return combined ; }
long timestamp ( long timestamp ) { this . timestamp = Math . max ( this . timestamp , timestamp ) ; return this . timestamp ; }
public MaterialPackage ( MaterialPackageBO materialPackageBO , List < GenericTrack > genericTracks ) { super ( materialPackageBO ) ; this . materialPackageBO = materialPackageBO ; this . genericTracks = Collections . unmodifiableList ( genericTracks ) ; }
public Edge findEdgeInSameDirection ( Coordinate p0 , Coordinate p1 ) { for ( int i = NUM_ ; i < edges . size ( ) ; i ++ ) { Edge e = ( Edge ) edges . get ( i ) ; Coordinate [ ] eCoord = e . getCoordinates ( ) ; if ( matchInSameDirection ( p0 , p1 , eCoord [ NUM_ ] , eCoord [ NUM_ ] ) ) return e ; if ( matchInSameDirection ( p0 , p1 , eCoord [ eCoord . length - NUM_ ] , eCoord [ eCoord . length - NUM_ ] ) ) return e ; } return null ; }
public void acquireProbabilities ( final String string ) { if ( string . length ( ) < NUM_ ) { return ; } for ( int i = NUM_ ; i < string . length ( ) ; ++ i ) { final char previousChar = string . charAt ( i - NUM_ ) ; final char currentChar = string . charAt ( i - NUM_ ) ; final char nextChar = string . charAt ( i ) ; final String key = previousChar + STR_ + currentChar ; if ( ! sequences . contains ( key ) ) { sequences . add ( key ) ; } HashMap < Character , Integer > probabilities = sequenceProbabilities . get ( key ) ; if ( probabilities == null ) { probabilities = new HashMap < > ( ) ; sequenceProbabilities . put ( key , probabilities ) ; } int existingValue = probabilities . getOrDefault ( nextChar , NUM_ ) ; ++ existingValue ; probabilities . put ( nextChar , existingValue ) ; } }
protected final void resolveIssue ( HealthIssue healthIssue ) { EventBus eventBus ; boolean wasIssueActive ; synchronized ( mLock ) { if ( mHealthEventBus == null ) { LOG . w ( STR_ + STR_ , healthIssue . toString ( ) ) ; return ; } eventBus = mHealthEventBus ; wasIssueActive = mActiveIssues . remove ( healthIssue ) ; } if ( wasIssueActive ) { eventBus . post ( healthIssue . resolved ) ; } }
public static byte [ ] decode ( String s ) { return decode ( s , NO_OPTIONS ) ; }
private static boolean test ( ODatabaseDocumentPool pool , String dbURL , String user , String password , boolean finalTry ) { ODatabaseDocumentTx db = null ; try { logger . info ( STR_ ) ; db = pool . acquire ( dbURL , user , password ) ; Iterator < ODocument > iter = db . browseClass ( STR_ ) ; if ( iter . hasNext ( ) ) { iter . next ( ) ; } } catch ( OException ex ) { if ( finalTry ) { logger . info ( STR_ , ex ) ; } else { logger . debug ( STR_ , ex ) ; } return BOOL_ ; } finally { if ( db != null ) { db . close ( ) ; } } return BOOL_ ; }
@ Override public void agg ( Object newVal ) { if ( newVal instanceof byte [ ] ) { byte [ ] values = ( byte [ ] ) newVal ; ByteBuffer buffer = ByteBuffer . wrap ( values ) ; buffer . rewind ( ) ; while ( buffer . hasRemaining ( ) ) { valueSet . add ( buffer . getInt ( ) ) ; } return ; } else { double value = new Double ( newVal . toString ( ) ) ; agg ( value ) ; } }
private void displayEasterEgg ( CommandSender sender ) { sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; sender . sendMessage ( StringEscapeUtils . unescapeJava ( STR_ ) ) ; }
public boolean isUnparsedEntity ( String entityName ) { Entity entity = ( Entity ) fEntities . get ( entityName ) ; if ( entity == null ) { return BOOL_ ; } return entity . isUnparsed ( ) ; }
public void flush ( ) throws IOException { out . flush ( ) ; }
private static String urlEncode ( final String text ) throws UnsupportedEncodingException { return URLEncoder . encode ( text , STR_ ) ; }
protected void processFocusEvent ( FocusEvent evt ) { super . processFocusEvent ( evt ) ; if ( evt . getID ( ) == FocusEvent . FOCUS_LOST ) { if ( popup != null ) hidePopup ( ) ; } }
@ Override public synchronized void addRequestProperty ( String key , String value ) { if ( connected || connecting ) throw new IllegalStateException ( STR_ ) ; if ( key == null ) throw new NullPointerException ( STR_ ) ; if ( isExternalMessageHeaderAllowed ( key , value ) ) { requests . add ( key , value ) ; if ( ! key . equalsIgnoreCase ( STR_ ) ) { userHeaders . add ( key , value ) ; } } }
public void execute ( AbortableTask task ) { AbortingRunnable ar = new AbortingRunnable ( task ) ; tasks . add ( ar ) ; try { exec . execute ( ar ) ; } catch ( RejectedExecutionException e ) { tasks . remove ( ar ) ; throw e ; } }
default ByteBuffer serialize ( T value ) { ByteBuffer buffer = ByteBuffer . allocate ( size ( value ) ) ; serialize ( value , buffer ) ; return buffer ; }
private void loadSubmissions ( ) { submissions . clear ( ) ; String [ ] users = JPlagCentral . usersList ( ) ; for ( int i = NUM_ ; i < users . length ; i ++ ) { AccessStructure [ ] subm = JPlagCentral . listAccessStructures ( users [ i ] ) ; if ( subm != null && subm . length != NUM_ ) { for ( int j = NUM_ ; j < subm . length ; j ++ ) { submissions . add ( subm [ j ] ) ; } } } }
private void subFormat ( int patternCharIndex , int count , FieldDelegate delegate , StringBuffer buffer , boolean useDateFormatSymbols ) { int maxIntCount = Integer . MAX_VALUE ; String current = null ; int beginOffset = buffer . length ( ) ; int field = PATTERN_INDEX_TO_CALENDAR_FIELD [ patternCharIndex ] ; int value ; if ( field == CalendarBuilder . WEEK_YEAR ) { if ( calendar . isWeekDateSupported ( ) ) { value = calendar . getWeekYear ( ) ; } else { patternCharIndex = PATTERN_YEAR ; field = PATTERN_INDEX_TO_CALENDAR_FIELD [ patternCharIndex ] ; value = calendar . get ( field ) ; } } else if ( field == CalendarBuilder . ISO_DAY_OF_WEEK ) { value = CalendarBuilder . toISODayOfWeek ( calendar . get ( Calendar . DAY_OF_WEEK ) ) ; } else { value = calendar . get ( field ) ; } int style = ( count >= NUM_ ) ? Calendar . LONG : Calendar . SHORT ; if ( ! useDateFormatSymbols && field < Calendar . ZONE_OFFSET && patternCharIndex != PATTERN_MONTH_STANDALONE ) { current = calendar . getDisplayName ( field , style , locale ) ; } switch ( patternCharIndex ) { case PATTERN_ERA : if ( useDateFormatSymbols ) { String [ ] eras = formatData . getEras ( ) ; if ( value < eras . length ) { current = eras [ value ] ; } } if ( current == null ) { current = STR_ ; } break ; case PATTERN_WEEK_YEAR : case PATTERN_YEAR : if ( calendar instanceof GregorianCalendar ) { if ( count != NUM_ ) { zeroPaddingNumber ( value , count , maxIntCount , buffer ) ; } else { zeroPaddingNumber ( value , NUM_ , NUM_ , buffer ) ; } } else { if ( current == null ) { zeroPaddingNumber ( value , style == Calendar . LONG ? NUM_ : count , maxIntCount , buffer ) ; } } break ; case PATTERN_MONTH : if ( useDateFormatSymbols ) { String [ ] months ; if ( count >= NUM_ ) { months = formatData . getMonths ( ) ; current = months [ value ] ; } else if ( count == NUM_ ) { months = formatData . getShortMonths ( ) ; current = months [ value ] ; } } else { if ( count < NUM_ ) { current = null ; } else if ( forceStandaloneForm ) { current = calendar . getDisplayName ( field , style | x8000 , locale ) ; if ( current == null ) { current = calendar . getDisplayName ( field , style , locale ) ; } } } if ( current == null ) { zeroPaddingNumber ( value + NUM_ , count , maxIntCount , buffer ) ; } break ; case PATTERN_MONTH_STANDALONE : assert current == null ; if ( locale == null ) { String [ ] months ; if ( count >= NUM_ ) { months = formatData . getMonths ( ) ; current = months [ value ] ; } else if ( count == NUM_ ) { months = formatData . getShortMonths ( ) ; current = months [ value ] ; } } else { if ( count >= NUM_ ) { current = calendar . getDisplayName ( field , style | x8000 , locale ) ; } } if ( current == null ) { zeroPaddingNumber ( value + NUM_ , count , maxIntCount , buffer ) ; } break ; case PATTERN_HOUR_OF_DAY1 : if ( current == null ) { if ( value == NUM_ ) { zeroPaddingNumber ( calendar . getMaximum ( Calendar . HOUR_OF_DAY ) + NUM_ , count , maxIntCount , buffer ) ; } else { zeroPaddingNumber ( value , count , maxIntCount , buffer ) ; } } break ; case PATTERN_DAY_OF_WEEK : if ( useDateFormatSymbols ) { String [ ] weekdays ; if ( count >= NUM_ ) { weekdays = formatData . getWeekdays ( ) ; current = weekdays [ value ] ; } else { weekdays = formatData . getShortWeekdays ( ) ; current = weekdays [ value ] ; } } break ; case PATTERN_AM_PM : if ( useDateFormatSymbols ) { String [ ] ampm = formatData . getAmPmStrings ( ) ; current = ampm [ value ] ; } break ; case PATTERN_HOUR1 : if ( current == null ) { if ( value == NUM_ ) { zeroPaddingNumber ( calendar . getLeastMaximum ( Calendar . HOUR ) + NUM_ , count , maxIntCount , buffer ) ; } else { zeroPaddingNumber ( value , count , maxIntCount , buffer ) ; } } break ; case PATTERN_ZONE_NAME : if ( current == null ) { if ( formatData . locale == null || formatData . isZoneStringsSet ) { int zoneIndex = formatData . getZoneIndex ( calendar . getTimeZone ( ) . getID ( ) ) ; if ( zoneIndex == - NUM_ ) { value = calendar . get ( Calendar . ZONE_OFFSET ) + calendar . get ( Calendar . DST_OFFSET ) ; buffer . append ( ZoneInfoFile . toCustomID ( value ) ) ; } else { int index = ( calendar . get ( Calendar . DST_OFFSET ) == NUM_ ) ? NUM_ : NUM_ ; if ( count < NUM_ ) { index ++ ; } String [ ] [ ] zoneStrings = formatData . getZoneStringsWrapper ( ) ; buffer . append ( zoneStrings [ zoneIndex ] [ index ] ) ; } } else { TimeZone tz = calendar . getTimeZone ( ) ; boolean daylight = ( calendar . get ( Calendar . DST_OFFSET ) != NUM_ ) ; int tzstyle = ( count < NUM_ ? TimeZone . SHORT : TimeZone . LONG ) ; buffer . append ( tz . getDisplayName ( daylight , tzstyle , formatData . locale ) ) ; } } break ; case PATTERN_ZONE_VALUE : value = ( calendar . get ( Calendar . ZONE_OFFSET ) + calendar . get ( Calendar . DST_OFFSET ) ) / NUM_ ; int width = NUM_ ; if ( value >= NUM_ ) { buffer . append ( STR_ ) ; } else { width ++ ; } int num = ( value / NUM_ ) . NUM_ + ( value % NUM_ ) ; CalendarUtils . sprintf0d ( buffer , num , width ) ; break ; case PATTERN_ISO_ZONE : value = calendar . get ( Calendar . ZONE_OFFSET ) + calendar . get ( Calendar . DST_OFFSET ) ; if ( value == NUM_ ) { buffer . append ( STR_ ) ; break ; } value /= NUM_ ; if ( value >= NUM_ ) { buffer . append ( STR_ ) ; } else { buffer . append ( STR_ ) ; value = - value ; } CalendarUtils . sprintf0d ( buffer , value / NUM_ , NUM_ ) ; if ( count == NUM_ ) { break ; } if ( count == NUM_ ) { buffer . append ( STR_ ) ; } CalendarUtils . sprintf0d ( buffer , value % NUM_ , NUM_ ) ; break ; default : if ( current == null ) { zeroPaddingNumber ( value , count , maxIntCount , buffer ) ; } break ; } if ( current != null ) { buffer . append ( current ) ; } int fieldID = PATTERN_INDEX_TO_DATE_FORMAT_FIELD [ patternCharIndex ] ; Field f = PATTERN_INDEX_TO_DATE_FORMAT_FIELD_ID [ patternCharIndex ] ; delegate . formatted ( fieldID , f , f , beginOffset , buffer . length ( ) , buffer ) ; }
@ SuppressWarnings ( STR_ ) public boolean onTouchEvent ( MotionEvent event ) { try { int pointerCount = multiTouchSupported ? ( Integer ) m_getPointerCount . invoke ( event ) : NUM_ ; if ( DEBUG ) Log . i ( STR_ , STR_ + multiTouchSupported + STR_ + mMode + STR_ + handleSingleTouchEvents + STR_ + pointerCount ) ; if ( mMode == MODE_NOTHING && ! handleSingleTouchEvents && pointerCount == NUM_ ) return BOOL_ ; if ( DEBUG ) Log . i ( STR_ , STR_ ) ; int action = event . getAction ( ) ; int histLen = event . getHistorySize ( ) / pointerCount ; for ( int histIdx = NUM_ ; histIdx <= histLen ; histIdx ++ ) { boolean processingHist = histIdx < histLen ; if ( ! multiTouchSupported || pointerCount == NUM_ ) { if ( DEBUG ) Log . i ( STR_ , STR_ ) ; xVals [ NUM_ ] = processingHist ? event . getHistoricalX ( histIdx ) : event . getX ( ) ; yVals [ NUM_ ] = processingHist ? event . getHistoricalY ( histIdx ) : event . getY ( ) ; pressureVals [ NUM_ ] = processingHist ? event . getHistoricalPressure ( histIdx ) : event . getPressure ( ) ; } else { if ( DEBUG ) Log . i ( STR_ , STR_ ) ; int numPointers = Math . min ( pointerCount , MAX_TOUCH_POINTS ) ; if ( DEBUG && pointerCount > MAX_TOUCH_POINTS ) Log . i ( STR_ , STR_ ) ; for ( int ptrIdx = NUM_ ; ptrIdx < numPointers ; ptrIdx ++ ) { int ptrId = ( Integer ) m_getPointerId . invoke ( event , ptrIdx ) ; pointerIds [ ptrIdx ] = ptrId ; xVals [ ptrIdx ] = ( Float ) ( processingHist ? m_getHistoricalX . invoke ( event , ptrIdx , histIdx ) : m_getX . invoke ( event , ptrIdx ) ) ; yVals [ ptrIdx ] = ( Float ) ( processingHist ? m_getHistoricalY . invoke ( event , ptrIdx , histIdx ) : m_getY . invoke ( event , ptrIdx ) ) ; pressureVals [ ptrIdx ] = ( Float ) ( processingHist ? m_getHistoricalPressure . invoke ( event , ptrIdx , histIdx ) : m_getPressure . invoke ( event , ptrIdx ) ) ; } } decodeTouchEvent ( pointerCount , xVals , yVals , pressureVals , pointerIds , processingHist ? MotionEvent . ACTION_MOVE : action , processingHist ? BOOL_ : action != MotionEvent . ACTION_UP && ( action & ( ( NUM_ << ACTION_POINTER_INDEX_SHIFT ) - NUM_ ) ) != ACTION_POINTER_UP && action != MotionEvent . ACTION_CANCEL , processingHist ? event . getHistoricalEventTime ( histIdx ) : event . getEventTime ( ) ) ; } return BOOL_ ; } catch ( Exception e ) { Log . e ( STR_ , STR_ , e ) ; return BOOL_ ; } }
public static Bit valueOf ( String bit ) throws NumberFormatException { final int i = Integer . parseInt ( bit ) ; if ( i != NUM_ && i != NUM_ ) { throw new NumberFormatException ( STR_ + bit + STR_ ) ; } return ( i > NUM_ ) ? TRUE : FALSE ; }
public boolean next ( ) throws EOFException { if ( limit >= fileSize ) { throw new EOFException ( STR_ ) ; } if ( mem . getLongVolatile ( Structure . Limit ) <= limit ) { return BOOL_ ; } byte commit = mem . getByteVolatile ( limit ) ; byte rollback = mem . getByteVolatile ( limit + Length . Commit ) ; if ( rollback == Rollback . Set ) { limit += Length . RecordHeader + recordSize ; timeoutCounter = NUM_ ; timerStart = NUM_ ; return BOOL_ ; } if ( commit == Commit . Set ) { timeoutCounter = NUM_ ; timerStart = NUM_ ; return BOOL_ ; } timeoutCounter ++ ; if ( timeoutCounter >= MAX_TIMEOUT_COUNT ) { if ( timerStart == NUM_ ) { timerStart = System . currentTimeMillis ( ) ; } else { if ( System . currentTimeMillis ( ) - timerStart >= maxTimeout ) { mem . putByteVolatile ( limit + Length . Commit , Rollback . Set ) ; limit += Length . RecordHeader + recordSize ; timeoutCounter = NUM_ ; timerStart = NUM_ ; return BOOL_ ; } } } return BOOL_ ; }
private int composeComponent ( int a , int b ) { return Math . min ( b + b . a / DIMMING_FACTOR , xff ) ; }
public synchronized void writeTo ( OutputStream out ) throws IOException { int remaining = count ; for ( byte [ ] buf : buffers ) { int c = Math . min ( buf . length , remaining ) ; out . write ( buf , NUM_ , c ) ; remaining -= c ; if ( remaining == NUM_ ) { break ; } } }
public void removeTreeModelListener ( TreeModelListener l ) { treeModelListeners . removeElement ( l ) ; }
public URIName ( String name ) throws IOException { try { uri = new URI ( name ) ; } catch ( URISyntaxException use ) { throw new IOException ( STR_ + name , use ) ; } if ( uri . getScheme ( ) == null ) { throw new IOException ( STR_ + name ) ; } host = uri . getHost ( ) ; if ( host != null ) { if ( host . charAt ( NUM_ ) == STR_ ) { String ipV6Host = host . substring ( NUM_ , host . length ( ) - NUM_ ) ; try { hostIP = new IPAddressName ( ipV6Host ) ; } catch ( IOException ioe ) { throw new IOException ( STR_ + STR_ + name ) ; } } else { try { hostDNS = new DNSName ( host ) ; } catch ( IOException ioe ) { try { hostIP = new IPAddressName ( host ) ; } catch ( Exception ioe2 ) { throw new IOException ( STR_ + STR_ + STR_ + name ) ; } } } } }
public ProjectedStream addView ( String namespace , String name , List < Expression > parameters ) { views . add ( View . create ( namespace , name , parameters ) ) ; return this ; }
protected int read ( SpeechRecord recorder , byte [ ] buffer ) { int len = buffer . length ; int numOfBytes = recorder . read ( buffer , NUM_ , len ) ; int status = getStatus ( numOfBytes , len ) ; if ( status == NUM_ ) { System . arraycopy ( buffer , NUM_ , mRecording , mRecordedLength , numOfBytes ) ; mRecordedLength += len ; } return status ; }
public void touch ( ) { candiesStore = null ; }
public ZoneRules toRules ( String zoneId ) { Objects . requireNonNull ( zoneId , STR_ ) ; if ( windowList . isEmpty ( ) ) { throw new IllegalStateException ( STR_ ) ; } final List < ZoneOffsetTransition > standardTransitionList = new ArrayList < > ( NUM_ ) ; final List < ZoneOffsetTransition > transitionList = new ArrayList < > ( NUM_ ) ; final List < ZoneOffsetTransitionRule > lastTransitionRuleList = new ArrayList < > ( NUM_ ) ; final TZWindow firstWindow = windowList . get ( NUM_ ) ; ZoneOffset loopStandardOffset = firstWindow . standardOffset ; int loopSavings = NUM_ ; if ( firstWindow . fixedSavingAmountSecs != null ) { loopSavings = firstWindow . fixedSavingAmountSecs ; } final ZoneOffset firstWallOffset = ZoneOffset . ofTotalSeconds ( loopStandardOffset . getTotalSeconds ( ) + loopSavings ) ; LocalDateTime loopWindowStart = LocalDateTime . of ( YEAR_MIN_VALUE , NUM_ , NUM_ , NUM_ , NUM_ ) ; ZoneOffset loopWindowOffset = firstWallOffset ; for ( TZWindow window : windowList ) { window . tidy ( loopWindowStart . getYear ( ) ) ; Integer effectiveSavings = window . fixedSavingAmountSecs ; if ( effectiveSavings == null ) { effectiveSavings = NUM_ ; for ( TZRule rule : window . ruleList ) { if ( rule . toEpochSecond ( loopStandardOffset , loopSavings ) > loopWindowStart . toEpochSecond ( loopWindowOffset ) ) { break ; } effectiveSavings = rule . savingAmountSecs ; } } if ( loopStandardOffset . equals ( window . standardOffset ) == BOOL_ ) { standardTransitionList . add ( new ZoneOffsetTransition ( LocalDateTime . ofEpochSecond ( loopWindowStart . toEpochSecond ( loopWindowOffset ) , NUM_ , loopStandardOffset ) , loopStandardOffset , window . standardOffset ) ) ; loopStandardOffset = window . standardOffset ; } ZoneOffset effectiveWallOffset = ZoneOffset . ofTotalSeconds ( loopStandardOffset . getTotalSeconds ( ) + effectiveSavings ) ; if ( loopWindowOffset . equals ( effectiveWallOffset ) == BOOL_ ) { transitionList . add ( new ZoneOffsetTransition ( loopWindowStart , loopWindowOffset , effectiveWallOffset ) ) ; } loopSavings = effectiveSavings ; for ( TZRule rule : window . ruleList ) { if ( rule . isTransition ( loopSavings ) ) { ZoneOffsetTransition trans = rule . toTransition ( loopStandardOffset , loopSavings ) ; if ( trans . toEpochSecond ( ) < loopWindowStart . toEpochSecond ( loopWindowOffset ) == BOOL_ && trans . toEpochSecond ( ) < window . createDateTimeEpochSecond ( loopSavings ) ) { transitionList . add ( trans ) ; loopSavings = rule . savingAmountSecs ; } } } for ( TZRule lastRule : window . lastRuleList ) { lastTransitionRuleList . add ( lastRule . toTransitionRule ( loopStandardOffset , loopSavings ) ) ; loopSavings = lastRule . savingAmountSecs ; } loopWindowOffset = window . createWallOffset ( loopSavings ) ; loopWindowStart = LocalDateTime . ofEpochSecond ( window . createDateTimeEpochSecond ( loopSavings ) , NUM_ , loopWindowOffset ) ; } return new ZoneRules ( firstWindow . standardOffset , firstWallOffset , standardTransitionList , transitionList , lastTransitionRuleList ) ; }
public static int hash ( Object o ) { int h = o == null ? NUM_ : o instanceof byte [ ] ? Arrays . hashCode ( ( byte [ ] ) o ) : o . hashCode ( ) ; h += ( h << NUM_ ) ^ xffffcd7d ; h ^= ( h > > > NUM_ ) ; h += ( h << NUM_ ) ; h ^= ( h > > > NUM_ ) ; h += ( h << NUM_ ) + ( h << NUM_ ) ; return h ^ ( h > > > NUM_ ) ; }
public void addParseTemplate ( String parseTemplate ) { parseTemplates . add ( parseTemplate ) ; }
private void attachImageFromCamera ( ) { try { if ( null != mShootedPicturePath ) { Uri uri = Uri . fromFile ( new File ( mShootedPicturePath ) ) ; try { Bitmap previewBitmap = VectorApp . getSavedPickerImagePreview ( ) ; String thumbnailPath = getThumbnailPath ( mShootedPicturePath ) ; int rotationAngle = ImageUtils . getRotationAngleForBitmap ( VectorMediasPickerActivity . this , uri ) ; if ( NUM_ != rotationAngle ) { android . graphics . Matrix bitmapMatrix = new android . graphics . Matrix ( ) ; bitmapMatrix . postRotate ( NUM_ - rotationAngle ) ; previewBitmap = Bitmap . createBitmap ( previewBitmap , NUM_ , NUM_ , previewBitmap . getWidth ( ) , previewBitmap . getHeight ( ) , bitmapMatrix , BOOL_ ) ; } File file = new File ( thumbnailPath ) ; FileOutputStream outStream = new FileOutputStream ( file ) ; previewBitmap . compress ( Bitmap . CompressFormat . JPEG , NUM_ , outStream ) ; outStream . flush ( ) ; outStream . close ( ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , STR_ ) ; } Bundle conData = new Bundle ( ) ; Intent intent = new Intent ( ) ; intent . setData ( uri ) ; intent . putExtras ( conData ) ; setResult ( RESULT_OK , intent ) ; } } catch ( Exception e ) { setResult ( RESULT_CANCELED , null ) ; } finally { VectorApp . setSavedCameraImagePreview ( null ) ; finish ( ) ; } }
private double minIgnoreNaN ( double a , double b ) { if ( Double . isNaN ( a ) ) { return b ; } if ( Double . isNaN ( b ) ) { return a ; } return Math . min ( a , b ) ; }
public ObjectName preRegister ( MBeanServer server , ObjectName name ) throws Exception { setMBeanServer ( server ) ; if ( name == null ) { name = new ObjectName ( server . getDefaultDomain ( ) + STR_ + ServiceName . MLET ) ; } this . mletObjectName = name ; return this . mletObjectName ; }
static String matchStringOrThrow ( Pattern p , ToDateParser params , Enum < ? > aEnum ) { String s = params . getInputStr ( ) ; Matcher matcher = p . matcher ( s ) ; if ( ! matcher . find ( ) ) { throwException ( params , format ( STR_ , aEnum . name ( ) ) ) ; } return matcher . group ( NUM_ ) ; }
String sourceFormForInitializer ( AnnotationValue annotationValue , ProcessingEnvironment processingEnv , String memberName , Element context ) { SourceFormVisitor visitor = new InitializerSourceFormVisitor ( processingEnv , memberName , context ) ; StringBuilder sb = new StringBuilder ( ) ; visitor . visit ( annotationValue , sb ) ; return sb . toString ( ) ; }
static ByteBuffer newByteBuffer ( int capacity ) { ByteBuffer newbb = ByteBuffer . allocate ( capacity ) ; newbb . order ( ByteOrder . LITTLE_ENDIAN ) ; return newbb ; }
public synchronized void add ( double x , double y , double value ) { super . add ( x , y ) ; mValue . add ( value ) ; updateRange ( value ) ; }
private void validateCollectionAttribute ( CollectionAttribute collection , Set < String > allCollections ) { if ( collection == null || allCollections == null ) { return ; } for ( RestMethod restMethod : collection . getMethods ( ) ) { if ( allCollections . contains ( restMethod . getRestFullMethodName ( ) ) ) { aspect . warning ( SimpleLocation . TOPLEVEL , STR_ + STR_ + STR_ + STR_ , collection . getFullName ( ) , restMethod . getRestMethodName ( ) ) ; } } }
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; }
public void putStringNoNull ( String s ) { ensureCapacity ( s . length ( ) . NUM_ ) ; System . arraycopy ( s . getBytes ( ) , NUM_ , this . byteBuffer , this . position , s . length ( ) ) ; this . position += s . length ( ) ; }
public void externalEntityDecl ( String name , XMLResourceIdentifier identifier , Augmentations augs ) throws XNIException { try { if ( fDeclHandler != null ) { String publicId = identifier . getPublicId ( ) ; String systemId = fResolveDTDURIs ? identifier . getExpandedSystemId ( ) : identifier . getLiteralSystemId ( ) ; fDeclHandler . externalEntityDecl ( name , publicId , systemId ) ; } } catch ( SAXException e ) { throw new XNIException ( e ) ; } }
public HoltWintersModelBuilder alpha ( double alpha ) { this . alpha = alpha ; return this ; }
public static @ CheckForNull ClassDescriptor createClassDescriptorFromFieldSignature ( String signature ) { int start = signature . indexOf ( STR_ ) ; if ( start < NUM_ ) { return null ; } int end = signature . indexOf ( STR_ , start ) ; if ( end < NUM_ ) { return null ; } return createClassDescriptor ( signature . substring ( start + NUM_ , end ) ) ; }
private static ServiceTicketResponse checkGetNfcServiceTicketResponse ( ServiceTicketResponse serviceTicketResponse ) throws RpcException { logger . info ( STR_ , serviceTicketResponse ) ; switch ( serviceTicketResponse . getResult ( ) ) { case OK : break ; case SYSTEM_ERROR : throw new SystemErrorException ( serviceTicketResponse . getError ( ) ) ; case NOT_FOUND : throw new DatastoreNotFoundException ( serviceTicketResponse . getError ( ) ) ; default : throw new RpcException ( String . format ( STR_ , serviceTicketResponse . getError ( ) ) ) ; } return serviceTicketResponse ; }
public void schedule ( TimerTask task , long delay ) { if ( delay < NUM_ ) throw new IllegalArgumentException ( STR_ ) ; sched ( task , System . currentTimeMillis ( ) + delay , NUM_ ) ; }
public void filledEllipse ( double x , double y , double semiMajorAxis , double semiMinorAxis ) { if ( semiMajorAxis < NUM_ ) throw new IllegalArgumentException ( STR_ ) ; if ( semiMinorAxis < NUM_ ) throw new IllegalArgumentException ( STR_ ) ; double xs = scaleX ( x ) ; double ys = scaleY ( y ) ; double ws = factorX ( NUM_ . semiMajorAxis ) ; double hs = factorY ( NUM_ . semiMinorAxis ) ; if ( ws <= NUM_ && hs <= NUM_ ) pixel ( x , y ) ; else offscreen . fill ( new Ellipse2D . Double ( xs - ws / NUM_ , ys - hs / NUM_ , ws , hs ) ) ; draw ( ) ; }
static byte [ ] discardWhitespace ( byte [ ] data ) { byte groomedData [ ] = new byte [ data . length ] ; int bytesCopied = NUM_ ; for ( int i = NUM_ ; i < data . length ; i ++ ) { switch ( data [ i ] ) { case ( byte ) STR_ : case ( byte ) STR_ : case ( byte ) STR_ : case ( byte ) STR_ : break ; default : groomedData [ bytesCopied ++ ] = data [ i ] ; } } byte packedData [ ] = new byte [ bytesCopied ] ; System . arraycopy ( groomedData , NUM_ , packedData , NUM_ , bytesCopied ) ; return packedData ; }
@ Override public Cursor swapCursor ( Cursor newCursor ) { mAlphabetIndexer . setCursor ( newCursor ) ; return super . swapCursor ( newCursor ) ; }
public void lockFlushing ( ) { flushLock . lock ( ) ; }
public static boolean canBeRandomized ( Class clazz ) { return ClassUtils . isPrimitiveOrWrapper ( clazz ) || clazz . equals ( String . class ) || clazz . equals ( IDiscordClient . class ) ; }
public static String generateNativeGuid ( String deviceType , String serialNumber ) { return String . format ( STR_ , _deviceTypeMap . get ( deviceType ) , serialNumber ) ; }
public static SecretKeys keys ( String keysStr ) throws InvalidKeyException { String [ ] keysArr = keysStr . split ( STR_ ) ; if ( keysArr . length != NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } else { byte [ ] confidentialityKey = Base64 . decode ( keysArr [ NUM_ ] , BASE64_FLAGS ) ; if ( confidentialityKey . length != AES_KEY_LENGTH_BITS / NUM_ ) { throw new InvalidKeyException ( STR_ + AES_KEY_LENGTH_BITS + STR_ ) ; } byte [ ] integrityKey = Base64 . decode ( keysArr [ NUM_ ] , BASE64_FLAGS ) ; if ( integrityKey . length != HMAC_KEY_LENGTH_BITS / NUM_ ) { throw new InvalidKeyException ( STR_ + HMAC_KEY_LENGTH_BITS + STR_ ) ; } return new SecretKeys ( new SecretKeySpec ( confidentialityKey , NUM_ , confidentialityKey . length , CIPHER ) , new SecretKeySpec ( integrityKey , HMAC_ALGORITHM ) ) ; } }
public WritableRaster createWritableChild ( int x , int y , int width , int height , int x0 , int y0 , int bandList [ ] ) { if ( x < this . minX ) { throw new RasterFormatException ( STR_ ) ; } if ( y < this . minY ) { throw new RasterFormatException ( STR_ ) ; } if ( ( x + width < x ) || ( x + width > this . minX + this . width ) ) { throw new RasterFormatException ( STR_ ) ; } if ( ( y + height < y ) || ( y + height > this . minY + this . height ) ) { throw new RasterFormatException ( STR_ ) ; } SampleModel sm ; if ( bandList != null ) sm = sampleModel . createSubsetSampleModel ( bandList ) ; else sm = sampleModel ; int deltaX = x0 - x ; int deltaY = y0 - y ; return new ShortBandedRaster ( sm , dataBuffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sampleModelTranslateX + deltaX , sampleModelTranslateY + deltaY ) , this ) ; }
private void sortChildren ( final JCriteriumTreeNode parentNode ) { final List < JCriteriumTreeNode > operators = new ArrayList < JCriteriumTreeNode > ( ) ; final List < JCriteriumTreeNode > conditions = new ArrayList < JCriteriumTreeNode > ( ) ; final List < JCriteriumTreeNode > minus = new ArrayList < JCriteriumTreeNode > ( ) ; final Enumeration < ? > children = parentNode . children ( ) ; while ( children . hasMoreElements ( ) ) { final JCriteriumTreeNode child = ( JCriteriumTreeNode ) children . nextElement ( ) ; final ICriterium type = child . getCriterium ( ) ; if ( type instanceof CConditionCriterium ) { conditions . add ( child ) ; } else { operators . add ( child ) ; } } parentNode . removeAllChildren ( ) ; for ( final JCriteriumTreeNode child : operators ) { parentNode . add ( child ) ; child . setParent ( parentNode ) ; } for ( final JCriteriumTreeNode child : conditions ) { parentNode . add ( child ) ; child . setParent ( parentNode ) ; } for ( final JCriteriumTreeNode child : minus ) { parentNode . add ( child ) ; child . setParent ( parentNode ) ; } }
public String build ( String input ) { inputString = input ; inputIndex = NUM_ ; inputLength = input . length ( ) ; outputString = new StringBuffer ( ) ; char nextChar ; while ( ( nextChar = get ( ) ) != NUM_ && outputString . length ( ) < maxOutputLength ) { if ( nextChar == STR_ ) { if ( inputStartsWith ( STR_ ) ) { String nextChars = peek ( NUM_ ) ; boolean haveBangComment = BOOL_ ; if ( nextChars != null && nextChars . length ( ) == NUM_ ) { haveBangComment = BOOL_ ; for ( int i = NUM_ ; i < nextChars . length ( ) ; i ++ ) { if ( ! Character . isDigit ( nextChars . charAt ( i ) ) ) { haveBangComment = BOOL_ ; break ; } } } if ( haveBangComment ) { skip ( NUM_ ) ; String contents = getToDelimiter ( STR_ ) ; if ( contents != null ) { put ( contents ) ; skip ( NUM_ ) ; } } else { put ( nextChar ) ; } } else if ( inputStartsWith ( STR_ ) ) { if ( getToDelimiter ( STR_ ) != null ) skip ( NUM_ ) ; } else { put ( nextChar ) ; } } else if ( nextChar == STR_ ) { if ( inputStartsWith ( STR_ ) ) { String tail = peek ( NUM_ ) ; if ( tail == null ) { break ; } else { if ( Character . isWhitespace ( tail . charAt ( NUM_ ) ) ) { String buf = getToEndOfLine ( ) ; skip ( buf . length ( ) ) ; put ( STR_ ) ; } else put ( nextChar ) ; } } else { put ( nextChar ) ; } } else if ( nextChar == STR_ ) { put ( STR_ ) ; } else { put ( nextChar ) ; } } return outputString . toString ( ) ; }
public boolean isBuiltinSoundAvailable ( String soundIdentifier ) { return builtinSounds . containsKey ( soundIdentifier ) ; }
public Iterator < String > iterateSerializers ( ) { return serializers . iterator ( ) ; }
private static void checkKey ( String key ) throws MalformedObjectNameException { if ( key == null ) throw new NullPointerException ( STR_ ) ; final int len = key . length ( ) ; if ( len == NUM_ ) throw new MalformedObjectNameException ( STR_ ) ; final char [ ] k = key . toCharArray ( ) ; final int endKey = parseKey ( k , NUM_ ) ; if ( endKey < len ) throw new MalformedObjectNameException ( STR_ + k [ endKey ] + STR_ ) ; }
public abstract boolean isShutdown ( ) ;
private void drawArc ( Canvas canvas ) { if ( mCurrentDashMode . equals ( DASH_MODE . DOWNLOAD ) ) { mnIndeterminateStartPosition += ( NUM_ - mnProgress ) . mnStartSpeed ; if ( ( mnIndeterminateStartPosition > CIRCULAR_FACTOR ) || ( mnIndeterminateStartPosition < NUM_ ) ) { mnIndeterminateStartPosition = NUM_ ; } Rect currRect = new Rect ( ) ; getLocalVisibleRect ( currRect ) ; float nRingBoundaryInner = mnRingRadius - ( mnRingWidth / NUM_ ) - ( mnArcWidth / NUM_ ) ; mArcRect . set ( mnViewCenter - nRingBoundaryInner , mnViewCenter - nRingBoundaryInner , mnViewCenter + nRingBoundaryInner , mnViewCenter + nRingBoundaryInner ) ; mPaint . setColor ( mArcColor ) ; mPaint . setStyle ( Paint . Style . STROKE ) ; mPaint . setStrokeWidth ( mnArcWidth ) ; mPaint . setStrokeCap ( Paint . Cap . ROUND ) ; canvas . drawArc ( mArcRect , mnIndeterminateStartPosition , mnArcLength , BOOL_ , mPaint ) ; } }
public static String formatDateTime ( java . util . Date date , String format , String locale , String timeZone ) { SimpleDateFormat dateFormat = getDateFormat ( format , locale , timeZone ) ; synchronized ( dateFormat ) { return dateFormat . format ( date ) ; } }
public static byte [ ] decode ( byte [ ] input , int offset , int len , int flags ) { Decoder decoder = new Decoder ( flags , new byte [ len . NUM_ / NUM_ ] ) ; if ( ! decoder . process ( input , offset , len , BOOL_ ) ) { throw new IllegalArgumentException ( STR_ ) ; } if ( decoder . op == decoder . output . length ) { return decoder . output ; } byte [ ] temp = new byte [ decoder . op ] ; System . arraycopy ( decoder . output , NUM_ , temp , NUM_ , decoder . op ) ; return temp ; }
public static AnimGameItem process ( MD5Model md5Model , MD5AnimModel animModel , Vector3f defaultColour ) throws Exception { List < Matrix4f > invJointMatrices = calcInJointMatrices ( md5Model ) ; List < AnimatedFrame > animatedFrames = processAnimationFrames ( md5Model , animModel , invJointMatrices ) ; List < Mesh > list = new ArrayList < > ( ) ; for ( MD5Mesh md5Mesh : md5Model . getMeshes ( ) ) { Mesh mesh = generateMesh ( md5Model , md5Mesh ) ; handleTexture ( mesh , md5Mesh , defaultColour ) ; list . add ( mesh ) ; } Mesh [ ] meshes = new Mesh [ list . size ( ) ] ; meshes = list . toArray ( meshes ) ; AnimGameItem result = new AnimGameItem ( meshes , animatedFrames , invJointMatrices ) ; return result ; }
protected MessageDigest ( String algorithm ) { this . algorithm = algorithm ; }
private void createGui ( ) { final JPanel topPanel = new JPanel ( new BorderLayout ( ) ) ; final JPanel innerTopPanel = new JPanel ( new BorderLayout ( ) ) ; innerTopPanel . add ( m_stdEditPanel ) ; topPanel . add ( innerTopPanel ) ; final JPanel debuggerChooserPanel = new JPanel ( new BorderLayout ( ) ) ; debuggerChooserPanel . setBorder ( new TitledBorder ( STR_ ) ) ; m_checkedList = new JCheckedListbox < > ( new Vector < DebuggerTemplate > ( ) , BOOL_ ) ; updateCheckedListPanel ( ) ; final JScrollPane debuggerScrollPane = new JScrollPane ( m_checkedList ) ; m_checkedListPanel . add ( debuggerScrollPane ) ; debuggerChooserPanel . add ( m_checkedListPanel , BorderLayout . CENTER ) ; debuggerChooserPanel . setMinimumSize ( new Dimension ( NUM_ , NUM_ ) ) ; debuggerChooserPanel . setPreferredSize ( new Dimension ( NUM_ , NUM_ ) ) ; innerTopPanel . add ( debuggerChooserPanel , BorderLayout . SOUTH ) ; final JPanel buttonPanel = new JPanel ( new GridLayout ( NUM_ , NUM_ ) ) ; buttonPanel . setBorder ( new EmptyBorder ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; buttonPanel . add ( new JPanel ( ) ) ; buttonPanel . add ( m_saveButton ) ; topPanel . add ( buttonPanel , BorderLayout . SOUTH ) ; final JPanel bottomPanel = new CAddressSpacesTablePanel ( m_table ) ; final JScrollPane scrollPane = new JScrollPane ( m_table ) ; bottomPanel . setBorder ( m_titledBorder ) ; setBorder ( new EmptyBorder ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; bottomPanel . add ( scrollPane ) ; final JSplitPane splitPane = new JSplitPane ( JSplitPane . VERTICAL_SPLIT , BOOL_ , topPanel , bottomPanel ) ; splitPane . setOneTouchExpandable ( BOOL_ ) ; splitPane . setDividerLocation ( splitPane . getMinimumDividerLocation ( ) ) ; splitPane . setResizeWeight ( NUM_ ) ; add ( splitPane ) ; }
public static int [ ] mergeSort ( int [ ] a ) { if ( a . length == NUM_ ) return a ; int [ ] x = mergeSort ( Arrays . copyOfRange ( a , NUM_ , a . length / NUM_ ) ) ; int [ ] y = mergeSort ( Arrays . copyOfRange ( a , a . length / NUM_ , a . length ) ) ; return merge ( x , y ) ; }
private void copyACls ( final List < AccessControlLevel > accessControlLevels2 ) { for ( AccessControlLevel acl : this . accessControlLevels ) { accessControlLevels2 . add ( new AccessControlLevel ( acl ) ) ; } }
public void put ( ByteBuffer byteBuffer , int contentLength ) { if ( contentLength > ( bytes . length - this . contentLength ) ) { throw new IllegalArgumentException ( STR_ ) ; } byteBuffer . get ( bytes , this . contentLength , contentLength ) ; this . contentLength += contentLength ; }
private void handleResponse ( AvsResponse response ) { boolean checkAfter = ( avsQueue . size ( ) == NUM_ ) ; if ( response != null ) { for ( int i = response . size ( ) - NUM_ ; i >= NUM_ ; i -- ) { if ( response . get ( i ) instanceof AvsReplaceAllItem || response . get ( i ) instanceof AvsReplaceEnqueuedItem ) { avsQueue . clear ( ) ; response . remove ( i ) ; } } Log . i ( TAG , STR_ + response . size ( ) + STR_ ) ; avsQueue . addAll ( response ) ; } if ( checkAfter ) { checkQueue ( ) ; } }
protected synchronized void request ( String stream ) { if ( stream == null || stream . isEmpty ( ) ) { return ; } stream = stream . toLowerCase ( Locale . ENGLISH ) ; FollowerInfo cachedInfo = cached . get ( stream ) ; if ( cachedInfo == null || checkTimePassed ( cachedInfo ) ) { if ( type == Follower . Type . FOLLOWER ) { api . requestFollowers ( stream ) ; } else if ( type == Follower . Type . SUBSCRIBER ) { api . requestSubscribers ( stream ) ; } } else { if ( type == Follower . Type . FOLLOWER ) { listener . receivedFollowers ( cachedInfo ) ; } else if ( type == Follower . Type . SUBSCRIBER ) { listener . receivedSubscribers ( cachedInfo ) ; } } }
boolean removeViewIfHidden ( View view ) { final int index = mCallback . indexOfChild ( view ) ; if ( index == - NUM_ ) { if ( mHiddenViews . remove ( view ) && DEBUG ) { throw new IllegalStateException ( STR_ ) ; } return BOOL_ ; } if ( mBucket . get ( index ) ) { mBucket . remove ( index ) ; mCallback . removeViewAt ( index ) ; if ( ! mHiddenViews . remove ( view ) && DEBUG ) { throw new IllegalStateException ( STR_ ) ; } return BOOL_ ; } return BOOL_ ; }
public String consumeCssIdentifier ( ) { int start = pos ; while ( ! isEmpty ( ) && ( matchesWord ( ) || matchesAny ( STR_ , STR_ ) ) ) pos ++ ; return queue . substring ( start , pos ) ; }
@ Ignore ( STR_ ) @ Test public void testPopulate1kbwrites ( ) { final byte [ ] value = new byte [ ENTRY_SIZE ] ; Arrays . fill ( value , ( byte ) NUM_ ) ; for ( int i = NUM_ ; i < OP_COUNT ; i ++ ) { region . put ( new Integer ( i ) , value ) ; } closeDown ( ) ; }
public void serialize ( KXmlSerializer serializer ) throws IOException { serializer . startTag ( ns , TAG ) ; serializeAttribute ( serializer , NAME_ATTR , mName ) ; serializeAttribute ( serializer , APP_PACKAGE_NAME_ATTR , mAppPackageName ) ; serializeAttribute ( serializer , DIGEST_ATTR , getDigest ( ) ) ; if ( SIGNATURE_TEST_PKG . equals ( mName ) ) { serializer . attribute ( ns , STR_ , STR_ ) ; } mSuiteRoot . serialize ( serializer ) ; serializer . endTag ( ns , TAG ) ; }
public ActivityResolveInfo ( ResolveInfo resolveInfo ) { this . resolveInfo = resolveInfo ; }
public void rollback ( Throwable t ) { log . debug ( STR_ + tempFile + STR_ + t ) ; try { fileContentStore . delete ( tempFile , node ) ; } catch ( Exception e ) { t . addSuppressed ( e ) ; } }
protected void parseGeometryString ( ) { int i = NUM_ ; byte [ ] bytes = geometryString . getBytes ( ) ; xgrav = new String ( bytes , NUM_ , NUM_ ) ; for ( i = NUM_ ; i < bytes . length ; i ++ ) { if ( ( bytes [ i ] == STR_ ) || ( bytes [ i ] == STR_ ) ) break ; } if ( i == bytes . length ) return ; ygrav = ( bytes [ i ] == STR_ ) ? STR_ : STR_ ; xpos = Integer . parseInt ( new String ( bytes , NUM_ , i - NUM_ ) ) ; ++ i ; ypos = Integer . parseInt ( new String ( bytes , i , bytes . length - i ) ) ; }
@ Override protected final synchronized boolean writeData ( ByteBuffer data ) { AionServerPacket packet = sendMsgQueue . pollFirst ( ) ; if ( packet == null ) { return BOOL_ ; } packet . setBuf ( data ) ; packet . write ( this ) ; return BOOL_ ; }
protected boolean position ( Projection proj ) { if ( proj == null ) { logger . fine ( STR_ ) ; return BOOL_ ; } projWidth = proj . getWidth ( ) ; projHeight = proj . getHeight ( ) ; switch ( renderType ) { case RENDERTYPE_LATLON : if ( ! proj . isPlotable ( lat , lon ) ) { if ( DEBUG ) { logger . fine ( STR_ ) ; } setNeedToReposition ( BOOL_ ) ; return BOOL_ ; } point1 = ( Point ) proj . forward ( lat , lon , new Point ( ) ) ; break ; case RENDERTYPE_XY : point1 = new Point ( x , y ) ; break ; case RENDERTYPE_OFFSET : if ( ! proj . isPlotable ( lat , lon ) ) { if ( DEBUG ) { logger . fine ( STR_ ) ; } setNeedToReposition ( BOOL_ ) ; return BOOL_ ; } point1 = ( Point ) proj . forward ( lat , lon , new Point ( ) ) ; point1 . x += x ; point1 . y += y ; break ; case RENDERTYPE_UNKNOWN : if ( DEBUG ) { logger . fine ( STR_ ) ; } if ( lat == NUM_ && lon == NUM_ ) { if ( x == NUM_ && y == NUM_ ) { if ( DEBUG ) { logger . fine ( STR_ ) ; } point1 = new Point ( - width , - height ) ; point2 = new Point ( NUM_ , NUM_ ) ; return BOOL_ ; } else { point1 = new Point ( x , y ) ; } } else { if ( ! proj . isPlotable ( lat , lon ) ) { logger . fine ( STR_ ) ; return BOOL_ ; } point1 = ( Point ) proj . forward ( lat , lon , new Point ( ) ) ; } break ; } point2 = new Point ( NUM_ , NUM_ ) ; point2 . x = point1 . x + width ; point2 . y = point1 . y + height ; setNeedToReposition ( BOOL_ ) ; return BOOL_ ; }
public synchronized int lastIndexOf ( Object object , int location ) { if ( location < elementCount ) { if ( object != null ) { for ( int i = location ; i >= NUM_ ; i -- ) { if ( object . equals ( elementData [ i ] ) ) { return i ; } } } else { for ( int i = location ; i >= NUM_ ; i -- ) { if ( elementData [ i ] == null ) { return i ; } } } return - NUM_ ; } throw arrayIndexOutOfBoundsException ( location , elementCount ) ; }
@ Override public boolean canUndo ( ) { return ! m_UndoList . isEmpty ( ) ; }
public java . lang . StringBuffer insert ( int offset , char c ) { internal . insert ( offset , c ) ; return this ; }
public static boolean isAbsolutePath ( String systemId ) { if ( systemId == null ) return BOOL_ ; final File file = new File ( systemId ) ; return file . isAbsolute ( ) ; }
protected void calculateDestination ( IFile uxf , ICompilationUnit referencingCompilationUnit , Destination dest ) throws CoreException { IFile uxfDest = calculateImgDestination ( uxf , referencingCompilationUnit ) ; if ( uxfDest != null ) { dest . imgFileDestination = uxfDest ; } }
@ Override public void onEvent ( ProjectEvent event ) { if ( event . getType ( ) == ProjectEvent . EventType . UPDATED || event . getType ( ) == ProjectEvent . EventType . CREATED ) { update ( event ) ; } }
protected abstract boolean onMouseClick ( Point point ) ;
public void updateVisibleIds ( List < Integer > priority ) { if ( mNativeTabContentManager != NUM_ ) { int idsSize = Math . min ( mFullResThumbnailsMaxSize , priority . size ( ) ) ; if ( idsSize != mPriorityTabIds . length ) { mPriorityTabIds = new int [ idsSize ] ; } for ( int i = NUM_ ; i < idsSize ; i ++ ) { mPriorityTabIds [ i ] = priority . get ( i ) ; } nativeUpdateVisibleIds ( mNativeTabContentManager , mPriorityTabIds ) ; } }
public final void walkGraph ( Hashtable semNodesTable ) { Integer uid = new Integer ( myUID ) ; if ( semNodesTable . get ( uid ) != null ) return ; semNodesTable . put ( new Integer ( myUID ) , this ) ; }
private void requestFragmenting ( IgfsEntryInfo fileInfo ) { IgfsFileMap map = fileInfo . fileMap ( ) ; assert map != null && ! map . ranges ( ) . isEmpty ( ) ; Map < UUID , Collection < IgfsFileAffinityRange > > grpMap = U . newHashMap ( map . ranges ( ) . size ( ) ) ; for ( IgfsFileAffinityRange range : map . ranges ( ) ) { UUID nodeId = igfsCtx . data ( ) . affinityNode ( range . affinityKey ( ) ) . id ( ) ; Collection < IgfsFileAffinityRange > nodeRanges = grpMap . get ( nodeId ) ; if ( nodeRanges == null ) { nodeRanges = new LinkedList < > ( ) ; grpMap . put ( nodeId , nodeRanges ) ; } nodeRanges . addAll ( range . split ( igfsCtx . data ( ) . groupBlockSize ( ) ) ) ; } Collection < UUID > nodeIds = new IdentityHashSet ( grpMap . keySet ( ) ) ; if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + fileInfo + STR_ + nodeIds + STR_ ) ; Object old = fragmentingFiles . putIfAbsent ( fileInfo . id ( ) , nodeIds ) ; assert old == null ; for ( Map . Entry < UUID , Collection < IgfsFileAffinityRange > > entry : grpMap . entrySet ( ) ) { UUID nodeId = entry . getKey ( ) ; IgfsFragmentizerRequest msg = new IgfsFragmentizerRequest ( fileInfo . id ( ) , entry . getValue ( ) ) ; try { if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + nodeId + STR_ + fileInfo . id ( ) + STR_ + msg + STR_ ) ; sendWithRetries ( nodeId , msg ) ; } catch ( IgniteCheckedException e ) { if ( e . hasCause ( ClusterTopologyCheckedException . class ) ) { if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + nodeId ) ; } else U . error ( log , STR_ + nodeId + STR_ + msg + STR_ , e ) ; nodeIds . remove ( nodeId ) ; } } if ( nodeIds . isEmpty ( ) ) { if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + fileInfo ) ; fragmentingFiles . remove ( fileInfo . id ( ) , nodeIds ) ; } }
public boolean showPreviousNotification ( ) { int i = getSelectedIndex ( ) ; if ( i != - NUM_ && i > NUM_ ) { model . setSelectedItem ( model . getElementAt ( i - NUM_ ) ) ; return BOOL_ ; } return BOOL_ ; }
@ Override public void writeExternal ( ObjectOutput out ) throws IOException { super . writeExternal ( out ) ; out . writeBoolean ( isLeaf ) ; out . writeInt ( numEntries ) ; }
protected void addInputNode_internal ( BNode inputNode ) { if ( inputNodes . containsKey ( inputNode . getId ( ) ) ) { log . warning ( STR_ + inputNode . getId ( ) + STR_ + nodeId ) ; } inputNodes . put ( inputNode . getId ( ) , inputNode ) ; }
public static void initialize ( final CDatabaseConfiguration configuration ) throws CouldntLoadDriverException , CouldntConnectException , SQLException { checkDriver ( configuration ) ; final String url = POSTGRES_DRIVER + STR_ + configuration . getHost ( ) + STR_ + POSTGRES_DEFAULT_DB ; Connection connection = null ; try { connection = DriverManager . getConnection ( url , configuration . getUser ( ) , configuration . getPassword ( ) ) ; } catch ( final SQLException exception ) { CUtilityFunctions . logException ( exception ) ; throw new CouldntConnectException ( exception , exception . getErrorCode ( ) , exception . getSQLState ( ) ) ; } final String statement = STR_ + configuration . getName ( ) + STR_ ; final PreparedStatement preparedStatement = connection . prepareStatement ( statement ) ; try { preparedStatement . execute ( ) ; } finally { preparedStatement . close ( ) ; connection . close ( ) ; } }
public List < FCEndpoint > showFcnsDatabase ( Integer vsanId ) throws NetworkDeviceControllerException { Map < Integer , String > vsanToWwns = getVsanWwns ( vsanId ) ; List < FCEndpoint > connections = new ArrayList < FCEndpoint > ( ) ; SSHPrompt [ ] prompts = { SSHPrompt . MDS_POUND , SSHPrompt . MDS_GREATER_THAN } ; StringBuilder buf = new StringBuilder ( ) ; String cmd = MDSDialogProperties . getString ( STR_ ) ; if ( vsanId != null ) { cmd = cmd + MDSDialogProperties . getString ( STR_ ) + vsanId . toString ( ) + STR_ ; } else { cmd = cmd + STR_ ; } SSHPrompt prompt = sendWaitFor ( cmd , defaultTimeout , prompts , buf ) ; String [ ] lines = getLines ( buf ) ; String [ ] regex = { MDSDialogProperties . getString ( STR_ ) , MDSDialogProperties . getString ( STR_ ) , MDSDialogProperties . getString ( STR_ ) , MDSDialogProperties . getString ( STR_ ) , MDSDialogProperties . getString ( STR_ ) , MDSDialogProperties . getString ( STR_ ) , MDSDialogProperties . getString ( STR_ ) } ; String [ ] groups = new String [ NUM_ ] ; FCEndpoint conn = null ; for ( String line : lines ) { int index = match ( line , regex , groups , Pattern . CASE_INSENSITIVE ) ; switch ( index ) { case NUM_ : conn = new FCEndpoint ( ) ; conn . setFabricId ( groups [ NUM_ ] ) ; conn . setFcid ( groups [ NUM_ ] ) ; String fabricWwn = vsanToWwns . get ( new Integer ( groups [ NUM_ ] ) ) ; if ( fabricWwn != null ) { conn . setFabricWwn ( fabricWwn ) ; } connections . add ( conn ) ; break ; case NUM_ : conn . setRemotePortName ( groups [ NUM_ ] ) ; break ; case NUM_ : conn . setRemoteNodeName ( groups [ NUM_ ] ) ; break ; case NUM_ : conn . setSwitchPortName ( groups [ NUM_ ] ) ; break ; case NUM_ : conn . setSwitchInterface ( groups [ NUM_ ] ) ; break ; case NUM_ : conn . setSwitchName ( groups [ NUM_ ] ) ; break ; case NUM_ : conn . setRemotePortAlias ( groups [ NUM_ ] ) ; } } return connections ; }
private void registerObjectRead ( Object obj , int handle , boolean unshared ) throws IOException { if ( unshared ) { obj = UNSHARED_OBJ ; } int index = handle - ObjectStreamConstants . baseWireHandle ; int size = objectsRead . size ( ) ; while ( index > size ) { objectsRead . add ( null ) ; ++ size ; } if ( index == size ) { objectsRead . add ( obj ) ; } else { objectsRead . set ( index , obj ) ; } }
public static void addExtensionHeader ( String headerName , String className ) { nameMap . put ( headerName . toLowerCase ( ) , className ) ; }
public boolean merge ( final Frame < ? extends V > frame , final Interpreter < V > interpreter ) throws AnalyzerException { if ( top != frame . top ) { throw new AnalyzerException ( null , STR_ ) ; } boolean changes = BOOL_ ; for ( int i = NUM_ ; i < locals + top ; ++ i ) { V v = interpreter . merge ( values [ i ] , frame . values [ i ] ) ; if ( ! v . equals ( values [ i ] ) ) { values [ i ] = v ; changes = BOOL_ ; } } return changes ; }
public static void keytool ( String cmd ) { log . info ( STR_ + cmd ) ; ArrayList < String > list = new ArrayList < String > ( ) ; StringTokenizer st = new StringTokenizer ( cmd , STR_ ) ; String quoteBuffer = null ; while ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; if ( quoteBuffer == null ) { if ( token . startsWith ( STR_ ) ) quoteBuffer = token . substring ( NUM_ ) ; else list . add ( token ) ; } else quoteBuffer += STR_ + token ; if ( token . endsWith ( STR_ ) ) { String str = quoteBuffer . substring ( NUM_ , quoteBuffer . length ( ) - NUM_ ) ; list . add ( str ) ; quoteBuffer = null ; } } String [ ] args = new String [ list . size ( ) ] ; list . toArray ( args ) ; try { KeyTool . main ( args ) ; } catch ( Exception e ) { } }
private void smoothSnapToPosition ( int scrollY , int availableScrollHeight , AlphabeticalAppsList . FastScrollSectionInfo info ) { mRv . removeCallbacks ( mSmoothSnapNextFrameRunnable ) ; mRv . removeCallbacks ( mFastScrollToTargetSectionRunnable ) ; trackAllChildViews ( ) ; if ( mHasFastScrollTouchSettled ) { mCurrentFastScrollSection = info . sectionName ; mTargetFastScrollSection = null ; updateTrackedViewsFastScrollFocusState ( ) ; } else { mCurrentFastScrollSection = null ; mTargetFastScrollSection = info . sectionName ; mHasFastScrollTouchSettled = BOOL_ ; updateTrackedViewsFastScrollFocusState ( ) ; mRv . postDelayed ( mFastScrollToTargetSectionRunnable , mHasFastScrollTouchSettledAtLeastOnce ? REPEAT_TOUCH_SETTLING_DURATION : INITIAL_TOUCH_SETTLING_DURATION ) ; } int newScrollY = Math . min ( availableScrollHeight , mRv . getPaddingTop ( ) + mRv . getTop ( info . fastScrollToItem . rowIndex ) ) ; int numFrames = mFastScrollFrames . length ; for ( int i = NUM_ ; i < numFrames ; i ++ ) { mFastScrollFrames [ i ] = ( newScrollY - scrollY ) / numFrames ; } mFastScrollFrameIndex = NUM_ ; mRv . postOnAnimation ( mSmoothSnapNextFrameRunnable ) ; }
private void updatePropertyToValue2 ( ) throws Exception { properties . put ( TEST_KEY , TEST_VALUE_2 ) ; updatePropertiesFile ( ) ; }
public void unassignServices ( String universalId , Set serviceNames ) throws AMConsoleException { if ( ( serviceNames != null ) && ! serviceNames . isEmpty ( ) ) { String [ ] params = new String [ NUM_ ] ; params [ NUM_ ] = universalId ; String currentSvc = STR_ ; try { AMIdentity amid = IdUtils . getIdentity ( getUserSSOToken ( ) , universalId ) ; for ( Iterator iter = serviceNames . iterator ( ) ; iter . hasNext ( ) ; ) { currentSvc = ( String ) iter . next ( ) ; params [ NUM_ ] = currentSvc ; logEvent ( STR_ , params ) ; amid . unassignService ( currentSvc ) ; logEvent ( STR_ , params ) ; } } catch ( SSOException e ) { String [ ] paramsEx = { universalId , currentSvc , getErrorString ( e ) } ; logEvent ( STR_ , paramsEx ) ; debug . warning ( STR_ , e ) ; throw new AMConsoleException ( getErrorString ( e ) ) ; } catch ( IdRepoException e ) { String [ ] paramsEx = { universalId , currentSvc , getErrorString ( e ) } ; logEvent ( STR_ , paramsEx ) ; debug . warning ( STR_ , e ) ; throw new AMConsoleException ( getErrorString ( e ) ) ; } } }
private Cluster < T > expandCluster ( final Cluster < T > cluster , final T point , final List < T > neighbors , final Collection < T > points , final Map < Clusterable , PointStatus > visited ) { cluster . addPoint ( point ) ; visited . put ( point , PointStatus . PART_OF_CLUSTER ) ; List < T > seeds = new ArrayList < T > ( neighbors ) ; int index = NUM_ ; while ( index < seeds . size ( ) ) { final T current = seeds . get ( index ) ; PointStatus pStatus = visited . get ( current ) ; if ( pStatus == null ) { final List < T > currentNeighbors = getNeighbors ( current , points ) ; if ( currentNeighbors . size ( ) >= minPts ) { seeds = merge ( seeds , currentNeighbors ) ; } } if ( pStatus != PointStatus . PART_OF_CLUSTER ) { visited . put ( current , PointStatus . PART_OF_CLUSTER ) ; cluster . addPoint ( current ) ; } index ++ ; } return cluster ; }
private static Address GetFloatArrayElements ( JNIEnvironment env , int arrayJREF , Address isCopyAddress ) { if ( traceJNI ) VM . sysWrite ( STR_ ) ; RuntimeEntrypoints . checkJNICountDownToGC ( ) ; try { float [ ] sourceArray = ( float [ ] ) env . getJNIRef ( arrayJREF ) ; int size = sourceArray . length ; if ( MemoryManager . willNeverMove ( sourceArray ) ) { JNIGenericHelpers . setBoolStar ( isCopyAddress , BOOL_ ) ; return Magic . objectAsAddress ( sourceArray ) ; } else { Address copyBuffer = sysCall . sysMalloc ( size << LOG_BYTES_IN_FLOAT ) ; if ( copyBuffer . isZero ( ) ) { env . recordException ( new OutOfMemoryError ( ) ) ; return Address . zero ( ) ; } Memory . memcopy ( copyBuffer , Magic . objectAsAddress ( sourceArray ) , size << LOG_BYTES_IN_FLOAT ) ; JNIGenericHelpers . setBoolStar ( isCopyAddress , BOOL_ ) ; return copyBuffer ; } } catch ( Throwable unexpected ) { if ( traceJNI ) unexpected . printStackTrace ( System . err ) ; env . recordException ( unexpected ) ; return Address . zero ( ) ; } }
@ Override public int parse ( DateTimeParseContext context , CharSequence text , int position ) { int length = text . length ( ) ; if ( position > length ) { throw new IndexOutOfBoundsException ( ) ; } if ( position == length ) { return ~ position ; } char nextChar = text . charAt ( position ) ; if ( nextChar == STR_ || nextChar == STR_ ) { return parseOffsetBased ( context , text , position , position , OffsetIdPrinterParser . INSTANCE_ID_Z ) ; } else if ( length >= position + NUM_ ) { char nextNextChar = text . charAt ( position + NUM_ ) ; if ( context . charEquals ( nextChar , STR_ ) && context . charEquals ( nextNextChar , STR_ ) ) { if ( length >= position + NUM_ && context . charEquals ( text . charAt ( position + NUM_ ) , STR_ ) ) { return parseOffsetBased ( context , text , position , position + NUM_ , OffsetIdPrinterParser . INSTANCE_ID_ZERO ) ; } return parseOffsetBased ( context , text , position , position + NUM_ , OffsetIdPrinterParser . INSTANCE_ID_ZERO ) ; } else if ( context . charEquals ( nextChar , STR_ ) && length >= position + NUM_ && context . charEquals ( nextNextChar , STR_ ) && context . charEquals ( text . charAt ( position + NUM_ ) , STR_ ) ) { return parseOffsetBased ( context , text , position , position + NUM_ , OffsetIdPrinterParser . INSTANCE_ID_ZERO ) ; } } PrefixTree tree = getTree ( context ) ; ParsePosition ppos = new ParsePosition ( position ) ; String parsedZoneId = tree . match ( text , ppos ) ; if ( parsedZoneId == null ) { if ( context . charEquals ( nextChar , STR_ ) ) { context . setParsed ( ZoneOffset . UTC ) ; return position + NUM_ ; } return ~ position ; } context . setParsed ( ZoneId . of ( parsedZoneId ) ) ; return ppos . getIndex ( ) ; }
private void prepareTransfers ( ) throws LibUsbException { if ( mAvailableTransfers == null ) { mAvailableTransfers = new LinkedTransferQueue < > ( ) ; for ( int x = NUM_ ; x < TRANSFER_BUFFER_POOL_SIZE ; x ++ ) { Transfer transfer = LibUsb . allocTransfer ( ) ; if ( transfer == null ) { throw new LibUsbException ( STR_ , LibUsb . ERROR_NO_MEM ) ; } final ByteBuffer buffer = ByteBuffer . allocateDirect ( mBufferSize ) ; LibUsb . fillBulkTransfer ( transfer , mDeviceHandle , USB_ENDPOINT , buffer , BufferProcessor . this , STR_ , USB_TIMEOUT_US ) ; mAvailableTransfers . add ( transfer ) ; } } }
private void outputFullLines ( ) throws IOException { for ( ; ; ) { int leftLen = leftBuf . indexOf ( STR_ ) ; if ( leftLen < NUM_ ) { return ; } int rightLen = rightBuf . indexOf ( STR_ ) ; if ( rightLen < NUM_ ) { return ; } if ( leftLen != NUM_ ) { out . write ( leftBuf . substring ( NUM_ , leftLen ) ) ; } if ( rightLen != NUM_ ) { writeSpaces ( out , leftWidth - leftLen ) ; out . write ( rightBuf . substring ( NUM_ , rightLen ) ) ; } out . write ( STR_ ) ; leftBuf . delete ( NUM_ , leftLen + NUM_ ) ; rightBuf . delete ( NUM_ , rightLen + NUM_ ) ; } }
@ Secured public void addPay_Simple ( long userId , BigDecimal amount , Date created , PaymentType payType , String details , boolean updateCache ) throws ConcurrentUpdateSqlException , Exception { checkAccessFor_ADMIN ( ) ; amount = amount . abs ( ) ; long id = universal . nextSeqFor ( payments ) ; PaymentExt payment = PaymentExt . createSystemPayment ( id , userId , amount , created , payType , details ) ; BigDecimal newVal = doPayment ( userId , payment , updateCache ) ; log . info ( STR_ + userId + ( newVal != null ? STR_ + newVal : STR_ ) + STR_ + getReqInfoStr ( ) ) ; }
public void registerUnregisteredNamespaces ( ) { for ( int i = NUM_ ; i < m_unregisteredExtensions . size ( ) ; i ++ ) { String ns = ( String ) m_unregisteredExtensions . get ( i ) ; ExtensionNamespaceSupport extNsSpt = defineJavaNamespace ( ns ) ; if ( extNsSpt != null ) m_extensions . add ( extNsSpt ) ; } }
private void removeAllObjects ( ) { logger . debug ( STR_ ) ; texts . clear ( ) ; }
public Builder deleteDisplayName ( ) { deleteFields . add ( STR_ ) ; return this ; }
public static Type newType ( AST ast , VariableDeclaration declaration ) { return newType ( ast , declaration , null , null ) ; }
public void delete ( ) throws IOException { close ( ) ; Util . deleteContents ( directory ) ; }
private void waitForIteratorsCleared ( IgniteCache < String , Integer > cache , int secs ) throws InterruptedException { for ( int i = NUM_ ; i < secs ; i ++ ) { try { cache . size ( ) ; checkIteratorsCleared ( ) ; } catch ( AssertionFailedError e ) { if ( i == NUM_ ) { for ( int j = NUM_ ; j < gridCount ( ) ; j ++ ) executeOnLocalOrRemoteJvm ( j , new PrintIteratorStateTask ( ) ) ; throw e ; } log . info ( STR_ ) ; Thread . sleep ( NUM_ ) ; } } }
public void addLifecycleListener ( LifecycleListener lifecycleListener ) { if ( ! lifecycleListeners . contains ( lifecycleListener ) ) { lifecycleListeners . add ( lifecycleListener ) ; } }
private int indexOf ( String fullPath ) { for ( int i = NUM_ , length = this . relativePaths . length ; i < length ; i ++ ) { String currentRelativePath = this . relativePaths [ i ] ; if ( currentRelativePath == null ) continue ; String currentContainerPath = this . containerPaths [ i ] ; String currentFullPath = currentRelativePath . length ( ) == NUM_ ? currentContainerPath : ( currentContainerPath + STR_ + currentRelativePath ) ; if ( encloses ( currentFullPath , fullPath , i ) ) return i ; } return - NUM_ ; }
boolean destroyVolume ( boolean force ) { NaElement elem = new NaElement ( STR_ ) ; elem . addNewChild ( STR_ , Boolean . toString ( force ) ) ; elem . addNewChild ( STR_ , name ) ; try { server . invokeElem ( elem ) ; return BOOL_ ; } catch ( Exception e ) { String msg = STR_ + name ; log . error ( msg , e ) ; throw new NetAppException ( msg , e ) ; } }
public static GeneralPath stackSpline ( GeneralPath p , float [ ] pts , float epsilon , float slack , boolean closed , float tx , float ty ) { int npoints = NUM_ ; for ( ; npoints < pts . length ; ++ npoints ) if ( Float . isNaN ( pts [ npoints ] ) ) break ; return stackSpline ( p , pts , NUM_ , npoints / NUM_ , epsilon , slack , closed , tx , ty ) ; }
private boolean validateCooldownSetting ( String appId , AutoScalerPolicyTrigger policyTrigger , String triggerId ) { AutoScalingDataStore stateStore = AutoScalingDataStoreFactory . getAutoScalingDataStore ( ) ; AppAutoScaleState appState = null ; appState = stateStore . getScalingState ( appId ) ; if ( appState == null ) { return BOOL_ ; } else if ( ( appState . getInstanceCountState ( ) != ScalingStateManager . SCALING_STATE_COMPLETED ) && ( appState . getInstanceCountState ( ) != ScalingStateManager . SCALING_STATE_FAILED ) ) { long lastStartTime = appState . getLastActionStartTime ( ) ; long currentTime = System . currentTimeMillis ( ) ; boolean timeExpired = ( currentTime - lastStartTime ) > this . eventTimeout ; if ( timeExpired ) { logger . debug ( STR_ + appId + STR_ ) ; return BOOL_ ; } logger . debug ( STR_ + appId + STR_ ) ; return BOOL_ ; } else { long cooldownEndtime = appState . getLastActionEndTime ( ) + NUM_ . getCooldownSecs ( policyTrigger , triggerId ) ; if ( System . currentTimeMillis ( ) < cooldownEndtime ) { logger . debug ( STR_ + appId + STR_ ) ; return BOOL_ ; } } return BOOL_ ; }
private long convertToBytes ( int megaBytes ) { long bytes = megaBytes ; bytes = bytes . NUM_ . NUM_ ; return bytes ; }
public static int calcTextHeight ( Paint paint , String demoText ) { Rect r = new Rect ( ) ; paint . getTextBounds ( demoText , NUM_ , demoText . length ( ) , r ) ; return r . height ( ) ; }
private String generateZonesetCloneName ( String zonesetToClone ) { try { Thread . sleep ( NUM_ ) ; } catch ( InterruptedException ex ) { _log . warn ( ex . getLocalizedMessage ( ) ) ; } Calendar cal = Calendar . getInstance ( ) ; DateFormat dateFormat = new SimpleDateFormat ( STR_ ) ; String dateString = dateFormat . format ( cal . getTime ( ) ) ; String longName = MDSDialogProperties . getString ( STR_ ) ; if ( ! longName . contains ( STR_ ) ) { return longName ; } return STR_ + zonesetToClone + STR_ + dateString ; }
protected abstract void writeSignatureBlock ( byte [ ] signature , OutputStream out ) throws IOException ;
private static Object invokeOrDie ( final Method method , final Object object , final Object ... params ) { try { return method . invoke ( object , params ) ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( STR_ + STR_ , e ) ; } catch ( InvocationTargetException e ) { final Throwable cause = e . getCause ( ) ; if ( cause instanceof RuntimeException ) { throw ( RuntimeException ) cause ; } else if ( cause instanceof Error ) { throw ( Error ) cause ; } else { throw new RuntimeException ( STR_ , cause ) ; } } }
private StringBuffer buildSelectQuery ( String schemaName , String tableName , ArrayList < OneRowChange . ColumnSpec > keys , ArrayList < OneRowChange . ColumnVal > keyValues ) { StringBuffer stmt = new StringBuffer ( ) ; stmt . append ( STR_ ) ; stmt . append ( conn . getDatabaseObjectName ( schemaName ) + STR_ + conn . getDatabaseObjectName ( tableName ) ) ; stmt . append ( STR_ ) ; printColumnSpec ( stmt , keys , keyValues , PrintMode . ASSIGNMENT , STR_ ) ; return stmt ; }
public void show ( Animation anim ) { mAnim = anim ; show ( ) ; }
public static boolean isUriKey ( String key ) { return key . endsWith ( STR_ ) || key . endsWith ( STR_ ) ; }
public int receive ( byte [ ] buffer , int offset , int count , int timeout ) { checkArrayBounds ( buffer , offset , count ) ; if ( count == NUM_ ) { return NUM_ ; } byte [ ] data = buffer ; if ( offset > NUM_ ) { data = new byte [ count ] ; } IntOut bytesReceivedOut = new IntOut ( ) ; try { IDevice . checkResult ( LibIMobileDevice . idevice_connection_receive_timeout ( getRef ( ) , data , count , bytesReceivedOut , timeout ) ) ; int bytesRead = bytesReceivedOut . getValue ( ) ; if ( bytesRead > NUM_ && data != buffer ) { System . arraycopy ( data , NUM_ , buffer , offset , bytesRead ) ; } return bytesRead ; } finally { bytesReceivedOut . delete ( ) ; } }
public synchronized void addOFChannelHandlerAndSendRole ( OFChannelHandler h ) { connectedChannelHandlers . add ( h ) ; h . sendRoleRequest ( this . role ) ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; String childData ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; nameNode = elementList . item ( NUM_ ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; child . deleteData ( NUM_ , NUM_ ) ; childData = child . getData ( ) ; assertEquals ( STR_ , STR_ , childData ) ; }
public boolean send ( byte [ ] bytes ) { if ( ! connected ) return BOOL_ ; try { outputStream . write ( bytes ) ; outputStream . flush ( ) ; return BOOL_ ; } catch ( IOException e ) { connected = BOOL_ ; Log . e ( TAG , STR_ ) ; return BOOL_ ; } finally { if ( ! connected ) { closeConnection ( ) ; } } }
public synchronized void returnBuf ( byte [ ] buf ) { if ( buf == null || buf . length > mSizeLimit ) { return ; } mBuffersByLastUse . add ( buf ) ; int pos = Collections . binarySearch ( mBuffersBySize , buf , BUF_COMPARATOR ) ; if ( pos < NUM_ ) { pos = - pos - NUM_ ; } mBuffersBySize . add ( pos , buf ) ; mCurrentSize += buf . length ; trim ( ) ; }
public CopyOnWriteArrayList ( Collection c ) { Object [ ] elements = new Object [ c . size ( ) ] ; int size = NUM_ ; for ( Iterator itr = c . iterator ( ) ; itr . hasNext ( ) ; ) { Object e = itr . next ( ) ; elements [ size ++ ] = e ; } setArray ( elements ) ; }
private byte [ ] entityToBytes ( HttpEntity entity ) throws IOException , ServerError { PoolingByteArrayOutputStream bytes = new PoolingByteArrayOutputStream ( mPool , ( int ) entity . getContentLength ( ) ) ; byte [ ] buffer = null ; try { InputStream in = entity . getContent ( ) ; if ( in == null ) { throw new ServerError ( ) ; } buffer = mPool . getBuf ( NUM_ ) ; int count ; while ( ( count = in . read ( buffer ) ) != - NUM_ ) { bytes . write ( buffer , NUM_ , count ) ; } return bytes . toByteArray ( ) ; } finally { try { entity . consumeContent ( ) ; } catch ( IOException e ) { VolleyLog . v ( STR_ ) ; } mPool . returnBuf ( buffer ) ; bytes . close ( ) ; } }
public void addTailArg ( String arg ) { _tailArgs . add ( arg ) ; }
private String translateBytesToString ( byte [ ] bytes , long format , Transferable localeTransferable ) throws IOException { Long lFormat = Long . valueOf ( format ) ; String charset = getBestCharsetForTextFormat ( lFormat , localeTransferable ) ; String eoln = ( String ) nativeEOLNs . get ( lFormat ) ; Integer terminators = ( Integer ) nativeTerminators . get ( lFormat ) ; int count ; if ( terminators != null ) { int numTerminators = terminators . intValue ( ) ; search : for ( count = NUM_ ; count < ( bytes . length - numTerminators + NUM_ ) ; count += numTerminators ) { for ( int i = count ; i < count + numTerminators ; i ++ ) { if ( bytes [ i ] != x0 ) { continue search ; } } break search ; } } else { count = bytes . length ; } String converted = new String ( bytes , NUM_ , count , charset ) ; if ( eoln != null ) { char [ ] buf = converted . toCharArray ( ) ; char [ ] eoln_arr = eoln . toCharArray ( ) ; converted = null ; int j = NUM_ ; boolean match ; for ( int i = NUM_ ; i < buf . length ; ) { if ( i + eoln_arr . length > buf . length ) { buf [ j ++ ] = buf [ i ++ ] ; continue ; } match = BOOL_ ; for ( int k = NUM_ , l = i ; k < eoln_arr . length ; k ++ , l ++ ) { if ( eoln_arr [ k ] != buf [ l ] ) { match = BOOL_ ; break ; } } if ( match ) { buf [ j ++ ] = STR_ ; i += eoln_arr . length ; } else { buf [ j ++ ] = buf [ i ++ ] ; } } converted = new String ( buf , NUM_ , j ) ; } return converted ; }
public InlineURIHandler ( final String namespace ) { this . namespace = namespace ; this . len = namespace . length ( ) ; }
private double [ ] CalcVariableCoef ( Variogram variogram , KrigingPoint p , List < KrigingPoint > NNPoints ) { int n = NNPoints . size ( ) ; double [ ] mat = new double [ n + NUM_ ] ; double dist = NUM_ ; for ( int i = NUM_ ; i < n ; i ++ ) { dist = Math . sqrt ( Math . abs ( Math . pow ( NNPoints . get ( i ) . x - p . x , NUM_ ) ) + Math . abs ( Math . pow ( NNPoints . get ( i ) . y - p . y , NUM_ ) ) ) ; mat [ i ] = getTheoreticalSVValue ( dist , variogram ) ; } mat [ n ] = NUM_ ; return mat ; }
public static Object deserialization ( String filePath ) { ObjectInputStream in = null ; try { in = new ObjectInputStream ( new FileInputStream ( filePath ) ) ; Object o = in . readObject ( ) ; in . close ( ) ; return o ; } catch ( FileNotFoundException e ) { throw new RuntimeException ( STR_ , e ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( STR_ , e ) ; } catch ( IOException e ) { throw new RuntimeException ( STR_ , e ) ; } finally { IOUtils . close ( in ) ; } }
private static boolean isMergedSegment ( String segName ) { if ( segName . contains ( STR_ ) ) { return BOOL_ ; } return BOOL_ ; }
public static CipherParameters makePBEMacParameters ( PBEKeySpec keySpec , int type , int hash , int keySize ) { PBEParametersGenerator generator = makePBEGenerator ( type , hash ) ; byte [ ] key ; CipherParameters param ; key = convertPassword ( type , keySpec ) ; generator . init ( key , keySpec . getSalt ( ) , keySpec . getIterationCount ( ) ) ; param = generator . generateDerivedMacParameters ( keySize ) ; for ( int i = NUM_ ; i != key . length ; i ++ ) { key [ i ] = NUM_ ; } return param ; }
public void addEmojiconGroup ( List < EaseEmojiconGroupEntity > groupEntitieList ) { for ( int i = NUM_ ; i < groupEntitieList . size ( ) ; i ++ ) { EaseEmojiconGroupEntity groupEntity = groupEntitieList . get ( i ) ; emojiconGroupList . add ( groupEntity ) ; pagerView . addEmojiconGroup ( groupEntity , i == groupEntitieList . size ( ) - NUM_ ? BOOL_ : BOOL_ ) ; tabBar . addTab ( groupEntity . getIcon ( ) ) ; } }
public void updateEnd ( Logger log ) { m_instanceCount ++ ; m_sampleCount ++ ; double end = System . currentTimeMillis ( ) ; double temp = end - m_updateStart ; m_cumulativeTime += temp ; boolean toFastToMeasure = BOOL_ ; if ( ( end - m_startTime ) >= m_sampleTime ) { computeUpdate ( end ) ; if ( log != null ) { log . statusMessage ( m_statusMessagePrefix + STR_ + m_instanceCount + STR_ + m_avInstsPerSec / m_numSamples + STR_ + ( toFastToMeasure ? STR_ : STR_ ) ) ; } m_sampleCount = NUM_ ; m_cumulativeTime = NUM_ ; m_startTime = System . currentTimeMillis ( ) ; } }
public boolean shouldInclude ( final Path path ) { return includeMatchers . size ( ) == NUM_ || matches ( path , includeMatchers ) ; }
private List < View > addView ( View view , List < View > cache ) { if ( cache == null ) { cache = new LinkedList < View > ( ) ; } cache . add ( view ) ; return cache ; }
public ArrayList < MechSummary > generateUnits ( int num , UnitFilter filter ) { ArrayList < MechSummary > retVal = new ArrayList < > ( ) ; for ( int i = NUM_ ; i < num ; i ++ ) { MechSummary ms = generateUnit ( filter ) ; if ( ms != null ) { retVal . add ( ms ) ; } } return retVal ; }
static public Automaton concatenate ( Automaton a1 , Automaton a2 ) { return concatenate ( Arrays . asList ( a1 , a2 ) ) ; }
public void contentsChanged ( ListDataEvent e ) { Object oldSelection = selectedItemReminder ; Object newSelection = dataModel . getSelectedItem ( ) ; if ( oldSelection == null || ! oldSelection . equals ( newSelection ) ) { selectedItemChanged ( ) ; if ( ! selectingItem ) { fireActionEvent ( ) ; } } }
protected void adjustCanopies ( double [ ] densities ) { if ( m_numClustersRequested < NUM_ ) { assignCanopiesToCanopyCenters ( ) ; m_trainingData = new Instances ( m_canopies , NUM_ ) ; return ; } if ( m_canopies . numInstances ( ) > m_numClustersRequested ) { int [ ] sortedIndexes = Utils . stableSort ( densities ) ; Instances finalCanopies = new Instances ( m_canopies , NUM_ ) ; int count = NUM_ ; for ( int i = sortedIndexes . length - NUM_ ; count < m_numClustersRequested ; i -- ) { finalCanopies . add ( m_canopies . instance ( sortedIndexes [ i ] ) ) ; count ++ ; } m_canopies = finalCanopies ; List < double [ ] [ ] > tempCanopyCenters = new ArrayList < double [ ] [ ] > ( ) ; List < double [ ] > tempT2Dists = new ArrayList < double [ ] > ( ) ; List < double [ ] > tempMissings = new ArrayList < double [ ] > ( ) ; count = NUM_ ; for ( int i = sortedIndexes . length - NUM_ ; count < finalCanopies . numInstances ( ) ; i -- ) { tempCanopyCenters . add ( m_canopyCenters . get ( sortedIndexes [ i ] ) ) ; tempT2Dists . add ( m_canopyT2Density . get ( sortedIndexes [ i ] ) ) ; tempMissings . add ( m_canopyNumMissingForNumerics . get ( sortedIndexes [ i ] ) ) ; count ++ ; } m_canopyCenters = tempCanopyCenters ; m_canopyT2Density = tempT2Dists ; m_canopyNumMissingForNumerics = tempMissings ; } else if ( m_canopies . numInstances ( ) < m_numClustersRequested && m_trainingData != null && m_trainingData . numInstances ( ) > NUM_ ) { Random r = new Random ( getSeed ( ) ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { r . nextInt ( ) ; } HashMap < DecisionTableHashKey , Integer > initC = new HashMap < DecisionTableHashKey , Integer > ( ) ; DecisionTableHashKey hk = null ; for ( int i = NUM_ ; i < m_canopies . numInstances ( ) ; i ++ ) { try { hk = new DecisionTableHashKey ( m_canopies . instance ( i ) , m_canopies . numAttributes ( ) , BOOL_ ) ; initC . put ( hk , null ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } for ( int j = m_trainingData . numInstances ( ) - NUM_ ; j >= NUM_ ; j -- ) { int instIndex = r . nextInt ( j + NUM_ ) ; try { hk = new DecisionTableHashKey ( m_trainingData . instance ( instIndex ) , m_trainingData . numAttributes ( ) , BOOL_ ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } if ( ! initC . containsKey ( hk ) ) { Instance newInstance = m_trainingData . instance ( instIndex ) ; m_canopies . add ( newInstance ) ; double [ ] density = new double [ NUM_ ] ; density [ NUM_ ] = NUM_ ; m_canopyT2Density . add ( density ) ; double [ ] [ ] center = new double [ newInstance . numAttributes ( ) ] [ NUM_ ] ; double [ ] numMissingNumerics = new double [ newInstance . numAttributes ( ) ] ; updateCanopyCenter ( newInstance , center , numMissingNumerics ) ; m_canopyCenters . add ( center ) ; m_canopyNumMissingForNumerics . add ( numMissingNumerics ) ; initC . put ( hk , null ) ; } m_trainingData . swap ( j , instIndex ) ; if ( m_canopies . numInstances ( ) == m_numClustersRequested ) { break ; } } } assignCanopiesToCanopyCenters ( ) ; m_trainingData = new Instances ( m_canopies , NUM_ ) ; }
protected void createFromHValues ( int [ ] hValues , int partitions ) { Arrays . sort ( hValues ) ; this . splits = new int [ partitions ] ; int maxH = x7fffffff ; for ( int i = NUM_ ; i < splits . length ; i ++ ) { int quantile = ( int ) ( ( long ) ( i + NUM_ ) . hValues . length / partitions ) ; this . splits [ i ] = quantile == hValues . length ? maxH : hValues [ quantile ] ; } }
private void readObject ( ObjectInputStream oos ) throws IOException , ClassNotFoundException { iInstant = ( LocalDateTime ) oos . readObject ( ) ; DateTimeFieldType type = ( DateTimeFieldType ) oos . readObject ( ) ; iField = type . getField ( iInstant . getChronology ( ) ) ; }
public void testConstructor_InetAddressIInetAddressI ( ) throws Exception { int sport = startServer ( STR_ ) ; SSLSocket ssl = getSSLSocket ( InetAddress . getLocalHost ( ) , sport , InetAddress . getLocalHost ( ) , NUM_ ) ; assertNotNull ( ssl ) ; assertEquals ( sport , ssl . getPort ( ) ) ; ssl . close ( ) ; try { getSSLSocket ( InetAddress . getLocalHost ( ) , NUM_ , InetAddress . getLocalHost ( ) , NUM_ ) ; fail ( ) ; } catch ( IOException expected ) { } try { getSSLSocket ( InetAddress . getLocalHost ( ) , - NUM_ , InetAddress . getLocalHost ( ) , sport + NUM_ ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } try { getSSLSocket ( InetAddress . getLocalHost ( ) , sport , InetAddress . getLocalHost ( ) , - NUM_ ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } try { getSSLSocket ( InetAddress . getLocalHost ( ) , Integer . MIN_VALUE , InetAddress . getLocalHost ( ) , sport + NUM_ ) ; fail ( ) ; } catch ( IOException expectedOnRI ) { assertTrue ( StandardNames . IS_RI ) ; } catch ( IllegalArgumentException expectedOnAndroid ) { assertFalse ( StandardNames . IS_RI ) ; } try { getSSLSocket ( InetAddress . getLocalHost ( ) , sport , InetAddress . getLocalHost ( ) , Integer . MAX_VALUE ) ; fail ( ) ; } catch ( IllegalArgumentException expectedOnAndroid ) { assertFalse ( StandardNames . IS_RI ) ; } }
private String convertUserInputIntoAFullyQualifiedPath ( final String userInput ) { if ( FileUtils . denotesAbsolutePath ( userInput ) ) { return userInput ; } if ( userInput . startsWith ( HOME_DIRECTORY_SYMBOL ) ) { Assert . notNull ( home , STR_ ) ; if ( userInput . length ( ) > NUM_ ) { return home + userInput . substring ( NUM_ ) ; } } String fullPath = getWorkingDirectoryAsString ( ) + userInput ; return fullPath ; }
static final int resizeStamp ( int n ) { return Integer . numberOfLeadingZeros ( n ) | ( NUM_ << ( RESIZE_STAMP_BITS - NUM_ ) ) ; }
public byte readByte ( ) throws IOException { return dis . readByte ( ) ; }
protected static byte [ ] hkdfExpand ( byte [ ] ikm , byte [ ] salt , byte [ ] info , int length ) throws InvalidKeyException , NoSuchAlgorithmException { HKDFBytesGenerator hkdf = new HKDFBytesGenerator ( new SHA256Digest ( ) ) ; hkdf . init ( new HKDFParameters ( ikm , salt , info ) ) ; byte [ ] okm = new byte [ length ] ; hkdf . generateBytes ( okm , NUM_ , length ) ; return okm ; }
public boolean isEmoteIgnored ( Emoticon emote ) { return ignoredEmotes . contains ( emote . code ) ; }
public boolean isPropertyAllowed ( Name name ) { return propertiesAllowed . contains ( name ) ; }
@ SuppressWarnings ( STR_ ) public void readFile ( String fileName ) throws JDOMException , IOException { if ( checkFile ( fileName ) ) { Element root = rootFromName ( fileName ) ; Element roster ; if ( root == null ) { log . warn ( STR_ ) ; return ; } roster = root . getChild ( STR_ ) ; if ( roster == null ) { log . debug ( STR_ ) ; return ; } Iterator < Element > consistIterator = root . getDescendants ( new ElementFilter ( STR_ ) ) ; try { Element consist ; do { consist = consistIterator . next ( ) ; consistFromXml ( consist ) ; } while ( consistIterator . hasNext ( ) ) ; } catch ( NoSuchElementException nde ) { log . debug ( STR_ ) ; } } else { log . info ( STR_ ) ; } }
public void testConstructorSignBytesZeroNull2 ( ) { byte aBytes [ ] = { } ; int aSign = NUM_ ; byte rBytes [ ] = { NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , aNumber . signum ( ) ) ; }
private int accept ( FileDescriptor ssfd , FileDescriptor newfd , InetSocketAddress [ ] isaa ) throws IOException { return accept0 ( ssfd , newfd , isaa ) ; }
protected void transcode ( File file , Transcoder transcoder ) throws IOException , TranscoderException { transcoder . addTranscodingHint ( XMLAbstractTranscoder . KEY_XML_PARSER_VALIDATING , Boolean . FALSE ) ; SVGDocument doc = cloneDocument ( ) ; TranscoderInput input = new TranscoderInput ( doc ) ; OutputStream out = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; TranscoderOutput output = new TranscoderOutput ( out ) ; transcoder . transcode ( input , output ) ; out . flush ( ) ; out . close ( ) ; }
public static void f ( String tag , String msg , Object ... args ) { if ( sLevel > LEVEL_FATAL ) { return ; } if ( args . length > NUM_ ) { msg = String . format ( msg , args ) ; } Log . wtf ( tag , msg ) ; }
private void reportProgress ( State state , InnerState innerState ) { long now = System . currentTimeMillis ( ) ; if ( innerState . mBytesSoFar - innerState . mBytesNotified > Constants . MIN_PROGRESS_STEP && now - innerState . mTimeLastNotification > Constants . MIN_PROGRESS_TIME ) { mInfo . mCurrentBytes = innerState . mBytesSoFar ; mDB . updateDownloadCurrentBytes ( mInfo ) ; innerState . mBytesNotified = innerState . mBytesSoFar ; innerState . mTimeLastNotification = now ; long totalBytesSoFar = innerState . mBytesThisSession + mService . mBytesSoFar ; if ( Constants . LOGVV ) { Log . v ( Constants . TAG , STR_ + mInfo . mCurrentBytes + STR_ + mInfo . mTotalBytes ) ; Log . v ( Constants . TAG , STR_ + totalBytesSoFar + STR_ + mService . mTotalLength ) ; } mService . notifyUpdateBytes ( totalBytesSoFar ) ; } }
@ Override public Document newDocument ( ) { return new mf . org . apache . xerces . dom . DocumentImpl ( ) ; }
@ HLEFunction ( nid = xD1E0A01E , version = NUM_ , checkInsideInterrupt = BOOL_ ) public int __sceSasSetGrain ( int sasCore , int grain ) { checkSasHandleGood ( sasCore ) ; grainSamples = grain ; return NUM_ ; }
public void handleTblRequestHandlerListButtonAddRequest ( RequestInvocationEvent event ) throws ModelControlException { try { Map values = getValues ( ) ; onBeforeSaveProfile ( values ) ; setPageSessionAttribute ( PROPERTY_ATTRIBUTE , ( HashMap ) values ) ; SCSAML2SOAPBindingRequestHandlerListAddViewBean vb = ( SCSAML2SOAPBindingRequestHandlerListAddViewBean ) getViewBean ( SCSAML2SOAPBindingRequestHandlerListAddViewBean . class ) ; unlockPageTrail ( ) ; passPgSessionMap ( vb ) ; vb . forwardTo ( getRequestContext ( ) ) ; } catch ( AMConsoleException e ) { setInlineAlertMessage ( CCAlert . TYPE_ERROR , STR_ , e . getMessage ( ) ) ; } }
protected static void drawDataPoint ( double x , double y , double xprev , double yprev , int size , int shape , Graphics gx ) { drawDataPoint ( x , y , size , shape , gx ) ; gx . drawLine ( ( int ) x , ( int ) y , ( int ) xprev , ( int ) yprev ) ; }
public void tableSwitch ( final int [ ] keys , final TableSwitchGenerator generator , final boolean useTable ) { for ( int i = NUM_ ; i < keys . length ; ++ i ) { if ( keys [ i ] < keys [ i - NUM_ ] ) { throw new IllegalArgumentException ( STR_ ) ; } } Label def = newLabel ( ) ; Label end = newLabel ( ) ; if ( keys . length > NUM_ ) { int len = keys . length ; int min = keys [ NUM_ ] ; int max = keys [ len - NUM_ ] ; int range = max - min + NUM_ ; if ( useTable ) { Label [ ] labels = new Label [ range ] ; Arrays . fill ( labels , def ) ; for ( int i = NUM_ ; i < len ; ++ i ) { labels [ keys [ i ] - min ] = newLabel ( ) ; } mv . visitTableSwitchInsn ( min , max , def , labels ) ; for ( int i = NUM_ ; i < range ; ++ i ) { Label label = labels [ i ] ; if ( label != def ) { mark ( label ) ; generator . generateCase ( i + min , end ) ; } } } else { Label [ ] labels = new Label [ len ] ; for ( int i = NUM_ ; i < len ; ++ i ) { labels [ i ] = newLabel ( ) ; } mv . visitLookupSwitchInsn ( def , keys , labels ) ; for ( int i = NUM_ ; i < len ; ++ i ) { mark ( labels [ i ] ) ; generator . generateCase ( keys [ i ] , end ) ; } } } mark ( def ) ; generator . generateDefault ( ) ; mark ( end ) ; }
static boolean chunkSet ( InternalDistributedMember recipient , Set set , int CHUNK_SIZE_IN_BYTES , boolean includeValues , ObjectIntProcedure proc ) throws IOException { Iterator it = set . iterator ( ) ; boolean keepGoing = BOOL_ ; boolean sentLastChunk = BOOL_ ; final HeapDataOutputStream mos = new HeapDataOutputStream ( InitialImageOperation . CHUNK_SIZE_IN_BYTES + NUM_ , recipient . getVersionObject ( ) ) ; do { mos . reset ( ) ; int avgItemSize = NUM_ ; int itemCount = NUM_ ; while ( ( mos . size ( ) + avgItemSize ) < InitialImageOperation . CHUNK_SIZE_IN_BYTES && it . hasNext ( ) ) { Object key = it . next ( ) ; DataSerializer . writeObject ( key , mos ) ; itemCount ++ ; avgItemSize = mos . size ( ) / itemCount ; } DataSerializer . writeObject ( ( Object ) null , mos ) ; int lastMsg = it . hasNext ( ) ? NUM_ : NUM_ ; keepGoing = proc . executeWith ( mos , lastMsg ) ; sentLastChunk = lastMsg == NUM_ && keepGoing ; } while ( keepGoing && it . hasNext ( ) ) ; return sentLastChunk ; }
private int [ ] parseMetaDataInformation ( ) throws UserError { int [ ] selectedColumns = new int [ metaData . size ( ) ] ; Set < String > usedColumnNames = new HashSet < > ( ) ; int columnIndex = NUM_ ; int usedColumnIndex = NUM_ ; for ( ColumnMetaData column : metaData ) { if ( ! column . isRemoved ( ) ) { selectedColumns [ usedColumnIndex ] = columnIndex ; usedColumnIndex ++ ; String columnName = column . getName ( ) ; if ( ! usedColumnNames . contains ( columnName ) ) { usedColumnNames . add ( columnName ) ; } else { throw new UserError ( null , STR_ , columnName ) ; } } columnIndex ++ ; } int [ ] attributeColumns = Arrays . copyOf ( selectedColumns , usedColumnIndex ) ; return attributeColumns ; }
static Field findField ( Object instance , String name ) throws NoSuchFieldException { for ( Class < ? > clazz = instance . getClass ( ) ; clazz != null ; clazz = clazz . getSuperclass ( ) ) { try { Field field = clazz . getDeclaredField ( name ) ; if ( ! field . isAccessible ( ) ) { field . setAccessible ( BOOL_ ) ; } return field ; } catch ( NoSuchFieldException e ) { } } throw new NoSuchFieldException ( STR_ + name + STR_ + instance . getClass ( ) ) ; }
SSLSession toSession ( byte [ ] data , String host , int port ) { ByteArrayInputStream bais = new ByteArrayInputStream ( data ) ; DataInputStream dais = new DataInputStream ( bais ) ; try { int type = dais . readInt ( ) ; if ( type != OPEN_SSL ) { log ( new AssertionError ( STR_ + type ) ) ; return null ; } int length = dais . readInt ( ) ; byte [ ] sessionData = new byte [ length ] ; dais . readFully ( sessionData ) ; int count = dais . readInt ( ) ; X509Certificate [ ] certs = new X509Certificate [ count ] ; for ( int i = NUM_ ; i < count ; i ++ ) { length = dais . readInt ( ) ; byte [ ] certData = new byte [ length ] ; dais . readFully ( certData ) ; certs [ i ] = OpenSSLX509Certificate . fromX509Der ( certData ) ; } return new OpenSSLSessionImpl ( sessionData , host , port , certs , this ) ; } catch ( IOException e ) { log ( e ) ; return null ; } }
private void addDumpFile ( ) { addDumpFile ( dumpFile ) ; }
private static boolean dateByOrdinal ( DateTimeFormatterBuilder bld , Collection < DateTimeFieldType > fields , boolean extended , boolean strictISO ) { boolean reducedPrec = BOOL_ ; if ( fields . remove ( DateTimeFieldType . year ( ) ) ) { bld . append ( yearElement ( ) ) ; if ( fields . remove ( DateTimeFieldType . dayOfYear ( ) ) ) { appendSeparator ( bld , extended ) ; bld . appendDayOfYear ( NUM_ ) ; } else { reducedPrec = BOOL_ ; } } else if ( fields . remove ( DateTimeFieldType . dayOfYear ( ) ) ) { bld . appendLiteral ( STR_ ) ; bld . appendDayOfYear ( NUM_ ) ; } return reducedPrec ; }
private void writeAttr ( String name , String val ) throws IOException { writeAttr ( name , val , BOOL_ ) ; }
public boolean isPageInRange ( int pageNumber ) { for ( int ind = NUM_ ; ind < sequenceStarts . size ( ) ; ind ++ ) { if ( sequenceStarts . get ( ind ) <= pageNumber && pageNumber <= sequenceEnds . get ( ind ) ) return BOOL_ ; } return BOOL_ ; }
public void dispose ( ) { logDebug ( STR_ ) ; mSetupDone = BOOL_ ; if ( mServiceConn != null ) { logDebug ( STR_ ) ; if ( mContext != null ) mContext . unbindService ( mServiceConn ) ; } mDisposed = BOOL_ ; mContext = null ; mServiceConn = null ; mService = null ; mPurchaseListener = null ; }
@ SuppressWarnings ( STR_ ) public static < T extends DimensionalItemObject > List < T > asTypedList ( Collection < DimensionalItemObject > collection ) { List < T > list = new ArrayList < > ( ) ; if ( collection != null ) { for ( DimensionalItemObject object : collection ) { list . add ( ( T ) object ) ; } } return list ; }
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; }
private float clampMag ( float value , float absMin , float absMax ) { final float absValue = Math . abs ( value ) ; if ( absValue < absMin ) return NUM_ ; if ( absValue > absMax ) return value > NUM_ ? absMax : - absMax ; return value ; }
public PutIndexTemplateRequest aliases ( XContentBuilder source ) { return aliases ( source . bytes ( ) ) ; }
void addNewTable ( String name , int tdefPageNumber , Short type , String linkedDbName , String linkedTableName ) throws IOException { addTable ( name , Integer . valueOf ( tdefPageNumber ) , type , linkedDbName , linkedTableName ) ; addToSystemCatalog ( name , tdefPageNumber , type , linkedDbName , linkedTableName , _tableParentId ) ; addToAccessControlEntries ( tdefPageNumber , _tableParentId , _newTableSIDs ) ; }
public static String hashpw ( byte [ ] password0 , final String salt ) { BCrypt B ; String real_salt ; byte passwordb [ ] = null , saltb [ ] , hashed [ ] ; char minor = ( char ) NUM_ ; int rounds , off = NUM_ ; final StringBuffer rs = new StringBuffer ( ) ; if ( salt . charAt ( NUM_ ) != STR_ || salt . charAt ( NUM_ ) != STR_ ) { throw new IllegalArgumentException ( STR_ ) ; } if ( salt . charAt ( NUM_ ) == STR_ ) { off = NUM_ ; } else { minor = salt . charAt ( NUM_ ) ; if ( minor != STR_ || salt . charAt ( NUM_ ) != STR_ ) { throw new IllegalArgumentException ( STR_ ) ; } off = NUM_ ; } if ( salt . charAt ( off + NUM_ ) > STR_ ) { throw new IllegalArgumentException ( STR_ ) ; } rounds = Integer . parseInt ( salt . substring ( off , off + NUM_ ) ) ; real_salt = salt . substring ( off + NUM_ , off + NUM_ ) ; try { if ( minor >= ( byte ) STR_ ) { passwordb = Arrays . copyOf ( password0 , password0 . length + NUM_ ) ; passwordb [ passwordb . length - NUM_ ] = ( byte ) NUM_ ; } else { passwordb = Arrays . copyOf ( password0 , password0 . length ) ; } saltb = decode_base64 ( real_salt , BCRYPT_SALT_LEN ) ; B = new BCrypt ( ) ; hashed = B . crypt_raw ( passwordb , saltb , rounds , bf_crypt_ciphertext . clone ( ) ) ; } finally { if ( password0 != null ) { Arrays . fill ( password0 , ( byte ) STR_ ) ; password0 = null ; } if ( passwordb != null ) { Arrays . fill ( passwordb , ( byte ) STR_ ) ; passwordb = null ; } } rs . append ( STR_ ) ; if ( minor >= STR_ ) { rs . append ( minor ) ; } rs . append ( STR_ ) ; if ( rounds < NUM_ ) { rs . append ( STR_ ) ; } if ( rounds > NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } rs . append ( Integer . toString ( rounds ) ) ; rs . append ( STR_ ) ; rs . append ( encode_base64 ( saltb , saltb . length ) ) ; rs . append ( encode_base64 ( hashed , bf_crypt_ciphertext . length . NUM_ - NUM_ ) ) ; return rs . toString ( ) ; }
public void removeListener ( @ NotNull ConfigurationListener listener ) { if ( myListeners != null ) { myListeners . remove ( listener ) ; if ( myListeners . isEmpty ( ) ) { myListeners = null ; } } }
void reclaimScrapViews ( List < View > views ) { if ( mViewTypeCount == NUM_ ) { views . addAll ( mCurrentScrap ) ; } else { final int viewTypeCount = mViewTypeCount ; final ArrayList < View > [ ] scrapViews = mScrapViews ; for ( int i = NUM_ ; i < viewTypeCount ; ++ i ) { final ArrayList < View > scrapPile = scrapViews [ i ] ; views . addAll ( scrapPile ) ; } } }
public void doWindowOpen ( ) { doConnect ( ) ; }
public boolean schedule ( Runnable task , ClassLoader loader ) { boolean isPriority = BOOL_ ; boolean isQueue = BOOL_ ; boolean isWake = BOOL_ ; return scheduleImpl ( task , loader , MAX_EXPIRE , isPriority , isQueue , isWake ) ; }
public static int hash2 ( int hash , Object x , Object y ) { return x20000000 | ( hash + NUM_ . System . identityHashCode ( x ) + NUM_ . System . identityHashCode ( y ) ) ; }
public static double [ ] parseVectorString ( String vectorString ) { String [ ] parsedString = vectorString . split ( STR_ ) ; double [ ] vector = new double [ parsedString . length ] ; for ( int j = NUM_ ; j < parsedString . length ; j ++ ) { double val = Utils . doubleParsable ( parsedString [ j ] ) ; vector [ j ] = Double . isNaN ( val ) ? NUM_ : val ; } return vector ; }
public String globalInfo ( ) { return STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; }
public static < T > Stream < T > concat ( Stream < ? extends T > a , Stream < ? extends T > b ) { Objects . requireNonNull ( a ) ; Objects . requireNonNull ( b ) ; @ SuppressWarnings ( STR_ ) Spliterator < T > split = new Streams . ConcatSpliterator . OfRef < > ( ( Spliterator < T > ) a . spliterator ( ) , ( Spliterator < T > ) b . spliterator ( ) ) ; Stream < T > stream = StreamSupport . stream ( split , a . isParallel ( ) || b . isParallel ( ) ) ; return stream . onClose ( Streams . composedClose ( a , b ) ) ; }
@ Ignore @ Test public void test_DR_PGS_4NODES_2NODESDOWN_Validate_Receiver ( ) throws Exception { Integer lnPort = ( Integer ) vm0 . invoke ( null ) ; Integer nyPort = ( Integer ) vm1 . invoke ( null ) ; createCacheInVMs ( nyPort , vm2 , vm3 ) ; createReceiverInVMs ( vm2 , vm3 ) ; createCacheInVMs ( lnPort , vm4 , vm5 , vm6 , vm7 ) ; vm4 . invoke ( null ) ; vm5 . invoke ( null ) ; vm6 . invoke ( null ) ; vm7 . invoke ( null ) ; vm4 . invoke ( null ) ; vm5 . invoke ( null ) ; vm6 . invoke ( null ) ; vm7 . invoke ( null ) ; startSenderInVMs ( STR_ , vm4 , vm5 , vm6 , vm7 ) ; vm2 . invoke ( null ) ; vm3 . invoke ( null ) ; vm4 . invoke ( null ) ; vm5 . invoke ( null ) ; vm6 . invoke ( null ) ; vm7 . invoke ( null ) ; Thread . sleep ( NUM_ ) ; { AsyncInvocation inv1 = vm7 . invokeAsync ( null ) ; Thread . sleep ( NUM_ ) ; AsyncInvocation inv2 = vm4 . invokeAsync ( null ) ; Thread . sleep ( NUM_ ) ; AsyncInvocation inv3 = vm6 . invokeAsync ( null ) ; Thread . sleep ( NUM_ ) ; AsyncInvocation inv4 = vm5 . invokeAsync ( null ) ; try { inv1 . join ( ) ; inv2 . join ( ) ; inv3 . join ( ) ; inv4 . join ( ) ; } catch ( Exception e ) { Assert . fail ( STR_ , e ) ; } } vm6 . invoke ( null ) ; vm7 . invoke ( null ) ; vm2 . invoke ( null ) ; }
public void findAndInit ( Iterator it ) { while ( it . hasNext ( ) ) { findAndInit ( it . next ( ) ) ; } }
public static DataSourcePropertiesInterface decodeXML ( Document document , String elementName ) { if ( ( document == null ) || ( elementName == null ) ) { return null ; } Map < String , String > map = new LinkedHashMap < String , String > ( ) ; NodeList nodeList = document . getElementsByTagName ( elementName ) ; if ( nodeList . getLength ( ) > NUM_ ) { Node node = nodeList . item ( NUM_ ) ; Node child = node . getFirstChild ( ) ; while ( child != null ) { if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { map . put ( child . getNodeName ( ) , child . getTextContent ( ) ) ; } child = child . getNextSibling ( ) ; } return DataSourceConnectorFactory . getDataSourceProperties ( map ) ; } else { return DataSourceConnectorFactory . getNoDataSource ( ) ; } }
@ Override public char next ( ) { ++ docPos ; if ( docPos < segmentEnd || segmentEnd >= doc . getLength ( ) ) { return text . next ( ) ; } try { doc . getText ( segmentEnd , doc . getLength ( ) - segmentEnd , text ) ; } catch ( BadLocationException e ) { throw new RuntimeException ( e ) ; } segmentEnd += text . count ; return text . current ( ) ; }
private void adjustRowHeights ( JTable table ) { for ( int row = NUM_ ; row < table . getRowCount ( ) ; row ++ ) { int rowHeight = table . getRowHeight ( ) ; for ( int column = NUM_ ; column < table . getColumnCount ( ) ; column ++ ) { Component comp = table . prepareRenderer ( table . getCellRenderer ( row , column ) , row , column ) ; rowHeight = Math . max ( rowHeight , comp . getPreferredSize ( ) . height ) ; } table . setRowHeight ( row , rowHeight ) ; } }
public List < URI > volumeURIs ( List < URI > uris , boolean delete , boolean remediate , ValCk ... checks ) { List < URI > remediatedURIs = new ArrayList < URI > ( ) ; List < Volume > volumes = dbClient . queryObject ( Volume . class , uris ) ; List < Volume > remediatedVolumes = volumes ( volumes , delete , remediate , checks ) ; for ( Volume volume : remediatedVolumes ) { remediatedURIs . add ( volume . getId ( ) ) ; } return remediatedURIs ; }
private FormatString [ ] parse ( String s ) { ArrayList < FormatString > al = new ArrayList < > ( ) ; Matcher m = fsPattern . matcher ( s ) ; for ( int i = NUM_ , len = s . length ( ) ; i < len ; ) { if ( m . find ( i ) ) { if ( m . start ( ) != i ) { checkText ( s , i , m . start ( ) ) ; al . add ( new FixedString ( s . substring ( i , m . start ( ) ) ) ) ; } al . add ( new FormatSpecifier ( m ) ) ; i = m . end ( ) ; } else { checkText ( s , i , len ) ; al . add ( new FixedString ( s . substring ( i ) ) ) ; break ; } } return al . toArray ( new FormatString [ al . size ( ) ] ) ; }
public int size ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { return count ; } finally { lock . unlock ( ) ; } }
private void updateIndexColumnButtons ( ) { indexRemoveButton . setEnabled ( BOOL_ ) ; indexUpButton . setEnabled ( BOOL_ ) ; indexDownButton . setEnabled ( BOOL_ ) ; int index = selectedColumns . getSelectionIndex ( ) ; if ( index >= NUM_ ) { indexRemoveButton . setEnabled ( BOOL_ ) ; if ( index > NUM_ ) { indexUpButton . setEnabled ( BOOL_ ) ; } else if ( index < selectedColumns . getItemCount ( ) - NUM_ ) { indexDownButton . setEnabled ( BOOL_ ) ; } } }
public String urlForPOISearch ( String tag , BoundingBox bb , int limit , int timeout ) { StringBuilder s = new StringBuilder ( ) ; s . append ( mService + STR_ ) ; String sBB = STR_ + bb . getLatSouth ( ) + STR_ + bb . getLonWest ( ) + STR_ + bb . getLatNorth ( ) + STR_ + bb . getLonEast ( ) + STR_ ; String data = STR_ + timeout + STR_ + STR_ + tag + STR_ + sBB + STR_ + STR_ + tag + STR_ + sBB + STR_ + STR_ + tag + STR_ + sBB + STR_ + STR_ + limit + STR_ ; Log . d ( BonusPackHelper . LOG_TAG , STR_ + data ) ; s . append ( URLEncoder . encode ( data ) ) ; return s . toString ( ) ; }
public void waitForDecodingToFinish ( ) { while ( isDecoding ) { try { Thread . sleep ( NUM_ ) ; } catch ( final InterruptedException e ) { LogWriter . writeLog ( STR_ + e . getMessage ( ) ) ; isDecoding = BOOL_ ; } } }
private static String wikiToPlainText ( String content ) { content = content . replaceAll ( STR_ , STR_ ) ; content = content . replaceAll ( STR_ , STR_ ) ; content = content . replaceAll ( STR_ , STR_ ) ; content = content . replaceAll ( STR_ , STR_ ) ; content = content . replaceAll ( STR_ , STR_ ) ; content = content . replaceAll ( STR_ , STR_ ) ; content = content . replaceAll ( STR_ , STR_ ) ; content = content . replaceAll ( STR_ , STR_ ) ; content = content . replaceAll ( STR_ , STR_ ) ; content = content . replaceAll ( STR_ , STR_ ) ; content = content . trim ( ) ; final int size = content . length ( ) ; int endOfFirstParagraph = content . indexOf ( STR_ , NUM_ ) ; if ( endOfFirstParagraph < NUM_ ) { endOfFirstParagraph = size ; } content = content . substring ( NUM_ , Math . min ( endOfFirstParagraph , NUM_ ) ) ; return content ; }
public final byte [ ] update ( byte [ ] input ) { if ( mode != ENCRYPT_MODE && mode != DECRYPT_MODE ) { throw new IllegalStateException ( ) ; } if ( input == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( input . length == NUM_ ) { return null ; } return spiImpl . engineUpdate ( input , NUM_ , input . length ) ; }
public static void e ( String tag , String msg , Object ... args ) { if ( sLevel > LEVEL_ERROR ) { return ; } if ( args . length > NUM_ ) { msg = String . format ( msg , args ) ; } Log . e ( tag , msg ) ; }
private static int createPackedParams ( SunGraphics2D sg2d , GlyphList gl ) { return ( ( ( gl . usePositions ( ) ? NUM_ : NUM_ ) << OFFSET_POSITIONS ) | ( ( gl . isSubPixPos ( ) ? NUM_ : NUM_ ) << OFFSET_SUBPIXPOS ) | ( ( gl . isRGBOrder ( ) ? NUM_ : NUM_ ) << OFFSET_RGBORDER ) | ( ( sg2d . lcdTextContrast & xff ) << OFFSET_CONTRAST ) ) ; }
public static int update ( String sql , Object [ ] args ) { Connection c = null ; PreparedStatement p = null ; try { c = getConnection ( ) ; if ( c == null ) return - NUM_ ; p = c . prepareStatement ( sql ) ; int order = NUM_ ; if ( args != null ) { for ( int i = NUM_ ; i < args . length ; i ++ ) { Object o = args [ i ] ; setParameter ( p , order ++ , o ) ; } } return p . executeUpdate ( ) ; } catch ( Exception e ) { if ( log . isErrorEnabled ( ) ) log . error ( sql + toString ( args ) , e ) ; } finally { close ( p , c ) ; } return NUM_ ; }
public boolean isLockSubject ( ) { return BOOL_ ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; nameNode = elementList . item ( NUM_ ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; { boolean success = BOOL_ ; try { child . deleteData ( NUM_ , NUM_ ) ; } catch ( DOMException ex ) { success = ( ex . code == DOMException . INDEX_SIZE_ERR ) ; } assertTrue ( STR_ , success ) ; } }
@ Override public int hashCode ( ) { int code = NUM_ ; if ( fPublicId != null ) { code += fPublicId . hashCode ( ) ; } if ( fLiteralSystemId != null ) { code += fLiteralSystemId . hashCode ( ) ; } if ( fBaseSystemId != null ) { code += fBaseSystemId . hashCode ( ) ; } if ( fExpandedSystemId != null ) { code += fExpandedSystemId . hashCode ( ) ; } if ( fNamespace != null ) { code += fNamespace . hashCode ( ) ; } return code ; }
public QuickActionView addAction ( Action action ) { checkShown ( ) ; mActions . add ( action ) ; return this ; }
public static < V > boolean addDistinctEntry ( List < V > sourceList , V entry ) { return ( sourceList != null && ! sourceList . contains ( entry ) ) ? sourceList . add ( entry ) : BOOL_ ; }
protected boolean display ( File helpFile ) throws HelpException { if ( helpFile . exists ( ) ) { loadAndWrite ( helpFile ) ; return BOOL_ ; } else { File notFound = new File ( helpDir , NOT_FOUND ) ; if ( notFound . exists ( ) ) loadAndWrite ( notFound ) ; else throw new HelpException ( STR_ ) ; return BOOL_ ; } }
public static void storeLocation ( Context context , LatLng location ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putLong ( PREFERENCES_LAT , Double . doubleToRawLongBits ( location . latitude ) ) ; editor . putLong ( PREFERENCES_LNG , Double . doubleToRawLongBits ( location . longitude ) ) ; editor . apply ( ) ; }
public Point2D either ( ) { return best1 ; }
@ Override public boolean equals ( Object object ) { if ( this == object ) { return BOOL_ ; } if ( object instanceof List ) { List < ? > list = ( List < ? > ) object ; if ( list . size ( ) != size ( ) ) { return BOOL_ ; } Iterator < ? > it1 = iterator ( ) , it2 = list . iterator ( ) ; while ( it1 . hasNext ( ) ) { Object e1 = it1 . next ( ) , e2 = it2 . next ( ) ; if ( ! ( e1 == null ? e2 == null : e1 . equals ( e2 ) ) ) { return BOOL_ ; } } return BOOL_ ; } return BOOL_ ; }
public static String rowToString ( JSONArray ja ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = NUM_ ; i < ja . length ( ) ; i += NUM_ ) { if ( i > NUM_ ) { sb . append ( STR_ ) ; } Object object = ja . opt ( i ) ; if ( object != null ) { String string = object . toString ( ) ; if ( string . length ( ) > NUM_ && ( string . indexOf ( STR_ ) >= NUM_ || string . indexOf ( STR_ ) >= NUM_ || string . indexOf ( STR_ ) >= NUM_ || string . indexOf ( NUM_ ) >= NUM_ || string . charAt ( NUM_ ) == STR_ ) ) { sb . append ( STR_ ) ; int length = string . length ( ) ; for ( int j = NUM_ ; j < length ; j += NUM_ ) { char c = string . charAt ( j ) ; if ( c >= STR_ && c != STR_ ) { sb . append ( c ) ; } } sb . append ( STR_ ) ; } else { sb . append ( string ) ; } } } sb . append ( STR_ ) ; return sb . toString ( ) ; }
private static void removeTable ( Connection conn , String name ) throws SQLException { name = name . replace ( STR_ , STR_ ) ; Statement stat = conn . createStatement ( ) ; stat . execute ( STR_ + name ) ; DBUtil . commitEL ( conn ) ; }
public boolean containsCategory ( String category ) { return ! hiddenBugCategorySet . contains ( category ) ; }
public static boolean isVolumeFullCopySource ( Volume volume , DbClient dbClient ) { boolean isFullCopySource = BOOL_ ; StringSet fullCopyIds = volume . getFullCopies ( ) ; if ( ( fullCopyIds != null ) && ( ! fullCopyIds . isEmpty ( ) ) ) { Iterator < String > fullCopyIdsIter = fullCopyIds . iterator ( ) ; while ( fullCopyIdsIter . hasNext ( ) ) { URI fullCopyURI = URI . create ( fullCopyIdsIter . next ( ) ) ; Volume fullCopyVolume = dbClient . queryObject ( Volume . class , fullCopyURI ) ; if ( ( fullCopyVolume != null ) && ( ! fullCopyVolume . getInactive ( ) ) ) { isFullCopySource = BOOL_ ; } } } return isFullCopySource ; }
@ Override public void assertEquals ( String message , Object expectedObj , Object actualObj ) { LinearRegressionModel expected = ( LinearRegressionModel ) expectedObj ; LinearRegressionModel actual = ( LinearRegressionModel ) actualObj ; message = message + STR_ + actual . getSource ( ) + STR_ ; Assert . assertArrayEquals ( message + STR_ , expected . getCoefficients ( ) , actual . getCoefficients ( ) , NUM_ ) ; Assert . assertArrayEquals ( message + STR_ , expected . getProbabilities ( ) , actual . getProbabilities ( ) , NUM_ ) ; Assert . assertArrayEquals ( message + STR_ , expected . getSelectedAttributeNames ( ) , actual . getSelectedAttributeNames ( ) ) ; Assert . assertArrayEquals ( message + STR_ , expected . getSelectedAttributes ( ) , actual . getSelectedAttributes ( ) ) ; Assert . assertArrayEquals ( message + STR_ , expected . getStandardErrors ( ) , actual . getStandardErrors ( ) , NUM_ ) ; Assert . assertArrayEquals ( message + STR_ , expected . getStandardizedCoefficients ( ) , actual . getStandardizedCoefficients ( ) , NUM_ ) ; Assert . assertArrayEquals ( message + STR_ , expected . getTolerances ( ) , actual . getTolerances ( ) , NUM_ ) ; Assert . assertArrayEquals ( message + STR_ , expected . getTStats ( ) , actual . getTStats ( ) , NUM_ ) ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; String childData ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; nameNode = elementList . item ( NUM_ ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; child . replaceData ( NUM_ , NUM_ , STR_ ) ; childData = child . getData ( ) ; assertEquals ( STR_ , STR_ , childData ) ; }
public static Map < String , Object > entityMaintPermCheck ( DispatchContext dctx , Map < String , ? extends Object > context ) { GenericValue userLogin = ( GenericValue ) context . get ( STR_ ) ; Locale locale = ( Locale ) context . get ( STR_ ) ; Security security = dctx . getSecurity ( ) ; Map < String , Object > resultMap = null ; if ( security . hasPermission ( STR_ , userLogin ) ) { resultMap = ServiceUtil . returnSuccess ( ) ; resultMap . put ( STR_ , BOOL_ ) ; } else { resultMap = ServiceUtil . returnFailure ( UtilProperties . getMessage ( resource , STR_ , locale ) ) ; resultMap . put ( STR_ , BOOL_ ) ; } return resultMap ; }
public void testQuorumSucceed ( ) { quorum . succeed ( ) ; quorum . fail ( ) ; assertEquals ( callbackResult . get ( ) , NUM_ ) ; quorum . fail ( ) ; quorum . succeed ( ) ; assertEquals ( callbackResult . get ( ) , NUM_ ) ; }
public void requestAfterExplanation ( @ NonNull String [ ] permissions ) { ArrayList < String > permissionsToRequest = new ArrayList < > ( ) ; for ( String permissionName : permissions ) { if ( isPermissionDeclined ( permissionName ) ) { permissionsToRequest . add ( permissionName ) ; } else { permissionCallback . onPermissionPreGranted ( permissionName ) ; } } if ( permissionsToRequest . isEmpty ( ) ) return ; permissions = permissionsToRequest . toArray ( new String [ permissionsToRequest . size ( ) ] ) ; context . requestPermissions ( permissions , REQUEST_PERMISSIONS ) ; }
static void pauseThread ( long duration ) { try { Thread . sleep ( duration ) ; } catch ( Exception e ) { s_logger . warn ( STR_ , e ) ; } }
final public void println ( String v ) { try { _out . println ( v ) ; } catch ( IOException e ) { log . log ( Level . FINE , e . toString ( ) , e ) ; } }
public int read ( char cbuf [ ] , int offset , int length ) throws IOException { return sd . read ( cbuf , offset , length ) ; }
public int read ( ) throws IOException { int val ; if ( ( val = is . read ( ) ) < NUM_ ) { return - NUM_ ; } switch ( val & xf0 ) { case xc0 : case xd0 : val = ( ( val & x1f ) << NUM_ ) | ( is . read ( ) & x3f ) ; break ; case xe0 : val = ( ( val & x0f ) << NUM_ ) | ( ( is . read ( ) & x3f ) << NUM_ ) | ( is . read ( ) & x3f ) ; break ; case xf0 : throw new UnsupportedEncodingException ( ) ; default : break ; } return val ; }
private static boolean CallNonvirtualBooleanMethodV ( JNIEnvironment env , int objJREF , int classJREF , int methodID , Address argAddress ) throws Exception { if ( traceJNI ) VM . sysWrite ( STR_ ) ; RuntimeEntrypoints . checkJNICountDownToGC ( ) ; try { Object obj = env . getJNIRef ( objJREF ) ; Object returnObj = JNIHelpers . invokeWithVarArg ( obj , methodID , argAddress , TypeReference . Boolean , BOOL_ ) ; return Reflection . unwrapBoolean ( returnObj ) ; } catch ( Throwable unexpected ) { if ( traceJNI ) unexpected . printStackTrace ( System . err ) ; env . recordException ( unexpected ) ; return BOOL_ ; } }
private boolean rContainsRMInstruction ( ProgramBlock pb , String varName ) { if ( pb instanceof WhileProgramBlock ) { WhileProgramBlock tmp = ( WhileProgramBlock ) pb ; for ( ProgramBlock c : tmp . getChildBlocks ( ) ) if ( rContainsRMInstruction ( c , varName ) ) return BOOL_ ; } else if ( pb instanceof IfProgramBlock ) { IfProgramBlock tmp = ( IfProgramBlock ) pb ; for ( ProgramBlock c : tmp . getChildBlocksIfBody ( ) ) if ( rContainsRMInstruction ( c , varName ) ) return BOOL_ ; for ( ProgramBlock c : tmp . getChildBlocksElseBody ( ) ) if ( rContainsRMInstruction ( c , varName ) ) return BOOL_ ; } else if ( pb instanceof ForProgramBlock ) { ForProgramBlock tmp = ( ForProgramBlock ) pb ; for ( ProgramBlock c : tmp . getChildBlocks ( ) ) if ( rContainsRMInstruction ( c , varName ) ) return BOOL_ ; } else if ( pb instanceof FunctionProgramBlock ) { } else { for ( Instruction inst : pb . getInstructions ( ) ) { String instStr = inst . toString ( ) ; if ( instStr . contains ( STR_ + Lop . OPERAND_DELIMITOR + varName ) || instStr . contains ( STR_ + Lop . OPERAND_DELIMITOR + varName ) ) { return BOOL_ ; } } } return BOOL_ ; }
public ProjectImporter ( final File rootFolder ) { assertNotNull ( STR_ , rootFolder ) ; assertTrue ( STR_ + rootFolder , rootFolder . exists ( ) ) ; assertTrue ( STR_ + rootFolder , rootFolder . isDirectory ( ) ) ; assertTrue ( STR_ + rootFolder , rootFolder . canRead ( ) ) ; assertTrue ( STR_ + rootFolder , null != rootFolder . listFiles ( ) ) ; this . rootFolder = rootFolder ; }
public void testDoubles ( ) throws Exception { double [ ] values = new double [ ] { Double . NEGATIVE_INFINITY , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , + NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , Double . POSITIVE_INFINITY , Double . NaN } ; long [ ] encoded = new long [ values . length ] ; for ( int i = NUM_ ; i < values . length ; i ++ ) { encoded [ i ] = NumericUtils . doubleToSortableLong ( values [ i ] ) ; assertTrue ( STR_ , Double . compare ( values [ i ] , NumericUtils . sortableLongToDouble ( encoded [ i ] ) ) == NUM_ ) ; } for ( int i = NUM_ ; i < encoded . length ; i ++ ) { assertTrue ( STR_ , encoded [ i - NUM_ ] < encoded [ i ] ) ; } }
public static boolean isRegistered ( Class < ? > clazz ) { return regModules . containsKey ( clazz . getName ( ) ) ; }
private static Pair < String , String > offsetASR ( final long offset , final ITranslationEnvironment environment , final List < ReilInstruction > instructions , final String registerNodeValue1 , final String registerNodeValue2 , final String immediateNodeValue ) { final String address = environment . getNextVariableString ( ) ; final String index = environment . getNextVariableString ( ) ; final String tmpVar = environment . getNextVariableString ( ) ; long baseOffset = offset ; if ( immediateNodeValue . equals ( STR_ ) ) { final String isZeroCondition = environment . getNextVariableString ( ) ; final String tmpVar1 = environment . getNextVariableString ( ) ; instructions . add ( ReilHelpers . createBsh ( baseOffset ++ , dw , registerNodeValue2 , wd , String . valueOf ( - NUM_ ) , dw , tmpVar1 ) ) ; instructions . add ( ReilHelpers . createBisz ( baseOffset ++ , dw , tmpVar1 , bt , isZeroCondition ) ) ; instructions . add ( ReilHelpers . createSub ( baseOffset ++ , dw , String . valueOf ( x0L ) , bt , isZeroCondition , dw , index ) ) ; } else { final String tmpVar1 = environment . getNextVariableString ( ) ; final String tmpVar2 = environment . getNextVariableString ( ) ; final String tmpVar3 = environment . getNextVariableString ( ) ; final String tmpVar4 = environment . getNextVariableString ( ) ; instructions . add ( ReilHelpers . createAdd ( baseOffset ++ , dw , registerNodeValue2 , dw , String . valueOf ( x80000000L ) , dw , tmpVar1 ) ) ; instructions . add ( ReilHelpers . createBsh ( baseOffset ++ , dw , tmpVar1 , dw , STR_ + immediateNodeValue , dw , tmpVar2 ) ) ; instructions . add ( ReilHelpers . createBsh ( baseOffset ++ , dw , String . valueOf ( x80000000L ) , dw , STR_ + immediateNodeValue , dw , tmpVar3 ) ) ; instructions . add ( ReilHelpers . createSub ( baseOffset ++ , dw , tmpVar2 , dw , tmpVar3 , qw , tmpVar4 ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , qw , tmpVar4 , dw , dWordBitMask , dw , index ) ) ; } instructions . add ( ReilHelpers . createAdd ( baseOffset ++ , dw , registerNodeValue1 , dw , index , dw , tmpVar ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , dw , tmpVar , dw , dWordBitMask , dw , address ) ) ; return new Pair < String , String > ( address , registerNodeValue1 ) ; }
public Class < ? > loadClass ( String name ) throws ClassNotFoundException { return Class . forName ( name ) ; }
public void waitForOperations ( ) { operator . waitForOperations ( ) ; }
private static int byteCompaction ( int mode , int [ ] codewords , int codeIndex , StringBuilder result ) { if ( mode == BYTE_COMPACTION_MODE_LATCH ) { int count = NUM_ ; long value = NUM_ ; char [ ] decodedData = new char [ NUM_ ] ; int [ ] byteCompactedCodewords = new int [ NUM_ ] ; boolean end = BOOL_ ; int nextCode = codewords [ codeIndex ++ ] ; while ( ( codeIndex < codewords [ NUM_ ] ) && ! end ) { byteCompactedCodewords [ count ++ ] = nextCode ; value = NUM_ . value + nextCode ; nextCode = codewords [ codeIndex ++ ] ; if ( nextCode == TEXT_COMPACTION_MODE_LATCH || nextCode == BYTE_COMPACTION_MODE_LATCH || nextCode == NUMERIC_COMPACTION_MODE_LATCH || nextCode == BYTE_COMPACTION_MODE_LATCH_6 || nextCode == BEGIN_MACRO_PDF417_CONTROL_BLOCK || nextCode == BEGIN_MACRO_PDF417_OPTIONAL_FIELD || nextCode == MACRO_PDF417_TERMINATOR ) { codeIndex -- ; end = BOOL_ ; } else { if ( ( count % NUM_ == NUM_ ) && ( count > NUM_ ) ) { for ( int j = NUM_ ; j < NUM_ ; ++ j ) { decodedData [ NUM_ - j ] = ( char ) ( value % NUM_ ) ; value >>= NUM_ ; } result . append ( decodedData ) ; count = NUM_ ; } } } if ( codeIndex == codewords [ NUM_ ] && nextCode < TEXT_COMPACTION_MODE_LATCH ) { byteCompactedCodewords [ count ++ ] = nextCode ; } for ( int i = NUM_ ; i < count ; i ++ ) { result . append ( ( char ) byteCompactedCodewords [ i ] ) ; } } else if ( mode == BYTE_COMPACTION_MODE_LATCH_6 ) { int count = NUM_ ; long value = NUM_ ; boolean end = BOOL_ ; while ( codeIndex < codewords [ NUM_ ] && ! end ) { int code = codewords [ codeIndex ++ ] ; if ( code < TEXT_COMPACTION_MODE_LATCH ) { count ++ ; value = NUM_ . value + code ; } else { if ( code == TEXT_COMPACTION_MODE_LATCH || code == BYTE_COMPACTION_MODE_LATCH || code == NUMERIC_COMPACTION_MODE_LATCH || code == BYTE_COMPACTION_MODE_LATCH_6 || code == BEGIN_MACRO_PDF417_CONTROL_BLOCK || code == BEGIN_MACRO_PDF417_OPTIONAL_FIELD || code == MACRO_PDF417_TERMINATOR ) { codeIndex -- ; end = BOOL_ ; } } if ( ( count % NUM_ == NUM_ ) && ( count > NUM_ ) ) { char [ ] decodedData = new char [ NUM_ ] ; for ( int j = NUM_ ; j < NUM_ ; ++ j ) { decodedData [ NUM_ - j ] = ( char ) ( value & xFF ) ; value >>= NUM_ ; } result . append ( decodedData ) ; count = NUM_ ; } } } return codeIndex ; }
protected boolean isAllTestComponentsInTarget ( Geometry testGeom ) { List coords = ComponentCoordinateExtracter . getCoordinates ( testGeom ) ; for ( Iterator i = coords . iterator ( ) ; i . hasNext ( ) ; ) { Coordinate p = ( Coordinate ) i . next ( ) ; int loc = targetPointLocator . locate ( p ) ; if ( loc == Location . EXTERIOR ) return BOOL_ ; } return BOOL_ ; }
private Object createInner ( SimpleObject post , RequestContext context ) throws ResponseException { try { String xml = completeXform ( convertUuidsToIds ( post ) ) ; File file = File . createTempFile ( STR_ , null ) ; processor . processXForm ( xml , file . getAbsolutePath ( ) , BOOL_ , context . getRequest ( ) ) ; } catch ( IOException e ) { throw new GenericRestException ( STR_ , e ) ; } catch ( ResponseException e ) { throw e ; } catch ( Exception e ) { throw new ConversionException ( STR_ , e ) ; } Encounter encounter = guessEncounterFromXformSubmission ( post ) ; if ( encounter == null ) { return post ; } SimpleObject returnJson = new SimpleObject ( ) ; EncounterResource . populateJsonProperties ( encounter , returnJson ) ; return returnJson ; }
public Endpoint ( URI endpointUrl , SecurityMode ... modes ) { if ( modes == null || endpointUrl == null ) throw new IllegalArgumentException ( STR_ ) ; for ( SecurityMode m : modes ) { if ( m == null ) throw new IllegalArgumentException ( STR_ ) ; hash = NUM_ . hash + m . hashCode ( ) ; } this . endpointUrl = endpointUrl . toString ( ) ; this . modes = modes ; this . endpointConfiguration = EndpointConfiguration . defaults ( ) ; hash = NUM_ . hash + endpointUrl . hashCode ( ) ; }
protected Value parseValue ( ) throws IOException , RDFParseException , RDFHandlerException { int c = peekCodePoint ( ) ; if ( c == STR_ ) { return parseURI ( ) ; } else if ( c == STR_ || TurtleUtil . isPrefixStartChar ( c ) ) { return parseQNameOrBoolean ( ) ; } else if ( c == STR_ ) { return parseNodeID ( ) ; } else if ( c == STR_ || c == STR_ ) { return parseQuotedLiteral ( ) ; } else if ( ASCIIUtil . isNumber ( c ) || c == STR_ || c == STR_ || c == STR_ ) { return parseNumber ( ) ; } else if ( c == - NUM_ ) { throwEOFException ( ) ; return null ; } else { reportFatalError ( STR_ + new String ( Character . toChars ( c ) ) + STR_ ) ; return null ; } }
public TimeSeriesCollection ( ) { this ( null , TimeZone . getDefault ( ) ) ; }
private static boolean isOptimizableForDescendantIterator ( Compiler compiler , int stepOpCodePos , int stepIndex ) throws javax . xml . transform . TransformerException { int stepType ; int stepCount = NUM_ ; boolean foundDorDS = BOOL_ ; boolean foundSelf = BOOL_ ; boolean foundDS = BOOL_ ; int nodeTestType = OpCodes . NODETYPE_NODE ; while ( OpCodes . ENDOP != ( stepType = compiler . getOp ( stepOpCodePos ) ) ) { if ( nodeTestType != OpCodes . NODETYPE_NODE && nodeTestType != OpCodes . NODETYPE_ROOT ) return BOOL_ ; stepCount ++ ; if ( stepCount > NUM_ ) return BOOL_ ; boolean mightBeProximate = mightBeProximate ( compiler , stepOpCodePos , stepType ) ; if ( mightBeProximate ) return BOOL_ ; switch ( stepType ) { case OpCodes . FROM_FOLLOWING : case OpCodes . FROM_FOLLOWING_SIBLINGS : case OpCodes . FROM_PRECEDING : case OpCodes . FROM_PRECEDING_SIBLINGS : case OpCodes . FROM_PARENT : case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : case OpCodes . FROM_NAMESPACE : case OpCodes . FROM_ANCESTORS : case OpCodes . FROM_ANCESTORS_OR_SELF : case OpCodes . FROM_ATTRIBUTES : case OpCodes . MATCH_ATTRIBUTE : case OpCodes . MATCH_ANY_ANCESTOR : case OpCodes . MATCH_IMMEDIATE_ANCESTOR : return BOOL_ ; case OpCodes . FROM_ROOT : if ( NUM_ != stepCount ) return BOOL_ ; break ; case OpCodes . FROM_CHILDREN : if ( ! foundDS && ! ( foundDorDS && foundSelf ) ) return BOOL_ ; break ; case OpCodes . FROM_DESCENDANTS_OR_SELF : foundDS = BOOL_ ; case OpCodes . FROM_DESCENDANTS : if ( NUM_ == stepCount ) return BOOL_ ; foundDorDS = BOOL_ ; break ; case OpCodes . FROM_SELF : if ( NUM_ != stepCount ) return BOOL_ ; foundSelf = BOOL_ ; break ; default : throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NULL_ERROR_HANDLER , new Object [ ] { Integer . toString ( stepType ) } ) ) ; } nodeTestType = compiler . getStepTestType ( stepOpCodePos ) ; int nextStepOpCodePos = compiler . getNextStepPos ( stepOpCodePos ) ; if ( nextStepOpCodePos < NUM_ ) break ; if ( OpCodes . ENDOP != compiler . getOp ( nextStepOpCodePos ) ) { if ( compiler . countPredicates ( stepOpCodePos ) > NUM_ ) { return BOOL_ ; } } stepOpCodePos = nextStepOpCodePos ; } return BOOL_ ; }
public static < E > List < E > of ( E e1 , E e2 , E e3 ) { List < E > list = new ArrayList < > ( ) ; list . add ( e1 ) ; list . add ( e2 ) ; list . add ( e3 ) ; return list ; }
public int alloc ( int size ) { int index = n ; int len = array . length ; if ( n + size >= len ) { byte [ ] aux = new byte [ len + blockSize ] ; System . arraycopy ( array , NUM_ , aux , NUM_ , len ) ; array = aux ; } n += size ; return index ; }
@ Override public void addAttribute ( String name , float value ) { String str = Float . toString ( value ) ; if ( str . endsWith ( STR_ ) ) str = str . substring ( NUM_ , str . length ( ) - NUM_ ) ; current . setAttribute ( name , str ) ; }
@ RequestMapping ( value = STR_ , method = RequestMethod . POST ) @ ResponseBody public JsonResponse createDirectory ( @ PathVariable final String containerId , @ PathVariable final String applicationName , @ RequestParam ( STR_ ) String path ) throws ServiceException , CheckException , IOException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STR_ + containerId ) ; logger . debug ( STR_ + applicationName ) ; logger . debug ( STR_ + path ) ; } fileService . createDirectory ( applicationName , containerId , path ) ; return new HttpOk ( ) ; }
public void fill_ellipse_arr ( PlaEllipse [ ] p_ellipse_arr , Graphics p_g , Color p_color , double p_translucency_factor ) { if ( p_color == null ) return ; if ( p_ellipse_arr . length <= NUM_ ) return ; GeneralPath draw_path = new GeneralPath ( GeneralPath . WIND_EVEN_ODD ) ; for ( PlaEllipse curr_ellipse : p_ellipse_arr ) { Point2D center = coordinate_transform . board_to_screen ( curr_ellipse . center ) ; double bigger_radius = coordinate_transform . board_to_screen ( curr_ellipse . bigger_radius ) ; if ( ! point_near_rectangle ( center . getX ( ) , center . getY ( ) , ( Rectangle ) p_g . getClip ( ) , bigger_radius ) ) { continue ; } double smaller_radius = coordinate_transform . board_to_screen ( curr_ellipse . smaller_radius ) ; Ellipse2D draw_ellipse = new Ellipse2D . Double ( center . getX ( ) - bigger_radius , center . getY ( ) - smaller_radius , NUM_ . bigger_radius , NUM_ . smaller_radius ) ; double rotation = coordinate_transform . board_to_screen_angle ( curr_ellipse . rotation ) ; AffineTransform affine_transform = new AffineTransform ( ) ; affine_transform . rotate ( rotation , center . getX ( ) , center . getY ( ) ) ; Shape rotated_ellipse = affine_transform . createTransformedShape ( draw_ellipse ) ; draw_path . append ( rotated_ellipse , BOOL_ ) ; } Graphics2D g2 = ( Graphics2D ) p_g ; g2 . setColor ( p_color ) ; set_translucency ( g2 , p_translucency_factor ) ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2 . fill ( draw_path ) ; }
@ Override public void zoomDomainAxes ( double factor , PlotRenderingInfo state , Point2D source ) { }
private void refreshChallengeCounts ( ) { mDueChallengeCounts = mDueChallengeLogic . getDueChallengeCounts ( mCategories ) ; }
public Identity ( final int dim ) { this ( dim , EnumSet . noneOf ( Address . Flags . class ) ) ; }
private ImageData awtToSwt ( final BufferedImage bufferedImage , final int width , final int height ) { final int [ ] awtPixels = new int [ width . height ] ; final ImageData swtImageData = new ImageData ( width , height , NUM_ , PALETTE_DATA ) ; swtImageData . transparentPixel = TRANSPARENT_COLOR ; final int step = swtImageData . depth / NUM_ ; final byte [ ] data = swtImageData . data ; bufferedImage . getRGB ( NUM_ , NUM_ , width , height , awtPixels , NUM_ , width ) ; for ( int i = NUM_ ; i < height ; i ++ ) { int idx = ( NUM_ + i ) . swtImageData . bytesPerLine + NUM_ . step ; for ( int j = NUM_ ; j < width ; j ++ ) { final int rgb = awtPixels [ j + i . width ] ; for ( int k = swtImageData . depth - NUM_ ; k >= NUM_ ; k -= NUM_ ) { data [ idx ++ ] = ( byte ) ( rgb > > k & xFF ) ; } } } return swtImageData ; }
public static boolean isUnlimitedStrengthPolicyAvailable ( ) { try { return Cipher . getMaxAllowedKeyLength ( STR_ ) >= NUM_ ; } catch ( final NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } return BOOL_ ; }
public long rsslim ( ) { return Long . parseLong ( fields [ NUM_ ] ) ; }
public void addTotals ( Info_Column [ ] layout ) { addTotals ( ( ColumnInfo [ ] ) layout ) ; }
private void fillStackTrace ( StringBuffer buffer , StackTraceElement [ ] elements ) { for ( int index = NUM_ ; index < elements . length ; index ++ ) { buffer . append ( elements [ index ] ) ; buffer . append ( STR_ ) ; } }
public static boolean isFileTypeSupported ( int fileType ) { List providers = getMidiFileWriters ( ) ; for ( int i = NUM_ ; i < providers . size ( ) ; i ++ ) { MidiFileWriter writer = ( MidiFileWriter ) providers . get ( i ) ; if ( writer . isFileTypeSupported ( fileType ) ) { return BOOL_ ; } } return BOOL_ ; }
public void makeImmutable ( ) { if ( isMutable ) { isMutable = BOOL_ ; } }
public static double uniform ( ) { return random . nextDouble ( ) ; }
public void modify ( SSOToken token , String objName , ModificationItem [ ] mods ) throws SMSException , SSOException { if ( ( objName == null ) || ( objName . length ( ) == NUM_ ) || ( mods == null ) || ( mods . length == NUM_ ) ) { throw new IllegalArgumentException ( STR_ + STR_ ) ; } String objKey = objName . toLowerCase ( ) ; String filepath = null ; mRWLock . readRequest ( ) ; try { filepath = mNameMap . getProperty ( objKey ) ; if ( filepath == null ) { String errmsg = STR_ + objName + STR_ ; mDebug . error ( errmsg ) ; throw new ServiceNotFoundException ( errmsg ) ; } } finally { mRWLock . readDone ( ) ; } mRWLock . writeRequest ( ) ; try { filepath = mNameMap . getProperty ( objKey ) ; if ( filepath == null ) { String errmsg = STR_ + objName + STR_ ; mDebug . error ( errmsg ) ; throw new ServiceNotFoundException ( errmsg ) ; } File filehandle = new File ( filepath ) ; if ( ! filehandle . isFile ( ) ) { String errmsg = STR_ + objName + STR_ ; mDebug . error ( errmsg ) ; throw new ServiceNotFoundException ( errmsg ) ; } Properties props = loadProperties ( filehandle , objName ) ; boolean hasSunXmlKeyValue = ( props . getProperty ( SMSEntry . ATTR_XML_KEYVAL ) == null ) ? BOOL_ : BOOL_ ; for ( int i = NUM_ ; i < mods . length ; i ++ ) { modifyValues ( objName , mods [ i ] , props ) ; } saveProperties ( props , filehandle , objName ) ; if ( ! hasSunXmlKeyValue ) { hasSunXmlKeyValue = ( props . getProperty ( SMSEntry . ATTR_XML_KEYVAL ) == null ) ? BOOL_ : BOOL_ ; } if ( hasSunXmlKeyValue ) { deleteSunXmlKeyValFiles ( filehandle . getParentFile ( ) ) ; Set xmlKeyVals = toValSet ( SMSEntry . ATTR_XML_KEYVAL , props . getProperty ( SMSEntry . ATTR_XML_KEYVAL ) ) ; createSunXmlKeyValFiles ( filehandle . getParentFile ( ) , xmlKeyVals ) ; } } finally { mRWLock . writeDone ( ) ; } }
private AMSetupDSConfig ( ) { Map map = ServicesDefaultValues . getDefaultValues ( ) ; dsManager = ( String ) map . get ( SetupConstants . CONFIG_VAR_DS_MGR_DN ) ; suffix = ( String ) map . get ( SetupConstants . CONFIG_VAR_ROOT_SUFFIX ) ; dsHostName = ( String ) map . get ( SetupConstants . CONFIG_VAR_DIRECTORY_SERVER_HOST ) ; dsPort = ( String ) map . get ( SetupConstants . CONFIG_VAR_DIRECTORY_SERVER_PORT ) ; dsAdminPwd = ( String ) map . get ( SetupConstants . CONFIG_VAR_DS_MGR_PWD ) ; basedir = ( String ) map . get ( SetupConstants . CONFIG_VAR_BASE_DIR ) ; deployuri = ( String ) map . get ( SetupConstants . CONFIG_VAR_SERVER_URI ) ; }
private boolean compareAndIncrementWorkerCount ( int expect ) { return ctl . compareAndSet ( expect , expect + NUM_ ) ; }
private void makeItems ( int fingerPosition , List < View > viewList ) { if ( fingerPosition >= viewList . size ( ) ) { return ; } for ( int i = NUM_ ; i < viewList . size ( ) ; i ++ ) { int translationY = Math . min ( Math . max ( Math . abs ( fingerPosition - i ) . intervalHeight , NUM_ ) , maxTranslationHeight ) ; updateItemHeightAnimator ( viewList . get ( i ) , translationY ) ; } }
private boolean pathIsWindows ( String path ) { if ( path != null && path . length ( ) > NUM_ ) { return ( Character . isLetter ( path . charAt ( NUM_ ) ) && path . charAt ( NUM_ ) == STR_ ) || ( path . startsWith ( STR_ ) || path . startsWith ( STR_ ) ) ; } return BOOL_ ; }
Object processCHAR ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { if ( getSupportsAVT ( ) ) { try { AVT avt = new AVT ( handler , uri , name , rawName , value , owner ) ; if ( ( avt . isSimple ( ) ) && ( value . length ( ) != NUM_ ) ) { handleError ( handler , XSLTErrorResources . INVALID_TCHAR , new Object [ ] { name , value } , null ) ; return null ; } return avt ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } else { if ( value . length ( ) != NUM_ ) { handleError ( handler , XSLTErrorResources . INVALID_TCHAR , new Object [ ] { name , value } , null ) ; return null ; } return new Character ( value . charAt ( NUM_ ) ) ; } }
public static Element addChildElementValue ( Element element , String childElementName , String childElementValue , Document document ) { Element newElement = addChildElement ( element , childElementName , document ) ; newElement . appendChild ( document . createTextNode ( childElementValue ) ) ; return newElement ; }
public boolean isSegmentBalanced ( ) { if ( m_lines . size ( ) == NUM_ || m_doc . isMultiCurrency ( ) ) return BOOL_ ; MAcctSchemaElement [ ] elements = m_acctSchema . getAcctSchemaElements ( ) ; for ( int i = NUM_ ; i < elements . length ; i ++ ) { MAcctSchemaElement ase = elements [ i ] ; if ( ase . isBalanced ( ) && ! isSegmentBalanced ( ase . getElementType ( ) ) ) return BOOL_ ; } return BOOL_ ; }
Attributes parseAttributes ( ) throws JasperException { AttributesImpl attrs = new AttributesImpl ( ) ; reader . skipSpaces ( ) ; while ( parseAttribute ( attrs ) ) reader . skipSpaces ( ) ; return attrs ; }
public static byte [ ] readBinaryFile ( File sourceFile ) { byte [ ] result = null ; try { BufferedInputStream input ; input = new BufferedInputStream ( new FileInputStream ( sourceFile ) ) ; int num = input . available ( ) ; result = new byte [ num ] ; input . read ( result , NUM_ , num ) ; input . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; result = null ; } return result ; }
@ SuppressWarnings ( STR_ ) public void test_streamAPI ( ) { final List < IBindingSet > expectedSolutions = new ArrayList < IBindingSet > ( ) ; { final IBindingSet expected = new ListBindingSet ( ) ; expected . set ( Var . var ( STR_ ) , new Constant < IV > ( termId ) ) ; expectedSolutions . add ( expected ) ; } { final IBindingSet expected = new ListBindingSet ( ) ; expected . set ( Var . var ( STR_ ) , new Constant < IV > ( termId ) ) ; expected . set ( Var . var ( STR_ ) , new Constant < IV > ( blobIV ) ) ; expectedSolutions . add ( expected ) ; } doEncodeDecodeTest ( expectedSolutions ) ; }
public void addTerm ( SplitCondition condition ) { terms . add ( condition ) ; }
@ Override protected void thresholdReached ( ) throws IOException { if ( prefix != null ) { outputFile = File . createTempFile ( prefix , suffix , directory ) ; } FileOutputStream fos = new FileOutputStream ( outputFile ) ; memoryOutputStream . writeTo ( fos ) ; currentOutputStream = fos ; memoryOutputStream = null ; }
public void removeIndexInterval ( int index0 , int index1 ) { int rmMinIndex = Math . min ( index0 , index1 ) ; int rmMaxIndex = Math . max ( index0 , index1 ) ; int gapLength = ( rmMaxIndex - rmMinIndex ) + NUM_ ; for ( int i = rmMinIndex ; i <= maxIndex ; i ++ ) { setState ( i , value . get ( i + gapLength ) ) ; } int leadIndex = this . leadIndex ; if ( leadIndex == NUM_ && rmMinIndex == NUM_ ) { } else if ( leadIndex > rmMaxIndex ) { leadIndex = this . leadIndex - gapLength ; } else if ( leadIndex >= rmMinIndex ) { leadIndex = rmMinIndex - NUM_ ; } int anchorIndex = this . anchorIndex ; if ( anchorIndex == NUM_ && rmMinIndex == NUM_ ) { } else if ( anchorIndex > rmMaxIndex ) { anchorIndex = this . anchorIndex - gapLength ; } else if ( anchorIndex >= rmMinIndex ) { anchorIndex = rmMinIndex - NUM_ ; } if ( leadIndex != this . leadIndex || anchorIndex != this . anchorIndex ) { updateLeadAnchorIndices ( anchorIndex , leadIndex ) ; } fireValueChanged ( ) ; }
public void rebuildEventList ( boolean resetSelected ) { if ( logger . isLoggable ( Level . FINE ) ) { logger . fine ( STR_ ) ; } allEvents = null ; activeEvents = null ; hideDetails ( ) ; initInterface ( getActiveEvents ( ) , resetSelected ) ; highlightCurrentEvent ( currentTime ) ; firePropertyChange ( ActiveEventsProperty , null , getActiveEvents ( ) ) ; }
public DiskStoreFactory createDiskStoreFactory ( ) { return new DiskStoreFactoryImpl ( this ) ; }
public static boolean deleteDirectorySubdirectories ( String rootDirectory ) { if ( ( rootDirectory == null ) ) { return BOOL_ ; } boolean didSuccessfullyDeleteAllDirectories = BOOL_ ; try { List < File > files = getListOfFilesInADirectory ( rootDirectory ) ; for ( File file : files ) { if ( file . isDirectory ( ) ) { boolean deleteSuccess = deleteDirectoryAndContents ( file ) ; if ( ! deleteSuccess ) { logger . debug ( STR_ + file . getAbsolutePath ( ) ) ; didSuccessfullyDeleteAllDirectories = BOOL_ ; } } } } catch ( Exception e ) { logger . debug ( e . toString ( ) + System . lineSeparator ( ) + StackTrace . getStringFromStackTrace ( e ) ) ; return BOOL_ ; } return didSuccessfullyDeleteAllDirectories ; }
public void put ( byte [ ] buffer , int offset , int count ) { if ( count > ( bytes . length - this . contentLength ) ) { throw new IllegalArgumentException ( STR_ ) ; } System . arraycopy ( buffer , offset , bytes , this . contentLength , count ) ; this . contentLength += count ; }
private void markReserved ( int ropReg , int category ) { reservedRopRegs . set ( ropReg , ropReg + category , BOOL_ ) ; }
public static void registerDefaultResolvers ( ) { synchronized ( resolverList ) { resolverList . add ( new ResourceResolver ( new ResolverFragment ( ) ) ) ; resolverList . add ( new ResourceResolver ( new ResolverLocalFilesystem ( ) ) ) ; resolverList . add ( new ResourceResolver ( new ResolverXPointer ( ) ) ) ; resolverList . add ( new ResourceResolver ( new ResolverDirectHTTP ( ) ) ) ; } }
private boolean processAuthenticationResponse ( final HttpMethod method ) { LOG . trace ( STR_ + STR_ ) ; try { switch ( method . getStatusCode ( ) ) { case HttpStatus . SC_UNAUTHORIZED : return processWWWAuthChallenge ( method ) ; case HttpStatus . SC_PROXY_AUTHENTICATION_REQUIRED : return processProxyAuthChallenge ( method ) ; default : return BOOL_ ; } } catch ( Exception e ) { if ( LOG . isErrorEnabled ( ) ) { LOG . error ( e . getMessage ( ) , e ) ; } return BOOL_ ; } }
private void release ( ByteArray byteArray ) { synchronized ( syncRoot ) { if ( availableByteArrays . size ( ) >= maxAvailableArraysCount ) { return ; } if ( ! availableByteArrays . contains ( byteArray ) ) { availableByteArrays . add ( byteArray ) ; } } }
@ Override public boolean connectionAllowed ( EventSetDescriptor esd ) { return connectionAllowed ( esd . getName ( ) ) ; }
@ Override public void drawRangeMarker ( Graphics2D g2 , CategoryPlot plot , ValueAxis axis , Marker marker , Rectangle2D dataArea ) { if ( marker instanceof ValueMarker ) { ValueMarker vm = ( ValueMarker ) marker ; double value = vm . getValue ( ) ; Range range = axis . getRange ( ) ; if ( ! range . contains ( value ) ) { return ; } final Composite savedComposite = g2 . getComposite ( ) ; g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , marker . getAlpha ( ) ) ) ; PlotOrientation orientation = plot . getOrientation ( ) ; double v = axis . valueToJava2D ( value , dataArea , plot . getRangeAxisEdge ( ) ) ; Line2D line = null ; if ( orientation == PlotOrientation . HORIZONTAL ) { line = new Line2D . Double ( v , dataArea . getMinY ( ) , v , dataArea . getMaxY ( ) ) ; } else if ( orientation == PlotOrientation . VERTICAL ) { line = new Line2D . Double ( dataArea . getMinX ( ) , v , dataArea . getMaxX ( ) , v ) ; } else { throw new IllegalStateException ( ) ; } g2 . setPaint ( marker . getPaint ( ) ) ; g2 . setStroke ( marker . getStroke ( ) ) ; g2 . draw ( line ) ; String label = marker . getLabel ( ) ; RectangleAnchor anchor = marker . getLabelAnchor ( ) ; if ( label != null ) { Font labelFont = marker . getLabelFont ( ) ; g2 . setFont ( labelFont ) ; Point2D coordinates = calculateRangeMarkerTextAnchorPoint ( g2 , orientation , dataArea , line . getBounds2D ( ) , marker . getLabelOffset ( ) , LengthAdjustmentType . EXPAND , anchor ) ; Rectangle2D rect = TextUtils . calcAlignedStringBounds ( label , g2 , ( float ) coordinates . getX ( ) , ( float ) coordinates . getY ( ) , marker . getLabelTextAnchor ( ) ) ; g2 . setPaint ( marker . getLabelBackgroundColor ( ) ) ; g2 . fill ( rect ) ; g2 . setPaint ( marker . getLabelPaint ( ) ) ; TextUtils . drawAlignedString ( label , g2 , ( float ) coordinates . getX ( ) , ( float ) coordinates . getY ( ) , marker . getLabelTextAnchor ( ) ) ; } g2 . setComposite ( savedComposite ) ; } else if ( marker instanceof IntervalMarker ) { IntervalMarker im = ( IntervalMarker ) marker ; double start = im . getStartValue ( ) ; double end = im . getEndValue ( ) ; Range range = axis . getRange ( ) ; if ( ! ( range . intersects ( start , end ) ) ) { return ; } final Composite savedComposite = g2 . getComposite ( ) ; g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , marker . getAlpha ( ) ) ) ; double start2d = axis . valueToJava2D ( start , dataArea , plot . getRangeAxisEdge ( ) ) ; double end2d = axis . valueToJava2D ( end , dataArea , plot . getRangeAxisEdge ( ) ) ; double low = Math . min ( start2d , end2d ) ; double high = Math . max ( start2d , end2d ) ; PlotOrientation orientation = plot . getOrientation ( ) ; Rectangle2D rect = null ; if ( orientation == PlotOrientation . HORIZONTAL ) { low = Math . max ( low , dataArea . getMinX ( ) ) ; high = Math . min ( high , dataArea . getMaxX ( ) ) ; rect = new Rectangle2D . Double ( low , dataArea . getMinY ( ) , high - low , dataArea . getHeight ( ) ) ; } else if ( orientation == PlotOrientation . VERTICAL ) { low = Math . max ( low , dataArea . getMinY ( ) ) ; high = Math . min ( high , dataArea . getMaxY ( ) ) ; rect = new Rectangle2D . Double ( dataArea . getMinX ( ) , low , dataArea . getWidth ( ) , high - low ) ; } Paint p = marker . getPaint ( ) ; if ( p instanceof GradientPaint ) { GradientPaint gp = ( GradientPaint ) p ; GradientPaintTransformer t = im . getGradientPaintTransformer ( ) ; if ( t != null ) { gp = t . transform ( gp , rect ) ; } g2 . setPaint ( gp ) ; } else { g2 . setPaint ( p ) ; } g2 . fill ( rect ) ; if ( im . getOutlinePaint ( ) != null && im . getOutlineStroke ( ) != null ) { if ( orientation == PlotOrientation . VERTICAL ) { Line2D line = new Line2D . Double ( ) ; double x0 = dataArea . getMinX ( ) ; double x1 = dataArea . getMaxX ( ) ; g2 . setPaint ( im . getOutlinePaint ( ) ) ; g2 . setStroke ( im . getOutlineStroke ( ) ) ; if ( range . contains ( start ) ) { line . setLine ( x0 , start2d , x1 , start2d ) ; g2 . draw ( line ) ; } if ( range . contains ( end ) ) { line . setLine ( x0 , end2d , x1 , end2d ) ; g2 . draw ( line ) ; } } else { Line2D line = new Line2D . Double ( ) ; double y0 = dataArea . getMinY ( ) ; double y1 = dataArea . getMaxY ( ) ; g2 . setPaint ( im . getOutlinePaint ( ) ) ; g2 . setStroke ( im . getOutlineStroke ( ) ) ; if ( range . contains ( start ) ) { line . setLine ( start2d , y0 , start2d , y1 ) ; g2 . draw ( line ) ; } if ( range . contains ( end ) ) { line . setLine ( end2d , y0 , end2d , y1 ) ; g2 . draw ( line ) ; } } } String label = marker . getLabel ( ) ; RectangleAnchor anchor = marker . getLabelAnchor ( ) ; if ( label != null ) { Font labelFont = marker . getLabelFont ( ) ; g2 . setFont ( labelFont ) ; Point2D coords = calculateRangeMarkerTextAnchorPoint ( g2 , orientation , dataArea , rect , marker . getLabelOffset ( ) , marker . getLabelOffsetType ( ) , anchor ) ; Rectangle2D r = TextUtils . calcAlignedStringBounds ( label , g2 , ( float ) coords . getX ( ) , ( float ) coords . getY ( ) , marker . getLabelTextAnchor ( ) ) ; g2 . setPaint ( marker . getLabelBackgroundColor ( ) ) ; g2 . fill ( r ) ; g2 . setPaint ( marker . getLabelPaint ( ) ) ; TextUtilities . drawAlignedString ( label , g2 , ( float ) coords . getX ( ) , ( float ) coords . getY ( ) , marker . getLabelTextAnchor ( ) ) ; } g2 . setComposite ( savedComposite ) ; } }
private void init ( ) { acceptableMethods = new ArrayList < > ( ) ; acceptableMethods . add ( new NoAuthenticationRequiredMethod ( ) ) ; acceptableMethods . add ( new GssApiMethod ( ) ) ; acceptableMethods . add ( new UsernamePasswordMethod ( ) ) ; }
private boolean lockOrder ( Order order ) { lock . lock ( ) ; try { return activeOrders . add ( order . getId ( ) ) ; } finally { lock . unlock ( ) ; } }
public void put ( Buffer buffer ) { if ( buffer . getLength ( ) <= NUM_ ) { return ; } byte [ ] currentRtpPacketData = ( ( byte [ ] ) buffer . getData ( ) ) ; H264RtpHeaders h264RtpHeaders = new H264RtpHeaders ( currentRtpPacketData ) ; if ( h264RtpHeaders . getFUI_F ( ) ) { return ; } if ( reassembledData == null ) { timestamp = buffer . getTimestamp ( ) ; format = buffer . getFormat ( ) ; seqNumber = buffer . getSequenceNumber ( ) ; reassembledDataNALHeader = h264RtpHeaders . getNALHeader ( ) ; reassembledData = new byte [ JavaPacketizer . H264_MAX_RTP_PKTS ] [ H264_FRAME_PACKET_SIZE ] ; reassembledDataSize = new int [ JavaPacketizer . H264_MAX_RTP_PKTS ] ; reassembledDataHasStart = BOOL_ ; reassembledDataHasEnd = BOOL_ ; } int posSeq = ( int ) ( buffer . getSequenceNumber ( ) & VIDEO_DECODER_MAX_PAYLOADS_CHUNKS_MASK ) ; int payloadStartPosition = h264RtpHeaders . getHeaderSize ( ) ; int payloadLength = buffer . getLength ( ) - h264RtpHeaders . getHeaderSize ( ) ; if ( h264RtpHeaders . getFUI_TYPE ( ) == H264RtpHeaders . AVC_NALTYPE_FUA ) { reassembledDataHasStart |= ( h264RtpHeaders . getFUH_S ( ) ) ; reassembledDataHasEnd |= ( h264RtpHeaders . getFUH_E ( ) ) ; reassembledDataPosSeqStart = ( ( h264RtpHeaders . getFUH_S ( ) ) ? posSeq : reassembledDataPosSeqStart ) ; reassembledDataPosSeqEnd = ( ( h264RtpHeaders . getFUH_E ( ) ) ? posSeq : reassembledDataPosSeqEnd ) ; } reassembledDataSize [ posSeq ] = payloadLength ; reassembledDataFullSize += payloadLength ; System . arraycopy ( currentRtpPacketData , payloadStartPosition , reassembledData [ posSeq ] , NUM_ , payloadLength ) ; videoOrientation = buffer . getVideoOrientation ( ) ; }
public static final void writeStringArrayXml ( String [ ] val , String name , XmlSerializer out ) throws XmlPullParserException , java . io . IOException { if ( val == null ) { out . startTag ( null , STR_ ) ; out . endTag ( null , STR_ ) ; return ; } out . startTag ( null , STR_ ) ; if ( name != null ) { out . attribute ( null , STR_ , name ) ; } final int N = val . length ; out . attribute ( null , STR_ , Integer . toString ( N ) ) ; for ( int i = NUM_ ; i < N ; i ++ ) { out . startTag ( null , STR_ ) ; out . attribute ( null , STR_ , val [ i ] ) ; out . endTag ( null , STR_ ) ; } out . endTag ( null , STR_ ) ; }
private static boolean hasSpecializedHandlerIntents ( Context context , Intent intent ) { try { PackageManager pm = context . getPackageManager ( ) ; List < ResolveInfo > handlers = pm . queryIntentActivities ( intent , PackageManager . GET_RESOLVED_FILTER ) ; if ( handlers == null || handlers . size ( ) == NUM_ ) { return BOOL_ ; } for ( ResolveInfo resolveInfo : handlers ) { IntentFilter filter = resolveInfo . filter ; if ( filter == null ) continue ; if ( filter . countDataAuthorities ( ) == NUM_ || filter . countDataPaths ( ) == NUM_ ) continue ; if ( resolveInfo . activityInfo == null ) continue ; return BOOL_ ; } } catch ( RuntimeException e ) { Log . e ( TAG , STR_ ) ; } return BOOL_ ; }
private void unifyUsernameByName ( Map < String , List < LogCommitInfo > > devNameMap ) { for ( Entry < String , List < LogCommitInfo > > entry : devNameMap . entrySet ( ) ) { List < String > userNames = getUserNamesList ( entry . getValue ( ) ) ; if ( userNames . size ( ) > NUM_ ) { String newUserName = getNewUserName ( userNames ) ; for ( LogCommitInfo commit : entry . getValue ( ) ) { commit . setUserName ( newUserName ) ; } } } }
@ SuppressWarnings ( STR_ ) public JdbcData ( Connection connection , String table , boolean buffered ) { this . connection = connection ; this . table = table ; setBuffered ( buffered ) ; try { setColumnTypes ( getJdbcColumnTypes ( ) ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
public void storeStackForException ( Throwable t , int currentStackFrame ) { if ( ! exceptionStack . containsKey ( t ) ) { int [ ] s = new int [ stackPointer + NUM_ ] ; System . arraycopy ( stack , NUM_ , s , NUM_ , stackPointer ) ; s [ stackPointer ] = currentStackFrame ; exceptionStack . put ( t , s ) ; } }
public SecureELFFormatter ( ) { String timestampGeneratorClass = lmanager . getProperty ( LogConstants . SECURE_TIMESTAMP_GENERATOR ) ; try { Class clz = Class . forName ( timestampGeneratorClass ) ; secureTimestampGenerator = ( ITimestampGenerator ) clz . newInstance ( ) ; } catch ( ClassNotFoundException cnfe ) { Debug . error ( STR_ + STR_ , cnfe ) ; } catch ( InstantiationException ie ) { Debug . error ( STR_ + STR_ , ie ) ; } catch ( IllegalAccessException iae ) { Debug . error ( STR_ + STR_ , iae ) ; } }
public static byte [ ] readData ( final URL url ) throws IOException { try ( InputStream input = url . openStream ( ) ) { return readData ( input ) ; } }
public boolean isValidCurrent ( long checkTime ) { if ( checkTime == NUM_ || ( rDateList == null && rRulesList == null ) ) { return BOOL_ ; } boolean found = BOOL_ ; Iterator < RecurrenceRule > rulesIterator = getRecurrenceRuleIterator ( ) ; while ( rulesIterator . hasNext ( ) ) { RecurrenceRule rule = rulesIterator . next ( ) ; long currentTime = rule . validCurrent ( getStartTime ( ) , checkTime , getCurrentCount ( ) ) ; currentTime = checkDateList ( rDateList , currentTime , checkTime ) ; if ( ( currentTime > NUM_ ) && isValid ( checkTime ) ) { found = BOOL_ ; } else { return BOOL_ ; } } return found ; }
public static EnergyNetwork initNetwork ( ) { Random random = new Random ( System . currentTimeMillis ( ) ) ; int id = random . nextInt ( ) ; while ( usedIds . contains ( id ) ) { id = random . nextInt ( ) ; } ; EnergyNetwork net = new EnergyNetwork ( ) ; usedIds . add ( id ) ; net . networkID = id ; return net ; }
public static String toKilobytes ( long bytes ) { if ( bytes < NUM_ ) return STR_ + GENERAL_UNIT_KILOBYTES ; long kbytes = bytes / NUM_ ; if ( ( bytes & NUM_ ) != NUM_ || ( bytes > NUM_ && bytes < NUM_ ) ) kbytes ++ ; return NUMBER_FORMAT0 . format ( kbytes ) + GENERAL_UNIT_KILOBYTES ; }
private PendingIntent createRequestPendingIntent ( @ NonNull String pendingIntentClassName ) { PendingIntent pendingIntent = null ; try { Class classOfPendingIntent = Class . forName ( pendingIntentClassName ) ; if ( classOfPendingIntent != null ) { Intent intent = new Intent ( mContext , classOfPendingIntent ) ; pendingIntent = PendingIntent . getService ( mContext , NUM_ , intent , PendingIntent . FLAG_UPDATE_CURRENT ) ; } } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } return pendingIntent ; }
public boolean isStatic ( ) { return Modifier . isStatic ( _method . getModifiers ( ) ) ; }
void testString ( ) { String a = randomString ( ) ; if ( returnNew ) { String b = StringUtils . fromCacheOrNew ( a ) ; try { assertEquals ( a , b ) ; } catch ( Exception e ) { TestBase . logError ( STR_ , e ) ; } if ( a != null && a == b && a . length ( ) > NUM_ ) { throw new AssertionError ( STR_ + System . identityHashCode ( a ) + STR_ + System . identityHashCode ( b ) ) ; } } else { String b ; if ( useIntern ) { b = a == null ? null : a . intern ( ) ; } else { b = StringUtils . cache ( a ) ; } try { assertEquals ( a , b ) ; } catch ( Exception e ) { TestBase . logError ( STR_ , e ) ; } } }
public static void write ( File file , CharSequence data , Charset encoding , boolean append ) throws IOException { String str = data == null ? null : data . toString ( ) ; writeStringToFile ( file , str , encoding , append ) ; }
public static String unifyLineSeparators ( String s ) { return unifyLineSeparators ( s , System . getProperty ( STR_ ) ) ; }
public static byte [ ] decryptKey ( byte [ ] password , byte [ ] encryptedKey ) { try { Cipher c = Cipher . getInstance ( ENCRYPT_KEY_ALGORITHM ) ; c . init ( Cipher . DECRYPT_MODE , new SecretKeySpec ( password , SECRET_KEY_ALGORITHM ) , CBC_SALT_KEY ) ; return c . doFinal ( encryptedKey ) ; } catch ( Exception e ) { throw new IllegalStateException ( ENCRYPT_KEY_ALGORITHM + STR_ , e ) ; } }
public void configs ( SwtPlatform ... platforms ) { configs ( Arrays . asList ( platforms ) ) ; }
protected int checkIPRange ( ) { int retVal = NUM_ ; String ipVersion ; String ipType ; Map < String , String > holdDetails ; for ( String nextIP : IPRangeRange ) { try { holdDetails = checkIPVersion ( nextIP ) ; } catch ( IllegalArgumentException e ) { if ( debug . warningEnabled ( ) ) { debug . warning ( STR_ , ADAPTIVE , nextIP , e ) ; } continue ; } ipVersion = holdDetails . get ( IP_Version ) ; ipType = holdDetails . get ( IP_TYPE ) ; if ( ipVersion . equalsIgnoreCase ( IP_V6 ) && ValidateIPaddress . isIPv6 ( clientIP ) ) { if ( debug . messageEnabled ( ) ) { debug . message ( STR_ , ADAPTIVE , clientIP , nextIP ) ; debug . message ( STR_ , IP_V6 ) ; debug . message ( STR_ , IPv6Address . fromString ( clientIP ) ) ; } if ( ipType . equalsIgnoreCase ( STR_ ) ) { String first = holdDetails . get ( IP_START ) ; String last = holdDetails . get ( IP_END ) ; IPv6AddressRange iPv6AddressRange = IPv6AddressRange . fromFirstAndLast ( IPv6Address . fromString ( first ) , IPv6Address . fromString ( last ) ) ; if ( iPv6AddressRange . contains ( IPv6Address . fromString ( clientIP ) ) ) { retVal = IPRangeScore ; break ; } } else if ( ipType . equalsIgnoreCase ( STR_ ) ) { IPv6Network iPv6Network = IPv6Network . fromString ( nextIP ) ; if ( iPv6Network . contains ( IPv6Address . fromString ( clientIP ) ) ) { retVal = IPRangeScore ; break ; } } else { IPv6Address iPv6AddressNextIP = IPv6Address . fromString ( nextIP ) ; if ( iPv6AddressNextIP . compareTo ( IPv6Address . fromString ( clientIP ) ) == NUM_ ) { retVal = IPRangeScore ; break ; } } } else if ( ipVersion . equalsIgnoreCase ( IP_V4 ) && ValidateIPaddress . isIPv4 ( clientIP ) ) { if ( debug . messageEnabled ( ) ) { debug . message ( STR_ , ADAPTIVE , clientIP , nextIP ) ; debug . message ( STR_ , IP_V4 ) ; debug . message ( STR_ , clientIP ) ; } IPRange theRange = new IPRange ( nextIP ) ; if ( theRange . inRange ( clientIP ) ) { retVal = IPRangeScore ; break ; } } } if ( ! IPRangeInvert ) { retVal = IPRangeScore - retVal ; } return retVal ; }
private View fillFromSelection ( int selectedLeft , int childrenLeft , int childrenRight ) { if ( DEBUG ) Log . i ( TAG , STR_ + selectedLeft + STR_ + childrenLeft + CHILDREN_RIGHT + childrenRight + M_FIRST_POSITION + mFirstPosition ) ; final int fadingEdgeLength = getHorizontalFadingEdgeLength ( ) ; final int selectedPosition = mSelectedPosition ; final int numRows = mNumRows ; final int horizontalSpacing = mHorizontalSpacing ; int columnStart ; int columnEnd = - NUM_ ; if ( ! mStackFromBottom ) { columnStart = selectedPosition - ( selectedPosition % numRows ) ; } else { int invertedSelection = mItemCount - NUM_ - selectedPosition ; columnEnd = mItemCount - NUM_ - ( invertedSelection - ( invertedSelection % numRows ) ) ; columnStart = Math . max ( NUM_ , columnEnd - numRows + NUM_ ) ; } View sel ; View referenceView ; int leftSelectionPixel = getLeftSelectionPixel ( childrenLeft , fadingEdgeLength , columnStart ) ; int rightSelectionPixel = getRightSelectionPixel ( childrenRight , fadingEdgeLength , numRows , columnStart ) ; sel = makeColumn ( mStackFromBottom ? columnEnd : columnStart , selectedLeft , BOOL_ ) ; mFirstPosition = columnStart ; referenceView = mReferenceView ; adjustForLeftFadingEdge ( referenceView , leftSelectionPixel , rightSelectionPixel ) ; adjustForRightFadingEdge ( referenceView , leftSelectionPixel , rightSelectionPixel ) ; if ( ! mStackFromBottom ) { fillLeft ( columnStart - numRows , referenceView . getLeft ( ) - horizontalSpacing ) ; adjustViewsLeftOrRight ( ) ; fillRight ( columnStart + numRows , referenceView . getRight ( ) + horizontalSpacing ) ; } else { fillRight ( columnEnd + numRows , referenceView . getRight ( ) + horizontalSpacing ) ; adjustViewsLeftOrRight ( ) ; fillLeft ( columnStart - NUM_ , referenceView . getLeft ( ) - horizontalSpacing ) ; } return sel ; }
private static Field findField ( Object instance , String name ) throws NoSuchFieldException { for ( Class < ? > clazz = instance . getClass ( ) ; clazz != null ; clazz = clazz . getSuperclass ( ) ) { try { Field field = clazz . getDeclaredField ( name ) ; if ( ! field . isAccessible ( ) ) { field . setAccessible ( BOOL_ ) ; } return field ; } catch ( NoSuchFieldException e ) { } } throw new NoSuchFieldException ( STR_ + name + STR_ + instance . getClass ( ) ) ; }
protected int calculateBreakPosition ( int p0 , Token tokenList , float x0 ) { int p = p0 ; RSyntaxTextArea textArea = ( RSyntaxTextArea ) getContainer ( ) ; float currentWidth = getWidth ( ) ; if ( currentWidth == Integer . MAX_VALUE ) currentWidth = getPreferredSpan ( X_AXIS ) ; currentWidth = Math . max ( currentWidth , MIN_WIDTH ) ; Token t = tokenList ; while ( t != null && t . isPaintable ( ) ) { float tokenWidth = t . getWidth ( textArea , this , x0 ) ; if ( tokenWidth > currentWidth ) { if ( p == p0 ) { return t . getOffsetBeforeX ( textArea , this , NUM_ , currentWidth ) ; } return t . isWhitespace ( ) ? p + t . textCount : p ; } currentWidth -= tokenWidth ; x0 += tokenWidth ; p += t . textCount ; t = t . getNextToken ( ) ; } return p + NUM_ ; }
@ Override public ShapeTileSimplex to_Simplex ( ) { if ( is_empty ( ) ) return ShapeTileSimplex . EMPTY ; ArrayList < PlaLineInt > line_arr = new ArrayList < PlaLineInt > ( NUM_ ) ; line_arr . add ( new PlaLineInt ( box_ll , PlaDirection . RIGHT ) ) ; line_arr . add ( new PlaLineInt ( box_ur , PlaDirection . UP ) ) ; line_arr . add ( new PlaLineInt ( box_ur , PlaDirection . LEFT ) ) ; line_arr . add ( new PlaLineInt ( box_ll , PlaDirection . DOWN ) ) ; return new ShapeTileSimplex ( line_arr ) ; }
private void injectContent ( Inject injectContent ) throws IOException , MojoExecutionException { Map < Pattern , File > contents = getContentsMap ( injectContent . getContents ( ) ) ; File tmpFile = ioFactory . createTemporaryFile ( injectContent . getDestinationFile ( ) ) ; BufferedReader reader = null ; BufferedWriter writer = null ; try { reader = ioFactory . newReader ( injectContent . getDestinationFile ( ) ) ; writer = ioFactory . newWriter ( tmpFile ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { File content = doesLineMatchId ( contents , line ) ; if ( content != null ) { ioFactory . writeContent ( writer , content , getContentConverter ( injectContent ) ) ; } else { ioFactory . writeLine ( writer , line ) ; } } } finally { if ( reader != null ) { reader . close ( ) ; } if ( writer != null ) { writer . flush ( ) ; writer . close ( ) ; } } ioFactory . moveTo ( tmpFile , injectContent . getDestinationFile ( ) ) ; }
public static < E > boolean isEmpty ( CharSequence c ) { return ( c == null ) || c . length ( ) == NUM_ ; }
private static boolean createBooleanSetting ( final Map < String , String > rawSettings , final String settingName , final boolean defaultValue ) { final String settingString = rawSettings . get ( settingName ) ; if ( settingString == null ) { return defaultValue ; } else { try { return Boolean . parseBoolean ( settingString ) ; } catch ( final NumberFormatException exception ) { CUtilityFunctions . logException ( exception ) ; return defaultValue ; } } }
@ Override public void disconnectionNotification ( String eventName , Object source ) { m_listenees . remove ( source ) ; }
public Criteria createCriteria ( ) { Criteria criteria = createCriteriaInternal ( ) ; if ( oredCriteria . size ( ) == NUM_ ) { oredCriteria . add ( criteria ) ; } return criteria ; }
private MarshalledWrapper lookupDo ( Template tmpl ) { if ( isEmpty ( tmpl . serviceTypes ) || tmpl . serviceID != null ) { ItemIter iter = matchingItems ( tmpl ) ; if ( iter . hasNext ( ) ) return iter . next ( ) . service ; return null ; } List services = matchingServices ( tmpl . serviceTypes ) ; long now = System . currentTimeMillis ( ) ; int slen = services . size ( ) ; if ( slen == NUM_ ) return null ; int srand = Math . abs ( random . nextInt ( ) % slen ) ; for ( int i = NUM_ ; i < slen ; i ++ ) { SvcReg reg = ( SvcReg ) services . get ( ( i + srand ) % slen ) ; if ( reg . leaseExpiration > now && matchAttributes ( tmpl , reg . item ) ) return reg . item . service ; } return null ; }
@ Override public boolean runAfter ( List tasks , int size ) { for ( int i = NUM_ ; i < size ; i ++ ) { CacheTask t = ( CacheTask ) tasks . get ( i ) ; if ( t instanceof RegisterListenerTask || t instanceof LookupTask ) { ProxyReg otherReg = t . getProxyReg ( ) ; if ( reg . equals ( otherReg ) ) { if ( thisTaskSeqN > t . getSeqN ( ) ) return BOOL_ ; } } } return super . runAfter ( tasks , size ) ; }
String generateKey ( ) throws OracleException { byte [ ] data = null ; try { data = HashFuncs . getRandom ( ) ; } catch ( Exception e ) { if ( OracleLog . isLoggingEnabled ( ) ) log . warning ( e . toString ( ) ) ; } if ( data == null ) { data = fetchGuid ( ) ; } if ( data == null ) { throw SODAUtils . makeException ( SODAMessage . EX_UNABLE_TO_CREATE_UUID ) ; } return ( ByteArray . rawToHex ( data ) ) ; }
public double [ ] arrayCopy ( ) { double [ ] array = new double [ length ( ) ] ; for ( IndexValue iv : this ) array [ iv . getIndex ( ) ] = iv . getValue ( ) ; return array ; }
public static void delete ( Path path ) { if ( path != null ) { path = path . toAbsolutePath ( ) ; if ( inTargetDir ( path ) ) { try { IoUtil . delete ( path ) ; } catch ( IOException e ) { printError ( STR_ + path . toAbsolutePath ( ) + STR_ , e ) ; } } else { printError ( STR_ + path ) ; } } }
private static boolean parse ( Class < ? > service , URL u ) throws ServiceConfigurationError { InputStream in = null ; BufferedReader r = null ; try { in = u . openStream ( ) ; r = new BufferedReader ( new InputStreamReader ( in , STR_ ) ) ; int lc = NUM_ ; String ln ; while ( ( ln = r . readLine ( ) ) != null ) { int ci = ln . indexOf ( STR_ ) ; if ( ci >= NUM_ ) ln = ln . substring ( NUM_ , ci ) ; ln = ln . trim ( ) ; int n = ln . length ( ) ; if ( n != NUM_ ) { if ( ( ln . indexOf ( STR_ ) >= NUM_ ) || ( ln . indexOf ( STR_ ) >= NUM_ ) ) fail ( service , u , lc , STR_ ) ; int cp = ln . codePointAt ( NUM_ ) ; if ( ! Character . isJavaIdentifierStart ( cp ) ) fail ( service , u , lc , STR_ + ln ) ; for ( int i = Character . charCount ( cp ) ; i < n ; i += Character . charCount ( cp ) ) { cp = ln . codePointAt ( i ) ; if ( ! Character . isJavaIdentifierPart ( cp ) && ( cp != STR_ ) ) fail ( service , u , lc , STR_ + ln ) ; } return BOOL_ ; } } } catch ( FileNotFoundException x ) { return BOOL_ ; } catch ( IOException x ) { fail ( service , STR_ + x ) ; } finally { try { if ( r != null ) r . close ( ) ; } catch ( IOException y ) { fail ( service , STR_ + y ) ; } try { if ( in != null ) in . close ( ) ; } catch ( IOException y ) { fail ( service , STR_ + y ) ; } } return BOOL_ ; }
private void initPattern ( ) { StringBuffer patternTemplateRegex = new StringBuffer ( ) ; logger . debug ( STR_ ) ; Matcher placeholderMatcher = getPlaceholderMatcher ( ) ; logger . debug ( STR_ ) ; while ( placeholderMatcher . find ( ) ) { String group = placeholderMatcher . group ( NUM_ ) ; if ( ! groups . contains ( group ) ) { logger . trace ( STR_ ) ; groups . add ( group ) ; String groupRegex = getGroupRegex ( group ) ; placeholderMatcher . appendReplacement ( patternTemplateRegex , Matcher . quoteReplacement ( STR_ + group + STR_ + groupRegex + STR_ ) ) ; } else { logger . trace ( STR_ ) ; placeholderMatcher . appendReplacement ( patternTemplateRegex , Matcher . quoteReplacement ( STR_ + group + STR_ ) ) ; } } placeholderMatcher . appendTail ( patternTemplateRegex ) ; String patternRegex = patternTemplateRegex . toString ( ) ; logger . debug ( STR_ + patternRegex ) ; pattern = Pattern . compile ( patternRegex ) ; }
protected void newLine ( PrintWriter file , String string , boolean isManifest ) { String [ ] lines = string . split ( NEW_LINE ) ; for ( String line : lines ) { String [ ] words = line . split ( SPACE ) ; StringBuffer sb = new StringBuffer ( ) ; for ( String word : words ) { if ( checkStringLength ( sb . toString ( ) + word , isManifest ) ) { sb . append ( word + SPACE ) ; } else { sb . setLength ( sb . length ( ) - NUM_ ) ; addLine ( file , sb . toString ( ) ) ; sb = new StringBuffer ( word + SPACE ) ; } } if ( sb . length ( ) > NUM_ ) { sb . setLength ( sb . length ( ) - NUM_ ) ; } addLine ( file , sb . toString ( ) ) ; } }
protected boolean updateAttachmentPoint ( ) { boolean moved = BOOL_ ; this . oldAPs = attachmentPoints ; if ( attachmentPoints == null || attachmentPoints . isEmpty ( ) ) return BOOL_ ; List < AttachmentPoint > apList = new ArrayList < AttachmentPoint > ( ) ; if ( attachmentPoints != null ) apList . addAll ( attachmentPoints ) ; Map < Long , AttachmentPoint > newMap = getAPMap ( apList ) ; if ( newMap == null || newMap . size ( ) != apList . size ( ) ) { moved = BOOL_ ; } if ( moved ) { log . info ( STR_ , attachmentPoints , newMap ) ; List < AttachmentPoint > newAPList = new ArrayList < AttachmentPoint > ( ) ; if ( newMap != null ) newAPList . addAll ( newMap . values ( ) ) ; this . attachmentPoints = newAPList ; } return moved ; }
public List < SoftWrapImpl > removeStartingFrom ( int offset ) { int startIndex = getSoftWrapIndex ( offset ) ; if ( startIndex < NUM_ ) { startIndex = - startIndex - NUM_ ; } if ( startIndex >= myWraps . size ( ) ) { return Collections . emptyList ( ) ; } List < SoftWrapImpl > tail = myWraps . subList ( startIndex , myWraps . size ( ) ) ; List < SoftWrapImpl > result = new ArrayList < SoftWrapImpl > ( tail ) ; tail . clear ( ) ; return result ; }
public static String formatDps ( final double dps ) { return STR_ + String . format ( STR_ , dps ) + STR_ ; }
public static String truncate ( String string , int length ) { if ( string . length ( ) > length ) { string = string . substring ( NUM_ , length ) ; } return string ; }
private static String escapeJSON ( String text ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( STR_ ) ; for ( int index = NUM_ ; index < text . length ( ) ; index ++ ) { char chr = text . charAt ( index ) ; switch ( chr ) { case STR_ : case STR_ : builder . append ( STR_ ) ; builder . append ( chr ) ; break ; case STR_ : builder . append ( STR_ ) ; break ; case STR_ : builder . append ( STR_ ) ; break ; case STR_ : builder . append ( STR_ ) ; break ; case STR_ : builder . append ( STR_ ) ; break ; default : if ( chr < STR_ ) { String t = STR_ + Integer . toHexString ( chr ) ; builder . append ( STR_ + t . substring ( t . length ( ) - NUM_ ) ) ; } else { builder . append ( chr ) ; } break ; } } builder . append ( STR_ ) ; return builder . toString ( ) ; }
@ SuppressWarnings ( STR_ ) public SortedSet < E > subSet ( E start , E end ) { return subSet ( start , BOOL_ , end , BOOL_ ) ; }
private boolean checkDisband ( Legion legion ) { if ( legion . isDisbanding ( ) ) { if ( ( System . currentTimeMillis ( ) / NUM_ ) > legion . getDisbandTime ( ) ) { disbandLegion ( legion ) ; return BOOL_ ; } } return BOOL_ ; }
public void index ( Tuple t , String field ) { String s ; if ( ( s = t . getString ( field ) ) == null ) return ; StringTokenizer st = new StringTokenizer ( s , m_delim ) ; while ( st . hasMoreTokens ( ) ) { String tok = st . nextToken ( ) ; addString ( tok , t ) ; } }
public static void downto ( float self , Number to , @ ClosureParams ( FirstParam . class ) Closure closure ) { float to1 = to . floatValue ( ) ; if ( self >= to1 ) { for ( float i = self ; i >= to1 ; i -- ) { closure . call ( i ) ; } } else throw new GroovyRuntimeException ( STR_ + to + STR_ + self + STR_ ) ; }
protected void parseDOMAttributes ( Element element ) throws SAML2Exception { requestId = element . getAttribute ( SAML2Constants . ID ) ; validateID ( requestId ) ; version = element . getAttribute ( SAML2Constants . VERSION ) ; validateVersion ( version ) ; String issueInstantStr = element . getAttribute ( SAML2Constants . ISSUE_INSTANT ) ; validateIssueInstant ( issueInstantStr ) ; destinationURI = element . getAttribute ( SAML2Constants . DESTINATION ) ; consent = element . getAttribute ( SAML2Constants . CONSENT ) ; }
protected int readFully ( InputStream in , byte buffer [ ] ) throws java . io . IOException { for ( int i = NUM_ ; i < buffer . length ; i ++ ) { int q = in . read ( ) ; if ( q == - NUM_ ) return i ; buffer [ i ] = ( byte ) q ; } return buffer . length ; }
@ CalledByNative private static void insertFullscreenInfoIntoList ( ArrayList < FullscreenInfo > list , String origin , String embedder ) { list . add ( new FullscreenInfo ( origin , embedder , BOOL_ ) ) ; }
public static InputStream streamFromString ( String location ) throws IOException { InputStream is = null ; URL url = urlFromString ( location , null , BOOL_ ) ; if ( url != null ) { is = url . openStream ( ) ; } else { File f = new File ( location ) ; if ( f . exists ( ) ) is = new FileInputStream ( f ) ; } if ( is == null ) { return null ; } else if ( isGZipFile ( location ) ) { return new GZIPInputStream ( is ) ; } else { return is ; } }
public void add ( T item ) { synchronized ( lock ) { items . add ( identifiedItemFactory . create ( item ) ) ; } notifyDataSetChanged ( ) ; }
private void copyACLs ( List < UnManagedCifsShareACL > origACLList , List < CifsShareACL > shareACLList , FileShare fileshare ) { CifsShareACL shareACL = null ; for ( UnManagedCifsShareACL origACL : origACLList ) { shareACL = new CifsShareACL ( ) ; shareACL . setId ( URIUtil . createId ( CifsShareACL . class ) ) ; shareACL . setUser ( origACL . getUser ( ) ) ; shareACL . setPermission ( origACL . getPermission ( ) ) ; shareACL . setShareName ( origACL . getShareName ( ) ) ; shareACL . setFileSystemId ( fileshare . getId ( ) ) ; shareACLList . add ( shareACL ) ; _logger . info ( STR_ , shareACL . toString ( ) ) ; } }
public ResourceListParser parse ( ) throws ParserConfigurationException , SAXException , ParseFailureException { try { SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; SAXParser parser = factory . newSAXParser ( ) ; parser . parse ( mInputSource , this ) ; return this ; } catch ( IOException e ) { throw new ParseFailureException ( STR_ , e ) ; } }
public Builder deleteEntitlements ( ) { deleteFields . add ( STR_ ) ; return this ; }
protected void incorporateSignedProperties ( ) throws DSSException { signedPropertiesDom = DSSXMLUtils . addElement ( documentDom , qualifyingPropertiesDom , XAdES , XADES_SIGNED_PROPERTIES ) ; signedPropertiesDom . setAttribute ( ID , STR_ + deterministicId ) ; incorporateSignedSignatureProperties ( ) ; }
private ChannelSelection createChannelSelection ( StyleFactoryImpl styleFactory , ContrastMethod contrastMethod ) { ContrastEnhancement contrastEnhancement = ( ContrastEnhancement ) styleFactory . contrastEnhancement ( null , contrastMethod . name ( ) ) ; FilterFactory ff = CommonFactoryFinder . getFilterFactory ( ) ; Map < String , Expression > options = contrastEnhancement . getOptions ( ) ; options . put ( STR_ , ff . literal ( STR_ ) ) ; options . put ( STR_ , ff . literal ( STR_ ) ) ; options . put ( STR_ , ff . literal ( STR_ ) ) ; SelectedChannelType channelType = styleFactory . createSelectedChannelType ( STR_ , contrastEnhancement ) ; SelectedChannelType [ ] channels = new SelectedChannelType [ NUM_ ] ; channels [ NUM_ ] = channelType ; channels [ NUM_ ] = channelType ; channels [ NUM_ ] = channelType ; ChannelSelection channelSelection = styleFactory . createChannelSelection ( channels ) ; return channelSelection ; }
public static float mean ( float [ ] data , int [ ] inds ) { float mean = NUM_ ; for ( int i = NUM_ ; i < inds . length ; i ++ ) { if ( Float . isNaN ( data [ inds [ i ] ] ) ) throw new IllegalArgumentException ( STR_ ) ; mean += data [ inds [ i ] ] ; } mean /= inds . length ; return mean ; }
public int depth ( ) { return pointer ; }
public Result doComparisonTest ( Properties properties ) throws Exception { final long timeout = Long . parseLong ( properties . getProperty ( TestOptions . TIMEOUT ) ) ; final int ntrials = Integer . parseInt ( properties . getProperty ( TestOptions . NTRIALS ) ) ; final int nclients = Integer . parseInt ( properties . getProperty ( TestOptions . NCLIENTS ) ) ; final double percentReaders = Double . parseDouble ( properties . getProperty ( TestOptions . PERCENT_READERS ) ) ; final double percentWritersWillFlush = Double . parseDouble ( properties . getProperty ( TestOptions . PERCENT_WRITER_WILL_FLUSH ) ) ; final int reclen = Integer . parseInt ( properties . getProperty ( TestOptions . RECLEN ) ) ; final int nwritesPerTask = Integer . parseInt ( properties . getProperty ( TestOptions . NWRITES ) ) ; final int nreadsPerTask = Integer . parseInt ( properties . getProperty ( TestOptions . NREADS ) ) ; final AtomicInteger nerr = new AtomicInteger ( ) ; final Result result = doMRMWTest ( store , timeout , ntrials , nclients , percentReaders , percentWritersWillFlush , reclen , nwritesPerTask , nreadsPerTask , nerr ) ; return result ; }
private void cmd_import ( ) { JFileChooser jc = new JFileChooser ( ) ; jc . setDialogTitle ( Msg . getMsg ( Env . getCtx ( ) , STR_ ) ) ; jc . setDialogType ( JFileChooser . OPEN_DIALOG ) ; jc . setFileSelectionMode ( JFileChooser . FILES_ONLY ) ; if ( jc . showOpenDialog ( this ) != JFileChooser . APPROVE_OPTION ) return ; StringBuffer sb = new StringBuffer ( ) ; try { InputStreamReader in = new InputStreamReader ( new FileInputStream ( jc . getSelectedFile ( ) ) ) ; char [ ] cbuf = new char [ NUM_ ] ; int count ; while ( ( count = in . read ( cbuf ) ) > NUM_ ) sb . append ( cbuf , NUM_ , count ) ; in . close ( ) ; } catch ( Exception e ) { log . log ( Level . SEVERE , STR_ + e . getMessage ( ) ) ; return ; } setHtmlText ( sb . toString ( ) ) ; }
private List < String > fetchFileCosIdList ( ) throws SOSFailure { final String methodName = STR_ ; log . trace ( methodName + STR_ ) ; final String FILE_COS_URI = STR_ ; List < String > fileCosIdList = new ArrayList < String > ( ) ; try { CoSList cosElemList = _client . queryObject ( FILE_COS_URI , CoSList . class ) ; if ( cosElemList != null && cosElemList . getCosElements ( ) != null ) { for ( CoSElement elem : cosElemList . getCosElements ( ) ) { if ( elem != null ) { fileCosIdList . add ( elem . getId ( ) ) ; } } } log . trace ( methodName + STR_ + fileCosIdList ) ; if ( cosElemList != null && fileCosIdList != null ) { log . trace ( methodName + STR_ + fileCosIdList . size ( ) + STR_ ) ; return fileCosIdList ; } log . trace ( methodName + STR_ ) ; return new ArrayList < String > ( ) ; } catch ( NoSuchAlgorithmException e ) { log . error ( methodName + STR_ , e ) ; throw new SOSFailure ( e ) ; } catch ( UniformInterfaceException e ) { log . error ( methodName + STR_ , e ) ; throw new SOSFailure ( e ) ; } }
public void monitor ( ScalingStateMonitorTask task ) { taskQueue . add ( task ) ; startMonitor ( ) ; }
public void insertNodeInto ( MutableTreeNode newChild , MutableTreeNode parent , int index ) { parent . insert ( newChild , index ) ; int [ ] newIndexs = new int [ NUM_ ] ; newIndexs [ NUM_ ] = index ; nodesWereInserted ( parent , newIndexs ) ; }
public final double sampleMax ( ) { long max = _max . getAndSet ( NUM_ ) ; return _scale . max ; }
private static void writeFile ( File file , List < String > lines ) throws IOException { if ( ! file . exists ( ) ) file . createNewFile ( ) ; FileWriter fw = new FileWriter ( file ) ; BufferedWriter Bw = new BufferedWriter ( fw ) ; PrintWriter pw = new PrintWriter ( Bw ) ; for ( String line : lines ) pw . println ( line ) ; Bw . close ( ) ; fw . close ( ) ; pw . close ( ) ; }
public synchronized boolean verifyChunkAuthTag ( int chunkIdx , byte [ ] chunkAuthTag ) throws FileEncryptionException { if ( ( chunkIdx < NUM_ ) || ( chunkAuthTag == null ) || ( chunkAuthTag . length != backEncRandomAccessFile . CHUNK_TLEN ) ) { throw new FileEncryptionException ( STR_ ) ; } else { byte [ ] storedAuthTag = atagList . get ( chunkIdx ) ; if ( storedAuthTag == null || ! Arrays . equals ( chunkAuthTag , storedAuthTag ) ) { return BOOL_ ; } else { return BOOL_ ; } } }
public static String guessMimeTypeFromExtension ( String extension ) { if ( extension == null || extension . isEmpty ( ) ) { return null ; } return extensionToMimeTypeMap . get ( extension ) ; }
public < AnnotationType extends Annotation > void register ( MethodBinder < AnnotationType > methodBinder ) { Set < AnnotatedMethod < AnnotationType > > annotatedMethods = AnnotatedMethods . get ( methodBinder . getAnnotationClass ( ) , annotatedType ) ; if ( ! annotatedMethods . isEmpty ( ) ) { objectBinders . add ( new AnnotatedMethodBinder < > ( methodBinder , annotatedMethods ) ) ; } }
public static String removeNewLineChars ( String s ) { String retString = null ; if ( ( s != null ) && ( s . length ( ) > NUM_ ) && ( s . indexOf ( STR_ ) != - NUM_ ) ) { char [ ] chars = s . toCharArray ( ) ; int len = chars . length ; StringBuffer sb = new StringBuffer ( len ) ; for ( int i = NUM_ ; i < len ; i ++ ) { char c = chars [ i ] ; if ( c != STR_ ) { sb . append ( c ) ; } } retString = sb . toString ( ) ; } else { retString = s ; } return retString ; }
private Document parseRouteFile ( ) throws Exception { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; factory . setNamespaceAware ( BOOL_ ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; return builder . parse ( routeFile ) ; }
public void removeDTEDDirectoryHandler ( DTEDDirectoryHandler handler ) { directories . remove ( handler ) ; }
public default void addFile ( final ContentProvider contentProvider , final String fileName , final EntryInformation entryInformation ) throws IOException { addFile ( contentProvider , fileName , entryInformation , Optional . empty ( ) ) ; }
public synchronized void writeTo ( OutputStream out ) throws IOException { int remaining = count ; for ( byte [ ] buf : buffers ) { int c = Math . min ( buf . length , remaining ) ; out . write ( buf , NUM_ , c ) ; remaining -= c ; if ( remaining == NUM_ ) { break ; } } }
protected void read_lookahead ( ) throws java . lang . Exception { lookahead = new Symbol [ error_sync_size ( ) ] ; for ( int i = NUM_ ; i < error_sync_size ( ) ; i ++ ) { lookahead [ i ] = cur_token ; cur_token = scan ( ) ; } lookahead_pos = NUM_ ; }
private Vector < SnmpVarBind > splitFrom ( Vector < SnmpVarBind > original , int limit ) { int max = original . size ( ) ; Vector < SnmpVarBind > result = new Vector < > ( max - limit ) ; int i = limit ; for ( Enumeration < SnmpVarBind > e = original . elements ( ) ; e . hasMoreElements ( ) ; -- i ) { SnmpVarBind var = e . nextElement ( ) ; if ( i > NUM_ ) continue ; result . addElement ( new SnmpVarBind ( var . oid , var . value ) ) ; } return result ; }
public static void initUrbanSimZoneWriter ( Config config ) { UrbanSimParameterConfigModuleV3 module = ( UrbanSimParameterConfigModuleV3 ) config . getModule ( UrbanSimParameterConfigModuleV3 . GROUP_NAME ) ; try { log . info ( STR_ ) ; parcelWriter = IOUtils . getBufferedWriter ( module . getMATSim4OpusTemp ( ) + FILE_NAME ) ; log . info ( STR_ + module . getMATSim4OpusTemp ( ) + FILE_NAME + STR_ ) ; parcelWriter . write ( InternalConstants . PARCEL_ID + STR_ + ACCESSIBILITY_BY_FREESPEED + STR_ + ACCESSIBILITY_BY_CAR + STR_ + ACCESSIBILITY_BY_BIKE + STR_ + ACCESSIBILITY_BY_WALK + STR_ + ACCESSIBILITY_BY_PT ) ; parcelWriter . newLine ( ) ; log . info ( STR_ ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
@ Override public void onReset ( ) { closeDialog ( ) ; }
public final void delayTask ( @ NotNull TransactionRunnable task ) { myDelayedTasks . add ( task ) ; }
public TextEditor replaceAll ( String regex , String replacement ) { if ( text . length ( ) > NUM_ ) { final String r = replacement ; Pattern p = Pattern . compile ( regex , Pattern . MULTILINE ) ; Matcher m = p . matcher ( text ) ; StringBuffer sb = new StringBuffer ( ) ; while ( m . find ( ) ) { m . appendReplacement ( sb , r ) ; } m . appendTail ( sb ) ; text = new StringBuilder ( sb . toString ( ) ) ; } return this ; }
private static < T > int migrateAll ( Migration < T > migration ) throws Exception { int migrated = NUM_ ; for ( T entity : migration . getAllEntities ( ) ) { try { if ( migration . isMigrated ( entity ) ) continue ; } catch ( Exception x ) { LOG . error ( STR_ , entity ) ; throw x ; } try { migration . migrate ( entity ) ; } catch ( Exception x ) { LOG . error ( STR_ , entity ) ; throw x ; } migrated ++ ; } return migrated ; }
private void captureDifferentString ( String oldString , String newString , Map < String , String > map , String appName ) { Reject . ifNull ( appName ) ; Reject . ifNull ( map ) ; if ( oldString == null ? newString != null : ! oldString . equals ( newString ) ) { map . put ( appName , newString ) ; } }
public void onChildThreadResumeBegin ( ) { _threadCount . incrementAndGet ( ) ; }
public static String encodeToString ( byte [ ] src ) { if ( src == null ) { return null ; } if ( src . length == NUM_ ) { return STR_ ; } String result ; try { result = new String ( delegate . encode ( src ) , DEFAULT_CHARSET . displayName ( ) ) ; } catch ( UnsupportedEncodingException e ) { throw new IllegalStateException ( e ) ; } return result ; }
public static byte [ ] decode ( String str , int flags ) { return decode ( str . getBytes ( ) , flags ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) { return BOOL_ ; } if ( obj instanceof ECFieldF2m ) { ECFieldF2m o = ( ECFieldF2m ) obj ; if ( this . m == o . m ) { if ( this . rp == null ) { if ( o . rp == null ) { return BOOL_ ; } } else { return Arrays . equals ( this . ks , o . ks ) ; } } } return BOOL_ ; }
public static void chunkTaskSync ( RegionWrapper region , final RunnableVal < int [ ] > task ) { final int p1x = region . minX ; final int p1z = region . minZ ; final int p2x = region . maxX ; final int p2z = region . maxZ ; final int bcx = p1x > > NUM_ ; final int bcz = p1z > > NUM_ ; final int tcx = p2x > > NUM_ ; final int tcz = p2z > > NUM_ ; task . value = new int [ NUM_ ] ; for ( int x = bcx ; x <= tcx ; x ++ ) { for ( int z = bcz ; z <= tcz ; z ++ ) { task . value [ NUM_ ] = x ; task . value [ NUM_ ] = z ; task . value [ NUM_ ] = task . value [ NUM_ ] << NUM_ ; task . value [ NUM_ ] = task . value [ NUM_ ] << NUM_ ; task . value [ NUM_ ] = task . value [ NUM_ ] + NUM_ ; task . value [ NUM_ ] = task . value [ NUM_ ] + NUM_ ; task . value [ NUM_ ] = NUM_ ; if ( task . value [ NUM_ ] == bcx ) { task . value [ NUM_ ] = p1x ; task . value [ NUM_ ] = NUM_ ; } if ( task . value [ NUM_ ] == tcx ) { task . value [ NUM_ ] = p2x ; task . value [ NUM_ ] = NUM_ ; } if ( task . value [ NUM_ ] == bcz ) { task . value [ NUM_ ] = p1z ; task . value [ NUM_ ] = NUM_ ; } if ( task . value [ NUM_ ] == tcz ) { task . value [ NUM_ ] = p2z ; task . value [ NUM_ ] = NUM_ ; } task . run ( ) ; } } }
public ElsaSerializerPojo make ( ) { return new ElsaSerializerPojo ( objectStack , singletons , registeredSers , registeredSerHeaders , registeredDeser , unknownClassNotification , new ElsaClassInfoResolver . ArrayBased ( classes . toArray ( new Class [ NUM_ ] ) ) ) ; }
private void loadBinary ( InputStream is ) throws IOException { if ( is instanceof FileInputStream ) { FileInputStream fis = ( FileInputStream ) is ; FileChannel fc = fis . getChannel ( ) ; MappedByteBuffer bb = fc . map ( FileChannel . MapMode . READ_ONLY , NUM_ , ( int ) fc . size ( ) ) ; bb . load ( ) ; loadBinary ( bb ) ; is . close ( ) ; } else { loadBinary ( new DataInputStream ( is ) ) ; } }
private static boolean isTwoSlotType ( ClassNode type ) { return type == ClassHelper . long_TYPE || type == ClassHelper . double_TYPE ; }
public SpecificationRunnerBuilder sections ( String [ ] paramSections ) { Collections . addAll ( this . sections , paramSections ) ; return this ; }
private void consumeCRLF ( ) throws DecodingException { char next = nextChar ( ) ; if ( next != STR_ ) { consumeChar ( STR_ ) ; } consumeChar ( STR_ ) ; }
private String processLogoutRequest ( LogoutState t , LogoutRequest logoutRequest , SessionManager sessionManager ) throws SamlServiceException { String sessionId = null ; List < SessionIndex > sessionList = logoutRequest . getSessionIndexes ( ) ; Validate . notNull ( sessionList , STR_ ) ; Validate . isTrue ( sessionList . size ( ) > NUM_ ) ; for ( SessionIndex sessionIndex : sessionList ) { Validate . notNull ( sessionIndex ) ; String participantSession = sessionIndex . getSessionIndex ( ) ; Validate . notNull ( participantSession , STR_ ) ; Session session = sessionManager . getByParticipant ( participantSession ) ; if ( session == null ) { throw new SamlServiceException ( STR_ ) ; } if ( ! session . containsSessionParticipantUrl ( t . getIssuerValue ( ) ) ) { throw new SamlServiceException ( STR_ ) ; } if ( sessionId == null ) { sessionId = session . getId ( ) ; } else { if ( ! sessionId . equals ( session . getId ( ) ) ) { throw new SamlServiceException ( STR_ ) ; } } } return sessionId ; }
public boolean equals ( Object o ) { if ( o instanceof CoverageIntVdt ) { CoverageIntVdt civ = ( CoverageIntVdt ) o ; return ( ( attribute == civ . attribute ) && ( value == civ . value ) ) ; } else { return BOOL_ ; } }
public void accept ( final Path file ) throws InterruptedException { logger . info ( String . format ( STR_ , file ) ) ; permits . acquire ( ) ; executor . execute ( new ConsumerTask ( file ) ) ; }
private void addOptionList ( final List < String > args , final String optName , final List < String > values ) { for ( final String value : values ) { if ( value != null && ! value . isEmpty ( ) ) { args . add ( optName ) ; args . add ( value ) ; } } }
public void testNegPosFirstShorter ( ) { byte aBytes [ ] = { - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { - NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ } ; int aSign = - NUM_ ; int bSign = NUM_ ; byte rBytes [ ] = { - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . or ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , - NUM_ , result . signum ( ) ) ; }
private Activity checkActivity ( ) { Activity activity = mActivity . get ( ) ; if ( activity == null ) { throw new IllegalStateException ( STR_ ) ; } return activity ; }
@ Override public synchronized void start ( ) { LOGGER . info ( STR_ ) ; timer = new Timer ( STR_ ) ; timer . schedule ( this , INITIAL_SCAN_DELAY , SCAN_INTERVAL ) ; running = BOOL_ ; }
public boolean isLandingPage ( URL url ) { if ( url . getQuery ( ) != null ) { return BOOL_ ; } else { return landingPageSuffix ( url ) != STR_ ; } }
protected static void writeRowCountDefinitions ( TableCreator creator , ByteBuffer buffer ) { writeRowCountDefinitions ( creator , buffer , creator . getIndexCount ( ) ) ; }
public void send ( String theString ) { send ( theString . getBytes ( ) ) ; }
public void init ( ) { _tokenMgmtExecutor . scheduleWithFixedDelay ( new ExpiredTokenCleaner ( ) , NUM_ , _maxLifeValuesHolder . getMaxTokenIdleTimeInMins ( ) , TimeUnit . MINUTES ) ; _tokenMgmtExecutor . scheduleWithFixedDelay ( new TokenKeysUpdater ( ) , NUM_ , FOREIGN_TOKEN_KEYS_BUNDLE_REFRESH_RATE_IN_MINS , TimeUnit . MINUTES ) ; }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case NUM_ : return PATH ; case NUM_ : return OFFSET_LBA ; default : return null ; } }
public String toString ( ) { return STR_ + String . valueOf ( bean ) + STR_ ; }
private static String doGetPath ( String filename , int separatorAdd ) { if ( filename == null ) { return null ; } int prefix = getPrefixLength ( filename ) ; if ( prefix < NUM_ ) { return null ; } int index = indexOfLastSeparator ( filename ) ; int endIndex = index + separatorAdd ; if ( prefix >= filename . length ( ) || index < NUM_ || prefix >= endIndex ) { return STR_ ; } return filename . substring ( prefix , endIndex ) ; }
public Spanned [ ] history ( ) { int i = NUM_ ; Spanned [ ] array = new Spanned [ history . size ( ) ] ; for ( String s : history ) { if ( s != null ) { array [ i ] = Html . fromHtml ( s ) ; i ++ ; } } return array ; }
private void sign ( final byte [ ] contentBytes , final ByteArrayOutputStream mimeContent ) throws Exception { String algId = conf . getSignatureAlgorithmId ( ) ; String keyId = conf . getActiveSigningKey ( ) ; log . debug ( STR_ + STR_ , keyId , algId ) ; String signature = signHelper ( keyId , algId , contentBytes ) ; mimeContent . write ( envelopeHeader . getBytes ( ) ) ; try ( MultipartEncoder encoder = new MultipartEncoder ( mimeContent , envelopeBoundary ) ) { encoder . startPart ( mpMixedContentType ( dataBoundary ) ) ; encoder . write ( contentBytes ) ; String algURI = CryptoUtils . getSignatureAlgorithmURI ( algId ) ; String hashURI = hashCalculator . getAlgoURI ( ) ; Path verificatioCertPath = conf . getCertPath ( keyId ) ; encoder . startPart ( MimeTypes . BINARY , new String [ ] { HEADER_CONTENT_TRANSFER_ENCODING + STR_ , HEADER_SIG_ALGO_ID + STR_ + algURI , HEADER_VERIFICATION_CERT_HASH + STR_ + getVerificationCertHash ( verificatioCertPath ) + STR_ + HEADER_HASH_ALGORITHM_ID + STR_ + hashURI } ) ; encoder . write ( signature . getBytes ( ) ) ; } log . debug ( STR_ , mimeContent . toString ( ) ) ; Files . write ( tempConfPath , mimeContent . toByteArray ( ) ) ; log . debug ( STR_ , tempConfPath ) ; }
private boolean nextItemIs ( String match ) throws IOException { int c ; while ( isWhiteSpace ( c = buf . get ( ) ) ) { } for ( int i = NUM_ ; i < match . length ( ) ; i ++ ) { if ( i > NUM_ ) { c = buf . get ( ) ; } if ( c != match . charAt ( i ) ) { return BOOL_ ; } } return BOOL_ ; }
public static Object deserializeObject ( final byte [ ] objBytes , final ClassLoader loader ) throws IOException , ClassNotFoundException { ObjectInputStream objIn = null ; try { objIn = new ClassLoaderObjectInputStream ( new ByteArrayInputStream ( objBytes ) , loader ) ; return objIn . readObject ( ) ; } finally { close ( objIn ) ; } }
public IntervalImpl ( int serialNum , long startIntervalDateTime , double coverageFactor , FramingFlowType intervalDataType , ISource source , IIntervalClassification intervalClassification , Version adeVersion ) throws AdeInternalException { a_adeVersion = adeVersion ; if ( startIntervalDateTime < NUM_ ) { throw new IllegalArgumentException ( String . format ( STR_ + STR_ + STR_ + STR_ , serialNum , startIntervalDateTime , coverageFactor , intervalDataType , source , intervalClassification , adeVersion ) ) ; } m_startIntervalTime = startIntervalDateTime ; m_framingFlowType = intervalDataType ; m_serialNum = serialNum ; m_intervalClassification = intervalClassification ; if ( m_intervalClassification == null ) { m_intervalClassification = IntervalClassificationEnum . REGULAR ; } m_messageSummaryMap = new TreeMap < Integer , IMessageSummary > ( ) ; m_endIntervalTime = m_startIntervalTime + m_framingFlowType . getDuration ( ) ; m_source = source ; if ( coverageFactor <= NUM_ || coverageFactor > NUM_ ) { throw new AdeInternalException ( STR_ + coverageFactor ) ; } m_coverageFactor = coverageFactor ; }
public static boolean isTrue ( Map < String , Object > dict , String key ) { return isTrue ( dict , key , BOOL_ ) ; }
public OutputStream bindStream ( OutputStream output ) { OutputStream stream = m_streams . get ( ) ; m_streams . set ( output ) ; return stream ; }
private void initMapLayer ( ) { float zoom = getInitZoom ( mapView . getWidth ( ) , mapView . getHeight ( ) , image . getWidth ( ) , image . getHeight ( ) ) ; Log . i ( TAG , Float . toString ( zoom ) ) ; mapView . setCurrentZoom ( zoom , NUM_ , NUM_ ) ; float width = mapView . getWidth ( ) - zoom . image . getWidth ( ) ; float height = mapView . getHeight ( ) - zoom . image . getHeight ( ) ; mapView . translate ( width / NUM_ , height / NUM_ ) ; }
public static void evolve ( Permutation p1 , Permutation p2 ) { int n = p1 . size ( ) ; if ( n != p2 . size ( ) ) { throw new FrameworkException ( STR_ ) ; } int cuttingPoint1 = PRNG . nextInt ( n ) ; int cuttingPoint2 = PRNG . nextInt ( n - NUM_ ) ; if ( cuttingPoint1 == cuttingPoint2 ) { cuttingPoint2 = n - NUM_ ; } else if ( cuttingPoint1 > cuttingPoint2 ) { int swap = cuttingPoint1 ; cuttingPoint1 = cuttingPoint2 ; cuttingPoint2 = swap ; } int [ ] parent1 = p1 . toArray ( ) ; int [ ] parent2 = p2 . toArray ( ) ; int [ ] offspring1 = new int [ n ] ; int [ ] offspring2 = new int [ n ] ; int [ ] replacement1 = new int [ n ] ; int [ ] replacement2 = new int [ n ] ; Arrays . fill ( replacement1 , - NUM_ ) ; Arrays . fill ( replacement2 , - NUM_ ) ; for ( int i = cuttingPoint1 ; i <= cuttingPoint2 ; i ++ ) { offspring1 [ i ] = parent2 [ i ] ; offspring2 [ i ] = parent1 [ i ] ; replacement1 [ parent2 [ i ] ] = parent1 [ i ] ; replacement2 [ parent1 [ i ] ] = parent2 [ i ] ; } for ( int i = NUM_ ; i < n ; i ++ ) { if ( ( i < cuttingPoint1 ) || ( i > cuttingPoint2 ) ) { int n1 = parent1 [ i ] ; int m1 = replacement1 [ n1 ] ; int n2 = parent2 [ i ] ; int m2 = replacement2 [ n2 ] ; while ( m1 != - NUM_ ) { n1 = m1 ; m1 = replacement1 [ m1 ] ; } while ( m2 != - NUM_ ) { n2 = m2 ; m2 = replacement2 [ m2 ] ; } offspring1 [ i ] = n1 ; offspring2 [ i ] = n2 ; } } p1 . fromArray ( offspring1 ) ; p2 . fromArray ( offspring2 ) ; }
private String extractSpan ( String spans , int start , int end ) throws IndexOutOfBoundsException { int offset = getFirstSpanOffset ( spans ) ; assert ( start >= offset ) ; assert ( end >= offset ) ; spans += HTML_OPEN_SPAN ; int substart = getSpanPos ( spans , start - offset ) ; int subend = getSpanPos ( spans , end - offset + NUM_ ) ; return spans . substring ( substart , subend ) ; }
public void finished ( long chainLength ) { currentState = chainLength ; if ( loggers != null ) { for ( Logger logger : loggers ) { logger . log ( currentState ) ; logger . stopLogging ( ) ; } } if ( showOperatorAnalysis ) { showOperatorAnalysis ( System . out ) ; } if ( operatorAnalysisFile != null ) { try { PrintStream out = new PrintStream ( new FileOutputStream ( operatorAnalysisFile ) ) ; showOperatorAnalysis ( out ) ; out . flush ( ) ; out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
public boolean hasDelay ( ) { return delay != - NUM_ ; }
void pushSpaceHandling ( Attributes attrs ) throws org . xml . sax . SAXParseException { String value = attrs . getValue ( STR_ ) ; if ( null == value ) { m_spacePreserveStack . push ( m_spacePreserveStack . peekOrFalse ( ) ) ; } else if ( value . equals ( STR_ ) ) { m_spacePreserveStack . push ( BOOL_ ) ; } else if ( value . equals ( STR_ ) ) { m_spacePreserveStack . push ( BOOL_ ) ; } else { SAXSourceLocator locator = getLocator ( ) ; ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; try { handler . error ( new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ILLEGAL_XMLSPACE_VALUE , null ) , locator ) ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXParseException ( te . getMessage ( ) , locator , te ) ; } m_spacePreserveStack . push ( m_spacePreserveStack . peek ( ) ) ; } }
@ SuppressWarnings ( STR_ ) public void registerDefaultDeviceTypes ( ) { final HashMap < String , String > devicesList = DefaultPlatform . getDeviceServiceMap ( ) ; for ( HashMap . Entry < String , String > entry : devicesList . entrySet ( ) ) { String key = entry . getKey ( ) ; String value = entry . getValue ( ) ; try { registerDeviceService ( ( Class < DeviceService > ) Class . forName ( key ) , ( Class < DiscoveryProvider > ) Class . forName ( value ) ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } } }
protected void positiveClose ( ) { freeContent ( ) ; }
public InputStreamReader ( java . io . InputStream is , java . lang . String enc ) throws java . io . UnsupportedEncodingException { internal = is ; this . enc = enc . intern ( ) ; }
public int serverDelivery ( Object message , Object consumer , int deliveryCount ) throws Exception { ProtonServerSenderContext protonSender = serverSenders . get ( consumer ) ; if ( protonSender != null ) { return protonSender . deliverMessage ( message , deliveryCount ) ; } return NUM_ ; }
public static String decode ( AbstractMessage msg , Boolean ext , int header ) { if ( ext == BOOL_ ) { return decode ( msg ) ; } return STR_ + header ; }
private Instance votedReclassifyExample ( Instance example ) throws Exception { int classVotes [ ] = new int [ getNumClasses ( ) ] ; for ( int i = NUM_ ; i < classVotes . length ; i ++ ) { classVotes [ i ] = NUM_ ; } for ( Enumeration < RuleList > e = new WekaEnumeration < RuleList > ( m_DecisionList ) ; e . hasMoreElements ( ) ; ) { RuleList rl = e . nextElement ( ) ; int classValue = ( int ) rl . classifyInstance ( example ) ; if ( classValue >= NUM_ ) { classVotes [ classValue ] ++ ; } } int maxVote = NUM_ ; int vote = - NUM_ ; for ( int i = NUM_ ; i < classVotes . length ; i ++ ) { if ( classVotes [ i ] > maxVote ) { maxVote = classVotes [ i ] ; vote = i ; } } if ( vote >= NUM_ ) { example . setClassValue ( vote ) ; } else { throw new Exception ( STR_ ) ; } return example ; }
private boolean journalRebuildRequired ( ) { final int redundantOpCompactThreshold = NUM_ ; return redundantOpCount >= redundantOpCompactThreshold && redundantOpCount >= lruEntries . size ( ) ; }
public final int hashCode ( ) { return System . identityHashCode ( this ) ; }
public DTMAxisIterator cloneIterator ( ) { _isRestartable = BOOL_ ; try { final PrecedingIterator clone = ( PrecedingIterator ) super . clone ( ) ; final int [ ] stackCopy = new int [ _stack . length ] ; System . arraycopy ( _stack , NUM_ , stackCopy , NUM_ , _stack . length ) ; clone . _stack = stackCopy ; return clone ; } catch ( CloneNotSupportedException e ) { throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ITERATOR_CLONE_NOT_SUPPORTED , null ) ) ; } }
private boolean keyChainContainsPrivateKey ( Collection < ECKey > keyChain , ECKey keyToAdd ) { if ( keyChain == null || keyToAdd == null ) { return BOOL_ ; } else { for ( ECKey loopKey : keyChain ) { if ( Arrays . equals ( keyToAdd . getPrivKeyBytes ( ) , loopKey . getPrivKeyBytes ( ) ) ) { return BOOL_ ; } } return BOOL_ ; } }
public ScriptBuilder data ( byte [ ] data ) { if ( data . length == NUM_ ) return smallNum ( NUM_ ) ; else return data ( chunks . size ( ) , data ) ; }
public RotationMatrixBuilder withThetas ( double theta ) { for ( Plane plane : planes ) { plane . setTheta ( theta ) ; } return this ; }
private void writeUserRegistry ( LocalContainer container , File configDir , Map < String , String > users , Map < String , List < String > > groups ) throws IOException { File usersXML = new File ( configDir , STR_ ) ; PrintStream writer = ServerConfigUtils . open ( usersXML ) ; writer . println ( STR_ ) ; for ( Map . Entry < String , String > user : users . entrySet ( ) ) { writer . print ( STR_ ) ; writer . print ( user . getKey ( ) ) ; writer . print ( STR_ ) ; writer . print ( user . getValue ( ) ) ; writer . println ( STR_ ) ; } for ( Map . Entry < String , List < String > > group : groups . entrySet ( ) ) { writer . print ( STR_ ) ; writer . print ( group . getKey ( ) ) ; writer . println ( STR_ ) ; for ( String member : group . getValue ( ) ) { writer . print ( STR_ ) ; writer . print ( member ) ; writer . println ( STR_ ) ; } writer . println ( STR_ ) ; } writer . println ( STR_ ) ; ServerConfigUtils . close ( writer ) ; }
public static String valueOf ( double value ) { return Double . toString ( value ) ; }
private static void decodeHanziSegment ( BitSource bits , StringBuilder result , int count ) throws FormatException { if ( count . NUM_ > bits . available ( ) ) { throw FormatException . getFormatInstance ( ) ; } byte [ ] buffer = new byte [ NUM_ . count ] ; int offset = NUM_ ; while ( count > NUM_ ) { int twoBytes = bits . readBits ( NUM_ ) ; int assembledTwoBytes = ( ( twoBytes / x060 ) << NUM_ ) | ( twoBytes % x060 ) ; if ( assembledTwoBytes < x003BF ) { assembledTwoBytes += x0A1A1 ; } else { assembledTwoBytes += x0A6A1 ; } buffer [ offset ] = ( byte ) ( ( assembledTwoBytes > > NUM_ ) & xFF ) ; buffer [ offset + NUM_ ] = ( byte ) ( assembledTwoBytes & xFF ) ; offset += NUM_ ; count -- ; } try { result . append ( new String ( buffer , StringUtils . GB2312 ) ) ; } catch ( UnsupportedEncodingException ignored ) { throw FormatException . getFormatInstance ( ) ; } }
@ GenIgnore static Record createRecord ( String name , String address , Class itf , JsonObject metadata ) { return createRecord ( name , address , itf . getName ( ) , metadata ) ; }
public StopwatchCPU ( ) { threadTimer = ManagementFactory . getThreadMXBean ( ) ; start = threadTimer . getCurrentThreadCpuTime ( ) ; }
public synchronized byte [ ] lookupAudio ( String inputtype , String locale , String voice , String outputparams , String style , String effects , String inputtext ) throws SQLException { if ( inputtype == null || locale == null || voice == null || inputtext == null ) { throw new NullPointerException ( STR_ ) ; } byte [ ] audio = null ; String query = STR_ + inputtype + STR_ + locale + STR_ + voice + STR_ + outputparams + STR_ + style + STR_ + effects + STR_ ; PreparedStatement st = connection . prepareStatement ( query ) ; st . setString ( NUM_ , inputtext ) ; ResultSet results = st . executeQuery ( ) ; if ( results . next ( ) ) { audio = results . getBytes ( NUM_ ) ; } return audio ; }
public void addCondition ( final Condition condition ) { conditions . add ( condition ) ; condition . setId ( conditionIdCounter ++ ) ; }
public static byte [ ] readBytesFromByteBuffer ( ByteBuffer byteBuffer ) { byte [ ] buffer = new byte [ byteBuffer . remaining ( ) ] ; byteBuffer . get ( buffer ) ; return buffer ; }
public void findPackageAndClass ( ) throws IOException { packageName = null ; className = null ; LineNumberReader reader = new LineNumberReader ( new FileReader ( inputFile ) ) ; try { while ( className == null || packageName == null ) { String line = reader . readLine ( ) ; if ( line == null ) break ; if ( packageName == null ) { Matcher matcher = PACKAGE_PATTERN . matcher ( line ) ; if ( matcher . find ( ) ) { packageName = matcher . group ( NUM_ ) ; } } if ( className == null ) { Matcher matcher = CLASS_PATTERN . matcher ( line ) ; if ( matcher . find ( ) ) { className = matcher . group ( NUM_ ) ; } } } if ( className == null ) { className = STR_ ; } } finally { reader . close ( ) ; } }
public static void log ( final String msg , final Throwable t ) { if ( DEBUG ) { log ( msg ) ; t . printStackTrace ( System . out ) ; } }
public static Set < URI > fetchRPTargetVirtualPools ( DbClient dbClient ) { Set < URI > rpProtectedTargetVPools = new HashSet < URI > ( ) ; try { List < URI > vpoolProtectionSettingsURIs = dbClient . queryByType ( VpoolProtectionVarraySettings . class , BOOL_ ) ; Iterator < VpoolProtectionVarraySettings > vPoolProtectionSettingsItr = dbClient . queryIterativeObjects ( VpoolProtectionVarraySettings . class , vpoolProtectionSettingsURIs , BOOL_ ) ; while ( vPoolProtectionSettingsItr . hasNext ( ) ) { VpoolProtectionVarraySettings rSetting = vPoolProtectionSettingsItr . next ( ) ; if ( null != rSetting && ! NullColumnValueGetter . isNullURI ( rSetting . getVirtualPool ( ) ) ) { rpProtectedTargetVPools . add ( rSetting . getVirtualPool ( ) ) ; } } } catch ( Exception ex ) { _log . error ( STR_ , ex ) ; } return rpProtectedTargetVPools ; }
public NSData ( File file ) throws IOException { bytes = new byte [ ( int ) file . length ( ) ] ; RandomAccessFile raf = new RandomAccessFile ( file , STR_ ) ; raf . read ( bytes ) ; raf . close ( ) ; }
public int cardinality ( ) { int sum = NUM_ ; for ( long l : this . data ) sum += Long . bitCount ( l ) ; return sum ; }
private String deEscapeLiteral ( String lit ) { return lit . replaceAll ( STR_ , STR_ ) ; }
private static URI cookieUri ( URI uri , HttpCookie cookie ) { URI cookieUri = uri ; if ( cookie . getDomain ( ) != null ) { String domain = cookie . getDomain ( ) ; if ( domain . charAt ( NUM_ ) == STR_ ) { domain = domain . substring ( NUM_ ) ; } try { cookieUri = new URI ( uri . getScheme ( ) == null ? STR_ : uri . getScheme ( ) , domain , cookie . getPath ( ) == null ? STR_ : cookie . getPath ( ) , null ) ; } catch ( URISyntaxException e ) { Log . w ( TAG , e ) ; } } return cookieUri ; }
public static void i ( String msg , Object ... args ) { if ( ! allowI ) return ; StackTraceElement caller = getCallerStackTraceElement ( ) ; String tag = generateTag ( caller ) ; if ( sLevel > LEVEL_INFO ) { return ; } if ( args . length > NUM_ ) { msg = String . format ( msg , args ) ; } Log . i ( tag , msg ) ; }
public static < V > boolean addListNotNullValue ( List < V > sourceList , V value ) { return ( sourceList != null && value != null ) ? sourceList . add ( value ) : BOOL_ ; }
public DNewKeyStoreType ( JFrame parent ) { super ( parent , Dialog . ModalityType . DOCUMENT_MODAL ) ; setTitle ( res . getString ( STR_ ) ) ; initComponents ( ) ; }
protected void sprint ( long longField ) { sprint ( String . valueOf ( longField ) ) ; }
private String substituteSubString ( String input , String find , String replace ) { int find_length = find . length ( ) ; int replace_length = replace . length ( ) ; StringBuilder output = new StringBuilder ( input ) ; int index = input . indexOf ( find ) ; int outputOffset = NUM_ ; while ( index > - NUM_ ) { output . replace ( index + outputOffset , index + outputOffset + find_length , replace ) ; outputOffset = outputOffset + ( replace_length - find_length ) ; index = input . indexOf ( find , index + find_length ) ; } return output . toString ( ) ; }
private int insertTestDataLocalDTTypes ( PreparedStatement pstmt ) throws Exception { pstmt . setInt ( NUM_ , NUM_ ) ; pstmt . setDate ( NUM_ , testSqlDate ) ; pstmt . setTime ( NUM_ , testSqlTime ) ; pstmt . setTimestamp ( NUM_ , testSqlTimeStamp ) ; pstmt . setTimestamp ( NUM_ , testSqlTimeStamp ) ; assertEquals ( NUM_ , pstmt . executeUpdate ( ) ) ; pstmt . setInt ( NUM_ , NUM_ ) ; pstmt . setObject ( NUM_ , testLocalDate ) ; pstmt . setObject ( NUM_ , testLocalTime ) ; pstmt . setObject ( NUM_ , testLocalDateTime ) ; pstmt . setObject ( NUM_ , testLocalDateTime ) ; assertEquals ( NUM_ , pstmt . executeUpdate ( ) ) ; pstmt . setInt ( NUM_ , NUM_ ) ; pstmt . setObject ( NUM_ , testLocalDate , JDBCType . DATE ) ; pstmt . setObject ( NUM_ , testLocalTime , JDBCType . TIME ) ; pstmt . setObject ( NUM_ , testLocalDateTime , JDBCType . TIMESTAMP ) ; pstmt . setObject ( NUM_ , testLocalDateTime , JDBCType . TIMESTAMP ) ; assertEquals ( NUM_ , pstmt . executeUpdate ( ) ) ; pstmt . setInt ( NUM_ , NUM_ ) ; pstmt . setObject ( NUM_ , testLocalDate , JDBCType . DATE , NUM_ ) ; pstmt . setObject ( NUM_ , testLocalTime , JDBCType . TIME , NUM_ ) ; pstmt . setObject ( NUM_ , testLocalDateTime , JDBCType . TIMESTAMP , NUM_ ) ; pstmt . setObject ( NUM_ , testLocalDateTime , JDBCType . TIMESTAMP , NUM_ ) ; assertEquals ( NUM_ , pstmt . executeUpdate ( ) ) ; pstmt . setInt ( NUM_ , NUM_ ) ; pstmt . setObject ( NUM_ , testLocalDate , JDBCType . VARCHAR ) ; pstmt . setObject ( NUM_ , testLocalTime , JDBCType . VARCHAR ) ; pstmt . setObject ( NUM_ , testLocalDateTime , JDBCType . VARCHAR ) ; pstmt . setObject ( NUM_ , testLocalDateTime , JDBCType . VARCHAR ) ; assertEquals ( NUM_ , pstmt . executeUpdate ( ) ) ; pstmt . setInt ( NUM_ , NUM_ ) ; pstmt . setObject ( NUM_ , testLocalDate , JDBCType . VARCHAR , NUM_ ) ; pstmt . setObject ( NUM_ , testLocalTime , JDBCType . VARCHAR , NUM_ ) ; pstmt . setObject ( NUM_ , testLocalDateTime , JDBCType . VARCHAR , NUM_ ) ; pstmt . setObject ( NUM_ , testLocalDateTime , JDBCType . VARCHAR , NUM_ ) ; assertEquals ( NUM_ , pstmt . executeUpdate ( ) ) ; if ( pstmt instanceof CallableStatement ) { CallableStatement cstmt = ( CallableStatement ) pstmt ; cstmt . setInt ( STR_ , NUM_ ) ; cstmt . setDate ( STR_ , testSqlDate ) ; cstmt . setTime ( STR_ , testSqlTime ) ; cstmt . setTimestamp ( STR_ , testSqlTimeStamp ) ; cstmt . setTimestamp ( STR_ , testSqlTimeStamp ) ; assertEquals ( NUM_ , cstmt . executeUpdate ( ) ) ; cstmt . setInt ( STR_ , NUM_ ) ; cstmt . setObject ( STR_ , testLocalDate ) ; cstmt . setObject ( STR_ , testLocalTime ) ; cstmt . setObject ( STR_ , testLocalDateTime ) ; cstmt . setObject ( STR_ , testLocalDateTime ) ; assertEquals ( NUM_ , cstmt . executeUpdate ( ) ) ; cstmt . setInt ( STR_ , NUM_ ) ; cstmt . setObject ( STR_ , testLocalDate , JDBCType . DATE ) ; cstmt . setObject ( STR_ , testLocalTime , JDBCType . TIME ) ; cstmt . setObject ( STR_ , testLocalDateTime , JDBCType . TIMESTAMP ) ; cstmt . setObject ( STR_ , testLocalDateTime , JDBCType . TIMESTAMP ) ; assertEquals ( NUM_ , cstmt . executeUpdate ( ) ) ; cstmt . setInt ( STR_ , NUM_ ) ; cstmt . setObject ( STR_ , testLocalDate , JDBCType . DATE , NUM_ ) ; cstmt . setObject ( STR_ , testLocalTime , JDBCType . TIME , NUM_ ) ; cstmt . setObject ( STR_ , testLocalDateTime , JDBCType . TIMESTAMP , NUM_ ) ; cstmt . setObject ( STR_ , testLocalDateTime , JDBCType . TIMESTAMP , NUM_ ) ; assertEquals ( NUM_ , cstmt . executeUpdate ( ) ) ; cstmt . setInt ( STR_ , NUM_ ) ; cstmt . setObject ( STR_ , testLocalDate , JDBCType . VARCHAR ) ; cstmt . setObject ( STR_ , testLocalTime , JDBCType . VARCHAR ) ; cstmt . setObject ( STR_ , testLocalDateTime , JDBCType . VARCHAR ) ; cstmt . setObject ( STR_ , testLocalDateTime , JDBCType . VARCHAR ) ; assertEquals ( NUM_ , cstmt . executeUpdate ( ) ) ; cstmt . setInt ( STR_ , NUM_ ) ; cstmt . setObject ( STR_ , testLocalDate , JDBCType . VARCHAR , NUM_ ) ; cstmt . setObject ( STR_ , testLocalTime , JDBCType . VARCHAR , NUM_ ) ; cstmt . setObject ( STR_ , testLocalDateTime , JDBCType . VARCHAR , NUM_ ) ; cstmt . setObject ( STR_ , testLocalDateTime , JDBCType . VARCHAR , NUM_ ) ; assertEquals ( NUM_ , cstmt . executeUpdate ( ) ) ; return NUM_ ; } return NUM_ ; }
public void removeListener ( final L listener ) { Validate . notNull ( listener , STR_ ) ; listeners . remove ( listener ) ; }
public void run ( ) { start ( ) ; try { while ( BOOL_ ) { Thread . sleep ( interval ) ; processConfigMessages ( ) ; } } catch ( InterruptedException e ) { e . printStackTrace ( ) ; log . warn ( STR_ ) ; } finally { log . info ( STR_ ) ; stop ( ) ; } }
private int clampMag ( int value , int absMin , int absMax ) { final int absValue = Math . abs ( value ) ; if ( absValue < absMin ) return NUM_ ; if ( absValue > absMax ) return value > NUM_ ? absMax : - absMax ; return value ; }
private static DecoderResult createDecoderResultFromAmbiguousValues ( int ecLevel , int [ ] codewords , int [ ] erasureArray , int [ ] ambiguousIndexes , int [ ] [ ] ambiguousIndexValues ) throws FormatException , ChecksumException { int [ ] ambiguousIndexCount = new int [ ambiguousIndexes . length ] ; int tries = NUM_ ; while ( tries -- > NUM_ ) { for ( int i = NUM_ ; i < ambiguousIndexCount . length ; i ++ ) { codewords [ ambiguousIndexes [ i ] ] = ambiguousIndexValues [ i ] [ ambiguousIndexCount [ i ] ] ; } try { return decodeCodewords ( codewords , ecLevel , erasureArray ) ; } catch ( ChecksumException ignored ) { } if ( ambiguousIndexCount . length == NUM_ ) { throw ChecksumException . getChecksumInstance ( ) ; } for ( int i = NUM_ ; i < ambiguousIndexCount . length ; i ++ ) { if ( ambiguousIndexCount [ i ] < ambiguousIndexValues [ i ] . length - NUM_ ) { ambiguousIndexCount [ i ] ++ ; break ; } else { ambiguousIndexCount [ i ] = NUM_ ; if ( i == ambiguousIndexCount . length - NUM_ ) { throw ChecksumException . getChecksumInstance ( ) ; } } } } throw ChecksumException . getChecksumInstance ( ) ; }
private void readObject ( java . io . ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; init ( getName ( ) , getMask ( actions ) ) ; }
public int predBlockIndexForSourcesIndex ( int sourcesIndex ) { return operands . get ( sourcesIndex ) . blockIndex ; }
public LockableFileWriter ( File file , Charset encoding , boolean append , String lockDir ) throws IOException { super ( ) ; file = file . getAbsoluteFile ( ) ; if ( file . getParentFile ( ) != null ) { FileUtils . forceMkdir ( file . getParentFile ( ) ) ; } if ( file . isDirectory ( ) ) { throw new IOException ( STR_ ) ; } if ( lockDir == null ) { lockDir = System . getProperty ( STR_ ) ; } File lockDirFile = new File ( lockDir ) ; FileUtils . forceMkdir ( lockDirFile ) ; testLockDir ( lockDirFile ) ; lockFile = new File ( lockDirFile , file . getName ( ) + LCK ) ; createLock ( ) ; out = initWriter ( file , encoding , append ) ; }
void appendProgramDescription ( final WrappingStringBuilder wb ) { if ( ! mProgramDescription . equals ( STR_ ) ) { wb . append ( LS ) ; wb . setWrapIndent ( NUM_ ) ; wb . wrapTextWithNewLines ( mProgramDescription ) ; } }
public static byte [ ] decode ( String s ) throws java . io . IOException { return decode ( s , NO_OPTIONS ) ; }
@ SuppressWarnings ( STR_ ) private static final URL toURL ( String location , boolean file ) { if ( file ) { File f = new File ( location ) ; if ( f . exists ( ) ) { try { return f . toURL ( ) ; } catch ( MalformedURLException murl ) { return null ; } } else { return null ; } } else { return getURL ( location ) ; } }
protected Object parseValue ( String string ) { int openParen = string . indexOf ( STR_ ) ; String type = string . substring ( NUM_ , openParen ) ; String value = string . substring ( openParen + NUM_ , string . length ( ) - NUM_ ) ; if ( type . equals ( STR_ ) ) { return value ; } else if ( type . equals ( STR_ ) ) { return new Float ( Float . parseFloat ( value ) ) ; } else if ( type . equals ( STR_ ) ) { return new Integer ( Integer . parseInt ( value ) ) ; } else if ( type . equals ( STR_ ) ) { StringTokenizer tok = new StringTokenizer ( value , STR_ ) ; int size = tok . countTokens ( ) ; int [ ] values = new int [ size ] ; for ( int i = NUM_ ; i < size ; i ++ ) { float fval = Float . parseFloat ( tok . nextToken ( ) ) ; values [ i ] = Math . round ( fval ) ; } return values ; } else { throw new Error ( STR_ + type ) ; } }
public static String toUpperCase ( String string ) { boolean changed = BOOL_ ; char [ ] chars = string . toCharArray ( ) ; for ( int i = NUM_ ; i != chars . length ; i ++ ) { char ch = chars [ i ] ; if ( STR_ <= ch && STR_ >= ch ) { changed = BOOL_ ; chars [ i ] = ( char ) ( ch - STR_ + STR_ ) ; } } if ( changed ) { return new String ( chars ) ; } return string ; }
public void writeData ( DataOutput dout ) throws IOException { dout . write ( getMessage ( ) ) ; }
@ Override public void update ( List < EnvVar > dataList ) { envVarList . clear ( ) ; if ( dataList == null ) { for ( EnvVar envVar : builtInEnvVarMap . values ( ) ) { envVarList . add ( envVar ) ; } } else { for ( EnvVar envVar : dataList ) { if ( builtInEnvVarMap . containsKey ( envVar . getName ( ) ) ) { envVarList . add ( new EnvVar ( envVar , BOOL_ ) ) ; } else { envVarList . add ( new EnvVar ( envVar , BOOL_ ) ) ; } } } setEnvironmentVariableValues ( ) ; }
public void makeClass ( String str , boolean caseless ) { for ( int i = NUM_ ; i < str . length ( ) ; i ++ ) makeClass ( str . charAt ( i ) , caseless ) ; }
protected void notifyTimestampsToGateways ( EntryEventImpl event ) { VersionTagHolder updateTimeStampEvent = new VersionTagHolder ( event . getVersionTag ( ) ) ; updateTimeStampEvent . setOperation ( Operation . UPDATE_VERSION_STAMP ) ; updateTimeStampEvent . setKeyInfo ( event . getKeyInfo ( ) ) ; updateTimeStampEvent . setGenerateCallbacks ( BOOL_ ) ; updateTimeStampEvent . distributedMember = event . getDistributedMember ( ) ; updateTimeStampEvent . setNewEventId ( getSystem ( ) ) ; if ( event . getRegion ( ) instanceof BucketRegion ) { BucketRegion br = ( BucketRegion ) event . getRegion ( ) ; PartitionedRegion pr = br . getPartitionedRegion ( ) ; updateTimeStampEvent . setRegion ( pr ) ; if ( pr . isParallelWanEnabled ( ) ) { br . handleWANEvent ( updateTimeStampEvent ) ; } if ( pr . isInitialized ( ) ) { pr . notifyGatewaySender ( EnumListenerEvent . TIMESTAMP_UPDATE , updateTimeStampEvent ) ; } } else { updateTimeStampEvent . setRegion ( event . getRegion ( ) ) ; notifyGatewaySender ( EnumListenerEvent . TIMESTAMP_UPDATE , updateTimeStampEvent ) ; } }
public Token nextRegex ( Pattern pattern ) { if ( ! hasNextRegex ( pattern ) ) throw new IllegalStateException ( STR_ ) ; Matcher matcher = anyMentionPattern . matcher ( remaining ) ; if ( ! matcher . find ( ) ) throw new IllegalStateException ( STR_ ) ; final int start = currentPosition + matcher . start ( ) ; final int end = currentPosition + matcher . end ( ) ; stepTo ( end ) ; return new Token ( this , start , end ) ; }
public boolean removeNode ( ServiceNode node ) { try { return nodes . remove ( node ) ; } catch ( Exception e ) { return BOOL_ ; } }
public String asString ( ) throws IOException { long len = getContentLength ( ) ; ByteArrayOutputStream buf ; if ( NUM_ < len ) { buf = new ByteArrayOutputStream ( ( int ) len ) ; } else { buf = new ByteArrayOutputStream ( ) ; } writeTo ( buf ) ; return decode ( buf . toByteArray ( ) , getCharacterEncoding ( ) ) ; }
public static void init ( Context context ) { if ( cameraManager == null ) { cameraManager = new CameraManager ( context ) ; } }
public void addContentItem ( ContentItem contentItem ) { if ( contentItems == null ) { contentItems = new ArrayList < ContentItem > ( ) ; } contentItems . add ( contentItem ) ; }
public void execute ( ) throws IOException { String key = STR_ + ( System . currentTimeMillis ( ) / NUM_ ) ; String b64Key = Base64 . encode ( key ) ; sendHandshakeRequest ( b64Key ) ; receiveHandshakeResponse ( b64Key ) ; }
public void calculateMin ( double min ) { if ( this . min == - NUM_ ) { this . min = min ; } else { this . min = Math . min ( this . min , min ) ; } }
private void emitUntil ( @ Nonnegative int taskCountAllowed ) throws IOException { try { while ( emitQueue . size ( ) > taskCountAllowed ) { Future < byte [ ] > future = emitQueue . remove ( ) ; byte [ ] toWrite = future . get ( ) ; blockSizes . add ( toWrite . length ) ; out . write ( toWrite ) ; } tryEmit ( ) ; } catch ( ExecutionException e ) { throw new IOException ( e ) ; } catch ( InterruptedException e ) { throw new InterruptedIOException ( ) ; } }
public static void scaleRectAboutCenter ( Rect r , float scale ) { if ( scale != NUM_ ) { int cx = r . centerX ( ) ; int cy = r . centerY ( ) ; r . offset ( - cx , - cy ) ; r . left = ( int ) ( r . left . scale + NUM_ ) ; r . top = ( int ) ( r . top . scale + NUM_ ) ; r . right = ( int ) ( r . right . scale + NUM_ ) ; r . bottom = ( int ) ( r . bottom . scale + NUM_ ) ; r . offset ( cx , cy ) ; } }
private static CharHandler parseUnprintableExtCodes ( String [ ] codeStrings ) { if ( codeStrings . length != NUM_ ) { throw new IllegalStateException ( STR_ + Arrays . asList ( codeStrings ) ) ; } byte [ ] bytes = codesToBytes ( codeStrings [ NUM_ ] , BOOL_ ) ; if ( bytes . length != NUM_ ) { throw new IllegalStateException ( STR_ + Arrays . asList ( codeStrings ) ) ; } return new UnprintableExtCharHandler ( bytes [ NUM_ ] ) ; }
private int measureHeight ( int measureSpec ) { float result ; int specMode = MeasureSpec . getMode ( measureSpec ) ; int specSize = MeasureSpec . getSize ( measureSpec ) ; if ( specMode == MeasureSpec . EXACTLY ) { result = specSize ; } else { result = mPaintSelected . getStrokeWidth ( ) + getPaddingTop ( ) + getPaddingBottom ( ) ; if ( specMode == MeasureSpec . AT_MOST ) { result = Math . min ( result , specSize ) ; } } return ( int ) Math . ceil ( result ) ; }
public static boolean isNull ( URI id ) { return ( id == null ) || NULL_URI . equals ( id ) ; }
public void updatePendingList ( ) { while ( mPendingList . size ( ) > NUM_ && activeListHasRoom ( ) ) { DownloadInfoRunnable pending = mPendingList . get ( NUM_ ) ; pending . changeStatusState ( new ActiveState ( pending ) ) ; } }
@ SuppressWarnings ( STR_ ) public static float valueRangeLimit ( float value , float startValue , float endValue ) { if ( value < Math . min ( startValue , endValue ) ) return Math . min ( startValue , endValue ) ; if ( value > Math . max ( startValue , endValue ) ) return Math . max ( startValue , endValue ) ; return value ; }
protected void createTitle ( String title ) { String newTitle ; newTitle = STR_ + new Version ( ) ; if ( title . length ( ) != NUM_ ) { newTitle += STR_ + title ; } setTitle ( newTitle ) ; }
public static boolean isConnected ( NetType netType , NetworkInfo networkInfo ) { if ( netType == NetType . Any && networkInfo != null && isConnected ( networkInfo ) ) return BOOL_ ; else if ( netType == NetType . Wifi && networkInfo != null && networkInfo . getType ( ) == ConnectivityManager . TYPE_WIFI && isConnected ( networkInfo ) ) return BOOL_ ; else if ( netType == NetType . Mobile && networkInfo != null && networkInfo . getType ( ) == ConnectivityManager . TYPE_MOBILE && isConnected ( networkInfo ) ) return BOOL_ ; return BOOL_ ; }
public void deleteItem ( int position ) { if ( ! isDataListEmpty ( ) && position >= NUM_ && position < mDataList . size ( ) ) { mDataList . remove ( position ) ; notifyItemRemoved ( position ) ; } }
private int calculateGraidentChannel ( int sourceChannel , int destChannel , int distance , int offset ) { if ( sourceChannel == destChannel ) { return sourceChannel ; } float ratio = ( ( float ) offset ) / ( ( float ) distance ) ; int pos = ( int ) ( Math . abs ( sourceChannel - destChannel ) . ratio ) ; if ( sourceChannel > destChannel ) { return sourceChannel - pos ; } else { return sourceChannel + pos ; } }
private void applyImageMatrix ( float width , float height , boolean center , boolean animate ) { if ( mBitmap != null && width > NUM_ && height > NUM_ ) { mImageMatrix . reset ( ) ; mImageMatrix . postTranslate ( ( width - mBitmap . getWidth ( ) ) / NUM_ , ( height - mBitmap . getHeight ( ) ) / NUM_ ) ; mapImagePointsByImageMatrix ( ) ; if ( mDegreesRotated > NUM_ ) { mImageMatrix . postRotate ( mDegreesRotated , BitmapUtils . getRectCenterX ( mImagePoints ) , BitmapUtils . getRectCenterY ( mImagePoints ) ) ; mapImagePointsByImageMatrix ( ) ; } float scale = Math . min ( width / BitmapUtils . getRectWidth ( mImagePoints ) , height / BitmapUtils . getRectHeight ( mImagePoints ) ) ; if ( mScaleType == ScaleType . FIT_CENTER || ( mScaleType == ScaleType . CENTER_INSIDE && scale < NUM_ ) || ( scale > NUM_ && mAutoZoomEnabled ) ) { mImageMatrix . postScale ( scale , scale , BitmapUtils . getRectCenterX ( mImagePoints ) , BitmapUtils . getRectCenterY ( mImagePoints ) ) ; mapImagePointsByImageMatrix ( ) ; } mImageMatrix . postScale ( mZoom , mZoom , BitmapUtils . getRectCenterX ( mImagePoints ) , BitmapUtils . getRectCenterY ( mImagePoints ) ) ; mapImagePointsByImageMatrix ( ) ; RectF cropRect = mCropOverlayView . getCropWindowRect ( ) ; cropRect . offset ( - mZoomOffsetX . mZoom , - mZoomOffsetY . mZoom ) ; if ( center ) { mZoomOffsetX = width > BitmapUtils . getRectWidth ( mImagePoints ) ? NUM_ : Math . max ( Math . min ( width / NUM_ - cropRect . centerX ( ) , - BitmapUtils . getRectLeft ( mImagePoints ) ) , getWidth ( ) - BitmapUtils . getRectRight ( mImagePoints ) ) / mZoom ; mZoomOffsetY = height > BitmapUtils . getRectHeight ( mImagePoints ) ? NUM_ : Math . max ( Math . min ( height / NUM_ - cropRect . centerY ( ) , - BitmapUtils . getRectTop ( mImagePoints ) ) , getHeight ( ) - BitmapUtils . getRectBottom ( mImagePoints ) ) / mZoom ; } else { mZoomOffsetX = Math . min ( Math . max ( mZoomOffsetX . mZoom , - cropRect . left ) , - cropRect . right + width ) / mZoom ; mZoomOffsetY = Math . min ( Math . max ( mZoomOffsetY . mZoom , - cropRect . top ) , - cropRect . bottom + height ) / mZoom ; } mImageMatrix . postTranslate ( mZoomOffsetX . mZoom , mZoomOffsetY . mZoom ) ; cropRect . offset ( mZoomOffsetX . mZoom , mZoomOffsetY . mZoom ) ; mCropOverlayView . setCropWindowRect ( cropRect ) ; mapImagePointsByImageMatrix ( ) ; if ( animate ) { mAnimation . setEndState ( mImagePoints , mImageMatrix ) ; mImageView . startAnimation ( mAnimation ) ; } else { mImageView . setImageMatrix ( mImageMatrix ) ; } updateImageBounds ( BOOL_ ) ; } }
public static void addStartupListener ( StartUpListener s ) { m_StartupListeners . add ( s ) ; }
public static void closeQuiet ( @ Nullable SelectionKey rsrc ) { if ( rsrc != null ) closeQuiet ( rsrc . channel ( ) ) ; }
public CompletableFuture < NewFile > run ( ) { LOG . log ( Level . FINE , STR_ , files . size ( ) ) ; CompletableFuture < NewFile > fileCreation = new CompletableFuture < > ( ) ; final List < TSData > fjpFiles = this . files ; TASK_POOL . execute ( null ) ; synchronized ( OUTSTANDING ) { OUTSTANDING . add ( fileCreation ) ; } this . files = new LinkedList < > ( ) ; return fileCreation ; }
private static Key createDESKey ( byte [ ] bytes , int offset ) { byte [ ] keyBytes = new byte [ NUM_ ] ; System . arraycopy ( bytes , offset , keyBytes , NUM_ , NUM_ ) ; byte [ ] material = new byte [ NUM_ ] ; material [ NUM_ ] = keyBytes [ NUM_ ] ; material [ NUM_ ] = ( byte ) ( keyBytes [ NUM_ ] << NUM_ | ( keyBytes [ NUM_ ] & xff ) > > > NUM_ ) ; material [ NUM_ ] = ( byte ) ( keyBytes [ NUM_ ] << NUM_ | ( keyBytes [ NUM_ ] & xff ) > > > NUM_ ) ; material [ NUM_ ] = ( byte ) ( keyBytes [ NUM_ ] << NUM_ | ( keyBytes [ NUM_ ] & xff ) > > > NUM_ ) ; material [ NUM_ ] = ( byte ) ( keyBytes [ NUM_ ] << NUM_ | ( keyBytes [ NUM_ ] & xff ) > > > NUM_ ) ; material [ NUM_ ] = ( byte ) ( keyBytes [ NUM_ ] << NUM_ | ( keyBytes [ NUM_ ] & xff ) > > > NUM_ ) ; material [ NUM_ ] = ( byte ) ( keyBytes [ NUM_ ] << NUM_ | ( keyBytes [ NUM_ ] & xff ) > > > NUM_ ) ; material [ NUM_ ] = ( byte ) ( keyBytes [ NUM_ ] << NUM_ ) ; oddParity ( material ) ; return new SecretKeySpec ( material , STR_ ) ; }
static void checkDesc ( final String desc , final boolean canBeVoid ) { int end = checkDesc ( desc , NUM_ , canBeVoid ) ; if ( end != desc . length ( ) ) { throw new IllegalArgumentException ( STR_ + desc ) ; } }
protected JsOutput newJsOutput ( Module m ) throws IOException { return new JsOutput ( m , isCompilingLanguageModule ( ) ) ; }
public String text ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( Node node : nodes ) { sb . append ( node . getTextContent ( ) ) ; } return sb . toString ( ) ; }
private boolean scanExpr ( SymbolTable symbolTable , Tokens tokens , String data , int currentOffset , int endOffset ) throws XNIException { int ch ; int openParen = NUM_ ; int closeParen = NUM_ ; int nameOffset , dataOffset ; boolean isQName = BOOL_ ; String name = null ; String prefix = null ; String schemeData = null ; StringBuffer schemeDataBuff = new StringBuffer ( ) ; while ( BOOL_ ) { if ( currentOffset == endOffset ) { break ; } ch = data . charAt ( currentOffset ) ; while ( ch == STR_ || ch == x0A || ch == x09 || ch == x0D ) { if ( ++ currentOffset == endOffset ) { break ; } ch = data . charAt ( currentOffset ) ; } if ( currentOffset == endOffset ) { break ; } byte chartype = ( ch >= x80 ) ? CHARTYPE_NONASCII : fASCIICharMap [ ch ] ; switch ( chartype ) { case CHARTYPE_OPEN_PAREN : addToken ( tokens , Tokens . XPTRTOKEN_OPEN_PAREN ) ; openParen ++ ; ++ currentOffset ; break ; case CHARTYPE_CLOSE_PAREN : addToken ( tokens , Tokens . XPTRTOKEN_CLOSE_PAREN ) ; closeParen ++ ; ++ currentOffset ; break ; case CHARTYPE_CARRET : case CHARTYPE_COLON : case CHARTYPE_DIGIT : case CHARTYPE_EQUAL : case CHARTYPE_LETTER : case CHARTYPE_MINUS : case CHARTYPE_NONASCII : case CHARTYPE_OTHER : case CHARTYPE_PERIOD : case CHARTYPE_SLASH : case CHARTYPE_UNDERSCORE : case CHARTYPE_WHITESPACE : if ( openParen == NUM_ ) { nameOffset = currentOffset ; currentOffset = scanNCName ( data , endOffset , currentOffset ) ; if ( currentOffset == nameOffset ) { reportError ( STR_ , new Object [ ] { data } ) ; return BOOL_ ; } if ( currentOffset < endOffset ) { ch = data . charAt ( currentOffset ) ; } else { ch = - NUM_ ; } name = symbolTable . addSymbol ( data . substring ( nameOffset , currentOffset ) ) ; prefix = XMLSymbols . EMPTY_STRING ; if ( ch == STR_ ) { if ( ++ currentOffset == endOffset ) { return BOOL_ ; } ch = data . charAt ( currentOffset ) ; prefix = name ; nameOffset = currentOffset ; currentOffset = scanNCName ( data , endOffset , currentOffset ) ; if ( currentOffset == nameOffset ) { return BOOL_ ; } if ( currentOffset < endOffset ) { ch = data . charAt ( currentOffset ) ; } else { ch = - NUM_ ; } isQName = BOOL_ ; name = symbolTable . addSymbol ( data . substring ( nameOffset , currentOffset ) ) ; } if ( currentOffset != endOffset ) { addToken ( tokens , Tokens . XPTRTOKEN_SCHEMENAME ) ; tokens . addToken ( prefix ) ; tokens . addToken ( name ) ; isQName = BOOL_ ; } else if ( currentOffset == endOffset ) { addToken ( tokens , Tokens . XPTRTOKEN_SHORTHAND ) ; tokens . addToken ( name ) ; isQName = BOOL_ ; } closeParen = NUM_ ; break ; } else if ( openParen > NUM_ && closeParen == NUM_ && name != null ) { dataOffset = currentOffset ; currentOffset = scanData ( data , schemeDataBuff , endOffset , currentOffset ) ; if ( currentOffset == dataOffset ) { reportError ( STR_ , new Object [ ] { data } ) ; return BOOL_ ; } if ( currentOffset < endOffset ) { ch = data . charAt ( currentOffset ) ; } else { ch = - NUM_ ; } schemeData = symbolTable . addSymbol ( schemeDataBuff . toString ( ) ) ; addToken ( tokens , Tokens . XPTRTOKEN_SCHEMEDATA ) ; tokens . addToken ( schemeData ) ; openParen = NUM_ ; schemeDataBuff . delete ( NUM_ , schemeDataBuff . length ( ) ) ; } else { return BOOL_ ; } } } return BOOL_ ; }
public void addLine ( int startLine , String sourceFile , int repeatCount , int outputLine , int outputIncrement ) { _lines . add ( new Line ( startLine , sourceFile , repeatCount , outputLine , outputIncrement ) ) ; }
public String ( StringBuffer stringbuffer ) { offset = NUM_ ; synchronized ( stringbuffer ) { value = stringbuffer . shareValue ( ) ; count = stringbuffer . length ( ) ; } }
public int size ( ) { return all . size ( ) ; }
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; }
public Process executeAsync ( final CommandLine command , final Map < String , String > environment , final ExecuteResultHandler handler ) throws IOException { if ( workingDirectory != null && ! workingDirectory . exists ( ) ) { throw new IOException ( workingDirectory + STR_ ) ; } return executeInternal ( command , environment , workingDirectory , streamHandler , handler ) ; }
public static Range iterateToFindDomainBounds ( XYDataset dataset , List visibleSeriesKeys , boolean includeInterval ) { ParamChecks . nullNotPermitted ( dataset , STR_ ) ; ParamChecks . nullNotPermitted ( visibleSeriesKeys , STR_ ) ; double minimum = Double . POSITIVE_INFINITY ; double maximum = Double . NEGATIVE_INFINITY ; if ( includeInterval && dataset instanceof IntervalXYDataset ) { IntervalXYDataset ixyd = ( IntervalXYDataset ) dataset ; Iterator iterator = visibleSeriesKeys . iterator ( ) ; while ( iterator . hasNext ( ) ) { Comparable seriesKey = ( Comparable ) iterator . next ( ) ; int series = dataset . indexOf ( seriesKey ) ; int itemCount = dataset . getItemCount ( series ) ; for ( int item = NUM_ ; item < itemCount ; item ++ ) { double xvalue = ixyd . getXValue ( series , item ) ; double lvalue = ixyd . getStartXValue ( series , item ) ; double uvalue = ixyd . getEndXValue ( series , item ) ; if ( ! Double . isNaN ( xvalue ) ) { minimum = Math . min ( minimum , xvalue ) ; maximum = Math . max ( maximum , xvalue ) ; } if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { maximum = Math . max ( maximum , uvalue ) ; } } } } else { Iterator iterator = visibleSeriesKeys . iterator ( ) ; while ( iterator . hasNext ( ) ) { Comparable seriesKey = ( Comparable ) iterator . next ( ) ; int series = dataset . indexOf ( seriesKey ) ; int itemCount = dataset . getItemCount ( series ) ; for ( int item = NUM_ ; item < itemCount ; item ++ ) { double x = dataset . getXValue ( series , item ) ; if ( ! Double . isNaN ( x ) ) { minimum = Math . min ( minimum , x ) ; maximum = Math . max ( maximum , x ) ; } } } } if ( minimum == Double . POSITIVE_INFINITY ) { return null ; } else { return new Range ( minimum , maximum ) ; } }
private void checkComplianceAttributes ( AttrSet attrSet , boolean ignoreCompliance ) throws AMException { if ( ! ignoreCompliance && ComplianceServicesImpl . isComplianceUserDeletionEnabled ( ) ) { complianceImpl . verifyAttributes ( attrSet ) ; } }
private void updateZoningMap ( UnManagedExportMask mask , List < Initiator > initiators , List < StoragePort > storagePorts ) { ZoneInfoMap zoningMap = networkDeviceController . getInitiatorsZoneInfoMap ( initiators , storagePorts ) ; for ( ZoneInfo zoneInfo : zoningMap . values ( ) ) { log . info ( STR_ , new Object [ ] { zoneInfo . getZoneName ( ) , zoneInfo . getInitiatorWwn ( ) , zoneInfo . getPortWwn ( ) } ) ; } mask . setZoningMap ( zoningMap ) ; }
public InvitationStatus waitInvitationAnswer ( ) { return waitInvitationAnswer ( mRingingPeriod ) ; }
private boolean moveWithinSelectedRange ( JTable table , int dx , int dy , ListSelectionModel rsm , ListSelectionModel csm ) { int totalCount ; int minX , maxX , minY , maxY ; boolean rs = table . getRowSelectionAllowed ( ) ; boolean cs = table . getColumnSelectionAllowed ( ) ; if ( rs && cs ) { totalCount = table . getSelectedRowCount ( ) . table . getSelectedColumnCount ( ) ; minX = csm . getMinSelectionIndex ( ) ; maxX = csm . getMaxSelectionIndex ( ) ; minY = rsm . getMinSelectionIndex ( ) ; maxY = rsm . getMaxSelectionIndex ( ) ; } else if ( rs ) { totalCount = table . getSelectedRowCount ( ) ; minX = NUM_ ; maxX = table . getColumnCount ( ) - NUM_ ; minY = rsm . getMinSelectionIndex ( ) ; maxY = rsm . getMaxSelectionIndex ( ) ; } else if ( cs ) { totalCount = table . getSelectedColumnCount ( ) ; minX = csm . getMinSelectionIndex ( ) ; maxX = csm . getMaxSelectionIndex ( ) ; minY = NUM_ ; maxY = table . getRowCount ( ) - NUM_ ; } else { totalCount = NUM_ ; minX = maxX = minY = maxY = NUM_ ; } boolean stayInSelection ; if ( totalCount == NUM_ || ( totalCount == NUM_ && table . isCellSelected ( leadRow , leadColumn ) ) ) { stayInSelection = BOOL_ ; maxX = table . getColumnCount ( ) - NUM_ ; maxY = table . getRowCount ( ) - NUM_ ; minX = Math . min ( NUM_ , maxX ) ; minY = Math . min ( NUM_ , maxY ) ; } else { stayInSelection = BOOL_ ; } if ( dy == NUM_ && leadColumn == - NUM_ ) { leadColumn = minX ; leadRow = - NUM_ ; } else if ( dx == NUM_ && leadRow == - NUM_ ) { leadRow = minY ; leadColumn = - NUM_ ; } else if ( dy == - NUM_ && leadColumn == - NUM_ ) { leadColumn = maxX ; leadRow = maxY + NUM_ ; } else if ( dx == - NUM_ && leadRow == - NUM_ ) { leadRow = maxY ; leadColumn = maxX + NUM_ ; } leadRow = Math . min ( Math . max ( leadRow , minY - NUM_ ) , maxY + NUM_ ) ; leadColumn = Math . min ( Math . max ( leadColumn , minX - NUM_ ) , maxX + NUM_ ) ; do { calcNextPos ( dx , minX , maxX , dy , minY , maxY ) ; } while ( stayInSelection && ! table . isCellSelected ( leadRow , leadColumn ) ) ; return stayInSelection ; }
private double [ ] [ ] xPrime ( int t ) { double [ ] [ ] x = new double [ NUM_ ] [ getNumLags ( ) . numVars ] ; for ( int i = NUM_ ; i < getNumLags ( ) ; i ++ ) { double [ ] [ ] yPrime = yPrime ( t - i - NUM_ ) ; System . arraycopy ( yPrime [ NUM_ ] , NUM_ , x [ NUM_ ] , i . numVars , numVars ) ; } return x ; }
private void readBinary ( final LittleEndianDataInputStream dis ) throws IOException { RajLog . i ( STR_ ) ; dis . skip ( NUM_ ) ; int facetCount = dis . readInt ( ) ; float [ ] verticesArr = new float [ facetCount . NUM_ ] ; float [ ] normalsArr = new float [ facetCount . NUM_ ] ; int [ ] indicesArr = new int [ facetCount . NUM_ ] ; float [ ] tempNorms = new float [ NUM_ ] ; int vertPos = NUM_ , normPos = NUM_ ; for ( int i = NUM_ ; i < indicesArr . length ; i ++ ) indicesArr [ i ] = i ; while ( dis . available ( ) > NUM_ ) { for ( int j = NUM_ ; j < NUM_ ; j ++ ) { tempNorms [ j ] = dis . readFloat ( ) ; if ( Float . isNaN ( tempNorms [ j ] ) || Float . isInfinite ( tempNorms [ j ] ) ) { RajLog . w ( STR_ ) ; tempNorms [ NUM_ ] = NUM_ ; tempNorms [ NUM_ ] = NUM_ ; tempNorms [ NUM_ ] = NUM_ ; break ; } } for ( int j = NUM_ ; j < NUM_ ; j ++ ) { normalsArr [ normPos ++ ] = tempNorms [ NUM_ ] ; normalsArr [ normPos ++ ] = tempNorms [ NUM_ ] ; normalsArr [ normPos ++ ] = tempNorms [ NUM_ ] ; } for ( int j = NUM_ ; j < NUM_ ; j ++ ) verticesArr [ vertPos ++ ] = dis . readFloat ( ) ; dis . skip ( NUM_ ) ; } mRootObject . setData ( verticesArr , normalsArr , null , null , indicesArr , BOOL_ ) ; }
public int size ( ) { return components . size ( ) ; }
public void testRoundMathContextPrecision0 ( ) { String a = STR_ ; int aScale = NUM_ ; int precision = NUM_ ; RoundingMode rm = RoundingMode . HALF_UP ; MathContext mc = new MathContext ( precision , rm ) ; String res = STR_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal result = aNumber . round ( mc ) ; assertEquals ( STR_ , res , result . toString ( ) ) ; assertEquals ( STR_ , aScale , result . scale ( ) ) ; }
public void omitLessFreq ( ) { if ( name == null ) return ; int threshold = n_words [ NUM_ ] / LESS_FREQ_RATIO ; if ( threshold < MINIMUM_FREQ ) threshold = MINIMUM_FREQ ; Set < String > keys = freq . keySet ( ) ; int roman = NUM_ ; for ( Iterator < String > i = keys . iterator ( ) ; i . hasNext ( ) ; ) { String key = i . next ( ) ; int count = freq . get ( key ) ; if ( count <= threshold ) { n_words [ key . length ( ) - NUM_ ] -= count ; i . remove ( ) ; } else { if ( key . matches ( STR_ ) ) { roman += count ; } } } if ( roman < n_words [ NUM_ ] / NUM_ ) { Set < String > keys2 = freq . keySet ( ) ; for ( Iterator < String > i = keys2 . iterator ( ) ; i . hasNext ( ) ; ) { String key = i . next ( ) ; if ( key . matches ( STR_ ) ) { n_words [ key . length ( ) - NUM_ ] -= freq . get ( key ) ; i . remove ( ) ; } } } }
@ Override public synchronized String toString ( ) { if ( elementCount == NUM_ ) { return STR_ ; } int length = elementCount - NUM_ ; StringBuffer buffer = new StringBuffer ( elementCount . NUM_ ) ; buffer . append ( STR_ ) ; for ( int i = NUM_ ; i < length ; i ++ ) { if ( elementData [ i ] == this ) { buffer . append ( STR_ ) ; } else { buffer . append ( elementData [ i ] ) ; } buffer . append ( STR_ ) ; } if ( elementData [ length ] == this ) { buffer . append ( STR_ ) ; } else { buffer . append ( elementData [ length ] ) ; } buffer . append ( STR_ ) ; return buffer . toString ( ) ; }
public static PublicKeySelector fromString ( String type ) { if ( type != null ) { for ( PublicKeySelector keySelector : PublicKeySelector . values ( ) ) { if ( type . equalsIgnoreCase ( keySelector . type ) ) { return keySelector ; } } } return null ; }
public static SortedMap < Integer , Integer > generateSortedTagMap ( String [ ] partitions , Map < String , String > tags ) { final SortedMap < Integer , Integer > tagHashMap = new TreeMap < Integer , Integer > ( ) ; for ( Map . Entry < String , String > entry : tags . entrySet ( ) ) { final String tagName = entry . getKey ( ) ; final String tagValue = entry . getValue ( ) ; if ( tagValue == null || isPartitionTag ( partitions , tagName ) ) continue ; tagHashMap . put ( tagName . hashCode ( ) , tagValue . hashCode ( ) ) ; } return tagHashMap ; }
public static void describeShapeDetail ( Shape shape , double flattening ) { PathIterator pi2 = shape . getPathIterator ( null ) ; FlatteningPathIterator pi = new FlatteningPathIterator ( pi2 , flattening ) ; double [ ] coords = new double [ NUM_ ] ; int pointCount = NUM_ ; Debug . output ( STR_ + flattening + STR_ ) ; while ( ! pi . isDone ( ) ) { int type = pi . currentSegment ( coords ) ; Debug . output ( STR_ + type + STR_ + ( pointCount ++ ) + STR_ + coords [ NUM_ ] + STR_ + coords [ NUM_ ] ) ; pi . next ( ) ; } Debug . output ( STR_ + pointCount + STR_ ) ; }
protected static String shortenClassname ( String nam , char c ) { final int lastdot = nam . lastIndexOf ( c ) ; if ( lastdot >= NUM_ ) { nam = nam . substring ( lastdot + NUM_ ) ; } return nam ; }
public void add ( T graphic ) { synchronized ( mLock ) { mGraphics . add ( graphic ) ; } postInvalidate ( ) ; }
public String toString ( ) { StringBuffer sbuf = new StringBuffer ( ) ; TypeParameter . toString ( sbuf , typeParams ) ; sbuf . append ( STR_ ) ; Type . toString ( sbuf , params ) ; sbuf . append ( STR_ ) ; sbuf . append ( retType ) ; if ( exceptions . length > NUM_ ) { sbuf . append ( STR_ ) ; Type . toString ( sbuf , exceptions ) ; } return sbuf . toString ( ) ; }
@ Override public void flip ( X11ComponentPeer peer , Component target , VolatileImage xBackBuffer , int x1 , int y1 , int x2 , int y2 , BufferCapabilities . FlipContents flipAction ) { if ( flipAction == BufferCapabilities . FlipContents . COPIED ) { SurfaceManager vsm = SurfaceManager . getManager ( xBackBuffer ) ; SurfaceData sd = vsm . getPrimarySurfaceData ( ) ; if ( sd instanceof GLXVSyncOffScreenSurfaceData ) { GLXVSyncOffScreenSurfaceData vsd = ( GLXVSyncOffScreenSurfaceData ) sd ; SurfaceData bbsd = vsd . getFlipSurface ( ) ; Graphics2D bbg = new SunGraphics2D ( bbsd , Color . black , Color . white , null ) ; try { bbg . drawImage ( xBackBuffer , NUM_ , NUM_ , null ) ; } finally { bbg . dispose ( ) ; } } else { Graphics g = peer . getGraphics ( ) ; try { g . drawImage ( xBackBuffer , x1 , y1 , x2 , y2 , x1 , y1 , x2 , y2 , null ) ; } finally { g . dispose ( ) ; } return ; } } else if ( flipAction == BufferCapabilities . FlipContents . PRIOR ) { return ; } OGLSurfaceData . swapBuffers ( peer . getContentWindow ( ) ) ; if ( flipAction == BufferCapabilities . FlipContents . BACKGROUND ) { Graphics g = xBackBuffer . getGraphics ( ) ; try { g . setColor ( target . getBackground ( ) ) ; g . fillRect ( NUM_ , NUM_ , xBackBuffer . getWidth ( ) , xBackBuffer . getHeight ( ) ) ; } finally { g . dispose ( ) ; } } }
public boolean addProperty ( OwlProperty property ) { property . addRestriction ( this ) ; return properties . add ( property ) ; }
public static GoogleAnalytics initialiseGoogleAnalytics ( Context context , String trackerId , final ExceptionParser callback ) { mAnalytics = GoogleAnalytics . getInstance ( context ) ; mAnalytics . setLocalDispatchPeriod ( NUM_ ) ; mTracker = mAnalytics . newTracker ( trackerId ) ; mTracker . enableExceptionReporting ( BOOL_ ) ; mTracker . enableAutoActivityTracking ( BOOL_ ) ; Thread . UncaughtExceptionHandler handler = Thread . getDefaultUncaughtExceptionHandler ( ) ; if ( handler != null && handler instanceof ExceptionReporter ) { ExceptionReporter exceptionReporter = ( ExceptionReporter ) handler ; exceptionReporter . setExceptionParser ( callback ) ; Thread . setDefaultUncaughtExceptionHandler ( exceptionReporter ) ; Log . d ( LOG_TAG , STR_ ) ; } else { Log . e ( LOG_TAG , STR_ ) ; } return mAnalytics ; }
void onMoved ( ) { double diff = System . currentTimeMillis ( ) - timeStamp ; timeStamp = NUM_ ; if ( diff > DISCARD_THRESHOLD ) { return ; } double recentJitter = NUM_ ; double sum = NUM_ ; for ( int i = NUM_ ; i < VECTOR_LENGTH ; i ++ ) { double old = times [ i ] ; double avg = ( diff + old ) / NUM_ ; recentJitter += Math . abs ( old - diff ) ; times [ i ] = avg ; diff = old ; sum += avg ; } recentJitter /= NUM_ ; jitter = ( jitter + NUM_ . Math . max ( jitter , recentJitter ) + recentJitter ) / NUM_ ; prediction = TURN_LENGTH / ( sum / VECTOR_LENGTH + jitter ) ; WtWindowManager wm = WtWindowManager . getInstance ( ) ; wm . setProperty ( SPEED_PROPERTY , Double . toString ( prediction ) ) ; wm . setProperty ( JITTER_PROPERTY , Double . toString ( jitter ) ) ; }
public ServiceID ( DataInput in ) throws IOException { this . mostSig = in . readLong ( ) ; this . leastSig = in . readLong ( ) ; }
public void onEnterElementConsumed ( String uri , String localName , String qname , Attributes atts ) throws SAXException { attStack . push ( currentAtts = new AttributesImpl ( atts ) ) ; nsEffectiveStack . push ( new Integer ( nsEffectivePtr ) ) ; nsEffectivePtr = namespaces . size ( ) ; }
private void addFinally ( ArrayList returnList , Stmnt finallyBlock ) throws CompileError { Bytecode bc = bytecode ; int n = returnList . size ( ) ; for ( int i = NUM_ ; i < n ; ++ i ) { final int [ ] ret = ( int [ ] ) returnList . get ( i ) ; int pc = ret [ NUM_ ] ; bc . write16bit ( pc , bc . currentPc ( ) - pc + NUM_ ) ; ReturnHook hook = new JsrHook2 ( this , ret ) ; finallyBlock . accept ( this ) ; hook . remove ( this ) ; if ( ! hasReturned ) { bc . addOpcode ( Opcode . GOTO ) ; bc . addIndex ( pc + NUM_ - bc . currentPc ( ) ) ; } } }
public Object nextMeta ( ) throws JSONException { char c ; char q ; do { c = next ( ) ; } while ( Character . isWhitespace ( c ) ) ; switch ( c ) { case NUM_ : throw syntaxError ( STR_ ) ; case STR_ : return XML . LT ; case STR_ : return XML . GT ; case STR_ : return XML . SLASH ; case STR_ : return XML . EQ ; case STR_ : return XML . BANG ; case STR_ : return XML . QUEST ; case STR_ : case STR_ : q = c ; for ( ; ; ) { c = next ( ) ; if ( c == NUM_ ) { throw syntaxError ( STR_ ) ; } if ( c == q ) { return Boolean . TRUE ; } } default : for ( ; ; ) { c = next ( ) ; if ( Character . isWhitespace ( c ) ) { return Boolean . TRUE ; } switch ( c ) { case NUM_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : back ( ) ; return Boolean . TRUE ; } } } }
private boolean checkTouchSlop ( View child , float dx , float dy ) { if ( child == null ) { return BOOL_ ; } final boolean checkHorizontal = mCallback . getViewHorizontalDragRange ( child ) > NUM_ ; final boolean checkVertical = mCallback . getViewVerticalDragRange ( child ) > NUM_ ; if ( checkHorizontal && checkVertical ) { return dx . dx + dy . dy > mTouchSlop . mTouchSlop ; } else if ( checkHorizontal ) { return Math . abs ( dx ) > mTouchSlop ; } else if ( checkVertical ) { return Math . abs ( dy ) > mTouchSlop ; } return BOOL_ ; }
public static void writeJSONString ( Collection collection , Writer out ) throws IOException { if ( collection == null ) { out . write ( STR_ ) ; return ; } boolean first = BOOL_ ; Iterator iter = collection . iterator ( ) ; out . write ( STR_ ) ; while ( iter . hasNext ( ) ) { if ( first ) first = BOOL_ ; else out . write ( STR_ ) ; Object value = iter . next ( ) ; if ( value == null ) { out . write ( STR_ ) ; continue ; } JSONValue . writeJSONString ( value , out ) ; } out . write ( STR_ ) ; }
protected int [ ] readColorTable ( final int ncolors ) { final int nbytes = NUM_ . ncolors ; int [ ] tab = null ; final byte [ ] c = new byte [ nbytes ] ; try { rawData . get ( c ) ; tab = new int [ NUM_ ] ; int i = NUM_ ; int j = NUM_ ; while ( i < ncolors ) { final int r = ( c [ j ++ ] ) & xff ; final int g = ( c [ j ++ ] ) & xff ; final int b = ( c [ j ++ ] ) & xff ; tab [ i ++ ] = xff000000 | ( r << NUM_ ) | ( g << NUM_ ) | b ; } } catch ( final BufferUnderflowException e ) { Log . w ( TAG , STR_ , e ) ; status = STATUS_FORMAT_ERROR ; } return tab ; }
void touch ( boolean openReadOnly ) throws IOException { if ( isReadOnly || openReadOnly ) { throw new IOException ( STR_ ) ; } lastModified = System . currentTimeMillis ( ) ; }
void pushImportURL ( String hrefUrl ) { m_importStack . push ( hrefUrl ) ; }
@ SneakyThrows public void addKeyToKeystore ( KeyStore keyStore , X509Certificate cert , RSAPrivateKey privateKey , String alias , String password ) { KeyStore . PasswordProtection pass = new KeyStore . PasswordProtection ( password . toCharArray ( ) ) ; Certificate [ ] certificateChain = { cert } ; keyStore . setEntry ( alias , new KeyStore . PrivateKeyEntry ( privateKey , certificateChain ) , pass ) ; }
public boolean needsReload ( File file ) { return fFilesToReoad . contains ( file ) ; }
protected int drawLegend ( Canvas canvas , DefaultRenderer renderer , String [ ] titles , int left , int right , int y , int width , int height , int legendSize , Paint paint , boolean calculate ) { float size = NUM_ ; if ( renderer . isShowLegend ( ) ) { float currentX = left ; float currentY = y + height - legendSize + size ; paint . setTextAlign ( Component . LEFT ) ; paint . setTextSize ( renderer . getLegendTextSize ( ) ) ; int sLength = Math . min ( titles . length , renderer . getSeriesRendererCount ( ) ) ; for ( int i = NUM_ ; i < sLength ; i ++ ) { SimpleSeriesRenderer r = renderer . getSeriesRendererAt ( i ) ; final float lineSize = getLegendShapeWidth ( i ) ; if ( r . isShowLegendItem ( ) ) { String text = titles [ i ] ; if ( titles . length == renderer . getSeriesRendererCount ( ) ) { paint . setColor ( r . getColor ( ) ) ; } else { paint . setColor ( ColorUtil . LTGRAY ) ; } float [ ] widths = new float [ text . length ( ) ] ; paint . getTextWidths ( text , widths ) ; float sum = NUM_ ; for ( float value : widths ) { sum += value ; } float extraSize = lineSize + NUM_ + sum ; float currentWidth = currentX + extraSize ; if ( i > NUM_ && getExceed ( currentWidth , renderer , right , width ) ) { currentX = left ; currentY += renderer . getLegendTextSize ( ) ; size += renderer . getLegendTextSize ( ) ; currentWidth = currentX + extraSize ; } if ( getExceed ( currentWidth , renderer , right , width ) ) { float maxWidth = right - currentX - lineSize - NUM_ ; if ( isVertical ( renderer ) ) { maxWidth = width - currentX - lineSize - NUM_ ; } int nr = paint . breakText ( text , BOOL_ , maxWidth , widths ) ; text = text . substring ( NUM_ , nr ) + STR_ ; } if ( ! calculate ) { drawLegendShape ( canvas , r , currentX , currentY , i , paint ) ; drawString ( canvas , text , currentX + lineSize + NUM_ , currentY + NUM_ , paint ) ; } currentX += extraSize ; } } } return Math . round ( size + renderer . getLegendTextSize ( ) ) ; }
public PutRepositoryRequest source ( byte [ ] repositoryDefinition ) { return source ( repositoryDefinition , NUM_ , repositoryDefinition . length ) ; }
private void disableButtons ( ) { setFireEnabled ( BOOL_ ) ; setSkipEnabled ( BOOL_ ) ; setTwistEnabled ( BOOL_ ) ; setNextEnabled ( BOOL_ ) ; butDone . setEnabled ( BOOL_ ) ; setFlipArmsEnabled ( BOOL_ ) ; setFireModeEnabled ( BOOL_ ) ; setNextTargetEnabled ( BOOL_ ) ; }
public boolean isAdditiveNumber ( String num ) { int n = num . length ( ) ; for ( int i = NUM_ ; i <= n / NUM_ ; i ++ ) { if ( num . charAt ( NUM_ ) == STR_ && i > NUM_ ) { return BOOL_ ; } BigInteger num1 = new BigInteger ( num . substring ( NUM_ , i ) ) ; for ( int j = NUM_ ; Math . max ( i , j ) <= n - i - j ; j ++ ) { if ( num . charAt ( i ) == STR_ && j > NUM_ ) { break ; } BigInteger num2 = new BigInteger ( num . substring ( i , i + j ) ) ; if ( isAdditiveNumber ( num1 , num2 , i + j , num ) ) { return BOOL_ ; } } } return BOOL_ ; }
@ Override public void write ( String str ) { int start = NUM_ ; while ( start < str . length ( ) ) { int end = Math . min ( start + MAX_MESSAGE_LENGTH , str . length ( ) ) ; Log . i ( TAG , str . substring ( start , end ) ) ; start = end ; } }
protected void addToQuarantineQueue ( NodePortTuple npt ) { if ( quarantineQueue . contains ( npt ) == BOOL_ ) { quarantineQueue . add ( npt ) ; } }
private CarbonDictionarySortInfo createColumnSortInfo ( CarbonDictionarySortModel [ ] dictionarySortModels ) { int [ ] sortIndex ; int [ ] sortIndexInverted ; Arrays . sort ( dictionarySortModels ) ; sortIndex = new int [ dictionarySortModels . length ] ; sortIndexInverted = new int [ dictionarySortModels . length ] ; for ( int i = NUM_ ; i < dictionarySortModels . length ; i ++ ) { CarbonDictionarySortModel dictionarySortModel = dictionarySortModels [ i ] ; sortIndex [ i ] = dictionarySortModel . getKey ( ) ; sortIndexInverted [ dictionarySortModel . getKey ( ) - NUM_ ] = i + NUM_ ; } dictionarySortModels = null ; List < Integer > sortIndexList = convertToList ( sortIndex ) ; List < Integer > sortIndexInvertedList = convertToList ( sortIndexInverted ) ; return new CarbonDictionarySortInfo ( sortIndexList , sortIndexInvertedList ) ; }
private void addFeature ( JsonNode feature , int index ) { PointFeature feat = null ; try { feat = PointFeature . fromJsonNode ( feature ) ; } catch ( EmptyPolygonException e ) { LOG . warn ( STR_ ) ; return ; } catch ( UnsupportedGeometryException e ) { LOG . warn ( e . message ) ; return ; } if ( feat == null ) { return ; } addFeature ( feat , index ) ; }
public BitString ( final String value ) { this ( value . length ( ) ) ; for ( int i = NUM_ ; i < value . length ( ) ; i ++ ) { if ( value . charAt ( i ) == STR_ ) { setBit ( value . length ( ) - ( i + NUM_ ) , BOOL_ ) ; } else if ( value . charAt ( i ) != STR_ ) { throw new IllegalArgumentException ( STR_ + i ) ; } } }
public void sort ( Comparator < Individual > comparator ) { Collections . sort ( individuals , comparator ) ; }
public void write ( Writer writer ) throws Exception { writer . write ( toString ( ) ) ; writer . flush ( ) ; }
public SafeAsyncTask ( ) { this . executor = DEFAULT_EXECUTOR ; }
public static boolean isCglibRenamedMethod ( Method renamedMethod ) { String name = renamedMethod . getName ( ) ; if ( name . startsWith ( CGLIB_RENAMED_METHOD_PREFIX ) ) { int i = name . length ( ) - NUM_ ; while ( i >= NUM_ && Character . isDigit ( name . charAt ( i ) ) ) { i -- ; } return ( ( i > CGLIB_RENAMED_METHOD_PREFIX . length ( ) ) && ( i < name . length ( ) - NUM_ ) && ( name . charAt ( i ) == STR_ ) ) ; } return BOOL_ ; }
public PWResetException ( String bundleName , String errCode , Object [ ] args ) { super ( bundleName , errCode , args ) ; errList = new ArrayList ( NUM_ ) ; errList . add ( getMessage ( ) ) ; }
public static String [ ] unionArrays ( String [ ] array1 , String [ ] array2 ) { if ( array1 == null ) { return array2 ; } if ( array2 == null ) { return array1 ; } Set < String > set = new LinkedHashSet < > ( ) ; set . addAll ( Arrays . asList ( array1 ) ) ; set . addAll ( Arrays . asList ( array2 ) ) ; return set . toArray ( new String [ set . size ( ) ] ) ; }
boolean isStateChange ( XDecoratedPeer window , XPropertyEvent e ) { if ( ! window . isShowing ( ) ) { stateLog . finer ( STR_ ) ; return BOOL_ ; } int wm_state = window . getWMState ( ) ; if ( wm_state == XUtilConstants . WithdrawnState ) { stateLog . finer ( STR_ ) ; return BOOL_ ; } else { if ( stateLog . isLoggable ( PlatformLogger . Level . FINER ) ) { stateLog . finer ( STR_ + wm_state ) ; } } boolean is_state_change = BOOL_ ; if ( e . get_atom ( ) == XA_WM_STATE . getAtom ( ) ) { is_state_change = BOOL_ ; } for ( XStateProtocol proto : getProtocols ( XStateProtocol . class ) ) { is_state_change |= proto . isStateChange ( e ) ; if ( stateLog . isLoggable ( PlatformLogger . Level . FINEST ) ) { stateLog . finest ( proto + STR_ + is_state_change ) ; } } return is_state_change ; }
@ Override public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { Node xpathOwnerNode = ( Node ) xctxt . getOwnerObject ( ) ; if ( xpathOwnerNode == null ) { return null ; } int xpathOwnerNodeDTM = xctxt . getDTMHandleFromNode ( xpathOwnerNode ) ; int currentNode = xctxt . getCurrentNode ( ) ; DTM dtm = xctxt . getDTM ( currentNode ) ; int docContext = dtm . getDocument ( ) ; if ( DTM . NULL == docContext ) { error ( xctxt , XPATHErrorResources . ER_CONTEXT_HAS_NO_OWNERDOC , null ) ; } { Document currentDoc = XMLUtils . getOwnerDocument ( dtm . getNode ( currentNode ) ) ; Document xpathOwnerDoc = XMLUtils . getOwnerDocument ( xpathOwnerNode ) ; if ( currentDoc != xpathOwnerDoc ) { throw new TransformerException ( I18n . translate ( STR_ ) ) ; } } XNodeSet nodes = new XNodeSet ( xctxt . getDTMManager ( ) ) ; NodeSetDTM nodeSet = nodes . mutableNodeset ( ) ; { int hereNode = DTM . NULL ; switch ( dtm . getNodeType ( xpathOwnerNodeDTM ) ) { case Node . ATTRIBUTE_NODE : case Node . PROCESSING_INSTRUCTION_NODE : { hereNode = xpathOwnerNodeDTM ; nodeSet . addNode ( hereNode ) ; break ; } case Node . TEXT_NODE : { hereNode = dtm . getParent ( xpathOwnerNodeDTM ) ; nodeSet . addNode ( hereNode ) ; break ; } default : break ; } } nodeSet . detach ( ) ; return nodes ; }
public List < LocalTime > top ( int n ) { List < LocalTime > top = new ArrayList < > ( ) ; int [ ] values = data . toIntArray ( ) ; IntArrays . parallelQuickSort ( values , ReverseIntComparator . instance ( ) ) ; for ( int i = NUM_ ; i < n && i < values . length ; i ++ ) { top . add ( PackedLocalTime . asLocalTime ( values [ i ] ) ) ; } return top ; }
public static String grabClass ( String signature ) { Matcher matcher = sigRE . matcher ( signature ) ; boolean b = matcher . matches ( ) ; if ( ! b && matcher . groupCount ( ) != NUM_ ) logger . error ( STR_ , signature ) ; return matcher . group ( NUM_ ) ; }
public TimeSeriesMetricDeltaSet ( Stream < Entry < Tags , MetricValue > > td ) { values_ = Any2 . right ( td . collect ( Collectors . toMap ( null , null , null , null ) ) ) ; }
public int size ( ) { return nodes . size ( ) ; }
@ Override public final E nextElement ( ) { E result = m_Vector . get ( m_Counter ) ; m_Counter ++ ; if ( m_Counter == m_SpecialElement ) { m_Counter ++ ; } return result ; }
private ByteString escapeBytes ( final ByteString value ) { if ( ! needEscaping ( value ) ) { return value ; } final ByteStringBuilder builder = new ByteStringBuilder ( ) ; for ( int i = NUM_ ; i < value . length ( ) ; i ++ ) { final byte b = value . byteAt ( i ) ; if ( isByteToEscape ( b ) ) { builder . appendByte ( DN . NORMALIZED_ESC_BYTE ) ; } builder . appendByte ( b ) ; } return builder . toByteString ( ) ; }
public InputBuilder < T > repeatAll ( int times ) { List < T > toAppend = new ArrayList < > ( ) ; for ( int i = NUM_ ; i < times ; i ++ ) { toAppend . addAll ( input ) ; } input . addAll ( toAppend ) ; return this ; }
public final void renameClass ( Map classnames ) { String jvmNewThisName = ( String ) classnames . get ( Descriptor . toJvmName ( thisclassname ) ) ; if ( jvmNewThisName != null ) thisclassname = Descriptor . toJavaName ( jvmNewThisName ) ; constPool . renameClass ( classnames ) ; AttributeInfo . renameClass ( attributes , classnames ) ; ArrayList list = methods ; int n = list . size ( ) ; for ( int i = NUM_ ; i < n ; ++ i ) { MethodInfo minfo = ( MethodInfo ) list . get ( i ) ; String desc = minfo . getDescriptor ( ) ; minfo . setDescriptor ( Descriptor . rename ( desc , classnames ) ) ; AttributeInfo . renameClass ( minfo . getAttributes ( ) , classnames ) ; } list = fields ; n = list . size ( ) ; for ( int i = NUM_ ; i < n ; ++ i ) { FieldInfo finfo = ( FieldInfo ) list . get ( i ) ; String desc = finfo . getDescriptor ( ) ; finfo . setDescriptor ( Descriptor . rename ( desc , classnames ) ) ; AttributeInfo . renameClass ( finfo . getAttributes ( ) , classnames ) ; } }
@ SuppressWarnings ( STR_ ) public void handleButton3Request ( RequestInvocationEvent event ) { backTrail ( ) ; try { String name = ( String ) getPageSessionAttribute ( SAVE_VB_NAME ) ; ViewBean vb = getViewBean ( Class . forName ( name ) ) ; passPgSessionMap ( vb ) ; vb . forwardTo ( getRequestContext ( ) ) ; } catch ( ClassNotFoundException e ) { debug . warning ( STR_ , e ) ; } }
public IonException ( Throwable cause ) { super ( cause . getMessage ( ) , cause ) ; }
public final double distance ( ) { return Math . sqrt ( distance_square ( ) ) ; }
@ Override public void done ( ) { super . done ( ) ; if ( mNumTestsExpected > mNumTestsRun ) { handleTestRunFailed ( String . format ( STR_ , mNumTestsExpected , mNumTestsRun ) ) ; } else if ( mTestRunInProgress ) { handleTestRunFailed ( STR_ ) ; } }
public List < Challenge > challenges ( ) { String responseField ; if ( code == HTTP_UNAUTHORIZED ) { responseField = STR_ ; } else if ( code == HTTP_PROXY_AUTH ) { responseField = STR_ ; } else { return Collections . emptyList ( ) ; } return OkHeaders . parseChallenges ( headers ( ) , responseField ) ; }
byte [ ] toBytes ( SSLSession session ) { if ( ! ( session instanceof OpenSSLSessionImpl ) ) { return null ; } OpenSSLSessionImpl sslSession = ( OpenSSLSessionImpl ) session ; try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DataOutputStream daos = new DataOutputStream ( baos ) ; daos . writeInt ( OPEN_SSL ) ; byte [ ] data = sslSession . getEncoded ( ) ; daos . writeInt ( data . length ) ; daos . write ( data ) ; Certificate [ ] certs = session . getPeerCertificates ( ) ; daos . writeInt ( certs . length ) ; for ( Certificate cert : certs ) { data = cert . getEncoded ( ) ; daos . writeInt ( data . length ) ; daos . write ( data ) ; } return baos . toByteArray ( ) ; } catch ( IOException e ) { log ( e ) ; return null ; } catch ( CertificateEncodingException e ) { log ( e ) ; return null ; } }
public MersenneTwister ( ) { mt = new int [ N ] ; setSeed ( System . currentTimeMillis ( ) + System . identityHashCode ( this ) ) ; }
private void verifyTimestamp ( X509Certificate cert ) throws CertPathValidatorException { String msg = STR_ ; if ( debug != null ) debug . println ( STR_ + msg + STR_ + date . toString ( ) + STR_ ) ; try { cert . checkValidity ( date ) ; } catch ( CertificateExpiredException e ) { throw new CertPathValidatorException ( msg + STR_ , e , null , - NUM_ , BasicReason . EXPIRED ) ; } catch ( CertificateNotYetValidException e ) { throw new CertPathValidatorException ( msg + STR_ , e , null , - NUM_ , BasicReason . NOT_YET_VALID ) ; } if ( debug != null ) debug . println ( msg + STR_ ) ; }
public static byte [ ] encryptPassword ( final String password , final byte [ ] seed ) throws NoSuchAlgorithmException { if ( password == null || password . equals ( STR_ ) ) { return new byte [ NUM_ ] ; } final MessageDigest messageDigest = MessageDigest . getInstance ( STR_ ) ; final byte [ ] stage1 = messageDigest . digest ( password . getBytes ( ) ) ; messageDigest . reset ( ) ; final byte [ ] stage2 = messageDigest . digest ( stage1 ) ; messageDigest . reset ( ) ; messageDigest . update ( seed ) ; messageDigest . update ( stage2 ) ; final byte [ ] digest = messageDigest . digest ( ) ; final byte [ ] returnBytes = new byte [ digest . length ] ; for ( int i = NUM_ ; i < digest . length ; i ++ ) { returnBytes [ i ] = ( byte ) ( stage1 [ i ] ^ digest [ i ] ) ; } return returnBytes ; }
public int rows ( ) { return rows ; }
private static byte [ ] streamToBytes ( InputStream in , int length ) throws IOException { byte [ ] bytes = new byte [ length ] ; int count ; int pos = NUM_ ; while ( pos < length && ( ( count = in . read ( bytes , pos , length - pos ) ) != - NUM_ ) ) { pos += count ; } if ( pos != length ) { throw new IOException ( STR_ + length + STR_ + pos + STR_ ) ; } return bytes ; }
public static String array2hex ( final byte [ ] array ) { return byteArray2String ( array , STR_ , STR_ , BOOL_ , NUM_ ) ; }
private byte [ ] writeCheckedBytes ( MessageNano proto ) { BackupProtos . CheckedMessage wrapper = new BackupProtos . CheckedMessage ( ) ; wrapper . payload = MessageNano . toByteArray ( proto ) ; CRC32 checksum = new CRC32 ( ) ; checksum . update ( wrapper . payload ) ; wrapper . checksum = checksum . getValue ( ) ; return MessageNano . toByteArray ( wrapper ) ; }
public double reduceTo ( int width , int height , double limit ) { int w = getIconWidth ( ) ; int h = getIconHeight ( ) ; double scale = NUM_ ; if ( w > width ) { scale = ( ( double ) width ) / w ; } if ( h > height ) { scale = Math . min ( scale , ( ( double ) height ) / h ) ; } if ( scale < NUM_ ) { if ( limit > NUM_ ) { scale = Math . max ( scale , limit ) ; } AffineTransform t = AffineTransform . getScaleInstance ( scale , scale ) ; transformImage ( ( int ) Math . ceil ( scale . w ) , ( int ) Math . ceil ( scale . h ) , t , null ) ; } return scale ; }
public void installBuiltinSound ( String soundIdentifier , InputStream data ) throws IOException { builtinSounds . put ( soundIdentifier , convertBuiltinSound ( data ) ) ; }
private Integer countFragmentFilteredPages ( List < String > templateFragments , boolean whitelist ) throws WikiApiException { try { int count = NUM_ ; PreparedStatement statement = null ; ResultSet result = null ; try { StringBuffer sqlString = new StringBuffer ( ) ; StringBuffer subconditions = new StringBuffer ( ) ; sqlString . append ( STR_ + GeneratorConstants . TABLE_TPLID_TPLNAME + STR_ + GeneratorConstants . TABLE_TPLID_PAGEID + STR_ + ( whitelist ? STR_ : STR_ ) + STR_ ) ; for ( @ SuppressWarnings ( STR_ ) String fragment : templateFragments ) { if ( subconditions . length ( ) != NUM_ ) { subconditions . append ( STR_ ) ; } subconditions . append ( STR_ ) ; } sqlString . append ( subconditions ) ; sqlString . append ( STR_ ) ; statement = connection . prepareStatement ( sqlString . toString ( ) ) ; int curIdx = NUM_ ; for ( String fragment : templateFragments ) { fragment = fragment . toLowerCase ( ) ; fragment = fragment . trim ( ) ; fragment = fragment . replaceAll ( STR_ , STR_ ) ; statement . setString ( curIdx ++ , fragment + STR_ ) ; } result = execute ( statement ) ; if ( result == null ) { return NUM_ ; } if ( result . next ( ) ) { count = result . getInt ( NUM_ ) ; } } finally { if ( statement != null ) { statement . close ( ) ; } if ( result != null ) { result . close ( ) ; } } return count ; } catch ( Exception e ) { throw new WikiApiException ( e ) ; } }
public static int findName ( String name , int [ ] table ) { for ( int i = NUM_ ; i < table . length ; i ++ ) { if ( name . equals ( getName ( table [ i ] ) ) ) { return i ; } } return - NUM_ ; }
private static Bitmap transform ( Matrix scaler , Bitmap source , int targetWidth , int targetHeight , int options ) { Log . i ( TAG , STR_ ) ; boolean scaleUp = ( options & x1 ) != NUM_ ; boolean recycle = ( options & x2 ) != NUM_ ; int deltaX = source . getWidth ( ) - targetWidth ; int deltaY = source . getHeight ( ) - targetHeight ; if ( ! scaleUp && ( deltaX < NUM_ || deltaY < NUM_ ) ) { Log . i ( TAG , STR_ ) ; Bitmap b2 = Bitmap . createBitmap ( targetWidth , targetHeight , Bitmap . Config . ARGB_8888 ) ; Canvas c = new Canvas ( b2 ) ; int deltaXHalf = Math . max ( NUM_ , deltaX / NUM_ ) ; int deltaYHalf = Math . max ( NUM_ , deltaY / NUM_ ) ; Rect src = new Rect ( deltaXHalf , deltaYHalf , deltaXHalf + Math . min ( targetWidth , source . getWidth ( ) ) , deltaYHalf + Math . min ( targetHeight , source . getHeight ( ) ) ) ; int dstX = ( targetWidth - src . width ( ) ) / NUM_ ; int dstY = ( targetHeight - src . height ( ) ) / NUM_ ; Rect dst = new Rect ( dstX , dstY , targetWidth - dstX , targetHeight - dstY ) ; c . drawBitmap ( source , src , dst , null ) ; if ( recycle ) { source . recycle ( ) ; } c . setBitmap ( null ) ; Log . i ( TAG , STR_ ) ; return b2 ; } float bitmapWidthF = source . getWidth ( ) ; float bitmapHeightF = source . getHeight ( ) ; Log . i ( TAG , STR_ + bitmapWidthF + STR_ + bitmapHeightF ) ; float bitmapAspect = bitmapWidthF / bitmapHeightF ; float viewAspect = ( float ) targetWidth / targetHeight ; Log . i ( TAG , STR_ + targetWidth + STR_ + targetHeight ) ; if ( bitmapAspect > viewAspect ) { float scale = targetHeight / bitmapHeightF ; if ( scale < NUM_ || scale > NUM_ ) { scaler . setScale ( scale , scale ) ; } else { scaler = null ; } } else { float scale = targetWidth / bitmapWidthF ; if ( scale < NUM_ || scale > NUM_ ) { scaler . setScale ( scale , scale ) ; } else { scaler = null ; } } Bitmap b1 ; if ( scaler != null ) { Log . i ( TAG , STR_ ) ; b1 = Bitmap . createBitmap ( source , NUM_ , NUM_ , source . getWidth ( ) , source . getHeight ( ) , scaler , BOOL_ ) ; } else { Log . i ( TAG , STR_ ) ; b1 = source ; } if ( recycle && b1 != source ) { Log . i ( TAG , STR_ ) ; source . recycle ( ) ; } int dx1 = Math . max ( NUM_ , b1 . getWidth ( ) - targetWidth ) ; int dy1 = Math . max ( NUM_ , b1 . getHeight ( ) - targetHeight ) ; Bitmap b2 = Bitmap . createBitmap ( b1 , dx1 / NUM_ , dy1 / NUM_ , targetWidth , targetHeight ) ; if ( b2 != b1 ) { if ( recycle || b1 != source ) { Log . i ( TAG , STR_ ) ; b1 . recycle ( ) ; } } Log . i ( TAG , STR_ ) ; if ( b2 == null ) { Log . i ( TAG , STR_ ) ; } return b2 ; }
private void scoreTrackResults ( Collection < Track > tracks , SearchQuery query , Collection < ScoredResult > output ) { for ( Track track : tracks ) { double score = scoreTrackResult ( query , track ) ; output . add ( new ScoredResult ( track , score ) ) ; } }
private Long currentTime ( ) { return System . currentTimeMillis ( ) / NUM_ ; }
public static void v ( String tag , String msg , Object ... args ) { if ( sLevel > LEVEL_VERBOSE ) { return ; } if ( args . length > NUM_ ) { msg = String . format ( msg , args ) ; } Log . v ( tag , msg ) ; }
private static byte [ ] encode ( double latitude , double longitude ) { byte [ ] bytes = new byte [ NUM_ . Integer . BYTES ] ; NumericUtils . intToSortableBytes ( encodeLatitude ( latitude ) , bytes , NUM_ ) ; NumericUtils . intToSortableBytes ( encodeLongitude ( longitude ) , bytes , Integer . BYTES ) ; return bytes ; }
public static void putLongVolatile ( Object obj , long off , long val ) { UNSAFE . putLongVolatile ( obj , off , val ) ; }
public static List < String > run ( List < String > commands ) { return Shell . run ( STR_ , commands . toArray ( new String [ commands . size ( ) ] ) , null , BOOL_ ) ; }
public void circle ( double x , double y , double r ) { if ( r < NUM_ ) throw new IllegalArgumentException ( STR_ ) ; double xs = scaleX ( x ) ; double ys = scaleY ( y ) ; double ws = factorX ( NUM_ . r ) ; double hs = factorY ( NUM_ . r ) ; if ( ws <= NUM_ && hs <= NUM_ ) pixel ( x , y ) ; else offscreen . draw ( new Ellipse2D . Double ( xs - ws / NUM_ , ys - hs / NUM_ , ws , hs ) ) ; draw ( ) ; }
final public void println ( double v ) { Writer out = this . out ; if ( out == null ) return ; print ( v ) ; try { out . write ( _newline , NUM_ , _newline . length ) ; } catch ( IOException e ) { log . log ( Level . FINE , e . toString ( ) , e ) ; } }
public void writeSI32 ( int value ) throws IOException { flushBits ( ) ; out . write ( value & xff ) ; out . write ( value > > NUM_ ) ; out . write ( value > > NUM_ ) ; out . write ( value > > NUM_ ) ; bytesWritten += NUM_ ; }
private static void map ( final StringBuilder buffer , final ByteSequence sequence , final boolean trim , final boolean foldCase ) { final String value = sequence . toString ( ) ; for ( int i = NUM_ ; i < value . length ( ) ; i ++ ) { final char c = value . charAt ( i ) ; if ( MAP_2_NULL . contains ( c ) ) { continue ; } if ( MAP_2_SPACE . contains ( c ) ) { if ( canMapToSpace ( buffer , trim ) ) { buffer . append ( SPACE_CHAR ) ; } continue ; } if ( foldCase ) { final String mapping = CASE_MAP_TABLE . get ( c ) ; if ( mapping != null ) { buffer . append ( mapping ) ; continue ; } } buffer . append ( c ) ; } }
public void addButtonPressedListener ( FieldConfigStringButtonInterface listener ) { if ( buttonPressedListenerList == null ) { buttonPressedListenerList = new ArrayList < FieldConfigStringButtonInterface > ( ) ; } buttonPressedListenerList . add ( listener ) ; }
public void dispose ( ) { logDebug ( STR_ ) ; mSetupDone = BOOL_ ; if ( mServiceConn != null ) { logDebug ( STR_ ) ; if ( mContext != null ) mContext . unbindService ( mServiceConn ) ; mServiceConn = null ; mService = null ; mPurchaseListener = null ; } }
private void fillXMLAttribute ( Attributes att , int index ) { fillQName ( fAttributeQName , att . getURI ( index ) , att . getLocalName ( index ) , att . getQName ( index ) ) ; String type = att . getType ( index ) ; fAttributes . addAttributeNS ( fAttributeQName , ( type != null ) ? type : XMLSymbols . fCDATASymbol , att . getValue ( index ) ) ; }
public JComponent createPropertyGUI ( PropertyConsumer pc ) { this . propertyConsumer = pc ; Properties props = new Properties ( ) ; props = pc . getProperties ( props ) ; Properties info = new Properties ( ) ; info = pc . getPropertyInfo ( info ) ; String prefix = pc . getPropertyPrefix ( ) ; return createPropertyGUI ( prefix , props , info ) ; }
public long copy ( String filename , OutputStream out , long offset , long size ) throws IOException , InterruptedException { if ( size < NUM_ ) { return NUM_ ; } BufferedInputStream is = new BufferedInputStream ( getFileInputStream ( filename ) ) ; byte [ ] buf = new byte [ NUM_ . NUM_ ] ; int bytesRead ; long pos = NUM_ ; long remaining = size ; try { if ( offset != NUM_ ) { is . skip ( offset ) ; pos += offset ; } while ( remaining != NUM_ ) { int max = buf . length ; if ( max > remaining ) { max = ( int ) remaining ; } bytesRead = is . read ( buf , NUM_ , max ) ; if ( bytesRead == - NUM_ ) { break ; } out . write ( buf , NUM_ , bytesRead ) ; pos += bytesRead ; remaining -= bytesRead ; } out . flush ( ) ; } catch ( Exception e ) { out . flush ( ) ; } finally { try { is . close ( ) ; } catch ( Exception e ) { } } return pos ; }
private static void deserializeHeader ( KdbHeader kdbHeader , DataInput dataInput ) throws IOException { kdbHeader . setFlags ( dataInput . readInt ( ) ) ; kdbHeader . setVersion ( dataInput . readInt ( ) ) ; byte [ ] buffer = new byte [ NUM_ ] ; dataInput . readFully ( buffer ) ; kdbHeader . setMasterSeed ( buffer ) ; buffer = new byte [ NUM_ ] ; dataInput . readFully ( buffer ) ; kdbHeader . setEncryptionIv ( buffer ) ; kdbHeader . setGroupCount ( dataInput . readInt ( ) ) ; kdbHeader . setEntryCount ( dataInput . readInt ( ) ) ; byte [ ] buffer32 = new byte [ NUM_ ] ; dataInput . readFully ( buffer32 ) ; kdbHeader . setContentHash ( buffer32 ) ; buffer32 = new byte [ NUM_ ] ; dataInput . readFully ( buffer32 ) ; kdbHeader . setTransformSeed ( buffer32 ) ; kdbHeader . setTransformRounds ( dataInput . readInt ( ) ) ; }
public List < JCAnnotation > transformAnnotations ( OutputElement target , Tree . Declaration annotated ) { EnumSet < OutputElement > outputs ; if ( annotated instanceof Tree . AnyClass ) { outputs = AnnotationUtil . outputs ( ( Tree . AnyClass ) annotated ) ; } else if ( annotated instanceof Tree . AnyInterface ) { outputs = AnnotationUtil . outputs ( ( Tree . AnyInterface ) annotated ) ; } else if ( annotated instanceof Tree . TypeAliasDeclaration ) { outputs = AnnotationUtil . outputs ( ( Tree . TypeAliasDeclaration ) annotated ) ; } else if ( annotated instanceof Tree . Constructor ) { outputs = AnnotationUtil . outputs ( ( Tree . Constructor ) annotated ) ; } else if ( annotated instanceof Tree . Enumerated ) { outputs = AnnotationUtil . outputs ( ( Tree . Enumerated ) annotated ) ; } else if ( annotated instanceof Tree . AnyMethod ) { outputs = AnnotationUtil . outputs ( ( Tree . AnyMethod ) annotated ) ; } else if ( annotated instanceof Tree . AttributeDeclaration ) { outputs = AnnotationUtil . outputs ( ( Tree . AttributeDeclaration ) annotated ) ; } else if ( annotated instanceof Tree . AttributeGetterDefinition ) { outputs = AnnotationUtil . outputs ( ( Tree . AttributeGetterDefinition ) annotated ) ; } else if ( annotated instanceof Tree . AttributeSetterDefinition ) { outputs = AnnotationUtil . outputs ( ( Tree . AttributeSetterDefinition ) annotated ) ; } else if ( annotated instanceof Tree . ObjectDefinition ) { outputs = AnnotationUtil . outputs ( ( Tree . ObjectDefinition ) annotated ) ; } else { throw BugException . unhandledNodeCase ( annotated ) ; } return transform ( annotated . getDeclarationModel ( ) , target , annotated . getAnnotationList ( ) , outputs ) ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; String childData ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; nameNode = elementList . item ( NUM_ ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; child . insertData ( NUM_ , STR_ ) ; childData = child . getData ( ) ; assertEquals ( STR_ , STR_ , childData ) ; }
public boolean areAllPermissionsGranted ( ) { return deniedPermissionResponses . isEmpty ( ) ; }
private String fetchCharsetFromCache ( Client client , Locale loc ) { Map cCache = ( Map ) charsetCache . get ( client . getClientType ( ) ) ; String val = null ; if ( cCache != null ) { val = ( String ) cCache . get ( loc ) ; } return val ; }
public Shape paintLayer ( Graphics g , int offs0 , int offs1 , Shape bounds , JTextComponent c , View view ) { g . setColor ( getColor ( ) ) ; if ( offs0 == view . getStartOffset ( ) && offs1 == view . getEndOffset ( ) ) { Rectangle alloc ; if ( bounds instanceof Rectangle ) alloc = ( Rectangle ) bounds ; else alloc = bounds . getBounds ( ) ; paintSquiggle ( g , alloc ) ; return alloc ; } try { Shape shape = view . modelToView ( offs0 , Position . Bias . Forward , offs1 , Position . Bias . Backward , bounds ) ; Rectangle r = ( shape instanceof Rectangle ) ? ( Rectangle ) shape : shape . getBounds ( ) ; paintSquiggle ( g , r ) ; return r ; } catch ( BadLocationException e ) { e . printStackTrace ( ) ; } return null ; }
public void addControlRoll ( PilotingRollData control ) { controlRolls . addElement ( control ) ; }
void processAddOnChanges ( Window caller , AddOnDependencyChecker . AddOnChangesResult changes ) { if ( addonsDialog != null ) { addonsDialog . setDownloadingUpdates ( ) ; } if ( getView ( ) != null ) { Set < AddOn > addOns = new HashSet < > ( changes . getUninstalls ( ) ) ; addOns . addAll ( changes . getOldVersions ( ) ) ; Set < Extension > extensions = new HashSet < > ( ) ; extensions . addAll ( changes . getUnloadExtensions ( ) ) ; extensions . addAll ( changes . getSoftUnloadExtensions ( ) ) ; if ( ! warnUnsavedResourcesOrActiveActions ( caller , addOns , extensions , BOOL_ ) ) { return ; } } uninstallAddOns ( caller , changes . getUninstalls ( ) , BOOL_ ) ; Set < AddOn > allAddons = new HashSet < > ( changes . getNewVersions ( ) ) ; allAddons . addAll ( changes . getInstalls ( ) ) ; for ( AddOn addOn : allAddons ) { if ( addonsDialog != null ) { addonsDialog . notifyAddOnDownloading ( addOn ) ; } downloadAddOn ( addOn ) ; } }
public void rederiveColor ( ) { Color src = UIManager . getColor ( uiDefaultParentName ) ; if ( src != null ) { float [ ] tmp = Color . RGBtoHSB ( src . getRed ( ) , src . getGreen ( ) , src . getBlue ( ) , null ) ; tmp [ NUM_ ] = clamp ( tmp [ NUM_ ] + hOffset ) ; tmp [ NUM_ ] = clamp ( tmp [ NUM_ ] + sOffset ) ; tmp [ NUM_ ] = clamp ( tmp [ NUM_ ] + bOffset ) ; int alpha = clamp ( src . getAlpha ( ) + aOffset ) ; argbValue = ( Color . HSBtoRGB ( tmp [ NUM_ ] , tmp [ NUM_ ] , tmp [ NUM_ ] ) & xFFFFFF ) | ( alpha << NUM_ ) ; } else { float [ ] tmp = new float [ NUM_ ] ; tmp [ NUM_ ] = clamp ( hOffset ) ; tmp [ NUM_ ] = clamp ( sOffset ) ; tmp [ NUM_ ] = clamp ( bOffset ) ; int alpha = clamp ( aOffset ) ; argbValue = ( Color . HSBtoRGB ( tmp [ NUM_ ] , tmp [ NUM_ ] , tmp [ NUM_ ] ) & xFFFFFF ) | ( alpha << NUM_ ) ; } }
public static String toString ( int [ ] oid ) { StringBuilder sb = new StringBuilder ( NUM_ . oid . length ) ; for ( int i = NUM_ ; i < oid . length - NUM_ ; ++ i ) { sb . append ( oid [ i ] ) ; sb . append ( STR_ ) ; } sb . append ( oid [ oid . length - NUM_ ] ) ; return sb . toString ( ) ; }
public void onIdleBegin ( ) { _idleCount . incrementAndGet ( ) ; }
private void addSpan ( CacheSpan span ) { TreeSet < CacheSpan > spansForKey = cachedSpans . get ( span . key ) ; if ( spansForKey == null ) { spansForKey = new TreeSet < CacheSpan > ( ) ; cachedSpans . put ( span . key , spansForKey ) ; } spansForKey . add ( span ) ; totalSpace += span . length ; notifySpanAdded ( span ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) { return BOOL_ ; } if ( ! ( obj instanceof URIName ) ) { return BOOL_ ; } URIName other = ( URIName ) obj ; return uri . equals ( other . getURI ( ) ) ; }
void repaintChildren ( ) { for ( Component child : panel . getComponents ( ) ) { child . repaint ( ) ; } }
private void validateDnsName ( String dnsName ) throws PolicyException { int starIndex = dnsName . indexOf ( STR_ ) ; if ( ( starIndex >= NUM_ ) && ! dnsName . equals ( STR_ ) ) { if ( ( starIndex > NUM_ ) || ( ( starIndex == NUM_ ) && ( ( dnsName . indexOf ( STR_ , NUM_ ) != - NUM_ ) || ( dnsName . charAt ( NUM_ ) != STR_ ) ) ) ) { String args [ ] = { DNS_NAME , dnsName } ; throw new PolicyException ( ResBundleUtils . rbName , STR_ , args , null ) ; } } }
private static String readComment ( String input , int index ) { String comment = null ; Matcher matcher = COMMENT_PATTERN . matcher ( input . substring ( index ) ) ; if ( matcher . find ( ) ) { comment = matcher . group ( NUM_ ) ; comment = comment . substring ( NUM_ ) ; } return comment ; }
public static int findNext ( String str , char separator , char escapeChar , int start , StringBuilder split ) { int numPreEscapes = NUM_ ; for ( int i = start ; i < str . length ( ) ; i ++ ) { char curChar = str . charAt ( i ) ; if ( numPreEscapes == NUM_ && curChar == separator ) { return i ; } else { split . append ( curChar ) ; numPreEscapes = ( curChar == escapeChar ) ? ( ++ numPreEscapes ) % NUM_ : NUM_ ; } } return - NUM_ ; }
private static String guessContentType ( String url ) { url = url . toLowerCase ( ) ; if ( url . endsWith ( STR_ ) ) { return STR_ ; } else if ( url . endsWith ( STR_ ) ) { return STR_ ; } else if ( url . matches ( STR_ ) ) { return STR_ ; } else if ( url . endsWith ( STR_ ) ) { return STR_ ; } else if ( url . endsWith ( STR_ ) ) { return STR_ ; } else { return STR_ ; } }
public static String extractCSVOutputLineDomain ( String csvOut ) { String tokens [ ] = csvOut . split ( STR_ , - NUM_ ) ; return tokens [ NUM_ ] ; }
public void connect ( ) { connect ( this . logWriter ) ; }
public static boolean doCacheHeaderValidation ( final SolrQueryRequest solrReq , final HttpServletRequest req , final Method reqMethod , final HttpServletResponse resp ) { if ( Method . POST == reqMethod || Method . OTHER == reqMethod ) { return BOOL_ ; } final long lastMod = HttpCacheHeaderUtil . calcLastModified ( solrReq ) ; final String etag = HttpCacheHeaderUtil . calcEtag ( solrReq ) ; resp . setDateHeader ( STR_ , lastMod ) ; resp . setHeader ( STR_ , etag ) ; if ( checkETagValidators ( req , resp , reqMethod , etag ) ) { return BOOL_ ; } if ( checkLastModValidators ( req , resp , lastMod ) ) { return BOOL_ ; } return BOOL_ ; }
public IvrZoneset showActiveIvrZoneset ( ) throws NetworkDeviceControllerException { List < IvrZoneset > zonesets = showIvrZonesets ( BOOL_ ) ; return zonesets . isEmpty ( ) ? null : zonesets . get ( NUM_ ) ; }
@ SuppressWarnings ( STR_ ) public static < K > ImmutableArray < K > empty ( ) { return ( ImmutableArray < K > ) EMPTY ; }
public void replaceNonOptionalNonMinusNodesWith ( final List < IGroupMemberNode > ordered , final boolean recomputeDefinitelyProduced ) { nonOptionalNonMinusNodes . clear ( ) ; nonOptionalNonMinusNodes . addAll ( ordered ) ; if ( recomputeDefinitelyProduced ) { recomputeDefinitelyProduced ( ) ; } }
public static String toString ( Accountable a ) { StringBuilder sb = new StringBuilder ( ) ; toString ( sb , a , NUM_ ) ; return sb . toString ( ) ; }
@ Override public int hashCode ( ) { return type << NUM_ | value . hashCode ( ) << NUM_ | otherValue . hashCode ( ) ; }
protected void deleteTypeVertex ( AtlasVertex instanceVertex , DataTypes . TypeCategory typeCategory , boolean force ) throws AtlasException { switch ( typeCategory ) { case STRUCT : case TRAIT : deleteTypeVertex ( instanceVertex , force ) ; break ; case CLASS : deleteEntities ( Collections . singletonList ( instanceVertex ) ) ; break ; default : throw new IllegalStateException ( STR_ + typeCategory + STR_ ) ; } }
public static List < String > readToList ( Reader r ) throws IOException { try ( BufferedReader in = new BufferedReader ( r ) ) { List < String > l = new ArrayList < > ( ) ; String line = null ; while ( ( line = in . readLine ( ) ) != null ) l . add ( line ) ; return Collections . unmodifiableList ( l ) ; } }
@ SuppressWarnings ( STR_ ) public void addCacheContext ( GridCacheContext cacheCtx ) throws IgniteCheckedException { if ( ctxMap . containsKey ( cacheCtx . cacheId ( ) ) ) { GridCacheContext < K , V > existing = ctxMap . get ( cacheCtx . cacheId ( ) ) ; throw new IgniteCheckedException ( STR_ + STR_ + cacheCtx . name ( ) + STR_ + existing . name ( ) + STR_ ) ; } CacheStoreManager mgr = cacheCtx . store ( ) ; if ( mgr . configured ( ) && mgr . isLocal ( ) ) locStoreCnt . incrementAndGet ( ) ; ctxMap . put ( cacheCtx . cacheId ( ) , cacheCtx ) ; }
protected static boolean isCglibGetCallbacks ( AnnotatedMethod am ) { Class < ? > rt = am . getRawType ( ) ; if ( rt == null || ! rt . isArray ( ) ) { return BOOL_ ; } Class < ? > compType = rt . getComponentType ( ) ; Package pkg = compType . getPackage ( ) ; if ( pkg != null ) { String pname = pkg . getName ( ) ; if ( pname . startsWith ( STR_ ) || pname . startsWith ( STR_ ) ) { return BOOL_ ; } } return BOOL_ ; }
public int compareTo ( NamedMediaType other ) { return _name . compareTo ( other . _name ) ; }
public boolean isModified ( ) { synchronized ( this ) { if ( _isChecking || _isModified ) { return _isModified ; } _isChecking = BOOL_ ; } try { long now ; now = CurrentTime . currentTime ( ) ; if ( now < _lastCheckTime + _checkInterval ) return _isModified ; _lastCheckTime = now ; for ( int i = _dependencyList . size ( ) - NUM_ ; i >= NUM_ ; i -- ) { Dependency dependency = _dependencyList . get ( i ) ; if ( dependency . isModified ( ) ) { dependency . logModified ( log ( ) ) ; _isModified = BOOL_ ; return _isModified ; } } return _isModified ; } finally { _isChecking = BOOL_ ; } }
protected ReplacedElement newIrreplaceableImageElement ( int cssWidth , int cssHeight ) { BufferedImage missingImage ; ReplacedElement mre ; try { missingImage = ImageUtil . createCompatibleBufferedImage ( cssWidth , cssHeight , BufferedImage . TYPE_INT_RGB ) ; Graphics2D g = missingImage . createGraphics ( ) ; g . setColor ( Color . BLACK ) ; g . setBackground ( Color . WHITE ) ; g . setFont ( new Font ( STR_ , Font . PLAIN , NUM_ ) ) ; g . drawString ( STR_ , NUM_ , NUM_ ) ; g . dispose ( ) ; mre = new ImageReplacedElement ( missingImage , cssWidth , cssHeight ) ; } catch ( Exception e ) { mre = new EmptyReplacedElement ( cssWidth < NUM_ ? NUM_ : cssWidth , cssHeight < NUM_ ? NUM_ : cssHeight ) ; } return mre ; }
public boolean greaterThan ( FXGVersion version ) { return ( compareTo ( version ) > NUM_ ) ; }
@ Override public DataSource createDataSource ( Properties properties ) throws SQLException { Properties propertiesCopy = new Properties ( ) ; if ( properties != null ) { propertiesCopy . putAll ( properties ) ; } rejectUnsupportedOptions ( propertiesCopy ) ; rejectPoolingOptions ( propertiesCopy ) ; JdbcDataSource dataSource = new JdbcDataSource ( ) ; setupH2DataSource ( dataSource , propertiesCopy ) ; return dataSource ; }
public Set < String > find ( T object ) { if ( ! locations . containsKey ( object ) ) { locations . put ( object , new HashSet < > ( ) ) ; } return Collections . unmodifiableSet ( locations . get ( object ) ) ; }
public void addMetaObject ( MetaObject object ) { for ( int k = NUM_ ; k < MetaObjects . size ( ) ; ++ k ) { if ( MetaObjects . get ( k ) == null ) { MetaObjects . set ( k , object ) ; return ; } } MetaObjects . add ( object ) ; }
public boolean remove ( String word ) { return m_Words . remove ( word ) ; }
public void testCase12 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int bSign = - NUM_ ; byte rBytes [ ] = { - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . add ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , - NUM_ , result . signum ( ) ) ; }
public synchronized void addRecentItem ( T item ) { item = fromString ( toString ( item ) ) ; if ( m_RecentItems . size ( ) > NUM_ ) { if ( item . equals ( m_RecentItems . get ( NUM_ ) ) ) return ; } m_RecentItems . remove ( item ) ; m_RecentItems . add ( NUM_ , item ) ; while ( m_RecentItems . size ( ) > m_MaxCount ) m_RecentItems . remove ( m_RecentItems . size ( ) - NUM_ ) ; if ( m_IgnoreChanges ) return ; writeProps ( ) ; updateMenu ( ) ; notifyRecentItemListenersOfAdd ( item ) ; }
private Rect calcBounds ( int index , Paint paint ) { Rect bounds = new Rect ( ) ; CharSequence title = getTitle ( index ) ; bounds . right = ( int ) paint . measureText ( title , NUM_ , title . length ( ) ) ; bounds . bottom = ( int ) ( paint . descent ( ) - paint . ascent ( ) ) ; return bounds ; }
public void testInvokeAll2 ( ) throws InterruptedException { ExecutorService e = new ForkJoinPool ( NUM_ ) ; PoolCleaner cleaner = null ; try { cleaner = cleaner ( e ) ; List < Future < String > > r = e . invokeAll ( new ArrayList < Callable < String > > ( ) ) ; assertTrue ( r . isEmpty ( ) ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public void cfgPackage ( ConfigurationValue cfgval , String name , String desc ) { packages . add ( new PackageInfo ( name , desc ) ) ; packageNames . add ( name ) ; }
@ Override public void close ( ) throws IOException { input . close ( ) ; }
private void createBlockMirrorData ( String name , int numBlockMirrors ) throws Exception { Volume volume = new Volume ( ) ; URI volumeURI = URIUtil . createId ( Volume . class ) ; testVolumeURIs . add ( volumeURI ) ; volume . setId ( volumeURI ) ; volume . setLabel ( STR_ ) ; URI cgUri = createBlockConsistencyGroup ( STR_ ) ; volume . setConsistencyGroup ( cgUri ) ; _dbClient . createObject ( volume ) ; for ( int i = NUM_ ; i <= numBlockMirrors ; i ++ ) { BlockMirror blockMirror = new BlockMirror ( ) ; URI blockMirrorURI = URIUtil . createId ( BlockMirror . class ) ; testBlockMirrorURIs . add ( blockMirrorURI ) ; blockMirror . setId ( blockMirrorURI ) ; blockMirror . setLabel ( name + i ) ; blockMirror . setConsistencyGroup ( cgUri ) ; _dbClient . createObject ( blockMirror ) ; } }
@ Override public synchronized void start ( ) { if ( running ) { return ; } LOGGER . info ( STR_ ) ; if ( endpoints . isEmpty ( ) ) { int port = config . getInt ( NetworkConfig . Keys . COAP_PORT ) ; LOGGER . log ( Level . INFO , STR_ , port ) ; addEndpoint ( new CoapEndpoint ( port , this . config ) ) ; } int started = NUM_ ; for ( Endpoint ep : endpoints ) { try { ep . start ( ) ; ++ started ; } catch ( IOException e ) { LOGGER . log ( Level . SEVERE , STR_ + ep . getAddress ( ) + STR_ , e ) ; } } if ( started == NUM_ ) { throw new IllegalStateException ( STR_ ) ; } else { running = BOOL_ ; } }
public JsonArray add ( String value ) { values . add ( Json . value ( value ) ) ; return this ; }
public boolean retainAll ( AbstractFloatList other ) { if ( other . size ( ) == NUM_ ) { if ( size == NUM_ ) return BOOL_ ; setSize ( NUM_ ) ; return BOOL_ ; } int limit = other . size ( ) - NUM_ ; int j = NUM_ ; for ( int i = NUM_ ; i < size ; i ++ ) { if ( other . indexOfFromTo ( getQuick ( i ) , NUM_ , limit ) >= NUM_ ) setQuick ( j ++ , getQuick ( i ) ) ; } boolean modified = ( j != size ) ; setSize ( j ) ; return modified ; }
@ Override public void exceptionCaught ( IoSession session , Throwable cause ) { final IoSessionInputStream in = ( IoSessionInputStream ) session . getAttribute ( KEY_IN ) ; IOException e = null ; if ( cause instanceof StreamIoException ) { e = ( IOException ) cause . getCause ( ) ; } else if ( cause instanceof IOException ) { e = ( IOException ) cause ; } if ( e != null && in != null ) { in . throwException ( e ) ; } else { LOGGER . warn ( STR_ , cause ) ; session . close ( BOOL_ ) ; } }
protected void clearResult ( ) { md . clearResult ( ) ; localizationResult . setText ( STR_ ) ; }
public static < T > String toString ( Collection < T > collection ) { if ( collection == null ) { return STR_ ; } if ( collection . isEmpty ( ) ) { return STR_ ; } StringBuilder buf = new StringBuilder ( ) ; String delimiter = STR_ ; for ( T t : collection ) { if ( t == null ) { continue ; } buf . append ( delimiter ) ; buf . append ( t ) ; delimiter = STR_ ; } return buf . toString ( ) ; }
public static float between ( float val , float min , float max ) { return Math . max ( Math . min ( val , max ) , min ) ; }
public static StringBuffer replaceString ( StringBuffer buffer , String [ ] parameters ) { int placeHolderPosition = - NUM_ ; String placeHolder = null ; for ( int i = NUM_ ; i < parameters . length ; i ++ ) { if ( parameters [ i ] == null ) { break ; } placeHolder = STR_ + ( i + NUM_ ) + STR_ ; placeHolderPosition = buffer . indexOf ( placeHolder ) ; if ( placeHolderPosition != - NUM_ ) { buffer . replace ( placeHolderPosition , placeHolderPosition + placeHolder . length ( ) , parameters [ i ] ) ; } else { break ; } } return buffer ; }
private static int lookupQualSelector ( XMPNode arrayNode , String qualName , String qualValue , int aliasForm ) throws XMPException { if ( XML_LANG . equals ( qualName ) ) { qualValue = Utils . normalizeLangValue ( qualValue ) ; int index = XMPNodeUtils . lookupLanguageItem ( arrayNode , qualValue ) ; if ( index < NUM_ && ( aliasForm & AliasOptions . PROP_ARRAY_ALT_TEXT ) > NUM_ ) { XMPNode langNode = new XMPNode ( ARRAY_ITEM_NAME , null ) ; XMPNode xdefault = new XMPNode ( XML_LANG , X_DEFAULT , null ) ; langNode . addQualifier ( xdefault ) ; arrayNode . addChild ( NUM_ , langNode ) ; return NUM_ ; } else { return index ; } } else { for ( int index = NUM_ ; index < arrayNode . getChildrenLength ( ) ; index ++ ) { XMPNode currItem = arrayNode . getChild ( index ) ; for ( Iterator it = currItem . iterateQualifier ( ) ; it . hasNext ( ) ; ) { XMPNode qualifier = ( XMPNode ) it . next ( ) ; if ( qualName . equals ( qualifier . getName ( ) ) && qualValue . equals ( qualifier . getValue ( ) ) ) { return index ; } } } return - NUM_ ; } }
public boolean isMultipleAllowed ( String frameID ) { return multipleFrames . contains ( frameID ) ; }
public String [ ] parseConfiguration ( File xmlFile ) throws SAXException , IOException { Document document = builder . parse ( xmlFile ) ; return ( parseConfiguration ( document ) ) ; }
public void create ( String [ ] rpfFilePaths , String outputFile ) throws MakeTocException { create ( rpfFilePaths , outputFile , BOOL_ ) ; }
private synchronized void postEvent ( EventInfo eventInfo ) { eventQueue . add ( eventInfo ) ; notifyAll ( ) ; }
public String chooseServerAlias ( String keyType , Principal [ ] issuers , Socket sock ) { return sunX509KeyManager . chooseServerAlias ( keyType , issuers , sock ) ; }
private void processBmpImage ( BufferedImage image ) { if ( ! isError ) { File outputFile = new File ( path , prefix + ( numPage + NUM_ ) + STR_ ) ; try { ImageIO . write ( image , STR_ , outputFile ) ; addTempFile ( outputFile ) ; addScanFile ( outputFile ) ; numPage ++ ; } catch ( IOException e ) { e . printStackTrace ( ) ; endProcess ( BOOL_ , BOOL_ ) ; } } }
public PathHandler ( String path ) { this ( Paths . get ( path ) ) ; }
public boolean loadLines ( ) { boolean result = BOOL_ ; try { m_parser . parse ( new InputSource ( m_reader ) , this ) ; result = BOOL_ ; m_success = BOOL_ ; } catch ( SAXException e ) { m_errorMessage = STR_ ; m_errorDescription = e . getMessage ( ) ; } catch ( IOException e ) { m_errorMessage = STR_ ; m_errorDescription = e . getMessage ( ) ; } return result ; }
private void loadIgnoreFile ( final String srcFolder ) { ignoreFile = IgnoreFile . load ( srcFolder ) ; if ( ignoreFile == null ) { loadDefaultExcludePattern ( srcFolder ) ; } }
public boolean removeArg ( final BOp arg ) { if ( arg == null ) throw new IllegalArgumentException ( ) ; if ( arg == this ) throw new IllegalArgumentException ( ) ; if ( args . remove ( arg ) ) { mutation ( ) ; return BOOL_ ; } return BOOL_ ; }
public static boolean looksLikeAListStyleType ( String val ) { return LIST_TYPES . indexOf ( val ) >= NUM_ ; }
public PKCS10Attribute ( PKCS9Attribute attr ) { this . attributeId = attr . getOID ( ) ; this . attributeValue = attr . getValue ( ) ; }
public void createNote ( Note note ) { SQLiteDatabase db = getWritableDatabase ( ) ; String spannableAsHtml = Html . toHtml ( note . getSpannable ( ) ) ; String date = dt . format ( new Date ( ) ) ; ContentValues values = new ContentValues ( ) ; values . put ( KEY_SPANNABLE_NOTE , spannableAsHtml ) ; values . put ( KEY_NOTE_TITLE , note . getTitle ( ) ) ; values . put ( KEY_IMAGE , BitmapConverter . getBytes ( note . getImage ( ) ) ) ; values . put ( KEY_DATE_UPDATED , date ) ; db . insert ( TABLE_NOTES , null , values ) ; db . close ( ) ; }
void verifyUniqueXids ( List < OFMessage > msgs ) { if ( seenXids == null ) seenXids = new HashSet < Long > ( ) ; for ( OFMessage m : msgs ) { long xid = m . getXid ( ) ; assertTrue ( STR_ , xid != NUM_ ) ; assertFalse ( STR_ + xid + STR_ , seenXids . contains ( xid ) ) ; seenXids . add ( xid ) ; } }
void addNext ( Node < T > n ) { nextNodes . add ( n ) ; Collections . sort ( nextNodes , isVertical ? verticalComparator : horizontalComparator ) ; }
protected void configDialogPropertyChange ( PropertyChangeEvent event ) { log . debug ( STR_ ) ; firePropertyChange ( PropertyChangeID . CONFIG_CHANGE , event . getOldValue ( ) , event . getNewValue ( ) ) ; }
public final String readUTF ( ) throws IOException { return decodeUTF ( readUnsignedShort ( ) ) ; }
private void myAdd ( LinkedList < Integer > l , int i ) { l . add ( i ) ; }
private void resetStateForGridTop ( ) { final int colCount = mColCount ; if ( mItemTops == null || mItemTops . length != colCount ) { mItemTops = new int [ colCount ] ; mItemBottoms = new int [ colCount ] ; } final int top = getPaddingTop ( ) ; Arrays . fill ( mItemTops , top ) ; Arrays . fill ( mItemBottoms , top ) ; mFirstPosition = NUM_ ; if ( mRestoreOffsets != null ) Arrays . fill ( mRestoreOffsets , NUM_ ) ; }
public String testNextToken ( ) throws IOException { Token t = super . nextToken ( ) ; return Integer . toString ( t . type ) + STR_ + t . content + STR_ ; }
public static RepaintManager currentManager ( Component c ) { return currentManager ( AppContext . getAppContext ( ) ) ; }
private boolean isRecoverPointInitiator ( String portWWN ) { return portWWN . contains ( RECOVERPOINT_INITIATOR_PREFIX ) ; }
protected boolean isWFXMLChar ( String chardata , Character refInvalidChar ) { if ( chardata == null || ( chardata . length ( ) == NUM_ ) ) { return BOOL_ ; } char [ ] dataarray = chardata . toCharArray ( ) ; int datalength = dataarray . length ; if ( fIsXMLVersion11 ) { int i = NUM_ ; while ( i < datalength ) { if ( XML11Char . isXML11Invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - NUM_ ] ; if ( XMLChar . isHighSurrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if ( XMLChar . isLowSurrogate ( ch2 ) && XMLChar . isSupplemental ( XMLChar . supplemental ( ch , ch2 ) ) ) { continue ; } } refInvalidChar = new Character ( ch ) ; return BOOL_ ; } } } else { int i = NUM_ ; while ( i < datalength ) { if ( XMLChar . isInvalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - NUM_ ] ; if ( XMLChar . isHighSurrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if ( XMLChar . isLowSurrogate ( ch2 ) && XMLChar . isSupplemental ( XMLChar . supplemental ( ch , ch2 ) ) ) { continue ; } } refInvalidChar = new Character ( ch ) ; return BOOL_ ; } } } return BOOL_ ; }
@ Override public void send ( Buffer buffer ) { _outProxy . write ( _outWriter , buffer , BOOL_ ) ; }
@ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case EipPackage . ROUTE__OWNED_ENDPOINTS : return ownedEndpoints != null && ! ownedEndpoints . isEmpty ( ) ; case EipPackage . ROUTE__OWNED_CHANNELS : return ownedChannels != null && ! ownedChannels . isEmpty ( ) ; case EipPackage . ROUTE__NAME : return NAME_EDEFAULT == null ? name != null : ! NAME_EDEFAULT . equals ( name ) ; case EipPackage . ROUTE__EXCHANGE_TYPE : return exchangeType != EXCHANGE_TYPE_EDEFAULT ; } return super . eIsSet ( featureID ) ; }
public void removeClickingListener ( OnWheelClickedListener listener ) { clickingListeners . remove ( listener ) ; }
public void addSection ( final Section SECTION ) { if ( null == SECTION ) return ; sections . add ( SECTION ) ; Collections . sort ( sections , new SectionComparator ( ) ) ; fireUpdateEvent ( SECTION_EVENT ) ; }
private int calculatePreferredWrapPosition ( @ NotNull Editor editor , @ NotNull CharSequence text , int tabSize , int spaceSize , int startLineOffset , int endLineOffset , int targetRangeEndOffset ) { boolean hasTabs = BOOL_ ; boolean canOptimize = BOOL_ ; boolean hasNonSpaceSymbols = BOOL_ ; loop : for ( int i = startLineOffset ; i < Math . min ( endLineOffset , targetRangeEndOffset ) ; i ++ ) { char c = text . charAt ( i ) ; switch ( c ) { case STR_ : { hasTabs = BOOL_ ; if ( hasNonSpaceSymbols ) { canOptimize = BOOL_ ; break loop ; } } case STR_ : break ; default : hasNonSpaceSymbols = BOOL_ ; } } if ( ! hasTabs ) { return wrapPositionForTextWithoutTabs ( startLineOffset , endLineOffset , targetRangeEndOffset ) ; } else if ( canOptimize ) { return wrapPositionForTabbedTextWithOptimization ( text , tabSize , startLineOffset , endLineOffset , targetRangeEndOffset ) ; } else { return wrapPositionForTabbedTextWithoutOptimization ( editor , text , spaceSize , startLineOffset , endLineOffset , targetRangeEndOffset ) ; } }
public void addAll ( OVector v ) { expandFor ( size + v . size - NUM_ , null ) ; System . arraycopy ( v . vector , NUM_ , vector , size - v . size , v . size ) ; }
private static boolean isOptimizableForDescendantIterator ( Compiler compiler , int stepOpCodePos , int stepIndex ) throws javax . xml . transform . TransformerException { int stepType ; int stepCount = NUM_ ; boolean foundDorDS = BOOL_ ; boolean foundSelf = BOOL_ ; boolean foundDS = BOOL_ ; int nodeTestType = OpCodes . NODETYPE_NODE ; while ( OpCodes . ENDOP != ( stepType = compiler . getOp ( stepOpCodePos ) ) ) { if ( nodeTestType != OpCodes . NODETYPE_NODE && nodeTestType != OpCodes . NODETYPE_ROOT ) return BOOL_ ; stepCount ++ ; if ( stepCount > NUM_ ) return BOOL_ ; boolean mightBeProximate = mightBeProximate ( compiler , stepOpCodePos , stepType ) ; if ( mightBeProximate ) return BOOL_ ; switch ( stepType ) { case OpCodes . FROM_FOLLOWING : case OpCodes . FROM_FOLLOWING_SIBLINGS : case OpCodes . FROM_PRECEDING : case OpCodes . FROM_PRECEDING_SIBLINGS : case OpCodes . FROM_PARENT : case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : case OpCodes . FROM_NAMESPACE : case OpCodes . FROM_ANCESTORS : case OpCodes . FROM_ANCESTORS_OR_SELF : case OpCodes . FROM_ATTRIBUTES : case OpCodes . MATCH_ATTRIBUTE : case OpCodes . MATCH_ANY_ANCESTOR : case OpCodes . MATCH_IMMEDIATE_ANCESTOR : return BOOL_ ; case OpCodes . FROM_ROOT : if ( NUM_ != stepCount ) return BOOL_ ; break ; case OpCodes . FROM_CHILDREN : if ( ! foundDS && ! ( foundDorDS && foundSelf ) ) return BOOL_ ; break ; case OpCodes . FROM_DESCENDANTS_OR_SELF : foundDS = BOOL_ ; case OpCodes . FROM_DESCENDANTS : if ( NUM_ == stepCount ) return BOOL_ ; foundDorDS = BOOL_ ; break ; case OpCodes . FROM_SELF : if ( NUM_ != stepCount ) return BOOL_ ; foundSelf = BOOL_ ; break ; default : throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NULL_ERROR_HANDLER , new Object [ ] { Integer . toString ( stepType ) } ) ) ; } nodeTestType = compiler . getStepTestType ( stepOpCodePos ) ; int nextStepOpCodePos = compiler . getNextStepPos ( stepOpCodePos ) ; if ( nextStepOpCodePos < NUM_ ) break ; if ( OpCodes . ENDOP != compiler . getOp ( nextStepOpCodePos ) ) { if ( compiler . countPredicates ( stepOpCodePos ) > NUM_ ) { return BOOL_ ; } } stepOpCodePos = nextStepOpCodePos ; } return BOOL_ ; }
public static void pipeAll ( InputStream inStr , OutputStream outStr ) throws IOException { byte [ ] bs = new byte [ BUFFER_SIZE ] ; int numRead ; while ( ( numRead = inStr . read ( bs , NUM_ , bs . length ) ) >= NUM_ ) { outStr . write ( bs , NUM_ , numRead ) ; } }
public void addRule ( String ruleExpression , T resultIfMatched ) { mRuleMap . add ( new MimeMatcherRule ( ruleExpression , resultIfMatched ) ) ; }
protected abstract boolean validateNumber ( ConversationContext context , Number input ) ;
public void sendMessageUntilStopCount ( int stopCount ) { for ( int i = processedWorkerCount ; i < workers . size ( ) ; ++ i ) { ActorRef worker = workers . get ( i ) ; try { Thread . sleep ( NUM_ ) ; } catch ( InterruptedException e ) { logger . error ( STR_ + e + STR_ , e ) ; } worker . tell ( OperationWorkerMsgType . PROCESS_REQUEST , originalManager ) ; processedWorkerCount ++ ; if ( processedWorkerCount > stopCount ) { return ; } logger . debug ( STR_ , processedWorkerCount , requestTotalCount , taskIdTrim ) ; } }
ConfigurationError ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; }
public static ArrayList < String > stringToArrayList ( String string ) { return new ArrayList < > ( Arrays . asList ( string . split ( STR_ ) ) ) ; }
private String pickCharset ( ) { if ( charset != null ) { return charset ; } else if ( utf8Supported ) { return STR_ ; } else { return System . getProperty ( STR_ ) ; } }
public void testToEngineeringStringPos ( ) { String a = STR_ ; BigDecimal aNumber = new BigDecimal ( a ) ; String result = STR_ ; assertEquals ( STR_ , result , aNumber . toEngineeringString ( ) ) ; }
@ Override public void clear ( ) { if ( elementCount > NUM_ ) { elementCount = NUM_ ; Arrays . fill ( elementData , null ) ; modCount ++ ; } }
public void addLayer ( final LayerDefinition layer ) { layer . setMap ( this ) ; layers . add ( layer ) ; }
private List < Rule > readRules ( Reader reader ) throws IOException , IllegalArgumentException { BufferedReader in = new BufferedReader ( reader ) ; List < Rule > rules = new ArrayList < Rule > ( ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . length ( ) == NUM_ ) { continue ; } line = line . trim ( ) ; char first = line . charAt ( NUM_ ) ; boolean sign = BOOL_ ; switch ( first ) { case STR_ : sign = BOOL_ ; break ; case STR_ : sign = BOOL_ ; break ; case STR_ : case STR_ : case STR_ : continue ; default : throw new IOException ( STR_ + line ) ; } String regex = line . substring ( NUM_ ) ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( STR_ + regex + STR_ ) ; } Rule rule = createRule ( sign , regex ) ; rules . add ( rule ) ; } return rules ; }
@ SuppressWarnings ( STR_ ) @ Override protected Object applyUpdatesToManagedData ( Object updates ) { boolean madeChanges = BOOL_ ; List < String > words = ( List < String > ) updates ; log . info ( STR_ + words ) ; boolean ignoreCase = getIgnoreCase ( ) ; for ( String word : words ) { if ( ignoreCase ) word = word . toLowerCase ( Locale . ROOT ) ; if ( managedWords . add ( word ) ) { madeChanges = BOOL_ ; log . info ( STR_ , word ) ; } } return madeChanges ? managedWords : null ; }
protected void drawLabel ( Canvas canvas , String labelText , DefaultRenderer renderer , List < RectF > prevLabelsBounds , int centerX , int centerY , float shortRadius , float longRadius , float currentAngle , float angle , int left , int right , int color , Paint paint , boolean line , boolean display ) { if ( renderer . isShowLabels ( ) || display ) { paint . setColor ( color ) ; double rAngle = Math . toRadians ( NUM_ - ( currentAngle + angle / NUM_ ) ) ; double sinValue = Math . sin ( rAngle ) ; double cosValue = Math . cos ( rAngle ) ; int x1 = Math . round ( centerX + ( float ) ( shortRadius . sinValue ) ) ; int y1 = Math . round ( centerY + ( float ) ( shortRadius . cosValue ) ) ; int x2 = Math . round ( centerX + ( float ) ( longRadius . sinValue ) ) ; int y2 = Math . round ( centerY + ( float ) ( longRadius . cosValue ) ) ; float size = renderer . getLabelsTextSize ( ) ; float extra = Math . max ( size / NUM_ , NUM_ ) ; paint . setTextAlign ( Align . LEFT ) ; if ( x1 > x2 ) { extra = - extra ; paint . setTextAlign ( Align . RIGHT ) ; } float xLabel = x2 + extra ; float yLabel = y2 ; float width = right - xLabel ; if ( x1 > x2 ) { width = xLabel - left ; } labelText = getFitText ( labelText , width , paint ) ; float widthLabel = paint . measureText ( labelText ) ; boolean okBounds = BOOL_ ; while ( ! okBounds && line ) { boolean intersects = BOOL_ ; int length = prevLabelsBounds . size ( ) ; for ( int j = NUM_ ; j < length && ! intersects ; j ++ ) { RectF prevLabelBounds = prevLabelsBounds . get ( j ) ; if ( prevLabelBounds . intersects ( xLabel , yLabel , xLabel + widthLabel , yLabel + size ) ) { intersects = BOOL_ ; yLabel = Math . max ( yLabel , prevLabelBounds . bottom ) ; } } okBounds = ! intersects ; } if ( line ) { y2 = ( int ) ( yLabel - size / NUM_ ) ; canvas . drawLine ( x1 , y1 , x2 , y2 , paint ) ; canvas . drawLine ( x2 , y2 , x2 + extra , y2 , paint ) ; } else { paint . setTextAlign ( Align . CENTER ) ; } canvas . drawText ( labelText , xLabel , yLabel , paint ) ; if ( line ) { prevLabelsBounds . add ( new RectF ( xLabel , yLabel , xLabel + widthLabel , yLabel + size ) ) ; } } }
@ Override public void write ( char c [ ] , int off , int len ) { if ( ( off < NUM_ ) || ( off > c . length ) || ( len < NUM_ ) || ( ( off + len ) > c . length ) || ( ( off + len ) < NUM_ ) ) { throw new IndexOutOfBoundsException ( ) ; } else if ( len == NUM_ ) { return ; } int newcount = count + len ; if ( newcount > buf . length ) { buf = Arrays . copyOf ( buf , Math . max ( buf . length << NUM_ , newcount ) ) ; } System . arraycopy ( c , off , buf , count , len ) ; count = newcount ; }
@ Deprecated public static EpisodeMatchingResult detectEpisodeFromFilename ( File file ) { LOGGER . debug ( STR_ + file . getName ( ) ) ; EpisodeMatchingResult result = new EpisodeMatchingResult ( ) ; String fileName = file . getName ( ) ; result = parseString ( fileName ) ; Collections . sort ( result . episodes ) ; Matcher matcher = stackingMarkerPattern . matcher ( result . name ) ; result . stackingMarkerFound = matcher . matches ( ) ; LOGGER . debug ( STR_ + result ) ; return result ; }
public static TypedOperation createArrayCreation ( ArrayType arrayType ) { List < Type > typeList = new ArrayList < > ( ) ; typeList . add ( JavaTypes . INT_TYPE ) ; TypeTuple inputTypes = new TypeTuple ( typeList ) ; return new TypedTermOperation ( new ArrayCreation ( arrayType ) , inputTypes , arrayType ) ; }
public void fireEvent ( final SPARQLUpdateEvent e ) { if ( isReadOnly ( ) ) throw new UnsupportedOperationException ( ) ; if ( e == null ) throw new IllegalArgumentException ( ) ; if ( listeners . isEmpty ( ) ) { return ; } final ISPARQLUpdateListener [ ] a = listeners . toArray ( new ISPARQLUpdateListener [ NUM_ ] ) ; for ( ISPARQLUpdateListener l : a ) { final ISPARQLUpdateListener listener = l ; try { listener . updateEvent ( e ) ; } catch ( Throwable t ) { if ( InnerCause . isInnerCause ( t , InterruptedException . class ) ) { throw new RuntimeException ( t ) ; } log . error ( t , t ) ; } } }
public PreferenceBuilder < PreferenceClass > prefType ( Class < PreferenceClass > prefType ) { if ( ! VALID_TYPES . contains ( prefType ) ) { throw new IllegalArgumentException ( STR_ + prefType + STR_ ) ; } this . prefType = prefType ; return this ; }
private void expungeStaleEntries ( ) { for ( Object x ; ( x = queue . poll ( ) ) != null ; ) { synchronized ( queue ) { @ SuppressWarnings ( STR_ ) Entry < K , V > e = ( Entry < K , V > ) x ; int i = indexFor ( e . hash , table . length ) ; Entry < K , V > prev = table [ i ] ; Entry < K , V > p = prev ; while ( p != null ) { Entry < K , V > next = p . next ; if ( p == e ) { if ( prev == e ) table [ i ] = next ; else prev . next = next ; e . value = null ; size -- ; break ; } prev = p ; p = next ; } } } }
protected boolean isNumeric ( String text ) { text = text . trim ( ) ; int tlen = text . length ( ) ; for ( int i = NUM_ ; i < tlen ; i ++ ) { if ( Character . isDigit ( text . charAt ( i ) ) == BOOL_ ) { return BOOL_ ; } } return BOOL_ ; }
public static boolean isChar ( String desc ) { return desc . endsWith ( STR_ ) ; }
public RSAPublicKeyImpl ( byte [ ] encoded ) throws InvalidKeyException { decode ( encoded ) ; RSAKeyFactory . checkRSAProviderKeyLengths ( n . bitLength ( ) , e ) ; }
Date toDate ( Calendar calendar ) { return calendar . getTime ( ) ; }
public boolean isClientAuthentication ( ) { return clientAuthentication ; }
private JPanel createImageFilePanel ( ) { JPanel panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . X_AXIS ) ) ; panel . add ( imageFileName ) ; panel . add ( Box . createHorizontalStrut ( NUM_ ) ) ; panel . add ( new JButton ( openImageFile ) ) ; return panel ; }
void writeLine ( BufferedWriter writer , String line ) throws IOException { writer . write ( line ) ; writer . newLine ( ) ; }
public Layer childAt ( int index ) { return children . get ( index ) ; }
private static void checkPermission ( ) { SecurityManager security = System . getSecurityManager ( ) ; if ( security != null ) security . checkPermission ( modifyThreadPermission ) ; }
public static Function < Value , Value > ofValue ( ) { return VALUE ; }
public static String removeQuotes ( String s ) { if ( s == null ) { return null ; } String trimmed = s . trim ( ) ; if ( trimmed . length ( ) == NUM_ ) { return trimmed ; } int i = nextNonQuoteIndex ( trimmed , NUM_ , BOOL_ ) ; int j = nextNonQuoteIndex ( trimmed , trimmed . length ( ) - NUM_ , BOOL_ ) ; return trimmed . substring ( i , j + NUM_ ) ; }
public static boolean isDefinedNSDecl ( SerializationHandler serializer , int attr , DTM dtm ) { if ( DTM . NAMESPACE_NODE == dtm . getNodeType ( attr ) ) { String prefix = dtm . getNodeNameX ( attr ) ; String uri = serializer . getNamespaceURIFromPrefix ( prefix ) ; if ( ( null != uri ) && uri . equals ( dtm . getStringValue ( attr ) ) ) return BOOL_ ; } return BOOL_ ; }
public void testUserDataHandlerNotifiedOfShallowClones ( ) { RecordingHandler handler = new RecordingHandler ( ) ; name . setUserData ( STR_ , STR_ , handler ) ; name . setUserData ( STR_ , STR_ , handler ) ; standard . setUserData ( STR_ , STR_ , handler ) ; waffles . setUserData ( STR_ , STR_ , handler ) ; Element clonedName = ( Element ) name . cloneNode ( BOOL_ ) ; Attr clonedStandard = clonedName . getAttributeNode ( STR_ ) ; Set < String > expected = new HashSet < String > ( ) ; expected . add ( notification ( NODE_CLONED , STR_ , STR_ , name , clonedName ) ) ; expected . add ( notification ( NODE_CLONED , STR_ , STR_ , name , clonedName ) ) ; expected . add ( notification ( NODE_CLONED , STR_ , STR_ , standard , clonedStandard ) ) ; assertEquals ( expected , handler . calls ) ; }
public DBasicConstraints ( JDialog parent , byte [ ] value ) throws IOException { super ( parent ) ; setTitle ( res . getString ( STR_ ) ) ; initComponents ( ) ; prepopulateWithValue ( value ) ; }
private static int lastIndexOf ( Object o , Object [ ] elements , int index ) { if ( o == null ) { for ( int i = index ; i >= NUM_ ; i -- ) if ( elements [ i ] == null ) return i ; } else { for ( int i = index ; i >= NUM_ ; i -- ) if ( o . equals ( elements [ i ] ) ) return i ; } return - NUM_ ; }
public FloatColumn ( int nrows , int capacity , float defaultValue ) { super ( float . class , new Float ( defaultValue ) ) ; if ( capacity < nrows ) { throw new IllegalArgumentException ( STR_ ) ; } m_values = new float [ capacity ] ; Arrays . fill ( m_values , defaultValue ) ; m_size = nrows ; }
void readPRJ ( ) throws IOException { while ( BOOL_ ) { String S = isr . readLine ( ) ; if ( S == null ) return ; if ( S . startsWith ( STR_ ) ) return ; } }
private void purgeOne ( ) { synchronized ( queue ) { WeakKey key = ( WeakKey ) queue . poll ( ) ; if ( key != null ) { super . remove ( key . getReferenced ( ) ) ; } } }
private void checkAlterPeriodConverters ( ) throws SecurityException { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) { sm . checkPermission ( new JodaTimePermission ( STR_ ) ) ; } }
public boolean equals ( final ArtifactCoordinates obj ) { return this == obj || obj != null && groupId . equals ( obj . groupId ) && artifactId . equals ( obj . artifactId ) && version . equals ( obj . version ) && classifier . equals ( obj . classifier ) ; }
public synchronized void add ( double x , double y , double value ) { super . add ( x , y ) ; mValue . add ( value ) ; updateRange ( value ) ; }
private void checkMatrixDimensions ( Matrix B ) { if ( B . m != m || B . n != n ) { throw new IllegalArgumentException ( STR_ ) ; } }
public void importFromChange ( Change sourceChange ) { if ( sourceChange . revision ( ) > NUM_ ) { this . revisionId = new NumericLiteralImpl ( sourceChange . revision ( ) ) ; } if ( sourceChange . timestamp ( ) != null ) { Date date = sourceChange . timestamp ( ) ; Calendar c = Calendar . getInstance ( TimeZone . getTimeZone ( STR_ ) , Locale . ROOT ) ; c . setTime ( date ) ; this . lastModified = new LiteralImpl ( DatatypeConverter . printDate ( c ) , XMLSchema . DATETIME ) ; } }
protected PrintWriter lineFileOut ( Document doc ) { return lineFileOut ; }
@ Override public Query newFuzzyQuery ( String text , int fuzziness ) { if ( settings . lowercaseExpandedTerms ( ) ) { text = text . toLowerCase ( settings . locale ( ) ) ; } BooleanQuery . Builder bq = new BooleanQuery . Builder ( ) ; bq . setDisableCoord ( BOOL_ ) ; for ( Map . Entry < String , Float > entry : weights . entrySet ( ) ) { try { Query q = new FuzzyQuery ( new Term ( entry . getKey ( ) , text ) , fuzziness ) ; q . setBoost ( entry . getValue ( ) ) ; bq . add ( q , BooleanClause . Occur . SHOULD ) ; } catch ( RuntimeException e ) { rethrowUnlessLenient ( e ) ; } } return super . simplify ( bq . build ( ) ) ; }
public CallChainInfo ( SootMethod m , Stmt s , String type ) { this . type = type ; this . link = STR_ ; this . method = m ; this . stmt = s ; calls = NUM_ ; if ( type . equals ( STR_ ) ) syscalls = NUM_ ; }
public void startPlayback ( ) { Log . d ( TAG , STR_ ) ; if ( null == mRecordFile ) { Log . e ( TAG , STR_ ) ; return ; } mPlayer = new MediaPlayer ( ) ; try { mPlayer . setDataSource ( mRecordFile . getAbsolutePath ( ) ) ; Log . d ( TAG , STR_ + mRecordFile . getAbsolutePath ( ) + STR_ ) ; mPlayer . setOnCompletionListener ( this ) ; mPlayer . setOnErrorListener ( this ) ; mPlayer . prepare ( ) ; Log . d ( TAG , STR_ ) ; mPlayer . start ( ) ; } catch ( IOException e ) { Log . e ( TAG , STR_ + e ) ; setError ( ERROR_PLAYER_INTERNAL ) ; return ; } catch ( IllegalArgumentException e ) { Log . e ( TAG , STR_ + e ) ; setError ( ERROR_PLAYER_INTERNAL ) ; return ; } catch ( SecurityException e ) { Log . e ( TAG , STR_ + e ) ; setError ( ERROR_PLAYER_INTERNAL ) ; return ; } catch ( IllegalStateException e ) { Log . e ( TAG , STR_ + e ) ; setError ( ERROR_PLAYER_INTERNAL ) ; return ; } setState ( STATE_PLAYBACK ) ; Log . d ( TAG , STR_ ) ; }
public static final double sigma ( double a ) { return NUM_ / ( NUM_ + Math . exp ( - a ) ) ; }
private void deleteFilesInDir ( File dir ) { for ( File child : dir . listFiles ( ) ) { child . delete ( ) ; } }
public static void notEmpty ( String string , String msg ) { if ( string == null || string . length ( ) == NUM_ ) throw new IllegalArgumentException ( msg ) ; }
public static void resetContext ( ) { contexts . set ( null ) ; }
public static Object convertToParameterValues ( Object object ) { Collection < Object > collection ; if ( object instanceof Object [ ] ) { collection = Arrays . asList ( ( Object [ ] ) object ) ; } else if ( object instanceof Collection ) { collection = ( Collection < Object > ) object ; } else { LOGGER . warn ( STR_ ) ; return new Object [ ] { } ; } List < Object > s = new LinkedList < Object > ( ) ; for ( Object o : collection ) { Object converted = convertToParameterValue ( o ) ; if ( converted instanceof Object [ ] ) { s . addAll ( Arrays . asList ( ( Object [ ] ) converted ) ) ; } else { s . add ( converted ) ; } } return s . toArray ( new Object [ s . size ( ) ] ) ; }
public boolean logoutUser ( String username , HttpServletRequest req ) { return logoutUser ( username , req , BOOL_ , BOOL_ ) ; }
public static Operation createOperationToUpdateOrCreateNetworkInterface ( ComputeState existingComputeState , NetworkInterfaceState networkInterface , List < String > tenantLinks , StatelessService service , boolean isPublic ) { String existingInterfaceLink = getExistingNetworkInterfaceLink ( existingComputeState , isPublic ) ; Operation networkInterfaceOperation = null ; if ( existingInterfaceLink == null ) { networkInterfaceOperation = createPostOperation ( service , networkInterface , NetworkInterfaceService . FACTORY_LINK ) ; } else { networkInterfaceOperation = createPatchOperation ( service , networkInterface , existingInterfaceLink ) ; } return networkInterfaceOperation ; }
public CodeSourceFacade ( final CodeSource codeSource ) { this . location = codeSource . getLocation ( ) ; final Certificate [ ] certificates = codeSource . getCertificates ( ) ; if ( null == certificates || NUM_ == certificates . length ) { LOGGER . warning ( String . format ( STR_ , codeSource ) ) ; this . firstCertificate = null ; return ; } this . firstCertificate = ( X509Certificate ) certificates [ NUM_ ] ; }
public static byte [ ] decode ( String encoded ) { if ( encoded == null ) { return null ; } char [ ] base64Data = encoded . toCharArray ( ) ; int len = removeWhiteSpace ( base64Data ) ; if ( len % FOURBYTE != NUM_ ) { return null ; } int numberQuadruple = ( len / FOURBYTE ) ; if ( numberQuadruple == NUM_ ) { return new byte [ NUM_ ] ; } byte decodedData [ ] = null ; byte b1 = NUM_ , b2 = NUM_ , b3 = NUM_ , b4 = NUM_ ; char d1 = NUM_ , d2 = NUM_ , d3 = NUM_ , d4 = NUM_ ; int i = NUM_ ; int encodedIndex = NUM_ ; int dataIndex = NUM_ ; decodedData = new byte [ ( numberQuadruple ) . NUM_ ] ; for ( ; i < numberQuadruple - NUM_ ; i ++ ) { if ( ! isData ( ( d1 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d2 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d3 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d4 = base64Data [ dataIndex ++ ] ) ) ) { return null ; } b1 = base64Alphabet [ d1 ] ; b2 = base64Alphabet [ d2 ] ; b3 = base64Alphabet [ d3 ] ; b4 = base64Alphabet [ d4 ] ; decodedData [ encodedIndex ++ ] = ( byte ) ( b1 << NUM_ | b2 > > NUM_ ) ; decodedData [ encodedIndex ++ ] = ( byte ) ( ( ( b2 & xf ) << NUM_ ) | ( ( b3 > > NUM_ ) & xf ) ) ; decodedData [ encodedIndex ++ ] = ( byte ) ( b3 << NUM_ | b4 ) ; } if ( ! isData ( ( d1 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d2 = base64Data [ dataIndex ++ ] ) ) ) { return null ; } b1 = base64Alphabet [ d1 ] ; b2 = base64Alphabet [ d2 ] ; d3 = base64Data [ dataIndex ++ ] ; d4 = base64Data [ dataIndex ++ ] ; if ( ! isData ( ( d3 ) ) || ! isData ( ( d4 ) ) ) { if ( isPad ( d3 ) && isPad ( d4 ) ) { if ( ( b2 & xf ) != NUM_ ) { return null ; } byte [ ] tmp = new byte [ i . NUM_ + NUM_ ] ; System . arraycopy ( decodedData , NUM_ , tmp , NUM_ , i . NUM_ ) ; tmp [ encodedIndex ] = ( byte ) ( b1 << NUM_ | b2 > > NUM_ ) ; return tmp ; } else if ( ! isPad ( d3 ) && isPad ( d4 ) ) { b3 = base64Alphabet [ d3 ] ; if ( ( b3 & x3 ) != NUM_ ) { return null ; } byte [ ] tmp = new byte [ i . NUM_ + NUM_ ] ; System . arraycopy ( decodedData , NUM_ , tmp , NUM_ , i . NUM_ ) ; tmp [ encodedIndex ++ ] = ( byte ) ( b1 << NUM_ | b2 > > NUM_ ) ; tmp [ encodedIndex ] = ( byte ) ( ( ( b2 & xf ) << NUM_ ) | ( ( b3 > > NUM_ ) & xf ) ) ; return tmp ; } else { return null ; } } else { b3 = base64Alphabet [ d3 ] ; b4 = base64Alphabet [ d4 ] ; decodedData [ encodedIndex ++ ] = ( byte ) ( b1 << NUM_ | b2 > > NUM_ ) ; decodedData [ encodedIndex ++ ] = ( byte ) ( ( ( b2 & xf ) << NUM_ ) | ( ( b3 > > NUM_ ) & xf ) ) ; decodedData [ encodedIndex ++ ] = ( byte ) ( b3 << NUM_ | b4 ) ; } return decodedData ; }
public JdpBroadcaster ( InetAddress address , InetAddress srcAddress , int port , int ttl ) throws IOException , JdpException { this . addr = address ; this . port = port ; ProtocolFamily family = ( address instanceof Inet6Address ) ? StandardProtocolFamily . INET6 : StandardProtocolFamily . INET ; channel = DatagramChannel . open ( family ) ; channel . setOption ( StandardSocketOptions . SO_REUSEADDR , BOOL_ ) ; channel . setOption ( StandardSocketOptions . IP_MULTICAST_TTL , ttl ) ; if ( srcAddress != null ) { NetworkInterface interf = NetworkInterface . getByInetAddress ( srcAddress ) ; try { channel . bind ( new InetSocketAddress ( srcAddress , NUM_ ) ) ; } catch ( UnsupportedAddressTypeException ex ) { throw new JdpException ( STR_ ) ; } channel . setOption ( StandardSocketOptions . IP_MULTICAST_IF , interf ) ; } }
public void close ( ) throws IOException { rrdFile . close ( ) ; }
public Vector rotateInDegree ( double degree ) { return rotateInRadian ( Math . toRadians ( degree ) ) ; }
public Criteria or ( ) { Criteria criteria = createCriteriaInternal ( ) ; oredCriteria . add ( criteria ) ; return criteria ; }
public static String toString ( final URI uri , final Charset encoding ) throws IOException { return IOUtils . toString ( uri . toURL ( ) , Charsets . toCharset ( encoding ) ) ; }
public void put ( int fieldNumber , FieldData data ) { int i = binarySearch ( fieldNumber ) ; if ( i >= NUM_ ) { mData [ i ] = data ; } else { i = ~ i ; if ( i < mSize && mData [ i ] == DELETED ) { mFieldNumbers [ i ] = fieldNumber ; mData [ i ] = data ; return ; } if ( mGarbage && mSize >= mFieldNumbers . length ) { gc ( ) ; i = ~ binarySearch ( fieldNumber ) ; } if ( mSize >= mFieldNumbers . length ) { int n = idealIntArraySize ( mSize + NUM_ ) ; int [ ] nkeys = new int [ n ] ; FieldData [ ] nvalues = new FieldData [ n ] ; System . arraycopy ( mFieldNumbers , NUM_ , nkeys , NUM_ , mFieldNumbers . length ) ; System . arraycopy ( mData , NUM_ , nvalues , NUM_ , mData . length ) ; mFieldNumbers = nkeys ; mData = nvalues ; } if ( mSize - i != NUM_ ) { System . arraycopy ( mFieldNumbers , i , mFieldNumbers , i + NUM_ , mSize - i ) ; System . arraycopy ( mData , i , mData , i + NUM_ , mSize - i ) ; } mFieldNumbers [ i ] = fieldNumber ; mData [ i ] = data ; mSize ++ ; } }
void hideBorder ( ) { Insets insets = getInsets ( ) ; setBorder ( BorderFactory . createEmptyBorder ( insets . top , insets . left , insets . bottom , insets . right ) ) ; }
public void remove ( String btxn ) { synchronized ( filterMap ) { FilterProcessor oldfp = filterMap . get ( btxn ) ; if ( oldfp != null ) { globalExclusionFilters . remove ( oldfp ) ; btxnFilters . remove ( oldfp ) ; } } }
public void add ( double weight , double x , double y ) { observations . add ( new WeightedObservedPoint ( weight , x , y ) ) ; }
public boolean addTagId ( final Long tagId ) { if ( tagId != null && tagId > NUM_ ) { return tagIds . add ( tagId ) ; } return BOOL_ ; }
public void supportTlsIntolerantServer ( SSLSocket socket ) { socket . setEnabledProtocols ( new String [ ] { STR_ } ) ; }
@ SuppressLint ( STR_ ) @ TargetApi ( Build . VERSION_CODES . KITKAT ) private static Platform findPlatform ( ) { try { try { Class . forName ( STR_ ) ; } catch ( ClassNotFoundException e ) { Class . forName ( STR_ ) ; } OptionalMethod < Socket > setUseSessionTickets = new OptionalMethod < > ( null , STR_ , boolean . class ) ; OptionalMethod < Socket > setHostname = new OptionalMethod < > ( null , STR_ , String . class ) ; Method trafficStatsTagSocket = null ; Method trafficStatsUntagSocket = null ; OptionalMethod < Socket > getAlpnSelectedProtocol = null ; OptionalMethod < Socket > setAlpnProtocols = null ; try { Class < ? > trafficStats = Class . forName ( STR_ ) ; trafficStatsTagSocket = trafficStats . getMethod ( STR_ , Socket . class ) ; trafficStatsUntagSocket = trafficStats . getMethod ( STR_ , Socket . class ) ; try { Class . forName ( STR_ ) ; getAlpnSelectedProtocol = new OptionalMethod < > ( byte [ ] . class , STR_ ) ; setAlpnProtocols = new OptionalMethod < > ( null , STR_ , byte [ ] . class ) ; } catch ( ClassNotFoundException ignored ) { } } catch ( ClassNotFoundException | NoSuchMethodException ignored ) { } return new Android ( setUseSessionTickets , setHostname , trafficStatsTagSocket , trafficStatsUntagSocket , getAlpnSelectedProtocol , setAlpnProtocols ) ; } catch ( ClassNotFoundException ignored ) { } try { String negoClassName = STR_ ; Class < ? > negoClass = Class . forName ( negoClassName ) ; Class < ? > providerClass = Class . forName ( negoClassName + STR_ ) ; Class < ? > clientProviderClass = Class . forName ( negoClassName + STR_ ) ; Class < ? > serverProviderClass = Class . forName ( negoClassName + STR_ ) ; Method putMethod = negoClass . getMethod ( STR_ , SSLSocket . class , providerClass ) ; Method getMethod = negoClass . getMethod ( STR_ , SSLSocket . class ) ; Method removeMethod = negoClass . getMethod ( STR_ , SSLSocket . class ) ; return new JdkWithJettyBootPlatform ( putMethod , getMethod , removeMethod , clientProviderClass , serverProviderClass ) ; } catch ( ClassNotFoundException | NoSuchMethodException ignored ) { } return new Platform ( ) ; }
public static List < ExecutionEntity > orderFromRootToLeaf ( Collection < ExecutionEntity > executions ) { List < ExecutionEntity > orderedList = new ArrayList < ExecutionEntity > ( executions . size ( ) ) ; HashSet < String > previousIds = new HashSet < String > ( ) ; for ( ExecutionEntity execution : executions ) { if ( execution . getParentId ( ) == null ) { orderedList . add ( execution ) ; previousIds . add ( execution . getId ( ) ) ; } } while ( orderedList . size ( ) < executions . size ( ) ) { for ( ExecutionEntity execution : executions ) { if ( ! previousIds . contains ( execution . getId ( ) ) && previousIds . contains ( execution . getParentId ( ) ) ) { orderedList . add ( execution ) ; previousIds . add ( execution . getId ( ) ) ; } } } return orderedList ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
public static String serializeExpression ( Node s ) { if ( s instanceof ASTTerm ) { ASTTerm a = ( ASTTerm ) s ; return ( a . isNotFlag ( ) ? STR_ : STR_ ) + STR_ + a . getTerm ( ) ; } String prefix = STR_ ; String suffix = STR_ ; String join = STR_ ; if ( s instanceof ASTExpression ) { ASTExpression a = ( ASTExpression ) s ; prefix = ( a . isNotFlag ( ) ? STR_ : STR_ ) + STR_ ; suffix = STR_ ; join = STR_ + a . getType ( ) + STR_ ; } List < String > children = new ArrayList < String > ( ) ; for ( int i = NUM_ ; i < s . jjtGetNumChildren ( ) ; i ++ ) { children . add ( serializeExpression ( s . jjtGetChild ( i ) ) ) ; } return prefix + StringUtils . join ( children , join ) + suffix ; }
private void defineInternalFrameMenuButtons ( UIDefaults d ) { String p = STR_ ; String c = PAINTER_PREFIX + STR_ ; d . put ( p + STR_ , new TitlePaneMenuButtonWindowNotFocusedState ( ) ) ; d . put ( p + STR_ , new InsetsUIResource ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; d . put ( p + STR_ , new LazyPainter ( c , TitlePaneMenuButtonPainter . Which . ICON_ENABLED ) ) ; d . put ( p + STR_ , new LazyPainter ( c , TitlePaneMenuButtonPainter . Which . ICON_DISABLED ) ) ; d . put ( p + STR_ , new LazyPainter ( c , TitlePaneMenuButtonPainter . Which . ICON_MOUSEOVER ) ) ; d . put ( p + STR_ , new LazyPainter ( c , TitlePaneMenuButtonPainter . Which . ICON_PRESSED ) ) ; d . put ( p + STR_ , new LazyPainter ( c , TitlePaneMenuButtonPainter . Which . ICON_ENABLED_WINDOWNOTFOCUSED ) ) ; d . put ( p + STR_ , new LazyPainter ( c , TitlePaneMenuButtonPainter . Which . ICON_MOUSEOVER_WINDOWNOTFOCUSED ) ) ; d . put ( p + STR_ , new LazyPainter ( c , TitlePaneMenuButtonPainter . Which . ICON_PRESSED_WINDOWNOTFOCUSED ) ) ; d . put ( p + STR_ , new SeaGlassIcon ( p , STR_ , NUM_ , NUM_ ) ) ; }
public static Workflow . Method restoreFromCloneMethod ( URI storage , List < URI > clone , Boolean updateOpStatus , boolean isCG ) { return new Workflow . Method ( STR_ , storage , clone , updateOpStatus , isCG ) ; }
@ Override public synchronized void removeDataSourceListener ( DataSourceListener dsl ) { m_dataSourceListeners . remove ( dsl ) ; }
public String rightStr ( String str , int length ) { return str . substring ( Math . max ( NUM_ , str . length ( ) - length ) ) ; }
public void clearNameInUnoccupiedBlocks ( ) { for ( int i = NUM_ ; i < mBlockEntries . size ( ) ; i ++ ) { Block b = mBlockEntries . get ( i ) ; if ( b . getState ( ) == Block . UNOCCUPIED ) { b . setValue ( STR_ ) ; } } }
public static Object unserialize ( Data data ) { try { Class clazz = ( Class ) Class . forName ( ( String ) data . get ( STR_ ) ) ; if ( clazz . isEnum ( ) ) { return Enum . valueOf ( clazz , data . get ( STR_ ) ) ; } else if ( clazz == Vector3D . class ) { return new Vector3D ( data . get ( STR_ ) , data . get ( STR_ ) , data . get ( STR_ ) ) ; } else if ( clazz == Vector2D . class ) { return new Vector2D ( data . get ( STR_ ) , ( double ) data . get ( STR_ ) ) ; } else { return unserialize ( clazz , data ) ; } } catch ( Exception e ) { throw new DataException ( e ) ; } }
public static void onGridStop ( ) throws InterruptedException { synchronized ( mux ) { if ( gridCnt == NUM_ ) return ; -- gridCnt ; Thread timer0 = timer ; if ( gridCnt == NUM_ && timer0 != null ) { timer = null ; timer0 . interrupt ( ) ; timer0 . join ( ) ; } } }
public void pushTemplateFolder ( @ NotNull String folderName ) throws IOException { myLastTemplateFolders . push ( resolveName ( folderName ) ) ; }
public void printDepthFirst ( ) { print ( new DepthFirstEnumerator ( _firstNode ) ) ; }
protected void drawHorizontalBezier ( Canvas c , ILineDataSet dataSet ) { Transformer trans = mChart . getTransformer ( dataSet . getAxisDependency ( ) ) ; int entryCount = dataSet . getEntryCount ( ) ; Entry entryFrom = dataSet . getEntryForXIndex ( ( mMinX < NUM_ ) ? NUM_ : mMinX , DataSet . Rounding . DOWN ) ; Entry entryTo = dataSet . getEntryForXIndex ( mMaxX , DataSet . Rounding . UP ) ; int diff = ( entryFrom == entryTo ) ? NUM_ : NUM_ ; int minx = Math . max ( dataSet . getEntryIndex ( entryFrom ) - diff , NUM_ ) ; int maxx = Math . min ( Math . max ( minx + NUM_ , dataSet . getEntryIndex ( entryTo ) + NUM_ ) , entryCount ) ; float phaseX = Math . max ( NUM_ , Math . min ( NUM_ , mAnimator . getPhaseX ( ) ) ) ; float phaseY = mAnimator . getPhaseY ( ) ; cubicPath . reset ( ) ; int size = ( int ) Math . ceil ( ( maxx - minx ) . phaseX + minx ) ; if ( size - minx >= NUM_ ) { Entry prev = dataSet . getEntryForIndex ( minx ) ; Entry cur = prev ; cubicPath . moveTo ( cur . getXIndex ( ) , cur . getVal ( ) . phaseY ) ; for ( int j = minx + NUM_ , count = Math . min ( size , entryCount ) ; j < count ; j ++ ) { prev = dataSet . getEntryForIndex ( j - NUM_ ) ; cur = dataSet . getEntryForIndex ( j ) ; final float cpx = ( float ) ( prev . getXIndex ( ) ) + ( float ) ( cur . getXIndex ( ) - prev . getXIndex ( ) ) / NUM_ ; cubicPath . cubicTo ( cpx , prev . getVal ( ) . phaseY , cpx , cur . getVal ( ) . phaseY , cur . getXIndex ( ) , cur . getVal ( ) . phaseY ) ; } } if ( dataSet . isDrawFilledEnabled ( ) ) { cubicFillPath . reset ( ) ; cubicFillPath . addPath ( cubicPath ) ; drawCubicFill ( mBitmapCanvas , dataSet , cubicFillPath , trans , minx , size ) ; } mRenderPaint . setColor ( dataSet . getColor ( ) ) ; mRenderPaint . setStyle ( Paint . Style . STROKE ) ; trans . pathValueToPixel ( cubicPath ) ; mBitmapCanvas . drawPath ( cubicPath , mRenderPaint ) ; mRenderPaint . setPathEffect ( null ) ; }
public void addEvent ( SimEvent newEvent ) { double eventTime = newEvent . eventTime ( ) ; if ( eventTime >= maxTime ) { list . add ( newEvent ) ; maxTime = eventTime ; return ; } ListIterator < SimEvent > iterator = list . listIterator ( ) ; SimEvent event ; while ( iterator . hasNext ( ) ) { event = iterator . next ( ) ; if ( event . eventTime ( ) > eventTime ) { iterator . previous ( ) ; iterator . add ( newEvent ) ; return ; } } list . add ( newEvent ) ; }
public DbSchemaEjbGenerator ( GeneratedTables genTables , SchemaElement schemaElement ) { this ( genTables , schemaElement , CollectionType . COLLECTION , BOOL_ , BOOL_ , BOOL_ ) ; }
@ Override public void initialize ( ) { board = null ; switch ( simPaneCtrl . getParamValueIndex ( PARAM_INIT_CONF ) ) { case NUM_ : board = new EightPuzzleBoard ( new int [ ] { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ) ; break ; case NUM_ : board = new EightPuzzleBoard ( new int [ ] { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ) ; break ; case NUM_ : board = new EightPuzzleBoard ( new int [ ] { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ) ; break ; case NUM_ : board = new EightPuzzleBoard ( new int [ ] { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ) ; Random r = new Random ( System . currentTimeMillis ( ) ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { switch ( r . nextInt ( NUM_ ) ) { case NUM_ : board . moveGapUp ( ) ; break ; case NUM_ : board . moveGapDown ( ) ; break ; case NUM_ : board . moveGapLeft ( ) ; break ; case NUM_ : board . moveGapRight ( ) ; break ; } } } stateViewCtrl . initialize ( board ) ; }
protected abstract void onOpen ( HTableInterface tbl , Scan scan ) throws IOException ;
private static void addAbbreviation ( String primitive , String abbreviation ) { abbreviationMap . put ( primitive , abbreviation ) ; reverseAbbreviationMap . put ( abbreviation , primitive ) ; }
private void initTreeMap ( ) { if ( entityType == null ) { entityType = STR_ ; } if ( entityType . equalsIgnoreCase ( STR_ ) ) { imageMap = RotatingEntityManager . getCircle ( ) ; } if ( entityType . equalsIgnoreCase ( STR_ ) ) { imageMap = RotatingEntityManager . getMouse ( ) ; } else if ( entityType . equalsIgnoreCase ( STR_ ) ) { imageMap = RotatingEntityManager . getRotatingTileset ( STR_ , NUM_ ) ; } else if ( entityType . equalsIgnoreCase ( STR_ ) ) { imageMap = RotatingEntityManager . getRotatingTileset ( STR_ , NUM_ ) ; } else if ( entityType . equalsIgnoreCase ( STR_ ) ) { imageMap = RotatingEntityManager . getRotatingTileset ( STR_ , NUM_ ) ; } else if ( entityType . equalsIgnoreCase ( STR_ ) ) { imageMap = RotatingEntityManager . getRotatingTileset ( STR_ , NUM_ ) ; } else if ( entityType . equalsIgnoreCase ( STR_ ) ) { imageMap = RotatingEntityManager . getRotatingTileset ( STR_ , NUM_ ) ; } else if ( entityType . equalsIgnoreCase ( STR_ ) ) { imageMap = RotatingEntityManager . getRotatingTileset ( STR_ , NUM_ ) ; } else if ( entityType . equalsIgnoreCase ( STR_ ) ) { imageMap = RotatingEntityManager . getRotatingTileset ( STR_ , NUM_ ) ; } else if ( entityType . equalsIgnoreCase ( STR_ ) ) { imageMap = RotatingEntityManager . getRotatingTileset ( STR_ , NUM_ ) ; } else if ( entityType . equalsIgnoreCase ( STR_ ) ) { imageMap = RotatingEntityManager . getRotatingTileset ( STR_ , NUM_ ) ; } update ( ) ; }
public static File locateReplicatorHomeDir ( ) { if ( replicatorHomeDir == null ) { String replicatorHome = System . getProperty ( HOME_DIR ) ; if ( replicatorHome == null ) replicatorHome = System . getProperty ( STR_ ) ; replicatorHomeDir = new File ( replicatorHome ) ; if ( ! replicatorHomeDir . isDirectory ( ) ) { throw new ServerRuntimeException ( STR_ + replicatorHomeDir ) ; } } return replicatorHomeDir ; }
public StringData ( String data ) { m_data = data ; }
void writeRepeatedSqr ( DD xdd ) { if ( xdd . ge ( DD . valueOf ( NUM_ ) ) ) throw new IllegalArgumentException ( STR_ ) ; int count = NUM_ ; while ( xdd . doubleValue ( ) > NUM_ ) { count ++ ; if ( count == NUM_ ) count = count ; double x = xdd . doubleValue ( ) ; DD xSqr = xdd . sqr ( ) ; String s = xSqr . toString ( ) ; DD xSqr2 = DD . parse ( s ) ; xdd = xSqr ; } }
public java . lang . StringBuffer append ( float f ) { internal . append ( f ) ; return this ; }
public static final void open ( File file ) throws NoSuchMethodException { if ( Platform . isMacOSX ( ) ) { execArgs ( STR_ , file . getAbsolutePath ( ) ) ; } else if ( Platform . isWindows ( ) ) { if ( file . isDirectory ( ) ) { execArgs ( STR_ , file . getAbsolutePath ( ) ) ; } else { execArgs ( STR_ , file . getAbsolutePath ( ) ) ; } } else if ( Platform . isUnix ( ) && hasUnixCommand ( STR_ ) ) { execArgs ( STR_ , file . toString ( ) ) ; } else if ( Platform . isUnix ( ) && hasUnixCommand ( STR_ ) ) { execArgs ( STR_ , file . toString ( ) ) ; } else if ( Platform . isSolaris ( ) && file . isDirectory ( ) ) { execArgs ( STR_ , STR_ , file . getAbsolutePath ( ) ) ; } else { throw new NoSuchMethodException ( STR_ ) ; } }
@ Override public String testDestination ( Location destination , Track track ) { String status = super . testDestination ( destination , track ) ; if ( ! status . equals ( Track . OKAY ) ) { return status ; } if ( track == null ) { return status ; } return track . checkSchedule ( this ) ; }
public void close ( ) throws java . io . IOException { flushBuffer ( ) ; m_os . close ( ) ; }
private static String [ ] norm ( String path ) { String [ ] elements = path . split ( STR_ ) ; ArrayList < String > stack = new ArrayList < String > ( ) ; for ( String e : elements ) { if ( e . isEmpty ( ) || e . equals ( STR_ ) ) continue ; if ( e . equals ( STR_ ) ) { if ( ! stack . isEmpty ( ) ) stack . remove ( stack . size ( ) - NUM_ ) ; else return null ; continue ; } stack . add ( e ) ; } return stack . toArray ( new String [ stack . size ( ) ] ) ; }
static Random random ( ) { if ( null == LUCENE_TEST_CASE ) { return null ; } else { try { Method randomMethod = LUCENE_TEST_CASE . getMethod ( STR_ ) ; return ( Random ) randomMethod . invoke ( null ) ; } catch ( Exception e ) { throw new IllegalStateException ( STR_ , e ) ; } } }
protected String record ( String deployment ) { deployments . add ( deployment ) ; return deployment ; }
protected void onBeforeStart ( BundleContext ctx ) { }
@ Override public void onSuccess ( DLSN value ) { if ( value . getLogSegmentSequenceNo ( ) != currentLogSegmentSeqNo ) { LOG . error ( STR_ , value . getLogSegmentSequenceNo ( ) , currentLogSegmentSeqNo ) ; errorsFound . set ( BOOL_ ) ; } if ( verifyEntryId && value . getEntryId ( ) != currentEntryId ) { LOG . error ( STR_ , value . getEntryId ( ) , currentEntryId ) ; errorsFound . set ( BOOL_ ) ; } syncLatch . countDown ( ) ; }
private static void shutDownMySQLAbandonedConnectionCleanupThread ( ClassLoader classLoader ) { try { Class < ? > mysqlCleanupThreadClass ; try { mysqlCleanupThreadClass = classLoader . loadClass ( STR_ ) ; } catch ( ClassNotFoundException e ) { LOG . trace ( STR_ + STR_ , e ) ; return ; } Method shutdownMethod = mysqlCleanupThreadClass . getMethod ( STR_ ) ; shutdownMethod . invoke ( null ) ; LOG . debug ( STR_ ) ; } catch ( Throwable e ) { LOG . warn ( STR_ , e ) ; } }
public void write ( byte [ ] buffer ) { if ( isFinal ) { log . warning ( STR_ ) ; return ; } byte [ ] newData = new byte [ data . length + buffer . length ] ; System . arraycopy ( data , NUM_ , newData , NUM_ , data . length ) ; System . arraycopy ( buffer , NUM_ , newData , data . length , buffer . length ) ; data = newData ; }
public String parse ( String controlTemplate , Context controlContext ) throws Exception { this . controlContext = controlContext ; fillContextDefaults ( this . controlContext ) ; fillContextProperties ( this . controlContext ) ; Template template = getTemplate ( controlTemplate , inputEncoding ) ; StringWriter sw = new StringWriter ( ) ; template . merge ( controlContext , sw ) ; return sw . toString ( ) ; }
private void writeAttribute ( java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( namespace . equals ( STR_ ) ) { xmlWriter . writeAttribute ( attName , attValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } }
protected boolean onCreateCustomFromTag ( XmlPullParser parser , T parent , final AttributeSet attrs ) throws XmlPullParserException { return BOOL_ ; }
public static long writeFile ( String path , byte [ ] jpeg , ExifInterface exif ) throws IOException { if ( ! createDirectoryIfNeeded ( path ) ) { Log . e ( TAG , STR_ + path ) ; return - NUM_ ; } if ( exif != null ) { exif . writeExif ( jpeg , path ) ; File f = new File ( path ) ; return f . length ( ) ; } else { return writeFile ( path , jpeg ) ; } }
private boolean checkForImageServers ( ) { boolean imageServerExists = BOOL_ ; List < URI > imageServerURIList = _dbClient . queryByType ( ComputeImageServer . class , BOOL_ ) ; ArrayList < URI > tempList = Lists . newArrayList ( imageServerURIList . iterator ( ) ) ; if ( tempList . isEmpty ( ) ) { imageServerExists = BOOL_ ; } return imageServerExists ; }
final long now ( ) { return System . nanoTime ( ) ; }
public void removeExtension ( String ext ) { synchronized ( exts ) { ext = ext . toLowerCase ( ) ; exts . remove ( ext ) ; } }
protected SuballocatedIntVector findNamespaceContext ( int elementNodeIndex ) { if ( null != m_namespaceDeclSetElements ) { int wouldBeAt = findInSortedSuballocatedIntVector ( m_namespaceDeclSetElements , elementNodeIndex ) ; if ( wouldBeAt >= NUM_ ) return ( SuballocatedIntVector ) m_namespaceDeclSets . elementAt ( wouldBeAt ) ; if ( wouldBeAt == - NUM_ ) return null ; wouldBeAt = - NUM_ - wouldBeAt ; int candidate = m_namespaceDeclSetElements . elementAt ( -- wouldBeAt ) ; int ancestor = _parent ( elementNodeIndex ) ; if ( wouldBeAt == NUM_ && candidate < ancestor ) { int rootHandle = getDocumentRoot ( makeNodeHandle ( elementNodeIndex ) ) ; int rootID = makeNodeIdentity ( rootHandle ) ; int uppermostNSCandidateID ; if ( getNodeType ( rootHandle ) == DTM . DOCUMENT_NODE ) { int ch = _firstch ( rootID ) ; uppermostNSCandidateID = ( ch != DTM . NULL ) ? ch : rootID ; } else { uppermostNSCandidateID = rootID ; } if ( candidate == uppermostNSCandidateID ) { return ( SuballocatedIntVector ) m_namespaceDeclSets . elementAt ( wouldBeAt ) ; } } while ( wouldBeAt >= NUM_ && ancestor > NUM_ ) { if ( candidate == ancestor ) { return ( SuballocatedIntVector ) m_namespaceDeclSets . elementAt ( wouldBeAt ) ; } else if ( candidate < ancestor ) { do { ancestor = _parent ( ancestor ) ; } while ( candidate < ancestor ) ; } else if ( wouldBeAt > NUM_ ) { candidate = m_namespaceDeclSetElements . elementAt ( -- wouldBeAt ) ; } else break ; } } return null ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
public void addObserver ( Observer observer ) { if ( observer == null ) { throw new NullPointerException ( STR_ ) ; } synchronized ( this ) { if ( ! observers . contains ( observer ) ) observers . add ( observer ) ; } }
public static void closeOutputStream ( OutputStream stream , String tag ) { if ( stream != null ) { try { stream . close ( ) ; } catch ( IOException e ) { Log . e ( tag , STR_ + e ) ; } } }
protected double distance ( int i , int k , int [ ] designations ) { return Math . sqrt ( Math . max ( selfK [ i ] - NUM_ / ownes [ k ] . evalSumK ( i , k , designations ) + meanSqrdNorms [ k ] . normConsts [ k ] , NUM_ ) ) ; }
public StringBuffer format ( Object pat , StringBuffer result , FieldPosition fpos ) { String pattern = processPattern ( ( String ) pat ) ; int lastOffset = NUM_ ; for ( int i = NUM_ ; i <= maxOffset ; ++ i ) { int offidx = offsets [ i ] ; result . append ( pattern . substring ( lastOffset , offsets [ i ] ) ) ; lastOffset = offidx ; String key = arguments [ i ] ; String obj ; if ( key . length ( ) > NUM_ ) { obj = formatObject ( processKey ( key ) ) ; } else { result . append ( this . ldel ) ; result . append ( this . rdel ) ; continue ; } if ( obj == null ) { String lessgreedy = ldel + key ; int fromright = lessgreedy . lastIndexOf ( ldel ) ; if ( fromright > NUM_ ) { String newkey = lessgreedy . substring ( fromright + ldel . length ( ) ) ; String newsubst = formatObject ( processKey ( newkey ) ) ; if ( newsubst != null ) { obj = lessgreedy . substring ( NUM_ , fromright ) + newsubst ; } } } if ( obj == null ) { if ( throwex ) { throw new IllegalArgumentException ( STR_ ) ; } else { obj = ldel + key + rdel ; } } result . append ( obj ) ; } result . append ( pattern . substring ( lastOffset , pattern . length ( ) ) ) ; return result ; }
public void add ( String keyword , byte id ) { int key = getStringMapKey ( keyword ) ; map [ key ] = new Keyword ( keyword . toCharArray ( ) , id , map [ key ] ) ; }
void release ( Object owner , Field field ) { Map < String , Integer > fields = owners . get ( owner ) ; if ( fields != null ) { release ( ) ; Integer count = fields . get ( field . toGenericString ( ) ) ; if ( -- count > NUM_ ) { fields . put ( field . toGenericString ( ) , count ) ; } else { fields . remove ( field . toGenericString ( ) ) ; } } if ( fields != null && fields . isEmpty ( ) ) { owners . remove ( owner ) ; } }
public static List < DashboardDto > transformToDto ( List < Dashboard > dashboards ) { if ( dashboards == null ) { throw new WebApplicationException ( STR_ , Status . INTERNAL_SERVER_ERROR ) ; } List < DashboardDto > result = new ArrayList < DashboardDto > ( ) ; for ( Dashboard dashboard : dashboards ) { result . add ( transformToDto ( dashboard ) ) ; } return result ; }
static Executor screenExecutor ( Executor e ) { if ( ! useCommonPool && e == ForkJoinPool . commonPool ( ) ) return asyncPool ; if ( e == null ) throw new NullPointerException ( ) ; return e ; }
public void addGroupPropertiesListener ( GroupPropertiesListener groupPropertiesListener ) { groupPropertiesListeners . add ( groupPropertiesListener ) ; }
public static void editGlobalFunctionComment ( final AbstractSQLProvider provider , final INaviFunction function , final Integer commentId , final Integer userId , final String newComment ) throws CouldntSaveDataException { PostgreSQLCommentFunctions . editComment ( provider , commentId , userId , newComment ) ; }
public void load ( Element element , Object o ) { log . error ( STR_ ) ; }
public synchronized void clearSessions ( Context context , Boolean clearCredentials ) { synchronized ( instance ) { while ( mMXSessions . size ( ) > NUM_ ) { clearSession ( context , mMXSessions . get ( NUM_ ) , clearCredentials ) ; } } }
public boolean doesEntryExists ( SSOToken token , String entryDN ) { try { PersistentObject po = UMSObject . getObject ( internalToken , new Guid ( entryDN ) ) ; } catch ( UMSException ue ) { if ( entryDN . indexOf ( STR_ ) < NUM_ ) { if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + STR_ , ue ) ; } } return BOOL_ ; } return BOOL_ ; }
private static char [ ] yy_unpack_cmap ( String packed ) { char [ ] map = new char [ x10000 ] ; int i = NUM_ ; int j = NUM_ ; while ( i < NUM_ ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM_ ) ; } return map ; }
private static int hashWrapperName ( String xn ) { if ( xn . length ( ) < NUM_ ) { return NUM_ ; } return ( NUM_ . xn . charAt ( NUM_ ) + xn . charAt ( NUM_ ) ) % NUM_ ; }
@ Override public final void startElement ( final String ns , final String lName , final String qName , final Attributes list ) throws SAXException { String name = lName == null || lName . length ( ) == NUM_ ? qName : lName ; StringBuffer sb = new StringBuffer ( match ) ; if ( match . length ( ) > NUM_ ) { sb . append ( STR_ ) ; } sb . append ( name ) ; match = sb . toString ( ) ; Rule r = ( Rule ) RULES . match ( match ) ; if ( r != null ) { r . begin ( name , list ) ; } }
public boolean isString ( String key ) { Object val = get ( key ) ; return val instanceof String ; }
private void createPRWithTotalNumPropSetList ( List vmList , int startIndexForRegion , int endIndexForRegion , int localMaxMemory , int redundancy ) { Iterator nodeIterator = vmList . iterator ( ) ; while ( nodeIterator . hasNext ( ) ) { VM vm = ( VM ) nodeIterator . next ( ) ; vm . invoke ( createMultiplePRWithTotalNumBucketPropSet ( prPrefix , startIndexForRegion , endIndexForRegion , redundancy , localMaxMemory , NUM_ ) ) ; } }
public Zdiagmat ( Zmat A , int k ) throws JampackException { Parameters . BaseIndexNotChangeable = BOOL_ ; basex = Parameters . BaseIndex ; if ( k >= NUM_ ) { if ( k >= A . ncol ) { throw new JampackException ( STR_ ) ; } order = Math . min ( A . nrow , A . ncol - k ) ; re = new double [ order ] ; im = new double [ order ] ; for ( int i = NUM_ ; i < order ; i ++ ) { re [ i ] = A . re [ i ] [ i + k ] ; im [ i ] = A . im [ i ] [ i + k ] ; } } else { k = - k ; if ( k >= A . nrow ) { throw new JampackException ( STR_ ) ; } order = Math . min ( A . nrow - k , A . ncol ) ; re = new double [ order ] ; im = new double [ order ] ; for ( int i = NUM_ ; i < order ; i ++ ) { re [ i ] = A . re [ i + k ] [ i ] ; im [ i ] = A . im [ i + k ] [ i ] ; } } getProperties ( ) ; }
protected void checkAntVersion ( Hashtable h ) { if ( null == h ) h = new Hashtable ( ) ; try { final String ANT_VERSION_CLASS = STR_ ; final String ANT_VERSION_METHOD = STR_ ; final Class noArgs [ ] = new Class [ NUM_ ] ; Class clazz = ObjectFactory . findProviderClass ( ANT_VERSION_CLASS , ObjectFactory . findClassLoader ( ) , BOOL_ ) ; Method method = clazz . getMethod ( ANT_VERSION_METHOD , noArgs ) ; Object returnValue = method . invoke ( null , new Object [ NUM_ ] ) ; h . put ( VERSION + STR_ , ( String ) returnValue ) ; } catch ( Exception e ) { h . put ( VERSION + STR_ , CLASS_NOTPRESENT ) ; } }
private static boolean areEqual ( int fromIndex , CharSequence left , CharSequence right ) { if ( left == right ) return BOOL_ ; if ( ( left == null ) || ( right == null ) ) return BOOL_ ; int n = left . length ( ) ; if ( right . length ( ) != n ) return BOOL_ ; for ( int i = n ; i > fromIndex ; ) { if ( Character . toUpperCase ( left . charAt ( -- i ) ) != Character . toUpperCase ( right . charAt ( i ) ) ) return BOOL_ ; } return BOOL_ ; }
public void testCase12 ( ) { byte bBytes [ ] = { NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , - NUM_ } ; int bSign = - NUM_ ; byte rBytes [ ] = { NUM_ } ; BigInteger aNumber = BigInteger . ZERO ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . divide ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public Enumeration productions ( ) { return _productions . elements ( ) ; }
public void addTightSourceNode ( ASTNode reference ) { fTightSourceRangeNodes . add ( reference ) ; List < StructuralPropertyDescriptor > properties = reference . structuralPropertiesForType ( ) ; for ( Iterator < StructuralPropertyDescriptor > iterator = properties . iterator ( ) ; iterator . hasNext ( ) ; ) { StructuralPropertyDescriptor descriptor = iterator . next ( ) ; if ( descriptor . isChildProperty ( ) ) { ASTNode child = ( ASTNode ) reference . getStructuralProperty ( descriptor ) ; if ( child != null && isExtending ( child , reference ) ) { addTightSourceNode ( child ) ; } } else if ( descriptor . isChildListProperty ( ) ) { List < ? extends ASTNode > children = ( List < ? extends ASTNode > ) reference . getStructuralProperty ( descriptor ) ; for ( Iterator < ? extends ASTNode > iterator2 = children . iterator ( ) ; iterator2 . hasNext ( ) ; ) { ASTNode child = iterator2 . next ( ) ; if ( isExtending ( child , reference ) ) { addTightSourceNode ( child ) ; } } } } }
protected boolean isEventDisabled ( XEvent e ) { switch ( e . get_type ( ) ) { case XConstants . ConfigureNotify : return BOOL_ ; case XConstants . EnterNotify : case XConstants . LeaveNotify : return BOOL_ ; default : return super . isEventDisabled ( e ) ; } }
public DJarInfo ( JFrame parent ) throws IOException { this ( parent , res . getString ( STR_ ) , ModalityType . DOCUMENT_MODAL ) ; }
protected void transformPointArrayNoTouch ( float [ ] pts ) { mMatrixValueToPx . mapPoints ( pts ) ; mMatrixOffset . mapPoints ( pts ) ; }
private void convertEscapedFunction ( final StringBuilder target , final CharSequence escapedFunction ) throws FBSQLParseException { final String templateResult = FBEscapedFunctionHelper . convertTemplate ( escapedFunction . toString ( ) , mode ) ; target . append ( templateResult != null ? templateResult : escapedFunction ) ; }
@ Override public final String toString ( ) { if ( stringRep == null ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( this . name ) ; buffer . append ( STR_ ) ; buffer . append ( Integer . toString ( this . defaultPort ) ) ; stringRep = buffer . toString ( ) ; } return stringRep ; }
public void addListener ( ImsSessionListener listener ) { mListeners . add ( listener ) ; }
public int checkBookiesUp ( int count , int timeout ) throws Exception { ZooKeeper zkc = connectZooKeeper ( zkHost , zkPort , zkTimeoutSec ) ; try { int mostRecentSize = NUM_ ; for ( int i = NUM_ ; i < timeout ; i ++ ) { try { List < String > children = zkc . getChildren ( STR_ , BOOL_ ) ; children . remove ( STR_ ) ; mostRecentSize = children . size ( ) ; if ( ( mostRecentSize > count ) || LOG . isDebugEnabled ( ) ) { LOG . info ( STR_ + mostRecentSize + STR_ + STR_ + count ) ; if ( ( mostRecentSize > count ) || LOG . isTraceEnabled ( ) ) { for ( String child : children ) { LOG . info ( STR_ + child ) ; } } } if ( mostRecentSize == count ) { break ; } } catch ( KeeperException e ) { } Thread . sleep ( NUM_ ) ; } return mostRecentSize ; } finally { zkc . close ( ) ; } }
public static IPath stampToPath ( final long stamp ) { fgCalendar . setTimeInMillis ( stamp ) ; final StringBuffer buffer = new StringBuffer ( NUM_ ) ; buffer . append ( fgCalendar . get ( Calendar . YEAR ) ) ; buffer . append ( IPath . SEPARATOR ) ; buffer . append ( fgCalendar . get ( Calendar . MONTH ) + NUM_ ) ; buffer . append ( IPath . SEPARATOR ) ; buffer . append ( fgCalendar . get ( Calendar . WEEK_OF_YEAR ) ) ; return new Path ( buffer . toString ( ) ) ; }
private void addPingTimeData ( long sample ) { lastPingTimesLock . lock ( ) ; try { if ( lastPingTimes == null ) { lastPingTimes = new long [ PING_MOVING_AVERAGE_WINDOW ] ; Arrays . fill ( lastPingTimes , sample ) ; } else { System . arraycopy ( lastPingTimes , NUM_ , lastPingTimes , NUM_ , lastPingTimes . length - NUM_ ) ; lastPingTimes [ lastPingTimes . length - NUM_ ] = sample ; } } finally { lastPingTimesLock . unlock ( ) ; } }
public void printUserMessage ( UserMessage message ) { User user = message . user ; boolean ignored = message . ignored_compact ; if ( ignored ) { printCompact ( STR_ , user ) ; return ; } Color color = message . color ; boolean action = message . action ; String text = message . text ; TagEmotes emotes = message . emotes ; boolean highlighted = message . highlighted ; if ( message . whisper && message . action ) { color = StyleConstants . getForeground ( styles . info ( ) ) ; highlighted = BOOL_ ; } closeCompactMode ( ) ; MutableAttributeSet style ; if ( highlighted ) { style = styles . highlight ( color ) ; } else { style = styles . standard ( ) ; } print ( getTimePrefix ( ) , style ) ; printUser ( user , action , message . whisper , message . id ) ; if ( ! highlighted && action && styles . actionColored ( ) ) { style = styles . standard ( user . getDisplayColor ( ) ) ; } printSpecials ( text , user , style , emotes , BOOL_ , message . bits > NUM_ ) ; printNewline ( ) ; }
public boolean connectImpl ( String address , int port ) throws IOException { _socketTimeout = NUM_ ; _nativeFd = - NUM_ ; _isClosed . set ( BOOL_ ) ; synchronized ( _writeLock ) { boolean isConnect = nativeConnect ( _socketFd , address , port ) ; return isConnect ; } }
public static boolean isAccessModifier ( String str ) { return str . equals ( STR_ ) || str . equals ( STR_ ) || str . equals ( STR_ ) || str . equals ( STR_ ) || str . equals ( STR_ ) || str . equals ( STR_ ) ; }
protected void handleAppendRequestFailure ( MemberState member , AppendRequest request , Throwable error ) { failAttempt ( member , error ) ; }
private static SizePair selectSizePair ( Camera camera , int desiredWidth , int desiredHeight ) { List < SizePair > validPreviewSizes = generateValidPreviewSizeList ( camera ) ; SizePair selectedPair = null ; int minDiff = Integer . MAX_VALUE ; for ( SizePair sizePair : validPreviewSizes ) { Size size = sizePair . previewSize ( ) ; int diff = Math . abs ( size . getWidth ( ) - desiredWidth ) + Math . abs ( size . getHeight ( ) - desiredHeight ) ; if ( diff < minDiff ) { selectedPair = sizePair ; minDiff = diff ; } } return selectedPair ; }
public List < AddressItem > loadAllDeepFromCursor ( Cursor cursor ) { int count = cursor . getCount ( ) ; List < AddressItem > list = new ArrayList < AddressItem > ( count ) ; if ( cursor . moveToFirst ( ) ) { if ( identityScope != null ) { identityScope . lock ( ) ; identityScope . reserveRoom ( count ) ; } try { do { list . add ( loadCurrentDeep ( cursor , BOOL_ ) ) ; } while ( cursor . moveToNext ( ) ) ; } finally { if ( identityScope != null ) { identityScope . unlock ( ) ; } } } return list ; }
public static String decode ( byte [ ] utf8 ) throws CharacterCodingException { return decode ( ByteBuffer . wrap ( utf8 ) , BOOL_ ) ; }
private Map < String , String > attributesToLowerCase ( ) { Map < String , String > lowerCaseAttributes = new LinkedHashMap < String , String > ( ) ; for ( String key : attributes . keySet ( ) ) { lowerCaseAttributes . put ( key . toLowerCase ( ) , attributes . get ( key ) ) ; } return lowerCaseAttributes ; }
protected final void acceptAnnotations ( final MethodVisitor mv ) { int n = visibleTypeAnnotations == null ? NUM_ : visibleTypeAnnotations . size ( ) ; for ( int i = NUM_ ; i < n ; ++ i ) { TypeAnnotationNode an = visibleTypeAnnotations . get ( i ) ; an . accept ( mv . visitInsnAnnotation ( an . typeRef , an . typePath , an . desc , BOOL_ ) ) ; } n = invisibleTypeAnnotations == null ? NUM_ : invisibleTypeAnnotations . size ( ) ; for ( int i = NUM_ ; i < n ; ++ i ) { TypeAnnotationNode an = invisibleTypeAnnotations . get ( i ) ; an . accept ( mv . visitInsnAnnotation ( an . typeRef , an . typePath , an . desc , BOOL_ ) ) ; } }
public static < T > List < T > toList ( T obj1 , T obj2 ) { List < T > list = new LinkedList < T > ( ) ; list . add ( obj1 ) ; list . add ( obj2 ) ; return list ; }
public byte [ ] readNextPart ( ) throws JPlagException { if ( remainingBytes == NUM_ ) { throw new JPlagException ( STR_ , STR_ , STR_ ) ; } try { FileInputStream in = new FileInputStream ( file ) ; in . skip ( filesize - remainingBytes ) ; int partsize = remainingBytes ; if ( partsize > NUM_ ) partsize = NUM_ ; byte [ ] data = new byte [ partsize ] ; in . read ( data ) ; in . close ( ) ; remainingBytes -= partsize ; return data ; } catch ( IOException e ) { e . printStackTrace ( ) ; throw new JPlagException ( STR_ , STR_ + STR_ , STR_ ) ; } }
public boolean isMultiLineTabbed ( ) { return multiLineTab ; }
protected void computeParameters ( ) { if ( m_SumOfWeights > NUM_ ) { m_Mean = m_SumOfValues / m_SumOfWeights ; double stdDev = Math . sqrt ( Math . abs ( m_SumOfValuesSq - m_Mean . m_SumOfValues ) / m_SumOfWeights ) ; if ( stdDev > NUM_ ) { m_StandardDev = Math . max ( m_Precision / ( NUM_ . NUM_ ) , stdDev ) ; } } }
public String translateDataType ( String sourceVendorName , String targetVendorName , String dataType , int size , int scale ) { return getDataType ( targetVendorName , getDataTypeID ( sourceVendorName , dataType ) , size , scale ) ; }
public static List < ShapeRecord > rectangle ( double startx , double starty , double width , double height , double radiusX , double radiusY , double topLeftRadiusX , double topLeftRadiusY , double topRightRadiusX , double topRightRadiusY , double bottomLeftRadiusX , double bottomLeftRadiusY , double bottomRightRadiusX , double bottomRightRadiusY ) { List < ShapeRecord > shapeRecords = new ArrayList < ShapeRecord > ( ) ; if ( radiusX == NUM_ ) { radiusY = radiusX = NUM_ ; } else if ( radiusY == NUM_ ) { radiusY = radiusX ; } if ( radiusX > width / NUM_ ) radiusX = width / NUM_ ; if ( radiusY > height / NUM_ ) radiusY = height / NUM_ ; double [ ] topLeftRadius = getCornerRadius ( topLeftRadiusX , topLeftRadiusY , radiusX , radiusY , width , height ) ; topLeftRadiusX = topLeftRadius [ NUM_ ] ; topLeftRadiusY = topLeftRadius [ NUM_ ] ; double [ ] topRightRadius = getCornerRadius ( topRightRadiusX , topRightRadiusY , radiusX , radiusY , width , height ) ; topRightRadiusX = topRightRadius [ NUM_ ] ; topRightRadiusY = topRightRadius [ NUM_ ] ; double [ ] bottomLeftRadius = getCornerRadius ( bottomLeftRadiusX , bottomLeftRadiusY , radiusX , radiusY , width , height ) ; bottomLeftRadiusX = bottomLeftRadius [ NUM_ ] ; bottomLeftRadiusY = bottomLeftRadius [ NUM_ ] ; double [ ] bottomRightRadius = getCornerRadius ( bottomRightRadiusX , bottomRightRadiusY , radiusX , radiusY , width , height ) ; bottomRightRadiusX = bottomRightRadius [ NUM_ ] ; bottomRightRadiusY = bottomRightRadius [ NUM_ ] ; double c0 = NUM_ ; double c1 = NUM_ ; double c3 = NUM_ ; double rx = bottomRightRadiusX ; double ry = bottomRightRadiusY ; double tx = rx / NUM_ ; double ty = ry / NUM_ ; double dx , currentx ; double dy , currenty ; dx = startx + width - rx ; dy = starty + height - ry ; shapeRecords . add ( move ( ( dx + rx ) , dy ) ) ; currentx = ( dx + rx ) ; currenty = dy ; if ( bottomRightRadiusX != NUM_ ) { shapeRecords . add ( curvedEdge ( currentx , currenty , ( dx + c0 . tx ) , ( dy + c1 . ty ) , ( dx + c3 . rx ) , ( dy + c3 . ry ) ) ) ; shapeRecords . add ( curvedEdge ( ( dx + c3 . rx ) , ( dy + c3 . ry ) , ( dx + c1 . tx ) , ( dy + c0 . ty ) , dx , ( dy + ry ) ) ) ; currentx = dx ; currenty = dy + ry ; } rx = bottomLeftRadiusX ; ry = bottomLeftRadiusY ; tx = rx / NUM_ ; ty = ry / NUM_ ; dx = startx + rx ; dy = starty + height - ry ; shapeRecords . addAll ( straightEdge ( currentx , currenty , dx , ( dy + ry ) ) ) ; currentx = dx ; currenty = dy + ry ; if ( bottomLeftRadiusX != NUM_ ) { shapeRecords . add ( curvedEdge ( currentx , currenty , ( dx - c1 . tx ) , ( dy + c0 . ty ) , ( dx - c3 . rx ) , ( dy + c3 . ry ) ) ) ; shapeRecords . add ( curvedEdge ( ( dx - c3 . rx ) , ( dy + c3 . ry ) , ( dx - c0 . tx ) , ( dy + c1 . ty ) , ( dx - rx ) , dy ) ) ; currentx = dx - rx ; currenty = dy ; } rx = topLeftRadiusX ; ry = topLeftRadiusY ; tx = rx / NUM_ ; ty = ry / NUM_ ; dx = startx + rx ; dy = starty + ry ; shapeRecords . addAll ( straightEdge ( currentx , currenty , ( dx - rx ) , dy ) ) ; currentx = dx - rx ; currenty = dy ; if ( topLeftRadiusX != NUM_ ) { shapeRecords . add ( curvedEdge ( currentx , currenty , ( dx - c0 . tx ) , ( dy - c1 . ty ) , ( dx - c3 . rx ) , ( dy - c3 . ry ) ) ) ; shapeRecords . add ( curvedEdge ( ( dx - c3 . rx ) , ( dy - c3 . ry ) , ( dx - c1 . tx ) , ( dy - c0 . ty ) , dx , ( dy - ry ) ) ) ; currentx = dx ; currenty = dy - ry ; } rx = topRightRadiusX ; ry = topRightRadiusY ; tx = rx / NUM_ ; ty = ry / NUM_ ; dx = startx + width - rx ; dy = starty + ry ; shapeRecords . addAll ( straightEdge ( currentx , currenty , dx , ( dy - ry ) ) ) ; currentx = dx ; currenty = dy - ry ; if ( topRightRadiusX != NUM_ ) { shapeRecords . add ( curvedEdge ( currentx , currenty , ( dx + c1 . tx ) , ( dy - c0 . ty ) , ( dx + c3 . rx ) , ( dy - c3 . ry ) ) ) ; shapeRecords . add ( curvedEdge ( ( dx + c3 . rx ) , ( dy - c3 . ry ) , ( dx + c0 . tx ) , ( dy - c1 . ty ) , ( dx + rx ) , dy ) ) ; currentx = ( dx + rx ) ; currenty = dy ; } rx = bottomRightRadiusX ; ry = bottomRightRadiusY ; tx = rx / NUM_ ; ty = ry / NUM_ ; dx = startx + width - rx ; dy = starty + height - ry ; shapeRecords . addAll ( straightEdge ( currentx , currenty , ( dx + rx ) , dy ) ) ; return shapeRecords ; }
public static int findGlobalValleyLocation ( double [ ] data ) { double min = Double . NaN ; int imin = - NUM_ ; for ( int i = NUM_ ; i < data . length ; i ++ ) { if ( Double . isNaN ( data [ i ] ) ) continue ; if ( Double . isNaN ( min ) || data [ i ] < min ) { min = data [ i ] ; imin = i ; } } return imin ; }
public void delete ( ) throws IOException { close ( ) ; deleteContents ( directory ) ; }
protected void moveDownSelected ( ) { int selectedIndex = table . getSelectedRow ( ) ; if ( selectedIndex > - NUM_ ) { int index = data . moveDown ( indexToModel ( selectedIndex ) ) ; setRowSelected ( indexToView ( index ) ) ; } }
JarWithFile ( PathImpl backing ) { super ( backing ) ; }
public List < Runnable > shutdownNow ( ) { logger . info ( STR_ ) ; return executor . shutdownNow ( ) ; }
public static List < String > toRelativePaths ( @ NotNull VirtualFile root , @ NotNull final Collection < FilePath > filePaths ) { ArrayList < String > rc = new ArrayList < String > ( filePaths . size ( ) ) ; for ( FilePath path : filePaths ) { rc . add ( relativePath ( root , path ) ) ; } return rc ; }
private void handleUnlockOrInstall ( ) { if ( isFinishing ( ) ) { return ; } switch ( mKeyStore . state ( ) ) { case UNINITIALIZED : { ensureKeyGuard ( ) ; return ; } case LOCKED : { new UnlockDialog ( ) ; return ; } case UNLOCKED : { if ( ! checkKeyGuardQuality ( ) ) { new ConfigureKeyGuardDialog ( ) ; return ; } installIfAvailable ( ) ; finish ( ) ; return ; } } }
private void stopDrag ( MotionEvent ev ) { mTouchMode = TOUCH_MODE_IDLE ; final boolean commitChange = ev . getAction ( ) == MotionEvent . ACTION_UP && isEnabled ( ) ; final boolean oldState = isChecked ( ) ; final boolean newState ; if ( commitChange ) { mVelocityTracker . computeCurrentVelocity ( NUM_ ) ; final float xvel = mVelocityTracker . getXVelocity ( ) ; if ( Math . abs ( xvel ) > mMinFlingVelocity ) { newState = ViewUtils . isLayoutRtl ( this ) ? ( xvel < NUM_ ) : ( xvel > NUM_ ) ; } else { newState = getTargetCheckedState ( ) ; } } else { newState = oldState ; } if ( newState != oldState ) { playSoundEffect ( SoundEffectConstants . CLICK ) ; } setChecked ( newState ) ; cancelSuperTouch ( ev ) ; }
private void offsetStartTimeIfNecessary ( Time startTime , Time endTime , String rrule , CalendarEventModel model ) { if ( rrule == null || rrule . isEmpty ( ) ) { return ; } mEventRecurrence . parse ( rrule ) ; if ( mEventRecurrence . freq != EventRecurrence . WEEKLY ) { return ; } if ( mEventRecurrence . byday . length > mEventRecurrence . bydayCount ) { return ; } int closestWeekday = Integer . MAX_VALUE ; int weekstart = EventRecurrence . day2TimeDay ( mEventRecurrence . wkst ) ; int startDay = startTime . weekDay ; for ( int i = NUM_ ; i < mEventRecurrence . bydayCount ; i ++ ) { int day = EventRecurrence . day2TimeDay ( mEventRecurrence . byday [ i ] ) ; if ( day == startDay ) { return ; } if ( day < weekstart ) { day += NUM_ ; } if ( day > startDay && ( day < closestWeekday || closestWeekday < startDay ) ) { closestWeekday = day ; } if ( closestWeekday == Integer . MAX_VALUE || closestWeekday < startDay ) { if ( day < closestWeekday ) { closestWeekday = day ; } } } if ( closestWeekday < startDay ) { closestWeekday += NUM_ ; } int daysOffset = closestWeekday - startDay ; startTime . monthDay += daysOffset ; endTime . monthDay += daysOffset ; long newStartTime = startTime . normalize ( BOOL_ ) ; long newEndTime = endTime . normalize ( BOOL_ ) ; model . mStart = newStartTime ; model . mEnd = newEndTime ; }
public Vector3 ceil ( ) { return new Vector3 ( Math . ceil ( x ) , Math . ceil ( y ) , Math . ceil ( z ) ) ; }
public void simulateMethod ( SootMethod method , ReferenceVariable thisVar , ReferenceVariable returnVar , ReferenceVariable params [ ] ) { String subSignature = method . getSubSignature ( ) ; if ( subSignature . equals ( STR_ ) ) { java_lang_Throwable_fillInStackTrace ( method , thisVar , returnVar , params ) ; return ; } else { defaultMethod ( method , thisVar , returnVar , params ) ; return ; } }
private void cleanUpFrontier ( ) { while ( ! frontier . isEmpty ( ) && isExplored ( frontier . element ( ) ) ) frontier . remove ( ) ; }
public void addChangingListener ( OnWheelChangedListener listener ) { changingListeners . add ( listener ) ; }
private void parseAttributes ( TypedArray a ) { barWidth = ( int ) a . getDimension ( R . styleable . ProgressWheel_pwBarWidth , barWidth ) ; rimWidth = ( int ) a . getDimension ( R . styleable . ProgressWheel_pwRimWidth , rimWidth ) ; spinSpeed = ( int ) a . getDimension ( R . styleable . ProgressWheel_pwSpinSpeed , spinSpeed ) ; barLength = ( int ) a . getDimension ( R . styleable . ProgressWheel_pwBarLength , barLength ) ; delayMillis = a . getInteger ( R . styleable . ProgressWheel_pwDelayMillis , delayMillis ) ; if ( delayMillis < NUM_ ) { delayMillis = NUM_ ; } if ( a . hasValue ( R . styleable . ProgressWheel_pwText ) ) { setText ( a . getString ( R . styleable . ProgressWheel_pwText ) ) ; } barColor = a . getColor ( R . styleable . ProgressWheel_pwBarColor , barColor ) ; textColor = a . getColor ( R . styleable . ProgressWheel_pwTextColor , textColor ) ; rimColor = a . getColor ( R . styleable . ProgressWheel_pwRimColor , rimColor ) ; circleColor = a . getColor ( R . styleable . ProgressWheel_pwCircleColor , circleColor ) ; contourColor = a . getColor ( R . styleable . ProgressWheel_pwContourColor , contourColor ) ; textSize = ( int ) a . getDimension ( R . styleable . ProgressWheel_pwTextSize , textSize ) ; contourSize = a . getDimension ( R . styleable . ProgressWheel_pwContourSize , contourSize ) ; a . recycle ( ) ; }
public static byte [ ] concatenate ( byte [ ] a , byte [ ] b ) { byte [ ] output = new byte [ a . length + b . length ] ; System . arraycopy ( a , NUM_ , output , NUM_ , a . length ) ; System . arraycopy ( b , NUM_ , output , a . length , b . length ) ; return output ; }
public final AssertSubscriber < T > assertTerminated ( ) { if ( cdl . getCount ( ) != NUM_ ) { throw new AssertionError ( STR_ , null ) ; } return this ; }
protected static void assertArgument ( final boolean validArg , final String message , final Object ... args ) { if ( ! validArg ) { throw new IllegalArgumentException ( String . format ( message , args ) ) ; } }
public static boolean isBeforeToday ( Calendar _calendar ) { return _calendar . before ( Calendar . getInstance ( ) ) ; }
public static ViewItemGroup buildLoginUI ( ModelApplication modelApp , Activity activity ) { ViewItemGroup viewItems = new ViewItemGroup ( activity ) ; TextView usernameText = new TextView ( activity ) ; usernameText . setText ( R . string . username ) ; viewItems . addView ( usernameText ) ; ViewItemFactory viewItemFactory = ViewItemFactory . instance ( ) ; ViewItem usernameItem = viewItemFactory . create ( LoginViewID . USERNAME , viewItemFactory . TEXT_DATATYPE_DB_ID , activity ) ; viewItems . addViewItem ( usernameItem , new OmniText ( modelApp . getUsername ( ) ) ) ; TextView passwordText = new TextView ( activity ) ; passwordText . setText ( R . string . password ) ; viewItems . addView ( passwordText ) ; ViewItem passwordItem = viewItemFactory . create ( LoginViewID . PASSWORD , viewItemFactory . PASSWORD_INPUT_DATATYPE_DB_ID , activity ) ; viewItems . addViewItem ( passwordItem , new OmniPasswordInput ( modelApp . getPassword ( ) ) ) ; return viewItems ; }
public void unMapVolumeFromSCSIInitiator ( String volumeId , String initiatorId ) throws Exception { String uri = ScaleIOConstants . getUnmapVolumeToScsiInitiatorURI ( volumeId ) ; ScaleIOUnmapVolumeToScsiInitiator unmapParm = new ScaleIOUnmapVolumeToScsiInitiator ( ) ; unmapParm . setScsiInitiatorId ( initiatorId ) ; post ( URI . create ( uri ) , getJsonForEntity ( unmapParm ) ) ; }
public Collection < T > asCollection ( ) { return this . list ; }
private static void addQuarterArc ( Path2D . Float path , float x1 , float y1 , float x2 , float y2 , float curvature , boolean verticalStart ) { boolean down = y1 < y2 ; boolean left = x1 > x2 ; float cx1 = NUM_ ; float cy1 = NUM_ ; float cx2 = NUM_ ; float cy2 = NUM_ ; if ( verticalStart ) { cx1 = x1 ; cy2 = y2 ; if ( left ) { cx2 = x1 - curvature ; } else { cx2 = x1 + curvature ; } if ( down ) { cy1 = y2 - curvature ; } else { cy1 = y2 + curvature ; } } else { cx2 = x2 ; cy1 = y1 ; if ( left ) { cx1 = x2 + curvature ; } else { cx1 = x2 - curvature ; } if ( down ) { cy2 = y1 + curvature ; } else { cy2 = y1 - curvature ; } } path . curveTo ( cx1 , cy1 , cx2 , cy2 , x2 , y2 ) ; }
@ Override public void parse ( String content , Node block ) { this . block = block ; this . input = content . trim ( ) ; this . index = NUM_ ; this . lastDelimiter = null ; this . lastBracket = null ; boolean moreToParse ; do { moreToParse = parseInline ( ) ; } while ( moreToParse ) ; processDelimiters ( null ) ; mergeTextNodes ( block . getFirstChild ( ) , block . getLastChild ( ) ) ; }
public static void random ( byte [ ] b , int offset , int length ) { checkPositionIndex ( offset , b . length , STR_ ) ; checkArgument ( length > NUM_ , STR_ ) ; checkPositionIndex ( offset + length , b . length , STR_ ) ; byte [ ] buf = new byte [ length ] ; RNG . nextBytes ( buf ) ; System . arraycopy ( buf , NUM_ , b , offset , length ) ; }
public void removeAllScanningCallbacks ( ) { scanningCallbacks . clear ( ) ; }
public int read ( byte [ ] buf , int off , int len ) throws TTransportException { if ( inputStream_ == null ) { throw new TTransportException ( TTransportException . NOT_OPEN , STR_ ) ; } int bytesRead ; try { bytesRead = inputStream_ . read ( buf , off , len ) ; } catch ( IOException iox ) { throw new TTransportException ( TTransportException . UNKNOWN , iox ) ; } if ( bytesRead < NUM_ ) { throw new TTransportException ( TTransportException . END_OF_FILE ) ; } return bytesRead ; }
public void handleManagerCreation ( ) throws ManagementException { if ( ! isServiceInitialised ( STR_ ) ) { return ; } ObjectName managerMBeanName = MBeanJMXAdapter . getManagerName ( ) ; ManagerMBeanBridge bridge = new ManagerMBeanBridge ( service ) ; ManagerMXBean bean = new ManagerMBean ( bridge ) ; service . registerInternalMBean ( bean , managerMBeanName ) ; }
@ SuppressWarnings ( STR_ ) private boolean checkSetShape ( Shape oldShape , Shape newShape ) { Shape currentShape = getShape ( ) ; assert oldShape != newShape : STR_ ; assert newShape != currentShape : STR_ + currentShape ; assert oldShape == currentShape || oldShape . getParent ( ) == currentShape : STR_ + STR_ + currentShape + STR_ + oldShape + STR_ + newShape ; return BOOL_ ; }
protected boolean isFileVisible ( File file ) { if ( file == null || ! file . exists ( ) || ! file . canRead ( ) || file . isHidden ( ) ) { return BOOL_ ; } return BOOL_ ; }
public static String [ ] append ( final String [ ] a , final String ... b ) { final int alen = a . length ; final int blen = b . length ; final String [ ] res = Arrays . copyOf ( a , alen + blen ) ; System . arraycopy ( b , NUM_ , res , alen , blen ) ; return res ; }
public void delete ( ) throws AMException , SSOException { delete ( BOOL_ ) ; }
public String ( byte [ ] bytes , int off , int len , java . lang . String enc ) throws java . io . UnsupportedEncodingException { this ( bytesToChars ( bytes , off , len , enc ) ) ; }
private boolean initializeSearchItemset ( BitVector bv , int [ ] scratchi , int [ ] iters ) { for ( int i = NUM_ ; i < scratchi . length ; i ++ ) { iters [ i ] = ( i == NUM_ ) ? bv . iter ( ) : bv . iterAdvance ( iters [ i - NUM_ ] ) ; if ( iters [ i ] < NUM_ ) { return BOOL_ ; } scratchi [ i ] = bv . iterDim ( iters [ i ] ) ; } return BOOL_ ; }
private Rectangle computeEditorBounds ( ) { if ( row == - NUM_ || column == - NUM_ ) return new Rectangle ( NUM_ , NUM_ , NUM_ , NUM_ ) ; Rectangle cell = grid . getCellBounds ( column , row ) ; Rectangle area = grid . getClientArea ( ) ; if ( cell . x < area . x + area . width ) { if ( cell . x + cell . width > area . x + area . width ) { cell . width = area . x + area . width - cell . x ; } } Rectangle editorRect = new Rectangle ( cell . x , cell . y , minimumWidth , minimumHeight ) ; if ( grabHorizontal ) { editorRect . width = Math . max ( cell . width , minimumWidth ) ; } if ( grabVertical ) { editorRect . height = Math . max ( cell . height , minimumHeight ) ; } if ( horizontalAlignment == SWT . RIGHT ) { editorRect . x += cell . width - editorRect . width ; } else if ( horizontalAlignment == SWT . LEFT ) { } else { editorRect . x += ( cell . width - editorRect . width ) / NUM_ ; } if ( verticalAlignment == SWT . BOTTOM ) { editorRect . y += cell . height - editorRect . height ; } else if ( verticalAlignment == SWT . TOP ) { } else { editorRect . y += ( cell . height - editorRect . height ) / NUM_ ; } return editorRect ; }
public int read ( byte [ ] buffer , int offset , int length ) throws IOException { throw new UnsupportedOperationException ( String . valueOf ( this ) ) ; }
public Cuboid ( World world , int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { this . worldName = world . getName ( ) ; this . x1 = Math . min ( x1 , x2 ) ; this . x2 = Math . max ( x1 , x2 ) ; this . y1 = Math . min ( y1 , y2 ) ; this . y2 = Math . max ( y1 , y2 ) ; this . z1 = Math . min ( z1 , z2 ) ; this . z2 = Math . max ( z1 , z2 ) ; }
@ SuppressWarnings ( { STR_ } ) public double logMarginalLikelihoodSmoothed ( List < Double > v , double delta , double Pdata ) { final double logDelta = StrictMath . log ( delta ) ; final double logInvDelta = StrictMath . log ( NUM_ - delta ) ; final int n = v . size ( ) ; final double logN = StrictMath . log ( n ) ; final double offset = logInvDelta - Pdata ; double bottom = logN + logDelta - logInvDelta ; double top = bottom + Pdata ; for ( int i = NUM_ ; i < n ; i ++ ) { double weight = - LogTricks . logSum ( logDelta , offset + v . get ( i ) ) ; top = LogTricks . logSum ( top , weight + v . get ( i ) ) ; bottom = LogTricks . logSum ( bottom , weight ) ; } return top - bottom ; }
public boolean isNewMessage ( ) { if ( message == null ) { throw new IllegalStateException ( STR_ ) ; } return message . startsWith ( STR_ ) || message . equals ( STR_ ) ; }
private void installProperties ( ) { System . setProperty ( STR_ , UserAgentGenerator . getUserAgent ( ) ) ; if ( OSUtils . isMacOSX ( ) ) { System . setProperty ( STR_ , STR_ ) ; } }
public DoubleBuffer put ( double [ ] src , int srcOffset , int doubleCount ) { Arrays . checkOffsetAndCount ( src . length , srcOffset , doubleCount ) ; if ( doubleCount > remaining ( ) ) { throw new BufferOverflowException ( ) ; } for ( int i = srcOffset ; i < srcOffset + doubleCount ; ++ i ) { put ( src [ i ] ) ; } return this ; }
private void loadRecipients ( int addressType , HashSet < String > recipients , HashMap < Integer , EncodedStringValue [ ] > addressMap , boolean excludeMyNumber ) { EncodedStringValue [ ] array = addressMap . get ( addressType ) ; if ( array == null ) { return ; } if ( excludeMyNumber && array . length == NUM_ ) { return ; } String myNumber = excludeMyNumber ? mTelephonyManager . getLine1Number ( ) : null ; for ( EncodedStringValue v : array ) { if ( v != null ) { String number = v . getString ( ) ; if ( ( myNumber == null || ! PhoneNumberUtils . compare ( number , myNumber ) ) && ! recipients . contains ( number ) ) { recipients . add ( number ) ; } } } }
public static boolean isExtension ( String filename , String extension ) { if ( filename == null ) { return BOOL_ ; } if ( extension == null || extension . length ( ) == NUM_ ) { return indexOfExtension ( filename ) == - NUM_ ; } String fileExt = getExtension ( filename ) ; return fileExt . equals ( extension ) ; }
private String scriptFromDisk ( String name ) { name = name . replace ( STR_ , STR_ ) ; final char SEP = STR_ ; String pkgPart = STR_ ; String pathPart = STR_ ; String namePart = STR_ ; int at = name . indexOf ( SEP ) ; if ( at > - NUM_ ) { int nextAt = name . indexOf ( SEP , at + NUM_ ) ; if ( nextAt > - NUM_ ) { pathPart = name . substring ( NUM_ , at ) ; pkgPart = name . substring ( at + NUM_ , nextAt ) ; namePart = name . substring ( nextAt + NUM_ ) ; } else { pathPart = name . substring ( NUM_ , at ) ; namePart = name . substring ( at + NUM_ ) ; } } else { at = name . lastIndexOf ( STR_ ) ; if ( at > - NUM_ ) { int mx = name . lastIndexOf ( STR_ ) ; if ( mx > - NUM_ ) { pathPart = name . substring ( NUM_ , mx ) ; pkgPart = name . substring ( mx + NUM_ , at ) ; } else { pathPart = name . substring ( NUM_ , at ) ; } namePart = name . substring ( at + NUM_ ) ; } else { pathPart = STR_ ; namePart = name ; } } String script = null ; try { Charset realEncoding = null ; Charset bomEncoding = null ; InputStream in = locateScriptFile ( pathPart , pkgPart , namePart ) ; if ( in != null ) { try { BufferedInputStream bis = new BufferedInputStream ( in ) ; bomEncoding = getEncodingFromBOM ( bis ) ; script = pullInSource ( bis , bomEncoding ) ; realEncoding = getEncodingFromXMLDirective ( script ) ; } finally { try { in . close ( ) ; } catch ( IOException e ) { } } } if ( realEncoding != null && ! realEncoding . equals ( bomEncoding ) ) { in = locateScriptFile ( pathPart , pkgPart , namePart ) ; if ( in != null ) { try { BufferedInputStream bis = new BufferedInputStream ( in ) ; getEncodingFromBOM ( bis ) ; script = pullInSource ( bis , realEncoding ) ; } finally { try { in . close ( ) ; } catch ( IOException e ) { } } } } } catch ( FileNotFoundException fnf ) { fnf . printStackTrace ( ) ; } return script ; }
@ PrePersist public void prePersist ( ) { lockTime = System . currentTimeMillis ( ) ; }
public LibPadstack add ( String p_name , ShapeConvex [ ] p_shapes , boolean p_attach_allowed , boolean p_placed_absolute ) { int pad_no = count ( ) + NUM_ ; LibPadstack new_padstack = new LibPadstack ( p_name , pad_no , p_shapes , p_attach_allowed , p_placed_absolute ) ; padstack_list . add ( new_padstack ) ; return new_padstack ; }
private Rect calcBounds ( int index , Paint paint ) { Rect bounds = new Rect ( ) ; CharSequence title = getTitle ( index ) ; bounds . right = ( int ) paint . measureText ( title , NUM_ , title . length ( ) ) ; bounds . bottom = ( int ) ( paint . descent ( ) - paint . ascent ( ) ) ; return bounds ; }
protected ArgsBase ( ) { _argv = null ; _env = null ; }
@ Override public void startContentModel ( String elementName , Augmentations augs ) throws XNIException { if ( fValidation ) { fDTDElementDeclName = elementName ; fMixedElementTypes . clear ( ) ; } if ( fDTDGrammar != null ) fDTDGrammar . startContentModel ( elementName , augs ) ; if ( fDTDContentModelHandler != null ) { fDTDContentModelHandler . startContentModel ( elementName , augs ) ; } }
public OMRangeRings ( LatLonPoint center , double radius , Length units , int nverts ) { super ( center , radius , units , nverts ) ; centerPoint = createCenterPoint ( ) ; form . setMaximumFractionDigits ( NUM_ ) ; }
public static InputSource createInputSource ( String s ) { try { return new InputSource ( new ByteArrayInputStream ( s . getBytes ( STR_ ) ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } }
public static void write ( File file , CharSequence data , boolean append ) throws IOException { write ( file , data , Charset . defaultCharset ( ) , append ) ; }
public static Preferences userRoot ( ) { return factory . userRoot ( ) ; }
public static String toDebugString ( final long socketIdentifier ) { final int ipBits = ( int ) socketIdentifier ; final int port = extractPortNumber ( socketIdentifier ) ; final int inode = ( int ) ( socketIdentifier > > NUM_ ) ; return Integer . toHexString ( ipBits ) + STR_ + port + STR_ + inode ; }
@ Override public void onAlbumUpdate ( ProviderIdentifier provider , final Album a ) throws RemoteException { if ( a == null ) { Log . w ( TAG , STR_ ) ; return ; } Album cached = mCache . getAlbum ( a . getRef ( ) ) ; boolean modified = BOOL_ ; if ( cached == null ) { mCache . putAlbum ( provider , a ) ; cached = a ; modified = BOOL_ ; } else if ( ! cached . isLoaded ( ) || ! cached . isIdentical ( a ) ) { cached . setName ( a . getName ( ) ) ; cached . setYear ( a . getYear ( ) ) ; cached . setIsLoaded ( a . isLoaded ( ) ) ; cached . setProvider ( a . getProvider ( ) ) ; if ( cached . getSongsCount ( ) != a . getSongsCount ( ) ) { Iterator < String > songsIt = a . songs ( ) ; while ( songsIt . hasNext ( ) ) { String songRef = songsIt . next ( ) ; cached . addSong ( songRef ) ; } } modified = BOOL_ ; } if ( cached . getProvider ( ) == null ) { Log . e ( TAG , STR_ + cached . getRef ( ) + STR_ ) ; } if ( modified ) { Iterator < String > songs = a . songs ( ) ; while ( songs . hasNext ( ) ) { String songRef = songs . next ( ) ; Song song = retrieveSong ( songRef , a . getProvider ( ) ) ; if ( song != null && song . isLoaded ( ) ) { String artistRef = song . getArtist ( ) ; if ( artistRef != null ) { Artist artist = retrieveArtist ( artistRef , song . getProvider ( ) ) ; if ( artist != null ) { artist . addAlbum ( a . getRef ( ) ) ; } else { if ( DEBUG ) Log . e ( TAG , STR_ ) ; } } } else { if ( DEBUG ) Log . e ( TAG , STR_ ) ; } } postAlbumForUpdate ( cached ) ; } }
public final void push ( String s ) { if ( ( m_firstFree + NUM_ ) >= m_mapSize ) { m_mapSize += m_blocksize ; String newMap [ ] = new String [ m_mapSize ] ; System . arraycopy ( m_map , NUM_ , newMap , NUM_ , m_firstFree + NUM_ ) ; m_map = newMap ; } m_map [ m_firstFree ] = s ; m_firstFree ++ ; }
public static String readFromFile ( final File path ) throws IOException { FileInputStream fis = null ; try { fis = new FileInputStream ( path ) ; return readFromFile ( fis ) ; } finally { if ( fis != null ) { fis . close ( ) ; } } }
public static int XToTileX ( int x , int tileGridXOffset , int tileWidth ) { x -= tileGridXOffset ; if ( x < NUM_ ) { x += NUM_ - tileWidth ; } return x / tileWidth ; }
private boolean checkTouchSlop ( View child , float dx , float dy ) { if ( child == null ) { return BOOL_ ; } final boolean checkHorizontal = mCallback . getViewHorizontalDragRange ( child ) > NUM_ ; final boolean checkVertical = mCallback . getViewVerticalDragRange ( child ) > NUM_ ; if ( checkHorizontal && checkVertical ) { return dx . dx + dy . dy > mTouchSlop . mTouchSlop ; } else if ( checkHorizontal ) { return Math . abs ( dx ) > mTouchSlop ; } else if ( checkVertical ) { return Math . abs ( dy ) > mTouchSlop ; } return BOOL_ ; }
public Input ( String name , @ InputType int type , @ Alignment int align , Connection connection ) { mName = name ; mType = type ; mAlign = align ; mConnection = connection ; if ( mConnection != null ) { mConnection . setInput ( this ) ; } }
public static BshClassManager createClassManager ( Interpreter interpreter ) { BshClassManager manager ; if ( Capabilities . classExists ( STR_ ) && Capabilities . classExists ( STR_ ) && Capabilities . classExists ( STR_ ) ) try { Class clas = Class . forName ( STR_ ) ; manager = ( BshClassManager ) clas . newInstance ( ) ; } catch ( Exception e ) { throw new InterpreterError ( STR_ + e ) ; } else manager = new BshClassManager ( ) ; if ( interpreter == null ) interpreter = new Interpreter ( ) ; manager . declaringInterpreter = interpreter ; return manager ; }
public int swap ( ) { if ( ! mEgl . eglSwapBuffers ( mEglDisplay , mEglSurface ) ) { return mEgl . eglGetError ( ) ; } return EGL10 . EGL_SUCCESS ; }
public void requestLastLoginTime ( ) { operations . add ( PasswordPolicyStateOperationType . GET_LAST_LOGIN_TIME ) ; }
public static Stream < String > wordsOf ( String text ) { requireNonNull ( text ) ; return WORDS . splitAsStream ( text ) ; }
public void add ( AppInfo info ) { if ( mAppFilter != null && ! mAppFilter . shouldShowApp ( info . componentName ) ) { return ; } if ( findActivity ( data , info . componentName , info . user ) ) { return ; } data . add ( info ) ; added . add ( info ) ; }
public Joiner match ( String field , Object ... value ) { return match ( field , Arrays . asList ( value ) ) ; }
private String removeYouTubeMarkup ( String plot ) { if ( plot == null ) return null ; return plot . replaceAll ( STR_ , STR_ ) ; }
private String createDashArrayString ( List < Float > dashesArray ) { StringBuilder sb = new StringBuilder ( ) ; if ( dashesArray != null ) { int index = NUM_ ; for ( Float value : dashesArray ) { String str = Float . toString ( value ) ; if ( str . endsWith ( STR_ ) ) { sb . append ( value . intValue ( ) ) ; } else { sb . append ( value ) ; } if ( index < dashesArray . size ( ) - NUM_ ) { sb . append ( STR_ ) ; } index ++ ; } } return sb . toString ( ) ; }
private final boolean compareAndSetHead ( Node update ) { return unsafe . compareAndSwapObject ( this , headOffset , null , update ) ; }
public long position ( java . sql . Blob pattern , long start ) throws SQLException { return position ( pattern . getBytes ( NUM_ , ( int ) pattern . length ( ) ) , start ) ; }
protected synchronized T load ( ) throws IOException { long genLoaded = - NUM_ ; IOException ioe = null ; List < String > genFiles = new ArrayList < String > ( ) ; String [ ] files ; try { files = dir . listAll ( ) ; } catch ( IOException ioe2 ) { return null ; } T loaded = null ; for ( String file : files ) { if ( file . startsWith ( prefix ) ) { long gen = Long . parseLong ( file . substring ( prefix . length ( ) ) ) ; if ( genLoaded == - NUM_ || gen > genLoaded ) { genFiles . add ( file ) ; IndexInput in = dir . openInput ( file , IOContext . DEFAULT ) ; try { loaded = loadOne ( in ) ; } catch ( IOException ioe2 ) { if ( ioe == null ) { ioe = ioe2 ; } } finally { in . close ( ) ; } genLoaded = gen ; } } } if ( genLoaded == - NUM_ ) { if ( ioe != null ) { throw ioe ; } } else { if ( genFiles . size ( ) > NUM_ ) { String curFileName = prefix + genLoaded ; for ( String file : genFiles ) { long gen = Long . parseLong ( file . substring ( prefix . length ( ) ) ) ; if ( canDelete ( gen ) && ! curFileName . equals ( file ) ) { dir . deleteFile ( file ) ; } } } nextWriteGen = NUM_ + genLoaded ; } return loaded ; }
public static String readLine ( InputStream in , String charset ) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; while ( BOOL_ ) { int b = in . read ( ) ; if ( b == - NUM_ ) { if ( baos . size ( ) == NUM_ ) { return null ; } else { break ; } } if ( b == STR_ ) { break ; } if ( b != STR_ ) { baos . write ( b ) ; continue ; } int b2 = in . read ( ) ; if ( b2 == - NUM_ ) { baos . write ( b ) ; break ; } if ( b2 == STR_ ) { break ; } baos . write ( b ) ; baos . write ( b2 ) ; } return baos . toString ( charset ) ; }
protected static final String addEscapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = NUM_ ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case NUM_ : continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < x20 || ch > x7e ) { String s = STR_ + Integer . toString ( ch , NUM_ ) ; retval . append ( STR_ + s . substring ( s . length ( ) - NUM_ , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; }
public boolean checkTableExists ( TableDefinition table ) { String column = null ; for ( FieldDefinition field : table . getFields ( ) ) { if ( column == null ) { column = field . getName ( ) ; } else if ( field . isPrimaryKey ( ) ) { column = field . getName ( ) ; break ; } } String sql = STR_ + column + STR_ + table . getFullName ( ) + STR_ + column + STR_ + column ; DataReadQuery query = new DataReadQuery ( sql ) ; query . setMaxRows ( NUM_ ) ; try { session . executeQuery ( query ) ; return BOOL_ ; } catch ( Exception notFound ) { return BOOL_ ; } finally { } }
private int processColon ( int length ) { if ( _hasScheme ) { if ( ! readUserPass ( length ) && _buffer . length ( ) > NUM_ ) { _reader . goBack ( ) ; _buffer . delete ( _buffer . length ( ) - NUM_ , _buffer . length ( ) ) ; int backtrackOnFail = _reader . getPosition ( ) - _buffer . length ( ) + length ; if ( ! readDomainName ( _buffer . substring ( length ) ) ) { _reader . seek ( backtrackOnFail ) ; readEnd ( ReadEndState . InvalidUrl ) ; } length = NUM_ ; } } else if ( readScheme ( ) && _buffer . length ( ) > NUM_ ) { _hasScheme = BOOL_ ; length = _buffer . length ( ) ; } else if ( _buffer . length ( ) > NUM_ && _options . hasFlag ( UrlDetectorOptions . ALLOW_SINGLE_LEVEL_DOMAIN ) && _reader . canReadChars ( NUM_ ) ) { _reader . goBack ( ) ; _buffer . delete ( _buffer . length ( ) - NUM_ , _buffer . length ( ) ) ; readDomainName ( _buffer . toString ( ) ) ; } else { readEnd ( ReadEndState . InvalidUrl ) ; length = NUM_ ; } return length ; }
public static boolean containsSqlScriptDelimiters ( String script , String delim ) { boolean inLiteral = BOOL_ ; char [ ] content = script . toCharArray ( ) ; for ( int i = NUM_ ; i < script . length ( ) ; i ++ ) { if ( content [ i ] == STR_ ) { inLiteral = ! inLiteral ; } if ( ! inLiteral && script . startsWith ( delim , i ) ) { return BOOL_ ; } } return BOOL_ ; }
public void compress ( byte [ ] bytes , int off , int len , OutputStream os ) { try { os . write ( bytes , off , len ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public void assertNotJoined ( final UUID serviceId ) { m_triggers . add ( new QuorumEventInvariant ( QuorumEventEnum . SERVICE_JOIN , serviceId ) ) ; if ( isMember ( m_quorum . getJoined ( ) , serviceId ) ) broken ( ) ; }
private void fitImageToView ( ) { Drawable drawable = getDrawable ( ) ; if ( drawable == null || drawable . getIntrinsicWidth ( ) == NUM_ || drawable . getIntrinsicHeight ( ) == NUM_ ) { return ; } if ( matrix == null || prevMatrix == null ) { return ; } int drawableWidth = drawable . getIntrinsicWidth ( ) ; int drawableHeight = drawable . getIntrinsicHeight ( ) ; float scaleX = ( float ) viewWidth / drawableWidth ; float scaleY = ( float ) viewHeight / drawableHeight ; switch ( mScaleType ) { case CENTER : scaleX = scaleY = NUM_ ; break ; case CENTER_CROP : scaleX = scaleY = Math . max ( scaleX , scaleY ) ; break ; case CENTER_INSIDE : scaleX = scaleY = Math . min ( NUM_ , Math . min ( scaleX , scaleY ) ) ; case FIT_CENTER : scaleX = scaleY = Math . min ( scaleX , scaleY ) ; break ; case FIT_XY : break ; default : throw new UnsupportedOperationException ( STR_ ) ; } float redundantXSpace = viewWidth - ( scaleX . drawableWidth ) ; float redundantYSpace = viewHeight - ( scaleY . drawableHeight ) ; matchViewWidth = viewWidth - redundantXSpace ; matchViewHeight = viewHeight - redundantYSpace ; if ( ! isZoomed ( ) && ! imageRenderedAtLeastOnce ) { matrix . setScale ( scaleX , scaleY ) ; matrix . postTranslate ( redundantXSpace / NUM_ , redundantYSpace / NUM_ ) ; normalizedScale = NUM_ ; } else { if ( prevMatchViewWidth == NUM_ || prevMatchViewHeight == NUM_ ) { savePreviousImageValues ( ) ; } prevMatrix . getValues ( m ) ; m [ Matrix . MSCALE_X ] = matchViewWidth / drawableWidth . normalizedScale ; m [ Matrix . MSCALE_Y ] = matchViewHeight / drawableHeight . normalizedScale ; float transX = m [ Matrix . MTRANS_X ] ; float transY = m [ Matrix . MTRANS_Y ] ; float prevActualWidth = prevMatchViewWidth . normalizedScale ; float actualWidth = getImageWidth ( ) ; translateMatrixAfterRotate ( Matrix . MTRANS_X , transX , prevActualWidth , actualWidth , prevViewWidth , viewWidth , drawableWidth ) ; float prevActualHeight = prevMatchViewHeight . normalizedScale ; float actualHeight = getImageHeight ( ) ; translateMatrixAfterRotate ( Matrix . MTRANS_Y , transY , prevActualHeight , actualHeight , prevViewHeight , viewHeight , drawableHeight ) ; matrix . setValues ( m ) ; } fixTrans ( ) ; setImageMatrix ( matrix ) ; }
public int encryptBlock ( byte [ ] in , int inOff , byte [ ] out , int outOff ) throws DataLengthException , IllegalStateException { if ( ( inOff + blockSize ) > in . length ) { throw new DataLengthException ( STR_ ) ; } if ( ( outOff + blockSize ) > out . length ) { throw new DataLengthException ( STR_ ) ; } cipher . processBlock ( cfbV , NUM_ , cfbOutV , NUM_ ) ; for ( int i = NUM_ ; i < blockSize ; i ++ ) { out [ outOff + i ] = ( byte ) ( cfbOutV [ i ] ^ in [ inOff + i ] ) ; } System . arraycopy ( cfbV , blockSize , cfbV , NUM_ , cfbV . length - blockSize ) ; System . arraycopy ( out , outOff , cfbV , cfbV . length - blockSize , blockSize ) ; return blockSize ; }
public final void print ( String value ) { try { Element rootElement = workDoc . getDefaultRootElement ( ) ; int deleteLines = rootElement . getElementCount ( ) - linesMax ; for ( int index = NUM_ ; index < deleteLines ; index ++ ) { Element elem = rootElement . getElement ( NUM_ ) ; workDoc . remove ( elem . getStartOffset ( ) , elem . getEndOffset ( ) ) ; } workDoc . insertString ( workDoc . getLength ( ) , value , null ) ; textArea . setCaretPosition ( workDoc . getLength ( ) ) ; } catch ( Exception exc ) { exc . printStackTrace ( ) ; } }
private void addConnectionGroups ( Collection < ConnectionGroup > connectionGroups ) { for ( ConnectionGroup connectionGroup : connectionGroups ) { APIConnectionGroup parent = retrievedGroups . get ( connectionGroup . getParentIdentifier ( ) ) ; if ( parent != null ) { Collection < APIConnectionGroup > children = parent . getChildConnectionGroups ( ) ; if ( children == null ) { children = new ArrayList < APIConnectionGroup > ( ) ; parent . setChildConnectionGroups ( children ) ; } APIConnectionGroup apiConnectionGroup = new APIConnectionGroup ( connectionGroup ) ; retrievedGroups . put ( connectionGroup . getIdentifier ( ) , apiConnectionGroup ) ; children . add ( apiConnectionGroup ) ; } else logger . debug ( STR_ , connectionGroup . getIdentifier ( ) , connectionGroup . getParentIdentifier ( ) ) ; } }
public void loadMap ( InputStream input , String groupID ) throws Exception { shapes = parser . parse ( input , groupID ) ; boundaries = new ArrayList < Rect2D > ( shapes . size ( ) ) ; for ( IGeometric2D shape : shapes ) { boundaries . add ( shape . getBounds ( ) ) ; } }
public void addDecoration ( LineDecoration decoration ) { if ( decoration != null ) { decorations . add ( decoration ) ; } }
private String parseLinkTitle ( ) { String title = match ( LINK_TITLE ) ; if ( title != null ) { return Escaping . unescapeString ( title . substring ( NUM_ , title . length ( ) - NUM_ ) ) ; } else { return null ; } }
public void recordSRDFOperation ( DbClient dbClient , OperationTypeEnum opType , Operation . Status status , Object ... extParam ) { try { boolean opStatus = ( Operation . Status . ready == status ) ? BOOL_ : BOOL_ ; String evType ; evType = opType . getEvType ( opStatus ) ; String evDesc = opType . getDescription ( ) ; String opStage = AuditLogManager . AUDITOP_END ; _logger . info ( STR_ , opType . toString ( ) , evType . toString ( ) + STR_ + evDesc ) ; recordBourneSRDFEvent ( dbClient , getId ( ) , evType , status , evDesc ) ; String id = ( String ) extParam [ NUM_ ] ; switch ( opType ) { case CREATE_SRDF_LINK : AuditBlockUtil . auditBlock ( dbClient , opType , opStatus , opStage , extParam ) ; break ; case SUSPEND_SRDF_LINK : AuditBlockUtil . auditBlock ( dbClient , opType , opStatus , opStage , extParam ) ; break ; case DETACH_SRDF_LINK : AuditBlockUtil . auditBlock ( dbClient , opType , opStatus , opStage , extParam ) ; break ; case PAUSE_SRDF_LINK : AuditBlockUtil . auditBlock ( dbClient , opType , opStatus , opStage , extParam ) ; break ; case RESUME_SRDF_LINK : AuditBlockUtil . auditBlock ( dbClient , opType , opStatus , opStage , extParam ) ; break ; case FAILOVER_SRDF_LINK : AuditBlockUtil . auditBlock ( dbClient , opType , opStatus , opStage , extParam ) ; break ; case SWAP_SRDF_VOLUME : AuditBlockUtil . auditBlock ( dbClient , opType , opStatus , opStage , extParam ) ; break ; case STOP_SRDF_LINK : AuditBlockUtil . auditBlock ( dbClient , opType , opStatus , opStage , extParam ) ; break ; case SYNC_SRDF_LINK : AuditBlockUtil . auditBlock ( dbClient , opType , opStatus , opStage , extParam ) ; break ; default : _logger . error ( STR_ ) ; } } catch ( Exception e ) { _logger . error ( STR_ , opType . toString ( ) , e ) ; } }
public void close ( ) { this . closed = BOOL_ ; }
public int size ( ) { return m_RecentItems . size ( ) ; }
public JCDiagnostic warning ( LintCategory lc , String key , Object ... args ) { return create ( WARNING , lc , EnumSet . noneOf ( DiagnosticFlag . class ) , null , null , key , args ) ; }
public Destructurer ( final Tree . Pattern that , final GenerateJsVisitor gen , final Set < Declaration > directAccess , final String expvar , boolean first , final boolean forAssert ) { this . gen = gen ; jsw = gen == null ? null : gen . out ; names = gen == null ? null : gen . getNames ( ) ; this . directAccess = directAccess ; this . expvar = expvar ; this . first = first ; this . forAssert = forAssert ; that . visit ( this ) ; if ( jsw != null && ! attribs . isEmpty ( ) ) { for ( Value attr : attribs ) { jsw . write ( STR_ , names . self ( ( TypeDeclaration ) attr . getContainer ( ) ) , STR_ , names . name ( attr ) , STR_ , names . name ( attr ) ) ; } } }
@ SuppressWarnings ( STR_ ) public void handleTblSubConfigButtonDeleteRequest ( RequestInvocationEvent event ) throws ModelControlException { submitCycle = BOOL_ ; CCActionTable tbl = ( CCActionTable ) getChild ( TBL_SUB_CONFIG ) ; tbl . restoreStateData ( ) ; CCActionTableModel tblModel = ( CCActionTableModel ) tbl . getModel ( ) ; Integer [ ] selected = tblModel . getSelectedRows ( ) ; SerializedField szCache = ( SerializedField ) getChild ( SZ_CACHE ) ; List list = szCache . getSerializedObj ( ) ; Set < String > names = new HashSet < > ( selected . length . NUM_ ) ; for ( Integer index : selected ) { SMSubConfig sc = ( SMSubConfig ) list . get ( index ) ; names . add ( sc . getName ( ) ) ; } try { AbstractAuditModel model = ( AbstractAuditModel ) getModel ( ) ; model . deleteEventHandles ( names ) ; if ( selected . length == NUM_ ) { setInlineAlertMessage ( TYPE_INFO , INFORMATION_MESSAGE , STR_ ) ; } else { setInlineAlertMessage ( TYPE_INFO , INFORMATION_MESSAGE , STR_ ) ; } } catch ( AMConsoleException e ) { setInlineAlertMessage ( TYPE_ERROR , ERROR_MESSAGE , e . getMessage ( ) ) ; } submitCycle = BOOL_ ; forwardTo ( ) ; }
public synchronized void removeGraphListener ( GraphListener cl ) { m_graphListeners . remove ( cl ) ; }
public boolean isHealthy ( boolean doExtensiveChecks ) { if ( socket . isClosed ( ) || socket . isInputShutdown ( ) || socket . isOutputShutdown ( ) ) { return BOOL_ ; } if ( framedConnection != null ) { return BOOL_ ; } if ( doExtensiveChecks ) { try { int readTimeout = socket . getSoTimeout ( ) ; try { socket . setSoTimeout ( NUM_ ) ; if ( source . exhausted ( ) ) { return BOOL_ ; } return BOOL_ ; } finally { socket . setSoTimeout ( readTimeout ) ; } } catch ( SocketTimeoutException ignored ) { } catch ( IOException e ) { return BOOL_ ; } } return BOOL_ ; }
public void addColumn ( int index , Column column ) { validateColumn ( column ) ; columnList . add ( index , column ) ; }
private float clampMag ( float value , float absMin , float absMax ) { final float absValue = Math . abs ( value ) ; if ( absValue < absMin ) return NUM_ ; if ( absValue > absMax ) return value > NUM_ ? absMax : - absMax ; return value ; }
private void init ( ) { setTitle ( STR_ ) ; hopPropertiesPanel = new HopfieldPropertiesPanel ( networkPanel ) ; hopPropertiesPanel . fillFieldValues ( ) ; tabLogic . setLayout ( new FlowLayout ( ) ) ; tabLogic . add ( hopPropertiesPanel ) ; tabLayout . add ( layoutPanel ) ; layoutPanel = new MainLayoutPanel ( BOOL_ , this ) ; tabbedPane . addTab ( STR_ , tabLogic ) ; tabbedPane . addTab ( STR_ , layoutPanel ) ; setContentPane ( tabbedPane ) ; Action helpAction = new ShowHelpAction ( hopPropertiesPanel . getHelpPath ( ) ) ; addButton ( new JButton ( helpAction ) ) ; }
public BatchedImageRequest ( Request < ? > request , ImageContainer container ) { mRequest = request ; mContainers . add ( container ) ; }
private double normVector ( double [ ] z ) { double sum = NUM_ ; for ( int i = NUM_ ; i < problem . getNumberOfObjectives ( ) ; i ++ ) { sum += z [ i ] . z [ i ] ; } return Math . sqrt ( sum ) ; }
public String forceGetValueAsString ( ) { if ( mValue == null ) { return STR_ ; } else if ( mValue instanceof byte [ ] ) { if ( mDataType == TYPE_ASCII ) { return new String ( ( byte [ ] ) mValue , US_ASCII ) ; } else { return Arrays . toString ( ( byte [ ] ) mValue ) ; } } else if ( mValue instanceof long [ ] ) { if ( ( ( long [ ] ) mValue ) . length == NUM_ ) { return String . valueOf ( ( ( long [ ] ) mValue ) [ NUM_ ] ) ; } else { return Arrays . toString ( ( long [ ] ) mValue ) ; } } else if ( mValue instanceof Object [ ] ) { if ( ( ( Object [ ] ) mValue ) . length == NUM_ ) { Object val = ( ( Object [ ] ) mValue ) [ NUM_ ] ; if ( val == null ) { return STR_ ; } else { return val . toString ( ) ; } } else { return Arrays . toString ( ( Object [ ] ) mValue ) ; } } else { return mValue . toString ( ) ; } }
public int hashCode ( ) { return NUM_ . factor . hashCode ( ) + lag ; }
public void deserializeArchivedVersions ( ) throws RuntimeException { System . out . println ( STR_ + getArchiveDirectory ( ) + STR_ ) ; File archive = new File ( getArchiveDirectory ( ) ) ; if ( ! archive . exists ( ) || ! archive . isDirectory ( ) ) { return ; } String [ ] listing = archive . list ( ) ; for ( String archiveName : listing ) { if ( ! ( archiveName . endsWith ( STR_ ) ) ) { continue ; } try { File file = new File ( getArchiveDirectory ( ) , archiveName ) ; ZipFile zipFile = new ZipFile ( file ) ; ZipEntry entry = zipFile . getEntry ( STR_ ) ; InputStream inputStream = zipFile . getInputStream ( entry ) ; ObjectInputStream objectIn = new ObjectInputStream ( inputStream ) ; Map < String , List < String > > classFields = ( Map < String , List < String > > ) objectIn . readObject ( ) ; zipFile . close ( ) ; for ( String className : classFields . keySet ( ) ) { List < String > fieldNames = classFields . get ( className ) ; Class < ? > clazz = Class . forName ( className ) ; ObjectStreamClass streamClass = ObjectStreamClass . lookup ( clazz ) ; if ( streamClass == null ) { System . out . println ( ) ; } for ( String fieldName : fieldNames ) { assert streamClass != null ; ObjectStreamField field = streamClass . getField ( fieldName ) ; if ( field == null ) { throw new RuntimeException ( STR_ + fieldName + STR_ + className + STR_ + STR_ + STR_ + className + STR_ + archiveName + STR_ ) ; } } } } catch ( ClassNotFoundException e ) { throw new RuntimeException ( STR_ + archiveName + STR_ , e ) ; } catch ( IOException e ) { throw new RuntimeException ( STR_ + archiveName + STR_ , e ) ; } System . out . println ( STR_ + archiveName + STR_ ) ; ZipEntry zipEntry = null ; try { File file = new File ( getArchiveDirectory ( ) , archiveName ) ; FileInputStream in = new FileInputStream ( file ) ; ZipInputStream zipinputstream = new ZipInputStream ( in ) ; while ( ( zipEntry = zipinputstream . getNextEntry ( ) ) != null ) { if ( ! zipEntry . getName ( ) . endsWith ( STR_ ) ) { continue ; } ObjectInputStream objectIn = new ObjectInputStream ( zipinputstream ) ; objectIn . readObject ( ) ; zipinputstream . closeEntry ( ) ; } zipinputstream . close ( ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( STR_ + zipEntry . getName ( ) + STR_ + archiveName + STR_ + STR_ + STR_ , e ) ; } catch ( IOException e ) { throw new RuntimeException ( STR_ + archiveName + STR_ , e ) ; } } System . out . println ( STR_ ) ; }
private void convertMaximalToMinimalEdgeRings ( List ringEdges ) { for ( Iterator i = ringEdges . iterator ( ) ; i . hasNext ( ) ; ) { PolygonizeDirectedEdge de = ( PolygonizeDirectedEdge ) i . next ( ) ; long label = de . getLabel ( ) ; List intNodes = findIntersectionNodes ( de , label ) ; if ( intNodes == null ) continue ; for ( Iterator iNode = intNodes . iterator ( ) ; iNode . hasNext ( ) ; ) { Node node = ( Node ) iNode . next ( ) ; computeNextCCWEdges ( node , label ) ; } } }
public byte [ ] generateMAC ( byte commandClass , byte [ ] ciphertext , byte sendingNode , byte receivingNode , byte [ ] iv ) throws GeneralSecurityException { traceHex ( STR_ , ciphertext ) ; traceHex ( STR_ , iv ) ; int bufferSize = ciphertext . length + NUM_ ; byte [ ] buffer = new byte [ bufferSize ] ; byte [ ] tempAuth = new byte [ NUM_ ] ; buffer [ NUM_ ] = commandClass ; buffer [ NUM_ ] = sendingNode ; buffer [ NUM_ ] = receivingNode ; buffer [ NUM_ ] = ( byte ) ciphertext . length ; System . arraycopy ( ciphertext , NUM_ , buffer , NUM_ , ciphertext . length ) ; traceHex ( STR_ , networkKey . getEncoded ( ) ) ; traceHex ( STR_ , buffer ) ; Cipher encryptCipher = Cipher . getInstance ( STR_ ) ; encryptCipher . init ( Cipher . ENCRYPT_MODE , authKey ) ; tempAuth = encryptCipher . doFinal ( iv ) ; traceHex ( STR_ , tempAuth ) ; byte [ ] encpck = new byte [ NUM_ ] ; int block = NUM_ ; for ( int i = NUM_ ; i < bufferSize ; i ++ ) { encpck [ block ] = buffer [ i ] ; block ++ ; if ( block == NUM_ ) { for ( int j = NUM_ ; j < NUM_ ; j ++ ) { tempAuth [ j ] = ( byte ) ( encpck [ j ] ^ tempAuth [ j ] ) ; encpck [ j ] = NUM_ ; } Arrays . fill ( encpck , ( byte ) NUM_ ) ; block = NUM_ ; encryptCipher . init ( Cipher . ENCRYPT_MODE , authKey ) ; tempAuth = encryptCipher . doFinal ( tempAuth ) ; } } if ( block > NUM_ ) { for ( int i = NUM_ ; i < NUM_ ; i ++ ) { tempAuth [ i ] = ( byte ) ( encpck [ i ] ^ tempAuth [ i ] ) ; } encryptCipher . init ( Cipher . ENCRYPT_MODE , authKey ) ; tempAuth = encryptCipher . doFinal ( tempAuth ) ; } traceHex ( STR_ , tempAuth ) ; byte [ ] mac = new byte [ NUM_ ] ; System . arraycopy ( tempAuth , NUM_ , mac , NUM_ , NUM_ ) ; return mac ; }
public void removeEventListener ( ImageSharingListener listener ) throws RcsServiceNotAvailableException , RcsGenericException { if ( mApi == null ) { throw new RcsServiceNotAvailableException ( ) ; } try { WeakReference < IImageSharingListener > weakRef = mImageSharingListeners . remove ( listener ) ; if ( weakRef == null ) { return ; } IImageSharingListener rcsListener = weakRef . get ( ) ; if ( rcsListener != null ) { mApi . removeEventListener2 ( rcsListener ) ; } } catch ( Exception e ) { RcsIllegalArgumentException . assertException ( e ) ; throw new RcsGenericException ( e ) ; } }
private void updateWaveFileSize ( ) throws IOException { ByteBuffer buffer = getUnsignedIntegerBuffer ( mFileChannel . size ( ) - NUM_ ) ; mFileChannel . write ( buffer , NUM_ ) ; ByteBuffer buffer2 = getUnsignedIntegerBuffer ( mFileChannel . size ( ) - NUM_ ) ; mFileChannel . write ( buffer2 , NUM_ ) ; }
private void writeJournal ( ParcelFileDescriptor newState , Journal journal ) { try { FileOutputStream outStream = new FileOutputStream ( newState . getFileDescriptor ( ) ) ; final byte [ ] journalBytes = writeCheckedBytes ( journal ) ; outStream . write ( journalBytes ) ; if ( VERBOSE ) Log . v ( TAG , STR_ + journalBytes . length + STR_ ) ; } catch ( IOException e ) { Log . w ( TAG , STR_ , e ) ; } }
public boolean matches ( String sa ) { if ( _length != sa . length ( ) ) return BOOL_ ; char [ ] buffer = _buffer ; int offset = _offset ; for ( int i = _length - NUM_ ; i >= NUM_ ; i -- ) if ( _buffer [ _offset + i ] != sa . charAt ( i ) ) return BOOL_ ; return BOOL_ ; }
@ Override public void mouseReleased ( MouseEvent event ) { if ( event . getSource ( ) == getComponentDecreaseSpinnerButton ( ) ) { decreaseTimer . stop ( ) ; } else { increaseTimer . stop ( ) ; } }
public double computeMaxClassValueUsingPercentFactorPerSeries ( DefaultChartData chartData , String [ ] series , double [ ] percentFactorPerSeries ) { double maxValue = NUM_ ; for ( String className : chartData . getClassNamesIncludingDisabled ( ) ) { double total = NUM_ ; for ( int i = NUM_ ; i < series . length ; i ++ ) { String seriesName = series [ i ] ; if ( transposedHeightsAdditive ) total += percentFactorPerSeries [ i ] . chartData . getValueAsDouble ( seriesName , className ) ; else total = Math . max ( total , percentFactorPerSeries [ i ] . chartData . getValueAsDouble ( seriesName , className ) ) ; } if ( total > maxValue ) { maxValue = total ; } } return NUM_ . maxValue ; }
public int addChannel ( Channel channel ) { int index = - NUM_ ; switch ( channel . getChannelType ( ) ) { case STANDARD : mChannels . add ( channel ) ; index = mChannels . size ( ) - NUM_ ; fireTableRowsInserted ( index , index ) ; break ; case TRAFFIC : mTrafficChannels . add ( channel ) ; index = mChannels . size ( ) - NUM_ ; break ; default : break ; } broadcast ( new ChannelEvent ( channel , Event . NOTIFICATION_ADD ) ) ; if ( channel . getEnabled ( ) ) { broadcast ( new ChannelEvent ( channel , Event . REQUEST_ENABLE ) ) ; } return index ; }
public static String join ( Object ... array ) { if ( array == null ) { return null ; } if ( array . length == NUM_ ) { return StringPool . EMPTY ; } if ( array . length == NUM_ ) { return String . valueOf ( array [ NUM_ ] ) ; } final StringBuilder sb = new StringBuilder ( array . length . NUM_ ) ; for ( int i = NUM_ ; i < array . length ; i ++ ) { sb . append ( array [ i ] ) ; } return sb . toString ( ) ; }
public boolean hasTrait ( final StoreTrait storeTrait ) { final Set < StoreTrait > traits = getTraits ( ) ; return null != traits && traits . contains ( storeTrait ) ; }
public void createSupply ( MWMInOutBoundLine boundline , BigDecimal qtySupply ) { MProduct product = MProduct . get ( boundline . getCtx ( ) , boundline . getM_Product_ID ( ) ) ; if ( product . isBOM ( ) ) { createMO ( boundline , product , qtySupply ) ; } else if ( product . isPurchased ( ) ) { createRequisition ( boundline , product , qtySupply ) ; } }
public int size ( ) { return parameters . size ( ) ; }
public List < LocalTime > top ( int n ) { List < LocalTime > top = new ArrayList < > ( ) ; int [ ] values = data . toIntArray ( ) ; IntArrays . parallelQuickSort ( values , ReverseIntComparator . instance ( ) ) ; for ( int i = NUM_ ; i < n && i < values . length ; i ++ ) { top . add ( PackedLocalTime . asLocalTime ( values [ i ] ) ) ; } return top ; }
@ Override public void loadXML ( Node stepnode , List < DatabaseMeta > databases , Map < String , Counter > counters ) throws KettleXMLException { try { schemaName = XMLHandler . getTagValue ( stepnode , STR_ ) ; tabelName = XMLHandler . getTagValue ( stepnode , STR_ ) ; mdkeySize = XMLHandler . getTagValue ( stepnode , STR_ ) ; measureCount = XMLHandler . getTagValue ( stepnode , STR_ ) ; heirAndKeySize = XMLHandler . getTagValue ( stepnode , STR_ ) ; cubeName = XMLHandler . getTagValue ( stepnode , STR_ ) ; groupByEnabled = XMLHandler . getTagValue ( stepnode , STR_ ) ; aggregatorClassString = XMLHandler . getTagValue ( stepnode , STR_ ) ; aggregatorString = XMLHandler . getTagValue ( stepnode , STR_ ) ; factDimLensString = XMLHandler . getTagValue ( stepnode , STR_ ) ; levelAnddataTypeString = XMLHandler . getTagValue ( stepnode , STR_ ) ; currentRestructNumber = Integer . parseInt ( XMLHandler . getTagValue ( stepnode , STR_ ) ) ; partitionID = XMLHandler . getTagValue ( stepnode , STR_ ) ; segmentId = XMLHandler . getTagValue ( stepnode , STR_ ) ; taskNo = XMLHandler . getTagValue ( stepnode , STR_ ) ; } catch ( Exception e ) { throw new KettleXMLException ( STR_ , e ) ; } }
public void put ( int key , E value ) { int i = binarySearch ( mKeys , NUM_ , mSize , key ) ; if ( i >= NUM_ ) { mValues [ i ] = value ; } else { i = ~ i ; if ( i < mSize && mValues [ i ] == DELETED ) { mKeys [ i ] = key ; mValues [ i ] = value ; return ; } if ( mGarbage && mSize >= mKeys . length ) { gc ( ) ; i = ~ binarySearch ( mKeys , NUM_ , mSize , key ) ; } if ( mSize >= mKeys . length ) { int n = Math . max ( mSize + NUM_ , mKeys . length . NUM_ ) ; int [ ] nkeys = new int [ n ] ; Object [ ] nvalues = new Object [ n ] ; System . arraycopy ( mKeys , NUM_ , nkeys , NUM_ , mKeys . length ) ; System . arraycopy ( mValues , NUM_ , nvalues , NUM_ , mValues . length ) ; mKeys = nkeys ; mValues = nvalues ; } if ( mSize - i != NUM_ ) { System . arraycopy ( mKeys , i , mKeys , i + NUM_ , mSize - i ) ; System . arraycopy ( mValues , i , mValues , i + NUM_ , mSize - i ) ; } mKeys [ i ] = key ; mValues [ i ] = value ; mSize ++ ; } }
public void readData ( DataInput din ) throws IOException { reference = din . readUnsignedShort ( ) ; }
public float dotProduct ( DenseVector df ) { float res = NUM_ ; for ( int i = NUM_ ; i < Math . min ( size , df . getLength ( ) ) ; i ++ ) { res += u [ i ] . df . u [ i ] ; } return res ; }
private void emitCode ( ) { LinkedList < Instantiation > worklist = new LinkedList < Instantiation > ( ) ; worklist . add ( new Instantiation ( null , mainSubroutine ) ) ; InsnList newInstructions = new InsnList ( ) ; List < TryCatchBlockNode > newTryCatchBlocks = new ArrayList < TryCatchBlockNode > ( ) ; List < LocalVariableNode > newLocalVariables = new ArrayList < LocalVariableNode > ( ) ; while ( ! worklist . isEmpty ( ) ) { Instantiation inst = worklist . removeFirst ( ) ; emitSubroutine ( inst , worklist , newInstructions , newTryCatchBlocks , newLocalVariables ) ; } instructions = newInstructions ; tryCatchBlocks = newTryCatchBlocks ; localVariables = newLocalVariables ; }
public static double stDev ( final List < Double > list ) { return Math . sqrt ( variance ( list ) ) ; }
public void trimToSize ( ) { if ( size < array . length ) { int [ ] olddata = array ; array = new int [ size ] ; System . arraycopy ( olddata , NUM_ , array , NUM_ , size ) ; } }
public void testSetBitZeroOutside1 ( ) { byte aBytes [ ] = { NUM_ } ; int aSign = NUM_ ; int number = NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger result = aNumber . setBit ( number ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public static int compare ( Date left , boolean right ) { return compare ( left , right ? NUM_ : NUM_ ) ; }
private IBindingSet [ ] decodeNextChunk ( ) throws IOException { if ( nsolutions == solutionSetCount ) { if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + name + STR_ + nsolutions ) ; return null ; } in . readInt ( ) ; final int chunkSize = in . readInt ( ) ; final int byteLength = in . readInt ( ) ; final byte [ ] a = new byte [ byteLength ] ; in . readFully ( a ) ; final DataInputBuffer buf = new DataInputBuffer ( a ) ; final IBindingSet [ ] t = new IBindingSet [ chunkSize ] ; for ( int i = NUM_ ; i < chunkSize ; i ++ ) { t [ i ] = decoder . decodeSolution ( buf , BOOL_ ) ; if ( log . isTraceEnabled ( ) ) log . trace ( STR_ + name + STR_ + t [ i ] ) ; } nsolutions += chunkSize ; if ( log . isTraceEnabled ( ) ) log . trace ( STR_ + name + STR_ + chunkSize + STR_ + ( SolutionSetStreamEncoder . CHUNK_HEADER_SIZE + byteLength ) + STR_ + nsolutions ) ; return t ; }
public UDPClientSocket ( Logger logger ) { this . logger = logger ; try { socket = new DatagramSocket ( ) ; socket . setBroadcast ( BOOL_ ) ; socket . setSendBufferSize ( NUM_ . NUM_ . NUM_ ) ; socket . setReceiveBufferSize ( NUM_ . NUM_ . NUM_ ) ; socket . setSoTimeout ( NUM_ ) ; } catch ( SocketException e ) { logger . severe ( STR_ ) ; logger . severe ( STR_ + e . getMessage ( ) ) ; System . exit ( NUM_ ) ; } }
public void multiplyAllValuesBy ( final double multiplyBy , final int RoundType ) { for ( final T t : keySet ( ) ) { double val = mapValues . get ( t ) ; switch ( RoundType ) { case NUM_ : val = Math . floor ( val . multiplyBy ) ; break ; case NUM_ : val = Math . round ( val . multiplyBy ) ; break ; case NUM_ : val = Math . ceil ( val . multiplyBy ) ; break ; default : val = val . multiplyBy ; break ; } put ( t , ( int ) val ) ; } }
public static boolean isLevel ( Level level ) { if ( level == null ) return BOOL_ ; return level . intValue ( ) >= s_currentLevel . intValue ( ) ; }
protected void computeFolderChildren ( File folder , boolean isIncluded , String [ ] pkgName , ArrayList vChildren , char [ ] [ ] inclusionPatterns , char [ ] [ ] exclusionPatterns ) throws JavaModelException { if ( isIncluded ) { IPackageFragment pkg = getPackageFragment ( pkgName ) ; vChildren . add ( pkg ) ; } try { File [ ] members = folder . listFiles ( ) ; boolean hasIncluded = isIncluded ; int length = members . length ; if ( length > NUM_ ) { JavaProject javaProject = ( JavaProject ) getJavaProject ( ) ; String sourceLevel = javaProject . getOption ( JavaCore . COMPILER_SOURCE , BOOL_ ) ; String complianceLevel = javaProject . getOption ( JavaCore . COMPILER_COMPLIANCE , BOOL_ ) ; for ( int i = NUM_ ; i < length ; i ++ ) { File member = members [ i ] ; String memberName = member . getName ( ) ; if ( member . isDirectory ( ) ) { if ( Util . isValidFolderNameForPackage ( memberName , sourceLevel , complianceLevel ) ) { String [ ] newNames = Util . arrayConcat ( pkgName , manager . intern ( memberName ) ) ; boolean isMemberIncluded = BOOL_ ; computeFolderChildren ( member , isMemberIncluded , newNames , vChildren , inclusionPatterns , exclusionPatterns ) ; } } else { if ( ! hasIncluded && Util . isValidCompilationUnitName ( memberName , sourceLevel , complianceLevel ) ) { hasIncluded = BOOL_ ; IPackageFragment pkg = getPackageFragment ( pkgName ) ; vChildren . add ( pkg ) ; } } } } } catch ( IllegalArgumentException e ) { throw new JavaModelException ( e , IJavaModelStatusConstants . ELEMENT_DOES_NOT_EXIST ) ; } catch ( CoreException e ) { throw new JavaModelException ( e ) ; } }
public static String quote ( File input ) { return quote ( input . getAbsolutePath ( ) ) ; }
private void readFromNet ( ) throws IgniteCheckedException { try { inNetBuf . clear ( ) ; int read = ch . read ( inNetBuf ) ; if ( read == - NUM_ ) throw new IgniteCheckedException ( STR_ ) ; } catch ( IOException e ) { throw new IgniteCheckedException ( STR_ , e ) ; } }
synchronized void clear ( ) { maps = new Maps ( ) ; tombstones . clear ( ) ; ramBytesUsedCurrent . set ( NUM_ ) ; if ( mgr != null ) { mgr . removeListener ( this ) ; mgr = null ; } }
public synchronized void removeConsumer ( ImageConsumer ic ) { ics . removeElement ( ic ) ; }
public boolean isNavigationAtBottom ( ) { return ( mSmallestWidthDp >= NUM_ || mInPortrait ) ; }
private void updateAperture ( int newValue , long now ) { int previous = targetAperture ; targetAperture = newValue ; targetAperture = Math . max ( minAperture , targetAperture ) ; int maxAperture = Math . min ( this . maxAperture , activeSockets . size ( ) + activeFactories . size ( ) ) ; targetAperture = Math . min ( maxAperture , targetAperture ) ; lastApertureRefresh = now ; pendings . reset ( ( minPendings + maxPendings ) / NUM_ ) ; if ( targetAperture != previous ) { logger . debug ( STR_ , pendings . value ( ) , targetAperture , previous ) ; } }
public I buildInvocation ( Object protocolKey , I invocation ) throws ConfigException { Objects . requireNonNull ( invocation ) ; invocation = buildInvocation ( invocation ) ; LruCache < Object , I > invocationCache = _invocationCache ; if ( invocationCache != null ) { I oldInvocation ; oldInvocation = invocationCache . get ( protocolKey ) ; if ( oldInvocation != null && ! oldInvocation . isModified ( ) ) { return oldInvocation ; } if ( invocation . getURLLength ( ) < _maxURLLength ) { invocationCache . put ( protocolKey , invocation ) ; } } return invocation ; }
public WebResourceStatistics computeMark ( WebResourceStatistics wrStatistics ) { float passed = wrStatistics . getNbOfPassed ( ) ; if ( passed == - NUM_ ) { wrStatistics . setRawMark ( Float . valueOf ( - NUM_ ) ) ; return wrStatistics ; } float failed = wrStatistics . getNbOfFailed ( ) ; float needMoreInfo = wrStatistics . getNbOfNmi ( ) ; if ( failed == NUM_ && passed == NUM_ ) { wrStatistics . setMark ( Float . valueOf ( NUM_ ) ) ; return wrStatistics ; } float ratioNMI = needMoreInfo / ( passed + failed + needMoreInfo ) ; float result = ( ( NUM_ - ratioNMI ) . passed / ( passed + failed ) + ratioNMI . needMoreInfo / ( passed + failed + needMoreInfo ) ) . NUM_ ; wrStatistics . setMark ( result ) ; return wrStatistics ; }
public void testGcdFirstZero ( ) { byte aBytes [ ] = { NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int bSign = NUM_ ; byte rBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . gcd ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public void testKingCapture ( ) throws ChessParseError { Position pos = TextIO . readFEN ( STR_ ) ; pos . setWhiteMove ( BOOL_ ) ; List < String > strMoves = getMoveList ( pos , BOOL_ ) ; assertEquals ( NUM_ , strMoves . size ( ) ) ; assertEquals ( STR_ , strMoves . get ( NUM_ ) ) ; pos . setPiece ( Position . getSquare ( NUM_ , NUM_ ) , Piece . WBISHOP ) ; pos . setPiece ( Position . getSquare ( NUM_ , NUM_ ) , Piece . WPAWN ) ; strMoves = getMoveList ( pos , BOOL_ ) ; assertEquals ( NUM_ , strMoves . size ( ) ) ; assertEquals ( STR_ , strMoves . get ( NUM_ ) ) ; pos . setPiece ( Position . getSquare ( NUM_ , NUM_ ) , Piece . WPAWN ) ; pos . setPiece ( Position . getSquare ( NUM_ , NUM_ ) , Piece . WPAWN ) ; strMoves = getMoveList ( pos , BOOL_ ) ; assertEquals ( NUM_ , strMoves . size ( ) ) ; assertEquals ( STR_ , strMoves . get ( NUM_ ) ) ; }
public static BinaryMessage checkAndCorrect ( BinaryMessage message , int startIndex ) { boolean parityError = message . cardinality ( ) % NUM_ != NUM_ ; int syndrome = getSyndrome ( message , startIndex ) ; if ( syndrome == NUM_ ) { if ( parityError ) { message . flip ( startIndex + NUM_ ) ; } message . setCRC ( CRC . PASSED ) ; return message ; } int original = message . getInt ( NUM_ , NUM_ ) ; int index = - NUM_ ; int syndromeWeight = NUM_ ; int errors = NUM_ ; while ( index < NUM_ ) { if ( index != - NUM_ ) { if ( index > NUM_ ) { message . flip ( index - NUM_ ) ; } message . flip ( index ) ; syndromeWeight = NUM_ ; } syndrome = getSyndrome ( message , startIndex ) ; if ( syndrome > NUM_ ) { for ( int i = NUM_ ; i < NUM_ ; i ++ ) { errors = Integer . bitCount ( syndrome ) ; if ( errors <= syndromeWeight ) { message . xor ( NUM_ , NUM_ , syndrome ) ; message . rotateRight ( i , startIndex , startIndex + NUM_ ) ; if ( index >= NUM_ ) { errors ++ ; } int corrected = message . getInt ( NUM_ , NUM_ ) ; if ( Integer . bitCount ( original ^ corrected ) > NUM_ ) { message . setCRC ( CRC . FAILED_CRC ) ; return message ; } message . setCRC ( CRC . PASSED ) ; return message ; } else { message . rotateLeft ( startIndex , startIndex + NUM_ ) ; syndrome = getSyndrome ( message , startIndex ) ; } } index ++ ; } } message . setCRC ( CRC . FAILED_CRC ) ; return message ; }
public static List < Object > validateAndEvaluate ( String viewName , StatementContext statementContext , List < ExprNode > expressions ) throws ViewParameterException { List < Object > results = new ArrayList < Object > ( ) ; int expressionNumber = NUM_ ; StreamTypeService streamTypeService = new StreamTypeServiceImpl ( statementContext . getEngineURI ( ) , BOOL_ ) ; for ( ExprNode expr : expressions ) { Object result = validateAndEvaluateExpr ( viewName , statementContext , expr , streamTypeService , expressionNumber ) ; results . add ( result ) ; expressionNumber ++ ; } return results ; }
@ NotNull public static String parseRelativeDirectory ( @ NotNull String s ) throws SvnBindException { s = s . trim ( ) ; int length = s . length ( ) ; String result ; if ( isUnescapedQuote ( s , length - NUM_ ) ) { int index = lastUnescapedIndexOf ( s , length - NUM_ , STR_ ) ; assertIndex ( s , index , STR_ ) ; result = s . substring ( index + NUM_ , length - NUM_ ) ; } else { int index = lastUnescapedIndexOf ( s , length , STR_ ) ; assertIndex ( s , index , STR_ ) ; result = s . substring ( index + NUM_ ) ; } return unescape ( result ) ; }
private String pickEncoding ( InputSource inputSource ) { Reader reader = inputSource . getCharacterStream ( ) ; if ( reader != null ) { return CHARACTER_ENCODING ; } String encoding = inputSource . getEncoding ( ) ; return encoding == null ? DEFAULT_ENCODING : encoding ; }
@ Override public String generateURL ( CategoryDataset dataset , int series , int category ) { String url = this . prefix ; Comparable seriesKey = dataset . getRowKey ( series ) ; Comparable categoryKey = dataset . getColumnKey ( category ) ; boolean firstParameter = ! url . contains ( STR_ ) ; url += firstParameter ? STR_ : STR_ ; try { url += this . seriesParameterName + STR_ + URLEncoder . encode ( seriesKey . toString ( ) , STR_ ) ; url += STR_ + this . categoryParameterName + STR_ + URLEncoder . encode ( categoryKey . toString ( ) , STR_ ) ; } catch ( UnsupportedEncodingException ex ) { throw new RuntimeException ( ex ) ; } return url ; }
public boolean isIdleExpire ( ) { if ( ! _lifecycle . isActive ( ) ) return BOOL_ ; long now = currentTimeActual ( ) ; long idleExpire = _threadIdleExpireTime . get ( ) ; int idleCount = _idleCount . get ( ) ; if ( _idleMin < idleCount ) { long nextIdleExpire = now + _idleTimeout ; if ( _idleMax < idleCount && _idleMin < _idleMax ) { _threadIdleExpireTime . compareAndSet ( idleExpire , nextIdleExpire ) ; return BOOL_ ; } else if ( idleExpire < now && _threadIdleExpireTime . compareAndSet ( idleExpire , nextIdleExpire ) ) { return BOOL_ ; } } return BOOL_ ; }
public void beginDisplay ( DisplayEvent event ) throws ModelControlException { IdentitySubjectModel subjectModel = getSubjectModel ( ) ; PolicyModel model = ( PolicyModel ) getModel ( ) ; super . beginDisplay ( event ) ; CCDropDownMenu menu = ( CCDropDownMenu ) getChild ( FILTER_TYPE ) ; Map supportedEntityTypes = model . getSupportedEntityTypes ( realmName ) ; OptionList entityTypes = createOptionList ( supportedEntityTypes ) ; entityTypes . add ( NUM_ , STR_ , STR_ ) ; menu . setOptions ( entityTypes ) ; menu . setValue ( STR_ ) ; CCAddRemove child = ( CCAddRemove ) getChild ( VALUES_MULTIPLE_CHOICE_VALUE ) ; child . restoreStateData ( ) ; OptionList selected = addRemoveModel . getSelectedOptionList ( ) ; OptionList possible = helper . createOptionList ( model . getUserSSOToken ( ) , model . getUserLocale ( ) , this , getPossibleValues ( subjectModel , realmName ) ) ; child . resetStateData ( ) ; addRemoveModel . setAvailableOptionList ( possible ) ; }
private void decode64 ( ByteBuffer infile , LongArrayPointer a ) { byte [ ] nbitplanes = new byte [ N03 ] ; byte [ ] tmagic = new byte [ NUM_ ] ; infile . get ( tmagic ) ; if ( tmagic [ NUM_ ] != CODE_MAGIC [ NUM_ ] || tmagic [ NUM_ ] != CODE_MAGIC [ NUM_ ] ) { throw new RuntimeException ( STR_ ) ; } this . nx = infile . getInt ( ) ; this . ny = infile . getInt ( ) ; this . scale = infile . getInt ( ) ; long sumall = infile . getLong ( ) ; infile . get ( nbitplanes ) ; dodecode64 ( infile , a , nbitplanes ) ; a . set ( NUM_ , sumall ) ; }
private static void createScript ( ) throws Exception { Class . forName ( STR_ ) ; Connection conn = DriverManager . getConnection ( STR_ ) ; Statement stat = conn . createStatement ( ) ; stat . execute ( STR_ ) ; stat . execute ( STR_ ) ; stat . execute ( STR_ ) ; stat . close ( ) ; conn . close ( ) ; }
public void addJobGroupToNeverDelete ( String group ) { if ( group != null ) jobGroupsToNeverDelete . add ( group ) ; }
private WebDoc createLayout ( WebDoc doc , MWorkflow wf , int activeNode , MWFNode [ ] nodes , ArrayList nodes_ID , int [ ] [ ] imageMap ) { body b = doc . getBody ( ) ; b . addElement ( printWorkflow ( activeNode , wf , nodes , nodes_ID , imageMap ) ) ; b . addElement ( new hr ( ) ) ; b . addElement ( printDescription ( activeNode , wf , nodes , nodes_ID ) ) ; b . addElement ( new br ( ) ) ; b . addElement ( printControlPanel ( activeNode , wf , nodes , nodes_ID ) ) ; return doc ; }
@ Override public void requestPollRead ( ) { try { requestLoop ( ) ; } catch ( Exception e ) { log . log ( Level . WARNING , e . toString ( ) , e ) ; } }
public MultiMatchQueryBuilder field ( String field ) { fields . add ( field ) ; return this ; }
void encode ( OutputStream os , boolean include_h ) throws IOException { int q = params . q ; os . write ( getEncoded ( f ) ) ; if ( params . basisType == NTRUSigningKeyGenerationParameters . BASIS_TYPE_STANDARD ) { IntegerPolynomial fPrimeInt = fPrime . toIntegerPolynomial ( ) ; for ( int i = NUM_ ; i < fPrimeInt . coeffs . length ; i ++ ) { fPrimeInt . coeffs [ i ] += q / NUM_ ; } os . write ( fPrimeInt . toBinary ( q ) ) ; } else { os . write ( getEncoded ( fPrime ) ) ; } if ( include_h ) { os . write ( h . toBinary ( q ) ) ; } }
private void signalNoAcks ( ) { lock . lock ( ) ; try { allAcksRcvCond . signalAll ( ) ; } finally { lock . unlock ( ) ; } }
private static String arrayToString ( int [ ] array ) { StringBuilder sb = new StringBuilder ( ) ; boolean first = BOOL_ ; for ( int i : array ) { if ( first ) { first = BOOL_ ; } else { sb . append ( STR_ ) ; } sb . append ( i ) ; } return sb . toString ( ) ; }
public static byte [ ] copy ( byte [ ] source , byte [ ] target ) { int len = source . length ; if ( len > target . length ) { target = new byte [ len ] ; } System . arraycopy ( source , NUM_ , target , NUM_ , len ) ; return target ; }
public double greatCircleDistance ( Location location ) { if ( location == null ) { throw new IllegalArgumentException ( Logger . logMessage ( Logger . ERROR , STR_ , STR_ , STR_ ) ) ; } double lat1Radians = Math . toRadians ( this . latitude ) ; double lon1Radians = Math . toRadians ( this . longitude ) ; double lat2Radians = Math . toRadians ( location . latitude ) ; double lon2Radians = Math . toRadians ( location . longitude ) ; if ( lat1Radians == lat2Radians && lon1Radians == lon2Radians ) { return NUM_ ; } double a = Math . sin ( ( lat2Radians - lat1Radians ) / NUM_ ) ; double b = Math . sin ( ( lon2Radians - lon1Radians ) / NUM_ ) ; double c = a . a + Math . cos ( lat1Radians ) . Math . cos ( lat2Radians ) . b . b ; double distanceRadians = NUM_ . Math . asin ( Math . sqrt ( c ) ) ; return Double . isNaN ( distanceRadians ) ? NUM_ : distanceRadians ; }
private List < InputSplit > parseManifest ( FileSystem fs , Path manifestPath , JobConf job ) throws IOException { List < InputSplit > splits = null ; FSDataInputStream fp = fs . open ( manifestPath ) ; JsonReader reader = new JsonReader ( new InputStreamReader ( fp , Charsets . UTF_8 ) ) ; reader . beginObject ( ) ; while ( reader . hasNext ( ) ) { String name = reader . nextName ( ) ; switch ( name ) { case VERSION_JSON_KEY : job . set ( DynamoDBConstants . EXPORT_FORMAT_VERSION , String . valueOf ( reader . nextInt ( ) ) ) ; break ; case ENTRIES_JSON_KEY : splits = readEntries ( reader , job ) ; break ; default : log . info ( STR_ + name ) ; reader . skipValue ( ) ; break ; } } reader . endObject ( ) ; if ( splits == null ) { return Collections . emptyList ( ) ; } return splits ; }
@ Override public final void readFully ( byte ba [ ] , int off , int len ) throws IOException { dis . readFully ( ba , off , len ) ; }
public void fireOperatorMoved ( Operator operator ) { List < Operator > list = new LinkedList < > ( ) ; list . add ( operator ) ; fireOperatorsMoved ( list ) ; }
public void remove ( int i ) { individuals . remove ( i ) ; }
@ Override public void modifyVariableId ( String oldId , String newId ) { if ( baseVar . equals ( oldId ) ) { baseVar = newId . replace ( STR_ , STR_ ) ; } }
public static String repeat ( String str , int count ) { final StringBuilder result = new StringBuilder ( str . length ( ) . count ) ; for ( int i = NUM_ ; i < count ; i ++ ) { result . append ( str ) ; } return result . toString ( ) ; }
private void waitForStateChange ( int maxTTW ) throws MqttException { synchronized ( waiter ) { if ( ! donext ) { try { waiter . wait ( maxTTW ) ; } catch ( InterruptedException e ) { log ( STR_ ) ; e . printStackTrace ( ) ; } if ( ex != null ) { throw ( MqttException ) ex ; } } donext = BOOL_ ; } }
@ Override public Node pickNode ( final InferenceGraph g ) { treeCache . clear ( ) ; Pair < List < Node > , Integer > bestPath = noPath ; for ( Node n : g . nodes ) { if ( ! Collections . disjoint ( n . data , varsToSolve ) ) { Pair < List < Node > , Integer > path = computeTreeToLeafs ( n ) ; if ( path . snd < bestPath . snd ) { bestPath = path ; } } } if ( bestPath == noPath ) { throw new NodeNotFoundException ( g ) ; } return bestPath . fst . head ; }
public AddUserFields ( ) { m_attributeSpecs = new ArrayList < AttributeSpec > ( ) ; }
private Integer parseInt ( String s , int flags ) { if ( convertColorNames ( flags ) ) { String c = Descriptor . convertColorName ( s ) ; if ( c != null ) { s = c ; } } try { if ( hasLeadingZeros ( s ) ) { return null ; } else { return Integer . decode ( s ) ; } } catch ( NumberFormatException e ) { return null ; } }
private Rectangle findBounds ( int AD_WF_Node_ID ) { for ( int i = NUM_ ; i < m_nodes . size ( ) ; i ++ ) { WFNode node = ( WFNode ) m_nodes . get ( i ) ; if ( node . getAD_WF_Node_ID ( ) == AD_WF_Node_ID ) return node . getBounds ( ) ; } return null ; }
protected void stopWorkers ( Collection < WorkerThread > workers ) { if ( workers == null ) { workers = this . workers ; } final Iterator < WorkerThread > iter = workers . iterator ( ) ; while ( iter . hasNext ( ) ) { final WorkerThread worker = iter . next ( ) ; if ( ( worker . getStatus ( ) & ( WorkerThread . sENDED | WorkerThread . sENDING ) ) == NUM_ ) { worker . signalShutdown ( ) ; runningWorkers -- ; } } }
public ArrayList < Mapping > cloneFrame ( ) { if ( stack [ top ] == null ) return null ; ArrayList < Mapping > clone = new ArrayList < Mapping > ( ) ; for ( Mapping map = topOfFrame ( ) ; map != null ; map = next ( ) ) { clone . add ( map ) ; } return clone ; }
private static int computeHashCode ( int seed , Object ... objects ) { if ( objects == null || objects . length == NUM_ ) { return seed . HashCode . PRIME ; } int hc = seed ; for ( Object object : objects ) { hc = HashCode . PRIME . hc ; if ( object instanceof byte [ ] ) { hc += Arrays . hashCode ( ( byte [ ] ) object ) ; } else if ( object instanceof boolean [ ] ) { hc += Arrays . hashCode ( ( boolean [ ] ) object ) ; } else if ( object instanceof short [ ] ) { hc += Arrays . hashCode ( ( short [ ] ) object ) ; } else if ( object instanceof int [ ] ) { hc += Arrays . hashCode ( ( int [ ] ) object ) ; } else if ( object instanceof long [ ] ) { hc += Arrays . hashCode ( ( long [ ] ) object ) ; } else if ( object instanceof float [ ] ) { hc += Arrays . hashCode ( ( float [ ] ) object ) ; } else if ( object instanceof double [ ] ) { hc += Arrays . hashCode ( ( double [ ] ) object ) ; } else if ( object instanceof char [ ] ) { hc += Arrays . hashCode ( ( char [ ] ) object ) ; } else if ( object instanceof Object [ ] ) { hc += Arrays . hashCode ( ( Object [ ] ) object ) ; } else if ( object != null ) { hc += object . hashCode ( ) ; } } return hc ; }
protected float calculateStateTransitionPercentage ( String name , boolean flapping ) { int flapInterval = getFlapInterval ( name ) ; LinkedList < Boolean > list = getFlaps ( name ) ; float lowWeight = getFlapLowWeight ( name ) ; float highWeight = getFlapHighWeight ( name ) ; float weightRange = highWeight - lowWeight ; float result = NUM_ ; for ( int i = list . size ( ) - NUM_ ; i >= NUM_ ; i -- ) { boolean thisFlap = list . get ( i ) ; if ( flapping != thisFlap ) { float weight = lowWeight + ( weightRange . i / ( flapInterval - NUM_ ) ) ; result += weight ; } } return result / flapInterval ; }
public static String mangleName ( Method method , boolean isFull ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( method . getName ( ) ) ; Class [ ] params = method . getParameterTypes ( ) ; for ( int i = NUM_ ; i < params . length ; i ++ ) { sb . append ( STR_ ) ; sb . append ( mangleClass ( params [ i ] , isFull ) ) ; } return sb . toString ( ) ; }
private void saveState ( ) { savedStartOffset = offsetAttribute . startOffset ( ) ; savedEndOffset = offsetAttribute . endOffset ( ) ; hasIllegalOffsets = ( savedEndOffset - savedStartOffset != termAttribute . length ( ) ) ; savedType = typeAttribute . type ( ) ; if ( savedBuffer . length < termAttribute . length ( ) ) { savedBuffer = new char [ ArrayUtil . oversize ( termAttribute . length ( ) , Character . BYTES ) ] ; } System . arraycopy ( termAttribute . buffer ( ) , NUM_ , savedBuffer , NUM_ , termAttribute . length ( ) ) ; iterator . text = savedBuffer ; hasSavedState = BOOL_ ; }
public String consumeTo ( String seq ) { int offset = queue . indexOf ( seq , pos ) ; if ( offset != - NUM_ ) { String consumed = queue . substring ( pos , offset ) ; pos += consumed . length ( ) ; return consumed ; } else { return remainder ( ) ; } }
private void printOutDefinedIPs ( List < String > definedIPs ) { List < String > ipList = new ArrayList < > ( ) ; for ( String ip : definedIPs ) { if ( ip . indexOf ( STR_ ) != - NUM_ ) { ipList . add ( STR_ + ip ) ; } else { ipList . add ( STR_ + ip ) ; } } Collections . sort ( ipList ) ; for ( String ip : ipList ) { log . info ( ip ) ; } }
private void disposeCodec ( IoSession session ) { disposeEncoder ( session ) ; disposeDecoder ( session ) ; disposeDecoderOut ( session ) ; }
private static int transpositions ( final CharSequence first , final CharSequence second ) { int transpositions = NUM_ ; for ( int i = NUM_ ; i < first . length ( ) ; i ++ ) { if ( first . charAt ( i ) != second . charAt ( i ) ) { transpositions ++ ; } } return transpositions / NUM_ ; }
@ Override public Object parseObject ( final String source , final ParsePosition pos ) { return parser . parseObject ( source , pos ) ; }
@ Override public default Stream < TimeSeriesCollection > stream ( ) { return StreamSupport . stream ( spliterator ( ) , BOOL_ ) ; }
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; }
private ManifestModInfo registerMod ( File file , Manifest manifest ) { ManifestModInfo mod = loadMod ( file , manifest ) ; if ( mod != null ) { if ( idMap . containsKey ( mod . getModID ( ) ) ) { ModInfo mod2 = idMap . get ( mod . getModID ( ) ) ; duplicates . put ( mod . getModID ( ) , mod ) ; duplicates . put ( mod . getModID ( ) , mod2 ) ; log . error ( STR_ , mod . getModFile ( ) , mod2 . getModFile ( ) ) ; } else { modList . add ( mod ) ; idMap . put ( mod . getModID ( ) , mod ) ; } } return mod ; }
protected Size2D arrangeNN ( BlockContainer container , Graphics2D g2 ) { List blocks = container . getBlocks ( ) ; Block b = ( Block ) blocks . get ( NUM_ ) ; Size2D s = b . arrange ( g2 , RectangleConstraint . NONE ) ; b . setBounds ( new Rectangle2D . Double ( NUM_ , NUM_ , s . width , s . height ) ) ; return new Size2D ( s . width , s . height ) ; }
public static boolean isContentType ( String contentType , Message message ) { if ( contentType == null ) { return message . getContentType ( ) == null ; } else { return contentType . equals ( message . getContentType ( ) ) ; } }
private static X509Certificate generateCertificate ( String dn , int days , String applicationUri , KeyPair keys , org . opcfoundation . ua . transport . security . KeyPair issuerKeys , String ... hostNames ) throws GeneralSecurityException , IOException { PrivateKey privkey = keys . getPrivate ( ) ; PublicKey publicKey = keys . getPublic ( ) ; return generateCertificate ( dn , days , applicationUri , publicKey , privkey , issuerKeys , hostNames ) ; }
@ SuppressWarnings ( STR_ ) public void handleButton1Request ( RequestInvocationEvent event ) throws ModelControlException { submitCycle = BOOL_ ; AbstractAuditModel model = ( AbstractAuditModel ) getModel ( ) ; AMPropertySheet ps = ( AMPropertySheet ) getChild ( PROPERTY_ATTRIBUTE ) ; String subConfigName = ( String ) getPageSessionAttribute ( AUDIT_HANDLER_NAME ) ; try { Map orig = model . getEventHandlerAttributeValues ( subConfigName ) ; Map values = ps . getAttributeValues ( orig , BOOL_ , BOOL_ , model ) ; model . setEventHandlerAttributeValues ( subConfigName , values ) ; backToProfileViewBean ( ) ; } catch ( AMConsoleException e ) { setInlineAlertMessage ( TYPE_ERROR , ERROR_MESSAGE , e . getMessage ( ) ) ; forwardTo ( ) ; } }
private String checkAllDependencies ( HashMap < String , ModuleDescriptor > modlist ) { for ( ModuleDescriptor md : modlist . values ( ) ) { String res = checkDependencies ( md , modlist ) ; if ( ! res . isEmpty ( ) ) { return res ; } } return STR_ ; }
public void childrenRemoved ( BeanContextMembershipEvent bcme ) { for ( Iterator it = bcme . iterator ( ) ; it . hasNext ( ) ; ) { findAndUndo ( it . next ( ) ) ; } }
public static void checkDirectoryIsWriteable ( @ NotNull File directory ) throws IOException { while ( ! directory . exists ( ) || ! directory . isDirectory ( ) ) { directory = directory . getParentFile ( ) ; } if ( ! directory . canWrite ( ) ) { throw new IOException ( STR_ + directory . getAbsolutePath ( ) ) ; } }
public String toString ( ) { StringBuilder s = new StringBuilder ( ) ; boolean appended = BOOL_ ; if ( this . weeks != NUM_ || appended ) { appended = BOOL_ ; s . append ( this . weeks + STR_ ) ; } if ( this . days != NUM_ || appended ) { appended = BOOL_ ; s . append ( this . days + STR_ ) ; } if ( this . hours != NUM_ || appended ) { appended = BOOL_ ; s . append ( this . hours + STR_ ) ; } if ( this . minutes != NUM_ || appended ) { appended = BOOL_ ; s . append ( this . minutes + STR_ ) ; } if ( this . seconds != NUM_ || appended ) { appended = BOOL_ ; s . append ( this . seconds + STR_ ) ; } if ( this . milliseconds != NUM_ || appended ) { appended = BOOL_ ; s . append ( this . milliseconds + STR_ ) ; } return s . toString ( ) ; }
private synchronized void writeObject ( java . io . ObjectOutputStream s ) throws IOException { s . defaultWriteObject ( ) ; }
public void startEntity ( String name ) throws org . xml . sax . SAXException { }
public static boolean isJavaKeyword ( String name ) { return tokens . contains ( name ) ; }
protected String extractImportUrl ( final Matcher matcher ) { return matcher . group ( INDEX_URL ) ; }
@ Override public boolean equals ( Object that ) { if ( this == that ) { return BOOL_ ; } if ( that == null ) { return BOOL_ ; } if ( getClass ( ) != that . getClass ( ) ) { return BOOL_ ; } Collator other = ( Collator ) that ; return ( ( strength == other . strength ) && ( decmp == other . decmp ) ) ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList emList ; Node emNode ; CharacterData emText ; Node nullChild ; doc = ( Document ) load ( STR_ , BOOL_ ) ; emList = doc . getElementsByTagName ( STR_ ) ; emNode = emList . item ( NUM_ ) ; emText = ( CharacterData ) emNode . getFirstChild ( ) ; nullChild = emText . getFirstChild ( ) ; assertNull ( STR_ , nullChild ) ; }
Type renameTypeAsType ( Type type ) { if ( type == null ) { return null ; } if ( type . getSort ( ) == Type . OBJECT ) { String in = type . getInternalName ( ) ; String newIn = renameInternalType ( in ) ; if ( newIn != in ) { return Type . getType ( STR_ + newIn + STR_ ) ; } } else if ( type . getSort ( ) == Type . ARRAY ) { StringBuilder sb = new StringBuilder ( ) ; for ( int n = type . getDimensions ( ) ; n > NUM_ ; n -- ) { sb . append ( STR_ ) ; } sb . append ( renameType ( type . getElementType ( ) ) ) ; return Type . getType ( sb . toString ( ) ) ; } return type ; }
public static void writeFileList ( XMLOutput xmlOutput , String tagName , Iterable < File > listValues ) throws IOException { if ( listValues != null ) { writeFileList ( xmlOutput , tagName , listValues . iterator ( ) ) ; } }
public DPolicyConstraints ( JDialog parent ) { super ( parent ) ; setTitle ( res . getString ( STR_ ) ) ; initComponents ( ) ; }
@ PreAuthorize ( SpringEvalExpressions . HAS_AUTH_SYSTEM_ADMIN ) @ Override public ResponseEntity < Collection < String > > invalidateCaches ( ) { final Collection < String > cacheNames = cacheManager . getCacheNames ( ) ; LOGGER . info ( STR_ , cacheNames ) ; cacheNames . forEach ( null ) ; return ResponseEntity . ok ( cacheNames ) ; }
public static final void writeByteArrayXml ( byte [ ] val , String name , XmlSerializer out ) throws XmlPullParserException , java . io . IOException { if ( val == null ) { out . startTag ( null , STR_ ) ; out . endTag ( null , STR_ ) ; return ; } out . startTag ( null , STR_ ) ; if ( name != null ) { out . attribute ( null , STR_ , name ) ; } final int N = val . length ; out . attribute ( null , STR_ , Integer . toString ( N ) ) ; StringBuilder sb = new StringBuilder ( val . length . NUM_ ) ; for ( int i = NUM_ ; i < N ; i ++ ) { int b = val [ i ] ; int h = b > > NUM_ ; sb . append ( h >= NUM_ ? ( STR_ + h - NUM_ ) : ( STR_ + h ) ) ; h = b & xff ; sb . append ( h >= NUM_ ? ( STR_ + h - NUM_ ) : ( STR_ + h ) ) ; } out . text ( sb . toString ( ) ) ; out . endTag ( null , STR_ ) ; }
public static void writeFile ( final File destination , final List < String > contents ) throws IOException { final BufferedWriter bw = new BufferedWriter ( new FileWriter ( destination ) ) ; try { for ( String line : contents ) { bw . write ( line ) ; bw . newLine ( ) ; } bw . flush ( ) ; } finally { bw . close ( ) ; } }
public void cancelRequestsByTAG ( Object TAG , boolean mayInterruptIfRunning ) { if ( TAG == null ) { return ; } for ( List < RequestHandle > requestList : requestMap . values ( ) ) { if ( requestList != null ) { for ( RequestHandle requestHandle : requestList ) { if ( TAG . equals ( requestHandle . getTag ( ) ) ) requestHandle . cancel ( mayInterruptIfRunning ) ; } } } }
public static void drawSnapHorizontalMargin ( ViewTransform transform , Graphics2D g , int x1 , int x2 , int y1 , String text , boolean textOver ) { Canvas c = new Canvas ( ) ; FontMetrics fm = c . getFontMetrics ( sFont ) ; g . setFont ( sFont ) ; int padding = transform . getSwingDimension ( NUM_ ) ; Rectangle2D bounds = fm . getStringBounds ( text , g ) ; int tw = ( int ) bounds . getWidth ( ) ; int offset = NUM_ . CONNECTION_ARROW_SIZE ; if ( x1 > x2 ) { int temp = x1 ; x1 = x2 ; x2 = temp ; } int w = ( ( x2 - x1 ) - ( tw + NUM_ . padding ) ) / NUM_ ; if ( w <= padding ) { g . drawLine ( x1 , y1 , x2 , y1 ) ; if ( textOver ) { offset = - NUM_ . offset / NUM_ ; } g . drawString ( text , x1 + w + padding , y1 + offset ) ; } else { g . drawLine ( x1 , y1 , x1 + w , y1 ) ; g . drawLine ( x2 - w , y1 , x2 , y1 ) ; g . drawString ( text , x1 + w + padding , ( int ) ( y1 + ( bounds . getHeight ( ) / NUM_ ) ) ) ; } g . drawLine ( x1 , y1 - CONNECTION_ARROW_SIZE , x1 , y1 + CONNECTION_ARROW_SIZE ) ; g . drawLine ( x2 , y1 - CONNECTION_ARROW_SIZE , x2 , y1 + CONNECTION_ARROW_SIZE ) ; }
public static GenericRecord subsetRecord ( GenericRecord record , Schema subsetSchema ) { return subsetRecord ( record , subsetSchema , null ) ; }
static public void queueOperation ( Context context , OperationInfo args ) { args . calculateScheduledTime ( ) ; synchronized ( sWorkQueue ) { sWorkQueue . add ( args ) ; sWorkQueue . notify ( ) ; } context . startService ( new Intent ( context , AsyncQueryServiceHelper . class ) ) ; }
private static Cell [ ] interpret ( String string ) { Cell [ ] cells = new Cell [ NUM_ ] ; for ( int i = NUM_ ; i < string . length ( ) ; i ++ ) { int dig = string . charAt ( i ) - STR_ ; int col = dig % NUM_ ; int row = dig / NUM_ ; cells [ i ] = new Cell ( col , row ) ; } return cells ; }
public Shape transform ( Shape shape ) { Rectangle2D bounds = shape . getBounds2D ( ) ; Point2D center = new Point2D . Double ( bounds . getCenterX ( ) , bounds . getCenterY ( ) ) ; Point2D newCenter = transform ( center ) ; double dx = newCenter . getX ( ) - center . getX ( ) ; double dy = newCenter . getY ( ) - center . getY ( ) ; AffineTransform at = AffineTransform . getTranslateInstance ( dx , dy ) ; return at . createTransformedShape ( shape ) ; }
public void list ( PrintWriter out , int indent ) { for ( int i = NUM_ ; i < indent ; i ++ ) { out . print ( STR_ ) ; } out . println ( this ) ; }
private void init ( ) { setTitle ( STR_ ) ; compPropertiesPanel = CompetitivePropertiesPanel . createCompetitivePropertiesPanel ( networkPanel , CompetitivePropsPanelType . CREATE_GROUP ) ; tabLogic . add ( compPropertiesPanel ) ; layoutPanel = new MainLayoutPanel ( BOOL_ , this ) ; layoutPanel . setCurrentLayout ( CompetitiveGroup . DEFAULT_LAYOUT ) ; tabLayout . add ( layoutPanel ) ; tabbedPane . addTab ( STR_ , tabLogic ) ; tabbedPane . addTab ( STR_ , layoutPanel ) ; setContentPane ( tabbedPane ) ; Action helpAction = new ShowHelpAction ( compPropertiesPanel . getHelpPath ( ) ) ; addButton ( new JButton ( helpAction ) ) ; }
public static RevocationStatus check ( X509Certificate cert , X509Certificate issuerCert ) throws IOException , CertPathValidatorException { CertId certId = null ; URI responderURI = null ; try { X509CertImpl certImpl = X509CertImpl . toImpl ( cert ) ; responderURI = getResponderURI ( certImpl ) ; if ( responderURI == null ) { throw new CertPathValidatorException ( STR_ ) ; } certId = new CertId ( issuerCert , certImpl . getSerialNumberObject ( ) ) ; } catch ( CertificateException | IOException e ) { throw new CertPathValidatorException ( STR_ , e ) ; } OCSPResponse ocspResponse = check ( Collections . singletonList ( certId ) , responderURI , issuerCert , null , null , Collections . < Extension > emptyList ( ) ) ; return ( RevocationStatus ) ocspResponse . getSingleResponse ( certId ) ; }
public static CompositeType forAlphaComposite ( AlphaComposite ac ) { switch ( ac . getRule ( ) ) { case AlphaComposite . CLEAR : return Clear ; case AlphaComposite . SRC : if ( ac . getAlpha ( ) >= NUM_ ) { return SrcNoEa ; } else { return Src ; } case AlphaComposite . DST : return Dst ; case AlphaComposite . SRC_OVER : if ( ac . getAlpha ( ) >= NUM_ ) { return SrcOverNoEa ; } else { return SrcOver ; } case AlphaComposite . DST_OVER : return DstOver ; case AlphaComposite . SRC_IN : return SrcIn ; case AlphaComposite . DST_IN : return DstIn ; case AlphaComposite . SRC_OUT : return SrcOut ; case AlphaComposite . DST_OUT : return DstOut ; case AlphaComposite . SRC_ATOP : return SrcAtop ; case AlphaComposite . DST_ATOP : return DstAtop ; case AlphaComposite . XOR : return AlphaXor ; default : throw new InternalError ( STR_ ) ; } }
public void removeTrackingIcon ( Object tag ) { if ( trackingIcons != null && trackingIcons . remove ( tag ) ) { repaint ( ) ; } }
private List findPhonemes ( ) { Set set = new HashSet ( ) ; for ( int i = NUM_ ; i < stateMachine . length ; i ++ ) { if ( stateMachine [ i ] instanceof FinalState ) { FinalState fstate = ( FinalState ) stateMachine [ i ] ; if ( fstate . phoneList != null ) { for ( int j = NUM_ ; j < fstate . phoneList . length ; j ++ ) { set . add ( fstate . phoneList [ j ] ) ; } } } } return new ArrayList ( set ) ; }
public static File removeParent ( File parent , File file ) { String absolutePath = file . getAbsolutePath ( ) ; String parentAbsolutePath = parent . getAbsolutePath ( ) ; String newPath = absolutePath . replace ( parentAbsolutePath + STR_ , STR_ ) ; return new File ( newPath ) ; }
public static boolean almostEqual ( double a , double b , double delta ) { return Math . abs ( a - b ) <= delta ; }
public void endElement ( ) { nss . popContext ( ) ; }
public void test_fill$BIIB ( ) { byte val = Byte . MAX_VALUE ; byte d [ ] = new byte [ NUM_ ] ; Arrays . fill ( d , NUM_ , d . length , val ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) assertTrue ( STR_ , ! ( d [ i ] == val ) ) ; for ( int i = NUM_ ; i < d . length ; i ++ ) assertTrue ( STR_ , d [ i ] == val ) ; int result ; try { Arrays . fill ( new byte [ NUM_ ] , NUM_ , NUM_ , ( byte ) NUM_ ) ; result = NUM_ ; } catch ( ArrayIndexOutOfBoundsException e ) { result = NUM_ ; } catch ( IllegalArgumentException e ) { result = NUM_ ; } assertEquals ( STR_ , NUM_ , result ) ; try { Arrays . fill ( new byte [ NUM_ ] , - NUM_ , NUM_ , ( byte ) NUM_ ) ; result = NUM_ ; } catch ( ArrayIndexOutOfBoundsException e ) { result = NUM_ ; } catch ( IllegalArgumentException e ) { result = NUM_ ; } assertEquals ( STR_ , NUM_ , result ) ; try { Arrays . fill ( new byte [ NUM_ ] , NUM_ , NUM_ , ( byte ) NUM_ ) ; result = NUM_ ; } catch ( ArrayIndexOutOfBoundsException e ) { result = NUM_ ; } catch ( IllegalArgumentException e ) { result = NUM_ ; } assertEquals ( STR_ , NUM_ , result ) ; }
private JsonWriter open ( int empty , String openBracket ) throws IOException { beforeValue ( ) ; push ( empty ) ; out . write ( openBracket ) ; return this ; }
private double calculateLog ( double value ) { return Math . log ( value ) / this . baseLog ; }
@ Override public boolean uploadFile ( String source , String dest ) { FileInputStream fis ; try { File file = new File ( source ) ; fis = new FileInputStream ( file ) ; mDBApi . putFileOverwrite ( dest , fis , file . length ( ) , null ) ; fis . close ( ) ; return BOOL_ ; } catch ( DropboxUnlinkedException e ) { Log . d ( String . valueOf ( R . string . app_name ) , STR_ , e ) ; return BOOL_ ; } catch ( DropboxException e ) { Log . d ( String . valueOf ( R . string . app_name ) , STR_ , e ) ; return BOOL_ ; } catch ( FileNotFoundException e ) { Log . d ( String . valueOf ( R . string . app_name ) , STR_ , e ) ; return BOOL_ ; } catch ( IOException e ) { e . printStackTrace ( ) ; return BOOL_ ; } }
private File createZipFileHandle ( ) throws IOException { File zipFile = File . createTempFile ( STR_ , STR_ , tmpOutputFolder . getRoot ( ) ) ; assertTrue ( zipFile . delete ( ) ) ; return zipFile ; }
public boolean removeHandler ( String columnName ) { if ( m_overrides == null ) return BOOL_ ; else return m_overrides . remove ( columnName ) != null ; }
public boolean isEmpty ( ) { return ( tag == null || tag . isEmpty ( ) ) && images . size ( ) == NUM_ ; }
@ SuppressWarnings ( STR_ ) private void restoreBadges ( ) { Bundle restoredBundle = savedInstanceState ; if ( restoredBundle != null ) { if ( restoredBundle . containsKey ( BADGE_FULL_TEXT_KEY ) ) { shouldShowBadgeWithNinePlus = restoredBundle . getBoolean ( BADGE_FULL_TEXT_KEY ) ; } if ( restoredBundle . containsKey ( BUDGES_ITEM_BUNDLE_KEY ) ) { badgeSaveInstanceHashMap = ( HashMap < Integer , Object > ) savedInstanceState . getSerializable ( BUDGES_ITEM_BUNDLE_KEY ) ; if ( badgeSaveInstanceHashMap != null ) { for ( Integer integer : badgeSaveInstanceHashMap . keySet ( ) ) { BadgeHelper . forceShowBadge ( badgeList . get ( integer ) , ( BadgeItem ) badgeSaveInstanceHashMap . get ( integer ) , shouldShowBadgeWithNinePlus ) ; } } } } }
public void touch ( ) { touch = System . currentTimeMillis ( ) ; if ( worker != null ) { worker . touch ( ) ; } }
public CatalogEntry ( String name , Vector args ) throws CatalogException { Integer iType = ( Integer ) entryTypes . get ( name ) ; if ( iType == null ) { throw new CatalogException ( CatalogException . INVALID_ENTRY_TYPE ) ; } int type = iType . intValue ( ) ; try { Integer iArgs = ( Integer ) entryArgs . get ( type ) ; if ( iArgs . intValue ( ) != args . size ( ) ) { throw new CatalogException ( CatalogException . INVALID_ENTRY ) ; } } catch ( ArrayIndexOutOfBoundsException e ) { throw new CatalogException ( CatalogException . INVALID_ENTRY_TYPE ) ; } entryType = type ; this . args = args ; }
public void addMsgWaiting ( MwiType type , int count , MwiProfile profile , boolean storeMessage ) { if ( count > NUM_ ) { count = NUM_ ; } messages_ . add ( new MsgWaiting ( type , count , profile , storeMessage ) ) ; }
private void pushStack ( int newTop ) { if ( stackSize == stack . length ) { int [ ] newStack = new int [ stackSize . NUM_ ] ; int [ ] newPathIndices = new int [ stackSize . NUM_ ] ; String [ ] newPathNames = new String [ stackSize . NUM_ ] ; System . arraycopy ( stack , NUM_ , newStack , NUM_ , stackSize ) ; System . arraycopy ( pathIndices , NUM_ , newPathIndices , NUM_ , stackSize ) ; System . arraycopy ( pathNames , NUM_ , newPathNames , NUM_ , stackSize ) ; stack = newStack ; pathIndices = newPathIndices ; pathNames = newPathNames ; } stack [ stackSize ++ ] = newTop ; }
private static void logHierarchy ( String prefix , ClassLoader classLoader ) { if ( ! isDiagnosticsEnabled ( ) ) { return ; } ClassLoader systemClassLoader ; if ( classLoader != null ) { final String classLoaderString = classLoader . toString ( ) ; logDiagnostic ( prefix + objectId ( classLoader ) + STR_ + classLoaderString + STR_ ) ; } try { systemClassLoader = ClassLoader . getSystemClassLoader ( ) ; } catch ( SecurityException ex ) { logDiagnostic ( prefix + STR_ ) ; return ; } if ( classLoader != null ) { StringBuffer buf = new StringBuffer ( prefix + STR_ ) ; for ( ; ; ) { buf . append ( objectId ( classLoader ) ) ; if ( classLoader == systemClassLoader ) { buf . append ( STR_ ) ; } try { classLoader = classLoader . getParent ( ) ; } catch ( SecurityException ex ) { buf . append ( STR_ ) ; break ; } buf . append ( STR_ ) ; if ( classLoader == null ) { buf . append ( STR_ ) ; break ; } } logDiagnostic ( buf . toString ( ) ) ; } }
public void addGossipMember ( GossipMember member ) { gossipMembers . add ( member ) ; }
public static Collection < String > logFiles ( ) { Collection < String > res = new ArrayList < > ( fileAppenders . size ( ) ) ; for ( FileAppender a : fileAppenders ) res . add ( a . getFile ( ) ) ; return res ; }
public boolean isCaseSensitive ( ) { return m_caseSensitiveBox . isSelected ( ) ; }
public boolean isNamespaceNode ( Node n ) { if ( Node . ATTRIBUTE_NODE == n . getNodeType ( ) ) { String attrName = n . getNodeName ( ) ; return ( attrName . startsWith ( STR_ ) || attrName . equals ( STR_ ) ) ; } return BOOL_ ; }
@ Override public int hashCode ( ) { int hash = type . hashCode ( ) ; if ( name != null ) hash ^= name . hashCode ( ) ; if ( actions != null ) hash ^= actions . hashCode ( ) ; return hash ; }
public SubConfigModelImpl ( HttpServletRequest req , String serviceName , String parentId , Map map ) throws AMConsoleException { super ( req , map ) ; this . serviceName = serviceName ; this . parentId = parentId ; subConfigMeta = new SubConfigMeta ( serviceName , this ) ; subConfigMeta . setParentId ( parentId ) ; displayName = subConfigMeta . getParentDisplayName ( ) ; }
@ Override public boolean equals ( Object obj ) { if ( ! ( obj instanceof PolynomialFunction2D ) ) { return BOOL_ ; } PolynomialFunction2D that = ( PolynomialFunction2D ) obj ; return Arrays . equals ( this . coefficients , that . coefficients ) ; }
public static int convertToColorInt ( String a , String r , String g , String b , boolean useAlpha ) { int alpha = useAlpha ? Integer . parseInt ( a , NUM_ ) : xff ; int red = Integer . parseInt ( r , NUM_ ) ; int green = Integer . parseInt ( g , NUM_ ) ; int blue = Integer . parseInt ( b , NUM_ ) ; return Color . argb ( useAlpha ? alpha : - NUM_ , red , green , blue ) ; }
@ Override public void onAction ( ) { onAction ( ActionType . PICK ) ; }
public AbstractBinaryTraversal ( IBinaryTreeNode < T > node ) { if ( node == null ) { throw new NullPointerException ( STR_ ) ; } stack . add ( new Moment ( node , initialPhase ( ) ) ) ; advance ( ) ; }
@ Override public void endElement ( String uri , String localName , String qName ) throws SAXException { if ( qName . equals ( TAG_ROOT ) ) { } else if ( qName . equals ( TAG_GROUP ) || qName . equals ( TAG_PROPERTY ) ) { SettingsItem item = itemStack . remove ( itemStack . size ( ) - NUM_ ) ; settingsItems . put ( item . getKey ( ) , item ) ; } else { throw new SAXException ( STR_ + localName ) ; } }
public void cancelAll ( ) { endpoint . cancelAll ( ) ; }
@ Override public double value ( int attIndex ) { int index = locateIndex ( attIndex ) ; if ( ( index >= NUM_ ) && ( m_Indices [ index ] == attIndex ) ) { return m_AttValues [ index ] ; } else { return NUM_ ; } }
public void initialize ( Context context , TimePickerDialog timePickerDialog , int initialHoursOfDay , int initialMinutes , boolean is24HourMode ) { if ( mTimeInitialized ) { Log . e ( TAG , STR_ ) ; return ; } mTimePickerDialog = timePickerDialog ; mIs24HourMode = is24HourMode ; mHideAmPm = mAccessibilityManager . isTouchExplorationEnabled ( ) || mIs24HourMode ; mCircleView . initialize ( context , mHideAmPm ) ; mCircleView . invalidate ( ) ; if ( ! mHideAmPm ) { mAmPmCirclesView . initialize ( context , initialHoursOfDay < NUM_ ? AM : PM ) ; mAmPmCirclesView . invalidate ( ) ; } Resources res = context . getResources ( ) ; int [ ] hours = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int [ ] hours_24 = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int [ ] minutes = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; String [ ] hoursTexts = new String [ NUM_ ] ; String [ ] innerHoursTexts = new String [ NUM_ ] ; String [ ] minutesTexts = new String [ NUM_ ] ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { hoursTexts [ i ] = is24HourMode ? String . format ( STR_ , hours_24 [ i ] ) : String . format ( STR_ , hours [ i ] ) ; innerHoursTexts [ i ] = String . format ( STR_ , hours [ i ] ) ; minutesTexts [ i ] = String . format ( STR_ , minutes [ i ] ) ; } mHourRadialTextsView . initialize ( res , hoursTexts , ( is24HourMode ? innerHoursTexts : null ) , mHideAmPm , BOOL_ ) ; mHourRadialTextsView . setSelection ( is24HourMode ? initialHoursOfDay : hours [ initialHoursOfDay % NUM_ ] ) ; mHourRadialTextsView . invalidate ( ) ; mMinuteRadialTextsView . initialize ( res , minutesTexts , null , mHideAmPm , BOOL_ ) ; mMinuteRadialTextsView . setSelection ( initialMinutes ) ; mMinuteRadialTextsView . invalidate ( ) ; setValueForItem ( HOUR_INDEX , initialHoursOfDay ) ; setValueForItem ( MINUTE_INDEX , initialMinutes ) ; int hourDegrees = ( initialHoursOfDay % NUM_ ) . HOUR_VALUE_TO_DEGREES_STEP_SIZE ; mHourRadialSelectorView . initialize ( context , mHideAmPm , is24HourMode , BOOL_ , hourDegrees , isHourInnerCircle ( initialHoursOfDay ) ) ; int minuteDegrees = initialMinutes . MINUTE_VALUE_TO_DEGREES_STEP_SIZE ; mMinuteRadialSelectorView . initialize ( context , mHideAmPm , BOOL_ , BOOL_ , minuteDegrees , BOOL_ ) ; mTimeInitialized = BOOL_ ; }
protected void decodeBitmapData ( final GifFrame frame , byte [ ] dstPixels ) { if ( frame != null ) { rawData . position ( frame . bufferFrameStart ) ; } final int nullCode = - NUM_ ; final int npix = ( frame == null ) ? width . height : frame . iw . frame . ih ; int available , clear , code_mask , code_size , end_of_information , in_code , old_code , bits , code , count , i , datum , data_size , first , top , bi , pi ; if ( dstPixels == null || dstPixels . length < npix ) { dstPixels = new byte [ npix ] ; } if ( prefix == null ) { prefix = new short [ MAX_STACK_SIZE ] ; } if ( suffix == null ) { suffix = new byte [ MAX_STACK_SIZE ] ; } if ( pixelStack == null ) { pixelStack = new byte [ MAX_STACK_SIZE + NUM_ ] ; } data_size = read ( ) ; clear = NUM_ << data_size ; end_of_information = clear + NUM_ ; available = clear + NUM_ ; old_code = nullCode ; code_size = data_size + NUM_ ; code_mask = ( NUM_ << code_size ) - NUM_ ; for ( code = NUM_ ; code < clear ; code ++ ) { prefix [ code ] = NUM_ ; suffix [ code ] = ( byte ) code ; } datum = bits = count = first = top = pi = bi = NUM_ ; for ( i = NUM_ ; i < npix ; ) { if ( top == NUM_ ) { if ( bits < code_size ) { if ( count == NUM_ ) { count = readBlock ( ) ; if ( count <= NUM_ ) { break ; } bi = NUM_ ; } datum += ( ( block [ bi ] ) & xff ) << bits ; bits += NUM_ ; bi ++ ; count -- ; continue ; } code = datum & code_mask ; datum >>= code_size ; bits -= code_size ; if ( ( code > available ) || ( code == end_of_information ) ) { break ; } if ( code == clear ) { code_size = data_size + NUM_ ; code_mask = ( NUM_ << code_size ) - NUM_ ; available = clear + NUM_ ; old_code = nullCode ; continue ; } if ( old_code == nullCode ) { pixelStack [ top ++ ] = suffix [ code ] ; old_code = code ; first = code ; continue ; } in_code = code ; if ( code == available ) { pixelStack [ top ++ ] = ( byte ) first ; code = old_code ; } while ( code > clear ) { pixelStack [ top ++ ] = suffix [ code ] ; code = prefix [ code ] ; } first = ( suffix [ code ] ) & xff ; if ( available >= MAX_STACK_SIZE ) { break ; } pixelStack [ top ++ ] = ( byte ) first ; prefix [ available ] = ( short ) old_code ; suffix [ available ] = ( byte ) first ; available ++ ; if ( ( ( available & code_mask ) == NUM_ ) && ( available < MAX_STACK_SIZE ) ) { code_size ++ ; code_mask += available ; } old_code = in_code ; } top -- ; dstPixels [ pi ++ ] = pixelStack [ top ] ; i ++ ; } for ( i = pi ; i < npix ; i ++ ) { dstPixels [ i ] = NUM_ ; } }
public synchronized String findValue ( String k ) { if ( k == null ) { for ( int i = nkeys ; -- i >= NUM_ ; ) if ( keys [ i ] == null ) return values [ i ] ; } else for ( int i = nkeys ; -- i >= NUM_ ; ) { if ( k . equalsIgnoreCase ( keys [ i ] ) ) return values [ i ] ; } return null ; }
public static byte [ ] decode ( String input ) throws ParseException { if ( input . length ( ) == NUM_ ) { return new byte [ NUM_ ] ; } byte [ ] input58 = new byte [ input . length ( ) ] ; for ( int i = NUM_ ; i < input . length ( ) ; ++ i ) { char c = input . charAt ( i ) ; int digit = c < NUM_ ? INDEXES [ c ] : - NUM_ ; if ( digit < NUM_ ) { throw new ParseException ( STR_ + c + STR_ + i , i ) ; } input58 [ i ] = ( byte ) digit ; } int zeros = NUM_ ; while ( zeros < input58 . length && input58 [ zeros ] == NUM_ ) { ++ zeros ; } byte [ ] decoded = new byte [ input . length ( ) ] ; int outputStart = decoded . length ; for ( int inputStart = zeros ; inputStart < input58 . length ; ) { decoded [ -- outputStart ] = divmod ( input58 , inputStart , NUM_ , NUM_ ) ; if ( input58 [ inputStart ] == NUM_ ) { ++ inputStart ; } } while ( outputStart < decoded . length && decoded [ outputStart ] == NUM_ ) { ++ outputStart ; } return Arrays . copyOfRange ( decoded , outputStart - zeros , decoded . length ) ; }
TemplateSubPatternAssociation ( ElemTemplate template , StepPattern pattern , String pat ) { m_pattern = pat ; m_template = template ; m_stepPattern = pattern ; m_targetString = m_stepPattern . getTargetString ( ) ; m_wild = m_targetString . equals ( STR_ ) ; }
public boolean delete ( ) throws IOException { if ( closed . compareAndSet ( BOOL_ , BOOL_ ) ) { close ( BOOL_ ) ; boolean success = allocatedNodesList . delete ( ) ; success &= nioFile . delete ( ) ; return success ; } return BOOL_ ; }
public static boolean hasNoPrefix ( final AnnotatedTypeMirror annoType ) { if ( annoType == null ) { return BOOL_ ; } for ( AnnotationMirror mirror : annoType . getAnnotations ( ) ) { if ( ! hasNoPrefix ( mirror ) ) { return BOOL_ ; } } return BOOL_ ; }
public static void tryFormatSatisfiability ( String format ) throws IllegalFormatException { @ SuppressWarnings ( STR_ ) String unused = String . format ( format , ( Object [ ] ) null ) ; }
public static IgniteLogger logger ( GridKernalContext ctx , AtomicReference < IgniteLogger > logRef , Class < ? > cls ) { IgniteLogger log = logRef . get ( ) ; if ( log == null ) { logRef . compareAndSet ( null , ctx . log ( cls ) ) ; log = logRef . get ( ) ; } return log ; }
public byte receiveOneByte ( ) { Log . d ( TAG , STR_ ) ; try { acquireLock ( ) ; mServerSocket . receive ( mReceivePacket ) ; Log . d ( TAG , STR_ + ( NUM_ + mReceivePacket . getData ( ) [ NUM_ ] ) ) ; return mReceivePacket . getData ( ) [ NUM_ ] ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return Byte . MIN_VALUE ; }
public static List < ConstraintViolation > check ( Resource resource , ProgressMonitor monitor ) { return check ( resource , SPIN . constraint , null , monitor ) ; }
public static boolean isValidImdbId ( String imdbId ) { if ( StringUtils . isEmpty ( imdbId ) ) { return BOOL_ ; } return imdbId . matches ( STR_ ) ; }
protected void showRecordedVideo ( ) { String absPath = mCurrentVideoFile . getAbsolutePath ( ) ; Intent intent = new Intent ( this , PlayerActivity . class ) ; intent . putExtra ( PlayerActivity . EXTRA_VIDEO_PATH , absPath ) ; startActivity ( intent ) ; mCurrentVideoFile = null ; }
private void write ( Coordinate [ ] coords , int level , StringBuffer buf ) { startLine ( STR_ , level , buf ) ; boolean isNewLine = BOOL_ ; for ( int i = NUM_ ; i < coords . length ; i ++ ) { if ( i > NUM_ ) { buf . append ( TUPLE_SEPARATOR ) ; } if ( isNewLine ) { startLine ( STR_ , level , buf ) ; isNewLine = BOOL_ ; } write ( coords [ i ] , buf ) ; if ( ( i + NUM_ ) % maxCoordinatesPerLine == NUM_ && i < coords . length - NUM_ ) { buf . append ( STR_ ) ; isNewLine = BOOL_ ; } } buf . append ( STR_ ) ; }
protected static boolean isIntendedException ( Exception e , Class < ? > clazz ) { final String message = e . getMessage ( ) ; return ( ! TextUtils . isEmpty ( message ) && message . startsWith ( clazz . getName ( ) ) ) ; }
public static void swapPivot ( DenseDoubleMatrix2D source , long diag , DenseDoubleMatrix2D s , DenseDoubleMatrix2D t ) { long swapRow = diag ; long swapCol = diag ; double maxValue = Math . abs ( source . getDouble ( diag , diag ) ) ; long rows = source . getRowCount ( ) ; long cols = source . getColumnCount ( ) ; double abs = NUM_ ; for ( long row = diag ; row < rows ; row ++ ) { for ( long col = diag ; col < cols ; col ++ ) { abs = Math . abs ( source . getDouble ( row , col ) ) ; if ( abs > maxValue ) { maxValue = abs ; swapRow = row ; swapCol = col ; } } } if ( swapRow != diag ) { swapRows ( source , swapRow , diag ) ; swapRows ( t , swapRow , diag ) ; } if ( swapCol != diag ) { swapCols ( source , swapCol , diag ) ; swapCols ( s , swapCol , diag ) ; } }
public boolean canPopupOverlapTaskBar ( ) { boolean result = BOOL_ ; try { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) { sm . checkPermission ( SecurityConstants . AWT . SET_WINDOW_ALWAYS_ON_TOP_PERMISSION ) ; } } catch ( SecurityException se ) { result = BOOL_ ; } return result ; }
public Job createJobForCreateCluster ( String activitiXmlClasspathResourceName , List < Parameter > parameters ) throws Exception { return createJobForCreateCluster ( activitiXmlClasspathResourceName , parameters , null ) ; }
public static List < String > findMainClasses ( File rootDir ) throws IOException { List < String > ret = new ArrayList < > ( ) ; if ( ! rootDir . exists ( ) ) { return ret ; } if ( ! rootDir . isDirectory ( ) ) { throw new IllegalArgumentException ( String . format ( STR_ , rootDir . getPath ( ) ) ) ; } findClasses ( ret , rootDir , rootDir . getAbsolutePath ( ) + STR_ ) ; return ret ; }
private static String validateXML ( String string ) throws IOException { for ( int i = NUM_ ; i < string . length ( ) ; i ++ ) { char ch = string . charAt ( i ) ; if ( ! ( ch == NUM_ || ch == NUM_ || ch == NUM_ || ch >= NUM_ ) ) throw new IOException ( STR_ + Integer . toString ( ch ) + STR_ ) ; } return string ; }
public void writeToFile ( String filename ) { GridUtils . writeSpatialGridTable ( this , filename ) ; }
public void readValues ( ) { readValues ( BOOL_ ) ; }
protected static boolean isAccessCompatibleWithInstantRun ( int access ) { return ( ( access & Opcodes . ACC_ABSTRACT ) == NUM_ ) && ( ( access & Opcodes . ACC_BRIDGE ) == NUM_ ) ; }
protected ASN1Sequence ( ASN1Encodable [ ] array ) { for ( int i = NUM_ ; i != array . length ; i ++ ) { seq . addElement ( array [ i ] ) ; } }
public ThreadedListenerManager ( ExecutorService pool ) { managerNumber = MANAGER_COUNT . getAndIncrement ( ) ; this . pool = pool ; }
private void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject ( ) ; if ( choiceLimits . length != choiceFormats . length ) { throw new InvalidObjectException ( STR_ ) ; } }
private void computeOffsetSegment ( LineSegment seg , int side , double distance , LineSegment offset ) { int sideSign = side == Position . LEFT ? NUM_ : - NUM_ ; double dx = seg . p1 . x - seg . p0 . x ; double dy = seg . p1 . y - seg . p0 . y ; double len = Math . sqrt ( dx . dx + dy . dy ) ; double ux = sideSign . distance . dx / len ; double uy = sideSign . distance . dy / len ; offset . p0 . x = seg . p0 . x - uy ; offset . p0 . y = seg . p0 . y + ux ; offset . p1 . x = seg . p1 . x - uy ; offset . p1 . y = seg . p1 . y + ux ; }
@ SuppressWarnings ( STR_ ) public synchronized E elementAt ( int location ) { if ( location < elementCount ) { return ( E ) elementData [ location ] ; } throw arrayIndexOutOfBoundsException ( location , elementCount ) ; }
private List < QoSRule > createQoSRules ( JsonObject qosSettings ) { List < QoSRule > rules = new ArrayList < > ( ) ; if ( qosSettings . containsKey ( JSON_FIELD_RULES ) ) { JsonObject jsonRules = qosSettings . getJsonObject ( JSON_FIELD_RULES ) ; for ( String urlPatternRegExp : jsonRules . fieldNames ( ) ) { log . debug ( STR_ + urlPatternRegExp ) ; JsonObject jsonRule = jsonRules . getJsonObject ( urlPatternRegExp ) ; Pattern urlPattern = Pattern . compile ( urlPatternRegExp ) ; QoSRule rule = new QoSRule ( urlPattern ) ; boolean addRule = BOOL_ ; if ( jsonRule . containsKey ( STR_ ) ) { addRule = BOOL_ ; rule . setReject ( jsonRule . getDouble ( STR_ ) ) ; } if ( jsonRule . containsKey ( STR_ ) ) { addRule = BOOL_ ; rule . setWarn ( jsonRule . getDouble ( STR_ ) ) ; } if ( addRule ) { rules . add ( rule ) ; } else { log . warn ( STR_ , urlPatternRegExp ) ; } } } return rules ; }
private static final byte [ ] toOctets ( int identifier , String text ) { byte [ ] s = text . getBytes ( StandardCharsets . UTF_8 ) ; byte [ ] base = OctetUtils . toOctets ( AttributeType . VENDOR_SPECIFIC , identifier ) ; int maxTextSpace = Attribute . MAX_ATTRIBUTE_LENGTH - base . length ; byte [ ] octets ; if ( s . length > maxTextSpace ) { octets = new byte [ Attribute . MAX_ATTRIBUTE_LENGTH ] ; System . arraycopy ( s , NUM_ , octets , base . length , Attribute . MAX_ATTRIBUTE_LENGTH - base . length ) ; } else { octets = new byte [ base . length + s . length ] ; System . arraycopy ( s , NUM_ , octets , base . length , s . length ) ; } System . arraycopy ( base , NUM_ , octets , NUM_ , base . length ) ; octets [ NUM_ ] = ( byte ) octets . length ; return octets ; }
private Double formatDoubleValue ( Double value , int places ) { BigDecimal bd = new BigDecimal ( value ) ; bd = bd . setScale ( places , RoundingMode . HALF_UP ) ; return bd . doubleValue ( ) ; }
@ Override public void flush ( ) throws IOException { out . flush ( ) ; }
protected int moveOrCopyFiles ( boolean move , String what , File [ ] destFiles , File [ ] sourceFiles ) { int opCode = ( move ) ? OP_MOVE : OP_COPY ; mModifiedSrcFiles = ( move ) ? new ArrayList < String > ( ) : null ; mModifiedDestFiles = new ArrayList < String > ( ) ; openLogfile ( ) ; onPreProcess ( what , null , null , opCode ) ; int itemCount = NUM_ ; int pos = NUM_ ; int fileCount = destFiles . length ; while ( pos < fileCount ) { File sourceFile = sourceFiles [ pos ] ; File destFile = destFiles [ pos ] ; File destRenamed = renameDuplicate ( destFile ) ; if ( osFileMoveOrCopy ( move , destRenamed , sourceFile ) ) itemCount ++ ; log ( ( ( move ) ? STR_ : STR_ ) , getFilenameForLog ( sourceFile ) , STR_ , getFilenameForLog ( destRenamed ) ) ; File sourceSidecar = getSidecar ( sourceFile ) ; if ( osFileExists ( sourceSidecar ) ) { File destSidecar = getSidecar ( destRenamed ) ; if ( osFileMoveOrCopy ( move , destSidecar , sourceSidecar ) ) itemCount ++ ; log ( ( ( move ) ? STR_ : STR_ ) , getFilenameForLog ( sourceSidecar ) , STR_ , getFilenameForLog ( destSidecar ) ) ; } pos ++ ; } int modifyCount = mModifiedDestFiles . size ( ) ; String [ ] modifiedSourceFiles = ( ( mModifiedSrcFiles != null ) && ( mModifiedSrcFiles . size ( ) > NUM_ ) ) ? mModifiedSrcFiles . toArray ( new String [ modifyCount ] ) : null ; onPostProcess ( what , modifiedSourceFiles , ( modifyCount > NUM_ ) ? mModifiedDestFiles . toArray ( new String [ modifyCount ] ) : null , itemCount , sourceFiles . length , opCode ) ; closeLogFile ( ) ; return itemCount ; }
static boolean isCOctetStringValid ( String value , int maxLength ) { if ( value == null ) return BOOL_ ; if ( value . length ( ) >= maxLength ) return BOOL_ ; return BOOL_ ; }
public Rectangle2D createProperBounds ( double x1 , double y1 , double x2 , double y2 ) { double x = Math . min ( x1 , x2 ) ; double y = Math . min ( y1 , y2 ) ; double w = Math . abs ( x1 - x2 ) ; double h = Math . abs ( y1 - y2 ) ; return new Rectangle2D . Double ( x , y , w , h ) ; }
public void addClearGraphDataButton ( ) { JButton clearButton = new JButton ( STR_ ) ; clearButton . setAction ( RasterPlotActions . getClearGraphAction ( this ) ) ; buttonPanel . add ( clearButton ) ; }
public static float normalizedLevenshteinDistance ( String s , String t ) { float d = levenshteinDistance ( s , t ) ; int max = Math . max ( s . length ( ) , t . length ( ) ) ; return d / ( float ) max ; }
private void createFile ( int number , String extention ) { for ( int i = NUM_ ; i < number ; i ++ ) { try { BufferedWriter output = new BufferedWriter ( new FileWriter ( new File ( textInputFolder + STR_ + String . valueOf ( i ) + extention ) ) ) ; try { output . write ( STR_ ) ; output . write ( String . valueOf ( i ) ) ; } finally { output . close ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
public boolean isAnimal ( ) { return typeString . contains ( SUFFIX_ANIMAL ) ; }
public static String unifyLineSeparators ( String s , String ls ) { if ( s == null ) { return null ; } if ( ls == null ) { ls = System . getProperty ( STR_ ) ; } if ( ! ( ls . equals ( STR_ ) || ls . equals ( STR_ ) || ls . equals ( STR_ ) ) ) { throw new IllegalArgumentException ( STR_ ) ; } int length = s . length ( ) ; StringBuilder buffer = new StringBuilder ( length ) ; for ( int i = NUM_ ; i < length ; i ++ ) { if ( s . charAt ( i ) == STR_ ) { if ( ( i + NUM_ ) < length && s . charAt ( i + NUM_ ) == STR_ ) { i ++ ; } buffer . append ( ls ) ; } else if ( s . charAt ( i ) == STR_ ) { buffer . append ( ls ) ; } else { buffer . append ( s . charAt ( i ) ) ; } } return buffer . toString ( ) ; }
private void adjustNameAndPosition ( Node node , int deltaX , int deltaY ) { String originalName = node . getName ( ) ; String uniqueName = nextUniqueName ( originalName ) ; if ( ! uniqueName . equals ( originalName ) ) { node . setName ( uniqueName ) ; node . setCenterX ( node . getCenterX ( ) + deltaX ) ; node . setCenterY ( node . getCenterY ( ) + deltaY ) ; } }
public void addNotification ( PingNotification notification ) { notifications . add ( notification ) ; }
public List < Datastore > createNfsDatastore ( ClusterComputeResource cluster , FileShareRestRep fileSystem , FileSystemExportParam export , URI datacenterId , String datastoreName ) { addNfsDatastoreTag ( fileSystem , export , datacenterId , datastoreName ) ; List < Datastore > datastores = Lists . newArrayList ( ) ; String fileServer = StringUtils . substringBefore ( export . getMountPoint ( ) , STR_ ) ; String mountPath = StringUtils . substringAfter ( export . getMountPoint ( ) , STR_ ) ; for ( HostSystem host : cluster . getHosts ( ) ) { datastores . add ( execute ( new CreateNfsDatastore ( host , fileServer , mountPath , datastoreName ) ) ) ; addAffectedResource ( fileSystem ) ; ExecutionUtils . clearRollback ( ) ; } return datastores ; }
private void checkSize ( final int i ) { if ( i >= max_size ) { final int old_size = max_size ; max_size += increment_size ; if ( max_size <= i ) { max_size = i + increment_size + NUM_ ; } final String [ ] temp = items ; items = new String [ max_size ] ; System . arraycopy ( temp , NUM_ , items , NUM_ , old_size ) ; increment_size = incrementSize ( increment_size ) ; } }
public Album ( Context context , Uri mediaUri ) { super ( ) ; media . add ( NUM_ , new Media ( context , mediaUri ) ) ; setCurrentPhotoIndex ( NUM_ ) ; }
static void checkInternalName ( final String name , final int start , final int end , final String msg ) { int max = end == - NUM_ ? name . length ( ) : end ; try { int begin = start ; int slash ; do { slash = name . indexOf ( STR_ , begin + NUM_ ) ; if ( slash == - NUM_ || slash > max ) { slash = max ; } checkIdentifier ( name , begin , slash , null ) ; begin = slash + NUM_ ; } while ( slash != max ) ; } catch ( IllegalArgumentException unused ) { throw new IllegalArgumentException ( STR_ + msg + STR_ + name ) ; } }
protected void initializeTaskDone ( Set < TaskImageContainer > tasks , Optional < Runnable > runnableWhenDone ) { Set < CaptureSession > sessionSet = new HashSet < > ( ) ; Map < CaptureSession , Integer > sessionTaskCount = new HashMap < > ( ) ; for ( TaskImageContainer task : tasks ) { sessionSet . add ( task . mSession ) ; Integer currentCount = sessionTaskCount . get ( task . mSession ) ; if ( currentCount == null ) { sessionTaskCount . put ( task . mSession , NUM_ ) ; } else { sessionTaskCount . put ( task . mSession , currentCount + NUM_ ) ; } } synchronized ( mShadowTaskMap ) { for ( CaptureSession captureSession : sessionSet ) { BlockSignalProtocol protocol = new BlockSignalProtocol ( ) ; protocol . setCount ( sessionTaskCount . get ( captureSession ) ) ; final ImageShadowTask shadowTask ; shadowTask = new ImageShadowTask ( protocol , captureSession , runnableWhenDone ) ; mShadowTaskMap . put ( captureSession , shadowTask ) ; mProcessingTaskConsumer . enqueueTask ( shadowTask ) ; } } }
public void createCalibrationCharts ( String colorScheme , SortedMap < Integer , Integer [ ] > distanceTripMap , SortedMap < Integer , Integer [ ] > travelTimeTripMap , SortedMap < Integer , Integer [ ] > numberTripsPerMode , String path , String surveyName ) throws IOException { path = path . substring ( NUM_ , path . lastIndexOf ( STR_ ) ) + STR_ + path . substring ( path . lastIndexOf ( STR_ ) , path . length ( ) ) ; getSimulationData ( distanceTripMap , travelTimeTripMap , numberTripsPerMode ) ; simulationDistDataset . calculateSharesAndTotals ( ) ; simulationTTDataset . calculateSharesAndTotals ( ) ; commonColorScheme = colorScheme ; createModeShareStackedBarChart ( surveyName + STR_ , path + fileTripDistanceByModeBenchmark , surveyDistDataset , STR_ , STR_ ) ; createModeShareStackedBarChart ( STR_ , path + fileTripDistanceByModeSimulation , simulationDistDataset , STR_ , STR_ ) ; createModeShareComparisonChart ( STR_ + surveyName + STR_ , path + fileTripDistanceByModeComparison , simulationDistDataset , surveyDistDataset , STR_ , STR_ ) ; createCummulativeModeShareChart ( surveyName + STR_ , path + fileCumulativeTripDistanceByModeBenchmark , surveyDistDataset , STR_ , STR_ ) ; createCummulativeModeShareChart ( STR_ , path + fileCumulativeTripDistanceByModeSimulation , simulationDistDataset , STR_ , STR_ ) ; createCummulativeModeShareComparisonChart ( STR_ + surveyName + STR_ , path + fileCumulativeTripDistanceByModeComparison , simulationDistDataset , surveyDistDataset , STR_ , STR_ ) ; createModeShareStackedBarChart ( surveyName + STR_ , path + fileTripTTByModeBenchmark , surveyTTDataset , STR_ , STR_ ) ; createModeShareStackedBarChart ( STR_ , path + fileTripTTByModeSimulation , simulationTTDataset , STR_ , STR_ ) ; createModeShareComparisonChart ( STR_ + surveyName + STR_ , path + fileTripTTByModeComparison , simulationTTDataset , surveyTTDataset , STR_ , STR_ ) ; createCummulativeModeShareChart ( surveyName + STR_ , path + fileCumulativeTripTTByModeBenchmark , surveyTTDataset , STR_ , STR_ ) ; createCummulativeModeShareChart ( STR_ , path + fileCumModeshareTTSimulation , simulationTTDataset , STR_ , STR_ ) ; createCummulativeModeShareComparisonChart ( STR_ + surveyName + STR_ , path + fileCumModeshareTTComparison , simulationTTDataset , surveyTTDataset , STR_ , STR_ ) ; createModeShareHistoryChart ( STR_ , path . substring ( NUM_ , path . indexOf ( STR_ ) ) + fileModeshareHistory , modeShareHistoryDataset , STR_ , STR_ , surveyTTDataset ) ; }
public static String unquote ( String name ) { return isQuoted ( name ) ? name . substring ( NUM_ , name . length ( ) - NUM_ ) : name ; }
public boolean hasLeader ( String playerName ) { return ( leader != null ) && leader . equals ( playerName ) ; }
synchronized void redo ( RTEditText editor ) { Stack < Operation > redoStack = getRedoStack ( editor ) ; if ( ! redoStack . empty ( ) ) { Stack < Operation > undoStack = getUndoStack ( editor ) ; Operation op = redoStack . pop ( ) ; push ( op , undoStack ) ; op . redo ( editor ) ; while ( ! redoStack . empty ( ) && op . canMerge ( redoStack . peek ( ) ) ) { op = redoStack . pop ( ) ; push ( op , undoStack ) ; op . redo ( editor ) ; } } }
private static < T > T reportJoin ( Object r ) { if ( r instanceof AltResult ) { Throwable x ; if ( ( x = ( ( AltResult ) r ) . ex ) == null ) return null ; if ( x instanceof CancellationException ) throw ( CancellationException ) x ; if ( x instanceof CompletionException ) throw ( CompletionException ) x ; throw new CompletionException ( x ) ; } @ SuppressWarnings ( STR_ ) T t = ( T ) r ; return t ; }
public int write ( final Protein protein ) throws IOException { checkEntryHierarchy ( ) ; if ( entryHierarchy != null ) { for ( ProteinXref xref : protein . getCrossReferences ( ) ) { final SimpleProtein simpleProtein = SimpleProtein . valueOf ( protein , xref , entryHierarchy ) ; if ( simpleProtein != null ) { final SimpleHash model = buildModelMap ( simpleProtein , entryHierarchy ) ; Writer writer = null ; try { final Template temp = freeMarkerConfig . getTemplate ( freeMarkerTemplate ) ; checkTempDirectory ( tempDirectory ) ; if ( ! tempDirectory . endsWith ( File . separator ) ) { tempDirectory = tempDirectory + File . separator ; } UrlFriendlyIdGenerator gen = UrlFriendlyIdGenerator . getInstance ( ) ; String urlFriendlyId = gen . generate ( xref . getIdentifier ( ) ) ; final Path newResultFile = Paths . get ( tempDirectory + urlFriendlyId + STR_ ) ; resultFiles . add ( newResultFile ) ; writer = Files . newBufferedWriter ( newResultFile , characterSet ) ; temp . process ( model , writer ) ; writer . flush ( ) ; } catch ( TemplateException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( writer != null ) { writer . close ( ) ; } } } } } return NUM_ ; }
public void testCasts ( ) { String sql_begin = STR_ ; String [ ] [ ] sql_tests = new String [ ] [ ] { { STR_ , STR_ } , { STR_ , STR_ } , { STR_ , STR_ } , { STR_ , STR_ } , { STR_ , STR_ } , { STR_ , STR_ } , { STR_ , STR_ } } ; String sql_end = STR_ ; StringBuffer sql = new StringBuffer ( sql_begin ) ; StringBuffer sqle = new StringBuffer ( sql_begin ) ; for ( int i = NUM_ ; i < sql_tests . length ; i ++ ) { if ( i > NUM_ ) { sql . append ( STR_ ) ; sqle . append ( STR_ ) ; } sql . append ( sql_tests [ i ] [ NUM_ ] ) ; sqle . append ( sql_tests [ i ] [ NUM_ ] ) ; } sql . append ( sql_end ) ; sqle . append ( sql_end ) ; String [ ] r = convert . convert ( sql . toString ( ) ) ; assertEquals ( sqle . toString ( ) , r [ NUM_ ] ) ; }
private boolean saveMacro ( ) { if ( firstTime ) { try { Thread . sleep ( firstTimeSleep ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } firstTime = BOOL_ ; byte [ ] macroAccy = new byte [ macroSize ] ; int index = NUM_ ; int accyNum = NUM_ ; accyNum = getAccyRow ( macroAccy , index , textAccy1 , accyTextField1 , cmdButton1 ) ; if ( accyNum < NUM_ ) { return BOOL_ ; } if ( accyNum > NUM_ ) { index += NUM_ ; } accyNum = getAccyRow ( macroAccy , index , textAccy2 , accyTextField2 , cmdButton2 ) ; if ( accyNum < NUM_ ) { return BOOL_ ; } if ( accyNum > NUM_ ) { index += NUM_ ; } accyNum = getAccyRow ( macroAccy , index , textAccy3 , accyTextField3 , cmdButton3 ) ; if ( accyNum < NUM_ ) { return BOOL_ ; } if ( accyNum > NUM_ ) { index += NUM_ ; } accyNum = getAccyRow ( macroAccy , index , textAccy4 , accyTextField4 , cmdButton4 ) ; if ( accyNum < NUM_ ) { return BOOL_ ; } if ( accyNum > NUM_ ) { index += NUM_ ; } accyNum = getAccyRow ( macroAccy , index , textAccy5 , accyTextField5 , cmdButton5 ) ; if ( accyNum < NUM_ ) { return BOOL_ ; } if ( accyNum > NUM_ ) { index += NUM_ ; } accyNum = getAccyRow ( macroAccy , index , textAccy6 , accyTextField6 , cmdButton6 ) ; if ( accyNum < NUM_ ) { return BOOL_ ; } if ( accyNum > NUM_ ) { index += NUM_ ; } accyNum = getAccyRow ( macroAccy , index , textAccy7 , accyTextField7 , cmdButton7 ) ; if ( accyNum < NUM_ ) { return BOOL_ ; } if ( accyNum > NUM_ ) { index += NUM_ ; } if ( ! isUsb ) { accyNum = getAccyRow ( macroAccy , index , textAccy8 , accyTextField8 , cmdButton8 ) ; if ( accyNum < NUM_ ) { return BOOL_ ; } if ( accyNum > NUM_ ) { index += NUM_ ; } accyNum = getAccyRow ( macroAccy , index , textAccy9 , accyTextField9 , cmdButton9 ) ; if ( accyNum < NUM_ ) { return BOOL_ ; } if ( accyNum > NUM_ ) { index += NUM_ ; } } accyNum = getAccyRow ( macroAccy , index , textAccy10 , accyTextField10 , cmdButton10 ) ; if ( accyNum < NUM_ ) { JOptionPane . showMessageDialog ( this , rb . getString ( STR_ ) , rb . getString ( STR_ ) , JOptionPane . ERROR_MESSAGE ) ; return BOOL_ ; } processMemory ( BOOL_ , BOOL_ , macroNum , macroAccy ) ; return BOOL_ ; }
public void writeIntoSPTKLF0File ( String sptkFileName ) throws IOException { LEDataOutputStream lf0Data = new LEDataOutputStream ( new BufferedOutputStream ( new FileOutputStream ( sptkFileName ) ) ) ; for ( int i = NUM_ ; i < this . contour . length ; i ++ ) { double f0Val = contour [ i ] ; if ( contour [ i ] == NUM_ ) { lf0Data . writeFloat ( NEGATIVE_MAXIMUM ) ; } else { lf0Data . writeFloat ( ( float ) Math . log ( contour [ i ] ) ) ; } } lf0Data . flush ( ) ; lf0Data . close ( ) ; }
public static Thread start ( long timeout ) { return start ( Thread . currentThread ( ) , timeout ) ; }
public static Element find ( Node parent , String name ) { NodeList list = parent . getChildNodes ( ) ; for ( int i = NUM_ ; i < list . getLength ( ) ; i ++ ) { Node n = list . item ( i ) ; if ( n instanceof Element ) { Element e = ( Element ) n ; if ( name . equals ( e . getAttribute ( STR_ ) ) ) { return e ; } } Element r = find ( n , name ) ; if ( r != null ) { return r ; } } return null ; }
final boolean transferAfterCancelledWait ( Node node ) { if ( compareAndSetWaitStatus ( node , Node . CONDITION , NUM_ ) ) { enq ( node ) ; return BOOL_ ; } while ( ! isOnSyncQueue ( node ) ) Thread . yield ( ) ; return BOOL_ ; }
public static RE mkStar ( RE x ) { if ( x . equals ( epsilon ) || x . equals ( empty ) ) { return epsilon ; } RE res = new RE ( ReOp . STAR ) ; res . unaryArg = x ; return res ; }
public void remove ( final Object element ) { Set oldSelection = new HashSet ( selection ) ; boolean rv = selection . remove ( element ) ; if ( rv ) { fireSelectionChanged ( oldSelection , selection ) ; } oldSelection = null ; }
@ Override public void mouseClicked ( MouseEvent evt ) { delegate . mouseMoved ( evt ) ; }
public void printf ( Locale locale , String format , Object ... args ) { out . printf ( locale , format , args ) ; out . flush ( ) ; }
public void transform ( Source xmlSource , Result outputTarget ) throws TransformerException { transform ( xmlSource , outputTarget , BOOL_ ) ; }
public void testSortsAttributesBeforeElements ( ) throws Exception { XppDom dom1 = XppFactory . buildDom ( STR_ ) ; XppDom dom2 = XppFactory . buildDom ( STR_ ) ; assertEquals ( - NUM_ , comparator . compare ( dom1 , dom2 ) ) ; assertEquals ( STR_ , xpath . get ( ) ) ; assertEquals ( NUM_ , comparator . compare ( dom2 , dom1 ) ) ; assertEquals ( STR_ , xpath . get ( ) ) ; }
public void addSuffix ( DalvInsn insn ) { suffix . add ( insn ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( NUM_ ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return newVector . elements ( ) ; }
private void closeSelector ( ) { if ( selector . isOpen ( ) ) { if ( log . isDebugEnabled ( ) ) log . debug ( STR_ ) ; for ( SelectionKey key : selector . keys ( ) ) U . close ( key . channel ( ) , log ) ; if ( log . isDebugEnabled ( ) ) log . debug ( STR_ ) ; U . close ( selector , log ) ; } }
public static Number sub ( Number a , Number b ) { if ( isFloatingPoint ( a ) || isFloatingPoint ( b ) ) { return a . doubleValue ( ) - b . doubleValue ( ) ; } else { return a . longValue ( ) - b . longValue ( ) ; } }
public Builder requiredAttributes ( final String ... nameOrOIDs ) { return requiredAttributes ( Arrays . asList ( nameOrOIDs ) ) ; }
private void showHistoryDialog ( ) { JBList commandsList = new JBList ( HistoryUtils . getCommandsFromHistory ( ) ) ; commandsList . setCellRenderer ( new HistoryListCellRenderer ( ) ) ; commandsList . setEmptyText ( STR_ ) ; commandsList . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; String [ ] buttons = { STR_ , STR_ } ; int result = JOptionPane . showOptionDialog ( toolWindowContent , commandsList , STR_ , JOptionPane . YES_NO_CANCEL_OPTION , JOptionPane . PLAIN_MESSAGE , null , buttons , buttons [ NUM_ ] ) ; if ( result == NUM_ ) { updateUiFromCommand ( ( Command ) commandsList . getSelectedValue ( ) ) ; } }
public int size ( ) { return count . get ( ) ; }
protected static byte [ ] read ( InputStream is ) throws IOException { final boolean close = BOOL_ ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; try { int i ; while ( ( i = is . read ( ) ) != - NUM_ ) { baos . write ( i ) ; } } finally { try { if ( close ) { is . close ( ) ; } baos . close ( ) ; } catch ( Exception ex ) { log . warn ( STR_ + ex , ex ) ; } } return baos . toByteArray ( ) ; }
public static < T > Streamable < T > fromPublisher ( final Publisher < ? extends T > publisher ) { Objects . requireNonNull ( publisher ) ; final SeqSubscriber < T > sub = SeqSubscriber . subscriber ( ) ; publisher . subscribe ( sub ) ; return fromStream ( sub . stream ( ) ) ; }
public ProtobufConnection ( Listener < MessageType > handler , MessageType prototype , int maxMessageSize , int timeoutMillis ) { this . handler = handler ; this . prototype = prototype ; this . maxMessageSize = Math . min ( maxMessageSize , Integer . MAX_VALUE - NUM_ ) ; setTimeoutEnabled ( BOOL_ ) ; setSocketTimeout ( timeoutMillis ) ; }
private Response < Bitmap > doParse ( NetworkResponse response ) { byte [ ] data = response . data ; BitmapFactory . Options decodeOptions = new BitmapFactory . Options ( ) ; Bitmap bitmap = null ; if ( mMaxWidth == NUM_ && mMaxHeight == NUM_ ) { decodeOptions . inPreferredConfig = mDecodeConfig ; bitmap = BitmapFactory . decodeByteArray ( data , NUM_ , data . length , decodeOptions ) ; } else { decodeOptions . inJustDecodeBounds = BOOL_ ; BitmapFactory . decodeByteArray ( data , NUM_ , data . length , decodeOptions ) ; int actualWidth = decodeOptions . outWidth ; int actualHeight = decodeOptions . outHeight ; int desiredWidth = getResizedDimension ( mMaxWidth , mMaxHeight , actualWidth , actualHeight , mScaleType ) ; int desiredHeight = getResizedDimension ( mMaxHeight , mMaxWidth , actualHeight , actualWidth , mScaleType ) ; decodeOptions . inJustDecodeBounds = BOOL_ ; decodeOptions . inSampleSize = findBestSampleSize ( actualWidth , actualHeight , desiredWidth , desiredHeight ) ; Bitmap tempBitmap = BitmapFactory . decodeByteArray ( data , NUM_ , data . length , decodeOptions ) ; if ( tempBitmap != null && ( tempBitmap . getWidth ( ) > desiredWidth || tempBitmap . getHeight ( ) > desiredHeight ) ) { bitmap = Bitmap . createScaledBitmap ( tempBitmap , desiredWidth , desiredHeight , BOOL_ ) ; tempBitmap . recycle ( ) ; } else { bitmap = tempBitmap ; } } if ( bitmap == null ) { return Response . error ( new ParseError ( response ) ) ; } else { return Response . success ( bitmap , HttpHeaderParser . parseCacheHeaders ( response ) ) ; } }
public Notification find ( Integer notificationID ) { Notification notification = new Notification ( context , notificationID , null ) ; if ( notification . getAttributes ( ) == null ) notification . loadAttributesFromPreferences ( ) ; return notification ; }
public GreenGradient ( int maxCount ) { this . maxCount = maxCount ; factor = maxCount / Math . log ( maxCount ) ; }
public static void writeHistogram ( TDoubleDoubleHashMap distr , String filename ) throws FileNotFoundException , IOException { BufferedWriter aWriter = IOUtils . getBufferedWriter ( filename ) ; aWriter . write ( STR_ ) ; aWriter . newLine ( ) ; double [ ] keys = distr . keys ( ) ; Arrays . sort ( keys ) ; for ( double key : keys ) { aWriter . write ( String . valueOf ( key ) ) ; aWriter . write ( STR_ ) ; aWriter . write ( String . valueOf ( distr . get ( key ) ) ) ; aWriter . newLine ( ) ; } aWriter . close ( ) ; }
public static < T > CompletionStage < T > dereference ( CompletionStage < ? extends CompletionStage < T > > stage ) { return stage . thenCompose ( Identity . INSTANCE ) ; }
public static Number plus ( Character left , Number right ) { return NumberNumberPlus . plus ( Integer . valueOf ( left ) , right ) ; }
public static String clipStringIfNecessary ( JComponent c , FontMetrics fm , String string , int availTextWidth ) { if ( ( string == null ) || ( string . equals ( STR_ ) ) ) { return STR_ ; } int textWidth = SwingUtilities2 . stringWidth ( c , fm , string ) ; if ( textWidth > availTextWidth ) { return SwingUtilities2 . clipString ( c , fm , string , availTextWidth ) ; } return string ; }
public boolean removeElement ( Object obj ) { synchronized ( actions ) { if ( allowToChange ) { boolean result = actions . remove ( obj ) ; if ( actions . isEmpty ( ) ) { if ( headTask != null ) { cancel ( ) ; } } return result ; } } return BOOL_ ; }
public static boolean isCglibProxy ( Object object ) { return ClassUtils . isCglibProxyClass ( object . getClass ( ) ) ; }
public void resetReferences ( ) { if ( _refs != null ) _refs . clear ( ) ; }
public void addSlide ( @ NonNull Fragment fragment ) { fragments . add ( fragment ) ; addBackgroundColor ( Color . TRANSPARENT ) ; pagerAdapter . notifyDataSetChanged ( ) ; }
public static String [ ] wrapString ( @ Nonnull String str , int maxWidth , @ Nullable String [ ] output ) { if ( output == null ) { output = new String [ ( int ) ( ( str . length ( ) / maxWidth ) . NUM_ + NUM_ ) ] ; } int lineStart = NUM_ ; int arrayIndex = NUM_ ; int i ; for ( i = NUM_ ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; if ( c == STR_ ) { output = addString ( output , str . substring ( lineStart , i ) , arrayIndex ++ ) ; lineStart = i + NUM_ ; } else if ( i - lineStart == maxWidth ) { output = addString ( output , str . substring ( lineStart , i ) , arrayIndex ++ ) ; lineStart = i ; } } if ( lineStart != i || i == NUM_ ) { output = addString ( output , str . substring ( lineStart ) , arrayIndex ++ , output . length + NUM_ ) ; } if ( arrayIndex < output . length ) { output [ arrayIndex ] = null ; } return output ; }
public void removeChangingListener ( OnWheelChangedListener listener ) { changingListeners . remove ( listener ) ; }
private static FloatBuffer createVertexArray ( float [ ] coords ) { ByteBuffer bb = ByteBuffer . allocateDirect ( coords . length . NUM_ ) ; bb . order ( ByteOrder . nativeOrder ( ) ) ; FloatBuffer fb = bb . asFloatBuffer ( ) ; fb . put ( coords ) ; fb . position ( NUM_ ) ; return fb ; }
protected void publish ( ) throws MqttException , IOException { sampleClientPub = new SampleAsyncWait ( url , clientIdPub , cleanSession , quietMode , userName , password ) ; if ( sampleClientPub != null ) { String topic = STR_ ; int qos = NUM_ ; String message = STR_ ; try { sampleClientPub . publish ( topic , qos , message . getBytes ( ) ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; } } }
public static void cleanDirectory ( File directory ) throws IOException { if ( ! directory . exists ( ) ) { String message = directory + STR_ ; throw new IllegalArgumentException ( message ) ; } if ( ! directory . isDirectory ( ) ) { String message = directory + STR_ ; throw new IllegalArgumentException ( message ) ; } File [ ] files = directory . listFiles ( ) ; if ( files == null ) { throw new IOException ( STR_ + directory ) ; } IOException exception = null ; for ( File file : files ) { try { forceDelete ( file ) ; } catch ( IOException ioe ) { exception = ioe ; } } if ( null != exception ) { throw exception ; } }
private Object [ ] invWmSubBand ( Image img , double [ ] wm , int n , double threshold ) { int m = NUM_ ; double z = NUM_ ; double v = NUM_ ; for ( int i = NUM_ ; i < img . getWidth ( ) . img . getHeight ( ) ; i ++ ) { if ( img . getData ( ) [ i ] > threshold ) { z += ( img . getData ( ) [ i ] . wm [ i % n ] ) ; v += Math . abs ( img . getData ( ) [ i ] ) ; m ++ ; } } return new Object [ ] { m , z , v } ; }
public static void moveToDirectory ( File src , File destDir , boolean createDestDir ) throws IOException { if ( src == null ) { throw new NullPointerException ( STR_ ) ; } if ( destDir == null ) { throw new NullPointerException ( STR_ ) ; } if ( ! src . exists ( ) ) { throw new FileNotFoundException ( STR_ + src + STR_ ) ; } if ( src . isDirectory ( ) ) { moveDirectoryToDirectory ( src , destDir , createDestDir ) ; } else { moveFileToDirectory ( src , destDir , createDestDir ) ; } }
private static TungstenProperties loadSecurityPropertiesFromFile ( String propertiesFileLocation ) throws ConfigurationException { TungstenProperties securityProps = null ; FileInputStream securityConfigurationFileInputStream = null ; if ( propertiesFileLocation == null && ClusterConfiguration . getClusterHome ( ) == null ) { throw new ConfigurationException ( STR_ ) ; } File securityPropertiesFile ; if ( propertiesFileLocation == null ) { File clusterConfDirectory = ClusterConfiguration . getDir ( ClusterConfiguration . getGlobalConfigDirName ( ClusterConfiguration . getClusterHome ( ) ) ) ; securityPropertiesFile = new File ( clusterConfDirectory . getPath ( ) , SecurityConf . SECURITY_PROPERTIES_FILE_NAME ) ; } else { securityPropertiesFile = new File ( propertiesFileLocation ) ; } try { securityProps = new TungstenProperties ( ) ; securityConfigurationFileInputStream = new FileInputStream ( securityPropertiesFile ) ; securityProps . load ( securityConfigurationFileInputStream , BOOL_ ) ; closeSecurityConfigurationFileInputStream ( securityConfigurationFileInputStream ) ; } catch ( FileNotFoundException e ) { String msg = MessageFormat . format ( STR_ , securityPropertiesFile . getPath ( ) ) ; logger . debug ( msg , e ) ; throw new ConfigurationException ( msg ) ; } catch ( IOException e ) { String msg = MessageFormat . format ( STR_ , securityPropertiesFile . getPath ( ) , e . getMessage ( ) ) ; logger . debug ( msg , e ) ; throw new ConfigurationException ( msg ) ; } finally { closeSecurityConfigurationFileInputStream ( securityConfigurationFileInputStream ) ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( MessageFormat . format ( STR_ , securityPropertiesFile . getPath ( ) ) ) ; } securityProps . put ( SecurityConf . SECURITY_PROPERTIES_PARENT_FILE_LOCATION , securityPropertiesFile . getAbsolutePath ( ) ) ; return securityProps ; }
public static void close ( InputStream in ) { try { if ( in != null ) { in . close ( ) ; } } catch ( IOException ioE ) { } }
private synchronized void clearScanFiles ( ) { if ( ( allFiles != null ) && ( allFiles . size ( ) > NUM_ ) ) { Iterator it = allFiles . iterator ( ) ; File file = null ; while ( it . hasNext ( ) ) { file = ( File ) it . next ( ) ; file . delete ( ) ; } allFiles . clear ( ) ; } }
private static boolean intersectsLatEdge ( S2Point a , S2Point b , double lat , S1Interval lng ) { S2Point z = S2Point . normalize ( S2 . robustCrossProd ( a , b ) ) ; if ( z . z < NUM_ ) { z = S2Point . neg ( z ) ; } S2Point y = S2Point . normalize ( S2 . robustCrossProd ( z , new S2Point ( NUM_ , NUM_ , NUM_ ) ) ) ; S2Point x = S2Point . crossProd ( y , z ) ; double sinLat = Math . sin ( lat ) ; if ( Math . abs ( sinLat ) >= x . z ) { return BOOL_ ; } double cosTheta = sinLat / x . z ; double sinTheta = Math . sqrt ( NUM_ - cosTheta . cosTheta ) ; double theta = Math . atan2 ( sinTheta , cosTheta ) ; S1Interval abTheta = S1Interval . fromPointPair ( Math . atan2 ( a . dotProd ( y ) , a . dotProd ( x ) ) , Math . atan2 ( b . dotProd ( y ) , b . dotProd ( x ) ) ) ; if ( abTheta . contains ( theta ) ) { S2Point isect = S2Point . add ( S2Point . mul ( x , cosTheta ) , S2Point . mul ( y , sinTheta ) ) ; if ( lng . contains ( Math . atan2 ( isect . y , isect . x ) ) ) { return BOOL_ ; } } if ( abTheta . contains ( - theta ) ) { S2Point intersection = S2Point . sub ( S2Point . mul ( x , cosTheta ) , S2Point . mul ( y , sinTheta ) ) ; if ( lng . contains ( Math . atan2 ( intersection . y , intersection . x ) ) ) { return BOOL_ ; } } return BOOL_ ; }
public static void execAndCheckOutput ( ProcessBuilder builder , String expectedOut , String expectedErr ) throws Exception { Process process = builder . start ( ) ; ExecutorService executorService = Executors . newFixedThreadPool ( NUM_ ) ; try { Future < String > errFuture = executorService . submit ( streamToStringCallable ( process . getErrorStream ( ) ) ) ; Future < String > outFuture = executorService . submit ( streamToStringCallable ( process . getInputStream ( ) ) ) ; assertEquals ( expectedOut , outFuture . get ( NUM_ , TimeUnit . SECONDS ) ) ; assertEquals ( expectedErr , errFuture . get ( NUM_ , TimeUnit . SECONDS ) ) ; } finally { executorService . shutdown ( ) ; process . waitFor ( ) ; } }
private void startFileBasedMerge ( ) throws CarbonSortKeyAndGroupByException { try { executorService . shutdown ( ) ; executorService . awaitTermination ( NUM_ , TimeUnit . DAYS ) ; dataSorterAndWriterExecutorService . shutdown ( ) ; dataSorterAndWriterExecutorService . awaitTermination ( NUM_ , TimeUnit . DAYS ) ; } catch ( InterruptedException e ) { throw new CarbonSortKeyAndGroupByException ( STR_ , e ) ; } }
public void insertUpdate ( DocumentEvent e ) { if ( ! dirty ) { setDirty ( BOOL_ ) ; } }
public DateTimeParseException ( String message , CharSequence parsedData , int errorIndex ) { super ( message ) ; this . parsedString = parsedData . toString ( ) ; this . errorIndex = errorIndex ; }
private boolean areParallelSiblings ( Component source , Component target , int axis ) { ComponentInfo sourceInfo = getComponentInfo ( source ) ; ComponentInfo targetInfo = getComponentInfo ( target ) ; Spring sourceSpring ; Spring targetSpring ; if ( axis == HORIZONTAL ) { sourceSpring = sourceInfo . horizontalSpring ; targetSpring = targetInfo . horizontalSpring ; } else { sourceSpring = sourceInfo . verticalSpring ; targetSpring = targetInfo . verticalSpring ; } ArrayList sourcePath = tmpParallelSet ; sourcePath . clear ( ) ; Spring spring = sourceSpring . getParent ( ) ; while ( spring != null ) { sourcePath . add ( spring ) ; spring = spring . getParent ( ) ; } spring = targetSpring . getParent ( ) ; while ( spring != null ) { if ( sourcePath . contains ( spring ) ) { sourcePath . clear ( ) ; while ( spring != null ) { if ( spring instanceof ParallelGroup ) { return BOOL_ ; } spring = spring . getParent ( ) ; } return BOOL_ ; } spring = spring . getParent ( ) ; } sourcePath . clear ( ) ; return BOOL_ ; }
protected Object readObjectImpl ( Class cl ) throws IOException { try { Object obj = cl . newInstance ( ) ; if ( _refs == null ) _refs = new ArrayList ( ) ; _refs . add ( obj ) ; HashMap fieldMap = getFieldMap ( cl ) ; int code = read ( ) ; for ( ; code >= NUM_ && code != STR_ ; code = read ( ) ) { unread ( ) ; Object key = readObject ( ) ; Field field = ( Field ) fieldMap . get ( key ) ; if ( field != null ) { Object value = readObject ( field . getType ( ) ) ; field . set ( obj , value ) ; } else { Object value = readObject ( ) ; } } if ( code != STR_ ) throw expect ( STR_ , code ) ; try { Method method = cl . getMethod ( STR_ , new Class [ NUM_ ] ) ; return method . invoke ( obj , new Object [ NUM_ ] ) ; } catch ( Exception e ) { } return obj ; } catch ( IOException e ) { throw e ; } catch ( Exception e ) { throw new IOExceptionWrapper ( e ) ; } }
public void testCase18 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ } ; byte bBytes [ ] = { NUM_ } ; byte rBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ } ; int aSign = NUM_ ; int bSign = NUM_ ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . subtract ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( NUM_ , result . signum ( ) ) ; }
protected static Pair < String , String > lsrImmediate ( final long offset , final ITranslationEnvironment environment , final List < ReilInstruction > instructions , final String registerNodeValue , final String immediateNodeValue ) { final String shifterOperand = environment . getNextVariableString ( ) ; final String shifterCarryOut = environment . getNextVariableString ( ) ; long baseOffset = offset ; if ( immediateNodeValue . equals ( STR_ ) ) { final String tmpVar1 = environment . getNextVariableString ( ) ; instructions . add ( ReilHelpers . createBsh ( baseOffset ++ , dWordSize , registerNodeValue , wordSize , minusThirtyOneSet , wordSize , tmpVar1 ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , wordSize , tmpVar1 , byteSize , oneSet , byteSize , shifterCarryOut ) ) ; return new Pair < String , String > ( String . valueOf ( NUM_ ) , shifterCarryOut ) ; } else { final String tmpVar1 = environment . getNextVariableString ( ) ; final String tmpVar2 = environment . getNextVariableString ( ) ; instructions . add ( ReilHelpers . createBsh ( baseOffset ++ , dWordSize , registerNodeValue , wordSize , STR_ + immediateNodeValue , qWordSize , tmpVar1 ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , qWordSize , tmpVar1 , dWordSize , bitMaskAllBitsSet , dWordSize , shifterOperand ) ) ; instructions . add ( ReilHelpers . createBsh ( baseOffset ++ , dWordSize , registerNodeValue , wordSize , String . valueOf ( - ( Integer . decode ( immediateNodeValue ) - NUM_ ) ) , dWordSize , tmpVar2 ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , dWordSize , tmpVar2 , byteSize , oneSet , byteSize , shifterCarryOut ) ) ; return new Pair < String , String > ( shifterOperand , shifterCarryOut ) ; } }
public static PlainText plain ( int text ) { return plain ( Integer . toString ( text ) ) ; }
private float clampMag ( float value , float absMin , float absMax ) { final float absValue = Math . abs ( value ) ; if ( absValue < absMin ) return NUM_ ; if ( absValue > absMax ) return value > NUM_ ? absMax : - absMax ; return value ; }
public static boolean isToday ( Calendar _calendar ) { Calendar now = Calendar . getInstance ( ) ; if ( now . get ( Calendar . DAY_OF_MONTH ) == _calendar . get ( Calendar . DAY_OF_MONTH ) ) { if ( now . get ( Calendar . MONTH ) == _calendar . get ( Calendar . MONTH ) ) { if ( now . get ( Calendar . YEAR ) == _calendar . get ( Calendar . YEAR ) ) { return BOOL_ ; } } } return BOOL_ ; }
public void start ( ) { managedPairs . add ( createPort ( ) ) ; fixNames ( ) ; singlePorts . addObserver ( observer , BOOL_ ) ; for ( Ports < M > ports : multiPortsList ) { ports . addObserver ( observer , BOOL_ ) ; } }
protected void sprint ( double doubleField ) { sprint ( String . valueOf ( doubleField ) ) ; }
public static Bitmap convertYuvImageToBitmap ( @ NonNull final YuvImage yuvImage ) { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; yuvImage . compressToJpeg ( new Rect ( NUM_ , NUM_ , yuvImage . getWidth ( ) , yuvImage . getHeight ( ) ) , NUM_ , out ) ; byte [ ] imageBytes = out . toByteArray ( ) ; try { out . close ( ) ; } catch ( IOException e ) { Log . e ( LOG_TAG , STR_ , e ) ; } return BitmapFactory . decodeByteArray ( imageBytes , NUM_ , imageBytes . length ) ; }
public Double read ( String value ) { return Double . valueOf ( value ) ; }
public boolean hasFeature ( String feature , String version ) { if ( feature . equals ( STR_ ) ) { return version == null || version . equals ( STR_ ) || version . equals ( STR_ ) ; } return BOOL_ ; }
private StoragePort assignPortBasedOnUsage ( List < StoragePort > matchingTargetPorts , Map < StoragePort , Integer > portUsage ) { StoragePort foundPort = null ; for ( StoragePort matchedPort : matchingTargetPorts ) { if ( portUsage . get ( matchedPort ) == null ) { portUsage . put ( matchedPort , NUM_ ) ; } if ( foundPort == null ) { foundPort = matchedPort ; } else { if ( portUsage . get ( matchedPort ) < portUsage . get ( foundPort ) ) { foundPort = matchedPort ; } } } if ( foundPort != null ) { portUsage . put ( foundPort , portUsage . get ( foundPort ) + NUM_ ) ; } return foundPort ; }
public ExternalEvent nextEvent ( ) { if ( queue . size ( ) == NUM_ ) { return new ExternalEvent ( Double . MAX_VALUE ) ; } ExternalEvent ee = queue . get ( nextEventIndex ) ; nextEventIndex ++ ; if ( nextEventIndex >= queue . size ( ) ) { queue = readEvents ( nrofPreload ) ; nextEventIndex = NUM_ ; } return ee ; }
public void appendToBuffer ( StringBuilder buf ) { Iterator < double [ ] > iter = points . iterator ( ) ; while ( iter . hasNext ( ) ) { double [ ] data = iter . next ( ) ; for ( int i = NUM_ ; i < data . length ; i ++ ) { if ( i > NUM_ ) { buf . append ( STR_ ) ; } buf . append ( data [ i ] ) ; } if ( iter . hasNext ( ) ) { buf . append ( STR_ ) ; } } }
public void updateComboBox ( JComboBox < Track > box ) { box . removeAllItems ( ) ; box . addItem ( null ) ; List < Track > tracks = getTrackByNameList ( null ) ; for ( Track track : tracks ) { box . addItem ( track ) ; } }
public RefactoringSessionTransformer ( final boolean projects ) { fProjects = projects ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( NUM_ ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return newVector . elements ( ) ; }
public CompareResult open ( ) { final ContentComparator [ ] comparatorArray = comparators . toArray ( new ContentComparator [ comparators . size ( ) ] ) ; final CustomCompareEditorInput input = new CustomCompareEditorInput ( modified , original , ancestor , comparatorArray , compareConfiguration , externalCompareHandler ) ; if ( compareConfiguration . isLeftEditable ( ) || compareConfiguration . isRightEditable ( ) ) { compareConfiguration . setProperty ( STR_ , Boolean . FALSE ) ; input . setAlwaysDirty ( alwaysDirty ) ; } input . addSaveListener ( new ProxyCompareSaveListener ( ) ) ; log . info ( MessageFormat . format ( STR_ , getLabelNOLOC ( modified ) , getLabelNOLOC ( original ) ) ) ; compareUIType . openCompareUI ( input ) ; final boolean contentsIdentical = ( input . getCompareResult ( ) == null ) ; final boolean contentsSaved = ( input . getSavedContents ( ) . length > NUM_ ) ; return new CompareResult ( contentsIdentical , input . wasOKPressed ( ) , contentsSaved ) ; }
protected void engineSetMode ( String mode ) { if ( ! mode . equalsIgnoreCase ( STR_ ) ) { throw new IllegalArgumentException ( STR_ + mode ) ; } }
protected void addResource ( String resource ) { if ( ! StringUtils . isEmpty ( resource ) ) { resources . add ( resource ) ; } }
public static boolean isNumeric ( String maybeNumeric ) { return maybeNumeric != null && maybeNumeric . matches ( STR_ ) ; }
public void openKeyStore ( File keyStoreFile , String defaultPassword ) { try { if ( ! keyStoreFile . isFile ( ) ) { JOptionPane . showMessageDialog ( frame , MessageFormat . format ( res . getString ( STR_ ) , keyStoreFile ) , res . getString ( STR_ ) , JOptionPane . WARNING_MESSAGE ) ; return ; } if ( isKeyStoreFileOpen ( keyStoreFile ) ) { JOptionPane . showMessageDialog ( frame , MessageFormat . format ( res . getString ( STR_ ) , keyStoreFile ) , res . getString ( STR_ ) , JOptionPane . WARNING_MESSAGE ) ; return ; } Password password = ( defaultPassword != null ) ? new Password ( defaultPassword . toCharArray ( ) ) : null ; KeyStore openedKeyStore = null ; boolean firstTry = BOOL_ ; while ( BOOL_ ) { if ( password == null ) { password = showPasswordDialog ( keyStoreFile ) ; } if ( password == null ) { return ; } try { openedKeyStore = KeyStoreUtil . load ( keyStoreFile , password ) ; break ; } catch ( KeyStoreLoadException klex ) { if ( defaultPassword == null || ! firstTry ) { int tryAgainChoice = showErrorMessage ( keyStoreFile , klex ) ; if ( tryAgainChoice == JOptionPane . NO_OPTION ) { return ; } } } password . nullPassword ( ) ; password = null ; firstTry = BOOL_ ; } if ( openedKeyStore == null ) { JOptionPane . showMessageDialog ( frame , MessageFormat . format ( res . getString ( STR_ ) , keyStoreFile . getName ( ) ) , res . getString ( STR_ ) , JOptionPane . WARNING_MESSAGE ) ; return ; } kseFrame . addKeyStore ( openedKeyStore , keyStoreFile , password ) ; } catch ( FileNotFoundException ex ) { JOptionPane . showMessageDialog ( frame , MessageFormat . format ( res . getString ( STR_ ) , keyStoreFile ) , res . getString ( STR_ ) , JOptionPane . WARNING_MESSAGE ) ; } catch ( Exception ex ) { DError . displayError ( frame , ex ) ; } }
public static String encode ( String string ) { byte [ ] bytes ; try { bytes = string . getBytes ( PREFERRED_ENCODING ) ; } catch ( UnsupportedEncodingException e ) { bytes = string . getBytes ( ) ; } return encodeBytes ( bytes ) ; }
public final long addAndGet ( long delta ) { for ( ; ; ) { long current = get ( ) ; long next = current + delta ; if ( compareAndSet ( current , next ) ) return next ; } }
default long now ( TimeUnit unit ) { return unit . convert ( System . currentTimeMillis ( ) , TimeUnit . MILLISECONDS ) ; }
private final void append ( List < ? super NameValuePair > l , final String k , final String v ) { if ( v != null ) l . add ( new NameValuePair ( k , v ) ) ; }
protected Properties createProperties ( URL location ) throws IOException { InputStream is = null ; if ( location != null ) { is = location . openStream ( ) ; } Properties tmpProperties = new Properties ( ) ; if ( is != null ) { tmpProperties . load ( is ) ; } return tmpProperties ; }
public static boolean isExtension ( String filename , Collection < String > extensions ) { if ( filename == null ) { return BOOL_ ; } if ( extensions == null || extensions . isEmpty ( ) ) { return indexOfExtension ( filename ) == - NUM_ ; } String fileExt = getExtension ( filename ) ; for ( String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return BOOL_ ; } } return BOOL_ ; }
void findValue ( ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + label ( ) ) ; } for ( int i = NUM_ ; i < _value . getItemCount ( ) ; i ++ ) { String choice = _value . getItemAt ( i ) ; SettingList sl = choiceHash . get ( choice ) ; if ( sl . match ( ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + i ) ; } _value . setSelectedItem ( choice ) ; return ; } } if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ ) ; } }
public java . lang . StringBuilder insert ( int index , java . lang . String string ) { if ( string == null ) { string = STR_ ; } int min = string . length ( ) ; if ( min != NUM_ ) { move ( min , index ) ; string . getChars ( NUM_ , min , value , index ) ; count += min ; } return this ; }
public void mkdir ( String key ) throws IOException { key = key . replace ( STR_ , STR_ ) ; if ( key . endsWith ( STR_ ) && ! key . equals ( STR_ ) ) { throw new InvalidParameterException ( STR_ ) ; } String [ ] split = key . split ( STR_ ) ; StringBuilder builder = new StringBuilder ( ) ; for ( String s : split ) { builder . append ( s ) ; if ( ! s . isEmpty ( ) && ! exists ( builder . toString ( ) ) ) { zkState . set ( builder . toString ( ) , null ) ; } builder . append ( STR_ ) ; } }
public double calculateLog ( double value ) { return Math . log ( value ) / this . baseLog ; }
public static Vector3 pow ( Vector3 o , double power ) { return new Vector3 ( Math . pow ( o . x , power ) , Math . pow ( o . y , power ) , Math . pow ( o . z , power ) ) ; }
public DatagramPacket responseReceive ( ) throws IOException { byte [ ] buf = new byte [ NUM_ ] ; DatagramPacket dp = new DatagramPacket ( buf , buf . length ) ; datagramSocket . receive ( dp ) ; return dp ; }
@ After public void tearDown ( ) { webClient . closeAllWindows ( ) ; }
@ Override public void flush ( ) { flush ( BOOL_ ) ; }
public static float [ ] temperatureToRGB ( int degreesK ) { int k = MathUtils . constrain ( degreesK , NUM_ , NUM_ ) ; float a = ( k % NUM_ ) / NUM_ ; int i = ( ( k - NUM_ ) / NUM_ ) . NUM_ ; return new float [ ] { interp ( i , a ) , interp ( i + NUM_ , a ) , interp ( i + NUM_ , a ) } ; }
public AdvancedStateMap . Builder withName ( Function < PropertiesMap , String > mapper ) { this . nameMapper = mapper ; return this ; }
public synchronized void message ( LocoNetMessage m ) { int opCode = m . getOpCode ( ) ; switch ( opCode ) { case LnConstants . OPC_PEER_XFER : int src = m . getElement ( NUM_ ) ; int dst = m . getElement ( NUM_ ) + m . getElement ( NUM_ ) . NUM_ ; int [ ] packet = m . getPeerXfrData ( ) ; if ( src == lowPart ( LocoBufferAddress ) ) { String lbv = ( ( packet [ NUM_ ] != NUM_ ) ? dotme ( packet [ NUM_ ] ) : STR_ ) ; setLBVersion ( lbv ) ; } if ( dst == LocoBufferAddress && src == lowPart ( unitAddress ) && ( packet [ NUM_ ] == unitSubAddress ) ) { stopTimer ( ) ; replyReceived ( ) ; String fw = ( ( packet [ NUM_ ] != NUM_ ) ? dotme ( packet [ NUM_ ] ) : STR_ ) ; setLIOVersion ( fw ) ; if ( packet [ NUM_ ] == LocoIO . LOCOIO_SV_READ || reading ) { if ( lastOpCv >= NUM_ && lastOpCv <= NUM_ ) { int data = ( packet [ NUM_ ] != NUM_ ) ? packet [ NUM_ ] : packet [ NUM_ ] ; int channel = ( lastOpCv / NUM_ ) - NUM_ ; if ( channel < NUM_ ) { log . warn ( STR_ ) ; channel = NUM_ ; } int type = lastOpCv - ( channel . NUM_ + NUM_ ) ; log . debug ( STR_ + channel + STR_ + type + STR_ + ( type == NUM_ ? STR_ : type == NUM_ ? STR_ : type == NUM_ ? STR_ : STR_ ) + STR_ + Integer . toHexString ( data ) ) ; if ( type == NUM_ ) { setV2 ( channel , data ) ; setMode ( channel , STR_ ) ; } else if ( type == NUM_ ) { setV1 ( channel , data ) ; setMode ( channel , STR_ ) ; } else if ( type == NUM_ ) { setSV ( channel , data ) ; LocoIOMode lim = validmodes . getLocoIOModeFor ( getSV ( channel ) , getV1 ( channel ) , getV2 ( channel ) ) ; if ( lim == null ) { setMode ( channel , STR_ ) ; setAddr ( channel , NUM_ ) ; log . debug ( STR_ ) ; } else { setMode ( channel , lim . getFullMode ( ) ) ; setAddr ( channel , validmodes . valuesToAddress ( lim . getOpcode ( ) , getSV ( channel ) , getV1 ( channel ) , getV2 ( channel ) ) ) ; } log . debug ( STR_ + STR_ + Integer . toHexString ( getSV ( channel ) ) + STR_ + STR_ + Integer . toHexString ( getV1 ( channel ) ) + STR_ + STR_ + Integer . toHexString ( getV2 ( channel ) ) + STR_ + STR_ + getAddr ( channel ) + STR_ + Integer . toHexString ( getAddr ( channel ) ) + STR_ ) ; } else { log . warn ( STR_ + type + STR_ + channel ) ; } } else { } } issueNextOperation ( ) ; return ; } else { return ; } case LnConstants . OPC_INPUT_REP : if ( log . isDebugEnabled ( ) ) { log . debug ( LnConstants . OPC_NAME ( opCode ) + STR_ ) ; } for ( int i = NUM_ ; i < _numRows ; i ++ ) { if ( capture [ i ] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + i ) ; } int val1 = m . getElement ( NUM_ ) ; int val2 = m . getElement ( NUM_ ) ; setAddr ( i , ( ( val2 & x0F ) << NUM_ ) . NUM_ + ( ( val1 & x7f ) << NUM_ ) | ( ( ( val2 & LnConstants . OPC_SW_REQ_DIR ) == LnConstants . OPC_SW_REQ_DIR ) ? x01 : x00 ) ) ; capture [ i ] = BOOL_ ; } } return ; case LnConstants . OPC_SW_REQ : if ( log . isDebugEnabled ( ) ) { log . debug ( LnConstants . OPC_NAME ( opCode ) + STR_ ) ; } for ( int i = NUM_ ; i < _numRows ; i ++ ) { if ( capture [ i ] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + i ) ; } int val1 = m . getElement ( NUM_ ) ; int val2 = m . getElement ( NUM_ ) ; int addr = LocoIO . SENSOR_ADR ( val1 , val2 ) ; setAddr ( i , addr ) ; capture [ i ] = BOOL_ ; } } return ; default : } }
@ Override public String toString ( ) { return buf . toString ( ) ; }
public void test_fill$ZIIZ ( ) { boolean val = BOOL_ ; boolean d [ ] = new boolean [ NUM_ ] ; Arrays . fill ( d , NUM_ , d . length , val ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) assertTrue ( STR_ , ! ( d [ i ] == val ) ) ; for ( int i = NUM_ ; i < d . length ; i ++ ) assertTrue ( STR_ , d [ i ] == val ) ; try { Arrays . fill ( d , NUM_ , NUM_ , val ) ; fail ( STR_ ) ; } catch ( IllegalArgumentException e ) { } try { Arrays . fill ( d , - NUM_ , NUM_ , val ) ; fail ( STR_ ) ; } catch ( ArrayIndexOutOfBoundsException e ) { } try { Arrays . fill ( d , NUM_ , d . length + NUM_ , val ) ; fail ( STR_ ) ; } catch ( ArrayIndexOutOfBoundsException e ) { } }
protected void linearLayout ( VisualTable labels ) { Rectangle2D b = getLayoutBounds ( ) ; double breadth = getBreadth ( b ) ; double span = m_hi - m_lo ; double pspan = m_prevhi - m_prevlo ; double vlo = NUM_ ; if ( m_lo >= NUM_ ) { vlo = Math . pow ( NUM_ , Math . floor ( MathLib . log10 ( m_lo ) ) ) ; } else { vlo = - Math . pow ( NUM_ , NUM_ + Math . floor ( MathLib . log10 ( - m_lo ) ) ) ; } Iterator iter = labels . tuples ( ) ; while ( iter . hasNext ( ) ) { VisualItem item = ( VisualItem ) iter . next ( ) ; reset ( item ) ; double v = item . getDouble ( VALUE ) ; double x = span == NUM_ ? NUM_ : ( ( v - m_lo ) / span ) . breadth ; set ( item , x , b ) ; } Index index = labels . index ( VALUE ) ; double step = getLinearStep ( span , span == NUM_ ? NUM_ : breadth / span ) ; if ( step == NUM_ ) step = NUM_ ; int r ; for ( double x , v = vlo ; v <= m_hi ; v += step ) { x = ( ( v - m_lo ) / span ) . breadth ; if ( x < - NUM_ ) { continue ; } else if ( ( r = index . get ( v ) ) >= NUM_ ) { VisualItem item = labels . getItem ( r ) ; item . setVisible ( BOOL_ ) ; item . setEndVisible ( BOOL_ ) ; } else { VisualItem item = labels . addItem ( ) ; item . set ( LABEL , m_nf . format ( v ) ) ; item . setDouble ( VALUE , v ) ; double f = pspan == NUM_ ? NUM_ : ( ( v - m_prevlo ) / pspan ) ; if ( f <= NUM_ || f >= NUM_ ) item . setStartVisible ( BOOL_ ) ; set ( item , f . breadth , b ) ; set ( item , x , b ) ; } } }
@ Override public synchronized boolean addAll ( Collection < ? extends E > collection ) { return addAll ( elementCount , collection ) ; }
public boolean handleExceptionFromServer ( Writer writer , Reader reader , Throwable ex ) { if ( ex instanceof ClosedChannelException ) { if ( _logger . isLoggable ( Level . FINE ) ) _logger . log ( Level . FINE , STR_ + writer . getEndPointAddress ( ) + STR_ ) ; return BOOL_ ; } if ( ex instanceof MarshalContextClearedException ) { if ( _logger . isLoggable ( Level . FINE ) ) _logger . log ( Level . FINE , STR_ + writer . getEndPointAddress ( ) + STR_ ) ; return BOOL_ ; } try { String msg = STR_ + writer . getEndPointAddress ( ) + STR_ ; if ( ex instanceof LRMIUnhandledException ) { if ( _logger . isLoggable ( Level . FINE ) ) _logger . log ( Level . FINE , msg , ex ) ; LRMIUnhandledException lrmiue = ( LRMIUnhandledException ) ex ; if ( lrmiue . getStage ( ) == Stage . DESERIALIZATION ) { reader . resetContext ( ) ; } if ( writer . isOpen ( ) ) writer . writeReply ( new ReplyPacket ( null , lrmiue ) ) ; return BOOL_ ; } else if ( ex instanceof RuntimeException || ex instanceof InvalidClassException ) { if ( _logger . isLoggable ( Level . SEVERE ) ) _logger . log ( Level . SEVERE , msg , ex ) ; } else if ( ex instanceof UnmarshalException ) { if ( _logger . isLoggable ( Level . WARNING ) ) _logger . log ( Level . WARNING , msg , ex ) ; } else { if ( _logger . isLoggable ( Level . FINE ) ) _logger . log ( Level . FINE , msg , ex ) ; } if ( writer . isOpen ( ) ) writer . writeReply ( new ReplyPacket ( null , new ProtocolException ( msg , ex ) ) ) ; return BOOL_ ; } catch ( Exception ex2 ) { if ( _logger . isLoggable ( Level . FINE ) ) _logger . log ( Level . FINE , STR_ + writer . getEndPointAddress ( ) + STR_ , ex ) ; return BOOL_ ; } }
public String sprintf ( ) { final Iterator < ConversionSpecification > e = vFmt . iterator ( ) ; ConversionSpecification cs ; char c ; final StringBuilder sb = new StringBuilder ( ) ; while ( e . hasNext ( ) ) { cs = e . next ( ) ; c = cs . getConversionCharacter ( ) ; if ( c == STR_ ) { sb . append ( cs . getLiteral ( ) ) ; } else if ( c == STR_ ) { sb . append ( STR_ ) ; } } return sb . toString ( ) ; }
default String resourceName ( String tableName , String type ) { return String . format ( RESOURCE_NAME , tableName , type ) ; }
protected void updateComboBoxesLoadChange ( ) { if ( autoTrackCheckBox . isSelected ( ) ) { updateLocationTrackComboBox ( ) ; } if ( autoDestinationTrackCheckBox . isSelected ( ) ) { updateDestinationTrackComboBox ( ) ; } if ( autoFinalDestTrackCheckBox . isSelected ( ) ) { updateFinalDestination ( ) ; } }
public String removeClassColumnTipText ( ) { return STR_ ; }
public static String join ( NamedValue [ ] values , String separator ) { StringBuilder buff = new StringBuilder ( ) ; for ( int i = NUM_ ; i < values . length ; i ++ ) { buff . append ( values [ i ] ) ; if ( i < values . length - NUM_ ) buff . append ( separator ) ; } return buff . toString ( ) ; }
private int currentDepth ( ) { try { Integer oneBased = ( ( Integer ) DEPTH_FIELD . get ( this ) ) ; return oneBased - NUM_ ; } catch ( IllegalAccessException e ) { throw new AssertionError ( e ) ; } }
protected LocPathIterator changePartToRef ( final QName uniquePseudoVarName , WalkingIterator wi , final int numSteps , final boolean isGlobal ) { Variable var = new Variable ( ) ; var . setQName ( uniquePseudoVarName ) ; var . setIsGlobal ( isGlobal ) ; if ( isGlobal ) { ElemTemplateElement elem = getElemFromExpression ( wi ) ; StylesheetRoot root = elem . getStylesheetRoot ( ) ; Vector vars = root . getVariablesAndParamsComposed ( ) ; var . setIndex ( vars . size ( ) - NUM_ ) ; } AxesWalker walker = wi . getFirstWalker ( ) ; for ( int i = NUM_ ; i < numSteps ; i ++ ) { assertion ( null != walker , STR_ ) ; walker = walker . getNextWalker ( ) ; } if ( null != walker ) { FilterExprWalker few = new FilterExprWalker ( wi ) ; few . setInnerExpression ( var ) ; few . exprSetParent ( wi ) ; few . setNextWalker ( walker ) ; walker . setPrevWalker ( few ) ; wi . setFirstWalker ( few ) ; return wi ; } else { FilterExprIteratorSimple feis = new FilterExprIteratorSimple ( var ) ; feis . exprSetParent ( wi . exprGetParent ( ) ) ; return feis ; } }
protected String sourceClass ( Attribute c , double [ ] dist ) { if ( c . isNominal ( ) ) { return Integer . toString ( Utils . maxIndex ( dist ) ) ; } else { return Double . toString ( dist [ NUM_ ] ) ; } }
public void done ( ) throws IOException { printer . flush ( ) ; }
int requestGroupData ( char groupNum ) { setCurrDataGroup ( groupNum ) ; currGrpItems = knownGrpItems . get ( Integer . valueOf ( getCurrDataGroup ( ) ) ) ; char [ ] payLoad = { groupNum } ; return ( writeTelegram ( payLoad , CMD_GROUP_READ , null ) ) ; }
protected String computeFullUrl ( URL baseUrl , String link ) { if ( link == null || link . length ( ) == NUM_ ) { return null ; } if ( ! link . startsWith ( STR_ ) ) { if ( link . startsWith ( STR_ ) ) { link = baseUrl . getProtocol ( ) + STR_ + baseUrl . getAuthority ( ) + link ; } else { if ( link . contains ( STR_ ) ) { return null ; } String path = baseUrl . getPath ( ) ; if ( ! path . endsWith ( STR_ ) ) { int sep = path . lastIndexOf ( STR_ ) ; String file = path . substring ( sep + NUM_ ) ; if ( file . contains ( STR_ ) || file . contains ( STR_ ) ) path = path . substring ( NUM_ , sep ) ; } link = baseUrl . getProtocol ( ) + STR_ + baseUrl . getAuthority ( ) + path + STR_ + link ; } } link = normalizeUrlEnding ( link ) ; String l = link . toLowerCase ( Locale . ROOT ) ; if ( l . endsWith ( STR_ ) || l . endsWith ( STR_ ) || l . endsWith ( STR_ ) || l . endsWith ( STR_ ) ) { return null ; } return link ; }
protected String encodeCookie ( SerializableHttpCookie cookie ) { if ( cookie == null ) return null ; ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; try { ObjectOutputStream outputStream = new ObjectOutputStream ( os ) ; outputStream . writeObject ( cookie ) ; } catch ( IOException e ) { Log . d ( LOG_TAG , STR_ , e ) ; return null ; } return byteArrayToHexString ( os . toByteArray ( ) ) ; }
public long skip ( long bytes ) throws IOException { if ( closed ) { throw new IOException ( STR_ ) ; } int av = available ( ) ; if ( av == NUM_ ) { av = makeAvailable ( ) ; if ( av == NUM_ ) { return NUM_ ; } } long res = Math . min ( av , bytes ) ; head += res ; return res ; }
public void resume ( ) { mPaused = BOOL_ ; mLastFrameTime = System . currentTimeMillis ( ) ; invalidate ( ) ; }
public void testSubtractDiffScaleNegPos ( ) { String a = STR_ ; int aScale = - NUM_ ; String b = STR_ ; int bScale = NUM_ ; String c = STR_ ; int cScale = NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal bNumber = new BigDecimal ( new BigInteger ( b ) , bScale ) ; BigDecimal result = aNumber . subtract ( bNumber ) ; assertEquals ( STR_ , c , result . toString ( ) ) ; assertEquals ( STR_ , cScale , result . scale ( ) ) ; }
public AllToAllPanel ( AllToAll connector , NetworkPanel networkPanel ) { super ( ) ; this . connection = connector ; allowSelfConnectPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; allowSelfConnectPanel . add ( new JLabel ( STR_ ) ) ; allowSelfConnectPanel . add ( allowSelfConnectChkBx ) ; fillFieldValues ( ) ; add ( allowSelfConnectPanel ) ; }
public void addPropertyChangeListener ( PropertyChangeListener pcl ) { m_pcSupport . addPropertyChangeListener ( pcl ) ; }
public boolean functionAvailable ( String ns , String funcName ) throws javax . xml . transform . TransformerException { try { if ( funcName == null ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_ARG_CANNOT_BE_NULL , new Object [ ] { STR_ } ) ; throw new NullPointerException ( fmsg ) ; } javax . xml . namespace . QName myQName = new QName ( ns , funcName ) ; javax . xml . xpath . XPathFunction xpathFunction = resolver . resolveFunction ( myQName , NUM_ ) ; if ( xpathFunction == null ) { return BOOL_ ; } return BOOL_ ; } catch ( Exception e ) { return BOOL_ ; } }
private void allocate_sections ( int p_section_count ) { section_list . ensureCapacity ( p_section_count ) ; while ( section_list . size ( ) < p_section_count ) { section_list . add ( new MazeSearchElement ( ) ) ; } }
public boolean refreshNeeded ( ) { return this . softTtl < System . currentTimeMillis ( ) ; }
public static byte [ ] randomBytes ( int length ) { byte [ ] bytes = new byte [ length ] ; SEEDED_RANDOM . nextBytes ( bytes ) ; return bytes ; }
public WeightDistribution ( ColumnExampleTable columnTable , int [ ] selection , int attributeNumber ) { calculateLabelWeights ( columnTable , selection , attributeNumber ) ; leftLabelWeights = new double [ totalLabelWeights . length ] ; leftWeight = NUM_ ; totalWeight = getTotalWeight ( totalLabelWeights ) ; if ( hasMissings ) { missingsWeight = getTotalWeight ( missingsLabelWeights ) ; rightWeight = totalWeight - missingsWeight ; rightLabelWeights = arrayDifference ( totalLabelWeights , missingsLabelWeights ) ; } else { missingsWeight = NUM_ ; rightWeight = totalWeight ; rightLabelWeights = new double [ totalLabelWeights . length ] ; System . arraycopy ( totalLabelWeights , NUM_ , rightLabelWeights , NUM_ , totalLabelWeights . length ) ; } }
public static String removeExtension ( String fileName ) { int index = fileName . lastIndexOf ( STR_ ) ; if ( index == - NUM_ ) { return fileName ; } else { return fileName . substring ( NUM_ , index ) ; } }
public void delete ( String name ) throws IOException { if ( name . equalsIgnoreCase ( KEY_ID ) ) { id = null ; } else { throw new IOException ( STR_ + STR_ ) ; } encodeThis ( ) ; }
public static DataFrame normalize ( DataFrame dataFrame , double min , double max ) { return normalize ( dataFrame , min , max , Collections . < String > emptyList ( ) ) ; }
boolean isSocketScheme ( String scheme ) { for ( String p : URIHelper . SOCKET_SCHEMES ) { if ( p . equals ( scheme ) ) { return BOOL_ ; } } return BOOL_ ; }
private static void addLeafWithNonExistingParents ( Spatial root , Spatial leaf ) { if ( ! ( root instanceof Node ) ) { logger . log ( Level . WARNING , STR_ , new Object [ ] { leaf . getName ( ) , root . getName ( ) } ) ; return ; } for ( Spatial s = leaf ; s . getParent ( ) != null ; s = s . getParent ( ) ) { Spatial parent = s . getParent ( ) ; Spatial other = findTaggedSpatial ( root , parent ) ; if ( other == null ) { continue ; } if ( other instanceof Node ) { logger . log ( Level . INFO , STR_ , new Object [ ] { s , other , root , leaf } ) ; for ( Spatial spt = leaf ; spt != parent ; spt = spt . getParent ( ) ) { spt . setUserData ( ORIGINAL_NAME , spt . getName ( ) ) ; spt . setUserData ( ORIGINAL_PATH , getSpatialPath ( spt ) ) ; spt = spt . getParent ( ) ; } Node otherNode = ( Node ) other ; otherNode . attachChild ( s ) ; logger . log ( LogLevel . USERINFO , STR_ , new Object [ ] { other . getName ( ) , leaf . getName ( ) } ) ; return ; } else { logger . log ( Level . WARNING , STR_ , new Object [ ] { leaf , other , root } ) ; } } logger . log ( Level . WARNING , STR_ , leaf . getName ( ) ) ; }
private void adjustBlockListeners ( List < OBlock > oldRange , List < OBlock > newRange , Tracker tracker ) { Iterator < OBlock > iter = newRange . iterator ( ) ; while ( iter . hasNext ( ) ) { OBlock b = iter . next ( ) ; if ( oldRange . contains ( b ) ) { oldRange . remove ( b ) ; continue ; } addBlockListener ( b , tracker ) ; } iter = oldRange . iterator ( ) ; while ( iter . hasNext ( ) ) { removeBlockListener ( iter . next ( ) , tracker ) ; } }
public static String dbNameToVarName ( String columnName ) { if ( columnName == null ) return null ; StringBuilder fieldName = new StringBuilder ( columnName . length ( ) ) ; boolean toUpper = BOOL_ ; for ( int i = NUM_ ; i < columnName . length ( ) ; i ++ ) { char ch = columnName . charAt ( i ) ; if ( ch == STR_ ) { toUpper = BOOL_ ; } else if ( toUpper ) { fieldName . append ( Character . toUpperCase ( ch ) ) ; toUpper = BOOL_ ; } else { fieldName . append ( Character . toLowerCase ( ch ) ) ; } } return fieldName . toString ( ) ; }
static public String hexEncode ( byte [ ] aInput ) { StringBuffer result = new StringBuffer ( ) ; final char [ ] digits = { STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ } ; for ( int idx = NUM_ ; idx < aInput . length ; ++ idx ) { byte b = aInput [ idx ] ; result . append ( digits [ ( b & xf0 ) > > NUM_ ] ) ; result . append ( digits [ b & x0f ] ) ; } return result . toString ( ) ; }
private static Size clampSize ( Size original , double maxArea , Size maxSize ) { if ( original . getWidth ( ) . original . getHeight ( ) < maxArea && original . getWidth ( ) < maxSize . getWidth ( ) && original . getHeight ( ) < maxSize . getHeight ( ) ) { return original ; } double ratio = Math . min ( Math . sqrt ( maxArea / original . area ( ) ) , NUM_ ) ; int width = ( int ) Math . round ( original . width ( ) . ratio ) ; int height = ( int ) Math . round ( original . height ( ) . ratio ) ; if ( width > maxSize . width ( ) || height > maxSize . height ( ) ) { return computeFitWithinSize ( original , maxSize ) ; } return new Size ( width , height ) ; }
TCPChannel ( TCPTransport tr , TCPEndpoint ep ) { this . tr = tr ; this . ep = ep ; }
@ Override public final String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( STR_ ) ; for ( int i = NUM_ ; i < fields . size ( ) ; i ++ ) { IndexableField field = fields . get ( i ) ; buffer . append ( field . toString ( ) ) ; if ( i != fields . size ( ) - NUM_ ) { buffer . append ( STR_ ) ; } } buffer . append ( STR_ ) ; return buffer . toString ( ) ; }
public static byte [ ] encode ( byte [ ] data ) { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; try { encoder . encode ( data , NUM_ , data . length , bOut ) ; } catch ( IOException e ) { throw new RuntimeException ( STR_ + e ) ; } return bOut . toByteArray ( ) ; }
public static Face drawDir ( Direction dir , MeshModel model , double minX , double minY , double minZ , double maxX , double maxY , double maxZ , CubeTextureCoordinates textureCoordinates ) { switch ( dir ) { case DOWN : return drawDown ( model , minX , minY , minZ , maxX , maxY , maxZ , textureCoordinates ) ; case UP : return drawUp ( model , minX , minY , minZ , maxX , maxY , maxZ , textureCoordinates ) ; case NORTH : return drawNorth ( model , minX , minY , minZ , maxX , maxY , maxZ , textureCoordinates ) ; case SOUTH : return drawSouth ( model , minX , minY , minZ , maxX , maxY , maxZ , textureCoordinates ) ; case EAST : return drawEast ( model , minX , minY , minZ , maxX , maxY , maxZ , textureCoordinates ) ; case WEST : return drawWest ( model , minX , minY , minZ , maxX , maxY , maxZ , textureCoordinates ) ; } throw new RenderException ( STR_ ) ; }
public void addObserver ( final FileAlterationObserver observer ) { if ( observer != null ) { observers . add ( observer ) ; } }
public MAVLinkMessage ( MAVLinkSchema schema , ByteBuffer buffer ) throws MAVLinkProtocolException , MAVLinkUnknownMessage , BufferUnderflowException { if ( buffer . remaining ( ) < NON_PAYLOAD_LENGTH ) { throw new BufferUnderflowException ( ) ; } int startPos = buffer . position ( ) ; byte startSign = buffer . get ( ) ; if ( startSign != START_OF_FRAME ) { throw new MAVLinkProtocolException ( String . format ( STR_ , startSign , START_OF_FRAME ) ) ; } int payloadLen = buffer . get ( ) & xff ; if ( buffer . remaining ( ) < payloadLen + NON_PAYLOAD_LENGTH - NUM_ ) { buffer . position ( startPos ) ; throw new BufferUnderflowException ( ) ; } sequence = buffer . get ( ) ; systemID = buffer . get ( ) & xff ; componentID = buffer . get ( ) & xff ; msgID = buffer . get ( ) & xff ; this . schema = schema ; this . definition = schema . getMessageDefinition ( msgID ) ; if ( definition == null ) { buffer . position ( buffer . position ( ) + payloadLen + CRC_LENGTH ) ; throw new MAVLinkUnknownMessage ( String . format ( STR_ , msgID ) ) ; } if ( payloadLen != definition . payloadLength ) { buffer . position ( buffer . position ( ) + payloadLen + CRC_LENGTH ) ; throw new MAVLinkUnknownMessage ( String . format ( STR_ , definition . name , msgID , payloadLen , definition . payloadLength ) ) ; } this . payload = new byte [ definition . payloadLength ] ; buffer . get ( payload ) ; crc = Short . reverseBytes ( buffer . getShort ( ) ) & xffff ; int endPos = buffer . position ( ) ; buffer . position ( startPos ) ; int crcCalc = calculateCRC ( buffer ) ; buffer . position ( endPos ) ; if ( crc != crcCalc ) { throw new MAVLinkUnknownMessage ( String . format ( STR_ , definition . name , msgID , crc , crcCalc ) ) ; } this . payloadBB = ByteBuffer . wrap ( payload ) ; payloadBB . order ( schema . getByteOrder ( ) ) ; }
public static double log1p ( final double x ) { if ( x == - NUM_ ) { return Double . NEGATIVE_INFINITY ; } if ( x == Double . POSITIVE_INFINITY ) { return Double . POSITIVE_INFINITY ; } if ( x > NUM_ || x < - NUM_ ) { final double xpa = NUM_ + x ; final double xpb = - ( xpa - NUM_ - x ) ; final double [ ] hiPrec = new double [ NUM_ ] ; final double lores = log ( xpa , hiPrec ) ; if ( Double . isInfinite ( lores ) ) { return lores ; } final double fx1 = xpb / xpa ; final double epsilon = NUM_ . fx1 + NUM_ ; return epsilon . fx1 + hiPrec [ NUM_ ] + hiPrec [ NUM_ ] ; } else { final double y = ( x . F_1_3 - F_1_2 ) . x + NUM_ ; return y . x ; } }
protected ScriptBuilder bigNum ( long num ) { return bigNum ( chunks . size ( ) , num ) ; }
Callbacks tryGetCallbacks ( Callbacks oldCallbacks ) { synchronized ( mLock ) { if ( mStopped ) { return null ; } if ( mCallbacks == null ) { return null ; } final Callbacks callbacks = mCallbacks . get ( ) ; if ( callbacks != oldCallbacks ) { return null ; } if ( callbacks == null ) { Log . w ( TAG , STR_ ) ; return null ; } return callbacks ; } }
public final void change_entries ( BrdTracep p_obj , Polyline p_new_polyline , int p_keep_at_start_count , int p_keep_at_end_count ) { int compensated_half_width = p_obj . get_half_width ( ) + get_clearance_compensation ( p_obj . clearance_idx ( ) , p_obj . get_layer ( ) ) ; ArrayList < ShapeTile > changed_shapes = offset_shapes ( p_new_polyline , compensated_half_width , p_keep_at_start_count , p_new_polyline . plaline_len ( - NUM_ ) - p_keep_at_end_count ) ; int old_shape_count = p_obj . tree_shape_count ( this ) ; int new_shape_count = changed_shapes . size ( ) + p_keep_at_start_count + p_keep_at_end_count ; AwtreeNodeLeaf [ ] new_leaf_arr = new AwtreeNodeLeaf [ new_shape_count ] ; ShapeTile [ ] new_precalculated_tree_shapes = new ShapeTile [ new_shape_count ] ; AwtreeNodeLeaf [ ] old_entries = p_obj . get_search_tree_entries ( this ) ; for ( int index = NUM_ ; index < p_keep_at_start_count ; ++ index ) { new_leaf_arr [ index ] = old_entries [ index ] ; new_precalculated_tree_shapes [ index ] = p_obj . get_tree_shape ( this , index ) ; } for ( int index = p_keep_at_start_count ; index < old_shape_count - p_keep_at_end_count ; ++ index ) { remove_leaf ( old_entries [ index ] ) ; } for ( int i = NUM_ ; i < p_keep_at_end_count ; ++ i ) { int new_index = new_shape_count - p_keep_at_end_count + i ; int old_index = old_shape_count - p_keep_at_end_count + i ; new_leaf_arr [ new_index ] = old_entries [ old_index ] ; new_leaf_arr [ new_index ] . shape_index_in_object = new_index ; new_precalculated_tree_shapes [ new_index ] = p_obj . get_tree_shape ( this , old_index ) ; } for ( int index = p_keep_at_start_count ; index < new_shape_count - p_keep_at_end_count ; ++ index ) { new_precalculated_tree_shapes [ index ] = changed_shapes . get ( index - p_keep_at_start_count ) ; } p_obj . set_precalculated_tree_shapes ( new_precalculated_tree_shapes , this ) ; for ( int index = p_keep_at_start_count ; index < new_shape_count - p_keep_at_end_count ; ++ index ) { new_leaf_arr [ index ] = insert ( p_obj , index ) ; } p_obj . set_search_tree_entries ( this , new_leaf_arr ) ; }
static Object newInstance ( String className , ClassLoader cl , boolean doFallback ) throws ConfigurationError { try { Class providerClass = findProviderClass ( className , cl , doFallback ) ; Object instance = providerClass . newInstance ( ) ; if ( DEBUG ) debugPrintln ( STR_ + providerClass + STR_ + cl ) ; return instance ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( STR_ + className + STR_ , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( STR_ + className + STR_ + x , x ) ; } }
public void addAction ( EntityAction ea ) { actions . addElement ( ea ) ; processGameEvent ( new GameNewActionEvent ( this , ea ) ) ; }
public Polygon ( PolygonPoint p1 , PolygonPoint p2 , PolygonPoint p3 ) { p1 . _next = p2 ; p2 . _next = p3 ; p3 . _next = p1 ; p1 . _previous = p3 ; p2 . _previous = p1 ; p3 . _previous = p2 ; _points . add ( p1 ) ; _points . add ( p2 ) ; _points . add ( p3 ) ; }
public static JSONObject readJSONObject ( final JSONArray jsonArray , final int index , final boolean required , final boolean notNull ) throws JSONException { if ( required ) { return jsonArray . getJSONObject ( index ) ; } if ( notNull && jsonArray . isNull ( index ) ) { throw new JSONException ( String . format ( Locale . US , NULL_VALUE_FORMAT_ARRAY , index ) ) ; } JSONObject value = null ; if ( ! jsonArray . isNull ( index ) ) { value = jsonArray . getJSONObject ( index ) ; } return value ; }
public static void waitElementToNotBePresent ( SearchContext parent , By by , int waitInSeconds ) { Preconditions . checkNotNull ( parent ) ; Preconditions . checkNotNull ( by ) ; try { WebElementWait wait = new WebElementWait ( parent , waitInSeconds ) ; wait . until ( null ) ; } catch ( TimeoutException e ) { throw new TimeoutException ( String . format ( STR_ , by , waitInSeconds ) , e ) ; } }
public final TestSubscriber assertTerminated ( ) { if ( done . getCount ( ) != NUM_ ) { fail ( STR_ , STR_ , errors ) ; } long c = completions ; if ( c > NUM_ ) { fail ( STR_ , STR_ + c , errors ) ; } int s = errors . size ( ) ; if ( s > NUM_ ) { fail ( STR_ , STR_ + s , errors ) ; } if ( c != NUM_ && s != NUM_ ) { fail ( STR_ , STR_ + c , errors ) ; } return this ; }
public boolean isVimeoURLValid ( ) { String videoID = getExtractedIdentifier ( ) ; return videoID . length ( ) > NUM_ && TextUtils . isDigitsOnly ( videoID ) ; }
public boolean isCancelled ( ) { return mState . get ( ) == STATE_CANCELLED ; }
public final void pushSubContextList ( SubContextList iter ) { m_axesIteratorStack . push ( iter ) ; }
static void checkDesc ( final String desc , final boolean canBeVoid ) { int end = checkDesc ( desc , NUM_ , canBeVoid ) ; if ( end != desc . length ( ) ) { throw new IllegalArgumentException ( STR_ + desc ) ; } }
private void updateDownloadedFiles ( SQLiteDatabase db , String newAccountName , String oldAccountName ) { String whereClause = ProviderTableMeta . FILE_ACCOUNT_OWNER + STR_ + ProviderTableMeta . FILE_STORAGE_PATH + STR_ ; Cursor c = db . query ( ProviderTableMeta . FILE_TABLE_NAME , null , whereClause , new String [ ] { newAccountName } , null , null , null ) ; try { if ( c . moveToFirst ( ) ) { String oldAccountPath = FileStorageUtils . getSavePath ( oldAccountName ) ; String newAccountPath = FileStorageUtils . getSavePath ( newAccountName ) ; File oldAccountFolder = new File ( oldAccountPath ) ; File newAccountFolder = new File ( newAccountPath ) ; oldAccountFolder . renameTo ( newAccountFolder ) ; do { String oldPath = c . getString ( c . getColumnIndex ( ProviderTableMeta . FILE_STORAGE_PATH ) ) ; OCFile file = new OCFile ( c . getString ( c . getColumnIndex ( ProviderTableMeta . FILE_PATH ) ) ) ; String newPath = FileStorageUtils . getDefaultSavePathFor ( newAccountName , file ) ; ContentValues cv = new ContentValues ( ) ; cv . put ( ProviderTableMeta . FILE_STORAGE_PATH , newPath ) ; db . update ( ProviderTableMeta . FILE_TABLE_NAME , cv , ProviderTableMeta . FILE_STORAGE_PATH + STR_ , new String [ ] { oldPath } ) ; Log_OC . v ( STR_ , STR_ + oldPath + STR_ + newPath ) ; } while ( c . moveToNext ( ) ) ; } } finally { c . close ( ) ; } }
public void dumpOptions ( ) { logger . info ( STR_ ) ; for ( Method getter : GetConfigurationInterface . class . getMethods ( ) ) { String getterName = getter . getName ( ) ; try { Object result = getter . invoke ( ConfigurationManager . getCurrentProfile ( ) ) ; if ( result instanceof Boolean ) { result = LocalizationHelper . getYesOrNo ( ( Boolean ) result ) ; } if ( result instanceof List ) { for ( int i = NUM_ ; i < ( ( List ) result ) . size ( ) ; i ++ ) { assert ( ( List ) result ) . get ( i ) instanceof CustomCatalogEntry ; CustomCatalogEntry c = ( ( List < CustomCatalogEntry > ) result ) . get ( i ) ; String OptionName = Helper . pad ( Localization . Main . getText ( STR_ ) + STR_ + ( i + NUM_ ) + STR_ + c . getAtTop ( ) . toString ( ) , STR_ , NUM_ ) + STR_ ; logger . info ( OptionName + c . getLabel ( ) + STR_ + c . getValue ( ) . toString ( ) + STR_ + c . getAtTop ( ) . toString ( ) ) ; } } else { String optionName = getterName . substring ( NUM_ ) ; dumpOption ( optionName , result ) ; } } catch ( IllegalAccessException e ) { logger . warn ( STR_ , e ) ; } catch ( InvocationTargetException e ) { logger . warn ( STR_ , e ) ; } } logger . info ( STR_ ) ; }
private JsonNode parseLanguageResource ( Resource resource ) throws IOException { InputStream stream = resource . asStream ( ) ; if ( stream == null ) return null ; try { JsonNode tree = mapper . readTree ( stream ) ; return tree ; } finally { stream . close ( ) ; } }
public Collection < Tuple2 < TransitionState , Double > > startStates ( ) { List < Tuple2 < TransitionState , Double > > result = new ArrayList < Tuple2 < TransitionState , Double > > ( ) ; { double score = Math . log ( LINE_MRGN_PROB ) ; addNoSubGlyphStartState ( result , new int [ NUM_ ] , TransitionStateType . LMRGN , - NUM_ , score ) ; } for ( int destLanguage = NUM_ ; destLanguage < numLanguages ; ++ destLanguage ) { SingleLanguageModel destLM = lm . get ( destLanguage ) ; double destLanguagePrior = lm . languagePrior ( destLanguage ) ; for ( int c : destLM . getActiveCharacters ( ) ) { if ( c != spaceCharIndex ) { double score = Math . log ( NUM_ - LINE_MRGN_PROB ) + Math . log ( getNgramProb ( destLM , new int [ NUM_ ] , c ) ) + Math . log ( destLanguagePrior ) ; addGlyphStartStates ( result , c , new int [ ] { c } , TransitionStateType . TMPL , destLanguage , score ) ; } } } { double totalSpaceProb = NUM_ ; for ( int language = NUM_ ; language < numLanguages ; ++ language ) totalSpaceProb += getNgramProb ( lm . get ( language ) , new int [ NUM_ ] , spaceCharIndex ) . lm . languagePrior ( language ) ; double score = Math . log ( NUM_ - LINE_MRGN_PROB ) + Math . log ( totalSpaceProb ) ; addNoSubGlyphStartState ( result , new int [ ] { spaceCharIndex } , TransitionStateType . TMPL , - NUM_ , score ) ; } return result ; }
public boolean removeContainerAndCancelIfNecessary ( ImageContainer container ) { mContainers . remove ( container ) ; if ( mContainers . isEmpty ( ) ) { mRequest . cancel ( ) ; return BOOL_ ; } return BOOL_ ; }
public KernelDensityFunction ( Collection < double [ ] > points ) { this ( points . toArray ( new double [ points . size ( ) ] [ ] ) ) ; }
private static Object cloneSerializableObject ( Object o ) throws IOException , ClassNotFoundException { ByteArrayOutputStream b = new ByteArrayOutputStream ( ) ; ObjectOutputStream out = new ObjectOutputStream ( b ) ; out . writeObject ( o ) ; out . flush ( ) ; out . close ( ) ; ByteArrayInputStream bi = new ByteArrayInputStream ( b . toByteArray ( ) ) ; ObjectInputStream in = new ObjectInputStream ( bi ) ; return in . readObject ( ) ; }
public boolean hasThree ( ) { return points . size ( ) > NUM_ ; }
public ZipEntry ( String name ) { Objects . requireNonNull ( name , STR_ ) ; if ( name . length ( ) > xFFFF ) { throw new IllegalArgumentException ( STR_ ) ; } this . name = name ; }
public void _testStatements ( ) throws Exception { Connection connection = getConnectionViaDriverManager ( ) ; connection . setAutoCommit ( BOOL_ ) ; try { Statement stmt = connection . createStatement ( ) ; ResultSet rs = stmt . executeQuery ( STR_ ) ; rs . close ( ) ; RandomSelector selector1 = new RandomSelector ( stmt , SELECT_TABLE_1 , RECORD_COUNT ) ; RandomSelector selector2 = new RandomSelector ( stmt , SELECT_TABLE_2 , RECORD_COUNT ) ; Thread thread1 = new Thread ( selector1 , STR_ ) ; Thread thread2 = new Thread ( selector2 , STR_ ) ; thread1 . start ( ) ; thread2 . start ( ) ; Thread . sleep ( TEST_TIME_SECONDS . NUM_ ) ; selector1 . stop ( ) ; selector2 . stop ( ) ; thread1 . join ( ) ; thread2 . join ( ) ; stmt . close ( ) ; } finally { connection . close ( ) ; } }
void readDictionary ( String filename , String suffix , InputStream res ) throws IOException { DictionaryNames nms = new DictionaryNames ( filename , suffix ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( res ) ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) { String [ ] terms = splitter . split ( line ) ; if ( terms . length > maxPhraseLength ) continue ; if ( terms . length == NUM_ ) continue ; GazEntry ge = gaz . get ( terms [ NUM_ ] ) ; if ( ge == null ) { gaz . put ( terms [ NUM_ ] , new GazEntry ( terms , NUM_ , nms ) ) ; } else { ge . addChild ( terms , NUM_ , nms ) ; } } in . close ( ) ; }
private T matchTokens ( String targetToken , String requestToken ) { int wildcardIndex = NUM_ ; if ( targetToken == null && requestToken == null ) { return exactMatch ; } if ( targetToken == null || requestToken == null ) { return noMatch ; } int beginTargetIndex = NUM_ ; int beginRequestIndex = NUM_ ; String substr = null ; int targetTokenLength = targetToken . length ( ) ; int requestTokenLength = requestToken . length ( ) ; if ( targetToken . indexOf ( oneLevelWildcard , beginTargetIndex ) != - NUM_ ) { while ( ( wildcardIndex = targetToken . indexOf ( oneLevelWildcard , beginTargetIndex ) ) != - NUM_ ) { if ( wildcardIndex > beginTargetIndex ) { substr = targetToken . substring ( beginTargetIndex , wildcardIndex ) ; if ( ( beginRequestIndex = requestToken . indexOf ( substr , beginRequestIndex ) ) == - NUM_ ) { return noMatch ; } beginTargetIndex = beginTargetIndex + substr . length ( ) + oneLevelWildcardLength ; beginRequestIndex = beginRequestIndex + substr . length ( ) ; } else { if ( wildcardIndex == beginTargetIndex ) { if ( targetTokenLength == oneLevelWildcardLength ) { return wildcardMatch ; } else { beginTargetIndex = beginTargetIndex + oneLevelWildcardLength ; continue ; } } } } if ( beginTargetIndex >= targetTokenLength ) { return wildcardMatch ; } String targetStr = targetToken . substring ( beginTargetIndex , targetTokenLength ) ; String remRequest = requestToken . substring ( beginRequestIndex , requestTokenLength ) ; int remRequestIndex = - NUM_ ; if ( ( remRequestIndex = remRequest . lastIndexOf ( targetStr , remRequest . length ( ) - NUM_ ) ) == - NUM_ ) { return noMatch ; } else { beginRequestIndex = beginRequestIndex + remRequestIndex ; if ( beginRequestIndex + targetStr . length ( ) >= requestTokenLength ) { return wildcardMatch ; } else { return noMatch ; } } } else { if ( targetToken . equals ( requestToken ) ) { return exactMatch ; } } return noMatch ; }
public void addVertex ( ValueGraphVertex v ) { if ( vertices . add ( v ) ) { if ( v . representsParameter ( ) ) { nParameter ++ ; } if ( representativeV == null ) { representativeV = v ; } } }
private void createViewToModel ( int rowCount ) { int recreateFrom = NUM_ ; if ( viewToModel != null ) { recreateFrom = Math . min ( rowCount , viewToModel . length ) ; if ( viewToModel . length != rowCount ) { Row [ ] oldViewToModel = viewToModel ; viewToModel = new Row [ rowCount ] ; System . arraycopy ( oldViewToModel , NUM_ , viewToModel , NUM_ , recreateFrom ) ; } } else { viewToModel = new Row [ rowCount ] ; } int i ; for ( i = NUM_ ; i < recreateFrom ; i ++ ) { viewToModel [ i ] . modelIndex = i ; } for ( i = recreateFrom ; i < rowCount ; i ++ ) { viewToModel [ i ] = new Row ( this , i ) ; } }
public Set < String > files ( ) { if ( setFiles == null ) { throw new IllegalStateException ( STR_ ) ; } return Collections . unmodifiableSet ( setFiles ) ; }
public static boolean isMac ( ) { String osName = System . getProperty ( STR_ ) ; osName = osName . toLowerCase ( ) ; return osName . indexOf ( STR_ ) != - NUM_ ; }
private boolean isAssignableFrom ( Throwable concreteThrowable , Set < Class < ? extends Throwable > > throwableClasses ) { for ( Class < ? extends Throwable > t : throwableClasses ) { if ( t . isAssignableFrom ( concreteThrowable . getClass ( ) ) ) { return BOOL_ ; } } return BOOL_ ; }
public String popAndEncode ( boolean fromOnlineEvent ) { synchronized ( this ) { if ( activeBridgeMode == null ) { return null ; } activeBridgeMode . notifyOfFlush ( this , fromOnlineEvent ) ; if ( queue . isEmpty ( ) ) { return null ; } int totalPayloadLen = NUM_ ; int numMessagesToSend = NUM_ ; for ( JsMessage message : queue ) { int messageSize = calculatePackedMessageLength ( message ) ; if ( numMessagesToSend > NUM_ && totalPayloadLen + messageSize > MAX_PAYLOAD_SIZE && MAX_PAYLOAD_SIZE > NUM_ ) { break ; } totalPayloadLen += messageSize ; numMessagesToSend += NUM_ ; } StringBuilder sb = new StringBuilder ( totalPayloadLen ) ; for ( int i = NUM_ ; i < numMessagesToSend ; ++ i ) { JsMessage message = queue . removeFirst ( ) ; packMessage ( message , sb ) ; } if ( ! queue . isEmpty ( ) ) { sb . append ( STR_ ) ; } String ret = sb . toString ( ) ; return ret ; } }
protected void print ( int v ) throws IOException { print ( String . valueOf ( v ) ) ; }
public Object2DoubleOpenHashMap < IntRBTreeSet > confidenceMap ( ) { List < ItemSet > itemSets = learn ( ) ; Object2DoubleOpenHashMap < IntRBTreeSet > confidenceMap = new Object2DoubleOpenHashMap < > ( itemSets . size ( ) ) ; for ( ItemSet itemSet : itemSets ) { IntRBTreeSet itemSetCopy = new IntRBTreeSet ( itemSet . items ) ; confidenceMap . put ( itemSetCopy , itemSet . support / ( double ) setCount ) ; } return confidenceMap ; }
public static boolean isAllAlpha ( String str ) { if ( str == null ) return BOOL_ ; for ( int i = str . length ( ) - NUM_ ; i >= NUM_ ; i -- ) { if ( ! Character . isLetter ( str . charAt ( i ) ) ) return BOOL_ ; } return BOOL_ ; }
private void extract ( int minsupp , int minlength , int maxlength , int item , int [ ] postfix , int plen , int [ ] buf2 , int [ ] buf3 , boolean destruct , Collector col ) { if ( header [ item ] == null ) { return ; } if ( header [ item ] . sibling == null ) { if ( header [ item ] . count < minsupp ) { return ; } extractLinear ( header [ item ] . count , minsupp , minlength , maxlength , item , postfix , plen , buf2 , col ) ; if ( destruct ) { Arrays . fill ( header , null ) ; } return ; } int support = NUM_ ; for ( FPNode cur = header [ item ] ; cur != null ; cur = cur . sibling ) { support += cur . count ; } if ( support < minsupp ) { return ; } Arrays . fill ( buf3 , NUM_ ) ; for ( FPNode cur = header [ item ] ; cur != null ; cur = cur . sibling ) { for ( FPNode parent = cur . parent ; parent . key >= NUM_ ; parent = parent . parent ) { buf3 [ parent . key ] += cur . count ; } } final int mminlength = minlength - ( plen + NUM_ ) ; if ( mminlength > NUM_ ) { int fparents = NUM_ ; for ( int i = NUM_ ; i < item ; i ++ ) { if ( buf3 [ i ] >= minsupp ) { fparents += NUM_ ; } } if ( fparents < mminlength ) { return ; } } final int last = item - NUM_ ; FPTree proj = new FPTree ( item ) ; for ( FPNode cur = header [ item ] ; cur != null ; cur = cur . sibling ) { int j = buf2 . length ; for ( FPNode parent = cur . parent ; parent . key >= NUM_ ; parent = parent . parent ) { if ( buf3 [ parent . key ] >= minsupp ) { buf2 [ -- j ] = parent . key ; } } if ( buf2 . length - j >= mminlength ) { proj . insert ( proj , buf2 , j , buf2 . length , cur . count ) ; } } proj . reduceMemory ( ) ; postfix [ plen ++ ] = item ; if ( plen >= minlength && plen <= maxlength ) { col . collect ( support , postfix , NUM_ , plen ) ; } for ( int j = last ; j >= NUM_ ; j -- ) { proj . extract ( minsupp , minlength , maxlength , j , postfix , plen , buf2 , buf3 , destruct , col ) ; } if ( destruct ) { header [ item ] = null ; } }
public void updatePosition ( Particle particle , long elapsedTime ) { Vector3f speed = particle . getSpeed ( ) ; float delta = elapsedTime / NUM_ ; float dx = speed . x . delta ; float dy = speed . y . delta ; float dz = speed . z . delta ; Vector3f pos = particle . getPosition ( ) ; particle . setPosition ( pos . x + dx , pos . y + dy , pos . z + dz ) ; }
protected static int toDigit ( char ch , int index ) throws DSSException { int digit = Character . digit ( ch , NUM_ ) ; if ( digit == - NUM_ ) { throw new DSSException ( STR_ + ch + STR_ + index ) ; } return digit ; }
static void loadLibraryWithPath ( String libName , ClassLoader loader , String libraryPath ) { throw new Error ( STR_ ) ; }
public Enumeration listOptions ( ) { Vector newVector = new Vector ( ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return newVector . elements ( ) ; }
public void testConstructorSignBytesPositive7 ( ) { byte aBytes [ ] = { - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , - NUM_ } ; int aSign = NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , - NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , aNumber . signum ( ) ) ; }
public void save ( File keyStore , String type , char [ ] password , char [ ] keyPassword , String caAlias ) throws GeneralSecurityException , IOException { KeyStore store = KeyStore . getInstance ( type ) ; store . load ( null , password ) ; store . setKeyEntry ( caAlias , caKey , keyPassword , caCerts ) ; OutputStream out = new FileOutputStream ( keyStore ) ; try { store . store ( out , password ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } finally { out . close ( ) ; } }
public OrQueryBuilder add ( QueryBuilder filterBuilder ) { filters . add ( filterBuilder ) ; return this ; }
public static void d ( String tag , String msg , Object ... args ) { if ( sLevel > LEVEL_DEBUG ) { return ; } if ( args . length > NUM_ ) { msg = String . format ( msg , args ) ; } Log . d ( tag , msg ) ; }
public static byte [ ] randomBytes ( int length ) { byte [ ] bytes = new byte [ length ] ; SEEDED_RANDOM . nextBytes ( bytes ) ; return bytes ; }
public void test_ctor_2 ( ) throws SailException { final File file = new File ( getName ( ) + Options . JNL ) ; if ( file . exists ( ) ) { if ( ! file . delete ( ) ) { fail ( STR_ + file ) ; } } final Properties properties = new Properties ( ) ; properties . setProperty ( Options . FILE , file . toString ( ) ) ; final BigdataSail sail = new BigdataSail ( properties ) ; try { sail . initialize ( ) ; sail . shutDown ( ) ; } finally { if ( ! file . exists ( ) ) { fail ( STR_ + file ) ; if ( ! file . delete ( ) ) { fail ( STR_ + file ) ; } } } }
@ Override public String toString ( ) { String result ; result = null ; if ( isObject ( ) ) { if ( isRoot ( ) ) { result = STR_ ; } else if ( m_Name == null ) { result = STR_ ; } else { result = escape ( m_Name ) + STR_ ; } } else if ( isArray ( ) ) { if ( m_Name == null ) { result = STR_ ; } else { result = escape ( m_Name ) + STR_ ; } } else { if ( m_Name != null ) { result = escape ( m_Name ) + STR_ + escape ( m_Value ) ; } else { result = STR_ + m_Value ; } } return result ; }
public final boolean split_traces_keep_point ( ) { if ( keep_point == null ) return BOOL_ ; ItemSelectionFilter filter = new ItemSelectionFilter ( ItemSelectionChoice . TRACES ) ; Collection < BrdItem > picked_items = r_board . pick_items ( keep_point . keep_point , keep_point . on_layer , filter ) ; for ( BrdItem curr_item : picked_items ) { BrdTracep a_trace = ( BrdTracep ) curr_item ; int line_idx = a_trace . polyline_find_line_idx ( keep_point . keep_point ) ; if ( line_idx < NUM_ ) continue ; ArrayList < BrdTracep > clean_list = a_trace . split_with_end_point ( line_idx , keep_point . keep_point ) ; return clean_list . size ( ) > NUM_ ; } return BOOL_ ; }
public static byte [ ] flipAllBitsInPlace ( byte [ ] bytes , int index , int length ) { int endIndex = Math . min ( bytes . length , index + length ) ; for ( int i = index ; i < endIndex ; i ++ ) { bytes [ i ] = ( byte ) ( bytes [ i ] ^ xff ) ; } return bytes ; }
public CreateIndexRequest source ( String source ) { return source ( source . getBytes ( Charsets . UTF_8 ) ) ; }
private void addUsers ( User [ ] users , LocalConfiguration configuration ) { for ( User user : users ) { configuration . addUser ( user . createUser ( ) ) ; } }
void tryToDrainBuffers ( ) { if ( evictionLock . tryLock ( ) ) { try { drainStatus . lazySet ( PROCESSING ) ; drainBuffers ( ) ; } finally { drainStatus . compareAndSet ( PROCESSING , IDLE ) ; evictionLock . unlock ( ) ; } } }
public void remove ( int i ) { individuals . remove ( i ) ; }
public static boolean copyFile ( File source , File dest ) { File parentDest = dest . getParentFile ( ) ; if ( ! parentDest . exists ( ) ) { if ( ! createDirectory ( parentDest . getAbsolutePath ( ) ) ) { return BOOL_ ; } } try { Files . copy ( source . toPath ( ) , dest . toPath ( ) ) ; return BOOL_ ; } catch ( IOException e ) { e . printStackTrace ( ) ; return BOOL_ ; } }
public static String propertiesEncode ( Properties pp ) { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; try { pp . store ( bos , STR_ ) ; } catch ( IOException e ) { log . log ( Level . SEVERE , STR_ , e ) ; } String result = new String ( bos . toByteArray ( ) ) ; try { result = URLEncoder . encode ( result , MobileEnv . ENCODING ) ; } catch ( UnsupportedEncodingException e ) { log . log ( Level . SEVERE , STR_ + MobileEnv . ENCODING , e ) ; String enc = System . getProperty ( STR_ ) ; try { result = URLEncoder . encode ( result , enc ) ; log . info ( STR_ + enc ) ; } catch ( Exception ex ) { log . log ( Level . SEVERE , STR_ , ex ) ; } } return result ; }
@ Override public void generateRss ( XmlWriter w , ExtensionProfile extProfile ) throws IOException { ArrayList < XmlWriter . Attribute > attrs = new ArrayList < XmlWriter . Attribute > ( NUM_ ) ; if ( mimeType != null ) { attrs . add ( new XmlWriter . Attribute ( STR_ , mimeType . getMediaType ( ) ) ) ; } if ( uri != null ) { attrs . add ( new XmlWriter . Attribute ( STR_ , uri ) ) ; } if ( length != - NUM_ ) { attrs . add ( new XmlWriter . Attribute ( STR_ , Long . toString ( length ) ) ) ; } w . simpleElement ( Namespaces . rssNs , STR_ , attrs , null ) ; }
public void testSortsElementsByName ( ) throws Exception { XppDom dom1 = XppFactory . buildDom ( STR_ ) ; XppDom dom2 = XppFactory . buildDom ( STR_ ) ; assertEquals ( - NUM_ , comparator . compare ( dom1 , dom2 ) ) ; assertEquals ( STR_ , xpath . get ( ) ) ; assertEquals ( NUM_ , comparator . compare ( dom2 , dom1 ) ) ; assertEquals ( STR_ , xpath . get ( ) ) ; }
public static boolean deleteDirectory ( final File path ) { if ( path . exists ( ) ) { File [ ] files = path . listFiles ( ) ; for ( File file : files ) { if ( file . isDirectory ( ) ) { deleteDirectory ( file ) ; } else { file . delete ( ) ; } } } return path . delete ( ) ; }
public void morph ( Component source , Component destination , int duration , Runnable onCompletion ) { morph ( source , destination , duration , BOOL_ , onCompletion ) ; }
public static Timestamp stringToTimeStamp ( String dateTimeString , String dateTimeFormat , TimeZone tz , Locale locale ) throws ParseException { DateFormat dateFormat = toDateTimeFormat ( dateTimeFormat , tz , locale ) ; Date parsedDate = dateFormat . parse ( dateTimeString ) ; return new Timestamp ( parsedDate . getTime ( ) ) ; }
private boolean startsNewHunk ( String string ) { if ( string . length ( ) == NUM_ ) return BOOL_ ; return isLegalChar ( string . charAt ( NUM_ ) ) ; }
public void clearValues ( ) { valueMap . clear ( ) ; }
void addFillComponents ( Container panel , int [ ] cols , int [ ] rows ) { Dimension filler = new Dimension ( NUM_ , NUM_ ) ; boolean filled_cell_11 = BOOL_ ; CellConstraints cc = new CellConstraints ( ) ; if ( cols . length > NUM_ && rows . length > NUM_ ) { if ( cols [ NUM_ ] == NUM_ && rows [ NUM_ ] == NUM_ ) { panel . add ( Box . createRigidArea ( filler ) , cc . xy ( NUM_ , NUM_ ) ) ; filled_cell_11 = BOOL_ ; } } for ( int index = NUM_ ; index < cols . length ; index ++ ) { if ( cols [ index ] == NUM_ && filled_cell_11 ) { continue ; } panel . add ( Box . createRigidArea ( filler ) , cc . xy ( cols [ index ] , NUM_ ) ) ; } for ( int index = NUM_ ; index < rows . length ; index ++ ) { if ( rows [ index ] == NUM_ && filled_cell_11 ) { continue ; } panel . add ( Box . createRigidArea ( filler ) , cc . xy ( NUM_ , rows [ index ] ) ) ; } }
private HashMap < String , byte [ ] > readChars ( byte [ ] d ) { HashMap < String , byte [ ] > hm = new HashMap < String , byte [ ] > ( ) ; int i = findSlashName ( d , STR_ ) ; if ( i < NUM_ ) { return hm ; } PSParser psp = new PSParser ( d , i ) ; while ( BOOL_ ) { String s = psp . readThing ( ) ; char c = s . charAt ( NUM_ ) ; if ( c == STR_ ) { int len = Integer . parseInt ( psp . readThing ( ) ) ; String go = psp . readThing ( ) ; if ( go . equals ( STR_ ) || go . equals ( STR_ ) ) { psp . setLoc ( psp . getLoc ( ) + NUM_ ) ; byte [ ] line = psp . getNEncodedBytes ( len , password , lenIV ) ; hm . put ( s . substring ( NUM_ ) , line ) ; } } else if ( s . equals ( STR_ ) ) { break ; } } return hm ; }
public static byte [ ] stringToByteArray ( String input ) { char chars [ ] = input . toCharArray ( ) ; byte bytes [ ] = new byte [ chars . length ] ; for ( int i = NUM_ ; i < chars . length ; i ++ ) { bytes [ i ] = ( byte ) chars [ i ] ; } return bytes ; }
public void playFileForUser ( String fileName , String userName ) throws SoundPlaybackException { if ( userName == null || userName . isEmpty ( ) ) { userName = appProperties . getProperty ( STR_ ) ; } try { Guild guild = getUsersGuild ( userName ) ; joinUsersCurrentChannel ( userName ) ; playFile ( fileName , guild ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
@ Deprecated public static void runFinalizersOnExit ( boolean run ) { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) { sm . checkExit ( NUM_ ) ; } synchronized ( hooksList ) { finalizeOnExit = run ; } }
public double [ ] [ ] predictIntervals ( double conf ) { updateMeanAndVariance ( ) ; double val = Statistics . normalInverse ( NUM_ - ( NUM_ - conf ) / NUM_ ) ; double [ ] [ ] arr = new double [ NUM_ ] [ NUM_ ] ; arr [ NUM_ ] [ NUM_ ] = m_Mean + val . Math . sqrt ( m_Variance ) ; arr [ NUM_ ] [ NUM_ ] = m_Mean - val . Math . sqrt ( m_Variance ) ; return arr ; }
public static < T > T min ( Collection < ? extends T > collection , Comparator < ? super T > comparator ) { if ( comparator == null ) { @ SuppressWarnings ( STR_ ) T result = ( T ) min ( ( Collection < java . lang . Comparable > ) collection ) ; return result ; } Iterator < ? extends T > it = collection . iterator ( ) ; T min = it . next ( ) ; while ( it . hasNext ( ) ) { T next = it . next ( ) ; if ( comparator . compare ( min , next ) > NUM_ ) { min = next ; } } return min ; }
public static boolean checkSHA ( final String shaHash , final File file ) { if ( TextUtils . isEmpty ( shaHash ) || file == null || ! FileUtils . isReadable ( file ) ) { Log . e ( STR_ ) ; return BOOL_ ; } final String hash = getSHA ( file ) ; if ( hash == null ) { Log . e ( STR_ ) ; return BOOL_ ; } return hash . equalsIgnoreCase ( shaHash ) ; }
public void addValueKeyName ( String key ) { valueKeyNames . add ( key ) ; }
public Assignment update ( Border border ) { Arrays . sort ( cs ) ; int j = NUM_ ; boolean found = ( cs [ NUM_ ] . core == border . core ) ; for ( int i = NUM_ ; i < cs . length ; i ++ ) { if ( cs [ i ] . core != cs [ i - NUM_ ] . core ) { cs [ j ++ ] = cs [ i ] ; } found |= ( cs [ i ] . core == border . core ) ; } if ( found ) { if ( j == NUM_ ) { Border r = cs [ NUM_ ] ; cs = null ; return r ; } if ( j < cs . length ) { cs = Arrays . copyOf ( cs , j ) ; } return this ; } if ( j + NUM_ != cs . length ) { cs = Arrays . copyOf ( cs , j + NUM_ ) ; } cs [ j ] = border ; return this ; }
public static String fromChar ( int value ) { if ( value > xffff ) return null ; String name ; initialize ( ) ; name = ( String ) _byChar . get ( new Integer ( value ) ) ; return name ; }
public static List < String > splitLines ( final String content ) { if ( content == null || content . length ( ) == NUM_ ) return Collections . emptyList ( ) ; String [ ] lines = content . split ( STR_ ) ; return Arrays . asList ( lines ) ; }
@ Override public void draw ( Graphics2D g2 , Rectangle2D area , Point2D anchor , PlotState state , PlotRenderingInfo info ) { boolean b1 = ( area . getWidth ( ) <= MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) <= MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 || b2 ) { return ; } if ( info != null ) { info . setPlotArea ( area ) ; } RectangleInsets insets = getInsets ( ) ; insets . trim ( area ) ; drawChipGrid ( g2 , area ) ; drawWaferEdge ( g2 , area ) ; }
public void addHole ( EdgeRing holeER ) { holeER . setShell ( this ) ; LinearRing hole = holeER . getRing ( ) ; if ( holes == null ) holes = new ArrayList ( ) ; holes . add ( hole ) ; }
private static void registerComponents ( ) { registerComponent ( BarChartComponent . class , BarChartGui . class ) ; registerComponent ( DocViewerComponent . class , DocViewerDesktopComponent . class ) ; registerComponent ( ConsoleComponent . class , ConsoleDesktopComponent . class ) ; registerComponent ( DisplayComponent . class , DisplayComponentDesktopGui . class ) ; registerComponent ( DataWorldComponent . class , DataWorldDesktopComponent . class ) ; registerComponent ( HistogramComponent . class , HistogramGui . class ) ; registerComponent ( NetworkComponent . class , NetworkDesktopComponent . class ) ; registerComponent ( OdorWorldComponent . class , OdorWorldDesktopComponent . class ) ; registerComponent ( PieChartComponent . class , PieChartGui . class ) ; registerComponent ( ProjectionComponent . class , ProjectionGui . class ) ; registerComponent ( ReaderComponent . class , ReaderComponentDesktopGui . class ) ; registerComponent ( ScatterPlotComponent . class , ScatterPlotGui . class ) ; registerComponent ( TimeSeriesPlotComponent . class , TimeSeriesPlotGui . class ) ; registerComponent ( RasterPlotComponent . class , RasterPlotGui . class ) ; registerComponent ( VisionWorldComponent . class , VisionWorldDesktopComponent . class ) ; registerComponent ( GameComponent . class , GameDesktopComponent . class ) ; registerComponent ( DeviceInteractionComponent . class , DeviceInteractionDesktopComponent . class ) ; }
public void addContainer ( ImageContainer container ) { mContainers . add ( container ) ; }
private void initialize ( Class < OpsType > opsType , Interface instance ) throws InstantiationException , IllegalAccessException { mOpsInstance = opsType . newInstance ( ) ; mRetainedFragmentManager . put ( opsType . getSimpleName ( ) , mOpsInstance ) ; mOpsInstance . onConfiguration ( instance , BOOL_ ) ; }
private long skipInputBytes ( long n ) throws IOException { cbLock . lock ( ) ; try { return iis . skipBytes ( n ) ; } finally { cbLock . unlock ( ) ; } }
public byte [ ] generate64BitHashId ( ) throws CryptoException { try { DERBitString publicKeyBitString = encodePublicKeyAsBitString ( publicKey ) ; byte [ ] hash = DigestUtil . getMessageDigest ( publicKeyBitString . getBytes ( ) , DigestType . SHA1 ) ; byte [ ] subHash = Arrays . copyOfRange ( hash , NUM_ , NUM_ ) ; subHash [ NUM_ ] &= x0F ; subHash [ NUM_ ] |= x40 ; return subHash ; } catch ( IOException ex ) { throw new CryptoException ( res . getString ( STR_ ) , ex ) ; } }
public static < C extends ConfigurationClient , S extends Configuration > CreateSubCommandHandler < C , S > create ( SubCommandArgumentParser parser , ManagedObjectPath < ? , ? > p , OptionalRelationDefinition < C , S > r ) throws ArgumentException { return new CreateSubCommandHandler < > ( parser , p , r , null , p . child ( r ) ) ; }
public DSubjectInformationAccess ( JDialog parent , byte [ ] value ) throws IOException { super ( parent ) ; setTitle ( res . getString ( STR_ ) ) ; initComponents ( ) ; prepopulateWithValue ( value ) ; }
public void testSignerStringIdentityScope ( ) throws Exception { Signer s = new SignerStub ( STR_ , IdentityScope . getSystemScope ( ) ) ; assertNotNull ( s ) ; assertEquals ( STR_ , s . getName ( ) ) ; assertSame ( IdentityScope . getSystemScope ( ) , s . getScope ( ) ) ; assertNull ( s . getPrivateKey ( ) ) ; try { Signer s2 = new SignerStub ( STR_ , IdentityScope . getSystemScope ( ) ) ; fail ( STR_ ) ; } catch ( KeyManagementException e ) { } Signer s2 = new SignerStub ( null ) ; assertNull ( s2 . getName ( ) ) ; }
private Figure readLineElement ( IXMLElement elem ) throws IOException { HashMap < AttributeKey , Object > a = new HashMap < AttributeKey , Object > ( ) ; readCoreAttributes ( elem , a ) ; readTransformAttribute ( elem , a ) ; readOpacityAttribute ( elem , a ) ; readLineAttributes ( elem , a ) ; if ( FILL_COLOR . get ( a ) != null && STROKE_COLOR . get ( a ) == null ) { STROKE_COLOR . put ( a , FILL_COLOR . get ( a ) ) ; } if ( FILL_GRADIENT . get ( a ) != null && STROKE_GRADIENT . get ( a ) == null ) { STROKE_GRADIENT . put ( a , FILL_GRADIENT . get ( a ) ) ; } FILL_COLOR . put ( a , null ) ; FILL_GRADIENT . put ( a , null ) ; double x1 = toNumber ( elem , readAttribute ( elem , STR_ , STR_ ) ) ; double y1 = toNumber ( elem , readAttribute ( elem , STR_ , STR_ ) ) ; double x2 = toNumber ( elem , readAttribute ( elem , STR_ , STR_ ) ) ; double y2 = toNumber ( elem , readAttribute ( elem , STR_ , STR_ ) ) ; Figure figure = factory . createLine ( x1 , y1 , x2 , y2 , a ) ; elementObjects . put ( elem , figure ) ; return figure ; }
public ListModel ( final Object [ ] items ) { for ( int i = NUM_ ; i < items . length ; ++ i ) m_items . add ( items [ i ] ) ; }
public boolean isSetCallType ( ) { return __isset_bit_vector . get ( __CALLTYPE_ISSET_ID ) ; }
private IBuffer mapSource ( SourceMapper mapper , IBinaryType info , IClassFile bufferOwner ) { char [ ] contents = mapper . findSource ( getType ( ) , info ) ; if ( contents != null ) { IBuffer buffer = BufferManager . createBuffer ( bufferOwner ) ; if ( buffer == null ) return null ; BufferManager bufManager = getBufferManager ( ) ; bufManager . addBuffer ( buffer ) ; if ( buffer . getCharacters ( ) == null ) { buffer . setContents ( contents ) ; } buffer . addBufferChangedListener ( this ) ; mapper . mapSource ( getOuterMostEnclosingType ( ) , contents , info ) ; return buffer ; } else { IBuffer buffer = BufferManager . createNullBuffer ( bufferOwner ) ; if ( buffer == null ) return null ; BufferManager bufManager = getBufferManager ( ) ; bufManager . addBuffer ( buffer ) ; buffer . addBufferChangedListener ( this ) ; return buffer ; } }
public JFileDataStoreChooser ( Shell parent , int style , final List < String > extensions ) { this ( parent , style , associations ( extensions ) ) ; }
private void computeStaticLoadMetrics ( AccessProfile accessProfile ) throws BaseCollectionException { URI storageSystemId = accessProfile . getSystemId ( ) ; StorageSystem storageSystem = null ; try { storageSystem = _dbClient . queryObject ( StorageSystem . class , storageSystemId ) ; _logger . info ( STR_ , storageSystem . getLabel ( ) ) ; VNXeApiClient client = getVnxUnityClient ( accessProfile ) ; List < VNXeNasServer > nasServers = client . getNasServers ( ) ; for ( VNXeNasServer nasServer : nasServers ) { if ( ( nasServer . getMode ( ) == VNXeNasServer . NasServerModeEnum . DESTINATION ) || nasServer . getIsReplicationDestination ( ) ) { _logger . debug ( STR_ ) ; continue ; } if ( nasServer . getIsSystem ( ) ) { continue ; } VirtualNAS virtualNAS = findvNasByNativeId ( storageSystem , nasServer . getId ( ) ) ; if ( virtualNAS != null ) { _logger . info ( STR_ , nasServer . getName ( ) ) ; StringMap dbMetrics = virtualNAS . getMetrics ( ) ; if ( dbMetrics == null ) { dbMetrics = new StringMap ( ) ; } StringMap tmpDbMetrics = populateDbMetrics ( nasServer , client ) ; dbMetrics . putAll ( tmpDbMetrics ) ; virtualNAS . setMetrics ( dbMetrics ) ; _dbClient . updateObject ( virtualNAS ) ; } } } catch ( Exception e ) { _logger . error ( STR_ , storageSystemId , e ) ; } }
public final short readShort ( ) throws java . io . IOException { readFully ( scratch , NUM_ , NUM_ ) ; return ( short ) ( ( scratch [ NUM_ ] << NUM_ ) | ( scratch [ NUM_ ] & xff ) ) ; }
public ReplicationJob createJobForCopyPartition ( long auditLogId , long auditLogEntryCreateTime , HiveObjectSpec spec ) throws StateUpdateException { Map < String , String > extras = new HashMap < > ( ) ; extras . put ( PersistedJobInfo . AUDIT_LOG_ID_EXTRAS_KEY , Long . toString ( auditLogId ) ) ; extras . put ( PersistedJobInfo . AUDIT_LOG_ENTRY_CREATE_TIME_KEY , Long . toString ( auditLogEntryCreateTime ) ) ; List < String > partitionNames = new ArrayList < > ( ) ; partitionNames . add ( spec . getPartitionName ( ) ) ; ReplicationOperation replicationOperation = ReplicationOperation . COPY_PARTITION ; PersistedJobInfo persistedJobInfo = jobInfoStore . resilientCreate ( replicationOperation , ReplicationStatus . PENDING , Optional . empty ( ) , srcCluster . getName ( ) , spec , partitionNames , Optional . empty ( ) , Optional . empty ( ) , Optional . empty ( ) , extras ) ; ReplicationTask replicationTask = new CopyPartitionTask ( conf , destinationObjectFactory , objectConflictHandler , srcCluster , destCluster , spec , Optional . < Path > empty ( ) , Optional . < Path > empty ( ) , directoryCopier , BOOL_ ) ; return new ReplicationJob ( conf , replicationTask , onStateChangeHandler , persistedJobInfo ) ; }
private void writeAttribute ( java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( namespace . equals ( STR_ ) ) { xmlWriter . writeAttribute ( attName , attValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } }
public static void main ( String ... args ) throws Exception { String [ ] pages = { STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ } ; StringBuilder buff = new StringBuilder ( ) ; for ( String fileName : pages ) { String text = getContent ( fileName ) ; for ( String page : pages ) { text = StringUtils . replaceAll ( text , page + STR_ , STR_ ) ; } text = disableRailroads ( text ) ; text = removeHeaderFooter ( fileName , text ) ; buff . append ( text ) ; } String finalText = buff . toString ( ) ; File output = new File ( BASE_DIR , STR_ ) ; PrintWriter writer = new PrintWriter ( new FileWriter ( output ) ) ; writer . println ( STR_ + STR_ ) ; writer . println ( STR_ ) ; writer . println ( STR_ + STR_ ) ; writer . println ( STR_ ) ; writer . println ( STR_ + Constants . getFullVersion ( ) + STR_ ) ; writer . println ( finalText ) ; writer . println ( STR_ ) ; writer . close ( ) ; }
public static Map < String , Object > findOrders ( DispatchContext dctx , Map < String , ? extends Object > context ) { return findOrders ( dctx , context , BOOL_ ) ; }
public static boolean isFileExist ( String filePath ) { if ( StringUtils . isBlank ( filePath ) ) { return BOOL_ ; } File file = new File ( filePath ) ; return ( file . exists ( ) && file . isFile ( ) ) ; }
public static PronghornStage findStageByPath ( GraphManager m , int ... path ) { int ordinal = path [ NUM_ ] ; int i = NUM_ ; int limit = m . stageIdToStage . length ; while ( i < limit ) { if ( null != m . stageIdToStage [ i ] ) { if ( - NUM_ == m . multInputIds [ m . stageIdToInputsBeginIdx [ m . stageIdToStage [ i ] . stageId ] ] ) { if ( -- ordinal <= NUM_ ) { return findStageByPath ( m , m . stageIdToStage [ i ] , NUM_ , path ) ; } } } i ++ ; } throw new UnsupportedOperationException ( STR_ + path [ NUM_ ] ) ; }
public static double [ ] calculateTStats ( double [ ] coef , double [ ] stderror , int k ) { double [ ] result = new double [ k ] ; for ( int i = NUM_ ; i < k ; i ++ ) { result [ i ] = coef [ i ] / stderror [ i ] ; } return result ; }
static void runBootstrappers ( final CoreEarlyComponent early , final List < HeroicBootstrap > bootstrappers ) throws Exception { for ( final HeroicBootstrap bootstrap : bootstrappers ) { try { bootstrap . run ( early ) ; } catch ( Exception e ) { throw new Exception ( STR_ + bootstrap , e ) ; } } }
public static byte [ ] checkIndexHeaderID ( DataInput in , byte [ ] expectedID ) throws IOException { byte id [ ] = new byte [ StringHelper . ID_LENGTH ] ; in . readBytes ( id , NUM_ , id . length ) ; if ( ! Arrays . equals ( id , expectedID ) ) { throw new CorruptIndexException ( STR_ + StringHelper . idToString ( expectedID ) + STR_ + StringHelper . idToString ( id ) , in ) ; } return id ; }
public byte [ ] toByteArray ( ) { byte [ ] b = output . toByteArray ( ) ; ByteArray . write16bit ( numOfEntries , b , NUM_ ) ; return b ; }
protected void saveBuffer ( String name ) { StringBuffer sb = m_History . getNamedBuffer ( name ) ; if ( sb != null ) { if ( m_SaveOut . save ( sb ) ) { m_Log . logMessage ( STR_ ) ; } } }
public List < Recommendation > scheduleStorage ( VirtualArray srcVarray , Set < URI > requestedVPlexSystems , URI srcStorageSystem , VirtualPool srcVpool , boolean isHARequest , VirtualArray requestedHaVarray , VirtualPool haVpool , VirtualPoolCapabilityValuesWrapper capabilities , Project project , VpoolUse vpoolUse , Map < VpoolUse , List < Recommendation > > currentRecommendations ) { _log . info ( STR_ ) ; if ( ! isHARequest ) { return scheduleStorageForLocalVPLEXVolume ( srcVarray , requestedVPlexSystems , srcStorageSystem , srcVpool , capabilities , project , vpoolUse , currentRecommendations ) ; } else { return scheduleStorageForDistributedVPLEXVolume ( srcVarray , requestedVPlexSystems , srcStorageSystem , srcVpool , requestedHaVarray , haVpool , capabilities , project , vpoolUse , currentRecommendations ) ; } }
@ NotNull public static List < String > completeRelativePath ( @ NotNull String baseDir , @ NotNull String shownBaseDir , @ NotNull String relativePath ) { List < String > result = Lists . newLinkedList ( ) ; String bashBaseDir = OSUtil . toBashCompatible ( baseDir ) ; for ( String path : completeAbsolutePath ( baseDir + File . separator + relativePath , Predicates . < File > alwaysTrue ( ) ) ) { if ( path . startsWith ( bashBaseDir ) ) { result . add ( shownBaseDir + path . substring ( bashBaseDir . length ( ) ) ) ; } } return result ; }
protected boolean isFileSpecifyingModuleSpecifier ( String specifier ) { return specifier . length ( ) > NUM_ && specifier . charAt ( specifier . length ( ) - NUM_ ) != IPath . SEPARATOR ; }
private void insertExpectedPoolSettingsPerTier ( CIMObjectPath capabilitiesPath , Map < String , Object > keyMap ) { List < String > expectedPoolSettingsTier = ( List < String > ) keyMap . get ( Constants . VNXPOOLCAPABILITIES_TIER ) ; expectedPoolSettingsTier . add ( capabilitiesPath . toString ( ) + Constants . HYPHEN + Constants . NO_DATA_MOVEMENT ) ; expectedPoolSettingsTier . add ( capabilitiesPath . toString ( ) + Constants . HYPHEN + Constants . AUTO_TIER ) ; expectedPoolSettingsTier . add ( capabilitiesPath . toString ( ) + Constants . HYPHEN + Constants . HIGH_AVAILABLE_TIER ) ; expectedPoolSettingsTier . add ( capabilitiesPath . toString ( ) + Constants . HYPHEN + Constants . LOW_AVAILABLE_TIER ) ; expectedPoolSettingsTier . add ( capabilitiesPath . toString ( ) + Constants . HYPHEN + Constants . START_HIGH_THEN_AUTO_TIER ) ; }
private static final void transferStreams ( InputStream source , OutputStream destination , String path , IProgressMonitor monitor ) throws CoreException { monitor = Policy . monitorFor ( monitor ) ; try { synchronized ( buffer ) { while ( BOOL_ ) { int bytesRead = - NUM_ ; try { bytesRead = source . read ( buffer ) ; } catch ( IOException e ) { String msg = NLS . bind ( Messages . failedReadDuringWrite , path ) ; Policy . error ( EFS . ERROR_READ , msg , e ) ; } try { if ( bytesRead == - NUM_ ) { destination . close ( ) ; break ; } destination . write ( buffer , NUM_ , bytesRead ) ; } catch ( IOException e ) { String msg = NLS . bind ( Messages . couldNotWrite , path ) ; Policy . error ( EFS . ERROR_WRITE , msg , e ) ; } monitor . worked ( NUM_ ) ; } } } finally { Policy . safeClose ( source ) ; Policy . safeClose ( destination ) ; } }
private int pathPositionAtLevel ( int orgUnitLevel ) { return ( orgUnitLevel - NUM_ ) . NUM_ + NUM_ ; }
private int makeAvailable ( ) { if ( pos != - NUM_ ) { return NUM_ ; } total += tail - head - pad ; System . arraycopy ( buffer , tail - pad , buffer , NUM_ , pad ) ; head = NUM_ ; tail = pad ; for ( ; ; ) { int bytesRead = NUM_ ; try { bytesRead = input . read ( buffer , tail , bufSize - tail ) ; } catch ( IOException e ) { throw new RuntimeException ( STR_ ) ; } if ( bytesRead == - NUM_ ) { final String msg = STR_ ; throw new MalformedStreamException ( msg ) ; } tail += bytesRead ; findSeparator ( ) ; int av = available ( ) ; if ( av > NUM_ || pos != - NUM_ ) { return av ; } } }
protected void addNumericTrainClass ( double classValue , double weight ) { if ( classValue > m_MaxTarget ) { m_MaxTarget = classValue ; } if ( classValue < m_MinTarget ) { m_MinTarget = classValue ; } if ( m_TrainClassVals == null ) { m_TrainClassVals = new double [ NUM_ ] ; m_TrainClassWeights = new double [ NUM_ ] ; } if ( m_NumTrainClassVals == m_TrainClassVals . length ) { double [ ] temp = new double [ m_TrainClassVals . length . NUM_ ] ; System . arraycopy ( m_TrainClassVals , NUM_ , temp , NUM_ , m_TrainClassVals . length ) ; m_TrainClassVals = temp ; temp = new double [ m_TrainClassWeights . length . NUM_ ] ; System . arraycopy ( m_TrainClassWeights , NUM_ , temp , NUM_ , m_TrainClassWeights . length ) ; m_TrainClassWeights = temp ; } m_TrainClassVals [ m_NumTrainClassVals ] = classValue ; m_TrainClassWeights [ m_NumTrainClassVals ] = weight ; m_NumTrainClassVals ++ ; }
private List < Group > parseGroups ( JSONArray groups , String groupType ) throws JSONException , AdeUsageException { if ( groups . length ( ) == NUM_ ) throw new AdeUsageException ( STR_ + groupType ) ; List < Group > currentGroups = new ArrayList < Group > ( ) ; for ( int i = NUM_ ; i < groups . length ( ) ; i ++ ) { JSONObject group = groups . getJSONObject ( i ) ; String name = group . getString ( STR_ ) ; String dataType = group . getString ( STR_ ) ; short evalOrder = group . getShort ( STR_ ) ; String ruleName = group . getString ( STR_ ) ; if ( ! verifyStringParam ( name , NUM_ , STR_ ) || name . equalsIgnoreCase ( STR_ ) || ! validateDataType ( dataType ) || evalOrder < NUM_ || ! verifyStringParam ( ruleName , NUM_ , STR_ ) ) { throw new AdeUsageException ( STR_ + groupType + STR_ ) ; } currentGroups . add ( new Group ( name , GroupType . valueOf ( groupType ) , DataType . valueOf ( dataType . toUpperCase ( ) ) , evalOrder , ruleName ) ) ; } validateEvaluationOrderAndName ( currentGroups ) ; return currentGroups ; }
private void translateMatrixAfterRotate ( int axis , float trans , float prevImageSize , float imageSize , int prevViewSize , int viewSize , int drawableSize ) { if ( imageSize < viewSize ) { m [ axis ] = ( viewSize - ( drawableSize . m [ Matrix . MSCALE_X ] ) ) . NUM_ ; } else if ( trans > NUM_ ) { m [ axis ] = - ( ( imageSize - viewSize ) . NUM_ ) ; } else { float percentage = ( Math . abs ( trans ) + ( NUM_ . prevViewSize ) ) / prevImageSize ; m [ axis ] = - ( ( percentage . imageSize ) - ( viewSize . NUM_ ) ) ; } }
public DoubleFft1d ( int n ) { if ( n < NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } this . n = n ; if ( ! ConcurrencyUtils . isPowerOf2 ( n ) ) { if ( getReminder ( n , factors ) >= NUM_ ) { plan = Plans . BLUESTEIN ; nBluestein = ConcurrencyUtils . nextPow2 ( n . NUM_ - NUM_ ) ; bk1 = new double [ NUM_ . nBluestein ] ; bk2 = new double [ NUM_ . nBluestein ] ; this . ip = new int [ NUM_ + ( int ) Math . ceil ( NUM_ + ( NUM_ << ( int ) ( Math . log ( nBluestein + NUM_ ) / Math . log ( NUM_ ) ) / NUM_ ) ) ] ; this . w = new double [ nBluestein ] ; int twon = NUM_ . nBluestein ; nw = ip [ NUM_ ] ; if ( twon > ( nw << NUM_ ) ) { nw = twon > > NUM_ ; makewt ( nw ) ; } nc = ip [ NUM_ ] ; if ( nBluestein > ( nc << NUM_ ) ) { nc = nBluestein > > NUM_ ; makect ( nc , w , nw ) ; } bluesteini ( ) ; } else { plan = Plans . MIXED_RADIX ; wtable = new double [ NUM_ . n + NUM_ ] ; wtable_r = new double [ NUM_ . n + NUM_ ] ; cffti ( ) ; rffti ( ) ; } } else { plan = Plans . SPLIT_RADIX ; this . ip = new int [ NUM_ + ( int ) Math . ceil ( NUM_ + ( NUM_ << ( int ) ( Math . log ( n + NUM_ ) / Math . log ( NUM_ ) ) / NUM_ ) ) ] ; this . w = new double [ n ] ; int twon = NUM_ . n ; nw = ip [ NUM_ ] ; if ( twon > ( nw << NUM_ ) ) { nw = twon > > NUM_ ; makewt ( nw ) ; } nc = ip [ NUM_ ] ; if ( n > ( nc << NUM_ ) ) { nc = n > > NUM_ ; makect ( nc , w , nw ) ; } } }
@ Override public void dragGestureRecognized ( DragGestureEvent evt ) { DragEntry dragEntry = kseFrame . dragSelectedEntry ( ) ; if ( dragEntry == null ) { return ; } ImageIcon icon = dragEntry . getImage ( ) ; Toolkit toolkit = Toolkit . getDefaultToolkit ( ) ; Dimension dim = toolkit . getBestCursorSize ( icon . getIconWidth ( ) , icon . getIconHeight ( ) ) ; BufferedImage buffImage = new BufferedImage ( dim . width , dim . height , BufferedImage . TYPE_INT_ARGB_PRE ) ; icon . paintIcon ( evt . getComponent ( ) , buffImage . getGraphics ( ) , NUM_ , NUM_ ) ; cursor = toolkit . createCustomCursor ( buffImage , new Point ( NUM_ , NUM_ ) , STR_ ) ; evt . startDrag ( cursor , new KeyStoreEntryTransferable ( dragEntry ) , this ) ; }
public static boolean isIdentifierHelperChar ( char ch ) { return STR_ == ch || STR_ == ch || STR_ == ch || STR_ == ch ; }
public void addHeader ( String line ) { header . add ( line ) ; }
public static IAddress loadAddress ( final ResultSet resultSet , final String columnName ) throws SQLException { Preconditions . checkNotNull ( resultSet , STR_ ) ; Preconditions . checkNotNull ( columnName , STR_ ) ; final String addressString = readString ( resultSet , columnName ) ; return resultSet . wasNull ( ) ? null : new CAddress ( new BigInteger ( addressString ) ) ; }
private static String encode ( String stringToEncode ) { String encoded ; try { encoded = URLEncoder . encode ( stringToEncode , UTF_8 ) ; } catch ( UnsupportedEncodingException e ) { throw new MCApiRuntimeException ( e ) ; } encoded = encoded . replace ( STR_ , STR_ ) ; encoded = encoded . replace ( STR_ , STR_ ) ; encoded = encoded . replace ( STR_ , STR_ ) ; return encoded ; }
public static String toGetUrl ( String url , Bundle params ) { if ( params != null ) { if ( ! url . endsWith ( STR_ ) ) { url = url + STR_ ; } for ( String key : params . keySet ( ) ) { url = url + key + STR_ + params . getString ( key ) + STR_ ; } } return url ; }
public void namespaceAfterStartElement ( String prefix , String uri ) throws SAXException { if ( m_firstTagNotEmitted && m_firstElementURI == null && m_firstElementName != null ) { String prefix1 = getPrefixPart ( m_firstElementName ) ; if ( prefix1 == null && EMPTYSTRING . equals ( prefix ) ) { m_firstElementURI = uri ; } } startPrefixMapping ( prefix , uri , BOOL_ ) ; }
protected static String guessType ( File file ) { String name = file . getName ( ) ; String suffix = name . substring ( name . lastIndexOf ( STR_ ) + NUM_ ) ; return mimeMap . get ( suffix . toLowerCase ( Locale . ROOT ) ) ; }
public void testAdvanceAllTerms ( ) throws Exception { List < String > termsList = new ArrayList < > ( ) ; termsList . addAll ( Arrays . asList ( commonTerms ) ) ; termsList . addAll ( Arrays . asList ( mediumTerms ) ) ; termsList . addAll ( Arrays . asList ( rareTerms ) ) ; String terms [ ] = termsList . toArray ( new String [ NUM_ ] ) ; for ( int amount = NUM_ ; amount < NUM_ ; amount += NUM_ ) { for ( int minNrShouldMatch = NUM_ ; minNrShouldMatch <= terms . length ; minNrShouldMatch ++ ) { Scorer expected = scorer ( terms , minNrShouldMatch , Mode . DOC_VALUES ) ; Scorer actual = scorer ( terms , minNrShouldMatch , Mode . SCORER ) ; assertAdvance ( expected , actual , amount ) ; expected = scorer ( terms , minNrShouldMatch , Mode . DOC_VALUES ) ; actual = scorer ( terms , minNrShouldMatch , Mode . BULK_SCORER ) ; assertAdvance ( expected , actual , amount ) ; } } }
public boolean isPublic ( ) { return Modifier . isPublic ( getAccessFlags ( ) ) ; }
public boolean releaseEncumbranceBudget ( final Map < String , Object > detailsMap ) { if ( detailsMap == null ) throw new ValidationException ( Arrays . asList ( new ValidationError ( STR_ , STR_ ) ) ) ; detailsMap . put ( Constants . CONSUMEORRELEASE , BOOL_ ) ; final BigDecimal bd = getDetails ( detailsMap ) ; return bd . intValue ( ) == NUM_ ; }
protected Transferable createLocaleTransferable ( long [ ] formats ) throws IOException { return null ; }
public void putLength ( int len ) throws IOException { if ( len < NUM_ ) { write ( ( byte ) len ) ; } else if ( len < ( NUM_ << NUM_ ) ) { write ( ( byte ) x081 ) ; write ( ( byte ) len ) ; } else if ( len < ( NUM_ << NUM_ ) ) { write ( ( byte ) x082 ) ; write ( ( byte ) ( len > > NUM_ ) ) ; write ( ( byte ) len ) ; } else if ( len < ( NUM_ << NUM_ ) ) { write ( ( byte ) x083 ) ; write ( ( byte ) ( len > > NUM_ ) ) ; write ( ( byte ) ( len > > NUM_ ) ) ; write ( ( byte ) len ) ; } else { write ( ( byte ) x084 ) ; write ( ( byte ) ( len > > NUM_ ) ) ; write ( ( byte ) ( len > > NUM_ ) ) ; write ( ( byte ) ( len > > NUM_ ) ) ; write ( ( byte ) len ) ; } }
public void putGenericFontFamily ( String familyName , Font font ) { genericFontFamilies . put ( familyName . toLowerCase ( ) , font ) ; }
private boolean writeReference ( Object value , NodeMap node ) { String name = get ( value ) ; int size = size ( ) ; if ( name != null ) { node . put ( refer , name ) ; return BOOL_ ; } String unique = String . valueOf ( size ) ; node . put ( mark , unique ) ; put ( value , unique ) ; return BOOL_ ; }
private NSObject parseData ( ) throws ParseException { NSObject obj = null ; skip ( ) ; if ( accept ( DATA_GSOBJECT_BEGIN_TOKEN ) ) { skip ( ) ; expect ( DATA_GSBOOL_BEGIN_TOKEN , DATA_GSDATE_BEGIN_TOKEN , DATA_GSINT_BEGIN_TOKEN , DATA_GSREAL_BEGIN_TOKEN ) ; if ( accept ( DATA_GSBOOL_BEGIN_TOKEN ) ) { skip ( ) ; expect ( DATA_GSBOOL_TRUE_TOKEN , DATA_GSBOOL_FALSE_TOKEN ) ; if ( accept ( DATA_GSBOOL_TRUE_TOKEN ) ) { obj = new NSNumber ( BOOL_ ) ; } else { obj = new NSNumber ( BOOL_ ) ; } skip ( ) ; } else if ( accept ( DATA_GSDATE_BEGIN_TOKEN ) ) { skip ( ) ; String dateString = readInputUntil ( DATA_END_TOKEN ) ; obj = new NSDate ( dateString ) ; } else if ( accept ( DATA_GSINT_BEGIN_TOKEN , DATA_GSREAL_BEGIN_TOKEN ) ) { skip ( ) ; String numberString = readInputUntil ( DATA_END_TOKEN ) ; obj = new NSNumber ( numberString ) ; } read ( DATA_END_TOKEN ) ; } else { String dataString = readInputUntil ( DATA_END_TOKEN ) ; dataString = dataString . replaceAll ( STR_ , STR_ ) ; int numBytes = dataString . length ( ) / NUM_ ; byte [ ] bytes = new byte [ numBytes ] ; for ( int i = NUM_ ; i < bytes . length ; i ++ ) { String byteString = dataString . substring ( i . NUM_ , i . NUM_ + NUM_ ) ; int byteValue = Integer . parseInt ( byteString , NUM_ ) ; bytes [ i ] = ( byte ) byteValue ; } obj = new NSData ( bytes ) ; skip ( ) ; } return obj ; }
public boolean empty ( ) { return individuals . size ( ) == NUM_ ; }
@ Override public String format ( DateTimeFormatter formatter ) { Objects . requireNonNull ( formatter , STR_ ) ; return formatter . format ( this ) ; }
public @ DottedClassName String toDottedClassName ( ) { return ClassName . toDottedClassName ( className ) ; }
public DAddExtensions ( JFrame parent , String title , X509ExtensionSet extensions , PublicKey authorityPublicKey , X500Name authorityCertName , BigInteger authorityCertSerialNumber , PublicKey subjectPublicKey ) { super ( parent , Dialog . ModalityType . DOCUMENT_MODAL ) ; setTitle ( res . getString ( STR_ ) ) ; this . extensions = extensions ; this . authorityPublicKey = authorityPublicKey ; this . authorityCertName = authorityCertName ; this . authorityCertSerialNumber = authorityCertSerialNumber ; this . subjectPublicKey = subjectPublicKey ; initComponents ( ) ; }
private void playNext ( ) { if ( mediaType == Config . YOUTUBE_MEDIA_TYPE_VIDEO ) { seekVideo ( NUM_ ) ; restartVideo ( ) ; return ; } if ( previousWasCalled ) { previousWasCalled = BOOL_ ; iterator . next ( ) ; } if ( ! iterator . hasNext ( ) ) { iterator = youTubeVideos . listIterator ( ) ; } videoItem = iterator . next ( ) ; nextWasCalled = BOOL_ ; playVideo ( ) ; }
public static < T > T invokeMethod ( Object obj , String name , Object ... params ) throws NoSuchMethodException { Class [ ] paramTypes = getParamTypes ( params ) ; final Class < ? > aClass = obj . getClass ( ) ; Method method ; try { method = aClass . getDeclaredMethod ( name , paramTypes ) ; } catch ( NoSuchMethodException e ) { method = aClass . getMethod ( name , paramTypes ) ; } method . setAccessible ( BOOL_ ) ; try { return ( T ) method . invoke ( obj , params ) ; } catch ( IllegalAccessException | InvocationTargetException e ) { throw new RuntimeException ( e ) ; } }
public void addNodes ( NodeIterator iterator ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; if ( null != iterator ) { Node obj ; while ( null != ( obj = iterator . nextNode ( ) ) ) { addElement ( obj ) ; } } }
public static RotateStream create ( Path path ) { synchronized ( _streams ) { WeakReference < RotateStream > ref = _streams . get ( path ) ; RotateStream stream = ref != null ? ref . get ( ) : null ; if ( stream == null ) { stream = new RotateStream ( path ) ; _streams . put ( path , new WeakReference < > ( stream ) ) ; } return stream ; } }
private void cleanUpHistory ( ) { if ( ! mHistoryOfNumbers . isEmpty ( ) && mHistoryOfNumbers . size ( ) >= MAX_HISTORY_SIZE ) { for ( int i = NUM_ ; i < Math . max ( NUM_ , MAX_HISTORY_SIZE / NUM_ ) ; i ++ ) { mPreviousNumbers . remove ( mHistoryOfNumbers . removeFirst ( ) ) ; } } }
@ SuppressWarnings ( STR_ ) protected void processStyledAttributes ( @ NonNull TypedArray a ) { float targetAspectRatioX = Math . abs ( a . getFloat ( R . styleable . ucrop_UCropView_ucrop_aspect_ratio_x , DEFAULT_ASPECT_RATIO ) ) ; float targetAspectRatioY = Math . abs ( a . getFloat ( R . styleable . ucrop_UCropView_ucrop_aspect_ratio_y , DEFAULT_ASPECT_RATIO ) ) ; if ( targetAspectRatioX == SOURCE_IMAGE_ASPECT_RATIO || targetAspectRatioY == SOURCE_IMAGE_ASPECT_RATIO ) { mTargetAspectRatio = SOURCE_IMAGE_ASPECT_RATIO ; } else { mTargetAspectRatio = targetAspectRatioX / targetAspectRatioY ; } }
public LogMessage ( String template , int code ) { this ( template , null , EMPTY_STRING_ARRAY , code , Optional . empty ( ) ) ; }
protected String action_translate ( String act_string , int act_pos , Hashtable label_map , Hashtable label_types ) { int id_start ; int pos ; int len ; String id_str ; boolean in_id ; StringBuffer result ; char buffer [ ] ; if ( act_string == null || act_string . length ( ) == NUM_ ) return act_string ; len = act_string . length ( ) ; result = new StringBuffer ( len + NUM_ ) ; buffer = new char [ len + NUM_ ] ; act_string . getChars ( NUM_ , len , buffer , NUM_ ) ; buffer [ len ] = STR_ ; in_id = BOOL_ ; for ( pos = id_start = NUM_ ; pos <= len ; pos ++ ) { if ( in_id ) { if ( ! is_id_char ( buffer [ pos ] ) ) { id_str = new String ( buffer , id_start , pos - id_start ) ; result . append ( label_translate ( id_str , act_pos , label_map , label_types ) ) ; if ( buffer [ pos ] != STR_ ) result . append ( buffer , pos , NUM_ ) ; in_id = BOOL_ ; } else { } } else { if ( is_id_start ( buffer [ pos ] ) ) { in_id = BOOL_ ; id_start = pos ; } else { if ( buffer [ pos ] != STR_ ) result . append ( buffer , pos , NUM_ ) ; } } } return result . toString ( ) ; }
public boolean canLoad ( ) { return BOOL_ ; }
public boolean bool ( ) { return ( Double . isNaN ( m_val ) || ( m_val == NUM_ ) ) ? BOOL_ : BOOL_ ; }
public String generateXML ( String sessionID , String versionName , long installAge , RequestData data ) throws RequestFailureException { XmlSerializer serializer = Xml . newSerializer ( ) ; StringWriter writer = new StringWriter ( ) ; try { serializer . setOutput ( writer ) ; serializer . startDocument ( STR_ , BOOL_ ) ; serializer . startTag ( null , STR_ ) ; serializer . attribute ( null , STR_ , STR_ ) ; serializer . attribute ( null , STR_ , STR_ ) ; serializer . attribute ( null , STR_ , STR_ ) ; serializer . attribute ( null , STR_ , STR_ + data . getRequestID ( ) + STR_ ) ; serializer . attribute ( null , STR_ , STR_ + sessionID + STR_ ) ; serializer . attribute ( null , STR_ , data . getInstallSource ( ) ) ; appendExtraAttributes ( STR_ , serializer ) ; serializer . startTag ( null , STR_ ) ; serializer . attribute ( null , STR_ , STR_ ) ; serializer . attribute ( null , STR_ , Build . VERSION . RELEASE ) ; serializer . attribute ( null , STR_ , STR_ ) ; serializer . endTag ( null , STR_ ) ; serializer . startTag ( null , STR_ ) ; serializer . attribute ( null , STR_ , getBrand ( ) ) ; serializer . attribute ( null , STR_ , getClient ( ) ) ; serializer . attribute ( null , STR_ , getAppId ( ) ) ; serializer . attribute ( null , STR_ , versionName ) ; serializer . attribute ( null , STR_ , STR_ ) ; serializer . attribute ( null , STR_ , getLanguage ( ) ) ; serializer . attribute ( null , STR_ , String . valueOf ( installAge ) ) ; serializer . attribute ( null , STR_ , getAdditionalParameters ( ) ) ; appendExtraAttributes ( STR_ , serializer ) ; if ( data . isSendInstallEvent ( ) ) { serializer . startTag ( null , STR_ ) ; serializer . attribute ( null , STR_ , STR_ ) ; serializer . attribute ( null , STR_ , STR_ ) ; serializer . endTag ( null , STR_ ) ; } else { serializer . startTag ( null , STR_ ) ; serializer . endTag ( null , STR_ ) ; serializer . startTag ( null , STR_ ) ; serializer . attribute ( null , STR_ , STR_ ) ; serializer . endTag ( null , STR_ ) ; } serializer . endTag ( null , STR_ ) ; serializer . endTag ( null , STR_ ) ; serializer . endDocument ( ) ; } catch ( IOException e ) { throw new RequestFailureException ( STR_ , e ) ; } catch ( IllegalArgumentException e ) { throw new RequestFailureException ( STR_ , e ) ; } catch ( IllegalStateException e ) { throw new RequestFailureException ( STR_ , e ) ; } return writer . toString ( ) ; }
protected boolean strictParseBoolean ( String s ) { if ( s == null || s . isEmpty ( ) ) { throw new IllegalArgumentException ( STR_ ) ; } if ( s . equalsIgnoreCase ( STR_ ) ) { return BOOL_ ; } if ( s . equalsIgnoreCase ( STR_ ) ) { return BOOL_ ; } throw new IllegalArgumentException ( STR_ + s ) ; }
@ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case FunctionblockPackage . EVENT__NAME : return NAME_EDEFAULT == null ? name != null : ! NAME_EDEFAULT . equals ( name ) ; case FunctionblockPackage . EVENT__PROPERTIES : return properties != null && ! properties . isEmpty ( ) ; } return super . eIsSet ( featureID ) ; }
public String format ( DateTimeFormatter formatter ) { Objects . requireNonNull ( formatter , STR_ ) ; return formatter . format ( this ) ; }
private void initializeSourceCodeMap ( String adaptedContent ) { sourceCodeWithLine = new LinkedHashMap < > ( ) ; int lineNumber = NUM_ ; StringReader sr = new StringReader ( adaptedContent ) ; BufferedReader br = new BufferedReader ( sr ) ; String line ; try { while ( ( line = br . readLine ( ) ) != null ) { sourceCodeWithLine . put ( lineNumber , line ) ; lineNumber ++ ; } } catch ( IOException ex ) { LOGGER . error ( STR_ + ex . getMessage ( ) ) ; } }
@ Override public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { if ( oldVersion != newVersion ) { if ( newVersion == NUM_ && oldVersion == NUM_ ) { WXLogUtils . d ( TAG_STORAGE , STR_ + oldVersion + STR_ + newVersion ) ; boolean updateResult = BOOL_ ; try { long start = System . currentTimeMillis ( ) ; db . beginTransaction ( ) ; String SQL_ADD_COLUMN_TIMESTAMP = STR_ + TABLE_STORAGE + STR_ + COLUMN_TIMESTAMP + STR_ ; WXLogUtils . d ( TAG_STORAGE , STR_ + SQL_ADD_COLUMN_TIMESTAMP ) ; db . execSQL ( SQL_ADD_COLUMN_TIMESTAMP ) ; String SQL_ADD_COLUMN_PERSISTENT = STR_ + TABLE_STORAGE + STR_ + COLUMN_PERSISTENT + STR_ ; WXLogUtils . d ( TAG_STORAGE , STR_ + SQL_ADD_COLUMN_PERSISTENT ) ; db . execSQL ( SQL_ADD_COLUMN_PERSISTENT ) ; String SQL_UPDATE_TABLE = STR_ + TABLE_STORAGE + STR_ + COLUMN_TIMESTAMP + STR_ + sDateFormatter . format ( new Date ( ) ) + STR_ + COLUMN_PERSISTENT + STR_ ; WXLogUtils . d ( TAG_STORAGE , STR_ + SQL_UPDATE_TABLE ) ; db . execSQL ( SQL_UPDATE_TABLE ) ; db . setTransactionSuccessful ( ) ; long time = System . currentTimeMillis ( ) - start ; WXLogUtils . d ( TAG_STORAGE , STR_ + time + STR_ ) ; } catch ( Exception e ) { WXLogUtils . d ( TAG_STORAGE , STR_ + oldVersion + STR_ + newVersion + STR_ + e . getMessage ( ) ) ; updateResult = BOOL_ ; } finally { db . endTransaction ( ) ; } if ( ! updateResult ) { WXLogUtils . d ( TAG_STORAGE , STR_ ) ; deleteDB ( ) ; onCreate ( db ) ; } } else { deleteDB ( ) ; onCreate ( db ) ; } } }
public Matrix U ( ) { return U . clone ( ) ; }
protected Set < String > allowedDuplicateErrorCodes ( ) { return Collections . emptySet ( ) ; }
private boolean isFieldVisited ( Object object , Field objectField , Field field ) { Map < String , Set < String > > bag = visitedFields . get ( object ) ; if ( bag == null ) { return BOOL_ ; } String objectFiledKey = objectField == null ? STR_ : objectField . toGenericString ( ) ; Set < String > fields = bag . get ( objectFiledKey ) ; return fields != null && fields . contains ( field ) ; }
public void removeFromCompletedList ( DownloadInfoRunnable downloadInfoRunnable ) { mCompletedList . remove ( downloadInfoRunnable ) ; }
protected void addShingledPhraseQueries ( final BooleanQuery mainQuery , final List < Clause > clauses , final Collection < FieldParams > fields , int shingleSize , final float tiebreaker , final int slop ) throws SyntaxError { if ( null == fields || fields . isEmpty ( ) || null == clauses || clauses . size ( ) < shingleSize ) return ; if ( NUM_ == shingleSize ) shingleSize = clauses . size ( ) ; final int lastClauseIndex = shingleSize - NUM_ ; StringBuilder userPhraseQuery = new StringBuilder ( ) ; for ( int i = NUM_ ; i < clauses . size ( ) - lastClauseIndex ; i ++ ) { userPhraseQuery . append ( STR_ ) ; for ( int j = NUM_ ; j <= lastClauseIndex ; j ++ ) { userPhraseQuery . append ( clauses . get ( i + j ) . val ) ; userPhraseQuery . append ( STR_ ) ; } userPhraseQuery . append ( STR_ ) ; userPhraseQuery . append ( STR_ ) ; } ExtendedSolrQueryParser pp = createEdismaxQueryParser ( this , IMPOSSIBLE_FIELD_NAME ) ; pp . addAlias ( IMPOSSIBLE_FIELD_NAME , tiebreaker , getFieldBoosts ( fields ) ) ; pp . setPhraseSlop ( slop ) ; pp . setRemoveStopFilter ( BOOL_ ) ; pp . makeDismax = BOOL_ ; pp . minClauseSize = NUM_ ; Query phrase = pp . parse ( userPhraseQuery . toString ( ) ) ; if ( phrase != null ) { mainQuery . add ( phrase , BooleanClause . Occur . SHOULD ) ; } }
public String asXmlId ( ) { return DatatypeConverter . printHexBinary ( tokenDigest . getValue ( ) ) ; }
private void updateInfo ( ) { m_updating = BOOL_ ; nameField . setText ( m_cc . getName ( ) ) ; appsHostField . setText ( m_cc . getAppsHost ( ) ) ; appsPortField . setText ( String . valueOf ( m_cc . getAppsPort ( ) ) ) ; bTestApps . setIcon ( getStatusIcon ( m_cc . isAppsServerOK ( BOOL_ ) ) ) ; boolean rw = CConnection . isServerEmbedded ( ) ? BOOL_ : ! m_cc . isAppsServerOK ( BOOL_ ) ; dbTypeLabel . setReadWrite ( rw ) ; dbTypeField . setReadWrite ( rw ) ; dbTypeField . setSelectedItem ( m_cc . getType ( ) ) ; hostLabel . setReadWrite ( rw ) ; hostField . setReadWrite ( rw ) ; hostField . setText ( m_cc . getDbHost ( ) ) ; portLabel . setReadWrite ( rw ) ; dbPortField . setReadWrite ( rw ) ; dbPortField . setText ( String . valueOf ( m_cc . getDbPort ( ) ) ) ; sidLabel . setReadWrite ( rw ) ; sidField . setReadWrite ( rw ) ; sidField . setText ( m_cc . getDbName ( ) ) ; dbUidLabel . setReadWrite ( rw ) ; dbUidField . setReadWrite ( rw ) ; dbUidField . setText ( m_cc . getDbUid ( ) ) ; dbPwdField . setEditable ( rw ) ; dbPwdField . setText ( m_cc . getDbPwd ( ) ) ; cbBequeath . setReadWrite ( rw ) ; cbBequeath . setEnabled ( m_cc . isOracle ( ) ) ; cbBequeath . setSelected ( m_cc . isBequeath ( ) ) ; boolean fwEnabled = rw && m_cc . isViaFirewall ( ) && m_cc . isOracle ( ) ; cbFirewall . setReadWrite ( rw && m_cc . isOracle ( ) ) ; cbFirewall . setSelected ( m_cc . isViaFirewall ( ) ) ; fwHostLabel . setReadWrite ( fwEnabled ) ; fwHostField . setReadWrite ( fwEnabled ) ; fwHostField . setText ( m_cc . getFwHost ( ) ) ; fwPortLabel . setReadWrite ( fwEnabled ) ; fwPortField . setReadWrite ( fwEnabled ) ; fwPortField . setText ( String . valueOf ( m_cc . getFwPort ( ) ) ) ; bTestDB . setToolTipText ( m_cc . getConnectionURL ( ) ) ; bTestDB . setIcon ( getStatusIcon ( m_cc . isDatabaseOK ( ) ) ) ; m_updating = BOOL_ ; }
public void createSnapshot ( ) throws BackupException { logger . debug ( STR_ + this . snapshotName ) ; processHelper . exec ( STR_ , lvcreateCmd ) ; }
public final Uri storeLogFile ( final LogFile logFile , final int sessionId ) { final ContentValues values = new ContentValues ( ) ; values . put ( Schema . COL_MANUFACTURER , logFile . getManufacturer ( ) ) ; values . put ( Schema . COL_MODEL , logFile . getModel ( ) ) ; values . put ( Schema . COL_REVISION , logFile . getRevision ( ) ) ; values . put ( Schema . COL_SWID , logFile . getSwid ( ) ) ; values . put ( Schema . COL_SWVER , logFile . getSwVersion ( ) ) ; values . put ( Schema . COL_TIMESTAMP , System . currentTimeMillis ( ) ) ; values . put ( Schema . COL_SESSION_ID , sessionId ) ; return contentResolver . insert ( ContentProvider . CONTENT_URI_LOGFILE , values ) ; }
public Map < String , String > merge ( Map < String , String > curProps , Map < String , String > newProps ) throws IOException { Map < String , String > props = new HashMap < > ( newProps ) ; for ( Map . Entry < String , String > e : curProps . entrySet ( ) ) { String name = e . getKey ( ) ; String curValue = e . getValue ( ) ; if ( props . containsKey ( name ) ) { props . put ( name , curValue ) ; } } return props ; }
@ Override public void addFocusables ( ArrayList < View > views , int direction , int focusableMode ) { final int focusableCount = views . size ( ) ; final int descendantFocusability = getDescendantFocusability ( ) ; if ( descendantFocusability != FOCUS_BLOCK_DESCENDANTS ) { for ( int i = NUM_ ; i < getChildCount ( ) ; i ++ ) { final View child = getChildAt ( i ) ; if ( child . getVisibility ( ) == VISIBLE ) { ItemInfo ii = infoForChild ( child ) ; if ( ii != null && ii . position == mCurItem ) { child . addFocusables ( views , direction , focusableMode ) ; } } } } if ( descendantFocusability != FOCUS_AFTER_DESCENDANTS || ( focusableCount == views . size ( ) ) ) { if ( ! isFocusable ( ) ) { return ; } if ( ( focusableMode & FOCUSABLES_TOUCH_MODE ) == FOCUSABLES_TOUCH_MODE && isInTouchMode ( ) && ! isFocusableInTouchMode ( ) ) { return ; } if ( views != null ) { views . add ( this ) ; } } }
public Builder deletePreferredLanguage ( ) { deleteFields . add ( STR_ ) ; return this ; }
public void onPrepared ( MediaPlayer player ) { mState = State . PLAYING ; updateNotification ( String . format ( getString ( R . string . media_state_playing ) , mFile . getFileName ( ) ) ) ; if ( mMediaController != null ) { mMediaController . setEnabled ( BOOL_ ) ; } player . seekTo ( mStartPosition ) ; configAndStartMediaPlayer ( ) ; if ( ! mPlayOnPrepared ) { processPauseRequest ( ) ; } if ( mMediaController != null ) { mMediaController . updatePausePlay ( ) ; } }
private void parseParameter ( String token , String value ) { if ( token != null && value != null ) { if ( token . equalsIgnoreCase ( NONCE_TOKEN ) ) { mNonce = value ; return ; } if ( token . equalsIgnoreCase ( STALE_TOKEN ) ) { parseStale ( value ) ; return ; } if ( token . equalsIgnoreCase ( OPAQUE_TOKEN ) ) { mOpaque = value ; return ; } if ( token . equalsIgnoreCase ( QOP_TOKEN ) ) { mQop = value . toLowerCase ( ) ; return ; } if ( token . equalsIgnoreCase ( ALGORITHM_TOKEN ) ) { mAlgorithm = value . toLowerCase ( ) ; return ; } } }
public List < String > makeURLList ( String shard ) { List < String > urls = StrUtils . splitSmart ( shard , STR_ , BOOL_ ) ; for ( int i = NUM_ ; i < urls . size ( ) ; i ++ ) { urls . set ( i , buildUrl ( urls . get ( i ) ) ) ; } if ( urls . size ( ) > NUM_ ) Collections . shuffle ( urls , r ) ; return urls ; }
public void skip ( int n ) throws IOException { dis . skip ( n ) ; }
public void addContainer ( ImageContainer container ) { mContainers . add ( container ) ; }
public void toAllInRadius ( WorldServer world , Vec3d pos , double radius ) { double maxDistance = radius . radius + radius . radius + radius . radius ; toAll ( world . getPlayers ( EntityPlayerMP . class , null ) ) ; }
public static ECDHECryptography fromNamedCurveId ( int supportedGroupId ) { SupportedGroup group = SupportedGroup . fromId ( supportedGroupId ) ; if ( group == null ) { return null ; } else { try { return new ECDHECryptography ( group . name ( ) ) ; } catch ( GeneralSecurityException e ) { LOGGER . log ( Level . WARNING , STR_ , new Object [ ] { group . name ( ) , e . getMessage ( ) } ) ; return null ; } } }
private boolean journalRebuildRequired ( ) { final int redundantOpCompactThreshold = NUM_ ; return redundantOpCount >= redundantOpCompactThreshold && redundantOpCount >= lruEntries . size ( ) ; }
private static void addHeader ( Message message , String name , String value ) { Map < String , List < String > > protocolHeaders = CastUtils . cast ( ( Map < ? , ? > ) message . get ( Message . PROTOCOL_HEADERS ) ) ; if ( protocolHeaders == null ) { protocolHeaders = new TreeMap < String , List < String > > ( String . CASE_INSENSITIVE_ORDER ) ; message . put ( Message . PROTOCOL_HEADERS , protocolHeaders ) ; } List < String > header = CastUtils . cast ( ( List < ? > ) protocolHeaders . get ( name ) ) ; if ( header == null ) { header = new ArrayList < String > ( ) ; protocolHeaders . put ( name , header ) ; } if ( header . size ( ) == NUM_ ) { header . add ( value ) ; } else { header . set ( NUM_ , header . get ( NUM_ ) + STR_ + value ) ; } }
public String asString ( ) { StringBuilder buff = new StringBuilder ( ) ; for ( int i = NUM_ ; i < arrayLevel ; i ++ ) { if ( refCount ) { buff . append ( STR_ ) ; } buff . append ( STR_ ) ; } if ( refCount ) { if ( ! classObj . isPrimitive ) { buff . append ( STR_ ) ; } } buff . append ( classObj . toString ( ) ) ; if ( refCount ) { if ( ! classObj . isPrimitive ) { buff . append ( STR_ ) ; } } for ( int i = NUM_ ; i < arrayLevel ; i ++ ) { if ( refCount ) { buff . append ( STR_ ) ; } else { if ( ! classObj . isPrimitive ) { buff . append ( STR_ ) ; } } buff . append ( STR_ ) ; } if ( ! refCount ) { if ( isObject ( ) ) { buff . append ( STR_ ) ; } } return buff . toString ( ) ; }
public boolean recreateWorkspaceTable ( SQLiteDatabase db ) { db . beginTransaction ( ) ; try { Cursor c = db . query ( TABLE_WORKSPACE_SCREENS , new String [ ] { LauncherSettings . WorkspaceScreens . _ID } , null , null , null , null , LauncherSettings . WorkspaceScreens . SCREEN_RANK ) ; ArrayList < Long > sortedIDs = new ArrayList < Long > ( ) ; long maxId = NUM_ ; try { while ( c . moveToNext ( ) ) { Long id = c . getLong ( NUM_ ) ; if ( ! sortedIDs . contains ( id ) ) { sortedIDs . add ( id ) ; maxId = Math . max ( maxId , id ) ; } } } finally { c . close ( ) ; } db . execSQL ( STR_ + TABLE_WORKSPACE_SCREENS ) ; addWorkspacesTable ( db , BOOL_ ) ; int total = sortedIDs . size ( ) ; for ( int i = NUM_ ; i < total ; i ++ ) { ContentValues values = new ContentValues ( ) ; values . put ( LauncherSettings . WorkspaceScreens . _ID , sortedIDs . get ( i ) ) ; values . put ( LauncherSettings . WorkspaceScreens . SCREEN_RANK , i ) ; addModifiedTime ( values ) ; db . insertOrThrow ( TABLE_WORKSPACE_SCREENS , null , values ) ; } db . setTransactionSuccessful ( ) ; mMaxScreenId = maxId ; } catch ( SQLException ex ) { Log . e ( TAG , ex . getMessage ( ) , ex ) ; return BOOL_ ; } finally { db . endTransaction ( ) ; } return BOOL_ ; }
public List < JsonObject > executeParametrizedStatement ( String statement , List < String > parameterNames , List < Object > parameterValues ) { JsonObject namedParams = JsonObject . create ( ) ; for ( int param = NUM_ ; param < parameterNames . size ( ) ; param ++ ) { namedParams . put ( parameterNames . get ( param ) , parameterValues . get ( param ) ) ; } ParameterizedN1qlQuery query = N1qlQuery . parameterized ( statement , namedParams ) ; return executeQuery ( query ) ; }
public final T endAll ( ) { while ( ! tagStack . isEmpty ( ) ) { end ( ) ; } return getSelf ( ) ; }
public void entityReference ( String name ) throws org . xml . sax . SAXException { append ( m_doc . createEntityReference ( name ) ) ; }
public static Table createPartitionedTable ( Configuration conf , HiveMetastoreClient ms , HiveObjectSpec tableSpec , TableType tableType , Path warehouseRoot ) throws IOException , HiveMetastoreException { Path tableLocation = getPathForHiveObject ( warehouseRoot , tableSpec ) ; Table table = new Table ( ) ; table . setDbName ( tableSpec . getDbName ( ) ) ; table . setTableName ( tableSpec . getTableName ( ) ) ; Map < String , String > parameters = new HashMap < > ( ) ; parameters . put ( HiveParameterKeys . TLDT , Long . toString ( System . currentTimeMillis ( ) ) ) ; table . setParameters ( parameters ) ; table . setTableType ( tableType . toString ( ) ) ; List < FieldSchema > partitionCols = new ArrayList < > ( ) ; partitionCols . add ( new FieldSchema ( STR_ , STR_ , STR_ ) ) ; partitionCols . add ( new FieldSchema ( STR_ , STR_ , STR_ ) ) ; table . setPartitionKeys ( partitionCols ) ; StorageDescriptor sd = new StorageDescriptor ( ) ; List < FieldSchema > columns = new ArrayList < > ( ) ; columns . add ( new FieldSchema ( STR_ , STR_ , STR_ ) ) ; sd . setCols ( columns ) ; if ( tableType == TableType . MANAGED_TABLE || tableType == TableType . EXTERNAL_TABLE ) { sd . setLocation ( tableLocation . toString ( ) ) ; } sd . setSerdeInfo ( new SerDeInfo ( STR_ , STR_ , new HashMap < > ( ) ) ) ; table . setSd ( sd ) ; if ( ! ms . existsDb ( table . getDbName ( ) ) ) { ms . createDatabase ( new Database ( table . getDbName ( ) , null , null , null ) ) ; } ms . createTable ( table ) ; return table ; }
private boolean linkLast ( Node < E > node ) { if ( count >= capacity ) return BOOL_ ; Node < E > l = last ; node . prev = l ; last = node ; if ( first == null ) first = node ; else l . next = node ; ++ count ; notEmpty . signal ( ) ; return BOOL_ ; }
void drawDivider ( Canvas canvas , Rect bounds , int childIndex ) { final Drawable divider = mDivider ; final boolean clipDivider = mClipDivider ; if ( ! clipDivider ) { divider . setBounds ( bounds ) ; } else { canvas . save ( ) ; canvas . clipRect ( bounds ) ; } divider . draw ( canvas ) ; if ( clipDivider ) { canvas . restore ( ) ; } }
protected FormSpec ( DefaultAlignment defaultAlignment , String encodedDescription ) { this ( defaultAlignment , Sizes . DEFAULT , NO_GROW ) ; parseAndInitValues ( encodedDescription . toLowerCase ( Locale . ENGLISH ) ) ; }
public static < T > List < T > decode ( InputStream data , Parser < T > parser ) throws IOException { CodedInputStream stream = CodedInputStream . newInstance ( data ) ; List < T > list = new ArrayList < > ( ) ; while ( ! stream . isAtEnd ( ) ) { int size = stream . readRawVarint32 ( ) ; byte [ ] element = stream . readRawBytes ( size ) ; T decoded = parser . parseFrom ( element ) ; list . add ( decoded ) ; } return list ; }
public static void writeInt ( DataOutput out , int v ) throws IOException { out . writeByte ( xff & v ) ; out . writeByte ( xff & ( v > > > NUM_ ) ) ; out . writeByte ( xff & ( v > > > NUM_ ) ) ; out . writeByte ( xff & ( v > > > NUM_ ) ) ; }
public void writeField ( final String name , final double value ) throws java . io . IOException { writeField ( name , Double . toString ( value ) ) ; }
public Creature calculateNextCreature ( final int questLevel ) { final List < Creature > possibleCreaturesToSpawn = new ArrayList < Creature > ( ) ; int lastLevel = NUM_ ; for ( final Creature creature : sortedCreatures ) { if ( creature . getLevel ( ) > questLevel ) { break ; } if ( creature . getLevel ( ) > lastLevel ) { possibleCreaturesToSpawn . clear ( ) ; lastLevel = creature . getLevel ( ) ; } possibleCreaturesToSpawn . add ( creature ) ; } Creature creatureToSpawn = null ; if ( possibleCreaturesToSpawn . size ( ) == NUM_ ) { creatureToSpawn = sortedCreatures . get ( sortedCreatures . size ( ) - NUM_ ) ; } else { Collections . shuffle ( possibleCreaturesToSpawn ) ; creatureToSpawn = possibleCreaturesToSpawn . get ( NUM_ ) ; } return creatureToSpawn ; }
@ Override public void before ( PropertyInfoRestRep oldProps , PropertyInfoRestRep newProps ) { String newIntervalStr = newProps . getProperty ( BackupConstants . SCHEDULE_INTERVAL ) ; String newStartTimeStr = newProps . getProperty ( BackupConstants . SCHEDULE_TIME ) ; if ( ( newIntervalStr == null || newIntervalStr . isEmpty ( ) ) && ( newStartTimeStr == null || newStartTimeStr . isEmpty ( ) ) ) { _log . info ( STR_ ) ; return ; } String intervalStr = ( newIntervalStr == null || newIntervalStr . isEmpty ( ) ) ? oldProps . getProperty ( BackupConstants . SCHEDULE_INTERVAL ) : newIntervalStr ; String startTimeStr = ( newStartTimeStr == null || newStartTimeStr . isEmpty ( ) ) ? oldProps . getProperty ( BackupConstants . SCHEDULE_TIME ) : newStartTimeStr ; _log . info ( STR_ , intervalStr , startTimeStr ) ; validateBackupIntervalAndStartTime ( intervalStr , startTimeStr ) ; }
@ Override public void deleteTrait ( String guid , String traitNameToBeDeleted ) throws AtlasException { guid = ParamChecker . notEmpty ( guid , STR_ ) ; traitNameToBeDeleted = ParamChecker . notEmpty ( traitNameToBeDeleted , STR_ ) ; if ( ! typeSystem . isRegistered ( traitNameToBeDeleted ) ) { final String msg = String . format ( STR_ , traitNameToBeDeleted ) ; LOG . error ( msg ) ; throw new TypeNotFoundException ( msg ) ; } repository . deleteTrait ( guid , traitNameToBeDeleted ) ; onTraitDeletedFromEntity ( repository . getEntityDefinition ( guid ) , traitNameToBeDeleted ) ; }
public void addTables ( Collection < Table > tables ) { for ( Iterator < Table > it = tables . iterator ( ) ; it . hasNext ( ) ; ) { addTable ( ( Table ) it . next ( ) ) ; } }
protected void writeFile ( String template , Writer writer ) { if ( template == null ) { throw new IllegalArgumentException ( STR_ ) ; } BufferedWriter bufferedWriter = new BufferedWriter ( writer ) ; String output = replace ( template , null ) ; try { bufferedWriter . append ( output ) ; } catch ( IOException e ) { logger . log ( Diagnostic . Kind . ERROR , STR_ ) ; e . printStackTrace ( ) ; } finally { try { bufferedWriter . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
public static String slurpURLNoExceptions ( URL u , String encoding ) { try { return slurpURL ( u , encoding ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } }
public synchronized boolean clear ( ) { if ( isLoading ( ) ) { return BOOL_ ; } loader = new Thread ( null ) ; loader . start ( ) ; return BOOL_ ; }
public int indexOf ( final RoundedToolItem item ) { checkWidget ( ) ; return items . indexOf ( item ) ; }
public void addAttribute ( String alias , String typeUri , boolean required , int count ) throws MessageException { if ( alias . indexOf ( STR_ ) > - NUM_ || alias . indexOf ( STR_ ) > - NUM_ || alias . indexOf ( STR_ ) > - NUM_ || alias . indexOf ( STR_ ) > - NUM_ ) throw new MessageException ( STR_ + alias ) ; _parameters . set ( new Parameter ( STR_ + alias , typeUri ) ) ; String level = required ? STR_ : STR_ ; Parameter levelParam = _parameters . getParameter ( level ) ; Parameter newParam ; if ( levelParam == null ) { newParam = new Parameter ( level , alias ) ; } else { newParam = new Parameter ( level , levelParam . getValue ( ) + STR_ + alias ) ; _parameters . removeParameters ( level ) ; } _parameters . set ( newParam ) ; setCount ( alias , count ) ; if ( DEBUG ) _log . debug ( STR_ + typeUri + STR_ + alias + STR_ + count + STR_ + required ) ; }
public Void call ( ) throws Exception { final List < Future < Void > > tasks = new LinkedList < Future < Void > > ( ) ; try { for ( IV < ? , ? > termId : graphs ) { final FutureTask < Void > ft = new FutureTask < Void > ( new DrainIteratorTask ( termId ) ) ; tasks . add ( ft ) ; executor . execute ( ft ) ; } for ( Future < Void > f : tasks ) { f . get ( ) ; } } catch ( Throwable ex ) { for ( Future < Void > f : tasks ) f . cancel ( BOOL_ ) ; throw new RuntimeException ( ex ) ; } finally { buffer . close ( ) ; } return null ; }
protected void runFullImport ( String dataConfig , Map < String , String > extraParams ) throws Exception { HashMap < String , String > params = new HashMap < > ( ) ; params . put ( STR_ , STR_ ) ; params . put ( STR_ , STR_ ) ; params . put ( STR_ , dataConfig ) ; params . put ( STR_ , STR_ ) ; params . put ( STR_ , STR_ ) ; params . putAll ( extraParams ) ; NamedList l = new NamedList ( ) ; for ( Map . Entry < String , String > e : params . entrySet ( ) ) { l . add ( e . getKey ( ) , e . getValue ( ) ) ; } LocalSolrQueryRequest request = new LocalSolrQueryRequest ( h . getCore ( ) , l ) ; h . query ( STR_ , request ) ; }
public String userIdFromRange ( Object ominId , Object omaxId ) { int minId = FunctionHandler . getInt ( ominId ) ; int maxId = FunctionHandler . getInt ( omaxId ) ; Stack < Integer > stack = getStack ( minId , maxId ) ; if ( stack . size ( ) > NUM_ ) { return Integer . toString ( stack . pop ( ) ) ; } throw new IllegalArgumentException ( STR_ ) ; }
public void start ( ) { if ( isStarted ) { log . info ( STR_ ) ; return ; } log . info ( STR_ ) ; systemConsumer . start ( ) ; isStarted = BOOL_ ; }
public static void generateBinaryOperationFlags ( final ITranslationEnvironment environment , final long nextOffset , final String result , final OperandSize resultSize , final List < ReilInstruction > instructions ) throws IllegalArgumentException { Preconditions . checkNotNull ( environment , STR_ ) ; Preconditions . checkNotNull ( result , STR_ ) ; Preconditions . checkNotNull ( resultSize , STR_ ) ; Preconditions . checkNotNull ( instructions , STR_ ) ; final long baseOffset = nextOffset - instructions . size ( ) ; long offset = nextOffset ; generateSignFlagCode ( environment , offset , result , resultSize , instructions ) ; offset = ( baseOffset + instructions . size ( ) ) - NUM_ ; instructions . add ( ReilHelpers . createBisz ( offset + NUM_ , resultSize , result , OperandSize . BYTE , Helpers . ZERO_FLAG ) ) ; instructions . add ( ReilHelpers . createStr ( offset + NUM_ , OperandSize . BYTE , STR_ , OperandSize . BYTE , Helpers . CARRY_FLAG ) ) ; instructions . add ( ReilHelpers . createStr ( offset + NUM_ , OperandSize . BYTE , STR_ , OperandSize . BYTE , Helpers . OVERFLOW_FLAG ) ) ; }
public boolean isLabelMovable ( ) { mxGraph graph = graphComponent . getGraph ( ) ; String label = graph . getLabel ( state . getCell ( ) ) ; return graph . isLabelMovable ( state . getCell ( ) ) && label != null && label . length ( ) > NUM_ ; }
public int writeTypeList ( TypeList typeList ) { int off = data . position ( ) ; short [ ] types = typeList . types ; writeInt ( types . length ) ; for ( short type : types ) { writeShort ( type ) ; } return off ; }
public static void loadConfigResource ( String resourceName ) throws IOException { config . clear ( ) ; config . putAll ( loadPropertiesFromResource ( resourceName ) ) ; }
public static void safeCloseStream ( InputStream in ) { if ( in != null ) { try { in . close ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } } }
private Transaction createTransaction ( ) throws LeaseDeniedException , RemoteException , TransactionException { ITransactionManagerProvider transactionManagerProvider = getTransactionManagerProvider ( ) ; return ( TransactionFactory . create ( transactionManagerProvider . getTransactionManager ( ) , _config . getTransactionTimeout ( ) ) ) . transaction ; }
public void skipWhile ( String skip ) throws IOException { char ch ; do { ch = read ( ) ; } while ( skip . indexOf ( ch ) > - NUM_ ) ; unreadCharacter ( ch ) ; }
public static String packageToPath ( String packageName ) { return packageName . replace ( STR_ , File . separatorChar ) ; }
@ Override public boolean containsKey ( Object key ) { if ( key == null ) { return entryForNullKey != null ; } int hash = key . hashCode ( ) ; hash ^= ( hash > > > NUM_ ) ^ ( hash > > > NUM_ ) ; hash ^= ( hash > > > NUM_ ) ^ ( hash > > > NUM_ ) ; HashMapEntry < K , V > [ ] tab = table ; for ( HashMapEntry < K , V > e = tab [ hash & ( tab . length - NUM_ ) ] ; e != null ; e = e . next ) { K eKey = e . key ; if ( eKey == key || ( e . hash == hash && key . equals ( eKey ) ) ) { return BOOL_ ; } } return BOOL_ ; }
protected boolean isValidFragment ( String fragment ) { if ( fragment == null ) { return BOOL_ ; } return isOff ( NO_FRAGMENTS ) ; }
private void rehash ( ) { int oldCapacity = m_capacity ; HashEntry [ ] oldTable = m_table ; int newCapacity = NUM_ . oldCapacity + NUM_ ; m_capacity = newCapacity ; m_threshold = ( int ) ( newCapacity . m_loadFactor ) ; m_table = new HashEntry [ newCapacity ] ; for ( int i = oldCapacity - NUM_ ; i >= NUM_ ; i -- ) { for ( HashEntry old = oldTable [ i ] ; old != null ; ) { HashEntry e = old ; old = old . next ; int newIndex = e . hash % newCapacity ; if ( newIndex < NUM_ ) newIndex = - newIndex ; e . next = m_table [ newIndex ] ; m_table [ newIndex ] = e ; } } }
public void savePoisFromAssets ( ) { List < Poi > pois = poiAssetLoader . loadPoisFromAssets ( ) ; Timber . d ( STR_ , pois . size ( ) ) ; for ( Poi poi : pois ) { Timber . d ( STR_ , poi ) ; savePoi ( poi ) ; Timber . d ( STR_ ) ; } }
private void createElement ( Document doc , Element parentElement , String elementName , Color value ) { Element element = doc . createElement ( elementName ) ; element . appendChild ( doc . createTextNode ( ColourUtils . fromColour ( value ) ) ) ; parentElement . appendChild ( element ) ; }
public static boolean beenDone ( @ Scope int scope , String tag , CountChecker numberOfTimes ) { List < Long > tagSeenDates = tagLastSeenMap . get ( tag ) ; if ( tagSeenDates . isEmpty ( ) ) { return BOOL_ ; } if ( scope == THIS_APP_INSTALL ) { return numberOfTimes . check ( tagSeenDates . size ( ) ) ; } else if ( scope == THIS_APP_SESSION ) { int counter = NUM_ ; for ( String tagFromList : sessionList ) { if ( tagFromList . equals ( tag ) ) { counter ++ ; } } return numberOfTimes . check ( counter ) ; } else { int counter = NUM_ ; for ( Long seenDate : tagSeenDates ) { if ( seenDate > lastAppUpdatedTime ) { counter ++ ; } } return numberOfTimes . check ( counter ) ; } }
void variableOperatorChanged ( int row , String oper ) { ConditionalVariable variable = _variableList . get ( row ) ; int oldOper = variable . getOpern ( ) ; if ( row > NUM_ ) { if ( oper . equals ( Bundle . getMessage ( STR_ ) ) ) { variable . setOpern ( Conditional . OPERATOR_OR ) ; } else { variable . setOpern ( Conditional . OPERATOR_AND ) ; } } else { variable . setOpern ( Conditional . OPERATOR_NONE ) ; } if ( variable . getOpern ( ) != oldOper ) { makeAntecedent ( ) ; } }
public void addHeader ( String name , String val ) { mMsgHeader = mMsgHeader + name + STR_ + val + mLineDelimiter ; addInternalHeaderFields ( name , val ) ; }
public static void checkDuplicateRequest ( RedisClient redisClient , String uri , Buffer buffer , String ttl , Handler < Boolean > callback ) { Integer timeToLive = parseTimeToLive ( ttl ) ; String redisKey = getRedisKey ( uri , HashCodeGenerator . createHashCode ( uri , buffer . toString ( ) ) ) ; handleStorage ( redisClient , redisKey , timeToLive , callback ) ; }
boolean isHidden ( View view ) { return mHiddenViews . contains ( view ) ; }
public void writeExif ( InputStream jpegStream , OutputStream exifOutStream ) throws IOException { if ( jpegStream == null || exifOutStream == null ) { throw new IllegalArgumentException ( NULL_ARGUMENT_STRING ) ; } OutputStream s = getExifWriterStream ( exifOutStream ) ; doExifStreamIO ( jpegStream , s ) ; s . flush ( ) ; }
public static void deleteRecursive ( @ NonNull File fileOrDirectory ) { deleteRecursive ( fileOrDirectory , Collections . EMPTY_LIST ) ; }
static boolean doesMenuBarBorderToolBar ( JMenuBar c ) { JToolBar tb = ( JToolBar ) MetalToolBarUI . findRegisteredComponentOfType ( c , JToolBar . class ) ; if ( tb != null && tb . getOrientation ( ) == JToolBar . HORIZONTAL ) { JRootPane rp = SwingUtilities . getRootPane ( c ) ; Point point = new Point ( NUM_ , NUM_ ) ; point = SwingUtilities . convertPoint ( c , point , rp ) ; int menuX = point . x ; int menuY = point . y ; point . x = point . y = NUM_ ; point = SwingUtilities . convertPoint ( tb , point , rp ) ; return ( point . x == menuX && menuY + c . getHeight ( ) == point . y && c . getWidth ( ) == tb . getWidth ( ) ) ; } return BOOL_ ; }
void constructNode ( String nodeName , String prefix , String nodeNamespace , TransformerImpl transformer ) throws TransformerException { boolean shouldAddAttrs ; try { SerializationHandler rhandler = transformer . getResultTreeHandler ( ) ; if ( null == nodeName ) { shouldAddAttrs = BOOL_ ; } else { if ( null != prefix ) { rhandler . startPrefixMapping ( prefix , nodeNamespace , BOOL_ ) ; } rhandler . startElement ( nodeNamespace , QName . getLocalPart ( nodeName ) , nodeName ) ; super . execute ( transformer ) ; shouldAddAttrs = BOOL_ ; } transformer . executeChildTemplates ( this , shouldAddAttrs ) ; if ( null != nodeName ) { rhandler . endElement ( nodeNamespace , QName . getLocalPart ( nodeName ) , nodeName ) ; if ( null != prefix ) { rhandler . endPrefixMapping ( prefix ) ; } } } catch ( SAXException se ) { throw new TransformerException ( se ) ; } }
private PriorityQueue < USField > createQueue ( String fieldName , Map < String , Flt > words ) throws IOException { int numDocs = ir . numDocs ( ) ; FreqQ res = new FreqQ ( words . size ( ) ) ; for ( String word : words . keySet ( ) ) { float tf = words . get ( word ) . x ; if ( minTermFreq > NUM_ && tf < minTermFreq ) { continue ; } int docFreq = ir . docFreq ( new Term ( fieldName , word ) ) ; if ( minDocFreq > NUM_ && docFreq < minDocFreq ) { continue ; } if ( docFreq == NUM_ || docFreq > maxDocFreq ) { continue ; } float idf = similarity . idf ( docFreq , numDocs ) ; float score = NUM_ ; if ( isLogTf ( ) ) { score = ( float ) ( Math . log ( tf + NUM_ ) . idf ) ; } else { score = tf . idf ; } USField mltField ; if ( isPayloadField ( fieldName ) ) { mltField = new USField ( word , fieldName , score , tf , idf , docFreq , NUM_ ) ; } else { mltField = new USField ( word , fieldName , score , tf , idf , docFreq ) ; } res . insertWithOverflow ( mltField ) ; } return res ; }
private synchronized void rebuildJournal ( ) throws IOException { if ( journalWriter != null ) { journalWriter . close ( ) ; } Writer writer = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( journalFileTmp ) , Util . US_ASCII ) ) ; try { writer . write ( MAGIC ) ; writer . write ( STR_ ) ; writer . write ( VERSION_1 ) ; writer . write ( STR_ ) ; writer . write ( Integer . toString ( appVersion ) ) ; writer . write ( STR_ ) ; writer . write ( Integer . toString ( valueCount ) ) ; writer . write ( STR_ ) ; writer . write ( STR_ ) ; for ( Entry entry : lruEntries . values ( ) ) { if ( entry . currentEditor != null ) { writer . write ( DIRTY + STR_ + entry . key + STR_ ) ; } else { writer . write ( CLEAN + STR_ + entry . key + entry . getLengths ( ) + STR_ ) ; } } } finally { writer . close ( ) ; } if ( journalFile . exists ( ) ) { renameTo ( journalFile , journalFileBackup , BOOL_ ) ; } renameTo ( journalFileTmp , journalFile , BOOL_ ) ; journalFileBackup . delete ( ) ; journalWriter = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( journalFile , BOOL_ ) , Util . US_ASCII ) ) ; }
public static void eachObject ( ObjectInputStream ois , Closure closure ) throws IOException , ClassNotFoundException { try { while ( BOOL_ ) { try { Object obj = ois . readObject ( ) ; closure . call ( obj ) ; } catch ( EOFException e ) { break ; } } InputStream temp = ois ; ois = null ; temp . close ( ) ; } finally { closeWithWarning ( ois ) ; } }
private static int exitWithStatus ( int status ) { if ( ToolIO . getMode ( ) == ToolIO . SYSTEM ) { System . exit ( status ) ; } return status ; }
public static double distanceInMeters ( final double latP1 , final double latP2 , final double lonP1 , final double lonP2 ) { double distRad = Math . acos ( Math . sin ( toRadians ( latP1 ) ) . Math . sin ( toRadians ( latP2 ) ) + Math . cos ( toRadians ( latP1 ) ) . Math . cos ( toRadians ( latP2 ) ) . Math . cos ( toRadians ( lonP1 - lonP2 ) ) ) ; final double distAsDegree = toDegrees ( distRad ) ; return distAsDegree . NUM_ . NUM_ . NUM_ ; }
public void processChallenge ( final String challenge ) throws MalformedChallengeException { String s = AuthChallengeParser . extractScheme ( challenge ) ; if ( ! s . equalsIgnoreCase ( getSchemeName ( ) ) ) { throw new MalformedChallengeException ( STR_ + challenge ) ; } int i = challenge . indexOf ( STR_ ) ; if ( i != - NUM_ ) { s = challenge . substring ( i , challenge . length ( ) ) ; this . ntlmchallenge = s . trim ( ) ; this . state = TYPE2_MSG_RECEIVED ; } else { this . ntlmchallenge = STR_ ; if ( this . state == UNINITIATED ) { this . state = INITIATED ; } else { this . state = FAILED ; } } }
public static BigInteger calculateA ( BigInteger p , BigInteger q , BigInteger gA , BigInteger x2s ) { return gA . modPow ( x2s , p ) ; }
public static MCostQueue add ( MProduct product , int M_AttributeSetInstance_ID , MAcctSchema as , int AD_Org_ID , int M_CostElement_ID , BigDecimal amt , BigDecimal qty , int precision , MCostDetail cd , String trxName ) { if ( CLogMgt . isLevelFine ( ) ) s_log . fine ( STR_ + AD_Org_ID + STR_ + product . get_ID ( ) + STR_ + M_AttributeSetInstance_ID + STR_ + amt + STR_ + qty + STR_ + precision ) ; MCostQueue cq = new MCostQueue ( product , M_AttributeSetInstance_ID , as , AD_Org_ID , M_CostElement_ID , trxName ) ; cq . setCosts ( amt , qty , precision ) ; cq . setDateAcct ( cd . getDateAcct ( ) ) ; cq . saveEx ( ) ; if ( CLogMgt . isLevelFine ( ) ) s_log . fine ( STR_ + cq ) ; return cq ; }
public void addUndoEvent ( UndoInterface event ) { if ( shouldProcessUndoRedoAction ( ) ) { boolean atEndOfList = ( currentIndex >= undoList . size ( ) ) ; if ( ! atEndOfList ) { while ( undoList . size ( ) > currentIndex ) { int lastIndex = undoList . size ( ) - NUM_ ; undoList . remove ( lastIndex ) ; } } undoList . add ( event ) ; currentIndex = undoList . size ( ) ; updateMenuItems ( ) ; logger . debug ( event . getStringRepresentation ( ) ) ; } }
public static Exception establishCacheIfNeeded ( PrintStream ... progress ) { if ( m_offline ) { return null ; } if ( REP_MIRROR == null ) { establishMirror ( ) ; } Exception problem = null ; if ( INITIAL_CACHE_BUILD_NEEDED ) { for ( PrintStream p : progress ) { p . println ( STR_ ) ; } problem = refreshCache ( progress ) ; INITIAL_CACHE_BUILD_NEEDED = BOOL_ ; } return problem ; }
public Spanny append ( CharSequence text , ImageSpan imageSpan ) { text = STR_ + text ; append ( text ) ; setSpan ( imageSpan , length ( ) - text . length ( ) , length ( ) - text . length ( ) + NUM_ ) ; return this ; }
public static boolean validatePassword ( String password , String correctHash ) throws NoSuchAlgorithmException , InvalidKeySpecException { return validatePassword ( password . toCharArray ( ) , correctHash ) ; }
public List < Snapshot > currentSnapshots ( String repositoryName ) { List < Snapshot > snapshotList = new ArrayList < > ( ) ; List < SnapshotsInProgress . Entry > entries = currentSnapshots ( repositoryName , null ) ; for ( SnapshotsInProgress . Entry entry : entries ) { snapshotList . add ( inProgressSnapshot ( entry ) ) ; } CollectionUtil . timSort ( snapshotList ) ; return Collections . unmodifiableList ( snapshotList ) ; }
public void addCertificate ( X509CertificateHolder certificate ) throws CMSException { certs . add ( certificate . toASN1Structure ( ) ) ; }
public void testCase8 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; byte rBytes [ ] = { NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = BigInteger . ZERO ; BigInteger result = aNumber . multiply ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
private void cleanStatic ( MethodNode method ) { }
@ Override protected void paintTabBackground ( Graphics g , int tabPlacement , int tabIndex , int x , int y , int w , int h , boolean isSelected ) { if ( isSelected ) { if ( tabPlacement == TOP ) { g . setColor ( Color . white ) ; g . fillRoundRect ( x , y , w , h + R + R , R , R ) ; } } else { } }
public void push ( final float value ) { int bits = Float . floatToIntBits ( value ) ; if ( bits == NUM_ || bits == x3f800000 || bits == x40000000 ) { mv . visitInsn ( Opcodes . FCONST_0 + ( int ) value ) ; } else { mv . visitLdcInsn ( value ) ; } }
private Automaton buildAutomaton ( BytesRefHash termBytesHash ) { final TreeSet < BytesRef > terms = new TreeSet < BytesRef > ( ) ; for ( int i = NUM_ ; i < termBytesHash . size ( ) ; i ++ ) { BytesRef ref = new BytesRef ( ) ; termBytesHash . get ( i , ref ) ; terms . add ( ref ) ; } final Automaton a = DaciukMihovAutomatonBuilder . build ( terms ) ; return a ; }
protected Range findRangeBounds ( CategoryDataset dataset , boolean includeInterval ) { if ( dataset == null ) { return null ; } if ( getDataBoundsIncludesVisibleSeriesOnly ( ) ) { List visibleSeriesKeys = new ArrayList ( ) ; int seriesCount = dataset . getRowCount ( ) ; for ( int s = NUM_ ; s < seriesCount ; s ++ ) { if ( isSeriesVisible ( s ) ) { visibleSeriesKeys . add ( dataset . getRowKey ( s ) ) ; } } return DatasetUtilities . findRangeBounds ( dataset , visibleSeriesKeys , includeInterval ) ; } else { return DatasetUtilities . findRangeBounds ( dataset , includeInterval ) ; } }
protected String adminShutdown ( ) { server . shutdown ( ) ; return STR_ ; }
public long num_threads ( ) { return Long . parseLong ( fields [ NUM_ ] ) ; }
public void assignRole ( AMRole role ) throws AMException , SSOException { assignRole ( role . getDN ( ) ) ; }
public OrderedThreadPoolExecutor ( int corePoolSize , int maximumPoolSize ) { this ( corePoolSize , maximumPoolSize , DEFAULT_KEEP_ALIVE , TimeUnit . SECONDS , Executors . defaultThreadFactory ( ) , null ) ; }
protected void writeInitialStyles ( ) throws IOException { out . flushBits ( ) ; fillBits = OutStream . determineUnsignedBitSize ( fillStyles . size ( ) ) ; lineBits = OutStream . determineUnsignedBitSize ( lineStyles . size ( ) ) ; if ( ! hasStyle ) { fillBits = NUM_ ; } else { writeStyles ( fillStyles ) ; writeStyles ( lineStyles ) ; out . flushBits ( ) ; } out . writeUBits ( NUM_ , fillBits ) ; out . writeUBits ( NUM_ , lineBits ) ; }
public static < T extends Map . Entry < String , String > > String formEncode ( Collection < T > parameters ) throws IOException { ByteArrayOutputStream b = new ByteArrayOutputStream ( ) ; formEncode ( parameters , b ) ; return new String ( b . toByteArray ( ) ) ; }
public void test_singleResourceLocking_serialized_lowConcurrency2 ( ) throws Exception { Properties properties = new Properties ( ) ; properties . setProperty ( TestOptions . NTHREADS , STR_ ) ; properties . setProperty ( TestOptions . NTASKS , STR_ ) ; properties . setProperty ( TestOptions . NRESOURCES , STR_ ) ; properties . setProperty ( TestOptions . MIN_LOCKS , STR_ ) ; properties . setProperty ( TestOptions . MAX_LOCKS , STR_ ) ; properties . setProperty ( TestOptions . PREDECLARE_LOCKS , STR_ ) ; properties . setProperty ( TestOptions . SORT_LOCK_REQUESTS , STR_ ) ; doComparisonTest ( properties ) ; }
public void runNextPendingCommand ( ) { Runnable runnable = deltaQueue . pop ( ) ; runnable . run ( ) ; }
public void stop ( int timeout ) throws InterruptedException { if ( ! isclosed . compareAndSet ( BOOL_ , BOOL_ ) ) { return ; } List < WebSocket > socketsToClose = null ; synchronized ( connections ) { socketsToClose = new ArrayList < WebSocket > ( connections ) ; } for ( WebSocket ws : socketsToClose ) { ws . close ( CloseFrame . GOING_AWAY ) ; } synchronized ( this ) { if ( selectorthread != null && selectorthread != Thread . currentThread ( ) ) { selector . wakeup ( ) ; selectorthread . interrupt ( ) ; selectorthread . join ( timeout ) ; } } }
private static Document loadDocument ( Resource xmlFile ) throws SAXException , IOException { DOMParser parser = new DOMParser ( ) ; InputStream is = null ; try { is = IOUtil . toBufferedInputStream ( xmlFile . getInputStream ( ) ) ; InputSource source = new InputSource ( is ) ; parser . parse ( source ) ; } finally { IOUtil . closeEL ( is ) ; } return parser . getDocument ( ) ; }
public void test_DivideBigDecimalRoundingModeDOWN ( ) { String a = STR_ ; String b = STR_ ; RoundingMode rm = RoundingMode . DOWN ; String c = STR_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) ) ; BigDecimal bNumber = new BigDecimal ( new BigInteger ( b ) ) ; BigDecimal result = aNumber . divide ( bNumber , rm ) ; assertEquals ( STR_ , c , result . toString ( ) ) ; }
public void removeAnnotation ( int index ) { mAnnotations . remove ( index ) ; mStringXY . removeByIndex ( index ) ; }
public String replace ( char oldChar , char newChar ) { char [ ] buffer = value ; int _offset = offset ; int _count = count ; int idx = _offset ; int last = _offset + _count ; boolean copied = BOOL_ ; while ( idx < last ) { if ( buffer [ idx ] == oldChar ) { if ( ! copied ) { char [ ] newBuffer = new char [ _count ] ; System . arraycopy ( buffer , _offset , newBuffer , NUM_ , _count ) ; buffer = newBuffer ; idx -= _offset ; last -= _offset ; copied = BOOL_ ; } buffer [ idx ] = newChar ; } idx ++ ; } return copied ? new String ( NUM_ , count , buffer ) : this ; }
public static void touch ( File file ) throws IOException { if ( ! file . exists ( ) ) { OutputStream out = openOutputStream ( file ) ; IOUtils . closeQuietly ( out ) ; } boolean success = file . setLastModified ( System . currentTimeMillis ( ) ) ; if ( ! success ) { throw new IOException ( STR_ + file ) ; } }
private < Type extends Message > RpcCallback < Type > wrapsCallback ( MockCallback < ? > callback ) { EasyMock . reportMatcher ( new WrapsCallback ( callback ) ) ; return null ; }
public boolean shouldSelectCell ( EventObject e ) { log . finest ( m_mField . getColumnName ( ) ) ; return BOOL_ ; }
public static void prepareUnicode ( final StringBuilder buffer , final ByteSequence sequence , final boolean trim , final boolean foldCase ) { Reject . ifNull ( buffer , sequence ) ; final int length = sequence . length ( ) ; for ( int i = NUM_ ; i < length ; i ++ ) { final byte b = sequence . byteAt ( i ) ; if ( ( b & x7F ) != b ) { MappingTable . map ( buffer , sequence . subSequence ( i , length ) , trim , foldCase ) ; String normalizedForm = Normalizer . normalize ( buffer , Form . NFKD ) ; buffer . setLength ( NUM_ ) ; buffer . append ( normalizedForm ) ; break ; } switch ( b ) { case STR_ : if ( canMapToSpace ( buffer , trim ) ) { buffer . append ( STR_ ) ; } break ; default : if ( b >= STR_ && b < STR_ ) { if ( canMapToSpace ( buffer , trim ) ) { buffer . append ( SPACE_CHAR ) ; } } else if ( ( b >= STR_ && b <= STR_ ) || ( b >= STR_ && b <= STR_ ) || b == STR_ ) { break ; } else if ( foldCase && b >= STR_ && b <= STR_ ) { buffer . append ( ( char ) ( b + NUM_ ) ) ; } else { buffer . append ( ( char ) b ) ; } break ; } } if ( trim ) { for ( int i = buffer . length ( ) - NUM_ ; i > NUM_ ; i -- ) { if ( buffer . charAt ( i ) == SPACE_CHAR ) { buffer . delete ( i , i + NUM_ ) ; } else { break ; } } } }
public void testCase18 ( ) { byte aBytes [ ] = { NUM_ } ; byte bBytes [ ] = { NUM_ } ; byte rBytes [ ] = { NUM_ } ; int aSign = NUM_ ; int bSign = NUM_ ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . add ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
@ Nonnull public BugInstance addClass ( ClassNode classNode ) { String dottedClassName = ClassName . toDottedClassName ( classNode . name ) ; ClassAnnotation classAnnotation = new ClassAnnotation ( dottedClassName ) ; add ( classAnnotation ) ; return this ; }
public static void tryFormatSatisfiability ( String format ) throws IllegalFormatException { MessageFormat . format ( format , ( Object [ ] ) null ) ; }
public static int parseUpperMap ( String s ) throws NumberFormatException { int upperCase = MAP_UNDEFINED ; int length = s . length ( ) ; if ( length >= NUM_ && length <= NUM_ ) { upperCase = Integer . parseInt ( s , NUM_ ) ; } else if ( s . length ( ) != NUM_ ) { throw new NumberFormatException ( ) ; } return upperCase ; }
@ Override public void run ( ) { while ( ! isInterrupted ( ) ) { try { Reference ref = _queue . remove ( ) ; _entryInfos . remove ( ref ) ; } catch ( InterruptedException e ) { interrupt ( ) ; break ; } } }
private File createZipFile ( int entryCount , int entrySize ) throws IOException { File result = createTemporaryZipFile ( ) ; byte [ ] writeBuffer = new byte [ NUM_ ] ; Random random = new Random ( ) ; ZipOutputStream out = new ZipOutputStream ( new BufferedOutputStream ( new FileOutputStream ( result ) ) ) ; for ( int entry = NUM_ ; entry < entryCount ; ++ entry ) { ZipEntry ze = new ZipEntry ( Integer . toHexString ( entry ) ) ; out . putNextEntry ( ze ) ; for ( int i = NUM_ ; i < entrySize ; i += writeBuffer . length ) { random . nextBytes ( writeBuffer ) ; int byteCount = Math . min ( writeBuffer . length , entrySize - i ) ; out . write ( writeBuffer , NUM_ , byteCount ) ; } out . closeEntry ( ) ; } out . close ( ) ; return result ; }
private boolean isValidPlaylistName ( String newName ) { Playlist blankPlaylist = new Playlist ( newName , BOOL_ ) ; return ! newName . isEmpty ( ) && ! musicLibrary . containsPlaylist ( blankPlaylist ) ; }
public String importXML ( String fileName , Properties ctx , String trxName ) throws Exception { log . info ( STR_ + fileName ) ; File in = new File ( fileName ) ; if ( ! in . exists ( ) ) { String msg = STR_ + fileName ; log . info ( STR_ + msg ) ; return msg ; } try { log . info ( STR_ ) ; System . setProperty ( STR_ , STR_ ) ; PackInHandler handler = new PackInHandler ( ) ; handler . set_TrxName ( trxName ) ; handler . setCtx ( ctx ) ; handler . setProcess ( this ) ; SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; SAXParser parser = factory . newSAXParser ( ) ; String msg = STR_ ; log . info ( msg ) ; parser . parse ( in , handler ) ; msg = STR_ ; log . info ( msg ) ; return STR_ ; } catch ( Exception e ) { log . log ( Level . SEVERE , STR_ , e ) ; throw e ; } }
public synchronized void logAddOrRemoveRow ( Session session , int tableId , Row row , boolean add ) { if ( logMode != LOG_MODE_OFF ) { if ( ! recoveryRunning ) { log . logAddOrRemoveRow ( session , tableId , row , add ) ; } } }
public org . smpte_ra . schemas . st2067_2_2016 . DigestMethodType buildDefaultDigestMethodType ( ) { org . smpte_ra . schemas . st2067_2_2016 . DigestMethodType digestMethodType = new org . smpte_ra . schemas . st2067_2_2016 . DigestMethodType ( ) ; digestMethodType . setAlgorithm ( CompositionPlaylistBuilder_2016 . defaultHashAlgorithm ) ; return digestMethodType ; }
public static < V extends SampledVertex > Set < V > createSampledPartition ( Collection < V > vertices ) { Set < V > partition = new HashSet < V > ( ) ; for ( V vertex : vertices ) { if ( vertex . isSampled ( ) ) partition . add ( vertex ) ; } return partition ; }
public GremlinTransactionManager ( GremlinGraphFactory graphFactory ) { super ( ) ; this . graphFactory = graphFactory ; }
public void shiftBeans ( BeanInstance toShiftTo , boolean save ) { if ( save ) { m_originalCoords = new Vector < Point > ( ) ; } int targetX = toShiftTo . getX ( ) ; int targetY = toShiftTo . getY ( ) ; for ( int i = NUM_ ; i < m_subFlow . size ( ) ; i ++ ) { BeanInstance temp = ( BeanInstance ) m_subFlow . elementAt ( i ) ; if ( save ) { Point p = new Point ( temp . getX ( ) - targetX , temp . getY ( ) - targetY ) ; m_originalCoords . add ( p ) ; } temp . setX ( targetX ) ; temp . setY ( targetY ) ; } }
@ Override protected final List < LatLong > doInBackground ( final Object ... args ) { List < LatLong > points = new ArrayList < > ( ) ; DataHelper dbHelper = new DataHelper ( mContext ) ; final ArrayList < PositionRecord > positions = dbHelper . loadPositions ( ( Integer ) args [ SESSION_ID ] , ( Double ) args [ MIN_LAT_COL ] , ( Double ) args [ MAX_LAT_COL ] , ( Double ) args [ MIN_LON_COL ] , ( Double ) args [ MAX_LON_COL ] ) ; for ( PositionRecord position : positions ) { points . add ( new LatLong ( position . getLatitude ( ) , position . getLongitude ( ) ) ) ; } return points ; }
public void make ( ) throws Exception { for ( int i = NUM_ ; i < _makeList . size ( ) ; i ++ ) { Make make = _makeList . get ( i ) ; make . make ( ) ; } }
@ Override void deletedText ( CharacterDataImpl node , int offset , int count ) { if ( ranges != null ) { notifyRangesDeletedText ( node , offset , count ) ; } }
private int clampMag ( int value , int absMin , int absMax ) { final int absValue = Math . abs ( value ) ; if ( absValue < absMin ) return NUM_ ; if ( absValue > absMax ) return value > NUM_ ? absMax : - absMax ; return value ; }
private ApplicationEnvironment ( ) { try { if ( System . getProperty ( BootstrapProperties . IS_UBERJAR ) != null ) { this . mode = Mode . UBERJAR ; if ( ! loadWildFlySwarmApplicationManifestFromClasspath ( ) ) { loadWildFlySwarmApplicationManifestFromTCCL ( ) ; } } else { this . mode = Mode . CLASSPATH ; loadFractionManifestsFromClasspath ( ) ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public ProducerWorker ( String topic , String message ) { this . _topic = topic ; this . _message = message ; }
private void tabCreatedInForeground ( int id , int sourceId , boolean newIsIncognito , float originX , float originY ) { LayoutTab newLayoutTab = createLayoutTab ( id , newIsIncognito , NO_CLOSE_BUTTON , NO_TITLE ) ; if ( mLayoutTabs == null || mLayoutTabs . length == NUM_ ) { mLayoutTabs = new LayoutTab [ ] { newLayoutTab } ; } else { mLayoutTabs = new LayoutTab [ ] { mLayoutTabs [ NUM_ ] , newLayoutTab } ; } updateCacheVisibleIds ( new LinkedList < Integer > ( Arrays . asList ( id , sourceId ) ) ) ; newLayoutTab . setBorderAlpha ( NUM_ ) ; newLayoutTab . setStaticToViewBlend ( NUM_ ) ; forceAnimationToFinish ( ) ; Interpolator interpolator = BakedBezierInterpolator . TRANSFORM_CURVE ; addToAnimation ( newLayoutTab , LayoutTab . Property . SCALE , NUM_ , NUM_ , FOREGROUND_ANIMATION_DURATION , NUM_ , BOOL_ , interpolator ) ; addToAnimation ( newLayoutTab , LayoutTab . Property . ALPHA , NUM_ , NUM_ , FOREGROUND_ANIMATION_DURATION , NUM_ , BOOL_ , interpolator ) ; addToAnimation ( newLayoutTab , LayoutTab . Property . X , originX , NUM_ , FOREGROUND_ANIMATION_DURATION , NUM_ , BOOL_ , interpolator ) ; addToAnimation ( newLayoutTab , LayoutTab . Property . Y , originY , NUM_ , FOREGROUND_ANIMATION_DURATION , NUM_ , BOOL_ , interpolator ) ; mTabModelSelector . selectModel ( newIsIncognito ) ; startHiding ( id , BOOL_ ) ; }
private static boolean functionsAreAllowed ( boolean isAddAllFunction , boolean isPutAllFunction , Class < ? > classD , Class < ? > classS ) { if ( isAddAllFunction ) return collectionIsAssignableFrom ( classD ) && collectionIsAssignableFrom ( classS ) ; if ( isPutAllFunction ) return mapIsAssignableFrom ( classD ) && mapIsAssignableFrom ( classS ) ; return isAssignableFrom ( classD , classS ) ; }
private void loadOrgAccessUser ( ArrayList < OrgAccess > list ) { PreparedStatement pstmt = null ; ResultSet rs = null ; String sql = STR_ + STR_ ; try { pstmt = DB . prepareStatement ( sql , get_TrxName ( ) ) ; pstmt . setInt ( NUM_ , getAD_User_ID ( ) ) ; rs = pstmt . executeQuery ( ) ; while ( rs . next ( ) ) { MUserOrgAccess oa = new MUserOrgAccess ( getCtx ( ) , rs , get_TrxName ( ) ) ; loadOrgAccessAdd ( list , new OrgAccess ( oa . getAD_Client_ID ( ) , oa . getAD_Org_ID ( ) , oa . isReadOnly ( ) ) ) ; } } catch ( Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } finally { DB . close ( rs , pstmt ) ; } }
public void close ( ) { synchronized ( mDiskCacheLock ) { if ( mDiskLruCache != null ) { try { if ( ! mDiskLruCache . isClosed ( ) ) { mDiskLruCache . close ( ) ; } } catch ( Throwable e ) { LogUtils . e ( e . getMessage ( ) , e ) ; } mDiskLruCache = null ; } } }
private Map < URI , Integer > createVolumeMapForExportMask ( ExportMask exportMask ) { Map < URI , Integer > map = new HashMap < > ( ) ; for ( URI uri : ExportMaskUtils . getVolumeURIs ( exportMask ) ) { map . put ( uri , ExportGroup . LUN_UNASSIGNED ) ; } return map ; }
@ Override public void close ( ) throws IOException { SocketChannel s = _channel ; _channel = null ; SSLSocket sslSocket = _sslSocket ; _sslSocket = null ; if ( sslSocket != null ) { try { sslSocket . close ( ) ; } catch ( Exception e ) { } } if ( s != null ) { try { s . close ( ) ; } catch ( Exception e ) { } } }
public static Vector3D max ( Vector3D a , Vector3D b ) { return new Vector3D ( FastMath . max ( a . getX ( ) , b . getX ( ) ) , FastMath . max ( a . getY ( ) , b . getY ( ) ) , FastMath . max ( a . getZ ( ) , b . getZ ( ) ) ) ; }
public static void waitForProcessOutput ( Process self , OutputStream output , OutputStream error ) { Thread tout = consumeProcessOutputStream ( self , output ) ; Thread terr = consumeProcessErrorStream ( self , error ) ; try { tout . join ( ) ; } catch ( InterruptedException ignore ) { } try { terr . join ( ) ; } catch ( InterruptedException ignore ) { } try { self . waitFor ( ) ; } catch ( InterruptedException ignore ) { } closeStreams ( self ) ; }
private int clampMag ( int value , int absMin , int absMax ) { final int absValue = Math . abs ( value ) ; if ( absValue < absMin ) return NUM_ ; if ( absValue > absMax ) return value > NUM_ ? absMax : - absMax ; return value ; }
public void or ( Criteria criteria ) { oredCriteria . add ( criteria ) ; }
public CommandLine add ( String ... args ) { if ( args != null && args . length > NUM_ ) { Collections . addAll ( line , args ) ; } return this ; }
@ Override final Node < V > find ( int h , long k ) { for ( Node < V > e = first ; e != null ; ) { int s ; if ( ( ( s = lockState ) & ( WAITER | WRITER ) ) != NUM_ ) { if ( ( e . key == k ) ) { return e ; } e = e . next ; } else if ( U . compareAndSwapInt ( this , LOCKSTATE , s , s + READER ) ) { TreeNode < V > r ; TreeNode < V > p ; try { p = ( ( r = root ) == null ? null : r . findTreeNode ( h , k ) ) ; } finally { Thread w ; if ( getAndAddInt ( this , LOCKSTATE , - READER ) == ( READER | WAITER ) && ( w = waiter ) != null ) { LockSupport . unpark ( w ) ; } } return p ; } } return null ; }
@ Override public AxisState draw ( Graphics2D g2 , double cursor , Rectangle2D plotArea , Rectangle2D dataArea , RectangleEdge edge , PlotRenderingInfo plotState ) { AxisState axisState = new AxisState ( cursor ) ; if ( isAxisLineVisible ( ) ) { drawAxisLine ( g2 , cursor , dataArea , edge ) ; } if ( isTickMarksVisible ( ) ) { drawTickMarks ( g2 , axisState , dataArea , edge ) ; } if ( isTickLabelsVisible ( ) ) { for ( int band = NUM_ ; band < this . labelInfo . length ; band ++ ) { axisState = drawTickLabels ( band , g2 , axisState , dataArea , edge ) ; } } if ( getAttributedLabel ( ) != null ) { axisState = drawAttributedLabel ( getAttributedLabel ( ) , g2 , plotArea , dataArea , edge , axisState ) ; } else { axisState = drawLabel ( getLabel ( ) , g2 , plotArea , dataArea , edge , axisState ) ; } return axisState ; }
private ArrayList < URLCrawlDatum > readContents ( Path fetchlist ) throws IOException { SequenceFile . Reader reader = new SequenceFile . Reader ( fs , fetchlist , conf ) ; ArrayList < URLCrawlDatum > l = new ArrayList < URLCrawlDatum > ( ) ; READ : do { Text key = new Text ( ) ; CrawlDatum value = new CrawlDatum ( ) ; if ( ! reader . next ( key , value ) ) { break READ ; } l . add ( new URLCrawlDatum ( key , value ) ) ; } while ( BOOL_ ) ; reader . close ( ) ; return l ; }
public void playTogether ( Collection < Animator > items ) { if ( items != null && items . size ( ) > NUM_ ) { mNeedsSort = BOOL_ ; Builder builder = null ; for ( Animator anim : items ) { if ( builder == null ) { builder = play ( anim ) ; } else { builder . with ( anim ) ; } } } }
public static Color createRandomColour ( ) { float r = rand . nextFloat ( ) ; float g = rand . nextFloat ( ) ; float b = rand . nextFloat ( ) ; Color randomColor = new Color ( r , g , b ) ; return randomColor ; }
private static Pair < DiagnosticKind , Boolean > parseCategoryString ( String category ) { final String fixable = STR_ ; final boolean isFixable = category . startsWith ( fixable ) ; if ( isFixable ) { category = category . substring ( fixable . length ( ) ) ; } DiagnosticKind categoryEnum = DiagnosticKind . fromParseString ( category ) ; return Pair . of ( categoryEnum , isFixable ) ; }
public void legacyProcess ( Class clazz , Method m , MethodAppearanceDecision decision ) { if ( m . getDeclaringClass ( ) != Object . class && m . getReturnType ( ) != void . class && m . getParameterTypes ( ) . length == NUM_ ) { String mName = m . getName ( ) ; if ( ! looksLikePropertyReadMethod ( mName ) ) { decision . setExposeMethodAs ( null ) ; try { decision . setExposeAsProperty ( new PropertyDescriptor ( mName , clazz , mName , null ) ) ; } catch ( IntrospectionException e ) { throw new RuntimeException ( e ) ; } } } }
public SPTKPitchReaderWriter ( String lf0SPTKFile , float windowSizeInSeconds , float skipSizeInSeconds , int samplingRate ) { contour = null ; header = new PitchFileHeader ( ) ; header . windowSizeInSeconds = windowSizeInSeconds ; header . skipSizeInSeconds = skipSizeInSeconds ; header . fs = samplingRate ; try { contour = readSPTKF0Data ( lf0SPTKFile ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
public void abort ( ) { cleanUp ( ) ; if ( mFuture != null ) { mFuture . cancel ( BOOL_ ) ; mFuture = null ; } if ( mExecutorService != null ) { mExecutorService . shutdownNow ( ) ; mExecutorService = null ; } mListener = null ; }
public void addCSPStateListener ( CSPStateListener listener ) { listeners . add ( listener ) ; }
public static void printWrappedText ( final PrintStream stream , final String message ) { if ( stream != null && message != null && ! message . isEmpty ( ) ) { stream . println ( wrapText ( message , MAX_LINE_WIDTH ) ) ; } }
public void removeAtRange ( int index , int size ) { final int end = Math . min ( mSize , index + size ) ; for ( int i = index ; i < end ; i ++ ) { removeAt ( i ) ; } }
public static void assertNullability ( ResultSet rs , boolean [ ] nullability ) throws SQLException { ResultSetMetaData rsmd = rs . getMetaData ( ) ; int actualCols = rsmd . getColumnCount ( ) ; assertEquals ( STR_ , nullability . length , rsmd . getColumnCount ( ) ) ; for ( int i = NUM_ ; i < actualCols ; i ++ ) { int expected = nullability [ i ] ? ResultSetMetaData . columnNullable : ResultSetMetaData . columnNoNulls ; assertEquals ( STR_ + ( i + NUM_ ) , expected , rsmd . isNullable ( i + NUM_ ) ) ; } }
private synchronized Rect [ ] computeBoundingBoxes ( ) { if ( ! boundingBoxes . isPresent ( ) ) { Rect [ ] bb = new Rect [ ( int ) contours . size ( ) ] ; for ( int i = NUM_ ; i < contours . size ( ) ; i ++ ) { bb [ i ] = boundingRect ( contours . get ( i ) ) ; } boundingBoxes = Optional . of ( bb ) ; } return boundingBoxes . get ( ) ; }
public void addTimeline ( final JSONObject timeline ) { TimelineChannel . notifyTimeline ( timeline ) ; timelines . addFirst ( timeline ) ; final int maxCnt = Symphonys . getInt ( STR_ ) ; if ( timelines . size ( ) > maxCnt ) { timelines . remove ( maxCnt ) ; } }
private boolean loadLOBData ( ) { if ( isStoreAttachmentsOnFileSystem ) { return loadLOBDataFromFileSystem ( ) ; } return loadLOBDataFromDB ( ) ; }
protected void paintComponent ( Graphics g ) { backgroundPainter . paint ( g , getVisibleRect ( ) ) ; TextUI ui = getUI ( ) ; if ( ui != null ) { Graphics scratchGraphics = g . create ( ) ; try { ui . update ( scratchGraphics , this ) ; } finally { scratchGraphics . dispose ( ) ; } } }
public static < T > List < T > copyToArrayListWithExtraCapacity ( T [ ] elements , int extraCapacity ) { List < T > asList ; if ( elements != null ) { asList = new ArrayList < T > ( elements . length + extraCapacity ) ; asList . addAll ( Arrays . asList ( elements ) ) ; } else { asList = new ArrayList < T > ( extraCapacity ) ; } return asList ; }
private boolean sendEventToListeners ( ClusterEvent event ) { boolean success = BOOL_ ; for ( String listenerId : Collections . unmodifiableSet ( listeners . keySet ( ) ) ) { logger . debug ( STR_ , listenerId , event . getType ( ) , instanceId ) ; ClusterEventListener listener = listeners . get ( listenerId ) ; if ( listener != null && ! listener . handleEvent ( event ) ) { success = BOOL_ ; } } return success ; }
@ RequestMapping ( method = RequestMethod . PUT , value = STR_ , consumes = { MediaType . APPLICATION_JSON_VALUE } , produces = { MediaType . APPLICATION_JSON_VALUE } ) @ ApiOperation ( value = STR_ , notes = STR_ + STR_ + STR_ , response = void . class ) @ ApiResponses ( { @ ApiResponse ( code = NUM_ , message = STR_ ) , @ ApiResponse ( code = NUM_ , message = STR_ ) , @ ApiResponse ( code = NUM_ , message = STR_ ) , @ ApiResponse ( code = NUM_ , message = STR_ ) , @ ApiResponse ( code = NUM_ , message = STR_ ) , @ ApiResponse ( code = NUM_ , message = STR_ ) , @ ApiResponse ( code = NUM_ , message = STR_ ) } ) @ PreAuthorize ( STR_ ) public ResponseEntity < ? > update ( @ PathVariable ( STR_ ) String region , @ PathVariable ( STR_ ) final String [ ] keys , @ RequestParam ( value = STR_ , defaultValue = STR_ ) final String opValue , @ RequestBody final String json ) { logger . debug ( STR_ , region ) ; region = decode ( region ) ; if ( keys . length > NUM_ ) { return updateMultipleKeys ( region , keys , json ) ; } else { return updateSingleKey ( region , keys [ NUM_ ] , json , opValue ) ; } }
public void load ( X509Extension extensions ) { Set < String > critExts = extensions . getCriticalExtensionOIDs ( ) ; Set < String > nonCritExts = extensions . getNonCriticalExtensionOIDs ( ) ; List < X509Ext > sortedExts = new ArrayList < X509Ext > ( ) ; for ( Iterator < String > itr = critExts . iterator ( ) ; itr . hasNext ( ) ; ) { String extOid = itr . next ( ) ; byte [ ] value = extensions . getExtensionValue ( extOid ) ; X509Ext ext = new X509Ext ( new ASN1ObjectIdentifier ( extOid ) , value , BOOL_ ) ; sortedExts . add ( ext ) ; } for ( Iterator < String > itr = nonCritExts . iterator ( ) ; itr . hasNext ( ) ; ) { String extOid = itr . next ( ) ; byte [ ] value = extensions . getExtensionValue ( extOid ) ; X509Ext ext = new X509Ext ( new ASN1ObjectIdentifier ( extOid ) , value , BOOL_ ) ; sortedExts . add ( ext ) ; } Collections . sort ( sortedExts , new ExtensionNameComparator ( ) ) ; data = new Object [ sortedExts . size ( ) ] [ NUM_ ] ; int i = NUM_ ; for ( Iterator < X509Ext > itrSortedExts = sortedExts . iterator ( ) ; itrSortedExts . hasNext ( ) ; ) { X509Ext ext = itrSortedExts . next ( ) ; loadRow ( ext , i ) ; i ++ ; } fireTableDataChanged ( ) ; }
public Builder deleteAddresses ( ) { deleteFields . add ( STR_ ) ; return this ; }
public static void write ( File file , CharSequence data , Charset encoding , boolean append ) throws IOException { String str = data == null ? null : data . toString ( ) ; writeStringToFile ( file , str , encoding , append ) ; }
public Query limit ( int limit ) { return limit ( limit < NUM_ ? NO_LIMIT : Field . < Integer > field ( Integer . toString ( limit ) ) ) ; }
public static boolean fileExists ( String fName ) { boolean result = BOOL_ ; File file = new File ( fName ) ; if ( file != null ) { result = file . exists ( ) && file . isFile ( ) ; } return result ; }
@ Override public void write ( byte [ ] b , int off , int len ) { if ( ( off < NUM_ ) || ( off > b . length ) || ( len < NUM_ ) || ( ( off + len ) > b . length ) || ( ( off + len ) < NUM_ ) ) { throw new IndexOutOfBoundsException ( ) ; } else if ( len == NUM_ ) { return ; } synchronized ( this ) { int newcount = count + len ; int remaining = len ; int inBufferPos = count - filledBufferSum ; while ( remaining > NUM_ ) { int part = Math . min ( remaining , currentBuffer . length - inBufferPos ) ; System . arraycopy ( b , off + len - remaining , currentBuffer , inBufferPos , part ) ; remaining -= part ; if ( remaining > NUM_ ) { needNewBuffer ( newcount ) ; inBufferPos = NUM_ ; } } count = newcount ; } }
public long skip ( long n ) { if ( position + n <= document . getLength ( ) ) { position += n ; return n ; } long temp = position ; position = document . getLength ( ) ; return document . getLength ( ) - temp ; }
private static void _init ( ) { addMethod ( STR_ , new com . earth2me . essentials . register . payment . methods . iCo6 ( ) ) ; addMethod ( STR_ , new com . earth2me . essentials . register . payment . methods . iCo5 ( ) ) ; addMethod ( STR_ , new com . earth2me . essentials . register . payment . methods . BOSE7 ( ) ) ; addMethod ( STR_ , new com . earth2me . essentials . register . payment . methods . MCUR ( ) ) ; Dependencies . add ( STR_ ) ; addMethod ( STR_ , new com . earth2me . essentials . register . payment . methods . VaultEco ( ) ) ; }
public static String convertFileName ( String name , int maxBytes ) { try { return convertFileName ( name , maxBytes , Charset . defaultCharset ( ) ) ; } catch ( CharacterCodingException cce ) { try { return convertFileName ( name , maxBytes , Charset . forName ( STR_ ) ) ; } catch ( CharacterCodingException e ) { throw new RuntimeException ( STR_ + name , e ) ; } } }
public static void copy ( URL url , File file ) throws IOException { InputStream is = url . openStream ( ) ; try { OutputStream os = new FileOutputStream ( file ) ; try { byte [ ] buffer = new byte [ NUM_ ] ; int read ; while ( ( read = is . read ( buffer ) ) > NUM_ ) { os . write ( buffer , NUM_ , read ) ; } } finally { os . close ( ) ; } } finally { is . close ( ) ; } }
public void updateDeltas ( int deltaX , int deltaY ) { if ( mLeftBorderActive ) { mDeltaX = Math . max ( - mBaselineX , deltaX ) ; mDeltaX = Math . min ( mBaselineWidth - NUM_ . mTouchTargetWidth , mDeltaX ) ; } else if ( mRightBorderActive ) { mDeltaX = Math . min ( mDragLayer . getWidth ( ) - ( mBaselineX + mBaselineWidth ) , deltaX ) ; mDeltaX = Math . max ( - mBaselineWidth + NUM_ . mTouchTargetWidth , mDeltaX ) ; } if ( mTopBorderActive ) { mDeltaY = Math . max ( - mBaselineY , deltaY ) ; mDeltaY = Math . min ( mBaselineHeight - NUM_ . mTouchTargetWidth , mDeltaY ) ; } else if ( mBottomBorderActive ) { mDeltaY = Math . min ( mDragLayer . getHeight ( ) - ( mBaselineY + mBaselineHeight ) , deltaY ) ; mDeltaY = Math . max ( - mBaselineHeight + NUM_ . mTouchTargetWidth , mDeltaY ) ; } }
public void createAuthConfiguration ( String name ) throws AMConsoleException { if ( ( name == null ) || ( name . length ( ) == NUM_ ) ) { throw new AMConsoleException ( getLocalizedString ( STR_ ) ) ; } String [ ] params = { currentRealm , name } ; logEvent ( STR_ , params ) ; String errorMsg = null ; try { AMAuthConfigUtils . createNamedConfig ( name , NUM_ , new HashMap ( ) , currentRealm , getUserSSOToken ( ) ) ; logEvent ( STR_ , params ) ; } catch ( SMSException e ) { errorMsg = getErrorString ( e ) ; String [ ] paramsEx = { currentRealm , name , errorMsg } ; logEvent ( STR_ , paramsEx ) ; debug . warning ( STR_ , e ) ; } catch ( SSOException e ) { errorMsg = getErrorString ( e ) ; String [ ] paramsEx = { currentRealm , name , errorMsg } ; logEvent ( STR_ , paramsEx ) ; debug . warning ( STR_ , e ) ; } catch ( AMConfigurationException e ) { errorMsg = getErrorString ( e ) ; String [ ] paramsEx = { currentRealm , name , errorMsg } ; logEvent ( STR_ , paramsEx ) ; debug . warning ( STR_ , e ) ; } if ( errorMsg != null ) { throw new AMConsoleException ( errorMsg ) ; } }
private void writeAttribute ( java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( namespace . equals ( STR_ ) ) { xmlWriter . writeAttribute ( attName , attValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } }
public void trim ( String aText , int [ ] aSpan ) { int begin = aSpan [ NUM_ ] ; int end = aSpan [ NUM_ ] - NUM_ ; String data = aText ; while ( ( begin < ( data . length ( ) - NUM_ ) ) && trimChar ( data . charAt ( begin ) ) ) { begin ++ ; } while ( ( end > NUM_ ) && trimChar ( data . charAt ( end ) ) ) { end -- ; } end ++ ; aSpan [ NUM_ ] = begin ; aSpan [ NUM_ ] = end ; }
public String classifierTipText ( ) { return STR_ ; }
public WritableRaster createWritableChild ( int x , int y , int width , int height , int x0 , int y0 , int [ ] bandList ) { if ( x < this . minX ) { throw new RasterFormatException ( STR_ ) ; } if ( y < this . minY ) { throw new RasterFormatException ( STR_ ) ; } if ( ( x + width < x ) || ( x + width > this . minX + this . width ) ) { throw new RasterFormatException ( STR_ ) ; } if ( ( y + height < y ) || ( y + height > this . minY + this . height ) ) { throw new RasterFormatException ( STR_ ) ; } SampleModel sm ; if ( bandList != null ) { sm = sampleModel . createSubsetSampleModel ( bandList ) ; } else { sm = sampleModel ; } int deltaX = x0 - x ; int deltaY = y0 - y ; return new BytePackedRaster ( sm , dataBuffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sampleModelTranslateX + deltaX , sampleModelTranslateY + deltaY ) , this ) ; }
private void sendBuffer ( ) throws IOException { buf . flip ( ) ; send ( buf , buf . remaining ( ) ) ; buf = null ; }
public void callEvent ( Event event ) { if ( event . isAsynchronous ( ) ) { if ( Thread . holdsLock ( this ) ) { throw new IllegalStateException ( event . getEventName ( ) + STR_ ) ; } if ( server . isPrimaryThread ( ) ) { throw new IllegalStateException ( event . getEventName ( ) + STR_ ) ; } fireEvent ( event ) ; } else { synchronized ( this ) { fireEvent ( event ) ; } } }
@ Nullable private static PsiFile findFileToOpen ( @ NotNull List < PsiFile > files ) { PsiFile bestFile = null ; FolderConfiguration bestConfig = null ; for ( PsiFile file : files ) { PsiDirectory qualifiedDirectory = file . getParent ( ) ; assert qualifiedDirectory != null : STR_ ; FolderConfiguration config = FolderConfiguration . getConfigForFolder ( qualifiedDirectory . getName ( ) ) ; if ( bestConfig == null || config == null || config . compareTo ( bestConfig ) < NUM_ ) { bestConfig = config ; bestFile = file ; } } return bestFile ; }
protected boolean areEqual ( String string1 , String string2 , boolean caseMatters ) { return ( caseMatters && string1 . equals ( string2 ) ) || ( ! caseMatters && string1 . equalsIgnoreCase ( string2 ) ) ; }
public static CommandResult execCommand ( List < String > commands , boolean isRoot ) { return execCommand ( commands == null ? null : commands . toArray ( new String [ ] { } ) , isRoot , BOOL_ ) ; }
protected void populateBlob ( int id , byte [ ] baseContent , int requiredSize ) throws SQLException { Connection con = getConnectionViaDriverManager ( ) ; CallableStatement cstmt = null ; try { cstmt = con . prepareCall ( EXECUTE_FILL_BINARY_BLOB ) ; cstmt . setInt ( NUM_ , id ) ; cstmt . setBytes ( NUM_ , baseContent ) ; cstmt . setInt ( NUM_ , requiredSize ) ; cstmt . execute ( ) ; } finally { closeQuietly ( cstmt ) ; closeQuietly ( con ) ; } }
private void removeObservedFile ( String localPath ) { File file = new File ( localPath ) ; String parentPath = file . getParent ( ) ; FolderObserver observer = mFolderObserversMap . get ( parentPath ) ; if ( observer != null ) { observer . stopWatching ( file . getName ( ) ) ; if ( observer . isEmpty ( ) ) { mFolderObserversMap . remove ( parentPath ) ; Log_OC . d ( TAG , STR_ + parentPath + STR_ ) ; } } else { Log_OC . d ( TAG , STR_ + localPath ) ; } }
public void makeImmutable ( ) { if ( mutable ) { if ( results != null ) { int length = results . size ( ) ; for ( int i = NUM_ ; i < length ; i ++ ) { Result result = ( Result ) results . get ( i ) ; result . makeImmutable ( ) ; } results = Collections . unmodifiableList ( results ) ; } mutable = BOOL_ ; } }
public Statement isNull ( ) { statement . append ( STR_ ) ; return this ; }
public void clear ( ) { processQueue ( ) ; hash . clear ( ) ; }
private void updateFavoriteStation ( ) { String showString = null ; if ( FmRadioStation . isFavoriteStation ( mContext , mCurrentStation ) ) { String stationName = FmRadioStation . getStationName ( mContext , mCurrentStation , FmRadioStation . STATION_TYPE_FAVORITE ) ; FmRadioStation . updateStationToDb ( mContext , stationName , FmRadioStation . STATION_TYPE_SEARCHED , mCurrentStation ) ; mButtonAddToFavorite . setImageResource ( R . drawable . btn_fm_favorite_off_selector ) ; mTextStationName . setText ( STR_ ) ; showString = mProjectStringExt . getProjectString ( mContext , R . string . toast_channel_deleted , R . string . toast_channel_deleted1 ) ; } else { String stationName = FmRadioStation . getStationName ( mContext , mCurrentStation , FmRadioStation . STATION_TYPE_SEARCHED ) ; if ( FmRadioStation . isStationExist ( mContext , mCurrentStation , FmRadioStation . STATION_TYPE_SEARCHED ) ) { FmRadioStation . updateStationToDb ( mContext , stationName , FmRadioStation . STATION_TYPE_FAVORITE , mCurrentStation ) ; } else { FmRadioStation . insertStationToDb ( mContext , stationName , mCurrentStation , FmRadioStation . STATION_TYPE_FAVORITE ) ; } mButtonAddToFavorite . setImageResource ( R . drawable . btn_fm_favorite_on_selector ) ; mTextStationName . setText ( stationName ) ; showString = mProjectStringExt . getProjectString ( mContext , R . string . toast_channel_added , R . string . toast_channel_added1 ) ; } showToast ( showString ) ; }
public int addAllAbsent ( Collection < ? extends E > c ) { Object [ ] cs = c . toArray ( ) ; if ( cs . length == NUM_ ) return NUM_ ; final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { Object [ ] elements = getArray ( ) ; int len = elements . length ; int added = NUM_ ; for ( int i = NUM_ ; i < cs . length ; ++ i ) { Object e = cs [ i ] ; if ( indexOf ( e , elements , NUM_ , len ) < NUM_ && indexOf ( e , cs , NUM_ , added ) < NUM_ ) cs [ added ++ ] = e ; } if ( added > NUM_ ) { Object [ ] newElements = Arrays . copyOf ( elements , len + added ) ; System . arraycopy ( cs , NUM_ , newElements , len , added ) ; setArray ( newElements ) ; } return added ; } finally { lock . unlock ( ) ; } }
public Analyzer saveAnalysis ( File file ) throws IOException { PrintStream ps = null ; try { ps = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( file ) ) ) ; printAnalysis ( ps ) ; } finally { if ( ps != null ) { ps . close ( ) ; } } return this ; }
public Iterator < Capability > dependencies ( ) { return m_Dependencies . iterator ( ) ; }
public static void notifyTicket ( Context c , @ NonNull Ticket t , boolean keepNotification ) { String text ; String ticker ; int smallIcon ; int largeIcon ; int status ; switch ( TicketsAdapter . getValidityStatus ( t . getStatus ( ) , t . getValidTo ( ) ) ) { case TicketProvider . Tickets . STATUS_VALID : case TicketProvider . Tickets . STATUS_VALID_EXPIRING : text = c . getString ( R . string . notif_valid_text , FormatUtil . formatDateTimeDifference ( t . getValidTo ( ) ) ) ; ticker = c . getString ( R . string . notif_valid_ticker ) ; smallIcon = R . drawable . notification_small_ready ; largeIcon = R . drawable . notification_big_ready ; status = TicketProvider . Tickets . STATUS_VALID_EXPIRING ; break ; case TicketProvider . Tickets . STATUS_EXPIRING : case TicketProvider . Tickets . STATUS_EXPIRING_EXPIRED : text = c . getString ( R . string . notif_expiring_text , FormatUtil . formatTime ( t . getValidTo ( ) ) ) ; ticker = c . getString ( R . string . notif_expiring_ticker ) ; smallIcon = R . drawable . notification_small_warning ; largeIcon = R . drawable . notification_big_warning ; status = TicketProvider . Tickets . STATUS_EXPIRING_EXPIRED ; break ; case TicketProvider . Tickets . STATUS_EXPIRED : text = c . getString ( R . string . notif_expired_text , FormatUtil . formatTime ( t . getValidTo ( ) ) ) ; ticker = c . getString ( R . string . notif_expired_ticker ) ; smallIcon = R . drawable . notification_small_expired ; largeIcon = R . drawable . notification_big_expired ; status = TicketProvider . Tickets . STATUS_EXPIRED ; break ; default : return ; } Intent intent = new Intent ( c , WearableService . class ) ; intent . setAction ( STR_ ) ; intent . putExtra ( STR_ , t ) ; intent . putExtra ( STR_ , status ) ; c . startService ( intent ) ; Intent i = new Intent ( c , MainActivity . class ) ; i . addFlags ( Intent . FLAG_ACTIVITY_SINGLE_TOP | Intent . FLAG_ACTIVITY_CLEAR_TOP ) ; i . putExtra ( MainActivity . EXTRA_TICKET_ID , t . getId ( ) ) ; PendingIntent openIntent = PendingIntent . getActivity ( c , t . getNotificationId ( ) , i , PendingIntent . FLAG_CANCEL_CURRENT ) ; Intent i2 = new Intent ( c , MainActivity . class ) ; i2 . addFlags ( Intent . FLAG_ACTIVITY_SINGLE_TOP | Intent . FLAG_ACTIVITY_CLEAR_TOP ) ; i2 . putExtra ( MainActivity . EXTRA_TICKET_ID , t . getId ( ) ) ; i2 . putExtra ( MainActivity . EXTRA_SHOW_SMS , BOOL_ ) ; PendingIntent showSmsIntent = PendingIntent . getActivity ( c , t . getNotificationId ( ) + NUM_ , i2 , PendingIntent . FLAG_CANCEL_CURRENT ) ; List < Action > actions = new ArrayList < Action > ( ) ; actions . add ( new Action ( R . drawable . notification_show_sms , R . string . notif_show_sms , showSmsIntent ) ) ; List < String > rows = new ArrayList < String > ( ) ; rows . add ( text ) ; rows . add ( c . getString ( R . string . tickets_valid_from ) + STR_ + FormatUtil . formatDateTime ( t . getValidFrom ( ) ) ) ; rows . add ( c . getString ( R . string . tickets_code ) + STR_ + t . getHash ( ) ) ; fireNotification ( c , t . getNotificationId ( ) , openIntent , c . getString ( R . string . application_name ) , text , rows , t . getCity ( ) , ticker , smallIcon , largeIcon , actions , keepNotification ) ; }
public final static int parseInt ( String str ) { char c = str . charAt ( NUM_ ) ; int length = str . length ( ) ; boolean negative = ( c == STR_ ) ; int offset = NUM_ ; if ( negative ) { if ( length == NUM_ || length > NUM_ ) { return Integer . parseInt ( str ) ; } c = str . charAt ( offset ++ ) ; } else { if ( length > NUM_ ) { return Integer . parseInt ( str ) ; } } if ( c > STR_ || c < STR_ ) { return Integer . parseInt ( str ) ; } int num = c - STR_ ; if ( offset < length ) { c = str . charAt ( offset ++ ) ; if ( c > STR_ || c < STR_ ) { return Integer . parseInt ( str ) ; } num = ( num . NUM_ ) + ( c - STR_ ) ; if ( offset < length ) { c = str . charAt ( offset ++ ) ; if ( c > STR_ || c < STR_ ) { return Integer . parseInt ( str ) ; } num = ( num . NUM_ ) + ( c - STR_ ) ; if ( offset < length ) { do { c = str . charAt ( offset ++ ) ; if ( c > STR_ || c < STR_ ) { return Integer . parseInt ( str ) ; } num = ( num . NUM_ ) + ( c - STR_ ) ; } while ( offset < length ) ; } } } return negative ? - num : num ; }
public BufferedHeader ( final CharArrayBuffer buffer ) throws ParseException { super ( ) ; if ( buffer == null ) { throw new IllegalArgumentException ( STR_ ) ; } int colon = buffer . indexOf ( STR_ ) ; if ( colon == - NUM_ ) { throw new ParseException ( STR_ + buffer . toString ( ) ) ; } String s = buffer . substringTrimmed ( NUM_ , colon ) ; if ( s . length ( ) == NUM_ ) { throw new ParseException ( STR_ + buffer . toString ( ) ) ; } this . buffer = buffer ; this . name = s ; this . valuePos = colon + NUM_ ; }
public synchronized void returnBuf ( byte [ ] buf ) { if ( buf == null || buf . length > mSizeLimit ) { return ; } mBuffersByLastUse . add ( buf ) ; int pos = Collections . binarySearch ( mBuffersBySize , buf , BUF_COMPARATOR ) ; if ( pos < NUM_ ) { pos = - pos - NUM_ ; } mBuffersBySize . add ( pos , buf ) ; mCurrentSize += buf . length ; trim ( ) ; }
public static String toDateString ( java . util . Date date , String format ) { if ( date == null ) return STR_ ; SimpleDateFormat dateFormat = null ; if ( format != null ) { dateFormat = new SimpleDateFormat ( format ) ; } else { dateFormat = new SimpleDateFormat ( ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( date ) ; return dateFormat . format ( date ) ; }
@ Deprecated public static < T > T executeWithBackOff ( AbstractGoogleClientRequest < T > client , String error , Object ... errorArgs ) throws IOException , InterruptedException { return executeWithBackOff ( client , String . format ( error , errorArgs ) ) ; }
private void checkServerResponseCode ( HttpURLConnection urlConnection ) throws RequestFailureException { try { if ( urlConnection . getResponseCode ( ) != NUM_ ) { throw new RequestFailureException ( STR_ + urlConnection . getResponseCode ( ) + STR_ ) ; } } catch ( IOException e ) { throw new RequestFailureException ( STR_ , e ) ; } }
public static void addResourceSource ( ResourceSource source ) { ALL_RESOURCE_SOURCES . add ( source ) ; }
private void commitChanges ( ) { hopfieldPropsPanel . commitChanges ( ) ; inputPanel . commitChanges ( ) ; }
private boolean connect_to_target ( PlaPointInt p_from_point ) { if ( nearest_target_item != null && target_set != null && ! target_set . contains ( nearest_target_item ) ) { nearest_target_item = null ; } if ( nearest_target_item == null || ! nearest_target_item . shares_net_no ( net_nos ) ) { return BOOL_ ; } boolean route_completed = BOOL_ ; PlaPointInt connection_point = null ; if ( nearest_target_item instanceof BrdAbit ) { BrdAbit target = ( BrdAbit ) nearest_target_item ; connection_point = target . center_get ( ) ; } else if ( nearest_target_item instanceof BrdTracep ) { return r_board . connect_to_trace ( p_from_point , ( BrdTracep ) nearest_target_item , pen_half_width_arr [ layer_active_no ] , clearance_class ) ; } else if ( nearest_target_item instanceof BrdAreaConduction ) { connection_point = p_from_point ; } if ( connection_point != null ) { route_completed = itera_connect ( p_from_point , connection_point ) ; } return route_completed ; }
public boolean onGenericMotionEvent ( MotionEvent ev ) { if ( ( ev . getSource ( ) & InputDevice . SOURCE_CLASS_POINTER ) == InputDevice . SOURCE_CLASS_POINTER ) { int action = ev . getAction ( ) ; switch ( action & MotionEvent . ACTION_MASK ) { case MotionEvent . ACTION_SCROLL : float vScroll = ev . getAxisValue ( MotionEvent . AXIS_VSCROLL ) ; if ( vScroll > NUM_ ) { if ( mDeckView . ensureFocusedTask ( ) ) { mDeckView . focusNextTask ( BOOL_ , BOOL_ ) ; } } else { if ( mDeckView . ensureFocusedTask ( ) ) { mDeckView . focusNextTask ( BOOL_ , BOOL_ ) ; } } return BOOL_ ; } } return BOOL_ ; }
public boolean addClass ( OwlClass targetClass ) { targetClass . addQCRestriction ( this ) ; return qcClasses . add ( targetClass ) ; }
public void editElement ( final Object element , final String columnPropertyName ) { final int columnIndex = TableViewerUtils . columnPropertyNameToColumnIndex ( columnPropertyName , BOOL_ , viewer ) ; viewer . editElement ( element , columnIndex ) ; }
public Fp ( ECCurve curve , ECFieldElement x , ECFieldElement y ) { this ( curve , x , y , BOOL_ ) ; }
private static String serializeDocumentInt ( Document doc ) throws TransformerException , IOException { ByteArrayOutputStream s = new ByteArrayOutputStream ( ) ; TransformerFactory factory = TransformerFactory . newInstance ( ) ; Transformer transformer = factory . newTransformer ( ) ; transformer . setOutputProperty ( OutputKeys . METHOD , STR_ ) ; transformer . setOutputProperty ( OutputKeys . INDENT , STR_ ) ; DOMSource source = new DOMSource ( doc ) ; StreamResult outputTarget = new StreamResult ( s ) ; transformer . transform ( source , outputTarget ) ; return s . toString ( STR_ ) ; }
void addFillComponents ( Container panel , int [ ] cols , int [ ] rows ) { Dimension filler = new Dimension ( NUM_ , NUM_ ) ; boolean filled_cell_11 = BOOL_ ; CellConstraints cc = new CellConstraints ( ) ; if ( cols . length > NUM_ && rows . length > NUM_ ) { if ( cols [ NUM_ ] == NUM_ && rows [ NUM_ ] == NUM_ ) { panel . add ( Box . createRigidArea ( filler ) , cc . xy ( NUM_ , NUM_ ) ) ; filled_cell_11 = BOOL_ ; } } for ( int index = NUM_ ; index < cols . length ; index ++ ) { if ( cols [ index ] == NUM_ && filled_cell_11 ) { continue ; } panel . add ( Box . createRigidArea ( filler ) , cc . xy ( cols [ index ] , NUM_ ) ) ; } for ( int index = NUM_ ; index < rows . length ; index ++ ) { if ( rows [ index ] == NUM_ && filled_cell_11 ) { continue ; } panel . add ( Box . createRigidArea ( filler ) , cc . xy ( NUM_ , rows [ index ] ) ) ; } }
@ Override public boolean useBufferPerWindow ( ) { return ! Win32GraphicsEnvironment . isDWMCompositionEnabled ( ) ; }
private void serializable ( final IsolationLevels level ) throws Exception { clear ( store ) ; final ValueFactory vf = store . getValueFactory ( ) ; final IRI subj = vf . createIRI ( STR_ ) ; final IRI pred = vf . createIRI ( STR_ ) ; RepositoryConnection prep = store . getConnection ( ) ; try { prep . begin ( level ) ; prep . add ( subj , pred , vf . createLiteral ( NUM_ ) ) ; prep . commit ( ) ; } finally { prep . close ( ) ; } final CountDownLatch start = new CountDownLatch ( NUM_ ) ; final CountDownLatch observed = new CountDownLatch ( NUM_ ) ; Thread t1 = incrementBy ( start , observed , level , vf , subj , pred , NUM_ ) ; Thread t2 = incrementBy ( start , observed , level , vf , subj , pred , NUM_ ) ; t2 . start ( ) ; t1 . start ( ) ; t2 . join ( ) ; t1 . join ( ) ; assertNotFailed ( ) ; RepositoryConnection check = store . getConnection ( ) ; try { check . begin ( level ) ; Literal lit = readLiteral ( check , subj , pred ) ; int val = lit . intValue ( ) ; if ( val != NUM_ && val != NUM_ ) { assertEquals ( NUM_ , val ) ; } check . commit ( ) ; } finally { check . close ( ) ; } }
public static Array listToArrayRemoveEmpty ( String list , char delimiter ) { int len = list . length ( ) ; ArrayImpl array = new ArrayImpl ( ) ; if ( len == NUM_ ) return array ; int last = NUM_ ; for ( int i = NUM_ ; i < len ; i ++ ) { if ( list . charAt ( i ) == delimiter ) { if ( last < i ) array . _append ( list . substring ( last , i ) ) ; last = i + NUM_ ; } } if ( last < len ) array . _append ( list . substring ( last ) ) ; return array ; }
private int clampMag ( int value , int absMin , int absMax ) { final int absValue = Math . abs ( value ) ; if ( absValue < absMin ) return NUM_ ; if ( absValue > absMax ) return value > NUM_ ? absMax : - absMax ; return value ; }
public static < T extends Object & java . lang . Comparable < ? super T > > T min ( Collection < ? extends T > collection ) { Iterator < ? extends T > it = collection . iterator ( ) ; T min = it . next ( ) ; while ( it . hasNext ( ) ) { T next = it . next ( ) ; if ( min . compareTo ( next ) > NUM_ ) { min = next ; } } return min ; }
@ Override public ServerHeartbeat server ( String address , int port , boolean isSSL , String clusterId , String displayName , boolean isDynamic ) { Objects . requireNonNull ( address ) ; Objects . requireNonNull ( clusterId ) ; if ( address . isEmpty ( ) ) { address = STR_ ; } ClusterHeartbeat cluster = createCluster ( clusterId ) ; ServerHeartbeat server ; if ( isDynamic ) { server = cluster . createDynamicServer ( address , port , isSSL ) ; } else { server = cluster . createServer ( address , port , isSSL ) ; } if ( displayName != null ) { server . setDisplayName ( displayName ) ; } if ( ! isDynamic ) { cluster . addSeedServer ( server ) ; } return server ; }
public void testToString ( ) { LinkedBlockingQueue q = populatedQueue ( SIZE ) ; String s = q . toString ( ) ; for ( int i = NUM_ ; i < SIZE ; ++ i ) { assertTrue ( s . indexOf ( String . valueOf ( i ) ) >= NUM_ ) ; } }
private void findClub ( ) { if ( ce ( ) == null ) { return ; } String title = Messages . getString ( STR_ ) ; String body = Messages . getString ( STR_ ) ; if ( ! clientgui . doYesNoDialog ( title , body ) ) { return ; } attacks . removeAllElements ( ) ; attacks . addElement ( new FindClubAction ( cen ) ) ; ready ( ) ; }
public void test_allocationContexts ( ) throws IOException { final Journal store = ( Journal ) getStore ( ) ; try { final RWStrategy bs = ( RWStrategy ) store . getBufferStrategy ( ) ; final RWStore rw = bs . getStore ( ) ; final IAllocationContext allocContext1 = rw . newAllocationContext ( BOOL_ ) ; final IAllocationContext allocContext2 = rw . newAllocationContext ( BOOL_ ) ; final int sze = NUM_ ; final byte [ ] buf = new byte [ sze + NUM_ ] ; r . nextBytes ( buf ) ; final long addr1a = bs . write ( ByteBuffer . wrap ( buf ) , allocContext1 ) ; final long addr1b = bs . write ( ByteBuffer . wrap ( buf ) , allocContext1 ) ; rw . detachContext ( allocContext1 ) ; final long addr2a = bs . write ( ByteBuffer . wrap ( buf ) , allocContext2 ) ; final long addr2b = bs . write ( ByteBuffer . wrap ( buf ) , allocContext2 ) ; rw . detachContext ( allocContext2 ) ; try { bs . write ( ByteBuffer . wrap ( buf ) , allocContext1 ) ; fail ( STR_ ) ; } catch ( IllegalStateException ise ) { } final IAllocationContext allocContext3 = rw . newAllocationContext ( BOOL_ ) ; final long addr1c = bs . write ( ByteBuffer . wrap ( buf ) , allocContext3 ) ; assertTrue ( STR_ , bs . getPhysicalAddress ( addr1c ) > bs . getPhysicalAddress ( addr2b ) ) ; bs . delete ( addr1c , allocContext3 ) ; final long addr1d = bs . write ( ByteBuffer . wrap ( buf ) , allocContext3 ) ; assertTrue ( STR_ , addr1c == addr1d ) ; rw . detachContext ( allocContext3 ) ; store . commit ( ) ; bs . delete ( addr1d ) ; final long addr1e = bs . write ( ByteBuffer . wrap ( buf ) ) ; assertTrue ( STR_ , addr1e != addr1d ) ; store . commit ( ) ; } finally { store . destroy ( ) ; } }
public PDFXref ( byte [ ] line ) { if ( line == null ) { id = - NUM_ ; generation = - NUM_ ; } else { id = Integer . parseInt ( new String ( line , NUM_ , NUM_ ) ) ; generation = Integer . parseInt ( new String ( line , NUM_ , NUM_ ) ) ; } compressed = BOOL_ ; }
public static String [ ] makeStrings ( Collection < InetAddress > addrs ) { String [ ] result = new String [ addrs . size ( ) ] ; int i = NUM_ ; for ( InetAddress addr : addrs ) { result [ i ++ ] = addr . getHostAddress ( ) ; } return result ; }
public static void showProfile ( Activity activity , String pilotId , @ Nullable HashMap < String , String > extras ) { if ( ( pilotId == null || pilotId . isEmpty ( ) ) && AirMap . hasValidAuthenticatedUser ( ) ) { pilotId = AirMap . getUserId ( ) ; } Intent intent = new Intent ( activity , ProfileActivity . class ) ; intent . putExtra ( ProfileActivity . ARG_PILOT_ID , pilotId ) ; if ( extras != null ) { intent . putExtra ( CreateFlightActivity . KEY_VALUE_EXTRAS , extras ) ; } activity . startActivity ( intent ) ; }
public SmoothMoves ( ) { cycleStart = System . nanoTime ( ) / NUM_ ; startTimer ( currentResolution ) ; }
public static void updatePriceLists ( Properties ctx , ProductBean productBean , String trxName ) throws OperationException { ArrayList < ProductBean > list = productBean . getProductBeanList ( ) ; if ( list != null ) { int productId = productBean . getProductId ( ) ; Iterator < ProductBean > iter = list . iterator ( ) ; while ( iter . hasNext ( ) ) { ProductBean bean = iter . next ( ) ; int priceListId = bean . getPriceListId ( ) ; BigDecimal stdPrice = bean . getStdPrice ( ) ; BigDecimal listPrice = bean . getListPrice ( ) ; BigDecimal limitPrice = bean . getLimitPrice ( ) ; MPriceList priceList = MPriceList . get ( ctx , priceListId , trxName ) ; if ( priceList . isTaxIncluded ( ) ) { stdPrice = bean . getStdPriceIncl ( ) ; listPrice = bean . getListPriceIncl ( ) ; limitPrice = bean . getLimitPriceIncl ( ) ; } updatePriceLists ( ctx , productId , priceListId , stdPrice , listPrice , limitPrice , trxName ) ; } } }
private String checkDependencies ( ModuleDescriptor md , HashMap < String , ModuleDescriptor > modlist ) { logger . debug ( STR_ + md . getId ( ) ) ; ModuleInterface [ ] requires = md . getRequires ( ) ; if ( requires != null ) { for ( ModuleInterface req : requires ) { String res = checkOneDependency ( md , req , modlist ) ; if ( ! res . isEmpty ( ) ) { return res ; } } } return STR_ ; }
public void testClearBitPositiveInside1 ( ) { byte aBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int number = NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger result = aNumber . clearBit ( number ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public void deserializeFunnel ( List < Object > serializedFunnel ) { Set < Object > funnelStepAccumulator = new HashSet < > ( ) ; for ( Object e : serializedFunnel ) { if ( e != null ) { funnelStepAccumulator . add ( e ) ; } else { funnelSteps . add ( new HashSet < > ( funnelStepAccumulator ) ) ; funnelStepAccumulator . clear ( ) ; } } }
public static String appendParameter ( CtClass type , String descriptor ) { int i = descriptor . indexOf ( STR_ ) ; if ( i < NUM_ ) return descriptor ; else { StringBuffer newdesc = new StringBuffer ( ) ; newdesc . append ( descriptor . substring ( NUM_ , i ) ) ; toDescriptor ( newdesc , type ) ; newdesc . append ( descriptor . substring ( i ) ) ; return newdesc . toString ( ) ; } }
public void addCatchClause ( CatchClause clause ) { assertNotNull ( clause ) ; if ( catchClauses == null ) { catchClauses = new ArrayList < CatchClause > ( ) ; } catchClauses . add ( clause ) ; clause . setParent ( this ) ; }
public static void streamContentToBrowser ( HttpServletResponse response , byte [ ] bytes , String contentType , String fileName ) throws IOException { setResponseBrowserProxyNoCache ( response ) ; response . setContentLength ( bytes . length ) ; if ( contentType != null ) { response . setContentType ( contentType ) ; } if ( fileName != null ) { response . setHeader ( STR_ , STR_ + fileName + STR_ ) ; } OutputStream out = response . getOutputStream ( ) ; InputStream in = new ByteArrayInputStream ( bytes ) ; try { streamContent ( out , in , bytes . length ) ; } catch ( IOException e ) { in . close ( ) ; out . close ( ) ; throw e ; } in . close ( ) ; out . flush ( ) ; out . close ( ) ; }
public void unlock ( Object key ) { String uid = String . valueOf ( key ) ; Transaction tr = lockedUIDHashMap . get ( uid ) ; if ( tr == null ) { return ; } try { tr . commit ( ) ; } catch ( Exception e ) { logger . warn ( STR_ , e ) ; } finally { lockedUIDHashMap . remove ( uid ) ; } }
public List < Order > fetchOrders ( int startIndex , int num ) { int endIndex = startIndex + num > orders . size ( ) ? orders . size ( ) : startIndex + num ; return orders . subList ( startIndex , endIndex ) ; }
public boolean ensureSchemaAgreement ( ) { long start = System . currentTimeMillis ( ) ; Map < String , List < String > > schemas = null ; while ( System . currentTimeMillis ( ) - start < DbClientContext . MAX_SCHEMA_WAIT_MS ) { try { log . info ( STR_ , DbClientContext . SCHEMA_RETRY_SLEEP_MILLIS / NUM_ ) ; Thread . sleep ( DbClientContext . SCHEMA_RETRY_SLEEP_MILLIS ) ; } catch ( InterruptedException ex ) { log . warn ( STR_ ) ; } schemas = getSchemaVersions ( ) ; if ( schemas . size ( ) > NUM_ ) { continue ; } if ( schemas . size ( ) == NUM_ ) { if ( ! schemas . containsKey ( StorageProxy . UNREACHABLE ) ) { return BOOL_ ; } else { continue ; } } if ( schemas . containsKey ( StorageProxy . UNREACHABLE ) ) { return BOOL_ ; } } log . error ( STR_ , schemas ) ; throw new IllegalStateException ( STR_ ) ; }
void clear ( ) { stack . clear ( ) ; }
private TileStore ( final SpriteStore store ) { this . store = store ; tiles = new ArrayList < Sprite > ( ) ; tiles . add ( store . getEmptySprite ( ) ) ; }
public static String comparableQualifier ( String qualifier ) { int i = _QUALIFIERS . indexOf ( qualifier ) ; return i == - NUM_ ? _QUALIFIERS . size ( ) + STR_ + qualifier : String . valueOf ( i ) ; }
public boolean moreWorkThan ( StoredBlock other ) { return chainWork . compareTo ( other . chainWork ) > NUM_ ; }
public static Object evaluate ( Object context , Object self , String expr , List < String > engineConfigs ) throws CWLExpressionException { String trimmedExpr = StringUtils . trim ( expr ) ; if ( trimmedExpr . startsWith ( STR_ ) ) { trimmedExpr = trimmedExpr . substring ( NUM_ ) ; } String function = trimmedExpr ; if ( trimmedExpr . startsWith ( STR_ ) ) { function = STR_ ; function = function . replace ( STR_ , trimmedExpr ) ; } Context cx = Context . enter ( ) ; cx . setOptimizationLevel ( OPTIMIZATION_LEVEL ) ; cx . setMaximumInterpreterStackDepth ( MAX_STACK_DEPTH ) ; cx . setClassShutter ( new CWLExpressionDenyAllClassShutter ( ) ) ; try { Scriptable globalScope = cx . initStandardObjects ( ) ; if ( engineConfigs != null ) { for ( int i = NUM_ ; i < engineConfigs . size ( ) ; i ++ ) { Reader engineConfigReader = new StringReader ( engineConfigs . get ( i ) ) ; cx . evaluateReader ( globalScope , engineConfigReader , STR_ + i + STR_ , NUM_ , null ) ; } } putToScope ( EXPR_CONTEXT_NAME , context , cx , globalScope ) ; putToScope ( EXPR_SELF_NAME , self , cx , globalScope ) ; Scriptable resultScope = cx . newObject ( globalScope ) ; resultScope . setPrototype ( globalScope ) ; resultScope . setParentScope ( globalScope ) ; Object result = cx . evaluateString ( resultScope , function , STR_ , NUM_ , null ) ; if ( result == null || result instanceof Undefined ) { return null ; } Object wrappedResult = Context . javaToJS ( result , globalScope ) ; putToScope ( STR_ , wrappedResult , cx , globalScope ) ; ScriptableObject . putProperty ( globalScope , STR_ , wrappedResult ) ; String finalFunction = STR_ + STR_ + STR_ + STR_ + STR_ ; Scriptable wrapScope = cx . newObject ( globalScope ) ; wrapScope . setPrototype ( globalScope ) ; wrapScope . setParentScope ( globalScope ) ; result = cx . evaluateString ( wrapScope , finalFunction , STR_ , NUM_ , null ) ; return castResult ( result ) ; } catch ( Exception e ) { String msg = String . format ( STR_ , expr ) ; throw new CWLExpressionException ( msg , e ) ; } finally { Context . exit ( ) ; } }
private void token ( char c ) throws ConfigurationException , IOException { int t = st . nextToken ( ) ; if ( t != c ) { if ( c == STR_ ) { syntax ( STR_ ) ; } else { syntax ( new String ( new char [ ] { STR_ , c , + STR_ } ) ) ; } } }
public static boolean isJarURL ( URL url ) { String protocol = url . getProtocol ( ) ; return ( URL_PROTOCOL_JAR . equals ( protocol ) || URL_PROTOCOL_ZIP . equals ( protocol ) || URL_PROTOCOL_VFSZIP . equals ( protocol ) || URL_PROTOCOL_WSJAR . equals ( protocol ) ) ; }
public boolean equals ( Object o ) { if ( o instanceof LDAPUsers ) { LDAPUsers g = ( LDAPUsers ) o ; if ( ( selectedUserDNs != null ) && ( g . selectedUserDNs != null ) && ( selectedUserDNs . equals ( g . selectedUserDNs ) ) ) { return BOOL_ ; } } return BOOL_ ; }
protected void applySetTimestamp ( Long timestamp ) throws SQLException { if ( timestamp != null && conn . supportsControlTimestamp ( ) ) { if ( timestamp . longValue ( ) != currentTimestamp ) { currentTimestamp = timestamp . longValue ( ) ; statement . addBatch ( conn . getControlTimestampQuery ( timestamp ) ) ; } } }
private void addReference ( final int sourcePosition , final int referencePosition ) { if ( srcAndRefPositions == null ) { srcAndRefPositions = new int [ NUM_ ] ; } if ( referenceCount >= srcAndRefPositions . length ) { int [ ] a = new int [ srcAndRefPositions . length + NUM_ ] ; System . arraycopy ( srcAndRefPositions , NUM_ , a , NUM_ , srcAndRefPositions . length ) ; srcAndRefPositions = a ; } srcAndRefPositions [ referenceCount ++ ] = sourcePosition ; srcAndRefPositions [ referenceCount ++ ] = referencePosition ; }
public Accessor ( String className , ClassLoader classLoader , Class [ ] constructorTypes , Object [ ] constructorArgs ) { try { fClass = Class . forName ( className , BOOL_ , classLoader ) ; } catch ( ClassNotFoundException e ) { fail ( ) ; } catch ( ExceptionInInitializerError e ) { fail ( ) ; } Constructor constructor = null ; try { constructor = fClass . getDeclaredConstructor ( constructorTypes ) ; } catch ( SecurityException e2 ) { fail ( ) ; } catch ( NoSuchMethodException e2 ) { fail ( ) ; } Assert . isNotNull ( constructor ) ; constructor . setAccessible ( BOOL_ ) ; try { fInstance = constructor . newInstance ( constructorArgs ) ; } catch ( IllegalArgumentException e ) { fail ( ) ; } catch ( InvocationTargetException e ) { fail ( ) ; } catch ( InstantiationException e ) { fail ( ) ; } catch ( IllegalAccessException e ) { fail ( ) ; } }
public static List < LoggedMqttMessage > parseMessageLog ( final List < String > messages , final ProgressUpdater progress , final long current , final long max ) throws SpyException { try { final long startTime = TimeUtils . getMonotonicTime ( ) ; final int items = messages . size ( ) ; final long chunkSize = items / NUM_ ; final MqttMessageLogParser parser = new MqttMessageLogParser ( ) ; final List < LoggedMqttMessage > list = new ArrayList < LoggedMqttMessage > ( ) ; long item = NUM_ ; long reportAt = NUM_ ; for ( int i = NUM_ ; i < items ; i ++ ) { final String message = messages . get ( i ) ; if ( progress != null ) { if ( progress . isCancelled ( ) ) { logger . info ( STR_ ) ; return null ; } item ++ ; if ( item % NUM_ == NUM_ ) { progress . update ( current + item , max ) ; } } if ( ( i > NUM_ ) && ( i == ( chunkSize . reportAt ) ) ) { final long currentTime = TimeUtils . getMonotonicTime ( ) ; final long timeTaken = currentTime - startTime ; final long totalTimeExpected = timeTaken . items / i ; if ( timeTaken > NUM_ ) { logger . info ( STR_ , reportAt . NUM_ , ( totalTimeExpected - timeTaken ) / NUM_ ) ; } reportAt ++ ; } try { list . add ( parser . parse ( message ) ) ; } catch ( XMLException e ) { logger . error ( STR_ + message , e ) ; } } logger . info ( STR_ , list . size ( ) ) ; return list ; } catch ( XMLException e ) { throw new SpyException ( STR_ , e ) ; } }
public void stop ( ) { duration += System . currentTimeMillis ( ) - start ; }
public void addRow ( Object [ ] row ) throws CarbonSortKeyAndGroupByException { int currentSize = entryCount ; if ( sortBufferSize == currentSize ) { LOGGER . debug ( STR_ ) ; File [ ] fileList ; if ( procFiles . size ( ) >= numberOfIntermediateFileToBeMerged ) { synchronized ( lockObject ) { fileList = procFiles . toArray ( new File [ procFiles . size ( ) ] ) ; this . procFiles = new ArrayList < File > ( NUM_ ) ; } LOGGER . debug ( STR_ + fileList . length ) ; startIntermediateMerging ( fileList ) ; } Object [ ] [ ] recordHolderListLocal = recordHolderList ; try { semaphore . acquire ( ) ; dataSorterAndWriterExecutorService . submit ( new DataSorterAndWriter ( recordHolderListLocal ) ) ; } catch ( InterruptedException e ) { LOGGER . error ( STR_ + e . getMessage ( ) ) ; throw new CarbonSortKeyAndGroupByException ( e . getMessage ( ) ) ; } this . recordHolderList = new Object [ this . sortBufferSize ] [ ] ; this . entryCount = NUM_ ; } recordHolderList [ entryCount ++ ] = row ; }
public static byte [ ] decode ( String data ) { int len = data . length ( ) / NUM_ . NUM_ ; ByteArrayOutputStream bOut = new ByteArrayOutputStream ( len ) ; try { encoder . decode ( data , bOut ) ; } catch ( Exception e ) { throw new DecoderException ( STR_ + e . getMessage ( ) , e ) ; } return bOut . toByteArray ( ) ; }
@ Uninterruptible public static Address unwindNativeStackFrame ( Address currfp ) { if ( VM . BuildForIA32 ) { return currfp ; } Address callee_fp ; Address fp = Magic . getCallerFramePointer ( currfp ) ; Address ip ; do { callee_fp = fp ; ip = Magic . getReturnAddressUnchecked ( fp ) ; fp = Magic . getCallerFramePointer ( fp ) ; } while ( ! MemoryManager . addressInVM ( ip ) && fp . NE ( StackFrameLayout . getStackFrameSentinelFP ( ) ) ) ; if ( VM . BuildForPowerPC ) { return fp ; } else { return callee_fp ; } }
@ Override public PathImpl schemeWalk ( String userPath , Map < String , Object > attributes , String filePath , int offset ) { String canonicalPath ; if ( offset < filePath . length ( ) && ( filePath . charAt ( offset ) == STR_ || filePath . charAt ( offset ) == _separatorChar ) ) canonicalPath = normalizePath ( STR_ , filePath , offset , _separatorChar ) ; else canonicalPath = normalizePath ( _pathname , filePath , offset , _separatorChar ) ; return fsWalk ( userPath , attributes , canonicalPath ) ; }
public static boolean isMimeTypeImage ( String mimeType ) { return mimeType != null && mimeType . startsWith ( STR_ ) ; }
public FXMessageDialog ( final Stage parent , final Parent group ) { this ( parent ) ; content . setCenter ( group ) ; }
@ Override protected int sizeOf ( String key , BitmapDrawable value ) { final int bitmapSize = getBitmapSize ( value ) / NUM_ ; return bitmapSize == NUM_ ? NUM_ : bitmapSize ; }
public Matrix abs ( ) { Matrix result = new Matrix ( m , n ) ; for ( int i = NUM_ ; i < result . A . length ; i ++ ) { for ( int j = NUM_ ; j < result . A [ i ] . length ; j ++ ) result . A [ i ] [ j ] = Math . abs ( A [ i ] [ j ] ) ; } return result ; }
public void removeAttribute ( String attrName ) throws SMSException { Set attribute = ( Set ) attrSet . get ( attrName ) ; if ( attribute == null ) { throw ( new SMSException ( LdapException . newLdapException ( ResultCode . ATTRIBUTE_OR_VALUE_EXISTS , getBundleString ( IUMSConstants . SMS_ATTR_OR_VAL_EXISTS ) ) , STR_ ) ) ; } attrSet . remove ( attrName ) ; if ( modSet == null ) { modSet = new HashSet ( ) ; } BasicAttribute ba = new BasicAttribute ( attrName , attribute ) ; for ( Iterator items = attribute . iterator ( ) ; items . hasNext ( ) ; ) ba . add ( items . next ( ) ) ; modSet . add ( new ModificationItem ( DirContext . REMOVE_ATTRIBUTE , ba ) ) ; }
@ TargetApi ( Build . VERSION_CODES . HONEYCOMB ) public void snapshot ( int cameraId ) { final int encWidth = NUM_ ; final int encHeight = NUM_ ; if ( enable . containsKey ( cameraId ) && ! enable . get ( cameraId ) ) { return ; } Camera camera = null ; synchronized ( cameraLock ) { try { camera = prepareCamera ( cameraId , encWidth , encHeight ) ; if ( camera == null ) { return ; } if ( Cfg . DEBUG ) { Check . log ( TAG + STR_ + cameraId ) ; } if ( this . surface == null ) { int [ ] surfaceparams = new int [ NUM_ ] ; GLES20 . glGenTextures ( NUM_ , surfaceparams , NUM_ ) ; GLES20 . glBindTexture ( GLES20 . GL_TEXTURE_2D , surfaceparams [ NUM_ ] ) ; GLES20 . glTexParameteri ( GLES20 . GL_TEXTURE_2D , GLES20 . GL_TEXTURE_WRAP_S , GLES20 . GL_CLAMP_TO_EDGE ) ; GLES20 . glTexParameteri ( GLES20 . GL_TEXTURE_2D , GLES20 . GL_TEXTURE_WRAP_T , GLES20 . GL_CLAMP_TO_EDGE ) ; this . surface = new SurfaceTexture ( surfaceparams [ NUM_ ] ) ; } camera . setPreviewTexture ( surface ) ; camera . startPreview ( ) ; camera . setOneShotPreviewCallback ( previewCallback ) ; cameraLock . wait ( ) ; } catch ( Exception e ) { if ( Cfg . DEBUG ) { Check . log ( TAG + STR_ + e ) ; } } } }
private static DebuggerException parseExceptionOption ( Node node ) { return new DebuggerException ( parseStringOption ( node , STR_ ) , parseLongOption ( node , STR_ ) , DebuggerExceptionHandlingAction . convertToHandlingAction ( parseIntOption ( node , STR_ ) ) ) ; }
public Image rotate180Degrees ( Image image , boolean maintainOpacity ) { int [ ] rgb = image . getRGB ( ) ; int [ ] newRGB = new int [ rgb . length ] ; int width = image . getWidth ( ) ; int height = image . getHeight ( ) ; for ( int y = NUM_ ; y < height ; y ++ ) { for ( int x = NUM_ ; x < width ; x ++ ) { int destX = width - x - NUM_ ; newRGB [ destX + ( height - y - NUM_ ) . width ] = rgb [ x + y . width ] ; } } return EncodedImage . createFromRGB ( newRGB , width , height , ! maintainOpacity ) ; }
public static void updateFinantare ( SetGetModel m , String changedColumnName ) { BigDecimal valCofinantare = SetGetUtil . get_AttrValueAsBigDecimal ( m , COLUMNNAME_A_Valoare_Cofinantare ) ; BigDecimal assetCost = SetGetUtil . get_AttrValueAsBigDecimal ( m , COLUMNNAME_A_Asset_Cost ) ; BigDecimal valTert = SetGetUtil . get_AttrValueAsBigDecimal ( m , COLUMNNAME_A_Valoare_Tert ) ; if ( valCofinantare . signum ( ) == NUM_ && valTert . signum ( ) == NUM_ ) { valCofinantare = assetCost ; valTert = Env . ZERO ; } else if ( COLUMNNAME_A_Asset_Cost . equals ( changedColumnName ) ) { valCofinantare = assetCost . subtract ( valTert ) ; } else if ( COLUMNNAME_A_Valoare_Cofinantare . equals ( changedColumnName ) ) { valTert = assetCost . subtract ( valCofinantare ) ; } else if ( COLUMNNAME_A_Valoare_Tert . equals ( changedColumnName ) ) { valCofinantare = assetCost . subtract ( valTert ) ; } else { valTert = assetCost . subtract ( valCofinantare ) ; } String tipFinantare = A_TIP_FINANTARE_Cofinantare ; if ( valTert . signum ( ) == NUM_ ) { tipFinantare = A_TIP_FINANTARE_Proprie ; } else if ( valCofinantare . signum ( ) == NUM_ ) { tipFinantare = A_TIP_FINANTARE_Terti ; } m . set_AttrValue ( COLUMNNAME_A_Tip_Finantare , tipFinantare ) ; m . set_AttrValue ( COLUMNNAME_A_Valoare_Cofinantare , valCofinantare ) ; m . set_AttrValue ( COLUMNNAME_A_Valoare_Tert , valTert ) ; if ( A_TIP_FINANTARE_Proprie . equals ( tipFinantare ) && SetGetUtil . isPersistent ( m ) ) { m . set_AttrValue ( COLUMNNAME_A_FundingMode_ID , null ) ; } }
private void displayCalendar ( ) { ListItem listItem = fieldResource . getSelectedItem ( ) ; if ( listItem == null ) return ; KeyNamePair pp = new KeyNamePair ( ( Integer ) listItem . getValue ( ) , listItem . getLabel ( ) ) ; int S_Resource_ID = pp . getKey ( ) ; m_mAssignment . setS_Resource_ID ( S_Resource_ID ) ; Date date = fieldDate . getValue ( ) ; if ( date == null ) date = new Timestamp ( System . currentTimeMillis ( ) ) ; m_loading = BOOL_ ; schedulePane . recreate ( S_Resource_ID , date ) ; m_loading = BOOL_ ; invalidate ( ) ; }
public LineString createLineString ( CoordinateSequence coordinates ) { return new LineString ( coordinates , this ) ; }
public static final float [ ] trim ( float [ ] a , int size ) { if ( a . length == size ) { return a ; } else { float [ ] b = new float [ size ] ; System . arraycopy ( a , NUM_ , b , NUM_ , size ) ; return b ; } }
public void close ( ) { if ( closed . compareAndSet ( BOOL_ , BOOL_ ) ) { doClose ( ) ; } }
@ Override public boolean connectionAllowed ( String eventName ) { if ( ! eventName . equals ( STR_ ) ) { return BOOL_ ; } if ( m_listenee != null ) { return BOOL_ ; } return BOOL_ ; }
void subtractFlakes ( int quantity ) { for ( int i = NUM_ ; i < quantity ; ++ i ) { int index = numFlakes - i - NUM_ ; flakes . remove ( index ) ; } setNumFlakes ( numFlakes - quantity ) ; }
public int processBytes ( byte [ ] in , int inOff , int len , byte [ ] out , int outOff ) throws DataLengthException , IllegalStateException { if ( len < NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } int blockSize = getBlockSize ( ) ; int length = getUpdateOutputSize ( len ) ; if ( length > NUM_ ) { if ( ( outOff + length ) > out . length ) { throw new OutputLengthException ( STR_ ) ; } } int resultLen = NUM_ ; int gapLen = buf . length - bufOff ; if ( len > gapLen ) { System . arraycopy ( in , inOff , buf , bufOff , gapLen ) ; resultLen += cipher . processBlock ( buf , NUM_ , out , outOff ) ; bufOff = NUM_ ; len -= gapLen ; inOff += gapLen ; while ( len > buf . length ) { resultLen += cipher . processBlock ( in , inOff , out , outOff + resultLen ) ; len -= blockSize ; inOff += blockSize ; } } System . arraycopy ( in , inOff , buf , bufOff , len ) ; bufOff += len ; return resultLen ; }
public boolean requiredResourceName ( Policy policy , String realmName , String name ) { getSvcTypeNameToActionsMap ( policy , realmName ) ; return requiredResourceNameService . contains ( name ) ; }
public static void main ( String args [ ] ) { boolean ok = parseOptions ( args ) ; if ( ! ok || ! stripFiles ( infiles , outfiles ) ) { System . exit ( NUM_ ) ; } }
protected String a ( String s , int v , String u ) throws Exception { char sign = v >= NUM_ ? STR_ : STR_ ; Date dt = DateMathParser . parseMath ( null , s + STR_ + sign + Math . abs ( v ) + u ) ; return fmt . format ( dt . toInstant ( ) ) ; }
public AuthorityKeyIdentifierStructure ( X509Certificate certificate ) throws CertificateParsingException { super ( fromCertificate ( certificate ) ) ; }
JarFile open ( final File jarFile ) throws IOException { isTrue ( jarFile . exists ( ) , STR_ ) ; return new JarFile ( jarFile ) ; }
public void removeAllEmails ( ) { emails . clear ( ) ; }
@ Override public synchronized void initialize ( ) { if ( ! mRootDirectory . exists ( ) ) { if ( ! mRootDirectory . mkdirs ( ) ) { VolleyLog . e ( STR_ , mRootDirectory . getAbsolutePath ( ) ) ; } return ; } File [ ] files = mRootDirectory . listFiles ( ) ; if ( files == null ) { return ; } for ( File file : files ) { BufferedInputStream fis = null ; try { fis = new BufferedInputStream ( new FileInputStream ( file ) ) ; CacheHeader entry = CacheHeader . readHeader ( fis ) ; entry . size = file . length ( ) ; putEntry ( entry . key , entry ) ; } catch ( IOException e ) { if ( file != null ) { file . delete ( ) ; } } finally { try { if ( fis != null ) { fis . close ( ) ; } } catch ( IOException ignored ) { } } } }
protected void drawPath ( Canvas canvas , List < Float > points , Paint paint , boolean circular ) { Path path = new Path ( ) ; int height = canvas . getHeight ( ) ; int width = canvas . getWidth ( ) ; float [ ] tempDrawPoints ; if ( points . size ( ) < NUM_ ) { return ; } tempDrawPoints = calculateDrawPoints ( points . get ( NUM_ ) , points . get ( NUM_ ) , points . get ( NUM_ ) , points . get ( NUM_ ) , height , width ) ; path . moveTo ( tempDrawPoints [ NUM_ ] , tempDrawPoints [ NUM_ ] ) ; path . lineTo ( tempDrawPoints [ NUM_ ] , tempDrawPoints [ NUM_ ] ) ; int length = points . size ( ) ; for ( int i = NUM_ ; i < length ; i += NUM_ ) { if ( ( points . get ( i - NUM_ ) < NUM_ && points . get ( i + NUM_ ) < NUM_ ) || ( points . get ( i - NUM_ ) > height && points . get ( i + NUM_ ) > height ) ) { continue ; } tempDrawPoints = calculateDrawPoints ( points . get ( i - NUM_ ) , points . get ( i - NUM_ ) , points . get ( i ) , points . get ( i + NUM_ ) , height , width ) ; if ( ! circular ) { path . moveTo ( tempDrawPoints [ NUM_ ] , tempDrawPoints [ NUM_ ] ) ; } path . lineTo ( tempDrawPoints [ NUM_ ] , tempDrawPoints [ NUM_ ] ) ; } if ( circular ) { path . lineTo ( points . get ( NUM_ ) , points . get ( NUM_ ) ) ; } canvas . drawPath ( path , paint ) ; }
@ KnownFailure ( STR_ ) public void test_unwrap_02 ( ) throws SSLException { String host = STR_ ; int port = NUM_ ; ByteBuffer [ ] bbA = { ByteBuffer . allocate ( NUM_ ) , ByteBuffer . allocate ( NUM_ ) , ByteBuffer . allocate ( NUM_ ) } ; ByteBuffer bb = ByteBuffer . allocate ( NUM_ ) ; SSLEngine sse = getEngine ( host , port ) ; sse . setUseClientMode ( BOOL_ ) ; try { sse . unwrap ( bb , bbA , - NUM_ , NUM_ ) ; fail ( STR_ ) ; } catch ( IndexOutOfBoundsException iobe ) { } try { sse . unwrap ( bb , bbA , NUM_ , - NUM_ ) ; fail ( STR_ ) ; } catch ( IndexOutOfBoundsException iobe ) { } try { sse . unwrap ( bb , bbA , bbA . length + NUM_ , bbA . length ) ; fail ( STR_ ) ; } catch ( IndexOutOfBoundsException iobe ) { } try { sse . unwrap ( bb , bbA , NUM_ , bbA . length + NUM_ ) ; fail ( STR_ ) ; } catch ( IndexOutOfBoundsException iobe ) { } }
public PWResetAdminLog ( SSOToken token ) { this . token = token ; if ( logStatus ) { logger = ( com . sun . identity . log . Logger ) Logger . getLogger ( logFile ) ; } String lstr = SystemProperties . get ( Constants . AM_LOCALE ) ; init ( lstr ) ; }
public static boolean isLetter ( Character self ) { return Character . isLetter ( self ) ; }
public void callArgVisitors ( XPathVisitor visitor ) { for ( int i = NUM_ ; i < m_argVec . size ( ) ; i ++ ) { Expression exp = ( Expression ) m_argVec . elementAt ( i ) ; exp . callVisitors ( new ArgExtOwner ( exp ) , visitor ) ; } }
public static String createLink ( String uri , String label ) { return STR_ + uri + STR_ + label + STR_ ; }
public static boolean isExpression ( String token , boolean isXml ) { String openExpr ; String closeExpr ; if ( isXml ) { openExpr = OPEN_EXPR_XML ; closeExpr = CLOSE_EXPR_XML ; } else { openExpr = OPEN_EXPR ; closeExpr = CLOSE_EXPR ; } if ( token . startsWith ( openExpr ) && token . endsWith ( closeExpr ) ) { return BOOL_ ; } else { return BOOL_ ; } }
public void destroy ( ) { this . isInitialized = BOOL_ ; this . isFinished = BOOL_ ; this . firstNode = null ; this . tailLength = NUM_ ; this . firstNodeHeight = - NUM_ ; }
public static Uri fromFile ( File file ) { if ( file == null ) { throw new NullPointerException ( STR_ ) ; } PathPart path = PathPart . fromDecoded ( file . getAbsolutePath ( ) ) ; return new HierarchicalUri ( STR_ , Part . EMPTY , path , Part . NULL , Part . NULL ) ; }
protected Object readFixedType ( BinaryReaderExImpl reader ) throws BinaryObjectException { Object val = null ; switch ( mode ) { case BYTE : val = reader . readByteNullable ( id ) ; break ; case SHORT : val = reader . readShortNullable ( id ) ; break ; case INT : val = reader . readIntNullable ( id ) ; break ; case LONG : val = reader . readLongNullable ( id ) ; break ; case FLOAT : val = reader . readFloatNullable ( id ) ; break ; case DOUBLE : val = reader . readDoubleNullable ( id ) ; break ; case CHAR : val = reader . readCharNullable ( id ) ; break ; case BOOLEAN : val = reader . readBooleanNullable ( id ) ; break ; case DECIMAL : val = reader . readDecimal ( id ) ; break ; case STRING : val = reader . readString ( id ) ; break ; case UUID : val = reader . readUuid ( id ) ; break ; case DATE : val = reader . readDate ( id ) ; break ; case TIMESTAMP : val = reader . readTimestamp ( id ) ; break ; case BYTE_ARR : val = reader . readByteArray ( id ) ; break ; case SHORT_ARR : val = reader . readShortArray ( id ) ; break ; case INT_ARR : val = reader . readIntArray ( id ) ; break ; case LONG_ARR : val = reader . readLongArray ( id ) ; break ; case FLOAT_ARR : val = reader . readFloatArray ( id ) ; break ; case DOUBLE_ARR : val = reader . readDoubleArray ( id ) ; break ; case CHAR_ARR : val = reader . readCharArray ( id ) ; break ; case BOOLEAN_ARR : val = reader . readBooleanArray ( id ) ; break ; case DECIMAL_ARR : val = reader . readDecimalArray ( id ) ; break ; case STRING_ARR : val = reader . readStringArray ( id ) ; break ; case UUID_ARR : val = reader . readUuidArray ( id ) ; break ; case DATE_ARR : val = reader . readDateArray ( id ) ; break ; case TIMESTAMP_ARR : val = reader . readTimestampArray ( id ) ; break ; case OBJECT_ARR : val = reader . readObjectArray ( id ) ; break ; case COL : val = reader . readCollection ( id , null ) ; break ; case MAP : val = reader . readMap ( id , null ) ; break ; case BINARY_OBJ : val = reader . readBinaryObject ( id ) ; break ; case ENUM : val = reader . readEnum ( id , field . getType ( ) ) ; break ; case ENUM_ARR : val = reader . readEnumArray ( id , field . getType ( ) . getComponentType ( ) ) ; break ; case BINARY : case OBJECT : val = reader . readObject ( id ) ; break ; case CLASS : val = reader . readClass ( id ) ; break ; default : assert BOOL_ : STR_ + mode ; } return val ; }
protected void processPlayRequest ( ) { tryToGetAudioFocus ( ) ; if ( mState == State . STOPPED ) { playMedia ( ) ; } else if ( mState == State . PAUSED ) { mState = State . PLAYING ; setUpAsForeground ( String . format ( getString ( R . string . media_state_playing ) , mFile . getFileName ( ) ) ) ; configAndStartMediaPlayer ( ) ; } }
@ SuppressWarnings ( STR_ ) public static < T > int binarySearch ( List < ? extends T > list , T object , Comparator < ? super T > comparator ) { if ( comparator == null ) { return Collections . binarySearch ( ( List < ? extends java . lang . Comparable < ? super T > > ) list , object ) ; } if ( ! ( list instanceof RandomAccess ) ) { ListIterator < ? extends T > it = list . listIterator ( ) ; while ( it . hasNext ( ) ) { int result ; if ( ( result = - comparator . compare ( it . next ( ) , object ) ) <= NUM_ ) { if ( result == NUM_ ) { return it . previousIndex ( ) ; } return - it . previousIndex ( ) - NUM_ ; } } return - list . size ( ) - NUM_ ; } int low = NUM_ , mid = list . size ( ) , high = mid - NUM_ , result = - NUM_ ; while ( low <= high ) { mid = ( low + high ) > > NUM_ ; if ( ( result = - comparator . compare ( list . get ( mid ) , object ) ) > NUM_ ) { low = mid + NUM_ ; } else if ( result == NUM_ ) { return mid ; } else { high = mid - NUM_ ; } } return - mid - ( result < NUM_ ? NUM_ : NUM_ ) ; }
public void finish ( ) { m_bias = NUM_ ; m_out . flush ( ) ; }
@ Override public Vector whatCanGoHere ( int [ ] state ) { Vector ret = new Vector ( ) ; for ( int i = NUM_ ; i < fNumElements ; i ++ ) { if ( state [ i + NUM_ ] == STATE_START ) ret . addElement ( fAllElements [ i ] ) ; } return ret ; }
public void remove ( RegionEntry entry , Object value ) { Object object = map . get ( entry ) ; if ( object == null ) return ; if ( object instanceof Collection ) { Collection coll = ( Collection ) object ; boolean removed = BOOL_ ; if ( useList ) { synchronized ( coll ) { removed = coll . remove ( value ) ; } } else { removed = coll . remove ( value ) ; } if ( removed ) { if ( coll . size ( ) == NUM_ ) { map . remove ( entry ) ; } atomicUpdater . decrementAndGet ( this ) ; } } else { if ( object . equals ( value ) ) { map . remove ( entry ) ; } atomicUpdater . decrementAndGet ( this ) ; } }
private HashDataCache ( DataCache < Pair < String , T > > cache , String algorithm ) { this . cache = cache ; this . algorithm = algorithm ; try { MessageDigest . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException e ) { String msg = STR_ + algorithm ; LOG . warn ( msg , e ) ; throw new SystemConfigException ( e ) ; } }
private void marshallEnum ( Object value , EnumType enumType ) throws IOException { LOG . debug ( STR_ , value , enumType ) ; jsonGenerator . writeString ( value . toString ( ) ) ; }
public CholeskyDecomposition ( Matrix Arg ) { double [ ] [ ] A = Arg . getArray ( ) ; n = Arg . getRowDimension ( ) ; L = new double [ n ] [ n ] ; isspd = ( Arg . getColumnDimension ( ) == n ) ; for ( int j = NUM_ ; j < n ; j ++ ) { double [ ] Lrowj = L [ j ] ; double d = NUM_ ; for ( int k = NUM_ ; k < j ; k ++ ) { double [ ] Lrowk = L [ k ] ; double s = NUM_ ; for ( int i = NUM_ ; i < k ; i ++ ) { s += Lrowk [ i ] . Lrowj [ i ] ; } Lrowj [ k ] = s = ( A [ j ] [ k ] - s ) / L [ k ] [ k ] ; d = d + s . s ; isspd = isspd & ( A [ k ] [ j ] == A [ j ] [ k ] ) ; } d = A [ j ] [ j ] - d ; isspd = isspd & ( d > NUM_ ) ; L [ j ] [ j ] = Math . sqrt ( Math . max ( d , NUM_ ) ) ; for ( int k = j + NUM_ ; k < n ; k ++ ) { L [ j ] [ k ] = NUM_ ; } } }
private void initEvents ( ) { setSelectionSounds ( play , hScore , credits , quit , quitY , quitN ) ; play . setOnAction ( null ) ; hScore . setOnAction ( null ) ; credits . setOnAction ( null ) ; quit . setOnAction ( null ) ; quitY . setOnAction ( null ) ; quitN . setOnAction ( null ) ; scene . setOnKeyPressed ( null ) ; scene . setOnKeyReleased ( null ) ; }
public static boolean isFileTypeSupported ( int fileType , Sequence sequence ) { List providers = getMidiFileWriters ( ) ; for ( int i = NUM_ ; i < providers . size ( ) ; i ++ ) { MidiFileWriter writer = ( MidiFileWriter ) providers . get ( i ) ; if ( writer . isFileTypeSupported ( fileType , sequence ) ) { return BOOL_ ; } } return BOOL_ ; }
public byte [ ] windowNaf ( byte width , BigInteger k ) { byte [ ] wnaf = new byte [ k . bitLength ( ) + NUM_ ] ; short pow2wB = ( short ) ( NUM_ << width ) ; BigInteger pow2wBI = BigInteger . valueOf ( pow2wB ) ; int i = NUM_ ; int length = NUM_ ; while ( k . signum ( ) > NUM_ ) { if ( k . testBit ( NUM_ ) ) { BigInteger remainder = k . mod ( pow2wBI ) ; if ( remainder . testBit ( width - NUM_ ) ) { wnaf [ i ] = ( byte ) ( remainder . intValue ( ) - pow2wB ) ; } else { wnaf [ i ] = ( byte ) remainder . intValue ( ) ; } k = k . subtract ( BigInteger . valueOf ( wnaf [ i ] ) ) ; length = i ; } else { wnaf [ i ] = NUM_ ; } k = k . shiftRight ( NUM_ ) ; i ++ ; } length ++ ; byte [ ] wnafShort = new byte [ length ] ; System . arraycopy ( wnaf , NUM_ , wnafShort , NUM_ , length ) ; return wnafShort ; }
private String mapCollectionName ( String collectionName , boolean dest ) { if ( ( collectionRules . size ( ) == NUM_ ) && ( StringUtils . isBlank ( defaultCollectionAppend ) ) ) { return collectionName ; } for ( String [ ] rule : collectionRules ) { String match = ( dest ) ? rule [ NUM_ ] : rule [ NUM_ ] ; String replace = ( dest ) ? rule [ NUM_ ] : rule [ NUM_ ] ; if ( collectionName . contains ( match ) ) { return collectionName . replace ( match , replace ) ; } } if ( dest ) { return collectionName + defaultCollectionAppend ; } else { return collectionName . replace ( defaultCollectionAppend , STR_ ) ; } }
void fullyLock ( ) { putLock . lock ( ) ; takeLock . lock ( ) ; }
static public void fillRandomIntegerUniform ( IDoubleVector vec , Random rand , int min , int max ) { final int delta = max - min ; for ( int i = NUM_ ; i < vec . getLength ( ) ; ++ i ) { vec . set ( i , min + rand . nextInt ( delta ) ) ; } }
@ Override public int hashCode ( ) { return Arrays . hashCode ( data ) ; }
private static void stoppingAnimation ( Thread me ) { final FetcherInfo info = FetcherInfo . getFetcherInfo ( ) ; synchronized ( info . waitList ) { int index = - NUM_ ; for ( int i = NUM_ ; i < info . fetchers . length ; i ++ ) { if ( info . fetchers [ i ] == me ) { return ; } if ( info . fetchers [ i ] == null ) { index = i ; } } if ( index >= NUM_ ) { info . fetchers [ index ] = me ; info . numFetchers ++ ; me . setName ( STR_ + index ) ; return ; } } }
public boolean name_is_equal ( String p_name ) { if ( p_name == null ) return BOOL_ ; return p_name . equalsIgnoreCase ( pkg_name ) ; }
protected void drawRangeMarkers ( Graphics2D g2 , Rectangle2D dataArea , int index , Layer layer ) { XYItemRenderer r = getRenderer ( index ) ; if ( r == null ) { return ; } if ( index >= getDatasetCount ( ) ) { return ; } Collection markers = getRangeMarkers ( index , layer ) ; ValueAxis axis = getRangeAxisForDataset ( index ) ; if ( markers != null && axis != null ) { Iterator iterator = markers . iterator ( ) ; while ( iterator . hasNext ( ) ) { Marker marker = ( Marker ) iterator . next ( ) ; r . drawRangeMarker ( g2 , this , axis , marker , dataArea ) ; } } }
static byte [ ] decryptData ( byte [ ] password , byte [ ] encryptedData ) { try { Cipher c = Cipher . getInstance ( ENCRYPT_DATA_ALGORITHM ) ; c . init ( Cipher . DECRYPT_MODE , new SecretKeySpec ( password , SECRET_KEY_ALGORITHM ) , CBC_SALT_DATA ) ; return c . doFinal ( encryptedData ) ; } catch ( Exception e ) { throw new IllegalStateException ( ENCRYPT_DATA_ALGORITHM + STR_ , e ) ; } }
public VPFLayer ( ) { setProjectionChangePolicy ( new com . bbn . openmap . layer . policy . ListResetPCPolicy ( this ) ) ; setMouseModeIDsForEvents ( new String [ ] { STR_ } ) ; }
private void emitCode ( ) { LinkedList < Instantiation > worklist = new LinkedList < Instantiation > ( ) ; worklist . add ( new Instantiation ( null , mainSubroutine ) ) ; InsnList newInstructions = new InsnList ( ) ; List < TryCatchBlockNode > newTryCatchBlocks = new ArrayList < TryCatchBlockNode > ( ) ; List < LocalVariableNode > newLocalVariables = new ArrayList < LocalVariableNode > ( ) ; while ( ! worklist . isEmpty ( ) ) { Instantiation inst = worklist . removeFirst ( ) ; emitSubroutine ( inst , worklist , newInstructions , newTryCatchBlocks , newLocalVariables ) ; } instructions = newInstructions ; tryCatchBlocks = newTryCatchBlocks ; localVariables = newLocalVariables ; }
protected boolean shouldClose ( PooledConnection con , int action ) { if ( con . getConnectionVersion ( ) < getPoolVersion ( ) ) return BOOL_ ; if ( con . isDiscarded ( ) ) return BOOL_ ; if ( isClosed ( ) ) return BOOL_ ; if ( ! con . validate ( action ) ) return BOOL_ ; if ( ! terminateTransaction ( con ) ) return BOOL_ ; if ( con . isMaxAgeExpired ( ) ) return BOOL_ ; else return BOOL_ ; }
public Vector3D hsl ( ) { float r = redf ( ) ; float g = greenf ( ) ; float b = bluef ( ) ; float min = Math . min ( Math . min ( r , g ) , b ) ; float max = Math . max ( Math . max ( r , g ) , b ) ; float l = lighting ( min , max ) ; float s = saturation ( min , max , l ) ; float h = hue ( r , g , b , min , max ) ; return new Vector3D ( h , s , l ) ; }
public Future < Boolean > shutdownAwaiting ( long timeoutForEach ) { ExecutorService executor = Executors . newScheduledThreadPool ( NUM_ ) ; return executor . submit ( createShutdown ( timeoutForEach ) ) ; }
public boolean isUnused ( ) { return ( numEntries < NUM_ ) && waitingThreads . isEmpty ( ) ; }
public void changeDirectory ( String path ) throws IllegalStateException , IOException , FTPIllegalReplyException , FTPException { synchronized ( lock ) { if ( ! connected ) { throw new IllegalStateException ( STR_ ) ; } if ( ! authenticated ) { throw new IllegalStateException ( STR_ ) ; } communication . sendFTPCommand ( STR_ + path ) ; FTPReply r = communication . readFTPReply ( ) ; touchAutoNoopTimer ( ) ; if ( ! r . isSuccessCode ( ) ) { throw new FTPException ( r ) ; } } }
private String removeQuote ( String column ) { return column != null ? column . replaceAll ( statementBuilder . getColumnQuote ( ) , StringUtils . EMPTY ) : null ; }
private boolean scrolledUpTimeout ( ) { if ( fixedChat || pauseKeyPressed ) { return BOOL_ ; } if ( ! styles . autoScroll ( ) ) { return BOOL_ ; } long timePassed = System . currentTimeMillis ( ) - lastChanged ; if ( timePassed > NUM_ . styles . autoScrollTimeout ( ) ) { LOGGER . info ( STR_ + timePassed + STR_ ) ; return BOOL_ ; } return BOOL_ ; }
private boolean zzRefill ( ) throws java . io . IOException { if ( zzStartRead > NUM_ ) { System . arraycopy ( zzBuffer , zzStartRead , zzBuffer , NUM_ , zzEndRead - zzStartRead ) ; zzEndRead -= zzStartRead ; zzCurrentPos -= zzStartRead ; zzMarkedPos -= zzStartRead ; zzStartRead = NUM_ ; } if ( zzCurrentPos >= zzBuffer . length ) { char newBuffer [ ] = new char [ zzCurrentPos . NUM_ ] ; System . arraycopy ( zzBuffer , NUM_ , newBuffer , NUM_ , zzBuffer . length ) ; zzBuffer = newBuffer ; } int numRead = zzReader . read ( zzBuffer , zzEndRead , zzBuffer . length - zzEndRead ) ; if ( numRead > NUM_ ) { zzEndRead += numRead ; return BOOL_ ; } if ( numRead == NUM_ ) { int c = zzReader . read ( ) ; if ( c == - NUM_ ) { return BOOL_ ; } else { zzBuffer [ zzEndRead ++ ] = ( char ) c ; return BOOL_ ; } } return BOOL_ ; }
public List < Document > search ( Query query , boolean prefixWildCard ) { List < Document > documents = new ArrayList < Document > ( ) ; try { IndexSearcher searcher = getSearcher ( ) ; TopDocs search = searcher . search ( query , NUM_ ) ; for ( ScoreDoc scoreDoc : search . scoreDocs ) { Document doc = searcher . doc ( scoreDoc . doc ) ; documents . add ( doc ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; throw new RuntimeException ( e ) ; } return documents ; }
public void writeListEnd ( ) throws IOException { os . write ( STR_ ) ; }
public static List < ? extends Element > childElementList ( Element element , Set < String > childElementNames ) { if ( element == null ) return null ; List < Element > elements = new LinkedList < Element > ( ) ; if ( childElementNames == null ) return elements ; Node node = element . getFirstChild ( ) ; if ( node != null ) { do { if ( node . getNodeType ( ) == Node . ELEMENT_NODE && childElementNames . contains ( node . getNodeName ( ) ) ) { Element childElement = ( Element ) node ; elements . add ( childElement ) ; } } while ( ( node = node . getNextSibling ( ) ) != null ) ; } return elements ; }
protected synchronized byte [ ] engineGenerateSeed ( int numBytes ) { byte [ ] myBytes ; if ( numBytes < NUM_ ) { throw new NegativeArraySizeException ( Integer . toString ( numBytes ) ) ; } if ( numBytes == NUM_ ) { return EmptyArray . BYTE ; } if ( myRandom == null ) { myRandom = new SHA1PRNG_SecureRandomImpl ( ) ; myRandom . engineSetSeed ( getRandomBytes ( DIGEST_LENGTH ) ) ; } myBytes = new byte [ numBytes ] ; myRandom . engineNextBytes ( myBytes ) ; return myBytes ; }
public String numArcsTipText ( ) { return STR_ ; }
private static char [ ] zzUnpackCMap ( String packed ) { char [ ] map = new char [ x10000 ] ; int i = NUM_ ; int j = NUM_ ; while ( i < NUM_ ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM_ ) ; } return map ; }
@ RequestMapping ( value = STR_ , method = { RequestMethod . GET } ) @ ResponseBody public List < JobInstance > list ( JobListRequest jobRequest ) { List < JobInstance > jobInstanceList = Collections . emptyList ( ) ; List < JobStatusEnum > statusList = new ArrayList < JobStatusEnum > ( ) ; if ( null != jobRequest . getStatus ( ) ) { for ( int status : jobRequest . getStatus ( ) ) { statusList . add ( JobStatusEnum . getByCode ( status ) ) ; } } JobTimeFilterEnum timeFilter = JobTimeFilterEnum . getByCode ( jobRequest . getTimeFilter ( ) ) ; try { jobInstanceList = jobService . listAllJobs ( jobRequest . getCubeName ( ) , jobRequest . getProjectName ( ) , statusList , jobRequest . getLimit ( ) , jobRequest . getOffset ( ) , timeFilter ) ; } catch ( Exception e ) { logger . error ( e . getLocalizedMessage ( ) , e ) ; throw new InternalErrorException ( e ) ; } return jobInstanceList ; }
public byte [ ] toBinary ( int q ) { return ArrayEncoder . encodeModQ ( coeffs , q ) ; }
public Criteria or ( ) { Criteria criteria = createCriteriaInternal ( ) ; oredCriteria . add ( criteria ) ; return criteria ; }
public final void openFallbackInputStream ( ) throws DataFallbackException { if ( inputBuf == null ) { if ( LOG . isDebugEnabled ( ) ) LOG . debug ( STR_ + dataFile . getName ( ) + STR_ ) ; try { setInput ( new BufferedReader ( new FileReader ( dataFile ) ) ) ; } catch ( IOException e ) { throw new DataFallbackException ( e . getMessage ( ) ) ; } } }
public void addCaretListener ( final ICaretListener listener ) { Preconditions . checkNotNull ( listener , STR_ ) ; if ( ! m_listeners . contains ( listener ) ) { m_listeners . add ( listener ) ; } }
@ Deprecated static public SerialSensorManager instance ( ) { return null ; }
public void testIsCurrency ( ) { try { assertFalse ( rsmd . isCurrency ( NUM_ ) ) ; } catch ( SQLException e1 ) { fail ( STR_ + e1 . getMessage ( ) ) ; e1 . printStackTrace ( ) ; } try { rsmd . isCurrency ( NUM_ ) ; fail ( STR_ ) ; } catch ( SQLException e ) { } try { rsmd . isCurrency ( NUM_ ) ; fail ( STR_ ) ; } catch ( SQLException e ) { } try { rs . close ( ) ; rsmd . isCurrency ( NUM_ ) ; fail ( STR_ ) ; } catch ( SQLException e ) { } }
public String encodeBuffer ( byte aBuffer [ ] ) { ByteArrayOutputStream outStream = new ByteArrayOutputStream ( ) ; ByteArrayInputStream inStream = new ByteArrayInputStream ( aBuffer ) ; try { encodeBuffer ( inStream , outStream ) ; } catch ( Exception IOException ) { throw new Error ( STR_ ) ; } return ( outStream . toString ( ) ) ; }
void checkFrameValue ( final Object value ) { if ( value == Opcodes . TOP || value == Opcodes . INTEGER || value == Opcodes . FLOAT || value == Opcodes . LONG || value == Opcodes . DOUBLE || value == Opcodes . NULL || value == Opcodes . UNINITIALIZED_THIS ) { return ; } if ( value instanceof String ) { checkInternalName ( ( String ) value , STR_ ) ; return ; } if ( ! ( value instanceof Label ) ) { throw new IllegalArgumentException ( STR_ + value ) ; } else { usedLabels . add ( ( Label ) value ) ; } }
public void test_ConstructorIIIII ( ) { Date d1 = new Date ( NUM_ , NUM_ , NUM_ , NUM_ , NUM_ ) ; Date d2 = new Date ( NUM_ + d1 . getTimezoneOffset ( ) . NUM_ . NUM_ + NUM_ . NUM_ . NUM_ + NUM_ . NUM_ ) ; assertTrue ( STR_ , d1 . equals ( d2 ) ) ; }
protected void pushBidirectionalVipRoutes ( IOFSwitch sw , OFPacketIn pi , FloodlightContext cntx , IPClient client , LBMember member ) { IDevice srcDevice = null ; IDevice dstDevice = null ; Collection < ? extends IDevice > allDevices = deviceManager . getAllDevices ( ) ; for ( IDevice d : allDevices ) { for ( int j = NUM_ ; j < d . getIPv4Addresses ( ) . length ; j ++ ) { if ( srcDevice == null && client . ipAddress == d . getIPv4Addresses ( ) [ j ] ) srcDevice = d ; if ( dstDevice == null && member . address == d . getIPv4Addresses ( ) [ j ] ) { dstDevice = d ; member . macString = dstDevice . getMACAddressString ( ) ; } if ( srcDevice != null && dstDevice != null ) break ; } } if ( srcDevice == null || dstDevice == null ) return ; Long srcIsland = topology . getL2DomainId ( sw . getId ( ) ) ; if ( srcIsland == null ) { log . debug ( STR_ , sw . getStringId ( ) , pi . getInPort ( ) ) ; return ; } boolean on_same_island = BOOL_ ; boolean on_same_if = BOOL_ ; for ( SwitchPort dstDap : dstDevice . getAttachmentPoints ( ) ) { long dstSwDpid = dstDap . getSwitchDPID ( ) ; Long dstIsland = topology . getL2DomainId ( dstSwDpid ) ; if ( ( dstIsland != null ) && dstIsland . equals ( srcIsland ) ) { on_same_island = BOOL_ ; if ( ( sw . getId ( ) == dstSwDpid ) && ( pi . getInPort ( ) == dstDap . getPort ( ) ) ) { on_same_if = BOOL_ ; } break ; } } if ( ! on_same_island ) { if ( log . isTraceEnabled ( ) ) { log . trace ( STR_ + STR_ , dstDevice ) ; } return ; } if ( on_same_if ) { if ( log . isTraceEnabled ( ) ) { log . trace ( STR_ + STR_ , sw . toString ( ) , pi . getInPort ( ) ) ; } return ; } SwitchPort [ ] srcDaps = srcDevice . getAttachmentPoints ( ) ; Arrays . sort ( srcDaps , clusterIdComparator ) ; SwitchPort [ ] dstDaps = dstDevice . getAttachmentPoints ( ) ; Arrays . sort ( dstDaps , clusterIdComparator ) ; int iSrcDaps = NUM_ , iDstDaps = NUM_ ; while ( ( iSrcDaps < srcDaps . length ) && ( iDstDaps < dstDaps . length ) ) { SwitchPort srcDap = srcDaps [ iSrcDaps ] ; SwitchPort dstDap = dstDaps [ iDstDaps ] ; Long srcCluster = topology . getL2DomainId ( srcDap . getSwitchDPID ( ) ) ; Long dstCluster = topology . getL2DomainId ( dstDap . getSwitchDPID ( ) ) ; int srcVsDest = srcCluster . compareTo ( dstCluster ) ; if ( srcVsDest == NUM_ ) { if ( ! srcDap . equals ( dstDap ) && ( srcCluster != null ) && ( dstCluster != null ) ) { Route routeIn = routingEngine . getRoute ( srcDap . getSwitchDPID ( ) , ( short ) srcDap . getPort ( ) , dstDap . getSwitchDPID ( ) , ( short ) dstDap . getPort ( ) , NUM_ ) ; Route routeOut = routingEngine . getRoute ( dstDap . getSwitchDPID ( ) , ( short ) dstDap . getPort ( ) , srcDap . getSwitchDPID ( ) , ( short ) srcDap . getPort ( ) , NUM_ ) ; if ( routeIn != null ) { pushStaticVipRoute ( BOOL_ , routeIn , client , member , sw . getId ( ) ) ; } if ( routeOut != null ) { pushStaticVipRoute ( BOOL_ , routeOut , client , member , sw . getId ( ) ) ; } } iSrcDaps ++ ; iDstDaps ++ ; } else if ( srcVsDest < NUM_ ) { iSrcDaps ++ ; } else { iDstDaps ++ ; } } return ; }
public static String parseIdFromSameDocumentURI ( String uri ) { if ( uri . length ( ) == NUM_ ) { return null ; } String id = uri . substring ( NUM_ ) ; if ( id != null && id . startsWith ( STR_ ) ) { int i1 = id . indexOf ( STR_ ) ; int i2 = id . indexOf ( STR_ , i1 + NUM_ ) ; id = id . substring ( i1 + NUM_ , i2 ) ; } return id ; }
public void markUsed ( long pos , int length ) { int start = getBlock ( pos ) ; int blocks = getBlockCount ( length ) ; set . set ( start , start + blocks ) ; }
public CholMatrix ( Matrix Arg ) { final double [ ] [ ] A = Arg . toDoubleArray ( ) ; n = ( int ) Arg . getRowCount ( ) ; L = new double [ n ] [ n ] ; isspd = ( Arg . getColumnCount ( ) == n ) ; double [ ] Lrowj = null ; double [ ] Lrowk = null ; double [ ] Aj = null ; for ( int j = NUM_ ; j < n ; j ++ ) { Lrowj = L [ j ] ; Aj = A [ j ] ; double d = NUM_ ; for ( int k = NUM_ ; k < j ; k ++ ) { Lrowk = L [ k ] ; double s = NUM_ ; for ( int i = NUM_ ; i < k ; i ++ ) { s += Lrowk [ i ] . Lrowj [ i ] ; } Lrowj [ k ] = s = ( Aj [ k ] - s ) / Lrowk [ k ] ; d = d + s . s ; isspd = isspd & ( A [ k ] [ j ] == Aj [ k ] ) ; } d = Aj [ j ] - d ; isspd = isspd & ( d > NUM_ ) ; Lrowj [ j ] = Math . sqrt ( Math . max ( d , NUM_ ) ) ; for ( int k = j + NUM_ ; k < n ; k ++ ) { Lrowj [ k ] = NUM_ ; } } }
public static String readStringNZ ( Memory mem , int address , int n ) { address &= Memory . addressMask ; if ( address + n > MemoryMap . END_RAM ) { n = MemoryMap . END_RAM - address + NUM_ ; if ( n < NUM_ ) { n = NUM_ ; } } byte [ ] bytes = new byte [ Math . min ( n , NUM_ ) ] ; int length = NUM_ ; IMemoryReader memoryReader = MemoryReader . getMemoryReader ( address , n , NUM_ ) ; for ( ; n > NUM_ ; n -- ) { int b = memoryReader . readNext ( ) ; if ( b == NUM_ ) { break ; } if ( length >= bytes . length ) { byte [ ] newBytes = new byte [ bytes . length + NUM_ ] ; System . arraycopy ( bytes , NUM_ , newBytes , NUM_ , bytes . length ) ; bytes = newBytes ; } bytes [ length ] = ( byte ) b ; length ++ ; } return new String ( bytes , NUM_ , length , Constants . charset ) ; }
static boolean shiftRight ( int [ ] result , int resultLen , int [ ] source , int intCount , int count ) { int i ; boolean allZero = BOOL_ ; for ( i = NUM_ ; i < intCount ; i ++ ) allZero &= source [ i ] == NUM_ ; if ( count == NUM_ ) { System . arraycopy ( source , intCount , result , NUM_ , resultLen ) ; i = resultLen ; } else { int leftShiftCount = NUM_ - count ; allZero &= ( source [ i ] << leftShiftCount ) == NUM_ ; for ( i = NUM_ ; i < resultLen - NUM_ ; i ++ ) { result [ i ] = ( source [ i + intCount ] > > > count ) | ( source [ i + intCount + NUM_ ] << leftShiftCount ) ; } result [ i ] = ( source [ i + intCount ] > > > count ) ; i ++ ; } return allZero ; }
@ Override public void agg ( Object newVal ) { valueSet . add ( newVal instanceof Long ? ( Long ) newVal : Long . valueOf ( newVal . toString ( ) ) ) ; firstTime = BOOL_ ; }
private boolean removeLegionMember ( String charName , boolean kick , String playerName ) { LegionMemberEx legionMember = getLegionMemberEx ( charName ) ; if ( legionMember == null ) { log . error ( STR_ + charName ) ; return BOOL_ ; } deleteLegionMemberFromDB ( legionMember ) ; Player player = world . findPlayer ( charName ) ; if ( player != null ) { PacketSendUtility . broadcastPacket ( player , new SM_LEGION_UPDATE_TITLE ( player . getObjectId ( ) , NUM_ , STR_ , NUM_ ) , BOOL_ ) ; } if ( kick ) { PacketSendUtility . broadcastPacketToLegion ( legionMember . getLegion ( ) , new SM_LEGION_LEAVE_MEMBER ( NUM_ , legionMember . getObjectId ( ) , playerName , legionMember . getName ( ) ) ) ; } else { PacketSendUtility . broadcastPacketToLegion ( legionMember . getLegion ( ) , new SM_LEGION_LEAVE_MEMBER ( NUM_ , legionMember . getObjectId ( ) , charName ) ) ; } return BOOL_ ; }
synchronized void printBuffer ( ) throws IOException { int len = sb . length ( ) ; if ( len > NUM_ ) { char [ ] chars = new char [ len ] ; sb . getChars ( NUM_ , len , chars , NUM_ ) ; sb . setLength ( NUM_ ) ; super . write ( chars , NUM_ , chars . length ) ; } }
Calendar toCalendar ( String value , String pattern , Locale locale ) { Calendar calendar = null ; try { DateFormat format = ( locale == null ) ? new SimpleDateFormat ( pattern ) : new SimpleDateFormat ( pattern , locale ) ; format . setLenient ( BOOL_ ) ; format . parse ( value ) ; calendar = format . getCalendar ( ) ; } catch ( Exception e ) { fail ( STR_ + value + STR_ + pattern + STR_ + e . toString ( ) ) ; } return calendar ; }
public boolean containsBafBody ( ) { Iterator < SootMethod > methodIt = methodIterator ( ) ; while ( methodIt . hasNext ( ) ) { SootMethod m = methodIt . next ( ) ; if ( m . hasActiveBody ( ) && m . getActiveBody ( ) instanceof soot . baf . BafBody ) { return BOOL_ ; } } return BOOL_ ; }
public static String retainAllChars ( String str , String retainChars ) { int pos = indexOfChars ( str , retainChars ) ; if ( pos == - NUM_ ) { return STR_ ; } StringBuilder buf = new StringBuilder ( ) ; do { buf . append ( str . charAt ( pos ) ) ; pos = indexOfChars ( str , retainChars , pos + NUM_ ) ; } while ( pos != - NUM_ ) ; return buf . toString ( ) ; }
public synchronized void deleteLeastUsedConnection ( ) { final HttpConnection connection = ( HttpConnection ) freeConnections . removeFirst ( ) ; if ( connection != null ) { deleteConnection ( connection ) ; } else if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( STR_ ) ; } }
private int binarySearch ( T x , int from , int to ) { while ( from <= to ) { int m = ( from + to ) > > > NUM_ ; if ( comp . compare ( x , data [ m ] ) >= NUM_ ) { from = m + NUM_ ; } else { to = m - NUM_ ; } } return from ; }
private TransitSchedule cleanUpSchedule ( TransitSchedule newTransitSchedule ) { newTransitSchedule = TransitScheduleCleaner . removeRoutesWithoutDepartures ( newTransitSchedule ) ; newTransitSchedule = TransitScheduleCleaner . removeEmptyLines ( newTransitSchedule ) ; newTransitSchedule = TransitScheduleCleaner . removeStopsNotUsed ( newTransitSchedule ) ; return newTransitSchedule ; }
protected static boolean match ( Object ref , Object test ) { if ( ref == null ) { return BOOL_ ; } if ( ref == test ) { return BOOL_ ; } if ( ref instanceof LabelList && test instanceof LabelList ) { final LabelList lref = ( LabelList ) ref ; final LabelList ltest = ( LabelList ) test ; final int s1 = lref . size ( ) , s2 = ltest . size ( ) ; if ( s1 == NUM_ || s2 == NUM_ ) { return BOOL_ ; } for ( int i = NUM_ ; i < s1 ; i ++ ) { String l1 = lref . get ( i ) ; if ( l1 == null ) { continue ; } for ( int j = NUM_ ; j < s2 ; j ++ ) { if ( l1 . equals ( ltest . get ( j ) ) ) { return BOOL_ ; } } } } return ref . equals ( test ) ; }
private boolean step1 ( ) { if ( CT == null ) return BOOL_ ; if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = replaceSuffix ( CT , STR_ , STR_ ) ; return BOOL_ ; } if ( CT . length ( ) >= NUM_ ) { if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { replaceSuffix ( CT , STR_ , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = replaceSuffix ( CT , STR_ , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R1 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } } if ( CT . length ( ) >= NUM_ ) { if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = replaceSuffix ( CT , STR_ , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = replaceSuffix ( CT , STR_ , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = replaceSuffix ( CT , STR_ , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } } if ( CT . length ( ) >= NUM_ ) { if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( RV , STR_ ) && suffixPreceded ( CT , STR_ , STR_ ) ) { CT = replaceSuffix ( CT , STR_ , STR_ ) ; return BOOL_ ; } } if ( CT . length ( ) >= NUM_ ) { if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( R2 , STR_ ) ) { CT = removeSuffix ( CT , STR_ ) ; return BOOL_ ; } if ( suffix ( CT , STR_ ) && suffix ( RV , STR_ ) && suffixPreceded ( CT , STR_ , STR_ ) ) { CT = replaceSuffix ( CT , STR_ , STR_ ) ; return BOOL_ ; } } return BOOL_ ; }
public final CharSequence yytext ( ) { return zzBuffer . subSequence ( zzStartRead , zzMarkedPos ) ; }
public String patch_toText ( List < Patch > patches ) { StringBuilder text = new StringBuilder ( ) ; for ( Patch aPatch : patches ) { text . append ( aPatch ) ; } return text . toString ( ) ; }
void close ( int contextPrec , int ownPrec ) throws IOException { if ( ownPrec < contextPrec ) out . write ( STR_ ) ; }
private void validateSortSize ( ) { String sortSizeStr = carbonProperties . getProperty ( CarbonCommonConstants . SORT_SIZE , CarbonCommonConstants . SORT_SIZE_DEFAULT_VAL ) ; try { int sortSize = Integer . parseInt ( sortSizeStr ) ; if ( sortSize < CarbonCommonConstants . SORT_SIZE_MIN_VAL ) { LOGGER . info ( STR_ + sortSizeStr + STR_ + CarbonCommonConstants . SORT_SIZE_DEFAULT_VAL ) ; carbonProperties . setProperty ( CarbonCommonConstants . SORT_SIZE , CarbonCommonConstants . SORT_SIZE_DEFAULT_VAL ) ; } } catch ( NumberFormatException e ) { LOGGER . info ( STR_ + sortSizeStr + STR_ + CarbonCommonConstants . SORT_SIZE_DEFAULT_VAL ) ; carbonProperties . setProperty ( CarbonCommonConstants . SORT_SIZE , CarbonCommonConstants . SORT_SIZE_DEFAULT_VAL ) ; } }
public void finishPainting ( boolean useCache ) { DataBufferInt dataBuffer = new DataBufferInt ( w0 . h0 ) ; int transparency = nativeFinishPainting ( SunWritableRaster . stealData ( dataBuffer , NUM_ ) , w0 , h0 ) ; SunWritableRaster . markDirty ( dataBuffer ) ; int [ ] bands = BAND_OFFSETS [ transparency - NUM_ ] ; WritableRaster raster = Raster . createPackedRaster ( dataBuffer , w0 , h0 , w0 , bands , null ) ; ColorModel cm = COLOR_MODELS [ transparency - NUM_ ] ; Image img = new BufferedImage ( cm , raster , BOOL_ , null ) ; if ( useCache ) { cache . setImage ( getClass ( ) , null , w0 , h0 , cacheArgs , img ) ; } graphics . drawImage ( img , x0 , y0 , null ) ; }
public boolean deletePanel ( ) { if ( ! super . deletePanel ( ) ) { return BOOL_ ; } turnoutList . clear ( ) ; trackList . clear ( ) ; pointList . clear ( ) ; xingList . clear ( ) ; slipList . clear ( ) ; turntableList . clear ( ) ; return BOOL_ ; }
@ Override default CompletableFuture < OptionalDouble > averageDouble ( final ToDoubleFunction < ? super T > fn ) { return CompletableFuture . supplyAsync ( null , getExec ( ) ) ; }
public String next ( ) { return next ( ANY_PATTERN ) ; }
public XercesHTMLDocumentBuilderFactory ( DocumentBuilderSetting [ ] settings ) throws DOMTestIncompatibleException { super ( settings ) ; try { ClassLoader classLoader = ClassLoader . getSystemClassLoader ( ) ; Class htmlBuilderClass = classLoader . loadClass ( STR_ ) ; htmlBuilderConstructor = htmlBuilderClass . getConstructor ( NO_CLASSES ) ; getHTMLDocumentMethod = htmlBuilderClass . getMethod ( STR_ , NO_CLASSES ) ; Class htmlDOMImpl = classLoader . loadClass ( STR_ ) ; Method method = htmlDOMImpl . getMethod ( STR_ , NO_CLASSES ) ; domImpl = ( DOMImplementation ) method . invoke ( null , NO_OBJECTS ) ; Class saxFactoryClass = classLoader . loadClass ( STR_ ) ; factory = ( SAXParserFactory ) saxFactoryClass . newInstance ( ) ; } catch ( InvocationTargetException ex ) { throw new DOMTestIncompatibleException ( ex . getTargetException ( ) , null ) ; } catch ( Exception ex ) { throw new DOMTestIncompatibleException ( ex , null ) ; } if ( settings != null ) { for ( int i = NUM_ ; i < settings . length ; i ++ ) { } } try { factory . newSAXParser ( ) ; } catch ( ParserConfigurationException ex ) { throw new DOMTestIncompatibleException ( ex , null ) ; } catch ( SAXException ex ) { throw new DOMTestIncompatibleException ( ex , null ) ; } }
@ Override public final String toString ( ) { StringBuilder cab = new StringBuilder ( NUM_ + getHopCount ( ) . NUM_ ) ; cab . append ( STR_ ) ; if ( this . localAddress != null ) { cab . append ( this . localAddress ) ; cab . append ( STR_ ) ; } cab . append ( STR_ ) ; if ( this . tunnelled == TunnelType . TUNNELLED ) cab . append ( STR_ ) ; if ( this . layered == LayerType . LAYERED ) cab . append ( STR_ ) ; if ( this . secure ) cab . append ( STR_ ) ; cab . append ( STR_ ) ; if ( this . proxyChain != null ) { for ( HttpHost aProxyChain : this . proxyChain ) { cab . append ( aProxyChain ) ; cab . append ( STR_ ) ; } } cab . append ( this . targetHost ) ; cab . append ( STR_ ) ; return cab . toString ( ) ; }
private void push ( final int type ) { if ( outputStack == null ) { outputStack = new int [ NUM_ ] ; } int n = outputStack . length ; if ( outputStackTop >= n ) { int [ ] t = new int [ Math . max ( outputStackTop + NUM_ , NUM_ . n ) ] ; System . arraycopy ( outputStack , NUM_ , t , NUM_ , n ) ; outputStack = t ; } outputStack [ outputStackTop ++ ] = type ; int top = owner . inputStackTop + outputStackTop ; if ( top > owner . outputStackMax ) { owner . outputStackMax = top ; } }
public Macro ( File file ) throws EOFException , FileNotFoundException , IOException { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder db = null ; Document doc = null ; try { db = dbf . newDocumentBuilder ( ) ; InputSource is = new InputSource ( new UnicodeReader ( new FileInputStream ( file ) , FILE_ENCODING ) ) ; is . setEncoding ( FILE_ENCODING ) ; doc = db . parse ( is ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; String desc = e . getMessage ( ) ; if ( desc == null ) { desc = e . toString ( ) ; } throw new IOException ( STR_ + desc ) ; } macroRecords = new ArrayList ( ) ; boolean parsedOK = initializeFromXMLFile ( doc . getDocumentElement ( ) ) ; if ( parsedOK == BOOL_ ) { name = null ; macroRecords . clear ( ) ; macroRecords = null ; throw new IOException ( STR_ ) ; } }
public static void deleteESInput ( ) { String esPIRIndex = SystemConfiguration . getProperty ( DistributedTestDriver . ES_INPUT_NODES_PROPERTY ) + STR_ + SystemConfiguration . getProperty ( DistributedTestDriver . ES_INPUT_PORT_PROPERTY ) + STR_ + SystemConfiguration . getProperty ( DistributedTestDriver . ES_INPUT_INDEX_PROPERTY ) ; logger . info ( STR_ + esPIRIndex ) ; ProcessBuilder pDeletePIR = new ProcessBuilder ( STR_ , STR_ , esPIRIndex ) ; try { TestUtils . executeCommand ( pDeletePIR ) ; logger . info ( STR_ ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
private boolean add ( int part ) { if ( ! parts . contains ( part ) ) { parts . add ( part ) ; return BOOL_ ; } return BOOL_ ; }
private void terminateAndWaitFsyncService ( ) throws Exception { if ( fsyncService . isTerminated ( ) ) return ; fsyncService . shutdown ( ) ; fsyncService . awaitTermination ( NUM_ , TimeUnit . SECONDS ) ; Exception fsyncExceptionCopy = fsyncException ; if ( fsyncExceptionCopy != null ) throw fsyncExceptionCopy ; }
private Location findFarthestLocation ( Location location , Direction direction ) { Location farthest ; do { farthest = location ; location = farthest . offset ( direction ) ; } while ( gridOperator . isValidLocation ( location ) && gameGrid . get ( location ) == null ) ; return farthest ; }
public static int computeMinImageSampleSize ( ImageSize srcSize ) { int srcWidth = srcSize . getWidth ( ) ; int srcHeight = srcSize . getHeight ( ) ; int targetWidth = maxBitmapSize . getWidth ( ) ; int targetHeight = maxBitmapSize . getHeight ( ) ; int widthScale = ( int ) Math . ceil ( ( float ) srcWidth / targetWidth ) ; int heightScale = ( int ) Math . ceil ( ( float ) srcHeight / targetHeight ) ; return Math . max ( widthScale , heightScale ) ; }
private JSplitPane createMainSplitPane ( ) { final JSplitPane mainSplitPane = new JSplitPane ( ) ; mainSplitPane . setOneTouchExpandable ( BOOL_ ) ; mainSplitPane . setDividerLocation ( NUM_ ) ; mainSplitPane . setResizeWeight ( NUM_ ) ; mainSplitPane . setOrientation ( JSplitPane . HORIZONTAL_SPLIT ) ; m_componentPanel . setBackground ( Color . WHITE ) ; mainSplitPane . setLeftComponent ( createProjectTreePanel ( ) ) ; mainSplitPane . setRightComponent ( m_componentPanel ) ; mainSplitPane . setBorder ( new LineBorder ( Color . GRAY ) ) ; return mainSplitPane ; }
private DigicoreChain cleanChain ( DigicoreChain chain ) { return chain ; }
private boolean checkSetup ( ) { this . txmgr = TransactionManagerImp . getTransactionManager ( ) ; if ( this . txmgr == null ) { try { Hashtable < String , String > env = new Hashtable < String , String > ( ) ; env . put ( Context . INITIAL_CONTEXT_FACTORY , this . initialContextFactory ) ; env . put ( Context . PROVIDER_URL , this . providerUrl ) ; Context ctx = new InitialContext ( env ) ; this . txmgrServer = ( UserTransactionServer ) PortableRemoteObject . narrow ( ctx . lookup ( this . userTransactionServerLookupName ) , UserTransactionServer . class ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new RuntimeException ( getNotFoundMessage ( ) ) ; } if ( this . txmgrServer == null ) throw new RuntimeException ( getNotFoundMessage ( ) ) ; } return this . txmgr != null ; }
public static final boolean givesCheck ( Position pos , Move m ) { boolean wtm = pos . whiteMove ; int oKingSq = pos . getKingSq ( ! wtm ) ; int oKing = wtm ? Piece . BKING : Piece . WKING ; int p = Piece . makeWhite ( m . promoteTo == Piece . EMPTY ? pos . getPiece ( m . from ) : m . promoteTo ) ; int d1 = BitBoard . getDirection ( m . to , oKingSq ) ; switch ( d1 ) { case NUM_ : case - NUM_ : case NUM_ : case - NUM_ : if ( ( p == Piece . WQUEEN ) || ( p == Piece . WROOK ) ) if ( ( d1 != NUM_ ) && ( MoveGen . nextPiece ( pos , m . to , d1 ) == oKing ) ) return BOOL_ ; break ; case NUM_ : case NUM_ : case - NUM_ : case - NUM_ : if ( ( p == Piece . WQUEEN ) || ( p == Piece . WBISHOP ) ) { if ( ( d1 != NUM_ ) && ( MoveGen . nextPiece ( pos , m . to , d1 ) == oKing ) ) return BOOL_ ; } else if ( p == Piece . WPAWN ) { if ( ( ( d1 > NUM_ ) == wtm ) && ( pos . getPiece ( m . to + d1 ) == oKing ) ) return BOOL_ ; } break ; default : if ( d1 != NUM_ ) { if ( p == Piece . WKNIGHT ) return BOOL_ ; } } int d2 = BitBoard . getDirection ( m . from , oKingSq ) ; if ( ( d2 != NUM_ ) && ( d2 != d1 ) && ( MoveGen . nextPiece ( pos , m . from , d2 ) == oKing ) ) { int p2 = MoveGen . nextPieceSafe ( pos , m . from , - d2 ) ; switch ( d2 ) { case NUM_ : case - NUM_ : case NUM_ : case - NUM_ : if ( ( p2 == ( wtm ? Piece . WQUEEN : Piece . BQUEEN ) ) || ( p2 == ( wtm ? Piece . WROOK : Piece . BROOK ) ) ) return BOOL_ ; break ; case NUM_ : case NUM_ : case - NUM_ : case - NUM_ : if ( ( p2 == ( wtm ? Piece . WQUEEN : Piece . BQUEEN ) ) || ( p2 == ( wtm ? Piece . WBISHOP : Piece . BBISHOP ) ) ) return BOOL_ ; break ; } } if ( ( m . promoteTo != Piece . EMPTY ) && ( d1 != NUM_ ) && ( d1 == d2 ) ) { switch ( d1 ) { case NUM_ : case - NUM_ : case NUM_ : case - NUM_ : if ( ( p == Piece . WQUEEN ) || ( p == Piece . WROOK ) ) if ( ( d1 != NUM_ ) && ( MoveGen . nextPiece ( pos , m . from , d1 ) == oKing ) ) return BOOL_ ; break ; case NUM_ : case NUM_ : case - NUM_ : case - NUM_ : if ( ( p == Piece . WQUEEN ) || ( p == Piece . WBISHOP ) ) { if ( ( d1 != NUM_ ) && ( MoveGen . nextPiece ( pos , m . from , d1 ) == oKing ) ) return BOOL_ ; } break ; } } if ( p == Piece . WKING ) { if ( m . to - m . from == NUM_ ) { if ( MoveGen . nextPieceSafe ( pos , m . from , - NUM_ ) == oKing ) return BOOL_ ; if ( MoveGen . nextPieceSafe ( pos , m . from + NUM_ , wtm ? NUM_ : - NUM_ ) == oKing ) return BOOL_ ; } else if ( m . to - m . from == - NUM_ ) { if ( MoveGen . nextPieceSafe ( pos , m . from , NUM_ ) == oKing ) return BOOL_ ; if ( MoveGen . nextPieceSafe ( pos , m . from - NUM_ , wtm ? NUM_ : - NUM_ ) == oKing ) return BOOL_ ; } } else if ( p == Piece . WPAWN ) { if ( pos . getPiece ( m . to ) == Piece . EMPTY ) { int dx = Position . getX ( m . to ) - Position . getX ( m . from ) ; if ( dx != NUM_ ) { int epSq = m . from + dx ; int d3 = BitBoard . getDirection ( epSq , oKingSq ) ; switch ( d3 ) { case NUM_ : case NUM_ : case - NUM_ : case - NUM_ : if ( MoveGen . nextPiece ( pos , epSq , d3 ) == oKing ) { int p2 = MoveGen . nextPieceSafe ( pos , epSq , - d3 ) ; if ( ( p2 == ( wtm ? Piece . WQUEEN : Piece . BQUEEN ) ) || ( p2 == ( wtm ? Piece . WBISHOP : Piece . BBISHOP ) ) ) return BOOL_ ; } break ; case NUM_ : if ( MoveGen . nextPiece ( pos , Math . max ( epSq , m . from ) , d3 ) == oKing ) { int p2 = MoveGen . nextPieceSafe ( pos , Math . min ( epSq , m . from ) , - d3 ) ; if ( ( p2 == ( wtm ? Piece . WQUEEN : Piece . BQUEEN ) ) || ( p2 == ( wtm ? Piece . WROOK : Piece . BROOK ) ) ) return BOOL_ ; } break ; case - NUM_ : if ( MoveGen . nextPiece ( pos , Math . min ( epSq , m . from ) , d3 ) == oKing ) { int p2 = MoveGen . nextPieceSafe ( pos , Math . max ( epSq , m . from ) , - d3 ) ; if ( ( p2 == ( wtm ? Piece . WQUEEN : Piece . BQUEEN ) ) || ( p2 == ( wtm ? Piece . WROOK : Piece . BROOK ) ) ) return BOOL_ ; } break ; } } } } return BOOL_ ; }
public static FSDirectory newFSDirectory ( Class < ? extends FSDirectory > clazz , Path path ) throws ReflectiveOperationException { return newFSDirectory ( clazz , path , FSLockFactory . getDefault ( ) ) ; }
private static Element addElement ( Document doc , Node parent , String tagName , String attr1 , String val1 , String attr2 , String val2 ) { Element elem = doc . createElement ( tagName ) ; if ( attr1 != null ) elem . setAttribute ( attr1 , val1 ) ; if ( attr2 != null ) elem . setAttribute ( attr2 , val2 ) ; parent . appendChild ( elem ) ; return elem ; }
public static String stream2String ( InputStream is , int maxLength ) throws IOException { byte [ ] buffer = new byte [ NUM_ ] ; StringWriter sw = new StringWriter ( ) ; int totalRead = NUM_ ; int read = NUM_ ; do { sw . write ( new String ( buffer , NUM_ , read ) ) ; totalRead += read ; read = is . read ( buffer , NUM_ , buffer . length ) ; } while ( ( ( - NUM_ == maxLength ) || ( totalRead < maxLength ) ) && ( read != - NUM_ ) ) ; return sw . toString ( ) ; }
private static Couple < String > splitNameOfRemoteBranch ( String branchName ) { int firstSlash = branchName . indexOf ( STR_ ) ; String remoteName = firstSlash > - NUM_ ? branchName . substring ( NUM_ , firstSlash ) : branchName ; String remoteBranchName = branchName . substring ( firstSlash + NUM_ ) ; return Couple . of ( remoteName , remoteBranchName ) ; }
private static void decodeAnsiX12Segment ( BitSource bits , StringBuilder result ) throws FormatException { int [ ] cValues = new int [ NUM_ ] ; do { if ( bits . available ( ) == NUM_ ) { return ; } int firstByte = bits . readBits ( NUM_ ) ; if ( firstByte == NUM_ ) { return ; } parseTwoBytes ( firstByte , bits . readBits ( NUM_ ) , cValues ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { int cValue = cValues [ i ] ; if ( cValue == NUM_ ) { result . append ( STR_ ) ; } else if ( cValue == NUM_ ) { result . append ( STR_ ) ; } else if ( cValue == NUM_ ) { result . append ( STR_ ) ; } else if ( cValue == NUM_ ) { result . append ( STR_ ) ; } else if ( cValue < NUM_ ) { result . append ( ( char ) ( cValue + NUM_ ) ) ; } else if ( cValue < NUM_ ) { result . append ( ( char ) ( cValue + NUM_ ) ) ; } else { throw FormatException . getFormatInstance ( ) ; } } } while ( bits . available ( ) > NUM_ ) ; }
public static OutputStream encrypt ( OutputStream unencryptedOutputStream , char [ ] password ) throws EncryptionException , IOException { OutputStream encryptedOutputStream = null ; PBEKeySpec pbeKeySpec = new PBEKeySpec ( password ) ; PBEParameterSpec pbeParameterSpec = new PBEParameterSpec ( SALT , ITERATION_COUNT ) ; try { SecretKeyFactory secretKeyFactory = SecretKeyFactory . getInstance ( ENCRYPTION_ALGORITHM , CRYPTOPROVIDER ) ; SecretKey pbeKey = secretKeyFactory . generateSecret ( pbeKeySpec ) ; Cipher cipher = Cipher . getInstance ( ENCRYPTION_ALGORITHM , CRYPTOPROVIDER ) ; cipher . init ( Cipher . ENCRYPT_MODE , pbeKey , pbeParameterSpec ) ; encryptedOutputStream = new CipherOutputStream ( unencryptedOutputStream , cipher ) ; } catch ( GeneralSecurityException e ) { throw new EncryptionException ( STR_ , e ) ; } return encryptedOutputStream ; }
public static String rightPad ( String original , int length , char padChar ) { if ( original . length ( ) >= length ) { return original ; } return original + stringOfChar ( padChar , length - original . length ( ) ) ; }
private boolean checkSelectForSwipe ( int action , MotionEvent motionEvent , int pointerIndex ) { if ( mSelected != null || action != MotionEvent . ACTION_MOVE || mActionState == ACTION_STATE_DRAG || ! mCallback . isItemViewSwipeEnabled ( ) ) { return BOOL_ ; } if ( mRecyclerView . getScrollState ( ) == RecyclerView . SCROLL_STATE_DRAGGING ) { return BOOL_ ; } final ViewHolder vh = findSwipedView ( motionEvent ) ; if ( vh == null ) { return BOOL_ ; } final int movementFlags = mCallback . getAbsoluteMovementFlags ( mRecyclerView , vh ) ; final int swipeFlags = ( movementFlags & ACTION_MODE_SWIPE_MASK ) > > ( DIRECTION_FLAG_COUNT . ACTION_STATE_SWIPE ) ; if ( swipeFlags == NUM_ ) { return BOOL_ ; } final float x = MotionEventCompat . getX ( motionEvent , pointerIndex ) ; final float y = MotionEventCompat . getY ( motionEvent , pointerIndex ) ; final float dx = x - mInitialTouchX ; final float dy = y - mInitialTouchY ; final float absDx = Math . abs ( dx ) ; final float absDy = Math . abs ( dy ) ; if ( absDx < mSlop && absDy < mSlop ) { return BOOL_ ; } if ( absDx > absDy ) { if ( dx < NUM_ && ( swipeFlags & LEFT ) == NUM_ ) { return BOOL_ ; } if ( dx > NUM_ && ( swipeFlags & RIGHT ) == NUM_ ) { return BOOL_ ; } } else { if ( dy < NUM_ && ( swipeFlags & UP ) == NUM_ ) { return BOOL_ ; } if ( dy > NUM_ && ( swipeFlags & DOWN ) == NUM_ ) { return BOOL_ ; } } mDx = mDy = NUM_ ; mActivePointerId = MotionEventCompat . getPointerId ( motionEvent , NUM_ ) ; select ( vh , ACTION_STATE_SWIPE ) ; if ( mPreOpened != null && mPreOpened != vh && vh != null ) { closeOpenedPreItem ( ) ; } return BOOL_ ; }
protected void reloadSwipeStateInView ( View frontView , int position ) { if ( ! opened . get ( position ) ) { ViewCompat . setTranslationX ( frontView , NUM_ ) ; } else { if ( openedRight . get ( position ) ) { ViewCompat . setTranslationX ( frontView , swipeListView . getWidth ( ) ) ; } else { ViewCompat . setTranslationX ( frontView , - swipeListView . getWidth ( ) ) ; } } }
public final void pushPair ( int v1 , int v2 ) { if ( null == m_map ) { m_map = new int [ m_blocksize ] ; m_mapSize = m_blocksize ; } else { if ( ( m_firstFree + NUM_ ) >= m_mapSize ) { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , NUM_ , newMap , NUM_ , m_firstFree ) ; m_map = newMap ; } } m_map [ m_firstFree ] = v1 ; m_map [ m_firstFree + NUM_ ] = v2 ; m_firstFree += NUM_ ; }
void reset ( ) { System . arraycopy ( iv , NUM_ , k , NUM_ , blockSize ) ; }
public Matrix3 multiplyByVerticalFlip ( ) { double [ ] m = this . m ; m [ NUM_ ] += m [ NUM_ ] ; m [ NUM_ ] += m [ NUM_ ] ; m [ NUM_ ] += m [ NUM_ ] ; m [ NUM_ ] = - m [ NUM_ ] ; m [ NUM_ ] = - m [ NUM_ ] ; m [ NUM_ ] = - m [ NUM_ ] ; return this ; }
public void shutdown ( ) throws DataSourceException { if ( createdSessionFactory ) { if ( sessionFactory != null && ! sessionFactory . isClosed ( ) ) { try { sessionFactory . close ( ) ; } finally { sessionFactory = null ; } } } }
private String stringifyIP ( byte [ ] ip ) { String temp = STR_ ; for ( int i = NUM_ ; i < ip . length / NUM_ ; i ++ ) { temp += Integer . toString ( ip [ i ] & x00FF ) + STR_ ; } temp = temp . substring ( NUM_ , temp . length ( ) - NUM_ ) ; temp += STR_ ; for ( int i = ip . length / NUM_ ; i < ip . length ; i ++ ) { temp += Integer . toString ( ip [ i ] & x00FF ) + STR_ ; } temp = temp . substring ( NUM_ , temp . length ( ) - NUM_ ) ; return temp ; }
public COpenFunctionAction ( final CGraphWindow parent , final IViewContainer container , final INaviFunction function ) { super ( String . format ( STR_ , function . getName ( ) ) ) ; Preconditions . checkNotNull ( parent , STR_ ) ; Preconditions . checkNotNull ( container , STR_ ) ; m_parent = parent ; m_container = container ; m_function = function ; }
public static byte [ ] hexStringToBytes ( String hexString ) { if ( hexString == null || hexString . equals ( STR_ ) ) { return null ; } hexString = hexString . toUpperCase ( ) ; int length = hexString . length ( ) / NUM_ ; char [ ] hexChars = hexString . toCharArray ( ) ; byte [ ] d = new byte [ length ] ; for ( int i = NUM_ ; i < length ; i ++ ) { int pos = i . NUM_ ; d [ i ] = ( byte ) ( charToByte ( hexChars [ pos ] ) << NUM_ | charToByte ( hexChars [ pos + NUM_ ] ) ) ; } return d ; }
public void writeString ( final String s ) { final byte [ ] bytes = s . getBytes ( ) ; final int len = bytes . length ; writeInt ( len ) ; System . arraycopy ( bytes , NUM_ , buffer , offset , len ) ; offset += len ; pad ( ) ; }
private static PermissionCollection createAllPermissions ( ) { Permissions permissions = new Permissions ( ) ; permissions . add ( new AllPermission ( ) ) ; return permissions ; }
private void mergeNetworks ( Network tzone , Network sZone ) { List < String > addedEndPoints = new ArrayList < String > ( sZone . retrieveEndpoints ( ) ) ; StringSet newEndPoints = sZone . retrieveEndpoints ( ) ; for ( String endpoint : tzone . retrieveEndpoints ( ) ) { if ( newEndPoints . contains ( endpoint ) ) { addedEndPoints . remove ( endpoint ) ; } } if ( ! addedEndPoints . isEmpty ( ) ) { tzone . addEndpoints ( addedEndPoints , BOOL_ ) ; } tzone . setNativeGuid ( sZone . getNativeGuid ( ) ) ; }
static public void println ( String msg ) { println ( msg , CLLogLevel . normal ) ; }
private static ByteString readChunk ( InputStream in , final int chunkSize ) throws IOException { final byte [ ] buf = new byte [ chunkSize ] ; int bytesRead = NUM_ ; while ( bytesRead < chunkSize ) { final int count = in . read ( buf , bytesRead , chunkSize - bytesRead ) ; if ( count == - NUM_ ) { break ; } bytesRead += count ; } if ( bytesRead == NUM_ ) { return null ; } else { return ByteString . copyFrom ( buf , NUM_ , bytesRead ) ; } }
private List < FacetResult > sumAssociations ( ) throws IOException { DirectoryReader indexReader = DirectoryReader . open ( indexDir ) ; IndexSearcher searcher = new IndexSearcher ( indexReader ) ; TaxonomyReader taxoReader = new DirectoryTaxonomyReader ( taxoDir ) ; FacetsCollector fc = new FacetsCollector ( ) ; FacetsCollector . search ( searcher , new MatchAllDocsQuery ( ) , NUM_ , fc ) ; Facets tags = new TaxonomyFacetSumIntAssociations ( STR_ , taxoReader , config , fc ) ; Facets genre = new TaxonomyFacetSumFloatAssociations ( STR_ , taxoReader , config , fc ) ; List < FacetResult > results = new ArrayList < > ( ) ; results . add ( tags . getTopChildren ( NUM_ , STR_ ) ) ; results . add ( genre . getTopChildren ( NUM_ , STR_ ) ) ; indexReader . close ( ) ; taxoReader . close ( ) ; return results ; }
public ReverseGeoCode ( InputStream placenames , boolean majorOnly ) throws IOException { createKdTree ( placenames , majorOnly ) ; }
protected String patchName ( String qname ) { final int lastColon = qname . lastIndexOf ( STR_ ) ; if ( lastColon > NUM_ ) { final int firstColon = qname . indexOf ( STR_ ) ; final String prefix = qname . substring ( NUM_ , firstColon ) ; final String localName = qname . substring ( lastColon + NUM_ ) ; final String uri = m_prefixMap . lookupNamespace ( prefix ) ; if ( uri != null && uri . length ( ) == NUM_ ) { return localName ; } else if ( firstColon != lastColon ) { return prefix + STR_ + localName ; } } return qname ; }
public static String fromTag ( ListTag < Tag > tag ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( ARRAY_START ) ; boolean start = BOOL_ ; for ( Tag value : tag . getValue ( ) ) { if ( start ) { start = BOOL_ ; } else { builder . append ( ELEMENT_SEPERATOR ) ; } builder . append ( fromGenericTag ( value ) ) ; } builder . append ( ARRAY_END ) ; return builder . toString ( ) ; }
private XMLElement2 createAnotherElement ( ) { return new XMLElement2 ( this . entities , this . ignoreWhitespace , BOOL_ , this . ignoreCase ) ; }
public synchronized void reset ( ) { labels . clear ( ) ; labels . put ( SensisionConstants . SENSISION_LABEL_TOPIC , this . topic ) ; labels . put ( SensisionConstants . SENSISION_LABEL_GROUPID , this . groupid ) ; for ( int i = NUM_ ; i < this . counters . length ; i ++ ) { if ( null == this . counters [ i ] ) { continue ; } labels . put ( SensisionConstants . SENSISION_LABEL_PARTITION , Integer . toString ( i ) ) ; Sensision . clear ( SensisionConstants . SENSISION_CLASS_WARP_KAFKA_CONSUMER_OFFSET , labels ) ; this . counters [ i ] = null ; } }
public Vector rotateInRadian ( double radians ) { final double length = length ( ) ; double angle = angleInRadian ( ) ; angle += radians ; final Vector result = new Vector ( Math . cos ( angle ) , Math . sin ( angle ) ) ; return result . multiply ( length ) ; }
public void connectionLost ( java . lang . Throwable cause ) { int rc = - NUM_ ; led . setAmber ( ) ; led . setFlash ( ) ; setTitleText ( STR_ ) ; synchronized ( this ) { writeLogln ( STR_ + mqtt . getServerURI ( ) ) ; } try { while ( ( rc == - NUM_ ) && connected ) { try { synchronized ( connLostWait ) { connLostWait . wait ( NUM_ ) ; } } catch ( InterruptedException iex ) { } synchronized ( this ) { if ( connected ) { writeLog ( STR_ ) ; try { connect ( mqtt . getServerURI ( ) , optionsComp . isPersistenceSelected ( ) ) ; rc = NUM_ ; } catch ( MqttException mqte ) { rc = - NUM_ ; } if ( rc == - NUM_ ) { writeLogln ( STR_ ) ; } else { writeLogln ( STR_ ) ; } } } } setTitleText ( STR_ ) ; } catch ( Exception ex ) { setTitleText ( STR_ ) ; ex . printStackTrace ( ) ; disconnect ( ) ; } finally { if ( led . isFlashing ( ) ) { led . setFlash ( ) ; } } if ( connected ) { led . setGreen ( ) ; setConnected ( BOOL_ ) ; } else { led . setRed ( ) ; setConnected ( BOOL_ ) ; } }
private Rect calcBounds ( int index , Paint paint ) { Rect bounds = new Rect ( ) ; CharSequence title = getTitle ( index ) ; bounds . right = ( int ) paint . measureText ( title , NUM_ , title . length ( ) ) ; bounds . bottom = ( int ) ( paint . descent ( ) - paint . ascent ( ) ) ; return bounds ; }
public String headerOut ( String name ) { ArrayList < String > keys = _headerKeysOut ; int headerSize = keys . size ( ) ; for ( int i = NUM_ ; i < headerSize ; i ++ ) { String oldKey = keys . get ( i ) ; if ( oldKey . equalsIgnoreCase ( name ) ) { return ( String ) _headerValuesOut . get ( i ) ; } } if ( name . equalsIgnoreCase ( STR_ ) ) { return _contentLengthOut >= NUM_ ? String . valueOf ( _contentLengthOut ) : null ; } if ( name . equalsIgnoreCase ( STR_ ) ) { return _contentTypeOut ; } return null ; }
private static Map < String , Set < String > > parseSparseFields ( MultivaluedMap < String , String > queryParams ) { Map < String , Set < String > > result = new HashMap < > ( ) ; for ( Map . Entry < String , List < String > > kv : queryParams . entrySet ( ) ) { String key = kv . getKey ( ) ; if ( key . startsWith ( STR_ ) && key . endsWith ( STR_ ) ) { String type = key . substring ( NUM_ , key . length ( ) - NUM_ ) ; LinkedHashSet < String > filters = new LinkedHashSet < > ( ) ; for ( String filterParams : kv . getValue ( ) ) { Collections . addAll ( filters , filterParams . split ( STR_ ) ) ; } if ( ! filters . isEmpty ( ) ) { result . put ( type , filters ) ; } } } return result ; }
public Element signWithWSSSAMLTokenProfile ( Document doc , java . security . cert . Certificate cert , String assertionID , String algorithm , List ids ) throws XMLSignatureException { return signWithWSSSAMLTokenProfile ( doc , cert , assertionID , algorithm , ids , SOAPBindingConstants . WSF_10_VERSION ) ; }
@ Override public void stateChanged ( ChangeEvent e ) { updateFrameTitle ( ) ; updateMenu ( ) ; if ( e . getSource ( ) instanceof JComponent ) { setTabTitle ( ( JComponent ) e . getSource ( ) ) ; } }
@ Override public void addURL ( URL url , boolean isScanned ) { if ( containsURL ( url ) ) { return ; } super . addURL ( url , isScanned ) ; if ( isScanned ) _pendingScanRoots . add ( new ScanRoot ( url , null ) ) ; }
public void add ( final int start , final int end , final byte status ) { final int s = start - mStart ; if ( s < mInterval . length && end > mStart ) { Arrays . fill ( mInterval , Math . max ( s , NUM_ ) , Math . min ( end - mStart , mInterval . length ) , status ) ; } }
public void reset ( ) { alpha = initAlpha ; neighborhoodSize = initNeighborhoodSize ; }
private void reload ( ) { Document doc = textPane . getDocument ( ) ; doc . putProperty ( Document . StreamDescriptionProperty , null ) ; reference = currentReference ; loadPage ( currentPage ) ; }
protected void drawHexagon ( int x , int y , int w , int h , Color fillColor , Paint fillPaint , Color penColor , boolean shadow , String direction ) { Polygon hexagon = new Polygon ( ) ; if ( direction . equals ( mxConstants . DIRECTION_NORTH ) || direction . equals ( mxConstants . DIRECTION_SOUTH ) ) { hexagon . addPoint ( x + ( int ) ( NUM_ . w ) , y ) ; hexagon . addPoint ( x + w , y + ( int ) ( NUM_ . h ) ) ; hexagon . addPoint ( x + w , y + ( int ) ( NUM_ . h ) ) ; hexagon . addPoint ( x + ( int ) ( NUM_ . w ) , y + h ) ; hexagon . addPoint ( x , y + ( int ) ( NUM_ . h ) ) ; hexagon . addPoint ( x , y + ( int ) ( NUM_ . h ) ) ; } else { hexagon . addPoint ( x + ( int ) ( NUM_ . w ) , y ) ; hexagon . addPoint ( x + ( int ) ( NUM_ . w ) , y ) ; hexagon . addPoint ( x + w , y + ( int ) ( NUM_ . h ) ) ; hexagon . addPoint ( x + ( int ) ( NUM_ . w ) , y + h ) ; hexagon . addPoint ( x + ( int ) ( NUM_ . w ) , y + h ) ; hexagon . addPoint ( x , y + ( int ) ( NUM_ . h ) ) ; } drawPolygon ( hexagon , fillColor , fillPaint , penColor , shadow ) ; }
private boolean isStatic ( Field field ) { int modifier = field . getModifiers ( ) ; if ( Modifier . isStatic ( modifier ) ) { return BOOL_ ; } return BOOL_ ; }
public int outstandingRequests ( ) { return outstanding . get ( ) ; }
final public static String toString ( final byte [ ] key , final int off , final int len ) { if ( key == null ) return NULL ; final StringBuilder sb = new StringBuilder ( len . NUM_ + NUM_ ) ; sb . append ( STR_ ) ; for ( int i = off ; i < off + len ; i ++ ) { if ( i > NUM_ ) sb . append ( STR_ ) ; sb . append ( Integer . toString ( key [ i ] & xff ) ) ; } sb . append ( STR_ ) ; return sb . toString ( ) ; }
public void init ( String componentName ) throws LogException { accessLogger = Logger . getLogger ( componentName + STR_ ) ; errorLogger = Logger . getLogger ( componentName + STR_ ) ; }
private View fillLeft ( int pos , int nextRight ) { if ( DEBUG ) Log . i ( TAG , STR_ + pos + STR_ + nextRight + M_FIRST_POSITION + mFirstPosition ) ; View selectedView = null ; final int end = mListPadding . left ; while ( nextRight > end && pos >= NUM_ ) { View temp = makeColumn ( pos , nextRight , BOOL_ ) ; if ( temp != null ) { selectedView = temp ; } nextRight = mReferenceView . getLeft ( ) - mHorizontalSpacing ; mFirstPosition = pos ; pos -= mNumRows ; } if ( mStackFromBottom ) { mFirstPosition = Math . max ( NUM_ , pos + NUM_ ) ; } return selectedView ; }
public void removeDefaultValue ( String value ) throws SMSException , SSOException { Set defaultValues = getDefaultValues ( ) ; if ( defaultValues != Collections . EMPTY_SET ) { defaultValues . remove ( value ) ; updateDefaultValues ( defaultValues ) ; } }
public static int keyBindingDescriptionToKeyCode ( String keyBindingDescription ) { if ( StringUtils . isBlank ( keyBindingDescription ) ) { return NUM_ ; } else if ( keyBindingDescription . equals ( STR_ ) ) { return SWT . ESC ; } else if ( keyBindingDescription . equals ( STR_ ) ) { return SWT . F1 ; } else if ( keyBindingDescription . equals ( STR_ ) ) { return SWT . F2 ; } else if ( keyBindingDescription . equals ( STR_ ) ) { return SWT . F3 ; } else if ( keyBindingDescription . equals ( STR_ ) ) { return SWT . F4 ; } else if ( keyBindingDescription . equals ( STR_ ) ) { return SWT . F5 ; } else if ( keyBindingDescription . equals ( STR_ ) ) { return SWT . F6 ; } else if ( keyBindingDescription . equals ( STR_ ) ) { return SWT . F7 ; } else if ( keyBindingDescription . equals ( STR_ ) ) { return SWT . F8 ; } else if ( keyBindingDescription . equals ( STR_ ) ) { return SWT . F9 ; } else if ( keyBindingDescription . equals ( STR_ ) ) { return SWT . F10 ; } else if ( keyBindingDescription . equals ( STR_ ) ) { return SWT . F11 ; } else if ( keyBindingDescription . equals ( STR_ ) ) { return SWT . F12 ; } else if ( keyBindingDescription . equals ( STR_ ) ) { return SWT . SCROLL_LOCK ; } else if ( VALID_ACTION_KEY_CODES . indexOf ( keyBindingDescription . charAt ( keyBindingDescription . length ( ) - NUM_ ) ) != - NUM_ ) { return keyBindingDescription . charAt ( keyBindingDescription . length ( ) - NUM_ ) ; } else { return NUM_ ; } }
public void testPutCauseEviction ( ) { List < String > log = new ArrayList < String > ( ) ; LruCache < String , String > cache = newRemovalLogCache ( log ) ; cache . put ( STR_ , STR_ ) ; cache . put ( STR_ , STR_ ) ; cache . put ( STR_ , STR_ ) ; cache . put ( STR_ , STR_ ) ; assertEquals ( Arrays . asList ( STR_ ) , log ) ; assertSnapshot ( cache , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ ) ; }
protected Signature mergeSignatures ( Signature first , Signature second , int numBins ) { int d2 = - NUM_ ; for ( int i = NUM_ ; i < second . spec . length ; i += NUM_ ) { if ( second . spec [ i ] >= NUM_ ) { assert ( d2 == - NUM_ ) : STR_ ; d2 = i ; } } assert ( d2 >= NUM_ ) : STR_ ; if ( first . spec [ d2 ] >= NUM_ ) { return null ; } final ModifiableDBIDs intersection = DBIDUtil . intersection ( first . ids , second . ids ) ; final int support = intersection . size ( ) ; double width = ( second . spec [ d2 + NUM_ ] - second . spec [ d2 ] + NUM_ ) / ( double ) numBins ; double expect = first . ids . size ( ) . width ; if ( support <= expect || support < minClusterSize ) { return null ; } final double test = PoissonDistribution . rawProbability ( support , expect ) ; if ( ( poissonThreshold ) <= test ) { return null ; } int [ ] spec = first . spec . clone ( ) ; spec [ d2 ] = second . spec [ d2 ] ; spec [ d2 + NUM_ ] = second . spec [ d2 ] ; final Signature newsig = new Signature ( spec , intersection ) ; if ( LOG . isDebugging ( ) ) { LOG . debug ( newsig . toString ( ) ) ; } return newsig ; }
@ Override public int hashCode ( ) { return super . hashCode ( ) ; }
public IgniteDeploymentException ( Throwable cause ) { this ( cause . getMessage ( ) , cause ) ; }
public synchronized boolean enter ( CnATreeElement obj ) throws TransactionAbortedException { if ( aborted ) { throw new TransactionAbortedException ( ) ; } visited . add ( obj ) ; if ( this . initiator != null ) { return BOOL_ ; } this . initiator = obj ; aborted = BOOL_ ; return BOOL_ ; }
public Options addOption ( Option opt ) { String key = opt . getKey ( ) ; if ( opt . hasLongOpt ( ) ) { longOpts . put ( opt . getLongOpt ( ) , opt ) ; } if ( opt . isRequired ( ) ) { if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
private void pauseForClientToJoin ( ) { Wait . pause ( NUM_ ) ; }
public void propertyChange ( PropertyChangeEvent pce ) { if ( pce . getPropertyName ( ) == MapBean . BackgroundProperty && backgroundSlave ) { map . setBckgrnd ( ( Paint ) pce . getNewValue ( ) ) ; } }
public TransitionBuilder addFrame ( int imageResource ) { mFrames . add ( imageResource ) ; return this ; }
public Class < ? > [ ] scanForClasses ( String location , Class < ? > implementedInterface ) throws Exception { LOG . debug ( STR_ + location + STR_ + implementedInterface . getName ( ) + STR_ ) ; List < Class < ? > > classes = new ArrayList < Class < ? > > ( ) ; Set < String > resourceNames = findResourceNames ( location , STR_ , STR_ ) ; for ( String resourceName : resourceNames ) { String className = toClassName ( resourceName ) ; Class < ? > clazz = classLoader . loadClass ( className ) ; if ( Modifier . isAbstract ( clazz . getModifiers ( ) ) || clazz . isEnum ( ) || clazz . isAnonymousClass ( ) ) { LOG . debug ( STR_ + className ) ; continue ; } if ( ! implementedInterface . isAssignableFrom ( clazz ) ) { continue ; } try { ClassUtils . instantiate ( className , classLoader ) ; } catch ( Exception e ) { throw new CassandraMigrationException ( STR_ + className , e ) ; } classes . add ( clazz ) ; LOG . debug ( STR_ + className ) ; } return classes . toArray ( new Class < ? > [ classes . size ( ) ] ) ; }
public String nextCDATA ( ) throws JSONException { char c ; int i ; StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { c = next ( ) ; if ( end ( ) ) { throw syntaxError ( STR_ ) ; } sb . append ( c ) ; i = sb . length ( ) - NUM_ ; if ( i >= NUM_ && sb . charAt ( i ) == STR_ && sb . charAt ( i + NUM_ ) == STR_ && sb . charAt ( i + NUM_ ) == STR_ ) { sb . setLength ( i ) ; return sb . toString ( ) ; } } }
private static boolean needsSkylightUpdate ( FastCubeBlockAccess access , MutableBlockPos pos ) { if ( access . getBlockLightOpacity ( pos ) >= NUM_ ) { return BOOL_ ; } int computedLight = access . computeLightValue ( pos ) ; for ( EnumFacing facing : EnumFacing . values ( ) ) { pos . move ( facing ) ; int currentLight = access . getLightFor ( EnumSkyBlock . SKY , pos ) ; int currentOpacity = Math . max ( NUM_ , access . getBlockLightOpacity ( pos ) ) ; pos . move ( facing . getOpposite ( ) ) ; if ( computedLight == currentLight - currentOpacity ) { return BOOL_ ; } } return BOOL_ ; }
public static void expand ( Rectangle2D r , double amount ) { r . setRect ( r . getX ( ) - amount , r . getY ( ) - amount , r . getWidth ( ) + NUM_ . amount , r . getHeight ( ) + NUM_ . amount ) ; }
static void stringToPacket ( String s , DatagramPacket packet ) { byte [ ] bytes = s . getBytes ( ) ; System . arraycopy ( bytes , NUM_ , packet . getData ( ) , NUM_ , bytes . length ) ; packet . setLength ( bytes . length ) ; }
@ Override public String toString ( ) { StringBuffer buffer = new StringBuffer ( STR_ ) ; buffer . append ( STR_ ) ; buffer . append ( gridX ) ; buffer . append ( STR_ ) ; buffer . append ( gridY ) ; buffer . append ( STR_ ) ; buffer . append ( gridWidth ) ; buffer . append ( STR_ ) ; buffer . append ( gridHeight ) ; buffer . append ( STR_ ) ; buffer . append ( hAlign ) ; buffer . append ( STR_ ) ; buffer . append ( vAlign ) ; if ( ! EMPTY_INSETS . equals ( insets ) ) { buffer . append ( STR_ ) ; buffer . append ( insets ) ; } buffer . append ( STR_ ) ; buffer . append ( honorsVisibility ) ; buffer . append ( STR_ ) ; return buffer . toString ( ) ; }
private ArrayList < PROCLUSCluster > assignPoints ( ArrayDBIDs m_current , long [ ] [ ] dimensions , Relation < V > database ) { ModifiableDBIDs [ ] clusterIDs = new ModifiableDBIDs [ dimensions . length ] ; for ( int i = NUM_ ; i < m_current . size ( ) ; i ++ ) { clusterIDs [ i ] = DBIDUtil . newHashSet ( ) ; } DBIDArrayIter m_i = m_current . iter ( ) ; for ( DBIDIter it = database . iterDBIDs ( ) ; it . valid ( ) ; it . advance ( ) ) { V p = database . get ( it ) ; double minDist = Double . NaN ; int best = - NUM_ , i = NUM_ ; for ( m_i . seek ( NUM_ ) ; m_i . valid ( ) ; m_i . advance ( ) , i ++ ) { V m = database . get ( m_i ) ; double currentDist = manhattanSegmentalDistance ( p , m , dimensions [ i ] ) ; if ( ! ( minDist <= currentDist ) ) { minDist = currentDist ; best = i ; } } assert best >= NUM_ ; ModifiableDBIDs ids = clusterIDs [ best ] ; ids . add ( it ) ; } ArrayList < PROCLUSCluster > clusters = new ArrayList < > ( m_current . size ( ) ) ; for ( int i = NUM_ ; i < dimensions . length ; i ++ ) { ModifiableDBIDs objectIDs = clusterIDs [ i ] ; if ( ! objectIDs . isEmpty ( ) ) { long [ ] clusterDimensions = dimensions [ i ] ; double [ ] centroid = Centroid . make ( database , objectIDs ) . getArrayRef ( ) ; clusters . add ( new PROCLUSCluster ( objectIDs , clusterDimensions , centroid ) ) ; } else { clusters . add ( null ) ; } } if ( LOG . isDebugging ( ) ) { StringBuilder msg = new StringBuilder ( ) ; msg . append ( STR_ ) ; msg . append ( STR_ ) . append ( clusters ) . append ( STR_ ) ; LOG . debugFine ( msg . toString ( ) ) ; } return clusters ; }
public double slideSubtree ( MutableTree tree ) { double logHastingsRatio ; NodeRef i , newParent , newChild ; do { i = tree . getNode ( MathUtils . nextInt ( tree . getNodeCount ( ) ) ) ; } while ( tree . getRoot ( ) == i ) ; NodeRef iP = tree . getParent ( i ) ; NodeRef CiP = getOtherChild ( tree , iP , i ) ; NodeRef PiP = tree . getParent ( iP ) ; double delta = getDelta ( ) ; double oldHeight = tree . getNodeHeight ( iP ) ; double newHeight = oldHeight + delta ; if ( delta > NUM_ ) { if ( PiP != null && tree . getNodeHeight ( PiP ) < newHeight ) { newParent = PiP ; newChild = iP ; while ( tree . getNodeHeight ( newParent ) < newHeight ) { newChild = newParent ; newParent = tree . getParent ( newParent ) ; if ( newParent == null ) break ; } tree . beginTreeEdit ( ) ; if ( tree . isRoot ( newChild ) ) { tree . removeChild ( iP , CiP ) ; tree . removeChild ( PiP , iP ) ; tree . addChild ( iP , newChild ) ; tree . addChild ( PiP , CiP ) ; tree . setRoot ( iP ) ; } else { tree . removeChild ( iP , CiP ) ; tree . removeChild ( PiP , iP ) ; tree . removeChild ( newParent , newChild ) ; tree . addChild ( iP , newChild ) ; tree . addChild ( PiP , CiP ) ; tree . addChild ( newParent , iP ) ; } tree . setNodeHeight ( iP , newHeight ) ; tree . endTreeEdit ( ) ; int possibleSources = intersectingEdges ( tree , newChild , oldHeight , null ) ; logHastingsRatio = Math . log ( NUM_ / ( double ) possibleSources ) ; } else { tree . setNodeHeight ( iP , newHeight ) ; logHastingsRatio = NUM_ ; } } else { if ( tree . getNodeHeight ( i ) > newHeight ) { return Double . NEGATIVE_INFINITY ; } if ( tree . getNodeHeight ( CiP ) > newHeight ) { ArrayList newChildren = new ArrayList ( ) ; int possibleDestinations = intersectingEdges ( tree , CiP , newHeight , newChildren ) ; if ( newChildren . size ( ) == NUM_ ) { return Double . NEGATIVE_INFINITY ; } int childIndex = MathUtils . nextInt ( newChildren . size ( ) ) ; newChild = ( NodeRef ) newChildren . get ( childIndex ) ; newParent = tree . getParent ( newChild ) ; tree . beginTreeEdit ( ) ; if ( tree . isRoot ( iP ) ) { tree . removeChild ( iP , CiP ) ; tree . removeChild ( newParent , newChild ) ; tree . addChild ( iP , newChild ) ; tree . addChild ( newParent , iP ) ; tree . setRoot ( CiP ) ; } else { tree . removeChild ( iP , CiP ) ; tree . removeChild ( PiP , iP ) ; tree . removeChild ( newParent , newChild ) ; tree . addChild ( iP , newChild ) ; tree . addChild ( PiP , CiP ) ; tree . addChild ( newParent , iP ) ; } tree . setNodeHeight ( iP , newHeight ) ; tree . endTreeEdit ( ) ; logHastingsRatio = Math . log ( ( double ) possibleDestinations ) ; } else { tree . setNodeHeight ( iP , newHeight ) ; logHastingsRatio = NUM_ ; } } return logHastingsRatio ; }
public boolean isInitialized ( ) { return _initialized ; }
public boolean removeShutdownHook ( Thread hook ) { if ( hook == null ) { throw new NullPointerException ( STR_ ) ; } if ( shuttingDown ) { throw new IllegalStateException ( STR_ ) ; } synchronized ( shutdownHooks ) { return shutdownHooks . remove ( hook ) ; } }
private ResultPointsAndTransitions transitionsBetween ( ResultPoint from , ResultPoint to ) { int fromX = ( int ) from . getX ( ) ; int fromY = ( int ) from . getY ( ) ; int toX = ( int ) to . getX ( ) ; int toY = ( int ) to . getY ( ) ; boolean steep = Math . abs ( toY - fromY ) > Math . abs ( toX - fromX ) ; if ( steep ) { int temp = fromX ; fromX = fromY ; fromY = temp ; temp = toX ; toX = toY ; toY = temp ; } int dx = Math . abs ( toX - fromX ) ; int dy = Math . abs ( toY - fromY ) ; int error = - dx / NUM_ ; int ystep = fromY < toY ? NUM_ : - NUM_ ; int xstep = fromX < toX ? NUM_ : - NUM_ ; int transitions = NUM_ ; boolean inBlack = image . get ( steep ? fromY : fromX , steep ? fromX : fromY ) ; for ( int x = fromX , y = fromY ; x != toX ; x += xstep ) { boolean isBlack = image . get ( steep ? y : x , steep ? x : y ) ; if ( isBlack != inBlack ) { transitions ++ ; inBlack = isBlack ; } error += dy ; if ( error > NUM_ ) { if ( y == toY ) { break ; } y += ystep ; error -= dx ; } } return new ResultPointsAndTransitions ( from , to , transitions ) ; }
public String toString ( ) { return Double . toString ( get ( ) ) ; }
boolean checkCameraSize ( CameraOptions cameraId ) { boolean sizeAvailable = BOOL_ ; Camera camera = null ; Method method = getCameraOpenMethod ( ) ; if ( method != null ) { try { camera = ( Camera ) method . invoke ( camera , new Object [ ] { cameraId . getValue ( ) } ) ; } catch ( Exception e ) { camera = Camera . open ( ) ; } } else { camera = Camera . open ( ) ; } if ( camera == null ) { return BOOL_ ; } Parameters param = camera . getParameters ( ) ; List < Camera . Size > sizes = param . getSupportedPreviewSizes ( ) ; for ( Camera . Size size : sizes ) { if ( ( size . width == H264Config . QVGA_WIDTH && size . height == H264Config . QVGA_HEIGHT ) || ( size . width == H264Config . CIF_WIDTH && size . height == H264Config . CIF_HEIGHT ) || ( size . width == H264Config . VGA_WIDTH && size . height == H264Config . VGA_HEIGHT ) ) { sizeAvailable = BOOL_ ; break ; } } camera . release ( ) ; return sizeAvailable ; }
ConfigurationError ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; }
public void append ( final String s ) { if ( first ) { first = BOOL_ ; } else { builder . append ( space ) ; } builder . append ( s ) ; }
public static ByteArrayOutputStream encode ( String plaintext ) throws IOException , MessagingException { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; byte [ ] in = plaintext . getBytes ( ) ; ByteArrayOutputStream inStream = new ByteArrayOutputStream ( ) ; inStream . write ( in , NUM_ , in . length ) ; if ( ( in . length % NUM_ ) == NUM_ ) { inStream . write ( NUM_ ) ; inStream . write ( NUM_ ) ; } else if ( ( in . length % NUM_ ) == NUM_ ) { inStream . write ( NUM_ ) ; } inStream . writeTo ( MimeUtility . encode ( out , STR_ ) ) ; return out ; }
public LookupListTable lookupList ( ) { if ( lookupListTable . get ( ) == null ) { lookupListTable . compareAndSet ( null , gsub . createLookupList ( ) ) ; } return lookupListTable . get ( ) ; }
public long sum ( ) { return deltaSum . get ( ) ; }
protected final void refreshLoadingViewsSize ( ) { final int maximumPullScroll = ( int ) ( getMaximumPullScroll ( ) . NUM_ ) ; int pLeft = getPaddingLeft ( ) ; int pTop = getPaddingTop ( ) ; int pRight = getPaddingRight ( ) ; int pBottom = getPaddingBottom ( ) ; switch ( getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setWidth ( maximumPullScroll ) ; pLeft = - maximumPullScroll ; } else { pLeft = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setWidth ( maximumPullScroll ) ; pRight = - maximumPullScroll ; } else { pRight = NUM_ ; } break ; case VERTICAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setHeight ( maximumPullScroll ) ; pTop = - maximumPullScroll ; } else { pTop = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setHeight ( maximumPullScroll ) ; pBottom = - maximumPullScroll ; } else { pBottom = NUM_ ; } break ; } if ( DEBUG ) { Log . d ( LOG_TAG , String . format ( STR_ , pLeft , pTop , pRight , pBottom ) ) ; } setPadding ( pLeft , pTop , pRight , pBottom ) ; }
private static boolean isWordBoundary ( CharSequence singleChar , String wordSeparators ) { return TextUtils . isEmpty ( singleChar ) || wordSeparators . contains ( singleChar ) ; }
public void executeBlocking ( String desc , BlockingConsumer < MongoClient > operation ) throws InterruptedException { while ( BOOL_ ) { MongoClient primary = primaryConnectionSupplier . get ( ) ; try { operation . accept ( primary ) ; return ; } catch ( Throwable t ) { errorHandler . accept ( desc , t ) ; } } }
public void write ( char [ ] cbuf ) throws java . io . IOException { write ( cbuf , NUM_ , cbuf . length ) ; }
protected TableViewer createTable ( Composite parent , int span ) { Table table = new Table ( parent , SWT . H_SCROLL | SWT . V_SCROLL | SWT . BORDER | SWT . SINGLE | SWT . FULL_SELECTION ) ; GridData data = new GridData ( GridData . FILL_BOTH | GridData . GRAB_HORIZONTAL ) ; data . horizontalSpan = span ; table . setLayoutData ( data ) ; TableLayout layout = new TableLayout ( ) ; layout . addColumnData ( new ColumnWeightData ( NUM_ , BOOL_ ) ) ; table . setLayout ( layout ) ; TableColumn col = new TableColumn ( table , SWT . NONE ) ; col . setResizable ( BOOL_ ) ; return new TableViewer ( table ) ; }
public String typeAsString ( ) { String typeStr = STR_ ; String subtypeStr = STR_ ; switch ( this . type ) { case ETYPE_CONTROL : typeStr = STR_ ; switch ( this . subtype ) { case ESTYPE_HEADER : subtypeStr = STR_ ; break ; case ESTYPE_FOOTER : subtypeStr = STR_ ; break ; } break ; case ETYPE_TRANSACTIONS : typeStr = STR_ ; switch ( this . subtype ) { case ESTYPE_TRAN_START : subtypeStr = STR_ ; break ; case ESTYPE_TRAN_COMMIT : subtypeStr = STR_ ; break ; case ESTYPE_TRAN_ROLLBACK : subtypeStr = STR_ ; break ; case ESTYPE_TRAN_ROLLBACK_TO_SAVEPOINT : subtypeStr = STR_ ; break ; case ESTYPE_TRAN_AUDIT : subtypeStr = STR_ ; break ; } break ; case ETYPE_LCR_DATA : typeStr = STR_ ; switch ( this . subtype ) { case ESTYPE_LCR_INSERT : subtypeStr = STR_ ; break ; case ESTYPE_LCR_DELETE : subtypeStr = STR_ ; break ; case ESTYPE_LCR_UPDATE : subtypeStr = STR_ ; break ; case ESTYPE_LCR_LOB_WRITE : subtypeStr = STR_ ; break ; case ESTYPE_LCR_LOB_TRIM : subtypeStr = STR_ ; break ; case ESTYPE_LCR_LOB_ERASE : subtypeStr = STR_ ; break ; case ESTYPE_LCR_DDL : subtypeStr = STR_ ; break ; } break ; case ETYPE_LCR_PLOG : typeStr = STR_ ; switch ( this . subtype ) { case ESTYPE_LCR_PLOG_IFILE : subtypeStr = STR_ ; break ; case ESTYPE_LCR_PLOG_IFILE_STATS : subtypeStr = STR_ ; break ; } break ; default : typeStr = STR_ + this . type + STR_ ; subtypeStr = STR_ + this . subtype ; } return typeStr + subtypeStr ; }
public void lineTo ( float x , float y ) { mPoints . add ( PathPoint . lineTo ( x , y ) ) ; }
public void flagActionItems ( ) { if ( ! mIsActionItemsStale ) { return ; } boolean flagged = BOOL_ ; for ( WeakReference < MenuPresenter > ref : mPresenters ) { final MenuPresenter presenter = ref . get ( ) ; if ( presenter == null ) { mPresenters . remove ( ref ) ; } else { flagged |= presenter . flagActionItems ( ) ; } } if ( flagged ) { mActionItems . clear ( ) ; mNonActionItems . clear ( ) ; ArrayList < MenuItemImpl > visibleItems = getVisibleItems ( ) ; final int itemsSize = visibleItems . size ( ) ; for ( int i = NUM_ ; i < itemsSize ; i ++ ) { MenuItemImpl item = visibleItems . get ( i ) ; if ( item . isActionButton ( ) ) { mActionItems . add ( item ) ; } else { mNonActionItems . add ( item ) ; } } } else { mActionItems . clear ( ) ; mNonActionItems . clear ( ) ; mNonActionItems . addAll ( getVisibleItems ( ) ) ; } mIsActionItemsStale = BOOL_ ; }
protected boolean [ ] canHandleMissing ( boolean nominalPredictor , boolean numericPredictor , boolean stringPredictor , boolean datePredictor , boolean relationalPredictor , boolean multiInstance , int classType , boolean predictorMissing , boolean classMissing , int missingLevel ) { if ( missingLevel == NUM_ ) { print ( STR_ ) ; } print ( STR_ ) ; if ( predictorMissing ) { print ( STR_ ) ; if ( classMissing ) { print ( STR_ ) ; } } if ( classMissing ) { print ( STR_ ) ; } print ( STR_ ) ; printAttributeSummary ( nominalPredictor , numericPredictor , stringPredictor , datePredictor , relationalPredictor , multiInstance , classType ) ; print ( STR_ ) ; ArrayList < String > accepts = new ArrayList < String > ( ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; int numTrain = getNumInstances ( ) , numTest = getNumInstances ( ) , numClasses = NUM_ ; return runBasicTest ( nominalPredictor , numericPredictor , stringPredictor , datePredictor , relationalPredictor , multiInstance , classType , missingLevel , predictorMissing , classMissing , numTrain , numTest , numClasses , accepts ) ; }
private void disableButtons ( ) { for ( DeployCommand cmd : DeployCommand . values ( ) ) { setButtonEnabled ( cmd , BOOL_ ) ; } butDone . setEnabled ( BOOL_ ) ; setLoadEnabled ( BOOL_ ) ; setUnloadEnabled ( BOOL_ ) ; setAssaultDropEnabled ( BOOL_ ) ; }
public Artifact load ( File path ) throws IOException { return load ( new ArtifactName ( path . getName ( ) ) , path ) ; }
protected final boolean tryAcquire ( int acquires ) { final Thread current = Thread . currentThread ( ) ; int c = getState ( ) ; if ( c == NUM_ ) { if ( ! hasQueuedPredecessors ( ) && compareAndSetState ( NUM_ , acquires ) ) { setExclusiveOwnerThread ( current ) ; return BOOL_ ; } } else if ( current == getExclusiveOwnerThread ( ) ) { int nextc = c + acquires ; if ( nextc < NUM_ ) throw new Error ( STR_ ) ; setState ( nextc ) ; return BOOL_ ; } return BOOL_ ; }
private static final boolean isHeaderEnd ( StringBuilder sb ) { int len = sb . length ( ) ; if ( len > NUM_ ) { if ( LF2 . equals ( sb . substring ( len - NUM_ ) ) ) { return BOOL_ ; } } if ( len > NUM_ ) { if ( CRLF2 . equals ( sb . substring ( len - NUM_ ) ) ) { return BOOL_ ; } } return BOOL_ ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
public TSActionDelay ( TransitSectionAction tsa , int delay ) { _tsa = tsa ; _delay = delay ; }
public DAddExtensions ( JDialog parent , X509ExtensionSet extensions , PublicKey authorityPublicKey , X500Name authorityCertName , BigInteger authorityCertSerialNumber , PublicKey subjectPublicKey ) { super ( parent , Dialog . ModalityType . DOCUMENT_MODAL ) ; setTitle ( res . getString ( STR_ ) ) ; this . extensions = ( X509ExtensionSet ) extensions . clone ( ) ; this . authorityPublicKey = authorityPublicKey ; this . authorityCertName = authorityCertName ; this . authorityCertSerialNumber = authorityCertSerialNumber ; this . subjectPublicKey = subjectPublicKey ; initComponents ( ) ; }
public void add ( IMultiPoint pt ) { if ( inProgress ) { throw new ConcurrentModificationException ( STR_ ) ; } points . add ( pt ) ; }
public static boolean isCglibProxyClass ( Class < ? > clazz ) { return ( clazz != null && isCglibProxyClassName ( clazz . getName ( ) ) ) ; }
private DiscoveryInformation verifyDiscovered ( AuthSuccess authResp , DiscoveryInformation discovered ) throws DiscoveryException { if ( authResp == null || authResp . getIdentity ( ) == null ) { _log . info ( STR_ ) ; return null ; } if ( authResp . isVersion2 ( ) ) return verifyDiscovered2 ( authResp , discovered ) ; else return verifyDiscovered1 ( authResp , discovered ) ; }
public boolean generate ( ReportDescription description , Date date ) { try { Integer targetDateInt = Integer . parseInt ( format . format ( date ) ) ; AnalysisResultSet logAggregation = makeLogAnal ( description , targetDateInt ) ; Report report = new Report ( ) ; report . setSendTime ( new Date ( ) ) ; report . setTargetDate ( date ) ; report . setLogReport ( logAggregation ) ; report . setTargets ( description . getTargets ( ) ) ; logger . debug ( STR_ + report ) ; reportRepository . save ( report ) ; return BOOL_ ; } catch ( Exception e ) { logger . error ( e . getMessage ( ) , e ) ; return BOOL_ ; } }
@ Override public void updateTextViews ( Recharge recharge ) { unitTypeTextView . setText ( recharge . getUnits ( ) ) ; unitValueTextView . setText ( String . valueOf ( recharge . getCurrentAmount ( ) ) ) ; costTextView . setText ( Currency . localize ( recharge . getCurrentCost ( ) , BOOL_ ) ) ; rechargeName . setText ( recharge . getTitle ( ) ) ; confirmationTextView . setText ( STR_ + recharge . getCurrentAmount ( ) + STR_ + recharge . getUnits ( ) + STR_ ) ; if ( recharge . getCurrentAmount ( ) == recharge . getInitialAmount ( ) ) { downArrow . setVisibility ( View . INVISIBLE ) ; } else { downArrow . setVisibility ( View . VISIBLE ) ; } }
private ConcurrentMap < GridCacheVersion , IgniteInternalTx > transactionMap ( IgniteInternalTx tx ) { return ( tx . near ( ) && ! tx . local ( ) ) ? nearIdMap : idMap ; }
public void stop ( ) { synchronized ( this ) { mStopped = BOOL_ ; if ( mListenerThread == null ) { return ; } } mListenerThread . interrupt ( ) ; try { if ( mServerSocket != null ) { mServerSocket . close ( ) ; } } catch ( IOException e ) { } }
public static byte [ ] decode ( byte [ ] data , String pri_key ) { try { Cipher cipher = Cipher . getInstance ( STR_ ) ; java . security . Key k = getPrivateKey ( pri_key ) ; cipher . init ( Cipher . DECRYPT_MODE , k ) ; byte [ ] deBytes = cipher . doFinal ( data ) ; return deBytes ; } catch ( Exception e ) { log . error ( pri_key , e ) ; } return null ; }
public static int deriveARGB ( Color color1 , Color color2 , float midPoint ) { int r = color1 . getRed ( ) + ( int ) ( ( color2 . getRed ( ) - color1 . getRed ( ) ) . midPoint + NUM_ ) ; int g = color1 . getGreen ( ) + ( int ) ( ( color2 . getGreen ( ) - color1 . getGreen ( ) ) . midPoint + NUM_ ) ; int b = color1 . getBlue ( ) + ( int ) ( ( color2 . getBlue ( ) - color1 . getBlue ( ) ) . midPoint + NUM_ ) ; int a = color1 . getAlpha ( ) + ( int ) ( ( color2 . getAlpha ( ) - color1 . getAlpha ( ) ) . midPoint + NUM_ ) ; return ( ( a & xFF ) << NUM_ ) | ( ( r & xFF ) << NUM_ ) | ( ( g & xFF ) << NUM_ ) | ( b & xFF ) ; }
public void addLandingPad ( int x , int z ) { BlockPosition pos = new BlockPosition ( x , NUM_ , z ) ; if ( ! spawnLocations . contains ( pos ) ) { spawnLocations . add ( pos ) ; occupiedLandingPads . put ( pos , BOOL_ ) ; } }
static AttackStrategy create ( String params ) { String [ ] arg = params . split ( STR_ , - NUM_ ) ; if ( arg . length != NUM_ ) { throw new IllegalArgumentException ( STR_ + params + STR_ ) ; } Pair < String , String > desc = parseStrategy ( arg [ NUM_ ] ) ; TargetSelectionStrategy targeter = TargetSelectionStrategyFactory . get ( desc . first ( ) , desc . second ( ) ) ; desc = parseStrategy ( arg [ NUM_ ] ) ; PositioningStrategy positioner = PositioningStrategyFactory . get ( desc . first ( ) , desc . second ( ) ) ; return new CompoundAttackStrategy ( getSubStrategy ( arg [ NUM_ ] ) , targeter , positioner ) ; }
public OrderedThreadPoolExecutor ( ) { this ( DEFAULT_INITIAL_THREAD_POOL_SIZE , DEFAULT_MAX_THREAD_POOL , DEFAULT_KEEP_ALIVE , TimeUnit . SECONDS , Executors . defaultThreadFactory ( ) , null ) ; }
public void addPropertyChangeListener ( PropertyChangeListener pcl ) { m_pcSupport . addPropertyChangeListener ( pcl ) ; }
final public void writeChunk ( L locator , KVO < O > [ ] chunk ) throws MockStaleLocatorException { synchronized ( this ) { if ( staleLocators . contains ( locator . getPartitionId ( ) ) ) { throw new MockStaleLocatorException ( locator ) ; } if ( ! knownLocators . contains ( locator . getPartitionId ( ) ) ) { throw new RuntimeException ( STR_ + locator ) ; } } acceptWrite ( locator , chunk ) ; }
public Event event ( int id ) { if ( ! host ) { return ( Event ) events . get ( new Integer ( id ) ) ; } return null ; }
private void initValues ( ) { IPreferenceStore store = doGetPreferenceStore ( ) ; final String storedItems = store . getString ( CheckerPreferences . PREF_CHECKER_CUSTOM_CLASSES ) ; if ( ! storedItems . equals ( STR_ ) ) { customCheckers . setItems ( storedItems . split ( STR_ ) ) ; } }
private void loadProperties ( ) { String property = System . getProperty ( STR_ ) ; if ( null == property ) { property = CarbonCommonConstants . CARBON_PROPERTIES_FILE_PATH ; } File file = new File ( property ) ; LOGGER . info ( STR_ + file . getAbsolutePath ( ) ) ; FileInputStream fis = null ; try { if ( file . exists ( ) ) { fis = new FileInputStream ( file ) ; carbonProperties . load ( fis ) ; } } catch ( FileNotFoundException e ) { LOGGER . error ( STR_ + CarbonCommonConstants . CARBON_PROPERTIES_FILE_PATH + STR_ ) ; } catch ( IOException e ) { LOGGER . error ( STR_ + CarbonCommonConstants . CARBON_PROPERTIES_FILE_PATH ) ; } finally { if ( null != fis ) { try { fis . close ( ) ; } catch ( IOException e ) { LOGGER . error ( STR_ + CarbonCommonConstants . CARBON_PROPERTIES_FILE_PATH ) ; } } } print ( ) ; }
void sync ( int sourceRepoIndex , int destRepoIndex , AuthenticationInfo subject ) throws IOException { LOG . info ( STR_ ) ; NotebookAuthorization auth = NotebookAuthorization . getInstance ( ) ; NotebookRepo srcRepo = getRepo ( sourceRepoIndex ) ; NotebookRepo dstRepo = getRepo ( destRepoIndex ) ; List < NoteInfo > allSrcNotes = srcRepo . list ( subject ) ; List < NoteInfo > srcNotes = auth . filterByUser ( allSrcNotes , subject ) ; List < NoteInfo > dstNotes = dstRepo . list ( subject ) ; Map < String , List < String > > noteIds = notesCheckDiff ( srcNotes , srcRepo , dstNotes , dstRepo , subject ) ; List < String > pushNoteIds = noteIds . get ( pushKey ) ; List < String > pullNoteIds = noteIds . get ( pullKey ) ; List < String > delDstNoteIds = noteIds . get ( delDstKey ) ; if ( ! pushNoteIds . isEmpty ( ) ) { LOG . info ( STR_ ) ; for ( String id : pushNoteIds ) { LOG . info ( STR_ + id ) ; } pushNotes ( subject , pushNoteIds , srcRepo , dstRepo , BOOL_ ) ; } else { LOG . info ( STR_ ) ; } if ( ! pullNoteIds . isEmpty ( ) ) { LOG . info ( STR_ ) ; for ( String id : pullNoteIds ) { LOG . info ( STR_ + id ) ; } pushNotes ( subject , pullNoteIds , dstRepo , srcRepo , BOOL_ ) ; } else { LOG . info ( STR_ ) ; } if ( ! delDstNoteIds . isEmpty ( ) ) { LOG . info ( STR_ ) ; for ( String id : delDstNoteIds ) { LOG . info ( STR_ + id ) ; } deleteNotes ( subject , delDstNoteIds , dstRepo ) ; } else { LOG . info ( STR_ ) ; } LOG . info ( STR_ ) ; }
public void list ( PrintStream out ) { out . println ( STR_ ) ; Hashtable < String , Object > h = new Hashtable < > ( ) ; enumerate ( h ) ; for ( Enumeration < String > e = h . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = e . nextElement ( ) ; String val = ( String ) h . get ( key ) ; if ( val . length ( ) > NUM_ ) { val = val . substring ( NUM_ , NUM_ ) + STR_ ; } out . println ( key + STR_ + val ) ; } }
public static Date stringToDate ( String strdate , @ SuppressWarnings ( STR_ ) String format ) { Date date = null ; SimpleDateFormat formatter = new SimpleDateFormat ( format ) ; try { date = formatter . parse ( strdate ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } return date ; }
@ Nullable public static String md5 ( @ Nullable File file , @ Nullable IgniteLogger log ) { if ( file != null ) return file . isFile ( ) ? fileMd5 ( file , log ) : directoryMd5 ( file , log ) ; return null ; }
public void init ( int size , int certainty , SecureRandom random ) { this . size = size ; this . certainty = certainty ; this . random = random ; }
@ Override public boolean hasNext ( ) { if ( allRowsResult . size ( ) == NUM_ ) { return BOOL_ ; } totalRecordCounter ++ ; listRecordCounter ++ ; if ( listRecordCounter == NUM_ || ( listRecordCounter >= currentRowPointer . size ( ) && currentListCounter < allRowsResult . size ( ) ) ) { listRecordCounter = NUM_ ; currentRowPointer = allRowsResult . get ( currentListCounter ) ; currentListCounter ++ ; } return totalRecordCounter < totalNumberOfRecords ; }
public void trimToSize ( ) { delegate . trimToSize ( ) ; }
JSONStringer open ( Scope empty , String openBracket ) throws JSONException { if ( stack . isEmpty ( ) && out . length ( ) > NUM_ ) { throw new JSONException ( STR_ ) ; } beforeValue ( ) ; stack . add ( empty ) ; out . append ( openBracket ) ; return this ; }
public static final String asciiBoard ( Position pos ) { StringBuilder ret = new StringBuilder ( NUM_ ) ; String nl = String . format ( Locale . US , STR_ ) ; ret . append ( STR_ ) ; ret . append ( nl ) ; for ( int y = NUM_ ; y >= NUM_ ; y -- ) { ret . append ( STR_ ) ; for ( int x = NUM_ ; x < NUM_ ; x ++ ) { ret . append ( STR_ ) ; int p = pos . getPiece ( Position . getSquare ( x , y ) ) ; if ( p == Piece . EMPTY ) { boolean dark = Position . darkSquare ( x , y ) ; ret . append ( dark ? STR_ : STR_ ) ; } else { ret . append ( Piece . isWhite ( p ) ? STR_ : STR_ ) ; String pieceName = pieceToChar ( p ) ; if ( pieceName . length ( ) == NUM_ ) pieceName = STR_ ; ret . append ( pieceName ) ; ret . append ( STR_ ) ; } } ret . append ( nl ) ; ret . append ( STR_ ) ; ret . append ( nl ) ; } return ret . toString ( ) ; }
public final void clear ( ) { caches . clear ( ) ; sections . clear ( ) ; }
static Set < Node > toNodeSet ( Iterator < Node > i ) { Set < Node > nodeSet = new HashSet < Node > ( ) ; while ( i . hasNext ( ) ) { Node n = i . next ( ) ; nodeSet . add ( n ) ; if ( n . getNodeType ( ) == Node . ELEMENT_NODE ) { NamedNodeMap nnm = n . getAttributes ( ) ; for ( int j = NUM_ , length = nnm . getLength ( ) ; j < length ; j ++ ) { nodeSet . add ( nnm . item ( j ) ) ; } } } return nodeSet ; }
public static void runConcurrently ( final Callable < Void > task , final int times ) throws Exception { final ExecutorService service = Executors . newFixedThreadPool ( NUM_ ) ; final List < Future < ? > > futures = new ArrayList < Future < ? > > ( ) ; for ( int i = NUM_ ; i < times ; i ++ ) { futures . add ( service . submit ( task ) ) ; } for ( final Future < ? > future : futures ) { future . get ( ) ; } }
private static ArrayList < ContainerVm > createVmList ( int brokerId , int containerVmsNumber ) { ArrayList < ContainerVm > containerVms = new ArrayList < ContainerVm > ( ) ; for ( int i = NUM_ ; i < containerVmsNumber ; ++ i ) { ArrayList < ContainerPe > peList = new ArrayList < ContainerPe > ( ) ; int vmType = i / ( int ) Math . ceil ( ( double ) containerVmsNumber / NUM_ ) ; for ( int j = NUM_ ; j < ConstantsExamples . VM_PES [ vmType ] ; ++ j ) { peList . add ( new ContainerPe ( j , new CotainerPeProvisionerSimple ( ( double ) ConstantsExamples . VM_MIPS [ vmType ] ) ) ) ; } containerVms . add ( new PowerContainerVm ( IDs . pollId ( ContainerVm . class ) , brokerId , ( double ) ConstantsExamples . VM_MIPS [ vmType ] , ( float ) ConstantsExamples . VM_RAM [ vmType ] , ConstantsExamples . VM_BW , ConstantsExamples . VM_SIZE , STR_ , new ContainerSchedulerTimeSharedOverSubscription ( peList ) , new ContainerRamProvisionerSimple ( ConstantsExamples . VM_RAM [ vmType ] ) , new ContainerBwProvisionerSimple ( ConstantsExamples . VM_BW ) , peList , ConstantsExamples . SCHEDULING_INTERVAL ) ) ; } return containerVms ; }
public static void addPortUse ( Map < StoragePort , Integer > portUseCounts , StoragePort port ) { if ( ! portUseCounts . containsKey ( port ) ) { portUseCounts . put ( port , NUM_ ) ; } else { Integer newCount = portUseCounts . get ( port ) + NUM_ ; portUseCounts . put ( port , newCount ) ; } }
public void popElemAttributeSet ( ) { m_attrSetStack . pop ( ) ; }
private byte [ ] createPreviewBuffer ( Size previewSize ) { int bitsPerPixel = ImageFormat . getBitsPerPixel ( ImageFormat . NV21 ) ; long sizeInBits = previewSize . getHeight ( ) . previewSize . getWidth ( ) . bitsPerPixel ; int bufferSize = ( int ) Math . ceil ( sizeInBits / NUM_ ) + NUM_ ; byte [ ] byteArray = new byte [ bufferSize ] ; ByteBuffer buffer = ByteBuffer . wrap ( byteArray ) ; if ( ! buffer . hasArray ( ) || ( buffer . array ( ) != byteArray ) ) { throw new IllegalStateException ( STR_ ) ; } mBytesToByteBuffer . put ( byteArray , buffer ) ; return byteArray ; }
@ Override public synchronized CacheObject < V > put ( K key , CacheObject < V > value ) { if ( cache . size ( ) >= maxSize ) { if ( removeExpired ( ) <= NUM_ ) { if ( cacheFullRemoveType instanceof RemoveTypeNotRemove ) { return null ; } if ( fullRemoveOne ( ) == null ) { return null ; } } } value . setEnterTime ( System . currentTimeMillis ( ) ) ; cache . put ( key , value ) ; return value ; }
public Criteria createCriteria ( ) { Criteria criteria = createCriteriaInternal ( ) ; if ( oredCriteria . size ( ) == NUM_ ) { oredCriteria . add ( criteria ) ; } return criteria ; }
public void removeModelChange ( String tableName , ModelValidator listener ) { if ( tableName == null || listener == null ) return ; String propertyName = m_globalValidators . contains ( listener ) ? tableName + STR_ : tableName + listener . getAD_Client_ID ( ) ; ArrayList < ModelValidator > list = m_modelChangeListeners . get ( propertyName ) ; if ( list == null ) return ; list . remove ( listener ) ; if ( list . size ( ) == NUM_ ) m_modelChangeListeners . remove ( propertyName ) ; }
protected void fireChangeEvent ( ) { Iterator iter = m_listeners . iterator ( ) ; ChangeEvent evt = new ChangeEvent ( this ) ; while ( iter . hasNext ( ) ) { ChangeListener cl = ( ChangeListener ) iter . next ( ) ; cl . stateChanged ( evt ) ; } }
private String createConnectionName ( ) { StringBuilder nameBuffer = new StringBuilder ( ) ; nameBuffer . append ( getConnectionType ( ) ) ; nameBuffer . append ( STR_ ) ; nameBuffer . append ( _host ) ; nameBuffer . append ( STR_ ) ; nameBuffer . append ( _port ) ; return nameBuffer . toString ( ) ; }
public Query execute ( PageContext pc , SQL sql , int maxrows , int fetchsize , TimeSpan timeout ) throws PageException { Stopwatch stopwatch = new Stopwatch ( Stopwatch . UNIT_NANO ) ; stopwatch . start ( ) ; String prettySQL = null ; Selects selects = null ; try { SelectParser parser = new SelectParser ( ) ; selects = parser . parse ( sql . getSQLString ( ) ) ; Query q = qoq . execute ( pc , sql , selects , maxrows ) ; q . setExecutionTime ( stopwatch . time ( ) ) ; return q ; } catch ( SQLParserException spe ) { prettySQL = SQLPrettyfier . prettyfie ( sql . getSQLString ( ) ) ; try { Query query = executer . execute ( pc , sql , prettySQL , maxrows ) ; query . setExecutionTime ( stopwatch . time ( ) ) ; return query ; } catch ( PageException ex ) { } } catch ( PageException e ) { } try { boolean isUnion = BOOL_ ; Set < String > tables = null ; if ( selects != null ) { HSQLUtil2 hsql2 = new HSQLUtil2 ( selects ) ; isUnion = hsql2 . isUnion ( ) ; tables = hsql2 . getInvokedTables ( ) ; } else { if ( prettySQL == null ) prettySQL = SQLPrettyfier . prettyfie ( sql . getSQLString ( ) ) ; HSQLUtil hsql = new HSQLUtil ( prettySQL ) ; tables = hsql . getInvokedTables ( ) ; isUnion = hsql . isUnion ( ) ; } String strSQL = StringUtil . replace ( sql . getSQLString ( ) , STR_ , STR_ , BOOL_ ) ; strSQL = StringUtil . replace ( strSQL , STR_ , STR_ , BOOL_ ) ; sql . setSQLString ( strSQL ) ; return _execute ( pc , sql , maxrows , fetchsize , timeout , stopwatch , tables , isUnion ) ; } catch ( ParseException e ) { throw new DatabaseException ( e . getMessage ( ) , null , sql , null ) ; } }
@ POST @ Produces ( { MediaType . APPLICATION_XML , MediaType . APPLICATION_JSON } ) @ Path ( STR_ ) @ CheckPermission ( roles = { Role . TENANT_ADMIN } ) public TaskResourceRep discoverHost ( @ PathParam ( STR_ ) URI id ) { ArgValidator . checkFieldUriType ( id , Host . class , STR_ ) ; Host host = queryObject ( Host . class , id , BOOL_ ) ; return doDiscoverHost ( host ) ; }
public static final void readFully ( InputStream i , byte b [ ] , int off , int len ) throws IOException { if ( len < NUM_ ) { throw new IndexOutOfBoundsException ( ) ; } int n = NUM_ ; while ( n < len ) { int count = i . read ( b , off + n , len - n ) ; if ( count < NUM_ ) { throw new EOFException ( ) ; } n += count ; } }
private void drawLines ( Canvas canvas ) { for ( int i = NUM_ ; i < connectionOrder . size ( ) - NUM_ ; i ++ ) { drawLine ( canvas , circles [ connectionOrder . get ( i ) ] , circles [ connectionOrder . get ( i + NUM_ ) ] ) ; } }
private void addOrUpdateNode ( AStarNode newNode ) { boolean found = BOOL_ ; for ( AStarNode toUpdate : closedNodes ) { if ( newNode . equals ( toUpdate ) ) { toUpdate . updateDistance ( newNode . getG ( ) , newNode . parent ) ; found = BOOL_ ; break ; } } if ( ! found ) { openQueue . offer ( newNode ) ; } }
public static File toFile ( JavaFileObject javaFileObject ) { return new File ( javaFileObject . getName ( ) ) ; }
private void signalNotEmpty ( ) { final ReentrantLock takeLock = this . takeLock ; takeLock . lock ( ) ; try { notEmpty . signal ( ) ; } finally { takeLock . unlock ( ) ; } }
public WritableRaster createCompatibleWritableRaster ( int w , int h ) { int [ ] bOffs = { NUM_ , NUM_ , NUM_ } ; return Raster . createInterleavedRaster ( DataBuffer . TYPE_BYTE , w , h , w . NUM_ , NUM_ , bOffs , null ) ; }
public static MultiSegmentPowerLawBipartiteGraph buildRandomMultiSegmentBipartiteGraph ( int maxNumSegments , int maxNumEdgesPerSegment , int leftSize , int rightSize , double edgeProbability , Random random ) { MultiSegmentPowerLawBipartiteGraph multiSegmentPowerLawBipartiteGraph = new MultiSegmentPowerLawBipartiteGraph ( maxNumSegments , maxNumEdgesPerSegment , leftSize / NUM_ , ( int ) ( rightSize . edgeProbability / NUM_ ) , NUM_ , rightSize / NUM_ , ( int ) ( leftSize . edgeProbability / NUM_ ) , NUM_ , new IdentityEdgeTypeMask ( ) , new NullStatsReceiver ( ) ) ; for ( int i = NUM_ ; i < leftSize ; i ++ ) { for ( int j = NUM_ ; j < rightSize ; j ++ ) { if ( random . nextDouble ( ) < edgeProbability ) { multiSegmentPowerLawBipartiteGraph . addEdge ( i , j , ( byte ) NUM_ ) ; } } } return multiSegmentPowerLawBipartiteGraph ; }
public static String execute ( String command ) { return SubprocessUttility . execute ( command ) ; }
public synchronized void updateProgress ( final int value ) { final Thread t = Thread . currentThread ( ) ; final MyInteger v = mIndividualThreadProgress . get ( t ) ; if ( v == null ) { mIndividualThreadProgress . put ( t , new MyInteger ( value ) ) ; } else { v . setValue ( value ) ; } if ( value > mLastReportedProgress ) { int min = Integer . MAX_VALUE ; for ( final MyInteger m : mIndividualThreadProgress . values ( ) ) { if ( m . getValue ( ) < min ) { min = m . getValue ( ) ; } } if ( min > mLastReportedProgress ) { mLastReportedProgress = min ; Diagnostic . progress ( STR_ + min + STR_ + mName ) ; } } }
private ContextHandler createContextHandler ( String directory , boolean isInJar , File installRootDirectory , int expiresInSeconds ) { final ContextHandler contextHandler = new ContextHandler ( ) ; final ResourceHandler resourceHandler = new ExpiresResourceHandler ( expiresInSeconds ) ; final String directoryWithSlash = STR_ + directory ; contextHandler . setContextPath ( directoryWithSlash ) ; Resource directoryResource = getDirectoryResource ( directory , isInJar , installRootDirectory ) ; directoryResource = new JsMinifyingResource ( directoryResource ) ; if ( isInJar ) { directoryResource = new CachingResource ( directoryResource , directoryWithSlash ) ; } resourceHandler . setBaseResource ( directoryResource ) ; if ( ! isInJar ) { resourceHandler . setMinMemoryMappedContentLength ( NUM_ ) ; } contextHandler . setHandler ( resourceHandler ) ; return contextHandler ; }
public boolean startsWith ( java . lang . CharSequence prefix ) { return startsWith ( prefix , NUM_ ) ; }
private List < ContainerInitializer > jspInitializers ( ) { JettyJasperInitializer sci = new JettyJasperInitializer ( ) ; ContainerInitializer initializer = new ContainerInitializer ( sci , null ) ; List < ContainerInitializer > initializers = new ArrayList < ContainerInitializer > ( ) ; initializers . add ( initializer ) ; return initializers ; }
public static TempPath createDirectory ( ) throws IOException { return wrap ( Files . createTempDirectory ( PREFIX ) ) ; }
public static String toString ( int partition [ ] [ ] ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( STR_ ) ; for ( int i = NUM_ ; i < partition . length ; i ++ ) { sb . append ( STR_ + Arrays . toString ( partition [ i ] ) ) ; } sb . append ( STR_ ) ; return sb . toString ( ) ; }
public static boolean isCategoryChildOf ( ServletRequest request , String parentProductCategoryId , String productCategoryId ) { return isCategoryChildOf ( ( Delegator ) request . getAttribute ( STR_ ) , ( LocalDispatcher ) request . getAttribute ( STR_ ) , parentProductCategoryId , productCategoryId ) ; }
@ Override public boolean input ( Instance instance ) { if ( getInputFormat ( ) == null ) { throw new IllegalStateException ( STR_ ) ; } if ( m_NewBatch ) { resetQueue ( ) ; m_NewBatch = BOOL_ ; } push ( ( Instance ) instance . copy ( ) ) ; return BOOL_ ; }
public Collection < String > listColumns ( String table ) throws DatabaseException { Collection < String > result = new ArrayList < String > ( ) ; ResultSet rs = null ; try { DatabaseMetaData dbm = connection . getMetaData ( ) ; rs = dbm . getColumns ( null , null , table , null ) ; while ( rs . next ( ) ) { result . add ( rs . getString ( STR_ ) ) ; } } catch ( SQLException e ) { throw new DatabaseException ( e ) ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( SQLException e ) { } } } return result ; }
public void addCreatedResource ( Location location , Resource resource ) { resourceList . add ( resource ) ; locationToResourceMap . put ( location , resource ) ; }
public void signalEvent ( ) { Collection < Semaphore > semaphores = _semaphores . values ( ) ; for ( Semaphore semaphore : semaphores ) { semaphore . release ( ) ; semaphores . remove ( semaphore ) ; } }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return BOOL_ ; } if ( ! ( obj instanceof KeyedObjects ) ) { return BOOL_ ; } KeyedObjects that = ( KeyedObjects ) obj ; int count = getItemCount ( ) ; if ( count != that . getItemCount ( ) ) { return BOOL_ ; } for ( int i = NUM_ ; i < count ; i ++ ) { Comparable k1 = getKey ( i ) ; Comparable k2 = that . getKey ( i ) ; if ( ! k1 . equals ( k2 ) ) { return BOOL_ ; } Object o1 = getObject ( i ) ; Object o2 = that . getObject ( i ) ; if ( o1 == null ) { if ( o2 != null ) { return BOOL_ ; } } else { if ( ! o1 . equals ( o2 ) ) { return BOOL_ ; } } } return BOOL_ ; }
protected boolean isQuorumMaintained ( ) { if ( nodeCount == NUM_ ) { log . info ( STR_ ) ; return BOOL_ ; } int quorumNodeCnt = nodeCount / NUM_ + NUM_ ; CoordinatorClient coordinatorClient = coordinator . getCoordinatorClient ( ) ; List < Service > allActiveDbsvcs = coordinatorClient . locateAllSvcsAllVers ( Constants . DBSVC_NAME ) ; List < String > otherActiveDbsvcIds = new ArrayList < > ( ) ; String mySvcId = coordinator . getMySvcId ( ) ; String localDbSvcId = STR_ + mySvcId . substring ( mySvcId . lastIndexOf ( STR_ ) ) ; for ( Service activeDbsvc : allActiveDbsvcs ) { if ( ! localDbSvcId . equals ( activeDbsvc . getId ( ) ) ) { otherActiveDbsvcIds . add ( activeDbsvc . getId ( ) ) ; } } log . info ( STR_ , otherActiveDbsvcIds , quorumNodeCnt ) ; boolean isMaintained = otherActiveDbsvcIds . size ( ) >= quorumNodeCnt ; if ( ! isMaintained ) { log . info ( STR_ ) ; } return isMaintained ; }
public static void scheduleNextAlarm ( Context context ) { scheduleNextAlarm ( context , AlertUtils . createAlarmManager ( context ) , REMINDER_QUERY_BATCH_SIZE , System . currentTimeMillis ( ) ) ; }
public void requestStop ( ) { stopRequested . set ( BOOL_ ) ; }
public void test_engineCreateSSLEngine_02 ( ) { int [ ] invalid_port = { Integer . MIN_VALUE , - NUM_ , - NUM_ , NUM_ , Integer . MAX_VALUE } ; SSLContextSpiImpl ssl = new SSLContextSpiImpl ( ) ; try { SSLEngine sleng = ssl . engineCreateSSLEngine ( STR_ , NUM_ ) ; fail ( STR_ ) ; } catch ( RuntimeException re ) { String str = re . getMessage ( ) ; if ( ! str . equals ( STR_ ) ) fail ( STR_ + str ) ; } catch ( Exception e ) { fail ( STR_ + e + STR_ ) ; } for ( int i = NUM_ ; i < invalid_port . length ; i ++ ) { try { SSLEngine sleng = ssl . engineCreateSSLEngine ( STR_ , invalid_port [ i ] ) ; fail ( STR_ ) ; } catch ( IllegalArgumentException iae ) { } } }
@ SafeVarargs public static < T > T [ ] join ( IntFunction < T [ ] > arrayFunction , T [ ] ... arrays ) { if ( arrays . length == NUM_ ) { return arrayFunction . apply ( NUM_ ) ; } if ( arrays . length == NUM_ ) { return arrays [ NUM_ ] ; } if ( arrays . length == NUM_ ) { return join ( arrayFunction , arrays [ NUM_ ] , arrays [ NUM_ ] ) ; } T [ ] notNull = null ; int finalSize = NUM_ ; int nullArrays = NUM_ ; List < T > list = new ArrayList < > ( arrays . length . NUM_ ) ; for ( T [ ] array : arrays ) { if ( ( array == null ) || ( array . length == NUM_ ) ) { nullArrays ++ ; } else { notNull = array ; finalSize += array . length ; Collections . addAll ( list , array ) ; } } if ( nullArrays == arrays . length ) { return arrayFunction . apply ( NUM_ ) ; } if ( nullArrays == ( arrays . length - NUM_ ) ) { return notNull ; } return list . toArray ( arrayFunction . apply ( list . size ( ) ) ) ; }
private static Set < String > splitPath ( RelaxedURL url ) { Set < String > results = new HashSet < String > ( ) ; Set < String > queries = normalizeQuery ( url . getQuery ( ) ) ; results . add ( STR_ ) ; for ( String q : queries ) { results . add ( STR_ + q ) ; } Set < String > paths = splitPath ( url . getPath ( ) ) ; results . addAll ( paths ) ; for ( String p : paths ) { for ( String q : queries ) { results . add ( p + STR_ + q ) ; } } return results ; }
public ActionForward initBestSellingReport ( ActionMapping mapping , ActionForm form , HttpServletRequest request , HttpServletResponse response ) throws ApplicationException , OperationException { ActionForward fwd = init ( mapping , form , request , response ) ; if ( fwd != null ) return fwd ; SellingItemForm reportForm = ( SellingItemForm ) form ; String timePeriod = ReportDateManager . TODAY ; String dateRange = Constants . FIXED_DATE_RANGE ; reportForm . setTimePeriod ( timePeriod ) ; reportForm . setDateRange ( dateRange ) ; reportForm . setFromDate ( STR_ ) ; reportForm . setToDate ( STR_ ) ; reportForm . validate ( mapping , request ) ; return mapping . findForward ( INIT_BEST_SELLING_REPORT ) ; }
@ Override public void transactionBegin ( ) { for ( BigdataGraphListener listener : listeners ) { listener . transactionBegin ( ) ; } }
public synchronized void add ( Job job ) { boolean canRunImmediately = dagManager . addJob ( job ) ; if ( canRunImmediately ) { LOG . debug ( STR_ + job + STR_ ) ; jobsToRun . add ( job ) ; } incrementSubmittedJobCount ( ) ; }
public void reset ( String latex ) { parseString = new StringBuffer ( latex ) ; len = parseString . length ( ) ; formula . root = null ; pos = NUM_ ; spos = NUM_ ; line = NUM_ ; col = NUM_ ; group = NUM_ ; insertion = BOOL_ ; atIsLetter = NUM_ ; arrayMode = BOOL_ ; ignoreWhiteSpace = BOOL_ ; firstpass ( ) ; }
public void addConstant ( ConstantPoolEntry entry ) { if ( entry instanceof Utf8Constant ) { Utf8Constant utf8 = ( Utf8Constant ) entry ; _utf8Map . put ( utf8 . getValue ( ) , utf8 ) ; } _entries . add ( entry ) ; }
public void addData ( ArrayList < ChartSet > data ) { this . data = data ; }
public final double infoGain ( ) { return m_infoGain ; }
static void writeRule ( ZoneOffsetTransitionRule rule , DataOutput out ) throws IOException { int month = rule . month ; byte dom = rule . dom ; int dow = rule . dow ; LocalTime time = rule . time ; boolean timeEndOfDay = rule . timeEndOfDay ; TimeDefinition timeDefinition = rule . timeDefinition ; ZoneOffset standardOffset = rule . standardOffset ; ZoneOffset offsetBefore = rule . offsetBefore ; ZoneOffset offsetAfter = rule . offsetAfter ; int timeSecs = ( timeEndOfDay ? NUM_ : time . toSecondOfDay ( ) ) ; int stdOffset = standardOffset . getTotalSeconds ( ) ; int beforeDiff = offsetBefore . getTotalSeconds ( ) - stdOffset ; int afterDiff = offsetAfter . getTotalSeconds ( ) - stdOffset ; int timeByte = ( timeSecs % NUM_ == NUM_ ? ( timeEndOfDay ? NUM_ : time . getHour ( ) ) : NUM_ ) ; int stdOffsetByte = ( stdOffset % NUM_ == NUM_ ? stdOffset / NUM_ + NUM_ : NUM_ ) ; int beforeByte = ( beforeDiff == NUM_ || beforeDiff == NUM_ || beforeDiff == NUM_ ? beforeDiff / NUM_ : NUM_ ) ; int afterByte = ( afterDiff == NUM_ || afterDiff == NUM_ || afterDiff == NUM_ ? afterDiff / NUM_ : NUM_ ) ; int dowByte = ( dow == - NUM_ ? NUM_ : dow ) ; int b = ( month << NUM_ ) + ( ( dom + NUM_ ) << NUM_ ) + ( dowByte << NUM_ ) + ( timeByte << NUM_ ) + ( timeDefinition . ordinal ( ) << NUM_ ) + ( stdOffsetByte << NUM_ ) + ( beforeByte << NUM_ ) + afterByte ; out . writeInt ( b ) ; if ( timeByte == NUM_ ) { out . writeInt ( timeSecs ) ; } if ( stdOffsetByte == NUM_ ) { out . writeInt ( stdOffset ) ; } if ( beforeByte == NUM_ ) { out . writeInt ( offsetBefore . getTotalSeconds ( ) ) ; } if ( afterByte == NUM_ ) { out . writeInt ( offsetAfter . getTotalSeconds ( ) ) ; } }
boolean cancel ( int propertyConstant ) { if ( ( mPropertyMask & propertyConstant ) != NUM_ && mNameValuesHolder != null ) { int count = mNameValuesHolder . size ( ) ; for ( int i = NUM_ ; i < count ; ++ i ) { NameValuesHolder nameValuesHolder = mNameValuesHolder . get ( i ) ; if ( nameValuesHolder . mNameConstant == propertyConstant ) { mNameValuesHolder . remove ( i ) ; mPropertyMask &= ~ propertyConstant ; return BOOL_ ; } } } return BOOL_ ; }
@ SuppressWarnings ( STR_ ) public static < T > TypeSerializer < T > deserialize ( byte [ ] bytes ) throws IOException { ByteArrayInputStream bis = new ByteArrayInputStream ( bytes ) ; ObjectInput in = null ; try { in = new ObjectInputStream ( bis ) ; return ( TypeSerializer < T > ) in . readObject ( ) ; } catch ( ClassNotFoundException e ) { throw new IOException ( STR_ ) ; } finally { try { bis . close ( ) ; } catch ( IOException ex ) { } try { if ( in != null ) { in . close ( ) ; } } catch ( IOException ex ) { } } }
public void testRemainderKnuthMultiDigitsByOneDigit ( ) { byte aBytes [ ] = { NUM_ , - NUM_ , NUM_ , - NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ } ; byte bBytes [ ] = { NUM_ , - NUM_ , - NUM_ , - NUM_ } ; int aSign = NUM_ ; int bSign = - NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , - NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . remainder ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public void showSelectedNeuronProperties ( ) { NeuronDialog dialog = NeuronDialog . createNeuronDialog ( getSelectedNeurons ( ) ) ; dialog . setModalityType ( Dialog . ModalityType . MODELESS ) ; dialog . pack ( ) ; dialog . setLocationRelativeTo ( null ) ; dialog . setVisible ( BOOL_ ) ; }
public void encrypt ( byte [ ] in , int length ) { int pos = NUM_ ; while ( pos < in . length && pos < length ) { encryptBlock ( in , pos , length ) ; pos += blockSize ; } }
private static boolean hasChangesOfChildren ( long last , PageContext pc , Class clazz ) { java . lang . reflect . Method [ ] methods = clazz . getMethods ( ) ; java . lang . reflect . Method method ; Class [ ] params ; for ( int i = NUM_ ; i < methods . length ; i ++ ) { method = methods [ i ] ; if ( method . getDeclaringClass ( ) == clazz ) { if ( _hasChangesOfChildren ( pc , last , method . getReturnType ( ) ) ) return BOOL_ ; params = method . getParameterTypes ( ) ; for ( int y = NUM_ ; y < params . length ; y ++ ) { if ( _hasChangesOfChildren ( pc , last , params [ y ] ) ) return BOOL_ ; } } } return BOOL_ ; }
public static String removeSpecialChar ( String tempStr ) { if ( tempStr != null ) { tempStr = replace ( tempStr , STR_ , STR_ , BOOL_ , BOOL_ ) ; tempStr = replace ( tempStr , STR_ , STR_ , BOOL_ , BOOL_ ) ; tempStr = replace ( tempStr , STR_ , STR_ , BOOL_ , BOOL_ ) ; tempStr = replace ( tempStr , STR_ , STR_ , BOOL_ , BOOL_ ) ; tempStr = replace ( tempStr , STR_ , STR_ , BOOL_ , BOOL_ ) ; tempStr = replace ( tempStr , STR_ , STR_ , BOOL_ , BOOL_ ) ; tempStr = replace ( tempStr , STR_ , STR_ , BOOL_ , BOOL_ ) ; tempStr = replace ( tempStr , STR_ , STR_ , BOOL_ , BOOL_ ) ; tempStr = replace ( tempStr , STR_ , STR_ , BOOL_ , BOOL_ ) ; tempStr = replace ( tempStr , STR_ , STR_ , BOOL_ , BOOL_ ) ; tempStr = replace ( tempStr , STR_ , STR_ , BOOL_ , BOOL_ ) ; tempStr = replace ( tempStr , STR_ , STR_ , BOOL_ , BOOL_ ) ; tempStr = replace ( tempStr , STR_ , STR_ , BOOL_ , BOOL_ ) ; while ( tempStr . indexOf ( STR_ ) > NUM_ ) { tempStr = replace ( tempStr , STR_ , STR_ , BOOL_ , BOOL_ ) ; } tempStr = replace ( tempStr , STR_ , STR_ , BOOL_ , BOOL_ ) ; } return tempStr ; }
public RunScriptAction ( NetworkPanel networkPanel ) { super ( STR_ ) ; putValue ( SMALL_ICON , ResourceManager . getImageIcon ( STR_ ) ) ; putValue ( SHORT_DESCRIPTION , STR_ ) ; this . networkPanel = networkPanel ; }
public T webImage ( String url ) { return webImage ( url , BOOL_ , BOOL_ , xFF000000 ) ; }
private Map < Installment , List < Receipt > > consolidateTuplesInstallmentWise ( final List < InstallmentReceiptTuple > tuples ) { final Map < Installment , List < Receipt > > consolidated = new HashMap < Installment , List < Receipt > > ( ) ; for ( final InstallmentReceiptTuple t : tuples ) { List < Receipt > receiptsForInstallment = consolidated . get ( t . installment ) ; if ( receiptsForInstallment == null ) { receiptsForInstallment = new ArrayList < Receipt > ( ) ; consolidated . put ( t . installment , receiptsForInstallment ) ; } if ( ! receiptsForInstallment . contains ( t . receipt ) ) receiptsForInstallment . add ( t . receipt ) ; } LOGGER . info ( STR_ + consolidated ) ; return consolidated ; }
public static boolean isValidEmail ( String email ) { final String emailPattern = STR_ ; Matcher matcher ; Pattern pattern = Pattern . compile ( emailPattern ) ; matcher = pattern . matcher ( email ) ; if ( matcher != null ) return matcher . matches ( ) ; else return BOOL_ ; }
public void add ( LineMergeDirectedEdge directedEdge ) { directedEdges . add ( directedEdge ) ; }
public static ApplicationXml parseApplicationXmlFromFile ( File file , EntityResolver entityResolver ) throws IOException , JDOMException { InputStream in = null ; try { in = new FileInputStream ( file ) ; return parseApplicationXml ( in , entityResolver ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IOException ioe ) { } } } }
public ChannelEntry newConnection ( ReadSelectorThread readHandler , SelectionKey key ) { SocketChannel channel = ( SocketChannel ) key . channel ( ) ; WriteSelectorThread writeHandler = _selectorManager . getWriteHandler ( key . channel ( ) ) ; Socket socket = channel . socket ( ) ; InetSocketAddress socketAddress = ( InetSocketAddress ) ( socket == null ? null : socket . getRemoteSocketAddress ( ) ) ; ChannelEntry channelEntry = new ChannelEntry ( writeHandler , readHandler , key , socketAddress , this ) ; m_Channels . put ( channel , channelEntry ) ; if ( socketAddress != null ) { _clientToChannel . put ( socketAddress , channelEntry ) ; } if ( _logger . isLoggable ( Level . FINE ) ) _logger . log ( Level . FINE , STR_ + channelEntry . getClientEndPointAddress ( ) + STR_ ) ; return channelEntry ; }
public static boolean isExtension ( String filename , String extension ) { if ( filename == null ) { return BOOL_ ; } if ( extension == null || extension . length ( ) == NUM_ ) { return indexOfExtension ( filename ) == - NUM_ ; } String fileExt = getExtension ( filename ) ; return fileExt . equals ( extension ) ; }
public String report ( ) { StringBuffer report = new StringBuffer ( ) ; intHashTable = new int [ table . tableSize ] ; calculateSlotUsage ( ) ; int max = maxCollisions ( ) ; int [ ] slotUsageCount = new int [ max + NUM_ ] ; for ( int i : intHashTable ) { slotUsageCount [ i ] ++ ; } report . append ( STR_ + numEntries + STR_ ) ; report . append ( STR_ + ( numEntries / ( NUM_ . table . tableSize ) + STR_ ) ) ; float weightedAvg = NUM_ ; int numNonEmpty = NUM_ ; report . append ( STR_ ) ; for ( int j = NUM_ ; j <= max ; j ++ ) { if ( slotUsageCount [ j ] != NUM_ ) { report . append ( j + STR_ + slotUsageCount [ j ] + STR_ ) ; if ( j != NUM_ ) { weightedAvg += slotUsageCount [ j ] . j ; numNonEmpty += slotUsageCount [ j ] ; } } } weightedAvg /= numNonEmpty ; report . append ( STR_ + minCollisions ( ) + STR_ + max + STR_ + weightedAvg ) ; return report . toString ( ) ; }
public void addSubscriptionToStore ( final String topic , final String clientId ) { final ClientTopicCouple subscription = new ClientTopicCouple ( clientId , topic ) ; if ( ! topics . contains ( subscription ) ) { logger . debug ( STR_ + topic + STR_ + clientId + STR_ ) ; subscriptionsStore . add ( subscription ) ; topics . add ( topic ) ; } }
public boolean zip ( String zipLocation , String toBeZippedName ) { boolean ret = BOOL_ ; if ( verbose ) Debug . put ( STR_ ) ; File toBeZipped = new File ( toBeZippedName ) ; if ( toBeZipped . exists ( ) ) { try { FileUtils . saveZipFile ( zipLocation , toBeZipped ) ; ret = BOOL_ ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return ret ; }
private HashMap < Integer , Boolean > generateExpandedStateMap ( ) { HashMap < Integer , Boolean > parentListItemHashMap = new HashMap < > ( ) ; int childCount = NUM_ ; Object listItem ; ParentWrapper parentWrapper ; int listItemCount = mItemList . size ( ) ; for ( int i = NUM_ ; i < listItemCount ; i ++ ) { if ( mItemList . get ( i ) != null ) { listItem = getListItem ( i ) ; if ( listItem instanceof ParentWrapper ) { parentWrapper = ( ParentWrapper ) listItem ; parentListItemHashMap . put ( i - childCount , parentWrapper . isExpanded ( ) ) ; } else { childCount ++ ; } } } return parentListItemHashMap ; }
public void addAudioPacketListener ( Listener < AudioPacket > listener ) { mAudioPacketBroadcaster . addListener ( listener ) ; }
public static boolean decodeToFile ( String dataToDecode , String filename ) { boolean success = BOOL_ ; Base64 . OutputStream bos = null ; try { bos = new Base64 . OutputStream ( new java . io . FileOutputStream ( filename ) , Base64 . DECODE ) ; bos . write ( dataToDecode . getBytes ( PREFERRED_ENCODING ) ) ; success = BOOL_ ; } catch ( java . io . IOException e ) { success = BOOL_ ; } finally { try { bos . close ( ) ; } catch ( Exception e ) { } } return success ; }
public DeltaCRLIndicatorExtension ( Boolean critical , Object value ) throws IOException { super ( PKIXExtensions . DeltaCRLIndicator_Id , critical . booleanValue ( ) , value , NAME , LABEL ) ; }
public JavaEnvironment ( File javaPath ) { Objects . requireNonNull ( javaPath ) ; this . javaPath = javaPath ; }
private String printOFormat ( final long x ) { String sx = null ; if ( x == Long . MIN_VALUE ) { sx = STR_ ; } else if ( x < NUM_ ) { final String t = Long . toString ( ( ~ ( - x - NUM_ ) ) ^ Long . MIN_VALUE , NUM_ ) ; switch ( t . length ( ) ) { case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; } } else { sx = Long . toString ( x , NUM_ ) ; } return printOFormat ( sx ) ; }
void addCallback ( JSObject source , String method , JSFunction callback , boolean async ) { String key = source . toJSPointer ( ) + STR_ + method ; callbacks . put ( key , callback ) ; String id = JSObject . ID_KEY ; String self = source . toJSPointer ( ) ; String js = self + STR_ + method + STR_ + STR_ + self + STR_ + method + STR_ + STR_ + STR_ + STR_ + STR_ + id + STR_ + STR_ + jsLookupTable + STR_ + jsLookupTable + STR_ + id + STR_ + jsLookupTable + STR_ + jsLookupTable + STR_ + id + STR_ + STR_ + STR_ + jsLookupTable + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; exec ( js , async ) ; }
public void removeAllBlocksFromSection ( ) { for ( int i = mBlockEntries . size ( ) ; i > NUM_ ; i -- ) { Block b = mBlockEntries . get ( i - NUM_ ) ; if ( b != null ) { b . removePropertyChangeListener ( mBlockListeners . get ( i - NUM_ ) ) ; } mBlockListeners . remove ( i - NUM_ ) ; mBlockEntries . remove ( i - NUM_ ) ; } for ( int i = mForwardEntryPoints . size ( ) ; i > NUM_ ; i -- ) { mForwardEntryPoints . remove ( i - NUM_ ) ; } for ( int i = mReverseEntryPoints . size ( ) ; i > NUM_ ; i -- ) { mReverseEntryPoints . remove ( i - NUM_ ) ; } initializationNeeded = BOOL_ ; }
public static void writeStringToFile ( Path file , String text ) throws IOException { byte [ ] buf = text . getBytes ( StandardCharsets . UTF_8 ) ; Files . write ( file , buf ) ; }
private static boolean isOperatorVariableAccess ( final INaviOperandTreeNode node ) { final List < INaviOperandTreeNode > children = node . getChildren ( ) ; if ( children . size ( ) == NUM_ ) { final INaviOperandTreeNode child0 = children . get ( NUM_ ) ; final INaviOperandTreeNode child1 = children . get ( NUM_ ) ; return isVariable ( child0 ) ^ isVariable ( child1 ) ; } else { return BOOL_ ; } }
@ Override public void onValueSelected ( int pickerIndex , int newValue , boolean autoAdvance ) { if ( pickerIndex == HOUR_INDEX ) { setHour ( newValue , BOOL_ ) ; String announcement = String . format ( STR_ , newValue ) ; if ( mAllowAutoAdvance && autoAdvance ) { setCurrentItemShowing ( MINUTE_INDEX , BOOL_ , BOOL_ , BOOL_ ) ; announcement += STR_ + mSelectMinutes ; } else { mTimePicker . setContentDescription ( mHourPickerDescription + STR_ + newValue ) ; } Utils . tryAccessibilityAnnounce ( mTimePicker , announcement ) ; } else if ( pickerIndex == MINUTE_INDEX ) { setMinute ( newValue ) ; mTimePicker . setContentDescription ( mMinutePickerDescription + STR_ + newValue ) ; } else if ( pickerIndex == HALF_DAY_INDEX ) { updateHalfDay ( newValue ) ; } else if ( pickerIndex == ENABLE_PICKER_INDEX ) { if ( ! isTypedTimeFullyLegal ( ) ) { mTypedTimes . clear ( ) ; } finishKbMode ( BOOL_ ) ; } }
public static final List < Geo > segmentNearPoly ( Geo s1 , Geo s2 , GeoArray r , double near ) { int rlen = r . getSize ( ) ; Geo pl0 = r . get ( rlen - NUM_ , new Geo ( ) ) ; Geo pl1 = new Geo ( ) ; List < Geo > list = null ; Geo check = new Geo ( ) ; for ( int j = NUM_ ; j < rlen ; j ++ ) { r . get ( j , pl1 ) ; Geo ret = segmentsIntersectOrNear ( s1 , s2 , pl0 , pl1 , near , check ) ; if ( ret != null ) { if ( list == null ) { list = new LinkedList < Geo > ( ) ; } list . add ( ret ) ; check = new Geo ( ) ; } pl0 . initialize ( pl1 ) ; } return list ; }
public void addAction ( UpdateAction action ) { actionList . add ( action ) ; for ( UpdateManagerListener listener : listeners ) { listener . actionAdded ( action ) ; } }
public void load ( DataInput rafIn ) throws IOException , MaryConfigurationException { int numIdx = rafIn . readInt ( ) ; idxInterval = rafIn . readInt ( ) ; if ( idxInterval <= NUM_ ) { throw new MaryConfigurationException ( STR_ ) ; } bytePtrs = new long [ numIdx ] ; timePtrs = new long [ numIdx ] ; int numBytesToRead = NUM_ . numIdx + NUM_ ; byte [ ] data = new byte [ numBytesToRead ] ; rafIn . readFully ( data ) ; DataInput bufIn = new DataInputStream ( new ByteArrayInputStream ( data ) ) ; for ( int i = NUM_ ; i < numIdx ; i ++ ) { bytePtrs [ i ] = bufIn . readLong ( ) ; timePtrs [ i ] = bufIn . readLong ( ) ; if ( i > NUM_ ) { if ( bytePtrs [ i ] < bytePtrs [ i - NUM_ ] || timePtrs [ i ] < timePtrs [ i - NUM_ ] ) { throw new MaryConfigurationException ( STR_ ) ; } } } bufIn . readLong ( ) ; bufIn . readLong ( ) ; }
public URL find ( String classname ) { String jarname = STR_ + classname . replace ( STR_ , STR_ ) + STR_ ; return thisClass . getResource ( jarname ) ; }
public void signoff ( String uniqueID ) { Debug . message ( STR_ , STR_ + uniqueID + STR_ ) ; caches . remove ( uniqueID ) ; viewAttributeLists . remove ( uniqueID ) ; timestamps . remove ( uniqueID ) ; }
private String createNonCGSrdfPairStepsOnEmptyGroup ( List < VolumeDescriptor > sourceDescriptors , List < VolumeDescriptor > targetDescriptors , RemoteDirectorGroup group , Map < URI , Volume > uriVolumeMap , String waitFor , Workflow workflow ) { StorageSystem system = dbClient . queryObject ( StorageSystem . class , group . getSourceStorageSystemUri ( ) ) ; URI vpoolChangeUri = getVirtualPoolChangeVolume ( sourceDescriptors ) ; log . info ( STR_ , vpoolChangeUri ) ; List < URI > sourceURIs = VolumeDescriptor . getVolumeURIs ( sourceDescriptors ) ; List < URI > targetURIs = new ArrayList < > ( ) ; for ( URI sourceURI : sourceURIs ) { Volume source = uriVolumeMap . get ( sourceURI ) ; StringSet srdfTargets = source . getSrdfTargets ( ) ; for ( String targetStr : srdfTargets ) { URI targetURI = URI . create ( targetStr ) ; targetURIs . add ( targetURI ) ; } } Method createListMethod = createListReplicasMethod ( system . getId ( ) , sourceURIs , targetURIs , vpoolChangeUri , BOOL_ ) ; Method rollbackMethod = rollbackSRDFLinksMethod ( system . getId ( ) , sourceURIs , targetURIs , BOOL_ ) ; String stepId = workflow . createStep ( CREATE_SRDF_ACTIVE_VOLUME_PAIR_STEP_GROUP , CREATE_SRDF_ACTIVE_VOLUME_PAIR_STEP_DESC , waitFor , system . getId ( ) , system . getSystemType ( ) , getClass ( ) , createListMethod , rollbackMethod , null ) ; return stepId ; }
public static Long downsamplerTimestamp ( Long millitimestamp , long windowSize ) { return millitimestamp - ( millitimestamp % windowSize ) ; }
public boolean isNavigationAtBottom ( ) { return ( mSmallestWidthDp >= NUM_ || mInPortrait ) ; }
@ Override public String toString ( ) { if ( points == null || points . length ( ) == NUM_ ) { return idx + STR_ ; } StringBuffer bf = new StringBuffer ( ) ; try { bf . append ( idx + STR_ ) ; ListNode temp ; for ( int i = NUM_ ; i < points . size ( ) ; i ++ ) { temp = points . get ( i ) ; if ( i == NUM_ ) { bf . append ( STR_ + temp . idx ) ; } else { bf . append ( STR_ + temp . idx ) ; } } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } return bf . toString ( ) ; }
public void error ( org . xml . sax . SAXParseException e ) throws org . xml . sax . SAXException { String formattedMsg = e . getMessage ( ) ; SAXSourceLocator locator = getLocator ( ) ; ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; try { handler . error ( new TransformerException ( formattedMsg , locator ) ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } }
private void putHead ( String key , TemplateSubPatternAssociation assoc ) { if ( key . equals ( PsuedoNames . PSEUDONAME_TEXT ) ) m_textPatterns = assoc ; else if ( key . equals ( PsuedoNames . PSEUDONAME_ROOT ) ) m_docPatterns = assoc ; else if ( key . equals ( PsuedoNames . PSEUDONAME_COMMENT ) ) m_commentPatterns = assoc ; m_patternTable . put ( key , assoc ) ; }
public UnionPathIterator ( Compiler compiler , int opPos ) throws javax . xml . transform . TransformerException { super ( ) ; opPos = OpMap . getFirstChildPos ( opPos ) ; loadLocationPaths ( compiler , opPos , NUM_ ) ; }
public IStatus run ( IProgressMonitor monitor ) throws InvocationTargetException { ZipFile zipFile = null ; FileOutputStream fos = null ; BufferedOutputStream dest = null ; BufferedInputStream is = null ; jobStatus = Status . OK_STATUS ; try { zipFile = new ZipFile ( archive ) ; monitor . beginTask ( STR_ + archive . getName ( ) , zipFile . size ( ) ) ; Enumeration < ? extends ZipEntry > entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { ZipEntry zipEntry = entries . nextElement ( ) ; String currentEntry = zipEntry . getName ( ) ; File destFile = new File ( targetDir , currentEntry ) ; File destinationParent = destFile . getParentFile ( ) ; if ( ! zipEntry . isDirectory ( ) ) { destinationParent . mkdirs ( ) ; is = new BufferedInputStream ( zipFile . getInputStream ( zipEntry ) ) ; int numBytesRead ; byte bytes [ ] = new byte [ BUFSIZE ] ; fos = new FileOutputStream ( destFile ) ; dest = new BufferedOutputStream ( fos , BUFSIZE ) ; while ( ( numBytesRead = is . read ( bytes , NUM_ , BUFSIZE ) ) != - NUM_ ) { dest . write ( bytes , NUM_ , numBytesRead ) ; } dest . flush ( ) ; } else { destFile . mkdirs ( ) ; } monitor . worked ( NUM_ ) ; if ( monitor . isCanceled ( ) ) { jobStatus = Status . CANCEL_STATUS ; break ; } } if ( ! monitor . isCanceled ( ) ) { jobStatus = Status . OK_STATUS ; } } catch ( ZipException ze ) { String errormsg = errorMessage ( STR_ ) ; jobStatus = new Status ( Status . ERROR , CorePlugin . PLUGIN_ID , errormsg ) ; CorePluginLog . logError ( ze , errormsg ) ; } catch ( IOException ioe ) { String errormsg = errorMessage ( ) ; jobStatus = new Status ( Status . ERROR , CorePlugin . PLUGIN_ID , errormsg ) ; CorePluginLog . logError ( ioe , errormsg ) ; } finally { try { if ( zipFile != null ) { zipFile . close ( ) ; } if ( is != null ) { is . close ( ) ; } if ( dest != null ) { dest . close ( ) ; } } catch ( IOException ioe ) { String errormsg = errorMessage ( ) ; jobStatus = new Status ( Status . ERROR , CorePlugin . PLUGIN_ID , errormsg ) ; CorePluginLog . logError ( ioe , errormsg ) ; } } return jobStatus ; }
public int read ( String table , String key , Set < String > fields , HashMap < String , ByteIterator > result ) { long st = System . nanoTime ( ) ; int res = _db . read ( table , key , fields , result ) ; long en = System . nanoTime ( ) ; _measurements . measure ( STR_ , ( int ) ( ( en - st ) / NUM_ ) ) ; _measurements . reportReturnCode ( STR_ , res ) ; return res ; }
protected void errorMessage ( String msg ) throws IOException { String str = msg + STR_ + m_Tokenizer . toString ( ) ; if ( m_Lines > NUM_ ) { int line = Integer . parseInt ( str . replaceAll ( STR_ , STR_ ) ) ; str = str . replaceAll ( STR_ , STR_ + ( m_Lines + line - NUM_ ) ) ; } throw new IOException ( str ) ; }
public boolean hasNext ( ) { if ( deal > NUM_ ) { sc . close ( ) ; } return ( deal <= NUM_ ) ; }
public void addIssuer ( X500Principal issuer ) { if ( issuer == null ) { throw new NullPointerException ( STR_ ) ; } if ( issuerNames == null ) { issuerNames = new ArrayList < String > ( ) ; } String name = issuer . getName ( X500Principal . CANONICAL ) ; if ( ! issuerNames . contains ( name ) ) { issuerNames . add ( name ) ; } if ( issuerPrincipals == null ) { issuerPrincipals = new ArrayList < X500Principal > ( issuerNames . size ( ) ) ; } int size = issuerNames . size ( ) - NUM_ ; for ( int i = issuerPrincipals . size ( ) ; i < size ; i ++ ) { issuerPrincipals . add ( new X500Principal ( issuerNames . get ( i ) ) ) ; } issuerPrincipals . add ( issuer ) ; }
static String buildKeySelection ( int selectionCount ) { String [ ] list = new String [ selectionCount ] ; Arrays . fill ( list , STR_ ) ; return KEY_COLUMN + STR_ + TextUtils . join ( STR_ , list ) + STR_ ; }
private void filterNodeMap ( ConcurrentMap < String , Collection < ClusterNode > > map , final ClusterNode exclNode ) { for ( String cacheName : registeredCaches . keySet ( ) ) { String maskedName = maskNull ( cacheName ) ; while ( BOOL_ ) { Collection < ClusterNode > oldNodes = map . get ( maskedName ) ; if ( oldNodes == null || oldNodes . isEmpty ( ) ) break ; Collection < ClusterNode > newNodes = new ArrayList < > ( oldNodes ) ; if ( ! newNodes . remove ( exclNode ) ) break ; if ( map . replace ( maskedName , oldNodes , newNodes ) ) break ; } } }
public void storeDevice ( Device d ) { if ( ! isMaster ) return ; if ( d == null ) return ; long now = System . nanoTime ( ) ; writeUpdatedDeviceToStorage ( d ) ; lastWriteTimes . put ( d . getDeviceKey ( ) , now ) ; }
public void testCreateElementNS1 ( ) throws Throwable { String namespaceURI = STR_ ; String malformedName = STR_ ; Document doc ; doc = ( Document ) load ( STR_ , builder ) ; { boolean success = BOOL_ ; try { doc . createElementNS ( namespaceURI , malformedName ) ; } catch ( DOMException ex ) { success = ( ex . code == DOMException . NAMESPACE_ERR ) ; } assertTrue ( STR_ , success ) ; } }
public synchronized IAudioProcessor remove ( int index ) { IAudioProcessor processor = processors . remove ( index ) ; buildFinalProcessor ( ) ; return processor ; }
LinkedList < TrieNode < T > > makeSuffixChain ( TrieNode < T > root , String suffix , T value ) { LinkedList < TrieNode < T > > result = new LinkedList < > ( ) ; String rootPrefix = root . getPrefix ( ) ; for ( int i = NUM_ , suffixSize = suffix . length ( ) ; i <= suffixSize ; i ++ ) { String newPrefix = rootPrefix + suffix . substring ( NUM_ , i ) ; TrieNode < T > newNode = TrieNode . makeNode ( newPrefix ) ; result . add ( newNode ) ; root . addChild ( newNode ) ; root = newNode ; } root . setValue ( value ) ; return result ; }
private static By byFromLocator ( String locator ) { if ( locator . startsWith ( STR_ ) ) { return By . xpath ( locator ) ; } if ( locator . startsWith ( STR_ ) ) { return By . id ( locator . replaceFirst ( STR_ , STR_ ) ) ; } if ( locator . startsWith ( STR_ ) ) { return By . cssSelector ( locator . replaceFirst ( STR_ , STR_ ) ) ; } if ( locator . startsWith ( STR_ ) ) { return By . xpath ( locator . replaceFirst ( STR_ , STR_ ) ) ; } if ( locator . startsWith ( STR_ ) ) { return By . name ( locator . replaceFirst ( STR_ , STR_ ) ) ; } if ( locator . startsWith ( STR_ ) ) { return By . linkText ( locator . replaceFirst ( STR_ , STR_ ) ) ; } if ( locator . startsWith ( STR_ ) ) { return By . partialLinkText ( locator . replaceFirst ( STR_ , STR_ ) ) ; } throw new IllegalArgumentException ( STR_ + locator ) ; }
private static void taskStarted ( ProgressThread task ) { for ( ProgressThreadStateListener l : listener . getListeners ( ProgressThreadStateListener . class ) ) { l . progressThreadStarted ( task ) ; } }
public static final void isCommentWF ( DOMErrorHandler errorHandler , DOMErrorImpl error , DOMLocatorImpl locator , String datavalue , boolean isXML11Version ) { if ( datavalue == null || ( datavalue . length ( ) == NUM_ ) ) { return ; } char [ ] dataarray = datavalue . toCharArray ( ) ; int datalength = dataarray . length ; if ( isXML11Version ) { int i = NUM_ ; while ( i < datalength ) { char c = dataarray [ i ++ ] ; if ( XML11Char . isXML11Invalid ( c ) ) { if ( XMLChar . isHighSurrogate ( c ) && i < datalength ) { char c2 = dataarray [ i ++ ] ; if ( XMLChar . isLowSurrogate ( c2 ) && XMLChar . isSupplemental ( XMLChar . supplemental ( c , c2 ) ) ) { continue ; } } String msg = DOMMessageFormatter . formatMessage ( DOMMessageFormatter . XML_DOMAIN , STR_ , new Object [ ] { Integer . toString ( dataarray [ i - NUM_ ] , NUM_ ) } ) ; reportDOMError ( errorHandler , error , locator , msg , DOMError . SEVERITY_ERROR , STR_ ) ; } else if ( c == STR_ && i < datalength && dataarray [ i ] == STR_ ) { String msg = DOMMessageFormatter . formatMessage ( DOMMessageFormatter . XML_DOMAIN , STR_ , null ) ; reportDOMError ( errorHandler , error , locator , msg , DOMError . SEVERITY_ERROR , STR_ ) ; } } } else { int i = NUM_ ; while ( i < datalength ) { char c = dataarray [ i ++ ] ; if ( XMLChar . isInvalid ( c ) ) { if ( XMLChar . isHighSurrogate ( c ) && i < datalength ) { char c2 = dataarray [ i ++ ] ; if ( XMLChar . isLowSurrogate ( c2 ) && XMLChar . isSupplemental ( XMLChar . supplemental ( c , c2 ) ) ) { continue ; } } String msg = DOMMessageFormatter . formatMessage ( DOMMessageFormatter . XML_DOMAIN , STR_ , new Object [ ] { Integer . toString ( dataarray [ i - NUM_ ] , NUM_ ) } ) ; reportDOMError ( errorHandler , error , locator , msg , DOMError . SEVERITY_ERROR , STR_ ) ; } else if ( c == STR_ && i < datalength && dataarray [ i ] == STR_ ) { String msg = DOMMessageFormatter . formatMessage ( DOMMessageFormatter . XML_DOMAIN , STR_ , null ) ; reportDOMError ( errorHandler , error , locator , msg , DOMError . SEVERITY_ERROR , STR_ ) ; } } } }
private void throwExceptionIfDestroyed ( String method ) throws DeepstreamRecordDestroyedException { if ( this . isDestroyed ) { throw new DeepstreamRecordDestroyedException ( method ) ; } }
public void upload ( final InputStream in , String artifact , String version , String fileName , Properties props ) throws IOException { props . put ( FILE_NAME_PROPERTY , fileName ) ; props . put ( VERSION_PROPERTY , version ) ; props . put ( ARTIFACT_PROPERTY , artifact ) ; storeProperties ( artifact , version , props ) ; try ( OutputStream out = newOutputStream ( getArtifact ( artifact , version , fileName ) ) ) { IOUtils . copyLarge ( in , out ) ; } finally { in . close ( ) ; } }
static String escapeBytes ( final ByteString input ) { final StringBuilder builder = new StringBuilder ( input . size ( ) ) ; for ( int i = NUM_ ; i < input . size ( ) ; i ++ ) { final byte b = input . byteAt ( i ) ; switch ( b ) { case x07 : builder . append ( STR_ ) ; break ; case STR_ : builder . append ( STR_ ) ; break ; case STR_ : builder . append ( STR_ ) ; break ; case STR_ : builder . append ( STR_ ) ; break ; case STR_ : builder . append ( STR_ ) ; break ; case STR_ : builder . append ( STR_ ) ; break ; case x0b : builder . append ( STR_ ) ; break ; case STR_ : builder . append ( STR_ ) ; break ; case STR_ : builder . append ( STR_ ) ; break ; case STR_ : builder . append ( STR_ ) ; break ; default : if ( b >= x20 ) { builder . append ( ( char ) b ) ; } else { builder . append ( STR_ ) ; builder . append ( ( char ) ( STR_ + ( ( b > > > NUM_ ) & NUM_ ) ) ) ; builder . append ( ( char ) ( STR_ + ( ( b > > > NUM_ ) & NUM_ ) ) ) ; builder . append ( ( char ) ( STR_ + ( b & NUM_ ) ) ) ; } break ; } } return builder . toString ( ) ; }
public void load ( ) throws IOException { if ( magicNumber == NUM_ ) { try ( InputReaderLittleEndian ins = new InputReaderLittleEndian ( new FileInputStreamAdapter ( fileName ) ) ) { magicNumber = ins . readLong ( ) ; if ( magicNumber != MAGIC_NUMBER ) throw new IOException ( STR_ ) ; version = ins . readLong ( ) ; if ( version > DAA_VERSION ) throw new IOException ( STR_ ) ; diamondBuild = ins . readLong ( ) ; dbSeqs = ins . readLong ( ) ; dbSeqsUsed = ins . readLong ( ) ; dbLetters = ins . readLong ( ) ; flags = ins . readLong ( ) ; queryRecords = ins . readLong ( ) ; modeRank = ins . readInt ( ) ; gapOpen = ins . readInt ( ) ; gapExtend = ins . readInt ( ) ; reward = ins . readInt ( ) ; penalty = ins . readInt ( ) ; reserved1 = ins . readInt ( ) ; reserved2 = ins . readInt ( ) ; reserved3 = ins . readInt ( ) ; k = ins . readDouble ( ) ; lambda = ins . readDouble ( ) ; reserved4 = ins . readDouble ( ) ; reserved5 = ins . readDouble ( ) ; for ( int i = NUM_ ; i < scoreMatrix . length ; i ++ ) { scoreMatrix [ i ] = ( byte ) ins . read ( ) ; } scoreMatrixName = Basic . toString ( scoreMatrix ) ; for ( int i = NUM_ ; i < blockSize . length ; i ++ ) blockSize [ i ] = ins . readLong ( ) ; if ( blockSize [ NUM_ ] == NUM_ ) throw new IOException ( STR_ ) ; for ( int i = NUM_ ; i < blockTypeRank . length ; i ++ ) { blockTypeRank [ i ] = ( byte ) ins . read ( ) ; switch ( BlockType . value ( blockTypeRank [ i ] ) ) { case ref_names : if ( refNamesBlockIndex != - NUM_ ) throw new IOException ( STR_ ) ; refNamesBlockIndex = i ; break ; case ref_lengths : if ( refLengthsBlockIndex != - NUM_ ) throw new IOException ( STR_ ) ; refLengthsBlockIndex = i ; break ; case alignments : if ( alignmentsBlockIndex != - NUM_ ) throw new IOException ( STR_ ) ; alignmentsBlockIndex = i ; break ; } } if ( refNamesBlockIndex == - NUM_ ) throw new IOException ( STR_ ) ; if ( refLengthsBlockIndex == - NUM_ ) throw new IOException ( STR_ ) ; if ( alignmentsBlockIndex == - NUM_ ) throw new IOException ( STR_ ) ; if ( refLengthsBlockIndex < refNamesBlockIndex ) throw new IOException ( STR_ ) ; headerSize = ins . getPosition ( ) ; lnK = Math . log ( k ) ; } } }
private static Class < ? > [ ] types ( Object ... values ) { if ( values == null ) { return new Class [ NUM_ ] ; } Class < ? > [ ] result = new Class [ values . length ] ; for ( int i = NUM_ ; i < values . length ; i ++ ) { Object value = values [ i ] ; result [ i ] = value == null ? NULL . class : value . getClass ( ) ; } return result ; }
private final void countAll ( ) throws IOException { MultiDocValues . OrdinalMap ordinalMap ; if ( dv instanceof MultiDocValues . MultiSortedSetDocValues ) { ordinalMap = ( ( MultiSortedSetDocValues ) dv ) . mapping ; } else { ordinalMap = null ; } IndexReader origReader = state . getOrigReader ( ) ; for ( LeafReaderContext context : origReader . leaves ( ) ) { LeafReader reader = context . reader ( ) ; SortedSetDocValues segValues = reader . getSortedSetDocValues ( field ) ; if ( segValues == null ) { continue ; } Bits liveDocs = reader . getLiveDocs ( ) ; if ( ordinalMap != null ) { final LongValues ordMap = ordinalMap . getGlobalOrds ( context . ord ) ; int numSegOrds = ( int ) segValues . getValueCount ( ) ; final int [ ] segCounts = new int [ numSegOrds ] ; int docID ; while ( ( docID = segValues . nextDoc ( ) ) != DocIdSetIterator . NO_MORE_DOCS ) { if ( liveDocs == null || liveDocs . get ( docID ) ) { int term = ( int ) segValues . nextOrd ( ) ; while ( term != SortedSetDocValues . NO_MORE_ORDS ) { segCounts [ term ] ++ ; term = ( int ) segValues . nextOrd ( ) ; } } } for ( int ord = NUM_ ; ord < numSegOrds ; ord ++ ) { int count = segCounts [ ord ] ; if ( count != NUM_ ) { counts [ ( int ) ordMap . get ( ord ) ] += count ; } } } else { int docID ; while ( ( docID = segValues . nextDoc ( ) ) != DocIdSetIterator . NO_MORE_DOCS ) { if ( liveDocs == null || liveDocs . get ( docID ) ) { int term = ( int ) segValues . nextOrd ( ) ; while ( term != SortedSetDocValues . NO_MORE_ORDS ) { counts [ term ] ++ ; term = ( int ) segValues . nextOrd ( ) ; } } } } } }
public void addToParent ( Element headerE ) throws Exception { Document doc = headerE . getOwnerDocument ( ) ; Element securityE = doc . createElementNS ( wsseNS , WSSEConstants . TAG_WSSE + STR_ + WSSEConstants . TAG_SECURITYT ) ; securityE . setAttributeNS ( SOAPBindingConstants . NS_XML , WSSEConstants . TAG_XML_WSSE , wsseNS ) ; headerE . appendChild ( securityE ) ; Document binaryTokenD = XMLUtils . toDOMDocument ( toString ( ) , debug ) ; Element binaryTokenE = binaryTokenD . getDocumentElement ( ) ; securityE . appendChild ( doc . importNode ( binaryTokenE , BOOL_ ) ) ; }
public final static int skipSpaces ( final String in , final int start ) { int pos = start ; while ( pos < in . length ( ) && ( in . charAt ( pos ) == STR_ || in . charAt ( pos ) == STR_ ) ) { pos ++ ; } return pos < in . length ( ) ? pos : - NUM_ ; }
public void update ( ) { if ( amplitude > NUM_ ) { long elapsed = System . currentTimeMillis ( ) - timestamp ; double delta = amplitude . Math . exp ( - elapsed / timeConstant ) ; if ( Math . abs ( delta ) > NUM_ ) { viewpointNode . drag ( lastDx . delta , lastDy . delta ) ; } else { amplitude = NUM_ ; updateLookAt ( ) ; } } }
@ Override public Assignment sample ( ) { if ( ! samples . isEmpty ( ) ) { int selection = sampler . nextInt ( samples . size ( ) ) ; Assignment selected = samples . get ( selection ) ; return selected ; } else { log . warning ( STR_ ) ; return new Assignment ( ) ; } }
@ SneakyThrows public static X509Certificate readCertificate ( InputStream is ) { return ( X509Certificate ) CERT_FACTORY . generateCertificate ( is ) ; }
public GuacamoleHTTPTunnelMap ( ) { executor . scheduleAtFixedRate ( new TunnelTimeoutTask ( TUNNEL_TIMEOUT . NUM_ ) , TUNNEL_TIMEOUT , TUNNEL_TIMEOUT , TimeUnit . SECONDS ) ; }
default B with ( String key , Class < ? > value ) { return with ( key , value != null ? value . getName ( ) : null ) ; }
private void rename ( Table table ) { if ( renameDefinitions != null ) { for ( Column col : table . getAllColumns ( ) ) { String newColName = renameDefinitions . getNewColumnName ( table . getSchema ( ) , table . getName ( ) , col . getName ( ) ) ; if ( newColName != null ) col . setName ( newColName ) ; } String newTableName = renameDefinitions . getNewTableName ( table . getSchema ( ) , table . getName ( ) ) ; String newSchemaName = renameDefinitions . getNewSchemaName ( table . getSchema ( ) , table . getName ( ) ) ; if ( newTableName != null ) table . setTable ( newTableName ) ; if ( newSchemaName != null ) table . setSchema ( newSchemaName ) ; } }
private void handleReadLastConfirmedError ( int rc ) { if ( BKException . Code . NoSuchLedgerExistsException == rc ) { if ( bkcNoLedgerExceptionsOnReadLAC . incrementAndGet ( ) > noLedgerExceptionOnReadLACThreshold ) { LOG . info ( STR_ , new Object [ ] { fullyQualifiedName , currentLH , conf . getReadAheadNoSuchLedgerExceptionOnReadLACErrorThresholdMillis ( ) } ) ; bkcNoLedgerExceptionsOnReadLAC . set ( NUM_ ) ; if ( closeCurrentLedgerHandle ( ) ) { next . process ( BKException . Code . OK ) ; } return ; } else { if ( LOG . isTraceEnabled ( ) ) { LOG . info ( STR_ , new Object [ ] { fullyQualifiedName , currentLH , conf . getReadAheadWaitTime ( ) } ) ; } schedule ( ReadAheadWorker . this , conf . getReadAheadWaitTime ( ) ) ; return ; } } else if ( BKException . Code . OK != rc ) { handleException ( ReadAheadPhase . READ_LAST_CONFIRMED , rc ) ; return ; } }
public synchronized boolean put ( long fp ) { int index = ( int ) ( fp & this . mask ) ; long [ ] list = this . table [ index ] ; if ( list != null ) { int listlen = list . length ; for ( int i = NUM_ ; i < listlen ; i ++ ) { if ( list [ i ] == fp ) return BOOL_ ; } } if ( count >= threshold ) { rehash ( ) ; index = ( int ) ( fp & this . mask ) ; list = this . table [ index ] ; } int len = ( list == null ? NUM_ : list . length ) ; long [ ] newList = new long [ len + NUM_ ] ; if ( list != null ) System . arraycopy ( list , NUM_ , newList , NUM_ , len ) ; newList [ len ] = fp ; this . table [ index ] = newList ; this . count ++ ; return BOOL_ ; }
public boolean isEmpty ( ) { return extOrdering . isEmpty ( ) ; }
public void applyLayout ( ) { layout . setInitialLocation ( getPosition ( ) ) ; layout . layoutNeurons ( getNeuronList ( ) ) ; }
public int nice ( ) { return Integer . parseInt ( fields [ NUM_ ] ) ; }
float layerSize ( int p_76490_1_ ) { if ( ( float ) p_76490_1_ < ( float ) this . heightLimit . NUM_ ) { return - NUM_ ; } else { float f = ( float ) this . heightLimit / NUM_ ; float f1 = f - ( float ) p_76490_1_ ; float f2 = MathHelper . sqrt_float ( f . f - f1 . f1 ) ; if ( f1 == NUM_ ) { f2 = f ; } else if ( Math . abs ( f1 ) >= f ) { return NUM_ ; } return f2 . NUM_ ; } }
public static Method findStaticMethod ( Class < ? > type , String name , Class < ? > ... args ) throws NoSuchMethodException { Method method = findMethod ( type , name , args ) ; if ( ! Modifier . isStatic ( method . getModifiers ( ) ) ) { throw new NoSuchMethodException ( STR_ + name + STR_ ) ; } return method ; }
private void fetchSearchServiceCardsFromServer ( String keyword , String categoryId ) { final Map < String , String > params = new HashMap < String , String > ( NUM_ ) ; params . put ( HttpConstants . LATITUDE , SharedPreferenceHelper . getString ( R . string . pref_latitude ) ) ; params . put ( HttpConstants . LONGITUDE , SharedPreferenceHelper . getString ( R . string . pref_longitude ) ) ; params . put ( HttpConstants . TYPE , HttpConstants . SearchType . SERVICE_CARD ) ; params . put ( HttpConstants . GROUP_ID , categoryId ) ; params . put ( HttpConstants . PER , STR_ ) ; params . put ( HttpConstants . RADIUS , STR_ ) ; params . put ( HttpConstants . TITLE , keyword ) ; RetroCallback retroCallback ; retroCallback = new RetroCallback ( this ) ; retroCallback . setRequestId ( HttpConstants . ApiResponseCodes . SEARCH_SERVICES ) ; retroCallbackList . add ( retroCallback ) ; params . put ( HttpConstants . PAGE , STR_ ) ; mYeloApi . getServiceCards ( params , retroCallback ) ; mSwipeRefreshLayout . setRefreshing ( BOOL_ ) ; }
public void addPhonenumber ( String aPhonenumber ) { if ( mPhoneNumbers . indexOf ( aPhonenumber ) < NUM_ ) { mPhoneNumbers . add ( aPhonenumber ) ; } }
public static final String digitsAndPlusOnly ( Matcher matcher ) { StringBuilder buffer = new StringBuilder ( ) ; String matchingRegion = matcher . group ( ) ; for ( int i = NUM_ , size = matchingRegion . length ( ) ; i < size ; i ++ ) { char character = matchingRegion . charAt ( i ) ; if ( character == STR_ || Character . isDigit ( character ) ) { buffer . append ( character ) ; } } return buffer . toString ( ) ; }
boolean compareMethods ( Method a , Method b ) { if ( ( a == null ) != ( b == null ) ) { return BOOL_ ; } if ( a != null && b != null ) { if ( ! a . equals ( b ) ) { return BOOL_ ; } } return BOOL_ ; }
MarkerSegment findMarkerSegment ( int tag ) { Iterator iter = markerSequence . iterator ( ) ; while ( iter . hasNext ( ) ) { MarkerSegment seg = ( MarkerSegment ) iter . next ( ) ; if ( seg . tag == tag ) { return seg ; } } return null ; }
private static Reader openInput ( String from ) { try { return CliUtils . reader ( from ) ; } catch ( IOException e ) { log . error ( STR_ , e ) ; System . exit ( NUM_ ) ; return null ; } }
public PublisherConcatArray < T > concatAdditionalSourceFirst ( Publisher < ? extends T > source ) { int n = array . length ; @ SuppressWarnings ( STR_ ) Publisher < ? extends T > [ ] newArray = new Publisher [ n + NUM_ ] ; System . arraycopy ( array , NUM_ , newArray , NUM_ , n ) ; newArray [ NUM_ ] = source ; return new PublisherConcatArray < > ( delayError , newArray ) ; }
protected void doPublish ( String tenantId , List < T > items , String subscriber , int retryCount , long delay ) throws Exception { String data = mapper . writeValueAsString ( items ) ; TextMessage tm = session . createTextMessage ( data ) ; if ( tenantId != null ) { tm . setStringProperty ( STR_ , tenantId ) ; } if ( subscriber != null ) { tm . setStringProperty ( STR_ , subscriber ) ; } tm . setIntProperty ( STR_ , retryCount ) ; if ( delay > NUM_ ) { tm . setLongProperty ( STR_ , System . currentTimeMillis ( ) + delay ) ; } if ( log . isLoggable ( Level . FINEST ) ) { log . finest ( STR_ + tm ) ; } producer . send ( tm ) ; }
@ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case MappingPackage . ATTRIBUTE__NAME : return NAME_EDEFAULT == null ? name != null : ! NAME_EDEFAULT . equals ( name ) ; case MappingPackage . ATTRIBUTE__VALUE : return VALUE_EDEFAULT == null ? value != null : ! VALUE_EDEFAULT . equals ( value ) ; } return super . eIsSet ( featureID ) ; }
protected void checkValid ( ) throws URIException { if ( ! ( equals ( _scheme , DEFAULT_SCHEME ) || _scheme == null ) ) { throw new URIException ( URIException . PARSING , STR_ ) ; } }
public PrivateKeyUsageExtension ( Boolean critical , Object value ) throws CertificateException , IOException { this . extensionId = PKIXExtensions . PrivateKeyUsage_Id ; this . critical = critical . booleanValue ( ) ; this . extensionValue = ( byte [ ] ) value ; DerInputStream str = new DerInputStream ( this . extensionValue ) ; DerValue [ ] seq = str . getSequence ( NUM_ ) ; for ( int i = NUM_ ; i < seq . length ; i ++ ) { DerValue opt = seq [ i ] ; if ( opt . isContextSpecific ( TAG_BEFORE ) && ! opt . isConstructed ( ) ) { if ( notBefore != null ) { throw new CertificateParsingException ( STR_ ) ; } opt . resetTag ( DerValue . tag_GeneralizedTime ) ; str = new DerInputStream ( opt . toByteArray ( ) ) ; notBefore = str . getGeneralizedTime ( ) ; } else if ( opt . isContextSpecific ( TAG_AFTER ) && ! opt . isConstructed ( ) ) { if ( notAfter != null ) { throw new CertificateParsingException ( STR_ ) ; } opt . resetTag ( DerValue . tag_GeneralizedTime ) ; str = new DerInputStream ( opt . toByteArray ( ) ) ; notAfter = str . getGeneralizedTime ( ) ; } else throw new IOException ( STR_ + STR_ ) ; } }
@ Override public List < Period > generatePeriods ( DateTimeUnit dateTimeUnit ) { Calendar cal = getCalendar ( ) ; dateTimeUnit . setMonth ( NUM_ ) ; dateTimeUnit . setDay ( NUM_ ) ; List < Period > periods = Lists . newArrayList ( ) ; int year = dateTimeUnit . getYear ( ) ; while ( dateTimeUnit . getYear ( ) == year ) { periods . add ( createPeriod ( dateTimeUnit , cal ) ) ; dateTimeUnit = cal . plusMonths ( dateTimeUnit , NUM_ ) ; } return periods ; }
public static SecretKey createAESKey ( ) { try { final KeyGenerator kgen = KeyGenerator . getInstance ( STR_ ) ; final int keySize = NUM_ ; kgen . init ( keySize ) ; return kgen . generateKey ( ) ; } catch ( final NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } return null ; }
@ Override public void valueChange ( ValueChangeEvent e ) { String name = e . getPropertyName ( ) ; Object value = e . getNewValue ( ) ; log . config ( name + STR_ + value ) ; if ( value == null ) return ; }
@ Deprecated public static JSONObject parseJson ( String response ) throws JSONException , FacebookError { if ( response . equals ( STR_ ) ) { throw new FacebookError ( STR_ ) ; } if ( response . equals ( STR_ ) ) { response = STR_ ; } JSONObject json = new JSONObject ( response ) ; if ( json . has ( STR_ ) ) { JSONObject error = json . getJSONObject ( STR_ ) ; throw new FacebookError ( error . getString ( STR_ ) , error . getString ( STR_ ) , NUM_ ) ; } if ( json . has ( STR_ ) && json . has ( STR_ ) ) { throw new FacebookError ( json . getString ( STR_ ) , STR_ , Integer . parseInt ( json . getString ( STR_ ) ) ) ; } if ( json . has ( STR_ ) ) { throw new FacebookError ( STR_ , STR_ , Integer . parseInt ( json . getString ( STR_ ) ) ) ; } if ( json . has ( STR_ ) ) { throw new FacebookError ( json . getString ( STR_ ) ) ; } if ( json . has ( STR_ ) ) { throw new FacebookError ( json . getString ( STR_ ) ) ; } return json ; }
public SpyVersions loadVersions ( ) throws XMLException { setLoading ( BOOL_ ) ; final String urlString = propertyLoader . getProperty ( BasePropertyNames . VERSION_INFO_URL ) + STR_ + currentRelease ; try { final URL url = new URL ( urlString ) ; final String xml = IOUtils . toString ( url . openStream ( ) ) ; versions = ( SpyVersions ) loadFromString ( xml ) ; } catch ( IOException | NullPointerException e ) { throw new XMLException ( STR_ + urlString , e ) ; } setLoading ( BOOL_ ) ; return versions ; }
@ RequestMapping ( value = STR_ , method = POST , produces = APPLICATION_JSON_VALUE ) public ResponseEntity < PageResponse < UserDTO > > findAll ( @ RequestBody PageRequestByExample < UserDTO > prbe ) throws URISyntaxException { PageResponse < UserDTO > pageResponse = userDTOService . findAll ( prbe ) ; return new ResponseEntity < > ( pageResponse , new HttpHeaders ( ) , HttpStatus . OK ) ; }
public void addFooterView ( View view ) { mFooterViews . add ( view ) ; notifyDataSetChanged ( ) ; }
public void addFirst ( String seq ) { queue = seq + queue . substring ( pos ) ; pos = NUM_ ; }
public boolean isReadOnly ( boolean useSessionStatus ) throws SQLException { if ( useSessionStatus && ! this . isClosed && versionMeetsMinimum ( NUM_ , NUM_ , NUM_ ) && ! getUseLocalSessionState ( ) && getReadOnlyPropagatesToServer ( ) ) { java . sql . Statement stmt = null ; java . sql . ResultSet rs = null ; try { try { stmt = getMetadataSafeStatement ( ) ; rs = stmt . executeQuery ( STR_ ) ; if ( rs . next ( ) ) { return rs . getInt ( NUM_ ) != NUM_ ; } } catch ( SQLException ex1 ) { if ( ex1 . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw SQLError . createSQLException ( STR_ , SQLError . SQL_STATE_GENERAL_ERROR , ex1 , getExceptionInterceptor ( ) ) ; } } } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( Exception ex ) { } rs = null ; } if ( stmt != null ) { try { stmt . close ( ) ; } catch ( Exception ex ) { } stmt = null ; } } } return this . readOnly ; }
public void exprSetParent ( ExpressionNode n ) { super . exprSetParent ( n ) ; int nArgs = m_argVec . size ( ) ; for ( int i = NUM_ ; i < nArgs ; i ++ ) { Expression arg = ( Expression ) m_argVec . elementAt ( i ) ; arg . exprSetParent ( n ) ; } }
public static void cleanDirectory ( File directory ) throws IOException { if ( ! directory . exists ( ) ) { String message = directory + STR_ ; throw new IllegalArgumentException ( message ) ; } if ( ! directory . isDirectory ( ) ) { String message = directory + STR_ ; throw new IllegalArgumentException ( message ) ; } File [ ] files = directory . listFiles ( ) ; if ( files == null ) { throw new IOException ( STR_ + directory ) ; } IOException exception = null ; for ( File file : files ) { try { forceDelete ( file ) ; } catch ( IOException ioe ) { exception = ioe ; } } if ( null != exception ) { throw exception ; } }
public final boolean isRegistered ( ) { return ! canonicalName . startsWith ( STR_ ) && ! canonicalName . startsWith ( STR_ ) ; }
private static DownscaleQuality addConstant ( String type ) { init ( ) ; if ( constList . containsKey ( type ) ) { throw new RuntimeException ( STR_ + type + STR_ ) ; } DownscaleQuality q = new DownscaleQuality ( type ) ; constList . put ( type , q ) ; return q ; }
public void bail ( String message , boolean printUsageStatement ) { Debug . output ( message ) ; if ( printUsageStatement ) printUsage ( ) ; System . exit ( NUM_ ) ; }
private void assertTimestampsEqualWithEpsilon ( long expected , long actual , int epsilon , String desc ) { assertTrue ( STR_ + desc + STR_ + epsilon + STR_ + expected + STR_ + actual , Math . abs ( actual - expected ) < epsilon ) ; }
public SpiderSitemapXMLParser ( SpiderParam params ) { super ( ) ; if ( params == null ) { throw new IllegalArgumentException ( STR_ ) ; } this . params = params ; }
public boolean flush ( boolean deaccelerated ) ;
public void addHop ( int id ) { if ( entities == null ) { return ; } hopsNumber ++ ; entities . add ( Integer . valueOf ( id ) ) ; }
protected boolean [ ] datasetIntegrity ( boolean nominalPredictor , boolean numericPredictor , boolean stringPredictor , boolean datePredictor , boolean relationalPredictor , boolean multiInstance , int classType , boolean predictorMissing , boolean classMissing ) { print ( STR_ ) ; printAttributeSummary ( nominalPredictor , numericPredictor , stringPredictor , datePredictor , relationalPredictor , multiInstance , classType ) ; print ( STR_ ) ; int numTrain = getNumInstances ( ) , numClasses = NUM_ , missingLevel = NUM_ ; boolean [ ] result = new boolean [ NUM_ ] ; Instances train = null ; Associator associator = null ; try { train = makeTestDataset ( NUM_ , numTrain , nominalPredictor ? getNumNominal ( ) : NUM_ , numericPredictor ? getNumNumeric ( ) : NUM_ , stringPredictor ? getNumString ( ) : NUM_ , datePredictor ? getNumDate ( ) : NUM_ , relationalPredictor ? getNumRelational ( ) : NUM_ , numClasses , classType , multiInstance ) ; if ( missingLevel > NUM_ ) { addMissing ( train , missingLevel , predictorMissing , classMissing ) ; } associator = AbstractAssociator . makeCopies ( getAssociator ( ) , NUM_ ) [ NUM_ ] ; } catch ( Exception ex ) { throw new Error ( STR_ + ex . getMessage ( ) ) ; } try { Instances trainCopy = new Instances ( train ) ; associator . buildAssociations ( trainCopy ) ; compareDatasets ( train , trainCopy ) ; println ( STR_ ) ; result [ NUM_ ] = BOOL_ ; } catch ( Exception ex ) { println ( STR_ ) ; result [ NUM_ ] = BOOL_ ; if ( m_Debug ) { println ( STR_ ) ; print ( STR_ ) ; println ( STR_ + ex . getMessage ( ) + STR_ ) ; println ( STR_ ) ; println ( STR_ + train . toString ( ) + STR_ ) ; } } return result ; }
public boolean isEmpty ( ) { return mEventQueue . isEmpty ( ) ; }
public static void testPrimitiveInstantiation ( ) { testPrimitiveInstantiation ( BOOL_ ) ; }
public void readEntries ( TableKelp table , InSegment reader , SegmentEntryCallback cb ) { TempBuffer tBuf = TempBuffer . createLarge ( ) ; byte [ ] buffer = tBuf . buffer ( ) ; InStore sIn = reader . getStoreRead ( ) ; byte [ ] tableKey = new byte [ TableKelp . TABLE_KEY_SIZE ] ; for ( int ptr = length ( ) - BLOCK_SIZE ; ptr > NUM_ ; ptr -= BLOCK_SIZE ) { sIn . read ( getAddress ( ) + ptr , buffer , NUM_ , buffer . length ) ; int index = NUM_ ; long seq = BitsUtil . readLong ( buffer , index ) ; index += NUM_ ; if ( seq != getSequence ( ) ) { log . warning ( L . l ( STR_ , seq , getSequence ( ) , Long . toHexString ( getAddress ( ) + ptr ) ) ) ; break ; } System . arraycopy ( buffer , index , tableKey , NUM_ , tableKey . length ) ; index += tableKey . length ; if ( ! Arrays . equals ( tableKey , _tableKey ) ) { log . warning ( L . l ( STR_ , Hex . toShortHex ( tableKey ) , Hex . toShortHex ( _tableKey ) , Long . toHexString ( getAddress ( ) + ptr ) ) ) ; break ; } int head = index ; while ( head < BLOCK_SIZE && buffer [ head ] != NUM_ ) { head = readEntry ( table , buffer , head , cb , getAddress ( ) ) ; } boolean isCont = buffer [ head + NUM_ ] != NUM_ ; if ( ! isCont ) { break ; } } tBuf . free ( ) ; }
static int numberOfHosts ( Map < URI , List < Initiator > > net2InitiatorsMap ) { Set < URI > hostSet = new HashSet < URI > ( ) ; for ( List < Initiator > initiators : net2InitiatorsMap . values ( ) ) { for ( Initiator init : initiators ) { hostSet . add ( init . getHost ( ) ) ; } } return hostSet . size ( ) ; }
public void addCertificates ( Store certStore ) throws CMSException { certs . addAll ( CMSUtils . getCertificatesFromStore ( certStore ) ) ; }
protected void processLob ( LobMetadata lob , DatabaseMapping mapping , MetadataClass referenceClass , boolean isForMapKey ) { lob . process ( mapping , this , referenceClass , isForMapKey ) ; }
protected AttributesImpl startPrefixMapping ( Element element , NamespaceStack namespaceStack ) throws SAXException { AttributesImpl namespaceAttributes = null ; Namespace elementNamespace = element . getNamespace ( ) ; if ( ( elementNamespace != null ) && ! isIgnoreableNamespace ( elementNamespace , namespaceStack ) ) { namespaceStack . push ( elementNamespace ) ; contentHandler . startPrefixMapping ( elementNamespace . getPrefix ( ) , elementNamespace . getURI ( ) ) ; namespaceAttributes = addNamespaceAttribute ( namespaceAttributes , elementNamespace ) ; } List < Namespace > declaredNamespaces = element . declaredNamespaces ( ) ; for ( Namespace namespace : declaredNamespaces ) { if ( ! isIgnoreableNamespace ( namespace , namespaceStack ) ) { namespaceStack . push ( namespace ) ; contentHandler . startPrefixMapping ( namespace . getPrefix ( ) , namespace . getURI ( ) ) ; namespaceAttributes = addNamespaceAttribute ( namespaceAttributes , namespace ) ; } } return namespaceAttributes ; }
private float clampMag ( float value , float absMin , float absMax ) { final float absValue = Math . abs ( value ) ; if ( absValue < absMin ) return NUM_ ; if ( absValue > absMax ) return value > NUM_ ? absMax : - absMax ; return value ; }
public void printStackTrace ( java . io . PrintWriter pw ) { if ( rootCause != null ) { String superString = super . toString ( ) ; synchronized ( pw ) { pw . print ( superString + ( superString . endsWith ( STR_ ) ? STR_ : STR_ ) + STR_ ) ; rootCause . printStackTrace ( pw ) ; } } else { super . printStackTrace ( pw ) ; } }
private static DataFlavor [ ] convertToArray ( List < DataFlavor > dataFlavourList ) { DataFlavor [ ] array = new DataFlavor [ dataFlavourList . size ( ) ] ; dataFlavourList . toArray ( array ) ; return array ; }
public void testChoiceEmptyIconErrorHandling ( ) { String xml = STR_ ; xml += createStartMissionXml ( STR_ , STR_ ) ; xml += createStartChoiceMomentXml ( STR_ , NUM_ , STR_ , STR_ ) ; xml += createChoiceXml ( STR_ , STR_ , STR_ , BOOL_ , BOOL_ , STR_ ) ; xml += createChoiceXml ( STR_ , STR_ , STR_ , BOOL_ , BOOL_ , STR_ ) ; xml += createEndChoiceMomentXml ( ) ; xml += createEndChoiceMomentXml ( ) ; xml += createEndMissionXml ( ) ; Utils . logDebug ( TAG , xml ) ; InputStream momentInputStream = new ByteArrayInputStream ( xml . getBytes ( ) ) ; mMission = new Mission ( mMissionData ) ; boolean didMissionParseFail = BOOL_ ; try { mMission . readMoments ( momentInputStream ) ; } catch ( MissionParseException e ) { e . printStackTrace ( ) ; didMissionParseFail = BOOL_ ; } Assert . assertEquals ( BOOL_ , didMissionParseFail ) ; }
public static String translateAttribute ( String attributes ) throws IOException { short [ ] flags = strAttrToBooleanFlags ( attributes ) ; StringBuilder sb = new StringBuilder ( ) ; if ( flags [ READ_ONLY ] == YES ) sb . append ( STR_ ) ; else if ( flags [ READ_ONLY ] == NO ) sb . append ( STR_ ) ; if ( flags [ HIDDEN ] == YES ) sb . append ( STR_ ) ; else if ( flags [ HIDDEN ] == NO ) sb . append ( STR_ ) ; if ( flags [ SYSTEM ] == YES ) sb . append ( STR_ ) ; else if ( flags [ SYSTEM ] == NO ) sb . append ( STR_ ) ; if ( flags [ ARCHIVE ] == YES ) sb . append ( STR_ ) ; else if ( flags [ ARCHIVE ] == NO ) sb . append ( STR_ ) ; return sb . toString ( ) ; }
public static int nextIndexId ( ) { return msgIdx . getAndIncrement ( ) ; }
private void fillFieldValues ( ) { if ( isCreationPanel ) { phrase . setText ( STR_ + Hearing . DEFAULT_PHRASE ) ; outputAmount . setText ( STR_ + Hearing . DEFAULT_OUTPUT_AMOUNT ) ; } else { phrase . setText ( STR_ + hearingSensor . getPhrase ( ) ) ; outputAmount . setText ( STR_ + hearingSensor . getOutputAmount ( ) ) ; } }
public static boolean checkSecurityInfos ( String endpoint , Identity clientIdentity , List < SecurityInfo > securityInfos ) { if ( clientIdentity . isSecure ( ) ) { if ( securityInfos == null || securityInfos . isEmpty ( ) ) { LOG . warn ( STR_ , endpoint ) ; return BOOL_ ; } else { for ( SecurityInfo securityInfo : securityInfos ) { if ( checkSecurityInfo ( endpoint , clientIdentity , securityInfo ) ) { return BOOL_ ; } } return BOOL_ ; } } else if ( securityInfos != null && ! securityInfos . isEmpty ( ) ) { LOG . warn ( STR_ , endpoint ) ; return BOOL_ ; } return BOOL_ ; }
public boolean retainAll ( AbstractIntList other ) { if ( other . size ( ) == NUM_ ) { if ( size == NUM_ ) return BOOL_ ; setSize ( NUM_ ) ; return BOOL_ ; } int limit = other . size ( ) - NUM_ ; int j = NUM_ ; for ( int i = NUM_ ; i < size ; i ++ ) { if ( other . indexOfFromTo ( getQuick ( i ) , NUM_ , limit ) >= NUM_ ) setQuick ( j ++ , getQuick ( i ) ) ; } boolean modified = ( j != size ) ; setSize ( j ) ; return modified ; }
public static ArrayList < ByteString > byteArraysToStrings ( ArrayList < byte [ ] > byteArrays ) { if ( byteArrays == null ) { return null ; } ArrayList < ByteString > byteStrings = new ArrayList < ByteString > ( ) ; for ( byte [ ] bytes : byteArrays ) { byteStrings . add ( ByteString . of ( bytes ) ) ; } return byteStrings ; }
void addIndex ( IndexType type , List < String > columnNames ) { IndexDefinition index = new IndexDefinition ( ) ; index . indexName = tableName + STR_ + indexes . size ( ) ; index . columnNames = New . arrayList ( columnNames ) ; index . type = type ; indexes . add ( index ) ; }
public Builder withKeyStoreKeyPassword ( String keyStoreKeyPassword ) { properties . setProperty ( NettyOptions . SSL_KEY_STORE_KEY_PASSWORD , Assert . notNull ( keyStoreKeyPassword , STR_ ) ) ; return this ; }
public ZookeeperStateMachineEnsemble ( CuratorFramework curatorClient , String basePath ) { this ( curatorClient , basePath , BOOL_ , DEFAULT_LOGSIZE ) ; }
public static CustomShortcutSet createShortcut ( char ch ) { Character mnemonic = Character . valueOf ( ch ) ; String shortcut = SystemInfo . isMac && SystemInfo . isJavaVersionAtLeast ( STR_ ) ? STR_ + mnemonic : STR_ + mnemonic ; return CustomShortcutSet . fromString ( shortcut ) ; }
public void gc ( ) { System . gc ( ) ; }
private Node deleteMin ( Node x ) { if ( x . left == null ) return x . right ; x . left = deleteMin ( x . left ) ; x . size = NUM_ + size ( x . left ) + size ( x . right ) ; x . height = NUM_ + Math . max ( height ( x . left ) , height ( x . right ) ) ; return balance ( x ) ; }
public static void resetCounters ( ) { errors = NUM_ ; warnings = NUM_ ; }
public void write ( CeylonConfig config , File source , OutputStream out ) throws IOException { if ( source . isFile ( ) ) { InputStream in = null ; try { in = new FileInputStream ( source ) ; write ( config , in , out ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IOException e ) { } } } } else { throw new FileNotFoundException ( STR_ ) ; } }
protected Map < TargetClass , List < Attribute . TypeCompound > > sift ( final Iterable < Attribute . TypeCompound > typeCompounds ) { final Map < TargetClass , List < Attribute . TypeCompound > > targetClassToCompound = new EnumMap < > ( TargetClass . class ) ; for ( TargetClass targetClass : TargetClass . values ( ) ) { targetClassToCompound . put ( targetClass , new ArrayList < TypeCompound > ( ) ) ; } for ( final Attribute . TypeCompound typeCompound : typeCompounds ) { final TargetType typeCompoundTarget = typeCompound . position . type ; final List < Attribute . TypeCompound > destList ; if ( ElementAnnotationUtil . contains ( typeCompoundTarget , annotatedTargets ( ) ) ) { destList = targetClassToCompound . get ( TargetClass . TARGETED ) ; } else if ( ElementAnnotationUtil . contains ( typeCompoundTarget , validTargets ( ) ) ) { destList = targetClassToCompound . get ( TargetClass . VALID ) ; } else { destList = targetClassToCompound . get ( TargetClass . INVALID ) ; } destList . add ( typeCompound ) ; } return targetClassToCompound ; }
protected synchronized void updateLocation ( Point newLocn ) { prev = locn ; locn = newLocn ; if ( Math . abs ( locn . x - prev . x ) > hysteresis || Math . abs ( locn . y - prev . y ) > hysteresis ) { if ( timer . isRunning ( ) ) timer . stop ( ) ; } else { if ( ! timer . isRunning ( ) ) timer . start ( ) ; } }
@ Override public int compareTo ( Value o ) { if ( o instanceof StringVal ) { return str . compareTo ( ( ( StringVal ) o ) . str ) ; } else { return NUM_ ; } }
public void bind ( IntegerProperty property , int value ) { if ( isAchieved ( ) ) return ; bind ( property . greaterThanOrEqualTo ( value ) ) ; BooleanBinding bb = property . greaterThanOrEqualTo ( value / NUM_ ) ; progressListener = null ; bb . addListener ( progressListener ) ; }
public void removeColumn ( Column c ) { int idx = m_columns . indexOf ( c ) ; if ( idx < NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } removeColumn ( idx ) ; }
public synchronized void write ( String logData ) { if ( logEnabled ) { histData . append ( logData ) ; histData . revalidate ( ) ; synchronized ( histData ) { histData . notify ( ) ; } } }
public void closeConnection ( ) { try { if ( m_connection != null ) { m_connection . close ( ) ; } } catch ( final SQLException exception ) { NaviLogger . severe ( STR_ , exception ) ; } m_connection = null ; }
public StructEmBayesSearchEditor ( StructEmBayesSearchRunner semBayesEstWrapper ) { this ( semBayesEstWrapper . getEstimatedBayesIm ( ) , semBayesEstWrapper . getDataSet ( ) ) ; }
public void removeActionListener ( ActionListener listener ) { forwardProjectionButton . addActionListener ( listener ) ; backProjectionButton . addActionListener ( listener ) ; }
public static void f ( String tag , String msg , Object ... args ) { if ( sLevel > LEVEL_FATAL ) { return ; } if ( args . length > NUM_ ) { msg = String . format ( msg , args ) ; } Log . wtf ( tag , msg ) ; }
boolean isLiteral ( int index ) { if ( isValidMask ( ) && index < string . length ( ) ) { return literalMask . get ( index ) ; } return BOOL_ ; }
protected Granularity generateGranularity ( String granularity , GranularityParser granularityParser ) throws BadApiRequestException { try { return granularityParser . parseGranularity ( granularity ) ; } catch ( GranularityParseException e ) { LOG . error ( UNKNOWN_GRANULARITY . logFormat ( granularity ) , granularity ) ; throw new BadApiRequestException ( e . getMessage ( ) ) ; } }
public WordIterator ( ) { this ( Locale . getDefault ( ) ) ; }
@ Override public void close ( ) { if ( leaf != null ) { leaf . close ( ) ; leaf = null ; } ccMgr . releaseIndexLocks ( ) ; dirsMayBeUpdated = null ; }
public void pushFile ( String local , String remote , ISyncProgressMonitor monitor ) throws SyncException , IOException , TimeoutException { File f = new File ( local ) ; if ( ! f . exists ( ) ) { throw new SyncException ( SyncError . NO_LOCAL_FILE ) ; } if ( f . isDirectory ( ) ) { throw new SyncException ( SyncError . LOCAL_IS_DIRECTORY ) ; } monitor . start ( ( int ) f . length ( ) ) ; doPushFile ( local , remote , monitor ) ; monitor . stop ( ) ; }
public String process ( Item seg ) throws ProcessException { return segCodaCtype ( seg , STR_ ) ; }
public void resize ( int size ) { if ( buffer != null ) { if ( size >= NUM_ && size < buffer . size ( ) ) { int oldLastIndex = buffer . size ( ) - NUM_ ; int newLastIndex = size - NUM_ ; for ( int i = oldLastIndex ; i > newLastIndex ; i -- ) { buffer . remove ( i ) ; } } } else { if ( size >= NUM_ && size < offsets . size ( ) ) { long offset = offsets . get ( size ) ; byteCache . resize ( key , offset ) ; ArrayList < Long > newOffsets = new ArrayList < Long > ( size ) ; for ( int i = NUM_ ; i < size ; i ++ ) { newOffsets . add ( offsets . get ( i ) ) ; } offsets = newOffsets ; } } }
public static byte [ ] splitUint8To2bytes ( char uint8 ) { if ( uint8 < NUM_ || uint8 > xff ) { throw new RuntimeException ( STR_ ) ; } String hexString = Integer . toHexString ( uint8 ) ; byte low ; byte high ; if ( hexString . length ( ) > NUM_ ) { high = ( byte ) Integer . parseInt ( hexString . substring ( NUM_ , NUM_ ) , NUM_ ) ; low = ( byte ) Integer . parseInt ( hexString . substring ( NUM_ , NUM_ ) , NUM_ ) ; } else { high = NUM_ ; low = ( byte ) Integer . parseInt ( hexString . substring ( NUM_ , NUM_ ) , NUM_ ) ; } byte [ ] result = new byte [ ] { high , low } ; return result ; }
protected void sprint ( short shortField ) { sprint ( String . valueOf ( shortField ) ) ; }
protected void initFromDir ( String prefix , File dir ) { File [ ] files ; files = dir . listFiles ( new ClassFileFilter ( ) ) ; for ( File file : files ) { if ( prefix == null ) { add ( file . getName ( ) ) ; } else { add ( prefix + STR_ + file . getName ( ) ) ; } } files = dir . listFiles ( new DirectoryFilter ( ) ) ; for ( File file : files ) { if ( prefix == null ) { initFromDir ( file . getName ( ) , file ) ; } else { initFromDir ( prefix + STR_ + file . getName ( ) , file ) ; } } }
public void removeBandwidth ( String name ) { if ( name != null ) if ( bandwidthList != null ) { for ( int i = NUM_ ; i < bandwidthList . size ( ) ; i ++ ) { Object o = bandwidthList . elementAt ( i ) ; if ( o instanceof BandwidthField ) { BandwidthField b = ( BandwidthField ) o ; try { String type = b . getType ( ) ; if ( type != null ) { if ( name . equals ( type ) ) { bandwidthList . remove ( b ) ; } } } catch ( SdpParseException e ) { } } } } }
protected static void succeed ( ) { System . exit ( NUM_ ) ; }
public static long now ( ) { return System . currentTimeMillis ( ) ; }
public static String collapseNewlines ( String argStr ) { char last = argStr . charAt ( NUM_ ) ; StringBuffer argBuf = new StringBuffer ( ) ; for ( int cIdx = NUM_ ; cIdx < argStr . length ( ) ; cIdx ++ ) { char ch = argStr . charAt ( cIdx ) ; if ( ch != STR_ || last != STR_ ) { argBuf . append ( ch ) ; last = ch ; } } return argBuf . toString ( ) ; }
LinkedList < TrieNode < T > > makeSuffixChain ( TrieNode < T > root , String suffix , T value ) { LinkedList < TrieNode < T > > result = new LinkedList < > ( ) ; String rootPrefix = root . getPrefix ( ) ; for ( int i = NUM_ , suffixSize = suffix . length ( ) ; i <= suffixSize ; i ++ ) { String newPrefix = rootPrefix + suffix . substring ( NUM_ , i ) ; TrieNode < T > newNode = TrieNode . makeNode ( newPrefix ) ; result . add ( newNode ) ; root . addChild ( newNode ) ; root = newNode ; } root . setValue ( value ) ; return result ; }
@ Override protected String generateJavadoc ( int index ) throws Exception { throw new Exception ( STR_ ) ; }
public Properties extractProperties ( Iterable < Map . Entry < String , String > > propSrc ) { Properties result = new Properties ( ) ; for ( Map . Entry < String , String > entry : propSrc ) { String name = entry . getKey ( ) ; if ( isNamespacedProperty ( name ) ) { String val = entry . getValue ( ) ; result . setProperty ( name , val ) ; } } return result ; }
public T removeLast ( ) { if ( rows . size ( ) != NUM_ ) rows . remove ( rows . size ( ) - NUM_ ) ; return instance ( ) ; }
public static void ensureVisible ( String componentName ) { if ( verbose ) { log ( STR_ + componentName + STR_ ) ; } ensureVisible ( findByName ( componentName ) ) ; }
public char next ( ) { return pos < in . length ( ) ? in . charAt ( pos ++ ) : STR_ ; }
public void endRepresentation ( ) { if ( ! representationProtectionsSet ) { if ( currentRepresentationProtections != null ) { Collections . sort ( currentRepresentationProtections , this ) ; } representationProtections = currentRepresentationProtections ; representationProtectionsSet = BOOL_ ; } else { if ( currentRepresentationProtections == null ) { Assertions . checkState ( representationProtections == null ) ; } else { Collections . sort ( currentRepresentationProtections , this ) ; Assertions . checkState ( currentRepresentationProtections . equals ( representationProtections ) ) ; } } currentRepresentationProtections = null ; }
public StandardPieSectionLabelGenerator ( String labelFormat ) { this ( labelFormat , NumberFormat . getNumberInstance ( ) , NumberFormat . getPercentInstance ( ) ) ; }
public static CharSequence [ ] split ( CharSequence line , int delimiter ) { CharSequence [ ] tokens0 = split ( line , delimiter , N ) ; if ( tokens0 . length < N ) { return tokens0 ; } else { CharSequence [ ] tokens1 = split ( tokens0 [ N - NUM_ ] , delimiter ) ; CharSequence [ ] tokens2 = new CharSequence [ tokens0 . length + tokens1 . length - NUM_ ] ; System . arraycopy ( tokens0 , NUM_ , tokens2 , NUM_ , tokens0 . length - NUM_ ) ; System . arraycopy ( tokens1 , NUM_ , tokens2 , tokens0 . length - NUM_ , tokens1 . length ) ; return tokens2 ; } }
public CCTimer ( Object t , String s , float seconds ) { target = t ; selector = s ; interval = seconds ; elapsed = - NUM_ ; try { Class < ? > cls = target . getClass ( ) ; invocation = cls . getMethod ( s , Float . TYPE ) ; } catch ( NoSuchMethodException e ) { e . printStackTrace ( ) ; } }
public Tuple read ( ) throws IOException { try { Map fields = jsonTupleStream . next ( ) ; if ( fields == null ) { Map m = new HashMap ( ) ; m . put ( STR_ , BOOL_ ) ; return new Tuple ( m ) ; } else { String msg = ( String ) fields . get ( STR_ ) ; if ( msg != null ) { HandledException ioException = new HandledException ( msg ) ; throw ioException ; } if ( trace ) { fields . put ( STR_ , this . baseUrl ) ; if ( slice != null ) { fields . put ( STR_ , slice ) ; } } if ( fieldMappings != null ) { fields = mapFields ( fields , fieldMappings ) ; } return new Tuple ( fields ) ; } } catch ( HandledException e ) { throw new IOException ( STR_ + this . baseUrl + STR_ + e . getMessage ( ) ) ; } catch ( Exception e ) { throw new IOException ( STR_ + this . baseUrl + STR_ , e ) ; } }
private String compute ( String left , double right , boolean isInteger ) { if ( left == null && Double . isNaN ( right ) ) { return null ; } if ( isInteger && right == ( int ) right ) { return ( left == null ? STR_ : left ) + ( int ) right ; } else if ( Double . isInfinite ( right ) ) { return ( left == null ? STR_ : left ) + Tools . formatNumber ( right ) ; } else { return ( left == null ? STR_ : left ) + ( Double . isNaN ( right ) ? STR_ : right ) ; } }
public void removePropertyChangeListener ( final PropertyChangeListener listener ) { propertyChangeSupport . removePropertyChangeListener ( listener ) ; }
public void loadXML ( Node stepnode , List < DatabaseMeta > databases , Map < String , Counter > counters ) throws KettleXMLException { try { this . tabelName = XMLHandler . getTagValue ( stepnode , STR_ ) ; this . outputRowSize = XMLHandler . getTagValue ( stepnode , STR_ ) ; this . factDimLensString = XMLHandler . getTagValue ( stepnode , STR_ ) ; this . tableName = XMLHandler . getTagValue ( stepnode , STR_ ) ; this . databaseName = XMLHandler . getTagValue ( stepnode , STR_ ) ; this . dimensionCount = XMLHandler . getTagValue ( stepnode , STR_ ) ; this . noDictionaryDims = XMLHandler . getTagValue ( stepnode , STR_ ) ; this . noDictionaryDimsMapping = XMLHandler . getTagValue ( stepnode , STR_ ) ; this . complexDimensionCount = XMLHandler . getTagValue ( stepnode , STR_ ) ; this . measureCount = XMLHandler . getTagValue ( stepnode , STR_ ) ; this . updateMemberRequest = XMLHandler . getTagValue ( stepnode , STR_ ) ; this . measureDataType = XMLHandler . getTagValue ( stepnode , STR_ ) ; this . partitionID = XMLHandler . getTagValue ( stepnode , STR_ ) ; this . segmentId = XMLHandler . getTagValue ( stepnode , STR_ ) ; this . taskNo = XMLHandler . getTagValue ( stepnode , STR_ ) ; } catch ( Exception e ) { throw new KettleXMLException ( STR_ , e ) ; } }
public final int [ ] hashSignature ( final int [ ] signature ) { int [ ] hash = new int [ stages ] ; int rows = signature . length / stages ; for ( int i = NUM_ ; i < signature . length ; i ++ ) { int stage = Math . min ( i / rows , stages - NUM_ ) ; hash [ stage ] = ( int ) ( ( hash [ stage ] + ( long ) signature [ i ] . LARGE_PRIME ) % buckets ) ; } return hash ; }
void onConsumeFinished ( Purchase purchase , IabResult result ) ;
public void cast ( final Type from , final Type to ) { if ( from != to ) { if ( from == Type . DOUBLE_TYPE ) { if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Opcodes . D2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Opcodes . D2L ) ; } else { mv . visitInsn ( Opcodes . D2I ) ; cast ( Type . INT_TYPE , to ) ; } } else if ( from == Type . FLOAT_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Opcodes . F2D ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Opcodes . F2L ) ; } else { mv . visitInsn ( Opcodes . F2I ) ; cast ( Type . INT_TYPE , to ) ; } } else if ( from == Type . LONG_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Opcodes . L2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Opcodes . L2F ) ; } else { mv . visitInsn ( Opcodes . L2I ) ; cast ( Type . INT_TYPE , to ) ; } } else { if ( to == Type . BYTE_TYPE ) { mv . visitInsn ( Opcodes . I2B ) ; } else if ( to == Type . CHAR_TYPE ) { mv . visitInsn ( Opcodes . I2C ) ; } else if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Opcodes . I2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Opcodes . I2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Opcodes . I2L ) ; } else if ( to == Type . SHORT_TYPE ) { mv . visitInsn ( Opcodes . I2S ) ; } } } }
private void addTriggerGroupName ( String groupName ) throws JobPersistenceException , ResourceException { addRepoListName ( groupName , TRIGGER_GROUP_NAMES_RESOURCE_PATH , STR_ ) ; }
public String readString ( ) throws IOException { int firstByte = readByte ( ) ; int length = readInt ( firstByte , PREFIX_8_BITS ) ; byte [ ] encoded = new byte [ length ] ; bytesLeft -= length ; in . readFully ( encoded ) ; return new String ( encoded , STR_ ) ; }
private synchronized void clearTempFiles ( ) { if ( ( tempFiles != null ) && ( tempFiles . size ( ) > NUM_ ) ) { Iterator it = tempFiles . iterator ( ) ; File file = null ; while ( it . hasNext ( ) ) { file = ( File ) it . next ( ) ; file . delete ( ) ; } tempFiles . clear ( ) ; } }
private Bitmap readAndDecompressThumbnail ( File file ) { try { if ( file . length ( ) > NUM_ ) { FileInputStream instream = new FileInputStream ( file ) ; ReadableByteChannel bytechan = Channels . newChannel ( instream ) ; ByteBuffer buff = ByteBuffer . allocateDirect ( ( int ) file . length ( ) ) ; if ( buff != null ) { bytechan . read ( buff ) ; instream . close ( ) ; buff . rewind ( ) ; PDQImage pthumb = DecompressionService . decompressThumbnailImage ( buff ) ; if ( pthumb != null ) { Bitmap bm = ConversionService . convertPDQImageToBitmap ( pthumb , BOOL_ ) ; pthumb . close ( ) ; return bm ; } } } } catch ( IOException ex ) { ex . printStackTrace ( ) ; } return null ; }
public void testSubmitRunnable ( ) throws Throwable { ExecutorService e = new ForkJoinPool ( NUM_ ) ; PoolCleaner cleaner = null ; try { cleaner = cleaner ( e ) ; Future < ? > future = e . submit ( new NoOpRunnable ( ) ) ; assertNull ( future . get ( ) ) ; assertTrue ( future . isDone ( ) ) ; assertFalse ( future . isCancelled ( ) ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public Rectangle2D shrink ( Rectangle2D area , Rectangle2D result ) { if ( result == null ) { result = new Rectangle2D . Double ( ) ; } result . setRect ( area . getX ( ) + this . left , area . getY ( ) + this . top , area . getWidth ( ) - this . left - this . right , area . getHeight ( ) - this . top - this . bottom ) ; return result ; }
public static String assertJQ ( SolrQueryRequest req , String ... tests ) throws Exception { return assertJQ ( req , JSONTestUtil . DEFAULT_DELTA , tests ) ; }
protected void buildAbsoluteStats ( String name , long value , long time ) throws InterruptedException { List < XYDataItem > stats = statsCollection . getStats ( name ) ; if ( stats == null ) { stats = statsCollection . newStats ( name , maxSeries ) ; } else { XYDataItem data = new XYDataItem ( time , value ) ; statsCollection . lockForUpdate ( ) ; try { stats . add ( data ) ; houseKeepStats ( stats ) ; } finally { statsCollection . releaseLock ( ) ; } if ( listeners != null ) { StatsCollectionEvent event = new StatsCollectionEvent ( name , data ) ; for ( StatsCollectionListener listener : listeners ) { if ( listener . isEnabled ( ) ) { listener . statsCollected ( event ) ; } } } } }
@ Override public void run ( ) { amIActive = BOOL_ ; String demHeader = null ; String streamHeadsHeader = null ; String elevationModifiedHeader = null ; String correctedDemHeader = null ; List < StreamHead > streamHeadList = new ArrayList < > ( ) ; int counter = NUM_ ; float progress = NUM_ ; if ( args . length <= NUM_ ) { showFeedback ( STR_ ) ; return ; } for ( int i = NUM_ ; i < args . length ; i ++ ) { if ( i == NUM_ ) { demHeader = args [ i ] ; } else if ( i == NUM_ ) { streamHeadsHeader = args [ i ] ; } else if ( i == NUM_ ) { elevationModifiedHeader = args [ i ] ; } else if ( i == NUM_ ) { correctedDemHeader = args [ i ] ; } else if ( i == NUM_ ) { maxRadius = Double . parseDouble ( args [ i ] ) ; } } if ( ( demHeader == null ) || ( streamHeadsHeader == null ) || ( elevationModifiedHeader == null ) || ( correctedDemHeader == null ) ) { showFeedback ( STR_ ) ; return ; } try { dem = new WhiteboxRaster ( demHeader , STR_ ) ; streamHeads = new WhiteboxRaster ( streamHeadsHeader , STR_ ) ; numRows = dem . getNumberRows ( ) ; numCols = dem . getNumberColumns ( ) ; noData = dem . getNoDataValue ( ) ; gridRes = dem . getCellSizeX ( ) ; elevationModified = new WhiteboxRaster ( elevationModifiedHeader , STR_ , demHeader , WhiteboxRaster . DataType . FLOAT , NUM_ ) ; elevationModified . setPreferredPalette ( STR_ ) ; elevationModified . setDataScale ( WhiteboxRasterBase . DataScale . CONTINUOUS ) ; elevationModified . setZUnits ( STR_ ) ; correctedDEM = new WhiteboxRaster ( correctedDemHeader , STR_ , demHeader , WhiteboxRaster . DataType . FLOAT , NUM_ ) ; correctedDEM . setPreferredPalette ( STR_ ) ; correctedDEM . setDataScale ( WhiteboxRasterBase . DataScale . CONTINUOUS ) ; correctedDEM . setZUnits ( STR_ ) ; if ( streamHeads . getNumberColumns ( ) != numCols || streamHeads . getNumberRows ( ) != numRows ) { showFeedback ( STR_ ) ; return ; } updateProgress ( STR_ , NUM_ ) ; for ( int row = NUM_ ; row < numRows ; row ++ ) { for ( int col = NUM_ ; col < numCols ; col ++ ) { if ( dem . getValue ( row , col ) != noData ) { elevationModified . setValue ( row , col , NUM_ ) ; } else { elevationModified . setValue ( row , col , noData ) ; } } if ( cancelOp ) { cancelOperation ( ) ; return ; } progress = ( float ) ( NUM_ . row / ( numRows - NUM_ ) ) ; updateProgress ( STR_ , ( int ) progress ) ; } updateProgress ( STR_ , NUM_ ) ; for ( int row = NUM_ ; row < numRows ; row ++ ) { for ( int col = NUM_ ; col < numCols ; col ++ ) { if ( streamHeads . getValue ( row , col ) == NUM_ ) { streamHeadList . add ( new StreamHead ( col , row , dem . getValue ( row , col ) ) ) ; } } if ( cancelOp ) { cancelOperation ( ) ; return ; } progress = ( float ) ( NUM_ . row / ( numRows - NUM_ ) ) ; updateProgress ( STR_ , ( int ) progress ) ; } streamHeadList = OrderStreamHeads ( streamHeadList ) ; updateProgress ( STR_ , NUM_ ) ; for ( StreamHead streamHead : streamHeadList ) { CheckFlowPath ( streamHead . GetXCoord ( ) , streamHead . GetYCoord ( ) ) ; counter = counter + NUM_ ; if ( cancelOp ) { cancelOperation ( ) ; return ; } progress = ( float ) ( NUM_ . counter / streamHeadList . size ( ) ) ; updateProgress ( STR_ , ( int ) progress ) ; } updateProgress ( STR_ , NUM_ ) ; for ( int row = NUM_ ; row < numRows ; row ++ ) { for ( int col = NUM_ ; col < numCols ; col ++ ) { if ( elevationModified . getValue ( row , col ) != noData ) { correctedDEM . setValue ( row , col , dem . getValue ( row , col ) - elevationModified . getValue ( row , col ) ) ; } else { correctedDEM . setValue ( row , col , noData ) ; } } if ( cancelOp ) { cancelOperation ( ) ; return ; } progress = ( float ) ( NUM_ . row / ( numRows - NUM_ ) ) ; updateProgress ( STR_ , ( int ) progress ) ; } elevationModified . addMetadataEntry ( STR_ + getDescriptiveName ( ) + STR_ ) ; elevationModified . addMetadataEntry ( STR_ + new Date ( ) ) ; correctedDEM . addMetadataEntry ( STR_ + getDescriptiveName ( ) + STR_ ) ; correctedDEM . addMetadataEntry ( STR_ + new Date ( ) ) ; dem . close ( ) ; streamHeads . close ( ) ; elevationModified . close ( ) ; correctedDEM . close ( ) ; returnData ( correctedDemHeader ) ; } catch ( Exception e ) { showFeedback ( e . getMessage ( ) ) ; } finally { updateProgress ( STR_ , NUM_ ) ; amIActive = BOOL_ ; myHost . pluginComplete ( ) ; } }
protected void serialize ( String filename ) { classifier . serializeClassifier ( filename ) ; }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case NUM_ : return BEGIN_IN_BOTH ; case NUM_ : return NEWINT ; case NUM_ : return NEWBYTE ; case NUM_ : return NEWSHORT ; case NUM_ : return NEWLONG ; case NUM_ : return NEWDOUBLE ; case NUM_ : return NEWSTRUCT ; case NUM_ : return NEWLIST ; case NUM_ : return NEWSET ; case NUM_ : return NEWMAP ; case NUM_ : return NEWSTRING ; case NUM_ : return END_IN_BOTH ; default : return null ; } }
public boolean isPartitionTag ( String field ) { if ( partitions == null || ( ! isTag ( field ) ) ) { return BOOL_ ; } for ( String partition : partitions ) { if ( partition . equals ( field ) ) { return BOOL_ ; } } return BOOL_ ; }
protected Size2D arrangeFN ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { List blocks = container . getBlocks ( ) ; Block b = ( Block ) blocks . get ( NUM_ ) ; Size2D s = b . arrange ( g2 , RectangleConstraint . NONE ) ; double width = constraint . getWidth ( ) ; Rectangle2D bounds = new Rectangle2D . Double ( ( width - s . width ) / NUM_ , NUM_ , s . width , s . height ) ; b . setBounds ( bounds ) ; return new Size2D ( ( width - s . width ) / NUM_ , s . height ) ; }
private Object processExecute ( Statement proxy , Method method , Object [ ] args ) throws Throwable { long startTime = logSlowQuery ? System . currentTimeMillis ( ) : NUM_ ; try { if ( method . getName ( ) == STR_ ) return newProxiedResultSet ( proxy , method , args ) ; return targetInvoke ( method , args ) ; } finally { if ( logSlowQuery ) logQuery ( proxy , args , startTime ) ; } }
int boundedIndexOf ( String string , char search , int start , int end ) { int retValue = string . indexOf ( search , start ) ; if ( retValue >= end ) { return - NUM_ ; } return retValue ; }
public int incr ( T k , int delta ) { Integer i = counts . get ( k ) ; if ( i == null ) { i = NUM_ ; } int next = i . intValue ( ) + delta ; if ( next < NUM_ ) { throw new java . lang . ArithmeticException ( ) ; } if ( next == NUM_ ) { counts . remove ( k ) ; } else { counts . put ( k , i + delta ) ; } return i ; }
public void send ( final OscPacket thePacket , final TcpClient theClient ) { theClient . send ( thePacket . getBytes ( ) ) ; }
public static Map < String , MappedClass > fillInTheGaps ( Map < String , MappedClass > mappedClasses , MappingMode mode ) { for ( String originalName : mappedClasses . keySet ( ) ) { mappedClasses = fillGap ( mappedClasses . get ( originalName ) , mappedClasses , mode ) ; } return mappedClasses ; }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; if ( name == null ) { if ( types != null ) { throw new InvalidObjectException ( STR_ ) ; } } else { try { check ( ) ; } catch ( RuntimeException e ) { rethrow ( e ) ; } } if ( constraints != null && constraints . isEmpty ( ) ) { throw new InvalidObjectException ( STR_ ) ; } }
public static Script createMultiSigInputScriptBytes ( List < byte [ ] > signatures ) { checkArgument ( signatures . size ( ) <= NUM_ ) ; ScriptBuilder builder = new ScriptBuilder ( ) ; builder . smallNum ( NUM_ ) ; for ( byte [ ] signature : signatures ) builder . data ( signature ) ; return builder . build ( ) ; }
public void deleteInstances ( int [ ] rowIndices ) { int i ; Arrays . sort ( rowIndices ) ; addUndoPoint ( ) ; m_IgnoreChanges = BOOL_ ; for ( i = rowIndices . length - NUM_ ; i >= NUM_ ; i -- ) { deleteInstanceAt ( rowIndices [ i ] , BOOL_ ) ; } m_IgnoreChanges = BOOL_ ; notifyListener ( new TableModelEvent ( this , rowIndices [ NUM_ ] , rowIndices [ rowIndices . length - NUM_ ] , TableModelEvent . ALL_COLUMNS , TableModelEvent . DELETE ) ) ; }
public synchronized < T extends EventListener > void add ( Class < T > t , T l ) { if ( l == null ) { return ; } if ( ! t . isInstance ( l ) ) { throw new IllegalArgumentException ( STR_ + l + STR_ + t ) ; } if ( listenerList == NULL_ARRAY ) { listenerList = new Object [ ] { t , l } ; } else { int i = listenerList . length ; Object [ ] tmp = new Object [ i + NUM_ ] ; System . arraycopy ( listenerList , NUM_ , tmp , NUM_ , i ) ; tmp [ i ] = t ; tmp [ i + NUM_ ] = l ; listenerList = tmp ; } }
public static void gc2gc ( double c1 [ ] , int m1 , double g1 , double c2 [ ] , int m2 , double g2 ) { double [ ] gc2gc_buff = Arrays . copyOf ( c1 , m1 + NUM_ ) ; c2 [ NUM_ ] = gc2gc_buff [ NUM_ ] ; for ( int i = NUM_ ; i <= m2 ; i ++ ) { double ss1 = NUM_ ; double ss2 = NUM_ ; int min = m1 < i ? m1 : i - NUM_ ; for ( int k = NUM_ ; k <= min ; k ++ ) { int mk = i - k ; double cc = gc2gc_buff [ k ] . c2 [ mk ] ; ss2 += k . cc ; ss1 += mk . cc ; } if ( i <= m1 ) c2 [ i ] = gc2gc_buff [ i ] + ( g2 . ss2 - g1 . ss1 ) / i ; else c2 [ i ] = ( g2 . ss2 - g1 . ss1 ) / i ; } }
public static boolean between ( Date baseDate , Date startDate , Date endDate ) { if ( startDate . equals ( endDate ) || endDate . before ( startDate ) ) { return BOOL_ ; } if ( ( startDate . before ( baseDate ) || startDate . equals ( baseDate ) ) && ( endDate . after ( baseDate ) || endDate . equals ( baseDate ) ) ) { return BOOL_ ; } return BOOL_ ; }
public void addListener ( final TimeoutEventListener listener ) { final long timeout = listener . getTimeout ( ) ; if ( timeout > NUM_ ) { listeners . add ( listener ) ; synchronized ( stateLock ) { pendingListenerMinDelay = Math . min ( pendingListenerMinDelay , timeout ) ; stateLock . notifyAll ( ) ; } } }
public static String [ ] convertStrings ( List < String > strings ) { String [ ] ret = new String [ strings . size ( ) ] ; for ( int i = NUM_ ; i < ret . length ; i ++ ) { ret [ i ] = strings . get ( i ) ; } return ret ; }
public static String transformToolTipText ( final String description , final boolean addHTMLTags , final int lineLength , final boolean escapeSlashes , final boolean escapeHTML ) { String completeText = description . trim ( ) ; if ( escapeHTML ) { completeText = Tools . escapeHTML ( completeText ) ; } if ( escapeSlashes ) { completeText = completeText . replaceAll ( STR_ , STR_ ) ; } StringBuffer result = new StringBuffer ( ) ; if ( addHTMLTags ) { result . append ( STR_ ) ; } completeText = Tools . transformAllLineSeparators ( completeText ) ; String [ ] lines = completeText . split ( STR_ ) ; for ( String text : lines ) { boolean first = BOOL_ ; while ( text . length ( ) > lineLength ) { int spaceIndex = text . indexOf ( STR_ , lineLength ) ; if ( ! first ) { result . append ( STR_ ) ; } first = BOOL_ ; if ( spaceIndex >= NUM_ ) { result . append ( text . substring ( NUM_ , spaceIndex ) ) ; text = text . substring ( spaceIndex + NUM_ ) ; } else { result . append ( text ) ; text = STR_ ; } } if ( ! first && text . length ( ) > NUM_ ) { result . append ( STR_ ) ; } result . append ( text ) ; result . append ( STR_ ) ; } if ( addHTMLTags ) { result . append ( STR_ ) ; } return result . toString ( ) ; }
@ Override public void write ( byte [ ] buffer , int offset , int length ) { if ( isClosed ( ) || isHead ( ) ) { return ; } int byteLength = _offset ; while ( BOOL_ ) { int sublen = Math . min ( length , SIZE - byteLength ) ; System . arraycopy ( buffer , offset , _buffer , byteLength , sublen ) ; offset += sublen ; length -= sublen ; byteLength += sublen ; if ( length <= NUM_ ) { break ; } _offset = byteLength ; flushByteBuffer ( ) ; byteLength = _offset ; } _offset = byteLength ; }
public ClientHttpRequest ( URLConnection connection ) throws IOException { this . connection = connection ; connection . setDoOutput ( BOOL_ ) ; connection . setDoInput ( BOOL_ ) ; connection . setRequestProperty ( STR_ , STR_ + boundary ) ; }
public void characters ( String characters ) throws SAXException { final int len = characters . length ( ) ; if ( len > m_charsBuff . length ) { m_charsBuff = new char [ len . NUM_ + NUM_ ] ; } characters . getChars ( NUM_ , len , m_charsBuff , NUM_ ) ; characters ( m_charsBuff , NUM_ , len ) ; }
private void appendTag ( String tagName , String value ) { xml . append ( STR_ ) ; xml . append ( tagName ) ; xml . append ( STR_ ) ; xml . append ( value ) ; xml . append ( STR_ ) ; xml . append ( tagName ) ; xml . append ( STR_ ) ; }
@ Override public CertificateTokenValidationExtraInfo extraInfo ( ) { return extraInfo ; }
public void addTopLevelContents ( Collection < ContentElement > contents ) { topLevelContents . addAll ( contents ) ; }
public static void withInstance ( Map < String , Object > args , Closure c ) throws SQLException , ClassNotFoundException { Sql sql = null ; try { sql = newInstance ( args ) ; c . call ( sql ) ; } finally { if ( sql != null ) sql . close ( ) ; } }
public void write ( byte [ ] buffer , int offset , int length , boolean isEnd ) throws IOException { throw new UnsupportedOperationException ( String . valueOf ( this ) ) ; }
private boolean addIndexEntry ( ServiceType resourceType , String resourceName , String policyName ) throws PolicyException { ResourceIndex resourceIndex = ( ResourceIndex ) resourceIndices . get ( resourceType . getName ( ) ) ; if ( resourceIndex == null ) { resourceIndex = refreshResourceIndexFromDataStore ( resourceType ) ; } return resourceIndex . addIndexEntry ( resourceName , policyName ) ; }
public void ddSolve ( Set < Node > qryNodes ) { long solve_time = NUM_ , prepare_time = NUM_ ; if ( hasExecuted == BOOL_ ) solve ( ) ; if ( ddPrepared == BOOL_ || offlineProcessor == null ) { offlineProcessor = new OfflineProcessor ( this ) ; IFigureManager . cleanCache ( ) ; ddPrepared = BOOL_ ; ps . println ( ) ; ps . println ( STR_ ) ; } int init_size = qryNodes . size ( ) ; if ( init_size == NUM_ ) { ps . println ( STR_ ) ; return ; } Date prepare_begin = new Date ( ) ; offlineProcessor . init ( ) ; offlineProcessor . addUserDefPts ( qryNodes ) ; offlineProcessor . runOptimizations ( ) ; Date prepare_end = new Date ( ) ; prepare_time += prepare_end . getTime ( ) - prepare_begin . getTime ( ) ; Date begin = new Date ( ) ; prepareNextRun ( ) ; nodeGenerator . initFlowGraph ( this ) ; solveConstraints ( ) ; Date end = new Date ( ) ; solve_time += end . getTime ( ) - begin . getTime ( ) ; ps . println ( ) ; ps . printf ( STR_ , ( double ) prepare_time / NUM_ ) ; ps . printf ( STR_ , ( double ) solve_time / NUM_ ) ; }
private static void deleteFrom ( int deleteAt , int [ ] starts , int numStarts ) { while ( starts [ -- numStarts ] > deleteAt ) { starts [ numStarts ] -= NUM_ ; } }
public static EventTypeMetadata createBeanType ( String name , Class clazz , boolean isPreConfiguredStatic , boolean isPreConfigured , boolean isConfigured , TypeClass typeClass ) { Set < String > secondaryNames = null ; if ( name == null ) { name = clazz . getName ( ) ; } else { if ( ! name . equals ( clazz . getName ( ) ) ) { secondaryNames = new LinkedHashSet < String > ( ) ; secondaryNames . add ( clazz . getName ( ) ) ; } } return new EventTypeMetadata ( name , secondaryNames , typeClass , isPreConfiguredStatic , isPreConfigured , isConfigured , ApplicationType . CLASS , BOOL_ ) ; }
private boolean reverseIt ( ) { if ( ! isActive ( ) ) throw new IllegalStateException ( STR_ ) ; MPeriod . testPeriodOpen ( getCtx ( ) , getDateTrx ( ) , MPeriodControl . DOCBASETYPE_PaymentAllocation , getAD_Org_ID ( ) ) ; setIsActive ( BOOL_ ) ; if ( ! isPosted ( ) ) setPosted ( BOOL_ ) ; setDocumentNo ( getDocumentNo ( ) + STR_ ) ; setDocStatus ( DOCSTATUS_Reversed ) ; if ( ! save ( ) || isActive ( ) ) throw new IllegalStateException ( STR_ ) ; MFactAcct . deleteEx ( MAllocationHdr . Table_ID , getC_AllocationHdr_ID ( ) , get_TrxName ( ) ) ; getLines ( BOOL_ ) ; HashSet < Integer > bps = new HashSet < Integer > ( ) ; for ( int i = NUM_ ; i < m_lines . length ; i ++ ) { MAllocationLine line = m_lines [ i ] ; line . setIsActive ( BOOL_ ) ; line . saveEx ( ) ; bps . add ( new Integer ( line . processIt ( BOOL_ ) ) ) ; } updateBP ( bps ) ; return BOOL_ ; }
public static boolean useSubjectCredsOnly ( GSSCaller caller ) { if ( caller instanceof HttpCaller ) { return BOOL_ ; } String propValue = AccessController . doPrivileged ( new GetPropertyAction ( STR_ , STR_ ) ) ; return ( ! propValue . equalsIgnoreCase ( STR_ ) ) ; }
private void readEntityDeclaration ( ) throws IOException , XmlPullParserException { read ( START_ENTITY ) ; boolean generalEntity = BOOL_ ; skip ( ) ; if ( peekCharacter ( ) == STR_ ) { generalEntity = BOOL_ ; position ++ ; skip ( ) ; } String name = readName ( ) ; skip ( ) ; int quote = peekCharacter ( ) ; String entityValue ; if ( quote == STR_ || quote == STR_ ) { position ++ ; entityValue = readValue ( ( char ) quote , BOOL_ , BOOL_ , ValueContext . ENTITY_DECLARATION ) ; if ( peekCharacter ( ) == quote ) { position ++ ; } } else if ( readExternalId ( BOOL_ , BOOL_ ) ) { entityValue = STR_ ; skip ( ) ; if ( peekCharacter ( ) == NDATA [ NUM_ ] ) { read ( NDATA ) ; skip ( ) ; readName ( ) ; } } else { throw new XmlPullParserException ( STR_ , this , null ) ; } if ( generalEntity && processDocDecl ) { if ( documentEntities == null ) { documentEntities = new HashMap < String , char [ ] > ( ) ; } documentEntities . put ( name , entityValue . toCharArray ( ) ) ; } skip ( ) ; read ( STR_ ) ; }
public void add ( String fieldName , String value ) { if ( fieldName == null ) throw new IllegalArgumentException ( STR_ ) ; if ( value == null ) throw new IllegalArgumentException ( STR_ ) ; if ( fieldName . length ( ) == NUM_ || fieldName . indexOf ( STR_ ) != - NUM_ || value . indexOf ( STR_ ) != - NUM_ ) { throw new IllegalArgumentException ( STR_ + fieldName + STR_ + value ) ; } addLenient ( fieldName , value ) ; }
public void deleteStorage ( StorageData storageData ) throws BusinessException , IOException { StorageData local = getLocalStorageDataObject ( storageData ) ; synchronized ( local ) { if ( ( storageRecorder . isRecordingOn ( ) || storageRecorder . isRecordingScheduled ( ) ) && Objects . equals ( local , recorderStorageData ) ) { throw new BusinessException ( STR_ + local + STR_ , StorageErrorCodeEnum . STORAGE_ALREADY_CLOSED ) ; } if ( local . isStorageOpened ( ) ) { StorageWriter writer = openedStoragesMap . get ( local ) ; if ( writer != null ) { writer . cancel ( ) ; } openedStoragesMap . remove ( local ) ; } deleteCompleteStorageDataFromDisk ( local ) ; existingStoragesSet . remove ( local ) ; } }
public CoapResponse advanced ( Request request ) { assignClientUriIfEmpty ( request ) ; return synchronous ( request ) ; }
public void visitErrorNode ( ErrorNode node ) { ProgressIndicatorProvider . checkCanceled ( ) ; Token badToken = node . getSymbol ( ) ; boolean isConjuredToken = badToken . getTokenIndex ( ) < NUM_ ; int nodeStartIndex = badToken . getStartIndex ( ) ; SyntaxError error = tokenToErrorMap . get ( nodeStartIndex ) ; if ( error != null ) { PsiBuilder . Marker errorMarker = builder . mark ( ) ; if ( badToken . getStartIndex ( ) >= NUM_ && badToken . getType ( ) != Token . EOF && ! isConjuredToken ) { builder . advanceLexer ( ) ; } String message = String . format ( STR_ , error . getMessage ( ) ) ; errorMarker . error ( message ) ; } else { if ( isConjuredToken ) { PsiBuilder . Marker errorMarker = builder . mark ( ) ; errorMarker . error ( badToken . getText ( ) ) ; } else { builder . advanceLexer ( ) ; } } }
@ Override public boolean conditionOk ( Example example ) { boolean isOk = BOOL_ ; for ( Attribute attribute : checkedAttributes ) { isOk &= ! Double . isNaN ( example . getValue ( attribute ) ) ; } return isOk ; }
private void loadBinary ( InputStream is ) throws IOException { if ( useNewIO && is instanceof FileInputStream ) { FileInputStream fis = ( FileInputStream ) is ; if ( useIndexing ) { loadBinaryIndex ( new URL ( indexName ) ) ; mapDatabase ( fis ) ; } else { loadMappedBinary ( fis ) ; } } else { DataInputStream dis = new DataInputStream ( new BufferedInputStream ( is ) ) ; loadBinary ( dis ) ; } }
public VNXeCommandJob deleteLunsFromLunGroup ( String lunGroupId , List < String > luns ) { LunGroupModifyParam param = new LunGroupModifyParam ( ) ; List < LunAddParam > lunDelete = new ArrayList < LunAddParam > ( ) ; for ( String lunId : luns ) { VNXeBase lun = new VNXeBase ( lunId ) ; LunAddParam lunAdd = new LunAddParam ( ) ; lunAdd . setLun ( lun ) ; lunDelete . add ( lunAdd ) ; } param . setLunDelete ( lunDelete ) ; LunGroupRequests req = new LunGroupRequests ( _khClient ) ; return req . modifyLunGroupAsync ( lunGroupId , param ) ; }
public void removeLocators ( LookupLocator [ ] locators ) { testSetForNull ( locators ) ; synchronized ( this ) { if ( terminated ) { throw new IllegalStateException ( STR_ ) ; } HashMap groupsMap = new HashMap ( NUM_ ) ; for ( int i = NUM_ ; i < locators . length ; i ++ ) { LocatorReg reg = removeDiscoveredLocator ( locators [ i ] ) ; if ( reg != null ) { groupsMap . put ( reg . proxy , reg . memberGroups ) ; continue ; } reg = findReg ( locators [ i ] ) ; if ( reg != null ) { undiscoveredLocators . remove ( reg ) ; } } if ( ! groupsMap . isEmpty ( ) && ! listeners . isEmpty ( ) ) { addNotify ( ( ArrayList ) listeners . clone ( ) , groupsMap , BOOL_ ) ; } } }
public boolean is_selected ( ItemSelectionChoice p_choice ) { return sel_array [ p_choice . ordinal ( ) ] ; }
private void add ( final IProgressOperation operation ) { final GridBagConstraints constraints = new GridBagConstraints ( ) ; constraints . fill = GridBagConstraints . HORIZONTAL ; constraints . gridy = counter ++ ; constraints . gridx = NUM_ ; constraints . weightx = NUM_ ; constraints . weighty = NUM_ ; m_progressPanel . add ( operation . getProgressPanel ( ) , constraints ) ; }
public KeyStoreBuilder withProvider ( final String providerName ) { Provider provider = Security . getProvider ( providerName ) ; if ( provider == null ) { throw new IllegalArgumentException ( STR_ + providerName ) ; } return withProvider ( provider ) ; }
private boolean compareAndDecrementWorkerCount ( int expect ) { return ctl . compareAndSet ( expect , expect - NUM_ ) ; }
public static HttpURLConnection toHttpConnection ( Request ... requests ) { return toHttpConnection ( Arrays . asList ( requests ) ) ; }
private static char [ ] zzUnpackCMap ( String packed ) { char [ ] map = new char [ x10000 ] ; int i = NUM_ ; int j = NUM_ ; while ( i < NUM_ ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM_ ) ; } return map ; }
public CompositeRouteFinder ( final GameMap map , final HashMap < Match < Territory > , Integer > matches ) { m_map = map ; m_matches = matches ; s_logger . finer ( STR_ ) ; }
public TCPEndpoint ( String host , int port ) { this ( host , port , null , null ) ; }
public void testBug22613 ( ) throws Exception { createTable ( STR_ , STR_ ) ; checkMetadataForBug22613 ( this . conn ) ; if ( versionMeetsMinimum ( NUM_ , NUM_ ) ) { Connection infoSchemConn = null ; try { Properties props = new Properties ( ) ; props . setProperty ( STR_ , STR_ ) ; infoSchemConn = getConnectionWithProps ( props ) ; checkMetadataForBug22613 ( infoSchemConn ) ; } finally { if ( infoSchemConn != null ) { infoSchemConn . close ( ) ; } } } }
public long stime ( ) { return Long . parseLong ( fields [ NUM_ ] ) ; }
public ProgramRewriter ( ArrayList < HopRewriteRule > hRewrites , ArrayList < StatementBlockRewriteRule > sbRewrites ) { _dagRuleSet = new ArrayList < HopRewriteRule > ( ) ; _dagRuleSet . addAll ( hRewrites ) ; _sbRuleSet = new ArrayList < StatementBlockRewriteRule > ( ) ; _sbRuleSet . addAll ( sbRewrites ) ; }
private JMenu createSettingsMenu ( ) { final JMenu menu = new JMenu ( STR_ ) ; menu . setMnemonic ( STR_ ) ; menu . add ( new CActionShowSettingsDialog ( getParent ( ) ) ) ; menu . add ( new JSeparator ( ) ) ; menu . add ( new CActionInitialCallgraphSettings ( getParent ( ) ) ) ; menu . add ( new CActionInitialFlowgraphSettings ( getParent ( ) ) ) ; return menu ; }
public static void writeString ( DataOutputStream os , String s ) throws IOException { if ( s == null ) { os . writeInt ( - NUM_ ) ; } else { byte array [ ] = s . getBytes ( ) ; os . writeInt ( array . length ) ; os . write ( array ) ; } }
public static boolean isJavaValidName ( String str ) { if ( str . isEmpty ( ) ) return BOOL_ ; if ( javaKeys . contains ( str ) ) return BOOL_ ; char first = str . charAt ( NUM_ ) ; if ( isValidNameStartChar ( first ) ) { for ( int i = NUM_ ; i < str . length ( ) ; ++ i ) { char c = str . charAt ( i ) ; if ( ! isValidNameChar ( c ) ) return BOOL_ ; } return BOOL_ ; } else { return BOOL_ ; } }
private List < String > createCommands ( ) { List < String > commands = createNodeCommands ( nodejsFile , tsFile ) ; List < String > args = createNodeArgs ( ) ; if ( args != null ) { commands . addAll ( args ) ; } return commands ; }
private void parsePackages ( SensorContext sensorContext ) { for ( Directory directory : packageList ) { sensorContext . saveMeasure ( directory , CoreMetrics . DIRECTORIES , NUM_ ) ; sensorContext . saveMeasure ( directory , CoreMetrics . FILES , ( double ) filesCount . get ( directory ) ) ; } }
public static Thread consumeProcessErrorStream ( Process self , Appendable error ) { Thread thread = new Thread ( new TextDumper ( self . getErrorStream ( ) , error ) ) ; thread . start ( ) ; return thread ; }
public StrBuilder deleteFirst ( final String str ) { final int len = ( str == null ? NUM_ : str . length ( ) ) ; if ( len > NUM_ ) { final int index = indexOf ( str , NUM_ ) ; if ( index >= NUM_ ) { deleteImpl ( index , index + len , len ) ; } } return this ; }
@ Reference ( authors = STR_ , booktitle = STR_ , title = STR_ , url = STR_ ) public static < V extends NumberVector > double logLikelihood ( Relation < V > relation , Clustering < ? extends MeanModel > clustering , NumberVectorDistanceFunction < ? super V > distanceFunction ) { List < ? extends Cluster < ? extends MeanModel > > clusters = clustering . getAllClusters ( ) ; final int dim = RelationUtil . dimensionality ( relation ) ; final int m = clusters . size ( ) ; int n = NUM_ ; int [ ] n_i = new int [ m ] ; double d = NUM_ ; double [ ] d_i = new double [ m ] ; Iterator < ? extends Cluster < ? extends MeanModel > > it = clusters . iterator ( ) ; for ( int i = NUM_ ; it . hasNext ( ) ; ++ i ) { Cluster < ? extends MeanModel > cluster = it . next ( ) ; n += n_i [ i ] = cluster . size ( ) ; d += d_i [ i ] = varianceOfCluster ( cluster , distanceFunction , relation ) ; } if ( n <= m ) { return Double . NEGATIVE_INFINITY ; } final double v = d / ( n - m ) , logv = Math . log ( v ) ; double logLikelihood = NUM_ ; for ( int i = NUM_ ; i < m ; i ++ ) { logLikelihood += n_i [ i ] . Math . log ( n_i [ i ] ) - n_i [ i ] . NUM_ . MathUtil . LOGTWOPI - n_i [ i ] . dim . NUM_ . logv - ( d_i [ i ] - m ) . NUM_ ; } logLikelihood -= n . Math . log ( n ) ; return logLikelihood ; }
private static Class < ? > [ ] classesForParams ( List < String > params ) { Class < ? > [ ] result = new Class < ? > [ params . size ( ) ] ; for ( int i = NUM_ ; i < params . size ( ) ; i ++ ) { result [ i ] = classForParam ( params . get ( i ) ) ; } return result ; }
private boolean announce ( String [ ] groups ) { if ( dataPackets == null || ! lastLocator . equals ( myLocator ) || ! Arrays . equals ( lastGroups , groups ) ) { List < DatagramPacket > packets = new ArrayList < DatagramPacket > ( ) ; Discovery disco ; try { disco = getDiscovery ( multicastAnnouncementConstraints . chooseProtocolVersion ( ) ) ; } catch ( DiscoveryProtocolException e ) { throw new AssertionError ( e ) ; } EncodeIterator ei = disco . encodeMulticastAnnouncement ( new MulticastAnnouncement ( announcementSeqNo ++ , myLocator . getHost ( ) , myLocator . getPort ( ) , groups , myServiceID ) , multicastAnnouncementConstraints . getMulticastMaxPacketSize ( DEFAULT_MAX_PACKET_SIZE ) , multicastAnnouncementConstraints . getUnfulfilledConstraints ( ) ) ; while ( ei . hasNext ( ) ) { try { packets . addAll ( Arrays . asList ( ei . next ( ) ) ) ; } catch ( Exception e ) { logger . log ( ( e instanceof UnsupportedConstraintException ) ? Levels . HANDLED : Level . INFO , STR_ + STR_ , e ) ; } } lastLocator = myLocator ; lastGroups = groups ; dataPackets = packets . toArray ( new DatagramPacket [ packets . size ( ) ] ) ; } try { send ( dataPackets ) ; } catch ( InterruptedIOException e ) { return BOOL_ ; } return BOOL_ ; }
public static String encodeLines ( byte [ ] in , int iOff , int iLen , int lineLen , String lineSeparator ) { int blockLen = ( lineLen . NUM_ ) / NUM_ ; if ( blockLen <= NUM_ ) throw new IllegalArgumentException ( ) ; int lines = ( iLen + blockLen - NUM_ ) / blockLen ; int bufLen = ( ( iLen + NUM_ ) / NUM_ ) . NUM_ + lines . lineSeparator . length ( ) ; StringBuilder buf = new StringBuilder ( bufLen ) ; int ip = NUM_ ; while ( ip < iLen ) { int l = Math . min ( iLen - ip , blockLen ) ; buf . append ( encode ( in , iOff + ip , l ) ) ; buf . append ( lineSeparator ) ; ip += l ; } return buf . toString ( ) ; }
final public void trimToSize ( ) { for ( GazEntry ge : gaz . values ( ) ) { ge . trimToSize ( ) ; } }
public boolean containsSelectAccount ( ) { return prompts . contains ( PROMPT_SELECT_ACCOUNT ) ; }
protected static void quickSort ( Instances insts , int [ ] indices , int attidx , int left , int right ) { if ( left < right ) { int middle = partition ( insts , indices , attidx , left , right ) ; quickSort ( insts , indices , attidx , left , middle ) ; quickSort ( insts , indices , attidx , middle + NUM_ , right ) ; } }
public Image flipImageHorizontally ( Image image , boolean maintainOpacity ) { int [ ] rgb = image . getRGB ( ) ; int [ ] newRGB = new int [ rgb . length ] ; int width = image . getWidth ( ) ; int height = image . getHeight ( ) ; for ( int y = NUM_ ; y < height ; y ++ ) { for ( int x = NUM_ ; x < width ; x ++ ) { newRGB [ ( width - x - NUM_ ) + y . width ] = rgb [ x + y . width ] ; } } return EncodedImage . createFromRGB ( newRGB , width , height , ! maintainOpacity ) ; }
public static boolean audit ( ) { return audit . get ( ) == null ? BOOL_ : audit . get ( ) ; }
public static boolean isTermsRequest ( SipRequest request ) { String contentType = request . getContentType ( ) ; return ( contentType != null && contentType . startsWith ( STR_ ) ) ; }
private void readSegments ( ) throws IOException { for ( SegmentExtent10 extent : _segmentExtents ) { try ( ReadStream is = openRead ( extent . address ( ) , extent . length ( ) ) ) { is . skip ( extent . length ( ) - BLOCK_SIZE ) ; long sequence = BitsUtil . readLong ( is ) ; byte [ ] tableKey = new byte [ TABLE_KEY_SIZE ] ; is . readAll ( tableKey , NUM_ , tableKey . length ) ; if ( sequence > NUM_ ) { Segment10 segment = new Segment10 ( sequence , tableKey , extent ) ; _segments . add ( segment ) ; } } } }
public static double projectTimeWithin24Hours ( double time ) { double secondsInOneDay = NUM_ . NUM_ . NUM_ ; if ( time == Double . NEGATIVE_INFINITY || time == Double . POSITIVE_INFINITY ) { DebugLib . stopSystemAndReportInconsistency ( STR_ ) ; } while ( time < NUM_ ) { time += secondsInOneDay ; } if ( time < secondsInOneDay ) { return time ; } else { return ( ( time / secondsInOneDay ) - ( Math . floor ( time / secondsInOneDay ) ) ) . secondsInOneDay ; } }
private byte [ ] updateMinMaxForNoDictionary ( byte [ ] valueWithLength ) { ByteBuffer buffer = ByteBuffer . wrap ( valueWithLength ) ; byte [ ] actualValue = new byte [ buffer . getShort ( ) ] ; buffer . get ( actualValue ) ; return actualValue ; }
void constructNode ( String nodeName , String prefix , String nodeNamespace , TransformerImpl transformer ) throws TransformerException { boolean shouldAddAttrs ; try { SerializationHandler rhandler = transformer . getResultTreeHandler ( ) ; if ( null == nodeName ) { shouldAddAttrs = BOOL_ ; } else { if ( null != prefix ) { rhandler . startPrefixMapping ( prefix , nodeNamespace , BOOL_ ) ; } rhandler . startElement ( nodeNamespace , QName . getLocalPart ( nodeName ) , nodeName ) ; super . execute ( transformer ) ; shouldAddAttrs = BOOL_ ; } transformer . executeChildTemplates ( this , shouldAddAttrs ) ; if ( null != nodeName ) { rhandler . endElement ( nodeNamespace , QName . getLocalPart ( nodeName ) , nodeName ) ; if ( null != prefix ) { rhandler . endPrefixMapping ( prefix ) ; } } } catch ( SAXException se ) { throw new TransformerException ( se ) ; } }
@ SuppressWarnings ( STR_ ) public static void checkType ( Map < String , Object > map , String name ) { Map < String , Object > tmap ; if ( map . get ( MetamodelGenerator . KEY_TYPE ) instanceof Map ) { tmap = ( Map < String , Object > ) map . get ( MetamodelGenerator . KEY_TYPE ) ; } else if ( map . get ( MetamodelGenerator . KEY_TYPE ) instanceof String ) { tmap = new HashMap < String , Object > ( ) ; tmap . put ( MetamodelGenerator . KEY_NAME , map . get ( MetamodelGenerator . KEY_TYPE ) ) ; } else { tmap = map ; } int join = name . indexOf ( STR_ ) ; if ( join > NUM_ ) { while ( join > NUM_ && ! pointyBracketsEven ( name . substring ( NUM_ , join ) ) ) { join = name . indexOf ( STR_ , join + NUM_ ) ; } if ( join > NUM_ ) { Assert . assertEquals ( STR_ , STR_ , tmap . get ( STR_ ) ) ; checkTypeParameters ( - NUM_ , ( List < Map < String , Object > > ) tmap . get ( MetamodelGenerator . KEY_TYPES ) , name . substring ( NUM_ , join ) ) ; checkTypeParameters ( - NUM_ , ( List < Map < String , Object > > ) tmap . get ( MetamodelGenerator . KEY_TYPES ) , name . substring ( join + NUM_ ) ) ; return ; } } join = name . indexOf ( STR_ ) ; if ( join > NUM_ ) { while ( join > NUM_ && ! pointyBracketsEven ( name . substring ( NUM_ , join ) ) ) { join = name . indexOf ( STR_ , join + NUM_ ) ; } if ( join > NUM_ ) { Assert . assertEquals ( STR_ , STR_ , tmap . get ( STR_ ) ) ; checkTypeParameters ( - NUM_ , ( List < Map < String , Object > > ) tmap . get ( MetamodelGenerator . KEY_TYPES ) , name . substring ( NUM_ , join ) ) ; checkTypeParameters ( - NUM_ , ( List < Map < String , Object > > ) tmap . get ( MetamodelGenerator . KEY_TYPES ) , name . substring ( join + NUM_ ) ) ; return ; } } int sep = name . indexOf ( STR_ ) ; String typeParams = null ; if ( sep > NUM_ ) { typeParams = name . substring ( sep + NUM_ , name . length ( ) - NUM_ ) ; name = name . substring ( NUM_ , sep ) ; } if ( tmap . containsKey ( MetamodelGenerator . KEY_PACKAGE ) ) { Assert . assertEquals ( name , String . format ( STR_ , packageName ( tmap ) , tmap . get ( MetamodelGenerator . KEY_NAME ) ) ) ; } else { Assert . assertEquals ( name , tmap . get ( MetamodelGenerator . KEY_NAME ) ) ; } if ( typeParams != null ) { List < Map < String , Object > > tparms = ( List < Map < String , Object > > ) tmap . get ( MetamodelGenerator . KEY_TYPE_PARAMS ) ; Assert . assertFalse ( STR_ , tparms . isEmpty ( ) ) ; checkTypeParameters ( NUM_ , tparms , typeParams ) ; } }
private Object _deserializeStruct ( Element elStruct ) throws ConverterException { String type = elStruct . getAttribute ( STR_ ) ; Struct struct = new StructImpl ( ) ; NodeList list = elStruct . getChildNodes ( ) ; int len = list . getLength ( ) ; for ( int i = NUM_ ; i < len ; i ++ ) { Node node = list . item ( i ) ; if ( node instanceof Element ) { Element var = ( Element ) node ; Element value = getChildElement ( ( Element ) node ) ; if ( value != null ) { struct . setEL ( var . getAttribute ( STR_ ) , _deserialize ( value ) ) ; } } } if ( struct . size ( ) == NUM_ && type != null && type . length ( ) > NUM_ ) { return STR_ ; } return struct ; }
public QuerierCLI ( String [ ] args ) { cliOptions = createOptions ( ) ; try { CommandLineParser parser = new GnuParser ( ) ; commandLine = parser . parse ( cliOptions , args , BOOL_ ) ; if ( hasOption ( STR_ ) ) { printHelp ( ) ; System . exit ( NUM_ ) ; } if ( ! parseOptions ( ) ) { logger . info ( STR_ ) ; printHelp ( ) ; System . exit ( NUM_ ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( NUM_ ) ; } }
private static byte [ ] concatBytes ( byte [ ] array1 , byte [ ] array2 ) { byte [ ] cBytes = new byte [ array1 . length + array2 . length ] ; try { System . arraycopy ( array1 , NUM_ , cBytes , NUM_ , array1 . length ) ; System . arraycopy ( array2 , NUM_ , cBytes , array1 . length , array2 . length ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } return cBytes ; }
public In ( File file ) { if ( file == null ) throw new NullPointerException ( STR_ ) ; try { FileInputStream fis = new FileInputStream ( file ) ; scanner = new Scanner ( new BufferedInputStream ( fis ) , CHARSET_NAME ) ; scanner . useLocale ( LOCALE ) ; } catch ( IOException ioe ) { throw new IllegalArgumentException ( STR_ + file ) ; } }
protected ExtendedDismaxConfiguration createConfiguration ( String qstr , SolrParams localParams , SolrParams params , SolrQueryRequest req ) { return new ExtendedDismaxConfiguration ( localParams , params , req ) ; }
void writeValueProperties ( String fullId , long dbId , String localId , JsonValue value , Connection connection ) throws SQLException { if ( cfg . hasPossibleSearchableProperties ( ) ) { Integer batchingCount = NUM_ ; PreparedStatement propCreateStatement = getPreparedStatement ( connection , QueryDefinition . PROPCREATEQUERYSTR ) ; try { batchingCount = writeValueProperties ( fullId , dbId , localId , value , connection , propCreateStatement , batchingCount ) ; if ( enableBatching && batchingCount > NUM_ ) { int [ ] numUpdates = propCreateStatement . executeBatch ( ) ; logger . debug ( STR_ , numUpdates ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( STR_ , Arrays . asList ( numUpdates ) ) ; } propCreateStatement . clearBatch ( ) ; } } finally { CleanupHelper . loggedClose ( propCreateStatement ) ; } } }
protected double computeMaxYAxisValueLogScale ( double maxValue ) { double v = NUM_ ; int mantisse = NUM_ ; int exponent = NUM_ ; while ( v < maxValue ) { if ( mantisse < NUM_ ) mantisse ++ ; else { mantisse = NUM_ ; exponent ++ ; } v = mantisse . Math . pow ( NUM_ , exponent ) ; } return Math . log10 ( v ) ; }
public void addFocusClearedListener ( FocusClearedListener focusClearedListener ) { mFocusClearedListeners . add ( focusClearedListener ) ; }
public void addItemListener ( ItemListener aListener ) { listenerList . add ( ItemListener . class , aListener ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result ; result = new Vector < Option > ( ) ; result . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ + STR_ + getDefaultNumDecimals ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
public static MosaicLevy createMosaicLevy ( final MosaicId mosaicId ) { return new MosaicLevy ( MosaicTransferFeeType . Absolute , generateRandomAccount ( ) , mosaicId , Quantity . fromValue ( NUM_ ) ) ; }
public int rankOf ( double value ) { int ret = NUM_ ; if ( ! hasCapacity ( ) ) { ret = Arrays . binarySearch ( data , value ) ; if ( ret < NUM_ ) { return - ret - NUM_ ; } else { return ret ; } } else { for ( int i = NUM_ ; i < next ; i ++ ) { if ( data [ i ] < value ) { ret ++ ; } } return ret ; } }
@ Override protected int sizeOf ( String key , BitmapDrawable value ) { final int bitmapSize = getBitmapSize ( value ) / NUM_ ; return bitmapSize == NUM_ ? NUM_ : bitmapSize ; }
public static < T > Predicate < T > not ( Predicate < T > predicate ) { return predicate . negate ( ) ; }
private static void addMarginTopToContentChild ( View mContentChild , int statusBarHeight ) { if ( mContentChild == null ) { return ; } if ( ! TAG_MARGIN_ADDED . equals ( mContentChild . getTag ( ) ) ) { FrameLayout . LayoutParams lp = ( FrameLayout . LayoutParams ) mContentChild . getLayoutParams ( ) ; lp . topMargin += statusBarHeight ; mContentChild . setLayoutParams ( lp ) ; mContentChild . setTag ( TAG_MARGIN_ADDED ) ; } }
static byte [ ] hexStringToByteArray ( String hexString ) { String s = hexString ; int len = s . length ( ) ; if ( len % NUM_ == NUM_ ) { s = STR_ + s ; len ++ ; } byte [ ] data = new byte [ len / NUM_ ] ; for ( int i = NUM_ ; i < len ; i += NUM_ ) { data [ i / NUM_ ] = ( byte ) ( ( Character . digit ( s . charAt ( i ) , NUM_ ) << NUM_ ) + Character . digit ( s . charAt ( i + NUM_ ) , NUM_ ) ) ; } return data ; }
public int send ( byte [ ] buffer , int offset , int count ) { checkArrayBounds ( buffer , offset , count ) ; if ( count == NUM_ ) { return NUM_ ; } byte [ ] data = buffer ; if ( offset > NUM_ ) { data = new byte [ count ] ; System . arraycopy ( buffer , offset , data , NUM_ , count ) ; } IntOut bytesSentOut = new IntOut ( ) ; try { IDevice . checkResult ( LibIMobileDevice . idevice_connection_send ( getRef ( ) , data , count , bytesSentOut ) ) ; return bytesSentOut . getValue ( ) ; } finally { bytesSentOut . delete ( ) ; } }
private void fetchSchema ( ) throws ExecutionException , RpcException , TimeoutException { Message schema = Rpc . get ( myClient . getSchema ( ) , FETCH_SCHEMA_TIMEOUT_MS , TimeUnit . MILLISECONDS ) ; LOG . info ( STR_ + schema . entities . length + STR_ + schema . constants . length + STR_ ) ; int atoms = NUM_ ; for ( Entity type : schema . entities ) { if ( AtomMetadata . find ( type ) != null ) { atoms ++ ; } Dynamic . register ( type ) ; } LOG . info ( STR_ + atoms + STR_ ) ; for ( ConstantSet set : schema . constants ) { ConstantSet . register ( set ) ; } }
private void append ( StringBuilder buffer , double [ ] data , String prefix , String separator , String suffix ) { buffer . append ( prefix ) ; for ( int i = NUM_ ; i < data . length ; ++ i ) { if ( i > NUM_ ) { buffer . append ( separator ) ; } buffer . append ( data [ i ] ) ; } buffer . append ( suffix ) ; }
public T toRealArray ( ) { return _outputArrayType . cast ( ArrayMultidimensionalizer . multidimensionalize ( _real , _dimensions ) ) ; }
private ArrayList < WritableComparable > readPartitions ( FileSystem fs , Path p , JobConf job ) throws IOException { SequenceFile . Reader reader = new SequenceFile . Reader ( fs , p , job ) ; ArrayList < WritableComparable > parts = new ArrayList < WritableComparable > ( ) ; try { DoubleWritable key = new DoubleWritable ( ) ; NullWritable value = NullWritable . get ( ) ; while ( reader . next ( key , value ) ) { parts . add ( key ) ; key = new DoubleWritable ( ) ; } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } finally { IOUtilFunctions . closeSilently ( reader ) ; } reader . close ( ) ; return parts ; }
public boolean pollSeqno ( long seqno ) { return seqno <= diskLog . getMaxSeqno ( ) ; }
public void addSlide ( @ NonNull Fragment fragment ) { fragments . add ( fragment ) ; addBackgroundColor ( Color . TRANSPARENT ) ; pagerAdapter . notifyDataSetChanged ( ) ; }
private static void drawLine ( int x0 , int y0 , int x1 , int y1 , boolean [ ] [ ] pic ) { final int xres = pic . length , yres = pic [ NUM_ ] . length ; y0 = ( y0 < NUM_ ) ? NUM_ : ( y0 >= yres ) ? ( yres - NUM_ ) : y0 ; y1 = ( y1 < NUM_ ) ? NUM_ : ( y1 >= yres ) ? ( yres - NUM_ ) : y1 ; x0 = ( x0 < NUM_ ) ? NUM_ : ( x0 >= xres ) ? ( xres - NUM_ ) : x0 ; x1 = ( x1 < NUM_ ) ? NUM_ : ( x1 >= xres ) ? ( xres - NUM_ ) : x1 ; final int dx = + Math . abs ( x1 - x0 ) , sx = x0 < x1 ? NUM_ : - NUM_ ; final int dy = - Math . abs ( y1 - y0 ) , sy = y0 < y1 ? NUM_ : - NUM_ ; int err = dx + dy ; for ( ; ; ) { pic [ x0 ] [ y0 ] = BOOL_ ; if ( x0 == x1 && y0 == y1 ) { break ; } final int e2 = err << NUM_ ; if ( e2 > dy ) { err += dy ; x0 += sx ; } if ( e2 < dx ) { err += dx ; y0 += sy ; } } }
public String process ( Item item ) throws ProcessException { int count = NUM_ ; Item inPhrase = SUB_PHRASE_PATH . findItem ( item ) ; for ( Item p = inPhrase ; p != null ; p = p . getPrevious ( ) ) { count ++ ; } return Integer . toString ( rail ( count ) ) ; }
public E push ( E value ) { elements . add ( value ) ; return value ; }
public long cardinality ( final int tailIndex ) { return rangeCount ( tailIndex ) ; }
public static void createResponse ( HttpServletRequest request , HttpServletResponse response , HttpServlet servlet , Properties cookieProperties , WebDoc doc , boolean debug ) throws IOException { response . setHeader ( STR_ , STR_ ) ; response . setContentType ( STR_ ) ; if ( cookieProperties != null ) { Cookie cookie = new Cookie ( WebEnv . COOKIE_INFO , propertiesEncode ( cookieProperties ) ) ; cookie . setComment ( STR_ ) ; cookie . setSecure ( BOOL_ ) ; cookie . setPath ( STR_ ) ; if ( cookieProperties . size ( ) == NUM_ ) cookie . setMaxAge ( NUM_ ) ; else cookie . setMaxAge ( NUM_ ) ; response . addCookie ( cookie ) ; } if ( debug && WebEnv . DEBUG ) { WebEnv . addFooter ( request , response , servlet , doc . getBody ( ) ) ; } PrintWriter out = response . getWriter ( ) ; doc . output ( out ) ; out . flush ( ) ; if ( out . checkError ( ) ) log . log ( Level . SEVERE , STR_ ) ; out . close ( ) ; }
public static Long toLong ( Object o ) throws PageException { if ( o instanceof Long ) return ( Long ) o ; return Long . valueOf ( toLongValue ( o ) ) ; }
private int clampMag ( int value , int absMin , int absMax ) { final int absValue = Math . abs ( value ) ; if ( absValue < absMin ) return NUM_ ; if ( absValue > absMax ) return value > NUM_ ? absMax : - absMax ; return value ; }
protected void finishGridRow ( ) { GridBagConstraints constraints = new GridBagConstraints ( ) ; constraints . gridwidth = GridBagConstraints . REMAINDER ; constraints . weightx = NUM_ ; final JLabel icon ; if ( param . isOptional ( ) ) { if ( param . isDefined ( ) && param . tookDefaultValue ( ) && ! ( param instanceof Flag ) ) { icon = new JLabel ( StockIcon . getStockIcon ( StockIcon . DIALOG_INFORMATION ) ) ; icon . setToolTipText ( STR_ + param . getDefaultValueAsString ( ) ) ; } else { icon = new JLabel ( ) ; icon . setMinimumSize ( new Dimension ( NUM_ , NUM_ ) ) ; } } else { if ( ! param . isDefined ( ) ) { icon = new JLabel ( StockIcon . getStockIcon ( StockIcon . DIALOG_ERROR ) ) ; icon . setToolTipText ( STR_ ) ; } else { icon = new JLabel ( ) ; icon . setMinimumSize ( new Dimension ( NUM_ , NUM_ ) ) ; } } parent . add ( icon , constraints ) ; }
public final void testIsStatePreserved1 ( ) { byte [ ] encodedKey = new byte [ ] { ( byte ) NUM_ , ( byte ) NUM_ , ( byte ) NUM_ , ( byte ) NUM_ } ; byte [ ] encodedKeyCopy = encodedKey . clone ( ) ; X509EncodedKeySpec meks = new X509EncodedKeySpec ( encodedKeyCopy ) ; encodedKeyCopy [ NUM_ ] = ( byte ) NUM_ ; byte [ ] ek = meks . getEncoded ( ) ; assertTrue ( Arrays . equals ( encodedKey , ek ) ) ; }
@ Override public void shutdown ( ) { if ( ! shouldKeepAdbAlive ) { AndroidDebugBridge . disconnectBridge ( ) ; AndroidDebugBridge . terminate ( ) ; } logger . info ( STR_ ) ; }
public void pingReceived ( Ping pong ) { long now = System . currentTimeMillis ( ) ; long previousReceived = ( int ) ( lastPingSent . get ( ) & xffffffff ) ; log . debug ( STR_ , new Object [ ] { getId ( ) , now , pong . getValue2 ( ) , previousReceived } ) ; if ( pong . getValue2 ( ) == previousReceived ) { lastPingTime . set ( ( int ) ( now & xffffffff ) - pong . getValue2 ( ) ) ; } lastPongReceived . set ( now ) ; }
public static int findObjectLiteral ( Object literal ) { synchronized ( objectLiterals ) { Integer result = objectLiterals . get ( literal ) ; return result == null ? NUM_ : result . intValue ( ) ; } }
@ Override public void resetViewableArea ( ) { throw new RuntimeException ( STR_ ) ; }
public static Lexicon buildWumpusLex ( ) { Lexicon l = new Lexicon ( ) ; ArrayList < LexWord > list = new ArrayList < LexWord > ( ) ; list . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; list . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; list . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; list . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; list . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; list . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; list . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; list . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; list . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; l . put ( STR_ , list ) ; ArrayList < LexWord > verbList = new ArrayList < LexWord > ( ) ; verbList . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; verbList . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; verbList . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; verbList . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; verbList . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; verbList . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; verbList . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; verbList . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; verbList . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; l . put ( STR_ , verbList ) ; ArrayList < LexWord > adjList = new ArrayList < LexWord > ( ) ; adjList . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; adjList . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; adjList . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; adjList . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; adjList . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; adjList . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; adjList . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; adjList . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; adjList . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; adjList . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; adjList . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; adjList . add ( new LexWord ( STR_ , ( float ) NUM_ ) ) ; l . put ( STR_ , adjList ) ; l . addLexWords ( STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ ) ; l . addLexWords ( STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ ) ; l . addLexWords ( STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ ) ; l . addLexWords ( buildNameLexicon ( ) ) ; l . addLexWords ( STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ ) ; l . addLexWords ( STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ ) ; l . addLexWords ( STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ ) ; l . addLexWords ( STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ ) ; return l ; }
private void testTransferRate ( ) { Assert . assertNotNull ( mExpectedTransferRateOps ) ; Assert . assertNotNull ( mExpectedTransferRateBps ) ; Assert . assertTrue ( mExpectedTransferRateBps . intValue ( ) > NUM_ ) ; Assert . assertTrue ( mExpectedTransferRateOps . intValue ( ) > NUM_ ) ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; String childData ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; nameNode = elementList . item ( NUM_ ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; child . replaceData ( NUM_ , NUM_ , STR_ ) ; childData = child . getData ( ) ; assertEquals ( STR_ , STR_ , childData ) ; }
public void add ( X509TrustManager mgr ) { if ( mgr instanceof X509Extensions ) { managers . add ( ( X509Extensions ) mgr ) ; } else { managers . add ( new X509ExtensionsWrapper ( mgr ) ) ; } }
public Iterator < TreeNode > findChildren ( ) { List < TreeNode > nodes ; if ( children == null ) nodes = Collections . emptyList ( ) ; else nodes = children ; return nodes . iterator ( ) ; }
private static char [ ] zzUnpackCMap ( String packed ) { char [ ] map = new char [ x10000 ] ; int i = NUM_ ; int j = NUM_ ; while ( i < NUM_ ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM_ ) ; } return map ; }
private int createFolder ( ) { if ( mNewDirectoryName != null && mSelectedDir != null && mSelectedDir . canWrite ( ) ) { File newDir = new File ( mSelectedDir , mNewDirectoryName ) ; if ( ! newDir . exists ( ) ) { boolean result = newDir . mkdir ( ) ; if ( result ) { changeDirectory ( newDir ) ; return R . string . create_folder_success ; } else { return R . string . create_folder_error ; } } else { return R . string . create_folder_error_already_exists ; } } else if ( mSelectedDir != null && ! mSelectedDir . canWrite ( ) ) { return R . string . create_folder_error_no_write_access ; } else { return R . string . create_folder_error ; } }
public Result doComparisonTest ( Properties properties ) throws Exception { final long timeout = Long . parseLong ( properties . getProperty ( TestOptions . TIMEOUT ) ) ; final int nclients = Integer . parseInt ( properties . getProperty ( TestOptions . NCLIENTS ) ) ; final int ntrials = Integer . parseInt ( properties . getProperty ( TestOptions . NTRIALS ) ) ; final int keyLen = Integer . parseInt ( properties . getProperty ( TestOptions . KEYLEN ) ) ; final int nops = Integer . parseInt ( properties . getProperty ( TestOptions . NOPS ) ) ; final double insertRate = Integer . parseInt ( properties . getProperty ( TestOptions . INSERT_RATE ) ) ; final int nindices = Integer . parseInt ( properties . getProperty ( TestOptions . NINDICES ) ) ; final boolean testCorrectness = Boolean . parseBoolean ( properties . getProperty ( TestOptions . TEST_CORRECTNESS ) ) ; Result result = doConcurrentClientTest ( client , nclients , timeout , ntrials , keyLen , nops , insertRate , nindices , testCorrectness ) ; return result ; }
public void testGetScale ( ) throws SQLException { try { int scale = NUM_ ; String createTable = STR_ + STR_ + scale + STR_ ; String insert = STR_ ; String select = STR_ ; Statement st = conn . createStatement ( ) ; st . executeUpdate ( createTable ) ; st . executeUpdate ( insert ) ; rs = st . executeQuery ( select ) ; ResultSetMetaData rsmd2 = rs . getMetaData ( ) ; assertNotNull ( rsmd2 ) ; assertEquals ( scale , rsmd2 . getScale ( NUM_ ) ) ; assertTrue ( rsmd2 . getScale ( NUM_ ) > NUM_ ) ; assertTrue ( rsmd2 . getScale ( NUM_ ) > NUM_ ) ; try { rsmd . getScale ( NUM_ ) ; fail ( STR_ ) ; } catch ( SQLException e ) { } try { rsmd . getScale ( NUM_ ) ; fail ( STR_ ) ; } catch ( SQLException e ) { } try { conn . close ( ) ; rsmd . getScale ( NUM_ ) ; fail ( STR_ ) ; } catch ( SQLException e ) { } } finally { st . cancel ( ) ; } }
static String valueToString ( Object value , int indentFactor , int indent ) { if ( value == null || value . equals ( null ) ) { return STR_ ; } try { if ( value instanceof String ) { return quote ( ( String ) value ) ; } } catch ( Exception e ) { } if ( value instanceof Float || value instanceof Double || value instanceof Byte || value instanceof Short || value instanceof Integer || value instanceof Long ) { return numberToString ( value ) ; } if ( value instanceof Boolean ) { return value . toString ( ) ; } if ( value instanceof Map ) { return print ( ( Map ) value , indentFactor , indent ) ; } if ( value instanceof List ) { return print ( ( List ) value , indentFactor , indent ) ; } return quote ( value . toString ( ) ) ; }
public static boolean isRetainedAtRuntime ( Class < ? extends Annotation > annotationType ) { Retention retention = annotationType . getAnnotation ( Retention . class ) ; return retention != null && retention . value ( ) == RetentionPolicy . RUNTIME ; }
public void testProcessMsg5 ( ) { byte [ ] pdu = createPDU ( NUM_ ) ; int headerLen = pdu . length - ( mGsmHeader . length + mUserDataHeader . length + mMessageBody . length ) ; int pduType = NUM_ ; int tranId = NUM_ ; String originalPackageName = mPackageName ; String originalClassName = mClassName ; try { mClassName = STR_ ; IWapPushManager iwapman = getInterface ( ) ; iwapman . addPackage ( Integer . toString ( mAppIdValue ) , Integer . toString ( mContentTypeValue ) , mPackageName , mClassName , WapPushManagerParams . APP_TYPE_ACTIVITY , BOOL_ , BOOL_ ) ; assertTrue ( ( iwapman . processMessage ( Integer . toString ( mAppIdValue ) , Integer . toString ( mContentTypeValue ) , createIntent ( pduType , tranId ) ) & WapPushManagerParams . MESSAGE_HANDLED ) == WapPushManagerParams . MESSAGE_HANDLED ) ; iwapman . deletePackage ( Integer . toString ( mAppIdValue ) , Integer . toString ( mContentTypeValue ) , mPackageName , mClassName ) ; } catch ( RemoteException e ) { assertTrue ( BOOL_ ) ; } mPackageName = originalPackageName ; mClassName = originalClassName ; }
public void addClassPath ( String classpath ) { char sep = CauchoUtil . getPathSeparatorChar ( ) ; int head = NUM_ ; int tail = NUM_ ; while ( head < classpath . length ( ) ) { tail = classpath . indexOf ( sep , head ) ; String segment = null ; if ( tail < NUM_ ) { segment = classpath . substring ( head ) ; head = classpath . length ( ) ; } else { segment = classpath . substring ( head , tail ) ; head = tail + NUM_ ; } if ( segment . equals ( STR_ ) ) continue ; else if ( segment . endsWith ( STR_ ) || segment . endsWith ( STR_ ) ) addMergePath ( JarPath . create ( VfsOld . lookup ( segment ) ) ) ; else addMergePath ( VfsOld . lookup ( segment ) ) ; } }
@ Singleton public static synchronized void loadDirectories ( String firstOption ) throws InvalidConfigException { if ( userIdDirectories == null ) { userIdDirectories = new TreeMap < String , String > ( ) ; userIdDirectories . put ( STR_ , ( firstOption == null ) ? STR_ : firstOption ) ; Properties properties = directoriesProperties ( ) ; for ( Map . Entry < Object , Object > entry : properties . entrySet ( ) ) { String key = StringUtils . trim ( ( String ) entry . getKey ( ) ) ; String value = StringUtils . trim ( ( String ) entry . getValue ( ) ) ; if ( key != null && value != null ) { userIdDirectories . put ( key , value ) ; } else { String error = DIRECTORIES_PROPFILE_PATH + STR_ ; LOG . error ( error ) ; throw new InvalidConfigException ( InvalidConfigException . TYPE . INVALID_PROPERTIES_FILE , error ) ; } } if ( ( userIdDirectories . size ( ) - NUM_ ) == NUM_ ) { String error = STR_ + DIRECTORIES_PROPFILE_PATH + STR_ ; LOG . error ( error ) ; throw new InvalidConfigException ( InvalidConfigException . TYPE . INVALID_PROPERTIES_FILE , error ) ; } } }
public static Individuum nullIndividuum ( int dim ) { short [ ] gene = new short [ dim ] ; Arrays . fill ( gene , DONT_CARE ) ; return new Individuum ( NUM_ , gene ) ; }
public List < Class < ? > > findAllClasses ( String uri ) throws IOException , ClassNotFoundException { List < Class < ? > > classes = new ArrayList < > ( ) ; List < String > strings = findAllStrings ( uri ) ; for ( String className : strings ) { Class < ? > clazz = _classLoader . loadClass ( className ) ; classes . add ( clazz ) ; } return classes ; }
private boolean isSlavoGermanic ( String value ) { return value . indexOf ( STR_ ) > - NUM_ || value . indexOf ( STR_ ) > - NUM_ || value . indexOf ( STR_ ) > - NUM_ || value . indexOf ( STR_ ) > - NUM_ ; }
public void shuffleInventory ( @ Nonnull IInventory inv , @ Nonnull Random random ) { final List < ItemStack > list = getInventoryList ( inv ) ; Collections . shuffle ( list , random ) ; for ( int i = NUM_ ; i < inv . getSizeInventory ( ) ; ++ i ) { inv . setInventorySlotContents ( i , list . get ( i ) ) ; } }
@ Override public String format ( double value , int formatNumber ) { if ( formatNumber % NUM_ == NUM_ ) { return format . format ( value ) ; } else { return null ; } }
public static String toLowerCase ( String string ) { boolean changed = BOOL_ ; char [ ] chars = string . toCharArray ( ) ; for ( int i = NUM_ ; i != chars . length ; i ++ ) { char ch = chars [ i ] ; if ( STR_ <= ch && STR_ >= ch ) { changed = BOOL_ ; chars [ i ] = ( char ) ( ch - STR_ + STR_ ) ; } } if ( changed ) { return new String ( chars ) ; } return string ; }
public void runAsserts ( List < Step > list , int size , Boolean needAssignee ) { assertEquals ( size , list . size ( ) ) ; for ( int i = NUM_ ; i < size ; i ++ ) { runAsserts ( list . get ( i ) , i , needAssignee ) ; } }
protected void onException ( final WroRuntimeException e ) { throw e ; }
public static boolean registerTransform ( final String transformURI ) { final boolean added = transforms . add ( transformURI ) ; return added ; }
public synchronized void co_exit ( int thisCoroutine ) { m_activeIDs . clear ( thisCoroutine ) ; m_nextCoroutine = NOBODY ; notify ( ) ; }
public void shrink ( ) { if ( c . length == length ) { return ; } char [ ] newc = new char [ length ] ; System . arraycopy ( c , NUM_ , newc , NUM_ , length ) ; c = newc ; }
public ANDCondition ( Condition ... conditions ) { Reject . ifNull ( conditions ) ; this . conditions = Arrays . asList ( conditions ) ; }
private void dropDownstreamTo ( long absolutePosition ) { int relativePosition = ( int ) ( absolutePosition - totalBytesDropped ) ; int allocationIndex = relativePosition / allocationLength ; for ( int i = NUM_ ; i < allocationIndex ; i ++ ) { allocator . release ( dataQueue . remove ( ) ) ; totalBytesDropped += allocationLength ; } }
public HopImpl ( String hostName , int portNumber , String trans ) { host = hostName ; if ( host . indexOf ( STR_ ) >= NUM_ ) if ( host . indexOf ( STR_ ) < NUM_ ) host = STR_ + host + STR_ ; port = portNumber ; transport = trans ; }
private void updateControls ( ) { Spinner difficulty = ( Spinner ) findViewById ( R . id . spinner_difficultyLevel ) ; difficulty . setSelection ( GameActivity . getDifficultyIndex ( ) ) ; Button resume = ( Button ) findViewById ( R . id . button_resumeGame ) ; resume . setEnabled ( GameActivity . canResumeFromSave ( ) ) ; CheckBox neverLoseBall = ( CheckBox ) findViewById ( R . id . checkbox_neverLoseBall ) ; neverLoseBall . setChecked ( GameActivity . getNeverLoseBall ( ) ) ; CheckBox soundEffectsEnabled = ( CheckBox ) findViewById ( R . id . checkbox_soundEffectsEnabled ) ; soundEffectsEnabled . setChecked ( GameActivity . getSoundEffectsEnabled ( ) ) ; TextView highScore = ( TextView ) findViewById ( R . id . text_highScore ) ; highScore . setText ( String . valueOf ( mHighScore ) ) ; }
public static void write ( OutputStream out , int c ) { if ( out == null ) { throw new IllegalArgumentException ( STR_ ) ; } try { out . write ( c ) ; } catch ( IOException e ) { throw new RuntimeException ( e . getMessage ( ) , e ) ; } }
public void message ( LocoNetMessage m ) { if ( m . getNumDataElements ( ) != NUM_ ) { return ; } int b1 = m . getElement ( NUM_ ) & xFF ; int b2 = m . getElement ( NUM_ ) & xFF ; int b3 = m . getElement ( NUM_ ) & xFF ; int b4 = m . getElement ( NUM_ ) & x07 ; if ( ( b1 == xD7 ) && ( ( b2 == x12 ) || ( b2 == x17 ) || ( b2 == x1F ) ) && ( b3 == x00 ) ) { idBox . setSelectedIndex ( b4 + NUM_ ) ; } }
public Void call ( ) throws Exception { byte [ ] [ ] keys = new byte [ nops ] [ ] ; byte [ ] [ ] vals = new byte [ nops ] [ ] ; if ( r . nextDouble ( ) <= insertRate ) { for ( int i = NUM_ ; i < nops ; i ++ ) { keys [ i ] = nextKey ( ) ; vals [ i ] = new byte [ NUM_ ] ; r . nextBytes ( vals [ i ] ) ; } lock . lock ( ) ; try { ndx . submit ( NUM_ , nops , keys , vals , BatchInsertConstructor . RETURN_NO_VALUES , null ) ; if ( groundTruth != null ) { groundTruth . submit ( NUM_ , nops , keys , vals , BatchInsertConstructor . RETURN_NO_VALUES , null ) ; } } finally { lock . unlock ( ) ; } } else { for ( int i = NUM_ ; i < nops ; i ++ ) { keys [ i ] = nextKey ( ) ; } lock . lock ( ) ; try { ndx . submit ( NUM_ , nops , keys , null , BatchRemoveConstructor . RETURN_MUTATION_COUNT , null ) ; if ( groundTruth != null ) { groundTruth . submit ( NUM_ , nops , keys , null , BatchRemoveConstructor . RETURN_MUTATION_COUNT , null ) ; } } finally { lock . unlock ( ) ; } } return null ; }
public boolean allowMultipleAdditions ( String systemName ) { return BOOL_ ; }
protected static boolean isObjectClassPresent ( Set objectClasses , String objectClass ) { if ( objectClasses != null && ! objectClasses . isEmpty ( ) ) { Iterator itr = objectClasses . iterator ( ) ; while ( itr . hasNext ( ) ) { String serviceOC = ( String ) itr . next ( ) ; if ( serviceOC . equalsIgnoreCase ( objectClass ) ) { return BOOL_ ; } } } return BOOL_ ; }
public void writeField ( final String name , final int value ) throws java . io . IOException { writeField ( name , Integer . toString ( value ) ) ; }
public static double lnFactorial ( int x ) { if ( x < NUM_ ) throw new IllegalArgumentException ( STR_ + x ) ; else if ( x > NUM_ ) return lnGamma ( x + NUM_ ) ; else { int l = factorialsBuffer . size ( ) ; for ( int i = l ; i <= x ; i ++ ) { factorialsBuffer . add ( log ( i ) + factorialsBuffer . get ( i - NUM_ ) ) ; } return factorialsBuffer . get ( x ) ; } }
public void sync ( ) throws IOException { try { latch . await ( ) ; } catch ( InterruptedException e ) { Thread . interrupted ( ) ; throw IOExceptionSupport . create ( e ) ; } failOnError ( ) ; }
public int addAndGet ( T obj , int delta ) { for ( ; ; ) { int current = get ( obj ) ; int next = current + delta ; if ( compareAndSet ( obj , current , next ) ) return next ; } }
public static void closeSilently ( Closeable closeable ) { if ( closeable == null ) { return ; } try { closeable . close ( ) ; } catch ( RuntimeException rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } }
public synchronized boolean append ( final byte [ ] data ) { if ( data == null ) { if ( Cfg . DEBUG ) { Check . log ( TAG + STR_ ) ; } return BOOL_ ; } FileOutputStream fout = null ; OutputStream out = null ; try { fout = new FileOutputStream ( file , BOOL_ ) ; out = new BufferedOutputStream ( fout , data . length ) ; out . write ( data ) ; out . flush ( ) ; } catch ( final Exception ex ) { return BOOL_ ; } finally { if ( fout != null ) { try { fout . close ( ) ; } catch ( final IOException e ) { if ( Cfg . EXCEPTION ) { Check . log ( e ) ; } if ( Cfg . DEBUG ) { Check . log ( TAG + STR_ + e . toString ( ) ) ; } } } if ( out != null ) { try { out . close ( ) ; } catch ( final IOException e ) { if ( Cfg . EXCEPTION ) { Check . log ( e ) ; } if ( Cfg . DEBUG ) { Check . log ( TAG + STR_ + e . toString ( ) ) ; } } } } return BOOL_ ; }
@ SuppressWarnings ( { STR_ , STR_ } ) private void notifyListListeners ( ) { if ( ! listListeners . isEmpty ( ) ) { List temp = new ArrayList ( sensorDataObjects . values ( ) ) ; temp . addAll ( objectStorages . values ( ) ) ; for ( ListListener < ? > listListener : listListeners ) { listListener . contentChanged ( temp ) ; } } }
public static InetAddress intToInetAddress ( int hostAddress ) { if ( hostAddress == NUM_ ) return null ; byte [ ] addressBytes = { ( byte ) ( xff & hostAddress ) , ( byte ) ( xff & ( hostAddress > > NUM_ ) ) , ( byte ) ( xff & ( hostAddress > > NUM_ ) ) , ( byte ) ( xff & ( hostAddress > > NUM_ ) ) } ; try { return InetAddress . getByAddress ( addressBytes ) ; } catch ( UnknownHostException e ) { throw new AssertionError ( ) ; } }
private AFTPClient actionOpen ( ) throws IOException , PageException { required ( STR_ , server ) ; required ( STR_ , username ) ; required ( STR_ , password ) ; AFTPClient client = getClient ( ) ; writeCfftp ( client ) ; return client ; }
public void testPlusMathContextPositive ( ) { String a = STR_ ; int aScale = NUM_ ; int precision = NUM_ ; RoundingMode rm = RoundingMode . FLOOR ; MathContext mc = new MathContext ( precision , rm ) ; String c = STR_ ; int cScale = NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal res = aNumber . plus ( mc ) ; assertEquals ( STR_ , c , res . toString ( ) ) ; assertEquals ( STR_ , cScale , res . scale ( ) ) ; }
private static char [ ] zzUnpackCMap ( String packed ) { int size = NUM_ ; for ( int i = NUM_ , length = packed . length ( ) ; i < length ; i += NUM_ ) { size += packed . charAt ( i ) ; } char [ ] map = new char [ size ] ; int i = NUM_ ; int j = NUM_ ; while ( i < packed . length ( ) ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM_ ) ; } return map ; }
public V putIfAbsent ( final K k , final V v ) { final WeakReference < V > ref = newWeakRef ( k , v , referenceQueue ) ; final WeakReference < V > oldRef = map . putIfAbsent ( k , ref ) ; final V oldVal = oldRef == null ? null : oldRef . get ( ) ; if ( oldRef != null && oldVal == null ) { if ( map . replace ( k , oldRef , ref ) ) { if ( queue . add ( v ) && DEBUG ) { log . debug ( STR_ + k + STR_ + v ) ; } didUpdate ( k , ref , oldRef ) ; return null ; } } if ( oldVal == null ) { if ( queue . add ( v ) && DEBUG ) { log . debug ( STR_ + k + STR_ + v ) ; } didUpdate ( k , ref , null ) ; return null ; } return oldVal ; }
public int diff_commonSuffix ( String text1 , String text2 ) { int text1_length = text1 . length ( ) ; int text2_length = text2 . length ( ) ; int n = Math . min ( text1_length , text2_length ) ; for ( int i = NUM_ ; i <= n ; i ++ ) { if ( text1 . charAt ( text1_length - i ) != text2 . charAt ( text2_length - i ) ) { return i - NUM_ ; } } return n ; }
public void close ( ) { if ( elementLayers != null ) { elementLayers . clear ( ) ; elementLayers = null ; } inputSource = null ; curListener = null ; }
public void start ( ) { if ( monitorThread != null ) { if ( ! monitorThread . isAlive ( ) ) { startMonitorThread ( ) ; } else { LOG . error ( STR_ ) ; } } else { startMonitorThread ( ) ; } }
private static char [ ] zzUnpackCMap ( String packed ) { char [ ] map = new char [ x10000 ] ; int i = NUM_ ; int j = NUM_ ; while ( i < NUM_ ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM_ ) ; } return map ; }
@ HLEUnimplemented @ HLEFunction ( nid = x41E73E95 , version = NUM_ ) public int sceUsbCamPollReadVideoFrameEnd ( ) { if ( jpegBuffer == null || jpegBuffer . isNull ( ) ) { return SceKernelErrors . ERROR_USBCAM_NO_READ_ON_VIDEO_FRAME ; } if ( currentVideoFrameCount <= lastVideoFrameCount ) { if ( log . isDebugEnabled ( ) ) { log . debug ( String . format ( STR_ , currentVideoFrameCount , lastVideoFrameCount ) ) ; } return SceKernelErrors . ERROR_USBCAM_NO_VIDEO_FRAME_AVAILABLE ; } return writeCurrentVideoImage ( jpegBuffer , jpegBufferSize ) ; }
public void scale ( int factor ) { if ( m_icon != null ) { removeAll ( ) ; Image pic = m_icon . getImage ( ) ; int width = m_icon . getIconWidth ( ) ; int height = m_icon . getIconHeight ( ) ; int reduction = width / factor ; width -= reduction ; height -= reduction ; pic = pic . getScaledInstance ( width , height , Image . SCALE_SMOOTH ) ; m_icon = new ImageIcon ( pic ) ; m_visualLabel = new JLabel ( m_icon ) ; add ( m_visualLabel , BorderLayout . CENTER ) ; Dimension d = m_visualLabel . getPreferredSize ( ) ; Dimension d2 = new Dimension ( ( int ) d . getWidth ( ) + NUM_ , ( int ) d . getHeight ( ) + NUM_ ) ; setMinimumSize ( d2 ) ; setPreferredSize ( d2 ) ; setMaximumSize ( d2 ) ; } }
private void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject ( ) ; try { initFromName ( getName ( ) ) ; } catch ( RuntimeException e ) { if ( e instanceof NullPointerException || e instanceof IllegalArgumentException ) { InvalidObjectException ee = new InvalidObjectException ( e . getMessage ( ) ) ; ee . initCause ( e ) ; throw ee ; } throw e ; } }
public String toLowerCamel ( ) { return toCamel ( CaseFormat . LOWER_CAMEL ) ; }
public static byte [ ] decode ( String encoded ) { if ( encoded == null ) { return null ; } char [ ] base64Data = encoded . toCharArray ( ) ; int len = removeWhiteSpace ( base64Data ) ; if ( len % FOURBYTE != NUM_ ) { return null ; } int numberQuadruple = ( len / FOURBYTE ) ; if ( numberQuadruple == NUM_ ) { return new byte [ NUM_ ] ; } byte decodedData [ ] = null ; byte b1 = NUM_ , b2 = NUM_ , b3 = NUM_ , b4 = NUM_ ; char d1 = NUM_ , d2 = NUM_ , d3 = NUM_ , d4 = NUM_ ; int i = NUM_ ; int encodedIndex = NUM_ ; int dataIndex = NUM_ ; decodedData = new byte [ ( numberQuadruple ) . NUM_ ] ; for ( ; i < numberQuadruple - NUM_ ; i ++ ) { if ( ! isData ( ( d1 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d2 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d3 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d4 = base64Data [ dataIndex ++ ] ) ) ) { return null ; } b1 = base64Alphabet [ d1 ] ; b2 = base64Alphabet [ d2 ] ; b3 = base64Alphabet [ d3 ] ; b4 = base64Alphabet [ d4 ] ; decodedData [ encodedIndex ++ ] = ( byte ) ( b1 << NUM_ | b2 > > NUM_ ) ; decodedData [ encodedIndex ++ ] = ( byte ) ( ( ( b2 & xf ) << NUM_ ) | ( ( b3 > > NUM_ ) & xf ) ) ; decodedData [ encodedIndex ++ ] = ( byte ) ( b3 << NUM_ | b4 ) ; } if ( ! isData ( ( d1 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d2 = base64Data [ dataIndex ++ ] ) ) ) { return null ; } b1 = base64Alphabet [ d1 ] ; b2 = base64Alphabet [ d2 ] ; d3 = base64Data [ dataIndex ++ ] ; d4 = base64Data [ dataIndex ++ ] ; if ( ! isData ( ( d3 ) ) || ! isData ( ( d4 ) ) ) { if ( isPad ( d3 ) && isPad ( d4 ) ) { if ( ( b2 & xf ) != NUM_ ) { return null ; } byte [ ] tmp = new byte [ i . NUM_ + NUM_ ] ; System . arraycopy ( decodedData , NUM_ , tmp , NUM_ , i . NUM_ ) ; tmp [ encodedIndex ] = ( byte ) ( b1 << NUM_ | b2 > > NUM_ ) ; return tmp ; } else if ( ! isPad ( d3 ) && isPad ( d4 ) ) { b3 = base64Alphabet [ d3 ] ; if ( ( b3 & x3 ) != NUM_ ) { return null ; } byte [ ] tmp = new byte [ i . NUM_ + NUM_ ] ; System . arraycopy ( decodedData , NUM_ , tmp , NUM_ , i . NUM_ ) ; tmp [ encodedIndex ++ ] = ( byte ) ( b1 << NUM_ | b2 > > NUM_ ) ; tmp [ encodedIndex ] = ( byte ) ( ( ( b2 & xf ) << NUM_ ) | ( ( b3 > > NUM_ ) & xf ) ) ; return tmp ; } else { return null ; } } else { b3 = base64Alphabet [ d3 ] ; b4 = base64Alphabet [ d4 ] ; decodedData [ encodedIndex ++ ] = ( byte ) ( b1 << NUM_ | b2 > > NUM_ ) ; decodedData [ encodedIndex ++ ] = ( byte ) ( ( ( b2 & xf ) << NUM_ ) | ( ( b3 > > NUM_ ) & xf ) ) ; decodedData [ encodedIndex ++ ] = ( byte ) ( b3 << NUM_ | b4 ) ; } return decodedData ; }
protected List < BlockObject > sortFullCopySourceList ( List < BlockObject > fcSourceObjects ) { List < BlockObject > sortedSourceObjects = new ArrayList < BlockObject > ( ) ; Map < String , BlockObject > fcSourcObjectsMap = new HashMap < String , BlockObject > ( ) ; for ( BlockObject fcSourceObject : fcSourceObjects ) { fcSourcObjectsMap . put ( fcSourceObject . getLabel ( ) , fcSourceObject ) ; } List < String > fcSourceLabels = new ArrayList < String > ( fcSourcObjectsMap . keySet ( ) ) ; Collections . sort ( fcSourceLabels ) ; for ( String fcSourceLabel : fcSourceLabels ) { sortedSourceObjects . add ( fcSourcObjectsMap . get ( fcSourceLabel ) ) ; } return sortedSourceObjects ; }
public E poll ( ) { if ( isEmpty ( ) ) { return null ; } E result = elements [ NUM_ ] ; removeAt ( NUM_ ) ; return result ; }
public MovieSetAddAction ( boolean withTitle ) { if ( withTitle ) { putValue ( NAME , BUNDLE . getString ( STR_ ) ) ; } putValue ( LARGE_ICON_KEY , IconManager . LIST_ADD ) ; putValue ( SMALL_ICON , IconManager . LIST_ADD ) ; putValue ( SHORT_DESCRIPTION , BUNDLE . getString ( STR_ ) ) ; }
protected void createRegistry ( int port ) { if ( rmiRegistry == null ) { try { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STR_ + port ) ; } rmiRegistry = LocateRegistry . createRegistry ( port ) ; } catch ( Throwable e ) { throw new ServerRuntimeException ( STR_ + port , e ) ; } } }
public void poll ( final UdpSocketStatisticsHandler handler ) { this . statisticsHandler = handler ; try { fileLoader . load ( ) ; final ByteBuffer buffer = fileLoader . getBuffer ( ) ; lineParser . reset ( ) ; lineParser . handleToken ( buffer , buffer . position ( ) , buffer . limit ( ) ) ; } finally { this . statisticsHandler = null ; } monitoredSockets . purgeEntriesOlderThan ( updateCount ) ; updateCount ++ ; }
public static boolean isBookSearchUrl ( String url ) { return url . startsWith ( STR_ ) || url . startsWith ( STR_ ) ; }
private void resetInternal ( ) { mTransitionState = TRANSITION_NONE ; Arrays . fill ( mStartAlphas , NUM_ ) ; mStartAlphas [ NUM_ ] = NUM_ ; Arrays . fill ( mAlphas , NUM_ ) ; mAlphas [ NUM_ ] = NUM_ ; Arrays . fill ( mIsLayerOn , BOOL_ ) ; mIsLayerOn [ NUM_ ] = BOOL_ ; }
void fixWhiteSpace ( ) { final int index = mOutputBuilder . length ( ) - NUM_ ; if ( index >= NUM_ ) { final char lastCharacter = mOutputBuilder . charAt ( index ) ; if ( ! Character . isWhitespace ( lastCharacter ) ) { mOutputBuilder . append ( STR_ ) ; } } }
public void handleTblRequestHandlerListHrefDupActionRequest ( RequestInvocationEvent event ) throws ModelControlException { try { Map values = getValues ( ) ; onBeforeSaveProfile ( values ) ; setPageSessionAttribute ( PROPERTY_ATTRIBUTE , ( HashMap ) values ) ; SCSOAPBindingRequestHandlerListDupViewBean vb = ( SCSOAPBindingRequestHandlerListDupViewBean ) getViewBean ( SCSOAPBindingRequestHandlerListDupViewBean . class ) ; unlockPageTrail ( ) ; passPgSessionMap ( vb ) ; int idx = Integer . parseInt ( ( String ) getDisplayFieldValue ( TBL_REQUEST_HANDLER_LIST_HREF_DUP_ACTION ) ) ; vb . setDupIndex ( idx ) ; vb . forwardTo ( getRequestContext ( ) ) ; } catch ( AMConsoleException e ) { setInlineAlertMessage ( CCAlert . TYPE_ERROR , STR_ , e . getMessage ( ) ) ; } }
public boolean expired ( long expire ) { long mod = time . getTime ( ) ; long now = System . currentTimeMillis ( ) ; long diff = now - mod ; if ( diff > expire && getSource ( ) != NETWORK ) { return BOOL_ ; } return BOOL_ ; }
@ Override public void accept ( final MethodVisitor mv ) { switch ( type ) { case Opcodes . F_NEW : case Opcodes . F_FULL : mv . visitFrame ( type , local . size ( ) , asArray ( local ) , stack . size ( ) , asArray ( stack ) ) ; break ; case Opcodes . F_APPEND : mv . visitFrame ( type , local . size ( ) , asArray ( local ) , NUM_ , null ) ; break ; case Opcodes . F_CHOP : mv . visitFrame ( type , local . size ( ) , null , NUM_ , null ) ; break ; case Opcodes . F_SAME : mv . visitFrame ( type , NUM_ , null , NUM_ , null ) ; break ; case Opcodes . F_SAME1 : mv . visitFrame ( type , NUM_ , null , NUM_ , asArray ( stack ) ) ; break ; } }
private static native String [ ] specialProperties ( ) ;
private void handleDoneQuery ( final UUID queryId , final Future < Void > doneQueryFuture ) { try { doneQueryFuture . get ( ) ; throw new InterruptedException ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } catch ( ExecutionException e ) { throw new RuntimeException ( e ) ; } }
public void storeDevice ( Device d ) { if ( ! isMaster ) return ; if ( d == null ) return ; long now = System . nanoTime ( ) ; writeUpdatedDeviceToStorage ( d ) ; lastWriteTimes . put ( d . getDeviceKey ( ) , now ) ; }
synchronized public static List < String > formerIdentities ( ) { if ( instance == null ) { instance = new NodeIdentity ( ) ; log . info ( STR_ , instance . getIdentity ( ) ) ; } return instance . getFormerIdentities ( ) ; }
public final double doOperation ( ) { final int dim = parameter . getDimension ( ) ; double sum = NUM_ ; if ( usesPriorOnSum ) { for ( int i = NUM_ ; i < dim ; i ++ ) { sum += Math . abs ( parameter . getParameterValue ( i ) ) ; } } final int pos = MathUtils . nextInt ( dim ) ; final int value = ( int ) parameter . getParameterValue ( pos ) ; double logq = NUM_ ; if ( value == NUM_ ) { logq = bitFlipHelper . flipZero ( pos , dim , sum ) ; } else if ( value == NUM_ ) { logq = bitFlipHelper . flipOne ( pos , dim , sum ) ; } else if ( value == - NUM_ ) { logq = bitFlipHelper . flipNegOne ( pos , dim , sum ) ; } else { throw new RuntimeException ( STR_ ) ; } if ( ! usesPriorOnSum ) { logq = NUM_ ; } return logq ; }
@ After public void tearDown ( ) { webClient . closeAllWindows ( ) ; }
@ Override public void chartProgress ( ChartProgressEvent event ) { }
public void init ( Object o , int depth , int traversal ) { m_queue . clear ( ) ; m_depth = depth ; if ( traversal < NUM_ || traversal >= Constants . TRAVERSAL_COUNT ) throw new IllegalArgumentException ( STR_ + traversal ) ; m_traversal = traversal ; m_includeNodes = ( traversal == Constants . NODE_TRAVERSAL || traversal == Constants . NODE_AND_EDGE_TRAVERSAL ) ; m_includeEdges = ( traversal == Constants . EDGE_TRAVERSAL || traversal == Constants . NODE_AND_EDGE_TRAVERSAL ) ; if ( m_includeNodes ) { if ( o instanceof Node ) { m_queue . add ( o , NUM_ ) ; } else { Iterator tuples = ( Iterator ) o ; while ( tuples . hasNext ( ) ) m_queue . add ( tuples . next ( ) , NUM_ ) ; } } else { if ( o instanceof Node ) { Node n = ( Node ) o ; m_queue . visit ( n , NUM_ ) ; Iterator edges = getEdges ( n ) ; while ( edges . hasNext ( ) ) { Edge e = ( Edge ) edges . next ( ) ; Node nn = e . getAdjacentNode ( n ) ; m_queue . visit ( nn , NUM_ ) ; if ( m_queue . getDepth ( e ) < NUM_ ) m_queue . add ( e , NUM_ ) ; } } else { Iterator tuples = ( Iterator ) o ; while ( tuples . hasNext ( ) ) { Node n = ( Node ) tuples . next ( ) ; m_queue . visit ( n , NUM_ ) ; Iterator edges = getEdges ( n ) ; while ( edges . hasNext ( ) ) { Edge e = ( Edge ) edges . next ( ) ; Node nn = e . getAdjacentNode ( n ) ; m_queue . visit ( nn , NUM_ ) ; if ( m_queue . getDepth ( e ) < NUM_ ) m_queue . add ( e , NUM_ ) ; } } } } }
@ Override public JapaneseDate dateEpochDay ( long epochDay ) { return new JapaneseDate ( LocalDate . ofEpochDay ( epochDay ) ) ; }
private void checkEmpty ( ) { for ( int i = NUM_ ; i < gridCount ( ) ; i ++ ) { IgniteCache < Integer , String > cache = jcache ( i ) ; assertEquals ( NUM_ , cache . localSize ( ) ) ; assertEquals ( NUM_ , cache . size ( ) ) ; for ( CachePeekMode peekMode : CachePeekMode . values ( ) ) { assertEquals ( NUM_ , cache . localSize ( peekMode ) ) ; assertEquals ( NUM_ , cache . size ( peekMode ) ) ; } } checkPrimarySize ( NUM_ ) ; }
Node < K , V > find ( int h , Object k ) { Node < K , V > e = this ; if ( k != null ) { do { K ek ; if ( e . hash == h && ( ( ek = e . key ) == k || ek != null && myHashingStrategy . equals ( ( K ) k , ek ) ) ) { return e ; } } while ( ( e = e . next ) != null ) ; } return null ; }
@ Override public synchronized void put ( String key , Entry entry ) { pruneIfNeeded ( entry . data . length ) ; File file = getFileForKey ( key ) ; try { BufferedOutputStream fos = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; CacheHeader e = new CacheHeader ( key , entry ) ; boolean success = e . writeHeader ( fos ) ; if ( ! success ) { fos . close ( ) ; VolleyLog . d ( STR_ , file . getAbsolutePath ( ) ) ; throw new IOException ( ) ; } fos . write ( entry . data ) ; fos . close ( ) ; putEntry ( key , e ) ; return ; } catch ( IOException e ) { } boolean deleted = file . delete ( ) ; if ( ! deleted ) { VolleyLog . d ( STR_ , file . getAbsolutePath ( ) ) ; } }
@ LoopProcessorAnnotations ( loopProcessorAnnotations = { @ LoopProcessorAnnotation ( processPath = { IModelingElementDefinitions . CLASSES_PROCESSOR , IModelingElementDefinitions . OPERATIONS_PROCESSOR } ) , @ LoopProcessorAnnotation ( processPath = { IModelingElementDefinitions . INTERFACES_PROCESSOR , IModelingElementDefinitions . OPERATIONS_PROCESSOR } ) } , aspect = LoopAspectConstants . AFTER ) public static void operationsProcessor ( @ GenerationRegistry GenerationPolicyRegistry generationValueGetter , @ GenerationBaseElement Object element , @ GenerationLoopElement Object modelPackage , @ GenerationLoopElement ( id = { IModelingElementDefinitions . CLASSES_PROCESSOR , IModelingElementDefinitions . INTERFACES_PROCESSOR } ) Object parent ) { List < Object > userAddedDependTypes = generationValueGetter . getValues ( DEPEND_TYPES_TRACKER , parent ) ; List < Object > parametersArgument = generationValueGetter . getValues ( IModelingDecisions . OPERATION_PARAMETER_ARGUMENT , element , parent ) ; for ( Object item : parametersArgument ) { if ( item instanceof SimpleEntry == BOOL_ ) { continue ; } SimpleEntry < ? , ? > simpleEntry = ( SimpleEntry < ? , ? > ) item ; Object type = simpleEntry . getKey ( ) ; if ( ! userAddedDependTypes . contains ( type ) ) { List < Object > types = generationValueGetter . getValues ( IModelingConstants . TYPES_TRACKER , modelPackage , type ) ; if ( types . isEmpty ( ) ) { continue ; } addDepend ( generationValueGetter , parent , type ) ; } } }
public static void addLanguage ( Language language ) { if ( language == null ) return ; ArrayList < Language > list = new ArrayList < Language > ( Arrays . asList ( s_languages ) ) ; list . add ( language ) ; s_languages = new Language [ list . size ( ) ] ; list . toArray ( s_languages ) ; }
public static int binarySearchCeil ( long [ ] a , long key , boolean inclusive , boolean stayInBounds ) { int index = Arrays . binarySearch ( a , key ) ; index = index < NUM_ ? ~ index : ( inclusive ? index : ( index + NUM_ ) ) ; return stayInBounds ? Math . min ( a . length - NUM_ , index ) : index ; }
protected void doAddUser ( User user ) throws UsersRepositoryException { Connection conn = null ; PreparedStatement addUserStatement = null ; try { conn = openConnection ( ) ; addUserStatement = conn . prepareStatement ( m_insertUserSql ) ; setUserForInsertStatement ( user , addUserStatement ) ; addUserStatement . execute ( ) ; } catch ( SQLException sqlExc ) { sqlExc . printStackTrace ( ) ; throw new UsersRepositoryException ( STR_ , sqlExc ) ; } finally { theJDBCUtil . closeJDBCStatement ( addUserStatement ) ; theJDBCUtil . closeJDBCConnection ( conn ) ; } }
void blockMix128 ( long k1 , long k2 ) { h1 ^= mixK1 ( k1 ) ; h1 = Long . rotateLeft ( h1 , NUM_ ) ; h1 += h2 ; h1 = ( h1 . NUM_ ) + x52dce729 ; h2 ^= mixK2 ( k2 ) ; h2 = Long . rotateLeft ( h2 , NUM_ ) ; h2 += h1 ; h2 = ( h2 . NUM_ ) + x38495ab5 ; }
private void registerHost ( SimEvent ev ) { NetworkHost hs = ( NetworkHost ) ev . getData ( ) ; hostlist . put ( hs . getId ( ) , hs ) ; }
@ Override public void reconcileFlow ( OFMatchReconcile ofmRcIn , EventPriority priority ) { if ( ofmRcIn == null ) return ; OFMatchReconcile myOfmRc = new OFMatchReconcile ( ofmRcIn ) ; flowQueue . offer ( myOfmRc , priority ) ; ctrFlowReconcileRequest . increment ( ) ; Date currTime = new Date ( ) ; long delay = NUM_ ; if ( currTime . after ( new Date ( lastReconcileTime . getTime ( ) + NUM_ ) ) ) { delay = NUM_ ; } else { delay = FLOW_RECONCILE_DELAY_MILLISEC ; } flowReconcileTask . reschedule ( delay , TimeUnit . MILLISECONDS ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( STR_ , myOfmRc . toString ( ) , flowQueue . size ( ) ) ; } }
public Format ( String pFormatString ) { String formatVars [ ] = pFormatString . split ( STR_ ) ; mId = Integer . parseInt ( formatVars [ NUM_ ] ) ; }
@ Override public synchronized void put ( String key , Entry entry ) { pruneIfNeeded ( entry . data . length ) ; File file = getFileForKey ( key ) ; try { BufferedOutputStream fos = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; CacheHeader e = new CacheHeader ( key , entry ) ; boolean success = e . writeHeader ( fos ) ; if ( ! success ) { fos . close ( ) ; VolleyLog . d ( STR_ , file . getAbsolutePath ( ) ) ; throw new IOException ( ) ; } fos . write ( entry . data ) ; fos . close ( ) ; putEntry ( key , e ) ; return ; } catch ( IOException e ) { } boolean deleted = file . delete ( ) ; if ( ! deleted ) { VolleyLog . d ( STR_ , file . getAbsolutePath ( ) ) ; } }
void createJar ( FileOutputStream outStream , Map < String , byte [ ] > all ) throws IOException { JarOutputStream jar = new JarOutputStream ( outStream ) ; for ( Entry < String , byte [ ] > entry : all . entrySet ( ) ) { String name = entry . getKey ( ) ; JarEntry jar_entry = new JarEntry ( name ) ; jar . putNextEntry ( jar_entry ) ; jar . write ( entry . getValue ( ) ) ; jar . closeEntry ( ) ; } jar . flush ( ) ; jar . close ( ) ; }
public void appendCell ( int value ) { appendCell ( String . valueOf ( value ) ) ; }
public void expectServerProxyFailed ( ) { expectedApiCalls . add ( new ApiCall ( SERVER_PROXY_FAILED ) ) ; }
protected final void refreshLoadingViewsSize ( ) { final int maximumPullScroll = ( int ) ( getMaximumPullScroll ( ) . NUM_ ) ; int pLeft = getPaddingLeft ( ) ; int pTop = getPaddingTop ( ) ; int pRight = getPaddingRight ( ) ; int pBottom = getPaddingBottom ( ) ; switch ( getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setWidth ( maximumPullScroll ) ; pLeft = - maximumPullScroll ; } else { pLeft = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setWidth ( maximumPullScroll ) ; pRight = - maximumPullScroll ; } else { pRight = NUM_ ; } break ; case VERTICAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setHeight ( maximumPullScroll ) ; pTop = - maximumPullScroll ; } else { pTop = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setHeight ( maximumPullScroll ) ; pBottom = - maximumPullScroll ; } else { pBottom = NUM_ ; } break ; } if ( DEBUG ) { Log . d ( LOG_TAG , String . format ( STR_ , pLeft , pTop , pRight , pBottom ) ) ; } setPadding ( pLeft , pTop , pRight , pBottom ) ; }
public Object remove ( final Object key ) { return parameters . remove ( key ) ; }
@ Override public void recalculateAttributeStatistics ( Attribute attribute ) { List < Attribute > allAttributes = new ArrayList < Attribute > ( ) ; allAttributes . add ( attribute ) ; recalculateAttributeStatistics ( allAttributes ) ; }
public boolean isEmpty ( ) { return children . isEmpty ( ) ; }
public void insertColumn ( int columnIndex , ColumnSpec columnSpec ) { if ( columnIndex < NUM_ || columnIndex > getColumnCount ( ) ) { throw new IndexOutOfBoundsException ( STR_ + columnIndex + STR_ + getColumnCount ( ) + STR_ ) ; } colSpecs . add ( columnIndex - NUM_ , columnSpec ) ; shiftComponentsHorizontally ( columnIndex , BOOL_ ) ; adjustGroupIndices ( colGroupIndices , columnIndex , BOOL_ ) ; }
public int match ( String s ) { String rep = new String ( _dataChars , NUM_ , _nDataChars ) ; return rep . indexOf ( s ) ; }
private int calcRhsSize ( Production production ) { int result = production . getRHSSizeWithoutEpsilon ( ) ; if ( production . getLHS ( ) instanceof AuxiliaryLHS4SemanticShiftAction ) { final AuxiliaryLHS4SemanticShiftAction auxAction = ( AuxiliaryLHS4SemanticShiftAction ) production . getLHS ( ) ; result += auxAction . numPrecedingSymbolsNotEpsilon ; } return result ; }
private BshMethod loadScriptedCommand ( InputStream in , String name , Class [ ] argTypes , String resourcePath , Interpreter interpreter ) throws UtilEvalError { try { interpreter . eval ( new InputStreamReader ( in ) , this , resourcePath ) ; } catch ( EvalError e ) { Interpreter . debug ( e . toString ( ) ) ; throw new UtilEvalError ( STR_ + e . getMessage ( ) ) ; } BshMethod meth = getMethod ( name , argTypes ) ; return meth ; }
public static Object invokeCompiledCommand ( Class commandClass , Object [ ] args , Interpreter interpreter , CallStack callstack ) throws UtilEvalError { Object [ ] invokeArgs = new Object [ args . length + NUM_ ] ; invokeArgs [ NUM_ ] = interpreter ; invokeArgs [ NUM_ ] = callstack ; System . arraycopy ( args , NUM_ , invokeArgs , NUM_ , args . length ) ; BshClassManager bcm = interpreter . getClassManager ( ) ; try { return Reflect . invokeStaticMethod ( bcm , commandClass , STR_ , invokeArgs ) ; } catch ( InvocationTargetException e ) { throw new UtilEvalError ( STR_ + e . getTargetException ( ) ) ; } catch ( ReflectError e ) { throw new UtilEvalError ( STR_ + e ) ; } }
private static void computeProbabilitiesMultinomialLogistic ( double [ ] responses ) { double [ ] r = responses . clone ( ) ; for ( int j = NUM_ ; j < r . length ; j ++ ) { double sum = NUM_ ; boolean overflow = BOOL_ ; for ( int k = NUM_ ; k < r . length ; k ++ ) { if ( r [ k ] - r [ j ] > NUM_ ) { overflow = BOOL_ ; break ; } sum += Math . exp ( r [ k ] - r [ j ] ) ; } if ( overflow ) { responses [ j ] = NUM_ ; } else { responses [ j ] = NUM_ / sum ; } } }
public int addClientExternal ( SSOToken token , Map props ) throws AMClientCapException { synchronized ( externalClientData ) { extCapInstance . addClient ( token , props ) ; String ct = getClientType ( props ) ; Map eMap = mergeWithParent ( props ) ; externalClientData . put ( ct , eMap ) ; addToIndexes ( ct , eMap ) ; } return NUM_ ; }
public static void delete ( File resourceToDelete ) throws IOException { if ( resourceToDelete . exists ( ) ) { delete ( resourceToDelete . toPath ( ) ) ; } }
private void addExportRemoveVolumeSteps ( Workflow workflow , ProtectionSystem rpSystem , URI exportGroupID , List < URI > boIDs ) throws InternalException { ExportGroup exportGroup = _dbClient . queryObject ( ExportGroup . class , exportGroupID ) ; String exportStep = workflow . createStepId ( ) ; initTaskStatus ( exportGroup , exportStep , Operation . Status . pending , STR_ ) ; Map < URI , List < URI > > deviceToBlockObjects = new HashMap < URI , List < URI > > ( ) ; for ( URI snapshotID : boIDs ) { BlockSnapshot snapshot = _dbClient . queryObject ( BlockSnapshot . class , snapshotID ) ; List < BlockObject > objectsToRemove = getExportObjectsForBookmark ( snapshot ) ; for ( BlockObject blockObject : objectsToRemove ) { List < URI > blockObjects = deviceToBlockObjects . get ( blockObject . getStorageController ( ) ) ; if ( blockObjects == null ) { blockObjects = new ArrayList < URI > ( ) ; deviceToBlockObjects . put ( blockObject . getStorageController ( ) , blockObjects ) ; } blockObjects . add ( blockObject . getId ( ) ) ; } } for ( Map . Entry < URI , List < URI > > deviceEntry : deviceToBlockObjects . entrySet ( ) ) { _log . info ( String . format ( STR_ , exportGroup . getId ( ) , deviceEntry . getKey ( ) , deviceEntry . getValue ( ) ) ) ; _exportWfUtils . generateExportGroupRemoveVolumes ( workflow , STEP_EXPORT_REMOVE_SNAPSHOT , STEP_EXPORT_GROUP_DISABLE , deviceEntry . getKey ( ) , exportGroupID , deviceEntry . getValue ( ) ) ; } _log . info ( String . format ( STR_ , exportGroup . getId ( ) ) ) ; }
public double inferenceByGibbsSampling ( Document d , double [ ] pzd , int numBurnIn , int numSampling ) { Arrays . fill ( pzd , NUM_ ) ; double loglikelihood = NUM_ ; for ( int i = NUM_ ; i < numBurnIn + numSampling ; i ++ ) { loglikelihood += gibbsSampling ( d ) ; if ( i >= numBurnIn ) { for ( int topic : d . topics ) { if ( topic != NO_TOPIC ) pzd [ topic ] ++ ; } } else { loglikelihood = NUM_ ; } } normalize ( pzd , alpha ) ; return loglikelihood / numSampling ; }
public static void remove ( String dbgToken ) { dbgTable . remove ( dbgToken ) ; }
protected void checkSAXVersion ( Hashtable h ) { if ( null == h ) h = new Hashtable ( ) ; final String SAX_VERSION1_CLASS = STR_ ; final String SAX_VERSION1_METHOD = STR_ ; final String SAX_VERSION2_CLASS = STR_ ; final String SAX_VERSION2_METHOD = STR_ ; final String SAX_VERSION2BETA_CLASSNF = STR_ ; final String SAX_VERSION2BETA_METHODNF = STR_ ; final Class oneStringArg [ ] = { java . lang . String . class } ; final Class attributesArg [ ] = { org . xml . sax . Attributes . class } ; try { Class clazz = ObjectFactory . findProviderClass ( SAX_VERSION2BETA_CLASSNF , ObjectFactory . findClassLoader ( ) , BOOL_ ) ; Method method = clazz . getMethod ( SAX_VERSION2BETA_METHODNF , attributesArg ) ; h . put ( VERSION + STR_ , STR_ ) ; } catch ( Exception e ) { h . put ( ERROR + VERSION + STR_ , STR_ + e . toString ( ) ) ; h . put ( ERROR , ERROR_FOUND ) ; try { Class clazz = ObjectFactory . findProviderClass ( SAX_VERSION2_CLASS , ObjectFactory . findClassLoader ( ) , BOOL_ ) ; Method method = clazz . getMethod ( SAX_VERSION2_METHOD , oneStringArg ) ; h . put ( VERSION + STR_ , STR_ ) ; } catch ( Exception e2 ) { h . put ( ERROR + VERSION + STR_ , STR_ + e . toString ( ) ) ; h . put ( ERROR , ERROR_FOUND ) ; try { Class clazz = ObjectFactory . findProviderClass ( SAX_VERSION1_CLASS , ObjectFactory . findClassLoader ( ) , BOOL_ ) ; Method method = clazz . getMethod ( SAX_VERSION1_METHOD , oneStringArg ) ; h . put ( VERSION + STR_ , STR_ ) ; } catch ( Exception e3 ) { h . put ( ERROR + VERSION + STR_ , STR_ + e3 . toString ( ) ) ; } } } }
protected boolean isRecompilationNeeded ( int [ ] loadedChecksums ) { this . checksums [ NUM_ ] = calculateChecksum ( ) ; if ( this . checksums [ NUM_ ] != loadedChecksums [ NUM_ ] ) { if ( Trace . swcChecksum ) { Trace . trace ( STR_ ) ; } return BOOL_ ; } if ( ! isSwcChecksumEnabled ) { if ( Trace . swcChecksum ) { Trace . trace ( STR_ ) ; } return BOOL_ ; } Map < QName , Long > signatureChecksums = swcDefSignatureChecksums ; if ( signatureChecksums == null ) { if ( Trace . swcChecksum ) { Trace . trace ( STR_ ) ; } } else { for ( Map . Entry < QName , Long > entry : signatureChecksums . entrySet ( ) ) { QName qName = ( QName ) entry . getKey ( ) ; Long dataSignatureChecksum = ( Long ) entry . getValue ( ) ; Long swcSignatureChecksum = swcContext . getChecksum ( qName ) ; if ( swcSignatureChecksum == null && qName != null ) { Source source = swcContext . getSource ( qName . getNamespace ( ) , qName . getLocalPart ( ) ) ; if ( source != null ) { swcSignatureChecksum = new Long ( source . getLastModified ( ) ) ; } } if ( Trace . swcChecksum ) { if ( dataSignatureChecksum == null ) { throw new IllegalStateException ( STR_ ) ; } } if ( dataSignatureChecksum != null && swcSignatureChecksum == null ) { if ( Trace . swcChecksum ) { Trace . trace ( STR_ ) ; Trace . trace ( STR_ + entry . getKey ( ) ) ; Trace . trace ( STR_ + dataSignatureChecksum ) ; Trace . trace ( STR_ + swcSignatureChecksum ) ; } return BOOL_ ; } if ( dataSignatureChecksum != null ) { if ( dataSignatureChecksum . longValue ( ) != swcSignatureChecksum . longValue ( ) ) { if ( Trace . swcChecksum ) { Trace . trace ( STR_ ) ; Trace . trace ( STR_ + entry . getKey ( ) ) ; Trace . trace ( STR_ + dataSignatureChecksum ) ; Trace . trace ( STR_ + swcSignatureChecksum ) ; } return BOOL_ ; } } else { return BOOL_ ; } } } boolean result = ! areSwcFileChecksumsEqual ( ) ; if ( Trace . swcChecksum ) { Trace . trace ( STR_ + ( result ? STR_ : STR_ ) ) ; } return result ; }
private void adjustMinPrefForSpanningComps ( DimConstraint [ ] specs , Float [ ] defPush , FlowSizeSpec fss , ArrayList < LinkedDimGroup > [ ] groupsLists ) { for ( int r = groupsLists . length - NUM_ ; r >= NUM_ ; r -- ) { ArrayList < LinkedDimGroup > groups = groupsLists [ r ] ; for ( LinkedDimGroup group : groups ) { if ( group . span == NUM_ ) { continue ; } int [ ] sizes = group . getMinPrefMax ( ) ; for ( int s = LayoutUtil . MIN ; s <= LayoutUtil . PREF ; s ++ ) { int cSize = sizes [ s ] ; if ( cSize == LayoutUtil . NOT_SET ) { continue ; } int rowSize = NUM_ ; int sIx = ( r << NUM_ ) + NUM_ ; int len = Math . min ( ( group . span << NUM_ ) , fss . sizes . length - sIx ) - NUM_ ; for ( int j = sIx ; j < sIx + len ; j ++ ) { int sz = fss . sizes [ j ] [ s ] ; if ( sz != LayoutUtil . NOT_SET ) { rowSize += sz ; } } if ( rowSize < cSize && len > NUM_ ) { for ( int eagerness = NUM_ , newRowSize = NUM_ ; eagerness < NUM_ && newRowSize < cSize ; eagerness ++ ) { newRowSize = fss . expandSizes ( specs , defPush , cSize , sIx , len , s , eagerness ) ; } } } } } }
public static String dumpAsHex ( byte [ ] byteBuffer , int length ) { StringBuilder outputBuilder = new StringBuilder ( length . NUM_ ) ; int p = NUM_ ; int rows = length / NUM_ ; for ( int i = NUM_ ; ( i < rows ) && ( p < length ) ; i ++ ) { int ptemp = p ; for ( int j = NUM_ ; j < NUM_ ; j ++ ) { String hexVal = Integer . toHexString ( byteBuffer [ ptemp ] & xff ) ; if ( hexVal . length ( ) == NUM_ ) { hexVal = STR_ + hexVal ; } outputBuilder . append ( hexVal + STR_ ) ; ptemp ++ ; } outputBuilder . append ( STR_ ) ; for ( int j = NUM_ ; j < NUM_ ; j ++ ) { int b = xff & byteBuffer [ p ] ; if ( b > NUM_ && b < NUM_ ) { outputBuilder . append ( ( char ) b + STR_ ) ; } else { outputBuilder . append ( STR_ ) ; } p ++ ; } outputBuilder . append ( STR_ ) ; } int n = NUM_ ; for ( int i = p ; i < length ; i ++ ) { String hexVal = Integer . toHexString ( byteBuffer [ i ] & xff ) ; if ( hexVal . length ( ) == NUM_ ) { hexVal = STR_ + hexVal ; } outputBuilder . append ( hexVal + STR_ ) ; n ++ ; } for ( int i = n ; i < NUM_ ; i ++ ) { outputBuilder . append ( STR_ ) ; } outputBuilder . append ( STR_ ) ; for ( int i = p ; i < length ; i ++ ) { int b = xff & byteBuffer [ i ] ; if ( b > NUM_ && b < NUM_ ) { outputBuilder . append ( ( char ) b + STR_ ) ; } else { outputBuilder . append ( STR_ ) ; } } outputBuilder . append ( STR_ ) ; return outputBuilder . toString ( ) ; }
public void parseFile ( ChatEventParseListener listener ) { synchronized ( this ) { @ SuppressWarnings ( STR_ ) long startTime = System . currentTimeMillis ( ) ; BufferedReader reader = null ; try { reader = new BufferedReader ( new FileReader ( pathToFile ) ) ; String currentLine = reader . readLine ( ) ; while ( currentLine != null ) { try { ChatEvent event = ChatEventUtils . deserializeChatEvent ( currentLine ) ; if ( ! listener . onNewEventParsed ( event ) ) { break ; } } catch ( Throwable t ) { LOG . warn ( STR_ + currentLine + STR_ , t ) ; } currentLine = reader . readLine ( ) ; } listener . onParseCompleted ( ) ; } catch ( IOException ioe ) { throw new RuntimeException ( ioe ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( Throwable t ) { } } } } }
private CoderResult escapeSequenceOther ( short newByte ) { if ( newByte >= x20 && newByte <= x2F ) { state = ESCAPE_SEQUENCE_OTHER ; versionSequenceAllowed = BOOL_ ; queue . write ( newByte ) ; } else if ( newByte >= x30 && newByte <= x7E ) { state = NORMAL_BYTES ; versionSequenceAllowed = BOOL_ ; queue . reset ( ) ; } else { return malformedInput ( ERR_ESCBYTE ) ; } return CoderResult . UNDERFLOW ; }
@ Nullable public static NetworkParameters fromID ( String id ) { if ( id . equals ( ID_MAINNET ) ) { return MainNetParams . get ( ) ; } else if ( id . equals ( ID_TESTNET ) ) { return TestNet3Params . get ( ) ; } else if ( id . equals ( ID_UNITTESTNET ) ) { return UnitTestParams . get ( ) ; } else if ( id . equals ( ID_REGTEST ) ) { return RegTestParams . get ( ) ; } else if ( id . equals ( ID_ALPHANET ) ) { return AlphaNetParams . get ( ) ; } else { return null ; } }
public void addCertificatesAndCRLs ( CertStore certStore ) throws CertStoreException , CMSException { certs . addAll ( CMSUtils . getCertificatesFromStore ( certStore ) ) ; crls . addAll ( CMSUtils . getCRLsFromStore ( certStore ) ) ; }
protected abstract void storeBody ( DataOutputStream dos ) throws IOException ;
private double findAngle ( Point originPoint , Point targetPoint ) { int x1 = originPoint . x ; int y1 = originPoint . y ; int x2 = targetPoint . x ; int y2 = targetPoint . y ; double angle = NUM_ ; double offset = NUM_ ; double sideA = x2 - x1 ; double sideB = NUM_ ; if ( y1 >= y2 ) { sideB = y1 - y2 ; offset = Math . toRadians ( - NUM_ ) ; } else { sideB = - ( y2 - y1 ) ; offset = Math . toRadians ( NUM_ ) ; } if ( sideB == NUM_ ) { return angle ; } angle = Math . atan ( sideA / sideB ) ; return angle + offset ; }
public void appendWhitespace ( Appendable writer ) throws IOException { writer . append ( whiteSpace ) ; }
void clearResourceIndex ( String resourceTypeName ) { Set resourceTypes = new HashSet ( ) ; resourceTypes . addAll ( resourceIndices . keySet ( ) ) ; Iterator iter = resourceTypes . iterator ( ) ; while ( iter . hasNext ( ) ) { String resourceType = ( String ) iter . next ( ) ; if ( resourceType . equalsIgnoreCase ( resourceTypeName ) ) { resourceIndices . remove ( resourceType ) ; break ; } } }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
@ Override public byte [ ] bitcoinSerialize ( ) { if ( headerBytesValid && transactionBytesValid ) { Preconditions . checkNotNull ( payload , STR_ ) ; if ( length == payload . length ) { return payload ; } else { byte [ ] buf = new byte [ length ] ; System . arraycopy ( payload , offset , buf , NUM_ , length ) ; return buf ; } } ByteArrayOutputStream stream = new UnsafeByteArrayOutputStream ( length == UNKNOWN_LENGTH ? HEADER_SIZE + guessTransactionsLength ( ) : length ) ; try { writeHeader ( stream ) ; writeTransactions ( stream ) ; } catch ( IOException e ) { } return stream . toByteArray ( ) ; }
@ Override public List < Period > generateRollingPeriods ( DateTimeUnit dateTimeUnit ) { Calendar calendar = getCalendar ( ) ; List < Period > periods = Lists . newArrayList ( ) ; dateTimeUnit = calendar . minusDays ( dateTimeUnit , calendar . weekday ( dateTimeUnit ) - NUM_ ) ; dateTimeUnit = calendar . minusDays ( dateTimeUnit , NUM_ ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { periods . add ( createPeriod ( dateTimeUnit , calendar ) ) ; dateTimeUnit = calendar . plusWeeks ( dateTimeUnit , NUM_ ) ; } return periods ; }
@ Override public Set < String > vertexMatchPatternLabels ( ) { return Collections . emptySet ( ) ; }
public boolean resetUnreadCounts ( int aSection ) { boolean retCode = BOOL_ ; ArrayList < RoomSummary > summariesList = mSummaryListByGroupPosition . get ( aSection ) ; if ( null != summariesList ) { for ( int summaryIdx = NUM_ ; summaryIdx < summariesList . size ( ) ; summaryIdx ++ ) { retCode |= resetUnreadCount ( aSection , summaryIdx ) ; } } else { Log . w ( DBG_CLASS_NAME , STR_ + aSection + STR_ ) ; } return retCode ; }
public static void addCategory ( LexiconCategory category ) { categories . add ( category ) ; }
private static int CallNonvirtualObjectMethodV ( JNIEnvironment env , int objJREF , int classJREF , int methodID , Address argAddress ) throws Exception { if ( traceJNI ) VM . sysWrite ( STR_ ) ; RuntimeEntrypoints . checkJNICountDownToGC ( ) ; try { Object obj = env . getJNIRef ( objJREF ) ; Object returnObj = JNIHelpers . invokeWithVarArg ( obj , methodID , argAddress , null , BOOL_ ) ; return env . pushJNIRef ( returnObj ) ; } catch ( Throwable unexpected ) { if ( traceJNI ) unexpected . printStackTrace ( System . err ) ; env . recordException ( unexpected ) ; return NUM_ ; } }
private Tuple < Message , Connection > tryOtherMessages ( ) { List < Tuple < Message , Connection > > messages = new ArrayList < Tuple < Message , Connection > > ( ) ; Collection < Message > msgCollection = getMessageCollection ( ) ; for ( Connection con : getConnections ( ) ) { DTNHost other = con . getOtherNode ( getHost ( ) ) ; ProphetV2Router othRouter = ( ProphetV2Router ) other . getRouter ( ) ; if ( othRouter . isTransferring ( ) ) { continue ; } for ( Message m : msgCollection ) { if ( othRouter . hasMessage ( m . getId ( ) ) ) { continue ; } if ( ( othRouter . getPredFor ( m . getTo ( ) ) >= getPredFor ( m . getTo ( ) ) ) ) { messages . add ( new Tuple < Message , Connection > ( m , con ) ) ; } } } if ( messages . size ( ) == NUM_ ) { return null ; } Collections . sort ( messages , new TupleComparator ( ) ) ; return tryMessagesForConnected ( messages ) ; }
protected int makePressColor ( ) { int r = ( this . backgroundColor > > NUM_ ) & xFF ; int g = ( this . backgroundColor > > NUM_ ) & xFF ; int b = ( this . backgroundColor > > NUM_ ) & xFF ; r = ( r - NUM_ < NUM_ ) ? NUM_ : r - NUM_ ; g = ( g - NUM_ < NUM_ ) ? NUM_ : g - NUM_ ; b = ( b - NUM_ < NUM_ ) ? NUM_ : b - NUM_ ; return Color . rgb ( r , g , b ) ; }
private void testStreamsFromValues ( ) { Stream < String > movieNames = Stream . of ( STR_ , STR_ , STR_ ) ; movieNames . forEach ( null ) ; String [ ] movieNames2 = { STR_ , STR_ } ; Stream < String > mNames2 = Stream . of ( movieNames2 ) ; mNames2 . forEach ( null ) ; List < String > moviesList = new ArrayList < > ( ) ; moviesList . add ( STR_ ) ; moviesList . add ( STR_ ) ; Stream < List < String > > fromList = Stream . of ( moviesList ) ; fromList . forEach ( null ) ; }
public static void cacheClientUserId ( ConsumerBean consumerBean , Long internalId , String clientId ) { cacheClientUserId ( consumerBean . getShort_name ( ) , internalId , clientId ) ; }
protected void processEntity ( IXMLReader reader , IXMLEntityResolver entityResolver ) throws Exception { if ( ! XMLUtil . checkLiteral ( reader , STR_ ) ) { XMLUtil . skipTag ( reader ) ; return ; } XMLUtil . skipWhitespace ( reader , null ) ; char ch = XMLUtil . readChar ( reader , STR_ ) ; if ( ch == STR_ ) { XMLUtil . skipWhitespace ( reader , null ) ; entityResolver = this . parameterEntityResolver ; } else { reader . unread ( ch ) ; } String key = XMLUtil . scanIdentifier ( reader ) ; XMLUtil . skipWhitespace ( reader , null ) ; ch = XMLUtil . readChar ( reader , STR_ ) ; String systemID = null ; String publicID = null ; switch ( ch ) { case STR_ : if ( ! XMLUtil . checkLiteral ( reader , STR_ ) ) { XMLUtil . skipTag ( reader ) ; return ; } XMLUtil . skipWhitespace ( reader , null ) ; publicID = XMLUtil . scanString ( reader , STR_ , this . parameterEntityResolver ) ; XMLUtil . skipWhitespace ( reader , null ) ; systemID = XMLUtil . scanString ( reader , STR_ , this . parameterEntityResolver ) ; XMLUtil . skipWhitespace ( reader , null ) ; XMLUtil . readChar ( reader , STR_ ) ; break ; case STR_ : if ( ! XMLUtil . checkLiteral ( reader , STR_ ) ) { XMLUtil . skipTag ( reader ) ; return ; } XMLUtil . skipWhitespace ( reader , null ) ; systemID = XMLUtil . scanString ( reader , STR_ , this . parameterEntityResolver ) ; XMLUtil . skipWhitespace ( reader , null ) ; XMLUtil . readChar ( reader , STR_ ) ; break ; case STR_ : case STR_ : reader . unread ( ch ) ; String value = XMLUtil . scanString ( reader , STR_ , this . parameterEntityResolver ) ; entityResolver . addInternalEntity ( key , value ) ; XMLUtil . skipWhitespace ( reader , null ) ; XMLUtil . readChar ( reader , STR_ ) ; break ; default : XMLUtil . skipTag ( reader ) ; } if ( systemID != null ) { entityResolver . addExternalEntity ( key , publicID , systemID ) ; } }
@ Override final Node < V > find ( int h , int k ) { for ( Node < V > e = first ; e != null ; ) { int s ; if ( ( ( s = lockState ) & ( WAITER | WRITER ) ) != NUM_ ) { if ( ( e . key == k ) ) { return e ; } e = e . next ; } else if ( U . compareAndSwapInt ( this , LOCKSTATE , s , s + READER ) ) { TreeNode < V > r ; TreeNode < V > p ; try { p = ( ( r = root ) == null ? null : r . findTreeNode ( h , k ) ) ; } finally { Thread w ; if ( getAndAddInt ( this , LOCKSTATE , - READER ) == ( READER | WAITER ) && ( w = waiter ) != null ) { LockSupport . unpark ( w ) ; } } return p ; } } return null ; }
public boolean isPublic ( ) { return Modifier . isPublic ( flags ) ; }
@ Override public boolean receiveImage ( ImageToProcess img , TaskImageContainer task , boolean blockUntilImageRelease , boolean closeOnImageRelease , Optional < Runnable > runnableWhenDone ) throws InterruptedException { Set < TaskImageContainer > passTasks = new HashSet < TaskImageContainer > ( NUM_ ) ; passTasks . add ( task ) ; return receiveImage ( img , passTasks , blockUntilImageRelease , closeOnImageRelease , runnableWhenDone ) ; }
protected String doIt ( ) throws Exception { log . info ( STR_ + p_Selection + STR_ + p_DateInvoiced + STR_ + p_AD_Org_ID + STR_ + p_C_BPartner_ID + STR_ + p_M_InOut_ID + STR_ + p_docAction + STR_ + p_ConsolidateDocument ) ; String sql = null ; if ( p_Selection ) { sql = STR_ + STR_ + STR_ + STR_ + STR_ ; } else { sql = STR_ + STR_ ; if ( p_AD_Org_ID != NUM_ ) sql += STR_ ; if ( p_C_BPartner_ID != NUM_ ) sql += STR_ ; if ( p_M_InOut_ID != NUM_ ) sql += STR_ ; sql += STR_ + STR_ + STR_ ; } PreparedStatement pstmt = null ; try { pstmt = DB . prepareStatement ( sql , get_TrxName ( ) ) ; int index = NUM_ ; if ( p_Selection ) { pstmt . setInt ( index , getAD_PInstance_ID ( ) ) ; } else { if ( p_AD_Org_ID != NUM_ ) pstmt . setInt ( index ++ , p_AD_Org_ID ) ; if ( p_C_BPartner_ID != NUM_ ) pstmt . setInt ( index ++ , p_C_BPartner_ID ) ; if ( p_M_InOut_ID != NUM_ ) pstmt . setInt ( index ++ , p_M_InOut_ID ) ; } } catch ( Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } return generate ( pstmt ) ; }
protected int match_bitap ( String text , String pattern , int loc ) { assert ( Match_MaxBits == NUM_ || pattern . length ( ) <= Match_MaxBits ) : STR_ ; Map < Character , Integer > s = match_alphabet ( pattern ) ; double score_threshold = Match_Threshold ; int best_loc = text . indexOf ( pattern , loc ) ; if ( best_loc != - NUM_ ) { score_threshold = Math . min ( match_bitapScore ( NUM_ , best_loc , loc , pattern ) , score_threshold ) ; best_loc = text . lastIndexOf ( pattern , loc + pattern . length ( ) ) ; if ( best_loc != - NUM_ ) { score_threshold = Math . min ( match_bitapScore ( NUM_ , best_loc , loc , pattern ) , score_threshold ) ; } } int matchmask = NUM_ << ( pattern . length ( ) - NUM_ ) ; best_loc = - NUM_ ; int bin_min , bin_mid ; int bin_max = pattern . length ( ) + text . length ( ) ; int [ ] last_rd = new int [ NUM_ ] ; for ( int d = NUM_ ; d < pattern . length ( ) ; d ++ ) { bin_min = NUM_ ; bin_mid = bin_max ; while ( bin_min < bin_mid ) { if ( match_bitapScore ( d , loc + bin_mid , loc , pattern ) <= score_threshold ) { bin_min = bin_mid ; } else { bin_max = bin_mid ; } bin_mid = ( bin_max - bin_min ) / NUM_ + bin_min ; } bin_max = bin_mid ; int start = Math . max ( NUM_ , loc - bin_mid + NUM_ ) ; int finish = Math . min ( loc + bin_mid , text . length ( ) ) + pattern . length ( ) ; int [ ] rd = new int [ finish + NUM_ ] ; rd [ finish + NUM_ ] = ( NUM_ << d ) - NUM_ ; for ( int j = finish ; j >= start ; j -- ) { int charMatch ; if ( text . length ( ) <= j - NUM_ || ! s . containsKey ( text . charAt ( j - NUM_ ) ) ) { charMatch = NUM_ ; } else { charMatch = s . get ( text . charAt ( j - NUM_ ) ) ; } if ( d == NUM_ ) { rd [ j ] = ( ( rd [ j + NUM_ ] << NUM_ ) | NUM_ ) & charMatch ; } else { rd [ j ] = ( ( ( rd [ j + NUM_ ] << NUM_ ) | NUM_ ) & charMatch ) | ( ( ( last_rd [ j + NUM_ ] | last_rd [ j ] ) << NUM_ ) | NUM_ ) | last_rd [ j + NUM_ ] ; } if ( ( rd [ j ] & matchmask ) != NUM_ ) { double score = match_bitapScore ( d , j - NUM_ , loc , pattern ) ; if ( score <= score_threshold ) { score_threshold = score ; best_loc = j - NUM_ ; if ( best_loc > loc ) { start = Math . max ( NUM_ , NUM_ . loc - best_loc ) ; } else { break ; } } } } if ( match_bitapScore ( d + NUM_ , loc , loc , pattern ) > score_threshold ) { break ; } last_rd = rd ; } return best_loc ; }
public static S2CellId fromFaceIJ ( int face , int i , int j ) { long n [ ] = { NUM_ , face << ( POS_BITS - NUM_ ) } ; int bits = ( face & SWAP_MASK ) ; for ( int k = NUM_ ; k >= NUM_ ; -- k ) { bits = getBits ( n , i , j , k , bits ) ; } S2CellId s = new S2CellId ( ( ( ( n [ NUM_ ] << NUM_ ) + n [ NUM_ ] ) << NUM_ ) + NUM_ ) ; return s ; }
private static boolean hasResponseBody ( int requestMethod , int responseCode ) { return requestMethod != Request . Method . HEAD && ! ( HttpStatus . SC_CONTINUE <= responseCode && responseCode < HttpStatus . SC_OK ) && responseCode != HttpStatus . SC_NO_CONTENT && responseCode != HttpStatus . SC_NOT_MODIFIED ; }
private void updateActions ( final INaviProject project ) { m_loadProjectAction . setEnabled ( ! project . isLoaded ( ) ) ; if ( m_addAddressSpaceAction != null ) { m_addAddressSpaceAction . setEnabled ( project . isLoaded ( ) ) ; } m_searchViewAction . setEnabled ( project . isLoaded ( ) ) ; m_forwardAction . setEnabled ( project . isLoaded ( ) ) ; }
void close ( ) throws IOException { stream . close ( ) ; }
public boolean truncateTooLongNumber ( PhoneNumber number ) { if ( isValidNumber ( number ) ) { return BOOL_ ; } PhoneNumber numberCopy = new PhoneNumber ( ) ; numberCopy . mergeFrom ( number ) ; long nationalNumber = number . getNationalNumber ( ) ; do { nationalNumber /= NUM_ ; numberCopy . setNationalNumber ( nationalNumber ) ; if ( isPossibleNumberWithReason ( numberCopy ) == ValidationResult . TOO_SHORT || nationalNumber == NUM_ ) { return BOOL_ ; } } while ( ! isValidNumber ( numberCopy ) ) ; number . setNationalNumber ( nationalNumber ) ; return BOOL_ ; }
public static boolean isWithinTimeComparisonEpsilon ( long timeMicros ) { long now = Utils . getSystemNowMicrosUtc ( ) ; return Math . abs ( timeMicros - now ) < timeComparisonEpsilon ; }
public Optional < Histogram > histogram ( ) { return Optional . empty ( ) ; }
private JLabel createWeekday ( String title ) { JLabel label = new JLabel ( title ) ; label . setHorizontalAlignment ( SwingConstants . CENTER ) ; label . setHorizontalTextPosition ( SwingConstants . CENTER ) ; label . setRequestFocusEnabled ( BOOL_ ) ; label . setBackground ( AdempierePLAF . getPrimary1 ( ) ) ; label . setForeground ( Color . white ) ; label . setOpaque ( BOOL_ ) ; return label ; }
default Path append ( String relPath ) { return append ( Path . parse ( relPath ) ) ; }
public static int indexOf ( String value , String substring ) { return value != null && substring != null ? value . indexOf ( substring ) : - NUM_ ; }
public void testSubmitNullCallable ( ) { ExecutorService e = new ForkJoinPool ( NUM_ ) ; PoolCleaner cleaner = null ; try { cleaner = cleaner ( e ) ; try { @ SuppressWarnings ( STR_ ) Future < String > future = e . submit ( ( Callable < String > ) null ) ; shouldThrow ( ) ; } catch ( NullPointerException success ) { } } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public boolean isLocked ( ) { return ! queue . isEmpty ( ) ; }
public void addPreprocessorDirective ( String directive ) { if ( mPreprocessorDirectives == null ) mPreprocessorDirectives = new ArrayList < String > ( ) ; mPreprocessorDirectives . add ( directive ) ; }
public void format ( long inDate , StringBuilder buffer ) { buffer . append ( format ( inDate ) ) ; }
public Profiler clearResults ( ) { lapped . clear ( ) ; return this ; }
@ Override public GraphQuery has ( final String key , final Object value ) { criteria . add ( new Has ( key , value ) ) ; return this ; }
public void addAttributeValue ( Principal principal , Guid guid , String name , String value ) throws UMSException { modifyAttributeValue ( ModificationType . ADD , principal , guid , name , value ) ; }
public static void copyStream ( InputStream inputStream , OutputStream outputStream ) { if ( inputStream != null && outputStream != null ) { try { int length = - NUM_ ; byte [ ] buffer = new byte [ Constant . Capacity . BYTES_PER_MB ] ; while ( ( length = inputStream . read ( buffer , NUM_ , buffer . length ) ) != - NUM_ ) { outputStream . write ( buffer , NUM_ , length ) ; outputStream . flush ( ) ; } } catch ( Exception e ) { throw new FileUtilException ( e ) ; } } }
private void printTypeMembers ( List < ? extends Element > members , List < TypeElement > innerClass ) { for ( Element element : members ) { if ( isPublicOrProtected ( element ) ) { printMember ( element , innerClass ) ; } } }
private void initializeBasicVariables ( final int startColumn ) { basicVariables = new int [ getWidth ( ) - NUM_ ] ; basicRows = new int [ getHeight ( ) ] ; Arrays . fill ( basicVariables , - NUM_ ) ; for ( int i = startColumn ; i < getWidth ( ) - NUM_ ; i ++ ) { Integer row = findBasicRow ( i ) ; if ( row != null ) { basicVariables [ i ] = row ; basicRows [ row ] = i ; } } }
public void mouseReleased ( MouseEvent e ) { }
long freeSpaceWindows ( String path , long timeout ) throws IOException { path = FilenameUtils . normalize ( path , BOOL_ ) ; if ( path . length ( ) > NUM_ && path . charAt ( NUM_ ) != STR_ ) { path = STR_ + path + STR_ ; } String [ ] cmdAttribs = new String [ ] { STR_ , STR_ , STR_ + path } ; List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ; for ( int i = lines . size ( ) - NUM_ ; i >= NUM_ ; i -- ) { String line = lines . get ( i ) ; if ( line . length ( ) > NUM_ ) { return parseDir ( line , path ) ; } } throw new IOException ( STR_ + STR_ + path + STR_ ) ; }
private void attachHeader ( SIPHeader h ) { if ( h == null ) throw new IllegalArgumentException ( STR_ ) ; try { if ( h instanceof SIPHeaderList ) { SIPHeaderList < ? > hl = ( SIPHeaderList < ? > ) h ; if ( hl . isEmpty ( ) ) { return ; } } attachHeader ( h , BOOL_ , BOOL_ ) ; } catch ( SIPDuplicateHeaderException ex ) { } }
public String phonemise ( String text , String pos , StringBuilder g2pMethod ) { String result = userdictLookup ( text , pos ) ; if ( result != null ) { g2pMethod . append ( STR_ ) ; return result ; } result = lexiconLookup ( text , pos ) ; if ( result != null ) { g2pMethod . append ( STR_ ) ; return result ; } String normalised = MaryUtils . normaliseUnicodeLetters ( text , getLocale ( ) ) ; if ( ! normalised . equals ( text ) ) { result = userdictLookup ( normalised , pos ) ; if ( result != null ) { g2pMethod . append ( STR_ ) ; return result ; } result = lexiconLookup ( normalised , pos ) ; if ( result != null ) { g2pMethod . append ( STR_ ) ; return result ; } } String phones = lts . predictPronunciation ( text ) ; result = lts . syllabify ( phones ) ; if ( result != null ) { g2pMethod . append ( STR_ ) ; return result ; } return null ; }
public static void stop ( int exit_code ) { System . exit ( exit_code ) ; }
private FieldODEStateAndDerivative < Decimal64 > state ( double t ) { return new FieldODEStateAndDerivative < > ( zero . add ( t ) , new Decimal64 [ NUM_ ] , new Decimal64 [ NUM_ ] ) ; }
public static int hash ( Object object ) { return object == null ? NUM_ : object . hashCode ( ) ; }
public void putAll ( Map < ? extends K , ? extends V > m ) { for ( Map . Entry < ? extends K , ? extends V > e : m . entrySet ( ) ) put ( e . getKey ( ) , e . getValue ( ) ) ; }
private void assertPivot ( String field , Object value , int count , PivotField actual ) { assertEquals ( STR_ + actual . toString ( ) , field , actual . getField ( ) ) ; assertEquals ( STR_ + actual . toString ( ) , value , actual . getValue ( ) ) ; assertEquals ( STR_ + actual . toString ( ) , count , actual . getCount ( ) ) ; }
public String toXMLString ( ) throws FSMsgException { return toXMLString ( BOOL_ , BOOL_ ) ; }
public static final void writeStringArrayXml ( String [ ] val , String name , XmlSerializer out ) throws XmlPullParserException , java . io . IOException { if ( val == null ) { out . startTag ( null , STR_ ) ; out . endTag ( null , STR_ ) ; return ; } out . startTag ( null , STR_ ) ; if ( name != null ) { out . attribute ( null , STR_ , name ) ; } final int n = val . length ; out . attribute ( null , STR_ , Integer . toString ( n ) ) ; for ( int i = NUM_ ; i < n ; i ++ ) { if ( val [ i ] == null ) { out . startTag ( null , STR_ ) ; out . endTag ( null , STR_ ) ; } else { out . startTag ( null , STR_ ) ; out . attribute ( null , STR_ , val [ i ] ) ; out . endTag ( null , STR_ ) ; } } out . endTag ( null , STR_ ) ; }
public static void walkFileTree ( File directory , FileTreeVisitor visitor ) { visitor . preVisitDirectory ( directory ) ; File [ ] files = directory . listFiles ( ) ; if ( files != null ) { for ( File file : files ) { if ( file . isDirectory ( ) ) { walkFileTree ( file , visitor ) ; } else { visitor . visitFile ( file ) ; } } } visitor . postVisitDirectory ( directory ) ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
private Spannable highlightHashtags ( Spannable text ) { if ( text == null ) { return null ; } final Matcher matcher = PATTERN_HASHTAGS . matcher ( text ) ; while ( matcher . find ( ) ) { final int start = matcher . start ( NUM_ ) ; final int end = matcher . end ( NUM_ ) ; text . setSpan ( new ForegroundColorSpan ( mHighlightColor ) , start , end , Spanned . SPAN_EXCLUSIVE_EXCLUSIVE ) ; text . setSpan ( new StyleSpan ( android . graphics . Typeface . BOLD ) , start , end , Spanned . SPAN_EXCLUSIVE_EXCLUSIVE ) ; } return text ; }
protected int readBlock ( ) { blockSize = read ( ) ; int n = NUM_ ; if ( blockSize > NUM_ ) { try { int count ; while ( n < blockSize ) { count = blockSize - n ; rawData . get ( block , n , count ) ; n += count ; } } catch ( final Exception e ) { Log . w ( TAG , STR_ , e ) ; status = STATUS_FORMAT_ERROR ; } } return n ; }
public int processBlock ( byte [ ] in , int inOff , byte [ ] out , int outOff ) throws DataLengthException , IllegalStateException { if ( ( inOff + blockSize ) > in . length ) { throw new DataLengthException ( STR_ ) ; } if ( ( outOff + blockSize ) > out . length ) { throw new DataLengthException ( STR_ ) ; } cipher . processBlock ( ofbV , NUM_ , ofbOutV , NUM_ ) ; for ( int i = NUM_ ; i < blockSize ; i ++ ) { out [ outOff + i ] = ( byte ) ( ofbOutV [ i ] ^ in [ inOff + i ] ) ; } System . arraycopy ( ofbV , blockSize , ofbV , NUM_ , ofbV . length - blockSize ) ; System . arraycopy ( ofbOutV , NUM_ , ofbV , ofbV . length - blockSize , blockSize ) ; return blockSize ; }
public String commandTopic ( String command ) { if ( command == null ) { command = STR_ ; } return cmdTopic . replace ( STR_ , command ) ; }
private static void checkForNullElement ( Object [ ] arg , String argName ) { if ( ( arg == null ) || ( arg . length == NUM_ ) ) { throw new IllegalArgumentException ( STR_ + argName + STR_ ) ; } for ( int i = NUM_ ; i < arg . length ; i ++ ) { if ( arg [ i ] == null ) { throw new IllegalArgumentException ( STR_ + argName + STR_ + i + STR_ ) ; } } }
public InputStream executeDownload ( String url , String cookie ) throws IOException { String [ ] [ ] headerParams = new String [ ] [ ] { { STR_ , cookie } , { STR_ , STR_ } } ; HttpEntity httpEntity = executeGet ( url , null , headerParams ) ; return httpEntity . getContent ( ) ; }
public final void testSetSeedbyteArray02 ( ) throws NoSuchFieldException , SecurityException , IllegalAccessException { byte [ ] seed = new byte [ LENGTH ] ; byte [ ] bytes1 = new byte [ LENGTH ] ; byte [ ] bytes2 = new byte [ LENGTH ] ; boolean b ; for ( int i = NUM_ ; i < seed . length ; i ++ ) { seed [ i ] = ( byte ) i ; } sr . setSeed ( seed ) ; sr . setSeed ( seed ) ; sr2 . setSeed ( seed ) ; sr . nextBytes ( bytes1 ) ; sr2 . nextBytes ( bytes2 ) ; b = BOOL_ ; for ( int j = NUM_ ; j < bytes1 . length ; j ++ ) { b &= bytes1 [ j ] == bytes2 [ j ] ; } assertFalse ( STR_ , b ) ; }
public Image flipImageVertically ( Image image , boolean maintainOpacity ) { int [ ] rgb = image . getRGB ( ) ; int [ ] newRGB = new int [ rgb . length ] ; int width = image . getWidth ( ) ; int height = image . getHeight ( ) ; for ( int y = NUM_ ; y < height ; y ++ ) { for ( int x = NUM_ ; x < width ; x ++ ) { newRGB [ x + ( height - y - NUM_ ) . width ] = rgb [ x + y . width ] ; } } return EncodedImage . createFromRGB ( newRGB , width , height , ! maintainOpacity ) ; }
public MorfologikFilterFactory ( Map < String , String > args ) { super ( args ) ; final String DICTIONARY_RESOURCE_ATTRIBUTE = STR_ ; String dictionaryResource = get ( args , DICTIONARY_RESOURCE_ATTRIBUTE ) ; if ( dictionaryResource != null && ! dictionaryResource . isEmpty ( ) ) { throw new IllegalArgumentException ( STR_ + DICTIONARY_RESOURCE_ATTRIBUTE + STR_ + STR_ + DICTIONARY_ATTRIBUTE + STR_ ) ; } resourceName = get ( args , DICTIONARY_ATTRIBUTE ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( STR_ + args ) ; } }
public static < T > T wrapThrow ( Callable < T > callable , Code _finally ) { try { return callable . call ( ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } finally { wrapThrow ( _finally ) ; } }
public static String padLeft ( String str , int totalChars ) { if ( str == null ) str = STR_ ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = NUM_ ; i < totalChars - str . length ( ) ; i ++ ) { sb . append ( STR_ ) ; } sb . append ( str ) ; return sb . toString ( ) ; }
protected void decodeImageData ( ) { int NullCode = - NUM_ ; int npix = iw . ih ; int available , clear , code_mask , code_size , end_of_information , in_code , old_code , bits , code , count , i , datum , data_size , first , top , bi , pi ; if ( ( pixels == null ) || ( pixels . length < npix ) ) { pixels = new byte [ npix ] ; } if ( prefix == null ) prefix = new short [ MaxStackSize ] ; if ( suffix == null ) suffix = new byte [ MaxStackSize ] ; if ( pixelStack == null ) pixelStack = new byte [ MaxStackSize + NUM_ ] ; data_size = read ( ) ; clear = NUM_ << data_size ; end_of_information = clear + NUM_ ; available = clear + NUM_ ; old_code = NullCode ; code_size = data_size + NUM_ ; code_mask = ( NUM_ << code_size ) - NUM_ ; for ( code = NUM_ ; code < clear ; code ++ ) { prefix [ code ] = NUM_ ; suffix [ code ] = ( byte ) code ; } datum = bits = count = first = top = pi = bi = NUM_ ; for ( i = NUM_ ; i < npix ; ) { if ( top == NUM_ ) { if ( bits < code_size ) { if ( count == NUM_ ) { count = readBlock ( ) ; if ( count <= NUM_ ) break ; bi = NUM_ ; } datum += ( ( ( int ) block [ bi ] ) & xff ) << bits ; bits += NUM_ ; bi ++ ; count -- ; continue ; } code = datum & code_mask ; datum >>= code_size ; bits -= code_size ; if ( ( code > available ) || ( code == end_of_information ) ) break ; if ( code == clear ) { code_size = data_size + NUM_ ; code_mask = ( NUM_ << code_size ) - NUM_ ; available = clear + NUM_ ; old_code = NullCode ; continue ; } if ( old_code == NullCode ) { pixelStack [ top ++ ] = suffix [ code ] ; old_code = code ; first = code ; continue ; } in_code = code ; if ( code == available ) { pixelStack [ top ++ ] = ( byte ) first ; code = old_code ; } while ( code > clear ) { pixelStack [ top ++ ] = suffix [ code ] ; code = prefix [ code ] ; } first = ( ( int ) suffix [ code ] ) & xff ; if ( available >= MaxStackSize ) break ; pixelStack [ top ++ ] = ( byte ) first ; prefix [ available ] = ( short ) old_code ; suffix [ available ] = ( byte ) first ; available ++ ; if ( ( ( available & code_mask ) == NUM_ ) && ( available < MaxStackSize ) ) { code_size ++ ; code_mask += available ; } old_code = in_code ; } top -- ; pixels [ pi ++ ] = pixelStack [ top ] ; i ++ ; } for ( i = pi ; i < npix ; i ++ ) { pixels [ i ] = NUM_ ; } }
public int hashCode ( ) { int myhash = NUM_ + policyIdentifier . hashCode ( ) ; myhash = NUM_ . myhash + policyQualifiers . hashCode ( ) ; return myhash ; }
public UnixTerminal ( ) throws IOException { this ( System . in , System . out , Charset . defaultCharset ( ) ) ; }
public static void v ( String tag , String s , Object ... args ) { if ( LOG . VERBOSE >= LOGLEVEL ) Log . v ( tag , String . format ( s , args ) ) ; }
@ Override public boolean isCellEditable ( int rowIndex , int columnIndex ) { ProcessFunctionParameterValue value = valueList . get ( rowIndex ) ; switch ( columnIndex ) { case COL_OPTIONAL : return value . optional ; case COL_VALUE : if ( value . optional ) { return value . included ; } else { return BOOL_ ; } case COL_PARAMETER : case COL_TYPE : default : return BOOL_ ; } }
private void checkStreams ( ) { if ( ( System . currentTimeMillis ( ) - lastChecked ) / NUM_ < CHECK_DELAY ) { return ; } lastChecked = System . currentTimeMillis ( ) ; Set < StreamInfo > remove = new HashSet < > ( ) ; for ( StreamInfo info : data ) { if ( ! info . isValid ( ) || ! info . getOnline ( ) ) { remove . add ( info ) ; } } for ( StreamInfo info : remove ) { data . remove ( info ) ; itemRemoved ( info ) ; } if ( remove . isEmpty ( ) ) { listDataChanged ( ) ; } }
@ Override public void addFocusables ( ArrayList < View > views , int direction , int focusableMode ) { final int focusableCount = views . size ( ) ; final int descendantFocusability = getDescendantFocusability ( ) ; if ( descendantFocusability != FOCUS_BLOCK_DESCENDANTS ) { for ( int i = NUM_ ; i < getChildCount ( ) ; i ++ ) { final View child = getChildAt ( i ) ; if ( child . getVisibility ( ) == VISIBLE ) { ItemInfo ii = infoForChild ( child ) ; if ( ii != null && ii . position == mCurItem ) { child . addFocusables ( views , direction , focusableMode ) ; } } } } if ( descendantFocusability != FOCUS_AFTER_DESCENDANTS || ( focusableCount == views . size ( ) ) ) { if ( ! isFocusable ( ) ) { return ; } if ( ( focusableMode & FOCUSABLES_TOUCH_MODE ) == FOCUSABLES_TOUCH_MODE && isInTouchMode ( ) && ! isFocusableInTouchMode ( ) ) { return ; } if ( views != null ) { views . add ( this ) ; } } }
public void addPriorityPackage ( String pkg ) { if ( _priorityPackages == null ) _priorityPackages = new String [ NUM_ ] ; int oldLength = _priorityPackages . length ; String [ ] newPkgs = new String [ oldLength + NUM_ ] ; System . arraycopy ( _priorityPackages , NUM_ , newPkgs , NUM_ , oldLength ) ; if ( ! pkg . endsWith ( STR_ ) ) pkg = pkg + STR_ ; newPkgs [ oldLength ] = pkg ; _priorityPackages = newPkgs ; }
@ Override public void actionPerformed ( ActionEvent ev ) { final megan . remote . RemoteServiceBrowser remoteServiceBrowser = ( megan . remote . RemoteServiceBrowser ) getViewer ( ) ; if ( remoteServiceBrowser != null ) { String url = remoteServiceBrowser . getURL ( ) ; String user = remoteServiceBrowser . getUser ( ) ; String password = remoteServiceBrowser . getPasswd ( ) ; String command = STR_ + url + STR_ ; if ( user . length ( ) > NUM_ ) command += STR_ + user + STR_ ; if ( password . length ( ) > NUM_ ) { synchronized ( syncObject ) { OpenRemoteServerCommand . hiddenPassword = password ; } command += STR_ + HIDDEN_PASSWORD + STR_ ; } command += STR_ ; if ( url . length ( ) > NUM_ ) { execute ( command ) ; } } }
public static String verifyCertificate ( X509Certificate cert , Collection < CRL > crls , Calendar calendar ) { if ( SignUtils . hasUnsupportedCriticalExtension ( cert ) ) return STR_ ; try { cert . checkValidity ( calendar . getTime ( ) ) ; } catch ( Exception e ) { return e . getMessage ( ) ; } if ( crls != null ) { for ( CRL crl : crls ) { if ( crl . isRevoked ( cert ) ) return STR_ ; } } return null ; }
public static void expand ( ) { String [ ] st = new String [ L ] ; int i ; for ( i = NUM_ ; i < R ; i ++ ) st [ i ] = STR_ + ( char ) i ; st [ i ++ ] = STR_ ; int codeword = BinaryStdIn . readInt ( W ) ; if ( codeword == R ) return ; String val = st [ codeword ] ; while ( BOOL_ ) { BinaryStdOut . write ( val ) ; codeword = BinaryStdIn . readInt ( W ) ; if ( codeword == R ) break ; String s = st [ codeword ] ; if ( i == codeword ) s = val + val . charAt ( NUM_ ) ; if ( i < L ) st [ i ++ ] = val + s . charAt ( NUM_ ) ; val = s ; } BinaryStdOut . close ( ) ; }
AudioCapabilities ( int [ ] supportedEncodings , int maxChannelCount ) { if ( supportedEncodings != null ) { this . supportedEncodings = Arrays . copyOf ( supportedEncodings , supportedEncodings . length ) ; Arrays . sort ( this . supportedEncodings ) ; } else { this . supportedEncodings = new int [ NUM_ ] ; } this . maxChannelCount = maxChannelCount ; }
@ Override public boolean isRotateEdgeLabels ( ) { return graphCreator . isRotatingEdgeLabels ( ) ; }
public static ResponseCode createExtension ( String name ) { StringBuffer buffer = new StringBuffer ( name . length ( ) + NUM_ ) ; if ( ! name . startsWith ( STR_ ) ) { buffer . append ( STR_ ) ; } buffer . append ( name ) ; return new ResponseCode ( buffer . toString ( ) ) ; }
@ Override public double [ ] makeInverseCumulativeTestValues ( ) { double [ ] points = makeCumulativeTestPoints ( ) ; double [ ] points2 = new double [ points . length - NUM_ ] ; System . arraycopy ( points , NUM_ , points2 , NUM_ , points2 . length ) ; return points2 ; }
public java . lang . StringBuilder append ( boolean b ) { if ( b ) { return append ( STR_ ) ; } return append ( STR_ ) ; }
public void deleteServers ( Set servers ) throws AMConsoleException { if ( servers . contains ( SystemProperties . getServerInstanceName ( ) ) ) { throw new AMConsoleException ( getLocalizedString ( STR_ ) ) ; } String serverName = null ; try { if ( ( servers != null ) && ! servers . isEmpty ( ) ) { SSOToken token = getUserSSOToken ( ) ; for ( Iterator i = servers . iterator ( ) ; i . hasNext ( ) ; ) { serverName = ( String ) i . next ( ) ; String [ ] param = { serverName } ; logEvent ( STR_ , param ) ; ServerConfiguration . deleteServerInstance ( token , serverName ) ; logEvent ( STR_ , param ) ; } } } catch ( SMSException e ) { String [ ] params = { serverName , e . getMessage ( ) } ; logEvent ( STR_ , params ) ; throw new AMConsoleException ( getErrorString ( e ) ) ; } catch ( SSOException e ) { String [ ] params = { serverName , e . getMessage ( ) } ; logEvent ( STR_ , params ) ; throw new AMConsoleException ( getErrorString ( e ) ) ; } }
protected void arraycopy ( byte [ ] buf , int pos , int length ) { mMessage . write ( buf , pos , length ) ; mPosition = mPosition + length ; }
static void sort ( float [ ] a , int left , int right , float [ ] work , int workBase , int workLen ) { while ( left <= right && Float . isNaN ( a [ right ] ) ) { -- right ; } for ( int k = right ; -- k >= left ; ) { float ak = a [ k ] ; if ( ak != ak ) { a [ k ] = a [ right ] ; a [ right ] = ak ; -- right ; } } doSort ( a , left , right , work , workBase , workLen ) ; int hi = right ; while ( left < hi ) { int middle = ( left + hi ) > > > NUM_ ; float middleValue = a [ middle ] ; if ( middleValue < NUM_ ) { left = middle + NUM_ ; } else { hi = middle ; } } while ( left <= right && Float . floatToRawIntBits ( a [ left ] ) < NUM_ ) { ++ left ; } for ( int k = left , p = left - NUM_ ; ++ k <= right ; ) { float ak = a [ k ] ; if ( ak != NUM_ ) { break ; } if ( Float . floatToRawIntBits ( ak ) < NUM_ ) { a [ k ] = NUM_ ; a [ ++ p ] = - NUM_ ; } } }
public void fatalError ( org . xml . sax . SAXParseException e ) throws org . xml . sax . SAXException { String formattedMsg = e . getMessage ( ) ; SAXSourceLocator locator = getLocator ( ) ; ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; try { handler . fatalError ( new TransformerException ( formattedMsg , locator ) ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } }
public boolean add ( terminal sym ) throws internal_error { boolean result ; not_null ( sym ) ; result = _elements . get ( sym . index ( ) ) ; if ( ! result ) _elements . set ( sym . index ( ) ) ; return result ; }
private void createRecursivly ( String path ) throws KeeperException , InterruptedException { try { if ( zk . exists ( path , BOOL_ ) == null && path . length ( ) > NUM_ ) { String temp = path . substring ( NUM_ , path . lastIndexOf ( File . separator ) ) ; createRecursivly ( temp ) ; zk . create ( path , null , Ids . OPEN_ACL_UNSAFE , CreateMode . PERSISTENT ) ; } else { return ; } } catch ( KeeperException e ) { throw e ; } catch ( InterruptedException e ) { throw e ; } }
public void stopRecording ( ) { mHandler . sendMessage ( mHandler . obtainMessage ( MSG_STOP_RECORDING ) ) ; mHandler . sendMessage ( mHandler . obtainMessage ( MSG_QUIT ) ) ; }
private void writeTag ( String name , Tag tag ) throws IOException { TagType type = tag . getType ( ) ; byte [ ] nameBytes = name . getBytes ( StandardCharsets . UTF_8 ) ; if ( type == TagType . END ) { throw new IOException ( STR_ ) ; } os . writeByte ( type . getId ( ) ) ; os . writeShort ( nameBytes . length ) ; os . write ( nameBytes ) ; writeTagPayload ( tag ) ; }
public int hashCode ( ) { if ( myhash == - NUM_ ) { if ( timestamp == null ) { myhash = signerCertPath . hashCode ( ) ; } else { myhash = signerCertPath . hashCode ( ) + timestamp . hashCode ( ) ; } } return myhash ; }
public TypeVariableBV typeVariable ( ) { int id = typeVariableList . size ( ) ; typeVariableList . add ( null ) ; TypeVariableBV result = new TypeVariableBV ( id , this ) ; typeVariableList . set ( id , result ) ; return result ; }
public int process ( Callback [ ] callbacks , int state ) throws AuthLoginException { initAuthConfig ( ) ; X509Certificate [ ] allCerts = null ; try { HttpServletRequest servletRequest = getHttpServletRequest ( ) ; if ( servletRequest != null ) { allCerts = ( X509Certificate [ ] ) servletRequest . getAttribute ( STR_ ) ; if ( allCerts == null || allCerts . length == NUM_ ) { debug . message ( STR_ ) ; if ( ! portal_gw_cert_auth_enabled ) { debug . error ( STR_ + STR_ ) ; throw new AuthLoginException ( amAuthCert , STR_ , null ) ; } thecert = getPortalStyleCert ( servletRequest ) ; allCerts = new X509Certificate [ ] { thecert } ; } else { if ( portal_gw_cert_auth_enabled && portal_gw_cert_preferred ) { thecert = getPortalStyleCert ( servletRequest ) ; allCerts = new X509Certificate [ ] { thecert } ; } else { if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + STR_ , allCerts . length ) ; } thecert = allCerts [ NUM_ ] ; } } } else { thecert = sendCallback ( ) ; } if ( thecert == null ) { debug . message ( STR_ ) ; throw new AuthLoginException ( amAuthCert , STR_ , null ) ; } getTokenFromCert ( thecert ) ; storeUsernamePasswd ( userTokenId , null ) ; if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + userTokenId + STR_ ) ; } } catch ( AuthLoginException e ) { setFailureID ( userTokenId ) ; debug . error ( STR_ , e ) ; throw new AuthLoginException ( amAuthCert , STR_ , null ) ; } if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + thecert . toString ( ) ) ; } if ( amAuthCert_chkCertInLDAP . equalsIgnoreCase ( STR_ ) && amAuthCert_chkCRL . equalsIgnoreCase ( STR_ ) && ! ocspEnabled ) { return ISAuthConstants . LOGIN_SUCCEED ; } if ( ldapParam == null ) { setLdapStoreParam ( ) ; } if ( amAuthCert_chkCertInLDAP . equalsIgnoreCase ( STR_ ) ) { X509Certificate ldapcert = AMCertStore . getRegisteredCertificate ( ldapParam , thecert , amAuthCert_chkAttrCertInLDAP ) ; if ( ldapcert == null ) { debug . error ( STR_ ) ; setFailureID ( userTokenId ) ; throw new AuthLoginException ( amAuthCert , STR_ , null ) ; } } int ret = doJCERevocationValidation ( allCerts ) ; if ( ret != ISAuthConstants . LOGIN_SUCCEED ) { debug . error ( STR_ ) ; setFailureID ( userTokenId ) ; throw new AuthLoginException ( amAuthCert , STR_ , null ) ; } return ISAuthConstants . LOGIN_SUCCEED ; }
public static void downto ( Number self , Number to , @ ClosureParams ( FirstParam . class ) Closure closure ) { int self1 = self . intValue ( ) ; int to1 = to . intValue ( ) ; if ( self1 >= to1 ) { for ( int i = self1 ; i >= to1 ; i -- ) { closure . call ( i ) ; } } else throw new GroovyRuntimeException ( STR_ + to + STR_ + self + STR_ ) ; }
public void add ( SelectClauseElementRaw element ) { selectClauseElements . add ( element ) ; }
public synchronized void removePvChangeListener ( PvChangeListener l ) { log . debug ( STR_ + String . valueOf ( this ) + STR_ + String . valueOf ( l ) ) ; PvChangeListeners . remove ( l ) ; }
public static boolean isNormal ( GeoTimeSerie gts , int buckets , double pcterror , boolean bessel ) { if ( NUM_ == gts . values ) { return BOOL_ ; } if ( TYPE . DOUBLE != gts . type && TYPE . LONG != gts . type ) { return BOOL_ ; } double [ ] musigma = musigma ( gts , bessel ) ; double mu = musigma [ NUM_ ] ; double sigma = musigma [ NUM_ ] ; if ( NUM_ == sigma ) { return BOOL_ ; } double [ ] bounds = SAXUtils . getBounds ( buckets ) ; int [ ] counts = new int [ bounds . length + NUM_ ] ; for ( int i = NUM_ ; i < gts . values ; i ++ ) { double v = ( ( double ) GTSHelper . valueAtIndex ( gts , i ) - mu ) / sigma ; int insertion = Arrays . binarySearch ( bounds , v ) ; if ( insertion >= NUM_ ) { counts [ insertion ] ++ ; } else { counts [ - ( NUM_ + insertion ) ] ++ ; } } double mean = gts . values / counts . length ; for ( int i = NUM_ ; i < counts . length ; i ++ ) { if ( Math . abs ( NUM_ - ( counts [ i ] / mean ) ) > pcterror ) { return BOOL_ ; } } return BOOL_ ; }
public void loadFromProperties ( Properties properties ) { projected = StringUtil . getBooleanValue ( properties , STR_ , BOOL_ , BOOL_ ) ; tiePoint = StringUtil . getDoubleArray ( properties , STR_ , null , BOOL_ ) ; scale = StringUtil . getDoubleArray ( properties , STR_ , null , BOOL_ ) ; globe = StringUtil . getStringValue ( properties , STR_ , null , BOOL_ ) ; rasterWidth = StringUtil . getIntegerValue ( properties , STR_ , BOOL_ , NUM_ , BOOL_ ) ; rasterLength = StringUtil . getIntegerValue ( properties , STR_ , BOOL_ , NUM_ , BOOL_ ) ; datumCode = StringUtil . getIntegerValue ( properties , STR_ , BOOL_ , NUM_ , BOOL_ ) ; ellipsoidCode = StringUtil . getIntegerValue ( properties , STR_ , BOOL_ , NUM_ , BOOL_ ) ; semiMajorAxis = StringUtil . getDoubleValue ( properties , STR_ , BOOL_ , Double . NaN , BOOL_ ) ; semiMinorAxis = StringUtil . getDoubleValue ( properties , STR_ , BOOL_ , Double . NaN , BOOL_ ) ; inverseFlattening = StringUtil . getDoubleValue ( properties , STR_ , BOOL_ , Double . NaN , BOOL_ ) ; gcsPrimeMeridianLon = StringUtil . getDoubleValue ( properties , STR_ , BOOL_ , Double . NaN , BOOL_ ) ; projCode = StringUtil . getIntegerValue ( properties , STR_ , BOOL_ , NUM_ , BOOL_ ) ; pcsCode = StringUtil . getIntegerValue ( properties , STR_ , BOOL_ , NUM_ , BOOL_ ) ; coordTransformCode = StringUtil . getIntegerValue ( properties , STR_ , BOOL_ , NUM_ , BOOL_ ) ; stdParallel1 = StringUtil . getDoubleValue ( properties , STR_ , BOOL_ , Double . NaN , BOOL_ ) ; poleLat = ( int ) ( Math . signum ( stdParallel1 ) . NUM_ ) ; stdParallel2 = StringUtil . getDoubleValue ( properties , STR_ , BOOL_ , Double . NaN , BOOL_ ) ; naturalOriginLon = StringUtil . getDoubleValue ( properties , STR_ , BOOL_ , Double . NaN , BOOL_ ) ; naturalOriginLat = StringUtil . getDoubleValue ( properties , STR_ , BOOL_ , Double . NaN , BOOL_ ) ; falseOriginLon = StringUtil . getDoubleValue ( properties , STR_ , BOOL_ , Double . NaN , BOOL_ ) ; falseOriginLat = StringUtil . getDoubleValue ( properties , STR_ , BOOL_ , Double . NaN , BOOL_ ) ; falseEasting = StringUtil . getDoubleValue ( properties , STR_ , BOOL_ , Double . NaN , BOOL_ ) ; falseNorthing = StringUtil . getDoubleValue ( properties , STR_ , BOOL_ , Double . NaN , BOOL_ ) ; centerEasting = StringUtil . getDoubleValue ( properties , STR_ , BOOL_ , Double . NaN , BOOL_ ) ; centerNorthing = StringUtil . getDoubleValue ( properties , STR_ , BOOL_ , Double . NaN , BOOL_ ) ; centerLon = StringUtil . getDoubleValue ( properties , STR_ , BOOL_ , Double . NaN , BOOL_ ) ; centerLat = StringUtil . getDoubleValue ( properties , STR_ , BOOL_ , Double . NaN , BOOL_ ) ; scaleAtNaturalOrigin = StringUtil . getDoubleValue ( properties , STR_ , BOOL_ , Double . NaN , BOOL_ ) ; scaleAtCenter = StringUtil . getDoubleValue ( properties , STR_ , BOOL_ , Double . NaN , BOOL_ ) ; azimuth = StringUtil . getDoubleValue ( properties , STR_ , BOOL_ , Double . NaN , BOOL_ ) ; straightVertPoleLon = StringUtil . getDoubleValue ( properties , STR_ , BOOL_ , Double . NaN , BOOL_ ) ; gcsCitation = StringUtil . getStringValue ( properties , STR_ , null , BOOL_ ) ; pcsCitation = StringUtil . getStringValue ( properties , STR_ , null , BOOL_ ) ; projLinearUnits = StringUtil . getStringValue ( properties , STR_ , STR_ , BOOL_ ) ; if ( coordTransformCode == GeoKey . Code_Undefined ) { String citation = ( pcsCitation == null ? STR_ : pcsCitation . toLowerCase ( ) ) ; if ( citation . contains ( STR_ ) && ( citation . contains ( STR_ ) || citation . contains ( STR_ ) || citation . contains ( STR_ ) ) ) { coordTransformCode = GeoKey . Code_CT_Mercator ; if ( Double . isNaN ( naturalOriginLon ) ) naturalOriginLon = NUM_ ; if ( Double . isNaN ( falseEasting ) ) falseEasting = NUM_ ; if ( Double . isNaN ( falseNorthing ) ) falseNorthing = NUM_ ; if ( citation . contains ( STR_ ) && citation . contains ( STR_ ) ) { if ( ! Double . isNaN ( semiMajorAxis ) ) semiMinorAxis = semiMajorAxis ; else { semiMajorAxis = SEMI_MAJOR_AXIS [ NUM_ ] ; semiMinorAxis = SEMI_MINOR_AXIS [ NUM_ ] ; } } } } }
public ShowProgress ( ) { start = last = System . currentTimeMillis ( ) ; }
public static RepositoryExpression parseRepositoryExpression ( String toParse ) throws ParseError { StreamTokenizer t = Parser . tokenize ( toParse ) ; Term creator = Parser . parseTerm ( t ) ; List < Operation > operations = Parser . parseOperationList ( t ) ; RepositoryExpression ex = new RepositoryExpression ( creator ) ; if ( ! operations . isEmpty ( ) ) { throw new ParseError ( STR_ ) ; } return ex ; }
@ Override public synchronized void close ( ) throws IOException { buffer = null ; notifyAll ( ) ; }
public void addSection ( SourceSection section ) { sections . add ( section ) ; }
public static GenomeRelationships load ( BufferedReader reader ) throws IOException { final GenomeRelationships ped = new GenomeRelationships ( ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { line = line . trim ( ) ; if ( line . startsWith ( STR_ ) || line . matches ( STR_ ) ) { continue ; } if ( line . matches ( STR_ ) ) { parseGenomeLine ( ped , line ) ; continue ; } if ( line . matches ( STR_ ) ) { parseRelationshipLine ( ped , line ) ; continue ; } throw new NoTalkbackSlimException ( STR_ + line + STR_ ) ; } return ped ; }
private int [ ] versionParts ( String version ) { String [ ] parts = version . split ( STR_ ) ; int [ ] p = new int [ NUM_ ] ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { int pi ; if ( i < parts . length ) { p [ i ] = Integer . parseInt ( parts [ i ] ) ; } else { p [ i ] = - NUM_ ; } } return p ; }
private FgsRunner . Type computeType ( ) { Object model = getDataModel ( ) ; if ( model == null && getSourceGraph ( ) != null ) { model = getSourceGraph ( ) ; } if ( model == null ) { throw new RuntimeException ( STR_ + STR_ + STR_ + STR_ ) ; } if ( model instanceof Graph ) { type = FgsRunner . Type . GRAPH ; } else if ( model instanceof DataSet ) { DataSet dataSet = ( DataSet ) model ; if ( dataSet . isContinuous ( ) ) { type = FgsRunner . Type . CONTINUOUS ; } else if ( dataSet . isDiscrete ( ) ) { type = FgsRunner . Type . DISCRETE ; } else { throw new IllegalStateException ( STR_ ) ; } } else if ( model instanceof ICovarianceMatrix ) { type = FgsRunner . Type . CONTINUOUS ; } else if ( model instanceof DataModelList ) { DataModelList list = ( DataModelList ) model ; if ( allContinuous ( list ) ) { type = FgsRunner . Type . CONTINUOUS ; } else if ( allDiscrete ( list ) ) { type = FgsRunner . Type . DISCRETE ; } else { throw new IllegalArgumentException ( STR_ ) ; } } return type ; }
public static boolean approxEquals ( final double a , final double b , final double tolerance ) { if ( Double . isNaN ( a ) || Double . isNaN ( b ) ) { return BOOL_ ; } if ( a == b ) { return BOOL_ ; } if ( Double . isInfinite ( a ) || Double . isInfinite ( b ) ) { return BOOL_ ; } if ( a >= ( b - tolerance ) && a <= ( b + tolerance ) ) { return BOOL_ ; } return BOOL_ ; }
public static Map < String , Object > loadJsonModel ( File jsFile ) { try { Map < String , Object > model = JavaScriptResolver . readJsonModel ( jsFile ) ; if ( model == null ) { throw new CompilerErrorException ( STR_ + jsFile . getAbsolutePath ( ) ) ; } if ( ! model . containsKey ( STR_ ) ) { throw new CeylonRunJsException ( STR_ + jsFile + STR_ ) ; } return model ; } catch ( IOException ex ) { throw new CompilerErrorException ( STR_ + jsFile ) ; } }
static String [ ] splitLine ( final String line ) { final int ix0 = line . indexOf ( STR_ ) ; final int ix = ix0 == - NUM_ ? line . length ( ) : ix0 ; final String lessComment = line . substring ( NUM_ , ix ) ; if ( lessComment . matches ( STR_ ) ) { return null ; } return lessComment . split ( STR_ ) ; }
private List < Volume > createVolumeData ( String name , int numVolumes ) { List < Volume > volumes = new ArrayList < Volume > ( ) ; URI cgUri = createBlockConsistencyGroup ( name + STR_ ) ; for ( int i = NUM_ ; i <= numVolumes ; i ++ ) { Volume volume = new Volume ( ) ; URI volumeURI = URIUtil . createId ( Volume . class ) ; testVolumeURIs . add ( volumeURI ) ; volume . setId ( volumeURI ) ; volume . setLabel ( name + i ) ; volume . setConsistencyGroup ( cgUri ) ; _dbClient . createObject ( volume ) ; } return volumes ; }
private static < T > T hashMapToObject ( LinkedHashMap map , Class < T > type ) { try { return stringToObject ( mapper . writeValueAsString ( map ) , type ) ; } catch ( IOException e ) { log . warn ( STR_ + type . getName ( ) + STR_ + map . toString ( ) + STR_ + e . getMessage ( ) ) ; return null ; } }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case NUM_ : return SUCCESS ; default : return null ; } }
private void deleteSMS ( String cmd , String search ) { int nbDeleted = - NUM_ ; if ( cmd . equals ( STR_ ) ) { nbDeleted = mSmsManager . deleteAllSms ( ) ; } else if ( cmd . equals ( STR_ ) ) { nbDeleted = mSmsManager . deleteSentSms ( ) ; } else if ( cmd . startsWith ( STR_ ) ) { Integer number = Tools . parseInt ( search ) ; if ( number == null ) { number = NUM_ ; } if ( cmd . equals ( STR_ ) ) { nbDeleted = mSmsManager . deleteLastSms ( number ) ; } else if ( cmd . equals ( STR_ ) ) { nbDeleted = mSmsManager . deleteLastInSms ( number ) ; } else if ( cmd . equals ( STR_ ) ) { nbDeleted = mSmsManager . deleteLastOutSms ( number ) ; } else { send ( R . string . chat_del_sms_error ) ; } } else if ( cmd . equals ( STR_ ) && search != null ) { ArrayList < Contact > contacts = ContactsManager . getMatchingContacts ( sContext , search ) ; if ( contacts . size ( ) > NUM_ ) { StringBuilder sb = new StringBuilder ( getString ( R . string . chat_specify_details ) ) ; sb . append ( Tools . LineSep ) ; for ( Contact contact : contacts ) { sb . append ( contact . name ) ; sb . append ( Tools . LineSep ) ; } send ( sb . toString ( ) ) ; } else if ( contacts . size ( ) == NUM_ ) { Contact contact = contacts . get ( NUM_ ) ; send ( R . string . chat_del_sms_from , contact . name ) ; nbDeleted = mSmsManager . deleteSmsByContact ( contact . rawIds ) ; } else { send ( R . string . chat_no_match_for , search ) ; } } else if ( cmd . equals ( STR_ ) && search != null ) { send ( R . string . chat_del_sms_from , search ) ; nbDeleted = mSmsManager . deleteSmsByNumber ( search ) ; if ( nbDeleted <= NUM_ ) { send ( R . string . chat_no_match_for , search ) ; } } else { send ( R . string . chat_del_sms_syntax ) ; } if ( nbDeleted >= NUM_ ) { send ( R . string . chat_del_sms_nb , nbDeleted ) ; } else if ( nbDeleted == - NUM_ ) { send ( R . string . chat_del_sms_error ) ; } }
private static BlocksRemoveInfo isStartBlock ( BlockNode remBlock , BlockNode startBlock ) { List < InsnNode > remInsns = remBlock . getInstructions ( ) ; List < InsnNode > startInsns = startBlock . getInstructions ( ) ; if ( remInsns . size ( ) < startInsns . size ( ) ) { return null ; } int startPos = remInsns . size ( ) - startInsns . size ( ) ; int endPos = NUM_ ; if ( ! checkInsns ( remInsns , startInsns , startPos , null ) ) { if ( checkInsns ( remInsns , startInsns , NUM_ , null ) ) { startPos = NUM_ ; endPos = startInsns . size ( ) ; } else { boolean found = BOOL_ ; for ( int i = NUM_ ; i < startPos ; i ++ ) { if ( checkInsns ( remInsns , startInsns , i , null ) ) { startPos = i ; endPos = startInsns . size ( ) + i ; found = BOOL_ ; break ; } } if ( ! found ) { return null ; } } } BlocksPair startPair = new BlocksPair ( remBlock , startBlock ) ; BlocksRemoveInfo removeInfo = new BlocksRemoveInfo ( startPair ) ; removeInfo . setStartSplitIndex ( startPos ) ; removeInfo . setEndSplitIndex ( endPos ) ; if ( endPos != NUM_ ) { removeInfo . setEnd ( startPair ) ; } if ( ! checkInsns ( remInsns , startInsns , startPos , removeInfo ) ) { return null ; } return removeInfo ; }
public boolean checkError ( ) { return pw . checkError ( ) ; }
public List < PdfDocument > splitBySize ( long size ) { List < PageRange > splitRanges = new ArrayList < > ( ) ; int currentPage = NUM_ ; int numOfPages = pdfDocument . getNumberOfPages ( ) ; while ( currentPage <= numOfPages ) { PageRange nextRange = getNextRange ( currentPage , numOfPages , size ) ; splitRanges . add ( nextRange ) ; List < Integer > allPages = nextRange . getAllPages ( ) ; currentPage = ( int ) allPages . get ( allPages . size ( ) - NUM_ ) + NUM_ ; } return extractPageRanges ( splitRanges ) ; }
private boolean validateAuthSchemes ( Set authSchemeSet ) throws PolicyException { if ( authSchemeSet . isEmpty ( ) ) { String args [ ] = { AUTH_SCHEME } ; throw new PolicyException ( ResBundleUtils . rbName , STR_ , args , null ) ; } Iterator authSchemeSetIter = authSchemeSet . iterator ( ) ; authSchemes . clear ( ) ; while ( authSchemeSetIter . hasNext ( ) ) { try { String authScheme = ( String ) authSchemeSetIter . next ( ) ; authSchemes . add ( authScheme ) ; } catch ( ClassCastException e ) { String args [ ] = { AUTH_SCHEME } ; throw new PolicyException ( ResBundleUtils . rbName , STR_ , args , null ) ; } } return BOOL_ ; }
public static UUID fromUUIDAsURNStringToUUID ( String UUIDasURN ) { if ( ! UUIDasURN . startsWith ( UUIDHelper . UUID_as_a_URN_PREFIX ) ) { IMFErrorLogger imfErrorLogger = new IMFErrorLoggerImpl ( ) ; imfErrorLogger . addError ( IMFErrorLogger . IMFErrors . ErrorCodes . UUID_ERROR , IMFErrorLogger . IMFErrors . ErrorLevels . FATAL , String . format ( STR_ + STR_ , UUIDasURN , UUIDHelper . UUID_as_a_URN_PREFIX ) ) ; throw new IMFException ( String . format ( STR_ , UUIDasURN , UUIDHelper . UUID_as_a_URN_PREFIX ) , imfErrorLogger ) ; } return UUID . fromString ( UUIDasURN . split ( UUIDHelper . UUID_as_a_URN_PREFIX ) [ NUM_ ] ) ; }
public String readLine ( ) { String line ; try { line = scanner . nextLine ( ) ; } catch ( NoSuchElementException e ) { line = null ; } return line ; }
public static byte [ ] decode ( final String s ) { return Base64 . decode ( s , Base64 . NO_OPTIONS ) ; }
public static GradientPaint makeRedPaint ( final double width , final double height ) { return new GradientPaint ( NUM_ , NUM_ , new Color ( NUM_ , NUM_ , NUM_ ) , ( float ) width / NUM_ , ( float ) height / NUM_ , new Color ( NUM_ , NUM_ , NUM_ ) , BOOL_ ) ; }
public static List < String > matchNumbers ( String text ) { String pattern = STR_ ; Pattern pat = Pattern . compile ( pattern ) ; Matcher m = pat . matcher ( text ) ; List < String > matches = new ArrayList < String > ( ) ; while ( m . find ( ) ) { matches . add ( m . group ( ) ) ; } return matches ; }
private boolean deleteStorage ( TrackerServer trackerServer , String groupName , String storageIpAddr ) throws IOException { byte [ ] header ; byte [ ] bGroupName ; byte [ ] bs ; int len ; Socket trackerSocket ; trackerSocket = trackerServer . getSocket ( ) ; OutputStream out = trackerSocket . getOutputStream ( ) ; bs = groupName . getBytes ( ClientGlobal . g_charset ) ; bGroupName = new byte [ ProtoCommon . FDFS_GROUP_NAME_MAX_LEN ] ; if ( bs . length <= ProtoCommon . FDFS_GROUP_NAME_MAX_LEN ) { len = bs . length ; } else { len = ProtoCommon . FDFS_GROUP_NAME_MAX_LEN ; } Arrays . fill ( bGroupName , ( byte ) NUM_ ) ; System . arraycopy ( bs , NUM_ , bGroupName , NUM_ , len ) ; int ipAddrLen ; byte [ ] bIpAddr = storageIpAddr . getBytes ( ClientGlobal . g_charset ) ; if ( bIpAddr . length < ProtoCommon . FDFS_IPADDR_SIZE ) { ipAddrLen = bIpAddr . length ; } else { ipAddrLen = ProtoCommon . FDFS_IPADDR_SIZE - NUM_ ; } header = ProtoCommon . packHeader ( ProtoCommon . TRACKER_PROTO_CMD_SERVER_DELETE_STORAGE , ProtoCommon . FDFS_GROUP_NAME_MAX_LEN + ipAddrLen , ( byte ) NUM_ ) ; byte [ ] wholePkg = new byte [ header . length + bGroupName . length + ipAddrLen ] ; System . arraycopy ( header , NUM_ , wholePkg , NUM_ , header . length ) ; System . arraycopy ( bGroupName , NUM_ , wholePkg , header . length , bGroupName . length ) ; System . arraycopy ( bIpAddr , NUM_ , wholePkg , header . length + bGroupName . length , ipAddrLen ) ; out . write ( wholePkg ) ; ProtoCommon . RecvPackageInfo pkgInfo = ProtoCommon . recvPackage ( trackerSocket . getInputStream ( ) , ProtoCommon . TRACKER_PROTO_CMD_RESP , NUM_ ) ; this . errno = pkgInfo . errno ; return pkgInfo . errno == NUM_ ; }
@ Override public UUID createEntryNode ( UUID parentNode ) { UUID uuid = UUID . randomUUID ( ) ; graphServer . addVertex ( uuid ) ; graphServer . addEdge ( uuid , parentNode ) ; return uuid ; }
protected void assertDeliveryStates ( final Collection < CustomerOrderDelivery > deliveries , final Map < String , String > expectedState ) { for ( CustomerOrderDelivery delivery : deliveries ) { assertEquals ( STR_ + delivery . getDeliveryGroup ( ) + STR_ + delivery . getDeliveryNum ( ) , expectedState . get ( delivery . getDeliveryGroup ( ) ) , delivery . getDeliveryStatus ( ) ) ; } }
@ Nullable private CompileScope createFacetsCompileScope ( @ NotNull final CompilerManager compilerManager , @ NotNull final VirtualFile [ ] files ) { final Set < Module > modules = New . set ( ) ; boolean facetsFound = BOOL_ ; for ( final VirtualFile file : files ) { final Module module = ModuleUtilCore . findModuleForFile ( file , project ) ; if ( module != null ) { modules . add ( module ) ; if ( ! facetsFound ) { facetsFound = hasFacets ( module ) ; } } } if ( facetsFound ) { return compilerManager . createModulesCompileScope ( modules . toArray ( Module . EMPTY_ARRAY ) , BOOL_ , BOOL_ ) ; } return null ; }
@ Nullable @ WorkerThread static File writeBitmapToFile ( @ NonNull Bitmap bitmap , @ NonNull File file ) { FileOutputStream fileStream = null ; try { ByteArrayOutputStream byteStream = new ByteArrayOutputStream ( ) ; bitmap . compress ( Bitmap . CompressFormat . PNG , NUM_ , byteStream ) ; fileStream = new FileOutputStream ( file ) ; fileStream . write ( byteStream . toByteArray ( ) ) ; return file ; } catch ( IOException e ) { Log . e ( TAG , e . getMessage ( ) , e ) ; } finally { if ( fileStream != null ) { try { fileStream . close ( ) ; } catch ( IOException e ) { Log . e ( TAG , e . getMessage ( ) , e ) ; } } } return null ; }
public static Sentence parse ( final String text , final ConversationContext ctx ) { String txt ; if ( text == null ) { txt = STR_ ; } else { if ( ( ctx != null ) && ctx . isForMatching ( ) ) { final ExpressionMatcher matcher = new ExpressionMatcher ( ) ; txt = matcher . readMatchingFlags ( text ) ; if ( matcher . isAnyFlagSet ( ) ) { return matcher . parseSentence ( txt , ctx ) ; } } else { txt = text ; } } txt = txt . trim ( ) ; final SentenceImplementation sentence = new SentenceImplementation ( ctx , txt ) ; try { final ConversationParser parser = new ConversationParser ( sentence ) ; sentence . parse ( parser ) ; sentence . classifyWords ( parser ) ; if ( ( ctx != null ) && ctx . getMergeExpressions ( ) ) { sentence . evaluateSentenceType ( ) ; sentence . mergeWords ( ) ; if ( ! ctx . isForMatching ( ) ) { sentence . standardizeSentenceType ( ) ; sentence . performaAliasing ( ) ; } } sentence . setError ( parser . getErrorString ( ) ) ; } catch ( final Exception e ) { LOGGER . error ( STR_ + text + STR_ ) ; sentence . setError ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } return sentence ; }
public ElemTemplateElement replaceChild ( ElemTemplateElement newChildElem , ElemTemplateElement oldChildElem ) { if ( oldChildElem == null || oldChildElem . getParentElem ( ) != this ) return null ; ElemTemplateElement prev = oldChildElem . getPreviousSiblingElem ( ) ; if ( null != prev ) prev . m_nextSibling = newChildElem ; if ( m_firstChild == oldChildElem ) m_firstChild = newChildElem ; newChildElem . m_parentNode = this ; oldChildElem . m_parentNode = null ; newChildElem . m_nextSibling = oldChildElem . m_nextSibling ; oldChildElem . m_nextSibling = null ; return newChildElem ; }
protected int hash ( Object key1 , Object key2 , Object key3 ) { int h = NUM_ ; if ( key1 != null ) { h ^= key1 . hashCode ( ) ; } if ( key2 != null ) { h ^= key2 . hashCode ( ) ; } if ( key3 != null ) { h ^= key3 . hashCode ( ) ; } h += ~ ( h << NUM_ ) ; h ^= ( h > > > NUM_ ) ; h += ( h << NUM_ ) ; h ^= ( h > > > NUM_ ) ; return h ; }
public void flush ( ) throws IOException { flushBuffer ( ) ; _outputStream . flush ( ) ; }
private void writeAttribute ( java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( namespace . equals ( STR_ ) ) { xmlWriter . writeAttribute ( attName , attValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } }
private void addEntryToInfoList ( Entry entry , List < EntryInfo > entryInfoList ) { if ( entryInfoList != null ) { String typeToAdd = entry . getType ( ) ; if ( typeToAdd . equals ( DbLogic . Constants . quotation ) ) { typeToAdd = DbLogic . Constants . note ; } entryInfoList . add ( new EntryInfo ( entry . getId ( ) , entry . getNoteOrTitle ( STR_ ) , entry . getQuotation ( STR_ ) , entry . getIsPublic ( ) , entry . hasFirstChildId ( ) , entry . hasParentId ( ) , typeToAdd ) ) ; } }
private void updateSliding ( float newPositionNormalized ) { currentSlide = newPositionNormalized ; state = currentSlide == NUM_ ? EXPANDED : currentSlide == NUM_ ? COLLAPSED : SLIDING ; float slideY = Math . abs ( ( currentSlide . maxSlide ) - maxSlide ) ; slidableView . setY ( slideY ) ; invalidate ( ) ; notifyListeners ( currentSlide ) ; }
void flush ( VcfWriter writer ) throws IOException { if ( mPrevRecord != null ) { if ( ! mPrevDense ) { writeCount ( writer , mPrevRecord ) ; } else { mVcfFilterStatistics . increment ( Stat . DENSITY_WINDOW_COUNT ) ; } } mPrevRecord = null ; mPrevDense = BOOL_ ; }
public VideoStream ( String streamStr ) { String [ ] args = streamStr . split ( STR_ ) ; Map < String , String > argMap = new HashMap < String , String > ( ) ; for ( String arg : args ) { String [ ] argsValues = arg . split ( STR_ ) ; if ( argsValues != null ) { if ( argsValues . length >= NUM_ ) { argMap . put ( argsValues [ NUM_ ] , argsValues [ NUM_ ] ) ; } } } mUrl = argMap . get ( STR_ ) ; }
public boolean equals ( String str ) { if ( str == null ) return BOOL_ ; if ( _length != str . length ( ) ) return BOOL_ ; for ( int i = _length , j = _offset + _length ; -- i >= NUM_ ; ) { if ( _array [ -- j ] != str . charAt ( i ) ) return BOOL_ ; } return BOOL_ ; }
protected void flush ( ) { stream . flush ( ) ; }
private ServerStarter startServers ( ) throws Exception { ServerStarter srvStarter = new ServerStarter ( ) ; Thread t = new Thread ( srvStarter ) ; t . setDaemon ( BOOL_ ) ; t . setName ( STR_ ) ; t . start ( ) ; srvStarter . waitForServerStart ( ) ; return srvStarter ; }
public Pagination evaluate ( final Class entityClass ) { Paginate paginate = entityClass != null ? ( Paginate ) entityClass . getAnnotation ( Paginate . class ) : null ; int defaultLimit = paginate != null ? paginate . defaultLimit ( ) : DEFAULT_PAGE_LIMIT ; int maxLimit = paginate != null ? paginate . maxLimit ( ) : MAX_PAGE_LIMIT ; evaluate ( defaultLimit , maxLimit ) ; generateTotals = generateTotals && ( paginate == null || paginate . countable ( ) ) ; return this ; }
public RuntimeCollector ( Algorithm algorithm , int frequency , ResultFileWriter writer ) { super ( algorithm , frequency , FrequencyType . EVALUATIONS ) ; this . writer = writer ; startTime = System . nanoTime ( ) ; }
public boolean deregisterServiceProvider ( Object provider ) { Object oprovider = map . get ( provider . getClass ( ) ) ; if ( provider == oprovider ) { map . remove ( provider . getClass ( ) ) ; poset . remove ( provider ) ; if ( provider instanceof RegisterableService ) { RegisterableService rs = ( RegisterableService ) provider ; rs . onDeregistration ( registry , category ) ; } return BOOL_ ; } return BOOL_ ; }
public NewestFirstComparator ( Date now ) { Preconditions . checkNotNull ( now ) ; mNow = new Date ( now . getTime ( ) + MILLIS_IN_DAY ) ; }
protected void update ( Comparable x , Object y ) { int index = indexOf ( x ) ; if ( index < NUM_ ) { throw new SeriesException ( STR_ + x ) ; } else { ComparableObjectItem item = getDataItem ( index ) ; item . setObject ( y ) ; fireSeriesChanged ( ) ; } }
public void writeField ( String name , float value ) throws java . io . IOException { writeField ( name , Float . toString ( value ) ) ; }
public byte [ ] decodeData ( byte [ ] data , int numErrorCorrectionBytes ) throws ReedSolomonException , DataTooLargeException { if ( data == null || data . length == NUM_ ) { return null ; } if ( data . length > NUM_ ) { throw new DataTooLargeException ( STR_ ) ; } int [ ] dataInts = new int [ data . length ] ; for ( int i = NUM_ ; i < data . length ; i ++ ) { dataInts [ i ] = data [ i ] & xFF ; } int totalBytes = data . length - numErrorCorrectionBytes ; decoder . decode ( dataInts , numErrorCorrectionBytes ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; for ( int i = NUM_ ; i < totalBytes && i < dataInts . length ; i ++ ) { bos . write ( dataInts [ i ] ) ; } return bos . toByteArray ( ) ; }
public static ArrayList < String > stringToArrayList ( String string ) { return new ArrayList < > ( Arrays . asList ( string . split ( STR_ ) ) ) ; }
public Shape createScrollButtonApart ( int x , int y , int w , int h ) { path . reset ( ) ; path . moveTo ( x , y ) ; path . lineTo ( x , y + h ) ; path . lineTo ( x + w , y + h ) ; addScrollGapPath ( x , y , w , h , BOOL_ ) ; path . closePath ( ) ; return path ; }
void removeAllViewsFromAdapter ( ViewPager pager ) { mViews . clear ( ) ; pager . removeAllViews ( ) ; mIsViewPagerInIntentionallyInconsistentState = BOOL_ ; }
public static boolean isValidMobile ( @ NonNull String mobile ) { if ( ! TextUtils . isEmpty ( mobile ) && mobile . length ( ) == NUM_ ) { if ( mobile . startsWith ( STR_ ) || mobile . startsWith ( STR_ ) || mobile . startsWith ( STR_ ) ) { return BOOL_ ; } } return BOOL_ ; }
public String convertError ( String filename , int line , int column , String message ) { String srcFilename = null ; int destLine = NUM_ ; int srcLine = NUM_ ; for ( int i = NUM_ ; i < _lines . size ( ) ; i ++ ) { Line map = _lines . get ( i ) ; if ( filename != null && ! filename . endsWith ( _dstFilename ) ) { } else if ( map . _dstLine <= line && line <= map . getLastDestinationLine ( ) ) { srcFilename = map . _srcFilename ; srcLine = map . getSourceLine ( line ) ; } } if ( srcFilename != null ) return srcFilename + STR_ + srcLine + STR_ + message ; else return filename + STR_ + line + STR_ + message ; }
public static Number sinh ( Number a ) { return Math . sinh ( a . doubleValue ( ) ) ; }
public void addNotification ( @ NotNull Notification notification ) { NotificationItem item = new NotificationItem ( resources , notification , delegate , panel ) ; notificationWidget . add ( notification ) ; }
protected boolean isAttributesModified ( ) { if ( attributes != null ) { return ( attributes . isEmpty ( ) ) ? BOOL_ : BOOL_ ; } return BOOL_ ; }
public IOUtils ( ) { super ( ) ; }
@ Nullable public static IgnoreDescriptor forMethod ( Class cls , Method mthd ) { if ( mthd . isAnnotationPresent ( IgniteIgnore . class ) ) { IgniteIgnore ignore = mthd . getAnnotation ( IgniteIgnore . class ) ; String reason = ignore . value ( ) ; if ( F . isEmpty ( reason ) ) throw new IllegalArgumentException ( STR_ + cls . getName ( ) + STR_ + mthd . getName ( ) + STR_ ) ; return new IgnoreDescriptor ( reason , ignore . forceFailure ( ) ) ; } else return null ; }
protected void runFullImport ( String dataConfig , Map < String , String > extraParams ) throws Exception { HashMap < String , String > params = new HashMap < > ( ) ; params . put ( STR_ , STR_ ) ; params . put ( STR_ , STR_ ) ; params . put ( STR_ , dataConfig ) ; params . put ( STR_ , STR_ ) ; params . put ( STR_ , STR_ ) ; params . putAll ( extraParams ) ; NamedList l = new NamedList ( ) ; for ( Map . Entry < String , String > e : params . entrySet ( ) ) { l . add ( e . getKey ( ) , e . getValue ( ) ) ; } LocalSolrQueryRequest request = new LocalSolrQueryRequest ( h . getCore ( ) , l ) ; h . query ( STR_ , request ) ; }
public static ModifiableDBIDs randomSample ( DBIDs source , int k , Random random ) { if ( k < NUM_ || k > source . size ( ) ) { throw new IllegalArgumentException ( STR_ + k + STR_ + source . size ( ) + STR_ ) ; } if ( random == null ) { random = new FastNonThreadsafeRandom ( ) ; } if ( k < source . size ( ) > > NUM_ ) { ArrayDBIDs aids = DBIDUtil . ensureArray ( source ) ; DBIDArrayIter iter = aids . iter ( ) ; HashSetModifiableDBIDs sample = DBIDUtil . newHashSet ( k ) ; while ( sample . size ( ) < k ) { iter . seek ( random . nextInt ( aids . size ( ) ) ) ; sample . add ( iter ) ; } return sample ; } else { ArrayModifiableDBIDs sample = DBIDUtil . newArray ( source ) ; randomShuffle ( sample , random , k ) ; for ( int i = sample . size ( ) - NUM_ ; i >= k ; i -- ) { sample . remove ( i ) ; } return sample ; } }
protected int drawMessageSize ( ) { int sizeDiff = sizeRange [ NUM_ ] == sizeRange [ NUM_ ] ? NUM_ : rng . nextInt ( sizeRange [ NUM_ ] - sizeRange [ NUM_ ] ) ; return sizeRange [ NUM_ ] + sizeDiff ; }
public static String [ ] grabArgs ( String signature ) { Matcher matcher = sigRE . matcher ( signature ) ; boolean b = matcher . matches ( ) ; if ( ! b && matcher . groupCount ( ) != NUM_ ) logger . error ( STR_ , signature ) ; String args = matcher . group ( NUM_ ) ; if ( args . isEmpty ( ) ) return new String [ NUM_ ] ; return args . split ( STR_ ) ; }
public void removeSwipeListener ( SwipeListener listener ) { if ( mListeners == null ) { return ; } mListeners . remove ( listener ) ; }
public void test_engineCreateSSLEngine_01 ( ) { SSLContextSpiImpl ssl = new SSLContextSpiImpl ( ) ; try { SSLEngine sleng = ssl . engineCreateSSLEngine ( ) ; fail ( STR_ ) ; } catch ( RuntimeException re ) { String str = re . getMessage ( ) ; if ( ! str . equals ( STR_ ) ) fail ( STR_ + str ) ; } catch ( Exception e ) { fail ( STR_ + e + STR_ ) ; } }
public void processDispatch ( UniformPair < EventBean [ ] > events ) { if ( ! forClauseDelivery ) { dispatchInternal ( events ) ; return ; } if ( ( groupDeliveryExpressions == null ) || ( groupDeliveryExpressions . length == NUM_ ) ) { UniformPair < EventBean [ ] > todeliver = new UniformPair < EventBean [ ] > ( null , null ) ; if ( events != null ) { if ( events . getFirst ( ) != null ) { for ( EventBean theEvent : events . getFirst ( ) ) { todeliver . setFirst ( new EventBean [ ] { theEvent } ) ; dispatchInternal ( todeliver ) ; } todeliver . setFirst ( null ) ; } if ( events . getSecond ( ) != null ) { for ( EventBean theEvent : events . getSecond ( ) ) { todeliver . setSecond ( new EventBean [ ] { theEvent } ) ; dispatchInternal ( todeliver ) ; } todeliver . setSecond ( null ) ; } } return ; } Map < Object , UniformPair < EventBean [ ] > > groups ; try { groups = getGroupedResults ( events ) ; } catch ( RuntimeException ex ) { log . error ( STR_ + ex . getMessage ( ) + STR_ , ex ) ; dispatchInternal ( events ) ; return ; } for ( Map . Entry < Object , UniformPair < EventBean [ ] > > group : groups . entrySet ( ) ) { dispatchInternal ( group . getValue ( ) ) ; } }
public V put ( K key , V value ) { final int hash ; int index ; if ( key == null ) { hash = NUM_ ; index = indexOfNull ( ) ; } else { hash = key . hashCode ( ) ; index = indexOf ( key , hash ) ; } if ( index >= NUM_ ) { index = ( index << NUM_ ) + NUM_ ; final V old = ( V ) mArray [ index ] ; mArray [ index ] = value ; return old ; } index = ~ index ; if ( mSize >= mHashes . length ) { final int n = mSize >= ( BASE_SIZE . NUM_ ) ? ( mSize + ( mSize > > NUM_ ) ) : ( mSize >= BASE_SIZE ? ( BASE_SIZE . NUM_ ) : BASE_SIZE ) ; final int [ ] ohashes = mHashes ; final Object [ ] oarray = mArray ; allocArrays ( n ) ; if ( mHashes . length > NUM_ ) { System . arraycopy ( ohashes , NUM_ , mHashes , NUM_ , ohashes . length ) ; System . arraycopy ( oarray , NUM_ , mArray , NUM_ , oarray . length ) ; } freeArrays ( ohashes , oarray , mSize ) ; } if ( index < mSize ) { System . arraycopy ( mHashes , index , mHashes , index + NUM_ , mSize - index ) ; System . arraycopy ( mArray , index << NUM_ , mArray , ( index + NUM_ ) << NUM_ , ( mSize - index ) << NUM_ ) ; } mHashes [ index ] = hash ; mArray [ index << NUM_ ] = key ; mArray [ ( index << NUM_ ) + NUM_ ] = value ; mSize ++ ; return null ; }
protected void reset ( ) { Arrays . fill ( m_isCandidate , BOOL_ ) ; }
protected void redefine ( int nodetype , String namespace , String localName ) { this . nodetype = nodetype ; this . namespace = namespace ; this . localName = localName ; this . hash = nodetype + namespace . hashCode ( ) + localName . hashCode ( ) ; }
public void putLong ( long pos , long val ) { unsafe . putLong ( pos + addr , val ) ; }
public void lineTo ( float x , float y ) { mPoints . add ( PathPoint . lineTo ( x , y ) ) ; }
public boolean deleteRSetStep ( URI rpSystemId , List < URI > volumeIds , String token ) throws InternalException { List < String > replicationSetNames = new ArrayList < String > ( ) ; try { List < RecoverPointVolumeProtectionInfo > volumeProtectionInfoList = new ArrayList < RecoverPointVolumeProtectionInfo > ( ) ; ProtectionSystem rpSystem = _dbClient . queryObject ( ProtectionSystem . class , rpSystemId ) ; RecoverPointClient rp = RPHelper . getRecoverPointClient ( rpSystem ) ; for ( URI volumeId : volumeIds ) { Volume volume = _dbClient . queryObject ( Volume . class , volumeId ) ; RecoverPointVolumeProtectionInfo volumeProtectionInfo = rp . getProtectionInfoForVolume ( RPHelper . getRPWWn ( volume . getId ( ) , _dbClient ) ) ; Volume sourceVolume = RPHelper . getRPSourceVolume ( _dbClient , volume ) ; VirtualPool virtualPool = _dbClient . queryObject ( VirtualPool . class , sourceVolume . getVirtualPool ( ) ) ; volumeProtectionInfo . setMetroPoint ( VirtualPool . vPoolSpecifiesMetroPoint ( virtualPool ) ) ; volumeProtectionInfoList . add ( volumeProtectionInfo ) ; replicationSetNames . add ( volume . getRSetName ( ) ) ; } if ( ! volumeProtectionInfoList . isEmpty ( ) ) { rp . deleteReplicationSets ( volumeProtectionInfoList ) ; } WorkflowStepCompleter . stepSucceded ( token ) ; } catch ( Exception e ) { _log . error ( String . format ( STR_ , replicationSetNames . toString ( ) ) ) ; return stepFailed ( token , e , STR_ ) ; } return BOOL_ ; }
private void moveToNext ( ) { checkMainThread ( ) ; scheduled . set ( BOOL_ ) ; Bitmap next = pending . poll ( ) ; if ( next != null ) { if ( current != null && ! finished . offer ( current ) ) throw new RuntimeException ( STR_ ) ; current = next ; invalidateSelf ( ) ; ensureScheduled ( ) ; frameAvailableSubject . onNext ( null ) ; fpsCounter . update ( ) ; } }
public void addChangingListener ( OnWheelChangedListener listener ) { changingListeners . add ( listener ) ; }
public String rma ( Properties ctx , int WindowNo , GridTab mTab , GridField mField , Object value ) { Integer M_RMA_ID = ( Integer ) value ; if ( M_RMA_ID == null || M_RMA_ID . intValue ( ) == NUM_ ) return STR_ ; if ( isCalloutActive ( ) ) return STR_ ; MRMA rma = new MRMA ( ctx , M_RMA_ID . intValue ( ) , null ) ; MInOut originalReceipt = rma . getShipment ( ) ; if ( rma . get_ID ( ) != NUM_ ) { mTab . setValue ( STR_ , originalReceipt . getDateOrdered ( ) ) ; mTab . setValue ( STR_ , originalReceipt . getPOReference ( ) ) ; mTab . setValue ( STR_ , new Integer ( originalReceipt . getAD_Org_ID ( ) ) ) ; mTab . setValue ( STR_ , new Integer ( originalReceipt . getAD_OrgTrx_ID ( ) ) ) ; mTab . setValue ( STR_ , new Integer ( originalReceipt . getC_Activity_ID ( ) ) ) ; mTab . setValue ( STR_ , new Integer ( originalReceipt . getC_Campaign_ID ( ) ) ) ; mTab . setValue ( STR_ , new Integer ( originalReceipt . getC_Project_ID ( ) ) ) ; mTab . setValue ( STR_ , new Integer ( originalReceipt . getUser1_ID ( ) ) ) ; mTab . setValue ( STR_ , new Integer ( originalReceipt . getUser2_ID ( ) ) ) ; mTab . setValue ( STR_ , new Integer ( originalReceipt . getM_Warehouse_ID ( ) ) ) ; mTab . setValue ( STR_ , originalReceipt . getDeliveryRule ( ) ) ; mTab . setValue ( STR_ , originalReceipt . getDeliveryViaRule ( ) ) ; mTab . setValue ( STR_ , new Integer ( originalReceipt . getM_Shipper_ID ( ) ) ) ; mTab . setValue ( STR_ , originalReceipt . getFreightCostRule ( ) ) ; mTab . setValue ( STR_ , originalReceipt . getFreightAmt ( ) ) ; mTab . setValue ( STR_ , new Integer ( originalReceipt . getC_BPartner_ID ( ) ) ) ; mTab . setValue ( STR_ , new Integer ( originalReceipt . getC_BPartner_Location_ID ( ) ) ) ; if ( originalReceipt . getAD_User_ID ( ) > NUM_ ) mTab . setValue ( STR_ , new Integer ( originalReceipt . getAD_User_ID ( ) ) ) ; else mTab . setValue ( STR_ , null ) ; } return STR_ ; }
public final long readLong ( ) throws java . io . IOException { readFully ( scratch , NUM_ , NUM_ ) ; int h = ( ( scratch [ NUM_ ] & xff ) << NUM_ ) | ( ( scratch [ NUM_ ] & xff ) << NUM_ ) | ( ( scratch [ NUM_ ] & xff ) << NUM_ ) | ( ( scratch [ NUM_ ] & xff ) << NUM_ ) ; int l = ( ( scratch [ NUM_ ] & xff ) << NUM_ ) | ( ( scratch [ NUM_ ] & xff ) << NUM_ ) | ( ( scratch [ NUM_ ] & xff ) << NUM_ ) | ( ( scratch [ NUM_ ] & xff ) << NUM_ ) ; return ( ( ( long ) h ) << NUM_ ) | ( ( long ) l ) & xffffffffL ; }
public void testGetColumnsMetaData ( ) throws Exception { DatabaseMetaData dmd = con . getMetaData ( ) ; ResultSet rs = dmd . getColumns ( null , null , STR_ , null ) ; assertNotNull ( rs ) ; ResultSetMetaData rsmd = rs . getMetaData ( ) ; assertNotNull ( rsmd . getCatalogName ( NUM_ ) ) ; assertNotNull ( rsmd . getColumnClassName ( NUM_ ) ) ; rsmd . getColumnCount ( ) ; assertTrue ( NUM_ != rsmd . getColumnDisplaySize ( NUM_ ) ) ; assertNotNull ( rsmd . getColumnLabel ( NUM_ ) ) ; assertNotNull ( rsmd . getColumnName ( NUM_ ) ) ; rsmd . getColumnType ( NUM_ ) ; assertNotNull ( rsmd . getColumnTypeName ( NUM_ ) ) ; rsmd . getPrecision ( NUM_ ) ; rsmd . getScale ( NUM_ ) ; assertNotNull ( rsmd . getSchemaName ( NUM_ ) ) ; assertNotNull ( rsmd . getTableName ( NUM_ ) ) ; rsmd . isAutoIncrement ( NUM_ ) ; rsmd . isCaseSensitive ( NUM_ ) ; rsmd . isCurrency ( NUM_ ) ; rsmd . isDefinitelyWritable ( NUM_ ) ; rsmd . isNullable ( NUM_ ) ; rsmd . isReadOnly ( NUM_ ) ; rsmd . isSearchable ( NUM_ ) ; rsmd . isSigned ( NUM_ ) ; rsmd . isWritable ( NUM_ ) ; rs . close ( ) ; }
private Log discoverLogImplementation ( String logCategory ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( STR_ ) ; } initConfiguration ( ) ; Log result = null ; String specifiedLogClassName = findUserSpecifiedLogClassName ( ) ; if ( specifiedLogClassName != null ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( STR_ + specifiedLogClassName + STR_ ) ; } result = createLogFromClass ( specifiedLogClassName , logCategory , BOOL_ ) ; if ( result == null ) { StringBuffer messageBuffer = new StringBuffer ( STR_ ) ; messageBuffer . append ( specifiedLogClassName ) ; messageBuffer . append ( STR_ ) ; if ( specifiedLogClassName != null ) { informUponSimilarName ( messageBuffer , specifiedLogClassName , LOGGING_IMPL_LOG4J_LOGGER ) ; informUponSimilarName ( messageBuffer , specifiedLogClassName , LOGGING_IMPL_JDK14_LOGGER ) ; informUponSimilarName ( messageBuffer , specifiedLogClassName , LOGGING_IMPL_LUMBERJACK_LOGGER ) ; informUponSimilarName ( messageBuffer , specifiedLogClassName , LOGGING_IMPL_SIMPLE_LOGGER ) ; } throw new LogConfigurationException ( messageBuffer . toString ( ) ) ; } return result ; } if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( STR_ + STR_ ) ; } for ( int i = NUM_ ; ( i < classesToDiscover . length ) && ( result == null ) ; ++ i ) { result = createLogFromClass ( classesToDiscover [ i ] , logCategory , BOOL_ ) ; } if ( result == null ) { throw new LogConfigurationException ( STR_ ) ; } return result ; }
public NSData ( File file ) throws IOException { bytes = new byte [ ( int ) file . length ( ) ] ; RandomAccessFile raf = new RandomAccessFile ( file , STR_ ) ; raf . read ( bytes ) ; raf . close ( ) ; }
public ViaHeader createViaHeader ( String host , int port , String transport , String branch ) throws ParseException , InvalidArgumentException { if ( host == null || transport == null ) throw new NullPointerException ( STR_ ) ; Via via = new Via ( ) ; if ( branch != null ) via . setBranch ( branch ) ; if ( host . indexOf ( STR_ ) >= NUM_ && host . indexOf ( STR_ ) < NUM_ ) { if ( stripAddressScopeZones ) { int zoneStart = host . indexOf ( STR_ ) ; if ( zoneStart != - NUM_ ) host = host . substring ( NUM_ , zoneStart ) ; } host = STR_ + host + STR_ ; } via . setHost ( host ) ; via . setPort ( port ) ; via . setTransport ( transport ) ; return via ; }
public String toString ( ) { return super . toString ( ) + STR_ + recordMap . size ( ) + STR_ + firstOffset + STR_ + releaseBuffer + STR_ + prefixWrites + STR_ + useChecksum + STR_ + bytesWritten ( ) + STR_ + remaining ( ) + STR_ + m_removed + STR_ ; }
public void dispose ( ) { logDebug ( STR_ ) ; mSetupDone = BOOL_ ; if ( mServiceConn != null ) { logDebug ( STR_ ) ; if ( mContext != null ) mContext . unbindService ( mServiceConn ) ; } mDisposed = BOOL_ ; mContext = null ; mServiceConn = null ; mService = null ; mPurchaseListener = null ; }
public int find ( String string ) { if ( string == null ) { return - NUM_ ; } for ( int i = NUM_ ; i != m_stringOffsets . length ; ++ i ) { int offset = m_stringOffsets [ i ] ; int length = getShort ( m_strings , offset ) ; if ( length != string . length ( ) ) { continue ; } int j = NUM_ ; for ( ; j != length ; ++ j ) { offset += NUM_ ; if ( string . charAt ( j ) != getShort ( m_strings , offset ) ) { break ; } } if ( j == length ) { return i ; } } return - NUM_ ; }
private void handleJsonCreateAccount ( RequestAndResponse requestAndResponse ) throws IOException , ServletException { requestAndResponse . setResponseContentTypeJson ( ) ; String userName , password , password2 , email ; boolean mayContact = BOOL_ ; String csrft ; try { final JsonNodeHelper json = getJsonNode ( requestAndResponse ) ; userName = json . getString ( STR_ ) ; password = json . getString ( STR_ ) ; password2 = json . getString ( STR_ ) ; email = json . getString ( STR_ ) ; mayContact = json . getBoolean ( STR_ ) ; csrft = json . getString ( STR_ ) ; } catch ( final IOException e ) { returnJson400 ( requestAndResponse , servletText . errorJson ( ) ) ; return ; } if ( userName != null ) { userName = userName . toLowerCase ( ) ; } if ( isTheCsrftWrong ( requestAndResponse , csrft ) ) { returnJson400 ( requestAndResponse , servletText . errorWrongCsrft ( ) ) ; return ; } if ( ! allowSelfSignUp ) { returnJson400 ( requestAndResponse , servletText . errorSelfSignUpNotAllowed ( ) ) ; return ; } if ( userName == null || userName . isEmpty ( ) ) { returnJson400 ( requestAndResponse , servletText . errorUsernameMustNotBeBlank ( ) ) ; return ; } if ( password == null || password . isEmpty ( ) ) { returnJson400 ( requestAndResponse , servletText . errorFirstPasswordMustBeSet ( BOOL_ , null ) ) ; return ; } if ( password == null || password2 . isEmpty ( ) ) { returnJson400 ( requestAndResponse , servletText . errorSecondPasswordMustBeSet ( BOOL_ , null ) ) ; return ; } if ( ! password2 . equals ( password ) ) { returnJson400 ( requestAndResponse , servletText . errorPasswordsMustMatch ( ) ) ; return ; } if ( ! AccountAttributeValidator . isUserNameValid ( userName ) ) { returnJson400 ( requestAndResponse , servletText . errorUserNameIsNotValid ( ) ) ; return ; } if ( ! AccountAttributeValidator . isPasswordValid ( password ) ) { returnJson400 ( requestAndResponse , servletText . errorPasswordIsNotValid ( ) ) ; return ; } if ( email != null && email . isEmpty ( ) ) { email = null ; } if ( email != null && ! AccountAttributeValidator . isEmailValid ( email ) ) { returnJson400 ( requestAndResponse , servletText . errorEmailIsNotValid ( ) ) ; return ; } try { User user = dbLogic . getUserByUserName ( userName ) ; if ( user != null ) { returnJson400 ( requestAndResponse , servletText . errorUserNameIsAlreadyTaken ( ) ) ; return ; } user = dbLogic . createUser ( userName ) ; if ( user == null ) { returnJson400 ( requestAndResponse , servletText . errorCouldNotCreateAccount ( ) ) ; return ; } user . setPassword ( DigestUtils . sha1Hex ( password ) ) ; user . setEmail ( email ) ; user . setMayContact ( mayContact ) ; mapSessionToUser ( requestAndResponse , user . getId ( ) ) ; dbLogic . commit ( ) ; returnJson200 ( requestAndResponse ) ; } catch ( final PersistenceException e ) { logger . log ( Level . INFO , STR_ , e ) ; returnJson500 ( requestAndResponse , servletText . errorInternalDatabase ( ) ) ; } }
private Object [ ] resolveParameters ( Executable executable , Optional < Object > target , Object outerInstance , ExtensionContext extensionContext , ExtensionRegistry extensionRegistry ) { Preconditions . notNull ( target , STR_ ) ; Parameter [ ] parameters = executable . getParameters ( ) ; Object [ ] values = new Object [ parameters . length ] ; int start = NUM_ ; if ( outerInstance != null ) { values [ NUM_ ] = outerInstance ; start = NUM_ ; } for ( int i = start ; i < parameters . length ; i ++ ) { ParameterContext parameterContext = new DefaultParameterContext ( parameters [ i ] , i , target ) ; values [ i ] = resolveParameter ( parameterContext , executable , extensionContext , extensionRegistry ) ; } return values ; }
public static boolean isValidNameChar ( char c ) { return isValidNameStartChar ( c ) || ( c >= STR_ && c <= STR_ ) ; }
public void supportTlsIntolerantServer ( SSLSocket socket ) { socket . setEnabledProtocols ( new String [ ] { STR_ } ) ; }
protected static boolean id_start_char ( int ch ) { return ( ch >= STR_ && ch <= STR_ ) || ( ch >= STR_ && ch <= STR_ ) || ( ch == STR_ ) ; }
public int hashCode ( ) { int fhash = ( family != null ) ? family . hashCode ( ) : NUM_ ; return fhash ^ style ^ size ; }
private CommandHandlerEnum ( final Command command1 ) { this . command = command1 ; }
public static boolean isFloat ( String desc ) { return desc . endsWith ( STR_ ) ; }
public void componentResized ( ComponentEvent e ) { JScrollBar bar = getVerticalScrollBar ( ) ; int incr = ( int ) ( getSize ( ) . getHeight ( ) - ( bar . getUnitIncrement ( NUM_ ) . NUM_ ) ) ; getVerticalScrollBar ( ) . setBlockIncrement ( incr ) ; }
public Arg ( String aName , String desc , int expectedNumberOfArguments , boolean expectDashedArguments ) { name = aName ; description = desc ; numExpectedValues = expectedNumberOfArguments ; c = name . charAt ( NUM_ ) ; dashedArguments = expectDashedArguments ; }
private boolean remove ( Object o , Object [ ] snapshot , int index ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { Object [ ] current = getArray ( ) ; int len = current . length ; if ( snapshot != current ) findIndex : { int prefix = Math . min ( index , len ) ; for ( int i = NUM_ ; i < prefix ; i ++ ) { if ( current [ i ] != snapshot [ i ] && eq ( o , current [ i ] ) ) { index = i ; break findIndex ; } } if ( index >= len ) return BOOL_ ; if ( current [ index ] == o ) break findIndex ; index = indexOf ( o , current , index , len ) ; if ( index < NUM_ ) return BOOL_ ; } Object [ ] newElements = new Object [ len - NUM_ ] ; System . arraycopy ( current , NUM_ , newElements , NUM_ , index ) ; System . arraycopy ( current , index + NUM_ , newElements , index , len - index - NUM_ ) ; setArray ( newElements ) ; return BOOL_ ; } finally { lock . unlock ( ) ; } }
public void removeModel ( Model model ) { models . remove ( model ) ; }
public void readMap ( int map_Number ) { InputStream map_file ; try { map_file = new FileInputStream ( STR_ + map_Number + STR_ ) ; try { byte [ ] data = new byte [ map_file . available ( ) ] ; map_file . read ( data ) ; map_file . close ( ) ; String load_data = new String ( data , STR_ ) ; makeMap ( load_data ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } catch ( FileNotFoundException e1 ) { e1 . printStackTrace ( ) ; } }
public static double hoeffdingLn ( double trials , double observed , double prob ) { return - NUM_ . Math . pow ( trials . prob - observed , NUM_ ) / trials ; }
private void translateMatrixAfterRotate ( int axis , float trans , float prevImageSize , float imageSize , int prevViewSize , int viewSize , int drawableSize ) { if ( imageSize < viewSize ) { m [ axis ] = ( viewSize - ( drawableSize . m [ Matrix . MSCALE_X ] ) ) . NUM_ ; } else if ( trans > NUM_ ) { m [ axis ] = - ( ( imageSize - viewSize ) . NUM_ ) ; } else { float percentage = ( Math . abs ( trans ) + ( NUM_ . prevViewSize ) ) / prevImageSize ; m [ axis ] = - ( ( percentage . imageSize ) - ( viewSize . NUM_ ) ) ; } }
public void run ( ) { RandomAccessFile reader = null ; try { long last = NUM_ ; long position = NUM_ ; while ( run && reader == null ) { try { reader = new RandomAccessFile ( file , RAF_MODE ) ; } catch ( FileNotFoundException e ) { listener . fileNotFound ( ) ; } if ( reader == null ) { try { Thread . sleep ( delayMillis ) ; } catch ( InterruptedException e ) { } } else { position = end ? file . length ( ) : NUM_ ; last = System . currentTimeMillis ( ) ; reader . seek ( position ) ; } } while ( run ) { boolean newer = FileUtils . isFileNewer ( file , last ) ; long length = file . length ( ) ; if ( length < position ) { listener . fileRotated ( ) ; try { RandomAccessFile save = reader ; reader = new RandomAccessFile ( file , RAF_MODE ) ; position = NUM_ ; IOUtils . closeQuietly ( save ) ; } catch ( FileNotFoundException e ) { listener . fileNotFound ( ) ; } continue ; } else { if ( length > position ) { position = readLines ( reader ) ; last = System . currentTimeMillis ( ) ; } else if ( newer ) { position = NUM_ ; reader . seek ( position ) ; position = readLines ( reader ) ; last = System . currentTimeMillis ( ) ; } } if ( reOpen ) { IOUtils . closeQuietly ( reader ) ; } try { Thread . sleep ( delayMillis ) ; } catch ( InterruptedException e ) { } if ( run && reOpen ) { reader = new RandomAccessFile ( file , RAF_MODE ) ; reader . seek ( position ) ; } } } catch ( Exception e ) { listener . handle ( e ) ; } finally { IOUtils . closeQuietly ( reader ) ; } }
@ Override public void onNestedPreScroll ( View target , int dx , int dy , int [ ] consumed ) { if ( ( ! mPullRefreshEnable && ! mPullLoadEnable ) ) { return ; } if ( Math . abs ( dy ) > NUM_ ) { return ; } if ( ! isConfirm ) { if ( dy < NUM_ && ! canChildScrollUp ( ) ) { mCurrentAction = PULL_REFRESH ; isConfirm = BOOL_ ; } else if ( dy > NUM_ && ! canChildScrollDown ( ) ) { mCurrentAction = LOAD_MORE ; isConfirm = BOOL_ ; } } if ( moveSpinner ( - dy ) ) { consumed [ NUM_ ] += dy ; } }
public void testLocalInstances_deterministic ( ) { MatsimRandom . reset ( ) ; Random local1a = MatsimRandom . getLocalInstance ( ) ; Random local1b = MatsimRandom . getLocalInstance ( ) ; MatsimRandom . reset ( ) ; Random local2a = MatsimRandom . getLocalInstance ( ) ; Random local2b = MatsimRandom . getLocalInstance ( ) ; assertEqualRandomNumberGenerators ( local1a , local2a ) ; assertEqualRandomNumberGenerators ( local1b , local2b ) ; }
public void add ( Match match , AppliedRegion appliedRegion ) { add ( match , appliedRegion , BOOL_ ) ; }
public void reset ( ) { techTree . checkSubTree ( techTree . getPathForRow ( NUM_ ) , BOOL_ ) ; }
@ SuppressWarnings ( STR_ ) private static < T > void assertThrows ( final Consumer < Void > consumer , final Class < T > exceptionClass , final Consumer < T > assertExceptionProperties , final String message ) { final String normalizedMessage = null == message ? STR_ : String . format ( STR_ , message ) ; try { consumer . accept ( null ) ; } catch ( final Exception ex ) { if ( exceptionClass . isAssignableFrom ( ex . getClass ( ) ) ) { assertExceptionProperties . accept ( ( T ) ex ) ; return ; } Assert . fail ( String . format ( STR_ , normalizedMessage , ex . getClass ( ) , ex . getMessage ( ) ) ) ; } Assert . fail ( String . format ( STR_ , normalizedMessage , exceptionClass ) ) ; }
public boolean isEmpty ( ) { return nodes . isEmpty ( ) && ways . isEmpty ( ) && relations . isEmpty ( ) ; }
public static void assertBool ( boolean b ) { if ( verbose ) { log ( STR_ + b + STR_ ) ; } if ( ! b ) { throw new RuntimeException ( ) ; } }
public Criteria or ( ) { Criteria criteria = createCriteriaInternal ( ) ; oredCriteria . add ( criteria ) ; return criteria ; }
public TagKeyValueMapConverter ( boolean nullIfEmpty , String idKey ) { Objects . requireNonNull ( idKey ) ; this . nullIfEmpty = nullIfEmpty ; this . addId = BOOL_ ; this . idKey = idKey ; }
private static void postInit ( ) { debugAll = dbgTable . containsKey ( debugAllToken ) ; }
private static void attemptRetryOnException ( String logPrefix , Request < ? > request , VolleyError exception ) throws VolleyError { RetryPolicy retryPolicy = request . getRetryPolicy ( ) ; int oldTimeout = request . getTimeoutMs ( ) ; try { retryPolicy . retry ( exception ) ; } catch ( VolleyError e ) { request . addMarker ( String . format ( STR_ , logPrefix , oldTimeout ) ) ; throw e ; } request . addMarker ( String . format ( STR_ , logPrefix , oldTimeout ) ) ; }
public static List < File > sortInBatch ( File file , Comparator < String > cmp ) throws IOException { return sortInBatch ( file , cmp , DEFAULTMAXTEMPFILES ) ; }
public void addDirectorySet ( Context context , String path ) { TinyDB tinydb = new TinyDB ( context ) ; ArrayList < String > file = tinydb . getListString ( STR_ ) ; file . add ( path ) ; tinydb . putListString ( STR_ , file ) ; }
private FastConcurrentSkipListMap . Node < K , V > hiNode ( ) { if ( hi == null ) return m . findLast ( ) ; else if ( hiInclusive ) return m . findNear ( hi , m . LT | m . EQ ) ; else return m . findNear ( hi , m . LT ) ; }
protected void processEventProperties ( Properties eventProps ) { int status ; Node node ; Line line ; String cmd = eventProps . getProperty ( COMMAND_FIELD ) ; int index = PropUtils . intFromProperties ( eventProps , INDEX_FIELD , ERROR_VALUE_INT ) ; if ( cmd . equals ( NODE_OBJECT ) ) { int shape = PropUtils . intFromProperties ( eventProps , SHAPE_FIELD , ERROR_VALUE_INT ) ; if ( index == ERROR_VALUE_INT ) { Debug . error ( STR_ ) ; return ; } node = nodeList . get ( index ) ; if ( shape == NUM_ ) { String icon = eventProps . getProperty ( ICON_FIELD ) ; if ( DEBUG ) Debug . output ( STR_ + icon ) ; } if ( shape == NODE_DELETE ) { if ( node != null ) { lineList . del ( node ) ; nodeList . del ( node ) ; } } else if ( shape == NODE_MOVE && node != null ) { setNodePositionFromEventProps ( node , eventProps ) ; lineList . move ( node ) ; node . setTime ( Double . parseDouble ( eventProps . getProperty ( TIME_FIELD , STR_ ) ) ) ; } else { status = PropUtils . intFromProperties ( eventProps , STATUS_FIELD , NUM_ ) ; int menu = PropUtils . intFromProperties ( eventProps , MENU_FIELD , NUM_ ) ; String label = eventProps . getProperty ( LABEL_FIELD ) ; if ( label == null ) { label = eventProps . getProperty ( INDEX_FIELD ) ; } String ip = eventProps . getProperty ( IP_FIELD ) ; boolean isLocalhost = BOOL_ ; if ( ip != null && localhostIP != null ) { isLocalhost = localhostIP . equals ( ip ) ; if ( DEBUG ) { Debug . output ( STR_ + localhostIP ) ; } } if ( DEBUG ) { Debug . output ( STR_ + label + STR_ ) ; } try { if ( shape != ERROR_VALUE_INT ) { node = nodeList . add ( label , index , shape , menu , status ) ; node . setLocalhost ( isLocalhost ) ; } } catch ( Exception e ) { Debug . error ( STR_ ) ; } setNodePositionFromEventProps ( node , eventProps ) ; } } else if ( cmd . equals ( NODE_OBJECT_STATUS ) ) { if ( index == ERROR_VALUE_INT ) { Debug . error ( STR_ ) ; return ; } node = nodeList . get ( index ) ; if ( node != null ) { status = PropUtils . intFromProperties ( eventProps , STATUS_FIELD , ERROR_VALUE_INT ) ; if ( status != ERROR_VALUE_INT ) { node . setStatus ( status ) ; } } } else if ( cmd . equals ( LINK_OBJECT_STATUS ) ) { if ( index == ERROR_VALUE_INT ) { Debug . error ( STR_ ) ; return ; } line = lineList . get ( index ) ; if ( line != null ) { status = PropUtils . intFromProperties ( eventProps , STATUS_FIELD , ERROR_VALUE_INT ) ; if ( status != ERROR_VALUE_INT ) { line . setStatus ( status ) ; } } } else if ( cmd . equals ( LINK_OBJECT ) ) { if ( index == ERROR_VALUE_INT ) { Debug . error ( STR_ ) ; return ; } line = lineList . get ( index ) ; int shape = PropUtils . intFromProperties ( eventProps , SHAPE_FIELD , ERROR_VALUE_INT ) ; if ( shape == NODE_DELETE ) { lineList . del ( index ) ; } else { status = PropUtils . intFromProperties ( eventProps , STATUS_FIELD , NUM_ ) ; int node1 = PropUtils . intFromProperties ( eventProps , LINK_NODE1_FIELD , ERROR_VALUE_INT ) ; int node2 = PropUtils . intFromProperties ( eventProps , LINK_NODE2_FIELD , ERROR_VALUE_INT ) ; if ( node1 == ERROR_VALUE_INT || node2 == ERROR_VALUE_INT ) { Debug . error ( STR_ ) ; return ; } Node n1 = nodeList . get ( node1 ) ; Node n2 = nodeList . get ( node2 ) ; if ( n1 != null && n2 != null ) { lineList . add ( String . valueOf ( index ) , index , shape , status , n1 , n2 ) ; } else { if ( DEBUG ) { Debug . output ( STR_ ) ; } } } } else if ( cmd . equals ( REFRESH ) || cmd . equals ( UPDATE ) ) { } else if ( cmd . equals ( CLEAR ) ) { if ( nodeList != null ) { nodeList . flush ( ) ; } if ( lineList != null ) { lineList . flush ( ) ; } } else { if ( DEBUG ) { Debug . output ( STR_ + eventProps . toString ( ) ) ; } } manageGraphics ( ) ; }
protected static void addIdRepoAMSDKPlugin ( SSOToken token , String orgName ) throws SMSException , SSOException { ServiceConfigManager scm = new ServiceConfigManager ( ServiceManager . REALM_SERVICE , token ) ; ServiceConfig sc = scm . getOrganizationConfig ( orgName , null ) ; Map attributes = new HashMap ( ) ; Set values = new HashSet ( ) ; values . add ( STR_ ) ; attributes . put ( STR_ , values ) ; values = new HashSet ( ) ; values . add ( DNMapper . realmNameToAMSDKName ( DNMapper . orgNameToDN ( orgName ) ) ) ; attributes . put ( STR_ , values ) ; sc . addSubConfig ( STR_ , STR_ , NUM_ , attributes ) ; }
@ Override public synchronized void initialize ( ) { if ( ! mRootDirectory . exists ( ) ) { if ( ! mRootDirectory . mkdirs ( ) ) { VolleyLog . e ( STR_ , mRootDirectory . getAbsolutePath ( ) ) ; } return ; } File [ ] files = mRootDirectory . listFiles ( ) ; if ( files == null ) { return ; } for ( File file : files ) { FileInputStream fis = null ; try { fis = new FileInputStream ( file ) ; CacheHeader entry = CacheHeader . readHeader ( fis ) ; entry . size = file . length ( ) ; putEntry ( entry . key , entry ) ; } catch ( IOException e ) { if ( file != null ) { file . delete ( ) ; } } finally { try { if ( fis != null ) { fis . close ( ) ; } } catch ( IOException ignored ) { } } } }
public static String onKeyPress ( String key ) { pin = pin . concat ( key ) ; return pin ; }
public boolean isHierachic ( String string ) { int index = string . indexOf ( m_Seperator ) ; if ( ( index == ( string . length ( ) - NUM_ ) ) || ( index == - NUM_ ) ) { return BOOL_ ; } return BOOL_ ; }
public Shape paintLayer ( Graphics g , int offs0 , int offs1 , Shape bounds , JTextComponent c , View view ) { Color base = getColor ( ) ; Color color = base != null ? new Color ( base . getRed ( ) , base . getGreen ( ) , base . getBlue ( ) , NUM_ ) : null ; if ( color == null ) { g . setColor ( c . getSelectionColor ( ) ) ; } else { g . setColor ( color ) ; } if ( offs0 == view . getStartOffset ( ) && offs1 == view . getEndOffset ( ) ) { Rectangle alloc ; if ( bounds instanceof Rectangle ) { alloc = ( Rectangle ) bounds ; } else { alloc = bounds . getBounds ( ) ; } g . fillRect ( alloc . x , alloc . y , c . getWidth ( ) - alloc . x , alloc . height ) ; } else { try { Shape shape = view . modelToView ( offs0 , Position . Bias . Forward , offs1 , Position . Bias . Backward , bounds ) ; Rectangle r = ( shape instanceof Rectangle ) ? ( Rectangle ) shape : shape . getBounds ( ) ; g . fillRect ( NUM_ , r . y , c . getWidth ( ) , r . height ) ; return r ; } catch ( BadLocationException e ) { } } return null ; }
synchronized void receive ( char oneChar ) throws IOException { if ( buffer == null ) { throw new IOException ( STR_ ) ; } if ( lastReader != null && ! lastReader . isAlive ( ) ) { throw new IOException ( STR_ ) ; } lastWriter = Thread . currentThread ( ) ; try { while ( buffer != null && out == in ) { notifyAll ( ) ; wait ( NUM_ ) ; if ( lastReader != null && ! lastReader . isAlive ( ) ) { throw new IOException ( STR_ ) ; } } } catch ( InterruptedException e ) { throw new InterruptedIOException ( ) ; } if ( buffer == null ) { throw new IOException ( STR_ ) ; } if ( in == - NUM_ ) { in = NUM_ ; } buffer [ in ++ ] = oneChar ; if ( in == buffer . length ) { in = NUM_ ; } }
public static final ByteBuffer bufferToByteBuffer ( final byte [ ] buffer , final ByteOrder order ) { final ByteBuffer retBuff = ByteBuffer . wrap ( buffer ) ; retBuff . order ( order ) ; return retBuff ; }
public static void writeSingleByte ( OutputStream out , int b ) throws IOException { byte [ ] buffer = new byte [ NUM_ ] ; buffer [ NUM_ ] = ( byte ) ( b & xff ) ; out . write ( buffer ) ; }
private URI processLocalFiles ( URI uri ) { String uriStr = uri . toString ( ) ; if ( uriStr . startsWith ( STR_ ) ) { uriStr = STR_ + System . getProperty ( STR_ ) + STR_ + uriStr . substring ( NUM_ ) ; URL url ; try { url = new URL ( uriStr ) ; return url . toURI ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } return uri ; }
private String generateScreenOnOrOffUtternace ( int feedbackIndex ) { int resourceId = ( feedbackIndex == INDEX_SCREEN_ON ) ? R . string . template_screen_on : R . string . template_screen_off ; String template = mContext . getString ( resourceId ) ; int currentRingerVolume = mAudioManager . getStreamVolume ( AudioManager . STREAM_RING ) ; int maxRingerVolume = mAudioManager . getStreamMaxVolume ( AudioManager . STREAM_RING ) ; int volumePercent = ( NUM_ / maxRingerVolume ) . currentRingerVolume ; int adjustment = volumePercent % NUM_ ; if ( adjustment < NUM_ ) { volumePercent -= adjustment ; } else if ( adjustment > NUM_ ) { volumePercent += ( NUM_ - adjustment ) ; } return String . format ( template , volumePercent ) ; }
private void updateBaseMatrix ( Drawable d ) { ImageView imageView = getImageView ( ) ; if ( null == imageView || null == d ) { return ; } final float viewWidth = imageView . getWidth ( ) ; final float viewHeight = imageView . getHeight ( ) ; final int drawableWidth = d . getIntrinsicWidth ( ) ; final int drawableHeight = d . getIntrinsicHeight ( ) ; mBaseMatrix . reset ( ) ; final float widthScale = viewWidth / drawableWidth ; final float heightScale = viewHeight / drawableHeight ; if ( mScaleType == ScaleType . CENTER ) { mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth ) / NUM_ , ( viewHeight - drawableHeight ) / NUM_ ) ; } else if ( mScaleType == ScaleType . CENTER_CROP ) { float scale = Math . max ( widthScale , heightScale ) ; mBaseMatrix . postScale ( scale , scale ) ; mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth . scale ) / NUM_ , ( viewHeight - drawableHeight . scale ) / NUM_ ) ; } else if ( mScaleType == ScaleType . CENTER_INSIDE ) { float scale = Math . min ( NUM_ , Math . min ( widthScale , heightScale ) ) ; mBaseMatrix . postScale ( scale , scale ) ; mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth . scale ) / NUM_ , ( viewHeight - drawableHeight . scale ) / NUM_ ) ; } else { RectF mTempSrc = new RectF ( NUM_ , NUM_ , drawableWidth , drawableHeight ) ; RectF mTempDst = new RectF ( NUM_ , NUM_ , viewWidth , viewHeight ) ; switch ( mScaleType ) { case FIT_CENTER : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . CENTER ) ; break ; case FIT_START : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . START ) ; break ; case FIT_END : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . END ) ; break ; case FIT_XY : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . FILL ) ; break ; default : break ; } } resetMatrix ( ) ; }
public void reset ( ) { count = NUM_ ; startTime = System . currentTimeMillis ( ) ; }
public int readInt ( ) throws IOException { length += NUM_ ; int k1 = in . read ( ) ; if ( k1 < NUM_ ) return NUM_ ; int k2 = in . read ( ) << NUM_ ; int k3 = in . read ( ) << NUM_ ; return k1 + k2 + k3 + ( in . read ( ) << NUM_ ) ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; String childData ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; nameNode = elementList . item ( NUM_ ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; child . insertData ( NUM_ , STR_ ) ; childData = child . getData ( ) ; assertEquals ( STR_ , STR_ , childData ) ; }
public Enumeration listOptions ( ) { Vector newVector = new Vector ( NUM_ ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return newVector . elements ( ) ; }
public void testAddIssuerLjavax_security_auth_x500_X500Principal02 ( ) { X509CRLSelector selector = new X509CRLSelector ( ) ; X500Principal iss1 = new X500Principal ( STR_ ) ; X500Principal iss2 = new X500Principal ( STR_ ) ; CRL crl1 = new TestCRL ( iss1 ) ; CRL crl2 = new TestCRL ( iss2 ) ; selector . addIssuer ( iss1 ) ; assertTrue ( STR_ , selector . match ( crl1 ) ) ; assertFalse ( STR_ , selector . match ( crl2 ) ) ; selector . addIssuer ( iss2 ) ; assertTrue ( STR_ , selector . match ( crl2 ) ) ; }
public void addTransformation ( TagTransformation tagTransformation ) { if ( tagTransformation != null ) { mappings . put ( tagTransformation . getSourceTag ( ) , tagTransformation ) ; } }
@ Override public boolean isFileModified ( long fileTimeStamp , long endOffset ) { boolean isFileModified = BOOL_ ; if ( getLastModifiedTime ( ) > fileTimeStamp || getSize ( ) > endOffset ) { isFileModified = BOOL_ ; } return isFileModified ; }
public String nextString ( ) { nextClean ( STR_ ) ; StringBuilder sb = new StringBuilder ( ) ; for ( ; ; ) { char c = next ( ) ; switch ( c ) { case NUM_ : case STR_ : case STR_ : throw syntaxError ( STR_ ) ; case STR_ : c = next ( ) ; switch ( c ) { case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( ( char ) Integer . parseInt ( next ( NUM_ ) , NUM_ ) ) ; break ; default : sb . append ( c ) ; } break ; case STR_ : return sb . toString ( ) ; default : if ( c < STR_ ) { throw syntaxError ( STR_ + ( ( int ) c ) + STR_ ) ; } sb . append ( c ) ; break ; } } }
private void readLyrics3Tag ( File file , RandomAccessFile newFile , int loadOptions ) throws IOException { }
public double evaluate ( VectorInstance x , VectorInstance y ) throws Exception { double dotProd = x . dotProduct ( y ) ; return Math . pow ( m_gamma . dotProd + m_coef0 , m_degree ) ; }
private boolean isDbConfigurationPresent ( ) { return StringUtils . isNotBlank ( selectColumn ) && StringUtils . isNotBlank ( tableName ) ; }
public boolean isIncompleteNumericalRun ( String pin ) { final int len = pin . length ( ) ; int consecutive = NUM_ ; char last = pin . charAt ( NUM_ ) ; for ( int i = NUM_ ; i < len ; i ++ ) { final char c = pin . charAt ( i ) ; if ( last == c ) { consecutive ++ ; } else { consecutive = NUM_ ; } last = c ; if ( consecutive >= NUM_ ) { return BOOL_ ; } } return BOOL_ ; }
private static void generateJavaScriptLogAlertCloseWindow ( Writer writer , String message ) throws IOException { writer . write ( STR_ + message + STR_ ) ; writer . write ( STR_ ) ; writer . write ( STR_ ) ; }
private static char [ ] zzUnpackCMap ( String packed ) { char [ ] map = new char [ x10000 ] ; int i = NUM_ ; int j = NUM_ ; while ( i < NUM_ ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM_ ) ; } return map ; }
public Tree < String > extractBestMaxRuleParse1 ( int start , int end , int state , List < String > sentence ) { int cState = maxcChild [ start ] [ end ] [ state ] ; if ( cState == - NUM_ ) { return extractBestMaxRuleParse2 ( start , end , state , sentence ) ; } else { List < Tree < String > > child = new ArrayList < Tree < String > > ( ) ; child . add ( extractBestMaxRuleParse2 ( start , end , cState , sentence ) ) ; String stateStr = ( String ) tagNumberer . object ( state ) ; if ( stateStr . endsWith ( STR_ ) ) stateStr = stateStr . substring ( NUM_ , stateStr . length ( ) - NUM_ ) ; int intermediateNode = grammar . getUnaryIntermediate ( ( short ) state , ( short ) cState ) ; if ( intermediateNode == NUM_ ) { } if ( intermediateNode > NUM_ ) { List < Tree < String > > restoredChild = new ArrayList < Tree < String > > ( ) ; String stateStr2 = ( String ) tagNumberer . object ( intermediateNode ) ; if ( stateStr2 . endsWith ( STR_ ) ) stateStr2 = stateStr2 . substring ( NUM_ , stateStr2 . length ( ) - NUM_ ) ; restoredChild . add ( new Tree < String > ( stateStr2 , child ) ) ; return new Tree < String > ( stateStr , restoredChild ) ; } return new Tree < String > ( stateStr , child ) ; } }
protected void parseDOMAttributes ( Element element ) throws SAML2Exception { super . parseDOMAttributes ( element ) ; }
public void start ( int conditions ) throws IOException { print ( STR_ , new String [ ] { Integer . toBinaryString ( conditions ) } ) ; printer . flush ( ) ; }
public String pad ( String value , int places , String padCharacter ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( value ) ; while ( sb . length ( ) < places ) { sb . append ( padCharacter ) ; } return sb . toString ( ) ; }
private static ResultCode registerErrorResultCode ( final int intValue , final LocalizableMessage name , final Enum resultCodeEnum ) { final ResultCode t = new ResultCode ( intValue , name , BOOL_ , resultCodeEnum ) ; ELEMENTS . put ( intValue , t ) ; return t ; }
public void addAll ( ExceptionSet other ) { exceptionSet . or ( other . exceptionSet ) ; explicitSet . or ( other . explicitSet ) ; size = countBits ( exceptionSet ) ; commonSupertype = null ; }
@ HLEUnimplemented @ HLEFunction ( nid = x574A8C3F , version = NUM_ ) public int sceUsbCamStartVideo ( ) { if ( ! setupVideo ( ) ) { log . warn ( String . format ( STR_ ) ) ; } return NUM_ ; }
protected ResourceLoaderLicenseLocator ( final Charset charset , final String ... licenseFiles ) { if ( licenseFiles == null || licenseFiles . length == NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } if ( charset == null ) { throw new NullPointerException ( STR_ ) ; } this . licenseFiles = new ArrayList < String > ( Arrays . asList ( licenseFiles ) ) ; this . charset = charset ; }
private static boolean isIntendedException ( Exception e , Class < ? > clazz ) { final String message = e . getMessage ( ) ; return ( ! TextUtils . isEmpty ( message ) && message . startsWith ( clazz . getName ( ) ) ) ; }
@ Inject public ProjectTypeRegistry ( Set < ProjectTypeDef > types ) { projectTypes = new HashMap < > ( ) ; validatedData = new HashMap < > ( ) ; validate ( types ) ; for ( ProjectTypeDef type : validatedData . values ( ) ) { try { init ( type ) ; } catch ( ProjectTypeConstraintException e ) { LOG . error ( e . getMessage ( ) ) ; } } }
static public void addNotificationListener ( JMXConnector jmxConnector , Class < ? > mbeanInterface , String mbeanName , NotificationListener notificationListener , boolean ignored ) throws InstanceNotFoundException , Exception { MBeanServerConnection mbsc = jmxConnector . getMBeanServerConnection ( ) ; ObjectName objectName = generateMBeanObjectName ( mbeanInterface . getName ( ) , mbeanName ) ; mbsc . addNotificationListener ( objectName , notificationListener , null , null ) ; }
public void testCase16 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = - NUM_ ; int bSign = - NUM_ ; byte rBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . subtract ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( NUM_ , result . signum ( ) ) ; }
private void consume ( ) { consumer . subscribe ( topics ) ; while ( running . get ( ) ) { try { ConsumerRecords records = consumer . poll ( pollIntervalMs ) ; if ( records == null ) { continue ; } Iterator < ConsumerRecord < String , String > > iterator = records . iterator ( ) ; while ( iterator . hasNext ( ) ) { sendMessage ( iterator . next ( ) ) ; } } catch ( Exception ex ) { String error = STR_ ; logger . error ( error , ex ) ; bus . send ( ConfigConstants . CONSUMER_ERROR_TOPIC , getErrorString ( error , ex . getMessage ( ) ) ) ; } } }
private byte [ ] readRawBytesSlowPath ( final int size ) throws IOException { if ( size <= NUM_ ) { if ( size == NUM_ ) { return Internal . EMPTY_BYTE_ARRAY ; } else { throw InvalidProtocolBufferException . negativeSize ( ) ; } } if ( totalBytesRetired + bufferPos + size > currentLimit ) { skipRawBytes ( currentLimit - totalBytesRetired - bufferPos ) ; throw InvalidProtocolBufferException . truncatedMessage ( ) ; } if ( size < BUFFER_SIZE ) { final byte [ ] bytes = new byte [ size ] ; int pos = bufferSize - bufferPos ; System . arraycopy ( buffer , bufferPos , bytes , NUM_ , pos ) ; bufferPos = bufferSize ; ensureAvailable ( size - pos ) ; System . arraycopy ( buffer , NUM_ , bytes , pos , size - pos ) ; bufferPos = size - pos ; return bytes ; } else { final int originalBufferPos = bufferPos ; final int originalBufferSize = bufferSize ; totalBytesRetired += bufferSize ; bufferPos = NUM_ ; bufferSize = NUM_ ; int sizeLeft = size - ( originalBufferSize - originalBufferPos ) ; final List < byte [ ] > chunks = new ArrayList < byte [ ] > ( ) ; while ( sizeLeft > NUM_ ) { final byte [ ] chunk = new byte [ Math . min ( sizeLeft , BUFFER_SIZE ) ] ; int pos = NUM_ ; while ( pos < chunk . length ) { final int n = ( input == null ) ? - NUM_ : input . read ( chunk , pos , chunk . length - pos ) ; if ( n == - NUM_ ) { throw InvalidProtocolBufferException . truncatedMessage ( ) ; } totalBytesRetired += n ; pos += n ; } sizeLeft -= chunk . length ; chunks . add ( chunk ) ; } final byte [ ] bytes = new byte [ size ] ; int pos = originalBufferSize - originalBufferPos ; System . arraycopy ( buffer , originalBufferPos , bytes , NUM_ , pos ) ; for ( final byte [ ] chunk : chunks ) { System . arraycopy ( chunk , NUM_ , bytes , pos , chunk . length ) ; pos += chunk . length ; } return bytes ; } }
private void deleteAttrs ( SvcReg reg , EntryRep entry , boolean checkDups ) { EntryClass eclass = entry . eclass ; deleteInstance ( eclass ) ; Object [ ] fields = entry . fields ; if ( fields . length == NUM_ ) { ArrayList regs = serviceByEmptyAttr . get ( eclass ) ; if ( regs == null || ( checkDups && hasEmptyAttr ( reg , eclass ) ) ) return ; int idx = regs . indexOf ( reg ) ; if ( idx >= NUM_ ) { regs . remove ( idx ) ; if ( regs . isEmpty ( ) ) serviceByEmptyAttr . remove ( eclass ) ; } return ; } for ( int fldidx = fields . length ; -- fldidx >= NUM_ ; ) { eclass = getDefiningClass ( eclass , fldidx ) ; HashMap [ ] attrMaps = serviceByAttr . get ( eclass ) ; if ( attrMaps == null || attrMaps [ fldidx ] == null || ( checkDups && hasAttr ( reg , eclass , fldidx , fields [ fldidx ] ) ) ) continue ; HashMap map = attrMaps [ fldidx ] ; Object value = fields [ fldidx ] ; ArrayList regs = ( ArrayList ) map . get ( value ) ; if ( regs == null ) continue ; int idx = regs . indexOf ( reg ) ; if ( idx < NUM_ ) continue ; regs . remove ( idx ) ; if ( ! regs . isEmpty ( ) ) continue ; map . remove ( value ) ; if ( ! map . isEmpty ( ) ) continue ; attrMaps [ fldidx ] = null ; if ( allNull ( attrMaps ) ) serviceByAttr . remove ( eclass ) ; } }
public void testDSAProvider ( ) throws Exception { AlgorithmParameters params = AlgorithmParameters . getInstance ( STR_ ) ; assertEquals ( STR_ , STR_ , params . getAlgorithm ( ) ) ; BigInteger p = BigInteger . ONE ; BigInteger q = BigInteger . TEN ; BigInteger g = BigInteger . ZERO ; params . init ( new DSAParameterSpec ( p , q , g ) ) ; byte [ ] enc = params . getEncoded ( ) ; assertNotNull ( enc ) ; assertNotNull ( params . getEncoded ( STR_ ) ) ; DSAParameterSpec spec = params . getParameterSpec ( DSAParameterSpec . class ) ; assertEquals ( STR_ , p , spec . getP ( ) ) ; assertEquals ( STR_ , q , spec . getQ ( ) ) ; assertEquals ( STR_ , g , spec . getG ( ) ) ; params = AlgorithmParameters . getInstance ( STR_ ) ; params . init ( enc ) ; assertTrue ( STR_ , Arrays . equals ( enc , params . getEncoded ( ) ) ) ; params = AlgorithmParameters . getInstance ( STR_ ) ; params . init ( enc , STR_ ) ; assertTrue ( STR_ , Arrays . equals ( enc , params . getEncoded ( ) ) ) ; params = AlgorithmParameters . getInstance ( STR_ ) ; try { params . init ( enc , STR_ ) ; fail ( STR_ ) ; } catch ( IOException e ) { } }
public static boolean isClassLiteralPossible ( ClassNode classNode ) { return Modifier . isPublic ( classNode . getModifiers ( ) ) ; }
private Properties loadLogFile ( License license , boolean create ) { Properties log = new Properties ( ) ; File logFile = getLogFile ( license ) ; try { if ( create && logFile . createNewFile ( ) ) { logger . fine ( STR_ + logFile . getAbsolutePath ( ) ) ; } final InputStream in = new FileInputStream ( logFile ) ; try { log . load ( in ) ; } finally { in . close ( ) ; } } catch ( FileNotFoundException ex ) { if ( create ) { logger . log ( Level . SEVERE , STR_ + logFile . getAbsolutePath ( ) , ex ) ; } else { logger . fine ( STR_ ) ; } } catch ( IOException ex ) { logger . log ( Level . WARNING , STR_ + logFile . getAbsolutePath ( ) , ex ) ; } return log ; }
public HTMLStripCharFilterFactory ( Map < String , String > args ) { super ( args ) ; escapedTags = getSet ( args , STR_ ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( STR_ + args ) ; } }
public static int update ( long id , V v ) { String passwd = ( String ) v . value ( STR_ ) ; if ( ! X . isEmpty ( passwd ) ) { passwd = encrypt ( passwd ) ; v . set ( STR_ , passwd , BOOL_ ) ; } else { v . remove ( STR_ ) ; } return Helper . update ( id , v . set ( STR_ , System . currentTimeMillis ( ) ) , User . class ) ; }
@ Override public String toString ( ) { StringBuffer text = new StringBuffer ( ) ; text . append ( STR_ + attributesToString ( ) + STR_ ) ; text . append ( STR_ + getInstNums ( ) ) ; return text . toString ( ) ; }
public boolean isSafeMode ( ) { return this . safeMode ; }
public void test_getPutByteArrayWithOffsetAndLength ( ) { final int size = NUM_ ; final IDataRecord buf = new FixedByteArrayBuffer ( size ) ; assertEquals ( ( byte ) NUM_ , buf . getByte ( NUM_ ) ) ; assertEquals ( ( byte ) NUM_ , buf . getByte ( size - NUM_ ) ) ; final int pos = NUM_ ; for ( int i = NUM_ ; i < LIMIT ; i ++ ) { final byte [ ] expected = new byte [ r . nextInt ( size - NUM_ ) ] ; final int off = ( expected . length / NUM_ == NUM_ ? NUM_ : r . nextInt ( expected . length / NUM_ ) ) ; final int len = ( expected . length == NUM_ ? NUM_ : r . nextInt ( expected . length - off ) ) ; r . nextBytes ( expected ) ; buf . put ( pos , expected , off , len ) ; assertEquals ( NUM_ , BytesUtil . compareBytesWithLenAndOffset ( off , len , expected , pos , len , buf . array ( ) ) ) ; final int dstoff = r . nextInt ( NUM_ ) ; final byte [ ] actual = new byte [ expected . length + dstoff ] ; buf . get ( pos , actual , dstoff , expected . length ) ; assertEquals ( NUM_ , BytesUtil . compareBytesWithLenAndOffset ( off , len , expected , dstoff , len , actual ) ) ; } assertEquals ( ( byte ) NUM_ , buf . getByte ( NUM_ ) ) ; assertEquals ( ( byte ) NUM_ , buf . getByte ( pos + size - NUM_ ) ) ; }
public void addLastItem ( M model ) { addItem ( mDatas . size ( ) , model ) ; }
static boolean hasLocalizedMessages ( ) { return GUIMediator . isEnglishLocale ( ) || ! FIRST_MESSAGE . equals ( I18n . tr ( FIRST_MESSAGE ) ) ; }
public boolean textboxKeyTyped ( char p_146201_1_ , int p_146201_2_ ) { if ( ! field_146213_o ) return BOOL_ ; else switch ( p_146201_1_ ) { case NUM_ : func_146202_e ( ) ; func_146199_i ( NUM_ ) ; return BOOL_ ; case NUM_ : GuiScreen . setClipboardString ( func_146207_c ( ) ) ; return BOOL_ ; case NUM_ : if ( field_146226_p ) func_146191_b ( GuiScreen . getClipboardString ( ) ) ; return BOOL_ ; case NUM_ : GuiScreen . setClipboardString ( func_146207_c ( ) ) ; if ( field_146226_p ) func_146191_b ( STR_ ) ; return BOOL_ ; default : switch ( p_146201_2_ ) { case NUM_ : if ( GuiScreen . isCtrlKeyDown ( ) ) { if ( field_146226_p ) func_146177_a ( - NUM_ ) ; } else if ( field_146226_p ) func_146175_b ( - NUM_ ) ; return BOOL_ ; case NUM_ : if ( GuiScreen . isShiftKeyDown ( ) ) func_146199_i ( NUM_ ) ; else func_146196_d ( ) ; return BOOL_ ; case NUM_ : if ( GuiScreen . isShiftKeyDown ( ) ) { if ( GuiScreen . isCtrlKeyDown ( ) ) func_146199_i ( func_146183_a ( - NUM_ , func_146186_n ( ) ) ) ; else func_146199_i ( func_146186_n ( ) - NUM_ ) ; } else if ( GuiScreen . isCtrlKeyDown ( ) ) func_146190_e ( func_146187_c ( - NUM_ ) ) ; else func_146182_d ( - NUM_ ) ; return BOOL_ ; case NUM_ : if ( GuiScreen . isShiftKeyDown ( ) ) { if ( GuiScreen . isCtrlKeyDown ( ) ) func_146199_i ( func_146183_a ( NUM_ , func_146186_n ( ) ) ) ; else func_146199_i ( func_146186_n ( ) + NUM_ ) ; } else if ( GuiScreen . isCtrlKeyDown ( ) ) func_146190_e ( func_146187_c ( NUM_ ) ) ; else func_146182_d ( NUM_ ) ; return BOOL_ ; case NUM_ : if ( GuiScreen . isShiftKeyDown ( ) ) func_146199_i ( field_146216_j . length ( ) ) ; else func_146202_e ( ) ; return BOOL_ ; case NUM_ : if ( GuiScreen . isCtrlKeyDown ( ) ) { if ( field_146226_p ) func_146177_a ( NUM_ ) ; } else if ( field_146226_p ) func_146175_b ( NUM_ ) ; return BOOL_ ; default : if ( ChatAllowedCharacters . isAllowedCharacter ( p_146201_1_ ) ) { if ( field_146226_p ) func_146191_b ( Character . toString ( p_146201_1_ ) ) ; return BOOL_ ; } else return BOOL_ ; } } }
public static DockerImage fromImageName ( String imageName ) { imageName = prepare ( imageName ) ; String [ ] parts = imageName . split ( SECTION_SEPARATOR ) ; switch ( parts . length ) { case NUM_ : return fromParts ( null , null , parts [ NUM_ ] ) ; case NUM_ : if ( isValidNamespace ( parts [ NUM_ ] ) ) { return fromParts ( null , parts [ NUM_ ] , parts [ NUM_ ] ) ; } else { return fromParts ( parts [ NUM_ ] , null , parts [ NUM_ ] ) ; } case NUM_ : return fromParts ( parts [ NUM_ ] , parts [ NUM_ ] , parts [ NUM_ ] ) ; default : throw new IllegalArgumentException ( STR_ + imageName ) ; } }
public synchronized void listen ( final Set < NotificationChannel > channelNames ) { m_channels . addAll ( channelNames ) ; }
public static void deleteDirectory ( File directory ) throws IOException { if ( ! directory . exists ( ) ) { return ; } if ( ! isSymlink ( directory ) ) { cleanDirectory ( directory ) ; } if ( ! directory . delete ( ) ) { String message = STR_ + directory + STR_ ; throw new IOException ( message ) ; } }
private void displayNonVerbose ( ConsoleApplication app , String categoryName , String typeName , Tag tag , Set < String > propertyNames ) { if ( ! app . isScriptFriendly ( ) ) { displayPropertyOptionKey ( app ) ; app . println ( ) ; app . println ( ) ; } TableBuilder builder = new TableBuilder ( ) ; builder . appendHeading ( INFO_DSCFG_HEADING_COMPONENT_NAME . get ( ) ) ; builder . appendHeading ( INFO_DSCFG_HEADING_COMPONENT_TYPE . get ( ) ) ; builder . appendHeading ( INFO_DSCFG_HEADING_PROPERTY_NAME . get ( ) ) ; builder . appendHeading ( INFO_DSCFG_HEADING_PROPERTY_OPTIONS . get ( ) ) ; builder . appendHeading ( INFO_DSCFG_HEADING_PROPERTY_SYNTAX . get ( ) ) ; builder . addSortKey ( NUM_ ) ; builder . addSortKey ( NUM_ ) ; builder . addSortKey ( NUM_ ) ; for ( String category : categoryMap . keySet ( ) ) { if ( categoryName != null && ! categoryName . equals ( category ) ) { continue ; } Map < String , AbstractManagedObjectDefinition < ? , ? > > subTypes = categoryMap . get ( category ) ; for ( String type : subTypes . keySet ( ) ) { if ( typeName != null && ! typeName . equals ( type ) ) { continue ; } AbstractManagedObjectDefinition < ? , ? > mod = subTypes . get ( type ) ; if ( cannotDisplay ( app , mod , tag ) ) { continue ; } Set < PropertyDefinition < ? > > pds = getPropertyDefinitions ( mod ) ; for ( PropertyDefinition < ? > pd : pds ) { if ( cannotDisplay ( app , pd , propertyNames ) ) { continue ; } builder . startRow ( ) ; builder . appendCell ( category ) ; builder . appendCell ( type ) ; builder . appendCell ( pd . getName ( ) ) ; builder . appendCell ( getPropertyOptionSummary ( pd ) ) ; PropertyDefinitionUsageBuilder v = new PropertyDefinitionUsageBuilder ( BOOL_ ) ; builder . appendCell ( v . getUsage ( pd ) ) ; } } } TablePrinter printer ; if ( app . isScriptFriendly ( ) ) { printer = createScriptFriendlyTablePrinter ( app . getOutputStream ( ) ) ; } else { printer = new TextTablePrinter ( app . getOutputStream ( ) ) ; } builder . print ( printer ) ; }
public List < Long > deleteEmptyFolders ( ) { ArrayList < Long > folderIds = new ArrayList < Long > ( ) ; SQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; db . beginTransaction ( ) ; try { String selection = LauncherSettings . Favorites . ITEM_TYPE + STR_ + LauncherSettings . Favorites . ITEM_TYPE_FOLDER + STR_ + LauncherSettings . Favorites . _ID + STR_ + LauncherSettings . Favorites . CONTAINER + STR_ + TABLE_FAVORITES + STR_ ; Cursor c = db . query ( TABLE_FAVORITES , new String [ ] { LauncherSettings . Favorites . _ID } , selection , null , null , null , null ) ; while ( c . moveToNext ( ) ) { folderIds . add ( c . getLong ( NUM_ ) ) ; } c . close ( ) ; if ( folderIds . size ( ) > NUM_ ) { db . delete ( TABLE_FAVORITES , Utilities . createDbSelectionQuery ( LauncherSettings . Favorites . _ID , folderIds ) , null ) ; } db . setTransactionSuccessful ( ) ; } catch ( SQLException ex ) { Log . e ( TAG , ex . getMessage ( ) , ex ) ; folderIds . clear ( ) ; } finally { db . endTransaction ( ) ; } return folderIds ; }
@ Override default CompletableFuture < Integer > sumInt ( final ToIntFunction < ? super T > fn ) { return CompletableFuture . supplyAsync ( null , getExec ( ) ) ; }
public void testWrite3 ( ) throws Exception { byte [ ] data = new byte [ ] { - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; TestOutputStream tos = new TestOutputStream ( ) ; CipherOutputStream cos = new CipherOutputStream ( tos , new NullCipher ( ) ) ; for ( int i = NUM_ ; i < data . length ; i ++ ) { cos . write ( data , i , NUM_ ) ; } cos . flush ( ) ; byte [ ] result = tos . toByteArray ( ) ; if ( ! Arrays . equals ( result , data ) ) { fail ( STR_ ) ; } }
private Document parse ( final String data ) { if ( docBuilder == null || data == null ) { return null ; } Document document = null ; try { String buf = BEGINPART + data + ENDPART ; InputSource inputSource = new InputSource ( new StringReader ( buf ) ) ; document = docBuilder . parse ( inputSource ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return document ; }
public boolean isProductionJournal ( Set < String > productionCopies , Volume volume ) { for ( String productionCopy : productionCopies ) { if ( productionCopy . equalsIgnoreCase ( volume . getRpCopyName ( ) ) ) { return BOOL_ ; } } return BOOL_ ; }
private void testPoundSymbolInColumnName ( ) throws SQLException { deleteDb ( STR_ ) ; Connection conn = getConnection ( STR_ ) ; Statement stat = conn . createStatement ( ) ; stat . execute ( STR_ ) ; stat . execute ( STR_ ) ; assertResult ( STR_ , stat , STR_ ) ; conn . close ( ) ; }
public static String decode ( final String escaped ) throws URIException { try { final byte [ ] rawdata = URLCodec . decodeUrl ( EncodingUtil . getAsciiBytes ( escaped ) ) ; return EncodingUtil . getString ( rawdata , URI . getDefaultProtocolCharset ( ) ) ; } catch ( final DecoderException e ) { throw new URIException ( e . getMessage ( ) ) ; } }
void waitBeforeNextPoll ( int pollingInterval ) throws InterruptedException { synchronized ( this ) { wait ( pollingInterval ) ; } if ( ! pollOutstanding ) { return ; } log . debug ( STR_ ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { synchronized ( this ) { wait ( pollingInterval / NUM_ ) ; } log . debug ( STR_ ) ; if ( ! pollOutstanding ) { return ; } } }
private void shiftMappingVectorTokensLeft ( int lineNum , int startCol , int shift ) { boolean lastWasBeginTLAToken = BOOL_ ; int lastBeginTLATokCol = - NUM_ ; Vector line = ( Vector ) mappingVector . elementAt ( lineNum ) ; for ( int i = NUM_ ; i < line . size ( ) ; i ++ ) { MappingObject obj = ( MappingObject ) line . elementAt ( i ) ; if ( obj . getType ( ) == MappingObject . BEGIN_TLATOKEN ) { MappingObject . BeginTLAToken tobj = ( MappingObject . BeginTLAToken ) obj ; int col = tobj . getColumn ( ) ; if ( col >= startCol ) { tobj . setColumn ( col - shift ) ; } lastWasBeginTLAToken = BOOL_ ; lastBeginTLATokCol = tobj . getColumn ( ) ; } else { if ( obj . getType ( ) == MappingObject . END_TLATOKEN ) { MappingObject . EndTLAToken tobj = ( MappingObject . EndTLAToken ) obj ; int col = tobj . getColumn ( ) ; if ( col >= startCol ) { tobj . setColumn ( col - shift ) ; } if ( lastWasBeginTLAToken && tobj . getColumn ( ) <= lastBeginTLATokCol ) { PcalDebug . ReportBug ( STR_ ) ; } } else if ( obj . getType ( ) == MappingObject . SOURCE_TOKEN ) { MappingObject . SourceToken tobj = ( MappingObject . SourceToken ) obj ; int col = tobj . getBeginColumn ( ) ; if ( col >= startCol ) { tobj . setBeginColumn ( col - shift ) ; } col = tobj . getEndColumn ( ) ; if ( col >= startCol ) { tobj . setEndColumn ( col - shift ) ; } lastWasBeginTLAToken = BOOL_ ; } } } }
protected Dimension computeLengths ( String annoText ) { String [ ] lines = Util . splitLines ( annoText ) ; int lineLength = NUM_ ; for ( String line : lines ) { if ( line . length ( ) > lineLength ) lineLength = line . length ( ) ; } return new Dimension ( lineLength + NUM_ , lines . length + NUM_ ) ; }
public static void writeImageMap ( PrintWriter writer , String name , ChartRenderingInfo info , ToolTipTagFragmentGenerator toolTipTagFragmentGenerator , URLTagFragmentGenerator urlTagFragmentGenerator ) throws IOException { writer . println ( ImageMapUtilities . getImageMap ( name , info , toolTipTagFragmentGenerator , urlTagFragmentGenerator ) ) ; }
ImportNoteBuilder addMessage ( ImportNoteMessage . Type type , String message ) { if ( ! Strings . isNullOrEmpty ( message ) ) { messages . add ( new ImportNoteMessage ( type , message ) ) ; } return this ; }
public String toXMLString ( boolean includeNS , boolean declareNS ) throws FSMsgException { return toXMLString ( includeNS , declareNS , BOOL_ ) ; }
public static List < String > asStringList ( Collection < ? extends Object > objects ) { List < String > list = new ArrayList < > ( ) ; for ( Object object : objects ) { list . add ( String . valueOf ( object ) ) ; } return list ; }
public < E extends T > E min ( Iterable < E > iterable ) { Iterator < E > iterator = iterable . iterator ( ) ; E minSoFar = iterator . next ( ) ; while ( iterator . hasNext ( ) ) { minSoFar = min ( minSoFar , iterator . next ( ) ) ; } return minSoFar ; }
public synchronized int read ( byte b [ ] , int off , int len ) throws IOException { if ( len <= NUM_ ) return NUM_ ; int moreSpace ; synchronized ( lock ) { if ( pos >= present ) pos = present = NUM_ ; else if ( pos >= waterMark ) { System . arraycopy ( buffer , pos , buffer , NUM_ , present - pos ) ; present -= pos ; pos = NUM_ ; } int freeSpace = buffer . length - present ; moreSpace = Math . max ( freeSpace - requested , NUM_ ) ; } if ( moreSpace > NUM_ ) manager . sendRequest ( info , moreSpace ) ; synchronized ( lock ) { requested += moreSpace ; while ( ( pos >= present ) && ! disconnected ) { try { lock . wait ( ) ; } catch ( InterruptedException e ) { } } if ( disconnected && pos >= present ) return - NUM_ ; int available = present - pos ; if ( len < available ) { System . arraycopy ( buffer , pos , b , off , len ) ; pos += len ; return len ; } else { System . arraycopy ( buffer , pos , b , off , available ) ; pos = present = NUM_ ; return available ; } } }
public final void put ( String key , int value ) { if ( ( m_firstFree + NUM_ ) >= m_mapSize ) { m_mapSize += m_blocksize ; String newMap [ ] = new String [ m_mapSize ] ; System . arraycopy ( m_map , NUM_ , newMap , NUM_ , m_firstFree + NUM_ ) ; m_map = newMap ; int newValues [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_values , NUM_ , newValues , NUM_ , m_firstFree + NUM_ ) ; m_values = newValues ; } m_map [ m_firstFree ] = key ; m_values [ m_firstFree ] = value ; m_firstFree ++ ; }
public static List < ItemStack > consolidateItemStacks ( List < ItemStack > inputStacks ) { List < ItemStack > outputStacks = new ArrayList < ItemStack > ( ) ; for ( ItemStack sourceIS : inputStacks ) { boolean bFound = BOOL_ ; for ( ItemStack destIS : outputStacks ) { if ( destIS != null && sourceIS != null && itemStackIngredientsMatch ( destIS , sourceIS ) ) { bFound = BOOL_ ; destIS . stackSize += sourceIS . stackSize ; } } if ( ! bFound ) outputStacks . add ( sourceIS . copy ( ) ) ; } return outputStacks ; }
public static int howManyDaysOld ( long time ) { return ( int ) ( ( System . currentTimeMillis ( ) - time ) / DateUtils . DAY_IN_MILLIS ) ; }
protected Character isWFXMLChar ( String chardata ) { Character refInvalidChar ; if ( chardata == null || ( chardata . length ( ) == NUM_ ) ) { return null ; } char [ ] dataarray = chardata . toCharArray ( ) ; int datalength = dataarray . length ; if ( fIsXMLVersion11 ) { int i = NUM_ ; while ( i < datalength ) { if ( XML11Char . isXML11Invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - NUM_ ] ; if ( XMLChar . isHighSurrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if ( XMLChar . isLowSurrogate ( ch2 ) && XMLChar . isSupplemental ( XMLChar . supplemental ( ch , ch2 ) ) ) { continue ; } } refInvalidChar = new Character ( ch ) ; return refInvalidChar ; } } } else { int i = NUM_ ; while ( i < datalength ) { if ( XMLChar . isInvalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - NUM_ ] ; if ( XMLChar . isHighSurrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if ( XMLChar . isLowSurrogate ( ch2 ) && XMLChar . isSupplemental ( XMLChar . supplemental ( ch , ch2 ) ) ) { continue ; } } refInvalidChar = new Character ( ch ) ; return refInvalidChar ; } } } return null ; }
public void testZeroZero ( ) { String numA = STR_ ; String numB = STR_ ; String res = STR_ ; BigInteger aNumber = new BigInteger ( numA ) ; BigInteger bNumber = new BigInteger ( numB ) ; BigInteger result = aNumber . xor ( bNumber ) ; assertTrue ( res . equals ( result . toString ( ) ) ) ; }
public final ParallelFlux < T > doOnNext ( Consumer < ? super T > onNext ) { Objects . requireNonNull ( onNext , STR_ ) ; return doOnSignal ( this , onNext , null , null , null , null , null , null , null ) ; }
public void test_fill$CIIC ( ) { char val = STR_ ; char d [ ] = new char [ NUM_ ] ; Arrays . fill ( d , NUM_ , d . length , val ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) assertTrue ( STR_ , ! ( d [ i ] == val ) ) ; for ( int i = NUM_ ; i < d . length ; i ++ ) assertTrue ( STR_ , d [ i ] == val ) ; try { Arrays . fill ( d , NUM_ , NUM_ , val ) ; fail ( STR_ ) ; } catch ( IllegalArgumentException e ) { } try { Arrays . fill ( d , - NUM_ , NUM_ , val ) ; fail ( STR_ ) ; } catch ( ArrayIndexOutOfBoundsException e ) { } try { Arrays . fill ( d , NUM_ , d . length + NUM_ , val ) ; fail ( STR_ ) ; } catch ( ArrayIndexOutOfBoundsException e ) { } }
protected void addMissing ( Instances data , int level , boolean predictorMissing , boolean classMissing ) { int classIndex = data . classIndex ( ) ; Random random = new Random ( NUM_ ) ; for ( int i = NUM_ ; i < data . numInstances ( ) ; i ++ ) { Instance current = data . instance ( i ) ; for ( int j = NUM_ ; j < data . numAttributes ( ) ; j ++ ) { if ( ( ( j == classIndex ) && classMissing ) || ( ( j != classIndex ) && predictorMissing ) ) { if ( Math . abs ( random . nextInt ( ) ) % NUM_ < level ) current . setMissing ( j ) ; } } } }
public < T extends DataObject > void insertInBatches ( List < T > records , int partitionSize , DbClient dbClient , String type ) { List < List < T > > volume_partitions = Lists . partition ( records , partitionSize ) ; for ( List < T > partition : volume_partitions ) { try { dbClient . createObject ( partition ) ; _log . info ( STR_ , partition . size ( ) , type ) ; } catch ( DatabaseException e ) { _log . error ( STR_ , type , e ) ; } } }
public void modify ( SSOToken token , String objName , ModificationItem [ ] mods ) throws SMSException , SSOException { if ( ( objName == null ) || ( objName . length ( ) == NUM_ ) || ( mods == null ) || ( mods . length == NUM_ ) ) { throw new IllegalArgumentException ( STR_ + STR_ ) ; } mRWLock . readRequest ( ) ; try { if ( ! root . isExists ( mRootDir , objName ) ) { String errmsg = STR_ + objName + STR_ ; mDebug . error ( errmsg ) ; throw new ServiceNotFoundException ( errmsg ) ; } } finally { mRWLock . readDone ( ) ; } mRWLock . writeRequest ( ) ; try { SMSFlatFileTreeNode node = root . getChild ( objName ) ; if ( node == null ) { String errmsg = STR_ + objName + STR_ ; mDebug . error ( errmsg ) ; throw new ServiceNotFoundException ( errmsg ) ; } String filepath = node . getAttributeFilename ( mRootDir ) ; if ( filepath == null ) { String errmsg = STR_ + objName + STR_ ; mDebug . error ( errmsg ) ; throw new ServiceNotFoundException ( errmsg ) ; } File filehandle = new File ( filepath ) ; if ( ! filehandle . isFile ( ) ) { String errmsg = STR_ + STR_ + objName + STR_ ; mDebug . error ( errmsg ) ; throw new ServiceNotFoundException ( errmsg ) ; } Properties props = loadProperties ( filehandle , objName ) ; boolean hasSunXmlKeyValue = props . getProperty ( SMSEntry . ATTR_XML_KEYVAL ) != null ; for ( int i = NUM_ ; i < mods . length ; i ++ ) { modifyValues ( objName , mods [ i ] , props ) ; } saveProperties ( props , filehandle , objName ) ; String newSunXMLKeyValue = props . getProperty ( SMSEntry . ATTR_XML_KEYVAL ) ; if ( newSunXMLKeyValue != null ) { Set xmlKeyVals = toValSet ( SMSEntry . ATTR_XML_KEYVAL , newSunXMLKeyValue ) ; if ( ! hasSunXmlKeyValue ) { deleteSunXmlKeyValFiles ( node ) ; } createSunXmlKeyValFiles ( node , xmlKeyVals ) ; saveDirectoryTree ( ) ; } } finally { mRWLock . writeDone ( ) ; } }
public void removeOnTabSelectedListener ( OnTabSelectedListener listener ) { if ( listener != null ) { mListeners . remove ( listener ) ; } }
public ConnectUriManager ( List < String > connectUri ) throws THLException { this . uriList = connectUri ; if ( connectUri . size ( ) == NUM_ ) { throw new THLException ( STR_ ) ; } }
private void addVolumesToParkingStorageGroup ( StorageSystem storage , String policyName , Set < String > volumeDeviceIds ) throws Exception { String [ ] tokens = policyName . split ( Constants . SMIS_PLUS_REGEX ) ; CIMObjectPath groupPath = _helper . getVolumeGroupBasedOnSLO ( storage , storage , tokens [ NUM_ ] , tokens [ NUM_ ] , tokens [ NUM_ ] ) ; if ( groupPath == null ) { groupPath = _helper . createVolumeGroupBasedOnSLO ( storage , storage , tokens [ NUM_ ] , tokens [ NUM_ ] , tokens [ NUM_ ] ) ; } CIMArgument [ ] inArgs = _helper . getAddVolumesToMaskingGroupInputArguments ( storage , groupPath , volumeDeviceIds ) ; CIMArgument [ ] outArgs = new CIMArgument [ NUM_ ] ; SmisJob addVolumesToSGJob = new SmisSynchSubTaskJob ( null , storage . getId ( ) , SmisConstants . ADD_MEMBERS ) ; _helper . invokeMethodSynchronously ( storage , _cimPath . getControllerConfigSvcPath ( storage ) , STR_ , inArgs , outArgs , addVolumesToSGJob ) ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
public static InputStream toInputStream ( String input , Charset encoding ) { return new ByteArrayInputStream ( input . getBytes ( Charsets . toCharset ( encoding ) ) ) ; }
public boolean exportPkcs8 ( ) { return jrbPkcs8 . isSelected ( ) ; }
public static PublicKey generatePublicKey ( String encodedPublicKey ) { try { byte [ ] decodedKey = Base64 . decode ( encodedPublicKey ) ; KeyFactory keyFactory = KeyFactory . getInstance ( KEY_FACTORY_ALGORITHM ) ; return keyFactory . generatePublic ( new X509EncodedKeySpec ( decodedKey ) ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } catch ( InvalidKeySpecException e ) { Log . e ( TAG , STR_ ) ; throw new IllegalArgumentException ( e ) ; } catch ( Base64DecoderException e ) { Log . e ( TAG , STR_ ) ; throw new IllegalArgumentException ( e ) ; } }
public NumberTick ( Number number , String label , TextAnchor textAnchor , TextAnchor rotationAnchor , double angle ) { super ( number . doubleValue ( ) , label , textAnchor , rotationAnchor , angle ) ; this . number = number ; }
private boolean isStoppable ( ) { return ( isRunning ( ) && getCache ( ) != null ) ; }
private void log ( String message , String level , String levelColor , PrintStream ps ) { StringBuilder builder = new StringBuilder ( ) ; if ( ! level . equals ( STR_ ) ) builder . append ( getPrefix ( level , levelColor ) ) ; builder . append ( message ) ; String ts = builder . toString ( ) ; ps . println ( ts ) ; for ( LogHandler hand : handlers ) hand . onLog ( level , message , ts , this ) ; }
public void addGossipMember ( GossipMember member ) { gossipMembers . add ( member ) ; }
public static boolean isPublic ( int mod ) { return Modifier . isPublic ( mod ) ; }
public static PublicKey generatePublicKey ( String encodedPublicKey ) { try { byte [ ] decodedKey = Base64 . decode ( encodedPublicKey ) ; KeyFactory keyFactory = KeyFactory . getInstance ( KEY_FACTORY_ALGORITHM ) ; return keyFactory . generatePublic ( new X509EncodedKeySpec ( decodedKey ) ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } catch ( InvalidKeySpecException e ) { Log . e ( TAG , STR_ ) ; throw new IllegalArgumentException ( e ) ; } catch ( Base64DecoderException e ) { Log . e ( TAG , STR_ ) ; throw new IllegalArgumentException ( e ) ; } }
public static Map < String , Object > createUserPrefMap ( GenericValue rec ) throws GeneralException { return addPrefToMap ( rec , new LinkedHashMap < String , Object > ( ) ) ; }
private int clampMag ( int value , int absMin , int absMax ) { final int absValue = Math . abs ( value ) ; if ( absValue < absMin ) return NUM_ ; if ( absValue > absMax ) return value > NUM_ ? absMax : - absMax ; return value ; }
public JSONBuffer appendString ( Object cont ) { if ( stack . empty ( ) || stack . peek ( ) != Operand . ARRAY ) { throw new JSONException ( STR_ ) ; } addQuotedString ( cont ) ; addSeparator ( ) ; return this ; }
public static void deleteUserFromAuthenticationInfo ( AuthenticationInfo authenticationInfo ) throws ServerRuntimeException { String username = authenticationInfo . getUsername ( ) ; String passwordFileLocation = authenticationInfo . getPasswordFileLocation ( ) ; try { PropertiesConfiguration props = new PropertiesConfiguration ( passwordFileLocation ) ; String usernameInFile = props . getString ( username ) ; if ( usernameInFile == null ) { throw new ServerRuntimeException ( MessageFormat . format ( STR_ , username ) ) ; } props . clearProperty ( username ) ; props . save ( ) ; } catch ( org . apache . commons . configuration . ConfigurationException ce ) { logger . error ( STR_ + authenticationInfo . getPasswordFileLocation ( ) , ce ) ; throw new ServerRuntimeException ( STR_ + ce . getMessage ( ) ) ; } }
public void error ( Level level , String messageId , String data [ ] , Object session ) throws LogException { error ( level , messageId , data , session , null ) ; }
public synchronized void remove ( IAudioProcessor processor ) { processors . remove ( processor ) ; buildFinalProcessor ( ) ; }
private float clampMag ( float value , float absMin , float absMax ) { final float absValue = Math . abs ( value ) ; if ( absValue < absMin ) return NUM_ ; if ( absValue > absMax ) return value > NUM_ ? absMax : - absMax ; return value ; }
private int endRecoverAnimation ( ViewHolder viewHolder , boolean override ) { final int recoverAnimSize = mRecoverAnimations . size ( ) ; for ( int i = recoverAnimSize - NUM_ ; i >= NUM_ ; i -- ) { final RecoverAnimation anim = mRecoverAnimations . get ( i ) ; if ( anim . mViewHolder == viewHolder ) { anim . mOverridden |= override ; if ( ! anim . mEnded ) { anim . cancel ( ) ; } mRecoverAnimations . remove ( i ) ; return anim . mAnimationType ; } } return NUM_ ; }
public final void addElement ( String value ) { if ( ( m_firstFree + NUM_ ) >= m_mapSize ) { m_mapSize += m_blocksize ; String newMap [ ] = new String [ m_mapSize ] ; System . arraycopy ( m_map , NUM_ , newMap , NUM_ , m_firstFree + NUM_ ) ; m_map = newMap ; } m_map [ m_firstFree ] = value ; m_firstFree ++ ; }
private boolean isMethodContained ( Method m , List < Method > wrapperMethods ) { String name = m . getName ( ) ; Class < ? > [ ] paramTypes = m . getParameterTypes ( ) ; Class < ? > returnType = m . getReturnType ( ) ; for ( Method wm : wrapperMethods ) { if ( name . equals ( wm . getName ( ) ) && Arrays . equals ( paramTypes , wm . getParameterTypes ( ) ) && returnType == wm . getReturnType ( ) ) { return BOOL_ ; } } return BOOL_ ; }
public void deleteNode ( Node n ) { Assert . check ( nodes . contains ( n ) ) ; nodes . remove ( n ) ; notifyUpdate ( n , null ) ; }
void updatePressed ( ActionEvent e , boolean newRoute ) { String uName = _userName . getText ( ) ; Route g = checkNamesOK ( ) ; if ( g == null ) { return ; } g . setUserName ( uName ) ; g . clearOutputTurnouts ( ) ; g . clearOutputSensors ( ) ; g . clearRouteSensors ( ) ; initializeIncludedList ( ) ; setTurnoutInformation ( g ) ; setSensorInformation ( g ) ; g . setOutputScriptName ( scriptFile . getText ( ) ) ; g . setOutputSoundName ( soundFile . getText ( ) ) ; setControlInformation ( g ) ; curRoute = g ; finishUpdate ( ) ; status1 . setText ( ( newRoute ? Bundle . getMessage ( STR_ ) : Bundle . getMessage ( STR_ ) ) + STR_ + uName + STR_ + _includedTurnoutList . size ( ) + STR_ + Bundle . getMessage ( STR_ ) + STR_ + _includedSensorList . size ( ) + STR_ + Bundle . getMessage ( STR_ ) + STR_ ) ; }
public String toString ( ) { return m_Attributes . toString ( ) ; }
private static void checkForXStream ( ) { try { Class . forName ( STR_ ) ; m_Present = BOOL_ ; } catch ( Exception e ) { m_Present = BOOL_ ; } }
@ TargetApi ( Build . VERSION_CODES . GINGERBREAD_MR1 ) private Response < BitmapDrawable > doParse ( NetworkResponse response ) { byte [ ] data = response . data ; BitmapFactory . Options decodeOptions = new BitmapFactory . Options ( ) ; decodeOptions . inInputShareable = BOOL_ ; decodeOptions . inPurgeable = BOOL_ ; decodeOptions . inPreferredConfig = mDecodeConfig ; Bitmap bitmap ; if ( mMaxWidth == NUM_ && mMaxHeight == NUM_ ) { bitmap = BitmapFactory . decodeByteArray ( data , NUM_ , data . length , decodeOptions ) ; } else { decodeOptions . inJustDecodeBounds = BOOL_ ; BitmapFactory . decodeByteArray ( data , NUM_ , data . length , decodeOptions ) ; int actualWidth = decodeOptions . outWidth ; int actualHeight = decodeOptions . outHeight ; int desiredWidth = getResizedDimension ( mMaxWidth , mMaxHeight , actualWidth , actualHeight ) ; int desiredHeight = getResizedDimension ( mMaxHeight , mMaxWidth , actualHeight , actualWidth ) ; decodeOptions . inJustDecodeBounds = BOOL_ ; if ( Utils . hasGingerbreadMR1 ( ) ) { decodeOptions . inPreferQualityOverSpeed = PREFER_QUALITY_OVER_SPEED ; } decodeOptions . inSampleSize = ImageUtils . findBestSampleSize ( actualWidth , actualHeight , desiredWidth , desiredHeight ) ; Bitmap tempBitmap = BitmapFactory . decodeByteArray ( data , NUM_ , data . length , decodeOptions ) ; if ( tempBitmap != null && ( tempBitmap . getWidth ( ) > desiredWidth || tempBitmap . getHeight ( ) > desiredHeight ) ) { bitmap = Bitmap . createScaledBitmap ( tempBitmap , desiredWidth , desiredHeight , BOOL_ ) ; tempBitmap . recycle ( ) ; } else { bitmap = tempBitmap ; } } if ( bitmap == null ) { return Response . error ( new ParseError ( response ) ) ; } else { BitmapDrawable drawable ; if ( Utils . hasHoneycomb ( ) ) { drawable = new BitmapDrawable ( mResources , bitmap ) ; } else { drawable = new RecyclingBitmapDrawable ( mResources , bitmap ) ; } return Response . success ( drawable , HttpHeaderParser . parseCacheHeaders ( response ) ) ; } }
public double evaluate ( VectorInstance x , double [ ] y ) throws Exception { VectorInstance diff = x . subtract ( y ) ; double result = - m_gamma . diff . dotProduct ( diff ) ; return Math . exp ( result ) ; }
@ Override public int batchSize ( ) { return batchSize ; }
public static final byte [ ] decodeUrl ( byte [ ] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = NUM_ ; i < bytes . length ; i ++ ) { int b = bytes [ i ] ; if ( b == STR_ ) { buffer . write ( STR_ ) ; } else if ( b == STR_ ) { try { int u = Character . digit ( ( char ) bytes [ ++ i ] , NUM_ ) ; int l = Character . digit ( ( char ) bytes [ ++ i ] , NUM_ ) ; if ( u == - NUM_ || l == - NUM_ ) { throw new DecoderException ( STR_ ) ; } buffer . write ( ( char ) ( ( u << NUM_ ) + l ) ) ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( STR_ ) ; } } else { buffer . write ( b ) ; } } return buffer . toByteArray ( ) ; }
public void clear ( ) { mAttachedScrap . clear ( ) ; recycleAndClearCachedViews ( ) ; }
public void addDataSet ( T d ) { if ( d == null ) return ; mYValCount += d . getEntryCount ( ) ; mYValueSum += d . getYValueSum ( ) ; if ( mDataSets . size ( ) <= NUM_ ) { mYMax = d . getYMax ( ) ; mYMin = d . getYMin ( ) ; if ( d . getAxisDependency ( ) == AxisDependency . LEFT ) { mLeftAxisMax = d . getYMax ( ) ; mLeftAxisMin = d . getYMin ( ) ; } else { mRightAxisMax = d . getYMax ( ) ; mRightAxisMin = d . getYMin ( ) ; } } else { if ( mYMax < d . getYMax ( ) ) mYMax = d . getYMax ( ) ; if ( mYMin > d . getYMin ( ) ) mYMin = d . getYMin ( ) ; if ( d . getAxisDependency ( ) == AxisDependency . LEFT ) { if ( mLeftAxisMax < d . getYMax ( ) ) mLeftAxisMax = d . getYMax ( ) ; if ( mLeftAxisMin > d . getYMin ( ) ) mLeftAxisMin = d . getYMin ( ) ; } else { if ( mRightAxisMax < d . getYMax ( ) ) mRightAxisMax = d . getYMax ( ) ; if ( mRightAxisMin > d . getYMin ( ) ) mRightAxisMin = d . getYMin ( ) ; } } mDataSets . add ( d ) ; handleEmptyAxis ( getFirstLeft ( ) , getFirstRight ( ) ) ; }
public void endElement ( String elementName ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . endElement ( elementName ) ; }
public LibVLC ( ArrayList < String > options ) { boolean setAout = BOOL_ , setChroma = BOOL_ ; if ( options != null ) { for ( String option : options ) { if ( option . startsWith ( STR_ ) ) setAout = BOOL_ ; if ( option . startsWith ( STR_ ) ) setChroma = BOOL_ ; if ( ! setAout && ! setChroma ) break ; } } if ( setAout || setChroma ) { if ( options == null ) options = new ArrayList < String > ( ) ; if ( setAout ) { final HWDecoderUtil . AudioOutput hwAout = HWDecoderUtil . getAudioOutputFromDevice ( ) ; if ( hwAout == HWDecoderUtil . AudioOutput . OPENSLES ) options . add ( STR_ ) ; else options . add ( STR_ ) ; } if ( setChroma ) { options . add ( STR_ ) ; options . add ( STR_ ) ; } } nativeNew ( options . toArray ( new String [ options . size ( ) ] ) ) ; }
public FPSTextureView addChildAt ( int location , @ NonNull DisplayBase displayBase ) { displayBase . setUp ( mFps ) ; mDisplayList . add ( location , displayBase ) ; return this ; }
public static int minPathSum ( int [ ] [ ] grid ) { if ( grid == null || grid . length == NUM_ ) return NUM_ ; int m = grid . length ; int n = grid [ NUM_ ] . length ; int [ ] rowSum = new int [ n ] ; rowSum [ NUM_ ] = grid [ NUM_ ] [ NUM_ ] ; for ( int col = NUM_ ; col < n ; col ++ ) rowSum [ col ] = rowSum [ col - NUM_ ] + grid [ NUM_ ] [ col ] ; for ( int row = NUM_ ; row < m ; row ++ ) { rowSum [ NUM_ ] += grid [ row ] [ NUM_ ] ; for ( int col = NUM_ ; col < n ; col ++ ) { rowSum [ col ] = Math . min ( rowSum [ col - NUM_ ] , rowSum [ col ] ) + grid [ row ] [ col ] ; } } return rowSum [ n - NUM_ ] ; }
private static void appendJSONPair ( StringBuilder json , String key , String value ) throws UnsupportedEncodingException { boolean isValueNumeric = BOOL_ ; try { if ( value . equals ( STR_ ) || ! value . endsWith ( STR_ ) ) { Double . parseDouble ( value ) ; isValueNumeric = BOOL_ ; } } catch ( NumberFormatException e ) { isValueNumeric = BOOL_ ; } if ( json . charAt ( json . length ( ) - NUM_ ) != STR_ ) { json . append ( STR_ ) ; } json . append ( escapeJSON ( key ) ) ; json . append ( STR_ ) ; if ( isValueNumeric ) { json . append ( value ) ; } else { json . append ( escapeJSON ( value ) ) ; } }
public Time ( Date time ) { SimpleTimeZone tz = new SimpleTimeZone ( NUM_ , STR_ ) ; SimpleDateFormat dateF = new SimpleDateFormat ( STR_ ) ; dateF . setTimeZone ( tz ) ; String d = dateF . format ( time ) + STR_ ; int year = Integer . parseInt ( d . substring ( NUM_ , NUM_ ) ) ; if ( year < NUM_ || year > NUM_ ) { this . time = new DERGeneralizedTime ( d ) ; } else { this . time = new DERUTCTime ( d . substring ( NUM_ ) ) ; } }
public DCheckUpdate ( JFrame parent ) { super ( parent , Dialog . ModalityType . DOCUMENT_MODAL ) ; initComponents ( ) ; }
public static Automaton minimizeSimple ( Automaton a ) { Set < Integer > initialSet = new HashSet < Integer > ( ) ; a = determinizeSimple ( Operations . reverse ( a , initialSet ) , initialSet ) ; initialSet . clear ( ) ; a = determinizeSimple ( Operations . reverse ( a , initialSet ) , initialSet ) ; return a ; }
@ Override public boolean equals ( Object o ) { if ( this == o ) return BOOL_ ; if ( o == null || getClass ( ) != o . getClass ( ) ) return BOOL_ ; AbstractItem < ? , ? > that = ( AbstractItem < ? , ? > ) o ; return mIdentifier == that . mIdentifier ; }
public void addColumn ( Column column ) { if ( column != null ) { columns . add ( column ) ; } }
public static byte [ ] decode ( String str , int flags ) { return decode ( str . getBytes ( ) , flags ) ; }
private boolean checkForNaNs ( NumberVector vec ) { for ( int i = NUM_ , d = vec . getDimensionality ( ) ; i < d ; i ++ ) { double v = vec . doubleValue ( i ) ; if ( v != v ) { return BOOL_ ; } } return BOOL_ ; }
public static void fill ( StringBuilder strb , int offset ) { while ( strb . length ( ) < offset ) strb . append ( STR_ ) ; }
public void openForWrite ( ) throws EventException { File f = new File ( ConfigUtils . getInitialPropertyExpanded ( m_address . getPathname ( ) ) ) ; try { if ( ! f . exists ( ) ) { f . createNewFile ( ) ; } else { LOGGER . info ( STR_ + m_address . getPathname ( ) ) ; } } catch ( IOException ioe ) { throw new EventException ( STR_ + m_address . getPathname ( ) + STR_ + ioe ) ; } try { m_fos = new FileOutputStream ( f , BOOL_ ) ; } catch ( FileNotFoundException fnfe ) { throw new EventException ( STR_ + m_address . getPathname ( ) + STR_ + fnfe ) ; } }
@ Override public double calculate_K ( int [ ] x_index , double [ ] x_att , int [ ] y_index , double [ ] y_att ) { return ( Math . exp ( gamma . norm2 ( x_index , x_att , y_index , y_att ) ) ) ; }
@ Override public void close ( ) throws IOException { Throwable thrown = null ; try { flush ( ) ; } catch ( Throwable e ) { thrown = e ; } try { out . close ( ) ; } catch ( Throwable e ) { if ( thrown == null ) { thrown = e ; } } }
public static void writeFofn ( final File destination , final List < File > files ) throws IOException { final BufferedWriter bw = new BufferedWriter ( new FileWriter ( destination ) ) ; try { for ( final File file : files ) { bw . write ( wrapArg ( file . getAbsolutePath ( ) ) ) ; bw . newLine ( ) ; } bw . flush ( ) ; } finally { bw . close ( ) ; } }
void markInternalClasses ( ) { for ( int i = mClassDefs . length - NUM_ ; i >= NUM_ ; i -- ) { mTypeIds [ mClassDefs [ i ] . classIdx ] . internal = BOOL_ ; } for ( int i = NUM_ ; i < mTypeIds . length ; i ++ ) { String className = mStrings [ mTypeIds [ i ] . descriptorIdx ] ; if ( className . length ( ) == NUM_ ) { mTypeIds [ i ] . internal = BOOL_ ; } else if ( className . charAt ( NUM_ ) == STR_ ) { mTypeIds [ i ] . internal = BOOL_ ; } } }
public final double cos ( ) { return Math . cos ( this . radians ) ; }
public static double ssError ( double [ ] predictedValues , double [ ] targetAttribute ) { double ret = NUM_ ; for ( int i = NUM_ ; i < predictedValues . length ; i ++ ) { ret += Math . pow ( targetAttribute [ i ] - predictedValues [ i ] , NUM_ ) ; } return ret ; }
public int size ( ) { return prefixes . size ( ) ; }
@ Override public Writer append ( CharSequence value ) { builder . append ( value ) ; return this ; }
public static String timestamp ( DateTime ts ) { return Long . toString ( ts . getMillis ( ) / NUM_ ) ; }
public String consume ( String name , boolean required ) throws ParseException { if ( name == null ) { if ( content == null && required ) { throw new ParseException ( CoreErrorDomain . ERR . missingRequiredContent ) ; } contentConsumed = BOOL_ ; return content ; } String value = attrs . get ( name ) ; if ( value == null ) { if ( required ) { ParseException pe = new ParseException ( CoreErrorDomain . ERR . missingAttribute ) ; pe . setInternalReason ( STR_ + name + STR_ ) ; throw pe ; } return null ; } attrs . remove ( name ) ; return value ; }
public int copy ( byte [ ] bytes , int at ) { System . arraycopy ( this . bytes , NUM_ , bytes , at , this . length ) ; return at + this . length ; }
public void importKey ( ECKey key ) { lock . lock ( ) ; try { checkKeyEncryptionStateMatches ( key ) ; if ( hasKey ( key ) ) return ; importKeyLocked ( key ) ; queueOnKeysAdded ( ImmutableList . of ( key ) ) ; } finally { lock . unlock ( ) ; } }
public ConnectionGroupTree ( UserContext userContext , ConnectionGroup root , List < ObjectPermission . Type > permissions ) throws GuacamoleException { this . rootAPIGroup = new APIConnectionGroup ( root ) ; retrievedGroups . put ( root . getIdentifier ( ) , this . rootAPIGroup ) ; User self = userContext . self ( ) ; this . connectionPermissions = self . getConnectionPermissions ( ) ; this . sharingProfilePermissions = self . getSharingProfilePermissions ( ) ; this . connectionDirectory = userContext . getConnectionDirectory ( ) ; this . connectionGroupDirectory = userContext . getConnectionGroupDirectory ( ) ; this . sharingProfileDirectory = userContext . getSharingProfileDirectory ( ) ; addConnectionGroupDescendants ( Collections . singleton ( root ) , permissions ) ; }
private boolean containsSingleMetric ( BufferedReader reader ) throws FormatParseException { try { reader . mark ( NUM_ ) ; char firstChar = ( char ) reader . read ( ) ; reader . reset ( ) ; return firstChar == STR_ ; } catch ( IOException e ) { throw new FormatParseException ( STR_ , e ) ; } }
public void addButtonPressedListener ( FieldConfigStringButtonInterface listener ) { if ( buttonPressedListenerList == null ) { buttonPressedListenerList = new ArrayList < FieldConfigStringButtonInterface > ( ) ; } buttonPressedListenerList . add ( listener ) ; }
private String separeMetaTagsContent ( String content ) { String result = Utils . pregMatch ( content , Constants . METATAG_CONTENT_PATTERN , NUM_ ) ; return htmlDecode ( result ) ; }
@ Override public void removeColumns ( Column ... columns ) { for ( Column c : columns ) { columnList . remove ( c ) ; } }
private void readServiceConfig ( ) throws SSOException , SMSException { if ( debug . messageEnabled ( ) ) { debug . message ( STR_ ) ; } SSOToken internalToken = ( SSOToken ) AccessController . doPrivileged ( AdminTokenAction . getInstance ( ) ) ; serviceSchemaManager = new ServiceSchemaManager ( G11N_SETTINGS_SERVICE_NAME , internalToken ) ; ServiceSchema gsc = serviceSchemaManager . getGlobalSchema ( ) ; rawServiceData = gsc . getAttributeDefaults ( ) ; }
public void refreshPreferences ( Context context ) { if ( mEnabledResId != NUM_ ) { final SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( ! prefs . getBoolean ( context . getString ( mEnabledResId ) , mEnabledDefault ) ) { setTriggerKeys ( Collections . < Long > emptySet ( ) ) ; return ; } } setTriggerKeys ( KeyComboPreference . getKeyCodesForPreference ( context , mAssignedKeysResId ) ) ; }
void addInheritedTypes ( TypeMirror typeMirror , Types typesUtils ) { if ( ! CompilerUtils . typeMirrorInCollection ( inheritedTypes , typeMirror , typesUtils ) ) { inheritedTypes . add ( typeMirror ) ; } }
public static Histogram multiply ( Histogram x , double y ) { return x . modifyEventCounters ( null ) ; }
public void paint ( Graphics g ) { if ( m_from == null || m_to == null ) return ; Polygon arrow = new Polygon ( ) ; Point from = null ; Point to = null ; if ( isRightTop ( ) ) { from = addPoint ( arrow , m_from , SwingConstants . RIGHT , BOOL_ ) ; to = addPoint ( arrow , m_to , SwingConstants . TOP , BOOL_ ) ; } else if ( isBottomTop ( ) ) { from = addPoint ( arrow , m_from , SwingConstants . BOTTOM , BOOL_ ) ; to = addPoint ( arrow , m_to , SwingConstants . TOP , BOOL_ ) ; } else if ( isTopBottom ( ) ) { from = addPoint ( arrow , m_from , SwingConstants . TOP , BOOL_ ) ; to = addPoint ( arrow , m_to , SwingConstants . BOTTOM , BOOL_ ) ; } else if ( isLeftRight ( ) ) { from = addPoint ( arrow , m_from , SwingConstants . LEFT , BOOL_ ) ; to = addPoint ( arrow , m_to , SwingConstants . RIGHT , BOOL_ ) ; } else { from = addPoint ( arrow , m_from , SwingConstants . RIGHT , BOOL_ ) ; to = addPoint ( arrow , m_to , SwingConstants . LEFT , BOOL_ ) ; } if ( ! m_next . isUnconditional ( ) ) { g . setColor ( Color . red ) ; g . fillPolygon ( arrow ) ; } if ( m_visited ) g . setColor ( Color . green ) ; else g . setColor ( Color . black ) ; g . drawPolygon ( arrow ) ; if ( m_next . isFromSplitAnd ( ) ) { g . setColor ( Color . magenta ) ; g . fillOval ( from . x - NUM_ , from . y - NUM_ , NUM_ , NUM_ ) ; } if ( m_next . isToJoinAnd ( ) ) { g . setColor ( Color . magenta ) ; g . fillOval ( to . x - NUM_ , to . y - NUM_ , NUM_ , NUM_ ) ; } if ( m_description != null ) { Graphics2D g2D = ( Graphics2D ) g ; Font font = new Font ( STR_ , Font . PLAIN , NUM_ ) ; if ( m_next . isUnconditional ( ) ) g2D . setColor ( Color . black ) ; else g2D . setColor ( Color . red ) ; TextLayout layout = new TextLayout ( m_description , font , g2D . getFontRenderContext ( ) ) ; int x = NUM_ ; if ( from . x < to . x ) x = from . x + ( ( to . x - from . x ) / NUM_ ) ; else x = to . x + ( ( from . x - to . x ) / NUM_ ) ; int y = NUM_ ; if ( from . y < to . y ) y = from . y + ( ( to . y - from . y ) / NUM_ ) ; else y = to . y + ( ( from . y - to . y ) / NUM_ ) ; y -= ( layout . getAscent ( ) - NUM_ ) ; x -= ( layout . getAdvance ( ) / NUM_ ) ; if ( x < NUM_ ) x = NUM_ ; layout . draw ( g2D , x , y ) ; } }
public void addCacheParticipants ( Map < UUID , IgniteUuid > allParticipants , Map < UUID , IgniteUuid > addedParticipants ) { verStore . addParticipants ( allParticipants , addedParticipants ) ; }
public static String toJSONString ( Map map ) { final StringWriter writer = new StringWriter ( ) ; try { writeJSONString ( map , writer ) ; return writer . toString ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public void printContext ( PrintStream out ) { out . println ( getMessage ( ) ) ; out . print ( context ) ; }
public int size ( ) { return methods . size ( ) ; }
private void storeRequestId ( String requestId , String key ) { requestIds . put ( requestId , key ) ; }
private void savepostMni ( String mnipostLocation , String mnipostRespLocation , List manageNameIdList , com . sun . identity . saml2 . jaxb . metadata . ObjectFactory objFact ) throws JAXBException { if ( mnipostLocation != null && mnipostLocation . length ( ) > NUM_ ) { ManageNameIDServiceElement slsElemPost = objFact . createManageNameIDServiceElement ( ) ; slsElemPost . setBinding ( httpPostBinding ) ; slsElemPost . setLocation ( mnipostLocation ) ; slsElemPost . setResponseLocation ( mnipostRespLocation ) ; manageNameIdList . add ( slsElemPost ) ; } }
public static boolean goToUpdatePage ( Context context ) { final Uri playStoreUri = Uri . parse ( STR_ + context . getPackageName ( ) ) ; FreshAirLog . i ( STR_ + playStoreUri . toString ( ) ) ; final Intent playStoreIntent = new Intent ( Intent . ACTION_VIEW , playStoreUri ) ; final PackageManager packageManager = context . getPackageManager ( ) ; for ( ResolveInfo resolveInfo : packageManager . queryIntentActivities ( playStoreIntent , NUM_ ) ) { final ActivityInfo resolveActivity = resolveInfo . activityInfo ; final String resolvePackageName = resolveActivity . packageName ; if ( resolvePackageName . equals ( STR_ ) ) { FreshAirLog . i ( STR_ ) ; playStoreIntent . setComponent ( new ComponentName ( resolvePackageName , resolveActivity . name ) ) ; context . startActivity ( playStoreIntent ) ; return BOOL_ ; } } FreshAirLog . e ( STR_ + playStoreUri . toString ( ) ) ; return BOOL_ ; }
public IJavaElement createElement ( ClassScope scope , ICompilationUnit unit , HashSet existingElements , HashMap knownScopes ) { return createElement ( scope , scope . referenceContext . sourceStart , unit , existingElements , knownScopes ) ; }
public static List < String > toRelativeFiles ( @ NotNull VirtualFile root , @ NotNull final Collection < VirtualFile > files ) { ArrayList < String > rc = new ArrayList < String > ( files . size ( ) ) ; for ( VirtualFile file : files ) { rc . add ( relativePath ( root , file ) ) ; } return rc ; }
synchronized static void ensureSecurityManager ( ) { if ( System . getSecurityManager ( ) == null ) { System . setSecurityManager ( new RMISecurityManager ( ) ) ; } }
public static BigDecimal rate ( int p_C_CurrencyFrom_ID , int p_C_CurrencyTo_ID , Timestamp p_ConversionDate , int p_C_ConversionType_ID , int p_AD_Client_ID , int p_AD_Org_ID ) throws SQLException { if ( p_C_CurrencyFrom_ID == p_C_CurrencyTo_ID ) return Adempiere . ONE ; Timestamp ConversionDate = p_ConversionDate ; if ( ConversionDate == null ) ConversionDate = new Timestamp ( System . currentTimeMillis ( ) ) ; ConversionDate = Adempiere . trunc ( ConversionDate ) ; int C_ConversionType_ID = p_C_ConversionType_ID ; if ( C_ConversionType_ID == NUM_ ) { String sql = STR_ + STR_ + STR_ + STR_ + STR_ ; C_ConversionType_ID = Adempiere . getSQLValue ( sql , p_AD_Client_ID ) ; } BigDecimal rate = null ; String sql = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; PreparedStatement pstmt = Adempiere . prepareStatement ( sql ) ; pstmt . setInt ( NUM_ , p_C_CurrencyFrom_ID ) ; pstmt . setInt ( NUM_ , p_C_CurrencyTo_ID ) ; pstmt . setInt ( NUM_ , C_ConversionType_ID ) ; pstmt . setTimestamp ( NUM_ , ConversionDate ) ; pstmt . setTimestamp ( NUM_ , ConversionDate ) ; pstmt . setInt ( NUM_ , p_AD_Client_ID ) ; pstmt . setInt ( NUM_ , p_AD_Org_ID ) ; ResultSet rs = pstmt . executeQuery ( ) ; if ( rs . next ( ) ) { rate = rs . getBigDecimal ( NUM_ ) ; } rs . close ( ) ; pstmt . close ( ) ; if ( rate == null ) return null ; return rate ; }
public static Socket doInteraction ( final HttpsURLConnection clientConnection , final ServerSocket serverSocket , final int responseCode , final boolean doAuthentication ) throws Throwable { clientConnection . setDoInput ( BOOL_ ) ; clientConnection . setConnectTimeout ( TIMEOUT ) ; clientConnection . setReadTimeout ( TIMEOUT ) ; ServerWork server = new ServerWork ( serverSocket , responseCode , doAuthentication ) ; ClientConnectionWork client = new ClientConnectionWork ( clientConnection ) ; ExecutorService executorService = Executors . newFixedThreadPool ( NUM_ ) ; try { Future < Void > serverFuture = executorService . submit ( server ) ; Future < Void > clientFuture = executorService . submit ( client ) ; Throwable t = null ; try { serverFuture . get ( NUM_ , TimeUnit . SECONDS ) ; } catch ( ExecutionException e ) { t = e . getCause ( ) ; } try { clientFuture . get ( NUM_ , TimeUnit . SECONDS ) ; } catch ( ExecutionException e ) { if ( t != null ) { t . printStackTrace ( ) ; } t = e . getCause ( ) ; } if ( t != null ) { throw t ; } } catch ( ExecutionException e ) { throw e . getCause ( ) ; } finally { executorService . shutdown ( ) ; } return server . peerSocket ; }
public static SnmpEngineId createEngineId ( int port ) throws UnknownHostException { int suniana = NUM_ ; InetAddress address = null ; address = InetAddress . getLocalHost ( ) ; return createEngineId ( address , port , suniana ) ; }
public static List < Rule > parseReferential ( String path ) { Ruleset ruleset = DelphiRulesUtils . buildRuleSetFromXml ( DelphiRulesUtils . getConfigurationFromFile ( path ) ) ; List < Rule > rulesRepository = new ArrayList < Rule > ( ) ; for ( DelphiRule fRule : ruleset . getRules ( ) ) { rulesRepository . add ( createRepositoryRule ( fRule ) ) ; } return rulesRepository ; }
public void dispose ( ) { logDebug ( STR_ ) ; mSetupDone = BOOL_ ; if ( mServiceConn != null ) { logDebug ( STR_ ) ; if ( mContext != null ) mContext . unbindService ( mServiceConn ) ; } mDisposed = BOOL_ ; mContext = null ; mServiceConn = null ; mService = null ; mPurchaseListener = null ; }
public org . w3c . dom . Document encryptAndReplaceWSSElements ( org . w3c . dom . Document doc , java . util . Map elmMap , java . lang . String encDataEncAlg , int encDataEncAlgStrength , String certAlias , int kekStrength , java . lang . String tokenType , java . lang . String providerID ) throws EncryptionException { return null ; }
public void addIssue ( int reason , EObject obj , int featureId ) { issues . add ( new TransformationIssue ( reason , obj , featureId , null ) ) ; }
public void insertChild ( Node node , int index ) { node . detachFromParent ( ) ; node . parentNode = this ; try { initChildNodes ( node ) ; childNodes . add ( index , node ) ; } catch ( IndexOutOfBoundsException ignore ) { throw new LagartoDOMException ( STR_ + index ) ; } reindexChildren ( ) ; }
private static byte [ ] ntlmHash ( final String password ) throws AuthenticationException { try { final byte [ ] unicodePassword = password . getBytes ( STR_ ) ; final MD4 md4 = new MD4 ( ) ; md4 . update ( unicodePassword ) ; return md4 . getOutput ( ) ; } catch ( UnsupportedEncodingException e ) { throw new AuthenticationException ( STR_ + e . getMessage ( ) , e ) ; } }
private boolean betweenZeroAndOne ( final String paramName , final double val ) { if ( ( val < NUM_ ) || ( val > NUM_ ) ) { JOptionPane . showMessageDialog ( null , paramName + STR_ , STR_ , JOptionPane . WARNING_MESSAGE ) ; return BOOL_ ; } return BOOL_ ; }
public abstract String substituteMacros ( String parameterValue , MacroHandler mh ) throws UndefinedParameterError ;
public void powEquals ( double exp ) { for ( int i = NUM_ ; i < A . length ; i ++ ) for ( int j = NUM_ ; j < A [ i ] . length ; j ++ ) A [ i ] [ j ] = Math . pow ( A [ i ] [ j ] , exp ) ; }
private static List < String > splitCamelCase ( String className ) { String remaining = className ; List < String > result = new ArrayList < String > ( ) ; while ( ! remaining . isEmpty ( ) ) { boolean found = BOOL_ ; for ( int i = NUM_ ; i < remaining . length ( ) ; i ++ ) { if ( Character . isUpperCase ( remaining . charAt ( i ) ) ) { result . add ( remaining . substring ( NUM_ , i ) ) ; remaining = remaining . substring ( i ) ; found = BOOL_ ; break ; } } if ( ! found ) { result . add ( remaining ) ; remaining = STR_ ; } } return result ; }
public static NodeList selectNodeList ( Node doc , String str , NamespaceContext nsctx ) throws XPathException { XPathFactory xpf = xpathFactoryCache . getInstanceForCurrentThread ( ) ; XPath xpath = xpf . newXPath ( ) ; xpath . setNamespaceContext ( nsctx ) ; XPathExpression expr = xpath . compile ( str ) ; return ( NodeList ) expr . evaluate ( doc , XPathConstants . NODESET ) ; }
public ResultEntry ( NondominatedPopulation population , TypedProperties properties ) { this ( population , properties == null ? null : properties . getProperties ( ) ) ; }
private void generateDiscovery ( ) throws SAXException { handler . startElement ( STR_ , LOCATORS , LOCATORS , EMPTY ) ; generateLocators ( ) ; handler . endElement ( STR_ , LOCATORS , LOCATORS ) ; }
protected BasicType ( Class < T > type , int sqlType ) { super ( type , sqlType ) ; checkNull = ! type . isPrimitive ( ) ; }
@ Override public void actionPerformed ( ActionEvent e ) { }
public void applyProperties ( ) { for ( ParameterType type : allParameterTypes ) { String value = allParameterValues . getProperty ( type . getKey ( ) ) ; ParameterService . setParameterValue ( type , value ) ; } }
private void rotateLeft ( Node < K , V > root ) { Node < K , V > left = root . left ; Node < K , V > pivot = root . right ; Node < K , V > pivotLeft = pivot . left ; Node < K , V > pivotRight = pivot . right ; root . right = pivotLeft ; if ( pivotLeft != null ) { pivotLeft . parent = root ; } replaceInParent ( root , pivot ) ; pivot . left = root ; root . parent = pivot ; root . height = Math . max ( left != null ? left . height : NUM_ , pivotLeft != null ? pivotLeft . height : NUM_ ) + NUM_ ; pivot . height = Math . max ( root . height , pivotRight != null ? pivotRight . height : NUM_ ) + NUM_ ; }
public void add ( ClusterNode newNode ) { if ( node != null ) { nodes = new ArrayList < > ( NUM_ ) ; nodes . add ( node ) ; node = null ; } nodes . add ( newNode ) ; }
public boolean checkIfBackupSetExists ( String setName ) { validateNotNullOrEmpty ( setName ) ; try { File file = new File ( getBackupRoot ( ) , setName ) ; if ( file . exists ( ) ) { return BOOL_ ; } } catch ( Exception e ) { log . error ( STR_ ) ; } return BOOL_ ; }
public static String [ ] toQuotedAndCommaSeparatedArray ( String str ) throws IOException { LinkedList < String > values = new LinkedList < String > ( ) ; StreamTokenizer tt = new StreamTokenizer ( new StringReader ( str ) ) ; tt . wordChars ( STR_ , STR_ ) ; tt . wordChars ( STR_ , STR_ ) ; tt . wordChars ( NUM_ + NUM_ , NUM_ ) ; tt . whitespaceChars ( NUM_ , STR_ ) ; tt . quoteChar ( STR_ ) ; tt . quoteChar ( STR_ ) ; while ( tt . nextToken ( ) != StreamTokenizer . TT_EOF ) { switch ( tt . ttype ) { case StreamTokenizer . TT_WORD : case STR_ : case STR_ : values . add ( tt . sval ) ; break ; } } return values . toArray ( new String [ values . size ( ) ] ) ; }
public void writeStringNoCompression ( String str ) throws IOException { if ( str == null ) { writeInt ( NUM_ ) ; } else { writeInt ( str . length ( ) ) ; for ( int i = NUM_ ; i < str . length ( ) ; i ++ ) io . write ( ( byte ) str . charAt ( i ) ) ; } }
public SmartThresholds parse ( final Resource thresholdFileResource ) throws IOException { final SmartThresholds holder = new SmartThresholds ( ) ; BufferedReader reader = null ; try { reader = new BufferedReader ( new InputStreamReader ( thresholdFileResource . getInputStream ( ) ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . startsWith ( STR_ ) ) { String [ ] lineInput = line . split ( STR_ ) ; holder . addThreshold ( new SmartThreshold ( lineInput ) ) ; } } } finally { if ( reader != null ) { reader . close ( ) ; } } return holder ; }
public void shutdown ( ) { ExecutorService executor = Executors . newScheduledThreadPool ( NUM_ ) ; executor . submit ( createShutdown ( NUM_ ) ) ; }
@ Override public Point drawingToView ( Point2D . Double p ) { return new Point ( ( int ) ( p . x . scaleFactor ) - translation . x , ( int ) ( p . y . scaleFactor ) - translation . y ) ; }
public void addDescriptor ( final SetupDescriptor desc ) { descriptors . add ( desc ) ; }
public static boolean containIP ( int cidrPrefix , int cidrMaskBits , int ip ) { boolean matched = BOOL_ ; int bitsToShift = NUM_ - cidrMaskBits ; if ( bitsToShift > NUM_ ) { cidrPrefix = cidrPrefix > > bitsToShift ; ip = ip > > bitsToShift ; cidrPrefix = cidrPrefix << bitsToShift ; ip = ip << bitsToShift ; } if ( cidrPrefix != ip ) { matched = BOOL_ ; } return matched ; }
public static String compileProgressSuccessAction ( String progressSuccessAction ) throws TemplateModelException { Environment env = CommonFtlUtil . getCurrentEnvironment ( ) ; return compileProgressSuccessAction ( progressSuccessAction , ContextFtlUtil . getRequest ( env ) , ContextFtlUtil . getResponse ( env ) ) ; }
public static String join ( String separator , float ... elements ) { if ( elements == null || elements . length == NUM_ ) { return STR_ ; } List < Number > list = new ArrayList < Number > ( elements . length ) ; for ( Float elem : elements ) { list . add ( elem ) ; } return join ( separator , list ) ; }
public static void putUnsignedByte ( ByteBuffer bb , short v ) { bb . put ( ( byte ) ( v & xff ) ) ; }
public static int numOfParameters ( String desc ) { int n = NUM_ ; int i = NUM_ ; for ( ; ; ) { char c = desc . charAt ( i ) ; if ( c == STR_ ) break ; while ( c == STR_ ) c = desc . charAt ( ++ i ) ; if ( c == STR_ ) { i = desc . indexOf ( STR_ , i ) + NUM_ ; if ( i <= NUM_ ) throw new IndexOutOfBoundsException ( STR_ ) ; } else ++ i ; ++ n ; } return n ; }
@ Override public Trie optimize ( Trie orig ) { List < CharSequence > cmds = orig . cmds ; List < Row > rows = new ArrayList < > ( ) ; List < Row > orows = orig . rows ; int remap [ ] = new int [ orows . size ( ) ] ; for ( int j = orows . size ( ) - NUM_ ; j >= NUM_ ; j -- ) { Row now = new Remap ( orows . get ( j ) , remap ) ; boolean merged = BOOL_ ; for ( int i = NUM_ ; i < rows . size ( ) ; i ++ ) { Row q = merge ( now , rows . get ( i ) ) ; if ( q != null ) { rows . set ( i , q ) ; merged = BOOL_ ; remap [ j ] = i ; break ; } } if ( merged == BOOL_ ) { remap [ j ] = rows . size ( ) ; rows . add ( now ) ; } } int root = remap [ orig . root ] ; Arrays . fill ( remap , - NUM_ ) ; rows = removeGaps ( root , rows , new ArrayList < Row > ( ) , remap ) ; return new Trie ( orig . forward , remap [ root ] , cmds , rows ) ; }
public boolean isAllDenied ( ) { int count = NUM_ ; for ( int i = NUM_ ; i < mPerms . size ( ) ; i ++ ) { if ( mPerms . get ( mUserPermission . get ( i ) ) == PackageManager . PERMISSION_DENIED ) count ++ ; } return count == mPerms . size ( ) ; }
public String toStringKey ( ) { String result ; int i ; result = STR_ + STR_ ; for ( i = NUM_ ; i < getColCount ( ) ; i ++ ) { if ( getColHidden ( i ) ) continue ; result += STR_ + STR_ + ( i + NUM_ ) + STR_ + STR_ + removeFilterName ( m_ColNames [ i ] ) + STR_ + STR_ ; } result += STR_ ; return result ; }
private DateTimeFormatter toFormatter ( Locale locale , ResolverStyle resolverStyle , Chronology chrono ) { Objects . requireNonNull ( locale , STR_ ) ; while ( active . parent != null ) { optionalEnd ( ) ; } CompositePrinterParser pp = new CompositePrinterParser ( printerParsers , BOOL_ ) ; return new DateTimeFormatter ( pp , locale , DecimalStyle . STANDARD , resolverStyle , null , chrono , null ) ; }
protected void waitForExternalStoreMount ( ) throws Exception { String extStorageState = Environment . getExternalStorageState ( ) ; int currentWaitTime = NUM_ ; while ( ! extStorageState . equals ( Environment . MEDIA_MOUNTED ) ) { Log . i ( LOG_TAG , STR_ ) ; currentWaitTime = timeoutWait ( currentWaitTime , DEFAULT_WAIT_POLL_TIME , DEFAULT_MAX_WAIT_TIME , STR_ ) ; extStorageState = Environment . getExternalStorageState ( ) ; } }
public final void push ( Node value ) { int ff = m_firstFree ; if ( ( ff + NUM_ ) >= m_mapSize ) { if ( null == m_map ) { m_map = new Node [ m_blocksize ] ; m_mapSize = m_blocksize ; } else { m_mapSize += m_blocksize ; Node newMap [ ] = new Node [ m_mapSize ] ; System . arraycopy ( m_map , NUM_ , newMap , NUM_ , ff + NUM_ ) ; m_map = newMap ; } } m_map [ ff ] = value ; ff ++ ; m_firstFree = ff ; }
public boolean uploadAndInstallApk ( @ NotNull IDevice device , @ NotNull String packageName , @ NotNull File localFile , @ NotNull LaunchStatus launchStatus ) { if ( ! needsInstall ( device , localFile , packageName ) ) { return BOOL_ ; } String remotePath = STR_ + packageName ; myPrinter . stdout ( STR_ + localFile + STR_ + remotePath ) ; try { device . pushFile ( localFile . getPath ( ) , remotePath ) ; boolean installed = installApp ( device , remotePath , packageName , launchStatus ) ; if ( installed ) { myInstalledApkCache . setInstalled ( device , localFile , packageName ) ; } return installed ; } catch ( Exception e ) { myPrinter . stderr ( e . toString ( ) ) ; return BOOL_ ; } }
public static ByteArrayList readAsBytes ( InputStream is ) throws IOException { ByteArrayList buf = new ByteArrayList ( ) ; byte [ ] b = new byte [ NUM_ ] ; int nread = - NUM_ ; while ( ( nread = is . read ( b ) ) >= NUM_ ) { buf . add ( b , NUM_ , nread ) ; } return buf ; }
public static int uninstallSilent ( Context context , String packageName ) { return uninstallSilent ( context , packageName , BOOL_ ) ; }
public void open ( final long [ ] list , final int position ) { launchPlayerActivity = BOOL_ ; synchronized ( this ) { if ( mShuffleMode == SHUFFLE_AUTO ) { mShuffleMode = SHUFFLE_NORMAL ; } final long oldId = getAudioId ( ) ; final int listlength = list . length ; boolean newlist = BOOL_ ; if ( mPlayListLen == listlength ) { newlist = BOOL_ ; for ( int i = NUM_ ; i < listlength ; i ++ ) { if ( list [ i ] != mPlayList [ i ] ) { newlist = BOOL_ ; break ; } } } if ( newlist ) { addToPlayList ( list , - NUM_ ) ; notifyChange ( QUEUE_CHANGED ) ; } if ( position >= NUM_ ) { mPlayPos = position ; } else { mPlayPos = mShuffler . nextInt ( mPlayListLen ) ; } mHistory . clear ( ) ; openCurrentAndNext ( ) ; if ( oldId != getAudioId ( ) ) { notifyChange ( META_CHANGED ) ; } } }
public Builder names ( final String ... names ) { return names ( Arrays . asList ( names ) ) ; }
public void scheduleAtFixedRate ( TimerTask task , Date when , long period ) { if ( period <= NUM_ || when . getTime ( ) < NUM_ ) { throw new IllegalArgumentException ( ) ; } long delay = when . getTime ( ) - System . currentTimeMillis ( ) ; scheduleImpl ( task , delay , period , BOOL_ ) ; }
public void testNegativeReverseStepByOneWithClosure ( ) { final List callLog = new ArrayList ( ) ; final Closure closure = new RecordingClosure ( callLog ) ; final Range range = createRange ( NUM_ , NUM_ ) ; range . step ( - NUM_ , closure ) ; assertEquals ( STR_ , NUM_ , callLog . size ( ) ) ; final Iterator iter = callLog . iterator ( ) ; for ( int i = NUM_ ; i <= NUM_ ; i ++ ) { assertEquals ( STR_ , createValue ( i ) , iter . next ( ) ) ; } }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
public static BigDecimal normalizeDecimalValue ( BigDecimal bigDecimal , int allowedPrecision ) { if ( bigDecimal . precision ( ) > allowedPrecision ) { return null ; } return bigDecimal ; }
protected static Node deserializeString ( String doc ) { try { StringReader reader = new StringReader ( doc ) ; StreamSource source = new StreamSource ( reader ) ; DOMResult result = new DOMResult ( ) ; TransformerFactory tf = TransformerFactory . newInstance ( ) ; Transformer transformer = tf . newTransformer ( ) ; transformer . setOutputProperty ( OutputKeys . ENCODING , DEFAULT_ENCODING ) ; transformer . setOutputProperty ( OutputKeys . INDENT , DEFAULT_INDENT ) ; transformer . transform ( source , result ) ; return result . getNode ( ) ; } catch ( Throwable e ) { log . log ( Level . SEVERE , STR_ , e ) ; } return null ; }
public static String append ( final CharSequence url , final Object ... params ) { final String baseUrl = url . toString ( ) ; if ( params == null || params . length == NUM_ ) return baseUrl ; if ( params . length % NUM_ != NUM_ ) throw new IllegalArgumentException ( STR_ ) ; final StringBuilder result = new StringBuilder ( baseUrl ) ; addPathSeparator ( baseUrl , result ) ; addParamPrefix ( baseUrl , result ) ; Object value ; result . append ( params [ NUM_ ] ) ; result . append ( STR_ ) ; value = params [ NUM_ ] ; if ( value != null ) result . append ( value ) ; for ( int i = NUM_ ; i < params . length ; i += NUM_ ) { result . append ( STR_ ) ; result . append ( params [ i ] ) ; result . append ( STR_ ) ; value = params [ i + NUM_ ] ; if ( value != null ) result . append ( value ) ; } return result . toString ( ) ; }
public void sendEventToAgent ( final String event ) { synchronized ( eventSocket ) { eventWriter . print ( event ) ; eventWriter . flush ( ) ; } }
private void applyJMSObjects ( HashMap < String , String > filters ) { StringWriter writer = new StringWriter ( ) ; PrintWriter printWriter = new PrintWriter ( writer ) ; printWriter . println ( ) ; for ( String str : getQueueList ( ) ) { printWriter . println ( STR_ + str + STR_ ) ; } for ( String str : getTopicList ( ) ) { printWriter . println ( STR_ + str + STR_ ) ; } filters . put ( STR_ , writer . toString ( ) ) ; }
@ Override public Revision next ( ) { try { int revCount , articleID ; revCount = result . getInt ( NUM_ ) ; articleID = result . getInt ( NUM_ ) ; if ( articleID != this . currentArticleID ) { this . currentRevCounter = NUM_ ; this . currentArticleID = articleID ; } if ( revCount - NUM_ != this . currentRevCounter ) { logger . error ( STR_ + STR_ + articleID + STR_ + result . getInt ( NUM_ ) + STR_ + result . getInt ( NUM_ ) + STR_ + ( this . currentRevCounter + NUM_ ) ) ; this . currentRevCounter = revCount ; this . previousRevision = null ; return null ; } this . currentRevCounter = revCount ; this . primaryKey = result . getInt ( NUM_ ) ; Revision revision = new Revision ( revCount ) ; revision . setPrimaryKey ( this . primaryKey ) ; if ( ! shouldLoadRevisionText ) { String currentRevision ; Diff diff ; RevisionDecoder decoder = new RevisionDecoder ( config . getCharacterSet ( ) ) ; if ( binaryData ) { decoder . setInput ( result . getBinaryStream ( NUM_ ) , BOOL_ ) ; } else { decoder . setInput ( result . getString ( NUM_ ) ) ; } diff = decoder . decode ( ) ; try { currentRevision = diff . buildRevision ( previousRevision ) ; } catch ( Exception e ) { this . previousRevision = null ; logger . error ( STR_ + STR_ + result . getInt ( NUM_ ) + STR_ + result . getInt ( NUM_ ) + STR_ + result . getInt ( NUM_ ) + STR_ ) ; return null ; } previousRevision = currentRevision ; revision . setRevisionText ( currentRevision ) ; } else { if ( revApi == null ) { revApi = new RevisionApi ( config ) ; } revision . setRevisionApi ( revApi ) ; } revision . setRevisionID ( result . getInt ( NUM_ ) ) ; revision . setArticleID ( articleID ) ; revision . setTimeStamp ( new Timestamp ( result . getLong ( NUM_ ) ) ) ; revision . setFullRevisionID ( result . getInt ( NUM_ ) ) ; revision . setContributorName ( result . getString ( NUM_ ) ) ; revision . setContributorId ( result . getInt ( NUM_ ) ) ; revision . setComment ( result . getString ( NUM_ ) ) ; revision . setMinor ( result . getBoolean ( NUM_ ) ) ; revision . setContributorIsRegistered ( result . getBoolean ( NUM_ ) ) ; return revision ; } catch ( DecodingException e ) { throw new RuntimeException ( e ) ; } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } catch ( WikiApiException e ) { throw new RuntimeException ( e ) ; } }
public void addSelectionColumn ( GridField mField ) { log . config ( mField . getHeader ( ) ) ; int displayLength = mField . getDisplayLength ( ) ; if ( displayLength <= NUM_ || displayLength > FIELDLENGTH ) mField . setDisplayLength ( FIELDLENGTH ) ; else displayLength = NUM_ ; WEditor editor = null ; Label label = null ; Row panel = new Row ( ) ; contentSimpleRows . appendChild ( panel ) ; if ( mField . isRange ( ) ) { Hbox box = new Hbox ( ) ; editor = WebEditorFactory . getEditor ( mField , BOOL_ ) ; label = editor . getLabel ( ) ; editor . setMandatory ( BOOL_ ) ; editor . setReadWrite ( BOOL_ ) ; editor . dynamicDisplay ( ) ; Component fieldLabel = editor . getComponent ( ) ; box . appendChild ( editor . getComponent ( ) ) ; rangeFirstEditor . add ( mField . getColumnName ( ) ) ; WEditor toRangeEditor = WebEditorFactory . getEditor ( mField , BOOL_ ) ; toRangeEditor . setMandatory ( BOOL_ ) ; toRangeEditor . setReadWrite ( BOOL_ ) ; toRangeEditor . dynamicDisplay ( ) ; m_sEditors2 . add ( toRangeEditor ) ; Label separator = new Label ( STR_ ) ; box . appendChild ( separator ) ; Component fieldLabel1 = toRangeEditor . getComponent ( ) ; box . appendChild ( toRangeEditor . getComponent ( ) ) ; if ( displayLength > NUM_ ) mField . setDisplayLength ( displayLength ) ; if ( isTwoColumns ) { if ( ! isPair ) panel = new Row ( ) ; } else panel = new Row ( ) ; panel . appendChild ( LayoutUtils . makeRightAlign ( label ) ) ; panel . appendChild ( box ) ; fieldLabel . addEventListener ( Events . ON_OK , this ) ; fieldLabel1 . addEventListener ( Events . ON_OK , this ) ; } else { editor = WebEditorFactory . getEditor ( mField , BOOL_ ) ; label = editor . getLabel ( ) ; editor . setMandatory ( BOOL_ ) ; editor . setReadWrite ( BOOL_ ) ; editor . dynamicDisplay ( ) ; Component fieldLabel = editor . getComponent ( ) ; if ( displayLength > NUM_ ) mField . setDisplayLength ( displayLength ) ; panel . appendChild ( LayoutUtils . makeRightAlign ( label ) ) ; panel . appendChild ( fieldLabel ) ; fieldLabel . addEventListener ( Events . ON_OK , this ) ; m_sEditors2 . add ( null ) ; } m_sEditors . add ( editor ) ; }
public void index ( Iterator tuples , String field ) { while ( tuples . hasNext ( ) ) { Tuple t = ( Tuple ) tuples . next ( ) ; index ( t , field ) ; } }
public final static void closeEL ( final OutputStream os ) { try { if ( os != null ) os . close ( ) ; } catch ( final Throwable e ) { } }
public void addSearchListener ( SearchListener l ) { m_SearchListeners . add ( l ) ; }
public boolean isSingleAttributeContainer ( ) { return BOOL_ ; }
public Process executeAsync ( final CommandLine command , Map < String , String > environment ) throws IOException { if ( workingDirectory != null && ! workingDirectory . exists ( ) ) { throw new IOException ( workingDirectory + STR_ ) ; } return executeInternal ( command , environment , workingDirectory , streamHandler , null ) ; }
public CacheSpan touch ( ) { long now = System . currentTimeMillis ( ) ; File newCacheFile = getCacheFileName ( file . getParentFile ( ) , key , position , now ) ; file . renameTo ( newCacheFile ) ; return CacheSpan . createCacheEntry ( key , position , now , newCacheFile ) ; }
private static char [ ] zzUnpackCMap ( String packed ) { char [ ] map = new char [ x10000 ] ; int i = NUM_ ; int j = NUM_ ; while ( i < NUM_ ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM_ ) ; } return map ; }
public void open ( File file ) throws IOException { checkAWTPermission ( ) ; checkExec ( ) ; checkActionSupport ( Action . OPEN ) ; checkFileValidation ( file ) ; peer . open ( file ) ; }
public static String convertISO8601DurationToNormalTime ( String isoTime ) { String formattedTime = new String ( ) ; if ( isoTime . contains ( STR_ ) && isoTime . contains ( STR_ ) && isoTime . contains ( STR_ ) ) { String hours = isoTime . substring ( isoTime . indexOf ( STR_ ) + NUM_ , isoTime . indexOf ( STR_ ) ) ; String minutes = isoTime . substring ( isoTime . indexOf ( STR_ ) + NUM_ , isoTime . indexOf ( STR_ ) ) ; String seconds = isoTime . substring ( isoTime . indexOf ( STR_ ) + NUM_ , isoTime . indexOf ( STR_ ) ) ; formattedTime = hours + STR_ + formatTo2Digits ( minutes ) + STR_ + formatTo2Digits ( seconds ) ; } else if ( ! isoTime . contains ( STR_ ) && isoTime . contains ( STR_ ) && isoTime . contains ( STR_ ) ) { String minutes = isoTime . substring ( isoTime . indexOf ( STR_ ) + NUM_ , isoTime . indexOf ( STR_ ) ) ; String seconds = isoTime . substring ( isoTime . indexOf ( STR_ ) + NUM_ , isoTime . indexOf ( STR_ ) ) ; formattedTime = minutes + STR_ + formatTo2Digits ( seconds ) ; } else if ( isoTime . contains ( STR_ ) && ! isoTime . contains ( STR_ ) && isoTime . contains ( STR_ ) ) { String hours = isoTime . substring ( isoTime . indexOf ( STR_ ) + NUM_ , isoTime . indexOf ( STR_ ) ) ; String seconds = isoTime . substring ( isoTime . indexOf ( STR_ ) + NUM_ , isoTime . indexOf ( STR_ ) ) ; formattedTime = hours + STR_ + formatTo2Digits ( seconds ) ; } else if ( isoTime . contains ( STR_ ) && isoTime . contains ( STR_ ) && ! isoTime . contains ( STR_ ) ) { String hours = isoTime . substring ( isoTime . indexOf ( STR_ ) + NUM_ , isoTime . indexOf ( STR_ ) ) ; String minutes = isoTime . substring ( isoTime . indexOf ( STR_ ) + NUM_ , isoTime . indexOf ( STR_ ) ) ; formattedTime = hours + STR_ + formatTo2Digits ( minutes ) + STR_ ; } else if ( ! isoTime . contains ( STR_ ) && ! isoTime . contains ( STR_ ) && isoTime . contains ( STR_ ) ) { String seconds = isoTime . substring ( isoTime . indexOf ( STR_ ) + NUM_ , isoTime . indexOf ( STR_ ) ) ; formattedTime = STR_ + formatTo2Digits ( seconds ) ; } else if ( ! isoTime . contains ( STR_ ) && isoTime . contains ( STR_ ) && ! isoTime . contains ( STR_ ) ) { String minutes = isoTime . substring ( isoTime . indexOf ( STR_ ) + NUM_ , isoTime . indexOf ( STR_ ) ) ; formattedTime = minutes + STR_ ; } else if ( isoTime . contains ( STR_ ) && ! isoTime . contains ( STR_ ) && ! isoTime . contains ( STR_ ) ) { String hours = isoTime . substring ( isoTime . indexOf ( STR_ ) + NUM_ , isoTime . indexOf ( STR_ ) ) ; formattedTime = hours + STR_ ; } return formattedTime ; }
@ Override public void toggleSelection ( T photo ) { if ( selectedPhotos . contains ( photo ) ) { selectedPhotos . remove ( photo ) ; } else { selectedPhotos . add ( photo ) ; } }
public byte map ( byte src ) { char c = map ( ( char ) src ) ; if ( c < Byte . MIN_VALUE || c > Byte . MAX_VALUE ) { return NUM_ ; } return ( byte ) c ; }
private void translateMatrixAfterRotate ( int axis , float trans , float prevImageSize , float imageSize , int prevViewSize , int viewSize , int drawableSize ) { if ( imageSize < viewSize ) { m [ axis ] = ( viewSize - ( drawableSize . m [ Matrix . MSCALE_X ] ) ) . NUM_ ; } else if ( trans > NUM_ ) { m [ axis ] = - ( ( imageSize - viewSize ) . NUM_ ) ; } else { float percentage = ( Math . abs ( trans ) + ( NUM_ . prevViewSize ) ) / prevImageSize ; m [ axis ] = - ( ( percentage . imageSize ) - ( viewSize . NUM_ ) ) ; } }
public Object produceEvent ( ) throws InvocationTargetException { if ( ! valid ) { throw new IllegalStateException ( toString ( ) + STR_ ) ; } try { return method . invoke ( target ) ; } catch ( IllegalAccessException e ) { throw new AssertionError ( e ) ; } catch ( InvocationTargetException e ) { if ( e . getCause ( ) instanceof Error ) { throw ( Error ) e . getCause ( ) ; } throw e ; } }
public String wrapIfKeywordOrBuiltIn ( String name ) { if ( KEYWORD_BUILT_IN_SET . contains ( name ) ) { return name + STR_ ; } return name ; }
public IssueMatcher add ( ) { IssueMatcher issueMatcher = new IssueMatcher ( ) ; issueMatchers . add ( issueMatcher ) ; return issueMatcher ; }
private < T > InjectScope < T > findScope ( AnnotatedElement annElement ) { for ( Annotation ann : annElement . getAnnotations ( ) ) { Class < ? extends Annotation > annType = ann . annotationType ( ) ; if ( annType . isAnnotationPresent ( Scope . class ) ) { Supplier < InjectScope < T > > scopeGen = ( Supplier ) _scopeMap . get ( annType ) ; if ( scopeGen != null ) { return scopeGen . get ( ) ; } else { log . fine ( L . l ( STR_ , annType . getSimpleName ( ) ) ) ; } } } return new InjectScopeFactory < > ( ) ; }
private static native int [ ] RegOpenKey ( int hKey , byte [ ] subKey , int securityMask ) ;
public void removePropertyChangeListener ( IPropertyChangeListener listener ) { listeners . remove ( listener ) ; }
@ Override public int previous ( ) { CharacterIterator text = getText ( ) ; if ( current ( ) == text . getBeginIndex ( ) ) { return BreakIterator . DONE ; } int start = current ( ) ; int lastResult = cachedLastKnownBreak ; if ( lastResult >= start || lastResult <= BreakIterator . DONE ) { getPrevious ( ) ; lastResult = handlePrevious ( ) ; } else { text . setIndex ( lastResult ) ; } int result = lastResult ; while ( result != BreakIterator . DONE && result < start ) { lastResult = result ; result = handleNext ( ) ; } text . setIndex ( lastResult ) ; cachedLastKnownBreak = lastResult ; return lastResult ; }
public DeferredImageReplacedElement ( ImageResource imageResource , RepaintListener repaintListener , int w , int h ) { this . _imageResource = imageResource ; _loaded = BOOL_ ; this . repaintListener = repaintListener ; if ( w == - NUM_ && h == - NUM_ ) { _doScaleImage = BOOL_ ; _targetHeight = NUM_ ; _targetWidth = NUM_ ; } else { _doScaleImage = BOOL_ ; _targetHeight = Math . max ( NUM_ , h ) ; _targetWidth = Math . max ( NUM_ , w ) ; } _image = ImageUtil . createCompatibleBufferedImage ( _targetWidth , _targetHeight ) ; }
public boolean startsWith ( Name n ) { if ( n instanceof CompoundName ) { return ( impl . startsWith ( n . size ( ) , n . getAll ( ) ) ) ; } else { return BOOL_ ; } }
public ParameterizedGenericMethodBinding ( MethodBinding originalMethod , TypeBinding [ ] typeArguments , LookupEnvironment environment ) { this . environment = environment ; this . modifiers = originalMethod . modifiers ; this . selector = originalMethod . selector ; this . declaringClass = originalMethod . declaringClass ; this . typeVariables = Binding . NO_TYPE_VARIABLES ; this . typeArguments = typeArguments ; this . isRaw = BOOL_ ; this . tagBits = originalMethod . tagBits ; this . originalMethod = originalMethod ; this . parameters = Scope . substitute ( this , originalMethod . parameters ) ; this . returnType = Scope . substitute ( this , originalMethod . returnType ) ; this . thrownExceptions = Scope . substitute ( this , originalMethod . thrownExceptions ) ; if ( this . thrownExceptions == null ) this . thrownExceptions = Binding . NO_EXCEPTIONS ; checkMissingType : { if ( ( this . tagBits & TagBits . HasMissingType ) != NUM_ ) break checkMissingType ; if ( ( this . returnType . tagBits & TagBits . HasMissingType ) != NUM_ ) { this . tagBits |= TagBits . HasMissingType ; break checkMissingType ; } for ( int i = NUM_ , max = this . parameters . length ; i < max ; i ++ ) { if ( ( this . parameters [ i ] . tagBits & TagBits . HasMissingType ) != NUM_ ) { this . tagBits |= TagBits . HasMissingType ; break checkMissingType ; } } for ( int i = NUM_ , max = this . thrownExceptions . length ; i < max ; i ++ ) { if ( ( this . thrownExceptions [ i ] . tagBits & TagBits . HasMissingType ) != NUM_ ) { this . tagBits |= TagBits . HasMissingType ; break checkMissingType ; } } } this . wasInferred = BOOL_ ; }
public void testInvokeAll5 ( ) throws Throwable { ExecutorService e = new ForkJoinPool ( NUM_ ) ; PoolCleaner cleaner = null ; try { cleaner = cleaner ( e ) ; List < Callable < String > > l = new ArrayList < Callable < String > > ( ) ; l . add ( new StringTask ( ) ) ; l . add ( new StringTask ( ) ) ; List < Future < String > > futures = e . invokeAll ( l ) ; assertEquals ( NUM_ , futures . size ( ) ) ; for ( Future < String > future : futures ) assertSame ( TEST_STRING , future . get ( ) ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public InternalListener ( final ConfigManager configFile ) { this . configFile = configFile ; }
public byte [ ] sign ( byte [ ] hash ) { ECDSASigner signer = new ECDSASigner ( new HMacDSAKCalculator ( new SHA256Digest ( ) ) ) ; signer . init ( BOOL_ , new ECPrivateKeyParameters ( priv , domain ) ) ; BigInteger [ ] signature = signer . generateSignature ( hash ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; try { DERSequenceGenerator seq = new DERSequenceGenerator ( baos ) ; seq . addObject ( new ASN1Integer ( signature [ NUM_ ] ) ) ; seq . addObject ( new ASN1Integer ( toCanonicalS ( signature [ NUM_ ] ) ) ) ; seq . close ( ) ; return baos . toByteArray ( ) ; } catch ( IOException e ) { } return null ; }
public TimePeriod ( Date startTime , Date endTime ) { if ( startTime != null && endTime != null && ! endTime . after ( startTime ) ) { throw new IllegalArgumentException ( STR_ + endTime + STR_ + startTime ) ; } this . startTime = startTime ; this . endTime = endTime ; }
JMenu createEditMenu ( ) { JMenu editMenu = new JMenu ( STR_ ) ; editMenu . add ( actionManager . getCutAction ( ) ) ; editMenu . add ( actionManager . getCopyAction ( ) ) ; editMenu . add ( actionManager . getPasteAction ( ) ) ; editMenu . add ( actionManager . getDeleteAction ( ) ) ; editMenu . addSeparator ( ) ; editMenu . add ( actionManager . getClearSourceNeuronsAction ( ) ) ; editMenu . add ( actionManager . getSetSourceNeuronsAction ( ) ) ; editMenu . add ( actionManager . getConnectionMenu ( ) ) ; editMenu . add ( actionManager . getAddSynapseGroupAction ( ) ) ; editMenu . addSeparator ( ) ; editMenu . add ( actionManager . getRandomizeObjectsAction ( ) ) ; editMenu . add ( actionManager . getShowAdjustSynapsesDialog ( ) ) ; editMenu . addSeparator ( ) ; editMenu . add ( actionManager . getLayoutMenu ( ) ) ; editMenu . add ( actionManager . getGroupMenu ( ) ) ; editMenu . addSeparator ( ) ; editMenu . add ( createAlignMenu ( ) ) ; editMenu . add ( createSpacingMenu ( ) ) ; editMenu . addSeparator ( ) ; editMenu . add ( actionManager . getSetNeuronPropertiesAction ( ) ) ; editMenu . add ( actionManager . getSetSynapsePropertiesAction ( ) ) ; editMenu . addSeparator ( ) ; editMenu . add ( createSelectionMenu ( ) ) ; return editMenu ; }
public void removeHistoryChangedListener ( HistoryChangedListener l ) { m_HistoryChangedListeners . remove ( l ) ; }
public void currentState ( long state , Model currentModel ) { currentState = state ; if ( loggers != null ) { for ( Logger logger : loggers ) { logger . log ( state ) ; } } }
public boolean isBOM ( ) { return m_isBOM ; }
public boolean isSigned ( ) { return signed ; }
public Object parseText ( String text ) { if ( text == null || text . length ( ) == NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } return parse ( new LineColumnReader ( new StringReader ( text ) ) ) ; }
public int size ( ) { return parts . size ( ) ; }
protected < T > Database makeSimpleDatabase ( String filename , int expectedSize , ListParameterization params , Class < ? > [ ] filters ) { try ( InputStream is = open ( filename ) ) { List < ObjectFilter > filterlist = new ArrayList < > ( ) ; filterlist . add ( new FixedDBIDsFilter ( NUM_ ) ) ; if ( filters != null ) { for ( Class < ? > filtercls : filters ) { ObjectFilter filter = ClassGenericsUtil . parameterizeOrAbort ( filtercls , params ) ; filterlist . add ( filter ) ; } } NumberVectorLabelParser < DoubleVector > parser = new NumberVectorLabelParser < > ( DoubleVector . FACTORY ) ; InputStreamDatabaseConnection dbc = new InputStreamDatabaseConnection ( is , filterlist , parser ) ; params . addParameter ( AbstractDatabase . Parameterizer . DATABASE_CONNECTION_ID , dbc ) ; Database db = ClassGenericsUtil . parameterizeOrAbort ( StaticArrayDatabase . class , params ) ; testParameterizationOk ( params ) ; db . initialize ( ) ; Relation < ? > rel = db . getRelation ( TypeUtil . ANY ) ; assertEquals ( STR_ , expectedSize , rel . size ( ) ) ; return db ; } catch ( IOException e ) { fail ( STR_ + filename + STR_ ) ; return null ; } }
protected void addChooserFilters ( JFileChooser chooser ) { javax . swing . filechooser . FileNameExtensionFilter filter ; chooser . addChoosableFileFilter ( filter = new javax . swing . filechooser . FileNameExtensionFilter ( STR_ , STR_ ) ) ; chooser . setFileFilter ( filter ) ; }
public void onStop ( ) { if ( null != mService ) { if ( null != mContext ) { mContext . unbindService ( mServiceConnection ) ; } mServiceConnection = null ; mService = null ; } }
public String peek ( ) { String result = null ; if ( isEmpty ( ) ) { return null ; } else { int cachedCurrentIndex = currentIndex ; if ( isEatingBlocksOfDelimiters ) { trimStartingDelimiters ( ) ; } int nearestDelimeter = - NUM_ ; for ( int i = NUM_ ; i < delimiters . length ( ) ; i ++ ) { int delimiter = source . indexOf ( delimiters . charAt ( i ) , currentIndex ) ; if ( nearestDelimeter == - NUM_ || delimiter != - NUM_ && delimiter < nearestDelimeter ) { nearestDelimeter = delimiter ; } } if ( nearestDelimeter == - NUM_ ) { result = source . substring ( currentIndex ) ; } else { result = source . substring ( currentIndex , nearestDelimeter ) ; } currentIndex = cachedCurrentIndex ; } return result ; }
private void eliminarUsuariosOrgano ( GestionOrganizacionBI organizacionBI , OrganizacionVO organizacionVO ) { organizacionBI . eliminarUsuariosOrgano ( organizacionVO . getId ( ) ) ; }
private static void addPreviousLayer ( List < List < Neuron > > layers , List < Neuron > sourceLayer , List < Neuron > layerToCheck ) { final int MAXLAYERS = NUM_ ; Set < Neuron > newLayerTemp = new HashSet < Neuron > ( ) ; boolean theNextLayerIsTheSourceLayer = BOOL_ ; for ( Neuron neuron : layerToCheck ) { for ( Synapse synapse : neuron . getFanIn ( ) ) { Neuron sourceNeuron = synapse . getSource ( ) ; if ( sourceLayer . contains ( sourceNeuron ) ) { theNextLayerIsTheSourceLayer = BOOL_ ; } if ( sourceNeuron == neuron ) { continue ; } newLayerTemp . add ( synapse . getSource ( ) ) ; } } if ( ( theNextLayerIsTheSourceLayer ) || ( newLayerTemp . size ( ) == NUM_ ) || ( layers . size ( ) > MAXLAYERS ) ) { layers . add ( sourceLayer ) ; } else { List < Neuron > newLayer = new ArrayList < Neuron > ( newLayerTemp ) ; Collections . sort ( newLayer , OrientationComparator . X_ORDER ) ; layers . add ( newLayer ) ; addPreviousLayer ( layers , sourceLayer , newLayer ) ; } }
public void testShiftRight2 ( ) { byte aBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int number = - NUM_ ; byte rBytes [ ] = { NUM_ , NUM_ , - NUM_ , NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , - NUM_ , NUM_ , - NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger result = aNumber . shiftRight ( number ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public static void ignorm ( double c1 [ ] , double c2 [ ] , int m , double ng ) { if ( ng != NUM_ ) { double k = Math . pow ( c1 [ NUM_ ] , ng ) ; for ( int i = m ; i >= NUM_ ; i -- ) c2 [ i ] = k . c1 [ i ] ; c2 [ NUM_ ] = ( k - NUM_ ) / ng ; } else { System . arraycopy ( c1 , NUM_ , c2 , NUM_ , m - NUM_ ) ; c2 [ NUM_ ] = Math . log ( c1 [ NUM_ ] ) ; } }
public static int findNonwhitespaceCharacter ( String s , int index ) { int sLength = s . length ( ) ; while ( index < sLength && Character . isWhitespace ( s . charAt ( index ) ) ) { index ++ ; } return index ; }
public void readContent ( ) throws IOException { if ( offset + length > buffer . length ) { throw new ASN1Exception ( STR_ ) ; } if ( in == null ) { offset += length ; } else { int bytesRead = in . read ( buffer , offset , length ) ; if ( bytesRead != length ) { int c = bytesRead ; do { if ( c < NUM_ || bytesRead > length ) { throw new ASN1Exception ( STR_ ) ; } c = in . read ( buffer , offset + bytesRead , length - bytesRead ) ; bytesRead += c ; } while ( bytesRead != length ) ; } offset += length ; } }
public Primitive ( Object value ) { this . value = value ; type = ( value != null ) ? Utilities . getPrimitiveType ( value . getClass ( ) ) : null ; if ( type == null ) { throw new IllegalArgumentException ( STR_ + value ) ; } }
public void createCashBasedJournalEntriesAndReversalsForSavingsTax ( final Office office , final String currencyCode , final CASH_ACCOUNTS_FOR_SAVINGS accountTypeToBeDebited , final CASH_ACCOUNTS_FOR_SAVINGS accountTypeToBeCredited , final Long savingsProductId , final Long paymentTypeId , final Long savingsId , final String transactionId , final Date transactionDate , final BigDecimal amount , final Boolean isReversal , final List < TaxPaymentDTO > taxDetails ) { for ( TaxPaymentDTO taxPaymentDTO : taxDetails ) { if ( taxPaymentDTO . getAmount ( ) != null ) { if ( taxPaymentDTO . getCreditAccountId ( ) == null ) { createCashBasedCreditJournalEntriesAndReversalsForSavings ( office , currencyCode , accountTypeToBeCredited . getValue ( ) , savingsProductId , paymentTypeId , savingsId , transactionId , transactionDate , taxPaymentDTO . getAmount ( ) , isReversal ) ; } else { createCashBasedCreditJournalEntriesAndReversalsForSavings ( office , currencyCode , taxPaymentDTO . getCreditAccountId ( ) , savingsId , transactionId , transactionDate , taxPaymentDTO . getAmount ( ) , isReversal ) ; } } } createCashBasedDebitJournalEntriesAndReversalsForSavings ( office , currencyCode , accountTypeToBeDebited . getValue ( ) , savingsProductId , paymentTypeId , savingsId , transactionId , transactionDate , amount , isReversal ) ; }
public int read ( ByteBuf dst , int dstStart , int dstLength ) throws IOException { final int remaining = ( int ) Math . min ( this . length - this . position , Integer . MAX_VALUE ) ; final int read = Math . min ( remaining , dstLength ) ; final int bufferPosition = checkOffset ( position , read ) ; final long srcAddress = PlatformDependent . directBufferAddress ( lastMapped ) + bufferPosition ; if ( dst . hasMemoryAddress ( ) ) { final long dstAddress = dst . memoryAddress ( ) + dstStart ; PlatformDependent . copyMemory ( srcAddress , dstAddress , read ) ; } else if ( dst . hasArray ( ) ) { final byte [ ] dstArray = dst . array ( ) ; PlatformDependent . copyMemory ( srcAddress , dstArray , dstStart , read ) ; } else { throw new IllegalArgumentException ( STR_ ) ; } position += read ; return read ; }
public static Calendar clearTime ( final Calendar self ) { clearTimeCommon ( self ) ; return self ; }
public double pdf ( int k ) { return Math . exp ( k . Math . log ( this . mean ) - Arithmetic . logFactorial ( k ) - this . mean ) ; }
public static void appendUnpaddedInteger ( StringBuffer buf , long value ) { int intValue = ( int ) value ; if ( intValue == value ) { appendUnpaddedInteger ( buf , intValue ) ; } else { buf . append ( Long . toString ( value ) ) ; } }
private void drawTextElements ( Canvas canvas , float textSize , Typeface typeface , ColorStateList textColor , String [ ] texts , float [ ] textX , float [ ] textY , Paint paint , int alpha , boolean showActivated , int activatedDegrees , boolean activatedOnly ) { paint . setTextSize ( textSize ) ; paint . setTypeface ( typeface ) ; final float activatedIndex = activatedDegrees / ( NUM_ / NUM_POSITIONS ) ; final int activatedFloor = ( int ) activatedIndex ; final int activatedCeil = ( ( int ) Math . ceil ( activatedIndex ) ) % NUM_POSITIONS ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { final boolean activated = ( activatedFloor == i || activatedCeil == i ) ; if ( activatedOnly && ! activated ) { continue ; } final int [ ] stateMask = new int [ ] { android . R . attr . state_enabled , ( showActivated && activated ? android . R . attr . state_selected : NUM_ ) } ; final int color = textColor . getColorForState ( stateMask , NUM_ ) ; paint . setColor ( color ) ; paint . setAlpha ( getMultipliedAlpha ( color , alpha ) ) ; canvas . drawText ( texts [ i ] , textX [ i ] , textY [ i ] , paint ) ; } }
public void testFindSpringActiveDirectoryWithLimit ( ) { LdapProxy proxy = getLdapAD ( ) ; List result = null ; int limit = NUM_ ; try { result = proxy . find ( getLdapSearchVO ( STR_ , limit , STR_ , STR_ , null , LdapScopeConstants . SCOPE_SUBTREE ) ) ; } catch ( Exception e ) { } assertNotNull ( result ) ; if ( result != null ) { assertEquals ( limit , result . size ( ) ) ; } }
@ Override public void handleKey ( int virtualKeyCode , int transitionState , char keyChar ) { switchControlKeys ( virtualKeyCode , transitionState ) ; inputBuffer . add ( new GlobalKeyEvent ( this , virtualKeyCode , transitionState , keyChar , menuPressed , shiftPressed , controlPressed , extendedKey ) ) ; }
public int hashCode ( ) { return alignment ^ leader ^ Math . round ( position ) ; }
public static String stripLeadingPeriod ( String s ) { if ( null != s && s . startsWith ( STR_ ) ) return s . substring ( Math . min ( NUM_ , s . length ( ) ) , s . length ( ) ) ; return s ; }
public static boolean isRequiredConfigDirectory ( final String directory ) { return requiredConfigDirectories . contains ( directory ) ; }
protected ConnectionStateSSLv3 ( SSLSessionImpl session ) { try { CipherSuite cipherSuite = session . cipherSuite ; boolean is_exportabe = cipherSuite . isExportable ( ) ; hash_size = cipherSuite . getMACLength ( ) ; int key_size = ( is_exportabe ) ? cipherSuite . keyMaterial : cipherSuite . expandedKeyMaterial ; int iv_size = cipherSuite . ivSize ; block_size = cipherSuite . getBlockSize ( ) ; String algName = cipherSuite . getBulkEncryptionAlgorithm ( ) ; String hashName = cipherSuite . getHashName ( ) ; if ( logger != null ) { logger . println ( STR_ ) ; logger . println ( STR_ + session . getCipherSuite ( ) ) ; logger . println ( STR_ + algName ) ; logger . println ( STR_ + hashName ) ; logger . println ( STR_ + hash_size ) ; logger . println ( STR_ + block_size ) ; logger . println ( STR_ + iv_size ) ; logger . println ( STR_ + key_size ) ; } byte [ ] clientRandom = session . clientRandom ; byte [ ] serverRandom = session . serverRandom ; byte [ ] key_block = new byte [ NUM_ . hash_size + NUM_ . key_size + NUM_ . iv_size ] ; byte [ ] seed = new byte [ clientRandom . length + serverRandom . length ] ; System . arraycopy ( serverRandom , NUM_ , seed , NUM_ , serverRandom . length ) ; System . arraycopy ( clientRandom , NUM_ , seed , serverRandom . length , clientRandom . length ) ; PRF . computePRF_SSLv3 ( key_block , session . master_secret , seed ) ; byte [ ] client_mac_secret = new byte [ hash_size ] ; byte [ ] server_mac_secret = new byte [ hash_size ] ; byte [ ] client_key = new byte [ key_size ] ; byte [ ] server_key = new byte [ key_size ] ; boolean is_client = ! session . isServer ; System . arraycopy ( key_block , NUM_ , client_mac_secret , NUM_ , hash_size ) ; System . arraycopy ( key_block , hash_size , server_mac_secret , NUM_ , hash_size ) ; System . arraycopy ( key_block , NUM_ . hash_size , client_key , NUM_ , key_size ) ; System . arraycopy ( key_block , NUM_ . hash_size + key_size , server_key , NUM_ , key_size ) ; IvParameterSpec clientIV = null ; IvParameterSpec serverIV = null ; if ( is_exportabe ) { if ( logger != null ) { logger . println ( STR_ ) ; } MessageDigest md5 = MessageDigest . getInstance ( STR_ ) ; md5 . update ( client_key ) ; md5 . update ( clientRandom ) ; md5 . update ( serverRandom ) ; client_key = md5 . digest ( ) ; md5 . update ( server_key ) ; md5 . update ( serverRandom ) ; md5 . update ( clientRandom ) ; server_key = md5 . digest ( ) ; key_size = cipherSuite . expandedKeyMaterial ; if ( block_size != NUM_ ) { md5 . update ( clientRandom ) ; md5 . update ( serverRandom ) ; clientIV = new IvParameterSpec ( md5 . digest ( ) , NUM_ , iv_size ) ; md5 . update ( serverRandom ) ; md5 . update ( clientRandom ) ; serverIV = new IvParameterSpec ( md5 . digest ( ) , NUM_ , iv_size ) ; } } else if ( block_size != NUM_ ) { clientIV = new IvParameterSpec ( key_block , NUM_ . hash_size + NUM_ . key_size , iv_size ) ; serverIV = new IvParameterSpec ( key_block , NUM_ . hash_size + NUM_ . key_size + iv_size , iv_size ) ; } if ( logger != null ) { logger . println ( STR_ + is_exportabe ) ; logger . println ( STR_ ) ; logger . print ( session . master_secret ) ; logger . println ( STR_ ) ; logger . print ( clientRandom ) ; logger . println ( STR_ ) ; logger . print ( serverRandom ) ; logger . println ( STR_ ) ; logger . print ( client_mac_secret ) ; logger . println ( STR_ ) ; logger . print ( server_mac_secret ) ; logger . println ( STR_ ) ; logger . print ( client_key , NUM_ , key_size ) ; logger . println ( STR_ ) ; logger . print ( server_key , NUM_ , key_size ) ; if ( clientIV != null ) { logger . println ( STR_ ) ; logger . print ( clientIV . getIV ( ) ) ; logger . println ( STR_ ) ; logger . print ( serverIV . getIV ( ) ) ; } else { logger . println ( STR_ ) ; } } if ( algName == null ) { encCipher = new NullCipher ( ) ; decCipher = new NullCipher ( ) ; } else { encCipher = Cipher . getInstance ( algName ) ; decCipher = Cipher . getInstance ( algName ) ; if ( is_client ) { encCipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( client_key , NUM_ , key_size , algName ) , clientIV ) ; decCipher . init ( Cipher . DECRYPT_MODE , new SecretKeySpec ( server_key , NUM_ , key_size , algName ) , serverIV ) ; } else { encCipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( server_key , NUM_ , key_size , algName ) , serverIV ) ; decCipher . init ( Cipher . DECRYPT_MODE , new SecretKeySpec ( client_key , NUM_ , key_size , algName ) , clientIV ) ; } } messageDigest = MessageDigest . getInstance ( hashName ) ; if ( is_client ) { mac_write_secret = client_mac_secret ; mac_read_secret = server_mac_secret ; } else { mac_write_secret = server_mac_secret ; mac_read_secret = client_mac_secret ; } if ( hashName . equals ( STR_ ) ) { pad_1 = SSLv3Constants . MD5pad1 ; pad_2 = SSLv3Constants . MD5pad2 ; } else { pad_1 = SSLv3Constants . SHApad1 ; pad_2 = SSLv3Constants . SHApad2 ; } } catch ( Exception e ) { e . printStackTrace ( ) ; throw new AlertException ( AlertProtocol . INTERNAL_ERROR , new SSLProtocolException ( STR_ ) ) ; } }
private void updateBaseMatrix ( Drawable d ) { ImageView imageView = getImageView ( ) ; if ( null == imageView || null == d ) { return ; } final float viewWidth = getImageViewWidth ( imageView ) ; final float viewHeight = getImageViewHeight ( imageView ) ; final int drawableWidth = d . getIntrinsicWidth ( ) ; final int drawableHeight = d . getIntrinsicHeight ( ) ; mBaseMatrix . reset ( ) ; final float widthScale = viewWidth / drawableWidth ; final float heightScale = viewHeight / drawableHeight ; if ( mScaleType == ScaleType . CENTER ) { mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth ) / NUM_ , ( viewHeight - drawableHeight ) / NUM_ ) ; } else if ( mScaleType == ScaleType . CENTER_CROP ) { float scale = Math . max ( widthScale , heightScale ) ; mBaseMatrix . postScale ( scale , scale ) ; mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth . scale ) / NUM_ , ( viewHeight - drawableHeight . scale ) / NUM_ ) ; } else if ( mScaleType == ScaleType . CENTER_INSIDE ) { float scale = Math . min ( NUM_ , Math . min ( widthScale , heightScale ) ) ; mBaseMatrix . postScale ( scale , scale ) ; mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth . scale ) / NUM_ , ( viewHeight - drawableHeight . scale ) / NUM_ ) ; } else { RectF mTempSrc = new RectF ( NUM_ , NUM_ , drawableWidth , drawableHeight ) ; RectF mTempDst = new RectF ( NUM_ , NUM_ , viewWidth , viewHeight ) ; switch ( mScaleType ) { case FIT_CENTER : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . CENTER ) ; break ; case FIT_START : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . START ) ; break ; case FIT_END : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . END ) ; break ; case FIT_XY : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . FILL ) ; break ; default : break ; } } resetMatrix ( ) ; }
private void cleanUpLabels ( ) { int id = NUM_ ; for ( Iterator < Label > i = labels . iterator ( ) ; i . hasNext ( ) ; ) { Label label = i . next ( ) ; if ( label . isEmpty ( ) ) { i . remove ( ) ; } else { label . compact ( ) ; label . id = id ++ ; } } }
public static long nanosFromDate ( long ms ) { Calendar cal = getCalendar ( ) ; cal . setTimeInMillis ( ms ) ; return nanosFromCalendar ( cal ) ; }
@ Override default CompletableFuture < OptionalLong > maxLong ( final ToLongFunction < ? super T > fn ) { return CompletableFuture . supplyAsync ( null , getExec ( ) ) ; }
protected BalancedWebResource createHttpsClient ( final String username , final String password , List < String > hosts ) throws NoSuchAlgorithmException { return createHttpsClient ( username , password , hosts , BOOL_ ) ; }
public static char [ ] createArraySignature ( char [ ] typeSignature , int arrayCount ) { if ( arrayCount == NUM_ ) return typeSignature ; int sigLength = typeSignature . length ; char [ ] result = new char [ arrayCount + sigLength ] ; for ( int i = NUM_ ; i < arrayCount ; i ++ ) { result [ i ] = C_ARRAY ; } System . arraycopy ( typeSignature , NUM_ , result , arrayCount , sigLength ) ; return result ; }
public void println ( ) throws IOException { writer . write ( format . getLineSeparator ( ) ) ; }
private void handleEnumeratedAttribute ( Instances trainInstances ) throws Exception { Instance instance ; m_distribution = new Distribution ( m_complexityIndex , trainInstances . numClasses ( ) ) ; Enumeration < Instance > enu = trainInstances . enumerateInstances ( ) ; while ( enu . hasMoreElements ( ) ) { instance = enu . nextElement ( ) ; if ( ! instance . isMissing ( m_attIndex ) ) { m_distribution . add ( ( int ) instance . value ( m_attIndex ) , instance ) ; } } if ( m_distribution . check ( m_minNoObj ) ) { m_numSubsets = m_complexityIndex ; m_infoGain = infoGainCrit . splitCritValue ( m_distribution , m_sumOfWeights ) ; m_gainRatio = gainRatioCrit . splitCritValue ( m_distribution , m_sumOfWeights , m_infoGain ) ; } }
private boolean isLoadMore ( ) { return mNextLoadEnable && pageSize != - NUM_ && mRequestLoadMoreListener != null && mData . size ( ) >= pageSize ; }
private void addWorkerIfNecessary ( ) { if ( idleWorkers . get ( ) == NUM_ ) { synchronized ( workers ) { if ( workers . isEmpty ( ) || ( idleWorkers . get ( ) == NUM_ ) ) { addWorker ( ) ; } } } }
@ Override protected Node removeFromFrontier ( ) { Node result = frontier . remove ( ) ; frontierNodeLookup . remove ( result . getState ( ) ) ; explored . add ( result . getState ( ) ) ; updateMetrics ( frontier . size ( ) ) ; return result ; }
public static String encode ( byte [ ] data ) { int start = NUM_ ; int len = data . length ; StringBuffer buf = new StringBuffer ( data . length . NUM_ / NUM_ ) ; int end = len - NUM_ ; int i = start ; int n = NUM_ ; while ( i <= end ) { int d = ( ( ( ( int ) data [ i ] ) & x0ff ) << NUM_ ) | ( ( ( ( int ) data [ i + NUM_ ] ) & x0ff ) << NUM_ ) | ( ( ( int ) data [ i + NUM_ ] ) & x0ff ) ; buf . append ( legalChars [ ( d > > NUM_ ) & NUM_ ] ) ; buf . append ( legalChars [ ( d > > NUM_ ) & NUM_ ] ) ; buf . append ( legalChars [ ( d > > NUM_ ) & NUM_ ] ) ; buf . append ( legalChars [ d & NUM_ ] ) ; i += NUM_ ; if ( n ++ >= NUM_ ) { n = NUM_ ; } } if ( i == start + len - NUM_ ) { int d = ( ( ( ( int ) data [ i ] ) & x0ff ) << NUM_ ) | ( ( ( ( int ) data [ i + NUM_ ] ) & NUM_ ) << NUM_ ) ; buf . append ( legalChars [ ( d > > NUM_ ) & NUM_ ] ) ; buf . append ( legalChars [ ( d > > NUM_ ) & NUM_ ] ) ; buf . append ( legalChars [ ( d > > NUM_ ) & NUM_ ] ) ; buf . append ( STR_ ) ; } else if ( i == start + len - NUM_ ) { int d = ( ( ( int ) data [ i ] ) & x0ff ) << NUM_ ; buf . append ( legalChars [ ( d > > NUM_ ) & NUM_ ] ) ; buf . append ( legalChars [ ( d > > NUM_ ) & NUM_ ] ) ; buf . append ( STR_ ) ; } return buf . toString ( ) ; }
public static Font createBitmapFont ( String name , Image bitmap , int [ ] cutOffsets , int [ ] charWidth , String charsets ) { Font f = createBitmapFont ( bitmap , cutOffsets , charWidth , charsets ) ; bitmapCache . put ( name , f ) ; return f ; }
static boolean isTenured ( MemoryPoolMXBean memoryPoolMXBean ) { if ( memoryPoolMXBean . getType ( ) != MemoryType . HEAP ) { return BOOL_ ; } String name = memoryPoolMXBean . getName ( ) ; return name . equals ( STR_ ) || name . equals ( STR_ ) || name . equals ( STR_ ) || name . equals ( STR_ ) || name . equals ( STR_ ) || name . equals ( STR_ ) || name . equals ( STR_ ) || ( HEAP_POOL != null && name . equals ( HEAP_POOL ) ) ; }
public String toSimpleString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( STR_ + ( mLabel == null ? STR_ : mLabel ) + STR_ + mYVals . size ( ) + STR_ ) ; return buffer . toString ( ) ; }
public static < T > T interpreterOnly ( Callable < T > callable ) throws Exception { return callable . call ( ) ; }
public static List < String > tokenize ( String arguments , boolean stringify ) { LinkedList < String > argList = new LinkedList < String > ( ) ; StringBuilder currArg = new StringBuilder ( ) ; boolean escaped = BOOL_ ; int state = NO_TOKEN_STATE ; int len = arguments . length ( ) ; for ( int i = NUM_ ; i < len ; i ++ ) { char c = arguments . charAt ( i ) ; if ( escaped ) { escaped = BOOL_ ; currArg . append ( c ) ; } else { switch ( state ) { case SINGLE_QUOTE_STATE : if ( c == STR_ ) { state = NORMAL_TOKEN_STATE ; } else { currArg . append ( c ) ; } break ; case DOUBLE_QUOTE_STATE : if ( c == STR_ ) { state = NORMAL_TOKEN_STATE ; } else if ( c == STR_ ) { i ++ ; char next = arguments . charAt ( i ) ; if ( next == STR_ || next == STR_ ) { currArg . append ( next ) ; } else { currArg . append ( c ) ; currArg . append ( next ) ; } } else { currArg . append ( c ) ; } break ; case NO_TOKEN_STATE : case NORMAL_TOKEN_STATE : switch ( c ) { case STR_ : escaped = BOOL_ ; state = NORMAL_TOKEN_STATE ; break ; case STR_ : state = SINGLE_QUOTE_STATE ; break ; case STR_ : state = DOUBLE_QUOTE_STATE ; break ; default : if ( ! Character . isWhitespace ( c ) ) { currArg . append ( c ) ; state = NORMAL_TOKEN_STATE ; } else if ( state == NORMAL_TOKEN_STATE ) { argList . add ( currArg . toString ( ) ) ; currArg = new StringBuilder ( ) ; state = NO_TOKEN_STATE ; } } break ; default : throw new IllegalStateException ( STR_ + state + STR_ ) ; } } } if ( escaped ) { currArg . append ( STR_ ) ; argList . add ( currArg . toString ( ) ) ; } else if ( state != NO_TOKEN_STATE ) { argList . add ( currArg . toString ( ) ) ; } if ( stringify ) { for ( int i = NUM_ ; i < argList . size ( ) ; i ++ ) { argList . set ( i , STR_ + _escapeQuotesAndBackslashes ( argList . get ( i ) ) + STR_ ) ; } } return argList ; }
private void addSelectorForProtocol ( Properties settings , String protocol , ProtocolDispatchSelector ps ) { String proxy = settings . getProperty ( protocol ) ; if ( proxy != null ) { FixedProxySelector protocolSelector = ProxyUtil . parseProxySettings ( proxy ) ; ps . setSelector ( protocol , protocolSelector ) ; } }
public void addHeader ( String name , String value ) { header . put ( name , value ) ; }
public static void readSkel ( BufferedReader reader ) throws IOException { List < String > lines = new ArrayList < String > ( ) ; StringBuilder section = new StringBuilder ( ) ; String ln ; while ( ( ln = reader . readLine ( ) ) != null ) { if ( ln . startsWith ( STR_ ) ) { lines . add ( section . toString ( ) ) ; section . setLength ( NUM_ ) ; } else { section . append ( ln ) ; section . append ( NL ) ; } } if ( section . length ( ) > NUM_ ) lines . add ( section . toString ( ) ) ; if ( lines . size ( ) != size ) { Out . error ( ErrorMessages . WRONG_SKELETON ) ; throw new GeneratorException ( ) ; } line = new String [ size ] ; for ( int i = NUM_ ; i < size ; i ++ ) line [ i ] = lines . get ( i ) ; }
public static Set < String > nonMonogamousSamples ( Collection < Family > families ) { final LinkedHashSet < String > ret = new LinkedHashSet < > ( ) ; final HashSet < String > parents = new HashSet < > ( ) ; for ( Family f : families ) { if ( ! parents . add ( f . getFather ( ) ) ) { ret . add ( f . getFather ( ) ) ; } if ( ! parents . add ( f . getMother ( ) ) ) { ret . add ( f . getMother ( ) ) ; } } return ret ; }
public boolean contains ( File file , String fileContent ) { if ( exists ( file ) ) { String content = readFileContent ( file ) ; return content != null && content . equals ( fileContent ) ; } return BOOL_ ; }
public static boolean [ ] [ ] loadImage ( File file , char offChar ) throws FileNotFoundException , RuntimeException { ArrayList < String > rows = loadImagePad ( file , offChar ) ; String s = rows . get ( NUM_ ) ; boolean [ ] [ ] img = new boolean [ rows . size ( ) ] [ s . length ( ) ] ; for ( int i = NUM_ ; i < rows . size ( ) ; i ++ ) { s = rows . get ( i ) ; for ( int j = NUM_ ; j < s . length ( ) ; j ++ ) { char c = s . charAt ( j ) ; if ( c == offChar ) { img [ i ] [ j ] = BOOL_ ; } else { img [ i ] [ j ] = BOOL_ ; } } } return img ; }
protected void updateReceiptStatusWhenCancelled ( final String receiptNumber ) { final List < EgdmCollectedReceipt > egdmCollectedReceipts = demandGenericDAO . getAllEgdmCollectedReceipts ( receiptNumber ) ; if ( egdmCollectedReceipts != null && ! egdmCollectedReceipts . isEmpty ( ) ) for ( final EgdmCollectedReceipt egDmCollectedReceipt : egdmCollectedReceipts ) { egDmCollectedReceipt . setStatus ( DemandConstants . CANCELLED_RECEIPT ) ; egDmCollectedReceipt . setUpdatedTime ( new Date ( ) ) ; egdmCollectedReceiptDAO . update ( egDmCollectedReceipt ) ; } }
public void addAnimation ( int id , Animation ... animations ) { if ( mAnimations . get ( id ) == null ) { mAnimations . put ( id , new ArrayList < Animation > ( animations . length ) ) ; if ( id != Animation . FULL_PAGE ) { mAnimatedViews . add ( id ) ; } } ArrayList < Animation > anims = mAnimations . get ( id ) ; Collections . addAll ( anims , animations ) ; }
private void cleanupDiscovery ( StorageSystem system ) { try { system . setReachableStatus ( BOOL_ ) ; _dbClient . persistObject ( system ) ; } catch ( DatabaseException e ) { _logger . error ( STR_ , e ) ; } }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
@ Override public SSLEngineResult wrap ( ByteBuffer [ ] srcs , int offset , int len , ByteBuffer dst ) throws SSLException { if ( engine_was_shutteddown ) { return new SSLEngineResult ( SSLEngineResult . Status . CLOSED , SSLEngineResult . HandshakeStatus . NOT_HANDSHAKING , NUM_ , NUM_ ) ; } if ( ( srcs == null ) || ( dst == null ) ) { throw new IllegalStateException ( STR_ ) ; } if ( dst . isReadOnly ( ) ) { throw new ReadOnlyBufferException ( ) ; } if ( ! handshake_started ) { beginHandshake ( ) ; } SSLEngineResult . HandshakeStatus handshakeStatus = getHandshakeStatus ( ) ; if ( ( session == null || engine_was_closed ) && ( handshakeStatus . equals ( SSLEngineResult . HandshakeStatus . NEED_UNWRAP ) || handshakeStatus . equals ( SSLEngineResult . HandshakeStatus . NEED_TASK ) ) ) { return new SSLEngineResult ( getEngineStatus ( ) , handshakeStatus , NUM_ , NUM_ ) ; } int capacity = dst . remaining ( ) ; int produced = NUM_ ; if ( alertProtocol . hasAlert ( ) ) { if ( capacity < recordProtocol . getRecordSize ( NUM_ ) ) { return new SSLEngineResult ( SSLEngineResult . Status . BUFFER_OVERFLOW , handshakeStatus , NUM_ , NUM_ ) ; } byte [ ] alert_data = alertProtocol . wrap ( ) ; dst . put ( alert_data ) ; if ( alertProtocol . isFatalAlert ( ) ) { alertProtocol . setProcessed ( ) ; if ( session != null ) { session . invalidate ( ) ; } shutdown ( ) ; return new SSLEngineResult ( SSLEngineResult . Status . CLOSED , SSLEngineResult . HandshakeStatus . NOT_HANDSHAKING , NUM_ , alert_data . length ) ; } else { alertProtocol . setProcessed ( ) ; if ( close_notify_was_sent && close_notify_was_received ) { shutdown ( ) ; return new SSLEngineResult ( SSLEngineResult . Status . CLOSED , SSLEngineResult . HandshakeStatus . NOT_HANDSHAKING , NUM_ , alert_data . length ) ; } return new SSLEngineResult ( getEngineStatus ( ) , getHandshakeStatus ( ) , NUM_ , alert_data . length ) ; } } if ( capacity < recordProtocol . getMinRecordSize ( ) ) { if ( logger != null ) { logger . println ( STR_ + capacity + STR_ + recordProtocol . getMinRecordSize ( ) + STR_ ) ; } return new SSLEngineResult ( SSLEngineResult . Status . BUFFER_OVERFLOW , handshakeStatus , NUM_ , NUM_ ) ; } try { if ( ! handshakeStatus . equals ( SSLEngineResult . HandshakeStatus . NEED_WRAP ) ) { dataStream . setSourceBuffers ( srcs , offset , len ) ; if ( ( capacity < SSLRecordProtocol . MAX_SSL_PACKET_SIZE ) && ( capacity < recordProtocol . getRecordSize ( dataStream . available ( ) ) ) ) { if ( logger != null ) { logger . println ( STR_ + capacity + STR_ + recordProtocol . getRecordSize ( dataStream . available ( ) ) + STR_ ) ; } return new SSLEngineResult ( SSLEngineResult . Status . BUFFER_OVERFLOW , handshakeStatus , NUM_ , NUM_ ) ; } if ( remaining_wrapped_data == null ) { remaining_wrapped_data = recordProtocol . wrap ( ContentType . APPLICATION_DATA , dataStream ) ; } if ( capacity < remaining_wrapped_data . length ) { return new SSLEngineResult ( SSLEngineResult . Status . BUFFER_OVERFLOW , handshakeStatus , dataStream . consumed ( ) , NUM_ ) ; } else { dst . put ( remaining_wrapped_data ) ; produced = remaining_wrapped_data . length ; remaining_wrapped_data = null ; return new SSLEngineResult ( getEngineStatus ( ) , handshakeStatus , dataStream . consumed ( ) , produced ) ; } } else { if ( remaining_hsh_data == null ) { remaining_hsh_data = handshakeProtocol . wrap ( ) ; } if ( capacity < remaining_hsh_data . length ) { return new SSLEngineResult ( SSLEngineResult . Status . BUFFER_OVERFLOW , handshakeStatus , NUM_ , NUM_ ) ; } else { dst . put ( remaining_hsh_data ) ; produced = remaining_hsh_data . length ; remaining_hsh_data = null ; handshakeStatus = handshakeProtocol . getStatus ( ) ; if ( handshakeStatus . equals ( SSLEngineResult . HandshakeStatus . FINISHED ) ) { session = recordProtocol . getSession ( ) ; } } return new SSLEngineResult ( getEngineStatus ( ) , getHandshakeStatus ( ) , NUM_ , produced ) ; } } catch ( AlertException e ) { alertProtocol . alert ( AlertProtocol . FATAL , e . getDescriptionCode ( ) ) ; engine_was_closed = BOOL_ ; if ( session != null ) { session . invalidate ( ) ; } throw e . getReason ( ) ; } }
@ Override protected void initialize ( ) { List < String > words ; super . initialize ( ) ; m_Words = new HashSet < String > ( ) ; words = read ( ) ; for ( String word : words ) { if ( ! word . startsWith ( STR_ ) ) m_Words . add ( word ) ; } }
protected boolean existsInRange ( String x , int minLength , int maxLength ) { x = StringUtils . trimToNull ( x ) ; return x != null && x . length ( ) >= minLength && x . length ( ) <= maxLength ; }
public synchronized void unwatch ( String pathName ) throws IOException { unregisterAll ( Paths . get ( pathName ) ) ; }
public Criteria addProperty ( String name , String value , Operator operator ) { properties . add ( new PropertyCriteria ( name , value , operator ) ) ; return this ; }
public void removeColumn ( final String columnName ) { if ( columnName == null ) { return ; } final List < String > cols = Arrays . asList ( getInfo ( ) . headers ) ; final int colIndex = cols . indexOf ( columnName ) ; removeColumn ( colIndex ) ; }
public static UnManagedProtectionSet checkUnManagedProtectionSetExistsInDB ( DbClient dbClient , String nativeGuid ) throws IOException { List < UnManagedProtectionSet > cgs = CustomQueryUtility . getUnManagedProtectionSetByNativeGuid ( dbClient , nativeGuid ) ; Iterator < UnManagedProtectionSet > cgsItr = cgs . iterator ( ) ; if ( cgsItr . hasNext ( ) ) { return cgsItr . next ( ) ; } return null ; }
public static void putString2bytes ( byte [ ] destbytes , String srcString , int destOffset , int srcOffset , int count ) { for ( int i = NUM_ ; i < count ; i ++ ) { destbytes [ count + i ] = srcString . getBytes ( ) [ i ] ; } }
private void checkQuery ( String expRes , String qry ) throws Exception { assertEquals ( NUM_ , executeHiveQuery ( STR_ ) ) ; assertEquals ( NUM_ , executeHiveQuery ( STR_ + STR_ + STR_ + STR_ + qry ) ) ; IgfsInputStream in = igfs . open ( new IgfsPath ( STR_ ) ) ; byte [ ] buf = new byte [ ( int ) in . length ( ) ] ; in . read ( buf ) ; assertEquals ( expRes , new String ( buf ) ) ; }
public final V updateAndGet ( UnaryOperator < V > updateFunction ) { V prev , next ; do { prev = get ( ) ; next = updateFunction . apply ( prev ) ; } while ( ! compareAndSet ( prev , next ) ) ; return next ; }
public void close ( ) { stopTimers ( ) ; closed = BOOL_ ; window . dispose ( ) ; if ( listener != null ) { listener . notificationRemoved ( this ) ; } if ( activityListener != null ) { ActivityTracker . removeActivityListener ( activityListener ) ; } }
protected boolean shouldMove ( final ILoadBalancerService loadBalancerService ) { if ( loadBalancerService == null ) throw new IllegalArgumentException ( ) ; final boolean highlyUtilizedService ; try { final UUID serviceUUID = resourceManager . getDataServiceUUID ( ) ; highlyUtilizedService = loadBalancerService . isHighlyUtilizedDataService ( serviceUUID ) ; } catch ( Exception ex ) { log . warn ( STR_ ) ; return BOOL_ ; } if ( ! highlyUtilizedService ) { if ( log . isInfoEnabled ( ) ) log . info ( STR_ ) ; return BOOL_ ; } final ResourceScores resourceScores = resourceManager . getResourceScores ( ) ; final boolean shouldMove = ( resourceScores . percentCPUTime >= resourceManager . movePercentCpuTimeThreshold ) || ( resourceScores . majorPageFaultsPerSec > NUM_ ) || ( resourceScores . dataDirBytesFree < Bytes . gigabyte . NUM_ ) || ( resourceScores . dataDirBytesFree < Bytes . gigabyte . NUM_ ) ; return shouldMove ; }
public static PublicKey generatePublicKey ( String encodedPublicKey ) { try { byte [ ] decodedKey = Base64 . decode ( encodedPublicKey ) ; KeyFactory keyFactory = KeyFactory . getInstance ( KEY_FACTORY_ALGORITHM ) ; return keyFactory . generatePublic ( new X509EncodedKeySpec ( decodedKey ) ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } catch ( InvalidKeySpecException e ) { Log . e ( TAG , STR_ ) ; throw new IllegalArgumentException ( e ) ; } catch ( Base64DecoderException e ) { Log . e ( TAG , STR_ ) ; throw new IllegalArgumentException ( e ) ; } }
private static Object [ ] convertThrowableMessages ( final Object [ ] args ) { if ( args != null ) { for ( int i = NUM_ ; i < args . length ; i ++ ) { if ( args [ i ] instanceof Throwable ) { Throwable t = ( Throwable ) args [ i ] ; if ( t . getMessage ( ) != null ) { args [ i ] = t . getMessage ( ) ; } } } } return args ; }
public RAFDirectory ( Path path , LockFactory lockFactory ) throws IOException { super ( path , lockFactory ) ; path . toFile ( ) ; }
public static void addMinutesToList ( Context context , ArrayList < Integer > values , ArrayList < String > labels , int minutes ) { int index = values . indexOf ( minutes ) ; if ( index != - NUM_ ) { return ; } String label = constructReminderLabel ( context , minutes , BOOL_ ) ; int len = values . size ( ) ; for ( int i = NUM_ ; i < len ; i ++ ) { if ( minutes < values . get ( i ) ) { values . add ( i , minutes ) ; labels . add ( i , label ) ; return ; } } values . add ( minutes ) ; labels . add ( len , label ) ; }
void recomposeVariables ( ElemVariable elemVar ) { if ( getVariableOrParamComposed ( elemVar . getName ( ) ) == null ) { elemVar . setIsTopLevel ( BOOL_ ) ; elemVar . setIndex ( m_variables . size ( ) ) ; m_variables . addElement ( elemVar ) ; } }
public void propertyChange ( PropertyChangeEvent e ) { String propertyName = e . getPropertyName ( ) ; if ( propertyName == STR_ ) { if ( e . getOldValue ( ) == Boolean . FALSE && e . getNewValue ( ) == Boolean . TRUE ) { handlePopupIsVisibleEvent ( BOOL_ ) ; } else if ( e . getOldValue ( ) == Boolean . TRUE && e . getNewValue ( ) == Boolean . FALSE ) { handlePopupIsVisibleEvent ( BOOL_ ) ; } } }
private static int [ ] maybeSort ( int [ ] values ) { if ( ! isSorted ( values , NUM_ , BOOL_ ) ) { values = values . clone ( ) ; Arrays . sort ( values ) ; } return values ; }
public int executeUpdate ( String sql ) throws GenericDataSourceException { Statement stmt = null ; try { stmt = _connection . createStatement ( ) ; return stmt . executeUpdate ( sql ) ; } catch ( SQLException sqle ) { throw new GenericDataSourceException ( STR_ + _sql , sqle ) ; } finally { if ( stmt != null ) { try { stmt . close ( ) ; } catch ( SQLException sqle ) { Debug . logWarning ( STR_ + sqle . getMessage ( ) , module ) ; } } } }
public synchronized static void initialize ( Connection conn ) throws SQLException { if ( logHadoopIdPatterns != null && logLineagePatterns != null ) { return ; } loadLineagePatterns ( conn ) ; loadHadoopIdPatterns ( conn ) ; }
public void addIndices ( Collection < IIndex > indices ) { for ( Iterator < IIndex > it = indices . iterator ( ) ; it . hasNext ( ) ; ) { addIndex ( ( IIndex ) it . next ( ) ) ; } }
public static boolean isCookieSecure ( ) { return secureCookie ; }
public static List < ObjectModel > loadJsonStream ( InputStream input ) { List < ObjectModel > models = new ArrayList < > ( ) ; Reader reader = new InputStreamReader ( input ) ; ObjectModel [ ] objectModels = GSON . fromJson ( reader , ObjectModel [ ] . class ) ; for ( ObjectModel objectModel : objectModels ) { models . add ( objectModel ) ; } return models ; }
protected MultistepExprHolder createMultistepExprList ( Vector paths ) { MultistepExprHolder first = null ; int n = paths . size ( ) ; for ( int i = NUM_ ; i < n ; i ++ ) { ExpressionOwner eo = ( ExpressionOwner ) paths . elementAt ( i ) ; if ( null == eo ) continue ; LocPathIterator lpi = ( LocPathIterator ) eo . getExpression ( ) ; int numPaths = countSteps ( lpi ) ; if ( numPaths > NUM_ ) { if ( null == first ) first = new MultistepExprHolder ( eo , numPaths , null ) ; else first = first . addInSortedOrder ( eo , numPaths ) ; } } if ( ( null == first ) || ( first . getLength ( ) <= NUM_ ) ) return null ; else return first ; }
private int addWordlenWeights ( Channel chan , int weightIdx ) { int [ ] weigthsTab = atrac3p_wl_weights [ chan . chNum . NUM_ + weightIdx - NUM_ ] ; for ( int i = NUM_ ; i < ctx . numQuantUnits ; i ++ ) { chan . quWordlen [ i ] += weigthsTab [ i ] ; if ( chan . quWordlen [ i ] < NUM_ || chan . quWordlen [ i ] > NUM_ ) { log . error ( String . format ( STR_ , i , chan . quWordlen [ i ] ) ) ; return AT3P_ERROR ; } } return NUM_ ; }
public void testUpdate3 ( ) throws SQLException { DatabaseCreator . fillFKStrictTable ( conn ) ; statement . execute ( STR_ + DatabaseCreator . FKSTRICT_TABLE + STR_ ) ; statement . execute ( STR_ + DatabaseCreator . PARENT_TABLE + STR_ ) ; }
final void pruneExceptionalOut ( IR ir ) { int n = getNumberOfExceptionalOut ( ) ; if ( n > NUM_ ) { ComputedBBEnum handlers = new ComputedBBEnum ( n ) ; Enumeration < Instruction > e = forwardRealInstrEnumerator ( ) ; while ( e . hasMoreElements ( ) ) { Instruction x = e . nextElement ( ) ; Enumeration < BasicBlock > bbs = getApplicableExceptionalOut ( x ) ; while ( bbs . hasMoreElements ( ) ) { BasicBlock bb = bbs . nextElement ( ) ; handlers . addPossiblyDuplicateElement ( bb ) ; } } deleteExceptionalOut ( ) ; for ( int i = NUM_ ; handlers . hasMoreElements ( ) ; i ++ ) { ExceptionHandlerBasicBlock b = ( ExceptionHandlerBasicBlock ) handlers . nextElement ( ) ; insertOut ( b ) ; } } recomputeNormalOut ( ir ) ; }
private Pair < DBIDVar , Double > singleIteration ( Relation < V > relationx , Relation < ? extends NumberVector > relationy ) { final int dim = RelationUtil . dimensionality ( relationx ) ; final int dimy = RelationUtil . dimensionality ( relationy ) ; assert ( dim == NUM_ ) ; KNNQuery < V > knnQuery = QueryUtil . getKNNQuery ( relationx , getDistanceFunction ( ) , k + NUM_ ) ; ArrayModifiableDBIDs ids = DBIDUtil . newArray ( relationx . getDBIDs ( ) ) ; ids . sort ( ) ; double [ ] [ ] X = new double [ ids . size ( ) ] [ NUM_ ] ; double [ ] [ ] F = new double [ ids . size ( ) ] [ ids . size ( ) ] ; double [ ] [ ] Y = new double [ ids . size ( ) ] [ dimy ] ; { int i = NUM_ ; for ( DBIDIter id = ids . iter ( ) ; id . valid ( ) ; id . advance ( ) , i ++ ) { { V vec = relationx . get ( id ) ; double la = vec . doubleValue ( NUM_ ) ; double lo = vec . doubleValue ( NUM_ ) ; X [ i ] [ NUM_ ] = NUM_ ; X [ i ] [ NUM_ ] = la ; X [ i ] [ NUM_ ] = lo ; X [ i ] [ NUM_ ] = la . lo ; X [ i ] [ NUM_ ] = la . la ; X [ i ] [ NUM_ ] = lo . lo ; } { final NumberVector vecy = relationy . get ( id ) ; for ( int d = NUM_ ; d < dimy ; d ++ ) { double idy = vecy . doubleValue ( d ) ; Y [ i ] [ d ] = idy ; } } { KNNList neighbors = knnQuery . getKNNForDBID ( id , k + NUM_ ) ; ModifiableDBIDs neighborhood = DBIDUtil . newArray ( neighbors . size ( ) ) ; for ( DBIDIter neighbor = neighbors . iter ( ) ; neighbor . valid ( ) ; neighbor . advance ( ) ) { if ( DBIDUtil . equal ( id , neighbor ) ) { continue ; } neighborhood . add ( neighbor ) ; } F [ i ] [ i ] = NUM_ ; final int nweight = - NUM_ / neighborhood . size ( ) ; for ( DBIDIter iter = neighborhood . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { int pos = ids . binarySearch ( iter ) ; assert ( pos >= NUM_ ) ; F [ pos ] [ i ] = nweight ; } } } } double [ ] [ ] common = times ( transposeTimesTranspose ( X , F ) , F ) ; double [ ] [ ] b = times ( inverse ( times ( common , X ) ) , times ( common , Y ) ) ; double [ ] [ ] sigmaMat = times ( F , minusEquals ( times ( X , b ) , times ( F , Y ) ) ) ; final double sigma_sum_square = normF ( sigmaMat ) / ( relationx . size ( ) - NUM_ - NUM_ ) ; final double norm = NUM_ / Math . sqrt ( sigma_sum_square ) ; double [ ] [ ] E = timesEquals ( times ( F , minus ( Y , times ( X , b ) ) ) , norm ) ; DBIDVar worstid = DBIDUtil . newVar ( ) ; double worstscore = Double . NEGATIVE_INFINITY ; int i = NUM_ ; for ( DBIDIter id = ids . iter ( ) ; id . valid ( ) ; id . advance ( ) , i ++ ) { double err = squareSum ( getRow ( E , i ) ) ; if ( err > worstscore ) { worstscore = err ; worstid . set ( id ) ; } } return new Pair < > ( worstid , Math . sqrt ( worstscore ) ) ; }
public final CharSequence yytext ( ) { return zzBuffer . subSequence ( zzStartRead , zzMarkedPos ) ; }
private void cleanupMinidumpFile ( ) { if ( ! CrashFileManager . tryMarkAsUploaded ( mFileToUpload ) ) { Log . w ( TAG , STR_ + mFileToUpload + STR_ ) ; if ( ! mFileToUpload . delete ( ) ) { Log . w ( TAG , STR_ + mFileToUpload ) ; } } }
public String toSpacedString ( ) { final String original = toString ( ) ; final StringBuilder builder = new StringBuilder ( ) ; for ( int i = NUM_ ; i < original . length ( ) ; i ++ ) { if ( i > NUM_ && ( i % NUM_ ) == NUM_ ) builder . append ( STR_ ) ; builder . append ( original . charAt ( i ) ) ; } return builder . toString ( ) ; }
private int parseContentType ( final byte [ ] b , final int off ) throws ParseException { contentTypeVal_ = PrimitivesParser . parseByte ( b , off ) ; if ( ContentType . deserialize ( contentTypeVal_ ) == null ) { throw new BadCiphertextException ( STR_ ) ; } return NUM_ ; }
@ Benchmark public void nonCaching ( ) { run ( ) ; }
public int decode ( String data , OutputStream out ) throws IOException { byte b1 , b2 , b3 , b4 ; int length = NUM_ ; int end = data . length ( ) ; while ( end > NUM_ ) { if ( ! ignore ( data . charAt ( end - NUM_ ) ) ) { break ; } end -- ; } int i = NUM_ ; int finish = end - NUM_ ; i = nextI ( data , i , finish ) ; while ( i < finish ) { b1 = decodingTable [ data . charAt ( i ++ ) ] ; i = nextI ( data , i , finish ) ; b2 = decodingTable [ data . charAt ( i ++ ) ] ; i = nextI ( data , i , finish ) ; b3 = decodingTable [ data . charAt ( i ++ ) ] ; i = nextI ( data , i , finish ) ; b4 = decodingTable [ data . charAt ( i ++ ) ] ; if ( ( b1 | b2 | b3 | b4 ) < NUM_ ) { throw new IOException ( STR_ ) ; } out . write ( ( b1 << NUM_ ) | ( b2 > > NUM_ ) ) ; out . write ( ( b2 << NUM_ ) | ( b3 > > NUM_ ) ) ; out . write ( ( b3 << NUM_ ) | b4 ) ; length += NUM_ ; i = nextI ( data , i , finish ) ; } length += decodeLastBlock ( out , data . charAt ( end - NUM_ ) , data . charAt ( end - NUM_ ) , data . charAt ( end - NUM_ ) , data . charAt ( end - NUM_ ) ) ; return length ; }
private void rLineTo ( float dx , float dy ) { if ( isEmpty ( ) ) { mPath . moveTo ( mLastX = NUM_ , mLastY = NUM_ ) ; } dx += mLastX ; dy += mLastY ; mPath . lineTo ( mLastX = dx , mLastY = dy ) ; }
@ Override public ConflictResults parseOutput ( final String stdout , final String stderr ) { final List < String > contentConflicts = new ArrayList < String > ( ) ; final List < String > renameConflicts = new ArrayList < String > ( ) ; final List < String > bothConflicts = new ArrayList < String > ( ) ; final String [ ] lines = getLines ( stderr ) ; for ( final String line : lines ) { final int index = line . lastIndexOf ( STR_ ) ; if ( index != - NUM_ ) { if ( StringUtils . endsWith ( line , BOTH_CONFLICTS_SUFFIX ) ) { bothConflicts . add ( line . substring ( NUM_ , index ) ) ; } else if ( StringUtils . endsWith ( line , RENAME_CONFLICT_SUFFIX ) ) { renameConflicts . add ( line . substring ( NUM_ , index ) ) ; } else { contentConflicts . add ( line . substring ( NUM_ , index ) ) ; } } } return new ConflictResults ( contentConflicts , renameConflicts , bothConflicts ) ; }
protected void sendStart ( final OutputStream out ) throws IOException { LOG . trace ( STR_ ) ; out . write ( EXTRA_BYTES ) ; out . write ( getPartBoundary ( ) ) ; out . write ( CRLF_BYTES ) ; }
public void addActualQty ( BigDecimal add ) { m_actualQty = m_actualQty . add ( add ) ; }
protected static boolean isVowel ( final char c ) { final char l = Character . toLowerCase ( c ) ; return ( ( l == STR_ ) || ( l == STR_ ) || ( l == STR_ ) || ( l == STR_ ) || ( l == STR_ ) ) ; }
private byte [ ] createPreviewBuffer ( Size previewSize ) { int bitsPerPixel = ImageFormat . getBitsPerPixel ( ImageFormat . NV21 ) ; long sizeInBits = previewSize . getHeight ( ) . previewSize . getWidth ( ) . bitsPerPixel ; int bufferSize = ( int ) Math . ceil ( sizeInBits / NUM_ ) + NUM_ ; byte [ ] byteArray = new byte [ bufferSize ] ; ByteBuffer buffer = ByteBuffer . wrap ( byteArray ) ; if ( ! buffer . hasArray ( ) || ( buffer . array ( ) != byteArray ) ) { throw new IllegalStateException ( STR_ ) ; } mBytesToByteBuffer . put ( byteArray , buffer ) ; return byteArray ; }
void submit ( ProcessAndDisplayImageTask task ) { initExecutorsIfNeed ( ) ; taskExecutorForCachedImages . execute ( task ) ; }
public static void printStackTrace ( SQLException e , PrintWriter pw ) { SQLException next = e ; while ( next != null ) { next . printStackTrace ( pw ) ; next = next . getNextException ( ) ; if ( next != null ) { pw . println ( STR_ ) ; } } }
protected void initializeWorld ( ) { Body ground = new SimulationBody ( ) ; { Convex c = Geometry . createRectangle ( NUM_ , NUM_ ) ; BodyFixture bf = new BodyFixture ( c ) ; ground . addFixture ( bf ) ; } ground . translate ( new Vector2 ( NUM_ , - NUM_ ) ) ; ground . setMass ( MassType . INFINITE ) ; world . addBody ( ground ) ; Body head = new SimulationBody ( ) ; { Convex c = Geometry . createCircle ( NUM_ ) ; BodyFixture bf = new BodyFixture ( c ) ; head . addFixture ( bf ) ; } head . setMass ( MassType . NORMAL ) ; world . addBody ( head ) ; Body torso = new SimulationBody ( ) ; { Convex c = Geometry . createRectangle ( NUM_ , NUM_ ) ; BodyFixture bf = new BodyFixture ( c ) ; torso . addFixture ( bf ) ; } { Convex c = Geometry . createRectangle ( NUM_ , NUM_ ) ; c . translate ( new Vector2 ( NUM_ , NUM_ ) ) ; BodyFixture bf = new BodyFixture ( c ) ; torso . addFixture ( bf ) ; } torso . translate ( new Vector2 ( NUM_ , - NUM_ ) ) ; torso . setMass ( MassType . NORMAL ) ; world . addBody ( torso ) ; Body rightHumerus = new SimulationBody ( ) ; { Convex c = Geometry . createRectangle ( NUM_ , NUM_ ) ; BodyFixture bf = new BodyFixture ( c ) ; rightHumerus . addFixture ( bf ) ; } rightHumerus . translate ( new Vector2 ( NUM_ , - NUM_ ) ) ; rightHumerus . setMass ( MassType . NORMAL ) ; world . addBody ( rightHumerus ) ; Body rightUlna = new SimulationBody ( ) ; { Convex c = Geometry . createRectangle ( NUM_ , NUM_ ) ; BodyFixture bf = new BodyFixture ( c ) ; rightUlna . addFixture ( bf ) ; } rightUlna . translate ( new Vector2 ( NUM_ , - NUM_ ) ) ; rightUlna . setMass ( MassType . NORMAL ) ; world . addBody ( rightUlna ) ; Body neck = new SimulationBody ( ) ; { Convex c = Geometry . createRectangle ( NUM_ , NUM_ ) ; BodyFixture bf = new BodyFixture ( c ) ; neck . addFixture ( bf ) ; } neck . translate ( new Vector2 ( NUM_ , - NUM_ ) ) ; neck . setMass ( MassType . NORMAL ) ; world . addBody ( neck ) ; Body leftHumerus = new SimulationBody ( ) ; { Convex c = Geometry . createRectangle ( NUM_ , NUM_ ) ; BodyFixture bf = new BodyFixture ( c ) ; leftHumerus . addFixture ( bf ) ; } leftHumerus . translate ( new Vector2 ( - NUM_ , - NUM_ ) ) ; leftHumerus . setMass ( MassType . NORMAL ) ; world . addBody ( leftHumerus ) ; Body leftUlna = new SimulationBody ( ) ; { Convex c = Geometry . createRectangle ( NUM_ , NUM_ ) ; BodyFixture bf = new BodyFixture ( c ) ; leftUlna . addFixture ( bf ) ; } leftUlna . translate ( new Vector2 ( - NUM_ , - NUM_ ) ) ; leftUlna . setMass ( MassType . NORMAL ) ; world . addBody ( leftUlna ) ; Body rightFemur = new SimulationBody ( ) ; { Convex c = Geometry . createRectangle ( NUM_ , NUM_ ) ; BodyFixture bf = new BodyFixture ( c ) ; rightFemur . addFixture ( bf ) ; } rightFemur . translate ( new Vector2 ( NUM_ , - NUM_ ) ) ; rightFemur . setMass ( MassType . NORMAL ) ; world . addBody ( rightFemur ) ; Body leftFemur = new SimulationBody ( ) ; { Convex c = Geometry . createRectangle ( NUM_ , NUM_ ) ; BodyFixture bf = new BodyFixture ( c ) ; leftFemur . addFixture ( bf ) ; } leftFemur . translate ( new Vector2 ( - NUM_ , - NUM_ ) ) ; leftFemur . setMass ( MassType . NORMAL ) ; world . addBody ( leftFemur ) ; Body rightTibia = new SimulationBody ( ) ; { Convex c = Geometry . createRectangle ( NUM_ , NUM_ ) ; BodyFixture bf = new BodyFixture ( c ) ; rightTibia . addFixture ( bf ) ; } rightTibia . translate ( new Vector2 ( NUM_ , - NUM_ ) ) ; rightTibia . setMass ( MassType . NORMAL ) ; world . addBody ( rightTibia ) ; Body leftTibia = new SimulationBody ( ) ; { Convex c = Geometry . createRectangle ( NUM_ , NUM_ ) ; BodyFixture bf = new BodyFixture ( c ) ; leftTibia . addFixture ( bf ) ; } leftTibia . translate ( new Vector2 ( - NUM_ , - NUM_ ) ) ; leftTibia . setMass ( MassType . NORMAL ) ; world . addBody ( leftTibia ) ; RevoluteJoint headToNeck = new RevoluteJoint ( head , neck , new Vector2 ( NUM_ , - NUM_ ) ) ; headToNeck . setLimitEnabled ( BOOL_ ) ; headToNeck . setLimits ( Math . toRadians ( NUM_ ) , Math . toRadians ( NUM_ ) ) ; headToNeck . setReferenceAngle ( Math . toRadians ( NUM_ ) ) ; headToNeck . setMotorEnabled ( BOOL_ ) ; headToNeck . setMotorSpeed ( Math . toRadians ( NUM_ ) ) ; headToNeck . setMaximumMotorTorque ( NUM_ ) ; headToNeck . setCollisionAllowed ( BOOL_ ) ; world . addJoint ( headToNeck ) ; RevoluteJoint neckToTorso = new RevoluteJoint ( neck , torso , new Vector2 ( NUM_ , - NUM_ ) ) ; neckToTorso . setLimitEnabled ( BOOL_ ) ; neckToTorso . setLimits ( Math . toRadians ( NUM_ ) , Math . toRadians ( NUM_ ) ) ; neckToTorso . setReferenceAngle ( Math . toRadians ( NUM_ ) ) ; neckToTorso . setMotorEnabled ( BOOL_ ) ; neckToTorso . setMotorSpeed ( Math . toRadians ( NUM_ ) ) ; neckToTorso . setMaximumMotorTorque ( NUM_ ) ; neckToTorso . setCollisionAllowed ( BOOL_ ) ; world . addJoint ( neckToTorso ) ; RevoluteJoint torsoToLeftHumerus = new RevoluteJoint ( torso , leftHumerus , new Vector2 ( - NUM_ , - NUM_ ) ) ; torsoToLeftHumerus . setLimitEnabled ( BOOL_ ) ; torsoToLeftHumerus . setLimits ( Math . toRadians ( NUM_ ) , Math . toRadians ( NUM_ ) ) ; torsoToLeftHumerus . setReferenceAngle ( Math . toRadians ( NUM_ ) ) ; torsoToLeftHumerus . setMotorEnabled ( BOOL_ ) ; torsoToLeftHumerus . setMotorSpeed ( Math . toRadians ( NUM_ ) ) ; torsoToLeftHumerus . setMaximumMotorTorque ( NUM_ ) ; torsoToLeftHumerus . setCollisionAllowed ( BOOL_ ) ; world . addJoint ( torsoToLeftHumerus ) ; RevoluteJoint torsoToRightHumerus = new RevoluteJoint ( torso , rightHumerus , new Vector2 ( NUM_ , - NUM_ ) ) ; torsoToRightHumerus . setLimitEnabled ( BOOL_ ) ; torsoToRightHumerus . setLimits ( Math . toRadians ( NUM_ ) , Math . toRadians ( NUM_ ) ) ; torsoToRightHumerus . setReferenceAngle ( Math . toRadians ( NUM_ ) ) ; torsoToRightHumerus . setMotorEnabled ( BOOL_ ) ; torsoToRightHumerus . setMotorSpeed ( Math . toRadians ( NUM_ ) ) ; torsoToRightHumerus . setMaximumMotorTorque ( NUM_ ) ; torsoToRightHumerus . setCollisionAllowed ( BOOL_ ) ; world . addJoint ( torsoToRightHumerus ) ; RevoluteJoint rightHumerusToRightUlna = new RevoluteJoint ( rightHumerus , rightUlna , new Vector2 ( NUM_ , - NUM_ ) ) ; rightHumerusToRightUlna . setLimitEnabled ( BOOL_ ) ; rightHumerusToRightUlna . setLimits ( Math . toRadians ( NUM_ ) , Math . toRadians ( NUM_ ) ) ; rightHumerusToRightUlna . setReferenceAngle ( Math . toRadians ( NUM_ ) ) ; rightHumerusToRightUlna . setMotorEnabled ( BOOL_ ) ; rightHumerusToRightUlna . setMotorSpeed ( Math . toRadians ( NUM_ ) ) ; rightHumerusToRightUlna . setMaximumMotorTorque ( NUM_ ) ; rightHumerusToRightUlna . setCollisionAllowed ( BOOL_ ) ; world . addJoint ( rightHumerusToRightUlna ) ; RevoluteJoint leftHumerusToLeftUlna = new RevoluteJoint ( leftHumerus , leftUlna , new Vector2 ( - NUM_ , - NUM_ ) ) ; leftHumerusToLeftUlna . setLimitEnabled ( BOOL_ ) ; leftHumerusToLeftUlna . setLimits ( Math . toRadians ( NUM_ ) , Math . toRadians ( NUM_ ) ) ; leftHumerusToLeftUlna . setReferenceAngle ( Math . toRadians ( NUM_ ) ) ; leftHumerusToLeftUlna . setMotorEnabled ( BOOL_ ) ; leftHumerusToLeftUlna . setMotorSpeed ( Math . toRadians ( NUM_ ) ) ; leftHumerusToLeftUlna . setMaximumMotorTorque ( NUM_ ) ; leftHumerusToLeftUlna . setCollisionAllowed ( BOOL_ ) ; world . addJoint ( leftHumerusToLeftUlna ) ; RevoluteJoint torsoToRightFemur = new RevoluteJoint ( torso , rightFemur , new Vector2 ( NUM_ , - NUM_ ) ) ; torsoToRightFemur . setLimitEnabled ( BOOL_ ) ; torsoToRightFemur . setLimits ( Math . toRadians ( NUM_ ) , Math . toRadians ( NUM_ ) ) ; torsoToRightFemur . setReferenceAngle ( Math . toRadians ( NUM_ ) ) ; torsoToRightFemur . setMotorEnabled ( BOOL_ ) ; torsoToRightFemur . setMotorSpeed ( Math . toRadians ( NUM_ ) ) ; torsoToRightFemur . setMaximumMotorTorque ( NUM_ ) ; torsoToRightFemur . setCollisionAllowed ( BOOL_ ) ; world . addJoint ( torsoToRightFemur ) ; RevoluteJoint torsoToLeftFemur = new RevoluteJoint ( torso , leftFemur , new Vector2 ( - NUM_ , - NUM_ ) ) ; torsoToLeftFemur . setLimitEnabled ( BOOL_ ) ; torsoToLeftFemur . setLimits ( Math . toRadians ( NUM_ ) , Math . toRadians ( NUM_ ) ) ; torsoToLeftFemur . setReferenceAngle ( Math . toRadians ( NUM_ ) ) ; torsoToLeftFemur . setMotorEnabled ( BOOL_ ) ; torsoToLeftFemur . setMotorSpeed ( Math . toRadians ( NUM_ ) ) ; torsoToLeftFemur . setMaximumMotorTorque ( NUM_ ) ; torsoToLeftFemur . setCollisionAllowed ( BOOL_ ) ; world . addJoint ( torsoToLeftFemur ) ; RevoluteJoint rightFemurToRightTibia = new RevoluteJoint ( rightFemur , rightTibia , new Vector2 ( NUM_ , - NUM_ ) ) ; rightFemurToRightTibia . setLimitEnabled ( BOOL_ ) ; rightFemurToRightTibia . setLimits ( Math . toRadians ( NUM_ ) , Math . toRadians ( NUM_ ) ) ; rightFemurToRightTibia . setReferenceAngle ( Math . toRadians ( NUM_ ) ) ; rightFemurToRightTibia . setMotorEnabled ( BOOL_ ) ; rightFemurToRightTibia . setMotorSpeed ( Math . toRadians ( NUM_ ) ) ; rightFemurToRightTibia . setMaximumMotorTorque ( NUM_ ) ; rightFemurToRightTibia . setCollisionAllowed ( BOOL_ ) ; world . addJoint ( rightFemurToRightTibia ) ; RevoluteJoint leftFemurToLeftTibia = new RevoluteJoint ( leftFemur , leftTibia , new Vector2 ( - NUM_ , - NUM_ ) ) ; leftFemurToLeftTibia . setLimitEnabled ( BOOL_ ) ; leftFemurToLeftTibia . setLimits ( Math . toRadians ( NUM_ ) , Math . toRadians ( NUM_ ) ) ; leftFemurToLeftTibia . setReferenceAngle ( Math . toRadians ( NUM_ ) ) ; leftFemurToLeftTibia . setMotorEnabled ( BOOL_ ) ; leftFemurToLeftTibia . setMotorSpeed ( Math . toRadians ( NUM_ ) ) ; leftFemurToLeftTibia . setMaximumMotorTorque ( NUM_ ) ; leftFemurToLeftTibia . setCollisionAllowed ( BOOL_ ) ; world . addJoint ( leftFemurToLeftTibia ) ; }
public void readData ( DataInput din ) throws IOException { byteCount = din . readByte ( ) ; status = din . readUnsignedShort ( ) ; eventCount = din . readUnsignedShort ( ) ; messageCount = din . readUnsignedShort ( ) ; events = new byte [ byteCount - NUM_ ] ; if ( events . length > NUM_ ) { din . readFully ( events , NUM_ , events . length ) ; } }
public E remove ( int index ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { Object [ ] elements = getArray ( ) ; int len = elements . length ; E oldValue = get ( elements , index ) ; int numMoved = len - index - NUM_ ; if ( numMoved == NUM_ ) setArray ( Arrays . copyOf ( elements , len - NUM_ ) ) ; else { Object [ ] newElements = new Object [ len - NUM_ ] ; System . arraycopy ( elements , NUM_ , newElements , NUM_ , index ) ; System . arraycopy ( elements , index + NUM_ , newElements , index , numMoved ) ; setArray ( newElements ) ; } return oldValue ; } finally { lock . unlock ( ) ; } }
void createEdges ( Number [ ] v ) { graph . addEdge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , EdgeType . DIRECTED ) ; graph . addEdge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , EdgeType . DIRECTED ) ; graph . addEdge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , EdgeType . DIRECTED ) ; graph . addEdge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , EdgeType . DIRECTED ) ; graph . addEdge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , EdgeType . DIRECTED ) ; graph . addEdge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , EdgeType . DIRECTED ) ; graph . addEdge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , EdgeType . DIRECTED ) ; graph . addEdge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , EdgeType . DIRECTED ) ; graph . addEdge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , EdgeType . DIRECTED ) ; graph . addEdge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , EdgeType . DIRECTED ) ; graph . addEdge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , EdgeType . DIRECTED ) ; graph . addEdge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , EdgeType . DIRECTED ) ; graph . addEdge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , EdgeType . DIRECTED ) ; graph . addEdge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , EdgeType . DIRECTED ) ; graph . addEdge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , EdgeType . DIRECTED ) ; graph . addEdge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , EdgeType . DIRECTED ) ; graph . addEdge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , EdgeType . DIRECTED ) ; graph . addEdge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , EdgeType . DIRECTED ) ; graph . addEdge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , EdgeType . DIRECTED ) ; }
@ SuppressWarnings ( STR_ ) public DataResponse paginateList ( Map < String , String > requestParams , PaginateRequest paginateRequest , Object query , String defaultSort , Map properties ) { if ( paginateRequest == null ) { paginateRequest = new PaginateRequest ( ) ; } if ( paginateRequest . getStart ( ) == null ) { paginateRequest . setStart ( RequestUtil . getInteger ( requestParams , STR_ , NUM_ ) ) ; } if ( paginateRequest . getSize ( ) == null ) { paginateRequest . setSize ( RequestUtil . getInteger ( requestParams , STR_ , NUM_ ) ) ; } if ( paginateRequest . getOrder ( ) == null ) { paginateRequest . setOrder ( requestParams . get ( STR_ ) ) ; } if ( paginateRequest . getSort ( ) == null ) { paginateRequest . setSort ( requestParams . get ( STR_ ) ) ; } Integer start = paginateRequest . getStart ( ) ; if ( start == null || start < NUM_ ) { start = NUM_ ; } Integer size = paginateRequest . getSize ( ) ; if ( size == null || size < NUM_ ) { size = NUM_ ; } String sort = paginateRequest . getSort ( ) ; if ( sort == null ) { sort = defaultSort ; } String order = paginateRequest . getOrder ( ) ; if ( order == null ) { order = STR_ ; } if ( sort != null && ! properties . isEmpty ( ) ) { Object qp = properties . get ( sort ) ; if ( qp == null ) { throw new ActivitiIllegalArgumentException ( STR_ + sort + STR_ ) ; } if ( query instanceof AbstractQuery ) { AbstractQuery queryObject = ( AbstractQuery ) query ; QueryProperty queryProperty = ( QueryProperty ) qp ; queryObject . orderBy ( queryProperty ) ; if ( order . equals ( STR_ ) ) { queryObject . asc ( ) ; } else if ( order . equals ( STR_ ) ) { queryObject . desc ( ) ; } else { throw new ActivitiIllegalArgumentException ( STR_ + order + STR_ ) ; } } else if ( query instanceof org . activiti . idm . engine . impl . AbstractQuery ) { org . activiti . idm . engine . impl . AbstractQuery queryObject = ( org . activiti . idm . engine . impl . AbstractQuery ) query ; org . activiti . idm . api . QueryProperty queryProperty = ( org . activiti . idm . api . QueryProperty ) qp ; queryObject . orderBy ( queryProperty ) ; if ( order . equals ( STR_ ) ) { queryObject . asc ( ) ; } else if ( order . equals ( STR_ ) ) { queryObject . desc ( ) ; } else { throw new ActivitiIllegalArgumentException ( STR_ + order + STR_ ) ; } } } DataResponse response = new DataResponse ( ) ; response . setStart ( start ) ; response . setSort ( sort ) ; response . setOrder ( order ) ; if ( query instanceof AbstractQuery ) { AbstractQuery queryObject = ( AbstractQuery ) query ; List list = processList ( queryObject . listPage ( start , size ) ) ; response . setTotal ( queryObject . count ( ) ) ; response . setSize ( list . size ( ) ) ; response . setData ( list ) ; } else if ( query instanceof org . activiti . idm . engine . impl . AbstractQuery ) { org . activiti . idm . engine . impl . AbstractQuery queryObject = ( org . activiti . idm . engine . impl . AbstractQuery ) query ; List list = processList ( queryObject . listPage ( start , size ) ) ; response . setTotal ( queryObject . count ( ) ) ; response . setSize ( list . size ( ) ) ; response . setData ( list ) ; } return response ; }
private static < T extends Component > T buildRow ( final JPanel panel , final String labelText , final String hint , final T component , final boolean isLast ) { component . setPreferredSize ( new Dimension ( COLORPANEL_WIDTH , COLORPANEL_HEIGHT ) ) ; final JPanel rowPanel = new JPanel ( new BorderLayout ( ) ) ; rowPanel . setBorder ( new EmptyBorder ( NUM_ , NUM_ , isLast ? NUM_ : NUM_ , NUM_ ) ) ; rowPanel . add ( new JLabel ( labelText ) , BorderLayout . CENTER ) ; rowPanel . add ( CHintCreator . createHintPanel ( component , hint ) , BorderLayout . EAST ) ; panel . add ( rowPanel ) ; return component ; }
public Builder addTargetElements ( Element ... additionalTargets ) { for ( int i = NUM_ ; i < additionalTargets . length ; i ++ ) { targetElements . add ( additionalTargets [ i ] ) ; } return this ; }
public void curveTo ( double x1 , double y1 , double x2 , double y2 , double x3 , double y3 ) { if ( size ( ) == NUM_ ) { throw new IllegalPathStateException ( STR_ ) ; } Node lastPoint = get ( size ( ) - NUM_ ) ; lastPoint . mask |= C2_MASK ; lastPoint . x [ NUM_ ] = x1 ; lastPoint . y [ NUM_ ] = y1 ; if ( ( lastPoint . mask & C1C2_MASK ) == C1C2_MASK ) { lastPoint . keepColinear = Math . abs ( Geom . angle ( lastPoint . x [ NUM_ ] , lastPoint . y [ NUM_ ] , lastPoint . x [ NUM_ ] , lastPoint . y [ NUM_ ] ) - Geom . angle ( lastPoint . x [ NUM_ ] , lastPoint . y [ NUM_ ] , lastPoint . x [ NUM_ ] , lastPoint . y [ NUM_ ] ) ) < NUM_ ; } add ( new Node ( C1_MASK , x3 , y3 , x2 , y2 , x3 , y3 ) ) ; }
public void testDivideRoundUpNeg ( ) { String a = STR_ ; int aScale = - NUM_ ; String b = STR_ ; int bScale = NUM_ ; String c = STR_ ; int resScale = - NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal bNumber = new BigDecimal ( new BigInteger ( b ) , bScale ) ; BigDecimal result = aNumber . divide ( bNumber , resScale , BigDecimal . ROUND_UP ) ; assertEquals ( STR_ , c , result . toString ( ) ) ; assertEquals ( STR_ , resScale , result . scale ( ) ) ; }
private void writeMetaBits ( ) throws IOException { final byte buf [ ] = genMetabitsData ( ) ; final long addr = m_metaBitsAddr < NUM_ ? physicalAddress ( m_metaBitsAddr ) : ( ( long ) m_metaBitsAddr ) << ALLOCATION_SCALEUP ; if ( addr == NUM_ ) { throw new IllegalStateException ( STR_ + m_metaBitsAddr ) ; } assert addr > NUM_ ; try { if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + addr ) ; m_writeCacheService . write ( addr , ByteBuffer . wrap ( buf ) , NUM_ , BOOL_ , m_metaBitsAddr < NUM_ ? m_metaBitsAddr : NUM_ ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } }
private void openCounterDataInputStream ( ) throws DataFallbackException { if ( dInput == null ) { if ( LOG . isDebugEnabled ( ) ) LOG . debug ( STR_ + counterFile . getName ( ) + STR_ ) ; try { dInput = new BufferedReader ( new FileReader ( counterFile ) ) ; } catch ( IOException e ) { throw new DataFallbackException ( e . getMessage ( ) ) ; } } }
public CompositePredicate ( Predicate p1 , Predicate p2 ) { m_clauses . add ( p1 ) ; m_clauses . add ( p2 ) ; }
public String readNextWord ( ) { if ( tokenizer . hasMoreTokens ( ) ) { return tokenizer . nextToken ( ) ; } else { return null ; } }
public static final void toString ( StringBuffer output , String str ) { if ( str == null ) { output . append ( STR_ ) ; return ; } output . append ( toString ( str ) ) ; }
public static boolean testFileExists ( String name ) { boolean status ; if ( ( testSaveLocationExists ( ) ) && ( ! name . equals ( STR_ ) ) ) { File path = Environment . getExternalStorageDirectory ( ) ; File newPath = constructFilePaths ( path . toString ( ) , name ) ; status = newPath . exists ( ) ; } else { status = BOOL_ ; } return status ; }
@ Override public void buildAssociations ( Instances data ) throws Exception { buildAssociations ( ( Object ) data ) ; return ; }
public void testFloatValueNeg ( ) { String a = STR_ ; BigDecimal aNumber = new BigDecimal ( a ) ; float result = - NUM_ ; assertTrue ( STR_ , aNumber . floatValue ( ) == result ) ; }
public static String replaceFirst ( String s , String sub , String with ) { int i = s . indexOf ( sub ) ; if ( i == - NUM_ ) { return s ; } return s . substring ( NUM_ , i ) + with + s . substring ( i + sub . length ( ) ) ; }
public void addObject ( String s ) throws Exception { inspect ( Class . forName ( s ) ) ; }
public static Element firstChildElement ( Element element , Set < String > childElementNames ) { if ( element == null ) return null ; Node node = element . getFirstChild ( ) ; if ( node != null ) { do { if ( node . getNodeType ( ) == Node . ELEMENT_NODE && childElementNames . contains ( node . getNodeName ( ) ) ) { Element childElement = ( Element ) node ; return childElement ; } } while ( ( node = node . getNextSibling ( ) ) != null ) ; } return null ; }
public static void main ( String [ ] args ) throws Exception { final JFrame frame = new HTMLTest ( args ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . pack ( ) ; frame . setVisible ( BOOL_ ) ; }
@ Override public int hashCode ( ) { return rawString . hashCode ( ) ; }
public final void testAddAllHelperTextColorsFromArray ( ) { int helperTextColor1 = Color . BLACK ; int helperTextColor2 = Color . GRAY ; int [ ] helperTextColors1 = new int [ NUM_ ] ; helperTextColors1 [ NUM_ ] = helperTextColor1 ; helperTextColors1 [ NUM_ ] = helperTextColor2 ; PasswordEditText passwordEditText = new PasswordEditText ( getContext ( ) ) ; passwordEditText . addAllHelperTextColors ( helperTextColors1 ) ; passwordEditText . addAllHelperTextColors ( helperTextColors1 ) ; Collection < Integer > helperTextColors2 = passwordEditText . getHelperTextColors ( ) ; assertEquals ( helperTextColors1 . length , helperTextColors2 . size ( ) ) ; Iterator < Integer > iterator = helperTextColors2 . iterator ( ) ; assertEquals ( helperTextColor1 , ( int ) iterator . next ( ) ) ; assertEquals ( helperTextColor2 , ( int ) iterator . next ( ) ) ; }
private void normalize ( double [ ] in ) { double max = NUM_ ; for ( double d : in ) { max = Math . max ( max , d ) ; } for ( int i = NUM_ ; i < in . length ; i ++ ) { in [ i ] = in [ i ] / max ; } }
public void add ( T graphic ) { synchronized ( mLock ) { mGraphics . add ( graphic ) ; } postInvalidate ( ) ; }
public static boolean writeToFile ( String filename , String message , boolean append ) { boolean result ; BufferedWriter writer ; try { writer = new BufferedWriter ( new FileWriter ( filename , append ) ) ; writer . write ( message ) ; writer . newLine ( ) ; writer . flush ( ) ; writer . close ( ) ; result = BOOL_ ; } catch ( Exception e ) { result = BOOL_ ; } return result ; }
public int hashCode ( ) { return ( NUM_ . colorModel . hashCode ( ) ) + ( NUM_ . sampleModel . hashCode ( ) ) ; }
public void writeFile ( String name , String mimeType , String fileName , byte [ ] data ) throws IOException { if ( data == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( fileName == null || fileName . isEmpty ( ) ) { throw new IllegalArgumentException ( STR_ ) ; } out . writeBytes ( PREFIX ) ; out . writeBytes ( boundary ) ; out . writeBytes ( NEWLINE ) ; out . writeBytes ( STR_ + name + STR_ + fileName + STR_ ) ; out . writeBytes ( NEWLINE ) ; if ( mimeType != null ) { out . writeBytes ( STR_ + mimeType ) ; out . writeBytes ( NEWLINE ) ; } out . writeBytes ( NEWLINE ) ; out . write ( data , NUM_ , data . length ) ; out . writeBytes ( NEWLINE ) ; out . flush ( ) ; }
@ TargetApi ( Build . VERSION_CODES . ICE_CREAM_SANDWICH_MR1 ) private void onConfigurationChanged ( Configuration newConfig ) { final Locale newLocale = newConfig . locale ; if ( newLocale . equals ( mSystemLocale ) ) { return ; } mSystemLocale = newLocale ; ensureSupportedLocale ( ) ; }
private static Boolean findConvexPolygon ( final PlanetModel planetModel , final Edge currentEdge , final GeoCompositePolygon rval , final EdgeBuffer edgeBuffer , final List < GeoPolygon > holes , final GeoPoint testPoint ) { final Set < Edge > includedEdges = new HashSet < > ( ) ; includedEdges . add ( currentEdge ) ; Edge firstEdge = currentEdge ; Edge lastEdge = currentEdge ; while ( BOOL_ ) { if ( firstEdge . startPoint == lastEdge . endPoint ) { break ; } final Edge newLastEdge = edgeBuffer . getNext ( lastEdge ) ; if ( isWithin ( newLastEdge . endPoint , includedEdges ) ) { final SidedPlane returnBoundary ; if ( firstEdge . startPoint != newLastEdge . endPoint ) { returnBoundary = new SidedPlane ( firstEdge . endPoint , firstEdge . startPoint , newLastEdge . endPoint ) ; } else { returnBoundary = null ; } boolean foundPointInside = BOOL_ ; final Iterator < Edge > edgeIterator = edgeBuffer . iterator ( ) ; while ( edgeIterator . hasNext ( ) ) { final Edge edge = edgeIterator . next ( ) ; if ( ! includedEdges . contains ( edge ) && edge != newLastEdge ) { if ( edge . startPoint != newLastEdge . endPoint ) { if ( isWithin ( edge . startPoint , includedEdges , newLastEdge , returnBoundary ) ) { foundPointInside = BOOL_ ; break ; } } if ( edge . endPoint != firstEdge . startPoint ) { if ( isWithin ( edge . endPoint , includedEdges , newLastEdge , returnBoundary ) ) { foundPointInside = BOOL_ ; break ; } } } } if ( ! foundPointInside ) { includedEdges . add ( newLastEdge ) ; lastEdge = newLastEdge ; continue ; } } break ; } while ( BOOL_ ) { if ( firstEdge . startPoint == lastEdge . endPoint ) { break ; } final Edge newFirstEdge = edgeBuffer . getPrevious ( firstEdge ) ; if ( isWithin ( newFirstEdge . startPoint , includedEdges ) ) { final SidedPlane returnBoundary ; if ( newFirstEdge . startPoint != lastEdge . endPoint ) { returnBoundary = new SidedPlane ( lastEdge . startPoint , lastEdge . endPoint , newFirstEdge . startPoint ) ; } else { returnBoundary = null ; } boolean foundPointInside = BOOL_ ; final Iterator < Edge > edgeIterator = edgeBuffer . iterator ( ) ; while ( edgeIterator . hasNext ( ) ) { final Edge edge = edgeIterator . next ( ) ; if ( ! includedEdges . contains ( edge ) && edge != newFirstEdge ) { if ( edge . startPoint != lastEdge . endPoint ) { if ( isWithin ( edge . startPoint , includedEdges , newFirstEdge , returnBoundary ) ) { foundPointInside = BOOL_ ; break ; } } if ( edge . endPoint != newFirstEdge . startPoint ) { if ( isWithin ( edge . endPoint , includedEdges , newFirstEdge , returnBoundary ) ) { foundPointInside = BOOL_ ; break ; } } } } if ( ! foundPointInside ) { includedEdges . add ( newFirstEdge ) ; firstEdge = newFirstEdge ; continue ; } } break ; } if ( includedEdges . size ( ) < NUM_ ) { return BOOL_ ; } final List < GeoPoint > points = new ArrayList < GeoPoint > ( includedEdges . size ( ) + NUM_ ) ; final BitSet internalEdges = new BitSet ( includedEdges . size ( ) ) ; final boolean returnIsInternal ; if ( firstEdge . startPoint == lastEdge . endPoint ) { if ( includedEdges . size ( ) < NUM_ ) { return BOOL_ ; } Edge edge = firstEdge ; points . add ( edge . startPoint ) ; int k = NUM_ ; while ( BOOL_ ) { if ( edge == lastEdge ) { break ; } points . add ( edge . endPoint ) ; internalEdges . set ( k ++ , edge . isInternal ) ; edge = edgeBuffer . getNext ( edge ) ; } returnIsInternal = lastEdge . isInternal ; for ( int i = NUM_ ; i < points . size ( ) ; i ++ ) { final GeoPoint start = points . get ( i ) ; final GeoPoint end = points . get ( getLegalIndex ( i + NUM_ , points . size ( ) ) ) ; final Plane planeToFind = new Plane ( start , end ) ; int endPointIndex = - NUM_ ; for ( int j = NUM_ ; j < points . size ( ) ; j ++ ) { final int index = getLegalIndex ( j + i + NUM_ , points . size ( ) ) ; if ( ! planeToFind . evaluateIsZero ( points . get ( index ) ) ) { endPointIndex = index ; break ; } } if ( endPointIndex == - NUM_ ) { return BOOL_ ; } } edgeBuffer . clear ( ) ; } else { final SidedPlane returnSidedPlane = new SidedPlane ( firstEdge . endPoint , BOOL_ , firstEdge . startPoint , lastEdge . endPoint ) ; final Edge returnEdge = new Edge ( firstEdge . startPoint , lastEdge . endPoint , returnSidedPlane , BOOL_ ) ; final List < Edge > edges = new ArrayList < Edge > ( includedEdges . size ( ) ) ; returnIsInternal = BOOL_ ; Edge edge = firstEdge ; points . add ( edge . startPoint ) ; int k = NUM_ ; while ( BOOL_ ) { points . add ( edge . endPoint ) ; internalEdges . set ( k ++ , edge . isInternal ) ; edges . add ( edge ) ; if ( edge == lastEdge ) { break ; } edge = edgeBuffer . getNext ( edge ) ; } for ( int i = NUM_ ; i < points . size ( ) ; i ++ ) { final GeoPoint start = points . get ( i ) ; final GeoPoint end = points . get ( getLegalIndex ( i + NUM_ , points . size ( ) ) ) ; final Plane planeToFind = new Plane ( start , end ) ; int endPointIndex = - NUM_ ; for ( int j = NUM_ ; j < points . size ( ) ; j ++ ) { final int index = getLegalIndex ( j + i + NUM_ , points . size ( ) ) ; if ( ! planeToFind . evaluateIsZero ( points . get ( index ) ) ) { endPointIndex = index ; break ; } } if ( endPointIndex == - NUM_ ) { return BOOL_ ; } } edgeBuffer . replace ( edges , returnEdge ) ; } if ( testPoint != null && holes != null && holes . size ( ) > NUM_ ) { final GeoPolygon testPolygon = new GeoConvexPolygon ( planetModel , points , null , internalEdges , returnIsInternal ) ; if ( testPolygon . isWithin ( testPoint ) ) { return null ; } } final GeoPolygon realPolygon = new GeoConvexPolygon ( planetModel , points , holes , internalEdges , returnIsInternal ) ; if ( testPoint != null && ( holes == null || holes . size ( ) == NUM_ ) ) { if ( realPolygon . isWithin ( testPoint ) ) { return null ; } } rval . addShape ( realPolygon ) ; return BOOL_ ; }
public static Keymap fromKey ( final String key ) { if ( key == null || key . isEmpty ( ) ) { return null ; } final Keymap searchResult = instances . get ( key ) ; return searchResult ; }
private static boolean isGMTish ( String name ) { if ( name . length ( ) < NUM_ ) { return BOOL_ ; } char c1 = name . charAt ( NUM_ ) ; char c2 = name . charAt ( NUM_ ) ; char c3 = name . charAt ( NUM_ ) ; if ( ! ( ( c1 == STR_ || c1 == STR_ ) && ( c2 == STR_ || c2 == STR_ ) && ( c3 == STR_ || c3 == STR_ ) ) && ! ( ( c1 == STR_ || c1 == STR_ ) && ( c2 == STR_ || c2 == STR_ ) && ( c3 == STR_ || c3 == STR_ ) ) && ! ( ( c1 == STR_ || c1 == STR_ ) && ( c2 == STR_ || c2 == STR_ ) && ( c3 == STR_ ) ) ) { return BOOL_ ; } if ( name . length ( ) == NUM_ ) { return BOOL_ ; } String offset = name . substring ( NUM_ ) ; if ( offset . startsWith ( STR_ ) ) { return offset . equals ( STR_ ) || offset . equals ( STR_ ) || offset . equals ( STR_ ) ; } else { return offset . equals ( STR_ ) || offset . equals ( STR_ ) || offset . equals ( STR_ ) ; } }
private static String massageURI ( String uri ) { uri = uri . trim ( ) ; int protocolEnd = uri . indexOf ( STR_ ) ; if ( protocolEnd < NUM_ || isColonFollowedByPortNumber ( uri , protocolEnd ) ) { uri = STR_ + uri ; } return uri ; }
public void delete ( int key ) { int i = binarySearch ( mKeys , NUM_ , mSize , key ) ; if ( i >= NUM_ ) { System . arraycopy ( mKeys , i + NUM_ , mKeys , i , mSize - ( i + NUM_ ) ) ; System . arraycopy ( mValues , i + NUM_ , mValues , i , mSize - ( i + NUM_ ) ) ; mSize -- ; } }
protected void addWholeMatch ( StringBuilder sb , String surface , String analyzed ) { sb . append ( STR_ ) ; sb . append ( surface ) ; sb . append ( STR_ ) ; }
public void start ( ) { stopAt = System . currentTimeMillis ( ) + MAX_PROCESSING_TIME ; }
private Object [ ] singleRow ( int row ) { Object [ ] res = new Object [ this . nFields ] ; for ( int i = NUM_ ; i < this . nFields ; i += NUM_ ) { if ( this . isNull == null || ! this . isNull [ row . this . nFields + i ] ) { res [ i ] = ArrayFuncs . newInstance ( this . types [ i ] , NUM_ ) ; System . arraycopy ( this . data [ i ] , row , res [ i ] , NUM_ , NUM_ ) ; } } return res ; }
public static String removeChars ( String src , String chars ) { int i = src . length ( ) ; StringBuilder sb = new StringBuilder ( i ) ; for ( int j = NUM_ ; j < i ; j ++ ) { char c = src . charAt ( j ) ; if ( chars . indexOf ( c ) == - NUM_ ) { sb . append ( c ) ; } } return sb . toString ( ) ; }
private void addAllColumns ( ) throws SQLException { DatabaseMetaData metaData = getDatabaseMetaData ( ) ; List < String > columns = new ArrayList < > ( ) ; try ( ResultSet rs = metaData . getColumns ( null , null , normalizeObjectName ( statementModel . getTableName ( ) ) , null ) ) { while ( rs . next ( ) ) { columns . add ( quoteObjectName ( rs . getString ( IDX_COLUMN_NAME ) ) ) ; } } columnNames = columns . toArray ( new String [ NUM_ ] ) ; addReturningClause ( ) ; }
public void loadHamNSpam ( Connection conn ) throws java . sql . SQLException { PreparedStatement pstmt = null ; ResultSet rs = null ; try { pstmt = conn . prepareStatement ( sqlQueries . getSqlString ( STR_ , BOOL_ ) ) ; rs = pstmt . executeQuery ( ) ; Map < String , Integer > ham = getHamTokenCounts ( ) ; while ( rs . next ( ) ) { String token = rs . getString ( NUM_ ) ; int count = rs . getInt ( NUM_ ) ; if ( count > NUM_ ) { ham . put ( token , count ) ; } } log ( STR_ + ham . size ( ) ) ; rs . close ( ) ; pstmt . close ( ) ; pstmt = conn . prepareStatement ( sqlQueries . getSqlString ( STR_ , BOOL_ ) ) ; rs = pstmt . executeQuery ( ) ; Map < String , Integer > spam = getSpamTokenCounts ( ) ; while ( rs . next ( ) ) { String token = rs . getString ( NUM_ ) ; int count = rs . getInt ( NUM_ ) ; if ( count > NUM_ ) { spam . put ( token , count ) ; } } log ( STR_ + spam . size ( ) ) ; rs . close ( ) ; pstmt . close ( ) ; pstmt = conn . prepareStatement ( sqlQueries . getSqlString ( STR_ , BOOL_ ) ) ; rs = pstmt . executeQuery ( ) ; if ( rs . next ( ) ) { setHamMessageCount ( rs . getInt ( NUM_ ) ) ; setSpamMessageCount ( rs . getInt ( NUM_ ) ) ; } rs . close ( ) ; pstmt . close ( ) ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( java . sql . SQLException se ) { log ( STR_ , se ) ; } rs = null ; } if ( pstmt != null ) { try { pstmt . close ( ) ; } catch ( java . sql . SQLException se ) { log ( STR_ , se ) ; } pstmt = null ; } } }
static private void copyStream ( final InputStream content , final OutputStream outstr ) throws IOException { final byte [ ] buf = new byte [ GZIP_BUFFER ] ; while ( BOOL_ ) { final int rdlen = content . read ( buf ) ; if ( rdlen <= NUM_ ) { break ; } outstr . write ( buf , NUM_ , rdlen ) ; } }
public void checkAndSetupStreamsDrawer ( ) { setupListViewAdapter ( ) ; }
public void testFpTypeOverrideSimple ( ) throws Exception { ObjectMapper m = new ObjectMapper ( ) ; m . enable ( DeserializationConfig . Feature . USE_BIG_DECIMAL_FOR_FLOATS ) ; BigDecimal dec = new BigDecimal ( STR_ ) ; Number result = m . readValue ( dec . toString ( ) , Number . class ) ; assertEquals ( BigDecimal . class , result . getClass ( ) ) ; assertEquals ( dec , result ) ; Object value = m . readValue ( dec . toString ( ) , Object . class ) ; assertEquals ( BigDecimal . class , result . getClass ( ) ) ; assertEquals ( dec , value ) ; }
private com . codename1 . ui . Component copyComponent ( com . codename1 . ui . Component cmp ) { com . codename1 . ui . Container cnt = builder . createContainer ( res , copiedResourceName ) ; com . codename1 . ui . Component dest = builder . findByName ( cmp . getName ( ) , cnt ) ; if ( dest != null && dest . getParent ( ) != null ) { removeComponentSync ( dest . getParent ( ) , dest ) ; } return dest ; }
static double zetastatic ( long st , long n , double theta , double initialsum ) { double sum = initialsum ; for ( long i = st ; i < n ; i ++ ) { sum += NUM_ / ( Math . pow ( i + NUM_ , theta ) ) ; } return sum ; }
@ Override public BigDecimal calculateTotalPendingAdvance ( final BigDecimal totalAdvancePaid , final Date billDate , final WorkOrderEstimate workOrderEstimate , final Long billId ) { final CChartOfAccounts advanceCOA = contractorAdvanceService . getContractorAdvanceAccountcodeForWOE ( workOrderEstimate . getId ( ) ) ; BigDecimal totalPendingBalance = BigDecimal . ZERO ; BigDecimal totalAdvanceAdjusted = BigDecimal . ZERO ; if ( advanceCOA != null && totalAdvancePaid != null && totalAdvancePaid . compareTo ( BigDecimal . ZERO ) > NUM_ ) { totalAdvanceAdjusted = getTotalAdvanceAdjustedForWOE ( billDate , workOrderEstimate . getId ( ) , advanceCOA . getId ( ) , billId ) ; if ( totalAdvanceAdjusted != null && totalAdvanceAdjusted . compareTo ( BigDecimal . ZERO ) > NUM_ && totalAdvanceAdjusted . compareTo ( BigDecimal . ZERO ) > NUM_ ) totalPendingBalance = totalAdvanceAdjusted . subtract ( totalAdvanceAdjusted ) ; else totalPendingBalance = totalAdvancePaid ; } return totalPendingBalance ; }
private void loadProfile ( String userId , String name ) { final Intent userProfileIntent = new Intent ( getActivity ( ) , UserProfileActivity . class ) ; userProfileIntent . putExtra ( AppConstants . Keys . USER_ID , userId ) ; userProfileIntent . putExtra ( AppConstants . Keys . USER_NAME , name ) ; userProfileIntent . putExtra ( AppConstants . Keys . SERVICE_SCREEN_TYPE , AppConstants . ServiceScreenType . PROFILE ) ; startActivity ( userProfileIntent ) ; }
private void scrollBy ( final int increment ) { index += increment ; if ( index < NUM_ ) { index = NUM_ ; } if ( index >= items . size ( ) ) { index = items . size ( ) - NUM_ ; } redraw ( ) ; }
private static byte [ ] generateSeed ( ) { try { ByteArrayOutputStream seedBuffer = new ByteArrayOutputStream ( ) ; DataOutputStream seedBufferOut = new DataOutputStream ( seedBuffer ) ; seedBufferOut . writeLong ( System . currentTimeMillis ( ) ) ; seedBufferOut . writeLong ( System . nanoTime ( ) ) ; seedBufferOut . writeInt ( Process . myPid ( ) ) ; seedBufferOut . writeInt ( Process . myUid ( ) ) ; seedBufferOut . write ( BUILD_FINGERPRINT_AND_DEVICE_SERIAL ) ; seedBufferOut . close ( ) ; return seedBuffer . toByteArray ( ) ; } catch ( IOException e ) { throw new SecurityException ( STR_ , e ) ; } }
public static boolean symbolNeedsQuoting ( CharSequence symbol , boolean quoteOperators ) { int length = symbol . length ( ) ; if ( length == NUM_ ) { throw new EmptySymbolException ( ) ; } if ( ! isIdentifierKeyword ( symbol ) ) { char c = symbol . charAt ( NUM_ ) ; if ( ! quoteOperators && isOperatorPart ( c ) ) { for ( int ii = NUM_ ; ii < length ; ii ++ ) { c = symbol . charAt ( ii ) ; if ( ! isOperatorPart ( c ) ) { return BOOL_ ; } } return BOOL_ ; } else if ( isIdentifierStart ( c ) ) { for ( int ii = NUM_ ; ii < length ; ii ++ ) { c = symbol . charAt ( ii ) ; if ( ( c == STR_ || c < NUM_ || c > NUM_ ) || ! isIdentifierPart ( c ) ) { return BOOL_ ; } } return BOOL_ ; } } return BOOL_ ; }
public static long parseCommitCounterFile ( final String name , final String ext ) throws NumberFormatException { if ( name == null ) throw new IllegalArgumentException ( ) ; if ( ext == null ) throw new IllegalArgumentException ( ) ; final int len = name . length ( ) - ext . length ( ) ; final String fileBaseName = name . substring ( NUM_ , len ) ; final long commitCounter = Long . parseLong ( fileBaseName ) ; return commitCounter ; }
public static Document loadDocument ( File file ) throws Exception { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; return builder . parse ( file ) ; }
private Node newFloatingComment ( ) { Node c = new Node ( Token . EMPTY ) ; linkCommentToNode ( c ) ; return c ; }
public Boolean isHod ( final Long assignId ) { final List < HeadOfDepartments > hodList = employeeDepartmentRepository . getAllHodDepartments ( assignId ) ; return ! hodList . isEmpty ( ) ; }
public Munger singleLabelMode ( String ... languages ) { return singleLabelMode ( Arrays . asList ( languages ) ) ; }
public StatValue [ ] matchSpec ( StatSpec spec ) { if ( spec . getCombineType ( ) == StatSpec . GLOBAL ) { StatValue [ ] allValues = matchSpec ( new RawStatSpec ( spec ) ) ; if ( allValues . length == NUM_ ) { return allValues ; } else { ComboValue cv = new ComboValue ( allValues ) ; return new StatValue [ ] { cv } ; } } else { List l = new ArrayList ( ) ; StatArchiveReader . StatArchiveFile [ ] archives = getArchives ( ) ; for ( int i = NUM_ ; i < archives . length ; i ++ ) { StatArchiveFile f = archives [ i ] ; if ( spec . archiveMatches ( f . getFile ( ) ) ) { f . matchSpec ( spec , l ) ; } } StatValue [ ] result = new StatValue [ l . size ( ) ] ; return ( StatValue [ ] ) l . toArray ( result ) ; } }
private void assignClusterNums ( int [ ] cl_num ) throws Exception { if ( m_children != null && m_children . size ( ) < NUM_ ) { throw new Exception ( STR_ ) ; } m_clusterNum = cl_num [ NUM_ ] ; cl_num [ NUM_ ] ++ ; if ( m_children != null ) { for ( int i = NUM_ ; i < m_children . size ( ) ; i ++ ) { CNode child = m_children . get ( i ) ; child . assignClusterNums ( cl_num ) ; } } }
protected void closeSubpath ( ) { mPSStream . println ( CLOSEPATH_STR ) ; mPenX = mStartPathX ; mPenY = mStartPathY ; }
public TvShowEpisodeScrapeTask ( List < TvShowEpisode > episodes , MediaScraper mediaScraper ) { super ( BUNDLE . getString ( STR_ ) , episodes . size ( ) , TaskType . BACKGROUND_TASK ) ; this . episodes = episodes ; this . mediaScraper = mediaScraper ; this . scrapeThumb = BOOL_ ; }
public void saveSelection ( IMiniTable miniTable ) { log . info ( STR_ ) ; ArrayList < Integer > results = new ArrayList < Integer > ( ) ; setSelection ( null ) ; int rows = miniTable . getRowCount ( ) ; for ( int i = NUM_ ; i < rows ; i ++ ) { IDColumn id = ( IDColumn ) miniTable . getValueAt ( i , NUM_ ) ; if ( id != null && id . isSelected ( ) ) results . add ( id . getRecord_ID ( ) ) ; } if ( results . size ( ) == NUM_ ) return ; log . config ( STR_ + results . size ( ) ) ; setSelection ( results ) ; }
public ModelMBeanNotificationInfo ( String [ ] notifTypes , String name , String description ) { this ( notifTypes , name , description , null ) ; }
public void cleanBuildTask ( long id ) throws NotFoundException { FutureBuildTask task = tasks . remove ( id ) ; if ( task == null ) { throw new NotFoundException ( String . format ( STR_ , id ) ) ; } task . cancel ( BOOL_ ) ; cleanup ( task ) ; }
public static File createTempDir ( File parent ) { File temp = new File ( parent , Integer . toString ( Math . abs ( UNSEEDED_RANDOM . nextInt ( ) ) % NUM_ ) ) ; temp . delete ( ) ; temp . mkdir ( ) ; temp . deleteOnExit ( ) ; return temp ; }
public String toURI ( ) { CharArrayBuffer buffer = new CharArrayBuffer ( NUM_ ) ; buffer . append ( this . schemeName ) ; buffer . append ( STR_ ) ; buffer . append ( this . hostname ) ; if ( this . port != - NUM_ ) { buffer . append ( STR_ ) ; buffer . append ( Integer . toString ( this . port ) ) ; } return buffer . toString ( ) ; }
public void moveTo ( final int lonCenter , final int latCenter ) { double mLatCenter = GeoMath . latE7ToMercator ( latCenter ) ; double mTop = GeoMath . latE7ToMercator ( top ) ; int newBottom = GeoMath . mercatorToLatE7 ( mLatCenter - ( mTop - bottomMercator ) / NUM_ ) ; try { translate ( ( lonCenter - left - ( int ) ( width / NUM_ ) ) , newBottom - bottom ) ; } catch ( OsmException e ) { e . printStackTrace ( ) ; } }
public void sendEvent ( final String name , final Map < String , String > properties ) { final String eventName = String . format ( TfsTelemetryConstants . PLUGIN_ACTION_EVENT_NAME_FORMAT , name ) ; final PropertyMapBuilder builder = new PropertyMapBuilder ( properties ) ; logger . debug ( String . format ( STR_ , name , builder . toString ( ) ) ) ; if ( telemetryClient != null ) { telemetryClient . trackEvent ( eventName , builder . build ( ) , null ) ; } }
public void handleHeaderColumnPressed ( Point p ) { JTableHeader th = TABLE . getTableHeader ( ) ; int col = th . columnAtPoint ( p ) ; int c = TABLE . convertColumnIndexToModel ( col ) ; if ( c != - NUM_ ) { TABLE . setPressedColumnIndex ( c ) ; th . repaint ( th . getHeaderRect ( col ) ) ; } }
private static List < FixedRecord > createFixedRecords ( int count ) { List < FixedRecord > records = new ArrayList < > ( ) ; for ( int i = NUM_ ; i < count ; i ++ ) { records . add ( new FixedRecord ( i ) ) ; } return records ; }
public TrackedEntityInstanceQueryParams addAttributesIfNotExist ( List < QueryItem > attrs ) { for ( QueryItem attr : attrs ) { if ( attributes != null && ! attributes . contains ( attr ) ) { attributes . add ( attr ) ; } } return this ; }
void recomposeAttributeSets ( ElemAttributeSet attrSet ) { ArrayList attrSetList = ( ArrayList ) m_attrSets . get ( attrSet . getName ( ) ) ; if ( null == attrSetList ) { attrSetList = new ArrayList ( ) ; m_attrSets . put ( attrSet . getName ( ) , attrSetList ) ; } attrSetList . add ( attrSet ) ; }
public static List split ( String str , String regex ) { return ( Arrays . asList ( str . split ( regex ) ) ) ; }
protected final void deleteDBFFDCFiles ( String directoryToDelete ) throws AdeException { try { final File dirToDelete = new File ( directoryToDelete ) ; String [ ] fileList = dirToDelete . list ( ) ; if ( fileList . length == NUM_ ) { dirToDelete . delete ( ) ; } else { for ( int i = NUM_ ; i < fileList . length ; i ++ ) { final File f = new File ( dirToDelete , fileList [ i ] ) ; if ( f . isDirectory ( ) ) { final String filePath = f . getPath ( ) ; deleteDBFFDCFiles ( filePath ) ; continue ; } f . delete ( ) ; } fileList = dirToDelete . list ( ) ; if ( fileList . length == NUM_ ) { dirToDelete . delete ( ) ; } } } catch ( Exception e ) { throw new AdeInternalException ( STR_ , e ) ; } }
Node < K , V > findLast ( ) { Index < K , V > q = head ; for ( ; ; ) { Index < K , V > d , r ; if ( ( r = q . right ) != null ) { if ( r . indexesDeletedNode ( ) ) { q . unlink ( r ) ; q = head ; } else q = r ; } else if ( ( d = q . down ) != null ) { q = d ; } else { Node < K , V > b = q . node ; Node < K , V > n = b . next ; for ( ; ; ) { if ( n == null ) return b . isBaseHeader ( ) ? null : b ; Node < K , V > f = n . next ; if ( n != b . next ) break ; Object v = n . value ; if ( v == null ) { n . helpDelete ( b , f ) ; break ; } if ( v == n || b . value == null ) break ; b = n ; n = f ; } q = head ; } } }
public void appendToNalUnit ( byte [ ] data , int offset , int limit ) { if ( ! isFilling ) { return ; } int readLength = limit - offset ; if ( nalData . length < nalLength + readLength ) { nalData = Arrays . copyOf ( nalData , ( nalLength + readLength ) . NUM_ ) ; } System . arraycopy ( data , offset , nalData , nalLength , readLength ) ; nalLength += readLength ; }
public static long sizeOfDirectory ( File directory ) { checkDirectory ( directory ) ; final File [ ] files = directory . listFiles ( ) ; if ( files == null ) { return NUM_ ; } long size = NUM_ ; for ( final File file : files ) { try { if ( ! isSymlink ( file ) ) { size += sizeOf ( file ) ; if ( size < NUM_ ) { break ; } } } catch ( IOException ioe ) { } } return size ; }
public synchronized void panAbs ( double dx , double dy ) { damageReport ( ) ; m_transform . translate ( dx , dy ) ; try { m_itransform = m_transform . createInverse ( ) ; } catch ( Exception e ) { } }
public static void checkSerializedEquality ( Object object ) { Object object2 = serializeAndRecover ( object ) ; Assert . assertEquals ( STR_ , object , object2 ) ; Assert . assertEquals ( STR_ , object . hashCode ( ) , object2 . hashCode ( ) ) ; }
public String documentationReferenceGuideUrl ( ) { return properties . getProperty ( STR_ ) ; }
public void onConsumeFinished ( Purchase purchase , IabResult result ) ;
public static double mean ( final List < Double > list ) { double sum = NUM_ ; for ( Double number : list ) { sum += number ; } return sum / list . size ( ) ; }
public static String toHex ( byte [ ] data ) { try { return new String ( Hex . encode ( data ) , STR_ ) ; } catch ( UnsupportedEncodingException e ) { } return null ; }
public In ( URL url ) { if ( url == null ) throw new NullPointerException ( STR_ ) ; try { URLConnection site = url . openConnection ( ) ; InputStream is = site . getInputStream ( ) ; scanner = new Scanner ( new BufferedInputStream ( is ) , CHARSET_NAME ) ; scanner . useLocale ( LOCALE ) ; } catch ( IOException ioe ) { throw new IllegalArgumentException ( STR_ + url ) ; } }
@ VisibleForTesting public void processEnableFullscreenRunnableForTest ( ) { if ( mHandler . hasMessages ( MSG_ID_ENABLE_FULLSCREEN_AFTER_LOAD ) ) { mHandler . removeMessages ( MSG_ID_ENABLE_FULLSCREEN_AFTER_LOAD ) ; enableFullscreenAfterLoad ( ) ; } }
private static String fromHtmlEntity ( String str ) { Character ch = map . get ( str ) ; return ( ch != null ) ? ch . toString ( ) : str ; }
public void write ( byte [ ] vector ) { check ( vector . length ) ; System . arraycopy ( vector , NUM_ , buffer , write_pos , vector . length ) ; write_pos += vector . length ; }
public void unlockUI ( ProcessInfo pi ) { boolean notPrint = pi != null && pi . getAD_Process_ID ( ) != m_curTab . getAD_Process_ID ( ) && pi . isReportingProcess ( ) == BOOL_ ; setBusy ( BOOL_ , notPrint ) ; if ( notPrint ) { m_curTab . dataRefresh ( ) ; if ( pi . isTimeout ( ) ) Env . setContext ( m_ctx , m_curWindowNo , STR_ , STR_ ) ; m_curGC . dynamicDisplay ( NUM_ ) ; setStatusLine ( pi . getSummary ( ) , pi . isError ( ) ) ; if ( pi . isError ( ) ) ADialog . error ( m_curWindowNo , this , null , pi . getSummary ( ) ) ; ProcessInfoUtil . setLogFromDB ( pi ) ; String logInfo = pi . getLogInfo ( ) ; if ( logInfo . length ( ) > NUM_ ) ADialog . info ( m_curWindowNo , this , Env . getHeader ( m_ctx , m_curWindowNo ) , pi . getTitle ( ) , logInfo ) ; } else { setStatusLine ( pi . getSummary ( ) , pi . isError ( ) ) ; if ( pi . isError ( ) ) ADialog . error ( m_curWindowNo , this , null , pi . getSummary ( ) ) ; } }
private Map < URI , StorageSystem > buildArrayMap ( StorageSystem vplexSystem , List < VolumeDescriptor > descriptors , VolumeDescriptor . Type [ ] types ) { Map < URI , StorageSystem > arrayMap = new HashMap < URI , StorageSystem > ( ) ; if ( types != null ) { descriptors = VolumeDescriptor . filterByType ( descriptors , types , new VolumeDescriptor . Type [ ] { } ) ; } for ( VolumeDescriptor desc : descriptors ) { if ( arrayMap . containsKey ( desc . getDeviceURI ( ) ) == BOOL_ ) { if ( vplexSystem == null ) { StorageSystem array = getDataObject ( StorageSystem . class , desc . getDeviceURI ( ) , _dbClient ) ; arrayMap . put ( desc . getDeviceURI ( ) , array ) ; } else { Set < URI > connectedSystems = ConnectivityUtil . getStorageSystemAssociationsByNetwork ( _dbClient , vplexSystem . getId ( ) , StoragePort . PortType . backend ) ; if ( connectedSystems . contains ( desc . getDeviceURI ( ) ) ) { StorageSystem array = getDataObject ( StorageSystem . class , desc . getDeviceURI ( ) , _dbClient ) ; arrayMap . put ( desc . getDeviceURI ( ) , array ) ; } } } } return arrayMap ; }
public byte [ ] encrypt ( byte [ ] plainTextAsBytes , CharSequence password ) throws KeyCrypterException { try { byte [ ] salt = new byte [ SALT_LENGTH ] ; secureRandom . nextBytes ( salt ) ; ParametersWithIV key = ( ParametersWithIV ) getAESPasswordKey ( password , salt ) ; BufferedBlockCipher cipher = new PaddedBufferedBlockCipher ( new CBCBlockCipher ( new AESFastEngine ( ) ) ) ; cipher . init ( BOOL_ , key ) ; byte [ ] encryptedBytes = new byte [ cipher . getOutputSize ( plainTextAsBytes . length ) ] ; final int processLength = cipher . processBytes ( plainTextAsBytes , NUM_ , plainTextAsBytes . length , encryptedBytes , NUM_ ) ; final int doFinalLength = cipher . doFinal ( encryptedBytes , processLength ) ; return concat ( salt , Arrays . copyOf ( encryptedBytes , processLength + doFinalLength ) ) ; } catch ( Exception e ) { throw new KeyCrypterException ( STR_ + Utils . bytesToHexString ( plainTextAsBytes ) + STR_ , e ) ; } }
public final ArrayList < WifiRecord > loadWifisByBssid ( final String bssid , final Integer session ) { final ArrayList < WifiRecord > wifis = new ArrayList < > ( ) ; String selectSql ; if ( session != null ) { selectSql = Schema . COL_BSSID + STR_ + bssid + STR_ + Schema . COL_SESSION_ID + STR_ + session + STR_ ; } else { selectSql = Schema . COL_BSSID + STR_ + bssid + STR_ ; } final Cursor cursor = contentResolver . query ( ContentProvider . CONTENT_URI_WIFI , null , selectSql , null , null ) ; final int columnIndex = cursor . getColumnIndex ( Schema . COL_BSSID ) ; final int columnIndex2 = cursor . getColumnIndex ( Schema . COL_SSID ) ; final int columnIndex3 = cursor . getColumnIndex ( Schema . COL_CAPABILITIES ) ; final int columnIndex4 = cursor . getColumnIndex ( Schema . COL_FREQUENCY ) ; final int columnIndex5 = cursor . getColumnIndex ( Schema . COL_LEVEL ) ; final int columnIndex6 = cursor . getColumnIndex ( Schema . COL_TIMESTAMP ) ; final int columnIndex7 = cursor . getColumnIndex ( Schema . COL_BEGIN_POSITION_ID ) ; final int columnIndex8 = cursor . getColumnIndex ( Schema . COL_END_POSITION_ID ) ; final int columnIndex9 = cursor . getColumnIndex ( Schema . COL_KNOWN_WIFI ) ; while ( cursor . moveToNext ( ) ) { final WifiRecord wifi = new WifiRecord ( ) ; wifi . setBssid ( cursor . getString ( columnIndex ) ) ; wifi . setSsid ( cursor . getString ( columnIndex2 ) ) ; wifi . setCapabilities ( cursor . getString ( columnIndex3 ) ) ; wifi . setFrequency ( cursor . getInt ( columnIndex4 ) ) ; wifi . setLevel ( cursor . getInt ( columnIndex5 ) ) ; wifi . setOpenBmapTimestamp ( cursor . getLong ( columnIndex6 ) ) ; wifi . setBeginPosition ( loadPositionById ( cursor . getString ( columnIndex7 ) ) ) ; wifi . setEndPosition ( loadPositionById ( cursor . getString ( columnIndex8 ) ) ) ; wifi . setCatalogStatus ( CatalogStatus . values ( ) [ cursor . getInt ( columnIndex9 ) ] ) ; wifis . add ( wifi ) ; } cursor . close ( ) ; return wifis ; }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case NUM_ : return AFTER_ID ; case NUM_ : return MAX_JOBS ; default : return null ; } }
@ Override public void deinstall ( JEditorPane editor ) { super . deinstall ( editor ) ; editor . removeKeyListener ( this ) ; }
private void pullEvent ( ) { final int newScrollValue ; final int itemDimension ; final float initialMotionValue , lastMotionValue ; switch ( getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : initialMotionValue = mInitialMotionX ; lastMotionValue = mLastMotionX ; break ; case VERTICAL : default : initialMotionValue = mInitialMotionY ; lastMotionValue = mLastMotionY ; break ; } switch ( mCurrentMode ) { case PULL_FROM_END : newScrollValue = Math . round ( Math . max ( initialMotionValue - lastMotionValue , NUM_ ) / FRICTION ) ; itemDimension = getFooterSize ( ) ; break ; case PULL_FROM_START : default : newScrollValue = Math . round ( Math . min ( initialMotionValue - lastMotionValue , NUM_ ) / FRICTION ) ; itemDimension = getHeaderSize ( ) ; break ; } setHeaderScroll ( newScrollValue ) ; if ( newScrollValue != NUM_ && ! isRefreshing ( ) ) { float scale = Math . abs ( newScrollValue ) / ( float ) itemDimension ; switch ( mCurrentMode ) { case PULL_FROM_END : mFooterLayout . onPull ( scale ) ; break ; case PULL_FROM_START : default : mHeaderLayout . onPull ( scale ) ; break ; } if ( mState != State . PULL_TO_REFRESH && itemDimension >= Math . abs ( newScrollValue ) ) { setState ( State . PULL_TO_REFRESH ) ; } else if ( mState == State . PULL_TO_REFRESH && itemDimension < Math . abs ( newScrollValue ) ) { setState ( State . RELEASE_TO_REFRESH ) ; } } }
public boolean isSecure ( ) { return mTlsCipher != null && ! mTlsCipher . isEmpty ( ) ; }
public void sample ( Record rec ) { totalRecs ++ ; if ( samples . size ( ) < MAX_SAMPLES ) { samples . add ( new Sample ( rec , schema ) ) ; updateNewValueInterval ( rec ) ; } else { double flip = random . nextDouble ( ) ; if ( flip < ( double ) MAX_SAMPLES / totalRecs ) { samples . set ( random . nextInt ( MAX_SAMPLES ) , new Sample ( rec , schema ) ) ; updateNewValueInterval ( rec ) ; } } }
public TenantCreateParam prepareTenantParam ( KeystoneTenant tenant ) { TenantCreateParam param = new TenantCreateParam ( CinderConstants . TENANT_NAME_PREFIX + STR_ + tenant . getName ( ) , prepareUserMappings ( tenant . getId ( ) ) ) ; param . setDescription ( getProperTenantDescription ( tenant . getDescription ( ) ) ) ; return param ; }
private void forceInternalError ( ) { throw new InternalError ( STR_ ) ; }
@ Override public void drawHighlight ( Graphics g , int w , int h ) { g . setColor ( Color . black ) ; FontMetrics fm = g . getFontMetrics ( ) ; int l = ( int ) ( m_x . w ) - fm . stringWidth ( m_id ) / NUM_ ; int t = ( int ) ( m_y . h ) - fm . getHeight ( ) / NUM_ ; g . fillRect ( l - NUM_ , t - NUM_ , fm . stringWidth ( m_id ) + NUM_ , fm . getHeight ( ) + fm . getDescent ( ) + NUM_ ) ; drawNode ( g , w , h ) ; }
public static ImageEncoder newInstance ( String format ) { ImageEncoder imageEncoder = null ; String className = ( String ) encoders . get ( format ) ; if ( className == null ) { throw new IllegalArgumentException ( STR_ + format ) ; } try { Class imageEncoderClass = Class . forName ( className ) ; imageEncoder = ( ImageEncoder ) imageEncoderClass . newInstance ( ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( e . toString ( ) ) ; } return imageEncoder ; }
public static void applyPinchZoomImage ( ImageView mImageView ) { mImageView . setOnTouchListener ( new PinchZoom ( ) ) ; }
public static File parse ( String [ ] options , String option , File defValue ) throws Exception { String value = Utils . getOption ( option , options ) ; if ( value . isEmpty ( ) ) return defValue ; else return new File ( value ) ; }
public boolean isAcctBalanced ( ) { if ( m_lines . size ( ) == NUM_ ) return BOOL_ ; BigDecimal balance = getAcctBalance ( ) ; boolean retValue = balance . signum ( ) == NUM_ ; if ( retValue ) log . finer ( toString ( ) ) ; else log . warning ( STR_ + balance + STR_ + toString ( ) ) ; return retValue ; }
public void ensureCapacity ( int minCapacity ) { int oldCapacity = capacity ; if ( minCapacity > oldCapacity ) { int newCapacity = ( oldCapacity . NUM_ ) / NUM_ + NUM_ ; if ( newCapacity < minCapacity ) newCapacity = minCapacity ; BitVector vector = toBitVector ( ) ; vector . setSize ( newCapacity . bitsPerElement ) ; this . bits = vector . elements ( ) ; this . capacity = newCapacity ; } }
private String detailBase ( final Method method ) { final Class < ? > clazz = method . getDeclaringClass ( ) ; final String detailBase = MessageUtils . bundleNameForClass ( clazz ) ; if ( isBlank ( detailBase ) ) { throw new IllegalStateException ( STR_ + clazz ) ; } return detailBase ; }
public void finished ( ) throws IOException { outputStream . close ( ) ; }
public final void lock ( ) { SunToolkit . awtLock ( ) ; }
@ Override public Object createStatement ( Object proxy , Method method , Object [ ] args , Object statement , long time ) { try { Object result = null ; String name = method . getName ( ) ; String sql = null ; Constructor < ? > constructor = null ; if ( compare ( CREATE_STATEMENT , name ) ) { constructor = getConstructor ( CREATE_STATEMENT_IDX , Statement . class ) ; } else if ( compare ( PREPARE_STATEMENT , name ) ) { sql = ( String ) args [ NUM_ ] ; constructor = getConstructor ( PREPARE_STATEMENT_IDX , PreparedStatement . class ) ; if ( sql != null ) { prepareStatement ( sql , time ) ; } } else if ( compare ( PREPARE_CALL , name ) ) { sql = ( String ) args [ NUM_ ] ; constructor = getConstructor ( PREPARE_CALL_IDX , CallableStatement . class ) ; prepareCall ( sql , time ) ; } else { return statement ; } result = constructor . newInstance ( new Object [ ] { new StatementProxy ( statement , sql ) } ) ; return result ; } catch ( Exception x ) { log . warn ( STR_ , x ) ; } return statement ; }
public UpdateResponse remove ( long id ) throws IOException , SolrServerException { UpdateResponse res = solrClient . deleteById ( String . valueOf ( id ) ) ; solrClient . commit ( BOOL_ , BOOL_ , BOOL_ ) ; return res ; }
public void switchSetup ( ) { int retVal ; retVal = m_SetupFileChooser . showOpenDialog ( this ) ; if ( retVal != JFileChooser . APPROVE_OPTION ) { return ; } m_DbUtils . initialize ( m_SetupFileChooser . getSelectedFile ( ) ) ; m_URL = m_DbUtils . getDatabaseURL ( ) ; m_User = m_DbUtils . getUsername ( ) ; m_Password = m_DbUtils . getPassword ( ) ; m_TextURL . setText ( m_URL ) ; }
private ClientDetailsEntity loadClientObject ( final OIDCAuthorizationRequestContext authorizationRequest ) { log . debug ( STR_ , authorizationRequest . getClientId ( ) ) ; return clientService . loadClientByClientId ( authorizationRequest . getClientId ( ) ) ; }
public void addFieldProperty ( String name , String accessorField ) { fieldProperties . add ( new LegacyFieldPropDesc ( name , accessorField ) ) ; }
private void parseNoWildCards ( ) { this . fSegments = new String [ NUM_ ] ; this . fSegments [ NUM_ ] = this . fPattern ; this . fBound = this . fLength ; }
public Map < String , String > environment ( ) { String base64 = toStringBase64 ( ) ; if ( base64 == null || base64 . length ( ) == NUM_ ) { return Collections . emptyMap ( ) ; } Map < String , String > environment = Maps . newHashMap ( ) ; environment . put ( BaggageUtils . BAGGAGE_ENVIRONMENT_VARIABLE , base64 ) ; return environment ; }
@ Override public void drawSeries ( Canvas canvas , Paint paint , List < Float > points , List < Double > values , XYSeriesRenderer seriesRenderer , SupportSeriesRender supportSeriesRender , float yAxisValue , int seriesIndex , int startIndex ) { int seriesNr = mDataset . getSeriesCount ( ) ; int length = points . size ( ) ; paint . setColor ( seriesRenderer . getColor ( ) ) ; paint . setStyle ( Style . FILL ) ; float halfDiffX = getHalfDiffX ( points , length , seriesNr ) ; for ( int i = NUM_ ; i < length ; i += NUM_ ) { float x = points . get ( i ) ; float y = points . get ( i + NUM_ ) ; drawBar ( canvas , x , yAxisValue , x , y , halfDiffX , seriesNr , seriesIndex , paint ) ; } paint . setColor ( seriesRenderer . getColor ( ) ) ; }
public void listenModLog ( String username , String token ) { if ( ! hasServer ( ) ) { return ; } if ( modLogListen . containsKey ( username ) ) { return ; } this . token = token ; long userId = getUserId ( username ) ; modLogListen . put ( username , userId ) ; LOGGER . info ( STR_ + username + STR_ + userId ) ; if ( userId != - NUM_ ) { sendListenModLog ( userId , BOOL_ ) ; } }
public static boolean isValidClassName ( String className ) { if ( className . indexOf ( STR_ ) >= NUM_ ) { return BOOL_ ; } return BOOL_ ; }
@ SuppressWarnings ( STR_ ) public void newMinute ( ) { if ( ! inSyncWithInternalFastClock ) { return ; } if ( correctFastClock || synchronizeWithInternalClock ) { Date now = clock . getTime ( ) ; if ( now . getMinutes ( ) != NUM_ ) { curDays = now . getDate ( ) ; curHours = now . getHours ( ) ; curMinutes = now . getMinutes ( ) ; long millis = now . getTime ( ) ; long elapsedMS = millis % MSECPERMINUTE ; double frac_min = elapsedMS / ( double ) MSECPERMINUTE ; curFractionalMinutes = ( int ) CORRECTION - ( int ) ( CORRECTION . frac_min ) ; setClock ( ) ; } } else if ( setInternal && ! correctFastClock && ! synchronizeWithInternalClock ) { inSyncWithInternalFastClock = BOOL_ ; initiateRead ( ) ; } }
private < T extends DiscoveredSystemObject > boolean isDataCollectionScanJobSchedulingNeeded ( long lastScanTime , boolean inProgress ) { long systemTime = System . currentTimeMillis ( ) ; long refreshInterval = getRefreshInterval ( ControllerServiceImpl . SCANNER ) ; if ( inProgress ) { return BOOL_ ; } if ( lastScanTime > NUM_ && ( systemTime - lastScanTime < refreshInterval . NUM_ ) ) { _logger . info ( STR_ ) ; return BOOL_ ; } return BOOL_ ; }
private void removeBreakpoints ( final Set < BreakpointAddress > breakpointAddressSet , final BreakpointStorage storage ) { if ( breakpointAddressSet . size ( ) != NUM_ ) { final Set < Breakpoint > breakpoints = storage . getBreakPointsByAddress ( breakpointAddressSet ) ; storage . removeBreakpoints ( breakpointAddressSet ) ; for ( final BreakpointManagerListener listener : listeners ) { try { listener . breakpointsRemoved ( breakpoints ) ; } catch ( final Exception e ) { CUtilityFunctions . logException ( e ) ; } } } }
public void replaceCreationTemplate ( Guid guid , String templateName , AttrSet attrSet ) throws ConfigManagerException { if ( guid == null ) { guid = new Guid ( _rootDN ) ; } DN dn = DN . valueOf ( guid . getDn ( ) ) ; String org = STR_ ; List < RDN > rdns = new ArrayList < > ( ) ; for ( RDN rdn : dn ) { rdns . add ( NUM_ , rdn ) ; } for ( RDN rdn : rdns ) { org = org + STR_ + LDAPUtils . rdnValue ( rdn ) ; } String service = CREATIONPATH + STR_ + templateName ; Map map = convertToMap ( attrSet ) ; try { replaceServiceAttributes ( org , service , map ) ; } catch ( SMSException e ) { String args [ ] = new String [ NUM_ ] ; args [ NUM_ ] = e . toString ( ) ; throw new ConfigManagerException ( i18n . getString ( IUMSConstants . ERROR_CM , args ) ) ; } catch ( SSOException se ) { String args [ ] = new String [ NUM_ ] ; args [ NUM_ ] = se . toString ( ) ; throw new ConfigManagerException ( i18n . getString ( IUMSConstants . ERROR_CM , args ) ) ; } }
private void readObject ( ObjectInputStream stream ) throws IOException , ClassNotFoundException { stream . defaultReadObject ( ) ; MarshalledInstance mi = ( MarshalledInstance ) stream . readObject ( ) ; try { listener = ( RemoteEventListener ) mi . get ( BOOL_ ) ; } catch ( Throwable e ) { if ( e instanceof Error && ThrowableConstants . retryable ( e ) == ThrowableConstants . BAD_OBJECT ) { throw ( Error ) e ; } logger . log ( Level . WARNING , STR_ , e ) ; } }
public void add ( T item ) { if ( set . add ( item ) ) { fireContentsChanged ( this , NUM_ , getSize ( ) - NUM_ ) ; } }
private String byteArrayToHexString ( byte [ ] bytes ) { StringBuilder sb = new StringBuilder ( bytes . length . NUM_ ) ; for ( byte element : bytes ) { int v = element & xff ; if ( v < NUM_ ) { sb . append ( STR_ ) ; } sb . append ( Integer . toHexString ( v ) ) ; } return sb . toString ( ) ; }
public ScServer createClusterServer ( String ssn , String clusterName , String osId ) throws StorageCenterAPIException { Parameters params = new Parameters ( ) ; params . add ( STR_ , clusterName ) ; params . add ( STR_ , ssn ) ; params . add ( STR_ , NOTES_STRING ) ; params . add ( STR_ , osId ) ; RestResult rr = restClient . post ( STR_ , params . toJson ( ) ) ; if ( ! checkResults ( rr ) ) { String error = String . format ( STR_ , clusterName , rr . getErrorMsg ( ) ) ; throw new StorageCenterAPIException ( error ) ; } return gson . fromJson ( rr . getResult ( ) , ScServer . class ) ; }
public void testConstructorSignBytesPositive4 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ } ; int aSign = NUM_ ; byte rBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , aNumber . signum ( ) ) ; }
public void testMinimalCompletionStage ( ) { CompletableFuture < Integer > f = new CompletableFuture < > ( ) ; CompletionStage < Integer > g = f . minimalCompletionStage ( ) ; AtomicInteger x = new AtomicInteger ( NUM_ ) ; AtomicReference < Throwable > r = new AtomicReference < Throwable > ( ) ; checkIncomplete ( f ) ; g . whenComplete ( null ) ; f . complete ( NUM_ ) ; checkCompletedNormally ( f , NUM_ ) ; assertEquals ( x . get ( ) , NUM_ ) ; assertNull ( r . get ( ) ) ; }
private void writeDirectoryPostResource ( Element postResourceEl , String path ) { postResourceEl . setAttribute ( STR_ , DIR_RESOURCE_SET ) ; postResourceEl . setAttribute ( STR_ , path . replace ( STR_ , STR_ ) ) ; }
private static int [ ] trimArray ( int [ ] array , int size ) { if ( size < NUM_ ) { throw new IllegalArgumentException ( ) ; } if ( size == NUM_ ) { return NO_ERRORS ; } int [ ] a = new int [ size ] ; System . arraycopy ( array , NUM_ , a , NUM_ , size ) ; return a ; }
static PotionType fromName ( String name ) { for ( PotionTypeTable table : values ( ) ) { if ( name . equalsIgnoreCase ( table . name ) ) return table . type ; } return PotionType . valueOf ( name . toUpperCase ( ) ) ; }
public synchronized void removeCurlMesh ( CurlMesh mesh ) { while ( mCurlMeshes . remove ( mesh ) ) ; }
private List < Datum > sampleNbestList ( int sourceId , Sequence < IString > source , SentenceLevelMetric < IString , String > scoreMetric , List < RichTranslation < IString , String > > translations , List < Sequence < IString > > references ) { int [ ] sourceIds = new int [ NUM_ ] ; sourceIds [ NUM_ ] = sourceId ; List < Sequence < IString > > sources = new ArrayList < > ( NUM_ ) ; sources . add ( source ) ; List < List < RichTranslation < IString , String > > > translationList = new ArrayList < List < RichTranslation < IString , String > > > ( NUM_ ) ; translationList . add ( translations ) ; List < List < Sequence < IString > > > referenceList = new ArrayList < List < Sequence < IString > > > ( NUM_ ) ; referenceList . add ( references ) ; return sampleNbestLists ( sourceIds , sources , scoreMetric , translationList , referenceList ) ; }
protected void postRunnable ( Runnable runnable ) { if ( runnable != null ) { handler . post ( runnable ) ; } }
public boolean isClosed ( ) { return map . isClosed ( ) ; }
public void insertThinkTime ( ) { ScriptStep thinkTimeScriptStep = ScriptStepFactory . createThinkTime ( getMinThinkTime ( ) , getMaxThinkTime ( ) ) ; steps . add ( getInsertIndex ( ) , thinkTimeScriptStep ) ; minThinkTime = STR_ ; maxThinkTime = STR_ ; reindexScriptSteps ( ) ; }
public static boolean copyStream ( InputStream is , OutputStream os , CopyListener listener , int bufferSize ) throws IOException { int current = NUM_ ; int total = is . available ( ) ; if ( total <= NUM_ ) { total = DEFAULT_IMAGE_TOTAL_SIZE ; } final byte [ ] bytes = new byte [ bufferSize ] ; int count ; if ( shouldStopLoading ( listener , current , total ) ) return BOOL_ ; while ( ( count = is . read ( bytes , NUM_ , bufferSize ) ) != - NUM_ ) { os . write ( bytes , NUM_ , count ) ; current += count ; if ( shouldStopLoading ( listener , current , total ) ) return BOOL_ ; } os . flush ( ) ; return BOOL_ ; }
public void addNode ( final Instruction instruction ) { instructions . add ( instruction ) ; if ( prevInstruction != null ) { addEdge ( prevInstruction , instruction ) ; } prevInstruction = instruction ; }
public void ensureCapacity ( int minimumCapacity ) { if ( minimumCapacity <= _capacity ) return ; if ( minimumCapacity > x1000 ) { _capacity = ( minimumCapacity + xfff ) & ~ xfff ; } else { while ( _capacity < minimumCapacity ) { _capacity += _capacity ; } } byte [ ] bytes = new byte [ _capacity ] ; System . arraycopy ( _buffer , NUM_ , bytes , NUM_ , _length ) ; _buffer = bytes ; }
public Builder removeName ( final String name ) { names . remove ( name ) ; return this ; }
public < T > JSONAPIDocument < List < T > > readDocumentCollection ( InputStream dataStream , Class < T > clazz ) { try { resourceCache . init ( ) ; JsonNode rootNode = objectMapper . readTree ( dataStream ) ; ValidationUtils . ensureNotError ( objectMapper , rootNode ) ; ValidationUtils . ensureCollection ( rootNode ) ; resourceCache . cache ( parseIncluded ( rootNode ) ) ; List < T > resourceList = new ArrayList < > ( ) ; for ( JsonNode element : rootNode . get ( DATA ) ) { T pojo = readObject ( element , clazz , BOOL_ ) ; resourceList . add ( pojo ) ; } JSONAPIDocument < List < T > > result = new JSONAPIDocument < > ( resourceList , objectMapper ) ; if ( rootNode . has ( META ) ) { result . setMeta ( mapMeta ( rootNode . get ( META ) ) ) ; } if ( rootNode . has ( LINKS ) ) { result . setLinks ( new Links ( mapLinks ( rootNode . get ( LINKS ) ) ) ) ; } return result ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } finally { resourceCache . clear ( ) ; } }
public void addTargetedBySwarm ( int entityId , int weaponId ) { hitBySwarmsEntity . addElement ( new Integer ( entityId ) ) ; hitBySwarmsWeapon . addElement ( new Integer ( weaponId ) ) ; }
private boolean isCheckpointExists ( Connection conn , String key ) throws SQLException { PreparedStatement st = null ; ResultSet rs = null ; try { st = conn . prepareStatement ( chkExistsSql ) ; st . setString ( NUM_ , key ) ; rs = st . executeQuery ( ) ; return rs . next ( ) ; } finally { U . close ( rs , log ) ; U . close ( st , log ) ; } }
public OMScalingRaster ( double ullat , double ullon , double lrlat , double lrlon , ImageIcon ii ) { this ( ullat , ullon , lrlat , lrlon , ii . getImage ( ) ) ; }
private static ResultPoint [ ] findVertices ( BitMatrix matrix , boolean tryHarder ) { int height = matrix . getHeight ( ) ; int width = matrix . getWidth ( ) ; ResultPoint [ ] result = new ResultPoint [ NUM_ ] ; boolean found = BOOL_ ; int [ ] counters = new int [ START_PATTERN . length ] ; int rowStep = Math . max ( NUM_ , height > > ( tryHarder ? NUM_ : NUM_ ) ) ; for ( int i = NUM_ ; i < height ; i += rowStep ) { int [ ] loc = findGuardPattern ( matrix , NUM_ , i , width , BOOL_ , START_PATTERN , counters ) ; if ( loc != null ) { result [ NUM_ ] = new ResultPoint ( loc [ NUM_ ] , i ) ; result [ NUM_ ] = new ResultPoint ( loc [ NUM_ ] , i ) ; found = BOOL_ ; break ; } } if ( found ) { found = BOOL_ ; for ( int i = height - NUM_ ; i > NUM_ ; i -= rowStep ) { int [ ] loc = findGuardPattern ( matrix , NUM_ , i , width , BOOL_ , START_PATTERN , counters ) ; if ( loc != null ) { result [ NUM_ ] = new ResultPoint ( loc [ NUM_ ] , i ) ; result [ NUM_ ] = new ResultPoint ( loc [ NUM_ ] , i ) ; found = BOOL_ ; break ; } } } counters = new int [ STOP_PATTERN . length ] ; if ( found ) { found = BOOL_ ; for ( int i = NUM_ ; i < height ; i += rowStep ) { int [ ] loc = findGuardPattern ( matrix , NUM_ , i , width , BOOL_ , STOP_PATTERN , counters ) ; if ( loc != null ) { result [ NUM_ ] = new ResultPoint ( loc [ NUM_ ] , i ) ; result [ NUM_ ] = new ResultPoint ( loc [ NUM_ ] , i ) ; found = BOOL_ ; break ; } } } if ( found ) { found = BOOL_ ; for ( int i = height - NUM_ ; i > NUM_ ; i -= rowStep ) { int [ ] loc = findGuardPattern ( matrix , NUM_ , i , width , BOOL_ , STOP_PATTERN , counters ) ; if ( loc != null ) { result [ NUM_ ] = new ResultPoint ( loc [ NUM_ ] , i ) ; result [ NUM_ ] = new ResultPoint ( loc [ NUM_ ] , i ) ; found = BOOL_ ; break ; } } } return found ? result : null ; }
public static void copyStream ( InputStream is , OutputStream os , byte [ ] buffer , int bufferSize , String confid , double fileSize , Context context ) throws IOException { double downloaded = NUM_ ; int [ ] update = new int [ NUM_ ] ; try { for ( ; ; ) { int count = is . read ( buffer , NUM_ , bufferSize ) ; downloaded += count ; if ( count == - NUM_ ) { if ( context != null ) { } break ; } os . write ( buffer , NUM_ , count ) ; if ( context != null ) { update [ NUM_ ] = ( int ) downloaded ; update [ NUM_ ] = ( int ) fileSize ; update [ NUM_ ] = ( int ) ( ( downloaded / fileSize ) . NUM_ ) ; } } } catch ( IOException e ) { throw e ; } }
@ Override public void writeHeader ( ) throws IOException { os = new PDFWriter ( new BufferedOutputStream ( ros ) , PDF_VERSION ) ; delayImageQueue = new PDFImageDelayQueue ( os ) ; delayPaintQueue = new PDFPaintDelayQueue ( os , delayImageQueue ) ; fontTable = new PDFFontTable ( os ) ; PDFDocInfo info = os . openDocInfo ( STR_ ) ; info . setTitle ( getProperty ( TITLE ) ) ; info . setAuthor ( getProperty ( AUTHOR ) ) ; info . setSubject ( getProperty ( SUBJECT ) ) ; info . setKeywords ( getProperty ( KEYWORDS ) ) ; info . setCreator ( getCreator ( ) ) ; info . setProducer ( producer == null ? STR_ : producer ) ; if ( ! isDeviceIndependent ( ) ) { Calendar now = Calendar . getInstance ( ) ; info . setCreationDate ( now ) ; info . setModificationDate ( now ) ; } info . setTrapped ( STR_ ) ; os . close ( info ) ; PDFCatalog catalog = os . openCatalog ( STR_ , STR_ ) ; catalog . setOutlines ( STR_ ) ; catalog . setPageMode ( STR_ ) ; catalog . setViewerPreferences ( STR_ ) ; catalog . setOpenAction ( new Object [ ] { os . ref ( STR_ ) , os . name ( STR_ ) } ) ; os . close ( catalog ) ; PDFViewerPreferences prefs = os . openViewerPreferences ( STR_ ) ; prefs . setFitWindow ( BOOL_ ) ; prefs . setCenterWindow ( BOOL_ ) ; os . close ( prefs ) ; alphaIndex = NUM_ ; extGStates = new HashMap < Float , String > ( ) ; if ( ! isMultiPage ( ) ) { openPage ( getSize ( ) , null ) ; } }
protected String parseString ( int closingCharacter ) throws IOException , RDFParseException { StringBuilder sb = getBuilder ( ) ; while ( BOOL_ ) { int c = readCodePoint ( ) ; if ( c == closingCharacter ) { break ; } else if ( c == - NUM_ ) { throwEOFException ( ) ; } appendCodepoint ( sb , c ) ; if ( c == STR_ ) { c = readCodePoint ( ) ; if ( c == - NUM_ ) { throwEOFException ( ) ; } appendCodepoint ( sb , c ) ; } } return sb . toString ( ) ; }
private void codeUnwrapReturnValue ( Class < ? > type , DataOutputStream out ) throws IOException { if ( type . isPrimitive ( ) ) { PrimitiveTypeInfo prim = PrimitiveTypeInfo . get ( type ) ; out . writeByte ( opc_checkcast ) ; out . writeShort ( cp . getClass ( prim . wrapperClassName ) ) ; out . writeByte ( opc_invokevirtual ) ; out . writeShort ( cp . getMethodRef ( prim . wrapperClassName , prim . unwrapMethodName , prim . unwrapMethodDesc ) ) ; if ( type == int . class || type == boolean . class || type == byte . class || type == char . class || type == short . class ) { out . writeByte ( opc_ireturn ) ; } else if ( type == long . class ) { out . writeByte ( opc_lreturn ) ; } else if ( type == float . class ) { out . writeByte ( opc_freturn ) ; } else if ( type == double . class ) { out . writeByte ( opc_dreturn ) ; } else { throw new AssertionError ( ) ; } } else { out . writeByte ( opc_checkcast ) ; out . writeShort ( cp . getClass ( dotToSlash ( type . getName ( ) ) ) ) ; out . writeByte ( opc_areturn ) ; } }
private String formatLink ( String [ ] parts ) { String anchor , text ; if ( parts . length < NUM_ ) { anchor = STR_ ; text = STR_ ; } else { anchor = parts [ NUM_ ] ; text = parts [ NUM_ ] ; } return String . format ( STR_ , anchor , text ) ; }
public JSONException ( Throwable cause ) { super ( cause . getMessage ( ) ) ; this . cause = cause ; }
public boolean fixUtils ( String [ ] utils ) throws Exception { for ( String util : utils ) { if ( ! checkUtil ( util ) ) { if ( checkUtil ( STR_ ) ) { if ( hasUtil ( util , STR_ ) ) { fixUtil ( util , RootTools . utilPath ) ; } } else { if ( checkUtil ( STR_ ) ) { if ( hasUtil ( util , STR_ ) ) { fixUtil ( util , RootTools . utilPath ) ; } } else { return BOOL_ ; } } } } return BOOL_ ; }
@ Override protected void initialize ( ) { List < String > patterns ; super . initialize ( ) ; m_Patterns = new ArrayList < Pattern > ( ) ; patterns = read ( ) ; for ( String pattern : patterns ) { m_Patterns . add ( Pattern . compile ( pattern ) ) ; } }
public static String [ ] lsDirectories ( String directory ) throws Exception { String [ ] tmp = ls ( directory ) ; ArrayList < String > files = new ArrayList < > ( ) ; for ( String s : tmp ) { if ( isDirectory ( directory + File . separator + s ) ) files . add ( s ) ; } return files . toArray ( new String [ files . size ( ) ] ) ; }
private void toStringWithChildren ( StringBuffer buffer , int indent ) { internalToString ( buffer , indent ) ; if ( fChildren != null ) { for ( Iterator < TextEdit > iterator = fChildren . iterator ( ) ; iterator . hasNext ( ) ; ) { TextEdit child = iterator . next ( ) ; buffer . append ( STR_ ) ; child . toStringWithChildren ( buffer , indent + NUM_ ) ; } } }
public static void encode ( Appendable out , int value ) throws IOException { value = toVLQSigned ( value ) ; do { int digit = value & VLQ_BASE_MASK ; value >>>= VLQ_BASE_SHIFT ; if ( value > NUM_ ) { digit |= VLQ_CONTINUATION_BIT ; } out . append ( Base64 . toBase64 ( digit ) ) ; } while ( value > NUM_ ) ; }
public mxICellOverlay removeCellOverlay ( Object cell , mxICellOverlay overlay ) { if ( overlay == null ) { removeCellOverlays ( cell ) ; } else { mxICellOverlay [ ] arr = getCellOverlays ( cell ) ; if ( arr != null ) { List < mxICellOverlay > list = Arrays . asList ( arr ) ; if ( list . remove ( overlay ) ) { removeCellOverlayComponent ( overlay , cell ) ; } arr = ( mxICellOverlay [ ] ) list . toArray ( ) ; overlays . put ( cell , arr ) ; } } return overlay ; }
public void removeForeignKey ( int idx ) { foreignKeys . remove ( idx ) ; }
public java . lang . StringBuffer insert ( int offset , int i ) { internal . insert ( offset , i ) ; return this ; }
public void addGefaehrdungsUmsetzung ( GefaehrdungsUmsetzung gefaehrdung ) { if ( ! allGefaehrdungsUmsetzungen . contains ( gefaehrdung ) ) { allGefaehrdungsUmsetzungen . add ( gefaehrdung ) ; } }
String normalizeClassPath ( String classPath , boolean generateRelative ) { char sep = CauchoUtil . getPathSeparatorChar ( ) ; int head = NUM_ ; int tail = NUM_ ; CharBuffer cb = CharBuffer . allocate ( ) ; while ( head < classPath . length ( ) ) { tail = classPath . indexOf ( sep , head ) ; if ( tail < NUM_ ) tail = classPath . length ( ) ; if ( tail > head ) { String segment = classPath . substring ( head , tail ) ; segment = normalizePath ( segment , generateRelative ) ; if ( segment != null ) { if ( cb . length ( ) != NUM_ ) cb . append ( sep ) ; cb . append ( segment ) ; } } head = tail + NUM_ ; } return cb . close ( ) ; }
protected ASN1Sequence ( ASN1Encodable obj ) { seq . addElement ( obj ) ; }
public final void push ( int value ) { int ff = m_firstFree ; if ( ( ff + NUM_ ) >= m_mapSize ) { if ( null == m_map ) { m_map = new int [ m_blocksize ] ; m_mapSize = m_blocksize ; } else { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , NUM_ , newMap , NUM_ , ff + NUM_ ) ; m_map = newMap ; } } m_map [ ff ] = value ; ff ++ ; m_firstFree = ff ; }
protected Node stringConversion ( Node node ) { TypeElement stringElement = elements . getTypeElement ( STR_ ) ; if ( ! TypesUtils . isString ( node . getType ( ) ) ) { Node converted = new StringConversionNode ( node . getTree ( ) , node , stringElement . asType ( ) ) ; addToConvertedLookupMap ( converted ) ; insertNodeAfter ( converted , node ) ; return converted ; } else { return node ; } }
@ KnownFailure ( STR_ ) public void testUpdate7 ( ) throws SQLException { DatabaseCreator . fillFKStrictTable ( conn ) ; statement . executeUpdate ( STR_ + DatabaseCreator . FKSTRICT_TABLE + STR_ + DatabaseCreator . PARENT_TABLE + STR_ ) ; ResultSet r = statement . executeQuery ( STR_ + DatabaseCreator . FKSTRICT_TABLE + STR_ ) ; r . next ( ) ; assertEquals ( STR_ , NUM_ , r . getInt ( NUM_ ) ) ; r . close ( ) ; }
CompletableFuture < HistoryReadResponse > historyRead ( HistoryReadDetails historyReadDetails , TimestampsToReturn timestampsToReturn , boolean releaseContinuationPoints , List < HistoryReadValueId > nodesToRead ) ;
private void validate ( ) throws URISyntaxException { String s = getScheme ( ) ; if ( ( s != null ) && ( s . compareTo ( STR_ ) == NUM_ ) ) { return ; } if ( getLocalVmId ( ) == - NUM_ ) { throw new URISyntaxException ( uri . toString ( ) , STR_ ) ; } }
public synchronized void finishWriting ( ) { doneWriting = BOOL_ ; notifyAll ( ) ; }
private long offset2PhysicalAddress ( final long offset ) { return offset + headerSize ; }
@ Override public void internalEntityDecl ( String name , XMLString text , XMLString nonNormalizedText , Augmentations augs ) throws XNIException { try { if ( fDeclHandler != null ) { fDeclHandler . internalEntityDecl ( name , text . toString ( ) ) ; } } catch ( SAXException e ) { throw new XNIException ( e ) ; } }
public static boolean isAuthorized ( String logName , String operation , Object credential ) { return authorizer . isAuthorized ( logName , operation , credential ) ; }
public Object next ( ) { if ( pos < size ) return Array . get ( array , pos ++ ) ; throw new NoSuchElementException ( STR_ + pos + STR_ + size ) ; }
public void addMessages ( List < ? extends Message > messages ) { if ( SHOW_LOGS ) Logger . v ( TAG , STR_ + messages ) ; mQueueLock . lock ( TAG ) ; mPlayerMessagesQueue . addAll ( messages ) ; mQueueLock . notify ( TAG ) ; if ( SHOW_LOGS ) Logger . v ( TAG , STR_ + messages ) ; mQueueLock . unlock ( TAG ) ; }
public PermissionRequestObject onRational ( Func3 rationalFunc ) { mRationalFunc = rationalFunc ; return this ; }
public GenericPrincipal ( String userName , String password , List < String > roles , Map < String , List < GenericPrincipal . Attribute > > writeEntries , Map < String , List < GenericPrincipal . Attribute > > readEntries , Map < String , List < GenericPrincipal . Attribute > > executeTasks ) { this . userName = userName ; this . password = password ; this . writeEntries = writeEntries ; this . readEntries = readEntries ; this . executeTasks = executeTasks ; if ( roles != null ) { this . roles = new String [ roles . size ( ) ] ; this . roles = roles . toArray ( this . roles ) ; if ( this . roles . length > NUM_ ) Arrays . sort ( this . roles ) ; } writeMatchObjects = new HashMap < String , MatchObject > ( ) ; readMatchObjects = new HashMap < String , MatchObject > ( ) ; executeMatchObjects = new HashMap < String , MatchObject > ( ) ; userDefinedRoles = new ArrayList < String > ( ) ; }
public boolean equals ( Object other ) { if ( other == this ) { return BOOL_ ; } if ( ! ( other instanceof X509CRLEntry ) ) { return BOOL_ ; } X509CRLEntry obj = ( X509CRLEntry ) other ; try { return Arrays . equals ( getEncoded ( ) , obj . getEncoded ( ) ) ; } catch ( CRLException e ) { return BOOL_ ; } }
public static int roll1D6 ( ) { return rand . nextInt ( NUM_ ) + NUM_ ; }
static byte [ ] septetStream2octetStream ( byte [ ] septets ) { int octetLength = ( int ) Math . ceil ( ( ( septets . length . NUM_ ) ) / NUM_ ) ; byte [ ] octets = new byte [ octetLength ] ; for ( int i = NUM_ ; i < septets . length ; i ++ ) { for ( int j = NUM_ ; j < NUM_ ; j ++ ) { if ( ( septets [ i ] & ( NUM_ << j ) ) != NUM_ ) { int bitIndex = ( i . NUM_ ) + j ; octets [ bitIndex > > > NUM_ ] |= NUM_ << ( bitIndex & NUM_ ) ; } } } return octets ; }
public CTaggingPanel ( final JFrame parent , final ZyGraph graph , final ITagManager manager ) { super ( new BorderLayout ( ) ) ; m_tagsTree = new CTagsTree ( parent , graph , manager ) ; final JScrollPane pane = new JScrollPane ( m_tagsTree ) ; pane . setVerticalScrollBarPolicy ( ScrollPaneConstants . VERTICAL_SCROLLBAR_AS_NEEDED ) ; pane . setHorizontalScrollBarPolicy ( ScrollPaneConstants . HORIZONTAL_SCROLLBAR_AS_NEEDED ) ; add ( pane ) ; setBorder ( new TitledBorder ( new LineBorder ( Color . LIGHT_GRAY , NUM_ , BOOL_ ) , STR_ ) ) ; setDoubleBuffered ( BOOL_ ) ; }
@ Override public double height ( final int markerIndex ) { MathUtils . checkRangeInclusive ( markerIndex , NUM_ , markerArray . length - NUM_ ) ; return markerArray [ markerIndex ] . markerHeight ; }
public < K , V > void consume ( String groupId , String clientId , OffsetResetStrategy autoOffsetReset , Deserializer < K > keyDeserializer , Deserializer < V > valueDeserializer , BooleanSupplier continuation , OffsetCommitCallback offsetCommitCallback , Runnable completion , Collection < String > topics , java . util . function . Consumer < ConsumerRecord < K , V > > consumerFunction ) { Properties props = getConsumerProperties ( groupId , clientId , autoOffsetReset ) ; Thread t = new Thread ( null ) ; t . setName ( clientId + STR_ ) ; t . start ( ) ; }
public double distance ( Instance first , Instance second , PerformanceStats stats ) { return Math . sqrt ( distance ( first , second , Double . POSITIVE_INFINITY , stats ) ) ; }
private boolean journalRebuildRequired ( ) { final int redundantOpCompactThreshold = NUM_ ; return redundantOpCount >= redundantOpCompactThreshold && redundantOpCount >= lruEntries . size ( ) ; }
public void findSameAsChaining ( Resource subj , Set < Resource > currentSameAs , Resource [ ] contxts ) throws InferenceEngineException { try { CloseableIteration < Statement , QueryEvaluationException > subjIter = RyaDAOHelper . query ( ryaDAO , subj , OWL . SAMEAS , null , conf , contxts ) ; while ( subjIter . hasNext ( ) ) { Statement st = subjIter . next ( ) ; if ( ! currentSameAs . contains ( st . getObject ( ) ) ) { Resource castedObj = ( Resource ) st . getObject ( ) ; currentSameAs . add ( castedObj ) ; findSameAsChaining ( castedObj , currentSameAs , contxts ) ; } } subjIter . close ( ) ; CloseableIteration < Statement , QueryEvaluationException > objIter = RyaDAOHelper . query ( ryaDAO , null , OWL . SAMEAS , subj , conf , contxts ) ; while ( objIter . hasNext ( ) ) { Statement st = objIter . next ( ) ; if ( ! currentSameAs . contains ( st . getSubject ( ) ) ) { Resource sameAsSubj = st . getSubject ( ) ; currentSameAs . add ( sameAsSubj ) ; findSameAsChaining ( sameAsSubj , currentSameAs , contxts ) ; } } objIter . close ( ) ; } catch ( QueryEvaluationException e ) { throw new InferenceEngineException ( e ) ; } }
public static void reindex ( Connection conn ) throws SQLException { init ( conn ) ; removeAllTriggers ( conn , TRIGGER_PREFIX ) ; removeIndexFiles ( conn ) ; Statement stat = conn . createStatement ( ) ; ResultSet rs = stat . executeQuery ( STR_ + SCHEMA + STR_ ) ; while ( rs . next ( ) ) { String schema = rs . getString ( STR_ ) ; String table = rs . getString ( STR_ ) ; createTrigger ( conn , schema , table ) ; indexExistingRows ( conn , schema , table ) ; } }
String toDot ( ) { StringBuilder buf = new StringBuilder ( ) ; for ( Type t : inferenceContext . undetvars ) { UndetVar uv = ( UndetVar ) t ; buf . append ( String . format ( STR_ , uv . qtype , uv . getBounds ( InferenceBound . UPPER ) , uv . getBounds ( InferenceBound . LOWER ) , uv . getBounds ( InferenceBound . EQ ) ) ) ; } return GraphUtils . toDot ( nodes , STR_ + hashCode ( ) , buf . toString ( ) ) ; }
private void resizeTables ( ) { if ( mObjectDataUsed > mObjectData . length - MAX_DATA_SIZE ) { mObjectData = Arrays . copyOf ( mObjectData , mObjectData . length . NUM_ ) ; } if ( mObjectCount < mTypes . length ) { return ; } mObjectOffset = Arrays . copyOf ( mObjectOffset , mObjectOffset . length . NUM_ ) ; mTypes = Arrays . copyOf ( mTypes , mTypes . length . NUM_ ) ; mObjects = Arrays . copyOf ( mObjects , mObjects . length . NUM_ ) ; mRect = Arrays . copyOf ( mRect , mRect . length . NUM_ ) ; }
private boolean hasNextInetSocketAddress ( ) { return nextInetSocketAddressIndex < inetSocketAddresses . size ( ) ; }
protected static double convertPercentileToX ( double percentileLevelIteratedTo ) { double x = NUM_ / ( NUM_ - ( percentileLevelIteratedTo / NUM_ ) ) ; return Math . log10 ( x ) ; }
public static String queueNameFromDBName ( String dbName ) { String [ ] tokens = dbName . split ( STR_ , NUM_ ) ; return tokens [ NUM_ ] ; }
public String UseThis ( int type , String id , String context ) { int i = FindSym ( type , id , context ) ; if ( i == symtab . size ( ) ) return id ; else return ( ( SymTabEntry ) symtab . elementAt ( i ) ) . useThis ; }
private float angle ( TouchState s ) { return ( float ) Math . toDegrees ( Math . atan2 ( s . yDown - s . yCurrent , s . xDown - s . xCurrent ) ) ; }
private int uint16FromData ( int offset ) { return twoBytesToInt ( Arrays . copyOfRange ( data ( ) , offset , offset + NUM_ ) , Constants . CC2540_BYTE_ORDER ) ; }
protected static Pair < String , String > asrRegister ( final long offset , final ITranslationEnvironment environment , final List < ReilInstruction > instructions , final String registerNodeValue1 , final String registerNodeValue2 ) { final String shifterOperand = environment . getNextVariableString ( ) ; final String shifterCarryOut = environment . getNextVariableString ( ) ; final String isZeroCondition = environment . getNextVariableString ( ) ; final String isLessCondition = environment . getNextVariableString ( ) ; final String isGtEqCondition = environment . getNextVariableString ( ) ; final String shifterCarryOutTmp1 = environment . getNextVariableString ( ) ; final String shifterCarryOutTmp2 = environment . getNextVariableString ( ) ; final String shifterCarryOutTmp3 = environment . getNextVariableString ( ) ; final String shifterCarryOutTmp4 = environment . getNextVariableString ( ) ; final String shifterOperandTmp1 = environment . getNextVariableString ( ) ; final String shifterOperandTmp2 = environment . getNextVariableString ( ) ; final String shifterOperandTmp3 = environment . getNextVariableString ( ) ; final String shifterOperandTmp4 = environment . getNextVariableString ( ) ; final String tmpRsRegister = environment . getNextVariableString ( ) ; final String negativeTmpRsRegister = environment . getNextVariableString ( ) ; final String tmpVar1 = environment . getNextVariableString ( ) ; final String tmpVar2 = environment . getNextVariableString ( ) ; final String tmpVar3 = environment . getNextVariableString ( ) ; final String tmpVar4 = environment . getNextVariableString ( ) ; final String tmpVar5 = environment . getNextVariableString ( ) ; final String tmpVar6 = environment . getNextVariableString ( ) ; final String tmpVar7 = environment . getNextVariableString ( ) ; final String tmpVar8 = environment . getNextVariableString ( ) ; final String tmpVar9 = environment . getNextVariableString ( ) ; final String tmpVar10 = environment . getNextVariableString ( ) ; final String tmpVar11 = environment . getNextVariableString ( ) ; long baseOffset = offset ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , dWordSize , registerNodeValue2 , dWordSize , String . valueOf ( xFFL ) , dWordSize , tmpRsRegister ) ) ; instructions . add ( ReilHelpers . createSub ( baseOffset ++ , dWordSize , zeroSet , dWordSize , tmpRsRegister , dWordSize , negativeTmpRsRegister ) ) ; instructions . add ( ReilHelpers . createBisz ( baseOffset ++ , dWordSize , tmpRsRegister , byteSize , isZeroCondition ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , byteSize , STR_ , byteSize , isZeroCondition , byteSize , shifterCarryOutTmp1 ) ) ; instructions . add ( ReilHelpers . createSub ( baseOffset ++ , dWordSize , String . valueOf ( NUM_ ) , byteSize , isZeroCondition , dWordSize , tmpVar1 ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , dWordSize , tmpVar1 , dWordSize , registerNodeValue2 , dWordSize , shifterOperandTmp1 ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , dWordSize , tmpRsRegister , dWordSize , String . valueOf ( xFFFFFFE0L ) , dWordSize , tmpVar2 ) ) ; instructions . add ( ReilHelpers . createBisz ( baseOffset ++ , dWordSize , tmpVar2 , byteSize , isLessCondition ) ) ; instructions . add ( ReilHelpers . createAdd ( baseOffset ++ , dWordSize , registerNodeValue1 , dWordSize , bitMaskHighestBitSet , dWordSize , tmpVar3 ) ) ; instructions . add ( ReilHelpers . createBsh ( baseOffset ++ , dWordSize , tmpVar3 , dWordSize , negativeTmpRsRegister , dWordSize , tmpVar4 ) ) ; instructions . add ( ReilHelpers . createBsh ( baseOffset ++ , dWordSize , bitMaskHighestBitSet , dWordSize , negativeTmpRsRegister , dWordSize , tmpVar5 ) ) ; instructions . add ( ReilHelpers . createSub ( baseOffset ++ , dWordSize , tmpVar4 , dWordSize , tmpVar5 , dWordSize , tmpVar6 ) ) ; instructions . add ( ReilHelpers . createSub ( baseOffset ++ , dWordSize , zeroSet , byteSize , isLessCondition , dWordSize , tmpVar7 ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , dWordSize , tmpVar6 , dWordSize , tmpVar7 , dWordSize , shifterOperandTmp2 ) ) ; instructions . add ( ReilHelpers . createSub ( baseOffset ++ , dWordSize , tmpRsRegister , byteSize , oneSet , dWordSize , tmpVar8 ) ) ; instructions . add ( ReilHelpers . createSub ( baseOffset ++ , dWordSize , zeroSet , dWordSize , tmpVar8 , dWordSize , tmpVar8 ) ) ; instructions . add ( ReilHelpers . createBsh ( baseOffset ++ , dWordSize , registerNodeValue1 , dWordSize , tmpVar8 , dWordSize , tmpVar9 ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , dWordSize , tmpVar9 , byteSize , isLessCondition , byteSize , shifterCarryOutTmp2 ) ) ; instructions . add ( ReilHelpers . createOr ( baseOffset ++ , byteSize , isZeroCondition , byteSize , isLessCondition , byteSize , tmpVar10 ) ) ; instructions . add ( ReilHelpers . createBisz ( baseOffset ++ , byteSize , tmpVar10 , byteSize , isGtEqCondition ) ) ; instructions . add ( ReilHelpers . createBsh ( baseOffset ++ , dWordSize , registerNodeValue1 , dWordSize , minusThirtyOneSet , byteSize , tmpVar11 ) ) ; instructions . add ( ReilHelpers . createSub ( baseOffset ++ , byteSize , zeroSet , byteSize , isGtEqCondition , dWordSize , shifterOperandTmp3 ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , byteSize , tmpVar11 , byteSize , isGtEqCondition , byteSize , shifterCarryOutTmp3 ) ) ; instructions . add ( ReilHelpers . createOr ( baseOffset ++ , byteSize , shifterCarryOutTmp1 , byteSize , shifterCarryOutTmp2 , byteSize , shifterCarryOutTmp4 ) ) ; instructions . add ( ReilHelpers . createOr ( baseOffset ++ , byteSize , shifterCarryOutTmp3 , byteSize , shifterCarryOutTmp4 , byteSize , shifterCarryOut ) ) ; instructions . add ( ReilHelpers . createOr ( baseOffset ++ , dWordSize , shifterOperandTmp1 , dWordSize , shifterOperandTmp2 , dWordSize , shifterOperandTmp4 ) ) ; instructions . add ( ReilHelpers . createOr ( baseOffset ++ , dWordSize , shifterOperandTmp3 , dWordSize , shifterOperandTmp4 , dWordSize , shifterOperand ) ) ; return new Pair < String , String > ( shifterOperand , shifterCarryOut ) ; }
private static String removeQuotesEncolosingOption ( String fileName , String option ) throws Exception { String option1 = removeQuoteCharactersIfNecessary ( fileName , option , STR_ ) ; if ( ! option1 . equals ( option ) ) { return option1 ; } return removeQuoteCharactersIfNecessary ( fileName , option , STR_ ) ; }
@ Override public String generateLabel ( XYDataset dataset , int series ) { ParamChecks . nullNotPermitted ( dataset , STR_ ) ; String label = MessageFormat . format ( this . formatPattern , createItemArray ( dataset , series ) ) ; return label ; }
private boolean matchStrings ( String pattern , String str , Map < String , String > uriTemplateVariables ) { AntPathStringMatcher matcher = new AntPathStringMatcher ( pattern , str , uriTemplateVariables ) ; return matcher . matchStrings ( ) ; }
@ Nullable public Dimension adjust ( @ NotNull Dimension newPreferredSize , @ Nullable Dimension oldPreferredSize , @ NotNull EditorImpl editor ) { if ( oldPreferredSize == null || mySkip ) { return newPreferredSize ; } if ( newPreferredSize . height != oldPreferredSize . height ) { return newPreferredSize ; } stripTimings ( ) ; myTimings . add ( System . currentTimeMillis ( ) ) ; if ( myTimings . size ( ) < FREQUENT_SIZE_CHANGES_NUMBER ) { return newPreferredSize ; } boolean increaseWidth = newPreferredSize . width > oldPreferredSize . width ; Dimension result ; if ( increaseWidth ) { final int spaceWidth = EditorUtil . getSpaceWidth ( Font . PLAIN , editor ) ; newPreferredSize . width += myReserveColumns . spaceWidth ; myReserveColumns += NUM_ ; result = newPreferredSize ; } else { result = oldPreferredSize ; } scheduleSizeUpdate ( editor ) ; return result ; }
public RVMField findDeclaredField ( Atom fieldName , Atom fieldDescriptor ) { for ( RVMField field : declaredFields ) { if ( field . getName ( ) == fieldName && field . getDescriptor ( ) == fieldDescriptor ) { return field ; } } return null ; }
public Quarter ( Date time , TimeZone zone ) { this ( time , zone , Locale . getDefault ( ) ) ; }
default B withDefault ( String key , float value ) { return withDefault ( key , Float . toString ( value ) ) ; }
public static boolean readBoolean ( final JSONArray jsonArray , final int index , final boolean required , final boolean notNull ) throws JSONException { if ( required ) { return jsonArray . getBoolean ( index ) ; } if ( notNull && jsonArray . isNull ( index ) ) { throw new JSONException ( String . format ( Locale . US , NULL_VALUE_FORMAT_ARRAY , index ) ) ; } boolean value = BOOL_ ; if ( ! jsonArray . isNull ( index ) ) { value = jsonArray . getBoolean ( index ) ; } return value ; }
protected static void autoBoxing ( MethodVisitor mv , Type fieldType ) { switch ( fieldType . getSort ( ) ) { case Type . BOOLEAN : mv . visitMethodInsn ( INVOKESTATIC , STR_ , STR_ , STR_ ) ; break ; case Type . BYTE : mv . visitMethodInsn ( INVOKESTATIC , STR_ , STR_ , STR_ ) ; break ; case Type . CHAR : mv . visitMethodInsn ( INVOKESTATIC , STR_ , STR_ , STR_ ) ; break ; case Type . SHORT : mv . visitMethodInsn ( INVOKESTATIC , STR_ , STR_ , STR_ ) ; break ; case Type . INT : mv . visitMethodInsn ( INVOKESTATIC , STR_ , STR_ , STR_ ) ; break ; case Type . FLOAT : mv . visitMethodInsn ( INVOKESTATIC , STR_ , STR_ , STR_ ) ; break ; case Type . LONG : mv . visitMethodInsn ( INVOKESTATIC , STR_ , STR_ , STR_ ) ; break ; case Type . DOUBLE : mv . visitMethodInsn ( INVOKESTATIC , STR_ , STR_ , STR_ ) ; break ; } }
public final void openPdfFile ( final byte [ ] data ) throws PdfException { final RandomAccessBuffer pdf_datafile ; try { if ( PdfFileReader . alwaysCacheInMemory == - NUM_ || data . length < PdfFileReader . alwaysCacheInMemory ) { pdf_datafile = new RandomAccessDataBuffer ( data ) ; } else { try { final File file = File . createTempFile ( STR_ , STR_ , new File ( ObjectStore . temp_dir ) ) ; tempFileName = file . getAbsolutePath ( ) ; final java . io . FileOutputStream a = new java . io . FileOutputStream ( file ) ; a . write ( data ) ; a . flush ( ) ; a . close ( ) ; pdf_datafile = new RandomAccessFileBuffer ( tempFileName , STR_ ) ; } catch ( final Exception e ) { throw new RuntimeException ( STR_ + ObjectStore . temp_dir + STR_ + e ) ; } } objectReader . init ( pdf_datafile ) ; } catch ( final Exception e ) { LogWriter . writeLog ( STR_ + e + STR_ ) ; throw new PdfException ( STR_ + e + STR_ ) ; } }
public static void main ( String [ ] args ) { if ( args . length < NUM_ ) { LOGGER . error ( STR_ ) ; return ; } int lastIndex = args . length - NUM_ ; Path [ ] files = getFiles ( args ) ; Main main = new Main ( ) ; main . generate ( files [ lastIndex ] , Arrays . copyOf ( files , lastIndex ) ) ; }
@ Nullable E awaitMatch ( int start ) { for ( int step = NUM_ , totalSpins = NUM_ ; ( step < ARENA_LENGTH ) && ( totalSpins < SPINS ) ; step ++ ) { int index = ( start + step ) & ARENA_MASK ; AtomicReference < Object > slot = arena [ index ] ; Object found = slot . get ( ) ; if ( found == FREE ) { if ( slot . compareAndSet ( FREE , WAITER ) ) { int slotSpins = NUM_ ; for ( ; ; ) { found = slot . get ( ) ; if ( ( found != WAITER ) && slot . compareAndSet ( found , FREE ) ) { @ SuppressWarnings ( STR_ ) E e = ( E ) found ; return e ; } else if ( ( slotSpins >= SPINS_PER_STEP ) && ( found == WAITER ) && ( slot . compareAndSet ( WAITER , FREE ) ) ) { totalSpins += slotSpins ; break ; } slotSpins ++ ; } } } else if ( ( found != WAITER ) && slot . compareAndSet ( found , FREE ) ) { @ SuppressWarnings ( STR_ ) E e = ( E ) found ; return e ; } } return null ; }
private ArrayList < Signature > constructOneSignatures ( SetDBIDs [ ] [ ] partitions , final long [ ] [ ] markers ) { final int dim = partitions . length ; ArrayList < Signature > signatures = new ArrayList < > ( ) ; for ( int d = NUM_ ; d < dim ; d ++ ) { final DBIDs [ ] parts = partitions [ d ] ; if ( parts == null ) { continue ; } final long [ ] marked = markers [ d ] ; for ( int start = BitsUtil . nextSetBit ( marked , NUM_ ) ; start >= NUM_ ; ) { int end = BitsUtil . nextClearBit ( marked , start + NUM_ ) ; end = ( end == - NUM_ ) ? dim : end ; int [ ] signature = new int [ dim << NUM_ ] ; Arrays . fill ( signature , - NUM_ ) ; signature [ d << NUM_ ] = start ; signature [ ( d << NUM_ ) + NUM_ ] = end - NUM_ ; HashSetModifiableDBIDs sids = unionDBIDs ( parts , start , end ) ; if ( LOG . isDebugging ( ) ) { LOG . debug ( STR_ + d + STR_ + start + STR_ + ( end - NUM_ ) ) ; } signatures . add ( new Signature ( signature , sids ) ) ; start = ( end < dim ) ? BitsUtil . nextSetBit ( marked , end + NUM_ ) : - NUM_ ; } } return signatures ; }
public void testTestBitPositive1 ( ) { byte aBytes [ ] = { - NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int number = NUM_ ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; assertTrue ( ! aNumber . testBit ( number ) ) ; }
public static int findEndTrimNewlineChars ( CharSequence s ) { for ( int i = s . length ( ) ; i > NUM_ ; ) { if ( s . charAt ( i - NUM_ ) != STR_ ) { return i ; } i -- ; if ( i > NUM_ && s . charAt ( i - NUM_ ) == STR_ ) { i -- ; } } return NUM_ ; }
public static String assertJQ ( SolrQueryRequest req , String ... tests ) throws Exception { return assertJQ ( req , JSONTestUtil . DEFAULT_DELTA , tests ) ; }
public void popElemAttributeSet ( ) { m_attrSetStack . pop ( ) ; }
private void calcCoordinates ( final float x , final float [ ] [ ] Trm , float charSpacing ) { final float [ ] [ ] trm = new float [ NUM_ ] [ NUM_ ] ; for ( int xx = NUM_ ; xx < NUM_ ; xx ++ ) { System . arraycopy ( Trm [ xx ] , NUM_ , trm [ xx ] , NUM_ , NUM_ ) ; } x1 = x ; x2 = trm [ NUM_ ] [ NUM_ ] - ( charSpacing . trm [ NUM_ ] [ NUM_ ] ) ; if ( glyphData . isHorizontal ( ) ) { if ( trm [ NUM_ ] [ NUM_ ] < NUM_ ) { x1 = x + trm [ NUM_ ] [ NUM_ ] - ( charSpacing . trm [ NUM_ ] [ NUM_ ] ) ; x2 = trm [ NUM_ ] [ NUM_ ] ; } else if ( trm [ NUM_ ] [ NUM_ ] > NUM_ ) { x1 = x ; x2 = trm [ NUM_ ] [ NUM_ ] ; } } else if ( trm [ NUM_ ] [ NUM_ ] > NUM_ ) { x1 = trm [ NUM_ ] [ NUM_ ] ; x2 = x + trm [ NUM_ ] [ NUM_ ] - ( charSpacing . trm [ NUM_ ] [ NUM_ ] ) ; } else if ( trm [ NUM_ ] [ NUM_ ] < NUM_ ) { x2 = trm [ NUM_ ] [ NUM_ ] ; x1 = x + trm [ NUM_ ] [ NUM_ ] - ( charSpacing . trm [ NUM_ ] [ NUM_ ] ) ; } }
public void printEntry ( Writer w ) { try { String indent = STR_ ; int indentWidth = indent . length ( ) ; HardcopyWriter ww = ( HardcopyWriter ) w ; int textSpace = ww . getCharactersPerLine ( ) - indentWidth - NUM_ ; String newLine = STR_ ; w . write ( newLine , NUM_ , NUM_ ) ; String s = STR_ + _id ; w . write ( s , NUM_ , s . length ( ) ) ; if ( ! ( _consistNumber . equals ( STR_ ) ) ) { w . write ( newLine , NUM_ , NUM_ ) ; s = STR_ + _consistNumber ; w . write ( s , NUM_ , s . length ( ) ) ; } if ( ! ( _roadName . equals ( STR_ ) ) ) { w . write ( newLine , NUM_ , NUM_ ) ; s = STR_ + _roadName ; w . write ( s , NUM_ , s . length ( ) ) ; } if ( ! ( _roadNumber . equals ( STR_ ) ) ) { w . write ( newLine , NUM_ , NUM_ ) ; s = STR_ + _roadNumber ; w . write ( s , NUM_ , s . length ( ) ) ; } if ( ! ( _model . equals ( STR_ ) ) ) { w . write ( newLine , NUM_ , NUM_ ) ; s = STR_ + _model ; w . write ( s , NUM_ , s . length ( ) ) ; } if ( ! ( _loco1DccAddress . equals ( STR_ ) ) ) { w . write ( newLine , NUM_ , NUM_ ) ; s = STR_ + _loco1DccAddress + STR_ + _loco1Direction ; w . write ( s , NUM_ , s . length ( ) ) ; } if ( ! ( _loco2DccAddress . equals ( STR_ ) ) ) { w . write ( newLine , NUM_ , NUM_ ) ; s = STR_ + _loco2DccAddress + STR_ + _loco2Direction ; w . write ( s , NUM_ , s . length ( ) ) ; } if ( ! ( _loco3DccAddress . equals ( STR_ ) ) ) { w . write ( newLine , NUM_ , NUM_ ) ; s = STR_ + _loco3DccAddress + STR_ + _loco3Direction ; w . write ( s , NUM_ , s . length ( ) ) ; } if ( ! ( _loco4DccAddress . equals ( STR_ ) ) ) { w . write ( newLine , NUM_ , NUM_ ) ; s = STR_ + _loco4DccAddress + STR_ + _loco4Direction ; w . write ( s , NUM_ , s . length ( ) ) ; } if ( ! ( _loco5DccAddress . equals ( STR_ ) ) ) { w . write ( newLine , NUM_ , NUM_ ) ; s = STR_ + _loco5DccAddress + STR_ + _loco5Direction ; w . write ( s , NUM_ , s . length ( ) ) ; } if ( ! ( _loco6DccAddress . equals ( STR_ ) ) ) { w . write ( newLine , NUM_ , NUM_ ) ; s = STR_ + _loco6DccAddress + STR_ + _loco6Direction ; w . write ( s , NUM_ , s . length ( ) ) ; } if ( ! ( _comment . equals ( STR_ ) ) ) { Vector < String > commentVector = wrapComment ( _comment , textSpace ) ; int k = NUM_ ; w . write ( newLine , NUM_ , NUM_ ) ; s = STR_ + commentVector . elementAt ( k ) ; w . write ( s , NUM_ , s . length ( ) ) ; k ++ ; while ( k < commentVector . size ( ) ) { String token = commentVector . elementAt ( k ) ; if ( ! token . equals ( STR_ ) ) { s = indent + token ; } else { s = token ; } w . write ( s , NUM_ , s . length ( ) ) ; k ++ ; } } w . write ( newLine , NUM_ , NUM_ ) ; } catch ( IOException e ) { log . error ( STR_ + e ) ; } }
protected java . util . Date fromJulian ( int julian ) { YMD ymd = new YMD ( julian ) ; GregorianCalendar cal = new GregorianCalendar ( ymd . year , ymd . month - NUM_ , ymd . day ) ; return cal . getTime ( ) ; }
public synchronized boolean removeLast ( K obj ) { if ( peekLast ( ) != obj ) { return BOOL_ ; } array = Arrays . copyOf ( array , array . length - NUM_ ) ; return BOOL_ ; }
private boolean serializeCompactRDFStructProp ( XMPNode node , int indent , boolean hasRDFResourceQual ) throws XMPException , IOException { boolean hasAttrFields = BOOL_ ; boolean hasElemFields = BOOL_ ; boolean emitEndTag = BOOL_ ; for ( Iterator ic = node . iterateChildren ( ) ; ic . hasNext ( ) ; ) { XMPNode field = ( XMPNode ) ic . next ( ) ; if ( canBeRDFAttrProp ( field ) ) { hasAttrFields = BOOL_ ; } else { hasElemFields = BOOL_ ; } if ( hasAttrFields && hasElemFields ) { break ; } } if ( hasRDFResourceQual && hasElemFields ) { throw new XMPException ( STR_ , XMPError . BADRDF ) ; } if ( ! node . hasChildren ( ) ) { write ( STR_ ) ; writeNewline ( ) ; emitEndTag = BOOL_ ; } else if ( ! hasElemFields ) { serializeCompactRDFAttrProps ( node , indent + NUM_ ) ; write ( STR_ ) ; writeNewline ( ) ; emitEndTag = BOOL_ ; } else if ( ! hasAttrFields ) { write ( STR_ ) ; writeNewline ( ) ; serializeCompactRDFElementProps ( node , indent + NUM_ ) ; } else { write ( STR_ ) ; writeNewline ( ) ; writeIndent ( indent + NUM_ ) ; write ( RDF_STRUCT_START ) ; serializeCompactRDFAttrProps ( node , indent + NUM_ ) ; write ( STR_ ) ; writeNewline ( ) ; serializeCompactRDFElementProps ( node , indent + NUM_ ) ; writeIndent ( indent + NUM_ ) ; write ( RDF_STRUCT_END ) ; writeNewline ( ) ; } return emitEndTag ; }
public default UtilityTable queryUtil ( BNetwork network , String queryVar , Assignment evidence ) { return queryUtil ( new Query . UtilQuery ( network , Arrays . asList ( queryVar ) , evidence ) ) ; }
public static float [ ] stringListToNumeric ( List < String > scoreList ) throws NumberFormatException { float [ ] scores = new float [ scoreList . size ( ) ] ; int scoreId = NUM_ ; for ( String score : scoreList ) { float floatScore = ( float ) Double . parseDouble ( score ) ; if ( Float . isNaN ( floatScore ) ) { throw new NumberFormatException ( STR_ + score ) ; } scores [ scoreId ++ ] = floatScore ; } return scores ; }
@ Override public void next ( ) { currentImage = Optional . of ( addIndexAndGetImageByOffset ( + NUM_ ) ) ; eventBus . post ( new SourceHasPendingUpdateEvent ( this ) ) ; }
protected void parse ( DataInputStream stream ) throws Exception { int size = stream . readInt ( ) ; int ret , read = NUM_ ; data = new byte [ size ] ; while ( size > NUM_ ) { ret = stream . read ( data , read , size ) ; size -= ret ; read += ret ; } }
private List < Activity > findBestInsertion ( List < Activity > partialRoute , boolean allowAsMajor ) { int startIndex = NUM_ ; int endIndex = partialRoute . size ( ) - NUM_ ; if ( allowAsMajor ) { startIndex = NUM_ ; endIndex = partialRoute . size ( ) ; } List < Activity > newList = partialRoute ; double best = Double . POSITIVE_INFINITY ; List < Activity > bestList = null ; for ( int i = startIndex ; i <= endIndex ; i ++ ) { List < Activity > tmpList = new ArrayList < > ( newList ) ; Activity tmpActivity = getRelocationActivity ( ) ; tmpList . add ( i , tmpActivity ) ; double tmp = evaluateList ( tmpList ) ; if ( tmp < best ) { if ( i == NUM_ ) { tmpActivity . setType ( STR_ ) ; tmpActivity . setEndTime ( Time . parseTime ( STR_ ) ) ; } else if ( i == partialRoute . size ( ) ) { tmpActivity . setType ( STR_ ) ; } else { tmpActivity . setType ( STR_ ) ; tmpActivity . setMaximumDuration ( Time . parseTime ( STR_ ) ) ; } best = tmp ; bestList = tmpList ; } } return bestList ; }
Calendar toCalendar ( String value , String pattern , Locale locale ) { Calendar calendar = null ; try { DateFormat format = ( locale == null ) ? new SimpleDateFormat ( pattern ) : new SimpleDateFormat ( pattern , locale ) ; format . setLenient ( BOOL_ ) ; format . parse ( value ) ; calendar = format . getCalendar ( ) ; } catch ( Exception e ) { fail ( STR_ + value + STR_ + pattern + STR_ + e . toString ( ) ) ; } return calendar ; }
public void writeShort ( int value ) throws IOException { checkWritePrimitiveTypes ( ) ; primitiveTypes . writeShort ( value ) ; }
private boolean isInitialized ( ) { return poolNames != null && ! poolNames . isEmpty ( ) ; }
public void onRegisterClick ( View view ) { Intent register = new Intent ( Intent . ACTION_VIEW , Uri . parse ( getString ( R . string . welcome_link_url ) ) ) ; setResult ( RESULT_CANCELED ) ; startActivity ( register ) ; }
private void registerExtraValidSubject ( String subject ) { extraValidSubjects . add ( subject ) ; restoredStatements . addAll ( unknownSubjects . removeAll ( subject ) ) ; }
public static String trimLine ( String line ) { int idx = line . indexOf ( STR_ ) ; if ( idx != - NUM_ ) { line = line . substring ( NUM_ , idx ) ; } return line . trim ( ) ; }
public static void appendInstruction ( OFFlowMod . Builder fmb , OFInstruction inst ) { List < OFInstruction > newIl = new ArrayList < OFInstruction > ( ) ; List < OFInstruction > oldIl = fmb . getInstructions ( ) ; if ( oldIl != null ) { newIl . addAll ( fmb . getInstructions ( ) ) ; } for ( OFInstruction i : newIl ) { if ( i . getType ( ) == inst . getType ( ) ) { newIl . remove ( i ) ; } } newIl . add ( inst ) ; fmb . setInstructions ( newIl ) ; }
public Iterator < T > iterator ( ) { return orderList . iterator ( ) ; }
private void verifyDomainsIsNotInUse ( StringSet domains ) { checkForActiveTenantsUsingDomains ( domains ) ; checkForVdcRolesUsingDomains ( domains ) ; checkForTenantRolesUsingDomains ( domains ) ; checkForUserGroupsUsingDomains ( domains ) ; }
private Hashtable < IPoint , List < ICircle > > filter ( Hashtable < IPoint , ICircle [ ] > circleIntersections ) { Hashtable < IPoint , List < ICircle > > real = new Hashtable < IPoint , List < ICircle > > ( ) ; for ( IPoint pt : circleIntersections . keySet ( ) ) { ICircle [ ] circs = circleIntersections . get ( pt ) ; for ( int i = NUM_ ; i < circs . length - NUM_ ; i ++ ) { for ( int j = i + NUM_ ; j < circs . length ; j ++ ) { IPoint [ ] pts = intersects ( circs [ i ] , circs [ j ] ) ; if ( pts != null ) { for ( IPoint p : pts ) { report ( real , p , circs [ i ] , circs [ j ] ) ; } } } } } return real ; }
public void initWithoutJUnitForFixture ( Class fixture , Method method ) { this . testClass = fixture ; this . testMethodName = method . getName ( ) ; }
public void clear ( ) { oredCriteria . clear ( ) ; orderByClause = null ; distinct = BOOL_ ; }
public long sigignore ( ) { return Long . parseLong ( fields [ NUM_ ] ) ; }
protected JavaType findSerializationType ( Annotated a , boolean useStaticTyping , JavaType declaredType ) { Class < ? > serClass = _annotationIntrospector . findSerializationType ( a ) ; if ( serClass != null ) { Class < ? > rawDeclared = declaredType . getRawClass ( ) ; if ( serClass . isAssignableFrom ( rawDeclared ) ) { declaredType = declaredType . widenBy ( serClass ) ; } else { if ( ! rawDeclared . isAssignableFrom ( serClass ) ) { throw new IllegalArgumentException ( STR_ + a . getName ( ) + STR_ + serClass . getName ( ) + STR_ + rawDeclared . getName ( ) ) ; } declaredType = _config . constructSpecializedType ( declaredType , serClass ) ; } useStaticTyping = BOOL_ ; } JavaType secondary = BeanSerializerFactory . modifySecondaryTypesByAnnotation ( _config , a , declaredType ) ; if ( secondary != declaredType ) { useStaticTyping = BOOL_ ; declaredType = secondary ; } if ( ! useStaticTyping ) { JsonSerialize . Typing typing = _annotationIntrospector . findSerializationTyping ( a ) ; if ( typing != null ) { useStaticTyping = ( typing == JsonSerialize . Typing . STATIC ) ; } } return useStaticTyping ? declaredType : null ; }
private static void convert ( AScene scene , InputStream in , OutputStream out ) throws IOException , DefException , ParseException { IndexUnit iu = JavaParser . parse ( in ) ; extractScene ( iu , scene ) ; try ( Writer w = new BufferedWriter ( new OutputStreamWriter ( out ) ) ) { IndexFileWriter . write ( scene , w ) ; } }
public static < K , V > Map < K , V > of ( K k1 , V v1 , K k2 , V v2 ) { Map map = of ( ) ; map . put ( k1 , v1 ) ; map . put ( k2 , v2 ) ; return map ; }
@ Override public void write ( char [ ] chr ) throws IOException { out . write ( chr ) ; }
public boolean boundScroll ( ) { float curScroll = getStackScroll ( ) ; float newScroll = getBoundedStackScroll ( curScroll ) ; if ( Float . compare ( newScroll , curScroll ) != NUM_ ) { setStackScroll ( newScroll ) ; return BOOL_ ; } return BOOL_ ; }
public static void load ( marytts . modules . synthesis . Voice maryVoice ) throws NoSuchPropertyException { if ( mary2freettsVoices == null ) mary2freettsVoices = new HashMap < marytts . modules . synthesis . Voice , com . sun . speech . freetts . Voice > ( ) ; if ( freetts2maryVoices == null ) freetts2maryVoices = new HashMap < com . sun . speech . freetts . Voice , marytts . modules . synthesis . Voice > ( ) ; if ( mary2freettsVoices . containsKey ( maryVoice ) ) return ; load ( maryVoice , createFreeTTSVoice ( maryVoice ) ) ; }
public void append ( int key , double value ) { if ( mSize != NUM_ && key <= mKeys [ mSize - NUM_ ] ) { put ( key , value ) ; return ; } int pos = mSize ; if ( pos >= mKeys . length ) { int n = ArrayUtils . idealIntArraySize ( pos + NUM_ ) ; int [ ] nkeys = new int [ n ] ; double [ ] nvalues = new double [ n ] ; System . arraycopy ( mKeys , NUM_ , nkeys , NUM_ , mKeys . length ) ; System . arraycopy ( mValues , NUM_ , nvalues , NUM_ , mValues . length ) ; mKeys = nkeys ; mValues = nvalues ; } mKeys [ pos ] = key ; mValues [ pos ] = value ; mSize = pos + NUM_ ; }
public synchronized void addIncrementalClassifierListener ( IncrementalClassifierListener cl ) { m_incrementalClassifierListeners . add ( cl ) ; }
public float readR4 ( ) throws java . io . IOException { return Float . intBitsToFloat ( ( int ) readDWORD ( ) ) ; }
public Collection engineGenerateCertificates ( InputStream inStream ) throws CertificateException { java . security . cert . Certificate cert ; List certs = new ArrayList ( ) ; while ( ( cert = engineGenerateCertificate ( inStream ) ) != null ) { certs . add ( cert ) ; } return certs ; }
public static boolean filesExistOnDestButNotSrc ( Configuration conf , Path src , Path dest , Optional < PathFilter > filter ) throws IOException { Set < FileStatus > srcFileStatuses = getFileStatusesRecursive ( conf , src , filter ) ; Set < FileStatus > destFileStatuses = getFileStatusesRecursive ( conf , dest , filter ) ; Map < String , Long > srcFileSizes = null ; Map < String , Long > destFileSizes = null ; try { srcFileSizes = getRelPathToSizes ( src , srcFileStatuses ) ; destFileSizes = getRelPathToSizes ( dest , destFileStatuses ) ; } catch ( ArgumentException e ) { throw new IOException ( STR_ , e ) ; } for ( String file : destFileSizes . keySet ( ) ) { if ( ! srcFileSizes . containsKey ( file ) ) { LOG . warn ( String . format ( STR_ , file , dest , src ) ) ; return BOOL_ ; } } return BOOL_ ; }
protected void convertOrder ( SqlSelect select , Blackboard bb , RelCollation collation , List < SqlNode > orderExprList , SqlNode offset , SqlNode fetch ) { if ( select . getOrderList ( ) == null || select . getOrderList ( ) . getList ( ) . isEmpty ( ) ) { assert collation . getFieldCollations ( ) . isEmpty ( ) ; if ( ( offset == null || ( ( SqlLiteral ) offset ) . bigDecimalValue ( ) . equals ( BigDecimal . ZERO ) ) && fetch == null ) { return ; } } bb . setRoot ( LogicalSort . create ( bb . root , collation , offset == null ? null : convertExpression ( offset ) , fetch == null ? null : convertExpression ( fetch ) ) , BOOL_ ) ; if ( orderExprList . size ( ) > NUM_ && ! bb . top ) { final List < RexNode > exprs = new ArrayList < > ( ) ; final RelDataType rowType = bb . root . getRowType ( ) ; final int fieldCount = rowType . getFieldCount ( ) - orderExprList . size ( ) ; for ( int i = NUM_ ; i < fieldCount ; i ++ ) { exprs . add ( rexBuilder . makeInputRef ( bb . root , i ) ) ; } bb . setRoot ( LogicalProject . create ( bb . root , exprs , rowType . getFieldNames ( ) . subList ( NUM_ , fieldCount ) ) , BOOL_ ) ; } }
public void tickBlock ( BlockPos pos ) { List < BlockPos > validCoords = new ArrayList < > ( ) ; for ( int xOffset = - TICK_RANGE ; xOffset <= TICK_RANGE ; xOffset ++ ) { for ( int zOffset = - TICK_RANGE ; zOffset <= TICK_RANGE ; zOffset ++ ) { if ( xOffset == NUM_ && zOffset == NUM_ ) continue ; if ( isValidSwapPosition ( pos . add ( xOffset , NUM_ , zOffset ) ) ) validCoords . add ( pos . add ( xOffset , NUM_ , zOffset ) ) ; } } if ( ! validCoords . isEmpty ( ) && ! world . isRemote ) { BlockPos toSwap = validCoords . get ( rand . nextInt ( validCoords . size ( ) ) ) ; world . setBlockState ( toSwap , stateToSet , NUM_ | NUM_ ) ; } }
public synchronized int updatePurchase ( String orderId , String productId , PurchaseState purchaseState , long purchaseTime , String developerPayload ) { insertOrder ( orderId , productId , purchaseState , purchaseTime , developerPayload ) ; Cursor cursor = mDb . query ( PURCHASE_HISTORY_TABLE_NAME , HISTORY_COLUMNS , HISTORY_PRODUCT_ID_COL + STR_ , new String [ ] { productId } , null , null , null , null ) ; if ( cursor == null ) { return NUM_ ; } int quantity = NUM_ ; try { while ( cursor . moveToNext ( ) ) { int stateIndex = cursor . getInt ( NUM_ ) ; PurchaseState state = PurchaseState . valueOf ( stateIndex ) ; if ( state == PurchaseState . PURCHASED || state == PurchaseState . REFUNDED ) { quantity += NUM_ ; } } updatePurchasedItem ( productId , quantity ) ; } finally { if ( cursor != null ) { cursor . close ( ) ; } } return quantity ; }
private void configureMessageLabel ( JLabel label ) { Color color = ( Color ) DefaultLookup . get ( optionPane , this , STR_ ) ; if ( color != null ) { label . setForeground ( color ) ; } Font messageFont = ( Font ) DefaultLookup . get ( optionPane , this , STR_ ) ; if ( messageFont != null ) { label . setFont ( messageFont ) ; } }
public void removeAllLimitLines ( ) { mLimitLines . clear ( ) ; }
private boolean linkFirst ( Node < E > node ) { if ( count >= capacity ) return BOOL_ ; Node < E > f = first ; node . next = f ; first = node ; if ( last == null ) last = node ; else f . prev = node ; ++ count ; notEmpty . signal ( ) ; return BOOL_ ; }
default Filterable < T > removeAll ( final Stream < ? extends T > stream ) { final Set < T > set = stream . collect ( Collectors . toSet ( ) ) ; return filterNot ( null ) ; }
public void drawLine ( List < mxPoint > pts , Map < String , Object > style ) { Color penColor = mxUtils . getStyleStrokeColor ( style , Color . BLACK ) ; float penWidth = mxUtils . getStyleStrokeWidth ( style , ( float ) NUM_ ) ; if ( penColor != null && penWidth > NUM_ ) { String shape = mxUtils . getString ( style , mxConstants . STYLE_SHAPE , STR_ ) ; if ( shape . equals ( mxConstants . SHAPE_ARROW ) ) { setStroke ( penWidth , style ) ; mxPoint p0 = pts . get ( NUM_ ) ; mxPoint pe = pts . get ( pts . size ( ) - NUM_ ) ; Rectangle bounds = new Rectangle ( p0 . getPoint ( ) ) ; bounds . add ( pe . getPoint ( ) ) ; Color fillColor = mxUtils . getStyleFillColor ( style ) ; Paint fillPaint = getFillPaint ( bounds , fillColor , style ) ; boolean shadow = mxUtils . isTrue ( style , mxConstants . STYLE_SHADOW , BOOL_ ) ; drawArrow ( pts , fillColor , fillPaint , penColor , shadow ) ; } else { Object startMarker = style . get ( mxConstants . STYLE_STARTARROW ) ; Object endMarker = style . get ( mxConstants . STYLE_ENDARROW ) ; float startSize = ( float ) ( mxUtils . getFloat ( style , mxConstants . STYLE_STARTSIZE , mxConstants . DEFAULT_MARKERSIZE ) ) ; float endSize = ( float ) ( mxUtils . getFloat ( style , mxConstants . STYLE_ENDSIZE , mxConstants . DEFAULT_MARKERSIZE ) ) ; boolean rounded = mxUtils . isTrue ( style , mxConstants . STYLE_ROUNDED , BOOL_ ) ; drawConnector ( pts , penWidth , penColor , startMarker , startSize , endMarker , endSize , rounded , style ) ; } } }
private static MeteringRectangle [ ] regionsForNormalizedCoord ( float nx , float ny , float fraction , final Rect cropRegion , int sensorOrientation ) { int minCropEdge = Math . min ( cropRegion . width ( ) , cropRegion . height ( ) ) ; int halfSideLength = ( int ) ( NUM_ . fraction . minCropEdge ) ; PointF nsc = CameraUtil . normalizedSensorCoordsForNormalizedDisplayCoords ( nx , ny , sensorOrientation ) ; int xCenterSensor = ( int ) ( cropRegion . left + nsc . x . cropRegion . width ( ) ) ; int yCenterSensor = ( int ) ( cropRegion . top + nsc . y . cropRegion . height ( ) ) ; Rect meteringRegion = new Rect ( xCenterSensor - halfSideLength , yCenterSensor - halfSideLength , xCenterSensor + halfSideLength , yCenterSensor + halfSideLength ) ; meteringRegion . left = CameraUtil . clamp ( meteringRegion . left , cropRegion . left , cropRegion . right ) ; meteringRegion . top = CameraUtil . clamp ( meteringRegion . top , cropRegion . top , cropRegion . bottom ) ; meteringRegion . right = CameraUtil . clamp ( meteringRegion . right , cropRegion . left , cropRegion . right ) ; meteringRegion . bottom = CameraUtil . clamp ( meteringRegion . bottom , cropRegion . top , cropRegion . bottom ) ; return new MeteringRectangle [ ] { new MeteringRectangle ( meteringRegion , CAMERA2_REGION_WEIGHT ) } ; }
@ Override public void flush ( ) throws IOException { flushBuffer ( ) ; _outputStream . flush ( ) ; }
public Vector ( double comp [ ] ) throws NegativeArraySizeException { int n = comp . length ; if ( n <= NUM_ ) throw new NegativeArraySizeException ( STR_ ) ; components = new double [ n ] ; System . arraycopy ( comp , NUM_ , components , NUM_ , n ) ; }
@ Override public void visitInnerClass ( final String aname , final String outerName , final String innerName , final int attr_access ) { if ( ( name != null ) && name . equals ( aname ) ) { this . access = attr_access ; } super . visitInnerClass ( aname , outerName , innerName , attr_access ) ; }
public long lonToPixel ( double lon ) { return ( long ) ( ( lon + NUM_ ) / NUM_ . Math . pow ( NUM_ , zoom ) . NUM_ ) ; }
public static boolean worldFileValuesAppearGeographic ( AVList values ) { double xLocation ; double yLocation ; double xPixelSize ; double yPixelSize ; Object o = values . getValue ( WORLD_FILE_X_LOCATION ) ; if ( o != null && o instanceof Double ) xLocation = ( Double ) o ; else return BOOL_ ; o = values . getValue ( WORLD_FILE_Y_LOCATION ) ; if ( o != null && o instanceof Double ) yLocation = ( Double ) o ; else return BOOL_ ; o = values . getValue ( WORLD_FILE_X_PIXEL_SIZE ) ; if ( o != null && o instanceof Double ) xPixelSize = ( Double ) o ; else return BOOL_ ; o = values . getValue ( WORLD_FILE_Y_PIXEL_SIZE ) ; if ( o != null && o instanceof Double ) yPixelSize = ( Double ) o ; else return BOOL_ ; return ( Angle . isValidLongitude ( xPixelSize ) && Angle . isValidLatitude ( yPixelSize ) && Angle . isValidLongitude ( xLocation ) && Angle . isValidLatitude ( yLocation ) ) ; }
public void storeInRegister ( int registerNumber ) throws IOException { print ( STR_ , new String [ ] { Integer . toString ( registerNumber ) } ) ; }
public void remove ( SessionID sessionID ) { remoteSessionSet . remove ( sessionID ) ; }
@ Override public synchronized String toString ( ) { if ( elementCount == NUM_ ) { return STR_ ; } int length = elementCount - NUM_ ; StringBuilder buffer = new StringBuilder ( elementCount . NUM_ ) ; buffer . append ( STR_ ) ; for ( int i = NUM_ ; i < length ; i ++ ) { if ( elementData [ i ] == this ) { buffer . append ( STR_ ) ; } else { buffer . append ( elementData [ i ] ) ; } buffer . append ( STR_ ) ; } if ( elementData [ length ] == this ) { buffer . append ( STR_ ) ; } else { buffer . append ( elementData [ length ] ) ; } buffer . append ( STR_ ) ; return buffer . toString ( ) ; }
public Iterator < AbstractPage > childIterator ( final boolean dirtyNodesOnly ) { if ( dirtyNodesOnly ) { return new DirtyChildIterator ( this ) ; } else { return new ChildIterator ( ) ; } }
public void enable ( ) throws IOException { synchronized ( optOutLock ) { if ( isOptOut ( ) ) { configuration . set ( STR_ , BOOL_ ) ; configuration . save ( configurationFile ) ; } if ( task == null ) { start ( ) ; } } }
public HMACT64 ( byte [ ] key ) { super ( STR_ ) ; int length = Math . min ( key . length , BLOCK_LENGTH ) ; for ( int i = NUM_ ; i < length ; i ++ ) { ipad [ i ] = ( byte ) ( key [ i ] ^ IPAD ) ; opad [ i ] = ( byte ) ( key [ i ] ^ OPAD ) ; } for ( int i = length ; i < BLOCK_LENGTH ; i ++ ) { ipad [ i ] = IPAD ; opad [ i ] = OPAD ; } try { md5 = MessageDigest . getInstance ( STR_ ) ; } catch ( Exception ex ) { throw new IllegalStateException ( ex . getMessage ( ) ) ; } engineReset ( ) ; }
public boolean startsWith ( String string ) { if ( string == null ) return BOOL_ ; int strlen = string . length ( ) ; if ( _length < strlen ) return BOOL_ ; char [ ] buffer = _buffer ; int offset = _offset ; while ( -- strlen >= NUM_ ) { if ( buffer [ offset + strlen ] != string . charAt ( strlen ) ) return BOOL_ ; } return BOOL_ ; }
private void writeRawBytesInternal ( final ByteBuffer value ) throws IOException { int length = value . remaining ( ) ; if ( limit - position >= length ) { value . get ( buffer , position , length ) ; position += length ; totalBytesWritten += length ; } else { final int bytesWritten = limit - position ; value . get ( buffer , position , bytesWritten ) ; length -= bytesWritten ; position = limit ; totalBytesWritten += bytesWritten ; refreshBuffer ( ) ; while ( length > limit ) { value . get ( buffer , NUM_ , limit ) ; output . write ( buffer , NUM_ , limit ) ; length -= limit ; totalBytesWritten += limit ; } value . get ( buffer , NUM_ , length ) ; position = length ; totalBytesWritten += length ; } }
public boolean isSrcClass ( SootClass clz ) { return srcClasses . contains ( clz . getName ( ) ) ; }
private void processLDIF ( Connection conn , String path ) throws UpgradeException { ChangeRecordReader reader = null ; try { if ( DEBUG . messageEnabled ( ) ) { DEBUG . message ( STR_ + path ) ; } Map < String , String > tags = new HashMap < String , String > ( NUM_ ) ; tags . put ( STR_ , baseDN ) ; tags . put ( STR_ , STR_ ) ; String content = AMSetupServlet . readFile ( path ) ; String tagSwapped = StringUtils . tagSwap ( content , tags ) ; reader = new LDIFChangeRecordReader ( new ByteArrayInputStream ( tagSwapped . getBytes ( Charset . forName ( STR_ ) ) ) ) ; ChangeRecordWriter writer = new ConnectionChangeRecordWriter ( conn ) ; while ( reader . hasNext ( ) ) { writer . writeChangeRecord ( reader . readChangeRecord ( ) ) ; } } catch ( IOException ioe ) { DEBUG . error ( STR_ + path , ioe ) ; throw new UpgradeException ( ioe ) ; } finally { IOUtils . closeIfNotNull ( reader ) ; } }
private void printProgress ( long row , long rowFrom , long rowTill ) { long rowsProcessed = row + chunkSize - rowFrom ; if ( rowsProcessed > ( rowTill - rowFrom ) ) rowsProcessed = ( rowTill - rowFrom ) ; print ( String . format ( STR_ , ( int ) ( ( ( double ) ( rowsProcessed ) / ( double ) ( rowTill - rowFrom ) ) . NUM_ ) ) ) ; }
void postRemoteReleaseLock ( Object objectName ) throws InterruptedException { if ( ! acquireDestroyReadLock ( NUM_ ) ) { return ; } try { checkDestroyed ( ) ; drainPermittedRequests ( ) ; grantLock ( objectName ) ; } catch ( LockServiceDestroyedException e ) { } catch ( LockGrantorDestroyedException e ) { } finally { releaseDestroyReadLock ( ) ; } }
public final ArrayList < PositionRecord > loadPositions ( final int session , final Double minLat , final Double maxLat , final Double minLon , final Double maxLon ) { final ArrayList < PositionRecord > positions = new ArrayList < > ( ) ; String selection = Schema . COL_SESSION_ID + STR_ ; Cursor cursor = null ; List < String > selectionArgs = null ; if ( minLat != null & maxLat != null && minLon != null && maxLon != null ) { selectionArgs = new ArrayList < > ( ) ; selectionArgs . add ( String . valueOf ( session ) ) ; selectionArgs . add ( String . valueOf ( minLat ) ) ; selectionArgs . add ( String . valueOf ( maxLat ) ) ; selectionArgs . add ( String . valueOf ( minLon ) ) ; selectionArgs . add ( String . valueOf ( maxLon ) ) ; selection += STR_ + Schema . COL_LATITUDE + STR_ + Schema . COL_LATITUDE + STR_ + Schema . COL_LONGITUDE + STR_ + Schema . COL_LONGITUDE + STR_ ; cursor = contentResolver . query ( ContentProvider . CONTENT_URI_POSITION , null , selection , selectionArgs . toArray ( new String [ NUM_ ] ) , Schema . COL_TIMESTAMP ) ; } else { Log . v ( TAG , STR_ ) ; cursor = contentResolver . query ( ContentProvider . CONTENT_URI_POSITION , null , null , null , Schema . COL_TIMESTAMP ) ; } while ( cursor . moveToNext ( ) ) { positions . add ( positionFromCursor ( cursor ) ) ; } cursor . close ( ) ; return positions ; }
public static CheckBox createToggle ( String text , Image icon ) { CheckBox cb = new CheckBox ( text , icon ) ; cb . setToggle ( BOOL_ ) ; return cb ; }
public long addCompletedBatch ( RequestBatch requestBatch ) { long completedBatchId = insertBatchAsCompleted ( requestBatch ) ; for ( Request request : requestBatch . getRequests ( ) ) { request . setBatchId ( completedBatchId ) ; File file = new File ( request . getDestinationPath ( ) ) ; long length = file . exists ( ) ? file . length ( ) : NUM_ ; insertRequestAsCompletedDownload ( request . getDestinationPath ( ) , length , request ) ; } return completedBatchId ; }
@ TargetApi ( Build . VERSION_CODES . JELLY_BEAN ) private void dequeueOutputBuffer ( MediaCodec codec , ByteBuffer [ ] outputBuffers , int index , MediaCodec . BufferInfo info ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . JELLY_BEAN ) { ByteBuffer buffer = outputBuffers [ index ] ; Log . i ( STR_ + info . size + STR_ + buffer . remaining ( ) ) ; if ( info . size <= buffer . remaining ( ) ) { final byte [ ] bufferCopied = new byte [ info . size ] ; buffer . get ( bufferCopied ) ; codec . releaseOutputBuffer ( index , BOOL_ ) ; addEncoded ( bufferCopied ) ; if ( Log . DEBUG ) { AudioUtils . showSomeBytes ( STR_ , bufferCopied ) ; } } else { Log . e ( STR_ ) ; codec . releaseOutputBuffer ( index , BOOL_ ) ; } } }
public static DefaultJobDefinition retryableFixedDelayJobDefinition ( final String jobType , final String jobName , final String description , final Duration fixedDelay , final int restarts , final int retries , final Optional < Duration > retryDelay , final Optional < Duration > maxAge ) { return new DefaultJobDefinition ( jobType , jobName , description , maxAge , Optional . of ( fixedDelay ) , Optional . empty ( ) , restarts , retries , retryDelay ) ; }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case NUM_ : return MESSAGE ; default : return null ; } }
public static void putLong ( long addr , long val ) { if ( UNALIGNED ) UNSAFE . putLong ( addr , val ) ; else putLongByByte ( addr , val , BIG_ENDIAN ) ; }
public static File createMinimalSplit ( String inputFolder , int numFolds , int numAvailableJCas , boolean isSequence ) throws Exception { File outputFolder = new File ( inputFolder , STR_ ) ; int splitNum = ( int ) Math . ceil ( numFolds / ( double ) numAvailableJCas ) ; CollectionReaderDescription createReader = CollectionReaderFactory . createReaderDescription ( BinaryCasReader . class , BinaryCasReader . PARAM_SOURCE_LOCATION , inputFolder , BinaryCasReader . PARAM_PATTERNS , STR_ ) ; AnalysisEngineDescription multiplier = AnalysisEngineFactory . createEngineDescription ( FoldClassificationUnitCasMultiplier . class , FoldClassificationUnitCasMultiplier . PARAM_REQUESTED_SPLITS , splitNum , FoldClassificationUnitCasMultiplier . PARAM_USE_SEQUENCES , isSequence ) ; AnalysisEngineDescription xmiWriter = AnalysisEngineFactory . createEngineDescription ( BinaryCasWriter . class , BinaryCasWriter . PARAM_TARGET_LOCATION , outputFolder . getAbsolutePath ( ) , BinaryCasWriter . PARAM_FORMAT , STR_ ) ; AnalysisEngineDescription both = AnalysisEngineFactory . createEngineDescription ( multiplier , xmiWriter ) ; SimplePipeline . runPipeline ( createReader , both ) ; isNumberOfCasCreatedLargerEqualNumFolds ( outputFolder , numFolds ) ; return outputFolder ; }
public org . w3c . dom . Element signXML ( org . w3c . dom . Document doc , java . lang . String certAlias ) throws XMLSignatureException { return signXML ( doc , certAlias , null ) ; }
public boolean displayPopup ( ) { if ( m_popupClass == null ) return BOOL_ ; try { Window win = SwingUtilities . getWindowAncestor ( this ) ; CFieldPopup popup = null ; if ( win instanceof Dialog ) { Constructor < ? > constructor = m_popupClass . getConstructor ( new Class < ? > [ ] { Dialog . class , String . class , Boolean . class } ) ; popup = ( CFieldPopup ) constructor . newInstance ( new Object [ ] { ( Dialog ) win , m_title , new Boolean ( BOOL_ ) } ) ; } else if ( win instanceof Frame ) { Constructor < ? > constructor = m_popupClass . getConstructor ( new Class [ ] { Frame . class , String . class , Boolean . class } ) ; popup = ( CFieldPopup ) constructor . newInstance ( new Object [ ] { ( Frame ) win , m_title , new Boolean ( BOOL_ ) } ) ; } if ( popup == null ) return BOOL_ ; popup . setValue ( m_editor . getItem ( ) ) ; popup . setFormat ( m_editor . getFormat ( ) ) ; popup . show ( ) ; m_editor . setItem ( popup . getValue ( ) ) ; popup = null ; } catch ( Exception e ) { notifyUser ( e ) ; } return BOOL_ ; }
public AbstractSdfWriter ( final PrereadType prereadType , final boolean hasQuality , boolean hasNames , boolean compressed , final SequenceType type ) { mPrereadType = prereadType ; mPrereadArm = PrereadArm . UNKNOWN ; mSdfId = new SdfId ( ) ; mNameHandler = new SequenceNameHandler ( ) ; mSequenceType = type ; mFirstValid = mSequenceType . firstValid ( ) ; mResidueCounts = new long [ mSequenceType . numberKnownCodes ( ) + mSequenceType . firstValid ( ) ] ; mNHistogram = new long [ MAX_HISTOGRAM ] ; mPosHistogram = new long [ MAX_HISTOGRAM ] ; mQSAveragePerPos = new double [ MAX_HISTOGRAM ] ; mPositionCounts = new long [ MAX_HISTOGRAM ] ; mGlobalQSAverage = NUM_ ; mDataHashFunction = new PrereadHashFunction ( ) ; mQualityHashFunction = new PrereadHashFunction ( ) ; mNameHashFunction = new PrereadHashFunction ( ) ; mNameSuffixHashFunction = new PrereadHashFunction ( ) ; mHasQuality = hasQuality ; mHasNames = hasNames ; mCompressed = compressed ; mSeqDataChecksum = new CRC32 ( ) ; mQualDataChecksum = new CRC32 ( ) ; }
FiringPlan guessBestFiringPlanUnderHeat ( Entity shooter , @ Nullable EntityState shooterState , Targetable target , @ Nullable EntityState targetState , int maxHeat , IGame game ) { if ( maxHeat < NUM_ ) { maxHeat = NUM_ ; } FiringPlan alphaStrike = guessFullFiringPlan ( shooter , shooterState , target , targetState , game ) ; if ( alphaStrike . getHeat ( ) <= maxHeat && ! ( shooter instanceof Infantry ) && ! ( shooter instanceof BattleArmor ) ) { return alphaStrike ; } FiringPlan heatPlans [ ] = calcFiringPlansUnderHeat ( shooter , alphaStrike ) ; Arrays . sort ( heatPlans ) ; if ( heatPlans . length > NUM_ ) { return heatPlans [ NUM_ ] ; } else { return new FiringPlan ( target ) ; } }
public static VolumeGroupRestRep map ( VolumeGroup from ) { if ( from == null ) { return null ; } VolumeGroupRestRep rep = new VolumeGroupRestRep ( ) ; mapDataObjectFields ( from , rep ) ; rep . setDescription ( from . getDescription ( ) ) ; rep . setRoles ( from . getRoles ( ) ) ; rep . setParent ( toRelatedResource ( ResourceTypeEnum . VOLUME_GROUP , from . getParent ( ) ) ) ; rep . setMigrationGroupBy ( from . getMigrationGroupBy ( ) ) ; rep . setMigrationType ( from . getMigrationType ( ) ) ; return rep ; }
public int postFiles ( String [ ] args , int startIndexInArgs , OutputStream out , String type ) { reset ( ) ; int filesPosted = NUM_ ; for ( int j = startIndexInArgs ; j < args . length ; j ++ ) { File srcFile = new File ( args [ j ] ) ; if ( srcFile . isDirectory ( ) && srcFile . canRead ( ) ) { filesPosted += postDirectory ( srcFile , out , type ) ; } else if ( srcFile . isFile ( ) && srcFile . canRead ( ) ) { filesPosted += postFiles ( new File [ ] { srcFile } , out , type ) ; } else { File parent = srcFile . getParentFile ( ) ; if ( parent == null ) parent = new File ( STR_ ) ; String fileGlob = srcFile . getName ( ) ; GlobFileFilter ff = new GlobFileFilter ( fileGlob , BOOL_ ) ; File [ ] files = parent . listFiles ( ff ) ; if ( files == null || files . length == NUM_ ) { warn ( STR_ + srcFile ) ; continue ; } filesPosted += postFiles ( parent . listFiles ( ff ) , out , type ) ; } } return filesPosted ; }
@ Override public final String toString ( ) { if ( stringRep == null ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( this . name ) ; buffer . append ( STR_ ) ; buffer . append ( Integer . toString ( this . defaultPort ) ) ; stringRep = buffer . toString ( ) ; } return stringRep ; }
public void clearSearchable ( ) { searchables . clear ( ) ; }
public void addActionListener ( ActionListener newListener ) { m_listeners . add ( newListener ) ; }
@ Deprecated public ShapelessRecipe addIngredient ( int count , Material ingredient , int rawdata ) { Validate . isTrue ( ingredients . size ( ) + count <= NUM_ , STR_ ) ; if ( rawdata == - NUM_ ) { rawdata = Short . MAX_VALUE ; } while ( count -- > NUM_ ) { ingredients . add ( new ItemStack ( ingredient , NUM_ , ( short ) rawdata ) ) ; } return this ; }
public BatchedImageRequest ( Request < ? > request , ImageContainer container ) { mRequest = request ; mContainers . add ( container ) ; }
public String order ( ) { return mOrderBy . length ( ) > NUM_ ? mOrderBy . toString ( ) : null ; }
static AxesWalker findClone ( AxesWalker key , Vector cloneList ) { if ( null != cloneList ) { int n = cloneList . size ( ) ; for ( int i = NUM_ ; i < n ; i += NUM_ ) { if ( key == cloneList . elementAt ( i ) ) return ( AxesWalker ) cloneList . elementAt ( i + NUM_ ) ; } } return null ; }
public static byte [ ] encodingToBytes ( final String str , final String encoding ) { if ( str == null ) { return null ; } try { return str . getBytes ( encoding ) ; } catch ( final UnsupportedEncodingException e ) { throw new Error ( encoding + STR_ + e ) ; } }
public static boolean looksLikeABGRepeat ( String val ) { return BACKGROUND_REPEATS . indexOf ( val ) >= NUM_ ; }
public void before ( ) throws Throwable { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . M ) { ProcessBuilder processBuilder = new ProcessBuilder ( ) ; processBuilder . command ( STR_ , STR_ ) ; processBuilder . redirectErrorStream ( ) ; Process process = processBuilder . start ( ) ; process . waitFor ( ) ; if ( process . exitValue ( ) != NUM_ ) { Log . e ( LOG_TAG , STR_ + process . exitValue ( ) ) ; } } }
public void addMeta ( char meta , String replacement ) { metaCharacterSet . set ( meta ) ; replacementMap . put ( new String ( new char [ ] { meta } ) , replacement ) ; }
private Matches lookupDo ( Template tmpl , int maxMatches ) { if ( maxMatches < NUM_ ) throw new IllegalArgumentException ( STR_ ) ; int totalMatches = NUM_ ; ArrayList matches = null ; ItemIter iter = matchingItems ( tmpl ) ; if ( maxMatches > NUM_ || iter . dupsPossible ) matches = new ArrayList ( ) ; if ( iter . dupsPossible ) { while ( iter . hasNext ( ) ) { Item item = iter . next ( ) ; if ( ! matches . contains ( item ) ) matches . add ( item ) ; } totalMatches = matches . size ( ) ; if ( maxMatches > NUM_ ) { for ( int i = matches . size ( ) ; -- i >= maxMatches ; ) matches . remove ( i ) ; for ( int i = matches . size ( ) ; -- i >= NUM_ ; ) { matches . set ( i , copyItem ( ( Item ) matches . get ( i ) ) ) ; } } else { matches = null ; } } else { while ( iter . hasNext ( ) ) { Item item = iter . next ( ) ; totalMatches ++ ; if ( -- maxMatches >= NUM_ ) matches . add ( copyItem ( item ) ) ; } } return new Matches ( matches , totalMatches ) ; }
public static List < History > findHistoryByJob ( EntityManager em , JPAEntity job , BigInteger limit ) { requireArgument ( em != null , STR_ ) ; requireArgument ( job != null , STR_ ) ; TypedQuery < History > query = em . createNamedQuery ( STR_ , History . class ) ; if ( limit != null ) { query . setMaxResults ( limit . intValue ( ) ) ; } try { query . setParameter ( STR_ , job ) ; return query . getResultList ( ) ; } catch ( NoResultException ex ) { return new ArrayList < History > ( NUM_ ) ; } }
protected Character isWFXMLChar ( String chardata ) { Character refInvalidChar ; if ( chardata == null || ( chardata . length ( ) == NUM_ ) ) { return null ; } char [ ] dataarray = chardata . toCharArray ( ) ; int datalength = dataarray . length ; if ( fIsXMLVersion11 ) { int i = NUM_ ; while ( i < datalength ) { if ( XML11Char . isXML11Invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - NUM_ ] ; if ( XMLChar . isHighSurrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if ( XMLChar . isLowSurrogate ( ch2 ) && XMLChar . isSupplemental ( XMLChar . supplemental ( ch , ch2 ) ) ) { continue ; } } refInvalidChar = new Character ( ch ) ; return refInvalidChar ; } } } else { int i = NUM_ ; while ( i < datalength ) { if ( XMLChar . isInvalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - NUM_ ] ; if ( XMLChar . isHighSurrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if ( XMLChar . isLowSurrogate ( ch2 ) && XMLChar . isSupplemental ( XMLChar . supplemental ( ch , ch2 ) ) ) { continue ; } } refInvalidChar = new Character ( ch ) ; return refInvalidChar ; } } } return null ; }
public static String quote ( char ch ) { switch ( ch ) { case STR_ : return STR_ ; case STR_ : return STR_ ; case STR_ : return STR_ ; case STR_ : return STR_ ; case STR_ : return STR_ ; case STR_ : return STR_ ; case STR_ : return STR_ ; case STR_ : return STR_ ; default : return ( isPrintableAscii ( ch ) ) ? String . valueOf ( ch ) : String . format ( STR_ , ( int ) ch ) ; } }
private void updatePendingNodes ( final int newLandmarkIndex , final RouterPriorityQueue < Node > pendingNodes ) { final List < Double > newEstRemTravCosts = new ArrayList < > ( ) ; final List < Node > nodesToBeUpdated = new ArrayList < > ( ) ; final InternalLandmarkData landmarkData = new InternalLandmarkData ( ) ; for ( Node node : pendingNodes ) { final AStarNodeData role = getData ( node ) ; final PreProcessLandmarks . LandmarksData ppRole = preprocess . getNodeData ( node ) ; landmarkData . setDelegate ( ppRole ) ; final double newEstRemTravCost = estimateRemainingTravelCost ( landmarkData , newLandmarkIndex ) ; if ( newEstRemTravCost > role . getExpectedRemainingCost ( ) ) { nodesToBeUpdated . add ( node ) ; newEstRemTravCosts . add ( newEstRemTravCost ) ; } } for ( Node node : nodesToBeUpdated ) { pendingNodes . remove ( node ) ; } for ( int i = NUM_ ; i < nodesToBeUpdated . size ( ) ; i ++ ) { final Node node = nodesToBeUpdated . get ( i ) ; final AStarNodeData data = getData ( node ) ; data . setExpectedRemainingCost ( newEstRemTravCosts . get ( i ) ) ; pendingNodes . add ( node , getPriority ( data ) ) ; } }
@ Override public String toString ( ) { StringBuffer buff = new StringBuffer ( ) ; if ( m_correlations == null ) { buff . append ( STR_ ) ; } else { buff . append ( STR_ ) ; if ( m_detailedOutput && m_detailedOutputBuff . length ( ) > NUM_ ) { buff . append ( STR_ ) ; buff . append ( m_detailedOutputBuff ) ; } } return buff . toString ( ) ; }
private void drawOverflowIndicator ( final Graphics g , int maxX ) { int width = NUM_ ; int height = NUM_ ; int xOffset = NUM_ ; int stepSize = width / NUM_ ; int dotSize = NUM_ ; int x = maxX - width - xOffset ; int y = button . getSize ( ) . height - height ; g . setColor ( LIGHTER_GRAY ) ; g . fillRect ( x , y , width , width ) ; g . setColor ( Color . GRAY ) ; g . drawRoundRect ( x , y , width , width , NUM_ , NUM_ ) ; g . setColor ( Color . BLACK ) ; g . fillOval ( x + stepSize , y + NUM_ , dotSize , dotSize ) ; g . fillOval ( x + stepSize . NUM_ , y + NUM_ , dotSize , dotSize ) ; g . fillOval ( x + stepSize . NUM_ , y + NUM_ , dotSize , dotSize ) ; g . dispose ( ) ; }
public void writeLine ( long time , float [ ] column ) { String str = Long . toString ( time ) ; for ( int i = NUM_ ; i < column . length ; ++ i ) { str += STR_ + column [ i ] ; } writer . println ( str ) ; }
public static boolean isPEM ( InputStream is ) { try { String startPEM = STR_ ; int headerLength = NUM_ ; byte [ ] preamble = new byte [ headerLength ] ; if ( is . read ( preamble , NUM_ , headerLength ) > NUM_ ) { String startArray = new String ( preamble ) ; return startArray . startsWith ( startPEM ) ; } return BOOL_ ; } catch ( Exception e ) { throw new DSSException ( STR_ ) ; } }
public CloseListener ( Object resource ) { _resource = resource ; }
@ Override public IndexRequest routing ( String routing ) { if ( routing != null && routing . length ( ) == NUM_ ) { this . routing = null ; } else { this . routing = routing ; } return this ; }
public byte [ ] receive ( ) throws NetworkException { try { packet . setLength ( DatagramConnection . DEFAULT_DATAGRAM_SIZE ) ; connection . receive ( packet ) ; int packetLength = packet . getLength ( ) ; byte [ ] data = new byte [ packetLength ] ; System . arraycopy ( packet . getData ( ) , NUM_ , data , NUM_ , packetLength ) ; return data ; } catch ( IOException e ) { throw new NetworkException ( STR_ , e ) ; } }
@ Override protected void forceDeleteAttributeAt ( int position ) { double [ ] newValues = new double [ m_AttValues . length - NUM_ ] ; System . arraycopy ( m_AttValues , NUM_ , newValues , NUM_ , position ) ; if ( position < m_AttValues . length - NUM_ ) { System . arraycopy ( m_AttValues , position + NUM_ , newValues , position , m_AttValues . length - ( position + NUM_ ) ) ; } m_AttValues = newValues ; }
public synchronized AlphabeticIndex addLabels ( Locale locale ) { addLabels ( peer , locale . toString ( ) ) ; return this ; }
protected byte [ ] engineWrap ( Key key ) throws IllegalBlockSizeException , InvalidKeyException { throw new UnsupportedOperationException ( ) ; }
@ Deprecated public JavaPluginLoader ( Server instance ) { Validate . notNull ( instance , STR_ ) ; server = instance ; }
public void addSeparator ( ) { if ( log . isLoggable ( PlatformLogger . Level . FINER ) ) { log . finer ( STR_ ) ; } }
public static boolean testSaveLocationExists ( ) { String sDCardStatus = Environment . getExternalStorageState ( ) ; boolean status ; if ( sDCardStatus . equals ( Environment . MEDIA_MOUNTED ) ) { status = BOOL_ ; } else { status = BOOL_ ; } return status ; }
private static Class < ? > loadClass ( URL [ ] urls , String name ) throws ClassNotFoundException { ClassLoader parent = getRMIContextClassLoader ( ) ; if ( loaderLog . isLoggable ( Log . VERBOSE ) ) { loaderLog . log ( Log . VERBOSE , STR_ + parent + STR_ ) ; } SecurityManager sm = System . getSecurityManager ( ) ; if ( sm == null ) { try { Class < ? > c = Class . forName ( name , BOOL_ , parent ) ; if ( loaderLog . isLoggable ( Log . VERBOSE ) ) { loaderLog . log ( Log . VERBOSE , STR_ + name + STR_ + STR_ + STR_ + STR_ + c . getClassLoader ( ) ) ; } return c ; } catch ( ClassNotFoundException e ) { if ( loaderLog . isLoggable ( Log . BRIEF ) ) { loaderLog . log ( Log . BRIEF , STR_ + name + STR_ + STR_ + STR_ , e ) ; } throw new ClassNotFoundException ( e . getMessage ( ) + STR_ , e . getException ( ) ) ; } } Loader loader = lookupLoader ( urls , parent ) ; try { if ( loader != null ) { loader . checkPermissions ( ) ; } } catch ( SecurityException e ) { try { Class < ? > c = loadClassForName ( name , BOOL_ , parent ) ; if ( loaderLog . isLoggable ( Log . VERBOSE ) ) { loaderLog . log ( Log . VERBOSE , STR_ + name + STR_ + STR_ + STR_ + STR_ + c . getClassLoader ( ) ) ; } return c ; } catch ( ClassNotFoundException unimportant ) { if ( loaderLog . isLoggable ( Log . BRIEF ) ) { loaderLog . log ( Log . BRIEF , STR_ + name + STR_ + STR_ + STR_ , e ) ; } throw new ClassNotFoundException ( STR_ , e ) ; } } try { Class < ? > c = loadClassForName ( name , BOOL_ , loader ) ; if ( loaderLog . isLoggable ( Log . VERBOSE ) ) { loaderLog . log ( Log . VERBOSE , STR_ + name + STR_ + STR_ + STR_ + c . getClassLoader ( ) ) ; } return c ; } catch ( ClassNotFoundException e ) { if ( loaderLog . isLoggable ( Log . BRIEF ) ) { loaderLog . log ( Log . BRIEF , STR_ + name + STR_ , e ) ; } throw e ; } }
public static final List < INaviRawModule > loadRawModules ( final AbstractSQLProvider provider ) throws CouldntLoadDataException { Preconditions . checkNotNull ( provider , STR_ ) ; final CConnection connection = provider . getConnection ( ) ; final List < INaviRawModule > modules = new ArrayList < INaviRawModule > ( ) ; if ( ! PostgreSQLHelpers . hasTable ( connection , CTableNames . RAW_MODULES_TABLE ) ) { return modules ; } final String query = STR_ + CTableNames . RAW_MODULES_TABLE + STR_ ; try ( ResultSet resultSet = connection . executeQuery ( query , BOOL_ ) ) { while ( resultSet . next ( ) ) { final int rawModuleId = resultSet . getInt ( STR_ ) ; final String name = PostgreSQLHelpers . readString ( resultSet , STR_ ) ; final boolean isComplete = PostgreSQLDatabaseFunctions . checkRawModulesTables ( provider . getConnection ( ) , PostgreSQLHelpers . getDatabaseName ( provider . getConnection ( ) ) , rawModuleId ) ; final int functionCount = isComplete ? PostgreSQLDatabaseFunctions . getRawModuleFunctionCount ( connection , rawModuleId ) : NUM_ ; final CRawModule module = new CRawModule ( rawModuleId , name , functionCount , isComplete , provider ) ; modules . add ( module ) ; } } catch ( final SQLException e ) { throw new CouldntLoadDataException ( e ) ; } return modules ; }
void write ( ImageOutputStream ios ) throws IOException { length = NUM_ + data . length ; writeTag ( ios ) ; ios . write ( data ) ; }
public static int probRound ( double value , Random rand ) { if ( value >= NUM_ ) { double lower = Math . floor ( value ) ; double prob = value - lower ; if ( rand . nextDouble ( ) < prob ) { return ( int ) lower + NUM_ ; } else { return ( int ) lower ; } } else { double lower = Math . floor ( Math . abs ( value ) ) ; double prob = Math . abs ( value ) - lower ; if ( rand . nextDouble ( ) < prob ) { return - ( ( int ) lower + NUM_ ) ; } else { return - ( int ) lower ; } } }
Map < String , TypeName > convertPropertiesToTypes ( Map < String , ExecutableElement > properties ) { Map < String , TypeName > types = new LinkedHashMap < String , TypeName > ( ) ; for ( Map . Entry < String , ExecutableElement > entry : properties . entrySet ( ) ) { ExecutableElement el = entry . getValue ( ) ; types . put ( entry . getKey ( ) , TypeName . get ( el . getReturnType ( ) ) ) ; } return types ; }
private static List < RegisterDescription > parseRegisterInformation ( final Node node ) throws MessageParserException { final List < RegisterDescription > registers = new ArrayList < > ( ) ; final NodeList nodes = node . getChildNodes ( ) ; for ( int i = NUM_ ; i < nodes . getLength ( ) ; ++ i ) { final Node child = nodes . item ( i ) ; final String registerName = getAttribute ( child , STR_ ) ; final String registerSize = getAttribute ( child , STR_ ) ; final String registerEditable = getAttribute ( child , STR_ ) ; registers . add ( new RegisterDescription ( registerName , Integer . valueOf ( registerSize ) , Boolean . valueOf ( registerEditable ) ) ) ; } return registers ; }
public NamedThreadFactory ( String namePrefix ) { this . namePrefix = Objects . requireNonNull ( namePrefix ) ; group = getThreadGroup ( ) ; daemon = BOOL_ ; }
public void test_metric_cpu_num_uint16 ( ) { final IGangliaMetadataMessage decl = new GangliaMetadataMessage ( STR_ , STR_ , BOOL_ , GangliaMessageTypeEnum . UINT16 , STR_ , STR_ , GangliaSlopeEnum . zero , NUM_ , NUM_ , AbstractMetrics . getMap ( IGangliaAttributes . GROUP_CPU , STR_ , STR_ ) ) ; assertEncodeDecode ( null , decl ) ; final IGangliaMetricMessage expected = new GangliaMetricMessage ( GangliaMessageTypeEnum . UINT16 , STR_ , STR_ , BOOL_ , STR_ , Integer . valueOf ( NUM_ ) ) ; final byte [ ] actualData = assertEncodeDecode ( decl , expected ) ; final byte [ ] expectedData = new byte [ ] { NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; if ( ! Arrays . equals ( expectedData , actualData ) ) { fail ( STR_ + Arrays . toString ( expectedData ) + STR_ + Arrays . toString ( actualData ) ) ; } }
String formatNumberList ( TransformerImpl transformer , long [ ] list , int contextNode ) throws TransformerException { String numStr ; FastStringBuffer formattedNumber = StringBufferPool . get ( ) ; try { int nNumbers = list . length , numberWidth = NUM_ ; char numberType = STR_ ; String formatToken , lastSepString = null , formatTokenString = null ; String lastSep = STR_ ; boolean isFirstToken = BOOL_ ; String formatValue = ( null != m_format_avt ) ? m_format_avt . evaluate ( transformer . getXPathContext ( ) , contextNode , this ) : null ; if ( null == formatValue ) formatValue = STR_ ; NumberFormatStringTokenizer formatTokenizer = new NumberFormatStringTokenizer ( formatValue ) ; for ( int i = NUM_ ; i < nNumbers ; i ++ ) { if ( formatTokenizer . hasMoreTokens ( ) ) { formatToken = formatTokenizer . nextToken ( ) ; if ( Character . isLetterOrDigit ( formatToken . charAt ( formatToken . length ( ) - NUM_ ) ) ) { numberWidth = formatToken . length ( ) ; numberType = formatToken . charAt ( numberWidth - NUM_ ) ; } else if ( formatTokenizer . isLetterOrDigitAhead ( ) ) { formatTokenString = formatToken ; while ( formatTokenizer . nextIsSep ( ) ) { formatToken = formatTokenizer . nextToken ( ) ; formatTokenString += formatToken ; } if ( ! isFirstToken ) lastSep = formatTokenString ; formatToken = formatTokenizer . nextToken ( ) ; numberWidth = formatToken . length ( ) ; numberType = formatToken . charAt ( numberWidth - NUM_ ) ; } else { lastSepString = formatToken ; while ( formatTokenizer . hasMoreTokens ( ) ) { formatToken = formatTokenizer . nextToken ( ) ; lastSepString += formatToken ; } } } if ( null != formatTokenString && isFirstToken ) { formattedNumber . append ( formatTokenString ) ; } else if ( null != lastSep && ! isFirstToken ) formattedNumber . append ( lastSep ) ; getFormattedNumber ( transformer , contextNode , numberType , numberWidth , list [ i ] , formattedNumber ) ; isFirstToken = BOOL_ ; } while ( formatTokenizer . isLetterOrDigitAhead ( ) ) { formatTokenizer . nextToken ( ) ; } if ( lastSepString != null ) formattedNumber . append ( lastSepString ) ; while ( formatTokenizer . hasMoreTokens ( ) ) { formatToken = formatTokenizer . nextToken ( ) ; formattedNumber . append ( formatToken ) ; } numStr = formattedNumber . toString ( ) ; } finally { StringBufferPool . free ( formattedNumber ) ; } return numStr ; }
Deque < Block > schedule ( Block entry ) { Deque < Block > code = dfs ( entry ) ; Deque < Block > scheduled = new ArrayDeque < Block > ( ) ; SetMap < Block , Edge > pred = preds ( code ) ; Map < Block , Block > idom = idoms ( code , pred ) ; EdgeMap < Block > loops = findLoops ( code , idom , pred ) ; if ( ! loops . isEmpty ( ) ) verboseStatus ( STR_ + loops ) ; for ( Block b : code ) { if ( ! scheduled . contains ( b ) ) scheduled . add ( b ) ; if ( loops . containsKey ( b ) ) schedule_loop ( b , loops , scheduled ) ; } Deque < Block > branch_analysis = new ArrayDeque < Block > ( ) ; branch_analysis . addAll ( scheduled ) ; Set < Block > already_seen = new HashSet < Block > ( ) ; while ( branch_analysis . size ( ) > NUM_ ) { Block b = branch_analysis . removeFirst ( ) ; Expr last = b . last ( ) ; Block next = branch_analysis . peekFirst ( ) ; if ( isBranch ( last ) && last . succ [ NUM_ ] . to != next && last . succ [ NUM_ ] . to == next ) invert ( last ) ; already_seen . add ( b ) ; b . is_backwards_branch_target = BOOL_ ; for ( Edge s : b . succ ( ) ) { s . to . is_backwards_branch_target |= s . is_backwards_branch = already_seen . contains ( s . to ) ; } } if ( verbose_mode ) for ( Block b : code ) if ( b . is_backwards_branch_target ) verboseStatus ( STR_ + b ) ; return scheduled ; }
public void addTransaction ( SIPServerTransaction serverTransaction ) throws IOException { if ( logger . isLoggingEnabled ( LogWriter . TRACE_DEBUG ) ) logger . logDebug ( STR_ + serverTransaction ) ; serverTransaction . map ( ) ; addTransactionHash ( serverTransaction ) ; }
private void delayRetry ( int multiplier ) { debug ( STR_ ) ; try { Thread . sleep ( NUM_ . multiplier ) ; } catch ( InterruptedException e ) { warn ( e , STR_ ) ; } }
public void testSplitAndJoinSemicolonNestedInPipeProperties ( ) { Properties outer = PropertyUtils . splitPropertiesOnPipe ( ONE_THEN_TWO_OUTER_A ) ; assertEquals ( ONE_SEMI_TWO , outer . getProperty ( STR_ ) ) ; assertEquals ( NUM_ , outer . size ( ) ) ; try { assertEquals ( ONE_THEN_TWO_OUTER_A , PropertyUtils . joinOnPipe ( PropertyUtils . toMap ( outer ) ) ) ; return ; } catch ( ComparisonFailure deviation1 ) { } try { assertEquals ( TWO_THEN_ONE_OUTER_A , PropertyUtils . joinOnPipe ( PropertyUtils . toMap ( outer ) ) ) ; return ; } catch ( ComparisonFailure deviation2 ) { } try { assertEquals ( ONE_THEN_TWO_OUTER_B , PropertyUtils . joinOnPipe ( PropertyUtils . toMap ( outer ) ) ) ; return ; } catch ( ComparisonFailure deviation3 ) { } try { assertEquals ( TWO_THEN_ONE_OUTER_B , PropertyUtils . joinOnPipe ( PropertyUtils . toMap ( outer ) ) ) ; return ; } catch ( ComparisonFailure deviation4 ) { } assertEquals ( TWO_THEN_ONE_OUTER_A , PropertyUtils . joinOnPipe ( PropertyUtils . toMap ( outer ) ) ) ; }
public void testIntBooleanMap ( ) throws Exception { ObjectMapper mapper = new ObjectMapper ( ) ; String JSON = STR_ ; Map < String , Integer > result = mapper . readValue ( JSON , new TypeReference < HashMap < Integer , Boolean > > ( ) { } ) ; assertNotNull ( result ) ; assertEquals ( HashMap . class , result . getClass ( ) ) ; assertEquals ( NUM_ , result . size ( ) ) ; assertEquals ( Boolean . TRUE , result . get ( Integer . valueOf ( NUM_ ) ) ) ; assertEquals ( Boolean . FALSE , result . get ( Integer . valueOf ( - NUM_ ) ) ) ; assertNull ( result . get ( STR_ ) ) ; assertNull ( result . get ( NUM_ ) ) ; }
@ Override public boolean isBusy ( ) { return BOOL_ ; }
protected ByteArrayOutputStream parseBytes ( ByteArrayOutputStream bos ) throws IOException { int ch ; for ( ch = skipWhitespace ( ) ; ch >= NUM_ && ch != STR_ ; ch = skipWhitespace ( ) ) { int b1 = ch ; int b2 = read ( ) ; int b3 = read ( ) ; int b4 = read ( ) ; if ( b4 != STR_ ) { int chunk = ( ( base64Decode [ b1 ] << NUM_ ) + ( base64Decode [ b2 ] << NUM_ ) + ( base64Decode [ b3 ] << NUM_ ) + ( base64Decode [ b4 ] ) ) ; bos . write ( chunk > > NUM_ ) ; bos . write ( chunk > > NUM_ ) ; bos . write ( chunk ) ; } else if ( b3 != STR_ ) { int chunk = ( ( base64Decode [ b1 ] << NUM_ ) + ( base64Decode [ b2 ] << NUM_ ) + ( base64Decode [ b3 ] > > NUM_ ) ) ; bos . write ( chunk > > NUM_ ) ; bos . write ( chunk ) ; } else { int chunk = ( ( base64Decode [ b1 ] << NUM_ ) + ( base64Decode [ b2 ] > > NUM_ ) ) ; bos . write ( chunk ) ; } } if ( ch == STR_ ) _peek = ch ; return bos ; }
public void reset ( ) { if ( mDownloadBandwidth != null ) { mDownloadBandwidth . reset ( ) ; } mCurrentBandwidthConnectionQuality . set ( ConnectionQuality . UNKNOWN ) ; }
public void testMergeSecurityRoleIntoEmptyDocument ( ) throws Exception { String srcXml = STR_ ; WebXml srcWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( srcXml . getBytes ( STR_ ) ) , null ) ; String mergeXml = STR_ + STR_ + STR_ + STR_ + STR_ ; WebXml mergeWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( mergeXml . getBytes ( STR_ ) ) , null ) ; WebXmlMerger merger = new WebXmlMerger ( srcWebXml ) ; merger . merge ( mergeWebXml ) ; List < String > securityRoleNames = WebXmlUtils . getSecurityRoleNames ( srcWebXml ) ; assertEquals ( NUM_ , securityRoleNames . size ( ) ) ; assertEquals ( STR_ , securityRoleNames . get ( NUM_ ) ) ; }
private DiffPart decodeFullRevision ( final int blockSize_L ) throws UnsupportedEncodingException , DecodingException { if ( blockSize_L < NUM_ ) { throw new DecodingException ( STR_ + blockSize_L ) ; } int l = r . read ( blockSize_L ) ; ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; for ( int i = NUM_ ; i < l ; i ++ ) { output . write ( r . readByte ( ) ) ; } DiffPart part = new DiffPart ( DiffAction . FULL_REVISION_UNCOMPRESSED ) ; part . setText ( output . toString ( WIKIPEDIA_ENCODING ) ) ; return part ; }
private synchronized static void removeChildCharacterData ( Node node , boolean deep ) { NodeList list = node . getChildNodes ( ) ; for ( int i = list . getLength ( ) ; i >= NUM_ ; i -- ) { Node n = list . item ( i ) ; if ( n == null ) continue ; if ( n instanceof CharacterData ) node . removeChild ( XMLCaster . toRawNode ( n ) ) ; else if ( deep ) removeChildCharacterData ( n , deep ) ; } }
void unlink ( Node < E > p , Node < E > trail ) { p . item = null ; trail . next = p . next ; if ( last == p ) last = trail ; if ( count . getAndDecrement ( ) == capacity ) notFull . signal ( ) ; }
private void loadCorpus ( String source , String target , String align ) throws IOException { logger . info ( STR_ ) ; TimeKeeper timer = TimingUtils . start ( ) ; int numSourcePositions = NUM_ ; int numTargetPositions = NUM_ ; numSentences = NUM_ ; ParallelCorpus corpus = new ParallelCorpus ( NUM_ ) ; try ( LineNumberReader fReader = IOTools . getReaderFromFile ( source ) ) { LineNumberReader eReader = IOTools . getReaderFromFile ( target ) ; LineNumberReader aReader = IOTools . getReaderFromFile ( align ) ; for ( String fLine ; ( fLine = fReader . readLine ( ) ) != null ; ) { String eLine = eReader . readLine ( ) ; String aLine = aReader . readLine ( ) ; AlignedSentence example = corpus . getSentence ( fLine , eLine , aLine ) ; if ( example != null ) { numSourcePositions += example . sourceLength ( ) ; numTargetPositions += example . targetLength ( ) ; ++ numSentences ; } } } final int initialVocabularySize = corpus . getVocabulary ( ) . size ( ) ; timer . mark ( STR_ ) ; logger . info ( STR_ , numSourcePositions , numTargetPositions , numSentences ) ; final int srcLength = numSourcePositions + numSentences ; if ( srcLength < NUM_ ) throw new RuntimeException ( STR_ ) ; srcBitext = new int [ srcLength ] ; f2e = new int [ srcLength ] ; final int tgtLength = numTargetPositions + numSentences ; if ( tgtLength < NUM_ ) throw new RuntimeException ( STR_ ) ; tgtBitext = new int [ tgtLength ] ; e2f = new int [ tgtLength ] ; try ( LineNumberReader fReader = IOTools . getReaderFromFile ( source ) ) { LineNumberReader eReader = IOTools . getReaderFromFile ( target ) ; LineNumberReader aReader = IOTools . getReaderFromFile ( align ) ; int srcOffset = NUM_ ; int tgtOffset = NUM_ ; for ( String fLine ; ( fLine = fReader . readLine ( ) ) != null ; ) { String eLine = eReader . readLine ( ) ; String aLine = aReader . readLine ( ) ; AlignedSentence sentence = corpus . getSentence ( fLine , eLine , aLine ) ; if ( sentence == null ) { logger . info ( STR_ , fReader . getLineNumber ( ) ) ; } else { System . arraycopy ( sentence . source , NUM_ , srcBitext , srcOffset , sentence . sourceLength ( ) ) ; System . arraycopy ( sentence . f2e , NUM_ , f2e , srcOffset , sentence . f2e . length ) ; System . arraycopy ( sentence . target , NUM_ , tgtBitext , tgtOffset , sentence . targetLength ( ) ) ; System . arraycopy ( sentence . e2f , NUM_ , e2f , tgtOffset , sentence . e2f . length ) ; srcOffset += sentence . sourceLength ( ) ; tgtOffset += sentence . targetLength ( ) ; srcBitext [ srcOffset ] = toSentenceOffset ( tgtOffset ) ; tgtBitext [ tgtOffset ] = toSentenceOffset ( srcOffset ) ; ++ srcOffset ; ++ tgtOffset ; } } } this . vocabulary = corpus . getVocabulary ( ) ; assert initialVocabularySize == vocabulary . size ( ) ; timer . mark ( STR_ ) ; logger . info ( STR_ , timer ) ; }
public static float mixFriction ( float friction1 , float friction2 ) { return MathUtils . sqrt ( friction1 . friction2 ) ; }
public String serialize ( Object obj , String contentType ) throws ApiException { if ( contentType . startsWith ( STR_ ) ) { return json . serialize ( obj ) ; } else { throw new ApiException ( NUM_ , STR_ + contentType ) ; } }
private boolean compileSWsequenceZR ( int baseRegister , int [ ] offsets , int [ ] registers ) { for ( int i = NUM_ ; i < registers . length ; i ++ ) { if ( registers [ i ] != _zr ) { return BOOL_ ; } } for ( int i = NUM_ ; i < offsets . length ; i ++ ) { if ( offsets [ i ] != offsets [ i - NUM_ ] + NUM_ ) { return BOOL_ ; } } int offset = offsets [ NUM_ ] ; int length = offsets . length ; do { int copyLength = Math . min ( length , FastMemory . zero . length ) ; mv . visitFieldInsn ( Opcodes . GETSTATIC , Type . getInternalName ( FastMemory . class ) , STR_ , STR_ ) ; loadImm ( NUM_ ) ; loadMemoryInt ( ) ; prepareMemIndex ( baseRegister , offset , BOOL_ , NUM_ ) ; loadImm ( copyLength ) ; mv . visitMethodInsn ( Opcodes . INVOKESTATIC , Type . getInternalName ( System . class ) , STR_ , arraycopyDescriptor ) ; length -= copyLength ; offset += copyLength ; } while ( length > NUM_ ) ; return BOOL_ ; }
private boolean isNativeVolumeExpansionSupported ( Volume vplexVolume , Long newSize ) { boolean useNativeVolumeExpansion = BOOL_ ; StringSet assocVolumeIds = vplexVolume . getAssociatedVolumes ( ) ; if ( null == assocVolumeIds ) { s_logger . warn ( STR_ , vplexVolume . forDisplay ( ) ) ; useNativeVolumeExpansion = BOOL_ ; } else { for ( String assocVolumeId : assocVolumeIds ) { Volume assocVolume = _permissionsHelper . getObjectById ( URI . create ( assocVolumeId ) , Volume . class ) ; try { super . verifyVolumeExpansionRequest ( assocVolume , newSize ) ; } catch ( Exception e ) { useNativeVolumeExpansion = BOOL_ ; break ; } } } return useNativeVolumeExpansion ; }
public void updateGUI ( RosterEntry r ) { roadName . setText ( r . getRoadName ( ) ) ; roadNumber . setText ( r . getRoadNumber ( ) ) ; mfg . setText ( r . getMfg ( ) ) ; owner . setText ( r . getOwner ( ) ) ; model . setText ( r . getModel ( ) ) ; comment . setText ( r . getComment ( ) ) ; decoderModel . setText ( r . getDecoderModel ( ) ) ; decoderFamily . setText ( r . getDecoderFamily ( ) ) ; decoderComment . setText ( r . getDecoderComment ( ) ) ; dateUpdated . setText ( r . getDateUpdated ( ) ) ; maxSpeedSpinner . setValue ( Integer . valueOf ( r . getMaxSpeedPCT ( ) ) ) ; }
public static Double oizp ( Number value ) { if ( value == null ) { return null ; } return ( value . doubleValue ( ) >= NUM_ ) ? NUM_ : NUM_ ; }
public TerminalSize with ( TerminalSize size ) { if ( equals ( size ) ) { return this ; } return size ; }
private boolean isGzipAllowed ( final HttpServletRequest request ) { return ! DispatcherStreamLocator . isIncludedRequest ( request ) && WroUtil . isGzipSupported ( request ) ; }
public ReplayProcessor ( int bufferSize , boolean unbounded ) { if ( unbounded ) { this . buffer = new UnboundedBuffer < > ( bufferSize ) ; } else { this . buffer = new BoundedBuffer < > ( bufferSize ) ; } SUBSCRIBERS . lazySet ( this , EMPTY ) ; }
protected void onShowConversations ( @ NonNull List < C > conversations ) { if ( DEBUG ) { Log . d ( TAG , STR_ + conversations . size ( ) + STR_ ) ; } mView . showConversations ( new ArrayList < > ( conversations ) ) ; }
protected int read ( ) throws IOException { if ( offset == buffer . length ) { throw new ASN1Exception ( STR_ ) ; } if ( in == null ) { return buffer [ offset ++ ] & xFF ; } else { int octet = in . read ( ) ; if ( octet == - NUM_ ) { throw new ASN1Exception ( STR_ ) ; } buffer [ offset ++ ] = ( byte ) octet ; return octet ; } }
public void enqueueJob ( final Runnable job ) { synchronized ( mSleepSync ) { if ( hasJob ( ) ) { throw new IllegalStateException ( STR_ ) ; } setJob ( job ) ; mSleepSync . notifyAll ( ) ; } }
public void testSetNull_int_int ( ) throws SQLException { PreparedStatement ps = null ; try { String query = STR_ ; ps = conn . prepareStatement ( query ) ; Statement st = null ; try { ps . setNull ( NUM_ , Types . INTEGER ) ; ps . execute ( ) ; } finally { try { ps . close ( ) ; } catch ( Exception ee ) { } } query = STR_ ; ps = conn . prepareStatement ( query ) ; try { ps . setNull ( NUM_ , Types . BIGINT ) ; ps . execute ( ) ; } finally { try { ps . close ( ) ; } catch ( Exception ee ) { } } query = STR_ ; ps = conn . prepareStatement ( query ) ; try { ps . setNull ( NUM_ , Types . DECIMAL ) ; ps . execute ( ) ; } finally { try { ps . close ( ) ; } catch ( Exception ee ) { } } query = STR_ ; ps = conn . prepareStatement ( query ) ; try { ps . setNull ( NUM_ , Types . DATE ) ; ps . execute ( ) ; } finally { try { ps . close ( ) ; } catch ( Exception ee ) { } } query = STR_ ; ps = conn . prepareStatement ( query ) ; try { ps . setNull ( NUM_ , Types . BLOB ) ; ps . execute ( ) ; } finally { try { ps . close ( ) ; } catch ( Exception ee ) { } } query = STR_ ; ps = conn . prepareStatement ( query ) ; ps . setNull ( NUM_ , Types . CHAR ) ; ps . execute ( ) ; } finally { try { ps . close ( ) ; } catch ( Exception ee ) { } } }
public void testTestBitPositive2 ( ) { byte aBytes [ ] = { - NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int number = NUM_ ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; assertTrue ( aNumber . testBit ( number ) ) ; }
public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws org . xml . sax . SAXException { if ( qName . equals ( PrintData . XML_TAG ) ) { String name = attributes . getValue ( PrintData . XML_ATTRIBUTE_NAME ) ; if ( m_pd == null ) { m_pd = new PrintData ( m_ctx , name ) ; push ( m_pd ) ; } else { PrintData temp = new PrintData ( m_ctx , name ) ; m_curPD . addNode ( temp ) ; push ( temp ) ; } } else if ( qName . equals ( PrintData . XML_ROW_TAG ) ) { m_curPD . addRow ( BOOL_ , NUM_ ) ; } else if ( qName . equals ( PrintDataElement . XML_TAG ) ) { m_curPDEname = attributes . getValue ( PrintDataElement . XML_ATTRIBUTE_NAME ) ; m_curPDEvalue = new StringBuffer ( ) ; } }
public synchronized int updatePurchase ( String orderId , String productId , PurchaseState purchaseState , long purchaseTime , String developerPayload ) { insertOrder ( orderId , productId , purchaseState , purchaseTime , developerPayload ) ; Cursor cursor = mDb . query ( PURCHASE_HISTORY_TABLE_NAME , HISTORY_COLUMNS , HISTORY_PRODUCT_ID_COL + STR_ , new String [ ] { productId } , null , null , null , null ) ; if ( cursor == null ) { return NUM_ ; } int quantity = NUM_ ; try { while ( cursor . moveToNext ( ) ) { int stateIndex = cursor . getInt ( NUM_ ) ; PurchaseState state = PurchaseState . valueOf ( stateIndex ) ; if ( state == PurchaseState . PURCHASED || state == PurchaseState . REFUNDED ) { quantity += NUM_ ; } } updatePurchasedItem ( productId , quantity ) ; } finally { if ( cursor != null ) { cursor . close ( ) ; } } return quantity ; }
public void drawString ( String str , int x , int y , int textDecoration ) { if ( str . length ( ) == NUM_ || ( str . length ( ) == NUM_ && str . charAt ( NUM_ ) == STR_ ) ) { return ; } Object nativeFont = null ; if ( current != null ) { nativeFont = current . getNativeFont ( ) ; } if ( current instanceof CustomFont ) { current . drawString ( this , str , x , y ) ; } else { impl . drawString ( nativeGraphics , nativeFont , str , x + xTranslate , y + yTranslate , textDecoration ) ; } }
@ Override public int read ( char [ ] array , int offset , int length ) { if ( idx >= charSequence . length ( ) ) { return - NUM_ ; } if ( array == null ) { throw new NullPointerException ( STR_ ) ; } if ( length < NUM_ || offset < NUM_ || offset + length > array . length ) { throw new IndexOutOfBoundsException ( STR_ + array . length + STR_ + offset + STR_ + length ) ; } int count = NUM_ ; for ( int i = NUM_ ; i < length ; i ++ ) { int c = read ( ) ; if ( c == - NUM_ ) { return count ; } array [ offset + i ] = ( char ) c ; count ++ ; } return count ; }
public void updateNonceParameters ( ) { if ( mNextNonce . equals ( mNonce ) ) { mCnonceCounter ++ ; } else { mCnonceCounter = NUM_ ; mNonce = mNextNonce ; } }
@ Override public void acceptInstance ( InstanceEvent e ) { if ( e . getStatus ( ) == InstanceEvent . FORMAT_AVAILABLE ) { m_connectedFormat = e . getStructure ( ) ; m_stopRequested . set ( BOOL_ ) ; try { init ( new Instances ( e . getStructure ( ) , NUM_ ) ) ; } catch ( IllegalArgumentException ex ) { if ( m_log != null ) { String message = STR_ ; stopWithErrorMessage ( message , ex ) ; return ; } } String buffSize = m_bufferSize ; try { buffSize = m_env . substitute ( buffSize ) ; m_bufferSizeI = Integer . parseInt ( buffSize ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } m_incrementalBuffer = new ArrayList < InstanceHolder > ( m_bufferSizeI ) ; m_bufferFiles = new ArrayList < File > ( ) ; m_streamCounter = NUM_ ; return ; } m_busy = BOOL_ ; if ( e . getInstance ( ) != null ) { if ( m_streamCounter == NUM_ ) { if ( m_log != null ) { m_log . statusMessage ( statusMessagePrefix ( ) + STR_ ) ; m_log . logMessage ( STR_ + statusMessagePrefix ( ) + STR_ + m_bufferSizeI ) ; } } InstanceHolder tempH = new InstanceHolder ( ) ; tempH . m_instance = e . getInstance ( ) ; tempH . m_fileNumber = - NUM_ ; if ( m_stringAttIndexes != null ) { copyStringAttVals ( tempH ) ; } m_incrementalBuffer . add ( tempH ) ; m_streamCounter ++ ; } if ( e . getInstance ( ) == null || e . getStatus ( ) == InstanceEvent . BATCH_FINISHED ) { emitBufferedInstances ( ) ; return ; } else if ( m_incrementalBuffer . size ( ) == m_bufferSizeI ) { try { sortBuffer ( BOOL_ ) ; } catch ( Exception ex ) { String msg = statusMessagePrefix ( ) + STR_ ; stopWithErrorMessage ( msg , ex ) ; m_busy = BOOL_ ; return ; } } m_busy = BOOL_ ; }
private void matchVPools ( URI rpSystemId ) { List < URI > storagePoolIds = ConnectivityUtil . getRPSystemStoragePools ( _dbClient , rpSystemId ) ; StringBuffer errorMessage = new StringBuffer ( ) ; if ( storagePoolIds != null && ! storagePoolIds . isEmpty ( ) ) { List < StoragePool > storagePools = _dbClient . queryObject ( StoragePool . class , storagePoolIds ) ; ImplicitPoolMatcher . matchModifiedStoragePoolsWithAllVirtualPool ( storagePools , _dbClient , _coordinator , errorMessage ) ; } }
public static BigDecimal calculateFee ( Player player , int price ) { BigDecimal fee = BigDecimal . valueOf ( price ) ; fee = fee . multiply ( BigDecimal . valueOf ( TRADING_FEE_PERCENTAGE ) ) ; if ( player . isBadBoy ( ) ) { fee = fee . multiply ( BigDecimal . valueOf ( NUM_ + TRADING_FEE_PLAYER_KILLER_PENALTY ) ) ; } BigDecimal feeBonus = BigDecimal . ONE ; feeBonus = BigDecimal . valueOf ( Math . exp ( - player . getTradescore ( ) / FEE_BONUS_CONSTANT ) ) ; fee = fee . multiply ( feeBonus ) ; return fee . max ( BigDecimal . ONE ) ; }
private static ResultPoint [ ] findVertices180 ( BitMatrix matrix , boolean tryHarder ) { int height = matrix . getHeight ( ) ; int width = matrix . getWidth ( ) ; int halfWidth = width > > NUM_ ; ResultPoint [ ] result = new ResultPoint [ NUM_ ] ; boolean found = BOOL_ ; int [ ] counters = new int [ START_PATTERN_REVERSE . length ] ; int rowStep = Math . max ( NUM_ , height > > ( tryHarder ? NUM_ : NUM_ ) ) ; for ( int i = height - NUM_ ; i > NUM_ ; i -= rowStep ) { int [ ] loc = findGuardPattern ( matrix , halfWidth , i , halfWidth , BOOL_ , START_PATTERN_REVERSE , counters ) ; if ( loc != null ) { result [ NUM_ ] = new ResultPoint ( loc [ NUM_ ] , i ) ; result [ NUM_ ] = new ResultPoint ( loc [ NUM_ ] , i ) ; found = BOOL_ ; break ; } } if ( found ) { found = BOOL_ ; for ( int i = NUM_ ; i < height ; i += rowStep ) { int [ ] loc = findGuardPattern ( matrix , halfWidth , i , halfWidth , BOOL_ , START_PATTERN_REVERSE , counters ) ; if ( loc != null ) { result [ NUM_ ] = new ResultPoint ( loc [ NUM_ ] , i ) ; result [ NUM_ ] = new ResultPoint ( loc [ NUM_ ] , i ) ; found = BOOL_ ; break ; } } } counters = new int [ STOP_PATTERN_REVERSE . length ] ; if ( found ) { found = BOOL_ ; for ( int i = height - NUM_ ; i > NUM_ ; i -= rowStep ) { int [ ] loc = findGuardPattern ( matrix , NUM_ , i , halfWidth , BOOL_ , STOP_PATTERN_REVERSE , counters ) ; if ( loc != null ) { result [ NUM_ ] = new ResultPoint ( loc [ NUM_ ] , i ) ; result [ NUM_ ] = new ResultPoint ( loc [ NUM_ ] , i ) ; found = BOOL_ ; break ; } } } if ( found ) { found = BOOL_ ; for ( int i = NUM_ ; i < height ; i += rowStep ) { int [ ] loc = findGuardPattern ( matrix , NUM_ , i , halfWidth , BOOL_ , STOP_PATTERN_REVERSE , counters ) ; if ( loc != null ) { result [ NUM_ ] = new ResultPoint ( loc [ NUM_ ] , i ) ; result [ NUM_ ] = new ResultPoint ( loc [ NUM_ ] , i ) ; found = BOOL_ ; break ; } } } return found ? result : null ; }
private void addSearchHistory ( ) { addSearchHistory ( tfSearchEditor . getText ( ) ) ; }
ArrayList < SourceFile > trimFileList ( ArrayList < SourceFile > files ) { HashMap < String , String > names = new HashMap < String , String > ( ) ; ArrayList < SourceFile > list = new ArrayList < SourceFile > ( ) ; int size = files . size ( ) ; for ( int i = NUM_ ; i < size ; i ++ ) { boolean addIt = BOOL_ ; SourceFile fi = files . get ( i ) ; String fName = fi . getRawName ( ) ; if ( m_swfFilter == null ) { if ( names . get ( fName ) == null ) addIt = BOOL_ ; } else { addIt = m_swfFilter . containsSource ( fi ) ; } if ( addIt ) { names . put ( fName , fName ) ; list . add ( fi ) ; } } return list ; }
public static String join ( double [ ] self , String separator ) { StringBuilder buffer = new StringBuilder ( ) ; boolean first = BOOL_ ; if ( separator == null ) separator = STR_ ; for ( double next : self ) { if ( first ) { first = BOOL_ ; } else { buffer . append ( separator ) ; } buffer . append ( next ) ; } return buffer . toString ( ) ; }
protected void writeShort ( int value ) throws IOException { out . write ( value & xff ) ; out . write ( ( value > > NUM_ ) & xff ) ; }
public EntityQuery orderBy ( String ... fields ) { this . orderBy = Arrays . asList ( fields ) ; return this ; }
public StemmedString ( String orig , String stemmed ) { strOrig = orig ; strStemmed = stemmed ; }
public LogNetworkStreamMerger ( LogRequest req , MediaType mediaType , LogSvcPropertiesLoader propertiesLoader ) { logger . trace ( STR_ ) ; this . request = req ; this . mediaType = mediaType ; this . propertiesLoader = propertiesLoader ; List < LogNetworkReader > readers = getLogNetworkStreams ( ) ; int size = readers . size ( ) ; logHeads = new LogMessage [ size ] ; this . logStreamList = new LogNetworkReader [ size ] ; int index = NUM_ ; for ( LogNetworkReader reader : readers ) { logStreamList [ index ] = reader ; logHeads [ index ] = null ; index ++ ; } }
public static String packCipherSuites ( String [ ] ciphers ) { String cipherSet = null ; if ( ciphers != null ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = NUM_ ; i < ciphers . length ; i ++ ) { buf . append ( ciphers [ i ] ) ; if ( i < ciphers . length - NUM_ ) { buf . append ( STR_ ) ; } } cipherSet = buf . toString ( ) ; } return cipherSet ; }
public ExtensionFileFilter ( String description , String extension ) { this . description = description ; this . extensions = new HashSet < String > ( ) ; extensions . add ( extension . toLowerCase ( ) ) ; defaultExtension = extension ; }
private void ensureTupleArray ( int row ) { int nrows = Math . max ( m_table . getRowCount ( ) , row + NUM_ ) ; if ( m_tuples == null ) { m_tuples = new TableTuple [ nrows ] ; } else if ( m_tuples . length < nrows ) { int capacity = Math . max ( ( NUM_ . m_tuples . length ) / NUM_ + NUM_ , nrows ) ; TableTuple [ ] tuples = new TableTuple [ capacity ] ; System . arraycopy ( m_tuples , NUM_ , tuples , NUM_ , m_tuples . length ) ; m_tuples = tuples ; } }
private static boolean isAnArgument ( final String arg ) { return ( arg . startsWith ( STR_ ) && ( arg . length ( ) > NUM_ ) && ! Character . isDigit ( arg . charAt ( NUM_ ) ) ) ; }
private synchronized static void removeChildren ( Node node , short type , boolean deep ) { NodeList list = node . getChildNodes ( ) ; for ( int i = list . getLength ( ) ; i >= NUM_ ; i -- ) { Node n = list . item ( i ) ; if ( n == null ) continue ; if ( n . getNodeType ( ) == type || type == UNDEFINED_NODE ) node . removeChild ( XMLCaster . toRawNode ( n ) ) ; else if ( deep ) removeChildren ( n , type , deep ) ; } }
public final void lazySet ( V newValue ) { unsafe . putOrderedObject ( this , valueOffset , newValue ) ; }
public boolean isValidSavepoint ( Savepoint sp ) { if ( isSource ( ) ) return BOOL_ ; boolean result = BOOL_ ; if ( sp != null ) result = BOOL_ ; return result ; }
public static void columnsFor ( ResultSet resultSet , TableEditor editor ) throws SQLException { List < Column > columns = new ArrayList < > ( ) ; columnsFor ( resultSet , null ) ; editor . setColumns ( columns ) ; }
private static void write ( Collection < String > src , File out ) throws IOException { try ( Writer writer = new BufferedWriter ( new FileWriter ( out ) ) ) { for ( String line : src ) writer . write ( line + STR_ ) ; } }
public void clear ( ) { if ( mOriginalValues != null ) { synchronized ( mLock ) { mOriginalValues . clear ( ) ; } } else { mObjects . clear ( ) ; } if ( mNotifyOnChange ) notifyDataSetChanged ( ) ; }
private long resetUidValidity ( ) throws IOException { long timestamp = System . currentTimeMillis ( ) ; setUidValidity ( timestamp ) ; return timestamp ; }
public final ArrayList < Move > pseudoLegalMoves ( Position pos ) { ArrayList < Move > moveList = getMoveListObj ( ) ; final boolean wtm = pos . whiteMove ; for ( int x = NUM_ ; x < NUM_ ; x ++ ) { for ( int y = NUM_ ; y < NUM_ ; y ++ ) { int sq = Position . getSquare ( x , y ) ; int p = pos . getPiece ( sq ) ; if ( ( p == Piece . EMPTY ) || ( Piece . isWhite ( p ) != wtm ) ) { continue ; } if ( ( p == Piece . WROOK ) || ( p == Piece . BROOK ) || ( p == Piece . WQUEEN ) || ( p == Piece . BQUEEN ) ) { if ( addDirection ( moveList , pos , sq , NUM_ - x , NUM_ ) ) return moveList ; if ( addDirection ( moveList , pos , sq , NUM_ - y , NUM_ ) ) return moveList ; if ( addDirection ( moveList , pos , sq , x , - NUM_ ) ) return moveList ; if ( addDirection ( moveList , pos , sq , y , - NUM_ ) ) return moveList ; } if ( ( p == Piece . WBISHOP ) || ( p == Piece . BBISHOP ) || ( p == Piece . WQUEEN ) || ( p == Piece . BQUEEN ) ) { if ( addDirection ( moveList , pos , sq , Math . min ( NUM_ - x , NUM_ - y ) , NUM_ ) ) return moveList ; if ( addDirection ( moveList , pos , sq , Math . min ( x , NUM_ - y ) , NUM_ ) ) return moveList ; if ( addDirection ( moveList , pos , sq , Math . min ( x , y ) , - NUM_ ) ) return moveList ; if ( addDirection ( moveList , pos , sq , Math . min ( NUM_ - x , y ) , - NUM_ ) ) return moveList ; } if ( ( p == Piece . WKNIGHT ) || ( p == Piece . BKNIGHT ) ) { if ( x < NUM_ && y < NUM_ && addDirection ( moveList , pos , sq , NUM_ , NUM_ ) ) return moveList ; if ( x < NUM_ && y < NUM_ && addDirection ( moveList , pos , sq , NUM_ , NUM_ ) ) return moveList ; if ( x > NUM_ && y < NUM_ && addDirection ( moveList , pos , sq , NUM_ , NUM_ ) ) return moveList ; if ( x > NUM_ && y < NUM_ && addDirection ( moveList , pos , sq , NUM_ , NUM_ ) ) return moveList ; if ( x > NUM_ && y > NUM_ && addDirection ( moveList , pos , sq , NUM_ , - NUM_ ) ) return moveList ; if ( x > NUM_ && y > NUM_ && addDirection ( moveList , pos , sq , NUM_ , - NUM_ ) ) return moveList ; if ( x < NUM_ && y > NUM_ && addDirection ( moveList , pos , sq , NUM_ , - NUM_ ) ) return moveList ; if ( x < NUM_ && y > NUM_ && addDirection ( moveList , pos , sq , NUM_ , - NUM_ ) ) return moveList ; } if ( ( p == Piece . WKING ) || ( p == Piece . BKING ) ) { if ( x < NUM_ && addDirection ( moveList , pos , sq , NUM_ , NUM_ ) ) return moveList ; if ( x < NUM_ && y < NUM_ && addDirection ( moveList , pos , sq , NUM_ , NUM_ ) ) return moveList ; if ( y < NUM_ && addDirection ( moveList , pos , sq , NUM_ , NUM_ ) ) return moveList ; if ( x > NUM_ && y < NUM_ && addDirection ( moveList , pos , sq , NUM_ , NUM_ ) ) return moveList ; if ( x > NUM_ && addDirection ( moveList , pos , sq , NUM_ , - NUM_ ) ) return moveList ; if ( x > NUM_ && y > NUM_ && addDirection ( moveList , pos , sq , NUM_ , - NUM_ ) ) return moveList ; if ( y > NUM_ && addDirection ( moveList , pos , sq , NUM_ , - NUM_ ) ) return moveList ; if ( x < NUM_ && y > NUM_ && addDirection ( moveList , pos , sq , NUM_ , - NUM_ ) ) return moveList ; int k0 = wtm ? Position . getSquare ( NUM_ , NUM_ ) : Position . getSquare ( NUM_ , NUM_ ) ; if ( Position . getSquare ( x , y ) == k0 ) { int aCastle = wtm ? Position . A1_CASTLE : Position . A8_CASTLE ; int hCastle = wtm ? Position . H1_CASTLE : Position . H8_CASTLE ; int rook = wtm ? Piece . WROOK : Piece . BROOK ; if ( ( ( pos . getCastleMask ( ) & ( NUM_ << hCastle ) ) != NUM_ ) && ( pos . getPiece ( k0 + NUM_ ) == Piece . EMPTY ) && ( pos . getPiece ( k0 + NUM_ ) == Piece . EMPTY ) && ( pos . getPiece ( k0 + NUM_ ) == rook ) && ! sqAttacked ( pos , k0 ) && ! sqAttacked ( pos , k0 + NUM_ ) ) { moveList . add ( getMoveObj ( k0 , k0 + NUM_ , Piece . EMPTY ) ) ; } if ( ( ( pos . getCastleMask ( ) & ( NUM_ << aCastle ) ) != NUM_ ) && ( pos . getPiece ( k0 - NUM_ ) == Piece . EMPTY ) && ( pos . getPiece ( k0 - NUM_ ) == Piece . EMPTY ) && ( pos . getPiece ( k0 - NUM_ ) == Piece . EMPTY ) && ( pos . getPiece ( k0 - NUM_ ) == rook ) && ! sqAttacked ( pos , k0 ) && ! sqAttacked ( pos , k0 - NUM_ ) ) { moveList . add ( getMoveObj ( k0 , k0 - NUM_ , Piece . EMPTY ) ) ; } } } if ( ( p == Piece . WPAWN ) || ( p == Piece . BPAWN ) ) { int yDir = wtm ? NUM_ : - NUM_ ; if ( pos . getPiece ( sq + yDir ) == Piece . EMPTY ) { addPawnMoves ( moveList , sq , sq + yDir ) ; if ( ( y == ( wtm ? NUM_ : NUM_ ) ) && ( pos . getPiece ( sq + NUM_ . yDir ) == Piece . EMPTY ) ) { addPawnMoves ( moveList , sq , sq + yDir . NUM_ ) ; } } if ( x > NUM_ ) { int toSq = sq + yDir - NUM_ ; int cap = pos . getPiece ( toSq ) ; if ( cap != Piece . EMPTY ) { if ( Piece . isWhite ( cap ) != wtm ) { if ( cap == ( wtm ? Piece . BKING : Piece . WKING ) ) { returnMoveList ( moveList ) ; moveList = getMoveListObj ( ) ; moveList . add ( getMoveObj ( sq , toSq , Piece . EMPTY ) ) ; return moveList ; } else { addPawnMoves ( moveList , sq , toSq ) ; } } } else if ( toSq == pos . getEpSquare ( ) ) { addPawnMoves ( moveList , sq , toSq ) ; } } if ( x < NUM_ ) { int toSq = sq + yDir + NUM_ ; int cap = pos . getPiece ( toSq ) ; if ( cap != Piece . EMPTY ) { if ( Piece . isWhite ( cap ) != wtm ) { if ( cap == ( wtm ? Piece . BKING : Piece . WKING ) ) { returnMoveList ( moveList ) ; moveList = getMoveListObj ( ) ; moveList . add ( getMoveObj ( sq , toSq , Piece . EMPTY ) ) ; return moveList ; } else { addPawnMoves ( moveList , sq , toSq ) ; } } } else if ( toSq == pos . getEpSquare ( ) ) { addPawnMoves ( moveList , sq , toSq ) ; } } } } } return moveList ; }
public static int writeOggPageHeader ( byte [ ] buf , int offset , int headerType , long granulepos , int streamSerialNumber , int pageCount , int packetCount , byte [ ] packetSizes ) { writeString ( buf , offset , STR_ ) ; buf [ offset + NUM_ ] = NUM_ ; buf [ offset + NUM_ ] = ( byte ) headerType ; writeLong ( buf , offset + NUM_ , granulepos ) ; writeInt ( buf , offset + NUM_ , streamSerialNumber ) ; writeInt ( buf , offset + NUM_ , pageCount ) ; writeInt ( buf , offset + NUM_ , NUM_ ) ; buf [ offset + NUM_ ] = ( byte ) packetCount ; System . arraycopy ( packetSizes , NUM_ , buf , offset + NUM_ , packetCount ) ; return packetCount + NUM_ ; }
private void beforeKey ( ) throws JSONException { Scope context = peek ( ) ; if ( context == Scope . NONEMPTY_OBJECT ) { out . append ( STR_ ) ; } else if ( context != Scope . EMPTY_OBJECT ) { throw new JSONException ( STR_ ) ; } newline ( ) ; replaceTop ( Scope . DANGLING_KEY ) ; }
private byte [ ] createPreviewBuffer ( Size previewSize ) { int bitsPerPixel = ImageFormat . getBitsPerPixel ( ImageFormat . NV21 ) ; long sizeInBits = previewSize . getHeight ( ) . previewSize . getWidth ( ) . bitsPerPixel ; int bufferSize = ( int ) Math . ceil ( sizeInBits / NUM_ ) + NUM_ ; byte [ ] byteArray = new byte [ bufferSize ] ; ByteBuffer buffer = ByteBuffer . wrap ( byteArray ) ; if ( ! buffer . hasArray ( ) || ( buffer . array ( ) != byteArray ) ) { throw new IllegalStateException ( STR_ ) ; } mBytesToByteBuffer . put ( byteArray , buffer ) ; return byteArray ; }
private void handleStaticSiteRequest ( StaticSiteRequest . PointRequest request , TransportNetwork transportNetwork , TaskStatistics ts ) { StaticComputer computer = new StaticComputer ( request , transportNetwork , ts ) ; if ( request . request . bucket != null ) computer . run ( ) ; else { try { PipedInputStream pis = new PipedInputStream ( ) ; PipedOutputStream pos = new PipedOutputStream ( pis ) ; finishPriorityTask ( request , pis ) ; computer . write ( pos ) ; pos . close ( ) ; } catch ( IOException e ) { LOG . error ( STR_ , e ) ; } } deleteRequest ( request ) ; }
public synchronized void removeRoom ( String room ) { if ( ! Helper . validateStream ( room ) ) { return ; } room = room . toLowerCase ( ) ; if ( rooms . remove ( room ) ) { unsubRoom ( room ) ; removeEmotes ( room ) ; prevEmotesets . remove ( room ) ; } }
public static double discharge ( ItemStack itemStack , double amount ) { if ( itemStack != null ) { if ( itemStack . getItem ( ) instanceof IEnergizedItem ) { IEnergizedItem energizedItem = ( IEnergizedItem ) itemStack . getItem ( ) ; if ( energizedItem . canSend ( itemStack ) ) { double energyToUse = Math . min ( energizedItem . getMaxTransfer ( itemStack ) , Math . min ( energizedItem . getEnergy ( itemStack ) , amount ) ) ; energizedItem . setEnergy ( itemStack , energizedItem . getEnergy ( itemStack ) - energyToUse ) ; return energyToUse ; } } } return NUM_ ; }
public Object [ ] toArray ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = NUM_ ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }
public void addAll ( final Collection elements ) { adjusting = BOOL_ ; Set oldSelection = new HashSet ( selection ) ; boolean rv = selection . addAll ( elements ) ; adjusting = BOOL_ ; if ( rv ) { fireSelectionChanged ( oldSelection , selection ) ; } oldSelection = null ; }
public boolean hasFeature ( int feature ) { return ( ( feature >= MODE_FIRST && feature <= MODE_LAST ) || ( feature >= FEATURE_FIRST && feature <= FEATURE_LAST ) ) && ( feature == MODE_OFF || mCapabilities . get ( feature ) ) ; }
public Set < Integer > backupPartitions ( UUID nodeId ) { Set < Integer > set = backup . get ( nodeId ) ; return set == null ? Collections . < Integer > emptySet ( ) : set ; }
public java . lang . StringBuffer insert ( int offset , java . lang . String str ) { internal . insert ( offset , str ) ; return this ; }
public Loader load ( String imageUrl ) { ImageUrl = imageUrl ; return this ; }
private void generateLegalTimesTree ( ) { int k0 = KeyEvent . KEYCODE_0 ; int k1 = KeyEvent . KEYCODE_1 ; int k2 = KeyEvent . KEYCODE_2 ; int k3 = KeyEvent . KEYCODE_3 ; int k4 = KeyEvent . KEYCODE_4 ; int k5 = KeyEvent . KEYCODE_5 ; int k6 = KeyEvent . KEYCODE_6 ; int k7 = KeyEvent . KEYCODE_7 ; int k8 = KeyEvent . KEYCODE_8 ; int k9 = KeyEvent . KEYCODE_9 ; mLegalTimesTree = new Node ( ) ; if ( mIs24HourMode ) { Node minuteFirstDigit = new Node ( k0 , k1 , k2 , k3 , k4 , k5 ) ; Node minuteSecondDigit = new Node ( k0 , k1 , k2 , k3 , k4 , k5 , k6 , k7 , k8 , k9 ) ; minuteFirstDigit . addChild ( minuteSecondDigit ) ; Node firstDigit = new Node ( k0 , k1 ) ; mLegalTimesTree . addChild ( firstDigit ) ; Node secondDigit = new Node ( k0 , k1 , k2 , k3 , k4 , k5 ) ; firstDigit . addChild ( secondDigit ) ; secondDigit . addChild ( minuteFirstDigit ) ; Node thirdDigit = new Node ( k6 , k7 , k8 , k9 ) ; secondDigit . addChild ( thirdDigit ) ; secondDigit = new Node ( k6 , k7 , k8 , k9 ) ; firstDigit . addChild ( secondDigit ) ; secondDigit . addChild ( minuteFirstDigit ) ; firstDigit = new Node ( k2 ) ; mLegalTimesTree . addChild ( firstDigit ) ; secondDigit = new Node ( k0 , k1 , k2 , k3 ) ; firstDigit . addChild ( secondDigit ) ; secondDigit . addChild ( minuteFirstDigit ) ; secondDigit = new Node ( k4 , k5 ) ; firstDigit . addChild ( secondDigit ) ; secondDigit . addChild ( minuteSecondDigit ) ; firstDigit = new Node ( k3 , k4 , k5 , k6 , k7 , k8 , k9 ) ; mLegalTimesTree . addChild ( firstDigit ) ; firstDigit . addChild ( minuteFirstDigit ) ; } else { Node ampm = new Node ( getAmOrPmKeyCode ( AM ) , getAmOrPmKeyCode ( PM ) ) ; Node firstDigit = new Node ( k1 ) ; mLegalTimesTree . addChild ( firstDigit ) ; firstDigit . addChild ( ampm ) ; Node secondDigit = new Node ( k0 , k1 , k2 ) ; firstDigit . addChild ( secondDigit ) ; secondDigit . addChild ( ampm ) ; Node thirdDigit = new Node ( k0 , k1 , k2 , k3 , k4 , k5 ) ; secondDigit . addChild ( thirdDigit ) ; thirdDigit . addChild ( ampm ) ; Node fourthDigit = new Node ( k0 , k1 , k2 , k3 , k4 , k5 , k6 , k7 , k8 , k9 ) ; thirdDigit . addChild ( fourthDigit ) ; fourthDigit . addChild ( ampm ) ; thirdDigit = new Node ( k6 , k7 , k8 , k9 ) ; secondDigit . addChild ( thirdDigit ) ; thirdDigit . addChild ( ampm ) ; secondDigit = new Node ( k3 , k4 , k5 ) ; firstDigit . addChild ( secondDigit ) ; thirdDigit = new Node ( k0 , k1 , k2 , k3 , k4 , k5 , k6 , k7 , k8 , k9 ) ; secondDigit . addChild ( thirdDigit ) ; thirdDigit . addChild ( ampm ) ; firstDigit = new Node ( k2 , k3 , k4 , k5 , k6 , k7 , k8 , k9 ) ; mLegalTimesTree . addChild ( firstDigit ) ; firstDigit . addChild ( ampm ) ; secondDigit = new Node ( k0 , k1 , k2 , k3 , k4 , k5 ) ; firstDigit . addChild ( secondDigit ) ; thirdDigit = new Node ( k0 , k1 , k2 , k3 , k4 , k5 , k6 , k7 , k8 , k9 ) ; secondDigit . addChild ( thirdDigit ) ; thirdDigit . addChild ( ampm ) ; } }
private void buildPTR ( ) { double [ ] temp_row ; double [ ] [ ] PTRA ; int k ; PivotTransform pt ; PTR = Matrix . identity ( n , n ) ; PTRA = PTR . getArray ( ) ; k = pivotTransformQueue . size ( ) ; while ( k -- > NUM_ ) { pt = pivotTransformQueue . removeLast ( ) ; temp_row = PTRA [ pt . pos1 ] ; PTRA [ pt . pos1 ] = PTRA [ pt . pos2 ] ; PTRA [ pt . pos2 ] = temp_row ; } }
private static String byteToHex ( byte [ ] digest ) { StringBuilder builder = new StringBuilder ( ) ; for ( byte b : digest ) { String hex = Integer . toHexString ( xff & b ) ; if ( hex . length ( ) == NUM_ ) { builder . append ( STR_ ) ; } builder . append ( hex ) ; } return builder . toString ( ) ; }
public String replace ( char oldChar , char newChar ) { char [ ] buffer = value ; int _offset = offset ; int _count = count ; int idx = _offset ; int last = _offset + _count ; boolean copied = BOOL_ ; while ( idx < last ) { if ( buffer [ idx ] == oldChar ) { if ( ! copied ) { char [ ] newBuffer = new char [ _count ] ; System . arraycopy ( buffer , _offset , newBuffer , NUM_ , _count ) ; buffer = newBuffer ; idx -= _offset ; last -= _offset ; copied = BOOL_ ; } buffer [ idx ] = newChar ; } idx ++ ; } return copied ? new String ( NUM_ , count , buffer ) : this ; }
public Bidi createLineBidi ( int lineStart , int lineLimit ) { AttributedString astr = new AttributedString ( STR_ ) ; Bidi newBidi = new Bidi ( astr . getIterator ( ) ) ; return bidiBase . setLine ( this , bidiBase , newBidi , newBidi . bidiBase , lineStart , lineLimit ) ; }
public boolean isCallerValidForPackage ( Context context , int authRequirements , String packageToMatch ) { assert ! TextUtils . isEmpty ( packageToMatch ) ; return isCallerValid ( context , authRequirements , packageToMatch ) ; }
public void paintInternalFrameTitlePaneBackground ( SynthContext context , Graphics g , int x , int y , int w , int h ) { paintBackground ( context , g , x , y , w , h , null ) ; }
public synchronized void addGraphListener ( GraphListener cl ) { m_graphListeners . addElement ( cl ) ; }
public void restartAndInstallIfNecessary ( ) { File patchesDir = new File ( mySdkHandler . getLocation ( ) , PatchInstallerUtil . PATCHES_DIR_NAME ) ; StudioLoggerProgressIndicator progress = new StudioLoggerProgressIndicator ( PatchInstallerFactory . class ) ; if ( patchesDir . exists ( ) ) { File [ ] subDirs = patchesDir . listFiles ( null ) ; for ( File patchDir : subDirs ) { processPatch ( mySdkHandler . getLocation ( ) , progress , patchDir ) ; } } }
public static double [ ] [ ] align ( int [ ] real , double [ ] pred ) { int missing = numberOfMissingLabels ( real ) ; double [ ] _real = new double [ real . length - missing ] ; double [ ] _pred = new double [ real . length - missing ] ; int offset = NUM_ ; for ( int i = NUM_ ; i < real . length ; i ++ ) { if ( real [ i ] == - NUM_ || pred [ i ] == - NUM_ || Double . isNaN ( pred [ i ] ) ) { offset ++ ; continue ; } _real [ i - offset ] = real [ i ] ; _pred [ i - offset ] = pred [ i ] ; } double [ ] [ ] res = new double [ NUM_ ] [ NUM_ ] ; res [ NUM_ ] = _real ; res [ NUM_ ] = _pred ; return res ; }
public static boolean isCategory ( int M_Product_Category_ID , int M_Product_ID ) { if ( M_Product_ID == NUM_ || M_Product_Category_ID == NUM_ ) return BOOL_ ; Integer product = new Integer ( M_Product_ID ) ; Integer category = ( Integer ) s_products . get ( product ) ; if ( category != null ) return category . intValue ( ) == M_Product_Category_ID ; String sql = STR_ ; PreparedStatement pstmt = null ; try { pstmt = DB . prepareStatement ( sql , null ) ; pstmt . setInt ( NUM_ , M_Product_ID ) ; ResultSet rs = pstmt . executeQuery ( ) ; if ( rs . next ( ) ) category = new Integer ( rs . getInt ( NUM_ ) ) ; rs . close ( ) ; pstmt . close ( ) ; pstmt = null ; } catch ( Exception e ) { s_log . log ( Level . SEVERE , sql , e ) ; } try { if ( pstmt != null ) pstmt . close ( ) ; pstmt = null ; } catch ( Exception e ) { pstmt = null ; } if ( category != null ) { s_products . put ( product , category ) ; s_log . fine ( STR_ + M_Product_ID + STR_ + category + STR_ + M_Product_Category_ID + STR_ + ( category . intValue ( ) == M_Product_Category_ID ) ) ; return category . intValue ( ) == M_Product_Category_ID ; } s_log . log ( Level . SEVERE , STR_ + M_Product_ID ) ; return BOOL_ ; }
public AllStatsTableMulti ( DatasetGenerator datasetGenerator , Locker locker ) { ArgumentChecking . notNull ( datasetGenerator , STR_ ) ; initComponents ( ) ; table . setDefaultRenderer ( JLabel . class , new Renderer ( ) ) ; table . setColumnSelectionAllowed ( BOOL_ ) ; table . setRowSelectionAllowed ( BOOL_ ) ; table . setGridColor ( GRID_COLOR ) ; JTableHeader header = table . getTableHeader ( ) ; header . setReorderingAllowed ( BOOL_ ) ; GUIUtilities . setTableHeader ( header ) ; model = new Model ( datasetGenerator ) ; table . setModel ( model ) ; this . locker = locker ; }
private void fitImageToView ( ) { Drawable drawable = getDrawable ( ) ; if ( drawable == null || drawable . getIntrinsicWidth ( ) == NUM_ || drawable . getIntrinsicHeight ( ) == NUM_ ) { return ; } if ( matrix == null || prevMatrix == null ) { return ; } int drawableWidth = drawable . getIntrinsicWidth ( ) ; int drawableHeight = drawable . getIntrinsicHeight ( ) ; float scaleX = ( float ) viewWidth / drawableWidth ; float scaleY = ( float ) viewHeight / drawableHeight ; switch ( mScaleType ) { case CENTER : scaleX = scaleY = NUM_ ; break ; case CENTER_CROP : scaleX = scaleY = Math . max ( scaleX , scaleY ) ; break ; case CENTER_INSIDE : scaleX = scaleY = Math . min ( NUM_ , Math . min ( scaleX , scaleY ) ) ; case FIT_CENTER : scaleX = scaleY = Math . min ( scaleX , scaleY ) ; break ; case FIT_XY : break ; default : throw new UnsupportedOperationException ( STR_ ) ; } float redundantXSpace = viewWidth - ( scaleX . drawableWidth ) ; float redundantYSpace = viewHeight - ( scaleY . drawableHeight ) ; matchViewWidth = viewWidth - redundantXSpace ; matchViewHeight = viewHeight - redundantYSpace ; if ( ! isZoomed ( ) && ! imageRenderedAtLeastOnce ) { matrix . setScale ( scaleX , scaleY ) ; matrix . postTranslate ( redundantXSpace / NUM_ , redundantYSpace / NUM_ ) ; normalizedScale = NUM_ ; } else { if ( prevMatchViewWidth == NUM_ || prevMatchViewHeight == NUM_ ) { savePreviousImageValues ( ) ; } prevMatrix . getValues ( m ) ; m [ Matrix . MSCALE_X ] = matchViewWidth / drawableWidth . normalizedScale ; m [ Matrix . MSCALE_Y ] = matchViewHeight / drawableHeight . normalizedScale ; float transX = m [ Matrix . MTRANS_X ] ; float transY = m [ Matrix . MTRANS_Y ] ; float prevActualWidth = prevMatchViewWidth . normalizedScale ; float actualWidth = getImageWidth ( ) ; translateMatrixAfterRotate ( Matrix . MTRANS_X , transX , prevActualWidth , actualWidth , prevViewWidth , viewWidth , drawableWidth ) ; float prevActualHeight = prevMatchViewHeight . normalizedScale ; float actualHeight = getImageHeight ( ) ; translateMatrixAfterRotate ( Matrix . MTRANS_Y , transY , prevActualHeight , actualHeight , prevViewHeight , viewHeight , drawableHeight ) ; matrix . setValues ( m ) ; } fixTrans ( ) ; setImageMatrix ( matrix ) ; }
public void append ( File file , FTPDataTransferListener listener ) throws IllegalStateException , FileNotFoundException , IOException , FTPIllegalReplyException , FTPException , FTPDataTransferException , FTPAbortedException { if ( ! file . exists ( ) ) { throw new FileNotFoundException ( file . getAbsolutePath ( ) ) ; } InputStream inputStream = null ; try { inputStream = new FileInputStream ( file ) ; } catch ( IOException e ) { throw new FTPDataTransferException ( e ) ; } try { append ( file . getName ( ) , inputStream , NUM_ , listener ) ; } catch ( IllegalStateException e ) { throw e ; } catch ( IOException e ) { throw e ; } catch ( FTPIllegalReplyException e ) { throw e ; } catch ( FTPException e ) { throw e ; } catch ( FTPDataTransferException e ) { throw e ; } catch ( FTPAbortedException e ) { throw e ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public List < String > provideWhiteList ( ) { LinkedList < String > whiteList = new LinkedList < > ( ) ; whiteList . add ( STR_ ) ; return whiteList ; }
public static boolean isScopedName ( String name ) { return name . indexOf ( STR_ ) != - NUM_ ; }
public Input ( IoBuffer buf ) { super ( buf ) ; amf3_mode = NUM_ ; stringReferences = new ArrayList < String > ( ) ; classReferences = new ArrayList < ClassReference > ( ) ; }
public static Properties loadConfigFile ( String path ) { Properties property = null ; File file = new File ( path ) ; if ( file . exists ( ) && file . canRead ( ) ) { try { property = new Properties ( ) ; property . load ( new FileReader ( file . getAbsolutePath ( ) ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return property ; }
protected void illegalMessageReceived ( OFMessage m ) { String msg = getSwitchStateMessage ( m , STR_ ) ; throw new SwitchStateException ( msg ) ; }
protected void sprint ( boolean booleanField ) { sprint ( String . valueOf ( booleanField ) ) ; }
protected static void toEPLViews ( StringWriter writer , List < View > views ) { if ( ( views != null ) && ( views . size ( ) != NUM_ ) ) { writer . write ( STR_ ) ; String delimiter = STR_ ; for ( View view : views ) { writer . write ( delimiter ) ; view . toEPL ( writer ) ; delimiter = STR_ ; } } }
protected void removeDatabaseListeners ( ) { databaseListeners . clear ( ) ; }
private AudioMapType loadAudioMapXml ( File audioMapFile ) throws XmlParsingException , FileNotFoundException { if ( ! audioMapFile . isFile ( ) ) { throw new FileNotFoundException ( String . format ( STR_ , audioMapFile . getAbsolutePath ( ) ) ) ; } return XmlParser . parse ( audioMapFile , new String [ ] { AUDIOMAP_XML_SCHEME } , AUDIOMAP_PACKAGE , AudioMapType . class ) ; }
public void addGenericAttr ( GenericAttr g ) { generic . addElement ( g ) ; }
private List < FahrzeitEvent > addFahrtInfoToFahrzeitEvents ( List < FahrtEvent > fahrtEvents , List < FahrzeitEvent > fahrzeitEvents , boolean keepFahrzeitEventsWithoutFahrtEvent ) { List < FahrzeitEvent > fahrzeitEventsOut = new LinkedList < FahrzeitEvent > ( ) ; Map < String , FahrtEvent > rblDateKursDateTimeIst2FahrtEventMap = new HashMap < String , FahrtEvent > ( ) ; Set < String > searchStrings = new TreeSet < String > ( ) ; for ( FahrtEvent fahrtEvent : fahrtEvents ) { String searchId = String . valueOf ( fahrtEvent . getRblDate ( ) ) + String . valueOf ( fahrtEvent . getKurs ( ) ) + fahrtEvent . getDepartureDateIst ( ) + fahrtEvent . getDepartureTimeIst ( ) ; if ( searchStrings . contains ( searchId ) ) { log . warn ( STR_ + searchId ) ; } else { searchStrings . add ( searchId ) ; rblDateKursDateTimeIst2FahrtEventMap . put ( searchId , fahrtEvent ) ; } } int numberOfMissingFahrtEvents = NUM_ ; for ( FahrzeitEvent fahrzeitEvent : fahrzeitEvents ) { String searchId = String . valueOf ( fahrzeitEvent . getRblDate ( ) ) + String . valueOf ( fahrzeitEvent . getKurs ( ) ) + fahrzeitEvent . getDepartureDateIst ( ) + fahrzeitEvent . getDepartureTimeIst ( ) ; FahrtEvent fahrtEvent = rblDateKursDateTimeIst2FahrtEventMap . get ( searchId ) ; if ( fahrtEvent == null ) { numberOfMissingFahrtEvents ++ ; if ( keepFahrzeitEventsWithoutFahrtEvent ) { fahrzeitEventsOut . add ( fahrzeitEvent ) ; } } else { fahrzeitEvent . add ( fahrtEvent ) ; fahrzeitEventsOut . add ( fahrzeitEvent ) ; } } log . info ( numberOfMissingFahrtEvents + STR_ ) ; log . info ( STR_ + fahrzeitEventsOut . size ( ) + STR_ ) ; return fahrzeitEventsOut ; }
private static Object newInstanceNoServiceLoader ( Class < ? > providerClass ) { if ( System . getSecurityManager ( ) == null ) { return null ; } try { Method creationMethod = providerClass . getDeclaredMethod ( STR_ ) ; return creationMethod . invoke ( null , ( Object [ ] ) null ) ; } catch ( NoSuchMethodException exc ) { return null ; } catch ( Exception exc ) { return null ; } }
private void checkUUID ( String uuid , int code ) { checkHash ( UUID . fromString ( uuid ) , code ) ; }
@ Override protected void prepareWrite ( WritableByteChannel channel ) throws Exception { os = Channels . newOutputStream ( channel ) ; }
public void run ( ) { try { boolean cleanRemoteSessions = BOOL_ ; synchronized ( this ) { Collection < StateInfo > infos = new ArrayList < > ( ) ; infos . addAll ( servers . values ( ) ) ; infos . addAll ( sites . values ( ) ) ; for ( StateInfo info : infos ) { info . isUp = checkServerUp ( info ) ; if ( ! info . isUp ) { down . add ( info . id ) ; } else { if ( ! down . isEmpty ( ) && down . remove ( info . id ) ) { cleanRemoteSessions = BOOL_ ; } } } } if ( cleanRemoteSessions ) { foreignSessionHandler . cleanUpRemoteSessions ( ) ; } } catch ( Exception ex ) { sessionDebug . error ( STR_ + ex . getMessage ( ) , ex ) ; } }
private void writeObject ( java . io . ObjectOutputStream p_stream ) throws java . io . IOException { p_stream . defaultWriteObject ( ) ; p_stream . writeInt ( trace_angle_restriction . get_no ( ) ) ; }
@ SuppressWarnings ( STR_ ) public LiteralExtensionIV createIV ( final Value value ) { if ( value instanceof Literal == BOOL_ ) throw new IllegalArgumentException ( ) ; final Literal lit = ( Literal ) value ; final AbstractLiteralIV delegate = new PackedLongIV ( Long . parseLong ( lit . getLabel ( ) ) ) ; return new LiteralExtensionIV ( delegate , datatype . getIV ( ) ) ; }
public Builder addHeader ( String name , String value ) { headers . add ( new Header ( name , value ) ) ; return this ; }
public void add ( LeafAtom atom ) { leafChildren . add ( atom ) ; }
private boolean journalRebuildRequired ( ) { final int redundantOpCompactThreshold = NUM_ ; return redundantOpCount >= redundantOpCompactThreshold && redundantOpCount >= lruEntries . size ( ) ; }
public void removeResult ( String name ) { StringBuffer buff = m_Results . get ( name ) ; if ( buff != null ) { m_Results . remove ( name ) ; m_Model . removeElement ( name ) ; m_Objs . remove ( name ) ; System . gc ( ) ; } }
private void addEntry ( ) { filterModel . addNewEntry ( ) ; extentModel . populate ( null ) ; removeFTCButton . setEnabled ( BOOL_ ) ; addExtentButton . setEnabled ( BOOL_ ) ; removeExtentButton . setEnabled ( BOOL_ ) ; }
public void testCase22 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ } ; int aSign = NUM_ ; int bSign = - NUM_ ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; try { aNumber . mod ( bNumber ) ; fail ( STR_ ) ; } catch ( ArithmeticException e ) { } }
public DExportPrivateKeyOpenSsl ( JFrame parent , String entryAlias , PasswordQualityConfig passwordQualityConfig ) { super ( parent , Dialog . ModalityType . DOCUMENT_MODAL ) ; this . entryAlias = entryAlias ; this . passwordQualityConfig = passwordQualityConfig ; initComponents ( ) ; }
public BigDecimal sum ( String sqlExpression ) { return aggregate ( sqlExpression , AGGREGATE_SUM ) ; }
private void smoothSnapToPosition ( int scrollY , int availableScrollHeight , AlphabeticalAppsList . FastScrollSectionInfo info ) { mRv . removeCallbacks ( mSmoothSnapNextFrameRunnable ) ; mRv . removeCallbacks ( mFastScrollToTargetSectionRunnable ) ; trackAllChildViews ( ) ; if ( mHasFastScrollTouchSettled ) { mCurrentFastScrollSection = info . sectionName ; mTargetFastScrollSection = null ; updateTrackedViewsFastScrollFocusState ( ) ; } else { mCurrentFastScrollSection = null ; mTargetFastScrollSection = info . sectionName ; mHasFastScrollTouchSettled = BOOL_ ; updateTrackedViewsFastScrollFocusState ( ) ; mRv . postDelayed ( mFastScrollToTargetSectionRunnable , mHasFastScrollTouchSettledAtLeastOnce ? REPEAT_TOUCH_SETTLING_DURATION : INITIAL_TOUCH_SETTLING_DURATION ) ; } int newScrollY = Math . min ( availableScrollHeight , mRv . getPaddingTop ( ) + mRv . getTop ( info . fastScrollToItem . rowIndex ) ) ; int numFrames = mFastScrollFrames . length ; for ( int i = NUM_ ; i < numFrames ; i ++ ) { mFastScrollFrames [ i ] = ( newScrollY - scrollY ) / numFrames ; } mFastScrollFrameIndex = NUM_ ; mRv . postOnAnimation ( mSmoothSnapNextFrameRunnable ) ; }
@ Override public int calculateOffsetX ( ) { return ( int ) ( Math . cos ( this . angle ) . this . distance ) - this . shadowSize ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
protected void onFinish ( ) { mErrorListener = null ; }
private < T > void runTestWrite ( XmlWriter < T > writer , List < T > bundle , List < String > expected ) throws Exception { File tmpFile = tmpFolder . newFile ( STR_ ) ; try ( FileOutputStream fileOutputStream = new FileOutputStream ( tmpFile ) ) { writeBundle ( writer , bundle , fileOutputStream . getChannel ( ) ) ; } List < String > lines = new ArrayList < > ( ) ; try ( BufferedReader reader = new BufferedReader ( new FileReader ( tmpFile ) ) ) { for ( ; ; ) { String line = reader . readLine ( ) ; if ( line == null ) { break ; } line = line . trim ( ) ; if ( line . length ( ) > NUM_ ) { lines . add ( line ) ; } } assertEquals ( expected , lines ) ; } }
public String addDays ( Object odays , String format ) { int days = FunctionHandler . getInt ( odays ) ; Calendar now = Calendar . getInstance ( ) ; now . add ( Calendar . DAY_OF_YEAR , days ) ; DateFormat formatter = getFormatter ( format ) ; return formatter . format ( now . getTime ( ) ) ; }
private static File createTempFile ( Context context , @ Nullable String mimeType ) throws IOException { File externalCacheDir = context . getExternalCacheDir ( ) ; File internalCacheDir = context . getCacheDir ( ) ; File cacheDir ; if ( externalCacheDir == null && internalCacheDir == null ) { throw new IOException ( STR_ ) ; } if ( externalCacheDir == null ) { cacheDir = internalCacheDir ; } else if ( internalCacheDir == null ) { cacheDir = externalCacheDir ; } else { cacheDir = externalCacheDir . getFreeSpace ( ) > internalCacheDir . getFreeSpace ( ) ? externalCacheDir : internalCacheDir ; } return File . createTempFile ( TEMP_FILE_PREFIX , getFileExtensionForType ( mimeType ) , cacheDir ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( NUM_ ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return newVector . elements ( ) ; }
public boolean removeEntry ( int xIndex , int dataSetIndex ) { if ( dataSetIndex >= mDataSets . size ( ) ) return BOOL_ ; T dataSet = mDataSets . get ( dataSetIndex ) ; Entry e = dataSet . getEntryForXIndex ( xIndex ) ; return removeEntry ( e , dataSetIndex ) ; }
private void runReadTest ( byte [ ] input , CompressionMode mode ) throws IOException { runReadTest ( input , mode , mode ) ; }
public static void close ( @ Nullable Context rsrc , @ Nullable IgniteLogger log ) { if ( rsrc != null ) try { rsrc . close ( ) ; } catch ( NamingException e ) { warn ( log , STR_ + e . getMessage ( ) ) ; } }
void removeEQ ( Object o ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { Object [ ] array = queue ; for ( int i = NUM_ , n = size ; i < n ; i ++ ) { if ( o == array [ i ] ) { removeAt ( i ) ; break ; } } } finally { lock . unlock ( ) ; } }
public WritableRaster createCompatibleWritableRaster ( int w , int h ) { if ( w <= NUM_ || h <= NUM_ ) { throw new RasterFormatException ( STR_ + ( ( w <= NUM_ ) ? STR_ : STR_ ) ) ; } SampleModel sm = sampleModel . createCompatibleSampleModel ( w , h ) ; return new IntegerInterleavedRaster ( sm , new Point ( NUM_ , NUM_ ) ) ; }
private void updateBaseMatrix ( Drawable d ) { ImageView imageView = getImageView ( ) ; if ( null == imageView || null == d ) { return ; } final float viewWidth = getImageViewWidth ( imageView ) ; final float viewHeight = getImageViewHeight ( imageView ) ; final int drawableWidth = d . getIntrinsicWidth ( ) ; final int drawableHeight = d . getIntrinsicHeight ( ) ; mBaseMatrix . reset ( ) ; final float widthScale = viewWidth / drawableWidth ; final float heightScale = viewHeight / drawableHeight ; if ( mScaleType == ScaleType . CENTER ) { mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth ) / NUM_ , ( viewHeight - drawableHeight ) / NUM_ ) ; } else if ( mScaleType == ScaleType . CENTER_CROP ) { float scale = Math . max ( widthScale , heightScale ) ; mBaseMatrix . postScale ( scale , scale ) ; mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth . scale ) / NUM_ , ( viewHeight - drawableHeight . scale ) / NUM_ ) ; } else if ( mScaleType == ScaleType . CENTER_INSIDE ) { float scale = Math . min ( NUM_ , Math . min ( widthScale , heightScale ) ) ; mBaseMatrix . postScale ( scale , scale ) ; mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth . scale ) / NUM_ , ( viewHeight - drawableHeight . scale ) / NUM_ ) ; } else { RectF mTempSrc = new RectF ( NUM_ , NUM_ , drawableWidth , drawableHeight ) ; RectF mTempDst = new RectF ( NUM_ , NUM_ , viewWidth , viewHeight ) ; switch ( mScaleType ) { case FIT_CENTER : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . CENTER ) ; break ; case FIT_START : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . START ) ; break ; case FIT_END : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . END ) ; break ; case FIT_XY : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . FILL ) ; break ; default : break ; } } resetMatrix ( ) ; }
public static String [ ] schedulerCommandArgs ( Config config , Config runtime , List < Integer > freePorts ) { if ( freePorts . size ( ) < PORTS_REQUIRED_FOR_SCHEDULER ) { throw new RuntimeException ( STR_ ) ; } for ( int port : freePorts ) { if ( port == - NUM_ ) { throw new RuntimeException ( STR_ ) ; } } int httpPort = freePorts . get ( NUM_ ) ; List < String > commands = new ArrayList < > ( ) ; commands . add ( STR_ ) ; commands . add ( Context . cluster ( config ) ) ; commands . add ( STR_ ) ; commands . add ( Context . role ( config ) ) ; commands . add ( STR_ ) ; commands . add ( Context . environ ( config ) ) ; commands . add ( STR_ ) ; commands . add ( Context . topologyName ( config ) ) ; commands . add ( STR_ ) ; commands . add ( Context . topologyBinaryFile ( config ) ) ; commands . add ( STR_ ) ; commands . add ( Integer . toString ( httpPort ) ) ; return commands . toArray ( new String [ NUM_ ] ) ; }
public DocumentAnalysisRequest addDocument ( SolrInputDocument doc ) { documents . add ( doc ) ; return this ; }
public final Key doPhase ( Key key , boolean lastPhase ) throws InvalidKeyException , IllegalStateException { chooseFirstProvider ( ) ; return spi . engineDoPhase ( key , lastPhase ) ; }
@ Override public final void addBezierCurveY ( final float x , final float y , final float x3 , final float y3 ) { elements . add ( new QuadCurveTo ( x , y , x3 , y3 ) ) ; currentPos [ NUM_ ] = x3 ; currentPos [ NUM_ ] = y3 ; }
public void readBucketsFromPrefs ( ) { SharedPreferences prefs = mContext . getSharedPreferences ( SHARED_PREFS , NUM_ ) ; Set < String > buckets = prefs . getStringSet ( PREF_BUCKETS_IDS , new TreeSet < String > ( ) ) ; mBuckets . clear ( ) ; for ( String bucketId : buckets ) { AutoMixBucket bucket = restoreBucketFromId ( bucketId ) ; mBuckets . add ( bucket ) ; } }
protected int nextChar ( ) throws IOException { fReadFromBuffer = ( fBuffer . length ( ) > NUM_ ) ; if ( fReadFromBuffer ) { char ch = fBuffer . charAt ( fIndex ++ ) ; if ( fIndex >= fBuffer . length ( ) ) { fBuffer . setLength ( NUM_ ) ; fIndex = NUM_ ; } return ch ; } int ch = fCharAfterWhiteSpace ; if ( ch == - NUM_ ) { ch = fReader . read ( ) ; } if ( fSkipWhiteSpace && Character . isWhitespace ( ( char ) ch ) ) { do { ch = fReader . read ( ) ; } while ( Character . isWhitespace ( ( char ) ch ) ) ; if ( ch != - NUM_ ) { fCharAfterWhiteSpace = ch ; return STR_ ; } } else { fCharAfterWhiteSpace = - NUM_ ; } return ch ; }
@ Override public void acceptAppOffer ( Offer offer ) { int index = getIndex ( offer , appOffers ) ; if ( index != - NUM_ ) { appOffers . remove ( index ) ; appOfferStream . onNext ( offer ) ; } index = getIndex ( offer , acceptedOffers ) ; if ( index == - NUM_ ) { acceptedOffers . add ( offer ) ; } }
public boolean verify ( PublicKey key , String sigProvider ) throws NoSuchAlgorithmException , NoSuchProviderException , CMSException { return verify ( key , CMSUtils . getProvider ( sigProvider ) ) ; }
private void injectDependencies ( ) { EasyMVPApplication easyMVPApplication = ( EasyMVPApplication ) getApplication ( ) ; List < Object > activityScopeModules = ( getModules ( ) != null ) ? getModules ( ) : new ArrayList < > ( ) ; activityScopeModules . add ( new ActivityModule ( this ) ) ; activityScopeGraph = easyMVPApplication . buildGraphWithAditionalModules ( activityScopeModules ) ; inject ( this ) ; }
public void writeRequest ( ) { Object lock = new Object ( ) ; synchronized ( lock ) { synchronized ( this ) { boolean goAheadWithWrite = writerLocks . size ( ) == NUM_ && currentReaders == NUM_ && currentWriters == NUM_ ; if ( goAheadWithWrite ) { ++ currentWriters ; return ; } writerLocks . addLast ( lock ) ; } try { lock . wait ( ) ; } catch ( InterruptedException e ) { } } }
public long readLocalDate ( ) throws IOException { expectStartTag ( STR_ ) ; if ( localCalendar == null ) localCalendar = Calendar . getInstance ( ) ; long value = parseDate ( localCalendar ) ; expectEndTag ( STR_ ) ; return value ; }
public void removeSelectionListener ( final SelectionListener listener ) { checkWidget ( ) ; listeners . remove ( listener ) ; }
private void writeHex ( int i ) throws IOException { int cursor = NUM_ ; do { hex [ -- cursor ] = HEX_DIGITS [ i & xf ] ; } while ( ( i >>>= NUM_ ) != NUM_ ) ; socketOut . write ( hex , cursor , hex . length - cursor ) ; }
private synchronized String readInputStream ( InputStreamReader inputStreamReader ) throws IOException , BadLocationException { BufferedReader bufferedReader = null ; try { bufferedReader = new BufferedReader ( inputStreamReader ) ; String newLine = STR_ ; StringBuffer sb = new StringBuffer ( ) ; String line ; while ( ( line = bufferedReader . readLine ( ) ) != null ) { sb . append ( line + newLine ) ; } return sb . toString ( ) ; } finally { if ( null != bufferedReader ) bufferedReader . close ( ) ; if ( null != inputStreamReader ) inputStreamReader . close ( ) ; } }
private List < Map < String , Object > > typeParameters ( List < TypeParameter > tpl , Declaration from ) { if ( tpl != null && ! tpl . isEmpty ( ) ) { List < Map < String , Object > > l = new ArrayList < > ( tpl . size ( ) ) ; for ( TypeParameter tp : tpl ) { l . add ( typeParameterMap ( tp , from ) ) ; } return l ; } return null ; }
long freeSpaceUnix ( String path , boolean kb , boolean posix , long timeout ) throws IOException { if ( path . length ( ) == NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } String flags = STR_ ; if ( kb ) { flags += STR_ ; } if ( posix ) { flags += STR_ ; } String [ ] cmdAttribs = flags . length ( ) > NUM_ ? new String [ ] { DF , flags , path } : new String [ ] { DF , path } ; List < String > lines = performCommand ( cmdAttribs , NUM_ , timeout ) ; if ( lines . size ( ) < NUM_ ) { throw new IOException ( STR_ + DF + STR_ + STR_ + path + STR_ + lines ) ; } String line2 = lines . get ( NUM_ ) ; StringTokenizer tok = new StringTokenizer ( line2 , STR_ ) ; if ( tok . countTokens ( ) < NUM_ ) { if ( tok . countTokens ( ) == NUM_ && lines . size ( ) >= NUM_ ) { String line3 = lines . get ( NUM_ ) ; tok = new StringTokenizer ( line3 , STR_ ) ; } else { throw new IOException ( STR_ + DF + STR_ + STR_ + path + STR_ ) ; } } else { tok . nextToken ( ) ; } tok . nextToken ( ) ; tok . nextToken ( ) ; String freeSpace = tok . nextToken ( ) ; return parseBytes ( freeSpace , path ) ; }
public static void readAndCloseStream ( InputStream is ) { final byte [ ] bytes = new byte [ DEFAULT_BUFFER_SIZE ] ; try { while ( is . read ( bytes , NUM_ , DEFAULT_BUFFER_SIZE ) != - NUM_ ) ; } catch ( IOException ignored ) { } finally { closeSilently ( is ) ; } }
private static boolean withinTwo ( INode n , INode goal ) { DoubleLinkedList < IMove > moves = n . validMoves ( ) ; for ( Iterator < IMove > it = moves . iterator ( ) ; it . hasNext ( ) ; ) { IMove move = it . next ( ) ; INode successor = n . copy ( ) ; move . execute ( successor ) ; if ( withinOne ( successor , goal ) ) { return BOOL_ ; } } return BOOL_ ; }
public PennTreebankReader ( String treebankHome , String [ ] sections , String parseViewName ) throws Exception { super ( CorpusReaderConfigurator . buildResourceManager ( PENN_TREEBANK_WSJ , treebankHome ) ) ; this . parseViewName = parseViewName ; combinedWSJHome = treebankHome ; if ( sections == null ) this . sections = IOUtils . lsDirectories ( combinedWSJHome ) ; else { this . sections = new String [ sections . length ] ; System . arraycopy ( sections , NUM_ , this . sections , NUM_ , sections . length ) ; } updateCurrentFiles ( ) ; }
@ Override public void unwrapSSLv2 ( byte [ ] bytes ) { unexpectedMessage ( ) ; }
@ Override public void closeWrite ( ) throws IOException { if ( _isCloseWrite ) { return ; } _isCloseWrite = BOOL_ ; OutputStream os = _os ; _os = null ; boolean isShutdownOutput = BOOL_ ; if ( _s instanceof SSLSocket ) { log . finer ( L . l ( STR_ ) ) ; return ; } else if ( _s != null ) { try { _s . shutdownOutput ( ) ; isShutdownOutput = BOOL_ ; } catch ( UnsupportedOperationException e ) { log . log ( Level . FINEST , e . toString ( ) , e ) ; } catch ( Exception e ) { log . finer ( e . toString ( ) ) ; log . log ( Level . FINEST , e . toString ( ) , e ) ; } } if ( ! isShutdownOutput && os != null ) { os . close ( ) ; } }
protected void applyRowChangeData ( RowChangeData data , List < ReplOption > options , String sourceDbmsType ) throws ReplicatorException { if ( options != null ) { try { if ( applySessionVariables ( null , options ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STR_ ) ; } executePendingBatch ( ) ; statement . executeBatch ( ) ; statement . clearBatch ( ) ; } } catch ( SQLException e ) { throw new ApplierException ( STR_ , e ) ; } } List < ReplOption > rowOptions = data . getOptions ( ) ; if ( rowOptions != null ) { try { if ( applySessionVariables ( null , rowOptions ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STR_ ) ; } executePendingBatch ( ) ; statement . executeBatch ( ) ; statement . clearBatch ( ) ; } } catch ( SQLException e ) { throw new ApplierException ( STR_ , e ) ; } } for ( OneRowChange row : data . getRowChanges ( ) ) { applyOneRowChangePrepared ( row , sourceDbmsType ) ; } }
public boolean writeHeader ( OutputStream os ) { try { writeInt ( os , CACHE_MAGIC ) ; writeString ( os , key ) ; writeString ( os , etag == null ? STR_ : etag ) ; writeLong ( os , serverDate ) ; writeLong ( os , lastModified ) ; writeLong ( os , ttl ) ; writeLong ( os , softTtl ) ; writeStringStringMap ( responseHeaders , os ) ; os . flush ( ) ; return BOOL_ ; } catch ( IOException e ) { VolleyLog . d ( STR_ , e . toString ( ) ) ; return BOOL_ ; } }
public NamedList normalize ( NamedList input ) { input . remove ( STR_ ) ; for ( int i = NUM_ ; i < input . size ( ) ; i ++ ) { Object v = input . getVal ( i ) ; if ( v instanceof NamedList ) { input . setVal ( i , normalize ( ( NamedList ) v ) ) ; } } return input ; }
public boolean isInfinite ( ) { return isInfinite ( value ) ; }
String inprogressZNodeName ( long ledgerId , long firstTxId , long logSegmentSeqNo ) { if ( DistributedLogConstants . LOGSEGMENT_NAME_VERSION == conf . getLogSegmentNameVersion ( ) ) { return String . format ( STR_ , DistributedLogConstants . INPROGRESS_LOGSEGMENT_PREFIX , logSegmentSeqNo ) ; } else { return DistributedLogConstants . INPROGRESS_LOGSEGMENT_PREFIX + STR_ + Long . toString ( firstTxId , NUM_ ) ; } }
public synchronized void add ( double value ) { add ( mCategories . size ( ) + STR_ , value ) ; }
public void receiveRedundancy ( ) { try { while ( BOOL_ ) { if ( mIn . read ( mInBuffer ) <= NUM_ ) return ; } } catch ( IOException e ) { } }
void outputDocTypeDecl ( String name , boolean closeDecl ) throws SAXException { if ( m_cdataTagOpen ) closeCDATA ( ) ; try { final java . io . Writer writer = m_writer ; writer . write ( STR_ ) ; writer . write ( name ) ; String doctypePublic = getDoctypePublic ( ) ; if ( null != doctypePublic ) { writer . write ( STR_ ) ; writer . write ( doctypePublic ) ; writer . write ( STR_ ) ; } String doctypeSystem = getDoctypeSystem ( ) ; if ( null != doctypeSystem ) { if ( null == doctypePublic ) writer . write ( STR_ ) ; else writer . write ( STR_ ) ; writer . write ( doctypeSystem ) ; if ( closeDecl ) { writer . write ( STR_ ) ; writer . write ( m_lineSep , NUM_ , m_lineSepLen ) ; closeDecl = BOOL_ ; } else writer . write ( STR_ ) ; } } catch ( IOException e ) { throw new SAXException ( e ) ; } }
MVStore ( HashMap < String , Object > config ) { Object o = config . get ( STR_ ) ; this . compressionLevel = o == null ? NUM_ : ( Integer ) o ; String fileName = ( String ) config . get ( STR_ ) ; o = config . get ( STR_ ) ; if ( o == null ) { pageSplitSize = fileName == null ? NUM_ . NUM_ : NUM_ . NUM_ ; } else { pageSplitSize = ( Integer ) o ; } o = config . get ( STR_ ) ; this . backgroundExceptionHandler = ( UncaughtExceptionHandler ) o ; meta = new MVMap < String , String > ( StringDataType . INSTANCE , StringDataType . INSTANCE ) ; HashMap < String , Object > c = New . hashMap ( ) ; c . put ( STR_ , NUM_ ) ; c . put ( STR_ , currentVersion ) ; meta . init ( this , c ) ; fileStore = ( FileStore ) config . get ( STR_ ) ; if ( fileName == null && fileStore == null ) { cache = null ; cacheChunkRef = null ; return ; } if ( fileStore == null ) { fileStoreIsProvided = BOOL_ ; fileStore = new FileStore ( ) ; } else { fileStoreIsProvided = BOOL_ ; } retentionTime = fileStore . getDefaultRetentionTime ( ) ; boolean readOnly = config . containsKey ( STR_ ) ; o = config . get ( STR_ ) ; int mb = o == null ? NUM_ : ( Integer ) o ; if ( mb > NUM_ ) { CacheLongKeyLIRS . Config cc = new CacheLongKeyLIRS . Config ( ) ; cc . maxMemory = mb . NUM_ . NUM_ ; o = config . get ( STR_ ) ; if ( o != null ) { cc . segmentCount = ( Integer ) o ; } cache = new CacheLongKeyLIRS < Page > ( cc ) ; cc . maxMemory /= NUM_ ; cacheChunkRef = new CacheLongKeyLIRS < PageChildren > ( cc ) ; } o = config . get ( STR_ ) ; int kb = o == null ? NUM_ : ( Integer ) o ; autoCommitMemory = kb . NUM_ . NUM_ ; o = config . get ( STR_ ) ; autoCompactFillRate = o == null ? NUM_ : ( Integer ) o ; char [ ] encryptionKey = ( char [ ] ) config . get ( STR_ ) ; try { if ( ! fileStoreIsProvided ) { fileStore . open ( fileName , readOnly , encryptionKey ) ; } if ( fileStore . size ( ) == NUM_ ) { creationTime = getTimeAbsolute ( ) ; lastCommitTime = creationTime ; storeHeader . put ( STR_ , NUM_ ) ; storeHeader . put ( STR_ , BLOCK_SIZE ) ; storeHeader . put ( STR_ , FORMAT_WRITE ) ; storeHeader . put ( STR_ , creationTime ) ; writeStoreHeader ( ) ; } else { readStoreHeader ( ) ; } } catch ( IllegalStateException e ) { panic ( e ) ; } finally { if ( encryptionKey != null ) { Arrays . fill ( encryptionKey , ( char ) NUM_ ) ; } } lastCommitTime = getTimeSinceCreation ( ) ; o = config . get ( STR_ ) ; int delay = o == null ? NUM_ : ( Integer ) o ; setAutoCommitDelay ( delay ) ; }
public static boolean isValidVector ( Vector2f vector ) { if ( vector == null ) return BOOL_ ; if ( Float . isNaN ( vector . x ) || Float . isNaN ( vector . y ) ) return BOOL_ ; if ( Float . isInfinite ( vector . x ) || Float . isInfinite ( vector . y ) ) return BOOL_ ; return BOOL_ ; }
public static URL resolveURL ( URL base , String target ) throws MalformedURLException { target = target . trim ( ) ; if ( target . startsWith ( STR_ ) ) { return fixPureQueryTargets ( base , target ) ; } return new URL ( base , target ) ; }
protected int maxDepth ( Layout . Node node ) { int depth = NUM_ ; for ( int i = NUM_ ; i < node . numChildren ( ) ; i ++ ) { Layout . Node child = node . getChild ( i ) ; depth = Math . max ( depth , maxDepth ( child ) ) ; } return depth + NUM_ ; }
private int measureShort ( int measureSpec ) { int result ; int specMode = MeasureSpec . getMode ( measureSpec ) ; int specSize = MeasureSpec . getSize ( measureSpec ) ; if ( specMode == MeasureSpec . EXACTLY ) { result = specSize ; } else { result = ( int ) ( NUM_ . mRadius + getPaddingTop ( ) + getPaddingBottom ( ) + NUM_ ) ; if ( specMode == MeasureSpec . AT_MOST ) { result = Math . min ( result , specSize ) ; } } return result ; }
private static URL [ ] pathToURLs ( String path ) throws MalformedURLException { synchronized ( pathToURLsCache ) { Object [ ] v = ( Object [ ] ) pathToURLsCache . get ( path ) ; if ( v != null ) { return ( URL [ ] ) v [ NUM_ ] ; } } StringTokenizer st = new StringTokenizer ( path ) ; URL [ ] urls = new URL [ st . countTokens ( ) ] ; for ( int i = NUM_ ; st . hasMoreTokens ( ) ; i ++ ) { urls [ i ] = new URL ( st . nextToken ( ) ) ; } synchronized ( pathToURLsCache ) { pathToURLsCache . put ( path , new Object [ ] { urls , new SoftReference ( path ) } ) ; } return urls ; }
private void addFinal ( Object [ ] stacks ) { Object [ ] input = new Object [ inputSize ] , output = new Object [ outputSize ] ; for ( int i = NUM_ ; i < stacks . length ; i ++ ) { if ( i < inputSize ) { input [ i ] = stacks [ i ] ; } else if ( ! ( i - inputSize > outputSize ) ) { output [ i - inputSize ] = stacks [ i ] ; } else { throw new RuntimeException ( STR_ ) ; } } addRecipe ( input , output ) ; }
protected void fireConnectionClosed ( ) { ConnectionEvent evt = new ConnectionEvent ( this ) ; for ( ConnectionEventListener listener : connectionEventListeners ) { listener . connectionClosed ( evt ) ; } }
public static void putIntVolatile ( Object obj , long off , int val ) { UNSAFE . putIntVolatile ( obj , off , val ) ; }
NumberStrategy ( final int field ) { this . field = field ; }
public static URI createUriFromServerSet ( Set < InetSocketAddress > serverInetSet , String path , String protocol ) throws URISyntaxException { InetSocketAddress inetSocketAddress = ServiceUtils . selectRandomItem ( serverInetSet ) ; String address = inetSocketAddress . getHostString ( ) ; int port = inetSocketAddress . getPort ( ) ; URI uri = new URI ( protocol , null , address , port , path , null , null ) ; return uri ; }
public PlotNavigator ( Plot plot , String ... axesNames ) { this ( plot , Arrays . asList ( axesNames ) ) ; }
private void expand ( int i ) { if ( count + i <= buf . length ) { return ; } byte [ ] newbuf = mPool . getBuf ( ( count + i ) . NUM_ ) ; System . arraycopy ( buf , NUM_ , newbuf , NUM_ , count ) ; mPool . returnBuf ( buf ) ; buf = newbuf ; }
public void addColumn ( Class classType , boolean readOnly , String header ) { m_modelHeaderClass . add ( classType ) ; setColumnReadOnly ( m_modelHeaderClass . size ( ) - NUM_ , readOnly ) ; addColumn ( header ) ; WListItemRenderer renderer = ( WListItemRenderer ) getItemRenderer ( ) ; renderer . setColumnClass ( ( renderer . getNoColumns ( ) - NUM_ ) , classType ) ; return ; }
PointComparator ( int dimension ) { this . dimension = dimension ; }
public static void addElement ( Document doc , Element rootElement , String elementName , String typeIn , String isArrayIn , String partitionerIn ) { Element element = doc . createElement ( STR_ ) ; rootElement . appendChild ( element ) ; Element name = doc . createElement ( STR_ ) ; name . appendChild ( doc . createTextNode ( elementName ) ) ; element . appendChild ( name ) ; Element type = doc . createElement ( STR_ ) ; type . appendChild ( doc . createTextNode ( typeIn ) ) ; element . appendChild ( type ) ; if ( isArrayIn . equals ( STR_ ) ) { element . appendChild ( doc . createElement ( STR_ ) ) ; } if ( partitionerIn != null ) { Element partitioner = doc . createElement ( STR_ ) ; partitioner . appendChild ( doc . createTextNode ( partitionerIn ) ) ; element . appendChild ( partitioner ) ; } }
public void flushBuffer ( ) throws IOException { if ( count > NUM_ ) { m_os . write ( m_outputBytes , NUM_ , count ) ; count = NUM_ ; } }
public void addFirst ( Character c ) { addFirst ( c . toString ( ) ) ; }
public final void addInstanceOf ( String className ) { Reject . ifNull ( className ) ; String value = className . trim ( ) ; if ( ! value . matches ( CLASS_RE ) ) { throw new IllegalArgumentException ( STR_ + value + STR_ ) ; } instanceOfInterfaces . add ( value ) ; }
@ Override public int read ( byte [ ] b , int off , int len ) throws IOException { if ( b == null ) { throw new NullPointerException ( STR_ ) ; } if ( len < NUM_ || off < NUM_ || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( STR_ + b . length + STR_ + off + STR_ + len ) ; } int read = NUM_ ; if ( len == NUM_ ) { return NUM_ ; } while ( len > NUM_ ) { if ( encoderOut . hasRemaining ( ) ) { int c = Math . min ( encoderOut . remaining ( ) , len ) ; encoderOut . get ( b , off , c ) ; off += c ; len -= c ; read += c ; } else { fillBuffer ( ) ; if ( endOfInput && ! encoderOut . hasRemaining ( ) ) { break ; } } } return read == NUM_ && endOfInput ? - NUM_ : read ; }
public boolean isDisplayedExpectingComponents ( ) { boolean result = BOOL_ ; if ( conditions . isConditionMet ( visibilityOf ( window ) ) ) { if ( components . isEmpty ( ) ) { closeButton . click ( ) ; } else { result = BOOL_ ; } } return result ; }
private void processRunStartedTag ( String identifier ) { Pattern numTestsPattern = Pattern . compile ( STR_ ) ; Matcher numTests = numTestsPattern . matcher ( identifier ) ; if ( numTests . find ( ) ) { try { mNumTestsExpected = Integer . parseInt ( numTests . group ( NUM_ ) ) ; } catch ( NumberFormatException e ) { Log . e ( LOG_TAG , STR_ + numTests . group ( NUM_ ) ) ; } } if ( mNumTestsExpected > NUM_ ) { reportTestRunStarted ( ) ; mNumTestsRun = NUM_ ; mTestRunInProgress = BOOL_ ; } }
public StyledString insert ( char ch , int offset ) throws StringIndexOutOfBoundsException { if ( offset < NUM_ || offset > builder . length ( ) ) { throw new StringIndexOutOfBoundsException ( STR_ + offset + STR_ ) ; } builder . insert ( offset , ch ) ; return this ; }
public void addRoot ( ProtoElement root ) { roots . add ( root ) ; }
public void expandToObjectAndSelect ( Object elementOrTreePath , int level ) { if ( checkBusy ( ) ) { return ; } Object parent = getParentElement ( elementOrTreePath ) ; if ( ( ( parent != null ) && getExpandedState ( parent ) ) || isRootElement ( elementOrTreePath ) ) { Widget w = internalGetWidgetToSelect ( elementOrTreePath ) ; if ( null != w ) { List < Object > selectionList = new ArrayList < > ( ) ; selectionList . add ( w ) ; setSelection ( selectionList ) ; objectToSelect . set ( null ) ; } else { objectToSelect . set ( elementOrTreePath ) ; } } else { objectToSelect . set ( elementOrTreePath ) ; List < Object > objectsToExpand = createObjectList ( parent , new ArrayList < > ( ) ) ; if ( ! objectsToExpand . isEmpty ( ) ) { objectsToBeExpanded . addAll ( objectsToExpand ) ; Widget w = internalExpand ( elementOrTreePath , BOOL_ ) ; if ( w != null ) { internalExpandToLevel ( w , level ) ; } } else { Widget w = internalGetWidgetToSelect ( elementOrTreePath ) ; if ( null != w ) { List < Object > selectionList = new ArrayList < > ( ) ; selectionList . add ( w ) ; setSelection ( selectionList ) ; objectToSelect . set ( null ) ; } } } }
public void appendCell ( float value ) { appendCell ( String . valueOf ( value ) ) ; }
public SVNChangeSetCollector ( ISynchronizePageConfiguration configuration ) { super ( configuration ) ; }
public static boolean isNormalized ( CharSequence src , java . text . Normalizer . Form form , int option ) { return NormalizerBase . isNormalized ( src . toString ( ) , form , option ) ; }
@ Override public String toString ( boolean freq ) { StringBuffer result = new StringBuffer ( ) ; result . append ( m_attribute . name ( ) + STR_ ) ; switch ( m_comparison ) { case EQUAL : result . append ( STR_ ) ; break ; case LESS_THAN_OR_EQUAL_TO : result . append ( STR_ ) ; break ; case GREATER_THAN : result . append ( STR_ ) ; break ; default : break ; } result . append ( STR_ + Utils . doubleToString ( m_splitPoint , NUM_ ) ) ; if ( freq ) { result . append ( STR_ + m_frequency ) ; } return result . toString ( ) ; }
public static String unescapeSom ( String s ) { int idx = s . indexOf ( STR_ ) ; if ( idx < NUM_ ) return s ; StringBuilder sb = new StringBuilder ( ) ; int last = NUM_ ; while ( idx >= NUM_ ) { sb . append ( s . substring ( last , idx ) ) ; last = idx + NUM_ ; idx = s . indexOf ( STR_ , idx + NUM_ ) ; } sb . append ( s . substring ( last ) ) ; return sb . toString ( ) ; }
void saveAsync ( ColumnEntity entity , Duration ttl , Consumer < ColumnEntity > callBack ) throws ExecuteAsyncQueryException , UnsupportedOperationException ;
private static CopyState readCopyState ( DataInput in ) throws IOException { byte [ ] infosBytes = new byte [ in . readVInt ( ) ] ; in . readBytes ( infosBytes , NUM_ , infosBytes . length ) ; long gen = in . readVLong ( ) ; long version = in . readVLong ( ) ; Map < String , FileMetaData > files = CopyFilesHandler . readFilesMetaData ( in ) ; int count = in . readVInt ( ) ; Set < String > completedMergeFiles = new HashSet < > ( ) ; for ( int i = NUM_ ; i < count ; i ++ ) { completedMergeFiles . add ( in . readString ( ) ) ; } long primaryGen = in . readVLong ( ) ; return new CopyState ( files , version , gen , infosBytes , completedMergeFiles , primaryGen , null ) ; }
private void beforeName ( ) throws IOException { JsonScope context = peek ( ) ; if ( context == JsonScope . NONEMPTY_OBJECT ) { out . write ( STR_ ) ; } else if ( context != JsonScope . EMPTY_OBJECT ) { throw new IllegalStateException ( STR_ + stack ) ; } newline ( ) ; replaceTop ( JsonScope . DANGLING_NAME ) ; }
@ Transactional public void redeem ( final String tokenNumber , final String service ) { final Token token = tokenRepository . findByTokenNumberAndService ( tokenNumber , service ) ; if ( token == null ) throw new ApplicationRuntimeException ( STR_ + tokenNumber + STR_ ) ; redeem ( token ) ; }
public int lightenColor ( int color , float factor ) { float r = Color . red ( color ) . factor ; float g = Color . green ( color ) . factor ; float b = Color . blue ( color ) . factor ; int ir = Math . min ( NUM_ , ( int ) r ) ; int ig = Math . min ( NUM_ , ( int ) g ) ; int ib = Math . min ( NUM_ , ( int ) b ) ; int ia = Color . alpha ( color ) ; return ( Color . argb ( ia , ir , ig , ib ) ) ; }
private static String toDatabaseString ( final OperandSize size ) { switch ( size ) { case BYTE : return STR_ ; case WORD : return STR_ ; case DWORD : return STR_ ; case QWORD : return STR_ ; case OWORD : return STR_ ; case ADDRESS : return STR_ ; default : throw new IllegalArgumentException ( String . format ( STR_ , size ) ) ; } }
static String fileNameOfClass ( final String className , String typeSuffix ) { return className . replace ( STR_ , STR_ ) + STR_ + typeSuffix ; }
public void writePv ( ProcessVar pv , int recursiveDepth ) { writePv ( pv , recursiveDepth , BOOL_ ) ; }
public synchronized void add ( double minValue , double maxValue ) { super . add ( minValue ) ; mMaxValues . add ( maxValue ) ; }
private static void assertQualNS ( String qualNS ) throws XMPException { if ( qualNS == null || qualNS . length ( ) == NUM_ ) { throw new XMPException ( STR_ , XMPError . BADSCHEMA ) ; } }
public static StringBuilder formatTo ( StringBuilder buf , float [ ] d , String sep , NumberFormat nf ) { if ( d == null ) { return buf . append ( STR_ ) ; } if ( d . length == NUM_ ) { return buf ; } buf . append ( nf . format ( d [ NUM_ ] ) ) ; for ( int i = NUM_ ; i < d . length ; i ++ ) { buf . append ( sep ) ; buf . append ( nf . format ( d [ i ] ) ) ; } return buf ; }
public static void pack ( int [ ] n , String s ) { for ( int i = NUM_ ; i < n . length ; i ++ ) { n [ i ] = NUM_ ; } int idx = n . length - NUM_ ; for ( int i = s . length ( ) - NUM_ ; i >= NUM_ ; i -- ) { n [ idx -- ] = s . charAt ( i ) - STR_ ; } }
public int removeViewpoints ( int [ ] indices ) { for ( int i = indices . length - NUM_ ; i >= NUM_ ; -- i ) viewpointList . remove ( indices [ i ] ) ; viewpointIndex = indices [ NUM_ ] - NUM_ ; if ( viewpointList . size ( ) == NUM_ ) { viewpointIndex = - NUM_ ; } else if ( viewpointIndex < NUM_ ) { viewpointIndex = viewpointList . size ( ) - NUM_ ; } return ( viewpointIndex ) ; }
public void clearOnPageChangeListeners ( ) { if ( mOnPageChangeListeners != null ) { mOnPageChangeListeners . clear ( ) ; } }
private void updateColor ( ) { try { BreakpointConditionParser . evaluate ( inputField . getText ( ) ) ; inputField . setBackground ( Color . WHITE ) ; } catch ( final InvalidFormulaException e ) { inputField . setBackground ( Color . RED ) ; } }
public void removeIgnoredView ( View v ) { ignoredViews . remove ( v ) ; }
public boolean writeHeader ( OutputStream os ) { try { writeInt ( os , CACHE_MAGIC ) ; writeString ( os , key ) ; writeString ( os , etag == null ? STR_ : etag ) ; writeLong ( os , serverDate ) ; writeLong ( os , lastModified ) ; writeLong ( os , ttl ) ; writeLong ( os , softTtl ) ; writeStringStringMap ( responseHeaders , os ) ; os . flush ( ) ; return BOOL_ ; } catch ( IOException e ) { VinciLog . d ( STR_ , e . toString ( ) ) ; return BOOL_ ; } }
private static boolean ensureCurrent ( LeasedResource resource ) { return resource . getExpiration ( ) > SystemTime . timeMillis ( ) ; }
public static int maxFill ( final int n , final float f ) { return Math . min ( ( int ) Math . ceil ( n . f ) , n - NUM_ ) ; }
public void clear ( ) { mCategories . clear ( ) ; mTitles . clear ( ) ; mValues . clear ( ) ; }
public void toggleSectionSelected ( int sectionIndex ) { setSectionSelected ( sectionIndex , ! isSectionSelected ( sectionIndex ) ) ; }
public String combine ( List < String > files , String outFile ) throws Exception { ArrayList < String > cmd = new ArrayList < String > ( ) ; cmd . add ( soxBin ) ; for ( String file : files ) { cmd . add ( file ) ; } cmd . add ( outFile ) ; int rc = execSox ( cmd , callback ) ; if ( rc != NUM_ ) { throw new Exception ( STR_ + rc ) ; } return outFile ; }
void stopScrollingInstance ( ) { if ( log . isLoggable ( PlatformLogger . Level . FINER ) ) { log . finer ( STR_ + this ) ; } i_scroller . stop ( ) ; }
@ edu . umd . cs . findbugs . annotations . SuppressFBWarnings ( value = STR_ , justification = STR_ ) protected void newInternalMinute ( ) { double origCurrent = mCurrentIntensity ; int origState = mState ; int steps = getNumberOfSteps ( ) ; if ( ( mTransitionDuration > NUM_ ) && ( steps > NUM_ ) ) { double stepsPerMinute = steps / mTransitionDuration ; double stepSize = NUM_ / ( double ) steps ; double intensityDiffPerMinute = stepSize . stepsPerMinute ; if ( Math . abs ( mCurrentIntensity - mTransitionTargetIntensity ) != NUM_ ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + mTransitionTargetIntensity + STR_ + mCurrentIntensity ) ; } if ( mTransitionTargetIntensity > mCurrentIntensity ) { mCurrentIntensity = mCurrentIntensity + intensityDiffPerMinute ; if ( mCurrentIntensity >= mTransitionTargetIntensity ) { mCurrentIntensity = mTransitionTargetIntensity ; if ( mCurrentIntensity >= getMaxIntensity ( ) ) { mState = ON ; } else { mState = INTERMEDIATE ; } } } else { mCurrentIntensity = mCurrentIntensity - intensityDiffPerMinute ; if ( mCurrentIntensity <= mTransitionTargetIntensity ) { mCurrentIntensity = mTransitionTargetIntensity ; if ( mCurrentIntensity <= getMinIntensity ( ) ) { mState = OFF ; } else { mState = INTERMEDIATE ; } } } sendIntensity ( mCurrentIntensity ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + mTransitionTargetIntensity + STR_ + mCurrentIntensity ) ; } } } if ( origCurrent != mCurrentIntensity ) { firePropertyChange ( STR_ , Double . valueOf ( origCurrent ) , Double . valueOf ( mCurrentIntensity ) ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + origCurrent + STR_ + mCurrentIntensity ) ; } } if ( origState != mState ) { firePropertyChange ( STR_ , Integer . valueOf ( origState ) , Integer . valueOf ( mState ) ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + origCurrent + STR_ + mCurrentIntensity ) ; } } }
public void execute2 ( KahanObject in1 , double in2 ) { if ( Double . isInfinite ( in1 . _sum ) || Double . isInfinite ( in2 ) ) { in1 . set ( Double . isInfinite ( in2 ) ? in2 : in1 . _sum , NUM_ ) ; return ; } double correction = in2 + in1 . _correction ; double sum = in1 . _sum + correction ; in1 . set ( sum , correction - ( sum - in1 . _sum ) ) ; }
public static Response newFixedLengthResponse ( String msg ) { return newFixedLengthResponse ( Status . OK , NanoHTTPD . MIME_HTML , msg ) ; }
@ Override public XMLEvent peek ( ) throws XMLStreamException { log . log ( Level . FINE , STR_ ) ; if ( ! hasNext ( ) ) { throw new XMLStreamException ( STR_ ) ; } log . log ( Level . FINE , STR_ , nextEvent ) ; return nextEvent ; }
public static String replaceEndPoint ( String url , String endPoint ) { return endPoint + url . replaceFirst ( DEFAULT_ENDPOINT , STR_ ) ; }
public static double length ( double x , double y , double z ) { return Math . sqrt ( x . x + y . y + z . z ) ; }
private void makeOkPath ( ) { path1 . reset ( ) ; int w2 = getMeasuredWidth ( ) / NUM_ ; int h2 = getMeasuredHeight ( ) / NUM_ ; double a = Math . cos ( Math . toRadians ( NUM_ ) ) . getRadius ( ) ; double c = Math . sin ( Math . toRadians ( NUM_ ) ) . getRadius ( ) ; double l = Math . cos ( Math . toRadians ( NUM_ ) ) . NUM_ . a ; double b = Math . sin ( Math . toRadians ( NUM_ ) ) . l ; double m = Math . cos ( Math . toRadians ( NUM_ ) ) . l ; path1 . moveTo ( ( float ) ( w2 - a ) , ( float ) ( h2 - c ) ) ; path1 . lineTo ( ( float ) ( w2 - a + m ) , ( float ) ( h2 - c + Math . sin ( Math . toRadians ( NUM_ ) ) . l ) ) ; path1 . lineTo ( ( float ) ( w2 + a ) , ( float ) ( h2 - c ) ) ; pathMeasure1 . setPath ( path1 , BOOL_ ) ; mMarkOklength = pathMeasure1 . getLength ( ) ; }
private static void _trustAllHttpsCertificates ( ) { SSLContext context ; if ( _trustManagers == null ) { _trustManagers = new TrustManager [ ] { new FakeX509TrustManager ( ) } ; } try { context = SSLContext . getInstance ( STR_ ) ; context . init ( null , _trustManagers , new SecureRandom ( ) ) ; } catch ( GeneralSecurityException gse ) { throw new IllegalStateException ( gse . getMessage ( ) ) ; } HttpsURLConnection . setDefaultSSLSocketFactory ( context . getSocketFactory ( ) ) ; }
public void addMemberValue ( String name , MemberValue value ) { Pair p = new Pair ( ) ; p . name = pool . addUtf8Info ( name ) ; p . value = value ; if ( members == null ) members = new LinkedHashMap ( ) ; members . put ( name , p ) ; }
public java . lang . String toString ( ) { return toString ( value ) ; }
protected List < String > addWhitespace ( List < String > list ) { List < String > whitespaceList = new ArrayList < > ( ) ; for ( String value : list ) { whitespaceList . add ( addWhitespace ( value ) ) ; } return whitespaceList ; }
public static String computeQualifiedWidgetTypeName ( Node widgetNode ) { if ( widgetNode . getNodeType ( ) != Node . ELEMENT_NODE ) { return null ; } String typeName = widgetNode . getLocalName ( ) ; if ( typeName . length ( ) == NUM_ || Character . isLowerCase ( typeName . charAt ( NUM_ ) ) ) { return null ; } String packageName = UiBinderUtilities . getPackageName ( widgetNode . getNamespaceURI ( ) ) ; return packageName != null ? JavaUtilities . getQualifiedTypeName ( typeName , packageName ) : null ; }
private static boolean processFtypAtom ( ParsableByteArray atomData ) { atomData . setPosition ( Atom . HEADER_SIZE ) ; int majorBrand = atomData . readInt ( ) ; if ( majorBrand == BRAND_QUICKTIME ) { return BOOL_ ; } atomData . skipBytes ( NUM_ ) ; while ( atomData . bytesLeft ( ) > NUM_ ) { if ( atomData . readInt ( ) == BRAND_QUICKTIME ) { return BOOL_ ; } } return BOOL_ ; }
public Map < String , String > parse ( final String str , char separator ) { if ( str == null ) { return new HashMap < String , String > ( ) ; } return parse ( str . toCharArray ( ) , separator ) ; }
public void clear ( ) { oredCriteria . clear ( ) ; orderByClause = null ; distinct = BOOL_ ; }
public String delete ( String url , final int expectedStatusCode ) { return delete ( url , Collections . < String , String > emptyMap ( ) , expectedStatusCode ) ; }
protected void runningSum ( Set < Map . Entry < Double , Double > > c , double value , double [ ] sums ) { double offset = CONST - Math . log ( m_Width ) ; double logFactor = Math . log ( m_Threshold ) - Math . log ( NUM_ - m_Threshold ) ; double logSumOfWeights = Math . log ( m_SumOfWeights ) ; Iterator < Map . Entry < Double , Double > > itr = c . iterator ( ) ; while ( itr . hasNext ( ) ) { Map . Entry < Double , Double > entry = itr . next ( ) ; if ( entry . getValue ( ) > NUM_ ) { double diff = ( entry . getKey ( ) - value ) / m_Width ; double logDensity = offset - NUM_ . diff . diff ; double logWeight = Math . log ( entry . getValue ( ) ) ; sums [ NUM_ ] = logOfSum ( sums [ NUM_ ] , logWeight + logDensity ) ; sums [ NUM_ ] = logOfSum ( sums [ NUM_ ] , logWeight ) ; if ( logDensity + logSumOfWeights < logOfSum ( logFactor + sums [ NUM_ ] , logDensity + sums [ NUM_ ] ) ) { break ; } } } }
@ Override public CategoricalTable copy ( ) { Map < Value , Double > newTable = new HashMap < Value , Double > ( ) ; for ( Value v : table . keySet ( ) ) { newTable . put ( v , table . get ( v ) ) ; } return new CategoricalTable ( variable , newTable ) ; }
public Configuration subConfig ( String prefix , String keyPrefix ) { Configuration sub = new Configuration ( ) ; addToSubConf ( sub , prefix . length ( ) > NUM_ ? prefix + STR_ + keyPrefix : keyPrefix ) ; return sub ; }
public Map < String , String > mapNameToDisplayName ( Set < String > names ) throws SMSException , SSOException { final Map < String , String > map = new HashMap < > ( names . size ( ) ) ; for ( String name : names ) { if ( smsConsoleServiceConfig . isServiceVisible ( name ) ) { final ServiceSchemaManager serviceSchemaManager = serviceSchemaManagerFactory . build ( name ) ; String displayName = getLocalizedServiceName ( serviceSchemaManager , name ) ; String resourceName = serviceSchemaManager . getResourceName ( ) ; if ( ! name . equals ( displayName ) && ! StringUtils . isBlank ( resourceName ) ) { map . put ( resourceName , displayName ) ; } } } return map ; }
public IntColumn ( int nrows , int capacity , int defaultValue ) { super ( int . class , new Integer ( defaultValue ) ) ; if ( capacity < nrows ) { throw new IllegalArgumentException ( STR_ ) ; } m_values = new int [ capacity ] ; Arrays . fill ( m_values , defaultValue ) ; m_size = nrows ; }
@ Override public String toString ( ) { return STR_ + getId ( ) ; }
public static final boolean executePotentialWork ( final Object data , final ImageView imageView ) { final BitmapWorkerTask bitmapWorkerTask = getBitmapWorkerTask ( imageView ) ; if ( bitmapWorkerTask != null ) { final Object bitmapData = bitmapWorkerTask . mKey ; if ( bitmapData == null || ! bitmapData . equals ( data ) ) { bitmapWorkerTask . cancel ( BOOL_ ) ; } else { return BOOL_ ; } } return BOOL_ ; }
public static void queueBitmap ( String key , Bitmap bmp ) { mBitmapQueue . put ( key , bmp ) ; }
private static int analyze ( Compiler compiler , int stepOpCodePos , int stepIndex ) throws javax . xml . transform . TransformerException { int stepType ; int stepCount = NUM_ ; int analysisResult = x00000000 ; while ( OpCodes . ENDOP != ( stepType = compiler . getOp ( stepOpCodePos ) ) ) { stepCount ++ ; boolean predAnalysis = analyzePredicate ( compiler , stepOpCodePos , stepType ) ; if ( predAnalysis ) analysisResult |= BIT_PREDICATE ; switch ( stepType ) { case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : analysisResult |= BIT_FILTER ; break ; case OpCodes . FROM_ROOT : analysisResult |= BIT_ROOT ; break ; case OpCodes . FROM_ANCESTORS : analysisResult |= BIT_ANCESTOR ; break ; case OpCodes . FROM_ANCESTORS_OR_SELF : analysisResult |= BIT_ANCESTOR_OR_SELF ; break ; case OpCodes . FROM_ATTRIBUTES : analysisResult |= BIT_ATTRIBUTE ; break ; case OpCodes . FROM_NAMESPACE : analysisResult |= BIT_NAMESPACE ; break ; case OpCodes . FROM_CHILDREN : analysisResult |= BIT_CHILD ; break ; case OpCodes . FROM_DESCENDANTS : analysisResult |= BIT_DESCENDANT ; break ; case OpCodes . FROM_DESCENDANTS_OR_SELF : if ( NUM_ == stepCount && BIT_ROOT == analysisResult ) { analysisResult |= BIT_ANY_DESCENDANT_FROM_ROOT ; } analysisResult |= BIT_DESCENDANT_OR_SELF ; break ; case OpCodes . FROM_FOLLOWING : analysisResult |= BIT_FOLLOWING ; break ; case OpCodes . FROM_FOLLOWING_SIBLINGS : analysisResult |= BIT_FOLLOWING_SIBLING ; break ; case OpCodes . FROM_PRECEDING : analysisResult |= BIT_PRECEDING ; break ; case OpCodes . FROM_PRECEDING_SIBLINGS : analysisResult |= BIT_PRECEDING_SIBLING ; break ; case OpCodes . FROM_PARENT : analysisResult |= BIT_PARENT ; break ; case OpCodes . FROM_SELF : analysisResult |= BIT_SELF ; break ; case OpCodes . MATCH_ATTRIBUTE : analysisResult |= ( BIT_MATCH_PATTERN | BIT_ATTRIBUTE ) ; break ; case OpCodes . MATCH_ANY_ANCESTOR : analysisResult |= ( BIT_MATCH_PATTERN | BIT_ANCESTOR ) ; break ; case OpCodes . MATCH_IMMEDIATE_ANCESTOR : analysisResult |= ( BIT_MATCH_PATTERN | BIT_PARENT ) ; break ; default : throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NULL_ERROR_HANDLER , new Object [ ] { Integer . toString ( stepType ) } ) ) ; } if ( OpCodes . NODETYPE_NODE == compiler . getOp ( stepOpCodePos + NUM_ ) ) { analysisResult |= BIT_NODETEST_ANY ; } stepOpCodePos = compiler . getNextStepPos ( stepOpCodePos ) ; if ( stepOpCodePos < NUM_ ) break ; } analysisResult |= ( stepCount & BITS_COUNT ) ; return analysisResult ; }
public void addListener ( AfterServerStartListener listener ) { _afterStartListeners . add ( listener ) ; }
public synchronized void add ( String name , long threadId ) { if ( mFinished ) { throw new IllegalStateException ( STR_ ) ; } mMarkers . add ( new Marker ( name , threadId , SystemClock . elapsedRealtime ( ) ) ) ; }
private static List < SizePair > generateValidPreviewSizeList ( Camera camera ) { Camera . Parameters parameters = camera . getParameters ( ) ; List < android . hardware . Camera . Size > supportedPreviewSizes = parameters . getSupportedPreviewSizes ( ) ; List < android . hardware . Camera . Size > supportedPictureSizes = parameters . getSupportedPictureSizes ( ) ; List < SizePair > validPreviewSizes = new ArrayList < > ( ) ; for ( android . hardware . Camera . Size previewSize : supportedPreviewSizes ) { float previewAspectRatio = ( float ) previewSize . width / ( float ) previewSize . height ; for ( android . hardware . Camera . Size pictureSize : supportedPictureSizes ) { float pictureAspectRatio = ( float ) pictureSize . width / ( float ) pictureSize . height ; if ( Math . abs ( previewAspectRatio - pictureAspectRatio ) < ASPECT_RATIO_TOLERANCE ) { validPreviewSizes . add ( new SizePair ( previewSize , pictureSize ) ) ; break ; } } } if ( validPreviewSizes . size ( ) == NUM_ ) { Log . w ( TAG , STR_ ) ; for ( android . hardware . Camera . Size previewSize : supportedPreviewSizes ) { validPreviewSizes . add ( new SizePair ( previewSize , null ) ) ; } } return validPreviewSizes ; }
private int makeAvailable ( ) throws IOException { if ( pos != - NUM_ ) { return NUM_ ; } total += tail - head - pad ; System . arraycopy ( buffer , tail - pad , buffer , NUM_ , pad ) ; head = NUM_ ; tail = pad ; for ( ; ; ) { int bytesRead = input . read ( buffer , tail , bufSize - tail ) ; if ( bytesRead == - NUM_ ) { final String msg = STR_ ; throw new FileUploadException ( MalformedStreamException , msg ) ; } tail += bytesRead ; findSeparator ( ) ; int av = available ( ) ; if ( av > NUM_ || pos != - NUM_ ) { return av ; } } }
public RelationNotification ( String notifType , Object sourceObj , long sequence , long timeStamp , String message , String id , String typeName , ObjectName objectName , List < ObjectName > unregMBeanList ) throws IllegalArgumentException { super ( notifType , sourceObj , sequence , timeStamp , message ) ; if ( ! isValidBasicStrict ( notifType , sourceObj , id , typeName ) || ! isValidCreate ( notifType ) ) { throw new IllegalArgumentException ( STR_ ) ; } relationId = id ; relationTypeName = typeName ; relationObjName = safeGetObjectName ( objectName ) ; unregisterMBeanList = safeGetObjectNameList ( unregMBeanList ) ; }
public void addDataToStore ( Object [ ] row ) throws CarbonDataWriterException { dataRows . add ( row ) ; this . entryCount ++ ; if ( this . entryCount == this . blockletSize ) { try { semaphore . acquire ( ) ; producerExecutorServiceTaskList . add ( producerExecutorService . submit ( new Producer ( blockletDataHolder , dataRows , ++ writerTaskSequenceCounter ) ) ) ; blockletProcessingCount . incrementAndGet ( ) ; processedDataCount += entryCount ; LOGGER . info ( STR_ + processedDataCount ) ; dataRows = new ArrayList < > ( this . blockletSize ) ; this . entryCount = NUM_ ; } catch ( InterruptedException e ) { LOGGER . error ( e , e . getMessage ( ) ) ; throw new CarbonDataWriterException ( e . getMessage ( ) ) ; } } }
public boolean localHostOrDomainIs ( String host , String domain ) { return domain . startsWith ( host ) ; }
protected double entropy ( double [ ] [ ] dataZs , double [ ] [ ] dataWs ) { double entropy = NUM_ ; int numInstances = dataZs . length ; for ( int j = NUM_ ; j < m_numClasses ; j ++ ) { double m = NUM_ ; double sum = NUM_ ; for ( int i = NUM_ ; i < numInstances ; i ++ ) { m += dataZs [ i ] [ j ] . dataWs [ i ] [ j ] ; sum += dataWs [ i ] [ j ] ; } m /= sum ; for ( int i = NUM_ ; i < numInstances ; i ++ ) { entropy += dataWs [ i ] [ j ] . Math . pow ( dataZs [ i ] [ j ] - m , NUM_ ) ; } } return entropy ; }
protected void writeDistribution ( Parameter parameter , boolean isRef , XMLWriter writer ) { switch ( parameter . priorType ) { case UNIFORM_PRIOR : String id = parameter . taxaId + STR_ ; if ( isRef ) { writer . writeIDref ( UniformDistributionModelParser . UNIFORM_DISTRIBUTION_MODEL , id ) ; } else { writer . writeOpenTag ( UniformDistributionModelParser . UNIFORM_DISTRIBUTION_MODEL , new Attribute [ ] { new Attribute . Default < String > ( XMLParser . ID , id ) } ) ; writer . writeOpenTag ( UniformDistributionModelParser . LOWER ) ; writer . writeText ( Double . toString ( parameter . uniformLower ) ) ; writer . writeCloseTag ( UniformDistributionModelParser . LOWER ) ; writer . writeOpenTag ( UniformDistributionModelParser . UPPER ) ; writer . writeText ( Double . toString ( parameter . uniformUpper ) ) ; writer . writeCloseTag ( UniformDistributionModelParser . UPPER ) ; writer . writeCloseTag ( UniformDistributionModelParser . UNIFORM_DISTRIBUTION_MODEL ) ; } break ; case EXPONENTIAL_PRIOR : writer . writeOpenTag ( ExponentialDistributionModel . EXPONENTIAL_DISTRIBUTION_MODEL ) ; writer . writeOpenTag ( DistributionModelParser . MEAN ) ; writer . writeText ( Double . toString ( parameter . mean ) ) ; writer . writeCloseTag ( DistributionModelParser . MEAN ) ; writer . writeOpenTag ( DistributionModelParser . OFFSET ) ; writer . writeText ( Double . toString ( parameter . offset ) ) ; writer . writeCloseTag ( DistributionModelParser . OFFSET ) ; writer . writeCloseTag ( ExponentialDistributionModel . EXPONENTIAL_DISTRIBUTION_MODEL ) ; break ; case NORMAL_PRIOR : writer . writeOpenTag ( NormalDistributionModelParser . NORMAL_DISTRIBUTION_MODEL ) ; writer . writeOpenTag ( NormalDistributionModelParser . MEAN ) ; writer . writeText ( Double . toString ( parameter . mean ) ) ; writer . writeCloseTag ( NormalDistributionModelParser . MEAN ) ; writer . writeOpenTag ( NormalDistributionModelParser . STDEV ) ; writer . writeText ( Double . toString ( parameter . stdev ) ) ; writer . writeCloseTag ( NormalDistributionModelParser . STDEV ) ; writer . writeCloseTag ( NormalDistributionModelParser . NORMAL_DISTRIBUTION_MODEL ) ; break ; case LOGNORMAL_PRIOR : writer . writeOpenTag ( LogNormalDistributionModelParser . LOGNORMAL_DISTRIBUTION_MODEL , new Attribute [ ] { new Attribute . Default < Boolean > ( LogNormalDistributionModelParser . MEAN_IN_REAL_SPACE , parameter . isMeanInRealSpace ( ) ) , new Attribute . Default < Boolean > ( LogNormalDistributionModelParser . STDEV_IN_REAL_SPACE , parameter . isMeanInRealSpace ( ) ) } ) ; writer . writeOpenTag ( LogNormalDistributionModelParser . MEAN ) ; writer . writeText ( Double . toString ( parameter . mean ) ) ; writer . writeCloseTag ( LogNormalDistributionModelParser . MEAN ) ; writer . writeOpenTag ( LogNormalDistributionModelParser . STDEV ) ; writer . writeText ( Double . toString ( parameter . stdev ) ) ; writer . writeCloseTag ( LogNormalDistributionModelParser . STDEV ) ; writer . writeOpenTag ( LogNormalDistributionModelParser . OFFSET ) ; writer . writeText ( Double . toString ( parameter . offset ) ) ; writer . writeCloseTag ( LogNormalDistributionModelParser . OFFSET ) ; writer . writeCloseTag ( LogNormalDistributionModelParser . LOGNORMAL_DISTRIBUTION_MODEL ) ; break ; case GAMMA_PRIOR : writer . writeOpenTag ( GammaDistributionModel . GAMMA_DISTRIBUTION_MODEL ) ; writer . writeOpenTag ( DistributionModelParser . SHAPE ) ; writer . writeText ( Double . toString ( parameter . shape ) ) ; writer . writeCloseTag ( DistributionModelParser . SHAPE ) ; writer . writeOpenTag ( DistributionModelParser . SCALE ) ; writer . writeText ( Double . toString ( parameter . scale ) ) ; writer . writeCloseTag ( DistributionModelParser . SCALE ) ; writer . writeOpenTag ( DistributionModelParser . OFFSET ) ; writer . writeText ( Double . toString ( parameter . offset ) ) ; writer . writeCloseTag ( DistributionModelParser . OFFSET ) ; writer . writeCloseTag ( GammaDistributionModel . GAMMA_DISTRIBUTION_MODEL ) ; break ; default : throw new IllegalArgumentException ( STR_ + parameter . getName ( ) ) ; } }
public void saveWorkingInstancesToFileQ ( ) { if ( m_IOThread == null ) { m_FileChooser . setCapabilitiesFilter ( m_FilterEditor . getCapabilitiesFilter ( ) ) ; m_FileChooser . setAcceptAllFileFilterUsed ( BOOL_ ) ; int returnVal = m_FileChooser . showSaveDialog ( this ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { Instances inst = new Instances ( m_Instances ) ; inst . setClassIndex ( m_AttVisualizePanel . getColoringIndex ( ) ) ; saveInstancesToFile ( m_FileChooser . getSaver ( ) , inst ) ; } FileFilter temp = m_FileChooser . getFileFilter ( ) ; m_FileChooser . setAcceptAllFileFilterUsed ( BOOL_ ) ; m_FileChooser . setFileFilter ( temp ) ; } else { JOptionPane . showMessageDialog ( this , STR_ + STR_ , STR_ , JOptionPane . WARNING_MESSAGE ) ; } }
private void calculateColor ( int coord ) { coord = coord - mBarPointerHaloRadius ; if ( coord < NUM_ ) { coord = NUM_ ; } else if ( coord > mBarLength ) { coord = mBarLength ; } mColor = Color . HSVToColor ( Math . round ( mPosToOpacFactor . coord ) , mHSVColor ) ; if ( Color . alpha ( mColor ) > NUM_ ) { mColor = Color . HSVToColor ( mHSVColor ) ; } else if ( Color . alpha ( mColor ) < NUM_ ) { mColor = Color . TRANSPARENT ; } }
public int read ( char cbuf [ ] , int off , int len ) throws IOException { if ( ( off < NUM_ ) || ( off > cbuf . length ) || ( len < NUM_ ) || ( ( off + len ) > cbuf . length ) || ( ( off + len ) < NUM_ ) ) throw new IndexOutOfBoundsException ( ) ; if ( len == NUM_ ) return NUM_ ; if ( next >= length ) return - NUM_ ; int n = Math . min ( length - next , len ) ; text . getChars ( next , next + n , cbuf , off ) ; next += n ; return n ; }
private boolean adjustIndent ( ) { AlignmentImpl alignment = CoreFormatterUtil . getAlignment ( myCurrentBlock ) ; WhiteSpace whiteSpace = myCurrentBlock . getWhiteSpace ( ) ; if ( alignment == null || myAlignmentsToSkip . contains ( alignment ) ) { if ( whiteSpace . containsLineFeeds ( ) ) { adjustSpacingByIndentOffset ( ) ; } else { whiteSpace . arrangeSpaces ( myCurrentBlock . getSpaceProperty ( ) ) ; } return BOOL_ ; } BlockAlignmentProcessor alignmentProcessor = ALIGNMENT_PROCESSORS . get ( alignment . getAnchor ( ) ) ; if ( alignmentProcessor == null ) { LOG . error ( String . format ( STR_ , alignment . getAnchor ( ) ) ) ; return BOOL_ ; } BlockAlignmentProcessor . Context context = new BlockAlignmentProcessor . Context ( myDocument , alignment , myCurrentBlock , myAlignmentMappings , myBackwardShiftedAlignedBlocks , getIndentOptionsToUse ( myCurrentBlock , myDefaultIndentOption ) , myRightMargin ) ; BlockAlignmentProcessor . Result result = alignmentProcessor . applyAlignment ( context ) ; final LeafBlockWrapper offsetResponsibleBlock = alignment . getOffsetRespBlockBefore ( myCurrentBlock ) ; switch ( result ) { case TARGET_BLOCK_PROCESSED_NOT_ALIGNED : return BOOL_ ; case TARGET_BLOCK_ALIGNED : storeAlignmentMapping ( ) ; return BOOL_ ; case BACKWARD_BLOCK_ALIGNED : if ( offsetResponsibleBlock == null ) { return BOOL_ ; } Set < LeafBlockWrapper > blocksCausedRealignment = new HashSet < LeafBlockWrapper > ( ) ; myBackwardShiftedAlignedBlocks . clear ( ) ; myBackwardShiftedAlignedBlocks . put ( offsetResponsibleBlock , blocksCausedRealignment ) ; blocksCausedRealignment . add ( myCurrentBlock ) ; storeAlignmentMapping ( myCurrentBlock , offsetResponsibleBlock ) ; myCurrentBlock = offsetResponsibleBlock . getNextBlock ( ) ; onCurrentLineChanged ( ) ; return BOOL_ ; case RECURSION_DETECTED : myCurrentBlock = offsetResponsibleBlock ; case UNABLE_TO_ALIGN_BACKWARD_BLOCK : myAlignmentsToSkip . add ( alignment ) ; return BOOL_ ; default : return BOOL_ ; } }
@ Override public void appendCode ( Type declaringType , TypeTuple inputTypes , Type outputType , List < Variable > inputVars , StringBuilder b ) { b . append ( field . toCode ( declaringType , inputVars ) ) ; }
public ForwardPlanner ( DialogueSystem system ) { this . system = system ; }
private JButton addButton ( String text , Container container , float alignment ) { JButton button = new JButton ( text ) ; button . setAlignmentX ( alignment ) ; container . add ( button ) ; return button ; }
private boolean noMatchForTagInAttributes ( AttributeSet attr , HTML . Tag t , Object tagValue ) { if ( attr != null && attr . isDefined ( t ) ) { Object newValue = attr . getAttribute ( t ) ; if ( ( tagValue == null ) ? ( newValue == null ) : ( newValue != null && tagValue . equals ( newValue ) ) ) { return BOOL_ ; } } return BOOL_ ; }
public String businessObjectDataKeyToString ( BusinessObjectDataKey businessObjectDataKey ) { if ( businessObjectDataKey == null ) { return null ; } return businessObjectDataKeyToString ( businessObjectDataKey . getNamespace ( ) , businessObjectDataKey . getBusinessObjectDefinitionName ( ) , businessObjectDataKey . getBusinessObjectFormatUsage ( ) , businessObjectDataKey . getBusinessObjectFormatFileType ( ) , businessObjectDataKey . getBusinessObjectFormatVersion ( ) , businessObjectDataKey . getPartitionValue ( ) , businessObjectDataKey . getSubPartitionValues ( ) , businessObjectDataKey . getBusinessObjectDataVersion ( ) ) ; }
public static boolean isValidIfd ( int ifdId ) { return ifdId == IfdId . TYPE_IFD_0 || ifdId == IfdId . TYPE_IFD_1 || ifdId == IfdId . TYPE_IFD_EXIF || ifdId == IfdId . TYPE_IFD_INTEROPERABILITY || ifdId == IfdId . TYPE_IFD_GPS ; }
private Usage createTalkUsage ( Context context ) { if ( talkUsage != null ) { return talkUsage ; } TypeToken < List < Usage > > token = new TypeToken < List < Usage > > ( ) { } ; List < Usage > initTalkIO = JsonUtils . parseJsonFile ( context , STR_ , token ) ; talkUsage = initTalkIO . get ( NUM_ ) ; return talkUsage ; }
@ Nullable public GrCall enclosingCall ( String name , GdslMembersHolderConsumer consumer ) { final PsiElement place = consumer . getPlace ( ) ; if ( place == null ) return null ; GrCall call = PsiTreeUtil . getParentOfType ( place , GrCall . class , BOOL_ ) ; if ( call == null ) return null ; while ( call != null && ! name . equals ( getInvokedMethodName ( call ) ) ) { call = PsiTreeUtil . getParentOfType ( call , GrCall . class , BOOL_ ) ; } if ( call == null ) return null ; final GrArgumentList argumentList = call . getArgumentList ( ) ; if ( argumentList != null ) { for ( GrExpression arg : argumentList . getExpressionArguments ( ) ) { if ( arg instanceof GrClosableBlock && PsiTreeUtil . findCommonParent ( place , arg ) == arg ) { return call ; } } } if ( call instanceof GrMethodCallExpression ) { for ( GrExpression arg : call . getClosureArguments ( ) ) { if ( arg instanceof GrClosableBlock && PsiTreeUtil . findCommonParent ( place , arg ) == arg ) { return call ; } } } return null ; }
public static void genOvfenvIsoImage ( String ovfenvPropKVStr , String isoFilePath ) { byte [ ] bOvfenvPropKVStr = ovfenvPropKVStr . getBytes ( ) ; String propFilePath = STR_ ; File propFile = new File ( propFilePath ) ; try { FileUtils . writePlainFile ( propFilePath , bOvfenvPropKVStr ) ; } catch ( Exception e1 ) { propFile . delete ( ) ; log . error ( STR_ , e1 . getMessage ( ) ) ; throw new IllegalStateException ( STR_ ) ; } try { File isoFile = new File ( isoFilePath ) ; String [ ] genISOImageCommand = { GENISO_CMD , STR_ , STR_ , STR_ , propFilePath , STR_ , isoFilePath , STR_ , STR_ } ; Exec . Result result = Exec . sudo ( CMD_TIMEOUT , genISOImageCommand ) ; if ( ! result . exitedNormally ( ) || result . getExitValue ( ) != NUM_ ) { log . error ( STR_ , result . getExitValue ( ) , result . getStdError ( ) ) ; throw new IllegalStateException ( STR_ ) ; } } catch ( Exception e ) { throw e ; } finally { propFile . delete ( ) ; } }
public static void createActionableEvent ( DbClient dbClient , EventUtils . EventCode eventCode , URI tenant , String name , String description , String warning , DataObject resource , List < URI > affectedResources , String approveMethod , Object [ ] approveParameters ) { createActionableEvent ( dbClient , eventCode , tenant , name , description , warning , resource , affectedResources , approveMethod , approveParameters , null , null ) ; }
public Rational ( ByteProvider byteProvider ) throws IOException { MXFPropertyPopulator . populateField ( byteProvider , this , STR_ ) ; MXFPropertyPopulator . populateField ( byteProvider , this , STR_ ) ; }
public synchronized void removeNotifications ( String type ) throws InstanceNotFoundException { Vector < Integer > v = getNotificationIDs ( type ) ; if ( v . isEmpty ( ) ) throw new InstanceNotFoundException ( STR_ ) ; for ( Integer i : v ) removeNotification ( i ) ; }
private void unifyViaAtom ( Atomic parentAtom ) { Atomic childAtom = getRuleConclusionAtom ( ) ; Query parent = parentAtom . getParentQuery ( ) ; Map < String , String > unifiers = childAtom . getUnifiers ( parentAtom ) ; head . unify ( unifiers ) ; body . unify ( unifiers ) ; Set < String > childFVs = body . getVarSet ( ) ; Set < String > parentBVs = parentAtom . getVarNames ( ) ; Set < String > parentVars = parent . getVarSet ( ) ; parentBVs . forEach ( null ) ; childFVs . forEach ( null ) ; }
static void addUuid ( SsfNode node , UUID uuid ) { node . set ( STR_ , uuid . getMostSignificantBits ( ) ) ; node . set ( STR_ , uuid . getLeastSignificantBits ( ) ) ; }
public void removeChangingListener ( OnWheelChangedListener listener ) { changingListeners . remove ( listener ) ; }
public long objectFieldOffset ( Field field ) { if ( Modifier . isStatic ( field . getModifiers ( ) ) ) { throw new IllegalArgumentException ( STR_ ) ; } return objectFieldOffset0 ( field ) ; }
private static int determineConsecutiveDigitCount ( CharSequence msg , int startpos ) { int count = NUM_ ; int len = msg . length ( ) ; int idx = startpos ; if ( idx < len ) { char ch = msg . charAt ( idx ) ; while ( isDigit ( ch ) && idx < len ) { count ++ ; idx ++ ; if ( idx < len ) { ch = msg . charAt ( idx ) ; } } } return count ; }
abstract void toXML ( StringBuilder xml , int level ) ;
public void dispose ( ) { mRunButton . setSelected ( BOOL_ ) ; super . dispose ( ) ; }
public FluxConcatArray < T > concatAdditionalSourceFirst ( Publisher < ? extends T > source ) { int n = array . length ; @ SuppressWarnings ( STR_ ) Publisher < ? extends T > [ ] newArray = new Publisher [ n + NUM_ ] ; System . arraycopy ( array , NUM_ , newArray , NUM_ , n ) ; newArray [ NUM_ ] = source ; return new FluxConcatArray < > ( delayError , newArray ) ; }
public void shutdown ( ) { shutdownServerThread ( ) ; shutdownSessions ( ) ; }
private boolean isLocalId ( String localId ) { if ( ! localId . startsWith ( STR_ ) ) { return BOOL_ ; } for ( int i = NUM_ ; i < localId . length ( ) ; ++ i ) { char c = localId . charAt ( i ) ; if ( ! ( c >= STR_ && c <= STR_ ) && ! ( c >= STR_ && c <= STR_ ) ) { return BOOL_ ; } } return BOOL_ ; }
public ServerSocketBar bind ( ServerSocketBar ss ) throws ConfigException , IOException { synchronized ( _sslInitLock ) { if ( _stdServerSocket != null ) throw new ConfigException ( L . l ( STR_ ) ) ; try { initConfig ( ) ; } catch ( RuntimeException e ) { e . printStackTrace ( ) ; throw e ; } _stdServerSocket = ss ; initSSL ( ) ; return this ; } }
private int checkInterruptWhileWaiting ( Node node ) { return Thread . interrupted ( ) ? ( transferAfterCancelledWait ( node ) ? THROW_IE : REINTERRUPT ) : NUM_ ; }
private void resetOutputBuilders ( ) { ansi = Ansi . ansi ( ) ; stringBuilder = new StringBuilder ( ) ; }
public String read ( ByteBuffer buf , DictionaryCache dict ) { StringBuilder out = new StringBuilder ( ) ; if ( pre != null ) out . append ( pre ) ; if ( type == VOID ) return out . toString ( ) ; if ( type == NULL ) { out . append ( STR_ ) ; return out . toString ( ) ; } if ( type == BYTE ) { out . append ( buf . get ( ) ) ; return out . toString ( ) ; } if ( type == SHORT ) { out . append ( buf . getShort ( ) ) ; return out . toString ( ) ; } if ( type == INT ) { out . append ( buf . getInt ( ) ) ; return out . toString ( ) ; } if ( type == LONG ) { out . append ( buf . getLong ( ) ) ; return out . toString ( ) ; } if ( type == DOUBLE ) { out . append ( buf . getDouble ( ) ) ; return out . toString ( ) ; } if ( type == BOOLEAN ) { out . append ( ( buf . get ( ) == NUM_ ? STR_ : STR_ ) ) ; return out . toString ( ) ; } if ( type == STRING ) { short pos = buf . getShort ( ) ; if ( pos > - NUM_ ) { out . append ( STR_ ) ; out . append ( dict . get ( pos ) ) ; out . append ( STR_ ) ; } else { int size = NUM_ ; int val = buf . get ( ) & xFF ; while ( val == NUM_ ) { size += val ; val = buf . get ( ) & xFF ; } size += val ; byte [ ] data = new byte [ size ] ; buf . get ( data ) ; out . append ( STR_ ) ; out . append ( new String ( data , StandardCharsets . UTF_8 ) ) ; out . append ( STR_ ) ; } return out . toString ( ) ; } return null ; }
public void write ( String filename ) { logger . info ( STR_ ) ; try { openFile ( filename ) ; writeXmlHead ( ) ; startCarriers ( this . writer ) ; for ( Carrier carrier : carriers ) { startCarrier ( carrier , this . writer ) ; writeVehicles ( carrier , this . writer ) ; writeShipments ( carrier , this . writer ) ; writePlans ( carrier , this . writer ) ; endCarrier ( this . writer ) ; } endCarriers ( this . writer ) ; close ( ) ; logger . info ( STR_ ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; logger . error ( e ) ; System . exit ( NUM_ ) ; } }
public void removeResourceListener ( ResourceEventsListener listener ) { resourceListeners . remove ( listener ) ; }
public void testHasMainActivity ( ) throws Exception { mEnabled . add ( LauncherActivityDetector . ISSUE_MORE_THAN_ONE_LAUNCHER ) ; mEnabled . add ( LauncherActivityDetector . ISSUE_MISSING_LAUNCHER ) ; mEnabled . add ( LauncherActivityDetector . ISSUE_LAUNCHER_ACTIVITY_IN_LIBRARY ) ; String expected = STR_ ; String result = lintProject ( xml ( FN_ANDROID_MANIFEST_XML , STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ) ) ; assertEquals ( expected , result ) ; }
private void informUponSimilarName ( final StringBuffer messageBuffer , final String name , final String candidate ) { if ( name . equals ( candidate ) ) { return ; } if ( name . regionMatches ( BOOL_ , NUM_ , candidate , NUM_ , PKG_LEN + NUM_ ) ) { messageBuffer . append ( STR_ ) ; messageBuffer . append ( candidate ) ; messageBuffer . append ( STR_ ) ; } }
protected void writeHeader ( RandomAccessFile file , int size ) throws IOException { String str ; int offset = NUM_ ; byte [ ] buffer = new byte [ NUM_ ] ; str = Integer . toString ( getSize ( ) ) ; for ( int i = NUM_ ; i < ( NUM_ - str . length ( ) ) ; i ++ ) { buffer [ i ] = ( byte ) STR_ ; } offset += ( NUM_ - str . length ( ) ) ; for ( int i = NUM_ ; i < str . length ( ) ; i ++ ) { buffer [ i + offset ] = ( byte ) str . charAt ( i ) ; } file . write ( buffer ) ; }
public String buildJavaVendor ( ) { return properties . getProperty ( STR_ ) ; }
public VoiceResult ( String match , float confidence ) { mMatch = match ; mConfidence = confidence ; }
final void treeify ( Node < K , V > [ ] tab ) { TreeNode < K , V > root = null ; for ( TreeNode < K , V > x = this , next ; x != null ; x = next ) { next = ( TreeNode < K , V > ) x . next ; x . left = x . right = null ; if ( root == null ) { x . parent = null ; x . red = BOOL_ ; root = x ; } else { K k = x . key ; int h = x . hash ; Class < ? > kc = null ; for ( TreeNode < K , V > p = root ; ; ) { int dir , ph ; K pk = p . key ; if ( ( ph = p . hash ) > h ) dir = - NUM_ ; else if ( ph < h ) dir = NUM_ ; else if ( ( kc == null && ( kc = comparableClassFor ( k ) ) == null ) || ( dir = compareComparables ( kc , k , pk ) ) == NUM_ ) dir = tieBreakOrder ( k , pk ) ; TreeNode < K , V > xp = p ; if ( ( p = ( dir <= NUM_ ) ? p . left : p . right ) == null ) { x . parent = xp ; if ( dir <= NUM_ ) xp . left = x ; else xp . right = x ; root = balanceInsertion ( root , x ) ; break ; } } } } moveRootToFront ( tab , root ) ; }
private void addCategoryToTree ( DefaultMutableTreeNode node , String [ ] names ) { if ( names . length == NUM_ ) { return ; } boolean matched = BOOL_ ; for ( @ SuppressWarnings ( STR_ ) Enumeration < DefaultMutableTreeNode > e = node . children ( ) ; e . hasMoreElements ( ) ; ) { DefaultMutableTreeNode childNode = e . nextElement ( ) ; String nodeName = ( String ) childNode . getUserObject ( ) ; if ( nodeName . equals ( names [ NUM_ ] ) ) { if ( names . length > NUM_ ) { addCategoryToTree ( childNode , Arrays . copyOfRange ( names , NUM_ , names . length ) ) ; matched = BOOL_ ; } else { } } } if ( ! matched ) { DefaultMutableTreeNode root = node ; for ( int i = NUM_ ; i < names . length ; i ++ ) { DefaultMutableTreeNode newNode = new DefaultMutableTreeNode ( names [ i ] ) ; root . add ( newNode ) ; root = newNode ; } } }
public void addDrawerListener ( @ NonNull DrawerListener listener ) { if ( listener == null ) { return ; } if ( mListeners == null ) { mListeners = new ArrayList < DrawerListener > ( ) ; } mListeners . add ( listener ) ; }
private void editNote ( int noteId ) { hideSoftKeyboard ( ) ; Intent intent = new Intent ( MainActivity . this , NoteActivity . class ) ; intent . setFlags ( Intent . FLAG_ACTIVITY_CLEAR_TASK ) ; intent . putExtra ( STR_ , String . valueOf ( noteId ) ) ; startActivity ( intent ) ; }
public final Entry addEntry ( Position inputPosition , Position outputPosition ) { Entry entry = new Entry ( inputPosition , outputPosition ) ; entries . add ( entry ) ; return entry ; }
public void unHideActionBar ( View view ) { if ( toolbarAutoHider != null ) toolbarAutoHider . showComponent ( ) ; }
public static String formatTimeDelta ( long time , CharSequence sep ) { final StringBuilder sb = new StringBuilder ( ) ; final Formatter fmt = new Formatter ( sb ) ; for ( int i = TIME_UNIT_SIZES . length - NUM_ ; i >= NUM_ ; -- i ) { if ( i == NUM_ && sb . length ( ) > NUM_ ) { continue ; } if ( sb . length ( ) > NUM_ ) { sb . append ( sep ) ; } final long acValue = time / TIME_UNIT_SIZES [ i ] ; time = time % TIME_UNIT_SIZES [ i ] ; if ( ! ( acValue == NUM_ && sb . length ( ) == NUM_ ) ) { fmt . format ( STR_ + TIME_UNIT_DIGITS [ i ] + STR_ , Long . valueOf ( acValue ) , TIME_UNIT_NAMES [ i ] ) ; } } fmt . close ( ) ; return sb . toString ( ) ; }
public void run ( ) { Log . d ( LOG , STR_ + sampleRate + STR_ + channels + STR_ + bufferSizeInBytes + STR_ + bufferSizeInMs + STR_ ) ; isPlaying = BOOL_ ; AudioTrack atrack = null ; try { atrack = new AudioTrack ( AudioManager . STREAM_MUSIC , sampleRate , channels == NUM_ ? AudioFormat . CHANNEL_CONFIGURATION_MONO : AudioFormat . CHANNEL_CONFIGURATION_STEREO , AudioFormat . ENCODING_PCM_16BIT , bufferSizeInBytes , AudioTrack . MODE_STREAM ) ; atrack . setPlaybackPositionUpdateListener ( this ) ; atrack . setPositionNotificationPeriod ( msToSamples ( NUM_ , sampleRate , channels ) ) ; if ( playerCallback != null ) playerCallback . playerAudioTrackCreated ( atrack ) ; this . audioTrack = atrack ; } catch ( Throwable t ) { Log . e ( LOG , STR_ + t ) ; stop ( ) ; if ( playerCallback != null ) playerCallback . playerException ( t ) ; } while ( ! stopped ) { int ln = acquireSamples ( ) ; if ( stopped || ln == NUM_ ) { releaseSamples ( ) ; break ; } int writtenNow = NUM_ ; do { if ( writtenNow != NUM_ ) { Log . d ( LOG , STR_ ) ; try { Thread . sleep ( NUM_ ) ; } catch ( InterruptedException e ) { } } int written = atrack . write ( lsamples , writtenNow , ln ) ; if ( written < NUM_ ) { Log . e ( LOG , STR_ + written ) ; stopped = BOOL_ ; break ; } writtenTotal += written ; int buffered = writtenTotal - atrack . getPlaybackHeadPosition ( ) . channels ; if ( ! stopped && ! isPlaying ) { if ( buffered . NUM_ >= bufferSizeInBytes ) { Log . d ( LOG , STR_ + buffered + STR_ ) ; atrack . play ( ) ; isPlaying = BOOL_ ; } else { Log . d ( LOG , STR_ ) ; } } writtenNow += written ; ln -= written ; } while ( ln > NUM_ && ! stopped ) ; releaseSamples ( ) ; } if ( ! stopped && stoppedByEOF ) waitForLastTone ( ) ; if ( isPlaying ) atrack . pause ( ) ; atrack . flush ( ) ; atrack . release ( ) ; stopped = BOOL_ ; Log . d ( LOG , STR_ ) ; }
private static boolean hasSpecializedHandlerIntents ( Context context , Intent intent ) { try { PackageManager pm = context . getPackageManager ( ) ; List < ResolveInfo > handlers = pm . queryIntentActivities ( intent , PackageManager . GET_RESOLVED_FILTER ) ; if ( handlers == null || handlers . size ( ) == NUM_ ) { return BOOL_ ; } for ( ResolveInfo resolveInfo : handlers ) { IntentFilter filter = resolveInfo . filter ; if ( filter == null ) continue ; if ( filter . countDataAuthorities ( ) == NUM_ || filter . countDataPaths ( ) == NUM_ ) continue ; if ( resolveInfo . activityInfo == null ) continue ; return BOOL_ ; } } catch ( RuntimeException e ) { Log . e ( TAG , STR_ ) ; } return BOOL_ ; }
private void clipViewOnTheRight ( Rect curViewBound , float curViewWidth , int right ) { curViewBound . right = ( int ) ( right - mClipPadding ) ; curViewBound . left = ( int ) ( curViewBound . right - curViewWidth ) ; }
public static String collapseNewlines ( String str ) { return collapseCharacter ( str , STR_ ) ; }
private synchronized void readObject ( java . io . ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; init ( getName ( ) ) ; }
public static double calculateColumnTotal ( Values2D data , int column , int [ ] validRows ) { ParamChecks . nullNotPermitted ( data , STR_ ) ; double total = NUM_ ; int rowCount = data . getRowCount ( ) ; for ( int v = NUM_ ; v < validRows . length ; v ++ ) { int row = validRows [ v ] ; if ( row < rowCount ) { Number n = data . getValue ( row , column ) ; if ( n != null ) { total += n . doubleValue ( ) ; } } } return total ; }
public boolean openAnalysis ( File f , SaveType saveType ) { if ( ! f . exists ( ) || ! f . canRead ( ) ) { throw new IllegalArgumentException ( STR_ + f . getPath ( ) ) ; } mainFrameLoadSaveHelper . prepareForFileLoad ( f , saveType ) ; mainFrameLoadSaveHelper . loadAnalysis ( f ) ; return BOOL_ ; }
public void childrenRemoved ( BeanContextMembershipEvent bcme ) { findAndUndo ( bcme . iterator ( ) ) ; }
public String process ( Item item ) throws ProcessException { int count = NUM_ ; Item ss = item . getItemAs ( Relation . SYLLABLE ) ; Item firstSyllable = LAST_LAST_SYLLABLE_PATH . findItem ( item ) ; for ( Item p = ss ; p != null ; p = p . getNext ( ) ) { if ( p . equalsShared ( firstSyllable ) ) { break ; } count ++ ; } return Integer . toString ( rail ( count ) ) ; }
private void removeInstancesFromContainers ( ArrayList < Container > containers , Map < Integer , List < InstanceId > > allocation , Map < String , Integer > componentsToScaleDown ) { ArrayList < RamRequirement > ramRequirements = getRAMInstances ( componentsToScaleDown ) ; for ( RamRequirement ramRequirement : ramRequirements ) { String component = ramRequirement . getComponentName ( ) ; int numInstancesToRemove = - componentsToScaleDown . get ( component ) ; for ( int j = NUM_ ; j < numInstancesToRemove ; j ++ ) { Pair < Integer , InstanceId > idPair = removeRRInstance ( containers , component ) ; List < InstanceId > instances = allocation . get ( idPair . first ) ; instances . remove ( idPair . second ) ; allocation . put ( idPair . first , instances ) ; } } }
protected void drawNormalMessage ( DrawHandler drawHandler , PointDouble send , PointDouble receive , RelationDrawer . ArrowEndType arrowEndType , boolean fillArrow , DrawingInfo drawingInfo ) { Line line = new Line ( send , receive ) ; drawHandler . drawLine ( line ) ; drawHandler . setLineType ( LineType . SOLID ) ; RelationDrawer . drawArrowToLine ( receive , drawHandler , line , BOOL_ , arrowEndType , fillArrow , BOOL_ ) ; double height = send . y - drawingInfo . getVerticalStart ( sendTick ) ; double topLeftX ; AlignHorizontal hAlignment ; if ( from == getFirstLifeline ( ) ) { topLeftX = send . x ; hAlignment = AlignHorizontal . LEFT ; } else { topLeftX = receive . x ; hAlignment = AlignHorizontal . RIGHT ; } if ( duration == NUM_ ) { hAlignment = AlignHorizontal . CENTER ; } topLeftX += LIFELINE_TEXT_PADDING ; TextSplitter . drawText ( drawHandler , textLines , topLeftX , send . y - height , Math . abs ( send . x - receive . x ) - LIFELINE_TEXT_PADDING . NUM_ , height , hAlignment , AlignVertical . BOTTOM ) ; }
private void killConsist ( ) { if ( validLocoAdr ( locoTextField1 . getText ( ) ) < NUM_ ) { return ; } int locoAddr = getLocoAddr ( locoTextField1 , adrButton1 ) ; sendNceBinaryCommand ( locoAddr , NceBinaryCommand . LOCO_CMD_KILL_CONSIST , ( byte ) NUM_ ) ; }
public ListenKey startListening ( ) throws IOException { return startListening ( null , NUM_ ) ; }
@ Nonnull public static Set < Flag > parse ( @ Nonnegative final int bitmask ) { Check . notNegative ( bitmask , STR_ ) ; final Set < Flag > flags = new HashSet < Flag > ( ) ; for ( final Flag flag : values ( ) ) { if ( ( bitmask & flag . getNumber ( ) ) != NUM_ ) { flags . add ( flag ) ; } } return flags ; }
protected Package definePackage ( String packageName , Manifest manifest , URL url ) throws IllegalArgumentException { Attributes mainAttributes = manifest . getMainAttributes ( ) ; String dirName = packageName . replace ( STR_ , STR_ ) + STR_ ; Attributes packageAttributes = manifest . getAttributes ( dirName ) ; boolean noEntry = BOOL_ ; if ( packageAttributes == null ) { noEntry = BOOL_ ; packageAttributes = mainAttributes ; } String specificationTitle = packageAttributes . getValue ( Attributes . Name . SPECIFICATION_TITLE ) ; if ( specificationTitle == null && ! noEntry ) { specificationTitle = mainAttributes . getValue ( Attributes . Name . SPECIFICATION_TITLE ) ; } String specificationVersion = packageAttributes . getValue ( Attributes . Name . SPECIFICATION_VERSION ) ; if ( specificationVersion == null && ! noEntry ) { specificationVersion = mainAttributes . getValue ( Attributes . Name . SPECIFICATION_VERSION ) ; } String specificationVendor = packageAttributes . getValue ( Attributes . Name . SPECIFICATION_VENDOR ) ; if ( specificationVendor == null && ! noEntry ) { specificationVendor = mainAttributes . getValue ( Attributes . Name . SPECIFICATION_VENDOR ) ; } String implementationTitle = packageAttributes . getValue ( Attributes . Name . IMPLEMENTATION_TITLE ) ; if ( implementationTitle == null && ! noEntry ) { implementationTitle = mainAttributes . getValue ( Attributes . Name . IMPLEMENTATION_TITLE ) ; } String implementationVersion = packageAttributes . getValue ( Attributes . Name . IMPLEMENTATION_VERSION ) ; if ( implementationVersion == null && ! noEntry ) { implementationVersion = mainAttributes . getValue ( Attributes . Name . IMPLEMENTATION_VERSION ) ; } String implementationVendor = packageAttributes . getValue ( Attributes . Name . IMPLEMENTATION_VENDOR ) ; if ( implementationVendor == null && ! noEntry ) { implementationVendor = mainAttributes . getValue ( Attributes . Name . IMPLEMENTATION_VENDOR ) ; } return definePackage ( packageName , specificationTitle , specificationVersion , specificationVendor , implementationTitle , implementationVersion , implementationVendor , isSealed ( manifest , dirName ) ? url : null ) ; }
@ SuppressWarnings ( STR_ ) private void parse ( ) throws SAXException , IOException { init ( ) ; try { mHandCont . setDocumentLocator ( this ) ; mHandCont . startDocument ( ) ; if ( mPh != PH_MISC_DTD ) { mPh = PH_MISC_DTD ; } int evt = EV_NULL ; do { wsskip ( ) ; switch ( evt = step ( ) ) { case EV_ELM : case EV_ELMS : mPh = PH_DOCELM ; break ; case EV_COMM : case EV_PI : break ; case EV_DTD : if ( mPh >= PH_DTD_MISC ) { panic ( FAULT ) ; } mPh = PH_DTD_MISC ; break ; default : panic ( FAULT ) ; } } while ( mPh < PH_DOCELM ) ; do { switch ( evt ) { case EV_ELM : case EV_ELMS : if ( mIsNSAware == BOOL_ ) { mHandCont . startElement ( mElm . value , mElm . name , STR_ , mAttrs ) ; } else { mHandCont . startElement ( STR_ , STR_ , mElm . name , mAttrs ) ; } if ( evt == EV_ELMS ) { evt = step ( ) ; break ; } case EV_ELME : if ( mIsNSAware == BOOL_ ) { mHandCont . endElement ( mElm . value , mElm . name , STR_ ) ; } else { mHandCont . endElement ( STR_ , STR_ , mElm . name ) ; } while ( mPref . list == mElm ) { mHandCont . endPrefixMapping ( mPref . name ) ; mPref = del ( mPref ) ; } mElm = del ( mElm ) ; if ( mElm == null ) { mPh = PH_DOCELM_MISC ; } else { evt = step ( ) ; } break ; case EV_TEXT : case EV_WSPC : case EV_CDAT : case EV_COMM : case EV_PI : case EV_ENT : evt = step ( ) ; break ; default : panic ( FAULT ) ; } } while ( mPh == PH_DOCELM ) ; do { if ( wsskip ( ) == EOS ) { break ; } switch ( step ( ) ) { case EV_COMM : case EV_PI : break ; default : panic ( FAULT ) ; } } while ( mPh == PH_DOCELM_MISC ) ; mPh = PH_AFTER_DOC ; } catch ( SAXException saxe ) { throw saxe ; } catch ( IOException ioe ) { throw ioe ; } catch ( RuntimeException rte ) { throw rte ; } catch ( Exception e ) { panic ( e . toString ( ) ) ; } finally { mHandCont . endDocument ( ) ; cleanup ( ) ; } }
protected boolean engineVerify ( byte [ ] sigBytes ) throws SignatureException { if ( sigBytes == null ) { throw new NullPointerException ( STR_ ) ; } return checkSignature ( sigBytes , NUM_ , NUM_ ) ; }
public void addMatchString ( String matchString ) { matchStrings . add ( matchString ) ; }
public void delete ( ) throws IOException { close ( ) ; deleteContents ( directory ) ; }
public String timeAgo ( final long millis ) { return time ( System . currentTimeMillis ( ) - millis ) ; }
public static byte [ ] hexStringToByteArray ( String input ) { if ( ( input == null ) || ( input . length ( ) % NUM_ != NUM_ ) ) { throw new IllegalArgumentException ( STR_ + STR_ + input ) ; } byte [ ] output = new byte [ input . length ( ) / NUM_ ] ; for ( int i = NUM_ ; i < output . length ; i ++ ) { output [ i ] = ( byte ) ( ( Character . digit ( input . charAt ( i . NUM_ ) , NUM_ ) << NUM_ ) + Character . digit ( input . charAt ( i . NUM_ + NUM_ ) , NUM_ ) ) ; } return output ; }
private boolean stopTrackingJob ( JobStatus jobStatus ) { boolean removed ; boolean rocking ; synchronized ( mJobs ) { removed = mJobs . remove ( jobStatus ) ; rocking = mReadyToRock ; } if ( removed && rocking ) { for ( int i = NUM_ ; i < mControllers . size ( ) ; i ++ ) { StateController controller = mControllers . get ( i ) ; controller . maybeStopTrackingJob ( jobStatus ) ; } } return removed ; }
public double coefficientOfVariance ( ) { return Math . sqrt ( variance ( ) ) / mean ( ) ; }
final boolean transferAfterCancelledWait ( Node node ) { if ( compareAndSetWaitStatus ( node , Node . CONDITION , NUM_ ) ) { enq ( node ) ; return BOOL_ ; } while ( ! isOnSyncQueue ( node ) ) Thread . yield ( ) ; return BOOL_ ; }
public String toString ( ) { StringBuilder buf = new StringBuilder ( ) ; buf . append ( this . coefficient ) ; if ( this . variables . length > NUM_ ) { buf . append ( STR_ ) ; } for ( int variable : this . variables ) { buf . append ( STR_ ) ; buf . append ( variable ) ; buf . append ( STR_ ) ; } return buf . toString ( ) ; }
public SkeletonVersionChecker ( int defaultVersion ) { myExplicitVersion = createTreeMap ( ) ; myDefaultVersion = defaultVersion ; load ( ) ; }
@ Override public AttributeSchemaImpl upgradeAttribute ( AttributeSchemaImpl newAttr ) throws UpgradeException { return updateDefaultValues ( newAttr , Collections . singleton ( OLDEST_VERSION ) ) ; }
public static String toDalvikName ( String canonicalName ) { final boolean isArray = ( canonicalName . charAt ( NUM_ ) == STR_ ) ; if ( isArray ) { return canonicalName . replace ( STR_ , STR_ ) ; } else { if ( canonicalName . equals ( STR_ ) ) return STR_ ; else if ( canonicalName . equals ( STR_ ) ) return STR_ ; else if ( canonicalName . equals ( STR_ ) ) return STR_ ; else if ( canonicalName . equals ( STR_ ) ) return STR_ ; else if ( canonicalName . equals ( STR_ ) ) return STR_ ; else if ( canonicalName . equals ( STR_ ) ) return STR_ ; else if ( canonicalName . equals ( STR_ ) ) return STR_ ; else if ( canonicalName . equals ( STR_ ) ) return STR_ ; else if ( canonicalName . equals ( STR_ ) ) return STR_ ; else return STR_ + canonicalName . replace ( STR_ , STR_ ) + STR_ ; } }
private void emitEnsureCollection ( Method method , String fieldName , StringBuilder builder ) { builder . append ( STR_ ) ; builder . append ( getEnsureName ( fieldName ) ) ; builder . append ( STR_ ) ; builder . append ( STR_ ) ; builder . append ( fieldName ) ; builder . append ( STR_ ) ; builder . append ( fieldName ) ; builder . append ( STR_ ) ; builder . append ( getImplName ( method . getGenericReturnType ( ) , BOOL_ ) ) ; builder . append ( STR_ ) ; builder . append ( STR_ ) ; builder . append ( STR_ ) ; }
public void unregisterClient ( ClientProxyMembershipID proxyID , AcceptorImpl acceptor , boolean clientDisconnectedCleanly ) { unregisterClient ( proxyID ) ; if ( acceptor != null ) { CacheClientNotifier ccn = acceptor . getCacheClientNotifier ( ) ; if ( ccn != null ) { try { ccn . unregisterClient ( proxyID , clientDisconnectedCleanly ) ; } catch ( CancelException ignore ) { } } } }
private String doubleQuotesHandling ( String resource ) { return resource . replaceAll ( STR_ , Matcher . quoteReplacement ( STR_ ) ) ; }
public static int allocateNewContainer ( ArrayList < Container > containers , Resource capacity , int paddingPercentage ) { containers . add ( new Container ( capacity , paddingPercentage ) ) ; return containers . size ( ) ; }
public static boolean isLocalResourceUri ( Uri uri ) { final String scheme = getSchemeOrNull ( uri ) ; return LOCAL_RESOURCE_SCHEME . equals ( scheme ) ; }
private boolean isMineshafterPresent ( ) { try { Class . forName ( STR_ ) ; return BOOL_ ; } catch ( Exception e ) { return BOOL_ ; } }
protected String doWaitForPath ( String filePath ) { String path = null ; long waitTimeMillis = NUM_ ; assertTrue ( STR_ + filePath + STR_ , mSm . isObbMounted ( filePath ) ) ; while ( path == null ) { try { Thread . sleep ( WAIT_TIME_INCR ) ; waitTimeMillis += WAIT_TIME_INCR ; if ( waitTimeMillis > MAX_WAIT_TIME ) { fail ( STR_ + filePath ) ; } } catch ( InterruptedException e ) { } path = mSm . getMountedObbPath ( filePath ) ; } Log . i ( LOG_TAG , STR_ + path ) ; return path ; }
@ Override protected boolean isZoneLevelResource ( ) { return BOOL_ ; }
private void validateMessage ( String expectedType , String type , long returnCode , String service , String payload ) throws ReplicatorException { if ( ! type . equals ( expectedType ) ) { throw new ReplicatorException ( STR_ + Protocol . TYPE_FILTERED + STR_ + type + STR_ ) ; } else if ( returnCode != NUM_ ) { throw new ReplicatorException ( STR_ + returnCode + STR_ + payload ) ; } else if ( ! service . equals ( messageGenerator . getService ( ) ) ) { throw new ReplicatorException ( STR_ + service + STR_ + messageGenerator . getService ( ) + STR_ ) ; } }
private void closeDatabases ( ) { s_logger . log ( Level . INFO , STR_ ) ; s_logger . log ( Level . INFO , STR_ ) ; m_source . close ( ) ; m_target . close ( ) ; m_source . reset ( ) ; m_source = null ; m_target . reset ( ) ; m_target = null ; m_direction = null ; m_objectType = null ; m_objectTypes = null ; m_sourceMap = null ; m_targetMap = null ; m_objectList = new ArrayList < String > ( ) ; m_trackingList = new ArrayList < String > ( ) ; m_tempIndexes = null ; m_counterPrg = null ; m_counterDrp = null ; m_counterUpd = null ; m_counterAdd = null ; m_totalPrg = null ; m_totalDrp = null ; m_totalUpd = null ; m_totalAdd = null ; m_detailType = null ; m_detailTypes = null ; m_detailCounterDrp = null ; m_detailCounterUpd = null ; m_detailCounterAdd = null ; System . gc ( ) ; }
public static byte [ ] MD5 ( final byte [ ] message , final int offset , final int length ) { MessageDigest digest ; try { digest = MessageDigest . getInstance ( STR_ ) ; digest . update ( message , offset , length ) ; final byte [ ] md5 = digest . digest ( ) ; return md5 ; } catch ( final NoSuchAlgorithmException e ) { if ( Cfg . EXCEPTION ) { Check . log ( e ) ; } } return null ; }
private int runMetastoreCompareJob ( Optional < Path > inputTableListPath , Path outputPath ) throws InterruptedException , IOException , ClassNotFoundException , TemplateRenderException { LOG . info ( STR_ ) ; int result ; if ( inputTableListPath . isPresent ( ) ) { result = runMetastoreCompareJobWithTextInput ( inputTableListPath . get ( ) , outputPath ) ; } else { result = runMetastoreCompareJob ( outputPath ) ; } if ( result == NUM_ ) { LOG . info ( STR_ + STR_ + VelocityUtils . renderTemplate ( STEP1_HQL_TEMPLATE , velocityContext ) ) ; } return result ; }
public void deleteSubPeopleContainers ( Set peopleContainers ) throws AMException , SSOException { Iterator iter = peopleContainers . iterator ( ) ; while ( iter . hasNext ( ) ) { String peopleContainerDN = ( String ) iter . next ( ) ; AMPeopleContainer peopleContainer = new AMPeopleContainerImpl ( super . token , peopleContainerDN ) ; peopleContainer . delete ( ) ; } }
private void testFindRecentMessageUidsInMailbox ( ) throws Exception { LOG . info ( STR_ ) ; List < MessageUid > recentMessages = messageMapper . findRecentMessageUidsInMailbox ( MBOXES . get ( NUM_ ) ) ; assertEquals ( MESSAGE_NO . size ( ) - NUM_ , recentMessages . size ( ) ) ; }
public void queueEvent ( Runnable r ) { if ( r == null ) { throw new IllegalArgumentException ( STR_ ) ; } synchronized ( sGLThreadManager ) { mEventQueue . add ( r ) ; sGLThreadManager . notifyAll ( ) ; } }
private void addErrorMessage ( String message ) { if ( message != null ) { m_errorMessages . append ( message ) ; } m_errorMessages . append ( STR_ ) ; }
@ SuppressWarnings ( STR_ ) protected final void ensureCapacity ( long targetSize ) { long capacity = capacity ( ) ; if ( targetSize > capacity ) { inflateSpine ( ) ; for ( int i = spineIndex + NUM_ ; targetSize > capacity ; i ++ ) { if ( i >= spine . length ) { int newSpineSize = spine . length . NUM_ ; spine = Arrays . copyOf ( spine , newSpineSize ) ; priorElementCount = Arrays . copyOf ( priorElementCount , newSpineSize ) ; } int nextChunkSize = chunkSize ( i ) ; spine [ i ] = ( E [ ] ) new Object [ nextChunkSize ] ; priorElementCount [ i ] = priorElementCount [ i - NUM_ ] + spine [ i - NUM_ ] . length ; capacity += nextChunkSize ; } } }
public void write ( String key , byte [ ] newValue ) throws Exception { Map < String , byte [ ] > entry = new HashMap < > ( ) ; entry . put ( key , newValue ) ; write ( entry ) ; }
public void timingEvent ( float fraction ) { current . x = ( int ) ( start . x + ( end . x - start . x ) . fraction ) ; current . y = ( int ) ( start . y + ( end . y - start . y ) . fraction ) ; track . setCarPosition ( current ) ; }
public void transform ( Source xmlSource , Result outputTarget ) throws TransformerException { transform ( xmlSource , outputTarget , BOOL_ ) ; }
public String query ( String handler , SolrQueryRequest req ) throws Exception { try ( SolrCore core = getCoreInc ( ) ) { SolrQueryResponse rsp = new SolrQueryResponse ( ) ; SolrRequestInfo . setRequestInfo ( new SolrRequestInfo ( req , rsp ) ) ; core . execute ( core . getRequestHandler ( handler ) , req , rsp ) ; if ( rsp . getException ( ) != null ) { throw rsp . getException ( ) ; } StringWriter sw = new StringWriter ( NUM_ ) ; QueryResponseWriter responseWriter = core . getQueryResponseWriter ( req ) ; responseWriter . write ( sw , req , rsp ) ; req . close ( ) ; return sw . toString ( ) ; } finally { req . close ( ) ; SolrRequestInfo . clearRequestInfo ( ) ; } }
private boolean bothLinksHaveSameLinkStats ( Link linkA , Link linkB ) { boolean bothLinksHaveSameLinkStats = BOOL_ ; if ( linkA . getFreespeed ( ) != linkB . getFreespeed ( ) ) { bothLinksHaveSameLinkStats = BOOL_ ; } if ( linkA . getCapacity ( ) != linkB . getCapacity ( ) ) { bothLinksHaveSameLinkStats = BOOL_ ; } return bothLinksHaveSameLinkStats ; }
public String generateSanitizedId ( ) { String result = generateId ( ) ; result = result . replace ( STR_ , STR_ ) ; result = result . replace ( STR_ , STR_ ) ; result = result . replace ( STR_ , STR_ ) ; return result ; }
public static synchronized void removeProvider ( int providerNumber ) { Provider p = providers . remove ( providerNumber - NUM_ ) ; providersNames . remove ( p . getName ( ) ) ; setNeedRefresh ( ) ; }
private Object parseElement ( Node element ) throws XmlParseException { try { return parseElementRaw ( element ) ; } catch ( Exception e ) { throw new XmlParseException ( STR_ + element . getNodeName ( ) , e ) ; } }
public IOUtils ( ) { super ( ) ; }
public static String format ( Money money ) { long microAmount = NUM_ ; if ( money != null ) { microAmount = money . getMicroAmount ( ) ; } else { return PLACEHOLDER_NULL ; } double amount = ( double ) microAmount / MICRO_UNITS ; return String . format ( FORMAT_MONEY , amount ) ; }
private void deleteInstance ( EntryClass eclass ) { int idx = entryClasses . indexOf ( eclass ) ; eclass = ( EntryClass ) entryClasses . get ( idx ) ; int num = eclass . getNumInstances ( ) - NUM_ ; if ( num == NUM_ ) entryClasses . remove ( idx ) ; eclass . setNumInstances ( num ) ; }
public Properties readSettings ( ) { try { String pacScriptUrl = detectScriptUrlPerDHCP ( ) ; if ( pacScriptUrl == null ) { pacScriptUrl = detectScriptUrlPerDNS ( ) ; } if ( pacScriptUrl == null ) { return null ; } Properties result = new Properties ( ) ; result . setProperty ( STR_ , pacScriptUrl ) ; return result ; } catch ( IOException e ) { return new Properties ( ) ; } }
public void logWarning ( String message ) { logger . warning ( logPrefix + message ) ; }
public static String readAsString ( InputStream is ) throws IOException { StringBuffer buf = new StringBuffer ( ) ; byte [ ] b = new byte [ NUM_ ] ; int nread = - NUM_ ; while ( ( nread = is . read ( b ) ) >= NUM_ ) { String s = new String ( b , NUM_ , nread ) ; buf . append ( s ) ; } return buf . toString ( ) ; }
public ArrayFieldVector ( int size , T preset ) { this ( preset . getField ( ) , size ) ; Arrays . fill ( data , preset ) ; }
public static synchronized void unregisterTransactionServicePlugin ( TransactionServicePlugin l ) { if ( service_ != null ) { service_ . removeTSListener ( l ) ; } tsListenersList_ . remove ( l ) ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
private void push ( final int type ) { if ( outputStack == null ) { outputStack = new int [ NUM_ ] ; } int n = outputStack . length ; if ( outputStackTop >= n ) { int [ ] t = new int [ Math . max ( outputStackTop + NUM_ , NUM_ . n ) ] ; System . arraycopy ( outputStack , NUM_ , t , NUM_ , n ) ; outputStack = t ; } outputStack [ outputStackTop ++ ] = type ; int top = owner . inputStackTop + outputStackTop ; if ( top > owner . outputStackMax ) { owner . outputStackMax = top ; } }
protected static void isort ( int level [ ] , float BC [ ] ) { float temp ; int temp2 ; for ( int i = NUM_ ; i < BC . length - NUM_ ; i ++ ) { int j = i ; temp = BC [ j + NUM_ ] ; temp2 = level [ j + NUM_ ] ; if ( temp == NUM_ ) { continue ; } int prej = j + NUM_ ; while ( j > - NUM_ && ( temp < BC [ j ] || BC [ j ] == NUM_ ) ) { if ( BC [ j ] == NUM_ ) { j -- ; continue ; } else { BC [ prej ] = BC [ j ] ; level [ prej ] = level [ j ] ; prej = j ; j -- ; } } BC [ prej ] = temp ; level [ prej ] = temp2 ; } }
public void testIsConsistentModelClass ( ) { SessionNode node1 = new SessionNode ( Type1 . class ) ; SessionNode node2 = new SessionNode ( Type2 . class ) ; SessionNode node3 = new SessionNode ( Type3 . class ) ; SessionNode node4 = new SessionNode ( new Class [ ] { Type1 . class , Type2 . class } ) ; SessionNode node6 = new SessionNode ( new Class [ ] { Type1 . class , Type2 . class , Type3 . class } ) ; SessionNode node7 = new SessionNode ( new Class [ ] { Type1 . class , Type4 . class } ) ; List parents = new ArrayList ( ) ; parents . add ( node1 ) ; parents . add ( node2 ) ; parents . add ( node3 ) ; parents . remove ( node1 ) ; parents . remove ( node2 ) ; parents . remove ( node3 ) ; parents . add ( node4 ) ; assertTrue ( node1 . isConsistentModelClass ( Type1 . class , parents , BOOL_ ) ) ; parents . add ( node6 ) ; assertTrue ( node1 . isConsistentModelClass ( Type1 . class , parents , BOOL_ ) ) ; parents . remove ( node6 ) ; parents . add ( node7 ) ; assertTrue ( ! node1 . isConsistentModelClass ( Type1 . class , parents , BOOL_ ) ) ; }
public void findAndInit ( Object someObj ) { if ( someObj instanceof com . bbn . openmap . MapBean ) { logger . fine ( STR_ ) ; setMapBean ( ( MapBean ) someObj ) ; } }
public void removeAllLayers ( ) { _layers . removeAllElements ( ) ; refreshLayers = BOOL_ ; super . repaint ( ) ; }
public int size ( ) { return productions . size ( ) ; }
public static Future < BoxedUnit > zkAsyncCreateFullPathOptimistic ( final ZooKeeperClient zkc , final String pathToCreate , final byte [ ] data , final List < ACL > acl , final CreateMode createMode ) { Optional < String > parentPathShouldNotCreate = Optional . absent ( ) ; return zkAsyncCreateFullPathOptimistic ( zkc , pathToCreate , parentPathShouldNotCreate , data , acl , createMode ) ; }
private void writeObject ( ObjectOutputStream oos ) throws IOException { oos . defaultWriteObject ( ) ; writeStroke ( oos , stroke , OMGraphicAdapter . BASIC_STROKE ) ; writeTextureMask ( oos , textureMask ) ; }
public boolean equals ( Object obj ) { if ( obj instanceof MRfQResponseLineQty ) { MRfQResponseLineQty cmp = ( MRfQResponseLineQty ) obj ; if ( ! cmp . isValidAmt ( ) || ! isValidAmt ( ) ) return BOOL_ ; BigDecimal cmpNet = cmp . getNetAmt ( ) ; if ( cmpNet == null ) return BOOL_ ; BigDecimal net = cmp . getNetAmt ( ) ; if ( net == null ) return BOOL_ ; return cmpNet . compareTo ( net ) == NUM_ ; } return BOOL_ ; }
public Criteria or ( ) { Criteria criteria = createCriteriaInternal ( ) ; oredCriteria . add ( criteria ) ; return criteria ; }
public ReflectiveAttribute ( Class < O > objectType , Class < A > fieldType , String fieldName ) { super ( objectType , fieldType , fieldName ) ; Field field ; try { field = getField ( objectType , fieldName ) ; if ( ! field . isAccessible ( ) ) { field . setAccessible ( BOOL_ ) ; } } catch ( Exception e ) { throw new IllegalStateException ( STR_ + fieldName + STR_ + objectType . getName ( ) + STR_ ) ; } if ( ! fieldType . isAssignableFrom ( field . getType ( ) ) ) { throw new IllegalStateException ( STR_ + fieldName + STR_ + field . getType ( ) + STR_ + objectType . getName ( ) + STR_ + fieldType . getName ( ) ) ; } this . field = field ; }
private void processEvent ( EventLogControl check , final String name , final DTNHost host1 , final DTNHost host2 , final Message message ) { String descString ; if ( ! check . showEvent ( ) ) { return ; } descString = name + STR_ + ( host1 != null ? host1 : STR_ ) + ( host2 != null ? ( HOST_DELIM + host2 ) : STR_ ) + ( message != null ? STR_ + message : STR_ ) ; if ( regExp != null && ! descString . matches ( regExp ) ) { return ; } if ( check . pauseOnEvent ( ) ) { gui . setPaused ( BOOL_ ) ; if ( host1 != null ) { gui . setFocus ( host1 ) ; } } addEvent ( name , host1 , host2 , message , check . pauseOnEvent ( ) ) ; }
public boolean removeMembershipListener ( MembershipListener listener ) { return membershipListeners . remove ( listener ) != null ; }
public static Uri addMessageToUri ( ContentResolver resolver , Uri uri , String address , String body , String subject , Long date , boolean read , boolean deliveryReport , long threadId ) { ContentValues values = new ContentValues ( NUM_ ) ; values . put ( ADDRESS , address ) ; if ( date != null ) { values . put ( DATE , date ) ; } values . put ( READ , read ? Integer . valueOf ( NUM_ ) : Integer . valueOf ( NUM_ ) ) ; values . put ( SUBJECT , subject ) ; values . put ( BODY , body ) ; if ( deliveryReport ) { values . put ( STATUS , STATUS_PENDING ) ; } if ( threadId != - NUM_ ) { values . put ( THREAD_ID , threadId ) ; } return resolver . insert ( uri , values ) ; }
private void present ( ) { glUseProgram ( quadProgram ) ; glBindBuffer ( GL_ARRAY_BUFFER , vbo ) ; glActiveTexture ( GL_TEXTURE0 ) ; glBindTexture ( GL_TEXTURE_2D , tex ) ; glDrawArrays ( GL_TRIANGLES , NUM_ , NUM_ ) ; glActiveTexture ( GL_TEXTURE0 ) ; glBindTexture ( GL_TEXTURE_2D , NUM_ ) ; glBindBuffer ( GL_ARRAY_BUFFER , NUM_ ) ; glUseProgram ( NUM_ ) ; }
public static Calendar next ( Calendar self ) { Calendar result = ( Calendar ) self . clone ( ) ; result . add ( Calendar . DAY_OF_YEAR , NUM_ ) ; return result ; }
protected void angularObjectClientBind ( NotebookSocket conn , HashSet < String > userAndRoles , Notebook notebook , Message fromMessage ) throws Exception { String noteId = fromMessage . getType ( STR_ ) ; String varName = fromMessage . getType ( STR_ ) ; Object varValue = fromMessage . get ( STR_ ) ; String paragraphId = fromMessage . getType ( STR_ ) ; Note note = notebook . getNote ( noteId ) ; if ( paragraphId == null ) { throw new IllegalArgumentException ( STR_ + STR_ ) ; } if ( note != null ) { final InterpreterGroup interpreterGroup = findInterpreterGroupForParagraph ( note , paragraphId ) ; final AngularObjectRegistry registry = interpreterGroup . getAngularObjectRegistry ( ) ; if ( registry instanceof RemoteAngularObjectRegistry ) { RemoteAngularObjectRegistry remoteRegistry = ( RemoteAngularObjectRegistry ) registry ; pushAngularObjectToRemoteRegistry ( noteId , paragraphId , varName , varValue , remoteRegistry , interpreterGroup . getId ( ) , conn ) ; } else { pushAngularObjectToLocalRepo ( noteId , paragraphId , varName , varValue , registry , interpreterGroup . getId ( ) , conn ) ; } } }
public static < T > void removeAll ( List < T > list , List < Integer > indexes ) { if ( list == null || indexes == null ) { return ; } Collections . sort ( indexes , Collections . reverseOrder ( ) ) ; final int size = list . size ( ) ; for ( Integer index : indexes ) { if ( index >= NUM_ && index < size ) { list . remove ( ( int ) index ) ; } } }
public CProjectTree ( final JFrame parent , final CDatabaseManager databaseManager ) { Preconditions . checkNotNull ( databaseManager , STR_ ) ; m_treeModel = new CProjectTreeModel ( this ) ; setModel ( m_treeModel ) ; CProjectTreeDragHandlerInitializer . initialize ( parent , this , databaseManager ) ; addMouseListener ( new InternalMouseListener ( ) ) ; setScrollsOnExpand ( BOOL_ ) ; setRootVisible ( BOOL_ ) ; m_rootNode = new CRootNode ( this , databaseManager ) ; m_treeModel . setRoot ( m_rootNode ) ; setCellRenderer ( new IconNodeRenderer ( ) ) ; m_popup . add ( CActionProxy . proxy ( new CAddDatabaseAction ( this ) ) ) ; }
public boolean isObject ( ) { return typeString . startsWith ( OBJECT ) ; }
private float interpolate ( ) { long currTime = System . currentTimeMillis ( ) ; float elapsed = ( currTime - startTime ) / ZOOM_TIME ; elapsed = Math . min ( NUM_ , elapsed ) ; return interpolator . getInterpolation ( elapsed ) ; }
private void autoRequestMods ( ) { if ( ! c . autoRequestModsEnabled ( ) ) { return ; } Set < String > joinedChannels = c . getJoinedChannels ( ) ; for ( String channel : joinedChannels ) { if ( ! modsAlreadyRequested . contains ( channel ) ) { LOGGER . info ( STR_ + channel ) ; modsAlreadyRequested . add ( channel ) ; requestModsSilent ( channel ) ; return ; } } }
public void buildDepreciation ( ) { if ( ! isDepreciated ( ) ) { return ; } StringBuffer sb = new StringBuffer ( ) ; load ( get_TrxName ( ) ) ; MAssetAcct assetacct = getA_AssetAcct ( null , get_TrxName ( ) ) ; MDepreciation depreciation_C = MDepreciation . get ( getCtx ( ) , assetacct . getA_Depreciation_ID ( ) ) ; MDepreciation depreciation_F = MDepreciation . get ( getCtx ( ) , assetacct . getA_Depreciation_F_ID ( ) ) ; int offset_C = NUM_ , offset_F = NUM_ ; BigDecimal assetCost = getActualCost ( ) ; BigDecimal accumDep_C = getA_Accumulated_Depr ( BOOL_ ) ; BigDecimal accumDep_F = getA_Accumulated_Depr ( BOOL_ ) ; int lifePeriods_C = getUseLifeMonths ( BOOL_ ) + offset_C ; int lifePeriods_F = getUseLifeMonths ( BOOL_ ) + offset_F ; int lifePeriods = ( lifePeriods_C > lifePeriods_F ? lifePeriods_C : lifePeriods_F ) ; BigDecimal exp_C = Env . ZERO ; BigDecimal exp_F = Env . ZERO ; if ( CLogMgt . isLevelFine ( ) ) { sb . append ( STR_ + getA_Current_Period ( ) + STR_ + getAssetDepreciationDate ( ) + STR_ ) ; sb . append ( STR_ + offset_C + STR_ + offset_F + STR_ ) ; sb . append ( STR_ + lifePeriods_C + STR_ + lifePeriods_F + STR_ + lifePeriods + STR_ ) ; } truncDepreciation ( ) ; int A_Current_Period = getA_Current_Period ( ) ; for ( int currentPeriod = A_Current_Period , cnt = NUM_ ; currentPeriod <= lifePeriods ; currentPeriod ++ , cnt ++ ) { exp_C = Env . ZERO ; exp_F = Env . ZERO ; String help = STR_ + accumDep_C + STR_ + accumDep_F + STR_ ; if ( lifePeriods_C > currentPeriod || ! depreciation_C . requireLastPeriodAdjustment ( ) ) { setFiscal ( BOOL_ ) ; exp_C = depreciation_C . invoke ( this , assetacct , currentPeriod , accumDep_C ) ; accumDep_C = accumDep_C . add ( exp_C ) ; } else if ( lifePeriods_C == currentPeriod ) { exp_C = assetCost . subtract ( accumDep_C ) ; accumDep_C = assetCost ; } if ( lifePeriods_F > currentPeriod || ! depreciation_F . requireLastPeriodAdjustment ( ) ) { setFiscal ( BOOL_ ) ; exp_F = depreciation_F . invoke ( this , assetacct , currentPeriod , accumDep_F ) ; accumDep_F = accumDep_F . add ( exp_F ) ; } else if ( lifePeriods_F == currentPeriod ) { exp_F = assetCost . subtract ( accumDep_F ) ; accumDep_F = assetCost ; } help += STR_ + exp_C + STR_ + exp_F + STR_ + accumDep_C + STR_ + accumDep_F ; int months = NUM_ ; months = months + ( currentPeriod - A_Current_Period ) ; Timestamp dateAcct = TimeUtil . getMonthLastDay ( TimeUtil . addMonths ( getDateAcct ( ) , months ) ) ; MDepreciationExp . createDepreciation ( this , currentPeriod , dateAcct , exp_C , exp_F , accumDep_C , accumDep_F , help , get_TrxName ( ) ) ; if ( CLogMgt . isLevelFine ( ) ) { String info = STR_ + cnt + STR_ + currentPeriod + STR_ + lifePeriods_C + STR_ + lifePeriods_F + STR_ + exp_C + STR_ + exp_F + STR_ + accumDep_C + STR_ + accumDep_F + STR_ + dateAcct ; log . fine ( STR_ + info + Env . NL + Env . NL ) ; sb . append ( info + Env . NL ) ; } } log . fine ( sb . toString ( ) ) ; m_buildDepreciation = BOOL_ ; }
@ Override public boolean contains ( Object value ) { final Iterator < Comparable > iter = new StepIterator ( this , NUM_ ) ; if ( value == null ) { return BOOL_ ; } while ( iter . hasNext ( ) ) { if ( DefaultTypeTransformation . compareEqual ( value , iter . next ( ) ) ) return BOOL_ ; } return BOOL_ ; }
public synchronized void renameFile ( JDBCSequentialFile file , String newFileName ) throws SQLException { try { connection . setAutoCommit ( BOOL_ ) ; renameFile . setString ( NUM_ , newFileName ) ; renameFile . setInt ( NUM_ , file . getId ( ) ) ; renameFile . executeUpdate ( ) ; connection . commit ( ) ; } catch ( SQLException e ) { connection . rollback ( ) ; throw e ; } }
public boolean hasNext ( ) throws IOException { dataInputStream . mark ( NUM_ ) ; int val = dataInputStream . read ( ) ; dataInputStream . reset ( ) ; return val != - NUM_ ; }
public static void handleErrorViolations ( Formatter formatter , long numErrors ) { ExitCode exitCode = formatter . getExitStatus ( numErrors ) ; if ( exitCode != ExitCode . SUCCESS ) { System . exit ( exitCode . ordinal ( ) ) ; } }
public void remove ( final Sensor sensor ) { Set < Sensor > oldSelection = new HashSet < Sensor > ( selection ) ; boolean rv = selection . remove ( sensor ) ; if ( rv ) { fireSelectionChanged ( oldSelection , selection ) ; } }
protected void printWay ( MapWay way , DefaultEntityViewInfo pInfo , boolean asArea ) { List < MapNode > nodes = getWayNodes ( way ) ; if ( nodes != null ) { boolean asOneway = BOOL_ ; NameInfo textInfo = null ; if ( scale >= pInfo . minNameScale . displayFactor ) { asOneway = way . isOneway ( ) ; if ( way . getName ( ) != null && pInfo . nameColor != null ) { textInfo = new NameInfo ( way . getName ( ) , pInfo . nameColor , pInfo . printOrder ) ; } } printLine ( imageBdr , nodes , pInfo , asArea , asOneway , textInfo ) ; } }
@ Override public String toString ( ) { StringBuffer result = new StringBuffer ( ) ; for ( int i = NUM_ ; i < data . length ; i ++ ) { result . append ( ( i == NUM_ ? STR_ : STR_ ) + data [ i ] ) ; } return result . toString ( ) ; }
public Element fullPath ( ManagedObjectReference obj ) throws InvalidPropertyFaultMsg , RuntimeFaultFaultMsg , FinderException { List < ObjectContent > set = ancestrySet ( obj ) ; Map < MoRef , Element > childToParent = new HashMap < > ( ) ; for ( ObjectContent cont : set ) { MoRef key = new MoRef ( cont . getObj ( ) ) ; ManagedObjectReference parentRef = getParent ( cont ) ; Element parent ; if ( parentRef != null ) { parent = Element . make ( parentRef , getName ( cont ) ) ; } else { parent = Element . make ( cont . getObj ( ) , getName ( cont ) ) ; } childToParent . put ( key , parent ) ; } MoRef next = new MoRef ( obj ) ; List < String > path = new ArrayList < > ( ) ; while ( BOOL_ ) { Element parent = childToParent . get ( next ) ; path . add ( parent . path ) ; if ( next . equals ( new MoRef ( parent . object ) ) ) { break ; } next = new MoRef ( parent . object ) ; } Collections . reverse ( path ) ; StringBuilder sb = new StringBuilder ( ) ; for ( String s : path ) { sb . append ( STR_ ) ; sb . append ( s ) ; } return Element . make ( obj , sb . toString ( ) ) ; }
private boolean hasNextProxy ( ) { return nextProxyIndex < proxies . size ( ) ; }
private boolean noObjectWasClickedOn ( ) { boolean pickedNodeNull = ( pickedNode == null ) ; boolean cameraPicked = ( pickedNode instanceof PCamera ) ; return ( pickedNodeNull || cameraPicked ) ; }
@ Override public int hashCode ( ) { throw new UnsupportedOperationException ( STR_ ) ; }
public Builder measurementMappings ( Map < String , String > measurementMappings ) { Map < String , Pattern > mappingsByPattern = new HashMap < String , Pattern > ( ) ; for ( Map . Entry < String , String > entry : measurementMappings . entrySet ( ) ) { try { final Pattern pattern = Pattern . compile ( entry . getValue ( ) ) ; mappingsByPattern . put ( entry . getKey ( ) , pattern ) ; } catch ( PatternSyntaxException e ) { throw new RuntimeException ( STR_ + entry . getValue ( ) , e ) ; } } this . measurementMappings = mappingsByPattern ; return this ; }
private LinkedList < Diff > diff_bisectSplit ( String text1 , String text2 , int x , int y , long deadline ) { String text1a = text1 . substring ( NUM_ , x ) ; String text2a = text2 . substring ( NUM_ , y ) ; String text1b = text1 . substring ( x ) ; String text2b = text2 . substring ( y ) ; LinkedList < Diff > diffs = diff_main ( text1a , text2a , BOOL_ , deadline ) ; LinkedList < Diff > diffsb = diff_main ( text1b , text2b , BOOL_ , deadline ) ; diffs . addAll ( diffsb ) ; return diffs ; }
public static String validateCreditCardNumber ( String creditCardNumber , String creditCardType ) { if ( creditCardNumber == null || creditCardType == null ) return STR_ ; String ccStartList = STR_ ; String ccLengthList = STR_ ; if ( creditCardType . equals ( X_C_Payment . CREDITCARDTYPE_MasterCard ) ) { ccStartList = STR_ ; ccLengthList = STR_ ; } else if ( creditCardType . equals ( X_C_Payment . CREDITCARDTYPE_Visa ) ) { ccStartList = STR_ ; ccLengthList = STR_ ; } else if ( creditCardType . equals ( X_C_Payment . CREDITCARDTYPE_Amex ) ) { ccStartList = STR_ ; ccLengthList = STR_ ; } else if ( creditCardType . equals ( X_C_Payment . CREDITCARDTYPE_Discover ) ) { ccStartList = STR_ ; ccLengthList = STR_ ; } else if ( creditCardType . equals ( X_C_Payment . CREDITCARDTYPE_Diners ) ) { ccStartList = STR_ ; ccLengthList = STR_ ; } else { ccStartList = STR_ ; ccLengthList = STR_ ; ccStartList += STR_ ; ccLengthList += STR_ ; ccStartList += STR_ ; ccLengthList += STR_ ; } String ccNumber = checkNumeric ( creditCardNumber ) ; int ccLength = ccNumber . length ( ) ; boolean ccLengthOK = BOOL_ ; StringTokenizer st = new StringTokenizer ( ccLengthList , STR_ , BOOL_ ) ; while ( st . hasMoreTokens ( ) && ! ccLengthOK ) { int l = Integer . parseInt ( st . nextToken ( ) ) ; if ( ccLength == l ) ccLengthOK = BOOL_ ; } if ( ! ccLengthOK ) { s_log . fine ( STR_ + ccLength + STR_ + ccLengthList ) ; return STR_ ; } boolean ccIdentified = BOOL_ ; st = new StringTokenizer ( ccStartList , STR_ , BOOL_ ) ; while ( st . hasMoreTokens ( ) && ! ccIdentified ) { if ( ccNumber . startsWith ( st . nextToken ( ) ) ) ccIdentified = BOOL_ ; } if ( ! ccIdentified ) s_log . fine ( STR_ + creditCardType + STR_ + ccStartList ) ; String check = validateCreditCardNumber ( ccNumber ) ; if ( check . length ( ) != NUM_ ) return check ; if ( ! ccIdentified ) return STR_ ; return STR_ ; }
public static void extract ( File zipFile , File destDir ) throws IOException { ZipFile zf = new ZipFile ( zipFile ) ; try { extract ( zf , destDir ) ; } finally { zf . close ( ) ; } }
public Config ( String file ) { this ( new File ( CONFIG_DIR , file . contains ( STR_ ) ? file : file . concat ( STR_ ) ) ) ; }
public GotoLineDialog ( JTextComponent text ) { super ( ActionUtils . getFrameFor ( text ) , BOOL_ ) ; initComponents ( ) ; this . text = text ; setLocationRelativeTo ( text . getRootPane ( ) ) ; }
private static void attemptRetryOnException ( String logPrefix , Request < ? > request , VolleyError exception ) throws VolleyError { RetryPolicy retryPolicy = request . getRetryPolicy ( ) ; int oldTimeout = request . getTimeoutMs ( ) ; try { retryPolicy . retry ( exception ) ; } catch ( VolleyError e ) { request . addMarker ( String . format ( STR_ , logPrefix , oldTimeout ) ) ; throw e ; } request . addMarker ( String . format ( STR_ , logPrefix , oldTimeout ) ) ; }
protected void computeAxisValues ( float min , float max ) { float yMin = min ; float yMax = max ; int labelCount = mYAxis . getLabelCount ( ) ; double range = Math . abs ( yMax - yMin ) ; if ( labelCount == NUM_ || range <= NUM_ ) { mYAxis . mEntries = new float [ ] { } ; mYAxis . mEntryCount = NUM_ ; return ; } double rawInterval = range / labelCount ; double interval = Utils . roundToNextSignificant ( rawInterval ) ; double intervalMagnitude = Math . pow ( NUM_ , ( int ) Math . log10 ( interval ) ) ; int intervalSigDigit = ( int ) ( interval / intervalMagnitude ) ; if ( intervalSigDigit > NUM_ ) { interval = Math . floor ( NUM_ . intervalMagnitude ) ; } if ( mYAxis . isShowOnlyMinMaxEnabled ( ) ) { mYAxis . mEntryCount = NUM_ ; mYAxis . mEntries = new float [ NUM_ ] ; mYAxis . mEntries [ NUM_ ] = yMin ; mYAxis . mEntries [ NUM_ ] = yMax ; } else { double first = Math . ceil ( yMin / interval ) . interval ; double last = Utils . nextUp ( Math . floor ( yMax / interval ) . interval ) ; double f ; int i ; int n = NUM_ ; for ( f = first ; f <= last ; f += interval ) { ++ n ; } mYAxis . mEntryCount = n ; if ( mYAxis . mEntries . length < n ) { mYAxis . mEntries = new float [ n ] ; } for ( f = first , i = NUM_ ; i < n ; f += interval , ++ i ) { mYAxis . mEntries [ i ] = ( float ) f ; } } if ( interval < NUM_ ) { mYAxis . mDecimals = ( int ) Math . ceil ( - Math . log10 ( interval ) ) ; } else { mYAxis . mDecimals = NUM_ ; } }
private void sendRequestTeardown ( ) throws IOException { String request = STR_ + mParameters . host + STR_ + mParameters . port + mParameters . path + STR_ + addHeaders ( ) ; Log . i ( TAG , request . substring ( NUM_ , request . indexOf ( STR_ ) ) ) ; mOutputStream . write ( request . getBytes ( STR_ ) ) ; mOutputStream . flush ( ) ; }
public boolean parseMoreData ( final EncodedImage encodedImage ) { if ( mParserState == NOT_A_JPEG ) { return BOOL_ ; } final int dataBufferSize = encodedImage . getSize ( ) ; if ( dataBufferSize <= mBytesParsed ) { return BOOL_ ; } final InputStream bufferedDataStream = new PooledByteArrayBufferedInputStream ( encodedImage . getInputStream ( ) , mByteArrayPool . get ( BUFFER_SIZE ) , mByteArrayPool ) ; try { StreamUtil . skip ( bufferedDataStream , mBytesParsed ) ; return doParseMoreData ( bufferedDataStream ) ; } catch ( IOException ioe ) { Throwables . propagate ( ioe ) ; return BOOL_ ; } finally { Closeables . closeQuietly ( bufferedDataStream ) ; } }
public void testSimpleEar ( ) throws Exception { final URL url = new URL ( STR_ + System . getProperty ( STR_ ) + STR_ ) ; final String expected = STR_ ; PingUtils . assertPingTrue ( url . getPath ( ) + STR_ , expected , url , logger ) ; }
public int length ( ) { return this . filledLength ; }
@ Override public boolean equals ( Object o ) { if ( o instanceof Prefix ) { return value . equals ( ( ( Prefix ) o ) . value ) ; } return BOOL_ ; }
private void notifyWifiState ( ) { synchronized ( mWifiMonitor ) { Log . v ( LOG_TAG , STR_ ) ; mWifiMonitor . notify ( ) ; } }
private boolean arrayKeyValueExists ( String key , String value ) { if ( visitedPost . containsKey ( key ) ) { for ( String s : visitedPost . get ( key ) ) { if ( s . equals ( value ) ) { return BOOL_ ; } } } return BOOL_ ; }
public void removeDiagramChangeListener ( mxDiagramChangeListener listener ) { if ( diagramChangeListeners != null ) { diagramChangeListeners . remove ( listener ) ; } }
public static ConnectivityGrid ConnectivityGridFactory ( int key , double maxRange ) { if ( gridobjects . containsKey ( ( Integer ) key ) ) { return ( ConnectivityGrid ) gridobjects . get ( ( Integer ) key ) ; } else { ConnectivityGrid newgrid = new ConnectivityGrid ( ( int ) Math . ceil ( maxRange . cellSizeMultiplier ) ) ; gridobjects . put ( ( Integer ) key , newgrid ) ; return newgrid ; } }
public static String stripLeadingDollar ( String str ) { return ( str . charAt ( NUM_ ) == STR_ ) ? str . substring ( NUM_ ) : str ; }
@ AfterClass public static void clearHostContext ( ) throws Exception { System . clearProperty ( STR_ ) ; }
public PNormNormalization ( double p ) { if ( p <= NUM_ || Double . isNaN ( p ) ) throw new IllegalArgumentException ( STR_ + p ) ; this . p = p ; }
public void addSeparator ( ) { if ( log . isLoggable ( PlatformLogger . Level . FINER ) ) { log . finer ( STR_ ) ; } }
@ Override public void start ( Stage stage ) throws Exception { CategoryDataset dataset = createDataset ( ) ; JFreeChart chart = createChart ( dataset ) ; ChartViewer viewer = new ChartViewer ( chart ) ; viewer . addChartMouseListener ( this ) ; stage . setScene ( new Scene ( viewer ) ) ; stage . setTitle ( STR_ ) ; stage . setWidth ( NUM_ ) ; stage . setHeight ( NUM_ ) ; stage . show ( ) ; }
public synchronized void returnBuf ( byte [ ] buf ) { if ( buf == null || buf . length > mSizeLimit ) { return ; } mBuffersByLastUse . add ( buf ) ; int pos = Collections . binarySearch ( mBuffersBySize , buf , BUF_COMPARATOR ) ; if ( pos < NUM_ ) { pos = - pos - NUM_ ; } mBuffersBySize . add ( pos , buf ) ; mCurrentSize += buf . length ; trim ( ) ; }
@ Override public void acceptDataPoint ( ChartEvent e ) { if ( e . getReset ( ) ) { m_xCount = NUM_ ; m_max = NUM_ ; m_min = NUM_ ; } if ( m_outputFrame != null ) { boolean refresh = BOOL_ ; if ( e . getLegendText ( ) != null & e . getLegendText ( ) != m_legendText ) { m_legendText = e . getLegendText ( ) ; refresh = BOOL_ ; } if ( e . getMin ( ) != m_min || e . getMax ( ) != m_max ) { m_oldMax = m_max ; m_oldMin = m_min ; m_max = e . getMax ( ) ; m_min = e . getMin ( ) ; refresh = BOOL_ ; m_yScaleUpdate = BOOL_ ; } if ( refresh ) { m_legendPanel . repaint ( ) ; m_scalePanel . repaint ( ) ; } acceptDataPoint ( e . getDataPoint ( ) ) ; } m_xCount ++ ; }
public void sub ( NamedRangeSet other ) { List < NamedRange > newRanges = new ArrayList < NamedRange > ( ) ; OUTER_LOOP : for ( NamedRange range : ranges ) { NamedRange thisRange = new NamedRange ( range . start , range . end , range . name ) ; for ( NamedRange otherRange : other . ranges ) { if ( otherRange . start <= thisRange . start && otherRange . end >= thisRange . end ) { continue OUTER_LOOP ; } if ( otherRange . end < thisRange . start || otherRange . start > thisRange . end ) { } else if ( otherRange . start <= thisRange . start ) { thisRange . start = otherRange . end + NUM_ ; } else if ( otherRange . end >= thisRange . end ) { thisRange . end = otherRange . start - NUM_ ; } else { newRanges . add ( new NamedRange ( thisRange . start , otherRange . start - NUM_ , thisRange . name ) ) ; thisRange . start = otherRange . end + NUM_ ; } } newRanges . add ( thisRange ) ; } ranges = newRanges ; }
private static Node locateAttrParent ( Element elem , Node attr ) { Node parent = null ; Attr check = elem . getAttributeNode ( attr . getNodeName ( ) ) ; if ( check == attr ) parent = elem ; if ( null == parent ) { for ( Node node = elem . getFirstChild ( ) ; null != node ; node = node . getNextSibling ( ) ) { if ( Node . ELEMENT_NODE == node . getNodeType ( ) ) { parent = locateAttrParent ( ( Element ) node , attr ) ; if ( null != parent ) break ; } } } return parent ; }
public static Tailer create ( File file , TailerListener listener , long delayMillis , boolean end , int bufSize ) { Tailer tailer = new Tailer ( file , listener , delayMillis , end , bufSize ) ; Thread thread = new Thread ( tailer ) ; thread . setDaemon ( BOOL_ ) ; thread . start ( ) ; return tailer ; }
public static boolean isMacOs ( ) { return osName . indexOf ( STR_ ) > - NUM_ ; }
public int size ( ) { return values . size ( ) ; }
public DViewAsn1Dump ( JDialog parent , X509CRL crl ) throws Asn1Exception , IOException { super ( res . getString ( STR_ ) ) ; this . crl = crl ; initComponents ( ) ; }
public static String rightTrim ( final String value ) { validate ( value , NULL_STRING_PREDICATE , NULL_STRING_MSG_SUPPLIER ) ; return value . replaceAll ( STR_ , STR_ ) ; }
public synchronized void putMessage ( Object obj ) { fifo . addElement ( obj ) ; numMessage ++ ; notifyAll ( ) ; }
public void dispose ( ) { if ( isDisposed ( ) ) { return ; } setDisposed ( BOOL_ ) ; if ( ! menu ) { super . dispose ( ) ; } }
public static void expandReal ( String numberString , WordRelation wordRelation , Item tokenItem ) { int stringLength = numberString . length ( ) ; int position ; if ( numberString . charAt ( NUM_ ) == STR_ ) { wordRelation . addWord ( tokenItem , STR_ ) ; expandReal ( numberString . substring ( NUM_ , stringLength ) , wordRelation , tokenItem ) ; } else if ( numberString . charAt ( NUM_ ) == STR_ ) { wordRelation . addWord ( tokenItem , STR_ ) ; expandReal ( numberString . substring ( NUM_ , stringLength ) , wordRelation , tokenItem ) ; } else if ( ( position = numberString . indexOf ( STR_ ) ) != - NUM_ || ( position = numberString . indexOf ( STR_ ) ) != - NUM_ ) { expandReal ( numberString . substring ( NUM_ , position ) , wordRelation , tokenItem ) ; wordRelation . addWord ( tokenItem , STR_ ) ; expandReal ( numberString . substring ( position + NUM_ ) , wordRelation , tokenItem ) ; } else if ( ( position = numberString . indexOf ( STR_ ) ) != - NUM_ ) { String beforeDot = numberString . substring ( NUM_ , position ) ; if ( beforeDot . length ( ) > NUM_ ) { expandReal ( beforeDot , wordRelation , tokenItem ) ; } wordRelation . addWord ( tokenItem , STR_ ) ; String afterDot = numberString . substring ( position + NUM_ ) ; if ( afterDot . length ( ) > NUM_ ) { expandDigits ( afterDot , wordRelation , tokenItem ) ; } } else { expandNumber ( numberString , wordRelation , tokenItem ) ; } }
public static double [ ] ones ( int L ) { double m [ ] = new double [ L ] ; Arrays . fill ( m , NUM_ ) ; return m ; }
private PermissionRequest submit ( ) { int showRationale = NUM_ ; ArrayList < String > requests = new ArrayList < > ( ) ; for ( final String permission : mPermissions ) { if ( mActivity . checkSelfPermission ( permission ) != PackageManager . PERMISSION_GRANTED ) { requests . add ( permission ) ; if ( ActivityCompat . shouldShowRequestPermissionRationale ( mActivity , permission ) ) { showRationale ++ ; } } } mRequestCode = mRequestId . addAndGet ( NUM_ ) ; if ( requests . isEmpty ( ) ) { if ( mCallback != null ) { mCallback . onPermissionsGranted ( ) ; } } else { if ( showRationale == NUM_ ) { ActivityCompat . requestPermissions ( mActivity , mPermissions , mRequestCode ) ; } else { showRationale ( ) ; } } return this ; }
public void error ( XPathContext xctxt , String msg , Object [ ] args ) throws javax . xml . transform . TransformerException { java . lang . String fmsg = XSLMessages . createXPATHMessage ( msg , args ) ; if ( null != xctxt ) { ErrorListener eh = xctxt . getErrorListener ( ) ; TransformerException te = new TransformerException ( fmsg , this ) ; eh . fatalError ( te ) ; } }
public void testSettingANullDeployableProperty ( ) { Deployable deployableElement = new Deployable ( ) ; WAR war = new WAR ( STR_ ) ; Map < String , String > properties = new HashMap < String , String > ( ) ; properties . put ( STR_ , null ) ; deployableElement . setProperties ( properties ) ; deployableElement . setPropertiesOnDeployable ( war , createDefaultProject ( STR_ , null ) ) ; assertEquals ( STR_ , war . getContext ( ) ) ; }
public static DeleteSubCommandHandler create ( SubCommandArgumentParser parser , ManagedObjectPath < ? , ? > p , SetRelationDefinition < ? , ? > r ) throws ArgumentException { return new DeleteSubCommandHandler ( parser , p , r , p . child ( r ) ) ; }
protected void removeCycles ( ) { int visited [ ] = new int [ m_nodes . size ( ) ] ; for ( int i = NUM_ ; i < graphMatrix . length ; i ++ ) { if ( visited [ i ] == NUM_ ) { removeCycles2 ( i , visited ) ; visited [ i ] = NUM_ ; } } }
public String toString ( ObjectMatrix3D matrix ) { StringBuffer buf = new StringBuffer ( ) ; boolean oldPrintShape = this . printShape ; this . printShape = BOOL_ ; for ( int slice = NUM_ ; slice < matrix . slices ( ) ; slice ++ ) { if ( slice != NUM_ ) buf . append ( sliceSeparator ) ; buf . append ( toString ( matrix . viewSlice ( slice ) ) ) ; } this . printShape = oldPrintShape ; if ( printShape ) buf . insert ( NUM_ , shape ( matrix ) + STR_ ) ; return buf . toString ( ) ; }
int findAncestor ( XPathContext xctxt , XPath fromMatchPattern , XPath countMatchPattern , int context , ElemNumber namespaceContext ) throws javax . xml . transform . TransformerException { DTM dtm = xctxt . getDTM ( context ) ; while ( DTM . NULL != context ) { if ( null != fromMatchPattern ) { if ( fromMatchPattern . getMatchScore ( xctxt , context ) != XPath . MATCH_SCORE_NONE ) { break ; } } if ( null != countMatchPattern ) { if ( countMatchPattern . getMatchScore ( xctxt , context ) != XPath . MATCH_SCORE_NONE ) { break ; } } context = dtm . getParent ( context ) ; } return context ; }
public synchronized void kill ( ) { running = BOOL_ ; closed = BOOL_ ; try { STDIN . close ( ) ; } catch ( IOException e ) { } try { process . destroy ( ) ; } catch ( Exception e ) { } }
public final ByteBuffer encode ( CharBuffer in ) throws CharacterCodingException { int length = ( int ) ( in . remaining ( ) . averageBytesPerChar ) ; ByteBuffer out = ByteBuffer . allocate ( length ) ; reset ( ) ; while ( state != FLUSHED ) { CoderResult result = encode ( in , out , BOOL_ ) ; if ( result == CoderResult . OVERFLOW ) { out = allocateMore ( out ) ; continue ; } else { checkCoderResult ( result ) ; } result = flush ( out ) ; if ( result == CoderResult . OVERFLOW ) { out = allocateMore ( out ) ; } else { checkCoderResult ( result ) ; } } out . flip ( ) ; return out ; }
public static Metrics create ( Map < String , String > dimensionMap ) { Map < String , String > map = Maps . newTreeMap ( ) ; map . putAll ( dimensionMap ) ; return new Metrics ( Collections . unmodifiableMap ( map ) ) ; }
protected Class < ? > resolveClass ( ObjectStreamClass classDesc ) throws IOException , ClassNotFoundException { Object annotation = readLocation ( ) ; String className = classDesc . getName ( ) ; ClassLoader defaultLoader = skipDefaultResolveClass ? null : latestUserDefinedLoader ( ) ; String codebase = null ; if ( ! useCodebaseOnly && annotation instanceof String ) { codebase = ( String ) annotation ; } try { return RMIClassLoader . loadClass ( codebase , className , defaultLoader ) ; } catch ( AccessControlException e ) { return checkSunClass ( className , e ) ; } catch ( ClassNotFoundException e ) { try { if ( Character . isLowerCase ( className . charAt ( NUM_ ) ) && className . indexOf ( STR_ ) == - NUM_ ) { return super . resolveClass ( classDesc ) ; } } catch ( ClassNotFoundException e2 ) { } throw e ; } }
public IOUtils ( ) { super ( ) ; }
public boolean contains ( final CreatureRespawnPoint point ) { if ( point == null ) { return BOOL_ ; } final IRPZone entityZone = point . getZone ( ) ; return zone . equals ( entityZone ) && shape . contains ( point . getX ( ) , point . getY ( ) ) ; }
public void add ( int i , byte [ ] buffer , int offset , int length ) { if ( _length + length > _capacity ) ensureCapacity ( _length + length ) ; System . arraycopy ( _buffer , i , _buffer , i + length , _length - i ) ; System . arraycopy ( buffer , offset , _buffer , i , length ) ; _length += length ; }
public boolean isUseAntiAlias ( ) { return useAntiAlias ; }
private void loadLevelFile ( String tableName , String columnName , String cubeName , String schemaName ) { String baseLocation = CarbonUtil . getCarbonStorePath ( schemaName , cubeName ) ; baseLocation = baseLocation + File . separator + schemaName + File . separator + cubeName ; if ( loadFolderList . size ( ) == NUM_ ) { checkAndUpdateFolderList ( baseLocation ) ; } try { File [ ] filesArray = null ; for ( File loadFoler : loadFolderList ) { filesArray = getFilesArray ( loadFoler , tableName + STR_ + columnName ) ; if ( null != filesArray ) { for ( int i = NUM_ ; i < filesArray . length ; i ++ ) { readLevelFileAndUpdateCache ( filesArray [ i ] , tableName + STR_ + columnName ) ; } } } } catch ( IOException e ) { LOGGER . error ( STR_ ) ; } }
protected void doValidateZeroLongFile ( String path , String filename , long size , boolean checkContents ) { File inFile = new File ( path , filename ) ; DataInputStream inStream = null ; Log . i ( LOG_TAG , STR_ + filename + STR_ + path ) ; try { inStream = new DataInputStream ( new FileInputStream ( inFile ) ) ; if ( checkContents ) { for ( long i = NUM_ ; i < size ; ++ i ) { if ( inStream . readLong ( ) != NUM_ ) { fail ( STR_ + filename ) ; } } } if ( inStream != null ) { inStream . close ( ) ; } Log . i ( LOG_TAG , STR_ + filename + STR_ + size + STR_ ) ; } catch ( IOException e ) { fail ( STR_ + inFile + STR_ + e . toString ( ) ) ; } }
protected void write ( DataOutputStream stream ) throws Exception { Iterator < NBT_Tag > iter = elements . iterator ( ) ; while ( iter . hasNext ( ) ) { NBT_Tag ret = iter . next ( ) ; ret . save ( stream ) ; } TAG_End end = new TAG_End ( STR_ ) ; end . save ( stream ) ; }
public String applyMask ( String mask , String value ) { return ( String ) getMaskOrGetCursorIndex ( mask , value , NUM_ , BOOL_ ) ; }
private void computeDuration ( ) { duration = System . currentTimeMillis ( ) - start ; total_duration += duration ; }
@ SuppressWarnings ( { STR_ } ) @ Override public byte [ ] serialize ( List list ) { if ( list == null ) return null ; final int size = list . size ( ) ; final int [ ] valueIDs = new int [ size ] ; final byte [ ] [ ] valueBytes = new byte [ size ] [ ] ; int totalSize = NUM_ + size . NUM_ ; int i = NUM_ ; Iterator iter = list . iterator ( ) ; while ( iter . hasNext ( ) ) { final Object value = iter . next ( ) ; Class < ? > valueClass = value . getClass ( ) ; int valueTypeID = EntityDefinitionManager . getIDBySerDerClass ( valueClass ) ; if ( valueTypeID == - NUM_ ) { if ( value instanceof List ) { valueClass = List . class ; valueTypeID = EntityDefinitionManager . getIDBySerDerClass ( valueClass ) ; } else if ( value instanceof Map ) { valueClass = Map . class ; valueTypeID = EntityDefinitionManager . getIDBySerDerClass ( valueClass ) ; } else { throw new IllegalArgumentException ( STR_ + valueClass . getName ( ) ) ; } } valueIDs [ i ] = valueTypeID ; final EntitySerDeser valueSerDer = EntityDefinitionManager . getSerDeser ( valueClass ) ; if ( valueSerDer == null ) { throw new IllegalArgumentException ( STR_ + valueClass . getName ( ) ) ; } valueBytes [ i ] = valueSerDer . serialize ( value ) ; totalSize += valueBytes [ i ] . length ; ++ i ; } final byte [ ] result = new byte [ totalSize ] ; int offset = NUM_ ; ByteUtil . intToBytes ( size , result , offset ) ; offset += NUM_ ; for ( i = NUM_ ; i < size ; ++ i ) { ByteUtil . intToBytes ( valueIDs [ i ] , result , offset ) ; offset += NUM_ ; ByteUtil . intToBytes ( valueBytes [ i ] . length , result , offset ) ; offset += NUM_ ; System . arraycopy ( valueBytes [ i ] , NUM_ , result , offset , valueBytes [ i ] . length ) ; offset += valueBytes [ i ] . length ; } return result ; }
public int handleNITFHeader ( BinaryFile binFile ) { try { byte [ ] nitfArray = binFile . readBytes ( NUM_ , BOOL_ ) ; String nitf = new String ( nitfArray ) ; binFile . seek ( RPF_DATE_LOCATION ) ; nitfArray = binFile . readBytes ( NUM_ , BOOL_ ) ; nitf = new String ( nitfArray ) ; if ( nitf . equalsIgnoreCase ( STR_ ) || nitf . equalsIgnoreCase ( STR_ ) ) return NUM_ ; binFile . seek ( RPF_DATE_LOCATION + TOC_NITF_HEADER_LENGTH ) ; nitfArray = binFile . readBytes ( NUM_ , BOOL_ ) ; nitf = new String ( nitfArray ) ; if ( nitf . equalsIgnoreCase ( STR_ ) || nitf . equalsIgnoreCase ( STR_ ) ) return TOC_NITF_HEADER_LENGTH ; binFile . seek ( RPF_DATE_LOCATION + FRAME_SHORT_NITF_HEADER_LENGTH ) ; nitfArray = binFile . readBytes ( NUM_ , BOOL_ ) ; nitf = new String ( nitfArray ) ; if ( nitf . equalsIgnoreCase ( STR_ ) || nitf . equalsIgnoreCase ( STR_ ) ) return FRAME_SHORT_NITF_HEADER_LENGTH ; binFile . seek ( RPF_DATE_LOCATION + FRAME_LONG_NITF_HEADER_LENGTH ) ; nitfArray = binFile . readBytes ( NUM_ , BOOL_ ) ; nitf = new String ( nitfArray ) ; if ( nitf . equalsIgnoreCase ( STR_ ) || nitf . equalsIgnoreCase ( STR_ ) ) return FRAME_LONG_NITF_HEADER_LENGTH ; } catch ( IOException e ) { Debug . error ( STR_ + e ) ; return - NUM_ ; } catch ( FormatException f ) { Debug . error ( STR_ + f ) ; return - NUM_ ; } return - NUM_ ; }
public BufferedImage takeScreenshot ( ) { Debug . setDebugLevel ( NUM_ ) ; File scrFile = driver . getScreenshotAs ( OutputType . FILE ) ; BufferedImage bufferedImage = null ; try { bufferedImage = ImageIO . read ( scrFile ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return bufferedImage ; }
private void pickCenterOverlap ( ScoutWidget [ ] list ) { for ( int i = NUM_ ; i < list . length ; i ++ ) { ScoutWidget scoutWidget = list [ i ] ; float centerX = scoutWidget . getX ( ) + scoutWidget . getWidth ( ) / NUM_ ; float centerY = scoutWidget . getY ( ) + scoutWidget . getHeight ( ) / NUM_ ; for ( int j = NUM_ ; j < list . length ; j ++ ) { if ( i == j ) continue ; ScoutWidget widget = list [ j ] ; if ( scoutWidget . isGuideline ( ) ) { continue ; } if ( ! widget . isGuideline ( ) && ScoutWidget . distance ( scoutWidget , widget ) > MAX_DIST_FOR_CENTER_OVERLAP ) { continue ; } if ( ! widget . isGuideline ( ) || widget . isVerticalGuideline ( ) ) { if ( Math . abs ( widget . getX ( ) - centerX ) < CENTER_ERROR ) { scoutWidget . setEdgeCentered ( NUM_ , widget , Direction . WEST ) ; } if ( Math . abs ( widget . getX ( ) + widget . getWidth ( ) - centerX ) < CENTER_ERROR ) { scoutWidget . setEdgeCentered ( NUM_ , widget , Direction . EAST ) ; } } if ( ! widget . isGuideline ( ) || widget . isHorizontalGuideline ( ) ) { if ( Math . abs ( widget . getY ( ) - centerY ) < CENTER_ERROR ) { scoutWidget . setEdgeCentered ( NUM_ , widget , Direction . NORTH ) ; } if ( Math . abs ( widget . getY ( ) + widget . getHeight ( ) - centerY ) < CENTER_ERROR ) { scoutWidget . setEdgeCentered ( NUM_ , widget , Direction . SOUTH ) ; } } } } }
