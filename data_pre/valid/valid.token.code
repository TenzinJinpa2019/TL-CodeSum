public int hashCode ( ) { return value . hashCode ( ) ; }
@ Override protected void propertyChange ( PropertyChangeEvent evt ) { if ( SeaGlassLookAndFeel . shouldUpdateStyle ( evt ) ) { updateStyle ( ( JTextComponent ) evt . getSource ( ) ) ; } super . propertyChange ( evt ) ; }
@ NotNull public PsiQuery filter ( @ NotNull final Class < ? extends PsiNamedElement > clazz , @ NotNull final String name ) { final Set < PsiElement > result = new HashSet < PsiElement > ( Arrays . asList ( myPsiElements ) ) ; for ( final PsiElement element : myPsiElements ) { final PsiNamedElement namedElement = PyUtil . as ( element , clazz ) ; if ( ( namedElement == null ) || ( ! name . equals ( namedElement . getName ( ) ) ) ) { result . remove ( element ) ; } } return new PsiQuery ( result . toArray ( new PsiElement [ result . size ( ) ] ) ) ; }
protected void writeQualifiedName ( String nsAlias , String name ) throws IOException { if ( nsAlias != null && nsAlias . length ( ) > NUM_ ) { writer . write ( nsAlias ) ; writer . write ( STR_ ) ; } writer . write ( name ) ; }
public TextEditor deleteAll ( String pattern ) { return replaceAll ( pattern , STR_ ) ; }
public synchronized GcmHelper addRegistrationCallback ( @ NonNull Context context , @ NonNull GcmRegistrationListener registrationListener , boolean sticky ) { if ( null == registrationCallbacks ) { registrationCallbacks = new ConcurrentLinkedQueue < > ( ) ; } registrationCallbacks . add ( registrationListener ) ; if ( sticky && ! TextUtils . isEmpty ( this . pushToken ) ) { registrationListener . onTokenAvailable ( context , pushToken , BOOL_ ) ; } return this ; }
@ Override public void acceptTrainingSet ( TrainingSetEvent e ) { Instances trainingSet = e . getTrainingSet ( ) ; DataSetEvent dse = new DataSetEvent ( this , trainingSet ) ; acceptDataSet ( dse ) ; }
< T > List < T > onFind ( Class < T > modelClass , String [ ] columns , String [ ] conditions , String orderBy , String limit , boolean isEager ) { BaseUtility . checkConditionsCorrect ( conditions ) ; List < T > dataList = query ( modelClass , columns , getWhereClause ( conditions ) , getWhereArgs ( conditions ) , null , null , orderBy , limit , getForeignKeyAssociations ( modelClass . getName ( ) , isEager ) ) ; return dataList ; }
private boolean isAgentEmpty ( Agent agent ) { if ( agent != null ) { String first = agent . getFirstName ( ) ; String last = agent . getLastName ( ) ; String email = agent . getEmail ( ) ; String home = agent . getHomepage ( ) ; String org = agent . getOrganisation ( ) ; String phone = agent . getPhone ( ) ; String position = agent . getPosition ( ) ; String city = null ; String street = null ; String country = null ; String code = null ; String province = null ; Address address = agent . getAddress ( ) ; if ( address != null ) { city = address . getCity ( ) ; street = address . getAddress ( ) ; country = address . getCountry ( ) ; code = address . getPostalCode ( ) ; province = address . getProvince ( ) ; } String directory = null ; String identifier = null ; List < UserId > userIds = agent . getUserIds ( ) ; if ( ! userIds . isEmpty ( ) ) { UserId userId = userIds . get ( NUM_ ) ; directory = userId . getDirectory ( ) ; identifier = userId . getIdentifier ( ) ; } return ( Strings . isNullOrEmpty ( city ) && Strings . isNullOrEmpty ( street ) && Strings . isNullOrEmpty ( country ) && Strings . isNullOrEmpty ( code ) && Strings . isNullOrEmpty ( province ) && Strings . isNullOrEmpty ( first ) && Strings . isNullOrEmpty ( last ) && Strings . isNullOrEmpty ( email ) && Strings . isNullOrEmpty ( home ) && Strings . isNullOrEmpty ( org ) && Strings . isNullOrEmpty ( phone ) && Strings . isNullOrEmpty ( position ) && Strings . isNullOrEmpty ( directory ) && Strings . isNullOrEmpty ( identifier ) ) ; } return BOOL_ ; }
public static byte [ ] calendarToRawBytes ( Calendar timestamp , boolean honorDeviceTimeOffset ) { if ( honorDeviceTimeOffset ) { int offsetInHours = MiBandCoordinator . getDeviceTimeOffsetHours ( ) ; if ( offsetInHours != NUM_ ) { timestamp . add ( Calendar . HOUR_OF_DAY , offsetInHours ) ; } } byte [ ] year = fromUint16 ( timestamp . get ( Calendar . YEAR ) ) ; return new byte [ ] { year [ NUM_ ] , year [ NUM_ ] , fromUint8 ( timestamp . get ( Calendar . MONTH ) + NUM_ ) , fromUint8 ( timestamp . get ( Calendar . DATE ) ) , fromUint8 ( timestamp . get ( Calendar . HOUR_OF_DAY ) ) , fromUint8 ( timestamp . get ( Calendar . MINUTE ) ) , fromUint8 ( timestamp . get ( Calendar . SECOND ) ) , dayOfWeekToRawBytes ( timestamp ) , NUM_ } ; }
protected void initBPOrderDetails ( int C_BPartner_ID , boolean forInvoice ) { log . config ( STR_ + C_BPartner_ID ) ; KeyNamePair pp = new KeyNamePair ( NUM_ , STR_ ) ; orderField . removeActionListener ( this ) ; orderField . removeAllItems ( ) ; orderField . addItem ( pp ) ; ArrayList < KeyNamePair > list = loadOrderData ( C_BPartner_ID , forInvoice , sameWarehouseCb . isSelected ( ) ) ; for ( KeyNamePair knp : list ) orderField . addItem ( knp ) ; orderField . setSelectedIndex ( NUM_ ) ; orderField . addActionListener ( this ) ; initBPDetails ( C_BPartner_ID ) ; }
public ModpackInitializationPanel ( WizardController controller , Map wizardData , Vector < String > versions , String selVersion ) { initComponents ( ) ; this . controller = controller ; this . wizardData = wizardData ; wizardData . put ( KEY_GAME_VERSION , versions ) ; wizardData . put ( STR_ , selVersion ) ; wizardData . put ( KEY_INCLUDING_LAUNCHER , BOOL_ ) ; configureComboContents ( ) ; checkProblem ( ) ; }
public synchronized void remove ( int index ) { super . remove ( index ) ; double removedValue = mValue . remove ( index ) ; if ( removedValue == mMinValue || removedValue == mMaxValue ) { initRange ( ) ; } }
private boolean coordIsCalendarCell ( float y ) { return y > cellHeight ; }
protected void sprint ( double doubleField ) { sprint ( String . valueOf ( doubleField ) ) ; }
private int attributeMap ( String name ) { Integer num = map . get ( name ) ; if ( num == null ) { return NUM_ ; } return num . intValue ( ) ; }
private void groupPlayerStandingCSV ( ) { for ( PlayerQB p : teamQBs ) { if ( p . year == NUM_ ) teamRSs . add ( p ) ; else if ( p . year == NUM_ ) teamFRs . add ( p ) ; else if ( p . year == NUM_ ) teamSOs . add ( p ) ; else if ( p . year == NUM_ ) teamJRs . add ( p ) ; else if ( p . year == NUM_ ) teamSRs . add ( p ) ; } for ( PlayerRB p : teamRBs ) { if ( p . year == NUM_ ) teamRSs . add ( p ) ; else if ( p . year == NUM_ ) teamFRs . add ( p ) ; else if ( p . year == NUM_ ) teamSOs . add ( p ) ; else if ( p . year == NUM_ ) teamJRs . add ( p ) ; else if ( p . year == NUM_ ) teamSRs . add ( p ) ; } for ( PlayerWR p : teamWRs ) { if ( p . year == NUM_ ) teamRSs . add ( p ) ; else if ( p . year == NUM_ ) teamFRs . add ( p ) ; else if ( p . year == NUM_ ) teamSOs . add ( p ) ; else if ( p . year == NUM_ ) teamJRs . add ( p ) ; else if ( p . year == NUM_ ) teamSRs . add ( p ) ; } for ( PlayerK p : teamKs ) { if ( p . year == NUM_ ) teamRSs . add ( p ) ; else if ( p . year == NUM_ ) teamFRs . add ( p ) ; else if ( p . year == NUM_ ) teamSOs . add ( p ) ; else if ( p . year == NUM_ ) teamJRs . add ( p ) ; else if ( p . year == NUM_ ) teamSRs . add ( p ) ; } for ( PlayerOL p : teamOLs ) { if ( p . year == NUM_ ) teamRSs . add ( p ) ; else if ( p . year == NUM_ ) teamFRs . add ( p ) ; else if ( p . year == NUM_ ) teamSOs . add ( p ) ; else if ( p . year == NUM_ ) teamJRs . add ( p ) ; else if ( p . year == NUM_ ) teamSRs . add ( p ) ; } for ( PlayerS p : teamSs ) { if ( p . year == NUM_ ) teamRSs . add ( p ) ; else if ( p . year == NUM_ ) teamFRs . add ( p ) ; else if ( p . year == NUM_ ) teamSOs . add ( p ) ; else if ( p . year == NUM_ ) teamJRs . add ( p ) ; else if ( p . year == NUM_ ) teamSRs . add ( p ) ; } for ( PlayerCB p : teamCBs ) { if ( p . year == NUM_ ) teamRSs . add ( p ) ; else if ( p . year == NUM_ ) teamFRs . add ( p ) ; else if ( p . year == NUM_ ) teamSOs . add ( p ) ; else if ( p . year == NUM_ ) teamJRs . add ( p ) ; else if ( p . year == NUM_ ) teamSRs . add ( p ) ; } for ( PlayerF7 p : teamF7s ) { if ( p . year == NUM_ ) teamRSs . add ( p ) ; else if ( p . year == NUM_ ) teamFRs . add ( p ) ; else if ( p . year == NUM_ ) teamSOs . add ( p ) ; else if ( p . year == NUM_ ) teamJRs . add ( p ) ; else if ( p . year == NUM_ ) teamSRs . add ( p ) ; } }
public String list ( ) throws IOException , TomcatManagerException { return invoke ( STR_ , null , null ) ; }
public AttributeFiller ( AttributesImpl attributes , PO poToAutoFill ) { attributes . clear ( ) ; atts = attributes ; po = poToAutoFill ; }
public static final void toByteArray ( ByteArrayOutputStream output , String str ) { if ( str == null ) { return ; } output . write ( NUM_ ) ; int max = str . length ( ) ; for ( int i = NUM_ ; i < max ; i ++ ) { int b = str . charAt ( i ) ; if ( ( b >= NUM_ ) && ( b <= NUM_ ) ) { switch ( b ) { case NUM_ : case NUM_ : output . write ( NUM_ ) ; break ; } output . write ( b ) ; } else { output . write ( NUM_ ) ; switch ( b ) { case NUM_ : output . write ( NUM_ ) ; break ; case NUM_ : output . write ( NUM_ ) ; break ; case NUM_ : output . write ( NUM_ ) ; break ; case NUM_ : output . write ( NUM_ ) ; break ; case NUM_ : output . write ( NUM_ ) ; break ; default : output . write ( NUM_ ) ; int b3 = b > > NUM_ ; int b4 = b & xf ; if ( b4 < NUM_ ) b4 += NUM_ ; else b4 += NUM_ ; int b2 = b3 > > NUM_ ; b3 &= xf ; if ( b3 < NUM_ ) b3 += NUM_ ; else b3 += NUM_ ; int b1 = b2 > > NUM_ ; b2 &= xf ; if ( b2 < NUM_ ) b2 += NUM_ ; else b2 += NUM_ ; if ( b1 < NUM_ ) b1 += NUM_ ; else b1 += NUM_ ; output . write ( b1 ) ; output . write ( b2 ) ; output . write ( b3 ) ; output . write ( b4 ) ; break ; } } } output . write ( NUM_ ) ; }
@ RequestMapping ( value = { STR_ , STR_ } , method = RequestMethod . PUT ) @ ResponseBody public RestWrapper insert ( @ ModelAttribute ( STR_ ) @ Valid File file , BindingResult bindingResult , Principal principal ) { RestWrapper restWrapper = null ; if ( bindingResult . hasErrors ( ) ) { BindingResultError bindingResultError = new BindingResultError ( ) ; return bindingResultError . errorMessage ( bindingResult ) ; } try { file . setCreationTS ( DateConverter . stringToDate ( file . getTableCreationTS ( ) ) ) ; fileDAO . insert ( file ) ; restWrapper = new RestWrapper ( file , RestWrapper . OK ) ; LOGGER . info ( STR_ + file . getBatchId ( ) + STR_ + principal . getName ( ) + file ) ; } catch ( MetadataException e ) { LOGGER . error ( e ) ; restWrapper = new RestWrapper ( e . getMessage ( ) , RestWrapper . ERROR ) ; } return restWrapper ; }
private void enableUpdates ( ) { if ( lmgr != null ) { try { lmgr . addGpsStatusListener ( this ) ; lmgr . requestLocationUpdates ( LocationManager . GPS_PROVIDER , gpsLoggingInterval , NUM_ , this ) ; } catch ( SecurityException e ) { Log . e ( TAG , STR_ ) ; } } }
private void addInteger ( ) { int oldPos = pos - NUM_ ; String literal = scanInteger ( ) ; final String substring ; final int radix ; if ( literal . startsWith ( STR_ ) || literal . startsWith ( STR_ ) ) { radix = NUM_ ; substring = literal . substring ( NUM_ ) ; } else if ( literal . startsWith ( STR_ ) && literal . length ( ) > NUM_ ) { radix = NUM_ ; substring = literal . substring ( NUM_ ) ; } else { radix = NUM_ ; substring = literal ; } int value = NUM_ ; try { value = Integer . parseInt ( substring , radix ) ; } catch ( NumberFormatException e ) { error ( STR_ + radix + STR_ + literal ) ; } addToken ( TokenKind . INT , oldPos , pos , value ) ; }
public void removeMouseListener ( GlobalMouseListener listener ) { listeners . remove ( listener ) ; }
public XMLDocument ( double version , boolean standalone ) { prolog = new Vector < Object > ( NUM_ ) ; StringBuffer versionStr = new StringBuffer ( ) ; versionStr . append ( STR_ ) ; versionStr . append ( version ) ; versionStr . append ( STR_ ) ; if ( standalone ) versionStr . append ( STR_ ) ; else versionStr . append ( STR_ ) ; this . versionDecl = versionStr . toString ( ) ; }
public ObjectName createDistributionLocator ( String host , int port , String workingDirectory , String productDirectory , String remoteCommand ) throws MalformedObjectNameException { try { DistributionLocatorJmxImpl locator = ( DistributionLocatorJmxImpl ) addDistributionLocator ( ) ; DistributionLocatorConfig config = locator . getConfig ( ) ; config . setHost ( host ) ; config . setPort ( port ) ; config . setWorkingDirectory ( workingDirectory ) ; config . setProductDirectory ( productDirectory ) ; config . setRemoteCommand ( remoteCommand ) ; return new ObjectName ( locator . getMBeanName ( ) ) ; } catch ( RuntimeException e ) { logger . warn ( e . getMessage ( ) , e ) ; throw e ; } catch ( VirtualMachineError err ) { SystemFailure . initiateFailure ( err ) ; throw err ; } catch ( Error e ) { SystemFailure . checkFailure ( ) ; logger . error ( e . getMessage ( ) , e ) ; throw e ; } }
void applyCenterPanel ( GrassMarlin ui ) { if ( treeViewComponent != null ) { centerPanelComponent . add ( treeViewComponent , SplitPane . Position . CENTER ) ; } centerPanelComponent . add ( graphComponent , SplitPane . Position . RIGHT ) ; centerPanelComponent . add ( logComponent , SplitPane . Position . LEFT_BOTTOM ) ; Border b = BorderFactory . createMatteBorder ( NUM_ , NUM_ , NUM_ , NUM_ , Color . GRAY ) ; Border b2 = BorderFactory . createMatteBorder ( NUM_ , NUM_ , NUM_ , NUM_ , Color . GRAY ) ; treeViewComponent . setBorder ( b2 ) ; graphComponent . setBorder ( b ) ; logComponent . setBorder ( b2 ) ; centerPanelComponent . setInitialSize ( x , y ) ; Dimension d = new Dimension ( NUM_ , NUM_ ) ; ui . add ( new Filler ( d , d , d ) , BorderLayout . WEST ) ; ui . add ( new Filler ( d , d , d ) , BorderLayout . EAST ) ; ui . add ( centerPanelComponent , BorderLayout . CENTER ) ; }
private boolean isAbstract ( String source ) { int nonterminalCount = NUM_ ; for ( String t : source . split ( STR_ ) ) { if ( ! t . matches ( NT_REGEX ) ) return BOOL_ ; nonterminalCount ++ ; } return nonterminalCount != NUM_ ; }
public static String URIforPortablePath ( String path ) { if ( path . startsWith ( FileUtil . PREFERENCES ) ) { return path . replaceFirst ( FileUtil . PREFERENCES , STR_ ) ; } else if ( path . startsWith ( FileUtil . PROGRAM ) ) { return path . replaceFirst ( FileUtil . PROGRAM , STR_ ) ; } else { return null ; } }
public int hashCode ( ) { return Float . floatToIntBits ( value ) ; }
public static void log ( Throwable error , String message , Object ... args ) { if ( loggingEnabled ) { Log . d ( TAG , args . length == NUM_ ? message : String . format ( message , args ) , error ) ; } }
public void addExtensionNamespace ( String uri , ExtensionHandler extNS ) { m_extensionFunctionNamespaces . put ( uri , extNS ) ; }
private void generateTypeParameterInfos ( BinaryMember parent , char [ ] signature , HashMap newElements , ArrayList typeParameterHandles ) { if ( signature == null ) return ; char [ ] [ ] typeParameterSignatures = Signature . getTypeParameters ( signature ) ; for ( int i = NUM_ , typeParameterCount = typeParameterSignatures . length ; i < typeParameterCount ; i ++ ) { char [ ] typeParameterSignature = typeParameterSignatures [ i ] ; char [ ] typeParameterName = Signature . getTypeVariable ( typeParameterSignature ) ; CharOperation . replace ( typeParameterSignature , STR_ , STR_ ) ; char [ ] [ ] typeParameterBoundSignatures = Signature . getTypeParameterBounds ( typeParameterSignature ) ; int boundLength = typeParameterBoundSignatures . length ; char [ ] [ ] typeParameterBounds = new char [ boundLength ] [ ] ; for ( int j = NUM_ ; j < boundLength ; j ++ ) { typeParameterBounds [ j ] = Signature . toCharArray ( typeParameterBoundSignatures [ j ] ) ; } TypeParameter typeParameter = new TypeParameter ( parent , parent . manager , new String ( typeParameterName ) ) ; TypeParameterElementInfo info = new TypeParameterElementInfo ( ) ; info . bounds = typeParameterBounds ; info . boundsSignatures = typeParameterBoundSignatures ; typeParameterHandles . add ( typeParameter ) ; while ( newElements . containsKey ( typeParameter ) ) typeParameter . occurrenceCount ++ ; newElements . put ( typeParameter , info ) ; } }
public final void testNextBytesbyteArray02 ( ) { byte [ ] myBytes ; byte [ ] myBytes1 ; byte [ ] myBytes2 ; for ( int i = NUM_ ; i < LENGTH ; i += INCR ) { myBytes = new byte [ i ] ; for ( int j = NUM_ ; j < i ; j ++ ) { myBytes [ j ] = ( byte ) ( j & xFF ) ; } sr . setSeed ( myBytes ) ; sr2 . setSeed ( myBytes ) ; for ( int k = NUM_ ; k < LENGTH ; k += INCR ) { myBytes1 = new byte [ k ] ; myBytes2 = new byte [ k ] ; sr . nextBytes ( myBytes1 ) ; sr2 . nextBytes ( myBytes2 ) ; for ( int l = NUM_ ; l < k ; l ++ ) { assertFalse ( STR_ + l + STR_ + k + STR_ + i + STR_ + myBytes1 [ l ] + STR_ + myBytes2 [ l ] , myBytes1 [ l ] != myBytes2 [ l ] ) ; } } } for ( int n = NUM_ ; n < LENGTH ; n += INCR ) { int n1 = NUM_ ; int n2 = NUM_ ; int n3 = NUM_ ; byte [ ] [ ] bytes1 = new byte [ NUM_ ] [ n1 ] ; byte [ ] [ ] bytes2 = new byte [ NUM_ ] [ n2 ] ; for ( int k = NUM_ ; k < bytes1 . length ; k ++ ) { sr . nextBytes ( bytes1 [ k ] ) ; } for ( int k = NUM_ ; k < bytes2 . length ; k ++ ) { sr2 . nextBytes ( bytes2 [ k ] ) ; } for ( int k = NUM_ ; k < n3 ; k ++ ) { int i1 = k / n1 ; int i2 = k % n1 ; int i3 = k / n2 ; int i4 = k % n2 ; assertTrue ( STR_ + i1 + STR_ + i2 + STR_ + i3 + STR_ + i4 , bytes1 [ i1 ] [ i2 ] == bytes2 [ i3 ] [ i4 ] ) ; } } }
private void signalNotEmpty ( ) { final ReentrantLock takeLock = this . takeLock ; takeLock . lock ( ) ; try { notEmpty . signal ( ) ; } finally { takeLock . unlock ( ) ; } }
public RoutingInfo ( Object o ) { this . text = o . toString ( ) ; }
private List < View > addView ( View view , List < View > cache ) { if ( cache == null ) { cache = new LinkedList < View > ( ) ; } cache . add ( view ) ; return cache ; }
public static CertChainKeyPair generateSigned ( String fqdn , X509Certificate issuerCertificate , PrivateKey issuerPrivateKey ) { try { return generateCertificateAndSign ( fqdn , issuerCertificate , issuerPrivateKey , getServerExtensions ( issuerCertificate ) ) ; } catch ( CertificateException | OperatorCreationException | NoSuchAlgorithmException | IOException e ) { throw new RuntimeException ( String . format ( STR_ , e . getMessage ( ) ) , e ) ; } }
private void startAnimation ( ) { ValueAnimator animator = ValueAnimator . ofFloat ( NUM_ ) ; ArrayList < NameValuesHolder > nameValueList = ( ArrayList < NameValuesHolder > ) mPendingAnimations . clone ( ) ; mPendingAnimations . clear ( ) ; int propertyMask = NUM_ ; int propertyCount = nameValueList . size ( ) ; for ( int i = NUM_ ; i < propertyCount ; ++ i ) { NameValuesHolder nameValuesHolder = nameValueList . get ( i ) ; propertyMask |= nameValuesHolder . mNameConstant ; } mAnimatorMap . put ( animator , new PropertyBundle ( propertyMask , nameValueList ) ) ; animator . addUpdateListener ( mAnimatorEventListener ) ; animator . addListener ( mAnimatorEventListener ) ; if ( mStartDelaySet ) { animator . setStartDelay ( mStartDelay ) ; } if ( mDurationSet ) { animator . setDuration ( mDuration ) ; } if ( mInterpolatorSet ) { animator . setInterpolator ( mInterpolator ) ; } animator . start ( ) ; }
public void addRequest ( Request request ) { requestSet . add ( request ) ; }
private void byte2hex ( byte b , StringBuffer buf ) { char [ ] hexChars = { STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ } ; int high = ( ( b & xf0 ) > > NUM_ ) ; int low = ( b & x0f ) ; buf . append ( hexChars [ high ] ) ; buf . append ( hexChars [ low ] ) ; }
public static List < GeoTimeSerie > timesplit ( GeoTimeSerie gts , long quietperiod , int minvalues , String labelname ) { List < GeoTimeSerie > series = new ArrayList < GeoTimeSerie > ( ) ; if ( NUM_ == gts . values || gts . hasLabel ( labelname ) ) { series . add ( gts . clone ( ) ) ; return series ; } sort ( gts , BOOL_ ) ; long lasttick = gts . ticks [ NUM_ ] ; int idx = NUM_ ; int gtsid = NUM_ ; GeoTimeSerie serie = new GeoTimeSerie ( gts . lastbucket , gts . bucketcount , gts . bucketspan , NUM_ ) ; serie . setName ( gts . getName ( ) ) ; Map < String , String > labels = new HashMap < String , String > ( ) ; labels . putAll ( gts . getLabels ( ) ) ; labels . put ( labelname , Integer . toString ( gtsid ) ) ; serie . setLabels ( labels ) ; while ( idx < gts . values ) { if ( gts . ticks [ idx ] - lasttick >= quietperiod ) { if ( serie . values > NUM_ && serie . values >= minvalues ) { series . add ( serie ) ; } serie = new GeoTimeSerie ( gts . lastbucket , gts . bucketcount , gts . bucketspan , NUM_ ) ; serie . setName ( gts . getName ( ) ) ; labels = new HashMap < String , String > ( ) ; labels . putAll ( gts . getLabels ( ) ) ; gtsid ++ ; labels . put ( labelname , Integer . toString ( gtsid ) ) ; serie . setLabels ( labels ) ; } Object value = GTSHelper . valueAtIndex ( gts , idx ) ; GTSHelper . setValue ( serie , gts . ticks [ idx ] , null != gts . locations ? gts . locations [ idx ] : GeoTimeSerie . NO_LOCATION , null != gts . elevations ? gts . elevations [ idx ] : GeoTimeSerie . NO_ELEVATION , value , BOOL_ ) ; lasttick = gts . ticks [ idx ] ; idx ++ ; } if ( serie . values > NUM_ && serie . values >= minvalues ) { series . add ( serie ) ; } return series ; }
protected void checkSignature ( byte [ ] buf ) { if ( ! Arrays . equals ( buf , PngHelperInternal . getPngIdSignature ( ) ) ) throw new PngjInputException ( STR_ ) ; }
private void twoWayMergeInternal ( final ReservoirLongsSketch sketchIn , final boolean isModifiable ) { if ( sketchIn . getN ( ) <= sketchIn . getK ( ) ) { twoWayMergeInternalStandard ( sketchIn ) ; } else if ( gadget_ . getN ( ) < gadget_ . getK ( ) ) { final ReservoirLongsSketch tmpSketch = gadget_ ; gadget_ = ( isModifiable ? sketchIn : sketchIn . copy ( ) ) ; twoWayMergeInternalStandard ( tmpSketch ) ; } else if ( sketchIn . getImplicitSampleWeight ( ) < gadget_ . getN ( ) / ( ( double ) ( gadget_ . getK ( ) - NUM_ ) ) ) { twoWayMergeInternalWeighted ( sketchIn ) ; } else { final ReservoirLongsSketch tmpSketch = gadget_ ; gadget_ = ( isModifiable ? sketchIn : sketchIn . copy ( ) ) ; twoWayMergeInternalWeighted ( tmpSketch ) ; } }
final public void print ( Object v ) { Writer out = this . out ; if ( out == null ) return ; try { if ( v == null ) out . write ( _nullChars , NUM_ , _nullChars . length ) ; else { String s = v . toString ( ) ; out . write ( s , NUM_ , s . length ( ) ) ; } } catch ( IOException e ) { log . log ( Level . FINE , e . toString ( ) , e ) ; } }
public void subscribeTo ( final K key , final Subscriber < V > subscriber , final Executor subscribeOn ) { CompletableFuture . runAsync ( null , subscribeOn ) ; }
public static boolean copyStream ( InputStream is , OutputStream os , CopyListener listener , int bufferSize ) throws IOException { int current = NUM_ ; int total = is . available ( ) ; if ( total <= NUM_ ) { total = DEFAULT_IMAGE_TOTAL_SIZE ; } final byte [ ] bytes = new byte [ bufferSize ] ; int count ; if ( shouldStopLoading ( listener , current , total ) ) return BOOL_ ; while ( ( count = is . read ( bytes , NUM_ , bufferSize ) ) != - NUM_ ) { os . write ( bytes , NUM_ , count ) ; current += count ; if ( shouldStopLoading ( listener , current , total ) ) return BOOL_ ; } os . flush ( ) ; return BOOL_ ; }
private void refreshBuffer ( ) throws IOException { if ( output == null ) { throw new OutOfSpaceException ( ) ; } output . write ( buffer , NUM_ , position ) ; position = NUM_ ; }
public String damageBayDoor ( ) { String bayType = STR_ ; Vector < Bay > potential ; potential = new Vector < Bay > ( ) ; Enumeration < Transporter > iter = transports . elements ( ) ; while ( iter . hasMoreElements ( ) ) { Transporter next = iter . nextElement ( ) ; if ( next instanceof Bay ) { Bay nextBay = ( Bay ) next ; if ( nextBay . getDoors ( ) > NUM_ ) { potential . add ( nextBay ) ; } } } if ( potential . size ( ) > NUM_ ) { Bay chosenBay = potential . elementAt ( Compute . randomInt ( potential . size ( ) ) ) ; chosenBay . destroyDoor ( ) ; chosenBay . resetDoors ( ) ; chosenBay . setDoors ( chosenBay . getDoors ( ) - NUM_ ) ; bayType = chosenBay . getType ( ) ; } return bayType ; }
public void updateEnabledState ( ) { boolean b = ( getSimulationThread ( ) == null ) ; boolean prep = b && controller != null && controller . isPrepared ( ) ; clearButton . setEnabled ( b ) ; prepareButton . setEnabled ( b ) ; runButton . setEnabled ( prep ) ; if ( b ) pauseButton . setSelected ( BOOL_ ) ; pauseButton . setEnabled ( ! b ) ; stepButton . setEnabled ( prep ) ; cancelButton . setEnabled ( ! b ) ; for ( JComboBox < Object > combo : selectors . combos ) combo . setEnabled ( b ) ; }
private void prepareVolumeData ( ) throws Exception { prepareVPlexVolumeData ( ) ; prepareRPVolumeData ( ) ; }
private static int determineIconIdByMimeTypeList ( List < String > mimetypes ) { if ( mimetypes == null || mimetypes . size ( ) < NUM_ ) { return R . drawable . file ; } else { for ( String mimetype : mimetypes ) { Integer iconId = MIMETYPE_TO_ICON_MAPPING . get ( mimetype ) ; if ( iconId != null ) { return iconId ; } } for ( String mimetype : mimetypes ) { String mainMimetypePart = mimetype . split ( STR_ ) [ NUM_ ] ; Integer iconId = MAINMIMETYPE_TO_ICON_MAPPING . get ( mainMimetypePart ) ; if ( iconId != null ) { return iconId ; } } } return R . drawable . file ; }
public SmsMmsMessage ( Context _context , long _messageId , long _threadId , long _timestamp , String _messageBody , int _unreadCount , int _messageType ) { context = _context ; messageId = _messageId ; threadId = _threadId ; timestamp = _timestamp ; messageBody = _messageBody ; unreadCount = _unreadCount ; messageType = _messageType ; fromAddress = SmsPopupUtils . getMmsAddress ( context , messageId ) ; fromEmailGateway = BOOL_ ; contactName = PhoneNumberUtils . formatNumber ( fromAddress ) ; ContactIdentification contactIdentify = SmsPopupUtils . getPersonIdFromPhoneNumber ( context , fromAddress ) ; if ( contactIdentify == null ) { contactIdentify = SmsPopupUtils . getPersonIdFromEmail ( context , fromAddress ) ; if ( contactIdentify != null ) { fromEmailGateway = BOOL_ ; } } if ( contactIdentify != null ) { contactId = contactIdentify . contactId ; contactLookupKey = contactIdentify . contactLookup ; contactName = contactIdentify . contactName ; } }
public void attributeAsClass ( ) { DataSortedTableModel model ; if ( m_CurrentCol == - NUM_ ) { return ; } model = ( DataSortedTableModel ) m_TableData . getModel ( ) ; if ( model . getAttributeAt ( m_CurrentCol ) == null ) { return ; } setCursor ( Cursor . getPredefinedCursor ( Cursor . WAIT_CURSOR ) ) ; model . attributeAsClassAt ( m_CurrentCol ) ; setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; }
public void addListener ( RefreshListener listener ) { if ( listener == null ) { throw new NullPointerException ( STR_ ) ; } refreshListeners . add ( listener ) ; }
public final void doExport ( final String trackName , final File target , int verbosity ) throws IOException { Log . i ( TAG , STR_ + target . getAbsolutePath ( ) ) ; mDbHelper = new DatabaseHelper ( mContext . getApplicationContext ( ) ) ; final BufferedWriter bw = new BufferedWriter ( new FileWriter ( target ) ) ; bw . write ( XML_HEADER ) ; bw . write ( TAG_GPX ) ; if ( verbosity == VERBOSITY_TRACK_AND_WAYPOINTS || verbosity == VERBOSITY_WAYPOINTS_ONLY || verbosity == VERBOSITY_ALL ) { writeWaypoints ( bw ) ; } if ( verbosity == VERBOSITY_TRACK_AND_WAYPOINTS || verbosity == VERBOSITY_ALL ) { writeTrackpoints ( trackName , bw ) ; } bw . flush ( ) ; if ( verbosity == VERBOSITY_ALL ) { writeWifis ( bw ) ; bw . flush ( ) ; writeCells ( bw ) ; bw . flush ( ) ; } bw . write ( TAG_GPX_CLOSE ) ; bw . close ( ) ; mDbHelper . close ( ) ; Log . i ( TAG , STR_ ) ; }
public List < V > valuesInSelection ( RichEditText editor , int spanType ) { List < V > result = new ArrayList < V > ( ) ; Selection expandedSelection = getExpandedSelection ( editor , spanType ) ; if ( expandedSelection != null ) { for ( Span < V > span : getSpans ( editor . getText ( ) , expandedSelection ) ) { result . add ( span . getValue ( ) ) ; } } return result ; }
private boolean isGTEDelta ( double value ) { return Math . abs ( value ) - Math . abs ( mDelta ) > - NUM_ ; }
public static String rowToString ( JSONArray ja ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = NUM_ ; i < ja . length ( ) ; i += NUM_ ) { if ( i > NUM_ ) { sb . append ( STR_ ) ; } Object object = ja . opt ( i ) ; if ( object != null ) { String string = object . toString ( ) ; if ( string . length ( ) > NUM_ && ( string . indexOf ( STR_ ) >= NUM_ || string . indexOf ( STR_ ) >= NUM_ || string . indexOf ( STR_ ) >= NUM_ || string . indexOf ( NUM_ ) >= NUM_ || string . charAt ( NUM_ ) == STR_ ) ) { sb . append ( STR_ ) ; int length = string . length ( ) ; for ( int j = NUM_ ; j < length ; j += NUM_ ) { char c = string . charAt ( j ) ; if ( c >= STR_ && c != STR_ ) { sb . append ( c ) ; } } sb . append ( STR_ ) ; } else { sb . append ( string ) ; } } } sb . append ( STR_ ) ; return sb . toString ( ) ; }
private void maybeSampleSyncParams ( ) { long playbackPositionUs = audioTrackUtil . getPlaybackHeadPositionUs ( ) ; if ( playbackPositionUs == NUM_ ) { return ; } if ( log . allowVerbose ( ) ) { log . v ( STR_ + playbackPositionUs ) ; } long systemClockUs = System . nanoTime ( ) / NUM_ ; if ( systemClockUs - lastPlayheadSampleTimeUs >= MIN_PLAYHEAD_OFFSET_SAMPLE_INTERVAL_US ) { playheadOffsets [ nextPlayheadOffsetIndex ] = playbackPositionUs - systemClockUs ; nextPlayheadOffsetIndex = ( nextPlayheadOffsetIndex + NUM_ ) % MAX_PLAYHEAD_OFFSET_COUNT ; if ( playheadOffsetCount < MAX_PLAYHEAD_OFFSET_COUNT ) { playheadOffsetCount ++ ; } lastPlayheadSampleTimeUs = systemClockUs ; smoothedPlayheadOffsetUs = NUM_ ; for ( int i = NUM_ ; i < playheadOffsetCount ; i ++ ) { smoothedPlayheadOffsetUs += playheadOffsets [ i ] / playheadOffsetCount ; } } if ( needsPassthroughWorkarounds ( ) ) { return ; } if ( systemClockUs - lastTimestampSampleTimeUs >= MIN_TIMESTAMP_SAMPLE_INTERVAL_US ) { audioTimestampSet = audioTrackUtil . updateTimestamp ( ) ; if ( audioTimestampSet ) { long audioTimestampUs = audioTrackUtil . getTimestampNanoTime ( ) / NUM_ ; if ( log . allowVerbose ( ) ) { log . v ( STR_ + audioTimestampUs ) ; } long audioTimestampFramePosition = audioTrackUtil . getTimestampFramePosition ( ) ; if ( audioTimestampUs < resumeSystemTimeUs ) { audioTimestampSet = BOOL_ ; log . w ( STR_ + audioTimestampUs + STR_ + resumeSystemTimeUs ) ; } else if ( Math . abs ( audioTimestampUs - systemClockUs ) > MAX_AUDIO_TIMESTAMP_OFFSET_US ) { String message = STR_ + audioTimestampFramePosition + STR_ + audioTimestampUs + STR_ + systemClockUs + STR_ + playbackPositionUs ; if ( failOnSpuriousAudioTimestamp ) { throw new InvalidAudioTrackTimestampException ( message ) ; } log . w ( message ) ; audioTimestampSet = BOOL_ ; } else if ( Math . abs ( framesToDurationUs ( audioTimestampFramePosition ) - playbackPositionUs ) > MAX_AUDIO_TIMESTAMP_OFFSET_US ) { String message = STR_ + audioTimestampFramePosition + STR_ + audioTimestampUs + STR_ + systemClockUs + STR_ + playbackPositionUs ; if ( failOnSpuriousAudioTimestamp ) { throw new InvalidAudioTrackTimestampException ( message ) ; } log . w ( message ) ; audioTimestampSet = BOOL_ ; } } if ( isLatencyQuirkEnabled ) { latencyUs = AmazonQuirks . getAudioHWLatency ( ) ; } else if ( getLatencyMethod != null && ! passthrough ) { try { latencyUs = ( Integer ) getLatencyMethod . invoke ( audioTrack , ( Object [ ] ) null ) . NUM_ - bufferSizeUs ; latencyUs = Math . max ( latencyUs , NUM_ ) ; if ( latencyUs > MAX_LATENCY_US ) { log . w ( STR_ + latencyUs ) ; latencyUs = NUM_ ; } } catch ( Exception e ) { getLatencyMethod = null ; } } lastTimestampSampleTimeUs = systemClockUs ; } }
@ Override public boolean contains ( Object object ) { if ( object == null ) { return BOOL_ ; } for ( int i = NUM_ ; i < size ; i ++ ) { if ( object . equals ( elements [ i ] ) ) { return BOOL_ ; } } return BOOL_ ; }
public void close ( ) throws IOException { writer . close ( ) ; }
public static void substituteProperties ( Node node , Properties properties ) { Node child ; Node next = node . getFirstChild ( ) ; while ( ( child = next ) != null ) { next = child . getNextSibling ( ) ; if ( child . getNodeType ( ) == Node . TEXT_NODE ) { child . setNodeValue ( PropertiesUtil . substituteProperty ( child . getNodeValue ( ) , properties ) ) ; } else if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { NamedNodeMap attributes = child . getAttributes ( ) ; for ( int i = NUM_ ; i < attributes . getLength ( ) ; i ++ ) { Node attribute = attributes . item ( i ) ; attribute . setNodeValue ( PropertiesUtil . substituteProperty ( attribute . getNodeValue ( ) , properties ) ) ; } substituteProperties ( child , properties ) ; } } }
@ SuppressWarnings ( STR_ ) public PseudoFunctionSelector ( String functionName , String expression ) { super ( Type . PSEUDO_FUNCTION ) ; this . pseudoFunction = ( PseudoFunction < E > ) lookupPseudoFunction ( functionName . trim ( ) ) ; this . expression = expression ; this . parsedExpression = pseudoFunction . parseExpression ( expression ) ; }
public static String fixQueryMistakes ( String q ) { q = q . replaceAll ( STR_ , STR_ ) ; q = q . replaceAll ( STR_ , STR_ ) ; return q ; }
public byte [ ] readBytes ( ) throws IOException { if ( ! parseTag ( ) ) throw new BurlapProtocolException ( STR_ ) ; String tag = sbuf . toString ( ) ; if ( tag . equals ( STR_ ) ) { expectEndTag ( STR_ ) ; return null ; } else if ( tag . equals ( STR_ ) ) { sbuf . setLength ( NUM_ ) ; byte [ ] value = parseBytes ( ) ; expectEndTag ( STR_ ) ; return value ; } else throw expectBeginTag ( STR_ , tag ) ; }
public synchronized Utterance pend ( ) { Utterance utterance = null ; while ( list . size ( ) == NUM_ ) { try { wait ( ) ; } catch ( InterruptedException ie ) { return null ; } } utterance = ( Utterance ) list . removeFirst ( ) ; notify ( ) ; return utterance ; }
public void testLongValuePos ( ) { String a = STR_ ; BigDecimal aNumber = new BigDecimal ( a ) ; long result = NUM_ ; assertTrue ( STR_ , aNumber . longValue ( ) == result ) ; }
public static EvaluationResult findOrCreate ( ResultHierarchy hierarchy , Result parent , String name , String shortname ) { ArrayList < EvaluationResult > ers = ResultUtil . filterResults ( hierarchy , parent , EvaluationResult . class ) ; EvaluationResult ev = null ; for ( EvaluationResult e : ers ) { if ( shortname . equals ( e . getShortName ( ) ) ) { ev = e ; break ; } } if ( ev == null ) { ev = new EvaluationResult ( name , shortname ) ; hierarchy . add ( parent , ev ) ; } return ev ; }
public static boolean isRunningJavaWebStart ( ) { boolean hasJNLP = BOOL_ ; try { Class . forName ( STR_ ) ; hasJNLP = BOOL_ ; } catch ( ClassNotFoundException ex ) { hasJNLP = BOOL_ ; } return hasJNLP ; }
public boolean isConnected ( ) { return connected . get ( ) ; }
private void tryScheduleAction ( Runnable action ) { try { scheduler . submit ( action ) ; } catch ( RejectedExecutionException e ) { } }
private static double scoreSequence ( List < LatLong > pts ) { LatLong prev = pts . get ( pts . size ( ) - NUM_ ) ; LatLong prevprev = pts . get ( pts . size ( ) - NUM_ ) ; double prevAngle = Math . atan2 ( prev . lat - prevprev . lat , prev . lng - prevprev . lng ) ; double score = NUM_ ; for ( LatLong pt : pts ) { double angle = Math . atan2 ( pt . lat - prev . lat , pt . lng - prev . lng ) ; double diff = prevAngle - angle ; if ( diff > Math . PI ) diff -= Math . PI . NUM_ ; else if ( diff < - Math . PI ) diff += Math . PI . NUM_ ; if ( diff < NUM_ ) score += NUM_ ; else score += diff ; prev = pt ; prevAngle = angle ; } return score ; }
public void addWebAppDebugModelListener ( IWebAppDebugModelListener listener ) { synchronized ( privateInstanceLock ) { webAppDebugModelListeners . add ( listener ) ; } }
public void resetPolicy ( ) { mPreferences . putString ( PREF_LAST_RESPONSE , Integer . toString ( Policy . RETRY ) ) ; setRetryUntil ( DEFAULT_RETRY_UNTIL ) ; setMaxRetries ( DEFAULT_MAX_RETRIES ) ; setRetryCount ( Long . parseLong ( DEFAULT_RETRY_COUNT ) ) ; setValidityTimestamp ( DEFAULT_VALIDITY_TIMESTAMP ) ; mPreferences . commit ( ) ; }
public void simulateMethod ( SootMethod method , ReferenceVariable thisVar , ReferenceVariable returnVar , ReferenceVariable params [ ] ) { String subSignature = method . getSubSignature ( ) ; if ( subSignature . equals ( STR_ ) ) { java_lang_SecurityManager_getClassContext ( method , thisVar , returnVar , params ) ; return ; } else if ( subSignature . equals ( STR_ ) ) { java_lang_SecurityManager_currentClassLoader0 ( method , thisVar , returnVar , params ) ; return ; } else if ( subSignature . equals ( STR_ ) ) { java_lang_SecurityManager_currentLoadedClass0 ( method , thisVar , returnVar , params ) ; return ; } else { defaultMethod ( method , thisVar , returnVar , params ) ; return ; } }
public static boolean isFileExists ( final String path ) { if ( TextUtils . isEmpty ( path ) ) { Log . e ( FileUtils . class , STR_ ) ; return BOOL_ ; } final File fileToCheck = new File ( path ) ; return fileToCheck . exists ( ) && ! fileToCheck . isDirectory ( ) ; }
private List < Reference > createSignatureReferences ( XMLSignatureFactory xmlSigFactory , List < String > referenceIdList ) throws NoSuchAlgorithmException , InvalidAlgorithmParameterException { List < Reference > result = new ArrayList < Reference > ( ) ; for ( String refId : referenceIdList ) { if ( refId == null ) { continue ; } Reference ref = xmlSigFactory . newReference ( STR_ + refId , xmlSigFactory . newDigestMethod ( DigestMethod . SHA512 , null ) , Collections . singletonList ( xmlSigFactory . newCanonicalizationMethod ( CanonicalizationMethod . EXCLUSIVE , ( C14NMethodParameterSpec ) null ) ) , null , null ) ; result . add ( ref ) ; } return Collections . unmodifiableList ( result ) ; }
public boolean removeNetworkConnection ( NetworkConnection networkConnection ) { return networkConnections . remove ( networkConnection ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
protected Object convertArray ( Object value ) { return value ; }
public static String encodeString ( String s ) { return new String ( encode ( s . getBytes ( ) ) ) ; }
GridLuceneFile ( GridLuceneDirectory dir ) { this . dir = dir ; filesCnt . incrementAndGet ( ) ; }
public void addAttributes ( Attributes atts ) throws SAXException { int nAtts = atts . getLength ( ) ; for ( int i = NUM_ ; i < nAtts ; i ++ ) { String uri = atts . getURI ( i ) ; if ( null == uri ) uri = STR_ ; addAttributeAlways ( uri , atts . getLocalName ( i ) , atts . getQName ( i ) , atts . getType ( i ) , atts . getValue ( i ) , BOOL_ ) ; } }
public synchronized void addPanListener ( PanListener listener ) { mPanListeners . add ( listener ) ; }
public synchronized long lastOnlineAgo ( ) { return ( System . currentTimeMillis ( ) - lastOnline ) / NUM_ ; }
public NameSpace swap ( NameSpace newTop ) { NameSpace oldTop = ( NameSpace ) ( stack . elementAt ( NUM_ ) ) ; stack . setElementAt ( newTop , NUM_ ) ; return oldTop ; }
public static List < String > classesPath ( ) throws FileNotFoundException , LoadingFileException { List < File > files = getJavaFiles ( ) ; List < String > paths = new ArrayList < String > ( ) ; for ( File file : files ) paths . add ( file . getPath ( ) ) ; return paths ; }
public static Number sub ( Number a , Number b ) { if ( isFloatingPoint ( a ) || isFloatingPoint ( b ) ) { return a . doubleValue ( ) - b . doubleValue ( ) ; } else { return a . longValue ( ) - b . longValue ( ) ; } }
public static Stream < String > wordsOf ( String text ) { requireNonNull ( text ) ; return WORDS . splitAsStream ( text ) ; }
public static DeleteParticipant [ ] loadDeleteParticipants ( RefactoringStatus status , RefactoringProcessor processor , Object element , DeleteArguments arguments , IParticipantDescriptorFilter filter , String [ ] affectedNatures , SharableParticipants shared ) { RefactoringParticipant [ ] participants = fgDeleteInstance . getParticipants ( status , processor , element , arguments , filter , affectedNatures , shared ) ; DeleteParticipant [ ] result = new DeleteParticipant [ participants . length ] ; System . arraycopy ( participants , NUM_ , result , NUM_ , participants . length ) ; return result ; }
public PutResult ( String successCount , String failCount , List < String > errorMessages ) { _successCount = successCount ; _failCount = failCount ; _errorMessages = new ArrayList < > ( ) ; if ( errorMessages != null ) { _errorMessages . addAll ( errorMessages ) ; } }
@ Override public int hashCode ( ) { int myPosition = position ; int hash = NUM_ ; while ( myPosition < limit ) { hash = hash + get ( myPosition ++ ) ; } return hash ; }
public void print ( CharSequence text ) throws IOException { int size = text . length ( ) ; int pos = NUM_ ; for ( int i = NUM_ ; i < size ; i ++ ) { if ( text . charAt ( i ) == STR_ ) { write ( text . subSequence ( pos , size ) , i - pos + NUM_ ) ; pos = i + NUM_ ; atStartOfLine = BOOL_ ; } } write ( text . subSequence ( pos , size ) , size - pos ) ; }
public void closeRunningApp ( String deviceID , String app_package ) throws InterruptedException , IOException { cmd . runCommand ( STR_ + deviceID + STR_ + app_package ) ; }
@ AndroidOnly ( STR_ ) public void test_unwrap_05 ( ) { String host = STR_ ; int port = NUM_ ; ByteBuffer [ ] bbA = { ByteBuffer . allocate ( NUM_ ) , ByteBuffer . allocate ( NUM_ ) , ByteBuffer . allocate ( NUM_ ) } ; ByteBuffer bb = ByteBuffer . allocate ( NUM_ ) ; SSLEngine sse = getEngine ( host , port ) ; try { sse . unwrap ( bb , bbA , NUM_ , bbA . length ) ; fail ( STR_ ) ; } catch ( IllegalStateException iobe ) { } catch ( Exception e ) { fail ( e + STR_ ) ; } }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; String childData ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; nameNode = elementList . item ( NUM_ ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; child . replaceData ( NUM_ , NUM_ , STR_ ) ; childData = child . getData ( ) ; assertEquals ( STR_ , STR_ , childData ) ; }
public boolean filteroutInvalidation ( T tag , TagQualityStatus statusToAdd , String statusDescription , Timestamp timestamp ) { return filterout ( tag , tag . getValue ( ) , tag . getValueDescription ( ) , statusToAdd , statusDescription , timestamp ) ; }
public void bindY ( DoubleProperty yProperty ) { minYWorld . bind ( yProperty . add ( getMinY ( ) ) ) ; maxYWorld . bind ( minYWorld . add ( getHeight ( ) ) ) ; }
private void copyFieldAttributes ( ) { if ( ( loadFields == null ) || fields == null ) { return ; } for ( int i = NUM_ ; i < loadFields . length ; i ++ ) { ObjectStreamField loadField = loadFields [ i ] ; String name = loadField . getName ( ) ; for ( int j = NUM_ ; j < fields . length ; j ++ ) { ObjectStreamField field = fields [ j ] ; if ( name . equals ( field . getName ( ) ) ) { loadField . setUnshared ( field . isUnshared ( ) ) ; loadField . setOffset ( field . getOffset ( ) ) ; break ; } } } }
public static Uri . Builder appendId ( Uri . Builder builder , long id ) { return builder . appendEncodedPath ( String . valueOf ( id ) ) ; }
private static void beginStartingService ( Context context , Intent intent ) { synchronized ( sStartingServiceSync ) { if ( sStartingService == null ) { PowerManager pm = ( PowerManager ) context . getSystemService ( Context . POWER_SERVICE ) ; sStartingService = pm . newWakeLock ( PowerManager . PARTIAL_WAKE_LOCK , STR_ ) ; } sStartingService . acquire ( ) ; if ( context . startService ( intent ) == null ) { Log . e ( TAG , STR_ ) ; } } }
private Rect calcBounds ( int index , Paint paint ) { Rect bounds = new Rect ( ) ; CharSequence title = getTitle ( index ) ; bounds . right = ( int ) paint . measureText ( title , NUM_ , title . length ( ) ) ; bounds . bottom = ( int ) ( paint . descent ( ) - paint . ascent ( ) ) ; return bounds ; }
public static double stddev ( double [ ] a ) { return Math . sqrt ( var ( a ) ) ; }
public SimpleArgumentsBundle ( @ NonNull Map < String , String > arguments , @ NonNull DisplayMetrics metrics ) { mArguments = arguments ; mMetrics = metrics ; }
public static String collapseWhitespace ( String str ) { return collapse ( str , WHITE_SPACES , STR_ ) ; }
private void adjustASIAndCollectFollowElements ( CustomInternalN4JSParser previousParser , boolean strict , Set < FollowElement > result ) { ObservableXtextTokenStream tokens = ( ObservableXtextTokenStream ) previousParser . getTokenStream ( ) ; int lastTokenIndex = tokens . size ( ) - NUM_ ; if ( lastTokenIndex >= NUM_ ) { CommonToken lastToken = ( CommonToken ) tokens . LT ( - NUM_ ) ; @ SuppressWarnings ( STR_ ) List < Token > tokenList = tokens . getTokens ( ) ; if ( lastToken == null ) { return ; } if ( shouldSkipASI ( lastToken ) ) { if ( maySkipASI ( lastToken , tokens ) ) { tokenList . remove ( lastTokenIndex ) ; result . addAll ( resetAndGetFollowElements ( tokens , strict ) ) ; removePostfixOperator ( result ) ; } } else if ( shouldAddSyntheticSemicolon ( previousParser , lastTokenIndex , lastToken ) ) { CommonToken token = new CommonToken ( semi ) ; tokenList . add ( token ) ; result . addAll ( resetAndGetFollowElements ( tokens , strict ) ) ; removePostfixOperator ( result ) ; } } }
public LinkedList < Patch > patch_make ( String text1 , String text2 ) { if ( text1 == null || text2 == null ) { throw new IllegalArgumentException ( STR_ ) ; } LinkedList < Diff > diffs = diff_main ( text1 , text2 , BOOL_ ) ; if ( diffs . size ( ) > NUM_ ) { diff_cleanupSemantic ( diffs ) ; diff_cleanupEfficiency ( diffs ) ; } return patch_make ( text1 , diffs ) ; }
public void testBasicsV6 ( ) throws Exception { Directory dir = newDirectory ( ) ; RandomIndexWriter writer = new RandomIndexWriter ( random ( ) , dir ) ; Document document = new Document ( ) ; InetAddress address = InetAddress . getByName ( STR_ ) ; document . add ( new InetAddressPoint ( STR_ , address ) ) ; writer . addDocument ( document ) ; IndexReader reader = writer . getReader ( ) ; IndexSearcher searcher = newSearcher ( reader ) ; assertEquals ( NUM_ , searcher . count ( InetAddressPoint . newExactQuery ( STR_ , address ) ) ) ; assertEquals ( NUM_ , searcher . count ( InetAddressPoint . newPrefixQuery ( STR_ , address , NUM_ ) ) ) ; assertEquals ( NUM_ , searcher . count ( InetAddressPoint . newRangeQuery ( STR_ , InetAddress . getByName ( STR_ ) , InetAddress . getByName ( STR_ ) ) ) ) ; reader . close ( ) ; writer . close ( ) ; dir . close ( ) ; }
private boolean isMinorVersionUpgrade ( String currentVersion , String targetVersion ) { String currentDbSchemaVersion = VdcUtil . getDbSchemaVersion ( currentVersion ) ; if ( currentDbSchemaVersion == null ) { return BOOL_ ; } return currentDbSchemaVersion . equals ( VdcUtil . getDbSchemaVersion ( targetVersion ) ) ; }
public static final void exception ( Throwable e ) { logExpensive ( Level . SEVERE , e . getMessage ( ) , e ) ; }
private static DefaultAlignment valueOf ( String str , boolean isHorizontal ) { if ( str . equals ( STR_ ) || str . equals ( STR_ ) ) { return FILL_ALIGN ; } else if ( str . equals ( STR_ ) || str . equals ( STR_ ) ) { return CENTER_ALIGN ; } else if ( isHorizontal ) { if ( str . equals ( STR_ ) || str . equals ( STR_ ) ) { return RIGHT_ALIGN ; } else if ( str . equals ( STR_ ) || str . equals ( STR_ ) ) { return LEFT_ALIGN ; } else { return null ; } } else if ( str . equals ( STR_ ) || str . equals ( STR_ ) ) { return TOP_ALIGN ; } else if ( str . equals ( STR_ ) || str . equals ( STR_ ) ) { return BOTTOM_ALIGN ; } else { return null ; } }
public void combineSets ( HashMap < String , Set < String > > containerAffinities , OperatorPair pair ) { Set < String > set1 = containerAffinities . get ( pair . first ) ; Set < String > set2 = containerAffinities . get ( pair . second ) ; set1 . addAll ( set2 ) ; containerAffinities . put ( pair . first , set1 ) ; containerAffinities . put ( pair . second , set1 ) ; }
protected void firePropertyChange ( String propertyName , Object oldValue , Object newValue ) { propertyChangeSupport . firePropertyChange ( propertyName , oldValue , newValue ) ; }
@ Override public boolean isBusy ( ) { return ( m_splitThread != null ) ; }
public static < E > boolean isNotEmpty ( CharSequence c ) { return ( ( c != null ) && ( c . length ( ) > NUM_ ) ) ; }
@ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case EipPackage . COMPOSITE_PROCESSOR__NAME : return NAME_EDEFAULT == null ? name != null : ! NAME_EDEFAULT . equals ( name ) ; case EipPackage . COMPOSITE_PROCESSOR__TO_CHANNELS : return toChannels != null && ! toChannels . isEmpty ( ) ; case EipPackage . COMPOSITE_PROCESSOR__FROM_CHANNELS : return fromChannels != null && ! fromChannels . isEmpty ( ) ; case EipPackage . COMPOSITE_PROCESSOR__OWNED_ENDPOINTS : return ownedEndpoints != null && ! ownedEndpoints . isEmpty ( ) ; } return super . eIsSet ( featureID ) ; }
private void addInfoButton ( JPanel panel , Object o , String clientProp ) { JButton hButton ; hButton = new JButton ( o . toString ( ) ) ; hButton . putClientProperty ( clientProp , o ) ; hButton . addActionListener ( this ) ; hButton . setFont ( font ) ; hButton . setMargin ( new Insets ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; hButton . setBackground ( LOG_BUTTON_BG ) ; panel . add ( hButton ) ; }
public void removeNetworkListener ( NetworkListener networkListener ) { networkListeners . remove ( networkListener ) ; }
public static String chomp ( String s ) { if ( s . endsWith ( STR_ ) ) return s . substring ( NUM_ , s . length ( ) - NUM_ ) ; if ( s . endsWith ( STR_ ) || s . endsWith ( STR_ ) ) return s . substring ( NUM_ , s . length ( ) - NUM_ ) ; return s ; }
private void validateSurrogateSettings ( ) { faultySurrogatesRadioButton . setEnabled ( BOOL_ ) ; discardSurrogatesArticleRadioButton . setEnabled ( BOOL_ ) ; replaceSurrogatesRadioButton . setEnabled ( BOOL_ ) ; discardSurrogatesRevisionRadioButton . setSelected ( BOOL_ ) ; }
static DiskId createDiskId ( long maxOplogSize , boolean isPersistenceType , boolean needsLinkedList ) { long bytes = maxOplogSize . NUM_ . NUM_ ; if ( bytes > Integer . MAX_VALUE ) { if ( isPersistenceType ) { if ( needsLinkedList ) { return new PersistenceWithLongOffset ( ) ; } else { return new PersistenceWithLongOffsetNoLL ( ) ; } } else { if ( needsLinkedList ) { return new OverflowOnlyWithLongOffset ( ) ; } else { return new OverflowOnlyWithLongOffsetNoLL ( ) ; } } } else { if ( isPersistenceType ) { if ( needsLinkedList ) { return new PersistenceWithIntOffset ( ) ; } else { return new PersistenceWithIntOffsetNoLL ( ) ; } } else { if ( needsLinkedList ) { return new OverflowOnlyWithIntOffset ( ) ; } else { return new OverflowOnlyWithIntOffsetNoLL ( ) ; } } } }
public void startElement ( String namespaceURI , String localName , String name , Attributes atts ) throws org . xml . sax . SAXException { ElemContext elemContext = m_elemContext ; if ( elemContext . m_startTagOpen ) { closeStartTag ( ) ; elemContext . m_startTagOpen = BOOL_ ; } else if ( m_cdataTagOpen ) { closeCDATA ( ) ; m_cdataTagOpen = BOOL_ ; } else if ( m_needToCallStartDocument ) { startDocumentInternal ( ) ; m_needToCallStartDocument = BOOL_ ; } if ( m_needToOutputDocTypeDecl ) { String n = name ; if ( n == null || n . length ( ) == NUM_ ) { n = localName ; } outputDocTypeDecl ( n ) ; } if ( null != namespaceURI && namespaceURI . length ( ) > NUM_ ) { super . startElement ( namespaceURI , localName , name , atts ) ; return ; } try { ElemDesc elemDesc = getElemDesc2 ( name ) ; int elemFlags = elemDesc . getFlags ( ) ; if ( m_doIndent ) { boolean isBlockElement = ( elemFlags & ElemDesc . BLOCK ) != NUM_ ; if ( m_ispreserve ) m_ispreserve = BOOL_ ; else if ( ( null != elemContext . m_elementName ) && ( ! m_inBlockElem || isBlockElement ) ) { m_startNewLine = BOOL_ ; indent ( ) ; } m_inBlockElem = ! isBlockElement ; } if ( atts != null ) addAttributes ( atts ) ; m_isprevtext = BOOL_ ; final java . io . Writer writer = m_writer ; writer . write ( STR_ ) ; writer . write ( name ) ; if ( m_tracer != null ) firePseudoAttributes ( ) ; if ( ( elemFlags & ElemDesc . EMPTY ) != NUM_ ) { m_elemContext = elemContext . push ( ) ; m_elemContext . m_elementName = name ; m_elemContext . m_elementDesc = elemDesc ; return ; } else { elemContext = elemContext . push ( namespaceURI , localName , name ) ; m_elemContext = elemContext ; elemContext . m_elementDesc = elemDesc ; elemContext . m_isRaw = ( elemFlags & ElemDesc . RAW ) != NUM_ ; } if ( ( elemFlags & ElemDesc . HEADELEM ) != NUM_ ) { closeStartTag ( ) ; elemContext . m_startTagOpen = BOOL_ ; if ( ! m_omitMetaTag ) { if ( m_doIndent ) indent ( ) ; writer . write ( STR_ ) ; String encoding = getEncoding ( ) ; String encode = Encodings . getMimeEncoding ( encoding ) ; writer . write ( encode ) ; writer . write ( STR_ ) ; } } } catch ( IOException e ) { throw new SAXException ( e ) ; } }
public static long sizeOf ( Class clazz ) { long maxSize = headerSize ( clazz ) ; while ( clazz != Object . class ) { for ( Field f : clazz . getDeclaredFields ( ) ) { if ( ( f . getModifiers ( ) & Modifier . STATIC ) == NUM_ ) { long offset = unsafe . objectFieldOffset ( f ) ; if ( offset > maxSize ) { maxSize = offset + NUM_ ; } } } clazz = clazz . getSuperclass ( ) ; } return roundUpTo8 ( maxSize ) ; }
public void addHandler ( String columnName , SQLDataHandler handler ) { if ( m_overrides == null ) m_overrides = new HashMap ( NUM_ ) ; m_overrides . put ( columnName , handler ) ; }
public void addNearEvicted ( KeyCacheObject key ) { if ( nearEvicted == null ) nearEvicted = new ArrayList < > ( ) ; nearEvicted . add ( key ) ; }
public Word ( String word , String displayAs , String ... soundsLike ) { this ( ) ; this . word = word ; this . displayAs = displayAs ; this . soundsLike = Arrays . asList ( soundsLike ) ; }
public EnumeratedDistribution ( final List < Pair < T , Double > > pmf ) throws MathIllegalArgumentException { singletons = new ArrayList < > ( pmf . size ( ) ) ; final double [ ] probs = new double [ pmf . size ( ) ] ; for ( int i = NUM_ ; i < pmf . size ( ) ; i ++ ) { final Pair < T , Double > sample = pmf . get ( i ) ; singletons . add ( sample . getKey ( ) ) ; final double p = sample . getValue ( ) ; probs [ i ] = p ; } probabilities = checkAndNormalize ( probs ) ; cumulativeProbabilities = new double [ probabilities . length ] ; double sum = NUM_ ; for ( int i = NUM_ ; i < probabilities . length ; i ++ ) { sum += probabilities [ i ] ; cumulativeProbabilities [ i ] = sum ; } }
@ Override public Calendar next ( ) { if ( spot . equals ( endFinal ) ) { throw new NoSuchElementException ( ) ; } spot . add ( Calendar . DATE , NUM_ ) ; return ( Calendar ) spot . clone ( ) ; }
public void pauseWork ( ) { mExitTasksEarly = BOOL_ ; setPause ( BOOL_ ) ; if ( DEBUG ) { Log . d ( Log_TAG , String . format ( STR_ , this ) ) ; } }
public static List < ErrorLogger . ErrorObject > isVirtualTrackInCPLConformed ( PayloadRecord cplPayloadRecord , VirtualTrack virtualTrack , List < PayloadRecord > essencesHeaderPartitionPayloads ) throws IOException { List < VirtualTrack > virtualTracks = new ArrayList < > ( ) ; IMFErrorLogger imfErrorLogger = new IMFErrorLoggerImpl ( ) ; virtualTracks . add ( virtualTrack ) ; imfErrorLogger . addAllErrors ( checkVirtualTrackAndEssencesHeaderPartitionPayloadRecords ( virtualTracks , essencesHeaderPartitionPayloads ) ) ; if ( imfErrorLogger . hasFatalErrors ( ) ) { return imfErrorLogger . getErrors ( ) ; } imfErrorLogger . addAllErrors ( conformVirtualTracksInCPL ( cplPayloadRecord , essencesHeaderPartitionPayloads , BOOL_ ) ) ; return imfErrorLogger . getErrors ( ) ; }
public byte receiveOneByte ( ) { Log . d ( TAG , STR_ ) ; try { acquireLock ( ) ; mServerSocket . receive ( mReceivePacket ) ; Log . d ( TAG , STR_ + ( NUM_ + mReceivePacket . getData ( ) [ NUM_ ] ) ) ; return mReceivePacket . getData ( ) [ NUM_ ] ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return Byte . MIN_VALUE ; }
public static String encode ( byte [ ] input ) { if ( input . length == NUM_ ) { return STR_ ; } int zeros = NUM_ ; while ( zeros < input . length && input [ zeros ] == NUM_ ) { ++ zeros ; } input = Arrays . copyOf ( input , input . length ) ; char [ ] encoded = new char [ input . length . NUM_ ] ; int outputStart = encoded . length ; for ( int inputStart = zeros ; inputStart < input . length ; ) { encoded [ -- outputStart ] = ALPHABET [ divmod ( input , inputStart , NUM_ , NUM_ ) ] ; if ( input [ inputStart ] == NUM_ ) { ++ inputStart ; } } while ( outputStart < encoded . length && encoded [ outputStart ] == ENCODED_ZERO ) { ++ outputStart ; } while ( -- zeros >= NUM_ ) { encoded [ -- outputStart ] = ENCODED_ZERO ; } return new String ( encoded , outputStart , encoded . length - outputStart ) ; }
public static int [ ] cells ( int [ ] start , int [ ] end ) { Arrays . sort ( start ) ; Arrays . sort ( end ) ; int overlap = NUM_ ; int gaps = NUM_ ; for ( int i = NUM_ , j = NUM_ ; j < end . length ; ) { if ( i < start . length && start [ i ] < end [ j ] ) { overlap ++ ; i ++ ; } else { j ++ ; overlap -- ; } if ( overlap == NUM_ ) { gaps ++ ; } } int [ ] cells = new int [ gaps . NUM_ ] ; overlap = NUM_ ; gaps = NUM_ ; int previousOverlap = NUM_ ; for ( int i = NUM_ , j = NUM_ ; j < end . length ; ) { if ( i < start . length && start [ i ] < end [ j ] ) { overlap ++ ; if ( previousOverlap == NUM_ ) { cells [ gaps ++ ] = start [ i ] ; } i ++ ; } else { overlap -- ; if ( overlap == NUM_ ) { cells [ gaps ++ ] = end [ j ] ; } j ++ ; } previousOverlap = overlap ; } return cells ; }
@ Override public InStore openRead ( long address , int size ) { if ( fileSize ( ) < address + size ) { throw new IllegalStateException ( L . l ( STR_ , this , address , size , fileSize ( ) ) ) ; } if ( _isClosed . get ( ) ) { throw new IllegalStateException ( L . l ( STR_ , this ) ) ; } if ( _fileSize < address + size ) { throw new IllegalStateException ( L . l ( STR_ , Long . toHexString ( address ) , size ) ) ; } try { streamOpen ( address , size ) ; return openReadImpl ( address , size ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
List < Address > geoDecode ( String searchedLocation ) { try { Geocoder geo = new Geocoder ( sContext , Locale . getDefault ( ) ) ; List < Address > addresses = geo . getFromLocationName ( searchedLocation , NUM_ ) ; if ( addresses != null && addresses . size ( ) > NUM_ ) { return addresses ; } } catch ( Exception ex ) { } return null ; }
private boolean isIdentifierStartChar ( int position ) { if ( _len >= NUM_ && position >= _len ) { return BOOL_ ; } char ch = _working [ position ] ; return Character . isUnicodeIdentifierStart ( ch ) ; }
public void destroy ( ) { fallbackStorage . clear ( ) ; FileUtils . deleteQuietly ( fallbackStorageFile ) ; }
public static SelectClause create ( String ... propertyNames ) { List < SelectClauseElement > selectList = new ArrayList < SelectClauseElement > ( ) ; for ( String name : propertyNames ) { selectList . add ( new SelectClauseExpression ( new PropertyValueExpression ( name ) ) ) ; } return new SelectClause ( StreamSelector . ISTREAM_ONLY , selectList ) ; }
ConfigurationError ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; }
public static String makeMarginTransform ( double owidth , double oheight , double iwidth , double iheight , double lmargin , double tmargin , double rmargin , double bmargin ) { double swidth = iwidth + lmargin + rmargin ; double sheight = iheight + tmargin + bmargin ; double scale = Math . max ( swidth / owidth , sheight / oheight ) ; double offx = ( scale . owidth - swidth ) . NUM_ + lmargin ; double offy = ( scale . oheight - sheight ) . NUM_ + tmargin ; return STR_ + fmt ( NUM_ / scale ) + STR_ + fmt ( offx ) + STR_ + fmt ( offy ) + STR_ ; }
public static boolean isAttachment ( String contentDisposition ) { return contentDisposition != null && contentDisposition . regionMatches ( BOOL_ , NUM_ , STR_ , NUM_ , NUM_ ) ; }
private JMenu createInsertMenu ( ) { JMenu insertMenu = new JMenu ( STR_ ) ; insertMenu . add ( actionManager . getNewNetworkAction ( ) ) ; JMenu newGaugeSubMenu = new JMenu ( STR_ ) ; for ( Action action : actionManager . getPlotActions ( ) ) { newGaugeSubMenu . add ( action ) ; } insertMenu . add ( newGaugeSubMenu ) ; JMenu newWorldSubMenu = new JMenu ( STR_ ) ; for ( Action action : actionManager . getNewWorldActions ( ) ) { newWorldSubMenu . add ( action ) ; } insertMenu . add ( newWorldSubMenu ) ; insertMenu . addSeparator ( ) ; insertMenu . add ( actionManager . getNewDocViewerAction ( ) ) ; insertMenu . add ( actionManager . getNewConsoleAction ( ) ) ; return insertMenu ; }
public static Vector < String > findPackages ( ) { Vector < String > result ; Enumeration < String > packages ; initCache ( ) ; result = new Vector < String > ( ) ; packages = m_ClassCache . packages ( ) ; while ( packages . hasMoreElements ( ) ) { result . add ( packages . nextElement ( ) ) ; } Collections . sort ( result , new StringCompare ( ) ) ; return result ; }
public static String convertSystemNameToAlternate ( String systemName ) { if ( ! validSystemNameFormat ( systemName , systemName . charAt ( NUM_ ) , STR_ ) ) { return STR_ ; } String altName = STR_ ; altName = systemName ; return altName ; }
private void initializeUserDirectives ( ) { userDirectives = new ArrayList < > ( ) ; IEclipsePreferences preferences = VelocityCorePlugin . getPreferences ( ) ; String directives = preferences . get ( IPreferencesConstants . VELOCITY_USER_DIRECTIVES , STR_ ) ; StringTokenizer st = new StringTokenizer ( directives , STR_ ) ; while ( st . hasMoreElements ( ) ) { String directive = ( String ) st . nextElement ( ) ; String name = directive . substring ( NUM_ , directive . indexOf ( STR_ ) ) ; int type = ( directive . endsWith ( STR_ ) ? Directive . BLOCK : Directive . LINE ) ; userDirectives . add ( STR_ + name ) ; addDirective ( new VelocityDirective ( name , type ) ) ; } }
private synchronized void storeTimestampAndSetStatus ( Timestamper . TimestampSucceeded message , TimestampRecord timestampRecord ) throws Exception { try { persistTimestampRecord ( message , timestampRecord ) ; setTimestampSucceeded ( ) ; } catch ( Exception e ) { log . error ( STR_ , e ) ; setTimestampFailedRegardlessOfQueue ( new DateTime ( ) ) ; throw e ; } }
public static Character [ ] valuesOf ( char [ ] array ) { Character [ ] dest = new Character [ array . length ] ; for ( int i = NUM_ ; i < array . length ; i ++ ) { dest [ i ] = Character . valueOf ( array [ i ] ) ; } return dest ; }
public void mark ( int readlimit ) { stream . mark ( readlimit ) ; if ( markSupported ( ) ) { markpos = framePos ; markPushBackLen = pushBackLen ; if ( markPushBackLen > NUM_ ) { if ( markPushBackBuffer == null ) { markPushBackBuffer = new byte [ frameSize ] ; } System . arraycopy ( pushBackBuffer , NUM_ , markPushBackBuffer , NUM_ , markPushBackLen ) ; } } }
public void testCreatingLauncherWithJetty1 ( ) { SwtBotProjectCreation . createMavenGwtProjectIsCreated1 ( bot , PROJECT_NAME , PACKAGE_NAME ) ; SwtBotProjectDebug . launchGWTDevModeWithJettyThenTerminateIt ( bot , PROJECT_NAME ) ; String persistedArgs = SwtBotProjectDebug . getTheProgramArgsTextBox ( bot ) ; assertTrue ( persistedArgs . contains ( STR_ ) ) ; }
@ KnownFailure ( STR_ ) public void test_getTablesLjava_lang_StringLjava_lang_StringLjava_lang_String$Ljava_lang_String ( ) throws SQLException { String [ ] tablesName = { VIEW_NAME , DatabaseCreator . TEST_TABLE1 , DatabaseCreator . TEST_TABLE3 } ; String [ ] tablesType = { STR_ , STR_ } ; Arrays . sort ( tablesName ) ; Arrays . sort ( tablesType ) ; ResultSet rs = meta . getTables ( null , null , null , null ) ; while ( rs . next ( ) ) { assertTrue ( STR_ , Arrays . binarySearch ( tablesName , rs . getString ( STR_ ) ) > - NUM_ ) ; assertNull ( STR_ + rs . getString ( STR_ ) , rs . getString ( STR_ ) ) ; assertTrue ( STR_ , Arrays . binarySearch ( tablesType , rs . getString ( STR_ ) ) > - NUM_ ) ; assertEquals ( STR_ , STR_ , rs . getString ( STR_ ) ) ; } rs . close ( ) ; rs = meta . getTables ( conn . getCatalog ( ) , null , null , new String [ ] { STR_ , STR_ } ) ; assertFalse ( STR_ , rs . next ( ) ) ; rs . close ( ) ; rs = meta . getTables ( conn . getCatalog ( ) , null , null , new String [ ] { STR_ , STR_ } ) ; assertTrue ( STR_ , rs . next ( ) ) ; assertEquals ( STR_ , VIEW_NAME , rs . getString ( STR_ ) ) ; assertNull ( STR_ + rs . getString ( STR_ ) , rs . getString ( STR_ ) ) ; assertEquals ( STR_ , STR_ , rs . getString ( STR_ ) ) ; assertEquals ( STR_ , STR_ , rs . getString ( STR_ ) ) ; assertFalse ( STR_ , rs . next ( ) ) ; assertFalse ( STR_ , rs . next ( ) ) ; rs . close ( ) ; rs = meta . getTables ( null , null , STR_ , null ) ; while ( rs . next ( ) ) { assertTrue ( STR_ , Arrays . binarySearch ( tablesName , rs . getString ( STR_ ) ) > - NUM_ ) ; assertNull ( STR_ , rs . getString ( STR_ ) ) ; assertTrue ( STR_ , Arrays . binarySearch ( tablesType , rs . getString ( STR_ ) ) > - NUM_ ) ; assertEquals ( STR_ , STR_ , rs . getString ( STR_ ) ) ; } rs . close ( ) ; conn . close ( ) ; try { meta . getTables ( null , null , null , null ) ; fail ( STR_ ) ; } catch ( SQLException e ) { } }
public static boolean needsDefaultFormatter ( ValueFormatter formatter ) { if ( formatter == null ) return BOOL_ ; if ( formatter instanceof DefaultValueFormatter ) return BOOL_ ; return BOOL_ ; }
public boolean putGrammar ( SchemaGrammar grammar , boolean deep , boolean ignoreConflict ) { if ( ! ignoreConflict ) { return putGrammar ( grammar , deep ) ; } SchemaGrammar sg = getGrammar ( grammar . fTargetNamespace ) ; if ( sg == null ) { putGrammar ( grammar ) ; } if ( ! deep ) { return BOOL_ ; } Vector currGrammars = grammar . getImportedGrammars ( ) ; if ( currGrammars == null ) { return BOOL_ ; } Vector grammars = ( ( Vector ) currGrammars . clone ( ) ) ; SchemaGrammar sg1 , sg2 ; Vector gs ; for ( int i = NUM_ ; i < grammars . size ( ) ; i ++ ) { sg1 = ( SchemaGrammar ) grammars . elementAt ( i ) ; sg2 = getGrammar ( sg1 . fTargetNamespace ) ; if ( sg2 == null ) { gs = sg1 . getImportedGrammars ( ) ; if ( gs == null ) continue ; for ( int j = gs . size ( ) - NUM_ ; j >= NUM_ ; j -- ) { sg2 = ( SchemaGrammar ) gs . elementAt ( j ) ; if ( ! grammars . contains ( sg2 ) ) grammars . addElement ( sg2 ) ; } } else { grammars . remove ( sg1 ) ; } } for ( int i = grammars . size ( ) - NUM_ ; i >= NUM_ ; i -- ) { putGrammar ( ( SchemaGrammar ) grammars . elementAt ( i ) ) ; } return BOOL_ ; }
public List < N > nodes ( @ Nullable Object key , int cnt ) { return nodes ( key , cnt , null , null ) ; }
public boolean isExistsKey ( Connection connection , Object [ ] keys ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( STR_ ) ; builder . append ( tableName ) ; builder . append ( STR_ ) ; String delimiter = STR_ ; for ( String keyField : keyFieldNames ) { builder . append ( delimiter ) ; builder . append ( keyField ) ; builder . append ( STR_ ) ; delimiter = STR_ ; } String query = builder . toString ( ) ; PreparedStatement statement = null ; try { if ( ( ExecutionPathDebugLog . isDebugEnabled ) && ( log . isDebugEnabled ( ) ) ) { log . debug ( STR_ + query + STR_ + print ( keys ) + STR_ ) ; } statement = connection . prepareStatement ( query ) ; for ( int i = NUM_ ; i < keys . length ; i ++ ) { statement . setObject ( i + NUM_ , keys [ i ] ) ; } ResultSet rs = statement . executeQuery ( ) ; if ( ! rs . next ( ) ) { return BOOL_ ; } return BOOL_ ; } catch ( SQLException ex ) { String message = STR_ + query + STR_ + ex . getMessage ( ) ; log . error ( message , ex ) ; storeExceptionHandler . handle ( message , ex ) ; throw new StoreExceptionDBRel ( message , ex ) ; } finally { try { if ( statement != null ) statement . close ( ) ; } catch ( SQLException e ) { } } }
public static < T > T implement ( Class < T > type , Object object ) { if ( type . isInstance ( object ) ) { return type . cast ( object ) ; } return type . cast ( Proxy . newProxyInstance ( type . getClassLoader ( ) , new Class [ ] { type } , new DuckType ( object ) ) ) ; }
public boolean isIvrVsan ( int vsanId ) { boolean inRange = vsans . contains ( vsanId ) ; if ( ! inRange ) { for ( IntRange range : getVsansRanges ( ) ) { inRange = range . containsInteger ( vsanId ) ; if ( inRange ) { break ; } } } return inRange ; }
private void addBOMLines ( MProduct product , BigDecimal qty ) { MPPProductBOM bom = MPPProductBOM . getDefault ( product , null ) ; MPPProductBOMLine [ ] bomLines = bom . getLines ( BOOL_ ) ; for ( int i = NUM_ ; i < bomLines . length ; i ++ ) addBOMLine ( bomLines [ i ] , qty ) ; log . fine ( STR_ + bomLines . length ) ; }
private QueryExp buildOptionalQueryExp ( final String [ ] attributes , final Object [ ] values ) { QueryExp queryExp = null ; for ( int i = NUM_ ; i < attributes . length ; i ++ ) { if ( values [ i ] instanceof Boolean ) { if ( queryExp == null ) { queryExp = Query . eq ( Query . attr ( attributes [ i ] ) , Query . value ( ( ( Boolean ) values [ i ] ) ) ) ; } else { queryExp = Query . and ( queryExp , Query . eq ( Query . attr ( attributes [ i ] ) , Query . value ( ( ( Boolean ) values [ i ] ) ) ) ) ; } } else if ( values [ i ] instanceof Number ) { if ( queryExp == null ) { queryExp = Query . eq ( Query . attr ( attributes [ i ] ) , Query . value ( ( Number ) values [ i ] ) ) ; } else { queryExp = Query . and ( queryExp , Query . eq ( Query . attr ( attributes [ i ] ) , Query . value ( ( Number ) values [ i ] ) ) ) ; } } else if ( values [ i ] instanceof String ) { if ( queryExp == null ) { queryExp = Query . eq ( Query . attr ( attributes [ i ] ) , Query . value ( ( String ) values [ i ] ) ) ; } else { queryExp = Query . and ( queryExp , Query . eq ( Query . attr ( attributes [ i ] ) , Query . value ( ( String ) values [ i ] ) ) ) ; } } } return queryExp ; }
@ Override public Foo fetchByUuid_C_Last ( String uuid , long companyId , OrderByComparator < Foo > orderByComparator ) { int count = countByUuid_C ( uuid , companyId ) ; if ( count == NUM_ ) { return null ; } List < Foo > list = findByUuid_C ( uuid , companyId , count - NUM_ , count , orderByComparator ) ; if ( ! list . isEmpty ( ) ) { return list . get ( NUM_ ) ; } return null ; }
public final boolean at ( String str , CharSequence csq ) { int i = index ; int length = csq . length ( ) ; for ( int j = NUM_ ; j < str . length ( ) ; ) { if ( ( i >= length ) || ( str . charAt ( j ++ ) != csq . charAt ( i ++ ) ) ) return BOOL_ ; } return BOOL_ ; }
public static int findLastOf ( String container , String charSeq , int begin ) { for ( int i = begin ; i < container . length ( ) && i >= NUM_ ; -- i ) { if ( charSeq . contains ( STR_ + container . charAt ( i ) ) ) return i ; } return - NUM_ ; }
private static CookieOrigin adjustEffectiveHost ( final CookieOrigin origin ) { String host = origin . getHost ( ) ; boolean isLocalHost = BOOL_ ; for ( int i = NUM_ ; i < host . length ( ) ; i ++ ) { char ch = host . charAt ( i ) ; if ( ch == STR_ || ch == STR_ ) { isLocalHost = BOOL_ ; break ; } } if ( isLocalHost ) { host += STR_ ; return new CookieOrigin ( host , origin . getPort ( ) , origin . getPath ( ) , origin . isSecure ( ) ) ; } else { return origin ; } }
public boolean addBound ( TypeBound bound ) { if ( bound . isTrivial ( ) ) { return BOOL_ ; } final boolean wasAdded = internal_addBound ( bound ) ; if ( DEBUG ) { final String suffix = wasAdded ? STR_ : STR_ ; log ( STR_ + bound + suffix ) ; } return wasAdded ; }
public boolean remove ( SimEvent event ) { return sortedSet . remove ( event ) ; }
public static final void printThreadCpuTime ( final Thread thread ) { if ( tbe . isThreadCpuTimeEnabled ( ) ) { log . info ( STR_ + thread . getName ( ) + STR_ + getThreadCpuTime ( thread ) + STR_ ) ; } }
public static Version fromBits ( int major , int minor , int bugfix ) { return new Version ( major , minor , bugfix ) ; }
private static IMultiPoint [ ] randomPoints ( int n , int d , int scale ) { IMultiPoint points [ ] = new IMultiPoint [ n ] ; for ( int i = NUM_ ; i < n ; i ++ ) { StringBuilder sb = new StringBuilder ( ) ; for ( int j = NUM_ ; j < d ; j ++ ) { sb . append ( rGen . nextDouble ( ) . scale ) ; if ( j < d - NUM_ ) { sb . append ( STR_ ) ; } } points [ i ] = new Hyperpoint ( sb . toString ( ) ) ; } return points ; }
public static String bytesToString ( int [ ] b ) { if ( b . length < NUM_ ) { return STR_ ; } return String . format ( STR_ , b [ NUM_ ] , b [ NUM_ ] , b [ NUM_ ] , b [ NUM_ ] ) ; }
private String convertToIsoDateTime ( String humanReadableDateTime ) throws ParseException { DateFormat dfInitial = new SimpleDateFormat ( STR_ ) ; Date initialDateTime = dfInitial . parse ( humanReadableDateTime ) ; DateFormat df = new SimpleDateFormat ( STR_ ) ; return df . format ( initialDateTime ) ; }
private static boolean classNamesEqual ( String name1 , String name2 ) { name1 = name1 . substring ( name1 . lastIndexOf ( STR_ ) + NUM_ ) ; name2 = name2 . substring ( name2 . lastIndexOf ( STR_ ) + NUM_ ) ; return name1 . equals ( name2 ) ; }
public boolean optBoolean ( int index ) { return optBoolean ( index , BOOL_ ) ; }
public CommandBuilder withLongSwitchIfPresent ( Map < String , Object > properties , String ... keys ) { withLongSwitchIfPresent ( properties , UnaryOperator . identity ( ) , keys ) ; return this ; }
private static boolean hasSpecializedHandlerIntents ( Context context , Intent intent ) { try { PackageManager pm = context . getPackageManager ( ) ; List < ResolveInfo > handlers = pm . queryIntentActivities ( intent , PackageManager . GET_RESOLVED_FILTER ) ; if ( handlers == null || handlers . size ( ) == NUM_ ) { return BOOL_ ; } for ( ResolveInfo resolveInfo : handlers ) { IntentFilter filter = resolveInfo . filter ; if ( filter == null ) continue ; if ( filter . countDataAuthorities ( ) == NUM_ || filter . countDataPaths ( ) == NUM_ ) continue ; if ( resolveInfo . activityInfo == null ) continue ; return BOOL_ ; } } catch ( RuntimeException e ) { Log . e ( TAG , STR_ ) ; } return BOOL_ ; }
private void onCollectionClicked ( Long collectionId ) { Intent intent = new Intent ( this , ProductListActivity . class ) ; if ( collectionId != null ) { intent . putExtra ( ProductListActivity . EXTRA_COLLECTION_ID , collectionId ) ; } startActivity ( intent ) ; }
public void addFrequency ( Frequency frequency ) { frequencies . add ( frequency ) ; }
public boolean isItemStackRegisteredForName ( ItemStack stack , String oreName ) { final int [ ] oreIDs = OreDictionary . getOreIDs ( stack ) ; for ( final int oreID : oreIDs ) { if ( oreName . equals ( OreDictionary . getOreName ( oreID ) ) ) { return BOOL_ ; } } return BOOL_ ; }
private static @ Nonnull URL [ ] createClassloaderUrls ( @ Nonnull URL url ) throws PluginException { List < URL > urls = new ArrayList < URL > ( ) ; urls . add ( url ) ; Manifest mf = null ; File f = new File ( url . getPath ( ) ) ; if ( ! f . isDirectory ( ) ) { JarInputStream jis = null ; try { jis = new JarInputStream ( url . openStream ( ) ) ; mf = jis . getManifest ( ) ; } catch ( IOException ioe ) { throw new PluginException ( STR_ + url , ioe ) ; } finally { IO . close ( jis ) ; } } else { File manifest = guessManifest ( f ) ; if ( manifest != null ) { FileInputStream is = null ; try { is = new FileInputStream ( manifest ) ; mf = new Manifest ( is ) ; } catch ( IOException e ) { throw new PluginException ( STR_ + url , e ) ; } finally { IO . close ( is ) ; } } } if ( mf != null ) { try { addClassPathFromManifest ( url , urls , mf ) ; } catch ( MalformedURLException e ) { throw new PluginException ( STR_ + url , e ) ; } } return urls . toArray ( new URL [ urls . size ( ) ] ) ; }
@ Override public void write ( String str , int st , int end ) throws IOException { out . write ( str , st , end ) ; }
public boolean isAwake ( ) { return isAwake ; }
private static void transferStreams ( InputStream source , OutputStream destination ) { byte [ ] buffer = new byte [ NUM_ ] ; try { while ( BOOL_ ) { int bytesRead = - NUM_ ; try { bytesRead = source . read ( buffer ) ; } catch ( IOException e ) { return ; } if ( bytesRead == - NUM_ ) break ; try { destination . write ( buffer , NUM_ , bytesRead ) ; } catch ( IOException e ) { return ; } } } finally { try { source . close ( ) ; } catch ( IOException e ) { } finally { try { destination . close ( ) ; } catch ( IOException e ) { } } } }
public static void gc ( ) { if ( startedGc ) { forceGc = BOOL_ ; gcShouldLoop = BOOL_ ; } startGCThread ( ) ; synchronized ( LOCK ) { LOCK . notify ( ) ; } try { Thread . sleep ( NUM_ ) ; } catch ( InterruptedException er ) { } }
private ArrayList < E > toArrayList ( ) { ArrayList < E > list = new ArrayList < E > ( ) ; for ( Node < E > p = first ( ) ; p != null ; p = succ ( p ) ) { E item = p . item ; if ( item != null ) list . add ( item ) ; } return list ; }
public static BlobEntry isBlobEntryForStoring ( String repositoryLocation , String mimeType ) { RepositoryLocation location ; try { location = new RepositoryLocation ( repositoryLocation ) ; Entry entry = location . locateEntry ( ) ; if ( entry instanceof BlobEntry ) { BlobEntry blobEntry = ( BlobEntry ) entry ; if ( mimeType . equals ( blobEntry . getMimeType ( ) ) ) { return blobEntry ; } else { SwingTools . showSimpleErrorMessage ( STR_ , blobEntry . getName ( ) ) ; return null ; } } else if ( entry == null ) { return createBlobEntry ( repositoryLocation ) ; } else { SwingTools . showSimpleErrorMessage ( STR_ , entry . getName ( ) ) ; } } catch ( RepositoryException e ) { SwingTools . showSimpleErrorMessage ( STR_ , e ) ; } catch ( MalformedRepositoryLocationException e ) { SwingTools . showSimpleErrorMessage ( STR_ , e ) ; } return null ; }
@ RequestMapping ( value = { STR_ , STR_ } , method = RequestMethod . PUT ) @ ResponseBody public RestWrapper insert ( @ ModelAttribute ( STR_ ) @ Valid Batch batch , BindingResult bindingResult , Principal principal ) { RestWrapper restWrapper = null ; if ( bindingResult . hasErrors ( ) ) { BindingResultError bindingResultError = new BindingResultError ( ) ; return bindingResultError . errorMessage ( bindingResult ) ; } try { com . wipro . ats . bdre . md . dao . jpa . Batch jpaBatch = new com . wipro . ats . bdre . md . dao . jpa . Batch ( ) ; jpaBatch . setBatchType ( batch . getBatchType ( ) ) ; InstanceExec instanceExec = new InstanceExec ( ) ; if ( batch . getSourceInstanceExecId ( ) != null ) { instanceExec . setInstanceExecId ( batch . getSourceInstanceExecId ( ) ) ; jpaBatch . setInstanceExec ( instanceExec ) ; } Long autoGenBatchId = batchDAO . insert ( jpaBatch ) ; batch . setBatchId ( autoGenBatchId ) ; restWrapper = new RestWrapper ( batch , RestWrapper . OK ) ; LOGGER . info ( RECORDWITHID + batch . getBatchId ( ) + STR_ + principal . getName ( ) + batch ) ; } catch ( MetadataException e ) { LOGGER . error ( e ) ; restWrapper = new RestWrapper ( e . getMessage ( ) , RestWrapper . ERROR ) ; } return restWrapper ; }
private void onClickGalleryImage ( final RecentMedia aMediaItem ) { if ( null != mCamera ) { mCamera . stopPreview ( ) ; } mSelectedGalleryItemsList . add ( aMediaItem ) ; if ( ( null != aMediaItem . mThumbnail ) && ! mIsAvatarMode ) { updateUiConfiguration ( UI_SHOW_TAKEN_IMAGE , IMAGE_ORIGIN_GALLERY ) ; mImagePreviewImageView . setImageBitmap ( aMediaItem . mThumbnail ) ; VectorApp . setSavedCameraImagePreview ( aMediaItem . mThumbnail ) ; } else if ( null != aMediaItem . mFileUri ) { displayImagePreview ( null , null , aMediaItem . mFileUri , IMAGE_ORIGIN_GALLERY ) ; } else { Log . e ( LOG_TAG , STR_ ) ; } mImagePreviewImageView . setTag ( aMediaItem . mFileUri ) ; }
public static double pareto ( double alpha ) { if ( ! ( alpha > NUM_ ) ) throw new IllegalArgumentException ( STR_ ) ; return Math . pow ( NUM_ - uniform ( ) , - NUM_ / alpha ) - NUM_ ; }
public void disconnectFromBroker ( final MqttAsyncConnection connection ) { try { connection . disconnect ( new MqttDisconnectionResultHandler ( ) ) ; } catch ( SpyException e ) { Platform . runLater ( new MqttEventHandler ( new MqttDisconnectionAttemptFailureEvent ( connection , e ) ) ) ; logger . error ( e . getMessage ( ) , e ) ; } }
public Object [ ] copyAll ( ) { return Arrays . copyOf ( args , args . length ) ; }
public void start ( ) { LOG . info ( STR_ , port , logLevel ) ; try { component . start ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( STR_ , e ) ; } LOG . info ( STR_ , port ) ; running = BOOL_ ; started = System . currentTimeMillis ( ) ; }
public FSAccountFedInfo readAccountFedInfo ( String userID , String providerID ) throws FSAccountMgmtException { return readAccountFedInfo ( userID , providerID , null ) ; }
public Response ( String status , String mimeType , String txt ) { this . status = status ; this . mimeType = mimeType ; try { this . data = new ByteArrayInputStream ( txt . getBytes ( STR_ ) ) ; } catch ( java . io . UnsupportedEncodingException uee ) { uee . printStackTrace ( ) ; } }
@ Parallel @ Realtime ( limit = LINEAR ) public E reduce ( BinaryOperator < E > operator ) { Iterator < E > itr = iterator ( ) ; if ( ! itr . hasNext ( ) ) return null ; E accumulator = itr . next ( ) ; while ( itr . hasNext ( ) ) accumulator = operator . apply ( accumulator , itr . next ( ) ) ; return accumulator ; }
public void saveHistory ( String filename ) throws Exception { FileOutputStream fos = new FileOutputStream ( filename ) ; ObjectOutputStream oos = new ObjectOutputStream ( fos ) ; oos . writeObject ( getHistory ( ) ) ; oos . close ( ) ; }
private void checkSize ( final int i ) { if ( i >= max_size ) { final int old_size = max_size ; max_size += increment_size ; if ( max_size <= i ) { max_size = i + increment_size + NUM_ ; } final double [ ] temp = items ; items = new double [ max_size ] ; System . arraycopy ( temp , NUM_ , items , NUM_ , old_size ) ; increment_size = incrementSize ( increment_size ) ; } }
public double nextGaussian ( ) { return random . nextGaussian ( ) ; }
private void readFromProperties ( final Properties props , final boolean defaultMinimized , final int defaultX , final int defaultY , final boolean defaultVisible ) { minimized = Boolean . parseBoolean ( props . getProperty ( STR_ + name + STR_ , Boolean . toString ( defaultMinimized ) ) ) ; visible = Boolean . parseBoolean ( props . getProperty ( STR_ + name + STR_ , Boolean . toString ( defaultVisible ) ) ) ; x = Integer . parseInt ( props . getProperty ( STR_ + name + STR_ , Integer . toString ( defaultX ) ) ) ; y = Integer . parseInt ( props . getProperty ( STR_ + name + STR_ , Integer . toString ( defaultY ) ) ) ; }
public boolean sendEMailAttachments ( int AD_User_ID , String subject , String message , Collection < File > attachments , boolean html ) { MUser to = MUser . get ( getCtx ( ) , AD_User_ID ) ; String toEMail = to . getEMail ( ) ; if ( toEMail == null || toEMail . length ( ) == NUM_ ) { log . warning ( STR_ + to ) ; return BOOL_ ; } EMail email = createEMail ( null , to , subject , message , html ) ; if ( email == null ) return BOOL_ ; email . addAttachments ( attachments ) ; try { return sendEmailNow ( null , to , email ) ; } catch ( Exception ex ) { log . severe ( getName ( ) + STR_ + ex . getLocalizedMessage ( ) ) ; return BOOL_ ; } }
private void addUnitTaxCalculationInfoClone ( final TaxCalculationInfo taxCalInfo , final TaxCalculationInfo clone ) { final List < UnitTaxCalculationInfo > units = new ArrayList < UnitTaxCalculationInfo > ( ) ; final List < UnitTaxCalculationInfo > unitsByDate = new ArrayList < UnitTaxCalculationInfo > ( ) ; for ( final UnitTaxCalculationInfo unitInfo : taxCalInfo . getUnitTaxCalculationInfos ( ) ) { final UnitTaxCalculationInfo newUnitInfo = getUnitTaxCalculationInfoClone ( unitInfo ) ; unitsByDate . add ( newUnitInfo ) ; } clone . setUnitTaxCalculationInfo ( units ) ; }
public SocketWrapper accept ( ) throws IOException { for ( ; ; ) { try { Socket sock = serverSocket . accept ( ) ; return new SocketWrapper ( sock ) ; } catch ( SocketTimeoutException e ) { } catch ( IOException e ) { if ( done ) { throw new SocketTerminationException ( STR_ , e ) ; } else { throw e ; } } } }
private String replaceDotInMustacheKeys ( final List < String > mustacheKeys , final String pluginCall ) { String fixedPluginCall = pluginCall ; for ( String mustacheKey : mustacheKeys ) { if ( mustacheKey . contains ( STR_ ) ) { fixedPluginCall = fixedPluginCall . replace ( STR_ + mustacheKey + STR_ , STR_ + mustacheKey . replace ( STR_ , STR_ ) + STR_ ) ; } } return fixedPluginCall ; }
protected synchronized Instance processBuffers ( ) { if ( m_firstBuffer != null && m_secondBuffer != null && m_firstBuffer . size ( ) > NUM_ && m_secondBuffer . size ( ) > NUM_ ) { if ( m_stopRequested . get ( ) ) { return null ; } InstanceHolder firstH = m_firstBuffer . peek ( ) ; InstanceHolder secondH = m_secondBuffer . peek ( ) ; Instance first = firstH . m_instance ; Instance second = secondH . m_instance ; int cmp = compare ( first , second , firstH , secondH ) ; if ( cmp == NUM_ ) { Instance newInst = generateMergedInstance ( m_firstBuffer . remove ( ) , m_secondBuffer . remove ( ) ) ; return newInst ; } else if ( cmp < NUM_ ) { do { m_firstBuffer . remove ( ) ; if ( m_firstBuffer . size ( ) > NUM_ ) { firstH = m_firstBuffer . peek ( ) ; first = firstH . m_instance ; cmp = compare ( first , second , firstH , secondH ) ; } } while ( cmp < NUM_ && m_firstBuffer . size ( ) > NUM_ ) ; } else { do { m_secondBuffer . remove ( ) ; if ( m_secondBuffer . size ( ) > NUM_ ) { secondH = m_secondBuffer . peek ( ) ; second = secondH . m_instance ; cmp = compare ( first , second , firstH , secondH ) ; } } while ( cmp > NUM_ && m_secondBuffer . size ( ) > NUM_ ) ; } } return null ; }
public boolean isThemeConstant ( String constantName , boolean def ) { String c = getThemeConstant ( constantName , null ) ; if ( c == null ) { return def ; } return c . equalsIgnoreCase ( STR_ ) || c . equals ( STR_ ) ; }
public void testDelete4 ( ) throws SQLException { DatabaseCreator . fillFKCascadeTable ( conn ) ; statement . execute ( STR_ + DatabaseCreator . PARENT_TABLE + STR_ ) ; }
public void unmap ( int addr , int len ) { for ( int i = NUM_ ; i < len ; i += PAGE_SIZE ) { int pte = getPTE ( addr + i ) ; if ( getPage ( pte ) != null ) { readableMemory [ pte ] = null ; writableMemory [ pte ] = null ; executableMemory [ pte ] = null ; } else { throw new Error ( STR_ + Integer . toHexString ( addr ) + STR_ + len ) ; } } }
private synchronized void saveToSettings ( ) { List < List > entriesToSave = new ArrayList < > ( ) ; for ( StatusHistoryEntry entry : entries . values ( ) ) { entriesToSave . add ( entryToList ( entry ) ) ; } settings . putList ( STR_ , entriesToSave ) ; }
protected void addToMaintenanceQueue ( NodePortTuple npt ) { if ( maintenanceQueue . contains ( npt ) == BOOL_ ) maintenanceQueue . add ( npt ) ; }
public MovieScraperMetadataPanel ( MovieScraperMetadataConfig config ) { this . config = config ; initComponents ( ) ; }
public int size ( ) { return seq . size ( ) ; }
public static void assertPropsPerRow ( Iterator < EventBean > iterator , SafeIterator < EventBean > safeIterator , String [ ] propertyNames , Object [ ] [ ] expected ) { assertPropsPerRow ( EPAssertionUtil . iteratorToArray ( iterator ) , propertyNames , expected ) ; assertPropsPerRow ( EPAssertionUtil . iteratorToArray ( safeIterator ) , propertyNames , expected ) ; safeIterator . close ( ) ; }
public boolean isLeaf ( ) { return children == null || children . isEmpty ( ) ; }
public void testGet ( ) throws Exception { IgniteCache < Long , Long > cache = populate ( ) ; for ( long i = from ; i < to ; i ++ ) { Long val = cache . get ( i ) ; assertNotNull ( val ) ; assertEquals ( i , val . longValue ( ) ) ; } assertEquals ( NUM_ , swappedCnt . get ( ) ) ; assertEquals ( NUM_ , offheapedCnt . get ( ) ) ; assertEquals ( to - from , unswapedCnt . get ( ) + onheapedCnt . get ( ) ) ; checkEntries ( cache ) ; assertEquals ( to - from , unswapedCnt . get ( ) + onheapedCnt . get ( ) ) ; }
public int read ( ) throws IOException { if ( hasNextChar ) { hasNextChar = BOOL_ ; write ( nextChar ) ; return nextChar ; } if ( previousLine != lexer . getLine ( ) ) { numUnicodeEscapesFoundOnCurrentLine = NUM_ ; previousLine = lexer . getLine ( ) ; } int c = reader . read ( ) ; if ( c != STR_ ) { write ( c ) ; return c ; } c = reader . read ( ) ; if ( c != STR_ ) { hasNextChar = BOOL_ ; nextChar = c ; write ( STR_ ) ; return STR_ ; } int numberOfUChars = NUM_ ; do { numberOfUChars ++ ; c = reader . read ( ) ; } while ( c == STR_ ) ; checkHexDigit ( c ) ; StringBuilder charNum = new StringBuilder ( ) ; charNum . append ( ( char ) c ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { c = reader . read ( ) ; checkHexDigit ( c ) ; charNum . append ( ( char ) c ) ; } int rv = Integer . parseInt ( charNum . toString ( ) , NUM_ ) ; write ( rv ) ; numUnicodeEscapesFound += NUM_ + numberOfUChars ; numUnicodeEscapesFoundOnCurrentLine += NUM_ + numberOfUChars ; return rv ; }
public boolean isEmpty ( ) { if ( ! built ) return itemBoundables . isEmpty ( ) ; return root . isEmpty ( ) ; }
protected AbstractWriter ( Writer w , Document doc , int pos , int len ) { this . doc = doc ; it = new ElementIterator ( doc . getDefaultRootElement ( ) ) ; out = w ; startOffset = pos ; endOffset = pos + len ; Object docNewline = doc . getProperty ( DefaultEditorKit . EndOfLineStringProperty ) ; if ( docNewline instanceof String ) { setLineSeparator ( ( String ) docNewline ) ; } else { String newline = null ; try { newline = System . getProperty ( STR_ ) ; } catch ( SecurityException se ) { } if ( newline == null ) { newline = STR_ ; } setLineSeparator ( newline ) ; } canWrapLines = BOOL_ ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
@ Override public Node importTo ( Document hostDocument ) { ValidateUtil . validateNotNull ( hostDocument , STR_ ) ; Element clonedTokenElement = ( Element ) hostDocument . importNode ( _parsedToken . getDocumentElement ( ) , BOOL_ ) ; markAssertionIdAttribute ( clonedTokenElement ) ; return clonedTokenElement ; }
public static Matrix random ( int m , int n ) { Matrix A = new Matrix ( m , n ) ; double [ ] [ ] X = A . getArray ( ) ; for ( int i = NUM_ ; i < m ; i ++ ) { for ( int j = NUM_ ; j < n ; j ++ ) { X [ i ] [ j ] = Math . random ( ) ; } } return A ; }
public void addPriorityUnit ( String id ) { if ( ! StringUtil . isPositiveInteger ( id ) ) { return ; } addPriorityUnit ( Integer . parseInt ( id ) ) ; }
private void calcIntervalDis ( ) { if ( mMarkTextPaint == null ) { return ; } String defaultText = STR_ ; Rect temp = new Rect ( ) ; int max = NUM_ ; if ( mItems != null && mItems . size ( ) > NUM_ ) { for ( String i : mItems ) { mMarkTextPaint . getTextBounds ( i , NUM_ , i . length ( ) , temp ) ; if ( temp . width ( ) > max ) { max = temp . width ( ) ; } } } else { mMarkTextPaint . getTextBounds ( defaultText , NUM_ , defaultText . length ( ) , temp ) ; max = temp . width ( ) ; } if ( ! TextUtils . isEmpty ( mAdditionCenterMark ) ) { mMarkTextPaint . setTextSize ( mNormalTextSize ) ; mMarkTextPaint . getTextBounds ( mAdditionCenterMark , NUM_ , mAdditionCenterMark . length ( ) , temp ) ; mAdditionCenterMarkWidth = temp . width ( ) ; max += temp . width ( ) ; } mIntervalDis = max . mIntervalFactor ; }
public boolean isUseSoftkeys ( ) { return useSoftkeys ; }
public void testDivisionKnuthFirstDigitsEqual ( ) { byte aBytes [ ] = { NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ } ; int aSign = - NUM_ ; int bSign = - NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . divide ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public void connectionClosed ( ConnectionEvent event ) { if ( isActive ) { ManagedConnection conn = ( ManagedConnection ) event . getSource ( ) ; TransactionManagerImpl transManager = TransactionManagerImpl . getTransactionManager ( ) ; try { Transaction txn = transManager . getTransaction ( ) ; if ( txn == null ) { mannPoolCache . returnPooledConnectionToPool ( conn ) ; } } catch ( Exception se ) { String exception = STR_ + se . getMessage ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( exception , se ) ; } } } }
public MetadataBlockHeader ( boolean isLastBlock , BlockType blockType , int dataLength ) { ByteBuffer rawdata = ByteBuffer . allocate ( HEADER_LENGTH ) ; this . blockType = blockType ; this . isLastBlock = isLastBlock ; this . dataLength = dataLength ; byte type ; if ( isLastBlock ) { type = ( byte ) ( x80 | blockType . getId ( ) ) ; } else { type = ( byte ) blockType . getId ( ) ; } rawdata . put ( type ) ; rawdata . put ( ( byte ) ( ( dataLength & xFF0000 ) > > > NUM_ ) ) ; rawdata . put ( ( byte ) ( ( dataLength & xFF00 ) > > > NUM_ ) ) ; rawdata . put ( ( byte ) ( dataLength & xFF ) ) ; bytes = new byte [ HEADER_LENGTH ] ; for ( int i = NUM_ ; i < HEADER_LENGTH ; i ++ ) { bytes [ i ] = rawdata . get ( i ) ; } }
private void checkFileToRun ( ) throws ExitCodeException { if ( runThisFile == null || ! runThisFile . exists ( ) ) { throw new ExitCodeException ( EXITCODE_MODULE_TO_RUN_NOT_FOUND ) ; } }
public void addLastItem ( M model ) { addItem ( mDatas . size ( ) , model ) ; }
@ ManagedOperation ( description = STR_ ) public void notifyAllTagCacheListeners ( ) { LOGGER . info ( STR_ ) ; for ( Long key : controlTagCache . getKeys ( ) ) { controlTagCache . acquireWriteLockOnKey ( key ) ; try { ControlTag controlTag = controlTagCache . getCopy ( key ) ; long eventTime = System . currentTimeMillis ( ) ; controlTagCache . notifyListenerStatusConfirmation ( controlTag , eventTime ) ; } finally { controlTagCache . releaseWriteLockOnKey ( key ) ; } } for ( Long key : dataTagCache . getKeys ( ) ) { dataTagCache . acquireWriteLockOnKey ( key ) ; try { DataTag dataTag = dataTagCache . getCopy ( key ) ; long eventTime = System . currentTimeMillis ( ) ; dataTagCache . notifyListenerStatusConfirmation ( dataTag , eventTime ) ; } finally { dataTagCache . releaseWriteLockOnKey ( key ) ; } } LOGGER . info ( STR_ ) ; }
public static long [ ] breakdown ( long t , @ NonNull TimeUnit unit , boolean roundMillis ) { long days = unit . toDays ( t ) ; long hours = unit . toHours ( t ) % NUM_ ; long minutes = unit . toMinutes ( t ) % NUM_ ; long seconds = unit . toSeconds ( t ) % NUM_ ; long msecs = unit . toMillis ( t ) % NUM_ ; if ( roundMillis ) { if ( msecs >= NUM_ ) { seconds ++ ; msecs = NUM_ ; if ( seconds == NUM_ ) { minutes ++ ; seconds = NUM_ ; if ( minutes == NUM_ ) { hours ++ ; minutes = NUM_ ; if ( hours == NUM_ ) { days ++ ; hours = NUM_ ; } } } } } return new long [ ] { days , hours , minutes , seconds , msecs } ; }
private int socksGetServerPort ( ) { InetSocketAddress addr = ( InetSocketAddress ) proxy . address ( ) ; return addr . getPort ( ) ; }
public static < T > ReactiveSeq < T > fromList ( final List < T > list ) { Objects . requireNonNull ( list ) ; final ReversingListSpliterator array = new ReversingListSpliterator < T > ( list , BOOL_ ) ; return StreamUtils . reactiveSeq ( StreamSupport . stream ( array , BOOL_ ) , Optional . ofNullable ( array ) ) ; }
private boolean processKeyUp ( int keyCode ) { if ( keyCode == KeyEvent . KEYCODE_DEL ) { if ( mInKbMode ) { if ( ! mTypedTimes . isEmpty ( ) ) { int deleted = deleteLastTypedKey ( ) ; String deletedKeyStr ; if ( deleted == getAmOrPmKeyCode ( AM ) ) { deletedKeyStr = mAmText ; } else if ( deleted == getAmOrPmKeyCode ( PM ) ) { deletedKeyStr = mPmText ; } else { deletedKeyStr = String . format ( STR_ , getValFromKeyCode ( deleted ) ) ; } ViewCompatUtils . announceForAccessibility ( mDelegator , String . format ( mDeletedKeyFormat , deletedKeyStr ) ) ; updateDisplay ( BOOL_ ) ; } } } else if ( keyCode == KeyEvent . KEYCODE_0 || keyCode == KeyEvent . KEYCODE_1 || keyCode == KeyEvent . KEYCODE_2 || keyCode == KeyEvent . KEYCODE_3 || keyCode == KeyEvent . KEYCODE_4 || keyCode == KeyEvent . KEYCODE_5 || keyCode == KeyEvent . KEYCODE_6 || keyCode == KeyEvent . KEYCODE_7 || keyCode == KeyEvent . KEYCODE_8 || keyCode == KeyEvent . KEYCODE_9 || ( ! mIs24HourView && ( keyCode == getAmOrPmKeyCode ( AM ) || keyCode == getAmOrPmKeyCode ( PM ) ) ) ) { if ( ! mInKbMode ) { if ( mRadialTimePickerView == null ) { Log . e ( TAG , STR_ ) ; return BOOL_ ; } mTypedTimes . clear ( ) ; tryStartingKbMode ( keyCode ) ; return BOOL_ ; } if ( addKeyIfLegal ( keyCode ) ) { updateDisplay ( BOOL_ ) ; } return BOOL_ ; } return BOOL_ ; }
public synchronized OMGraphicList prepare ( ) { OMGraphicList list = new OMGraphicList ( ) ; Projection proj = getProjection ( ) ; if ( proj == null ) { return list ; } Point2D upperLeft = proj . getUpperLeft ( ) ; Point2D lowerRight = proj . getLowerRight ( ) ; if ( upperLeft . getX ( ) > lowerRight . getX ( ) ) { getPoints ( new DataBounds ( upperLeft , new Point2D . Double ( NUM_ , lowerRight . getY ( ) ) ) , list , proj ) ; getPoints ( new DataBounds ( new Point2D . Double ( - NUM_ , upperLeft . getY ( ) ) , lowerRight ) , list , proj ) ; } else { getPoints ( new DataBounds ( upperLeft , lowerRight ) , list , proj ) ; } OMText statement = new OMText ( NUM_ , proj . getHeight ( ) - NUM_ , getName ( ) + STR_ + list . size ( ) + STR_ + dataSource . size ( ) + STR_ , OMText . JUSTIFY_LEFT ) ; statement . setFillPaint ( Color . gray ) ; statement . generate ( proj ) ; list . add ( NUM_ , statement ) ; return list ; }
public X509Name ( Vector oids , Vector values ) { this ( oids , values , new X509DefaultEntryConverter ( ) ) ; }
void nextLine ( ) { try { nextLine = currentEpisode . readLine ( ) ; while ( nextLine . equals ( STR_ ) ) nextLine = currentEpisode . readLine ( ) ; } catch ( IOException | NullPointerException e ) { nextLine = null ; } }
public Jobs subset ( String [ ] jobIds ) { final List < Job > subsetResult = new ArrayList < Job > ( ) ; for ( String jobId : jobIds ) { Job job = jobMap . get ( jobId ) ; if ( job . isAnalysis ( ) ) { subsetResult . add ( job ) ; } } return new Jobs ( subsetResult ) ; }
public void addPropertyChangeListener ( PropertyChangeListener listener ) { List < PropertyChangeListener > l = Arrays . asList ( listenerList . getListeners ( PropertyChangeListener . class ) ) ; if ( ! l . contains ( listener ) ) { listenerList . add ( PropertyChangeListener . class , listener ) ; } }
public static byte [ ] fromHexString ( String text ) { text = text . trim ( ) ; if ( text . length ( ) % NUM_ != NUM_ ) text = STR_ + text ; int resLen = text . length ( ) / NUM_ ; int loNibble , hiNibble ; byte [ ] res = new byte [ resLen ] ; for ( int i = NUM_ ; i < resLen ; i ++ ) { int j = i << NUM_ ; hiNibble = charToNibble ( text . charAt ( j ) ) ; loNibble = charToNibble ( text . charAt ( j + NUM_ ) ) ; if ( loNibble == - NUM_ || hiNibble == - NUM_ ) return null ; res [ i ] = ( byte ) ( hiNibble << NUM_ | loNibble ) ; } return res ; }
protected static double variance ( double [ ] s , double [ ] sS , double [ ] sumOfWeights ) { double var = NUM_ ; for ( int i = NUM_ ; i < s . length ; i ++ ) { if ( sumOfWeights [ i ] > NUM_ ) { var += singleVariance ( s [ i ] , sS [ i ] , sumOfWeights [ i ] ) ; } } return var ; }
public void write ( CharSequence csq ) throws IOException { final int length = csq . length ( ) ; for ( int i = NUM_ ; i < length ; ) { char c = csq . charAt ( i ++ ) ; if ( c < x80 ) { _bytes [ _index ] = ( byte ) c ; if ( ++ _index >= _bytes . length ) { flushBuffer ( ) ; } } else { write ( c ) ; } } }
public static boolean canResize ( List constraints ) { for ( Iterator iter = constraints . iterator ( ) ; iter . hasNext ( ) ; ) { DockConstraint dc = ( DockConstraint ) iter . next ( ) ; if ( ! dc . canResize ( ) ) return BOOL_ ; } return BOOL_ ; }
@ Override public boolean connectionAllowed ( EventSetDescriptor esd ) { return connectionAllowed ( esd . getName ( ) ) ; }
String readNumber ( String source , int ofs , String token , boolean adjacent ) { if ( adjacent ) { return source . substring ( ofs , ofs + token . length ( ) ) ; } int len = source . length ( ) ; for ( int i = ofs ; i < len ; i ++ ) { char ch = source . charAt ( i ) ; if ( isNumeric ( ch ) == BOOL_ ) { if ( i == NUM_ ) { return null ; } return source . substring ( ofs , i ) ; } } return source . substring ( ofs ) ; }
private Vec feedForward ( Vec input ) { Vec x = input ; for ( int i = NUM_ ; i < Ws . size ( ) ; i ++ ) { Matrix W_i = Ws . get ( i ) ; Vec b_i = bs . get ( i ) ; Vec a_i = W_i . multiply ( x ) ; a_i . mutableAdd ( b_i ) ; a_i . applyFunction ( f ) ; x = a_i ; } return x ; }
private boolean split_wtrace_other ( BrdTracep found_trace , Collection < BrdTracep > split_pieces , ArrayList < PlaLineInt > intersecting_lines , AwtreeFindEntry found_entry ) { if ( found_trace == this ) return BOOL_ ; boolean have_trace_split = BOOL_ ; for ( PlaLineInt inter_line : intersecting_lines ) { if ( have_trace_split ) break ; int line_no = found_entry . shape_index_in_object + NUM_ ; ArrayList < BrdTracep > curr_split_pieces = found_trace . split_with_end_line ( line_no , inter_line ) ; if ( curr_split_pieces . size ( ) < NUM_ ) continue ; have_trace_split = BOOL_ ; split_pieces . addAll ( curr_split_pieces ) ; } if ( ! have_trace_split ) split_pieces . add ( found_trace ) ; return have_trace_split ; }
private void printSolution ( Solution solution ) { if ( includeVariables ) { for ( int i = NUM_ ; i < solution . getNumberOfVariables ( ) ; i ++ ) { if ( i > NUM_ ) { writer . print ( STR_ ) ; } writer . print ( encode ( solution . getVariable ( i ) ) ) ; } } for ( int i = NUM_ ; i < solution . getNumberOfObjectives ( ) ; i ++ ) { if ( ( i > NUM_ ) || ( includeVariables && ( solution . getNumberOfVariables ( ) > NUM_ ) ) ) { writer . print ( STR_ ) ; } writer . print ( solution . getObjective ( i ) ) ; } writer . println ( ) ; }
public void readNBT ( NBTTagCompound nbt ) { if ( nbt . hasKey ( STR_ , NUM_ ) ) { this . decayLevel = nbt . getInteger ( STR_ ) ; this . decaySaturationLevel = nbt . getFloat ( STR_ ) ; this . decayAccelerationLevel = nbt . getFloat ( STR_ ) ; } }
public void copyTo ( PositionTextureVertex [ ] verts , TexturedQuad [ ] quad ) { TexturedPolygon [ ] poly = new TexturedPolygon [ quad . length ] ; for ( int idx = NUM_ ; idx < quad . length ; idx ++ ) { poly [ idx ] = new TexturedPolygon ( ( PositionTextureVertex [ ] ) quad [ idx ] . vertexPositions ) ; } copyTo ( verts , poly ) ; }
public synchronized void deleteObserver ( Observer observer ) { observers . remove ( observer ) ; }
public AccountAttribute asAccountAttribute ( Account account ) { if ( account == null ) { return null ; } AccountAttribute who = new AccountAttribute ( ) ; who . name = account . getFullName ( ) ; who . email = account . getPreferredEmail ( ) ; who . username = account . getUserName ( ) ; return who ; }
public void delete ( TemplatePersistenceData data ) { if ( data . isUserAdded ( ) ) fTemplates . remove ( data ) ; else data . setDeleted ( BOOL_ ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( NUM_ ) ; newVector . addElement ( new Option ( STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return newVector . elements ( ) ; }
public String consumeWord ( ) { int start = pos ; while ( matchesWord ( ) ) pos ++ ; return queue . substring ( start , pos ) ; }
public static void printInlining ( final ResolvedJavaMethod method , final int bci , final int inliningDepth , final boolean success , final String msg , final Object ... args ) { if ( HotSpotPrintInlining . getValue ( ) ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( STR_ ) ; sb . append ( STR_ ) ; sb . append ( String . format ( STR_ , STR_ , method . isSynchronized ( ) ? STR_ : STR_ , STR_ , STR_ , method . isNative ( ) ? STR_ : STR_ ) ) ; sb . append ( STR_ ) ; sb . append ( STR_ ) ; for ( int i = NUM_ ; i < inliningDepth ; i ++ ) { sb . append ( STR_ ) ; } sb . append ( String . format ( STR_ , bci , methodName ( method ) , success ? STR_ : STR_ , String . format ( msg , args ) ) ) ; TTY . println ( sb . toString ( ) ) ; } }
public static void appendChild ( Node parent , Node child ) { Document ownerDoc = getOwnerDocument ( parent ) ; if ( child . getOwnerDocument ( ) != ownerDoc ) { parent . appendChild ( ownerDoc . importNode ( child , BOOL_ ) ) ; } else { parent . appendChild ( child ) ; } }
protected void deleteSessionVariables ( String sessionId , String ... varNames ) { if ( sessionId . equals ( STR_ ) ) { return ; } Key key = keyFactory . newKey ( sessionId ) ; Transaction transaction = datastore . newTransaction ( ) ; try { Entity stateEntity = transaction . get ( key ) ; Entity . Builder builder = Entity . builder ( stateEntity ) ; StringBuilder delNames = new StringBuilder ( ) ; for ( String varName : varNames ) { delNames . append ( varName + STR_ ) ; builder = builder . remove ( varName ) ; } datastore . update ( builder . build ( ) ) ; } catch ( NullPointerException e ) { } finally { if ( transaction . active ( ) ) { transaction . rollback ( ) ; } } }
@ SuppressLint ( STR_ ) private void pruneScrapViews ( ) { final int maxViews = mActiveViews . length ; final int viewTypeCount = mViewTypeCount ; final ArrayList < View > [ ] scrapViews = mScrapViews ; for ( int i = NUM_ ; i < viewTypeCount ; ++ i ) { final ArrayList < View > scrapPile = scrapViews [ i ] ; int size = scrapPile . size ( ) ; final int extras = size - maxViews ; size -- ; for ( int j = NUM_ ; j < extras ; j ++ ) { removeDetachedView ( scrapPile . remove ( size -- ) , BOOL_ ) ; } } if ( mTransientStateViews != null ) { for ( int i = NUM_ ; i < mTransientStateViews . size ( ) ; i ++ ) { final View v = mTransientStateViews . valueAt ( i ) ; if ( ! v . hasTransientState ( ) ) { mTransientStateViews . removeAt ( i ) ; i -- ; } } } }
public static boolean isLafAqua ( ) { ensureValidCache ( ) ; if ( cachedIsLafAqua == null ) { cachedIsLafAqua = Boolean . valueOf ( computeIsLafAqua ( ) ) ; } return cachedIsLafAqua . booleanValue ( ) ; }
public void moveRandomly ( ) { setRandomPathFrom ( getX ( ) , getY ( ) , getMovementRange ( ) / NUM_ ) ; }
public void plnI ( Object o ) throws IOException { p ( o . toString ( ) ) ; pln ( ) ; pI ( ) ; }
@ Override public void writeEntityToNBT ( NBTTagCompound par1NBTTagCompound ) { par1NBTTagCompound . setShort ( STR_ , ( short ) this . xTile ) ; par1NBTTagCompound . setShort ( STR_ , ( short ) this . yTile ) ; par1NBTTagCompound . setShort ( STR_ , ( short ) this . zTile ) ; par1NBTTagCompound . setInteger ( STR_ , Block . getIdFromBlock ( this . inTile ) ) ; par1NBTTagCompound . setByte ( STR_ , ( byte ) this . inData ) ; par1NBTTagCompound . setByte ( STR_ , ( byte ) this . arrowShake ) ; par1NBTTagCompound . setByte ( STR_ , ( byte ) ( this . inGround ? NUM_ : NUM_ ) ) ; par1NBTTagCompound . setBoolean ( STR_ , this . isExplosive ) ; }
@ Override public StringBuffer format ( final double value , final StringBuffer buffer , final FieldPosition position ) { return format ( Double . valueOf ( value ) , buffer , position ) ; }
private Object translateStreamToInputStream ( InputStream str , DataFlavor flavor , long format , Transferable localeTransferable ) throws IOException { if ( isFlavorCharsetTextType ( flavor ) && isTextFormat ( format ) ) { str = new ReencodingInputStream ( str , format , DataTransferer . getTextCharset ( flavor ) , localeTransferable ) ; } return constructFlavoredObject ( str , flavor , InputStream . class ) ; }
public void dispose ( ) throws IabAsyncInProgressException { synchronized ( mAsyncInProgressLock ) { if ( mAsyncInProgress ) { throw new IabAsyncInProgressException ( STR_ + STR_ + mAsyncOperation + STR_ ) ; } } logDebug ( STR_ ) ; mSetupDone = BOOL_ ; if ( mServiceConn != null ) { logDebug ( STR_ ) ; if ( mContext != null ) mContext . unbindService ( mServiceConn ) ; } mDisposed = BOOL_ ; mContext = null ; mServiceConn = null ; mService = null ; mPurchaseListener = null ; }
private boolean isIPTResourceFolder ( File dir ) { if ( dir . exists ( ) && dir . isDirectory ( ) ) { File persistenceFile = new File ( dir , PERSISTENCE_FILE ) ; File emlFile = new File ( dir , DataDir . EML_XML_FILENAME ) ; return persistenceFile . isFile ( ) && emlFile . isFile ( ) ; } return BOOL_ ; }
public Set < String > addSpriteFrames ( String plist , CCTexture2D texture ) { HashMap < String , Object > dict = PlistParser . parse ( plist ) ; return addSpriteFrames ( dict , texture ) ; }
public void addAnnotation ( final Annotation annotation ) { annotationList . add ( annotation ) ; annotation . setxyGraph ( xyGraph ) ; add ( annotation ) ; revalidate ( ) ; changeSupport . firePropertyChange ( STR_ , null , annotation ) ; }
public static void createOverviews ( ASDocConfiguration config ) throws CompilerException { String templatesPath = config . getTemplatesPath ( ) ; String ditaPath = config . getOutput ( ) + STR_ + File . separator ; BufferedWriter writer = null ; Reader reader = null ; try { writer = new BufferedWriter ( new FileWriter ( ditaPath + STR_ ) ) ; if ( config . getPackageDescriptionFile ( ) != null ) { reader = new BufferedReader ( new FileReader ( config . getPackageDescriptionFile ( ) ) ) ; } else { reader = new BufferedReader ( new FileReader ( templatesPath + STR_ ) ) ; } OverviewsHandler h = new OverviewsHandler ( writer , config ) ; InputSource source = new InputSource ( reader ) ; SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; SAXParser parser = factory . newSAXParser ( ) ; parser . parse ( source , h ) ; } catch ( Exception e ) { if ( Trace . error ) e . printStackTrace ( ) ; CompilerMessage c = new CouldNotCreate ( STR_ , e . getMessage ( ) ) ; ThreadLocalToolkit . log ( c ) ; throw c ; } finally { if ( writer != null ) { try { writer . close ( ) ; } catch ( IOException ioe ) { } } if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException ioe ) { } } } }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
public CreateNewNoteIntentBuilder addTags ( @ Nullable ArrayList < String > tags ) { ArrayList < String > list = mArgs . getStringArrayList ( EvernoteIntent . EXTRA_TAG_NAME_LIST ) ; if ( list == null ) { list = tags ; } else if ( tags != null ) { list . addAll ( tags ) ; } return setTags ( list ) ; }
private RemoteOperationResult refreshSharesForFolder ( OwnCloudClient client ) { RemoteOperationResult result = null ; GetRemoteSharesForFileOperation operation = new GetRemoteSharesForFileOperation ( mLocalFolder . getRemotePath ( ) , BOOL_ , BOOL_ ) ; result = operation . execute ( client ) ; if ( result . isSuccess ( ) ) { ArrayList < OCShare > shares = new ArrayList < OCShare > ( ) ; for ( Object obj : result . getData ( ) ) { shares . add ( ( OCShare ) obj ) ; } mStorageManager . saveSharesInFolder ( shares , mLocalFolder ) ; } return result ; }
public double dist ( Math_Vector other ) { double distX = this . x - other . x ; double distY = this . y - other . y ; return Math . sqrt ( distX . distX + distY . distY ) ; }
public static String parseString ( String value ) { if ( ( value . startsWith ( STR_ ) ) && ( value . endsWith ( STR_ ) ) || ( value . startsWith ( STR_ ) ) && ( value . endsWith ( STR_ ) ) ) { if ( value . length ( ) > NUM_ ) { if ( value . indexOf ( STR_ ) != - NUM_ ) { return unescape ( value . substring ( NUM_ , value . length ( ) - NUM_ ) ) ; } return value . substring ( NUM_ , value . length ( ) - NUM_ ) ; } } throw new IllegalArgumentException ( STR_ + value + STR_ ) ; }
private void defineDesktopPanes ( UIDefaults d ) { d . put ( STR_ , new ColorUIResource ( x556ba6 ) ) ; String c = PAINTER_PREFIX + STR_ ; String p = STR_ ; d . put ( p + STR_ , new LazyPainter ( c , DesktopPanePainter . Which . BACKGROUND_ENABLED ) ) ; p = STR_ ; c = PAINTER_PREFIX + STR_ ; d . put ( p + STR_ , new InsetsUIResource ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; d . put ( p + STR_ , new LazyPainter ( c , DesktopIconPainter . Which . BACKGROUND_ENABLED ) ) ; }
private void fitImageToView ( ) { Drawable drawable = getDrawable ( ) ; if ( drawable == null || drawable . getIntrinsicWidth ( ) == NUM_ || drawable . getIntrinsicHeight ( ) == NUM_ ) { return ; } if ( matrix == null || prevMatrix == null ) { return ; } int drawableWidth = drawable . getIntrinsicWidth ( ) ; int drawableHeight = drawable . getIntrinsicHeight ( ) ; float scaleX = ( float ) viewWidth / drawableWidth ; float scaleY = ( float ) viewHeight / drawableHeight ; switch ( mScaleType ) { case CENTER : scaleX = scaleY = NUM_ ; break ; case CENTER_CROP : scaleX = scaleY = Math . max ( scaleX , scaleY ) ; break ; case CENTER_INSIDE : scaleX = scaleY = Math . min ( NUM_ , Math . min ( scaleX , scaleY ) ) ; case FIT_CENTER : scaleX = scaleY = Math . min ( scaleX , scaleY ) ; break ; case FIT_XY : break ; default : throw new UnsupportedOperationException ( STR_ ) ; } float redundantXSpace = viewWidth - ( scaleX . drawableWidth ) ; float redundantYSpace = viewHeight - ( scaleY . drawableHeight ) ; matchViewWidth = viewWidth - redundantXSpace ; matchViewHeight = viewHeight - redundantYSpace ; if ( ! isZoomed ( ) && ! imageRenderedAtLeastOnce ) { matrix . setScale ( scaleX , scaleY ) ; matrix . postTranslate ( redundantXSpace / NUM_ , redundantYSpace / NUM_ ) ; normalizedScale = NUM_ ; } else { if ( prevMatchViewWidth == NUM_ || prevMatchViewHeight == NUM_ ) { savePreviousImageValues ( ) ; } prevMatrix . getValues ( m ) ; m [ Matrix . MSCALE_X ] = matchViewWidth / drawableWidth . normalizedScale ; m [ Matrix . MSCALE_Y ] = matchViewHeight / drawableHeight . normalizedScale ; float transX = m [ Matrix . MTRANS_X ] ; float transY = m [ Matrix . MTRANS_Y ] ; float prevActualWidth = prevMatchViewWidth . normalizedScale ; float actualWidth = getImageWidth ( ) ; translateMatrixAfterRotate ( Matrix . MTRANS_X , transX , prevActualWidth , actualWidth , prevViewWidth , viewWidth , drawableWidth ) ; float prevActualHeight = prevMatchViewHeight . normalizedScale ; float actualHeight = getImageHeight ( ) ; translateMatrixAfterRotate ( Matrix . MTRANS_Y , transY , prevActualHeight , actualHeight , prevViewHeight , viewHeight , drawableHeight ) ; matrix . setValues ( m ) ; } fixTrans ( ) ; setImageMatrix ( matrix ) ; }
ObjectAnimator animateBoundScroll ( ) { float curScroll = getStackScroll ( ) ; float newScroll = getBoundedStackScroll ( curScroll ) ; if ( Float . compare ( newScroll , curScroll ) != NUM_ ) { animateScroll ( curScroll , newScroll , null ) ; } return mScrollAnimator ; }
public IntArray resize ( IntArray array , long size ) { if ( array instanceof BigIntArray ) { return resizeInPlace ( ( BigIntArray ) array , size ) ; } else { AbstractArray arr = ( AbstractArray ) array ; final IntArray newArray = newIntArray ( size , arr . clearOnResize ) ; for ( long i = NUM_ , end = Math . min ( size , array . size ( ) ) ; i < end ; ++ i ) { newArray . set ( i , array . get ( i ) ) ; } array . close ( ) ; return newArray ; } }
public DERUTCTime ( Date time ) { SimpleDateFormat dateF = new SimpleDateFormat ( STR_ ) ; dateF . setTimeZone ( new SimpleTimeZone ( NUM_ , STR_ ) ) ; this . time = Strings . toByteArray ( dateF . format ( time ) ) ; }
public static double pdf ( double x , double mu , double beta ) { final double z = ( x - mu ) / beta ; if ( x == Double . NEGATIVE_INFINITY ) { return NUM_ ; } return Math . exp ( - z - Math . exp ( - z ) ) / beta ; }
private static byte [ ] copy_buffer ( byte [ ] buffer , int sOffset , int len ) { byte [ ] newData = new byte [ len ] ; System . arraycopy ( buffer , sOffset , newData , NUM_ , len ) ; return newData ; }
public SharedFsCheckpointSpi ( ) { dirPaths . offer ( DFLT_DIR_PATH ) ; }
private void configure ( ) throws NullLocationException , FormatterInitException { String Interval = lmanager . getProperty ( LogConstants . LOGSIGN_PERIODINSECONDS ) ; if ( ( Interval == null ) || ( Interval . length ( ) == NUM_ ) ) { signInterval = LogConstants . LOGSIGN_PERIODINSECONDS_DEFAULT . NUM_ ; } else { signInterval = Long . parseLong ( Interval ) . NUM_ ; } String strMaxFileSize = lmanager . getProperty ( LogConstants . MAX_FILE_SIZE ) ; if ( ( strMaxFileSize == null ) || ( strMaxFileSize . length ( ) == NUM_ ) ) { maxFileSize = NUM_ ; } else { maxFileSize = Integer . parseInt ( strMaxFileSize ) ; } location = lmanager . getProperty ( LogConstants . LOG_PROP_PREFIX + STR_ + logName + STR_ ) ; if ( location == null ) { location = lmanager . getProperty ( LogConstants . LOG_LOCATION ) ; } if ( ( location == null ) || ( location . length ( ) == NUM_ ) ) { throw new NullLocationException ( STR_ ) ; } if ( ! location . endsWith ( File . separator ) ) { location += File . separator ; } String filesPerKeyStoreString = lmanager . getProperty ( LogConstants . FILES_PER_KEYSTORE ) ; if ( ( filesPerKeyStoreString == null ) || ( filesPerKeyStoreString . length ( ) == NUM_ ) ) { if ( Debug . warningEnabled ( ) ) { Debug . warning ( logName + STR_ + STR_ ) ; } filesPerKeyStoreString = STR_ ; } filesPerKeyStore = Integer . parseInt ( filesPerKeyStoreString ) ; if ( Debug . messageEnabled ( ) ) { Debug . message ( logName + STR_ + filesPerKeyStoreString ) ; } String archiverClassString = lmanager . getProperty ( LogConstants . ARCHIVER ) ; if ( ( archiverClassString == null ) || ( archiverClassString . length ( ) == NUM_ ) ) { throw new NullLocationException ( STR_ ) ; } archiverClass = archiverClassString ; }
public void pull ( final PullParams params , final ProgressMonitor progressMonitor ) throws IOException { pull ( params , progressMonitor , dockerDaemonUri ) ; }
public static InputStream streamFromString ( String location ) throws IOException { InputStream is = null ; URL url = urlFromString ( location , null , BOOL_ ) ; if ( url != null ) { is = url . openStream ( ) ; } else { File f = new File ( location ) ; if ( f . exists ( ) ) is = new FileInputStream ( f ) ; } if ( is == null ) { return null ; } else if ( isGZipFile ( location ) ) { return new GZIPInputStream ( is ) ; } else { return is ; } }
public void addUpdateListener ( AnimatorUpdateListener listener ) { if ( mUpdateListeners == null ) { mUpdateListeners = new ArrayList < AnimatorUpdateListener > ( ) ; } mUpdateListeners . add ( listener ) ; }
public void handleRequest ( RequestContext rc ) throws CLIException { super . handleRequest ( rc ) ; SSOToken adminSSOToken = getAdminSSOToken ( ) ; IOutput outputWriter = getOutputWriter ( ) ; String realm = getStringOptionValue ( IArgument . REALM_NAME ) ; String idName = getStringOptionValue ( ARGUMENT_ID_NAME ) ; String type = getStringOptionValue ( ARGUMENT_ID_TYPE ) ; IdType idType = convert2IdType ( type ) ; String [ ] params = { realm , type , idName } ; try { AMIdentityRepository amir = new AMIdentityRepository ( adminSSOToken , realm ) ; Set set = amir . getAllowedIdOperations ( idType ) ; if ( ! set . contains ( IdOperation . SERVICE ) ) { throw new CLIException ( MessageFormat . format ( getResourceString ( STR_ ) , ( Object [ ] ) params ) , ExitCodes . REQUEST_CANNOT_BE_PROCESSED ) ; } writeLog ( LogWriter . LOG_ACCESS , Level . INFO , STR_ , params ) ; AMIdentity amid = new AMIdentity ( adminSSOToken , idName , idType , realm , null ) ; Set services = amid . getAssignableServices ( ) ; if ( idType . equals ( IdType . USER ) ) { services . remove ( Constants . SVC_NAME_USER ) ; services . remove ( Constants . SVC_NAME_AUTH_CONFIG ) ; services . remove ( Constants . SVC_NAME_SAML ) ; } if ( ( services != null ) && ! services . isEmpty ( ) ) { String msg = getResourceString ( STR_ ) ; String [ ] arg = { STR_ } ; for ( Iterator i = services . iterator ( ) ; i . hasNext ( ) ; ) { arg [ NUM_ ] = ( String ) i . next ( ) ; outputWriter . printlnMessage ( MessageFormat . format ( msg , ( Object [ ] ) arg ) ) ; } } else { outputWriter . printlnMessage ( getResourceString ( STR_ ) ) ; } writeLog ( LogWriter . LOG_ACCESS , Level . INFO , STR_ , params ) ; } catch ( IdRepoException e ) { String [ ] args = { realm , type , idName , e . getMessage ( ) } ; debugError ( STR_ , e ) ; writeLog ( LogWriter . LOG_ERROR , Level . INFO , STR_ , args ) ; throw new CLIException ( e , ExitCodes . REQUEST_CANNOT_BE_PROCESSED ) ; } catch ( SSOException e ) { String [ ] args = { realm , type , idName , e . getMessage ( ) } ; debugError ( STR_ , e ) ; writeLog ( LogWriter . LOG_ERROR , Level . INFO , STR_ , args ) ; throw new CLIException ( e , ExitCodes . REQUEST_CANNOT_BE_PROCESSED ) ; } }
public boolean isAlive ( ) { if ( hasSentData ) { if ( System . currentTimeMillis ( ) - lastSendTime < TIMEOUT ) return BOOL_ ; return hasReceivedData && lastReceiveTime > lastSendTime ; } return BOOL_ ; }
private void removeSelectedItems ( List items ) { for ( Iterator iter = items . iterator ( ) ; iter . hasNext ( ) ; ) { Object item = iter . next ( ) ; removeHistoryItem ( item ) ; } refreshWithLastSelection = BOOL_ ; contentProvider . refresh ( ) ; }
public static < K , V > Map < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 ) { Map map = of ( ) ; map . put ( k1 , v1 ) ; map . put ( k2 , v2 ) ; map . put ( k3 , v3 ) ; map . put ( k4 , v4 ) ; return map ; }
public static void disableConnectionReuseIfNecessary ( ) { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . FROYO ) { System . setProperty ( STR_ , STR_ ) ; } }
public static long sizeOf ( Struct sct ) { Iterator < Entry < Key , Object > > it = sct . entryIterator ( ) ; Entry < Key , Object > e ; long size = NUM_ ; while ( it . hasNext ( ) ) { e = it . next ( ) ; size += SizeOf . size ( e . getKey ( ) ) ; size += SizeOf . size ( e . getValue ( ) ) ; } return size ; }
@ Override public boolean isEnabled ( ) { if ( ( attributeSelectionPanel != null ) && ! isValueOnly ( ) ) { return attributeSelectionPanel . isEnabled ( ) ; } else { if ( table != null ) { return table . isEnabled ( ) ; } } return BOOL_ ; }
public static Header [ ] parseHeaders ( final SessionInputBuffer inbuffer , int maxHeaderCount , int maxLineLen , LineParser parser ) throws HttpException , IOException { if ( inbuffer == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( parser == null ) parser = BasicLineParser . DEFAULT ; ArrayList headerLines = new ArrayList ( ) ; CharArrayBuffer current = null ; CharArrayBuffer previous = null ; for ( ; ; ) { if ( current == null ) { current = new CharArrayBuffer ( NUM_ ) ; } else { current . clear ( ) ; } int l = inbuffer . readLine ( current ) ; if ( l == - NUM_ || current . length ( ) < NUM_ ) { break ; } if ( ( current . charAt ( NUM_ ) == STR_ || current . charAt ( NUM_ ) == STR_ ) && previous != null ) { int i = NUM_ ; while ( i < current . length ( ) ) { char ch = current . charAt ( i ) ; if ( ch != STR_ && ch != STR_ ) { break ; } i ++ ; } if ( maxLineLen > NUM_ && previous . length ( ) + NUM_ + current . length ( ) - i > maxLineLen ) { throw new IOException ( STR_ ) ; } previous . append ( STR_ ) ; previous . append ( current , i , current . length ( ) - i ) ; } else { headerLines . add ( current ) ; previous = current ; current = null ; } if ( maxHeaderCount > NUM_ && headerLines . size ( ) >= maxHeaderCount ) { throw new IOException ( STR_ ) ; } } Header [ ] headers = new Header [ headerLines . size ( ) ] ; for ( int i = NUM_ ; i < headerLines . size ( ) ; i ++ ) { CharArrayBuffer buffer = ( CharArrayBuffer ) headerLines . get ( i ) ; try { headers [ i ] = parser . parseHeader ( buffer ) ; } catch ( ParseException ex ) { throw new ProtocolException ( ex . getMessage ( ) ) ; } } return headers ; }
@ Override public boolean isFactoryForType ( Object type ) { return supportedTypes . contains ( type ) || super . isFactoryForType ( type ) ; }
public void readContent ( byte [ ] dst , int offset , int length ) { System . arraycopy ( content , NUM_ , dst , offset , length ) ; }
public static void putObjectField ( Object obj , long fieldOff , Object val ) { UNSAFE . putObject ( obj , fieldOff , val ) ; }
public void onConfigurationChanged ( ) { int curFirst = pager . getCurrentScreen ( ) . PAGE_SIZE ; calPageSize ( ) ; int newPage = curFirst / PAGE_SIZE ; removeViewAt ( NUM_ ) ; afterPlatformListGot ( ) ; pager . setCurrentScreen ( newPage ) ; }
public List < FunctionDesc > listAllFunctions ( ) { List < FunctionDesc > functions = new ArrayList < FunctionDesc > ( ) ; for ( MeasureDesc m : measures ) { functions . add ( m . getFunction ( ) ) ; } return functions ; }
public boolean hasExplicitField ( String fieldName ) { if ( fields . containsKey ( fieldName ) ) { return BOOL_ ; } for ( DynamicField df : dynamicFields ) { if ( fieldName . equals ( df . getRegex ( ) ) ) return BOOL_ ; } return BOOL_ ; }
private static boolean instanceOfAny ( Object o , Collection < Class > classes ) { for ( Class c : classes ) { if ( c . isInstance ( o ) ) return BOOL_ ; } return BOOL_ ; }
public static IProposalComputer newSetterAttributeProposalComputer ( ContentAssistRequest contentAssistRequest , IJavaProject javaProject ) { IDOMNode node = ( IDOMNode ) contentAssistRequest . getNode ( ) ; if ( node . getNodeType ( ) != IDOMNode . ELEMENT_NODE ) { return null ; } String widgetTypeName = UiBinderXmlModelUtilities . computeQualifiedWidgetTypeName ( node ) ; if ( widgetTypeName == null ) { return null ; } String matchString = contentAssistRequest . getMatchString ( ) ; return new SetterAttributeProposalComputer ( node , widgetTypeName , javaProject , matchString , contentAssistRequest . getReplacementBeginPosition ( ) , matchString . length ( ) ) ; }
public void omitAll ( ) { if ( writeChunk != null ) bytesWritten += writeChunk . position ( ) ; bytesRead = bytesWritten ; list . clear ( ) ; writeChunk = null ; readChunk = null ; }
Job loadPreview ( FutureCallback < Pair < OmniBuildEnvironment , OmniGradleBuild > > resultHandler , List < ProgressListener > listeners ) ;
private void refresh ( ILaunchConfiguration configuration ) { setLaunchConfiguration ( configuration ) ; try { fModel = createClasspathModel ( configuration ) ; } catch ( Exception e ) { message = e . getMessage ( ) ; setErrorMessage ( e . getMessage ( ) ) ; } fClasspathViewer . setLaunchConfiguration ( configuration ) ; fClasspathViewer . setInput ( fModel ) ; setDirty ( BOOL_ ) ; }
public void computePackageFragmentRoots ( IClasspathEntry [ ] resolvedClasspath , ObjectVector accumulatedRoots , HashSet rootIDs , IClasspathEntry referringEntry , boolean retrieveExportedRoots , Map rootToResolvedEntries ) throws JavaModelException { if ( referringEntry == null ) { rootIDs . add ( rootID ( ) ) ; } for ( int i = NUM_ , length = resolvedClasspath . length ; i < length ; i ++ ) { computePackageFragmentRoots ( resolvedClasspath [ i ] , accumulatedRoots , rootIDs , referringEntry , retrieveExportedRoots , rootToResolvedEntries ) ; } }
private void init ( ) { setTitle ( STR_ ) ; somPanel = new SOMPropertiesPanel ( networkPanel , SOMPropsPanelType . CREATE_GROUP ) ; tabLogic . add ( somPanel ) ; layoutPanel = new MainLayoutPanel ( BOOL_ , this ) ; layoutPanel . setCurrentLayout ( SOMGroup . DEFAULT_LAYOUT ) ; tabLayout . add ( layoutPanel ) ; tabbedPane . addTab ( STR_ , tabLogic ) ; tabbedPane . addTab ( STR_ , layoutPanel ) ; setContentPane ( tabbedPane ) ; Action helpAction = new ShowHelpAction ( somPanel . getHelpPath ( ) ) ; addButton ( new JButton ( helpAction ) ) ; }
private String diff_linesToCharsMunge ( String text , List < String > lineArray , Map < String , Integer > lineHash ) { int lineStart = NUM_ ; int lineEnd = - NUM_ ; String line ; StringBuilder chars = new StringBuilder ( ) ; while ( lineEnd < text . length ( ) - NUM_ ) { lineEnd = text . indexOf ( STR_ , lineStart ) ; if ( lineEnd == - NUM_ ) { lineEnd = text . length ( ) - NUM_ ; } line = text . substring ( lineStart , lineEnd + NUM_ ) ; lineStart = lineEnd + NUM_ ; if ( lineHash . containsKey ( line ) ) { chars . append ( String . valueOf ( ( char ) ( int ) lineHash . get ( line ) ) ) ; } else { lineArray . add ( line ) ; lineHash . put ( line , lineArray . size ( ) - NUM_ ) ; chars . append ( String . valueOf ( ( char ) ( lineArray . size ( ) - NUM_ ) ) ) ; } } return chars . toString ( ) ; }
public void remove ( Video video ) { videoList . remove ( video ) ; notifyDataSetChanged ( ) ; }
public boolean canInvert ( ) { return BOOL_ ; }
public void addAllSearchables ( ArrayList < ? extends SearchResult > searchable ) { searchables . addAll ( searchable ) ; }
public static String toString ( final Iterable < ? > iterable ) { if ( iterable instanceof Collection ) { return iterable . toString ( ) ; } else { final StringBuilder builder = new StringBuilder ( ) ; boolean firstValue = BOOL_ ; builder . append ( STR_ ) ; for ( final Object value : iterable ) { if ( ! firstValue ) { builder . append ( STR_ ) ; } builder . append ( value ) ; firstValue = BOOL_ ; } builder . append ( STR_ ) ; return builder . toString ( ) ; } }
public static int parseInt ( String text ) { return parseInt ( text , NUM_ ) ; }
@ Override public void endDocument ( Augmentations augs ) throws XNIException { try { if ( fDocumentHandler != null ) { fDocumentHandler . endDocument ( ) ; } if ( fContentHandler != null ) { fContentHandler . endDocument ( ) ; } } catch ( SAXException e ) { throw new XNIException ( e ) ; } }
public String execCommand ( String command ) { StringBuilder buf = new StringBuilder ( ) ; sendWaitFor ( command , defaultTimeout , prompts , buf ) ; log . debug ( buf . toString ( ) ) ; return cleanOutput ( buf ) ; }
private void ClientThreadRun ( ) throws IOException { SocketChannel channel = null ; try { log . debug ( STR_ , hostname , port , pending . size ( ) ) ; channel = SocketChannel . open ( new InetSocketAddress ( hostname , port ) ) ; channel . configureBlocking ( BOOL_ ) ; ClientThreadMainLoop ( channel ) ; } finally { if ( channel != null ) { channel . close ( ) ; } if ( current != null ) { pending . offerFirst ( current ) ; current = null ; } } }
@ Override public PathImpl schemeWalk ( String userPath , Map < String , Object > newAttributes , String uri , int offset ) { int length = uri . length ( ) ; if ( length < NUM_ + offset || uri . charAt ( offset ) != STR_ || uri . charAt ( NUM_ + offset ) != STR_ ) throw new RuntimeException ( STR_ ) ; CharBuffer buf = new CharBuffer ( ) ; int i = NUM_ + offset ; int ch = NUM_ ; boolean isIpv6 = BOOL_ ; for ( ; ( i < length && ( ch = uri . charAt ( i ) ) != STR_ && ch != STR_ && ! ( ch == STR_ && ! isIpv6 ) ) ; i ++ ) { if ( ch == STR_ ) isIpv6 = BOOL_ ; else if ( ch == STR_ ) isIpv6 = BOOL_ ; buf . append ( ( char ) ch ) ; } String host = buf . toString ( ) ; if ( host . length ( ) == NUM_ ) throw new RuntimeException ( STR_ ) ; int port = NUM_ ; if ( ch == STR_ ) { for ( i ++ ; i < length && ( ch = uri . charAt ( i ) ) >= STR_ && ch <= STR_ ; i ++ ) { port = NUM_ . port + uri . charAt ( i ) - STR_ ; } } return create ( this , userPath , newAttributes , host , port ) ; }
@ RequestMapping ( value = STR_ ) public void ssoDefaultTenantBindingError ( Locale locale , HttpServletResponse response ) throws IOException { logger . info ( STR_ + locale . toString ( ) + STR_ ) ; sendError ( locale , response , STR_ ) ; }
@ After public void tearDown ( ) { webClient . closeAllWindows ( ) ; }
@ Override public void onCanStartVideoServiceChanged ( boolean canStartVideoService ) { Log . i ( STR_ , STR_ + String . valueOf ( canStartVideoService ) ) ; if ( canStartVideoService == BOOL_ ) { mConversationHelper . startOutgoingVideo ( ) ; mConversationHelper . startIncomingVideo ( ) ; } }
public Manifest ( InputStream is ) throws IOException { while ( is . available ( ) != NUM_ ) { MessageHeader m = new MessageHeader ( is ) ; entries . addElement ( m ) ; } }
@ Override public Object readReply ( Class expectedClass ) throws Throwable { int tag = read ( ) ; if ( tag == STR_ ) return readObject ( expectedClass ) ; else if ( tag == STR_ ) { HashMap map = ( HashMap ) readObject ( HashMap . class ) ; throw prepareFault ( map ) ; } else { StringBuilder sb = new StringBuilder ( ) ; sb . append ( ( char ) tag ) ; try { int ch ; while ( ( ch = read ( ) ) >= NUM_ ) { sb . append ( ( char ) ch ) ; } } catch ( IOException e ) { log . log ( Level . FINE , e . toString ( ) , e ) ; } throw error ( STR_ + codeName ( tag ) + STR_ + sb ) ; } }
public void removeClickingListener ( OnWheelClickedListener listener ) { clickingListeners . remove ( listener ) ; }
public static String unexpandLine ( CharSequence self , int tabStop ) { StringBuilder builder = new StringBuilder ( self . toString ( ) ) ; int index = NUM_ ; while ( index + tabStop < builder . length ( ) ) { String piece = builder . substring ( index , index + tabStop ) ; int count = NUM_ ; while ( ( count < tabStop ) && ( Character . isWhitespace ( piece . charAt ( tabStop - ( count + NUM_ ) ) ) ) ) count ++ ; if ( count > NUM_ ) { piece = piece . substring ( NUM_ , tabStop - count ) + STR_ ; builder . replace ( index , index + tabStop , piece ) ; index = index + tabStop - ( count - NUM_ ) ; } else index = index + tabStop ; } return builder . toString ( ) ; }
private void uninstall ( String rowType ) { if ( extensionsByRowtype . containsKey ( rowType ) ) { extensionsByRowtype . remove ( rowType ) ; File f = getExtensionFile ( rowType ) ; if ( f . exists ( ) ) { FileUtils . deleteQuietly ( f ) ; } else { log . warn ( STR_ + rowType ) ; } } else { log . warn ( STR_ + rowType ) ; } }
public void addPropertyChangeListener ( String propertyName , PropertyChangeListener in_pcl ) { pcSupport . addPropertyChangeListener ( propertyName , in_pcl ) ; }
static final int tableSizeFor ( int cap ) { int n = cap - NUM_ ; n |= n > > > NUM_ ; n |= n > > > NUM_ ; n |= n > > > NUM_ ; n |= n > > > NUM_ ; n |= n > > > NUM_ ; return ( n < NUM_ ) ? NUM_ : ( n >= MAXIMUM_CAPACITY ) ? MAXIMUM_CAPACITY : n + NUM_ ; }
@ Override public boolean connectionAllowed ( String eventName ) { if ( ! eventName . equals ( STR_ ) && ! eventName . equals ( STR_ ) && ! eventName . equals ( STR_ ) && ! eventName . equals ( STR_ ) ) { return BOOL_ ; } if ( m_listenee != null ) { return BOOL_ ; } return BOOL_ ; }
protected void generateOMGraphic ( OMGraphic g ) { if ( g != null && g . getNeedToRegenerate ( ) ) { Projection proj = getProjection ( ) ; if ( proj != null ) { g . generate ( proj ) ; } else if ( DEBUG ) { Debug . output ( STR_ + g . getNeedToRegenerate ( ) ) ; } } }
public void insertVariable ( ) { ScriptStep variableStep = ScriptStepFactory . createVariable ( getVariableKey ( ) , getVariableValue ( ) ) ; steps . add ( getInsertIndex ( ) , variableStep ) ; variableKey = STR_ ; variableValue = STR_ ; reindexScriptSteps ( ) ; }
protected boolean [ ] canHandleZeroTraining ( boolean nominalPredictor , boolean numericPredictor , boolean stringPredictor , boolean datePredictor , boolean relationalPredictor , boolean multiInstance , int classType ) { print ( STR_ ) ; printAttributeSummary ( nominalPredictor , numericPredictor , stringPredictor , datePredictor , relationalPredictor , multiInstance , classType ) ; print ( STR_ ) ; ArrayList < String > accepts = new ArrayList < String > ( ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; int numTrain = NUM_ , numTest = getNumInstances ( ) , numClasses = NUM_ , missingLevel = NUM_ ; boolean predictorMissing = BOOL_ , classMissing = BOOL_ ; return runBasicTest ( nominalPredictor , numericPredictor , stringPredictor , datePredictor , relationalPredictor , multiInstance , classType , missingLevel , predictorMissing , classMissing , numTrain , numTest , numClasses , accepts ) ; }
public static byte [ ] long2buff ( long n ) { byte [ ] bs ; bs = new byte [ NUM_ ] ; bs [ NUM_ ] = ( byte ) ( ( n > > NUM_ ) & xFF ) ; bs [ NUM_ ] = ( byte ) ( ( n > > NUM_ ) & xFF ) ; bs [ NUM_ ] = ( byte ) ( ( n > > NUM_ ) & xFF ) ; bs [ NUM_ ] = ( byte ) ( ( n > > NUM_ ) & xFF ) ; bs [ NUM_ ] = ( byte ) ( ( n > > NUM_ ) & xFF ) ; bs [ NUM_ ] = ( byte ) ( ( n > > NUM_ ) & xFF ) ; bs [ NUM_ ] = ( byte ) ( ( n > > NUM_ ) & xFF ) ; bs [ NUM_ ] = ( byte ) ( n & xFF ) ; return bs ; }
final boolean tryWriteLock ( ) { Thread current = Thread . currentThread ( ) ; int c = getState ( ) ; if ( c != NUM_ ) { int w = exclusiveCount ( c ) ; if ( w == NUM_ || current != getExclusiveOwnerThread ( ) ) return BOOL_ ; if ( w == MAX_COUNT ) throw new Error ( STR_ ) ; } if ( ! compareAndSetState ( c , c + NUM_ ) ) return BOOL_ ; setExclusiveOwnerThread ( current ) ; return BOOL_ ; }
public IoServiceListenerSupport ( IoService service ) { if ( service == null ) { throw new IllegalArgumentException ( STR_ ) ; } this . service = service ; }
private void cancelEventLeaseDo ( long eventID , Uuid leaseID ) throws UnknownLeaseException { long now = System . currentTimeMillis ( ) ; EventReg reg = ( EventReg ) eventByID . get ( new Long ( eventID ) ) ; if ( reg == null || reg . leaseExpiration <= now ) throw new UnknownLeaseException ( ) ; deleteEvent ( reg ) ; if ( reg . leaseExpiration == minEventExpiration ) concurrentObj . waiterNotify ( eventNotifier ) ; }
public static boolean isValidGDay ( String value ) { String regex = STR_ ; if ( value . matches ( regex ) ) { return isValidCalendarValue ( value ) ; } else { return BOOL_ ; } }
protected void paint3DRectLighting ( Graphics2D g2 , int x , int y , int width , int height ) { g2 . setColor ( Color . white ) ; g2 . drawLine ( x + NUM_ , y + NUM_ , x + NUM_ , y + height - NUM_ ) ; g2 . drawLine ( x + NUM_ , y + NUM_ , x + width - NUM_ , y + NUM_ ) ; g2 . setColor ( Color . gray ) ; g2 . drawLine ( x + NUM_ , y + height - NUM_ , x + width - NUM_ , y + height - NUM_ ) ; g2 . drawLine ( x + width - NUM_ , y + NUM_ , x + width - NUM_ , y + height - NUM_ ) ; g2 . setColor ( Color . darkGray ) ; g2 . drawLine ( x , y + height , x + width , y + height ) ; g2 . drawLine ( x + width , y , x + width , y + height ) ; }
private void parseAttributes ( TypedArray a ) { barWidth = ( int ) a . getDimension ( R . styleable . ProgressWheel_pwBarWidth , barWidth ) ; rimWidth = ( int ) a . getDimension ( R . styleable . ProgressWheel_pwRimWidth , rimWidth ) ; spinSpeed = ( int ) a . getDimension ( R . styleable . ProgressWheel_pwSpinSpeed , spinSpeed ) ; barLength = ( int ) a . getDimension ( R . styleable . ProgressWheel_pwBarLength , barLength ) ; delayMillis = a . getInteger ( R . styleable . ProgressWheel_pwDelayMillis , delayMillis ) ; if ( delayMillis < NUM_ ) { delayMillis = NUM_ ; } if ( a . hasValue ( R . styleable . ProgressWheel_pwText ) ) { setText ( a . getString ( R . styleable . ProgressWheel_pwText ) ) ; } barColor = a . getColor ( R . styleable . ProgressWheel_pwBarColor , barColor ) ; textColor = a . getColor ( R . styleable . ProgressWheel_pwTextColor , textColor ) ; rimColor = a . getColor ( R . styleable . ProgressWheel_pwRimColor , rimColor ) ; circleColor = a . getColor ( R . styleable . ProgressWheel_pwCircleColor , circleColor ) ; contourColor = a . getColor ( R . styleable . ProgressWheel_pwContourColor , contourColor ) ; textSize = ( int ) a . getDimension ( R . styleable . ProgressWheel_pwTextSize , textSize ) ; contourSize = a . getDimension ( R . styleable . ProgressWheel_pwContourSize , contourSize ) ; a . recycle ( ) ; }
@ Deprecated public MediaFile ( File f , MediaFileType type ) { this ( f . toPath ( ) , type ) ; }
public CommandLine clear ( ) { line . clear ( ) ; return this ; }
public static String grepMinusV ( String val , String pattern ) { return grepInner ( val , pattern , BOOL_ ) ; }
public DropDownPopupButtonBuilder add ( Action action ) { popupMenu . add ( action ) ; return this ; }
@ SuppressLint ( STR_ ) private void attachImageFrommGallery ( ) { Bundle conData = new Bundle ( ) ; Intent intent = new Intent ( ) ; if ( ( mSelectedGalleryItemsList . size ( ) == NUM_ ) || ( Build . VERSION . SDK_INT < Build . VERSION_CODES . JELLY_BEAN_MR2 ) ) { intent . setData ( mSelectedGalleryItemsList . get ( NUM_ ) . mFileUri ) ; } else if ( mSelectedGalleryItemsList . size ( ) > NUM_ ) { ClipData . Item firstUri = new ClipData . Item ( null , null , null , mSelectedGalleryItemsList . get ( NUM_ ) . mFileUri ) ; String [ ] mimeType = { STR_ } ; ClipData clipData = new ClipData ( STR_ , mimeType , firstUri ) ; for ( int index = NUM_ ; index < mSelectedGalleryItemsList . size ( ) ; index ++ ) { ClipData . Item item = new ClipData . Item ( null , null , null , mSelectedGalleryItemsList . get ( index ) . mFileUri ) ; clipData . addItem ( item ) ; } intent . setClipData ( clipData ) ; } else { Uri uriSavedFromLifeCycle = ( Uri ) mImagePreviewImageView . getTag ( ) ; if ( null != uriSavedFromLifeCycle ) { intent . setData ( uriSavedFromLifeCycle ) ; } } intent . putExtras ( conData ) ; setResult ( RESULT_OK , intent ) ; VectorApp . setSavedCameraImagePreview ( null ) ; finish ( ) ; }
public static void mkdirs ( File directory ) throws CreateDirectoryException { if ( directory . exists ( ) ) { if ( directory . isDirectory ( ) ) { return ; } if ( ! directory . delete ( ) ) { throw new CreateDirectoryException ( directory . getAbsolutePath ( ) , new FileDeleteException ( directory . getAbsolutePath ( ) ) ) ; } } if ( ! directory . mkdirs ( ) && ! directory . isDirectory ( ) ) { throw new CreateDirectoryException ( directory . getAbsolutePath ( ) ) ; } }
public boolean hasDependency ( Capability c ) { if ( doNotCheckCapabilities ( ) ) { return BOOL_ ; } return m_Dependencies . contains ( c ) ; }
private static int prefixLen ( String o1 , String o2 ) { final int l1 = o1 . length ( ) , l2 = o2 . length ( ) , l = l1 < l2 ? l1 : l2 ; int prefix = NUM_ ; while ( prefix < l && ( o1 . charAt ( prefix ) == o2 . charAt ( prefix ) ) ) { prefix ++ ; } return prefix ; }
@ Override public void writeExternal ( ObjectOutput out ) throws IOException { super . writeExternal ( out ) ; out . writeDouble ( parentDistance ) ; }
static int shouldNativelyFocusHeavyweight ( Component heavyweight , Component descendant , boolean temporary , boolean focusedWindowChangeAllowed , long time , CausedFocusEvent . Cause cause ) { if ( log . isLoggable ( PlatformLogger . Level . FINE ) ) { if ( heavyweight == null ) { log . fine ( STR_ ) ; } if ( time == NUM_ ) { log . fine ( STR_ ) ; } } if ( descendant == null ) { descendant = heavyweight ; } KeyboardFocusManager manager = getCurrentKeyboardFocusManager ( SunToolkit . targetToAppContext ( descendant ) ) ; KeyboardFocusManager thisManager = getCurrentKeyboardFocusManager ( ) ; Component currentFocusOwner = thisManager . getGlobalFocusOwner ( ) ; Component nativeFocusOwner = thisManager . getNativeFocusOwner ( ) ; Window nativeFocusedWindow = thisManager . getNativeFocusedWindow ( ) ; if ( focusLog . isLoggable ( PlatformLogger . Level . FINER ) ) { focusLog . finer ( STR_ , String . valueOf ( descendant ) , String . valueOf ( heavyweight ) ) ; } if ( focusLog . isLoggable ( PlatformLogger . Level . FINEST ) ) { focusLog . finest ( STR_ , String . valueOf ( currentFocusOwner ) ) ; focusLog . finest ( STR_ , String . valueOf ( nativeFocusOwner ) ) ; focusLog . finest ( STR_ , String . valueOf ( nativeFocusedWindow ) ) ; } synchronized ( heavyweightRequests ) { HeavyweightFocusRequest hwFocusRequest = getLastHWRequest ( ) ; if ( focusLog . isLoggable ( PlatformLogger . Level . FINEST ) ) { focusLog . finest ( STR_ , String . valueOf ( hwFocusRequest ) ) ; } if ( hwFocusRequest == null && heavyweight == nativeFocusOwner && heavyweight . getContainingWindow ( ) == nativeFocusedWindow ) { if ( descendant == currentFocusOwner ) { if ( focusLog . isLoggable ( PlatformLogger . Level . FINEST ) ) focusLog . finest ( STR_ , String . valueOf ( descendant ) ) ; return SNFH_FAILURE ; } manager . enqueueKeyEvents ( time , descendant ) ; hwFocusRequest = new HeavyweightFocusRequest ( heavyweight , descendant , temporary , cause ) ; heavyweightRequests . add ( hwFocusRequest ) ; if ( currentFocusOwner != null ) { FocusEvent currentFocusOwnerEvent = new CausedFocusEvent ( currentFocusOwner , FocusEvent . FOCUS_LOST , temporary , descendant , cause ) ; SunToolkit . postEvent ( currentFocusOwner . appContext , currentFocusOwnerEvent ) ; } FocusEvent newFocusOwnerEvent = new CausedFocusEvent ( descendant , FocusEvent . FOCUS_GAINED , temporary , currentFocusOwner , cause ) ; SunToolkit . postEvent ( descendant . appContext , newFocusOwnerEvent ) ; if ( focusLog . isLoggable ( PlatformLogger . Level . FINEST ) ) focusLog . finest ( STR_ , String . valueOf ( descendant ) ) ; return SNFH_SUCCESS_HANDLED ; } else if ( hwFocusRequest != null && hwFocusRequest . heavyweight == heavyweight ) { if ( hwFocusRequest . addLightweightRequest ( descendant , temporary , cause ) ) { manager . enqueueKeyEvents ( time , descendant ) ; } if ( focusLog . isLoggable ( PlatformLogger . Level . FINEST ) ) { focusLog . finest ( STR_ + descendant + STR_ + heavyweight ) ; } return SNFH_SUCCESS_HANDLED ; } else { if ( ! focusedWindowChangeAllowed ) { if ( hwFocusRequest == HeavyweightFocusRequest . CLEAR_GLOBAL_FOCUS_OWNER ) { int size = heavyweightRequests . size ( ) ; hwFocusRequest = ( HeavyweightFocusRequest ) ( ( size >= NUM_ ) ? heavyweightRequests . get ( size - NUM_ ) : null ) ; } if ( focusedWindowChanged ( heavyweight , ( hwFocusRequest != null ) ? hwFocusRequest . heavyweight : nativeFocusedWindow ) ) { if ( focusLog . isLoggable ( PlatformLogger . Level . FINEST ) ) { focusLog . finest ( STR_ + descendant ) ; } return SNFH_FAILURE ; } } manager . enqueueKeyEvents ( time , descendant ) ; heavyweightRequests . add ( new HeavyweightFocusRequest ( heavyweight , descendant , temporary , cause ) ) ; if ( focusLog . isLoggable ( PlatformLogger . Level . FINEST ) ) { focusLog . finest ( STR_ + descendant ) ; } return SNFH_SUCCESS_PROCEED ; } } }
public NamedThreadFactory ( final String poolID ) { id = poolID ; }
public void moveLocationUp ( RouteLocation rl ) { int sequenceId = rl . getSequenceId ( ) ; if ( sequenceId - NUM_ <= NUM_ ) { rl . setSequenceId ( _sequenceNum + NUM_ ) ; resequenceIds ( ) ; } else { RouteLocation replaceRl = getItemBySequenceId ( sequenceId - NUM_ ) ; if ( replaceRl != null ) { replaceRl . setSequenceId ( sequenceId ) ; rl . setSequenceId ( sequenceId - NUM_ ) ; } else { resequenceIds ( ) ; } } setDirtyAndFirePropertyChange ( LISTCHANGE_CHANGED_PROPERTY , null , Integer . toString ( sequenceId ) ) ; }
protected Attribute generateAttribute ( int index , int attType , String namePrefix ) throws Exception { Attribute result ; String name ; int valIndex ; int nomCount ; String prefix ; result = null ; if ( index == CLASS_IS_LAST ) { valIndex = NUM_ ; name = STR_ ; prefix = STR_ ; nomCount = getNumClasses ( ) ; } else { valIndex = index ; nomCount = getNumNominalValues ( ) ; prefix = STR_ + ( valIndex + NUM_ ) + STR_ ; switch ( attType ) { case Attribute . NOMINAL : name = STR_ + ( valIndex + NUM_ ) ; break ; case Attribute . NUMERIC : name = STR_ + ( valIndex + NUM_ ) ; break ; case Attribute . STRING : name = STR_ + ( valIndex + NUM_ ) ; break ; case Attribute . DATE : name = STR_ + ( valIndex + NUM_ ) ; break ; case Attribute . RELATIONAL : name = STR_ + ( valIndex + NUM_ ) ; break ; default : throw new IllegalArgumentException ( STR_ + attType + STR_ ) ; } } switch ( attType ) { case Attribute . NOMINAL : ArrayList < String > nomStrings = new ArrayList < String > ( valIndex + NUM_ ) ; for ( int j = NUM_ ; j < nomCount ; j ++ ) { nomStrings . add ( prefix + ( j + NUM_ ) ) ; } result = new Attribute ( namePrefix + name , nomStrings ) ; break ; case Attribute . NUMERIC : result = new Attribute ( namePrefix + name ) ; break ; case Attribute . STRING : result = new Attribute ( namePrefix + name , ( ArrayList < String > ) null ) ; break ; case Attribute . DATE : result = new Attribute ( namePrefix + name , STR_ ) ; break ; case Attribute . RELATIONAL : Instances rel ; if ( index == CLASS_IS_LAST ) { rel = getRelationalClassFormat ( ) ; } else { rel = getRelationalFormat ( index ) ; } if ( rel == null ) { TestInstances dataset = new TestInstances ( ) ; dataset . setNumNominal ( getNumRelationalNominal ( ) ) ; dataset . setNumNominalValues ( getNumRelationalNominalValues ( ) ) ; dataset . setNumNumeric ( getNumRelationalNumeric ( ) ) ; dataset . setNumString ( getNumRelationalString ( ) ) ; dataset . setNumDate ( getNumRelationalDate ( ) ) ; dataset . setNumInstances ( NUM_ ) ; dataset . setClassType ( Attribute . NOMINAL ) ; rel = new Instances ( dataset . generate ( ) ) ; if ( ! getNoClass ( ) ) { int clsIndex = rel . classIndex ( ) ; rel . setClassIndex ( - NUM_ ) ; rel . deleteAttributeAt ( clsIndex ) ; } } result = new Attribute ( namePrefix + name , rel ) ; break ; default : throw new IllegalArgumentException ( STR_ + attType + STR_ ) ; } return result ; }
public static String printCanopyAssignments ( Instances dataPoints , List < long [ ] > canopyAssignments ) { StringBuilder temp = new StringBuilder ( ) ; for ( int i = NUM_ ; i < dataPoints . size ( ) ; i ++ ) { temp . append ( STR_ + i + STR_ ) ; temp . append ( dataPoints . instance ( i ) ) ; if ( canopyAssignments != null && canopyAssignments . size ( ) == dataPoints . size ( ) ) { long [ ] assignments = canopyAssignments . get ( i ) ; temp . append ( printSingleAssignment ( assignments ) ) ; } temp . append ( STR_ ) ; } return temp . toString ( ) ; }
public static void registerDefaultPrefixes ( ) throws XMLSecurityException { setDefaultPrefix ( STR_ , STR_ ) ; setDefaultPrefix ( STR_ , STR_ ) ; setDefaultPrefix ( STR_ , STR_ ) ; setDefaultPrefix ( STR_ , STR_ ) ; setDefaultPrefix ( STR_ , STR_ ) ; setDefaultPrefix ( STR_ , STR_ ) ; setDefaultPrefix ( STR_ , STR_ ) ; setDefaultPrefix ( STR_ , STR_ ) ; }
protected void initBPOrderDetails ( int C_BPartner_ID , boolean forInvoice ) { log . config ( STR_ + C_BPartner_ID ) ; KeyNamePair pp = new KeyNamePair ( NUM_ , STR_ ) ; orderField . removeActionListener ( this ) ; orderField . removeAllItems ( ) ; orderField . addItem ( pp ) ; ArrayList < KeyNamePair > list = loadOrderData ( C_BPartner_ID , forInvoice , BOOL_ ) ; for ( KeyNamePair knp : list ) orderField . addItem ( knp ) ; orderField . setSelectedIndex ( NUM_ ) ; orderField . addActionListener ( this ) ; dialog . pack ( ) ; initBPDetails ( C_BPartner_ID ) ; }
private void writeToc ( ByteBuffer dataFileBuffer , TocType tocType , int entryCount , int firstEntryOffset ) { dataFileBuffer . putInt ( tocType . identifier ) ; dataFileBuffer . putInt ( entryCount ) ; dataFileBuffer . putLong ( firstEntryOffset ) ; }
public void startPart ( String contentType , String [ ] headers ) throws IOException { writeCurrentBoundary ( ) ; if ( contentType != null ) { writeString ( MimeUtils . HEADER_CONTENT_TYPE + STR_ + contentType ) ; out . write ( CRLF ) ; } for ( int i = NUM_ ; headers != null && i < headers . length ; i ++ ) { writeString ( headers [ i ] ) ; out . write ( CRLF ) ; } out . write ( CRLF ) ; }
public EmbeddedMetaService ( ) throws IOException , ExecutionException { this ( System . getenv ( JOLIE_HOME_ENV ) ) ; }
public int showDialog ( ) { m_Result = CANCEL_OPTION ; int [ ] origSelected = m_List . getSelectedIndices ( ) ; setVisible ( BOOL_ ) ; if ( m_Result == CANCEL_OPTION ) { m_List . setSelectedIndices ( origSelected ) ; } return m_Result ; }
public final void addAlarmValues ( final List < AlarmValueImpl > alarmValues ) { if ( alarmValues != null ) { for ( AlarmValueImpl alarmValue : alarmValues ) { if ( alarmValue != null ) { addAlarmValue ( alarmValue ) ; } } } }
public String product ( Properties ctx , int WindowNo , GridTab mTab , GridField mField , Object value ) { Integer M_Product_ID = ( Integer ) value ; if ( M_Product_ID == null || M_Product_ID . intValue ( ) == NUM_ ) return STR_ ; if ( Env . getContextAsInt ( ctx , WindowNo , Env . TAB_INFO , STR_ ) == M_Product_ID . intValue ( ) && Env . getContextAsInt ( ctx , WindowNo , Env . TAB_INFO , STR_ ) != NUM_ ) mTab . setValue ( STR_ , Env . getContextAsInt ( ctx , WindowNo , Env . TAB_INFO , STR_ ) ) ; else mTab . setValue ( STR_ , null ) ; checkQtyAvailable ( ctx , mTab , WindowNo , M_Product_ID , null ) ; return STR_ ; }
protected void processpacket ( SimEvent ev ) { CloudSim . cancelAll ( getId ( ) , new PredicateType ( CloudSimTags . Network_Event_UP ) ) ; schedule ( getId ( ) , switching_delay , CloudSimTags . Network_Event_UP ) ; pktlist . add ( ( NetworkPacket ) ev . getData ( ) ) ; }
public void addChild ( Controller controller ) { if ( children == null ) children = new ArrayList < Controller > ( ) ; children . add ( controller ) ; controller . parent = this ; }
protected boolean checkTurnoutsInSection ( Section s , int seqNum , Section nextSection , ActiveTrain at , LayoutEditor le , Section prevSection ) { return turnoutUtil ( s , seqNum , nextSection , at , le , BOOL_ , BOOL_ , prevSection ) ; }
private Point2D calculateLabelAnchorPoint ( ItemLabelAnchor anchor , Rectangle2D bar , PlotOrientation orientation ) { Point2D result = null ; double offset = getItemLabelAnchorOffset ( ) ; double x0 = bar . getX ( ) - offset ; double x1 = bar . getX ( ) ; double x2 = bar . getX ( ) + offset ; double x3 = bar . getCenterX ( ) ; double x4 = bar . getMaxX ( ) - offset ; double x5 = bar . getMaxX ( ) ; double x6 = bar . getMaxX ( ) + offset ; double y0 = bar . getMaxY ( ) + offset ; double y1 = bar . getMaxY ( ) ; double y2 = bar . getMaxY ( ) - offset ; double y3 = bar . getCenterY ( ) ; double y4 = bar . getMinY ( ) + offset ; double y5 = bar . getMinY ( ) ; double y6 = bar . getMinY ( ) - offset ; if ( anchor == ItemLabelAnchor . CENTER ) { result = new Point2D . Double ( x3 , y3 ) ; } else if ( anchor == ItemLabelAnchor . INSIDE1 ) { result = new Point2D . Double ( x4 , y4 ) ; } else if ( anchor == ItemLabelAnchor . INSIDE2 ) { result = new Point2D . Double ( x4 , y4 ) ; } else if ( anchor == ItemLabelAnchor . INSIDE3 ) { result = new Point2D . Double ( x4 , y3 ) ; } else if ( anchor == ItemLabelAnchor . INSIDE4 ) { result = new Point2D . Double ( x4 , y2 ) ; } else if ( anchor == ItemLabelAnchor . INSIDE5 ) { result = new Point2D . Double ( x4 , y2 ) ; } else if ( anchor == ItemLabelAnchor . INSIDE6 ) { result = new Point2D . Double ( x3 , y2 ) ; } else if ( anchor == ItemLabelAnchor . INSIDE7 ) { result = new Point2D . Double ( x2 , y2 ) ; } else if ( anchor == ItemLabelAnchor . INSIDE8 ) { result = new Point2D . Double ( x2 , y2 ) ; } else if ( anchor == ItemLabelAnchor . INSIDE9 ) { result = new Point2D . Double ( x2 , y3 ) ; } else if ( anchor == ItemLabelAnchor . INSIDE10 ) { result = new Point2D . Double ( x2 , y4 ) ; } else if ( anchor == ItemLabelAnchor . INSIDE11 ) { result = new Point2D . Double ( x2 , y4 ) ; } else if ( anchor == ItemLabelAnchor . INSIDE12 ) { result = new Point2D . Double ( x3 , y4 ) ; } else if ( anchor == ItemLabelAnchor . OUTSIDE1 ) { result = new Point2D . Double ( x5 , y6 ) ; } else if ( anchor == ItemLabelAnchor . OUTSIDE2 ) { result = new Point2D . Double ( x6 , y5 ) ; } else if ( anchor == ItemLabelAnchor . OUTSIDE3 ) { result = new Point2D . Double ( x6 , y3 ) ; } else if ( anchor == ItemLabelAnchor . OUTSIDE4 ) { result = new Point2D . Double ( x6 , y1 ) ; } else if ( anchor == ItemLabelAnchor . OUTSIDE5 ) { result = new Point2D . Double ( x5 , y0 ) ; } else if ( anchor == ItemLabelAnchor . OUTSIDE6 ) { result = new Point2D . Double ( x3 , y0 ) ; } else if ( anchor == ItemLabelAnchor . OUTSIDE7 ) { result = new Point2D . Double ( x1 , y0 ) ; } else if ( anchor == ItemLabelAnchor . OUTSIDE8 ) { result = new Point2D . Double ( x0 , y1 ) ; } else if ( anchor == ItemLabelAnchor . OUTSIDE9 ) { result = new Point2D . Double ( x0 , y3 ) ; } else if ( anchor == ItemLabelAnchor . OUTSIDE10 ) { result = new Point2D . Double ( x0 , y5 ) ; } else if ( anchor == ItemLabelAnchor . OUTSIDE11 ) { result = new Point2D . Double ( x1 , y6 ) ; } else if ( anchor == ItemLabelAnchor . OUTSIDE12 ) { result = new Point2D . Double ( x3 , y6 ) ; } return result ; }
public static String readFully ( Reader reader ) throws IOException { try { StringWriter writer = new StringWriter ( ) ; char [ ] buffer = new char [ NUM_ ] ; int count ; while ( ( count = reader . read ( buffer ) ) != - NUM_ ) { writer . write ( buffer , NUM_ , count ) ; } return writer . toString ( ) ; } finally { reader . close ( ) ; } }
protected String instanceToMatlab ( Instance inst ) { StringBuffer result ; int i ; result = new StringBuffer ( ) ; for ( i = NUM_ ; i < inst . numAttributes ( ) ; i ++ ) { if ( i > NUM_ ) { result . append ( ( m_UseTabs ? STR_ : STR_ ) ) ; } result . append ( m_Format . format ( inst . value ( i ) ) ) ; } return result . toString ( ) ; }
private static double distance ( Problem problem , Solution a , Solution b , double power ) { double distance = NUM_ ; for ( int i = NUM_ ; i < problem . getNumberOfObjectives ( ) ; i ++ ) { distance += Math . pow ( Math . abs ( a . getObjective ( i ) - b . getObjective ( i ) ) , power ) ; } return Math . pow ( distance , NUM_ / power ) ; }
private List < TokenType > extractStringLiteralDelimitingTokens ( String [ ] tokens ) { List < TokenType > delimitingTokens = new ArrayList < TokenType > ( ) ; for ( String token : tokens ) { String cleanToken = cleanToken ( token ) ; boolean handled = BOOL_ ; if ( alternateQuote == null ) { String alternateQuoteFromToken = extractAlternateOpenQuote ( cleanToken ) ; if ( alternateQuoteFromToken != null ) { String closeQuote = computeAlternateCloseQuote ( alternateQuoteFromToken ) ; if ( cleanToken . length ( ) >= ( alternateQuoteFromToken . length ( ) + closeQuote . length ( ) ) && cleanToken . startsWith ( alternateQuoteFromToken ) && cleanToken . endsWith ( closeQuote ) ) { continue ; } alternateQuote = closeQuote ; delimitingTokens . add ( TokenType . ALTERNATE_QUOTE ) ; continue ; } } if ( ( alternateQuote != null ) && cleanToken . endsWith ( alternateQuote ) ) { alternateQuote = null ; delimitingTokens . add ( TokenType . ALTERNATE_QUOTE ) ; continue ; } if ( ( cleanToken . length ( ) >= NUM_ ) && cleanToken . startsWith ( STR_ ) && cleanToken . endsWith ( STR_ ) ) { continue ; } if ( ( cleanToken . length ( ) >= NUM_ ) && cleanToken . startsWith ( STR_ ) && cleanToken . endsWith ( STR_ ) ) { continue ; } if ( isSingleLineComment ( cleanToken ) ) { delimitingTokens . add ( TokenType . SINGLE_LINE_COMMENT ) ; handled = BOOL_ ; } if ( cleanToken . startsWith ( STR_ ) ) { delimitingTokens . add ( TokenType . MULTI_LINE_COMMENT ) ; handled = BOOL_ ; } else if ( cleanToken . startsWith ( STR_ ) ) { delimitingTokens . add ( TokenType . QUOTE ) ; handled = BOOL_ ; } if ( ! cleanToken . startsWith ( STR_ ) && cleanToken . endsWith ( STR_ ) ) { delimitingTokens . add ( TokenType . MULTI_LINE_COMMENT ) ; handled = BOOL_ ; } else if ( ! cleanToken . startsWith ( STR_ ) && cleanToken . endsWith ( STR_ ) ) { delimitingTokens . add ( TokenType . QUOTE ) ; handled = BOOL_ ; } if ( ! handled ) { delimitingTokens . add ( TokenType . OTHER ) ; } } return delimitingTokens ; }
private void printRainbowUser ( User user , String userName , boolean action , SpecialColor type , String id ) { SimpleAttributeSet userStyle = new SimpleAttributeSet ( styles . nick ( ) ) ; userStyle . addAttribute ( Attribute . IS_USER_MESSAGE , BOOL_ ) ; userStyle . addAttribute ( Attribute . USER , user ) ; if ( id != null ) { userStyle . addAttribute ( Attribute . ID , id ) ; } int length = userName . length ( ) ; if ( action ) { print ( STR_ , styles . nick ( ) ) ; } for ( int i = NUM_ ; i < length ; i ++ ) { Color c ; if ( type == SpecialColor . RAINBOW ) { c = makeRainbowColor ( i , length ) ; } else { c = makeGoldColor ( i , length ) ; } StyleConstants . setForeground ( userStyle , c ) ; print ( userName . substring ( i , i + NUM_ ) , userStyle ) ; } }
public void notifyAddressThrottleFound ( DccThrottle t ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ ) ; } mThrottle = t ; setEnabled ( BOOL_ ) ; mThrottle . addPropertyChangeListener ( this ) ; setFnButtons ( ) ; }
public static void matrixMultWDivMM ( MatrixBlock mW , MatrixBlock mU , MatrixBlock mV , MatrixBlock mX , MatrixBlock ret , WDivMMType wt , int k ) throws DMLRuntimeException { if ( mW . isEmptyBlock ( BOOL_ ) || ( wt . isLeft ( ) && mU . isEmptyBlock ( BOOL_ ) ) || ( wt . isRight ( ) && mV . isEmptyBlock ( BOOL_ ) ) || ( wt . isBasic ( ) && mW . isEmptyBlock ( BOOL_ ) ) ) { ret . examSparsity ( ) ; return ; } ret . sparse = wt . isBasic ( ) ? mW . sparse : BOOL_ ; ret . allocateDenseOrSparseBlock ( ) ; if ( ! ret . isThreadSafe ( ) ) { matrixMultWDivMM ( mW , mU , mV , mX , ret , wt ) ; return ; } try { ExecutorService pool = Executors . newFixedThreadPool ( k ) ; ArrayList < MatrixMultWDivTask > tasks = new ArrayList < MatrixMultWDivTask > ( ) ; if ( wt . isLeft ( ) ) { int blklen = ( int ) ( Math . ceil ( ( double ) mW . clen / k ) ) ; for ( int j = NUM_ ; j < k & j . blklen < mW . clen ; j ++ ) tasks . add ( new MatrixMultWDivTask ( mW , mU , mV , mX , ret , wt , NUM_ , mW . rlen , j . blklen , Math . min ( ( j + NUM_ ) . blklen , mW . clen ) ) ) ; } else { int blklen = ( int ) ( Math . ceil ( ( double ) mW . rlen / k ) ) ; for ( int i = NUM_ ; i < k & i . blklen < mW . rlen ; i ++ ) tasks . add ( new MatrixMultWDivTask ( mW , mU , mV , mX , ret , wt , i . blklen , Math . min ( ( i + NUM_ ) . blklen , mW . rlen ) , NUM_ , mW . clen ) ) ; } List < Future < Long > > taskret = pool . invokeAll ( tasks ) ; pool . shutdown ( ) ; ret . nonZeros = NUM_ ; for ( Future < Long > task : taskret ) ret . nonZeros += task . get ( ) ; } catch ( Exception e ) { throw new DMLRuntimeException ( e ) ; } ret . examSparsity ( ) ; }
public boolean verify ( ) throws MissingResourceFailureException , XMLSecurityException { return super . verifyReferences ( BOOL_ ) ; }
public OpenIdPrompt ( String prompt ) { originalValue = prompt ; if ( isEmpty ( prompt ) ) { prompts = Collections . emptySet ( ) ; } else { prompts = stringToSet ( prompt . toLowerCase ( ) ) ; } }
private static boolean calculateIsFailure ( ) { int randomValue = random . nextInt ( NUM_ ) + NUM_ ; return randomValue <= ERROR_PCT ; }
private int checkUserLink ( SpannableStringBuilder out , String in , int start ) { int pos = start + NUM_ ; StringBuilder temp = new StringBuilder ( ) ; String targetString = in . substring ( pos , Math . min ( in . length ( ) , pos + NUM_ ) ) ; for ( int i = NUM_ ; i < targetString . length ( ) ; i ++ ) { char c = targetString . charAt ( i ) ; if ( ( c >= STR_ && c <= STR_ ) || ( c >= STR_ && c <= STR_ ) || ( c >= STR_ && c <= STR_ ) || c == STR_ ) { temp . append ( c ) ; } else { break ; } } String username = temp . toString ( ) ; if ( username . length ( ) < NUM_ || username . equalsIgnoreCase ( STR_ ) ) { return - NUM_ ; } out . append ( username ) ; return pos + username . length ( ) - NUM_ ; }
public void clear ( ) { mArrayList . clear ( ) ; }
public void test_commonTest_01 ( ) { SSLContextSpiImpl ssl = new SSLContextSpiImpl ( ) ; try { SSLSessionContext slsc = ssl . engineGetClientSessionContext ( ) ; fail ( STR_ ) ; } catch ( RuntimeException re ) { String str = re . getMessage ( ) ; if ( ! str . equals ( STR_ ) ) fail ( STR_ + str ) ; } catch ( Exception e ) { fail ( STR_ + e + STR_ ) ; } try { SSLSessionContext slsc = ssl . engineGetServerSessionContext ( ) ; fail ( STR_ ) ; } catch ( RuntimeException re ) { String str = re . getMessage ( ) ; if ( ! str . equals ( STR_ ) ) fail ( STR_ + str ) ; } catch ( Exception e ) { fail ( STR_ + e + STR_ ) ; } try { SSLServerSocketFactory sssf = ssl . engineGetServerSocketFactory ( ) ; fail ( STR_ ) ; } catch ( RuntimeException re ) { String str = re . getMessage ( ) ; if ( ! str . equals ( STR_ ) ) fail ( STR_ + str ) ; } catch ( Exception e ) { fail ( STR_ + e + STR_ ) ; } try { SSLSocketFactory ssf = ssl . engineGetSocketFactory ( ) ; fail ( STR_ ) ; } catch ( RuntimeException re ) { String str = re . getMessage ( ) ; if ( ! str . equals ( STR_ ) ) fail ( STR_ + str ) ; } catch ( Exception e ) { fail ( STR_ + e + STR_ ) ; } }
public static ClassDescriptor createClassDescriptorFromResourceName ( String resourceName ) { if ( ! isClassResource ( resourceName ) ) { throw new IllegalArgumentException ( STR_ + resourceName + STR_ ) ; } return createClassDescriptor ( resourceName . substring ( NUM_ , resourceName . length ( ) - NUM_ ) ) ; }
public static void show ( final Window parent , final String content ) { final CLogFileDialog dialog = new CLogFileDialog ( parent , content ) ; GuiHelper . centerChildToParent ( parent , dialog , BOOL_ ) ; dialog . setVisible ( BOOL_ ) ; }
protected void endNode ( Node node ) throws org . xml . sax . SAXException { switch ( node . getNodeType ( ) ) { case Node . DOCUMENT_NODE : break ; case Node . DOCUMENT_TYPE_NODE : serializeDocType ( ( DocumentType ) node , BOOL_ ) ; break ; case Node . ELEMENT_NODE : serializeElement ( ( Element ) node , BOOL_ ) ; break ; case Node . CDATA_SECTION_NODE : break ; case Node . ENTITY_REFERENCE_NODE : serializeEntityReference ( ( EntityReference ) node , BOOL_ ) ; break ; default : } }
public CreateWindowClause addView ( String namespace , String name ) { views . add ( View . create ( namespace , name ) ) ; return this ; }
public int size ( ) { return set . size ( ) ; }
public void associateConnection ( Object connection ) throws ResourceException { if ( ! connectionSharing ) disassociateConnections ( ) ; try { final FBConnection abstractConnection = ( FBConnection ) connection ; abstractConnection . setManagedConnection ( this ) ; connectionHandles . add ( abstractConnection ) ; } catch ( ClassCastException cce ) { throw new FBResourceException ( STR_ , cce ) ; } }
ChronoLocalDateTime < D > toLocalDateTime ( ) ;
private void save ( ) { try { FileUtils . write ( new File ( jarName + STR_ ) , text ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( null , e . getMessage ( ) , STR_ , JOptionPane . ERROR_MESSAGE ) ; } }
private static void assertNotEmpty ( String message , String string ) { assertNotNull ( message , string ) ; assertFalse ( message , string . equals ( STR_ ) ) ; }
private void generateEntityConfig ( ManagedEntityConfig config ) throws SAXException { String host = config . getHost ( ) ; if ( host != null ) { handler . startElement ( STR_ , HOST , HOST , EMPTY ) ; handler . characters ( host . toCharArray ( ) , NUM_ , host . length ( ) ) ; handler . endElement ( STR_ , HOST , HOST ) ; } String remoteCommand = config . getRemoteCommand ( ) ; if ( remoteCommand != null ) { handler . startElement ( STR_ , REMOTE_COMMAND , REMOTE_COMMAND , EMPTY ) ; handler . characters ( remoteCommand . toCharArray ( ) , NUM_ , remoteCommand . length ( ) ) ; handler . endElement ( STR_ , REMOTE_COMMAND , REMOTE_COMMAND ) ; } String workingDirectory = config . getWorkingDirectory ( ) ; if ( workingDirectory != null ) { handler . startElement ( STR_ , WORKING_DIRECTORY , WORKING_DIRECTORY , EMPTY ) ; handler . characters ( workingDirectory . toCharArray ( ) , NUM_ , workingDirectory . length ( ) ) ; handler . endElement ( STR_ , WORKING_DIRECTORY , WORKING_DIRECTORY ) ; } String productDirectory = config . getProductDirectory ( ) ; if ( productDirectory != null ) { handler . startElement ( STR_ , PRODUCT_DIRECTORY , PRODUCT_DIRECTORY , EMPTY ) ; handler . characters ( productDirectory . toCharArray ( ) , NUM_ , productDirectory . length ( ) ) ; handler . endElement ( STR_ , PRODUCT_DIRECTORY , PRODUCT_DIRECTORY ) ; } }
public void hiliteLabel ( Node v , NodeData data ) { NodeView nv = viewer . getNV ( v ) ; if ( nv . getLocation ( ) == null ) return ; Point apt = nv . getLabelPosition ( viewer . trans ) ; if ( apt == null ) return ; gc . setColor ( ProgramProperties . SELECTION_COLOR_ADDITIONAL_TEXT ) ; if ( ! nv . getLabelVisible ( ) && nv . getLabel ( ) != null ) { gc . setFont ( nv . getFont ( ) ) ; gc . drawString ( nv . getLabel ( ) , apt . x , apt . y ) ; } if ( data . getSummarized ( ) . length > NUM_ || ( data . getSummarized ( ) . length == NUM_ && data . getSummarized ( ) [ NUM_ ] > NUM_ ) ) { gc . setFont ( selectionFont ) ; StringBuilder buf = new StringBuilder ( ) ; if ( data . getCountAssigned ( ) > NUM_ ) { buf . append ( STR_ ) ; for ( int value : data . getAssigned ( ) ) { buf . append ( String . format ( STR_ , value ) ) ; } gc . drawString ( buf . toString ( ) , apt . x , apt . y += NUM_ ) ; } buf = new StringBuilder ( ) ; buf . append ( STR_ ) ; for ( int value : data . getSummarized ( ) ) { buf . append ( String . format ( STR_ , value ) ) ; } gc . drawString ( buf . toString ( ) , apt . x , apt . y += NUM_ ) ; } if ( data . getUpPValue ( ) != - NUM_ ) { gc . drawString ( STR_ + ( float ) data . getUpPValue ( ) , apt . x , apt . y += NUM_ ) ; } if ( data . getDownPValue ( ) != - NUM_ ) { gc . drawString ( STR_ + ( float ) data . getDownPValue ( ) , apt . x , apt . y += NUM_ ) ; } }
public void appendLine ( CharSequence line ) { lines . add ( line ) ; }
public void flagActionItems ( ) { if ( ! mIsActionItemsStale ) { return ; } boolean flagged = BOOL_ ; for ( WeakReference < MenuPresenter > ref : mPresenters ) { final MenuPresenter presenter = ref . get ( ) ; if ( presenter == null ) { mPresenters . remove ( ref ) ; } else { flagged |= presenter . flagActionItems ( ) ; } } if ( flagged ) { mActionItems . clear ( ) ; mNonActionItems . clear ( ) ; ArrayList < MenuItemImpl > visibleItems = getVisibleItems ( ) ; final int itemsSize = visibleItems . size ( ) ; for ( int i = NUM_ ; i < itemsSize ; i ++ ) { MenuItemImpl item = visibleItems . get ( i ) ; if ( item . isActionButton ( ) ) { mActionItems . add ( item ) ; } else { mNonActionItems . add ( item ) ; } } } else { mActionItems . clear ( ) ; mNonActionItems . clear ( ) ; mNonActionItems . addAll ( getVisibleItems ( ) ) ; } mIsActionItemsStale = BOOL_ ; }
public static void registerNewAggregationFunction ( String name , Class < ? extends AggregationFunction > clazz , AggregationFunctionMetaDataProvider metaDataProvider ) { AGGREATION_FUNCTIONS . put ( name , clazz ) ; AGGREGATION_FUNCTIONS_META_DATA_PROVIDER . put ( name , metaDataProvider ) ; }
private byte [ ] buildFileAuthTag ( ) throws FileEncryptionException { SecretKey key = backEncRandomAccessFile . shareKey ; if ( key == null || key . getEncoded ( ) . length == NUM_ ) { throw new FileEncryptionException ( STR_ ) ; } else { authTagHMac . reset ( ) ; KeyParameter keyParameter = new KeyParameter ( key . getEncoded ( ) ) ; authTagHMac . init ( keyParameter ) ; } if ( atagList . size ( ) == NUM_ ) { throw new FileEncryptionException ( STR_ ) ; } else { for ( int i = NUM_ ; i < atagList . size ( ) ; i ++ ) { byte [ ] curChunkTag = atagList . get ( i ) ; if ( ( curChunkTag == null ) || ( curChunkTag . length != CHUNK_AUTH_TAG_LENGTH ) ) { throw new FileEncryptionException ( STR_ + i ) ; } else { authTagHMac . update ( curChunkTag , NUM_ , CHUNK_AUTH_TAG_LENGTH ) ; } } byte [ ] tmp = new byte [ AUTH_TAG_SIZE ] ; authTagHMac . doFinal ( tmp , NUM_ ) ; return tmp ; } }
public int hashCode ( ) { return name . hashCode ( ) ; }
public void updateData ( MapElement mapElement ) { nameLabel . setText ( mapElement . getName ( ) ) ; pinnedCheckBox . setSelected ( mapElement . isPinned ( ) ) ; }
public int doFinal ( byte [ ] out , int outOff ) throws DataLengthException , IllegalStateException , InvalidCipherTextException { try { int resultLen = NUM_ ; if ( outOff + bufOff > out . length ) { throw new OutputLengthException ( STR_ ) ; } if ( bufOff != NUM_ ) { if ( ! partialBlockOkay ) { throw new DataLengthException ( STR_ ) ; } cipher . processBlock ( buf , NUM_ , buf , NUM_ ) ; resultLen = bufOff ; bufOff = NUM_ ; System . arraycopy ( buf , NUM_ , out , outOff , resultLen ) ; } return resultLen ; } finally { reset ( ) ; } }
public PriorityQueue ( int initialCapacity , Comparator < ? super E > comparator ) { if ( initialCapacity < NUM_ ) { throw new IllegalArgumentException ( ) ; } elements = newElementArray ( initialCapacity ) ; this . comparator = comparator ; }
public void readData ( DataInput input ) throws IOException { readReference = input . readUnsignedShort ( ) ; readCount = input . readUnsignedShort ( ) ; writeReference = input . readUnsignedShort ( ) ; writeCount = input . readUnsignedShort ( ) ; int byteCount = input . readUnsignedByte ( ) ; if ( nonWordDataHandler == null ) { byte buffer [ ] = new byte [ byteCount ] ; input . readFully ( buffer , NUM_ , byteCount ) ; int offset = NUM_ ; registers = new Register [ writeCount ] ; for ( int register = NUM_ ; register < writeCount ; register ++ ) { registers [ register ] = new SimpleRegister ( buffer [ offset ] , buffer [ offset + NUM_ ] ) ; offset += NUM_ ; } } else { nonWordDataHandler . readData ( input , writeReference , writeCount ) ; } }
private boolean isTouchInsideList ( MotionEvent ev ) { float x = ev . getX ( ) - mListView . getX ( ) ; float y = ev . getY ( ) - mListView . getY ( ) ; if ( x < NUM_ || x > mListView . getWidth ( ) || y < NUM_ || y > mListView . getHeight ( ) ) { return BOOL_ ; } return BOOL_ ; }
public static final void centerChildToParent ( final Component parent , final Component child , final boolean bStayOnScreen ) { int x = ( parent . getX ( ) + ( parent . getWidth ( ) / NUM_ ) ) - ( child . getWidth ( ) / NUM_ ) ; int y = ( parent . getY ( ) + ( parent . getHeight ( ) / NUM_ ) ) - ( child . getHeight ( ) / NUM_ ) ; if ( bStayOnScreen ) { final Toolkit tk = Toolkit . getDefaultToolkit ( ) ; final Dimension ss = new Dimension ( tk . getScreenSize ( ) ) ; if ( ( x + child . getWidth ( ) ) > ss . getWidth ( ) ) { x = ( int ) ( ss . getWidth ( ) - child . getWidth ( ) ) ; } if ( ( y + child . getHeight ( ) ) > ss . getHeight ( ) ) { y = ( int ) ( ss . getHeight ( ) - child . getHeight ( ) ) ; } if ( x < NUM_ ) { x = NUM_ ; } if ( y < NUM_ ) { y = NUM_ ; } } child . setLocation ( x , y ) ; }
public boolean isConnecting ( ) { return start != null && preview != null && preview . isVisible ( ) ; }
public ProtectedProperties ( Properties props ) { Enumeration < ? > propEnum = props . propertyNames ( ) ; while ( propEnum . hasMoreElements ( ) ) { String propName = ( String ) propEnum . nextElement ( ) ; String propValue = props . getProperty ( propName ) ; super . setProperty ( propName , propValue ) ; } closed = BOOL_ ; }
public boolean isEmpty ( ) { return itemList . isEmpty ( ) ; }
private static void fixNumericByteOrder ( byte [ ] bytes ) { for ( int i = NUM_ ; i < bytes . length ; i += NUM_ ) { ByteUtil . swap4Bytes ( bytes , i ) ; } }
public synchronized boolean hasScope ( ) { return ! scopeStack . isEmpty ( ) ; }
private boolean checkAttributeChanged ( String existing , String current ) { if ( existing == null && current == null ) { return BOOL_ ; } if ( ( existing == null ) ^ ( current == null ) ) { return BOOL_ ; } return ( ! existing . equalsIgnoreCase ( current ) ) ; }
public boolean isEmpty ( ) { return count ( ) == NUM_ ; }
@ Override public void addTableModelListener ( TableModelListener l ) { m_Listeners . add ( l ) ; }
private static URL [ ] pathToURLs ( String path ) throws MalformedURLException { synchronized ( pathToURLsCache ) { Object [ ] v = pathToURLsCache . get ( path ) ; if ( v != null ) { return ( ( URL [ ] ) v [ NUM_ ] ) ; } } StringTokenizer st = new StringTokenizer ( path ) ; URL [ ] urls = new URL [ st . countTokens ( ) ] ; for ( int i = NUM_ ; st . hasMoreTokens ( ) ; i ++ ) { urls [ i ] = new URL ( st . nextToken ( ) ) ; } synchronized ( pathToURLsCache ) { pathToURLsCache . put ( path , new Object [ ] { urls , new SoftReference < String > ( path ) } ) ; } return urls ; }
boolean performWork ( TaskManager . Task who , Object param ) throws JobException { Integer tmp = null ; synchronized ( tasks ) { tmp = ( Integer ) tasks . get ( who ) ; } if ( tmp == null ) throw new UnknownTaskException ( ) ; int rank = tmp . intValue ( ) ; synchronized ( attempts ) { attempts [ rank ] ++ ; } Object result = doWork ( who , param ) ; if ( result == null ) return BOOL_ ; try { reportDone ( who , result ) ; } catch ( UnknownTaskException e ) { } catch ( PartialResultException e ) { } catch ( JobException e ) { } return BOOL_ ; }
public List < Order > loadAllDeepFromCursor ( Cursor cursor ) { int count = cursor . getCount ( ) ; List < Order > list = new ArrayList < Order > ( count ) ; if ( cursor . moveToFirst ( ) ) { if ( identityScope != null ) { identityScope . lock ( ) ; identityScope . reserveRoom ( count ) ; } try { do { list . add ( loadCurrentDeep ( cursor , BOOL_ ) ) ; } while ( cursor . moveToNext ( ) ) ; } finally { if ( identityScope != null ) { identityScope . unlock ( ) ; } } } return list ; }
public static boolean isValidAuthType ( String authType ) { log . debug ( STR_ ) ; if ( authType != null ) { if ( ! authType . isEmpty ( ) ) { if ( authType . equalsIgnoreCase ( LdapAuthBase . LDAP_AUTH_TYPE_SIMPLE ) ) return BOOL_ ; if ( authType . equalsIgnoreCase ( LdapAuthBase . LDAP_AUTH_TYPE_NONE ) ) return BOOL_ ; } } return BOOL_ ; }
public int size ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { return count ; } finally { lock . unlock ( ) ; } }
@ After public void tearDown ( ) { webClient . closeAllWindows ( ) ; }
public AnnotationMember ( String name , Object val , Class type , Method m ) { this ( name , val ) ; definingMethod = m ; if ( type == int . class ) { elementType = Integer . class ; } else if ( type == boolean . class ) { elementType = Boolean . class ; } else if ( type == char . class ) { elementType = Character . class ; } else if ( type == float . class ) { elementType = Float . class ; } else if ( type == double . class ) { elementType = Double . class ; } else if ( type == long . class ) { elementType = Long . class ; } else if ( type == short . class ) { elementType = Short . class ; } else if ( type == byte . class ) { elementType = Byte . class ; } else { elementType = type ; } }
public void unregisterPreferenceChangeListener ( PreferenceChangeListener preferenceChangeListener ) { mListeners . remove ( preferenceChangeListener ) ; }
public static String join ( String separator , List < ? > elements ) { if ( elements == null || elements . size ( ) == NUM_ ) { return STR_ ; } StringBuffer sb = new StringBuffer ( elements . size ( ) . NUM_ ) ; int i = NUM_ ; for ( Object elem : elements ) { if ( i ++ > NUM_ ) { sb . append ( separator ) ; } sb . append ( format ( elem ) ) ; } return sb . toString ( ) ; }
public boolean removeTrace ( final Trace trace ) { boolean result = traceList . remove ( trace ) ; if ( result ) { remove ( trace ) ; revalidate ( ) ; } return result ; }
private void updateRandomValues ( ) { for ( int i = NUM_ ; i < mBlockNumber ; i ++ ) { for ( int j = NUM_ ; j < DEFAULT_NUMBER_RANDOM_VALUES ; j ++ ) { mBlockValues [ i ] [ j ] = mRandom . nextFloat ( ) ; if ( mBlockValues [ i ] [ j ] < NUM_ ) { mBlockValues [ i ] [ j ] = NUM_ ; } } } }
protected ASN1Set ( ASN1Encodable obj ) { set . addElement ( obj ) ; }
static private String BYTE_Min_Minus ( ) { long tempValue = Byte . MIN_VALUE - NUM_ ; return String . valueOf ( tempValue ) ; }
public DoubleAccumulator ( DoubleBinaryOperator accumulatorFunction , double identity ) { this . function = accumulatorFunction ; base = this . identity = Double . doubleToRawLongBits ( identity ) ; }
public static void bitmapToMat ( Bitmap bmp , Mat mat , boolean unPremultiplyAlpha ) { if ( bmp == null ) throw new java . lang . IllegalArgumentException ( STR_ ) ; if ( mat == null ) throw new java . lang . IllegalArgumentException ( STR_ ) ; nBitmapToMat2 ( bmp , mat . nativeObj , unPremultiplyAlpha ) ; }
public static void sendMail ( Context mContext , String mailID ) { Uri uri = Uri . parse ( STR_ + mailID ) ; Intent intent = new Intent ( Intent . ACTION_SENDTO , uri ) ; mContext . startActivity ( intent ) ; }
public void push ( @ NotNull StatusNotification notification ) { stack . push ( notification ) ; }
public void onPaintActions ( ViewTransform transform , Graphics2D g ) { if ( ! mIsSelected ) { return ; } if ( mColorSet == null ) { return ; } if ( mWidget . getVisibility ( ) == ConstraintWidget . GONE ) { return ; } if ( ! mShowResizeHandles ) { return ; } if ( ! mShowActions ) { return ; } if ( mWidgetActions . size ( ) == NUM_ ) { return ; } int l = transform . getSwingFX ( mWidget . getDrawX ( ) ) ; int t = transform . getSwingFY ( mWidget . getDrawY ( ) ) ; int h = transform . getSwingDimension ( mWidget . getHeight ( ) ) ; int x = l ; int y = t + h + ConnectionDraw . CONNECTION_ANCHOR_SIZE + NUM_ ; g . setColor ( mColorSet . getSelectedFrames ( ) ) ; for ( WidgetAction action : mWidgetActions ) { action . update ( ) ; if ( ! action . isVisible ( ) ) { continue ; } action . onPaint ( transform , g , x , y ) ; x += ACTION_SIZE + ConnectionDraw . CONNECTION_ANCHOR_SIZE ; } }
@ Override public Lookup createGlobalContext ( ) { if ( proxyLookup == null ) { logger . config ( STR_ ) ; projectLookup = new AbstractLookup ( content ) ; proxyLookup = new ProxyLookup ( globalContextLookup , projectLookup ) ; } return proxyLookup ; }
public void write ( byte [ ] bytes ) throws IOException { flushBits ( ) ; if ( bytes != null && bytes . length > NUM_ ) { out . write ( bytes ) ; bytesWritten += bytes . length ; } }
public static MutableList < String > chunk ( String string , int size ) { if ( size <= NUM_ ) { throw new IllegalArgumentException ( STR_ + size ) ; } int length = string . length ( ) ; if ( length == NUM_ ) { return FastList . newList ( ) ; } MutableList < String > result = FastList . newList ( ( length + size - NUM_ ) / size ) ; int startOffset = NUM_ ; while ( startOffset < length ) { result . add ( string . substring ( startOffset , Math . min ( startOffset + size , length ) ) ) ; startOffset += size ; } return result ; }
public void removeIm ( ImEntity im ) { ims . remove ( im ) ; }
public LanguageSetting ( Option opt ) { elem = null ; name = opt . getLanguage ( ) ; String [ ] suffixArray = opt . getSuffixes ( ) ; StringBuffer strbuf = new StringBuffer ( ) ; for ( int i = NUM_ ; i < suffixArray . length ; i ++ ) { strbuf . append ( suffixArray [ i ] ) ; if ( i != suffixArray . length - NUM_ ) strbuf . append ( STR_ ) ; } this . suffixes = strbuf . toString ( ) ; minMatchLen = opt . getMinimumMatchLength ( ) ; clusterType = opt . getClustertype ( ) ; readSubdirs = opt . isReadSubdirs ( ) ; storeMatches = opt . getStoreMatches ( ) ; }
private double calcUtil4Performing ( final double typDuration , final double actualDuration ) { return NUM_ . marginalUtilPerformingSec + marginalUtilPerformingSec . typDuration . Math . log ( actualDuration / typDuration ) ; }
public void clearAllCache ( ) { clearMemoryCache ( ) ; clearStorageCache ( ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( NUM_ ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return newVector . elements ( ) ; }
public void addNotify ( ) { super . addNotify ( ) ; if ( textArea != null ) { l . install ( textArea ) ; } updateCellWidths ( ) ; updateCellHeights ( ) ; }
@ Description ( summary = STR_ ) public void mavenInstallLocal ( ) { jarMVStore ( ) ; String pom = new String ( readFile ( new File ( STR_ ) ) ) ; pom = replaceAll ( pom , STR_ , STR_ ) ; writeFile ( new File ( STR_ ) , pom . getBytes ( ) ) ; execScript ( STR_ , args ( STR_ , STR_ , STR_ + getJarSuffix ( ) , STR_ , STR_ , STR_ , STR_ ) ) ; jar ( ) ; pom = new String ( readFile ( new File ( STR_ ) ) ) ; pom = replaceAll ( pom , STR_ , STR_ ) ; writeFile ( new File ( STR_ ) , pom . getBytes ( ) ) ; execScript ( STR_ , args ( STR_ , STR_ , STR_ + getJarSuffix ( ) , STR_ , STR_ , STR_ , STR_ ) ) ; }
public static boolean isDtoGetter ( Method method ) { if ( method . isAnnotationPresent ( DelegateTo . class ) ) { return BOOL_ ; } if ( method . getParameterTypes ( ) . length > NUM_ ) { return BOOL_ ; } String methodName = method . getName ( ) ; return methodName . startsWith ( STR_ ) || ( methodName . startsWith ( STR_ ) && ( ( method . getReturnType ( ) == Boolean . class || method . getReturnType ( ) == boolean . class ) ) ) ; }
protected List < VideoDTO > extractVideosFromCursor ( Cursor cursor , int offset , int limit ) { List < VideoDTO > videos = new ArrayList < > ( ) ; int count = NUM_ ; int begin = offset > NUM_ ? offset : NUM_ ; if ( cursor . moveToPosition ( begin ) ) { do { VideoDTO video = extractOneVideoFromCursor ( cursor ) ; videos . add ( video ) ; count ++ ; if ( limit > NUM_ && count > limit ) { break ; } } while ( cursor . moveToNext ( ) ) ; } cursor . close ( ) ; return videos ; }
private static void computeNextCCWEdges ( Node node , long label ) { DirectedEdgeStar deStar = node . getOutEdges ( ) ; PolygonizeDirectedEdge firstOutDE = null ; PolygonizeDirectedEdge prevInDE = null ; List edges = deStar . getEdges ( ) ; for ( int i = edges . size ( ) - NUM_ ; i >= NUM_ ; i -- ) { PolygonizeDirectedEdge de = ( PolygonizeDirectedEdge ) edges . get ( i ) ; PolygonizeDirectedEdge sym = ( PolygonizeDirectedEdge ) de . getSym ( ) ; PolygonizeDirectedEdge outDE = null ; if ( de . getLabel ( ) == label ) outDE = de ; PolygonizeDirectedEdge inDE = null ; if ( sym . getLabel ( ) == label ) inDE = sym ; if ( outDE == null && inDE == null ) continue ; if ( inDE != null ) { prevInDE = inDE ; } if ( outDE != null ) { if ( prevInDE != null ) { prevInDE . setNext ( outDE ) ; prevInDE = null ; } if ( firstOutDE == null ) firstOutDE = outDE ; } } if ( prevInDE != null ) { Assert . isTrue ( firstOutDE != null ) ; prevInDE . setNext ( firstOutDE ) ; } }
@ Override public boolean equals ( Object other ) { if ( other instanceof IntArrayWrapper ) { return Arrays . equals ( data , ( ( IntArrayWrapper ) other ) . data ) ; } return BOOL_ ; }
public static DateTime toDateSimple ( String str , TimeZone timeZone ) throws PageException { DateTime dt = toDateSimple ( str , CONVERTING_TYPE_OFFSET , BOOL_ , timeZone , null ) ; if ( dt == null ) throw new ExpressionException ( STR_ + str + STR_ ) ; return dt ; }
public boolean contains ( Song s ) { return mSongs . contains ( s ) ; }
private float clampMag ( float value , float absMin , float absMax ) { final float absValue = Math . abs ( value ) ; if ( absValue < absMin ) return NUM_ ; if ( absValue > absMax ) return value > NUM_ ? absMax : - absMax ; return value ; }
private boolean zzRefill ( ) throws java . io . IOException { if ( zzStartRead > NUM_ ) { zzEndRead += zzFinalHighSurrogate ; zzFinalHighSurrogate = NUM_ ; System . arraycopy ( zzBuffer , zzStartRead , zzBuffer , NUM_ , zzEndRead - zzStartRead ) ; zzEndRead -= zzStartRead ; zzCurrentPos -= zzStartRead ; zzMarkedPos -= zzStartRead ; zzStartRead = NUM_ ; } if ( zzCurrentPos >= zzBuffer . length - zzFinalHighSurrogate ) { char newBuffer [ ] = new char [ zzBuffer . length . NUM_ ] ; System . arraycopy ( zzBuffer , NUM_ , newBuffer , NUM_ , zzBuffer . length ) ; zzBuffer = newBuffer ; zzEndRead += zzFinalHighSurrogate ; zzFinalHighSurrogate = NUM_ ; } int requested = zzBuffer . length - zzEndRead ; int numRead = zzReader . read ( zzBuffer , zzEndRead , requested ) ; if ( numRead == NUM_ ) { throw new java . io . IOException ( STR_ ) ; } if ( numRead > NUM_ ) { zzEndRead += numRead ; if ( numRead == requested ) { if ( Character . isHighSurrogate ( zzBuffer [ zzEndRead - NUM_ ] ) ) { -- zzEndRead ; zzFinalHighSurrogate = NUM_ ; } } return BOOL_ ; } return BOOL_ ; }
public int addPadding ( byte [ ] in , int inOff ) { byte code = ( byte ) ( in . length - inOff ) ; while ( inOff < in . length - NUM_ ) { if ( random == null ) { in [ inOff ] = NUM_ ; } else { in [ inOff ] = ( byte ) random . nextInt ( ) ; } inOff ++ ; } in [ inOff ] = code ; return code ; }
public static Long makeLong ( String s ) { if ( WWUtil . isEmpty ( s ) ) { return null ; } try { return Long . valueOf ( s ) ; } catch ( NumberFormatException e ) { return null ; } }
private void verifyBlockSnapshotMigration ( ) throws Exception { log . info ( STR_ ) ; Iterator < BlockSnapshot > blockSnapshotItr = _dbClient . queryIterativeObjects ( BlockSnapshot . class , blockSnapshotURIs ) ; List < BlockObject > blockObjects = new ArrayList < BlockObject > ( ) ; while ( blockSnapshotItr . hasNext ( ) ) { blockObjects . add ( blockSnapshotItr . next ( ) ) ; } verifyBlockObjects ( blockObjects ) ; }
public static String edgeTypeToString ( @ Type int edgeType ) { switch ( edgeType ) { case FALL_THROUGH_EDGE : return STR_ ; case IFCMP_EDGE : return STR_ ; case SWITCH_EDGE : return STR_ ; case SWITCH_DEFAULT_EDGE : return STR_ ; case JSR_EDGE : return STR_ ; case RET_EDGE : return STR_ ; case GOTO_EDGE : return STR_ ; case RETURN_EDGE : return STR_ ; case UNHANDLED_EXCEPTION_EDGE : return STR_ ; case HANDLED_EXCEPTION_EDGE : return STR_ ; case START_EDGE : return STR_ ; case BACKEDGE_TARGET_EDGE : return STR_ ; case BACKEDGE_SOURCE_EDGE : return STR_ ; case EXIT_EDGE : return STR_ ; } throw new IllegalStateException ( STR_ + edgeType ) ; }
boolean checkGroups ( PhoneNumberUtil util , PhoneNumber number , StringBuilder normalizedCandidate , String [ ] expectedNumberGroups ) ;
private int insertUnassignedGroup ( ) throws SQLException { PreparedStatement groupStatement ; final int ruleid = insertUnassignedRule ( ) ; final int evaluationOrder = getNumOfGroups ( ) + NUM_ ; String unassignedGroupSqlStatement = STR_ + GROUPS_TABLE + STR_ + STR_ + STR_ ; unassignedGroupSqlStatement = String . format ( unassignedGroupSqlStatement , UNASSIGNED_GROUP , UNASSIGNED_GROUP_TYPE , UNASSIGNED_DATA_TYPE , ruleid , evaluationOrder ) ; groupStatement = prepareStatement ( unassignedGroupSqlStatement , new String [ ] { STR_ } ) ; groupStatement . execute ( ) ; return getInternalId ( groupStatement ) ; }
public Builder deleteExtensionField ( String urn , String fieldName ) { deleteFields . add ( urn + STR_ + fieldName ) ; return this ; }
@ SuppressWarnings ( STR_ ) private List < List < GroupAttribute > > searchAuthProvider ( Filter queryBuilder , String [ ] returnAttributes , final long countLimit , AttributesMapper mapper , ValidationFailureReason [ ] failureReason ) throws SizeLimitExceededException { SearchControls groupSearchControls = new SearchControls ( SearchControls . SUBTREE_SCOPE , countLimit , _searchControls . getTimeLimit ( ) , returnAttributes , _searchControls . getReturningObjFlag ( ) , _searchControls . getDerefLinkFlag ( ) ) ; List < List < GroupAttribute > > queryGroupResults = null ; queryGroupResults = safeLdapSearch ( _baseDN , queryBuilder . encode ( ) , groupSearchControls , mapper , failureReason ) ; return queryGroupResults ; }
protected void export ( OMGraphicList list , List < Object > masterRecord , boolean writeFiles ) { badGraphics = NUM_ ; if ( list == null ) { return ; } else if ( list instanceof EsriGraphicList ) { export ( ( EsriGraphicList ) list ) ; return ; } int dbfIndex = NUM_ ; for ( OMGraphic dtlGraphic : list ) { List < Object > record = masterRecord ; Integer recIndex = ( Integer ) dtlGraphic . getAttribute ( SHAPE_INDEX_ATTRIBUTE ) ; if ( recIndex == null ) { recIndex = dbfIndex ; } if ( record == null ) { record = getMasterDBFRecord ( recIndex ) ; } dbfIndex ++ ; if ( dtlGraphic instanceof OMGraphicList ) { if ( DEBUG ) logger . fine ( STR_ ) ; export ( ( OMGraphicList ) dtlGraphic , record , BOOL_ ) ; continue ; } if ( dtlGraphic . getRenderType ( ) != RENDERTYPE_LATLON ) { badGraphics ++ ; continue ; } if ( dtlGraphic instanceof OMAreaList ) { if ( DEBUG ) { logger . fine ( STR_ ) ; } addAreaList ( ( OMAreaList ) dtlGraphic , record ) ; } if ( dtlGraphic instanceof OMPoly ) { OMPoly omPoly = ( OMPoly ) dtlGraphic ; if ( isPolygon ( omPoly ) ) { if ( DEBUG ) logger . fine ( STR_ ) ; addPolygon ( dtlGraphic , record ) ; } else { if ( DEBUG ) logger . fine ( STR_ ) ; addLine ( dtlGraphic , record ) ; } } else if ( dtlGraphic instanceof OMRect ) { if ( DEBUG ) logger . fine ( STR_ ) ; addPolygon ( ( OMGraphic ) EsriPolygonList . convert ( ( OMRect ) dtlGraphic ) , record ) ; } else if ( dtlGraphic instanceof OMCircle ) { if ( DEBUG ) logger . fine ( STR_ ) ; addPolygon ( ( OMGraphic ) EsriPolygonList . convert ( ( OMCircle ) dtlGraphic , projection ) , record ) ; } else if ( dtlGraphic instanceof OMRangeRings ) { if ( DEBUG ) logger . fine ( STR_ ) ; export ( EsriPolygonList . convert ( ( OMRangeRings ) dtlGraphic , projection ) , record , BOOL_ ) ; } else if ( dtlGraphic instanceof OMLine ) { if ( DEBUG ) logger . fine ( STR_ ) ; addLine ( ( OMGraphic ) EsriPolylineList . convert ( ( OMLine ) dtlGraphic ) , record ) ; } else if ( dtlGraphic instanceof OMPoint ) { if ( DEBUG ) logger . fine ( STR_ ) ; addPoint ( dtlGraphic , record ) ; } } if ( badGraphics > NUM_ ) { DrawingToolRenderException . notifyUserOfNonLatLonGraphics ( badGraphics ) ; } if ( ! writeFiles ) { return ; } boolean needConfirmation = BOOL_ ; if ( filePath == null ) { filePath = getFilePathFromUser ( ) ; if ( filePath == null ) { return ; } needConfirmation = BOOL_ ; } if ( DEBUG ) logger . fine ( STR_ ) ; boolean needTypeSuffix = BOOL_ ; if ( polyList != null ) { eseInterfaces . add ( new ESEInterface ( polyList , filePath , null ) ) ; needTypeSuffix = BOOL_ ; } if ( lineList != null ) { eseInterfaces . add ( new ESEInterface ( lineList , filePath , ( needTypeSuffix ? LineSuffix : null ) ) ) ; needTypeSuffix = BOOL_ ; } if ( pointList != null ) { eseInterfaces . add ( new ESEInterface ( pointList , filePath , ( needTypeSuffix ? PointSuffix : null ) ) ) ; } if ( needConfirmation ) { showGUI ( ) ; } else { writeFiles ( ) ; } }
public Depend ( PathImpl source , long lastModified , long length ) { _source = source ; _lastModified = lastModified ; _length = length ; }
public boolean hasTaskOfTypeInProgress ( @ NotNull ExternalSystemTaskType type , @ NotNull Project project ) { String projectId = ExternalSystemTaskId . getProjectId ( project ) ; for ( ExternalSystemTaskId id : myTasksInProgress . keySet ( ) ) { if ( type . equals ( id . getType ( ) ) && projectId . equals ( id . getIdeProjectId ( ) ) ) { return BOOL_ ; } } return BOOL_ ; }
public final void removeChangeListener ( ChangeListener listener ) { listeners . remove ( listener ) ; }
public static boolean containsIgnoreCase ( String str , String query ) { if ( str != null && query != null ) { int limit = str . length ( ) - query . length ( ) + NUM_ ; for ( int i = NUM_ ; i < limit ; i ++ ) { if ( matchesIgnoreCase ( str , query , i ) ) { return BOOL_ ; } } } return BOOL_ ; }
public String toMatrixString ( ) throws Exception { return toMatrixString ( STR_ ) ; }
public QuadEdge connect ( QuadEdge a , QuadEdge b ) { QuadEdge q = QuadEdge . connect ( a , b ) ; quadEdges . add ( q ) ; return q ; }
public Test findTest ( List < String > suiteNames , String testClassName , String testName , boolean insertIfMissing ) { if ( suiteNames . size ( ) <= NUM_ ) { TestCase testCase = getTestCase ( testClassName ) ; return testCase . findTest ( testName , insertIfMissing ) ; } else { String rootName = suiteNames . remove ( NUM_ ) ; TestSuite suite = getTestSuite ( rootName ) ; return suite . findTest ( suiteNames , testClassName , testName , insertIfMissing ) ; } }
public Job configure ( boolean isSecured , String metaStoreUris , String principal , String redisHost , int redisPort , String password , int redisDb , String inputDatabase , String inputTable , String inputFilter , String keyName , String valueName , String keyPrefix , int numReducer , boolean replace , boolean pipeline , boolean flush , int commitSize , String [ ] anonFields , String exportSalt ) throws Exception { this . isSecured = isSecured ; this . metaStoreUris = metaStoreUris ; this . principal = principal ; this . redisHost = redisHost ; this . redisPort = redisPort ; this . password = password ; this . redisDb = redisDb ; this . inputDatabase = inputDatabase ; this . inputTable = inputTable ; this . inputFilter = inputFilter ; this . keyName = keyName ; this . keyPrefix = keyPrefix ; this . valueName = valueName ; this . numReducer = numReducer ; this . replace = replace ; this . pipeline = pipeline ; this . flush = flush ; this . commitSize = commitSize ; this . anonFields = anonFields . clone ( ) ; this . exportSalt = exportSalt ; return configure ( ) ; }
public static double log2 ( double a ) { return Math . log ( a ) / log2 ; }
public void addSuggestions ( final @ NonNull SuggestionsResult result , final @ NonNull String bucket , final @ NonNull TokenSource source ) { QueryToken query = result . getQueryToken ( ) ; synchronized ( mLock ) { mResultMap . put ( bucket , result ) ; Set < String > waitingForBuckets = mWaitingForResults . get ( query ) ; if ( waitingForBuckets != null ) { waitingForBuckets . remove ( bucket ) ; if ( waitingForBuckets . size ( ) == NUM_ ) { mWaitingForResults . remove ( query ) ; } } } String currentTokenString = source . getCurrentTokenString ( ) ; synchronized ( mLock ) { mSuggestions . clear ( ) ; List < Suggestible > suggestions = mSuggestionsListBuilder . buildSuggestions ( mResultMap , currentTokenString ) ; if ( suggestions . size ( ) > NUM_ ) { mSuggestions . addAll ( suggestions ) ; mSuggestionsVisibilityManager . displaySuggestions ( BOOL_ ) ; } else { hideSuggestionsIfNecessary ( result . getQueryToken ( ) , source ) ; } } notifyDataSetChanged ( ) ; }
public static < ET extends Enum < ET > > EnumResolver < ET > constructFor ( Class < ET > enumCls , AnnotationIntrospector ai ) { ET [ ] enumValues = enumCls . getEnumConstants ( ) ; if ( enumValues == null ) { throw new IllegalArgumentException ( STR_ + enumCls . getName ( ) ) ; } HashMap < String , ET > map = new HashMap < String , ET > ( ) ; for ( ET e : enumValues ) { map . put ( ai . findEnumValue ( e ) , e ) ; } return new EnumResolver < ET > ( enumCls , enumValues , map ) ; }
protected void encodeLineSuffix ( OutputStream aStream ) throws IOException { pStream . println ( ) ; }
public static boolean replace ( RTextArea textArea , String toFind , String replaceWith , boolean forward , boolean matchCase , boolean wholeWord , boolean regex ) throws PatternSyntaxException { textArea . beginAtomicEdit ( ) ; try { if ( regex ) { return regexReplace ( textArea , toFind , replaceWith , forward , matchCase , wholeWord ) ; } makeMarkAndDotEqual ( textArea , forward ) ; if ( find ( textArea , toFind , forward , matchCase , wholeWord , BOOL_ ) ) { textArea . replaceSelection ( replaceWith ) ; return BOOL_ ; } } finally { textArea . endAtomicEdit ( ) ; } return BOOL_ ; }
public void preSingleSignOnRequest ( String hostedEntityID , String idpEntityID , String realm , HttpServletRequest request , HttpServletResponse response , AuthnRequest authnRequest ) throws SAML2Exception { return ; }
void submit ( ProcessAndDisplayImageTask task ) { initExecutorsIfNeed ( ) ; taskExecutorForCachedImages . execute ( task ) ; }
public static ImageIcon createIcon ( BasicStroke stroke , int width , int height , boolean horizontalOrientation ) { BufferedImage bigImage = new BufferedImage ( width , height , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g = ( Graphics2D ) bigImage . getGraphics ( ) ; g . setBackground ( OMColor . clear ) ; g . setPaint ( OMColor . clear ) ; g . fillRect ( NUM_ , NUM_ , width , height ) ; g . setPaint ( Color . black ) ; g . setStroke ( stroke ) ; if ( horizontalOrientation ) { g . drawLine ( NUM_ , height / NUM_ , width , height / NUM_ ) ; } else { g . drawLine ( width / NUM_ , NUM_ , width / NUM_ , height ) ; } return new ImageIcon ( bigImage ) ; }
public static final < T extends EObject > List < T > collectNodesWithinSameThisEnvironment ( EObject root , Class < T > cls ) { final List < T > result = new ArrayList < > ( ) ; final TreeIterator < EObject > iter = root . eAllContents ( ) ; while ( iter . hasNext ( ) ) { final EObject obj = iter . next ( ) ; if ( cls . isAssignableFrom ( obj . getClass ( ) ) ) { @ SuppressWarnings ( STR_ ) final T objCasted = ( T ) obj ; result . add ( objCasted ) ; } if ( obj instanceof ThisArgProvider ) { iter . prune ( ) ; } } return result ; }
protected abstract List < SingleVariableDeclaration > adjustDstParams ( MethodDeclaration method ) ;
public String fullSource ( ) { if ( fullSource == null ) { fullSource = addSentenceMarkers ( source ( ) ) ; } return fullSource ; }
private void updateDetailData ( ) { final long start = mLeftPosition ; final long end = mRightPosition ; final long now = mCurrentTime ; final Context context = getContext ( ) ; NetworkStatsHistory . Entry originalEntry = mOriginalNetworkStatsHistory . getValues ( start , end , now , null ) ; final long originalTotalBytes = originalEntry . rxBytes ; mOriginalTotalPhrase = Formatter . formatFileSize ( context , originalTotalBytes ) ; NetworkStatsHistory . Entry compressedEntry = mReceivedNetworkStatsHistory . getValues ( start , end , now , null ) ; final long compressedTotalBytes = compressedEntry . rxBytes ; mReceivedTotalPhrase = Formatter . formatFileSize ( context , compressedTotalBytes ) ; float percentage = NUM_ ; if ( originalTotalBytes > NUM_ && originalTotalBytes > compressedTotalBytes ) { percentage = ( originalTotalBytes - compressedTotalBytes ) / ( float ) originalTotalBytes ; } mPercentReductionPhrase = String . format ( STR_ , NUM_ . percentage ) ; mStartDatePhrase = formatDate ( context , start ) ; mEndDatePhrase = formatDate ( context , end ) ; }
public PunctuationTrie < T > lookup ( CharSequence s ) { PunctuationTrie < T > t = this ; for ( int i = NUM_ , n = s . length ( ) ; i < n ; ++ i ) { t = t . lookup ( s . charAt ( i ) ) ; if ( null == t ) { break ; } } return t ; }
private static File constructFilePaths ( String file1 , String file2 ) { File newPath ; if ( file2 . startsWith ( file1 ) ) { newPath = new File ( file2 ) ; } else { newPath = new File ( file1 + STR_ + file2 ) ; } return newPath ; }
public String resolveTemplate ( ITemplateType templateType , Map < String , String > replacements ) throws IOException { Path path = getTemplatePath ( templateType ) ; String template = new String ( Files . readAllBytes ( path ) , StandardCharsets . UTF_8 ) ; return insertProperties ( template , replacements ) ; }
public void execute ( ) { try { prep . execute ( ) ; } catch ( SQLException e ) { throw convert ( e ) ; } }
public void clear ( ) { oredCriteria . clear ( ) ; orderByClause = null ; distinct = BOOL_ ; }
private static byte [ ] unwrapCalculatedValue ( byte [ ] data ) { if ( data . length < CALC_DATA_OFFSET ) { return data ; } ByteBuffer buffer = PageChannel . wrap ( data ) ; buffer . position ( CALC_DATA_LEN_OFFSET ) ; int dataLen = buffer . getInt ( ) ; byte [ ] newData = new byte [ Math . min ( buffer . remaining ( ) , dataLen ) ] ; buffer . get ( newData ) ; return newData ; }
public synchronized TypeInstance createInstance ( final String name , final String comment , final BaseType baseType , final Section section , final long sectionOffset ) throws CouldntSaveDataException , CouldntLoadDataException { Preconditions . checkNotNull ( name , STR_ ) ; Preconditions . checkArgument ( comment == null || ! comment . isEmpty ( ) , STR_ ) ; Preconditions . checkNotNull ( baseType , STR_ ) ; Preconditions . checkNotNull ( section , STR_ ) ; Preconditions . checkArgument ( sectionOffset >= NUM_ , STR_ ) ; Preconditions . checkArgument ( ! instancesByAddress . containsKey ( new TypeInstanceAddress ( section . getStartAddress ( ) , sectionOffset ) ) ) ; final TypeInstance instance = backend . createTypeInstance ( name , comment , baseType , section , sectionOffset ) ; instancesByAddress . put ( instance . getAddress ( ) , instance ) ; instances . add ( instance ) ; notifyInstanceAdded ( instance ) ; return instance ; }
void showInputBox ( String message , Consumer < String > resultCallback ) { showInputBox ( message , null , resultCallback ) ; }
public void add ( Field field ) { mFields . add ( field ) ; }
public static long measureTime ( Callable < Object > c , int threadCnt ) throws Exception { A . ensure ( threadCnt >= NUM_ , STR_ ) ; long start = System . currentTimeMillis ( ) ; if ( threadCnt == NUM_ ) c . call ( ) ; else GridTestUtils . runMultiThreaded ( c , threadCnt , STR_ ) ; return System . currentTimeMillis ( ) - start ; }
@ Override public boolean isClosed ( ) { return _isClosed . get ( ) ; }
protected StatementListNode generateDestructorBody ( Context context , StatementListNode statementList ) { Model model = ( Model ) value ; Set < String > ids = new LinkedHashSet < String > ( ) ; if ( model . isDeclared ( ) ) ids . add ( model . getId ( ) ) ; collectDeclarations ( model . getSubInitializerIterator ( ) , ids ) ; NodeFactory nodeFactory = context . getNodeFactory ( ) ; StatementListNode result = statementList ; StatementListNode functionStatementList = null ; for ( String id : ids ) { LiteralNullNode literalNull = nodeFactory . literalNull ( ) ; IdentifierNode identifier = nodeFactory . identifier ( id ) ; Node expressionStatement = nodeFactory . assignmentExpression ( identifier , ASSIGN_TOKEN , literalNull ) ; functionStatementList = nodeFactory . statementList ( functionStatementList , expressionStatement ) ; } FunctionSignatureNode functionSignature = nodeFactory . functionSignature ( null , null ) ; functionSignature . void_anno = BOOL_ ; IdentifierNode functionIdentifier = nodeFactory . identifier ( model . getDefinitionName ( ) + STR_ ) ; FunctionCommonNode functionCommon = nodeFactory . functionCommon ( context , functionIdentifier , functionSignature , functionStatementList ) ; functionCommon . setUserDefinedBody ( BOOL_ ) ; AttributeListNode attributeList = AbstractSyntaxTreeUtil . generatePrivateAttribute ( nodeFactory ) ; FunctionNameNode functionName = nodeFactory . functionName ( Tokens . EMPTY_TOKEN , functionIdentifier ) ; FunctionDefinitionNode functionDefinition = nodeFactory . functionDefinition ( context , attributeList , functionName , functionCommon ) ; result = nodeFactory . statementList ( result , functionDefinition ) ; return result ; }
protected synchronized void expire ( ) throws IllegalMonitorStateException { if ( owner == Thread . currentThread ( ) ) { expired = BOOL_ ; } else { throw new IllegalMonitorStateException ( STR_ ) ; } }
private StringBuffer prepareOptimizedInsertStatement ( OneRowChange oneRowChange ) { StringBuffer stmt ; stmt = new StringBuffer ( ) ; stmt . append ( STR_ ) ; stmt . append ( conn . getDatabaseObjectName ( oneRowChange . getSchemaName ( ) ) + STR_ + conn . getDatabaseObjectName ( oneRowChange . getTableName ( ) ) ) ; stmt . append ( STR_ ) ; printColumnSpec ( stmt , oneRowChange . getColumnSpec ( ) , null , null , PrintMode . NAMES_ONLY , STR_ ) ; stmt . append ( STR_ ) ; boolean firstRow = BOOL_ ; for ( ArrayList < ColumnVal > oneRowValues : oneRowChange . getColumnValues ( ) ) { if ( firstRow ) { firstRow = BOOL_ ; } else stmt . append ( STR_ ) ; printColumnSpec ( stmt , oneRowChange . getColumnSpec ( ) , null , oneRowValues , PrintMode . PLACE_HOLDER , STR_ ) ; stmt . append ( STR_ ) ; } return stmt ; }
private boolean extractorQueueEmpty ( ) throws InterruptedException { if ( extractor . hasMoreEvents ( ) ) return BOOL_ ; else if ( blockCommitIntervalMillis <= NUM_ ) return BOOL_ ; else { long nextCommitMillis = lastCommitMillis + blockCommitIntervalMillis ; long sleepMillis = nextCommitMillis - System . currentTimeMillis ( ) ; while ( sleepMillis > NUM_ ) { Thread . sleep ( NUM_ ) ; if ( extractor . hasMoreEvents ( ) ) return BOOL_ ; sleepMillis = nextCommitMillis - System . currentTimeMillis ( ) ; } return BOOL_ ; } }
public static void verify ( final ClassReader cr , final boolean dump , final PrintWriter pw ) { verify ( cr , null , dump , pw ) ; }
public FileAsyncHttpResponseHandler ( Context context ) { super ( ) ; this . file = getTemporaryFile ( context ) ; this . append = BOOL_ ; this . renameIfExists = BOOL_ ; }
public static boolean isWindowOpaque ( Window window ) { if ( window == null ) { throw new NullPointerException ( STR_ ) ; } return window . isOpaque ( ) ; }
public static byte [ ] encode ( byte [ ] data , int off , int length ) { int len = ( length + NUM_ ) / NUM_ . NUM_ ; ByteArrayOutputStream bOut = new ByteArrayOutputStream ( len ) ; try { encoder . encode ( data , off , length , bOut ) ; } catch ( Exception e ) { throw new EncoderException ( STR_ + e . getMessage ( ) , e ) ; } return bOut . toByteArray ( ) ; }
public double entropyNMIMin ( ) { return ( entropyMutualInformation ( ) / Math . min ( entropyFirst ( ) , entropySecond ( ) ) ) ; }
public static void unregister ( CloseWatcher w ) { w . closeable = null ; refs . remove ( w ) ; }
protected final void refreshLoadingViewsSize ( ) { final int maximumPullScroll = ( int ) ( getMaximumPullScroll ( ) . NUM_ ) ; int pLeft = getPaddingLeft ( ) ; int pTop = getPaddingTop ( ) ; int pRight = getPaddingRight ( ) ; int pBottom = getPaddingBottom ( ) ; switch ( getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setWidth ( maximumPullScroll ) ; pLeft = - maximumPullScroll ; } else { pLeft = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setWidth ( maximumPullScroll ) ; pRight = - maximumPullScroll ; } else { pRight = NUM_ ; } break ; case VERTICAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setHeight ( maximumPullScroll ) ; pTop = - maximumPullScroll ; } else { pTop = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setHeight ( maximumPullScroll ) ; pBottom = - maximumPullScroll ; } else { pBottom = NUM_ ; } break ; } if ( DEBUG ) { Log . d ( LOG_TAG , String . format ( STR_ , pLeft , pTop , pRight , pBottom ) ) ; } setPadding ( pLeft , pTop , pRight , pBottom ) ; }
static LabelNode [ ] clone ( final List < LabelNode > labels , final Map < LabelNode , LabelNode > map ) { LabelNode [ ] clones = new LabelNode [ labels . size ( ) ] ; for ( int i = NUM_ ; i < clones . length ; ++ i ) { clones [ i ] = map . get ( labels . get ( i ) ) ; } return clones ; }
@ Override public JettySolrRunner createJetty ( File solrHome , String dataDir , String shardList , String solrConfigOverride , String schemaOverride ) throws Exception { return createProxiedJetty ( solrHome , dataDir , shardList , solrConfigOverride , schemaOverride ) ; }
public synchronized void addBatchClassifierListener ( BatchClassifierListener cl ) { m_batchClassifierListeners . addElement ( cl ) ; }
private boolean matchAndwriteOneAuditLog ( BufferedWriter writer , AuditLog auditlog , String keyword ) throws MarshallingExcetion { try { AuditLogUtils . resetDesc ( auditlog , resb ) ; if ( AuditLogUtils . isKeywordContained ( auditlog , keyword ) ) { if ( _count . getAndIncrement ( ) > NUM_ ) { while ( ! _firstWritten . get ( ) ) { try { Thread . sleep ( NUM_ ) ; } catch ( InterruptedException e ) { _logger . warn ( STR_ ) ; } } writer . write ( STR_ + _mapper . writeValueAsString ( auditlog ) ) ; } else { writer . write ( _mapper . writeValueAsString ( auditlog ) ) ; _firstWritten . set ( BOOL_ ) ; } return BOOL_ ; } _logger . debug ( STR_ , auditlog . getDescription ( ) , keyword ) ; return BOOL_ ; } catch ( JsonGenerationException e ) { throw new MarshallingExcetion ( STR_ , e ) ; } catch ( JsonMappingException e ) { throw new MarshallingExcetion ( STR_ , e ) ; } catch ( IOException e ) { throw new MarshallingExcetion ( STR_ , e ) ; } }
String toString ( boolean includePrivateCredentials ) { String s = ResourcesMgr . getString ( STR_ ) ; String suffix = STR_ ; synchronized ( principals ) { Iterator < Principal > pI = principals . iterator ( ) ; while ( pI . hasNext ( ) ) { Principal p = pI . next ( ) ; suffix = suffix + ResourcesMgr . getString ( STR_ ) + p . toString ( ) + ResourcesMgr . getString ( STR_ ) ; } } synchronized ( pubCredentials ) { Iterator < Object > pI = pubCredentials . iterator ( ) ; while ( pI . hasNext ( ) ) { Object o = pI . next ( ) ; suffix = suffix + ResourcesMgr . getString ( STR_ ) + o . toString ( ) + ResourcesMgr . getString ( STR_ ) ; } } if ( includePrivateCredentials ) { synchronized ( privCredentials ) { Iterator < Object > pI = privCredentials . iterator ( ) ; while ( pI . hasNext ( ) ) { try { Object o = pI . next ( ) ; suffix += ResourcesMgr . getString ( STR_ ) + o . toString ( ) + ResourcesMgr . getString ( STR_ ) ; } catch ( SecurityException se ) { suffix += ResourcesMgr . getString ( STR_ ) ; break ; } } } } return s + suffix ; }
private void decodeTonesPhase ( int chNum , boolean bandHasTones [ ] ) { WavesData dst [ ] = ctx . channels [ chNum ] . tonesInfo ; for ( int sb = NUM_ ; sb < ctx . wavesInfo . numToneBands ; sb ++ ) { if ( ! bandHasTones [ sb ] ) { continue ; } int wparam = dst [ sb ] . startIndex ; for ( int i = NUM_ ; i < dst [ sb ] . numWavs ; i ++ ) { ctx . wavesInfo . waves [ wparam + i ] . phaseIndex = br . read ( NUM_ ) ; } } }
public int encode ( byte [ ] data , int off , int length , OutputStream out ) throws IOException { for ( int i = off ; i < ( off + length ) ; i ++ ) { int v = data [ i ] & xff ; out . write ( encodingTable [ ( v > > > NUM_ ) ] ) ; out . write ( encodingTable [ v & xf ] ) ; } return length . NUM_ ; }
public void clear ( ) { synchronized ( mLock ) { mGraphics . clear ( ) ; } postInvalidate ( ) ; }
public static String removeAll ( String str , String [ ] patterns ) { for ( String pattern : patterns ) str = str . replace ( pattern , STR_ ) ; return str ; }
public void addSeriesRenderer ( SimpleSeriesRenderer renderer ) { mRenderers . add ( renderer ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
@ Override public boolean isParent ( File folder , File file ) { return folder . equals ( file . getParentFile ( ) ) ; }
@ Override public void print ( char c ) throws IOException { boolean isWS = Character . isWhitespace ( c ) ; if ( isWS ) { if ( isFirstChar ) return ; if ( c == CHAR_RETURN ) return ; if ( sb . length ( ) > NUM_ ) { printBuffer ( ) ; lastChar = ( c == CHAR_NL ) ? CHAR_NL : c ; super . print ( lastChar ) ; return ; } } isFirstChar = BOOL_ ; if ( c == CHAR_GT && sb . length ( ) > NUM_ ) printBuffer ( ) ; if ( isWS || ! addToBuffer ( c ) ) { if ( depthSum == NUM_ ) { if ( isWS ) { if ( lastChar == CHAR_NL ) return ; if ( c != CHAR_NL ) { if ( Character . isWhitespace ( lastChar ) ) return ; } } } lastChar = c ; super . print ( c ) ; } }
public static TokenEndpointAuthMethod fromString ( String type ) { if ( type != null ) { for ( TokenEndpointAuthMethod authMethod : TokenEndpointAuthMethod . values ( ) ) { if ( type . equalsIgnoreCase ( authMethod . type ) ) { return authMethod ; } } } return null ; }
public void put ( E e ) throws InterruptedException { if ( e == null ) throw new NullPointerException ( ) ; int c = - NUM_ ; final ReentrantLock putLock = this . putLock ; final AtomicInteger count = this . count ; putLock . lockInterruptibly ( ) ; try { while ( count . get ( ) >= capacity ) { notFull . await ( ) ; } enqueue ( e ) ; c = count . getAndIncrement ( ) ; if ( c + NUM_ < capacity ) notFull . signal ( ) ; } finally { putLock . unlock ( ) ; } if ( c == NUM_ ) signalNotEmpty ( ) ; }
private boolean compare ( List < String > remoteModules , List < String > expectedModules ) { Collections . sort ( remoteModules ) ; Collections . sort ( expectedModules ) ; return remoteModules . equals ( expectedModules ) ; }
private void encodeSize ( ByteBuffer headerBuffer , int size ) { headerBuffer . put ( ( byte ) ( ( size & x00FF0000 ) > > NUM_ ) ) ; headerBuffer . put ( ( byte ) ( ( size & x0000FF00 ) > > NUM_ ) ) ; headerBuffer . put ( ( byte ) ( size & x000000FF ) ) ; logger . fine ( STR_ + size + STR_ + Integer . toBinaryString ( size ) + STR_ + Integer . toHexString ( size ) ) ; }
protected LinkedList < Diff > diff_bisect ( String text1 , String text2 , long deadline ) { int text1_length = text1 . length ( ) ; int text2_length = text2 . length ( ) ; int max_d = ( text1_length + text2_length + NUM_ ) / NUM_ ; int v_offset = max_d ; int v_length = NUM_ . max_d ; int [ ] v1 = new int [ v_length ] ; int [ ] v2 = new int [ v_length ] ; for ( int x = NUM_ ; x < v_length ; x ++ ) { v1 [ x ] = - NUM_ ; v2 [ x ] = - NUM_ ; } v1 [ v_offset + NUM_ ] = NUM_ ; v2 [ v_offset + NUM_ ] = NUM_ ; int delta = text1_length - text2_length ; boolean front = ( delta % NUM_ != NUM_ ) ; int k1start = NUM_ ; int k1end = NUM_ ; int k2start = NUM_ ; int k2end = NUM_ ; for ( int d = NUM_ ; d < max_d ; d ++ ) { if ( System . currentTimeMillis ( ) > deadline ) { break ; } for ( int k1 = - d + k1start ; k1 <= d - k1end ; k1 += NUM_ ) { int k1_offset = v_offset + k1 ; int x1 ; if ( k1 == - d || ( k1 != d && v1 [ k1_offset - NUM_ ] < v1 [ k1_offset + NUM_ ] ) ) { x1 = v1 [ k1_offset + NUM_ ] ; } else { x1 = v1 [ k1_offset - NUM_ ] + NUM_ ; } int y1 = x1 - k1 ; while ( x1 < text1_length && y1 < text2_length && text1 . charAt ( x1 ) == text2 . charAt ( y1 ) ) { x1 ++ ; y1 ++ ; } v1 [ k1_offset ] = x1 ; if ( x1 > text1_length ) { k1end += NUM_ ; } else if ( y1 > text2_length ) { k1start += NUM_ ; } else if ( front ) { int k2_offset = v_offset + delta - k1 ; if ( k2_offset >= NUM_ && k2_offset < v_length && v2 [ k2_offset ] != - NUM_ ) { int x2 = text1_length - v2 [ k2_offset ] ; if ( x1 >= x2 ) { return diff_bisectSplit ( text1 , text2 , x1 , y1 , deadline ) ; } } } } for ( int k2 = - d + k2start ; k2 <= d - k2end ; k2 += NUM_ ) { int k2_offset = v_offset + k2 ; int x2 ; if ( k2 == - d || ( k2 != d && v2 [ k2_offset - NUM_ ] < v2 [ k2_offset + NUM_ ] ) ) { x2 = v2 [ k2_offset + NUM_ ] ; } else { x2 = v2 [ k2_offset - NUM_ ] + NUM_ ; } int y2 = x2 - k2 ; while ( x2 < text1_length && y2 < text2_length && text1 . charAt ( text1_length - x2 - NUM_ ) == text2 . charAt ( text2_length - y2 - NUM_ ) ) { x2 ++ ; y2 ++ ; } v2 [ k2_offset ] = x2 ; if ( x2 > text1_length ) { k2end += NUM_ ; } else if ( y2 > text2_length ) { k2start += NUM_ ; } else if ( ! front ) { int k1_offset = v_offset + delta - k2 ; if ( k1_offset >= NUM_ && k1_offset < v_length && v1 [ k1_offset ] != - NUM_ ) { int x1 = v1 [ k1_offset ] ; int y1 = v_offset + x1 - k1_offset ; x2 = text1_length - x2 ; if ( x1 >= x2 ) { return diff_bisectSplit ( text1 , text2 , x1 , y1 , deadline ) ; } } } } } LinkedList < Diff > diffs = new LinkedList < Diff > ( ) ; diffs . add ( new Diff ( Operation . DELETE , text1 ) ) ; diffs . add ( new Diff ( Operation . INSERT , text2 ) ) ; return diffs ; }
public boolean thisIsYou ( Object n ) { return id . equals ( n ) ; }
private int syncContactNames ( Context context ) { final ContentResolver contentResolver = context . getContentResolver ( ) ; final Cursor cursor = contentResolver . query ( ContactNotifications . CONTENT_URI , null , null , null , null ) ; if ( cursor == null ) { return NUM_ ; } if ( cursor . getCount ( ) == NUM_ ) { return NUM_ ; } int count = NUM_ ; int updatedCount = NUM_ ; String id ; String contactName ; String contactLookup ; String contactId ; while ( cursor . moveToNext ( ) ) { count ++ ; id = cursor . getString ( cursor . getColumnIndexOrThrow ( ContactNotifications . _ID ) ) ; contactName = cursor . getString ( cursor . getColumnIndexOrThrow ( ContactNotifications . CONTACT_NAME ) ) ; contactId = cursor . getString ( cursor . getColumnIndexOrThrow ( ContactNotifications . CONTACT_ID ) ) ; contactLookup = cursor . getString ( cursor . getColumnIndexOrThrow ( ContactNotifications . CONTACT_LOOKUPKEY ) ) ; ContactIdentification contactInfo = SmsPopupUtils . getPersonNameByLookup ( context , contactLookup , contactId ) ; if ( contactInfo != null ) { boolean runUpdate = BOOL_ ; ContentValues vals = new ContentValues ( ) ; if ( contactName == null || ! contactName . equals ( contactInfo . contactName ) ) { vals . put ( ContactNotifications . CONTACT_NAME , contactInfo . contactName ) ; runUpdate = BOOL_ ; } if ( contactId == null || ! contactId . equals ( contactInfo . contactId ) ) { vals . put ( ContactNotifications . CONTACT_ID , contactInfo . contactId ) ; runUpdate = BOOL_ ; } if ( contactLookup == null || ! contactLookup . equals ( contactInfo . contactLookup ) ) { vals . put ( ContactNotifications . CONTACT_LOOKUPKEY , contactInfo . contactLookup ) ; runUpdate = BOOL_ ; } if ( runUpdate && NUM_ == contentResolver . update ( ContactNotifications . buildContactUri ( id ) , vals , null , null ) ) { updatedCount ++ ; } } } if ( cursor != null ) { cursor . close ( ) ; } if ( BuildConfig . DEBUG ) Log . v ( STR_ + updatedCount + STR_ + count ) ; return updatedCount ; }
@ Override public synchronized void clear ( ) { File [ ] files = mRootDirectory . listFiles ( ) ; if ( files != null ) { for ( File file : files ) { file . delete ( ) ; } } mEntries . clear ( ) ; mTotalSize = NUM_ ; VolleyLog . d ( STR_ ) ; }
@ Override protected void deviceFrameRect ( int x , int y , int width , int height , Color color ) { AffineTransform deviceTransform = getTransform ( ) ; int transformType = deviceTransform . getType ( ) ; boolean usePath = ( ( transformType & ( AffineTransform . TYPE_GENERAL_ROTATION | AffineTransform . TYPE_GENERAL_TRANSFORM ) ) != NUM_ ) ; if ( usePath ) { draw ( new Rectangle2D . Float ( x , y , width , height ) ) ; return ; } Stroke stroke = getStroke ( ) ; if ( stroke instanceof BasicStroke ) { BasicStroke lineStroke = ( BasicStroke ) stroke ; int endCap = lineStroke . getEndCap ( ) ; int lineJoin = lineStroke . getLineJoin ( ) ; if ( ( endCap == BasicStroke . CAP_SQUARE ) && ( lineJoin == BasicStroke . JOIN_MITER ) && ( lineStroke . getMiterLimit ( ) == NUM_ ) ) { float lineWidth = lineStroke . getLineWidth ( ) ; Point2D . Float penSize = new Point2D . Float ( lineWidth , lineWidth ) ; deviceTransform . deltaTransform ( penSize , penSize ) ; float deviceLineWidth = Math . min ( Math . abs ( penSize . x ) , Math . abs ( penSize . y ) ) ; Point2D . Float ul_pos = new Point2D . Float ( x , y ) ; deviceTransform . transform ( ul_pos , ul_pos ) ; Point2D . Float lr_pos = new Point2D . Float ( x + width , y + height ) ; deviceTransform . transform ( lr_pos , lr_pos ) ; float w = ( float ) ( lr_pos . getX ( ) - ul_pos . getX ( ) ) ; float h = ( float ) ( lr_pos . getY ( ) - ul_pos . getY ( ) ) ; WPrinterJob wPrinterJob = ( WPrinterJob ) getPrinterJob ( ) ; if ( wPrinterJob . selectStylePen ( endCap , lineJoin , deviceLineWidth , color ) == BOOL_ ) { wPrinterJob . frameRect ( ( float ) ul_pos . getX ( ) , ( float ) ul_pos . getY ( ) , w , h ) ; } else { double lowerRes = Math . min ( wPrinterJob . getXRes ( ) , wPrinterJob . getYRes ( ) ) ; if ( ( deviceLineWidth / lowerRes ) < MAX_THINLINE_INCHES ) { wPrinterJob . selectPen ( deviceLineWidth , color ) ; wPrinterJob . frameRect ( ( float ) ul_pos . getX ( ) , ( float ) ul_pos . getY ( ) , w , h ) ; } else { draw ( new Rectangle2D . Float ( x , y , width , height ) ) ; } } } else { draw ( new Rectangle2D . Float ( x , y , width , height ) ) ; } } }
public void resetWorkspace ( ) { mBlockFactory . clearPriorBlockReferences ( ) ; mRootBlocks . clear ( ) ; mStats . clear ( ) ; mDeletedBlocks . clear ( ) ; }
private void parseElement ( Element element ) throws SAML2Exception { AssertionFactory assertionFactory = AssertionFactory . getInstance ( ) ; ProtocolFactory protoFactory = ProtocolFactory . getInstance ( ) ; requestId = element . getAttribute ( SAML2Constants . ID ) ; validateID ( requestId ) ; version = element . getAttribute ( SAML2Constants . VERSION ) ; validateVersion ( version ) ; String issueInstantStr = element . getAttribute ( SAML2Constants . ISSUE_INSTANT ) ; validateIssueInstant ( issueInstantStr ) ; destinationURI = element . getAttribute ( SAML2Constants . DESTINATION ) ; consent = element . getAttribute ( SAML2Constants . CONSENT ) ; String notOnOrAfterStr = element . getAttribute ( SAML2Constants . NOTONORAFTER ) ; validateNotOnOrAfterStr ( notOnOrAfterStr ) ; reason = element . getAttribute ( SAML2Constants . REASON ) ; String sessionIndexStr = null ; NodeList nList = element . getChildNodes ( ) ; if ( ( nList != null ) && ( nList . getLength ( ) > NUM_ ) ) { for ( int i = NUM_ ; i < nList . getLength ( ) ; i ++ ) { Node childNode = nList . item ( i ) ; String cName = childNode . getLocalName ( ) ; if ( cName != null ) { if ( cName . equals ( SAML2Constants . ISSUER ) ) { nameID = assertionFactory . createIssuer ( ( Element ) childNode ) ; } else if ( cName . equals ( SAML2Constants . SIGNATURE ) ) { signatureString = XMLUtils . print ( ( Element ) childNode ) ; isSigned = BOOL_ ; } else if ( cName . equals ( SAML2Constants . EXTENSIONS ) ) { extensions = protoFactory . createExtensions ( ( Element ) childNode ) ; } else if ( cName . equals ( SAML2Constants . BASEID ) ) { baseId = assertionFactory . createBaseID ( ( Element ) childNode ) ; } else if ( cName . equals ( SAML2Constants . NAMEID ) ) { nameId = assertionFactory . createNameID ( ( Element ) childNode ) ; } else if ( cName . equals ( SAML2Constants . ENCRYPTEDID ) ) { encryptedId = assertionFactory . createEncryptedID ( ( Element ) childNode ) ; } else if ( cName . equals ( SAML2Constants . SESSION_INDEX ) ) { if ( ( sessionIndexList == null ) || ( sessionIndexList . isEmpty ( ) ) ) { sessionIndexList = new ArrayList ( ) ; } sessionIndexStr = XMLUtils . getElementString ( ( Element ) childNode ) ; sessionIndexList . add ( sessionIndexStr ) ; } } } validateBaseIDorNameIDorEncryptedID ( ) ; if ( ( sessionIndexList != null ) && ( ! sessionIndexList . isEmpty ( ) ) ) { sessionIndexList = Collections . unmodifiableList ( sessionIndexList ) ; } } }
public static BigDecimal paidToDate ( int p_C_Invoice_ID , int p_C_Currency_ID , int p_MultiplierAP , Timestamp DateAcct ) throws SQLException { if ( p_C_Invoice_ID == NUM_ || p_C_Currency_ID == NUM_ ) return null ; BigDecimal MultiplierAP = new BigDecimal ( ( double ) p_MultiplierAP ) ; if ( p_MultiplierAP == NUM_ ) MultiplierAP = Adempiere . ONE ; int C_ConversionType_ID = NUM_ ; BigDecimal paymentAmt = allocatedAmtToDate ( p_C_Invoice_ID , p_C_Currency_ID , C_ConversionType_ID , MultiplierAP , DateAcct ) ; return Currency . round ( paymentAmt , p_C_Currency_ID , null ) ; }
private int [ ] toIntArray ( ) { int length = encoding . length ; int [ ] result = new int [ NUM_ ] ; int which = NUM_ ; int fromPos = NUM_ ; for ( int i = NUM_ ; i < length ; i ++ ) { if ( ( encoding [ i ] & x80 ) == NUM_ ) { if ( i - fromPos + NUM_ > NUM_ ) { BigInteger big = new BigInteger ( pack ( encoding , fromPos , i - fromPos + NUM_ , NUM_ , NUM_ ) ) ; if ( fromPos == NUM_ ) { result [ which ++ ] = NUM_ ; BigInteger second = big . subtract ( BigInteger . valueOf ( NUM_ ) ) ; if ( second . compareTo ( BigInteger . valueOf ( Integer . MAX_VALUE ) ) == NUM_ ) { return null ; } else { result [ which ++ ] = second . intValue ( ) ; } } else { if ( big . compareTo ( BigInteger . valueOf ( Integer . MAX_VALUE ) ) == NUM_ ) { return null ; } else { result [ which ++ ] = big . intValue ( ) ; } } } else { int retval = NUM_ ; for ( int j = fromPos ; j <= i ; j ++ ) { retval <<= NUM_ ; byte tmp = encoding [ j ] ; retval |= ( tmp & x07f ) ; } if ( fromPos == NUM_ ) { if ( retval < NUM_ ) { result [ which ++ ] = retval / NUM_ ; result [ which ++ ] = retval % NUM_ ; } else { result [ which ++ ] = NUM_ ; result [ which ++ ] = retval - NUM_ ; } } else { result [ which ++ ] = retval ; } } fromPos = i + NUM_ ; } if ( which >= result . length ) { result = Arrays . copyOf ( result , which + NUM_ ) ; } } return Arrays . copyOf ( result , which ) ; }
public static List < Window > windows ( InputStream words , TokenizerFactory tokenizerFactory , int windowSize ) { Tokenizer tokenizer = tokenizerFactory . create ( words ) ; List < String > list = new ArrayList < > ( ) ; while ( tokenizer . hasMoreTokens ( ) ) list . add ( tokenizer . nextToken ( ) ) ; if ( list . isEmpty ( ) ) throw new IllegalStateException ( STR_ ) ; return windows ( list , windowSize ) ; }
public static double [ ] pageRank ( MatrixInterface preparedMatrix , int maxIteration ) { double [ ] init = new double [ preparedMatrix . getRowsCount ( ) ] ; for ( int i = NUM_ ; i != init . length ; i ++ ) init [ i ] = NUM_ ; return pageRank ( preparedMatrix , maxIteration , DEFAULT_D , init ) ; }
public boolean hasMIMEType ( String mimeType ) { if ( mimeType == null ) return BOOL_ ; String type = mimeType ; if ( mimeType . indexOf ( STR_ ) > NUM_ ) { type = mimeType . substring ( NUM_ , mimeType . indexOf ( STR_ ) ) ; } for ( String mt : this . mimeTypes ) { if ( mt . equalsIgnoreCase ( mimeType ) ) { return BOOL_ ; } if ( mimeType != type && mt . equalsIgnoreCase ( type ) ) { return BOOL_ ; } } return BOOL_ ; }
private int measureShort ( int measureSpec ) { int result ; int specMode = MeasureSpec . getMode ( measureSpec ) ; int specSize = MeasureSpec . getSize ( measureSpec ) ; if ( specMode == MeasureSpec . EXACTLY ) { result = specSize ; } else { result = ( int ) ( NUM_ . mRadius + getPaddingTop ( ) + getPaddingBottom ( ) + NUM_ ) ; if ( specMode == MeasureSpec . AT_MOST ) { result = Math . min ( result , specSize ) ; } } return result ; }
private void readObject ( java . io . ObjectInputStream s ) throws java . io . IOException , ClassNotFoundException { s . defaultReadObject ( ) ; key = key . clone ( ) ; }
void unexecuteNSDecls ( TransformerImpl transformer ) throws TransformerException { unexecuteNSDecls ( transformer , null ) ; }
public boolean add ( ProtocolMessage pm ) { return protocolMessages . add ( pm ) ; }
public void randomInit ( ) { do { m_bits = new boolean [ m_nNodes . m_nNodes ] ; for ( int i = NUM_ ; i < m_nNodes ; i ++ ) { int iPos ; do { iPos = m_random . nextInt ( m_nNodes . m_nNodes ) ; } while ( isSquare ( iPos ) ) ; m_bits [ iPos ] = BOOL_ ; } } while ( hasCycles ( ) ) ; calcGlobalScore ( ) ; }
public static int safeParseInt ( String s ) { return safeParseInt ( s , - NUM_ ) ; }
protected boolean hasReceiversFor ( DistributedMember endPoint ) { synchronized ( this . receivers ) { for ( Iterator it = receivers . iterator ( ) ; it . hasNext ( ) ; ) { Connection con = ( Connection ) it . next ( ) ; if ( endPoint . equals ( con . getRemoteAddress ( ) ) ) { return BOOL_ ; } } } return BOOL_ ; }
protected void decodeBitmapData ( final GifFrame frame , byte [ ] dstPixels ) { if ( frame != null ) { rawData . position ( frame . bufferFrameStart ) ; } final int nullCode = - NUM_ ; final int npix = ( frame == null ) ? width . height : frame . iw . frame . ih ; int available , clear , code_mask , code_size , end_of_information , in_code , old_code , bits , code , count , i , datum , data_size , first , top , bi , pi ; if ( dstPixels == null || dstPixels . length < npix ) { dstPixels = new byte [ npix ] ; } if ( prefix == null ) { prefix = new short [ MAX_STACK_SIZE ] ; } if ( suffix == null ) { suffix = new byte [ MAX_STACK_SIZE ] ; } if ( pixelStack == null ) { pixelStack = new byte [ MAX_STACK_SIZE + NUM_ ] ; } data_size = read ( ) ; clear = NUM_ << data_size ; end_of_information = clear + NUM_ ; available = clear + NUM_ ; old_code = nullCode ; code_size = data_size + NUM_ ; code_mask = ( NUM_ << code_size ) - NUM_ ; for ( code = NUM_ ; code < clear ; code ++ ) { prefix [ code ] = NUM_ ; suffix [ code ] = ( byte ) code ; } datum = bits = count = first = top = pi = bi = NUM_ ; for ( i = NUM_ ; i < npix ; ) { if ( top == NUM_ ) { if ( bits < code_size ) { if ( count == NUM_ ) { count = readBlock ( ) ; if ( count <= NUM_ ) { break ; } bi = NUM_ ; } datum += ( ( block [ bi ] ) & xff ) << bits ; bits += NUM_ ; bi ++ ; count -- ; continue ; } code = datum & code_mask ; datum >>= code_size ; bits -= code_size ; if ( ( code > available ) || ( code == end_of_information ) ) { break ; } if ( code == clear ) { code_size = data_size + NUM_ ; code_mask = ( NUM_ << code_size ) - NUM_ ; available = clear + NUM_ ; old_code = nullCode ; continue ; } if ( old_code == nullCode ) { pixelStack [ top ++ ] = suffix [ code ] ; old_code = code ; first = code ; continue ; } in_code = code ; if ( code == available ) { pixelStack [ top ++ ] = ( byte ) first ; code = old_code ; } while ( code > clear ) { pixelStack [ top ++ ] = suffix [ code ] ; code = prefix [ code ] ; } first = ( suffix [ code ] ) & xff ; if ( available >= MAX_STACK_SIZE ) { break ; } pixelStack [ top ++ ] = ( byte ) first ; prefix [ available ] = ( short ) old_code ; suffix [ available ] = ( byte ) first ; available ++ ; if ( ( ( available & code_mask ) == NUM_ ) && ( available < MAX_STACK_SIZE ) ) { code_size ++ ; code_mask += available ; } old_code = in_code ; } top -- ; dstPixels [ pi ++ ] = pixelStack [ top ] ; i ++ ; } for ( i = pi ; i < npix ; i ++ ) { dstPixels [ i ] = NUM_ ; } }
public void addRangeRestriction ( String ColumnName , Object Code , Object Code_to , String InfoName , String InfoDisplay , String InfoDisplay_to ) { Restriction r = new Restriction ( ColumnName , Code , Code_to , InfoName , InfoDisplay , InfoDisplay_to , BOOL_ , NUM_ ) ; m_list . add ( r ) ; }
@ SuppressWarnings ( STR_ ) E transfer ( E e , boolean timed , long nanos ) { QNode s = null ; boolean isData = ( e != null ) ; for ( ; ; ) { QNode t = tail ; QNode h = head ; if ( t == null || h == null ) continue ; if ( h == t || t . isData == isData ) { QNode tn = t . next ; if ( t != tail ) continue ; if ( tn != null ) { advanceTail ( t , tn ) ; continue ; } if ( timed && nanos <= NUM_ ) return null ; if ( s == null ) s = new QNode ( e , isData ) ; if ( ! t . casNext ( null , s ) ) continue ; advanceTail ( t , s ) ; Object x = awaitFulfill ( s , e , timed , nanos ) ; if ( x == s ) { clean ( t , s ) ; return null ; } if ( ! s . isOffList ( ) ) { advanceHead ( t , s ) ; if ( x != null ) s . item = s ; s . waiter = null ; } return ( x != null ) ? ( E ) x : e ; } else { QNode m = h . next ; if ( t != tail || m == null || h != head ) continue ; Object x = m . item ; if ( isData == ( x != null ) || x == m || ! m . casItem ( x , e ) ) { advanceHead ( h , m ) ; continue ; } advanceHead ( h , m ) ; LockSupport . unpark ( m . waiter ) ; return ( x != null ) ? ( E ) x : e ; } } }
protected void indexPoints ( InputStream is , long ptr , OutputStream os ) { boolean moreRecords = BOOL_ ; byte rHdr [ ] = new byte [ SHAPE_RECORD_HEADER_LENGTH ] ; byte outBuf [ ] = new byte [ SPATIAL_INDEX_RECORD_LENGTH ] ; int result ; int nRecords = NUM_ ; int recLengthWords , recLengthBytes ; long recOffset ; int shapeType ; int recBufSize = NUM_ ; byte recBuf [ ] = new byte [ recBufSize ] ; double x = NUM_ ; double y = NUM_ ; try { while ( moreRecords ) { result = is . read ( rHdr , NUM_ , SHAPE_RECORD_HEADER_LENGTH ) ; if ( result < NUM_ ) { moreRecords = BOOL_ ; if ( logger . isLoggable ( Level . FINE ) ) { logger . fine ( STR_ + nRecords + STR_ ) ; logger . fine ( STR_ + recBufSize ) ; } } else { nRecords ++ ; recOffset = ptr ; readBEInt ( rHdr , NUM_ ) ; recLengthWords = readBEInt ( rHdr , NUM_ ) ; recLengthBytes = recLengthWords . NUM_ ; if ( recLengthBytes > recBufSize ) { if ( logger . isLoggable ( Level . FINE ) ) { logger . fine ( STR_ + recLengthBytes ) ; } recBufSize = recLengthBytes ; recBuf = new byte [ recBufSize ] ; } result = is . read ( recBuf , NUM_ , recLengthBytes ) ; shapeType = readLEInt ( recBuf , NUM_ ) ; if ( shapeType != SHAPE_TYPE_NULL ) { x = readLEDouble ( recBuf , NUM_ ) ; y = readLEDouble ( recBuf , NUM_ ) ; } ptr += recLengthBytes + NUM_ ; writeBEInt ( outBuf , NUM_ , ( int ) ( recOffset / NUM_ ) ) ; writeBEInt ( outBuf , NUM_ , recLengthWords ) ; writeLEDouble ( outBuf , NUM_ , x ) ; writeLEDouble ( outBuf , NUM_ , y ) ; writeLEDouble ( outBuf , NUM_ , x ) ; writeLEDouble ( outBuf , NUM_ , y ) ; os . write ( outBuf , NUM_ , SPATIAL_INDEX_RECORD_LENGTH ) ; } } } catch ( java . io . IOException e ) { e . printStackTrace ( ) ; } finally { try { is . close ( ) ; } catch ( java . io . IOException e ) { } } }
public static String unsignedToString ( final int value ) { if ( value >= NUM_ ) { return Integer . toString ( value ) ; } else { return Long . toString ( value & x00000000FFFFFFFFL ) ; } }
public static List < File > findAll ( File baseFile , String regex ) { ArrayList < File > found = new ArrayList < File > ( ) ; findAll ( baseFile , regex , found ) ; return found ; }
public void appendCSSDefinition ( StringBuilder buf ) { buf . append ( STR_ ) ; buf . append ( name ) ; buf . append ( STR_ ) ; for ( Pair < String , String > pair : statements ) { buf . append ( pair . getFirst ( ) ) ; buf . append ( STR_ ) ; buf . append ( pair . getSecond ( ) ) ; buf . append ( STR_ ) ; } buf . append ( STR_ ) ; }
@ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case DatatypePackage . CONSTRAINT__TYPE : return type != TYPE_EDEFAULT ; case DatatypePackage . CONSTRAINT__CONSTRAINT_VALUES : return CONSTRAINT_VALUES_EDEFAULT == null ? constraintValues != null : ! CONSTRAINT_VALUES_EDEFAULT . equals ( constraintValues ) ; } return super . eIsSet ( featureID ) ; }
protected Object cloneObject ( Object obj ) { if ( obj == null ) { return null ; } if ( obj instanceof String || obj instanceof Boolean || obj instanceof Byte || obj instanceof Short || obj instanceof Character || obj instanceof Integer || obj instanceof Long || obj instanceof Float || obj instanceof Double ) { return obj ; } if ( obj instanceof byte [ ] ) { byte [ ] body = ( byte [ ] ) obj ; byte [ ] data = new byte [ body . length ] ; System . arraycopy ( body , NUM_ , data , NUM_ , body . length ) ; return data ; } return SerializationHelper . deepClone ( obj ) ; }
public void attach ( ActionObserver observer ) { observer . makeOneTimeUse ( ) ; lock . lock ( ) ; try { onceUsedObservers . add ( observer ) ; } finally { lock . unlock ( ) ; } }
private void signCertificateChain ( ) { List < Certificate > cc = new ArrayList < > ( ) ; cc . add ( signCert ) ; List < Certificate > oc = new ArrayList < > ( certs ) ; for ( int k = NUM_ ; k < oc . size ( ) ; ++ k ) { if ( signCert . equals ( oc . get ( k ) ) ) { oc . remove ( k ) ; -- k ; } } boolean found = BOOL_ ; while ( found ) { X509Certificate v = ( X509Certificate ) cc . get ( cc . size ( ) - NUM_ ) ; found = BOOL_ ; for ( int k = NUM_ ; k < oc . size ( ) ; ++ k ) { X509Certificate issuer = ( X509Certificate ) oc . get ( k ) ; try { v . verify ( issuer . getPublicKey ( ) , provider ) ; found = BOOL_ ; cc . add ( oc . get ( k ) ) ; oc . remove ( k ) ; break ; } catch ( Exception ignored ) { } } } signCerts = cc ; }
public static String meterToString ( OFInstructionMeter inst , Logger log ) { return Long . toString ( inst . getMeterId ( ) ) ; }
public String charset ( ) { return parameter ( HEADER_CONTENT_TYPE , PARAM_CHARSET ) ; }
public Dimension minimumLayoutSize ( Container parent ) { Dimension rd , mbd ; Insets i = getInsets ( ) ; if ( contentPane != null ) { rd = contentPane . getMinimumSize ( ) ; } else { rd = parent . getSize ( ) ; } if ( menuBar != null && menuBar . isVisible ( ) ) { mbd = menuBar . getMinimumSize ( ) ; } else { mbd = new Dimension ( NUM_ , NUM_ ) ; } return new Dimension ( Math . max ( rd . width , mbd . width ) + i . left + i . right , rd . height + mbd . height + i . top + i . bottom ) ; }
@ Override public void add ( int location , E object ) { insertElementAt ( object , location ) ; }
public static boolean checkIfCanUse ( String className ) { if ( MockList . shouldBeMocked ( className ) ) { return BOOL_ ; } for ( String s : classExceptions ) { if ( className . startsWith ( s ) ) { return BOOL_ ; } } return BOOL_ ; }
private static void applyOverrides ( ) { InputStream stream = getContentTypesPropertiesStream ( ) ; if ( stream == null ) { return ; } try { try { Properties overrides = new Properties ( ) ; overrides . load ( stream ) ; for ( Map . Entry < Object , Object > entry : overrides . entrySet ( ) ) { String extension = ( String ) entry . getKey ( ) ; String mimeType = ( String ) entry . getValue ( ) ; add ( mimeType , extension ) ; } } finally { stream . close ( ) ; } } catch ( IOException ignored ) { } }
@ Override public void run ( ) { amIActive = BOOL_ ; String inputHeader = null ; String outputHeader = null ; int row , col ; float progress = NUM_ ; double maxPatchValue = NUM_ ; int x , y ; boolean blnFoundNeighbour ; boolean blnIncludeDiagNeighbour = BOOL_ ; boolean blnTreatZerosAsBackground = BOOL_ ; int i ; if ( args . length <= NUM_ ) { showFeedback ( STR_ ) ; return ; } for ( i = NUM_ ; i < args . length ; i ++ ) { if ( i == NUM_ ) { inputHeader = args [ i ] ; } else if ( i == NUM_ ) { outputHeader = args [ i ] ; } else if ( i == NUM_ ) { blnIncludeDiagNeighbour = Boolean . parseBoolean ( args [ i ] ) ; if ( ! blnIncludeDiagNeighbour ) { dX = new int [ ] { NUM_ , NUM_ , NUM_ , - NUM_ } ; dY = new int [ ] { - NUM_ , NUM_ , NUM_ , NUM_ } ; } } else if ( i == NUM_ ) { blnTreatZerosAsBackground = Boolean . parseBoolean ( args [ i ] ) ; } } if ( ( inputHeader == null ) || ( outputHeader == null ) ) { showFeedback ( STR_ ) ; return ; } try { numScanCells = dY . length ; image = new WhiteboxRaster ( inputHeader , STR_ ) ; int rows = image . getNumberRows ( ) ; int cols = image . getNumberColumns ( ) ; noData = image . getNoDataValue ( ) ; double initialValue = - NUM_ ; output = new WhiteboxRaster ( outputHeader , STR_ , inputHeader , WhiteboxRaster . DataType . FLOAT , initialValue ) ; output . setDataScale ( WhiteboxRaster . DataScale . CATEGORICAL ) ; output . setPreferredPalette ( STR_ ) ; if ( blnTreatZerosAsBackground ) { for ( row = NUM_ ; row < rows ; row ++ ) { for ( col = NUM_ ; col < cols ; col ++ ) { if ( image . getValue ( row , col ) == NUM_ ) { output . setValue ( row , col , NUM_ ) ; } } if ( cancelOp ) { cancelOperation ( ) ; return ; } progress = ( float ) ( NUM_ . row / ( rows - NUM_ ) ) ; updateProgress ( ( int ) progress ) ; } if ( output . getValue ( NUM_ , NUM_ ) == - NUM_ ) { output . setValue ( NUM_ , NUM_ , NUM_ ) ; } } else { output . setValue ( NUM_ , NUM_ , NUM_ ) ; } double patchValue = NUM_ ; double neighbourPatchValue = NUM_ ; double newPatchValue = NUM_ ; double imageValue = NUM_ ; int loopNum = NUM_ ; updateProgress ( STR_ + loopNum + STR_ , NUM_ ) ; for ( row = NUM_ ; row < rows ; row ++ ) { for ( col = NUM_ ; col < cols ; col ++ ) { imageValue = image . getValue ( row , col ) ; if ( imageValue != noData ) { patchValue = output . getValue ( row , col ) ; if ( patchValue == initialValue ) { blnFoundNeighbour = BOOL_ ; for ( i = NUM_ ; i < numScanCells ; i ++ ) { x = col + dX [ i ] ; y = row + dY [ i ] ; neighbourPatchValue = output . getValue ( y , x ) ; if ( neighbourPatchValue != initialValue && image . getValue ( y , x ) == imageValue ) { output . setValue ( row , col , neighbourPatchValue ) ; newPatchValue = neighbourPatchValue ; blnFoundNeighbour = BOOL_ ; break ; } } if ( ! blnFoundNeighbour ) { maxPatchValue ++ ; newPatchValue = maxPatchValue ; output . setValue ( row , col , newPatchValue ) ; } depth = NUM_ ; ScanConnectedCells ( row , col , imageValue , initialValue , newPatchValue ) ; } } else { output . setValue ( row , col , noData ) ; } } if ( cancelOp ) { cancelOperation ( ) ; return ; } progress = ( float ) ( NUM_ . row / ( rows - NUM_ ) ) ; updateProgress ( ( int ) progress ) ; } boolean somethingDone ; double [ ] reclass = new double [ ( int ) maxPatchValue + NUM_ ] ; do { loopNum ++ ; updateProgress ( STR_ + loopNum + STR_ , NUM_ ) ; somethingDone = BOOL_ ; for ( row = NUM_ ; row < rows ; row ++ ) { for ( col = NUM_ ; col < cols ; col ++ ) { imageValue = image . getValue ( row , col ) ; if ( imageValue != noData ) { patchValue = output . getValue ( row , col ) ; for ( i = NUM_ ; i < numScanCells ; i ++ ) { x = col + dX [ i ] ; y = row + dY [ i ] ; neighbourPatchValue = output . getValue ( y , x ) ; if ( neighbourPatchValue != patchValue && image . getValue ( y , x ) == imageValue ) { somethingDone = BOOL_ ; if ( patchValue < neighbourPatchValue ) { reclass [ ( int ) neighbourPatchValue ] = - NUM_ ; output . setValue ( y , x , patchValue ) ; ScanConnectedCells ( y , x , imageValue , neighbourPatchValue , patchValue ) ; } else { reclass [ ( int ) patchValue ] = - NUM_ ; output . setValue ( row , col , neighbourPatchValue ) ; ScanConnectedCells ( row , col , imageValue , patchValue , neighbourPatchValue ) ; patchValue = neighbourPatchValue ; } } } } } if ( cancelOp ) { cancelOperation ( ) ; return ; } progress = ( float ) ( NUM_ . row / ( rows - NUM_ ) ) ; updateProgress ( ( int ) progress ) ; } } while ( somethingDone ) ; i = NUM_ ; for ( int a = NUM_ ; a < maxPatchValue + NUM_ ; a ++ ) { if ( reclass [ a ] != - NUM_ ) { reclass [ a ] = i ; i ++ ; } } loopNum ++ ; updateProgress ( STR_ + loopNum + STR_ , NUM_ ) ; for ( row = NUM_ ; row < rows ; row ++ ) { for ( col = NUM_ ; col < cols ; col ++ ) { patchValue = output . getValue ( row , col ) ; if ( patchValue != noData ) { output . setValue ( row , col , reclass [ ( int ) patchValue ] ) ; } } if ( cancelOp ) { cancelOperation ( ) ; return ; } progress = ( float ) ( NUM_ . row / ( rows - NUM_ ) ) ; updateProgress ( ( int ) progress ) ; } output . addMetadataEntry ( STR_ + getDescriptiveName ( ) + STR_ ) ; output . addMetadataEntry ( STR_ + new Date ( ) ) ; image . close ( ) ; output . close ( ) ; returnData ( outputHeader ) ; } catch ( OutOfMemoryError oe ) { myHost . showFeedback ( STR_ ) ; } catch ( Exception e ) { myHost . showFeedback ( STR_ ) ; myHost . logException ( STR_ + getDescriptiveName ( ) , e ) ; } finally { updateProgress ( STR_ , NUM_ ) ; amIActive = BOOL_ ; myHost . pluginComplete ( ) ; } }
public static int readAll ( InputStream i , byte b [ ] ) throws IOException { int len = b . length ; int n = NUM_ ; while ( n < len ) { int count = i . read ( b , n , len - n ) ; if ( count < NUM_ ) { return n ; } n += count ; } return n ; }
public void switchToSimple ( Experiment exp ) { if ( exp == null ) { exp = m_advancedPanel . getExperiment ( ) ; } if ( exp != null && ! m_simplePanel . setExperiment ( exp ) ) { m_AdvancedSetupRBut . setSelected ( BOOL_ ) ; switchToAdvanced ( exp ) ; } else { remove ( m_advancedPanel ) ; m_advancedPanel . removeNotesFrame ( ) ; add ( m_simplePanel , BorderLayout . CENTER ) ; validate ( ) ; repaint ( ) ; } }
public static CacheSpan createCacheEntry ( File file ) { Matcher matcher = CACHE_FILE_PATTERN_V2 . matcher ( file . getName ( ) ) ; if ( ! matcher . matches ( ) ) { return null ; } String key = Util . unescapeFileName ( matcher . group ( NUM_ ) ) ; return key == null ? null : createCacheEntry ( key , Long . parseLong ( matcher . group ( NUM_ ) ) , Long . parseLong ( matcher . group ( NUM_ ) ) , file ) ; }
public boolean isComponentPartOfCurrentMenu ( Component c ) { if ( selection . size ( ) > NUM_ ) { MenuElement me = selection . elementAt ( NUM_ ) ; return isComponentPartOfCurrentMenu ( me , c ) ; } else return BOOL_ ; }
public static int hsba ( float h , float s , float b , float a ) { return setAlpha ( Color . HSBtoRGB ( h , s , b ) , ( int ) ( a . NUM_ + NUM_ ) & xFF ) ; }
LambdaFormBuffer replaceFunctions ( NamedFunction [ ] oldFns , NamedFunction [ ] newFns , Object ... forArguments ) { assert ( inTrans ( ) ) ; if ( oldFns . length == NUM_ ) return this ; for ( int i = arity ; i < length ; i ++ ) { Name n = names [ i ] ; int nfi = indexOf ( n . function , oldFns ) ; if ( nfi >= NUM_ && Arrays . equals ( n . arguments , forArguments ) ) { changeName ( i , new Name ( newFns [ nfi ] , n . arguments ) ) ; } } return this ; }
@ Override public ClientSocket openIfLive ( ) { if ( _state . isClosed ( ) ) { return null ; } ClientSocket stream = openRecycle ( ) ; if ( stream != null ) return stream ; long now = CurrentTime . currentTime ( ) ; if ( isFailed ( now ) ) return null ; else if ( _state == State . FAIL && _startingCount . get ( ) > NUM_ ) { return null ; } return connect ( ) ; }
public void commit ( ) { info ( STR_ + solrUrl + STR_ ) ; doGet ( appendParam ( solrUrl . toString ( ) , STR_ ) ) ; }
public abstract void filesDropped ( java . io . File [ ] files ) ;
protected void waitForThreadToEnterWaitState ( Thread thread , long timeoutMillis ) { long startTime = NUM_ ; for ( ; ; ) { Thread . State s = thread . getState ( ) ; if ( s == Thread . State . BLOCKED || s == Thread . State . WAITING || s == Thread . State . TIMED_WAITING ) return ; else if ( s == Thread . State . TERMINATED ) fail ( STR_ ) ; else if ( startTime == NUM_ ) startTime = System . nanoTime ( ) ; else if ( millisElapsedSince ( startTime ) > timeoutMillis ) { threadAssertTrue ( thread . isAlive ( ) ) ; return ; } Thread . yield ( ) ; } }
public void forceRewriteExif ( String filename , Collection < ExifTag > tags ) throws FileNotFoundException , IOException { if ( ! rewriteExif ( filename , tags ) ) { ExifData tempData = mData ; mData = new ExifData ( DEFAULT_BYTE_ORDER ) ; FileInputStream is = null ; ByteArrayOutputStream bytes = null ; try { is = new FileInputStream ( filename ) ; bytes = new ByteArrayOutputStream ( ) ; doExifStreamIO ( is , bytes ) ; byte [ ] imageBytes = bytes . toByteArray ( ) ; readExif ( imageBytes ) ; setTags ( tags ) ; writeExif ( imageBytes , filename ) ; } catch ( IOException e ) { closeSilently ( is ) ; throw e ; } finally { is . close ( ) ; mData = tempData ; } } }
public static LatLng translatePoint ( LatLng point , double distance , double bearing ) { distance = distance / NUM_ ; double lat = Math . toRadians ( point . latitude ) ; double lng = Math . toRadians ( point . longitude ) ; bearing = Math . toRadians ( bearing ) ; double Lat2 = Math . asin ( ( Math . sin ( lat ) . Math . cos ( distance / EARTH ) ) + ( Math . cos ( lat ) . Math . sin ( distance / EARTH ) . Math . cos ( bearing ) ) ) ; double Long2 = lng + Math . atan2 ( Math . sin ( bearing ) . Math . sin ( distance / EARTH ) . Math . cos ( lat ) , Math . cos ( distance / EARTH ) - ( Math . sin ( lat ) . Math . sin ( Lat2 ) ) ) ; Lat2 = Math . toDegrees ( Lat2 ) ; Long2 = Math . toDegrees ( Long2 ) ; return new LatLng ( Lat2 , Long2 ) ; }
public boolean init ( ) { log . config ( STR_ ) ; MClient client = MClient . get ( Env . getCtx ( ) ) ; String ASPFilter = STR_ ; if ( client . isUseASP ( ) ) ASPFilter = STR_ + STR_ + STR_ + STR_ + STR_ + client . getAD_Client_ID ( ) + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + client . getAD_Client_ID ( ) + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + client . getAD_Client_ID ( ) + STR_ + STR_ + STR_ + STR_ + STR_ ; String sql = null ; if ( Env . isBaseLanguage ( Env . getCtx ( ) , STR_ ) ) sql = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + ASPFilter + STR_ ; else sql = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + Env . getAD_Language ( Env . getCtx ( ) ) + STR_ + STR_ + ASPFilter + STR_ ; boolean hasFields = BOOL_ ; Rows rows = new Rows ( ) ; try { PreparedStatement pstmt = DB . prepareStatement ( sql , null ) ; pstmt . setInt ( NUM_ , m_processInfo . getAD_Process_ID ( ) ) ; ResultSet rs = pstmt . executeQuery ( ) ; int field = NUM_ ; Row row = null ; while ( rs . next ( ) ) { hasFields = BOOL_ ; field ++ ; if ( field % NUM_ == NUM_ && mode == BROWSER_MODE ) { row = createField ( rs , rows , row ) ; } else { row = createField ( rs , rows , null ) ; } } rs . close ( ) ; pstmt . close ( ) ; } catch ( SQLException e ) { log . log ( Level . SEVERE , sql , e ) ; } if ( m_mFields . size ( ) != m_mFields2 . size ( ) || m_mFields . size ( ) != m_wEditors . size ( ) || m_mFields2 . size ( ) != m_wEditors2 . size ( ) ) log . log ( Level . SEVERE , STR_ ) ; if ( hasFields ) { centerPanel . appendChild ( rows ) ; dynamicDisplay ( ) ; } else dispose ( ) ; return hasFields ; }
public static String detectPropertiesPath ( ) { String override = System . getProperty ( STR_ ) ; if ( override != null ) { return override ; } String jarPath = detectJarPath ( ) ; String propFile = Constants . PROPS_FILE + STR_ ; return fixWhitespaces ( getParentDirectory ( jarPath ) + File . separator + propFile ) ; }
public void acceptPackage ( char [ ] packageName ) { }
public void resume ( ) { mPaused = BOOL_ ; mLastFrameTime = System . currentTimeMillis ( ) ; invalidate ( ) ; }
public GaussianDensityFunction ( Double mean , Double variance ) { this . mean = new double [ ] { mean } ; this . variance = new double [ ] { variance } ; stdDev = new double [ ] { Math . sqrt ( variance ) } ; if ( variance < NUM_ ) { log . warning ( STR_ + variance ) ; } }
int encryptFinal ( byte [ ] in , int inOfs , int len , byte [ ] out , int outOfs ) throws IllegalBlockSizeException , ShortBufferException { if ( out . length - outOfs < ( len + tagLenBytes ) ) { throw new ShortBufferException ( STR_ ) ; } processAAD ( ) ; if ( len > NUM_ ) { doLastBlock ( in , inOfs , len , out , outOfs , BOOL_ ) ; } byte [ ] lengthBlock = getLengthBlock ( sizeOfAAD . NUM_ , processed . NUM_ ) ; ghashAllToS . update ( lengthBlock ) ; byte [ ] s = ghashAllToS . digest ( ) ; byte [ ] sOut = new byte [ s . length ] ; GCTR gctrForSToTag = new GCTR ( embeddedCipher , this . preCounterBlock ) ; gctrForSToTag . doFinal ( s , NUM_ , s . length , sOut , NUM_ ) ; System . arraycopy ( sOut , NUM_ , out , ( outOfs + len ) , tagLenBytes ) ; return ( len + tagLenBytes ) ; }
private float interpolate ( ) { long currTime = System . currentTimeMillis ( ) ; float elapsed = ( currTime - startTime ) / ZOOM_TIME ; elapsed = Math . min ( NUM_ , elapsed ) ; return interpolator . getInterpolation ( elapsed ) ; }
public static String componentToImageColName ( String component ) { if ( component . equals ( MixnMatchColumns . KEY_HOMESCREEN ) ) { return ThemesColumns . HOMESCREEN_URI ; } else if ( component . equals ( MixnMatchColumns . KEY_LOCKSCREEN ) ) { return ThemesColumns . LOCKSCREEN_URI ; } else if ( component . equals ( MixnMatchColumns . KEY_BOOT_ANIM ) ) { return ThemesColumns . BOOT_ANIM_URI ; } else if ( component . equals ( MixnMatchColumns . KEY_FONT ) ) { return ThemesColumns . FONT_URI ; } else if ( component . equals ( MixnMatchColumns . KEY_ICONS ) ) { return ThemesColumns . ICON_URI ; } else if ( component . equals ( MixnMatchColumns . KEY_STATUS_BAR ) ) { return ThemesColumns . STATUSBAR_URI ; } else if ( component . equals ( MixnMatchColumns . KEY_NOTIFICATIONS ) ) { throw new IllegalArgumentException ( STR_ ) ; } else if ( component . equals ( MixnMatchColumns . KEY_RINGTONE ) ) { throw new IllegalArgumentException ( STR_ ) ; } else if ( component . equals ( MixnMatchColumns . KEY_OVERLAYS ) ) { return ThemesColumns . OVERLAYS_URI ; } else if ( component . equals ( MixnMatchColumns . KEY_ALARM ) ) { throw new IllegalArgumentException ( STR_ ) ; } else if ( component . equals ( MixnMatchColumns . KEY_NAVIGATION_BAR ) ) { throw new IllegalArgumentException ( STR_ ) ; } else if ( component . equals ( MixnMatchColumns . KEY_LIVE_LOCK_SCREEN ) ) { throw new IllegalArgumentException ( STR_ ) ; } return null ; }
public boolean isAbstract ( ) { return Modifier . isAbstract ( _method . getModifiers ( ) ) ; }
public void nodeClicked ( RequestInvocationEvent event , int nodeID ) { boolean forwardTo = BOOL_ ; String strNodeId = Integer . toString ( nodeID ) ; if ( strNodeId . length ( ) > NUM_ ) { String prefix = strNodeId . substring ( NUM_ , NUM_ ) ; if ( prefix . equals ( AMAdminConstants . TAB_AGENT_PREFIX ) ) { setPageSessionAttribute ( getTrackingTabIDName ( ) , Integer . toString ( nodeID ) ) ; AMViewConfig amconfig = AMViewConfig . getInstance ( ) ; List list = amconfig . getSupportedAgentTypes ( getModel ( ) ) ; strNodeId = strNodeId . substring ( NUM_ ) ; int idx = Integer . parseInt ( strNodeId ) ; if ( idx < list . size ( ) ) { setPageSessionAttribute ( PG_SESSION_AGENT_TYPE , ( String ) list . get ( idx ) ) ; AMPostViewBean vb = ( AMPostViewBean ) getViewBean ( AMPostViewBean . class ) ; passPgSessionMap ( vb ) ; vb . setTargetViewBeanURL ( STR_ ) ; vb . forwardTo ( getRequestContext ( ) ) ; forwardTo = BOOL_ ; } } } if ( ! forwardTo ) { try { AMViewBeanBase vb = getTabNodeAssociatedViewBean ( STR_ , nodeID ) ; String tmp = ( String ) getPageSessionAttribute ( AMAdminConstants . PREVIOUS_REALM ) ; vb . setPageSessionAttribute ( AMAdminConstants . PREVIOUS_REALM , tmp ) ; tmp = ( String ) getPageSessionAttribute ( AMAdminConstants . CURRENT_REALM ) ; vb . setPageSessionAttribute ( AMAdminConstants . CURRENT_REALM , tmp ) ; tmp = ( String ) getPageSessionAttribute ( AMAdminConstants . PREVIOUS_TAB_ID ) ; vb . setPageSessionAttribute ( AMAdminConstants . PREVIOUS_TAB_ID , tmp ) ; unlockPageTrailForSwapping ( ) ; passPgSessionMap ( vb ) ; vb . forwardTo ( getRequestContext ( ) ) ; } catch ( AMConsoleException e ) { debug . error ( STR_ , e ) ; forwardTo ( ) ; } } }
private static void parseCopyFields ( ParseContext context , FieldMapper fieldMapper , List < String > copyToFields ) throws IOException { if ( ! context . isWithinCopyTo ( ) && copyToFields . isEmpty ( ) == BOOL_ ) { context = context . createCopyToContext ( ) ; for ( String field : copyToFields ) { ParseContext . Document targetDoc = null ; for ( ParseContext . Document doc = context . doc ( ) ; doc != null ; doc = doc . getParent ( ) ) { if ( field . startsWith ( doc . getPrefix ( ) ) ) { targetDoc = doc ; break ; } } assert targetDoc != null ; final ParseContext copyToContext ; if ( targetDoc == context . doc ( ) ) { copyToContext = context ; } else { copyToContext = context . switchDoc ( targetDoc ) ; } parseCopy ( field , copyToContext ) ; } } }
protected File createObbFile ( String name , int rawResId ) { File outFile = null ; try { final File filesDir = mContext . getFilesDir ( ) ; outFile = new File ( filesDir , name ) ; copyRawToFile ( rawResId , outFile ) ; } catch ( NotFoundException e ) { if ( outFile != null ) { outFile . delete ( ) ; } } return outFile ; }
public PlaySoundEntity ( String sound , int radius , int volume ) { this . sounds = sound . split ( STR_ ) ; this . radius = radius ; this . volume = volume ; }
public Repository ( String domain ) { this ( domain , BOOL_ ) ; }
private void updateView ( int viewPosition ) { notifyItemChanged ( viewPosition ) ; }
public static String optimize ( String ... args ) { return simpleTag ( STR_ , args ) ; }
protected boolean isValidServer ( final String server ) { boolean isValid = checkServerPrefixes ( server ) ; if ( isValid ) { if ( server . startsWith ( STR_ ) ) { isValid = canConnect ( server ) ; } else if ( server . startsWith ( STR_ ) ) { isValid = isDirectory ( server ) ; } } return isValid ; }
public ConcurrentHashMap ( Map < ? extends K , ? extends V > m ) { this ( Math . max ( ( int ) ( m . size ( ) / DEFAULT_LOAD_FACTOR ) + NUM_ , DEFAULT_INITIAL_CAPACITY ) , DEFAULT_LOAD_FACTOR , DEFAULT_CONCURRENCY_LEVEL ) ; putAll ( m ) ; }
public MapMaker expiration ( long duration , TimeUnit unit ) { if ( expirationNanos != NUM_ ) { throw new IllegalStateException ( STR_ + expirationNanos + STR_ ) ; } if ( duration <= NUM_ ) { throw new IllegalArgumentException ( STR_ + duration ) ; } this . expirationNanos = unit . toNanos ( duration ) ; useCustomMap = BOOL_ ; return this ; }
void initFromNode ( final Node fromNode , final double startTime , final PseudoRemovePriorityQueue < Node > pendingNodes ) { DijkstraNodeData data = getData ( fromNode ) ; visitNode ( fromNode , data , pendingNodes , startTime , NUM_ , null ) ; }
public Collection < HTMLToken > tokenizeHTML ( ) { List < HTMLToken > tokens = new ArrayList < HTMLToken > ( ) ; String nestedTags = nestedTagsRegex ( NUM_ ) ; Pattern p = Pattern . compile ( STR_ + STR_ + STR_ + STR_ + STR_ + nestedTags + STR_ , Pattern . CASE_INSENSITIVE ) ; Matcher m = p . matcher ( text ) ; int lastPos = NUM_ ; while ( m . find ( ) ) { if ( lastPos < m . start ( ) ) { tokens . add ( HTMLToken . text ( text . substring ( lastPos , m . start ( ) ) ) ) ; } tokens . add ( HTMLToken . tag ( text . substring ( m . start ( ) , m . end ( ) ) ) ) ; lastPos = m . end ( ) ; } if ( lastPos < text . length ( ) ) { tokens . add ( HTMLToken . text ( text . substring ( lastPos , text . length ( ) ) ) ) ; } return tokens ; }
public int decryptBlock ( byte [ ] in , int inOff , byte [ ] out , int outOff ) throws DataLengthException , IllegalStateException { if ( ( inOff + blockSize ) > in . length ) { throw new DataLengthException ( STR_ ) ; } if ( ( outOff + blockSize ) > out . length ) { throw new DataLengthException ( STR_ ) ; } cipher . processBlock ( cfbV , NUM_ , cfbOutV , NUM_ ) ; System . arraycopy ( cfbV , blockSize , cfbV , NUM_ , cfbV . length - blockSize ) ; System . arraycopy ( in , inOff , cfbV , cfbV . length - blockSize , blockSize ) ; for ( int i = NUM_ ; i < blockSize ; i ++ ) { out [ outOff + i ] = ( byte ) ( cfbOutV [ i ] ^ in [ inOff + i ] ) ; } return blockSize ; }
private String computeMd5Hash ( String buffer ) { MessageDigest md ; try { md = MessageDigest . getInstance ( STR_ ) ; return bytesToHex ( md . digest ( buffer . getBytes ( STR_ ) ) ) ; } catch ( NoSuchAlgorithmException ignore ) { } catch ( UnsupportedEncodingException e ) { } return STR_ ; }
public static void checkArgument ( boolean expression , @ Nullable Object errorMessage ) { if ( ! expression ) { throw new IllegalArgumentException ( String . valueOf ( errorMessage ) ) ; } }
public void run ( ) throws IOException , InterruptedException { for ( int i = NUM_ ; i < connCnt ; i ++ ) exec . submit ( new ClientThread ( ) ) ; Thread . sleep ( NUM_ . NUM_ . NUM_ ) ; exec . shutdownNow ( ) ; }
public static String pluralize ( String word ) { if ( word == null ) { throw new IllegalArgumentException ( ) ; } final String lowerCaseWord = word . toLowerCase ( ) ; if ( endsWithAny ( lowerCaseWord , STR_ , STR_ , STR_ ) ) { return word + STR_ ; } if ( lowerCaseWord . endsWith ( STR_ ) && ! lowerCaseWord . endsWith ( STR_ ) || endsWithAny ( lowerCaseWord , STR_ , STR_ , STR_ ) ) { return word . substring ( NUM_ , word . length ( ) - NUM_ ) + STR_ ; } else { return word + STR_ ; } }
protected void onNetworkTypeChange ( NetworkInfo oldNetwork , NetworkInfo newNetwork ) throws RouterException { log . info ( String . format ( STR_ , oldNetwork == null ? STR_ : oldNetwork . getTypeName ( ) , newNetwork == null ? STR_ : newNetwork . getTypeName ( ) ) ) ; if ( disable ( ) ) { log . info ( String . format ( STR_ , oldNetwork == null ? STR_ : oldNetwork . getTypeName ( ) ) ) ; } networkInfo = newNetwork ; if ( enable ( ) ) { log . info ( String . format ( STR_ , newNetwork == null ? STR_ : newNetwork . getTypeName ( ) ) ) ; } }
private LinkedHashMap < Term , Integer > repeatingTerms ( ) { LinkedHashMap < Term , Integer > tord = new LinkedHashMap < > ( ) ; HashMap < Term , Integer > tcnt = new HashMap < > ( ) ; for ( PhrasePositions pp : phrasePositions ) { for ( Term t : pp . terms ) { Integer cnt0 = tcnt . get ( t ) ; Integer cnt = cnt0 == null ? new Integer ( NUM_ ) : new Integer ( NUM_ + cnt0 . intValue ( ) ) ; tcnt . put ( t , cnt ) ; if ( cnt == NUM_ ) { tord . put ( t , tord . size ( ) ) ; } } } return tord ; }
public List < InetAddress > discoverHosts ( int udpPort , int timeoutMillis ) { List < InetAddress > hosts = new ArrayList < InetAddress > ( ) ; DatagramSocket socket = null ; try { socket = new DatagramSocket ( ) ; broadcast ( udpPort , socket ) ; socket . setSoTimeout ( timeoutMillis ) ; while ( BOOL_ ) { DatagramPacket packet = new DatagramPacket ( new byte [ NUM_ ] , NUM_ ) ; try { socket . receive ( packet ) ; } catch ( SocketTimeoutException ex ) { if ( INFO ) info ( STR_ , STR_ ) ; return hosts ; } if ( INFO ) info ( STR_ , STR_ + packet . getAddress ( ) ) ; hosts . add ( packet . getAddress ( ) ) ; } } catch ( IOException ex ) { if ( ERROR ) error ( STR_ , STR_ , ex ) ; return hosts ; } finally { if ( socket != null ) socket . close ( ) ; } }
protected void reloadClusterConfiguration ( ) { synchronized ( this . cluster ) { loadClusterConfiguration ( ) ; } }
public double expectedUtility ( NondominatedPopulation population ) { double sum = NUM_ ; for ( int i = NUM_ ; i < weights . length ; i ++ ) { double max = Double . NEGATIVE_INFINITY ; for ( Solution solution : population ) { max = Math . max ( max , utilityFunction . computeUtility ( solution , weights [ i ] ) ) ; } sum += max ; } return sum / weights . length ; }
public void count ( HashMap < String , TreeMap < String , Integer > > table , String suffix , String tag ) { TreeMap < String , Integer > counts = table . get ( suffix ) ; if ( counts == null ) { counts = new TreeMap < String , Integer > ( ) ; table . put ( suffix , counts ) ; } Integer count = counts . get ( tag ) ; if ( count == null ) count = NUM_ ; counts . put ( tag , count + NUM_ ) ; }
public void addInputMode ( String mode , String [ ] [ ] inputChars ) { modesMap . put ( mode , inputChars ) ; }
public static void sleep ( int msec ) throws InterruptedException { Thread . sleep ( msec ) ; }
public static java . util . Date toDate ( String monthStr , String dayStr , String yearStr , String hourStr , String minuteStr , String secondStr ) { int month , day , year , hour , minute , second ; try { month = Integer . parseInt ( monthStr ) ; day = Integer . parseInt ( dayStr ) ; year = Integer . parseInt ( yearStr ) ; hour = Integer . parseInt ( hourStr ) ; minute = Integer . parseInt ( minuteStr ) ; second = Integer . parseInt ( secondStr ) ; } catch ( Exception e ) { return null ; } return toDate ( month , day , year , hour , minute , second ) ; }
public void propertyChange ( PropertyChangeEvent pce ) { if ( pce . getPropertyName ( ) == OMDrawingTool . LoadersProperty ) { Object obj = pce . getNewValue ( ) ; if ( obj instanceof Vector ) { Vector < EditToolLoader > loaders = ( Vector < EditToolLoader > ) obj ; setLoaders ( loaders . iterator ( ) ) ; resetGUI ( ) ; } } }
public void removeAppOffer ( Offer offer ) { int indexToRemove = getIndex ( offer ) ; if ( indexToRemove != - NUM_ ) { appOffers . remove ( indexToRemove ) ; notifyDataSetChanged ( ) ; } }
public Data transform ( Data data , XMLCryptoContext xc ) throws TransformException { return spi . transform ( data , xc ) ; }
public static int compare ( Comparable c1 , Comparable c2 , boolean nullGreater ) { if ( c1 == c2 ) { return NUM_ ; } else if ( c1 == null ) { return ( nullGreater ? NUM_ : - NUM_ ) ; } else if ( c2 == null ) { return ( nullGreater ? - NUM_ : NUM_ ) ; } return c1 . compareTo ( c2 ) ; }
OathDeviceSettings createDeviceProfile ( int minSharedSecretLength ) { Reject . ifFalse ( minSharedSecretLength >= NUM_ , STR_ ) ; int sharedSecretByteLength = Math . max ( MIN_SHARED_SECRET_BYTE_LENGTH , ( int ) Math . ceil ( minSharedSecretLength / NUM_ ) ) ; byte [ ] secretBytes = new byte [ sharedSecretByteLength ] ; secureRandom . nextBytes ( secretBytes ) ; String sharedSecret = DatatypeConverter . printHexBinary ( secretBytes ) ; return new OathDeviceSettings ( sharedSecret , DEVICE_NAME , INITIAL_LAST_LOGIN_TIME , INITIAL_COUNTER_VALUE ) ; }
public final void deleteSelectedObjects ( ) { Component [ ] components = getComponents ( ) ; List < DisplayNode > graphNodes = new ArrayList < > ( ) ; List < IDisplayEdge > graphEdges = new ArrayList < > ( ) ; for ( Component comp : components ) { if ( comp instanceof DisplayNode ) { if ( ! isDeleteVariablesAllowed ( ) ) { continue ; } DisplayNode node = ( DisplayNode ) comp ; if ( node . isSelected ( ) ) { graphNodes . add ( node ) ; } } else if ( comp instanceof IDisplayEdge ) { IDisplayEdge edge = ( IDisplayEdge ) comp ; if ( edge . isSelected ( ) ) { graphEdges . add ( edge ) ; } } } for ( DisplayNode graphNode : graphNodes ) { removeNode ( graphNode ) ; } for ( IDisplayEdge displayEdge : graphEdges ) { try { removeEdge ( displayEdge ) ; resetEdgeOffsets ( displayEdge ) ; } catch ( Exception e ) { if ( isNodeEdgeErrorsReported ( ) ) { JOptionPane . showMessageDialog ( JOptionUtils . centeringComp ( ) , e . getMessage ( ) ) ; } } } }
protected final void initStatistics ( String who , String [ ] headerLines ) throws AdeException { setStatsFilePath ( ) ; if ( statsFilePath == null ) { throw new AdeInternalException ( STR_ ) ; } appendStatString ( SPACER ) ; appendStatString ( String . format ( STR_ , currentTimeStamp ( ) , who ) ) ; appendStatString ( SPACER ) ; for ( int i = NUM_ ; i < headerLines . length ; i ++ ) { appendStatString ( headerLines [ i ] ) ; } appendStatString ( SPACER ) ; }
public static Map < String , Object > dayEndCapacityAvailable ( GenericValue techDataCalendarWeek , int dayEnd ) { Map < String , Object > result = FastMap . newInstance ( ) ; int moveDay = NUM_ ; Double capacity = null ; Time startTime = null ; while ( capacity == null || capacity . doubleValue ( ) == NUM_ ) { switch ( dayEnd ) { case Calendar . MONDAY : capacity = techDataCalendarWeek . getDouble ( STR_ ) ; startTime = techDataCalendarWeek . getTime ( STR_ ) ; break ; case Calendar . TUESDAY : capacity = techDataCalendarWeek . getDouble ( STR_ ) ; startTime = techDataCalendarWeek . getTime ( STR_ ) ; break ; case Calendar . WEDNESDAY : capacity = techDataCalendarWeek . getDouble ( STR_ ) ; startTime = techDataCalendarWeek . getTime ( STR_ ) ; break ; case Calendar . THURSDAY : capacity = techDataCalendarWeek . getDouble ( STR_ ) ; startTime = techDataCalendarWeek . getTime ( STR_ ) ; break ; case Calendar . FRIDAY : capacity = techDataCalendarWeek . getDouble ( STR_ ) ; startTime = techDataCalendarWeek . getTime ( STR_ ) ; break ; case Calendar . SATURDAY : capacity = techDataCalendarWeek . getDouble ( STR_ ) ; startTime = techDataCalendarWeek . getTime ( STR_ ) ; break ; case Calendar . SUNDAY : capacity = techDataCalendarWeek . getDouble ( STR_ ) ; startTime = techDataCalendarWeek . getTime ( STR_ ) ; break ; } if ( capacity == null || capacity . doubleValue ( ) == NUM_ ) { moveDay -= NUM_ ; dayEnd = ( dayEnd == NUM_ ) ? NUM_ : dayEnd - NUM_ ; } } result . put ( STR_ , capacity ) ; result . put ( STR_ , startTime ) ; result . put ( STR_ , Integer . valueOf ( moveDay ) ) ; return result ; }
protected void addClassPath ( String classpath ) { if ( classpath == null ) return ; String sep = classpath . indexOf ( STR_ ) == - NUM_ ? STR_ : STR_ ; String [ ] parseCp = classpath . split ( sep ) ; for ( String cpEntry : parseCp ) { addEntry ( cpEntry ) ; } }
@ Inject EntryUploaderImpl ( EntryInserter entryInserter , EntryProvider entryProvider , EntryUpdater entryUpdater ) { this . entryInserter = checkNotNull ( entryInserter ) ; this . entryProvider = checkNotNull ( entryProvider ) ; this . entryUpdater = checkNotNull ( entryUpdater ) ; }
protected void add ( long bytesIn , long bytesOut ) { totalBytesIn . addAndGet ( bytesIn ) ; totalBytesOut . addAndGet ( bytesOut ) ; }
public static double vectorDistance ( double [ ] vec1 , double [ ] vec2 , double power , double oneOverPower ) { double result = NUM_ ; if ( power == NUM_ ) { for ( int i = NUM_ ; i < vec1 . length ; i ++ ) { result += vec1 [ i ] - vec2 [ i ] == NUM_ ? NUM_ : NUM_ ; } } else if ( power == NUM_ ) { for ( int i = NUM_ ; i < vec1 . length ; i ++ ) { result += Math . abs ( vec1 [ i ] - vec2 [ i ] ) ; } } else if ( power == NUM_ ) { result = Math . sqrt ( distSquaredCartesian ( vec1 , vec2 ) ) ; } else if ( power == Integer . MAX_VALUE || Double . isInfinite ( power ) ) { for ( int i = NUM_ ; i < vec1 . length ; i ++ ) { result = Math . max ( result , Math . max ( vec1 [ i ] , vec2 [ i ] ) ) ; } } else { for ( int i = NUM_ ; i < vec1 . length ; i ++ ) { result += Math . pow ( vec1 [ i ] - vec2 [ i ] , power ) ; } result = Math . pow ( result , oneOverPower ) ; } return result ; }
public static float [ ] randomVector ( int aSize , long seed ) { Random rand = new Random ( seed ) ; float [ ] unk = new float [ aSize ] ; for ( int i = NUM_ ; i < unk . length ; i ++ ) { unk [ i ] = ( rand . nextFloat ( ) - NUM_ ) / aSize ; } return unk ; }
public boolean wasRaw ( ) { return wasRaw ; }
public Table findTable ( String catalogName , String schemaName , String tableName , boolean caseSensitive ) { String cacheKey = catalogName + STR_ + schemaName + STR_ + tableName + STR_ + caseSensitive ; Integer tableIndex = tableIndexCache . get ( cacheKey ) ; if ( tableIndex != null ) { if ( tableIndex < getTableCount ( ) ) { Table table = getTable ( tableIndex ) ; if ( doesMatch ( table , catalogName , schemaName , tableName , caseSensitive ) ) { return table ; } } } Table [ ] tables = getTables ( ) ; for ( int i = NUM_ ; i < tables . length ; i ++ ) { Table table = tables [ i ] ; if ( doesMatch ( table , catalogName , schemaName , tableName , caseSensitive ) ) { tableIndexCache . put ( cacheKey , i ) ; return table ; } } return null ; }
public void testDomainMatchesOnLocalAddresses ( ) { assertFalse ( HttpCookie . domainMatches ( STR_ , STR_ ) ) ; assertFalse ( HttpCookie . domainMatches ( STR_ , STR_ ) ) ; }
public void flush ( ) { writeDataBlock ( ) ; }
protected CRFPCoverageBox [ ] vectorToCRFPCoverageBoxes ( Vector vector ) { int size = vector . size ( ) ; CRFPCoverageBox [ ] rets = new CRFPCoverageBox [ size ] ; for ( int i = NUM_ ; i < size ; i ++ ) { RpfCoverageBox box = ( RpfCoverageBox ) vector . elementAt ( i ) ; if ( box != null ) { rets [ i ] = new CRFPCoverageBox ( ( float ) box . nw_lat , ( float ) box . nw_lon , ( float ) box . se_lat , ( float ) box . se_lon , box . subframeLatInterval , box . subframeLonInterval , box . chartCode , ( short ) box . zone , new XYPoint ( ( short ) box . startIndexes . x , ( short ) box . startIndexes . y ) , new XYPoint ( ( short ) box . endIndexes . x , ( short ) box . endIndexes . y ) , ( short ) box . tocNumber , ( short ) box . entryNumber , box . scale , box . percentCoverage ) ; } } return rets ; }
public void notifyListenersOfInitialization ( ) { if ( initialized ) { for ( ActionListener l : listeners ) { l . actionPerformed ( new ActionEvent ( this , ActionEvent . ACTION_PERFORMED , STR_ ) ) ; } } }
public void checkPassword ( String password ) throws BadRequestException { if ( password == null ) { throw new BadRequestException ( STR_ ) ; } if ( password . length ( ) < NUM_ ) { throw new BadRequestException ( STR_ ) ; } int numOfLetters = NUM_ ; int numOfDigits = NUM_ ; for ( char passwordChar : password . toCharArray ( ) ) { if ( Character . isDigit ( passwordChar ) ) { numOfDigits ++ ; } else if ( Character . isLetter ( passwordChar ) ) { numOfLetters ++ ; } } if ( numOfDigits == NUM_ || numOfLetters == NUM_ ) { throw new BadRequestException ( STR_ ) ; } }
final Node < K , V > find ( int h , Object k ) { if ( k != null ) { for ( Node < K , V > e = first ; e != null ; ) { int s ; K ek ; if ( ( ( s = lockState ) & ( WAITER | WRITER ) ) != NUM_ ) { if ( e . hash == h && ( ( ek = e . key ) == k || ( ek != null && k . equals ( ek ) ) ) ) return e ; e = e . next ; } else if ( U . compareAndSwapInt ( this , LOCKSTATE , s , s + READER ) ) { TreeNode < K , V > r , p ; try { p = ( ( r = root ) == null ? null : r . findTreeNode ( h , k , null ) ) ; } finally { Thread w ; if ( U . getAndAddInt ( this , LOCKSTATE , - READER ) == ( READER | WAITER ) && ( w = waiter ) != null ) LockSupport . unpark ( w ) ; } return p ; } } } return null ; }
@ SuppressWarnings ( STR_ ) private void collectAllRegionsDetails ( SystemMemberCacheJmxImpl cache , RegionSubRegionSnapshot regionSnapshot , Map < String , Map < String , ? > > regionsInfo , Map < String , ObjectName > existingRegionMbeans ) throws AdminException , OperationsException , MBeanException , ReflectionException { String fullPath = regionSnapshot . getFullPath ( ) ; if ( ! fullPath . equals ( PLACE_HOLDER_ROOT_REGION ) ) { fullPath = fullPath . substring ( PLACE_HOLDER_ROOT_REGION . length ( ) - NUM_ ) ; String name = regionSnapshot . getName ( ) ; Integer entryCount = Integer . valueOf ( regionSnapshot . getEntryCount ( ) ) ; Map < String , Object > details = new TreeMap < String , Object > ( ) ; details . put ( REGION_NAME , name ) ; details . put ( REGION_PATH , fullPath ) ; details . put ( REGION_ENTRYCOUNT , entryCount ) ; ObjectName regionObjectName = existingRegionMbeans . get ( fullPath ) ; if ( regionObjectName == null ) { regionObjectName = cache . manageRegion ( fullPath ) ; } Object attribute = getAttribute ( regionObjectName , STR_ , NOT_AVAILABLE ) ; attribute = attribute != null ? attribute . toString ( ) : attribute ; details . put ( REGION_SCOPE , attribute ) ; attribute = getAttribute ( regionObjectName , STR_ , NOT_AVAILABLE ) ; attribute = attribute != null ? attribute . toString ( ) : attribute ; details . put ( REGION_DATAPOLICY , attribute ) ; SubscriptionAttributes interestPolicyAttr = ( SubscriptionAttributes ) getAttribute ( regionObjectName , STR_ , null ) ; String interestPolicyStr = NOT_AVAILABLE ; if ( interestPolicyAttr != null ) { InterestPolicy interestPolicy = interestPolicyAttr . getInterestPolicy ( ) ; if ( interestPolicy != null ) { interestPolicyStr = interestPolicy . toString ( ) ; } } details . put ( REGION_INTERESTPOLICY , interestPolicyStr ) ; attribute = getAttribute ( regionObjectName , STR_ , NOT_AVAILABLE ) ; attribute = attribute != null ? attribute . toString ( ) : attribute ; details . put ( REGION_DISKATTRS , attribute ) ; regionsInfo . put ( fullPath , details ) ; } Set subRegionSnapshots = regionSnapshot . getSubRegionSnapshots ( ) ; for ( Iterator iterator = subRegionSnapshots . iterator ( ) ; iterator . hasNext ( ) ; ) { RegionSubRegionSnapshot subRegion = ( RegionSubRegionSnapshot ) iterator . next ( ) ; collectAllRegionsDetails ( cache , subRegion , regionsInfo , existingRegionMbeans ) ; } }
public synchronized boolean removeSuspendedResponse ( WorkerCategory category , Response response ) { Deque < Response > deque = workersByCategory . get ( category ) ; if ( deque == null ) { return BOOL_ ; } if ( deque . remove ( response ) ) { nWaitingConsumers -= NUM_ ; LOG . debug ( STR_ ) ; return BOOL_ ; } return BOOL_ ; }
public static Number sin ( Number a ) { return Math . sin ( a . doubleValue ( ) ) ; }
private TypedClassOperation instantiateOperationTypes ( TypedClassOperation operation ) { List < TypeVariable > typeParameters = operation . getTypeParameters ( ) ; if ( typeParameters . isEmpty ( ) ) { return operation ; } Substitution < ReferenceType > substitution = selectSubstitution ( typeParameters ) ; if ( substitution == null ) { return null ; } return operation . apply ( substitution ) ; }
default T fold ( final T identity , final BinaryOperator < T > accumulator ) { final Optional < T > opt = toOptional ( ) ; if ( opt . isPresent ( ) ) return accumulator . apply ( identity , get ( ) ) ; return identity ; }
protected void load ( String filename , Properties p ) throws FileNotFoundException { File file = new File ( filename ) ; if ( ! file . exists ( ) ) throw new FileNotFoundException ( filename ) ; classifier = new CRFClassifier < CoreLabel > ( p ) ; try { classifier . loadClassifier ( file , p ) ; } catch ( ClassCastException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } }
public String resolveFont ( java . awt . Font font ) { String ret = STR_ ; ret = ret . concat ( STR_ + font . getName ( ) ) ; if ( font . isBold ( ) ) ret = ret . concat ( STR_ ) ; else ret = ret . concat ( STR_ ) ; if ( font . isItalic ( ) ) ret = ret . concat ( STR_ ) ; else ret = ret . concat ( STR_ ) ; ret = ret . concat ( STR_ ) ; ret = ret . concat ( STR_ + font . getSize ( ) ) ; ret = ret . concat ( STR_ ) ; ret = ret . concat ( STR_ ) ; ret = ret . concat ( STR_ ) ; ret = ret . concat ( STR_ ) ; ret = ret . concat ( STR_ ) ; ret = ret . concat ( STR_ ) ; return ret ; }
public void addLineContent ( final ZyLineContent line ) { Preconditions . checkNotNull ( line , STR_ ) ; m_content . add ( line ) ; }
public static boolean excludeByPackage ( String pkg , List < String > excludePkg ) { for ( String ep : excludePkg ) { if ( pkg . matches ( ep ) ) { return BOOL_ ; } } return BOOL_ ; }
public RegionVersionHolder ( long ver ) { this . version = ver ; }
public static void writeFully ( FileChannel file , long pos , ByteBuffer src ) { try { int off = NUM_ ; do { int len = file . write ( src , pos + off ) ; off += len ; } while ( src . remaining ( ) > NUM_ ) ; } catch ( IOException e ) { throw newIllegalStateException ( ERROR_WRITING_FAILED , STR_ , file , src . remaining ( ) , pos , e ) ; } }
public void updateRequestTimeout ( TimeSpan span ) throws SecurityException , ApplicationException { checkWriteAccess ( ) ; boolean hasAccess = ConfigWebUtil . hasAccess ( config , SecurityManager . TYPE_SETTING ) ; if ( ! hasAccess ) throw new SecurityException ( STR_ ) ; Element scope = _getRootElement ( STR_ ) ; Element application = _getRootElement ( STR_ ) ; if ( span != null ) { if ( span . getMillis ( ) <= NUM_ ) throw new ApplicationException ( STR_ ) ; application . setAttribute ( STR_ , span . getDay ( ) + STR_ + span . getHour ( ) + STR_ + span . getMinute ( ) + STR_ + span . getSecond ( ) ) ; } else application . removeAttribute ( STR_ ) ; if ( scope . hasAttribute ( STR_ ) ) scope . removeAttribute ( STR_ ) ; }
@ Override protected boolean calcProblem ( ) { String type = getTagWithKey ( Tags . KEY_TYPE ) ; if ( type == null || type . equals ( STR_ ) ) { return BOOL_ ; } return super . calcProblem ( ) ; }
public int readByte ( ) throws IOException { ++ length ; return in . read ( ) & xff ; }
public void updateShapeShadowsToCurrentTime ( boolean updateMinutes , boolean updateHours , int currentMinute , int currentHour ) { if ( updateMinutes ) { int tens = ( int ) Math . floor ( currentMinute / NUM_ ) ; int units = ( int ) Math . floor ( currentMinute % NUM_ ) ; if ( minutesTens . getCurrentValue ( ) != tens ) { String mt = String . format ( STR_ , tens ) ; mt = mt . concat ( STR_ ) ; Log . d ( TAG , STR_ + mt ) ; minutesTens . parseJSON ( mt ) ; } if ( minutesUnits . getCurrentValue ( ) != units ) { String mu = String . format ( STR_ , units ) ; mu = mu . concat ( STR_ ) ; Log . d ( TAG , STR_ + mu ) ; minutesUnits . parseJSON ( mu ) ; } } if ( updateHours ) { int tens = ( int ) Math . floor ( currentHour / NUM_ ) ; int units = ( int ) Math . floor ( currentHour % NUM_ ) ; if ( hoursTens . getCurrentValue ( ) != tens ) { String ht = String . format ( STR_ , tens ) ; ht = ht . concat ( STR_ ) ; Log . d ( TAG , STR_ + ht ) ; hoursTens . parseJSON ( ht ) ; } if ( hoursUnits . getCurrentValue ( ) != units ) { String hu = String . format ( STR_ , units ) ; hu = hu . concat ( STR_ ) ; Log . d ( TAG , STR_ + hu ) ; hoursUnits . parseJSON ( hu ) ; } } }
public Set < RawProtein < SuperFamilyHmmer3RawMatch > > parse ( InputStream is ) throws IOException { Map < String , RawProtein < SuperFamilyHmmer3RawMatch > > data = new HashMap < String , RawProtein < SuperFamilyHmmer3RawMatch > > ( ) ; BufferedReader reader = null ; try { reader = new BufferedReader ( new InputStreamReader ( is ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { Set < SuperFamilyHmmer3RawMatch > rawMatches = parseLine ( line ) ; SuperFamilyHmmer3RawMatch rawMatch ; for ( SuperFamilyHmmer3RawMatch rawMatche : rawMatches ) { rawMatch = rawMatche ; String sequenceId = rawMatch . getSequenceIdentifier ( ) ; if ( data . containsKey ( sequenceId ) ) { RawProtein < SuperFamilyHmmer3RawMatch > rawProtein = data . get ( sequenceId ) ; rawProtein . addMatch ( rawMatch ) ; } else { RawProtein < SuperFamilyHmmer3RawMatch > rawProtein = new RawProtein < SuperFamilyHmmer3RawMatch > ( sequenceId ) ; rawProtein . addMatch ( rawMatch ) ; data . put ( sequenceId , rawProtein ) ; } } } } finally { if ( reader != null ) { reader . close ( ) ; } } return new HashSet < RawProtein < SuperFamilyHmmer3RawMatch > > ( data . values ( ) ) ; }
public UnionPathIterator ( Compiler compiler , int opPos ) throws javax . xml . transform . TransformerException { super ( ) ; opPos = OpMap . getFirstChildPos ( opPos ) ; loadLocationPaths ( compiler , opPos , NUM_ ) ; }
public String relationName ( ) { return m_RelationName ; }
private void writeAttribute ( java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( namespace . equals ( STR_ ) ) { xmlWriter . writeAttribute ( attName , attValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } }
@ RequestMapping ( value = STR_ , method = RequestMethod . POST , produces = MediaType . TEXT_PLAIN_VALUE ) @ Timed public ResponseEntity < ? > changePassword ( @ RequestBody String password ) { if ( ! checkPasswordLength ( password ) ) { return new ResponseEntity < > ( STR_ , HttpStatus . BAD_REQUEST ) ; } userService . changePassword ( password ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; }
public void testBadSegment ( ) throws IOException { Directory dir = newDirectory ( ) ; IndexWriter iw = new IndexWriter ( dir , newIndexWriterConfig ( new MockAnalyzer ( random ( ) ) ) ) ; Document document = new Document ( ) ; FieldType customType = new FieldType ( TextField . TYPE_NOT_STORED ) ; customType . setStoreTermVectors ( BOOL_ ) ; document . add ( newField ( STR_ , STR_ , customType ) ) ; iw . addDocument ( document ) ; iw . close ( ) ; dir . close ( ) ; }
public static int size ( String str ) { if ( str == null ) return NUM_ ; int length = str . length ( ) ; int size = length ; try { size = str . getBytes ( STR_ ) . length ; } catch ( UnsupportedEncodingException e ) { log . log ( Level . SEVERE , str , e ) ; } return size ; }
protected void synchWithTarget ( ) throws MonitorException { long timeLimit = System . currentTimeMillis ( ) + syncWaitMs ; log ( STR_ + lvmid + STR_ ) ; while ( ! prologue . isAccessible ( ) ) { log ( STR_ ) ; try { Thread . sleep ( NUM_ ) ; } catch ( InterruptedException e ) { } if ( System . currentTimeMillis ( ) > timeLimit ) { logln ( STR_ + lvmid ) ; throw new MonitorException ( STR_ ) ; } } logln ( STR_ + lvmid ) ; }
public static CharSequence time ( Context context , EasyCursor c ) { long now = System . currentTimeMillis ( ) ; long when = c . getLong ( Reviews . WRITTEN_ON ) ; return now - when > MINUTE_IN_MILLIS ? DateUtils . getRelativeTimeSpanString ( when , now , NUM_ , FORMAT_ABBREV_ALL ) : context . getString ( R . string . recent_time ) ; }
private double screenToNormalized ( float screenCoord ) { int width = getWidth ( ) ; if ( width <= NUM_ . padding ) { return NUM_ ; } else { double result = ( screenCoord - padding ) / ( width - NUM_ . padding ) ; return Math . min ( NUM_ , Math . max ( NUM_ , result ) ) ; } }
public long roundTripTime ( ) throws InterruptedException { latch . await ( ) ; return received - sent ; }
static private String userIdFromRange ( String [ ] values , boolean include ) { int minId = Integer . parseInt ( values [ NUM_ ] ) ; int maxId = Integer . parseInt ( values [ NUM_ ] ) ; String exclusions = values . length > NUM_ ? values [ NUM_ ] : null ; Stack < Integer > stack = getStack ( minId , maxId , exclusions , include ) ; if ( stack . size ( ) > NUM_ ) { return Integer . toString ( stack . pop ( ) ) ; } throw new IllegalArgumentException ( STR_ ) ; }
public void testCase4 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte rBytes [ ] = { - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ } ; int aSign = - NUM_ ; int bSign = NUM_ ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . add ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , - NUM_ , result . signum ( ) ) ; }
public static String stringDefaultValue ( String bytes ) { try { return new String ( bytes . getBytes ( STR_ ) , STR_ ) ; } catch ( UnsupportedEncodingException e ) { throw new IllegalStateException ( STR_ , e ) ; } }
public void actualizaCampo ( int tipoFicha , ValorCampoGenericoVO campo ) { ValorCampoGenericoVO campoAnterior = retrieve ( tipoFicha , campo . getTipo ( ) , campo . getIdObjeto ( ) , campo . getIdCampo ( ) , campo . getOrden ( ) , campo . getTipoElemento ( ) ) ; if ( campoAnterior == null ) insert ( tipoFicha , campo ) ; else update ( tipoFicha , campo , campoAnterior . getValorInfo ( ) ) ; }
public static int length ( RegExp re ) { RegExp2 r ; switch ( re . type ) { case sym . BAR : { r = ( RegExp2 ) re ; int l1 = length ( r . r1 ) ; if ( l1 < NUM_ ) return - NUM_ ; int l2 = length ( r . r2 ) ; if ( l1 == l2 ) return l1 ; else return - NUM_ ; } case sym . CONCAT : { r = ( RegExp2 ) re ; int l1 = length ( r . r1 ) ; if ( l1 < NUM_ ) return - NUM_ ; int l2 = length ( r . r2 ) ; if ( l2 < NUM_ ) return - NUM_ ; return l1 + l2 ; } case sym . STAR : case sym . PLUS : case sym . QUESTION : return - NUM_ ; case sym . CCLASS : case sym . CCLASSNOT : case sym . CHAR : case sym . CHAR_I : return NUM_ ; case sym . STRING : case sym . STRING_I : { String content = ( String ) ( ( RegExp1 ) re ) . content ; return content . length ( ) ; } case sym . TILDE : case sym . BANG : return - NUM_ ; case sym . MACROUSE : return length ( macros . getDefinition ( ( String ) ( ( RegExp1 ) re ) . content ) ) ; } throw new Error ( STR_ + re . type + STR_ + re ) ; }
public static TimeZone randomTimeZone ( Random random ) { String tzIds [ ] = TimeZone . getAvailableIDs ( ) ; return TimeZone . getTimeZone ( tzIds [ random . nextInt ( tzIds . length ) ] ) ; }
public static String arrayToList ( String [ ] array , String delimiter ) { if ( ArrayUtil . isEmpty ( array ) ) return STR_ ; StringBuilder sb = new StringBuilder ( array [ NUM_ ] ) ; if ( delimiter . length ( ) == NUM_ ) { char c = delimiter . charAt ( NUM_ ) ; for ( int i = NUM_ ; i < array . length ; i ++ ) { sb . append ( c ) ; sb . append ( array [ i ] ) ; } } else { for ( int i = NUM_ ; i < array . length ; i ++ ) { sb . append ( delimiter ) ; sb . append ( array [ i ] ) ; } } return sb . toString ( ) ; }
@ Override public boolean addAll ( Collection < ? extends E > c ) { Iterator < ? extends E > i = c . iterator ( ) ; boolean changed = BOOL_ ; while ( i . hasNext ( ) ) { boolean ret = add ( i . next ( ) ) ; if ( ! changed ) { changed = ret ; } } return changed ; }
public void reset ( ) { mCodes . clear ( ) ; mIsFirstCharCapitalized = BOOL_ ; mPreferredWord = null ; mTypedWord . setLength ( NUM_ ) ; mCapsCount = NUM_ ; }
private String extractPath ( final String uri ) { return DefaultWildcardStreamLocator . stripQueryPath ( uri . replace ( PREFIX , StringUtils . EMPTY ) ) ; }
public void addClassesToCheck ( File basedir , String ... relativeNames ) throws IOException { addClassesToCheck ( basedir , Arrays . asList ( relativeNames ) ) ; }
public static Short toShort ( String str ) throws PageException { return Short . valueOf ( toShortValue ( str ) ) ; }
public void testReadXmlLangNewStyle ( ) throws Exception { Properties result = xmlToProperties ( STR_ ) ; assertNotNull ( result ) ; assertTrue ( ! result . isEmpty ( ) ) ; assertEquals ( NUM_ , result . size ( ) ) ; assertEquals ( STR_ , result . getProperty ( STR_ ) ) ; }
public boolean hasPermission ( Security security , GenericValue userLogin ) { return OrderReadHelper . hasPermission ( security , userLogin , orderHeader ) ; }
protected boolean filterFiles ( List < File > files ) { if ( task . getNoMtimeCheck ( ) || isOutputRepositoryURL ( ) ) { return BOOL_ ; } Iterator < File > iter = files . iterator ( ) ; while ( iter . hasNext ( ) ) { File file = iter . next ( ) ; Module module = inferModule ( file ) ; if ( module == null ) { task . log ( STR_ + file , Project . MSG_VERBOSE ) ; continue ; } if ( module . getVersion ( ) == null ) { task . log ( STR_ + module . getName ( ) , Project . MSG_VERBOSE ) ; continue ; } long oldest = getArtifactFileTime ( module , file ) ; if ( oldest == Long . MAX_VALUE ) { File outModuleDir = getArtifactDir ( module ) ; oldest = oldestOutputArtifact ( Long . MAX_VALUE , outModuleDir ) ; task . log ( STR_ + module + STR_ + new Date ( oldest ) , Project . MSG_DEBUG ) ; } else { task . log ( STR_ + file + STR_ + module + STR_ + new Date ( oldest ) , Project . MSG_DEBUG ) ; } long newestFile = file . lastModified ( ) ; task . log ( STR_ + file + STR_ + new Date ( newestFile ) , Project . MSG_DEBUG ) ; if ( newestFile != Long . MIN_VALUE && oldest != Long . MAX_VALUE && newestFile < oldest ) { task . log ( STR_ + file + STR_ ) ; iter . remove ( ) ; } } return files . size ( ) == NUM_ ; }
public void flush ( ) { outputStream . flush ( ) ; }
public int createMeasures ( MSLAGoal goal ) { String sql = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + MInOut . Table_ID + STR_ ; int counter = NUM_ ; PreparedStatement pstmt = null ; ResultSet rs = null ; try { pstmt = DB . prepareStatement ( sql , null ) ; pstmt . setInt ( NUM_ , goal . getC_BPartner_ID ( ) ) ; pstmt . setInt ( NUM_ , goal . getPA_SLA_Goal_ID ( ) ) ; rs = pstmt . executeQuery ( ) ; while ( rs . next ( ) ) { int M_InOut_ID = rs . getInt ( NUM_ ) ; BigDecimal MeasureActual = rs . getBigDecimal ( NUM_ ) ; Timestamp MovementDate = rs . getTimestamp ( NUM_ ) ; String Description = rs . getString ( NUM_ ) + STR_ + rs . getTimestamp ( NUM_ ) ; if ( goal . isDateValid ( MovementDate ) ) { MSLAMeasure measure = new MSLAMeasure ( goal , MovementDate , MeasureActual , Description ) ; measure . setLink ( MInOut . Table_ID , M_InOut_ID ) ; if ( measure . save ( ) ) counter ++ ; } } } catch ( Exception e ) { log . log ( Level . SEVERE , STR_ , e ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } return counter ; }
public E removeAt ( int index ) { final Object old = mArray [ index ] ; if ( mSize <= NUM_ ) { if ( DEBUG ) Log . d ( TAG , STR_ + mHashes . length + STR_ ) ; freeArrays ( mHashes , mArray , mSize ) ; mHashes = SupportContainerInternals . EMPTY_INTS ; mArray = SupportContainerInternals . EMPTY_OBJECTS ; mSize = NUM_ ; } else { if ( mHashes . length > ( BASE_SIZE . NUM_ ) && mSize < mHashes . length / NUM_ ) { final int n = mSize > ( BASE_SIZE . NUM_ ) ? ( mSize + ( mSize > > NUM_ ) ) : ( BASE_SIZE . NUM_ ) ; if ( DEBUG ) Log . d ( TAG , STR_ + mHashes . length + STR_ + n ) ; final int [ ] ohashes = mHashes ; final Object [ ] oarray = mArray ; allocArrays ( n ) ; mSize -- ; if ( index > NUM_ ) { if ( DEBUG ) Log . d ( TAG , STR_ + index + STR_ ) ; System . arraycopy ( ohashes , NUM_ , mHashes , NUM_ , index ) ; System . arraycopy ( oarray , NUM_ , mArray , NUM_ , index ) ; } if ( index < mSize ) { if ( DEBUG ) Log . d ( TAG , STR_ + ( index + NUM_ ) + STR_ + mSize + STR_ + index ) ; System . arraycopy ( ohashes , index + NUM_ , mHashes , index , mSize - index ) ; System . arraycopy ( oarray , index + NUM_ , mArray , index , mSize - index ) ; } } else { mSize -- ; if ( index < mSize ) { if ( DEBUG ) Log . d ( TAG , STR_ + ( index + NUM_ ) + STR_ + mSize + STR_ + index ) ; System . arraycopy ( mHashes , index + NUM_ , mHashes , index , mSize - index ) ; System . arraycopy ( mArray , index + NUM_ , mArray , index , mSize - index ) ; } mArray [ mSize ] = null ; } } return ( E ) old ; }
@ Override public String resolveVideoUrl ( @ Nullable final Video video , Step step ) { if ( video == null ) return null ; String localPath = databaseFacade . getPathToVideoIfExist ( video ) ; if ( localPath != null && checkExistingOnDisk ( localPath , step ) ) { return localPath ; } else { List < VideoUrl > urlList = video . getUrls ( ) ; if ( urlList == null || urlList . size ( ) == NUM_ ) return null ; return resolveFromWeb ( urlList ) ; } }
protected Object lookupService ( ) throws Exception { Object service = null ; ServiceTemplate templ ; if ( template == null ) { Class < ? > [ ] types = ( serviceClass == null ? null : new Class [ ] { serviceClass } ) ; Entry [ ] entry = ( serviceName == null ? null : new Entry [ ] { new Name ( serviceName ) } ) ; templ = new ServiceTemplate ( null , types , entry ) ; } else { templ = template ; } LookupLocator [ ] lookupLocators = null ; if ( locators != null ) { lookupLocators = new LookupLocator [ locators . length ] ; for ( int i = NUM_ ; i < locators . length ; i ++ ) { String locator = locators [ i ] ; if ( ! locator . startsWith ( STR_ ) ) { locator = STR_ + locator ; } lookupLocators [ i ] = new LookupLocator ( locator ) ; } } ServiceDiscoveryManager serviceDiscovery = null ; try { serviceDiscovery = SharedDiscoveryManagement . getBackwardsServiceDiscoveryManager ( groups , lookupLocators , null ) ; ServiceItem returnObject = serviceDiscovery . lookup ( templ , null , timeout ) ; if ( returnObject != null ) { service = returnObject . service ; } } finally { if ( serviceDiscovery != null ) { try { serviceDiscovery . terminate ( ) ; } catch ( Exception e ) { logger . warn ( STR_ , e ) ; } } } return service ; }
public static boolean equals ( final Object obj1 , final Object obj2 ) { return ( obj1 != null && obj1 . equals ( obj2 ) ) ; }
public void testMergeSameFilterWithInitParamInTwoDocuments ( ) throws Exception { String srcXml = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; WebXml srcWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( srcXml . getBytes ( STR_ ) ) , null ) ; String mergeXml = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; WebXml mergeWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( mergeXml . getBytes ( STR_ ) ) , null ) ; WebXmlMerger merger = new WebXmlMerger ( srcWebXml ) ; merger . mergeFilters ( mergeWebXml ) ; assertTrue ( WebXmlUtils . hasFilter ( srcWebXml , STR_ ) ) ; List < String > filterInitParamNames = WebXmlUtils . getFilterInitParamNames ( srcWebXml , STR_ ) ; assertTrue ( filterInitParamNames . size ( ) == NUM_ ) ; assertEquals ( STR_ , filterInitParamNames . get ( NUM_ ) ) ; List < String > filterMappings = WebXmlUtils . getFilterMappings ( srcWebXml , STR_ ) ; assertEquals ( NUM_ , filterMappings . size ( ) ) ; assertEquals ( STR_ , filterMappings . get ( NUM_ ) ) ; }
public WebappTemplateLoader ( ServletContext servletContext , String subdirPath ) { if ( servletContext == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( subdirPath == null ) { throw new IllegalArgumentException ( STR_ ) ; } subdirPath = subdirPath . replace ( STR_ , STR_ ) ; if ( ! subdirPath . endsWith ( STR_ ) ) { subdirPath += STR_ ; } if ( ! subdirPath . startsWith ( STR_ ) ) { subdirPath = STR_ + subdirPath ; } this . subdirPath = subdirPath ; this . servletContext = servletContext ; }
@ SuppressWarnings ( { STR_ } ) public static < T > T [ ] insert ( T [ ] dest , T src , int offset , Class componentType ) { T [ ] temp = ( T [ ] ) Array . newInstance ( componentType , dest . length + NUM_ ) ; System . arraycopy ( dest , NUM_ , temp , NUM_ , offset ) ; temp [ offset ] = src ; System . arraycopy ( dest , offset , temp , offset + NUM_ , dest . length - offset ) ; return temp ; }
@ Override public void flush ( ) throws IOException { writer . write ( buffer , NUM_ , fill ) ; fill = NUM_ ; }
public MetricInstance withDependencyMetricNames ( List < String > dependencyMetricNames ) { return new MetricInstance ( metricName , maker , dependencyMetricNames . toArray ( new String [ dependencyMetricNames . size ( ) ] ) ) ; }
public static IStatus validateMethodName ( String name ) { return validateMethodName ( name , CompilerOptions . VERSION_1_3 , CompilerOptions . VERSION_1_3 ) ; }
@ SuppressWarnings ( STR_ ) void notifyAlarmClock ( TimerAlarmClockNotification notification ) { TimerNotification timerNotification = null ; Date timerDate = null ; TimerAlarmClock alarmClock = ( TimerAlarmClock ) notification . getSource ( ) ; synchronized ( Timer . this ) { for ( Object [ ] obj : timerTable . values ( ) ) { if ( obj [ ALARM_CLOCK_INDEX ] == alarmClock ) { timerNotification = ( TimerNotification ) obj [ TIMER_NOTIF_INDEX ] ; timerDate = ( Date ) obj [ TIMER_DATE_INDEX ] ; break ; } } } sendNotification ( timerDate , timerNotification ) ; updateTimerTable ( timerNotification . getNotificationID ( ) ) ; }
public ProfilerEntity start ( ) { start_time = System . nanoTime ( ) ; return this ; }
public static < E extends Enum < E > > EnumSet < E > of ( E e1 , E e2 , E e3 ) { EnumSet < E > set = of ( e1 , e2 ) ; set . add ( e3 ) ; return set ; }
public PickRequest withCameraPicsDirectory ( @ Nullable final File pDirFile ) { this . mCustomCameraPicsDirPath = pDirFile == null ? null : pDirFile . getAbsolutePath ( ) ; return this ; }
public void prepareForNextRun ( ) { for ( int i = NUM_ ; i < NUM_ ; i ++ ) { System . gc ( ) ; try { Thread . sleep ( NUM_ ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } }
public boolean writeHeader ( OutputStream os ) { try { writeInt ( os , CACHE_MAGIC ) ; writeString ( os , key ) ; writeString ( os , etag == null ? STR_ : etag ) ; writeLong ( os , serverDate ) ; writeLong ( os , lastModified ) ; writeLong ( os , ttl ) ; writeLong ( os , softTtl ) ; writeStringStringMap ( responseHeaders , os ) ; os . flush ( ) ; return BOOL_ ; } catch ( IOException e ) { VolleyLog . d ( STR_ , e . toString ( ) ) ; return BOOL_ ; } }
public void add ( Chip chip ) { if ( ! mChipList . contains ( chip ) || mToleratingDuplicate ) { mChipList . add ( chip ) ; notifyUpdate ( ) ; } }
private boolean checkTripZoneConsistency ( ) { log . info ( STR_ ) ; HashSet < String > missingZones = new HashSet < String > ( ) ; for ( Trip T : trips . values ( ) ) { BasicLocation zo = zones . getLocation ( Id . create ( T . zone_o , Zone . class ) ) ; BasicLocation zd = zones . getLocation ( Id . create ( T . zone_d , Zone . class ) ) ; if ( zo == null ) { missingZones . add ( T . zone_o ) ; } if ( zd == null ) { missingZones . add ( T . zone_d ) ; } } if ( missingZones . size ( ) > NUM_ ) { String msg = missingZones . size ( ) + STR_ ; for ( String s : missingZones ) msg += STR_ + s . toString ( ) + STR_ ; log . error ( msg ) ; return BOOL_ ; } else log . info ( STR_ ) ; return BOOL_ ; }
private int insertIndexForLayer ( Component comp , int layer , int position ) { int i , count , curLayer ; int layerStart = - NUM_ ; int layerEnd = - NUM_ ; int componentCount = getComponentCount ( ) ; ArrayList < Component > compList = new ArrayList < Component > ( componentCount ) ; for ( int index = NUM_ ; index < componentCount ; index ++ ) { if ( getComponent ( index ) != comp ) { compList . add ( getComponent ( index ) ) ; } } count = compList . size ( ) ; for ( i = NUM_ ; i < count ; i ++ ) { curLayer = getLayer ( compList . get ( i ) ) ; if ( layerStart == - NUM_ && curLayer == layer ) { layerStart = i ; } if ( curLayer < layer ) { if ( i == NUM_ ) { layerStart = NUM_ ; layerEnd = NUM_ ; } else { layerEnd = i ; } break ; } } if ( layerStart == - NUM_ && layerEnd == - NUM_ ) return count ; if ( layerStart != - NUM_ && layerEnd == - NUM_ ) layerEnd = count ; if ( layerEnd != - NUM_ && layerStart == - NUM_ ) layerStart = layerEnd ; if ( position == - NUM_ ) return layerEnd ; if ( position > - NUM_ && layerStart + position <= layerEnd ) return layerStart + position ; return layerEnd ; }
public void testTimedInvokeAll2 ( ) throws InterruptedException { ExecutorService e = new ForkJoinPool ( NUM_ ) ; PoolCleaner cleaner = null ; try { cleaner = cleaner ( e ) ; List < Future < String > > r = e . invokeAll ( new ArrayList < Callable < String > > ( ) , MEDIUM_DELAY_MS , MILLISECONDS ) ; assertTrue ( r . isEmpty ( ) ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public static WaitDialog showDialog ( WaitDialog . Runnable runnable , String message , Container container , int width , int height ) { WaitDialog newDialog = null ; if ( container instanceof JDialog ) { newDialog = new WaitDialog ( ( JDialog ) container ) ; } else if ( container instanceof JFrame ) { newDialog = new WaitDialog ( ( JFrame ) container ) ; } else { newDialog = new WaitDialog ( ( JDialog ) null ) ; newDialog . setLocationRelativeTo ( container ) ; } newDialog . buildDialog ( width , height ) ; runnable . setDialog ( newDialog ) ; newDialog . container = container ; newDialog . runnable = runnable ; newDialog . setMessage ( message ) ; Thread processThread = new ProcessThread ( newDialog ) ; processThread . start ( ) ; while ( ! newDialog . isVisible ( ) ) { try { Thread . sleep ( NUM_ ) ; } catch ( InterruptedException ie ) { } } return newDialog ; }
public void testFlipBitPositiveOutside2 ( ) { byte aBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int number = NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger result = aNumber . flipBit ( number ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public synchronized void write ( byte b [ ] , int off , int len ) throws IOException { if ( len <= NUM_ ) return ; int freeSpace = buffer . length - pos ; if ( len <= freeSpace ) { System . arraycopy ( b , off , buffer , pos , len ) ; pos += len ; return ; } flush ( ) ; int local_requested ; while ( BOOL_ ) { synchronized ( lock ) { while ( ( local_requested = requested ) < NUM_ && ! disconnected ) { try { lock . wait ( ) ; } catch ( InterruptedException e ) { } } if ( disconnected ) throw new IOException ( STR_ ) ; } if ( local_requested < len ) { manager . sendTransmit ( info , b , off , local_requested ) ; off += local_requested ; len -= local_requested ; synchronized ( lock ) { requested -= local_requested ; } } else { manager . sendTransmit ( info , b , off , len ) ; synchronized ( lock ) { requested -= len ; } break ; } } }
protected Alarm ( ) { this ( STR_ ) ; }
public void removeMouseMode ( MapMouseMode med ) { boolean needToAdjustActiveMode = BOOL_ ; if ( med == null ) { return ; } if ( med . equals ( activeMouseMode ) ) { needToAdjustActiveMode = BOOL_ ; setInactive ( med ) ; } for ( MapMouseMode checkMM : mouseModes ) { if ( med . equals ( checkMM ) ) { med . removeAllMapMouseListeners ( ) ; } else if ( needToAdjustActiveMode ) { setActive ( checkMM ) ; needToAdjustActiveMode = BOOL_ ; } } mouseModes . remove ( med ) ; firePropertyChange ( MouseModesProperty , null , mouseModes ) ; }
@ Override public boolean hasDispatchFunction ( ) { return BOOL_ ; }
public void addMap ( Map < K , V > map , K min , K max ) { if ( min != null && max != null && keyType . compare ( min , max ) > NUM_ ) { DataUtils . newIllegalArgumentException ( STR_ , min , max ) ; } int len = shards . length + NUM_ ; Shard < K , V > [ ] newShards = Arrays . copyOf ( shards , len ) ; Shard < K , V > newShard = new Shard < K , V > ( ) ; newShard . map = map ; newShard . minIncluding = min ; newShard . maxExcluding = max ; newShards [ len - NUM_ ] = newShard ; shards = newShards ; }
private void retryFailedInterfaces ( ) { for ( Iterator i = failedInterfaces . iterator ( ) ; i . hasNext ( ) ; ) { NetworkInterface nic = ( NetworkInterface ) i . next ( ) ; try { if ( nic != null ) { socket . setNetworkInterface ( nic ) ; } socket . joinGroup ( requestAddr ) ; i . remove ( ) ; Level l = multicastInterfacesSpecified ? Level . INFO : Level . FINE ; if ( logger . isLoggable ( l ) ) { if ( nic != null ) { logger . log ( l , STR_ , new Object [ ] { nic } ) ; } else { logger . log ( l , STR_ ) ; } } } catch ( IOException e ) { } } }
public void writeHeader ( ) throws IOException { FLVHeader flvHeader = new FLVHeader ( ) ; flvHeader . setFlagAudio ( BOOL_ ) ; flvHeader . setFlagVideo ( BOOL_ ) ; ByteBuffer header = ByteBuffer . allocate ( HEADER_LENGTH + NUM_ ) ; flvHeader . write ( header ) ; file . setLength ( HEADER_LENGTH + NUM_ ) ; if ( header . hasArray ( ) ) { log . debug ( STR_ ) ; file . write ( header . array ( ) ) ; } else { log . debug ( STR_ ) ; byte [ ] tmp = new byte [ HEADER_LENGTH + NUM_ ] ; header . get ( tmp ) ; file . write ( tmp ) ; } bytesWritten = file . length ( ) ; header . clear ( ) ; }
public static Future < ? > submit ( Runnable task ) { return THREAD_POOL . submit ( task ) ; }
public boolean addOverlay ( Overlay overlay , KmlDocument kmlDoc ) { if ( overlay == null ) return BOOL_ ; KmlFeature kmlItem ; if ( overlay instanceof GroundOverlay ) { kmlItem = new KmlGroundOverlay ( ( GroundOverlay ) overlay ) ; } else if ( overlay instanceof FolderOverlay ) { kmlItem = new KmlFolder ( ( FolderOverlay ) overlay , kmlDoc ) ; } else if ( overlay instanceof MarkerClusterer ) { kmlItem = new KmlFolder ( ( MarkerClusterer ) overlay , kmlDoc ) ; } else if ( overlay instanceof Marker ) { Marker marker = ( Marker ) overlay ; kmlItem = new KmlPlacemark ( marker ) ; } else if ( overlay instanceof Polygon ) { Polygon polygon = ( Polygon ) overlay ; kmlItem = new KmlPlacemark ( polygon , kmlDoc ) ; } else if ( overlay instanceof Polyline ) { Polyline polyline = ( Polyline ) overlay ; kmlItem = new KmlPlacemark ( polyline , kmlDoc ) ; } else { return BOOL_ ; } mItems . add ( kmlItem ) ; return BOOL_ ; }
private < T extends SBResource > T lookForResource ( SBResourceType type , Class < T > clazz ) { List < T > resources = lookForResources ( type , clazz ) ; return resources != null && resources . size ( ) > NUM_ ? resources . get ( NUM_ ) : null ; }
private Object produceEvent ( ) throws InvocationTargetException { if ( ! valid ) { throw new IllegalStateException ( toString ( ) + STR_ ) ; } try { return method . invoke ( target ) ; } catch ( IllegalAccessException e ) { throw new AssertionError ( e ) ; } catch ( InvocationTargetException e ) { if ( e . getCause ( ) instanceof Error ) { throw ( Error ) e . getCause ( ) ; } throw e ; } }
private List < Float > createDashArray ( String dashString ) { String [ ] dashes = dashString . split ( STR_ ) ; List < Float > floatDashArray = new ArrayList < Float > ( ) ; for ( String dashValue : dashes ) { try { floatDashArray . add ( Float . parseFloat ( dashValue ) ) ; } catch ( NumberFormatException e ) { return null ; } } return floatDashArray ; }
public void cleanPatchByVersion ( String versionName ) { if ( patchDirectory == null || versionName == null ) { return ; } String path = patchDirectory . getAbsolutePath ( ) + STR_ + versionName ; SharePatchFileUtil . deleteDir ( path ) ; }
public static boolean isValidJavaClassName ( String input ) { if ( ! StringUtils . hasText ( input ) ) { return BOOL_ ; } if ( ! Character . isJavaIdentifierStart ( input . charAt ( NUM_ ) ) ) { return BOOL_ ; } if ( input . length ( ) > NUM_ ) { for ( int i = NUM_ ; i < input . length ( ) ; i ++ ) { if ( ! Character . isJavaIdentifierPart ( input . charAt ( i ) ) ) { return BOOL_ ; } } } return BOOL_ ; }
public void test_create_empty ( ) { final String id = STR_ ; final Map < String , Object > metadata = new HashMap < String , Object > ( ) ; metadata . put ( FileMetadataSchema . ID , id ) ; metadata . put ( STR_ , STR_ ) ; final int version = repo . create ( metadata ) ; metadata . put ( FileMetadataSchema . VERSION , Integer . valueOf ( version ) ) ; assertEquals ( STR_ , NUM_ , version ) ; RepositoryDocumentImpl doc = ( RepositoryDocumentImpl ) repo . read ( id ) ; assertTrue ( STR_ , doc . exists ( ) ) ; assertEquals ( STR_ , version , doc . getVersion ( ) ) ; assertNotSame ( STR_ , NUM_ , doc . getVersionCreateTime ( ) ) ; assertEquals ( STR_ , doc . getVersionCreateTime ( ) , doc . getEarliestVersionCreateTime ( ) ) ; assertEquals ( STR_ , doc . getVersionCreateTime ( ) , doc . getMetadataUpdateTime ( ) ) ; Map < String , Object > actual = doc . asMap ( ) ; assertEquals ( STR_ , id , actual . get ( FileMetadataSchema . ID ) ) ; assertEquals ( STR_ , version , actual . get ( FileMetadataSchema . VERSION ) ) ; assertEquals ( STR_ , STR_ , actual . get ( STR_ ) ) ; assertEquals ( STR_ , metadata . size ( ) , actual . size ( ) ) ; }
public static String rename ( String desc , String oldname , String newname ) { if ( desc . indexOf ( oldname ) < NUM_ ) return desc ; StringBuffer newdesc = new StringBuffer ( ) ; int head = NUM_ ; int i = NUM_ ; for ( ; ; ) { int j = desc . indexOf ( STR_ , i ) ; if ( j < NUM_ ) break ; else if ( desc . startsWith ( oldname , j + NUM_ ) && desc . charAt ( j + oldname . length ( ) + NUM_ ) == STR_ ) { newdesc . append ( desc . substring ( head , j ) ) ; newdesc . append ( STR_ ) ; newdesc . append ( newname ) ; newdesc . append ( STR_ ) ; head = i = j + oldname . length ( ) + NUM_ ; } else { i = desc . indexOf ( STR_ , j ) + NUM_ ; if ( i < NUM_ ) break ; } } if ( head == NUM_ ) return desc ; else { int len = desc . length ( ) ; if ( head < len ) newdesc . append ( desc . substring ( head , len ) ) ; return newdesc . toString ( ) ; } }
public void sort ( int attIndex ) { double [ ] vals = new double [ numInstances ( ) ] ; Instance [ ] backup = new Instance [ vals . length ] ; for ( int i = NUM_ ; i < vals . length ; i ++ ) { Instance inst = instance ( i ) ; backup [ i ] = inst ; double val = inst . value ( attIndex ) ; if ( Utils . isMissingValue ( val ) ) { vals [ i ] = Double . MAX_VALUE ; } else { vals [ i ] = val ; } } int [ ] sortOrder = Utils . sortWithNoMissingValues ( vals ) ; for ( int i = NUM_ ; i < vals . length ; i ++ ) { m_Instances . set ( i , backup [ sortOrder [ i ] ] ) ; } }
private static byte CallByteMethodV ( JNIEnvironment env , int objJREF , int methodID , Address argAddress ) throws Exception { if ( traceJNI ) VM . sysWrite ( STR_ ) ; RuntimeEntrypoints . checkJNICountDownToGC ( ) ; try { Object obj = env . getJNIRef ( objJREF ) ; Object returnObj = JNIHelpers . invokeWithVarArg ( obj , methodID , argAddress , TypeReference . Byte , BOOL_ ) ; return Reflection . unwrapByte ( returnObj ) ; } catch ( Throwable unexpected ) { if ( traceJNI ) unexpected . printStackTrace ( System . err ) ; env . recordException ( unexpected ) ; return NUM_ ; } }
public boolean adjustEntry ( E entry ) { final SpatialDirectoryEntry se = ( SpatialDirectoryEntry ) entry ; final ModifiableHyperBoundingBox mbr = computeMBR ( ) ; boolean changed = BOOL_ ; if ( se . hasMBR ( ) ) { final int dim = se . getDimensionality ( ) ; for ( int i = NUM_ ; i < dim ; i ++ ) { if ( Math . abs ( se . getMin ( i ) - mbr . getMin ( i ) ) > Float . MIN_NORMAL ) { changed = BOOL_ ; break ; } if ( Math . abs ( se . getMax ( i ) - mbr . getMax ( i ) ) > Float . MIN_NORMAL ) { changed = BOOL_ ; break ; } } } else { changed = BOOL_ ; } if ( changed ) { se . setMBR ( mbr ) ; } return changed ; }
private void traceObject ( ObjectReference object , boolean root ) { if ( VERBOSE ) { Trace . trace ( Item . SANITY , STR_ , ObjectModel . getString ( object ) ) ; } if ( object . isNull ( ) ) return ; boolean marked = blackSet . contains ( object ) ; if ( ! marked ) { blackSet . add ( object ) ; markStack . add ( object ) ; } visitor . visitObject ( object , root , marked ) ; }
private static int compare ( int fromIndex , CharSequence left , CharSequence right ) { if ( left == null ) return - NUM_ ; if ( right == null ) return NUM_ ; for ( int i = fromIndex , n = MathLib . min ( left . length ( ) , right . length ( ) ) ; i < n ; i ++ ) { char c1 = Character . toUpperCase ( left . charAt ( i ) ) ; char c2 = Character . toUpperCase ( right . charAt ( i ) ) ; if ( c1 != c2 ) return c1 - c2 ; } return left . length ( ) - right . length ( ) ; }
public boolean restoreAccessibilityFocus ( CalendarDay day ) { if ( ( day . year != mYear ) || ( day . month != mMonth ) || ( day . day > mNumCells ) ) { return BOOL_ ; } mTouchHelper . setFocusedVirtualView ( day . day ) ; return BOOL_ ; }
public DriverTask createVolumeClone ( List < VolumeClone > clones ) { LOG . info ( STR_ ) ; DellSCDriverTask task = new DellSCDriverTask ( STR_ ) ; StringBuilder errBuffer = new StringBuilder ( ) ; int createCount = NUM_ ; for ( VolumeClone clone : clones ) { try { StorageCenterAPI api = connectionManager . getConnection ( clone . getStorageSystemId ( ) ) ; ScReplay replay = null ; api . checkAndInitVolume ( clone . getParentId ( ) ) ; if ( clone . getSourceType ( ) == SourceType . SNAPSHOT ) { replay = api . getReplay ( clone . getParentId ( ) ) ; } else { replay = api . createReplay ( clone . getParentId ( ) , NUM_ ) ; } ScVolume scVol = api . createViewVolume ( clone . getDisplayName ( ) , replay . instanceId ) ; clone . setProvisionedCapacity ( SizeUtil . sizeStrToBytes ( scVol . configuredSize ) ) ; clone . setAllocatedCapacity ( NUM_ ) ; clone . setWwn ( scVol . deviceId ) ; clone . setNativeId ( scVol . instanceId ) ; clone . setDeviceLabel ( scVol . name ) ; clone . setAccessStatus ( AccessStatus . READ_WRITE ) ; clone . setReplicationState ( ReplicationState . SYNCHRONIZED ) ; createCount ++ ; } catch ( DellSCDriverException | StorageCenterAPIException dex ) { String error = String . format ( STR_ , clone . getParentId ( ) , dex ) ; errBuffer . append ( String . format ( STR_ , error ) ) ; } } task . setMessage ( errBuffer . toString ( ) ) ; if ( createCount == clones . size ( ) ) { task . setStatus ( TaskStatus . READY ) ; } else if ( createCount == NUM_ ) { task . setStatus ( TaskStatus . FAILED ) ; } else { task . setStatus ( TaskStatus . PARTIALLY_FAILED ) ; } return task ; }
@ Override public int hashCode ( ) { if ( hash == NUM_ ) { int result = NUM_ ; result = NUM_ . result + range . hashCode ( ) ; long bitsWeight = Double . doubleToLongBits ( weight ) ; result = NUM_ . result + ( int ) ( bitsWeight ^ ( bitsWeight > > > NUM_ ) ) ; hash = result ; } return hash ; }
@ Override public void onClick ( View v ) { int position = Math . min ( ( Integer ) v . getTag ( ) , mItemList . size ( ) - NUM_ ) ; mSelectedTracker = mItemList . get ( position ) ; mToggleConfigHandler . showForSelectedToggle ( ) ; mToggleConfigHandler . showAtLocation ( v ) ; mToggleConfigHandler . setArrowPosition ( v ) ; }
private int readFromDataSource ( byte [ ] target , int offset , int length , int bytesAlreadyRead , boolean allowEndOfInput ) throws InterruptedException , IOException { if ( Thread . interrupted ( ) ) { throw new InterruptedException ( ) ; } int bytesRead = dataSource . read ( target , offset + bytesAlreadyRead , length - bytesAlreadyRead ) ; if ( bytesRead == C . RESULT_END_OF_INPUT ) { if ( bytesAlreadyRead == NUM_ && allowEndOfInput ) { return C . RESULT_END_OF_INPUT ; } throw new EOFException ( ) ; } return bytesAlreadyRead + bytesRead ; }
public Explanation explain ( int doc , Explanation freq ) throws IOException { return Explanation . match ( score ( doc , freq . getValue ( ) ) , STR_ + doc + STR_ + freq . getValue ( ) + STR_ , Collections . singleton ( freq ) ) ; }
public static Stack < String > splitParts ( String name ) { while ( name . startsWith ( STR_ ) ) name = name . substring ( NUM_ ) ; Stack < String > parts = new Stack < > ( ) ; int last = NUM_ ; int pos = NUM_ ; String part ; while ( BOOL_ ) { pos = last ; while ( BOOL_ ) { pos = name . indexOf ( STR_ , pos ) ; if ( pos < NUM_ ) break ; if ( name . charAt ( pos - NUM_ ) == STR_ ) ++ pos ; else break ; } if ( pos < NUM_ ) break ; part = name . substring ( last , pos ) ; if ( ! part . endsWith ( STR_ ) ) part += STR_ ; parts . add ( part ) ; last = pos + NUM_ ; } part = name . substring ( last ) ; if ( ! part . endsWith ( STR_ ) ) part += STR_ ; parts . add ( part ) ; return parts ; }
public Set < SootMethod > collectSourceMethods ( ) { Set < SootMethod > result = new HashSet < SootMethod > ( ) ; for ( SourceCallChainInfo cci : entry_points ) { collectSourceMethods ( cci , result ) ; } return result ; }
public void testPrecisionAndScale ( ) throws Exception { testPrecisionForType ( STR_ , NUM_ , - NUM_ , BOOL_ ) ; testPrecisionForType ( STR_ , NUM_ , - NUM_ , BOOL_ ) ; testPrecisionForType ( STR_ , NUM_ , - NUM_ , BOOL_ ) ; testPrecisionForType ( STR_ , NUM_ , - NUM_ , BOOL_ ) ; testPrecisionForType ( STR_ , NUM_ , - NUM_ , BOOL_ ) ; testPrecisionForType ( STR_ , NUM_ , - NUM_ , BOOL_ ) ; testPrecisionForType ( STR_ , NUM_ , - NUM_ , BOOL_ ) ; testPrecisionForType ( STR_ , NUM_ , - NUM_ , BOOL_ ) ; testPrecisionForType ( STR_ , NUM_ , - NUM_ , BOOL_ ) ; testPrecisionForType ( STR_ , NUM_ , - NUM_ , BOOL_ ) ; testPrecisionForType ( STR_ , NUM_ , NUM_ , BOOL_ ) ; testPrecisionForType ( STR_ , NUM_ , NUM_ , BOOL_ ) ; testPrecisionForType ( STR_ , NUM_ , NUM_ , BOOL_ ) ; testPrecisionForType ( STR_ , NUM_ , NUM_ , BOOL_ ) ; testPrecisionForType ( STR_ , NUM_ , NUM_ , BOOL_ ) ; testPrecisionForType ( STR_ , NUM_ , NUM_ , BOOL_ ) ; testPrecisionForType ( STR_ , NUM_ , NUM_ , BOOL_ ) ; testPrecisionForType ( STR_ , NUM_ , NUM_ , BOOL_ ) ; }
public void register ( NamedBean s ) { String systemName = s . getSystemName ( ) ; _tsys . put ( systemName , s ) ; String userName = s . getUserName ( ) ; if ( userName != null ) { _tuser . put ( userName , s ) ; } firePropertyChange ( STR_ , null , Integer . valueOf ( _tsys . size ( ) ) ) ; s . addPropertyChangeListener ( this , STR_ , STR_ ) ; }
public V put ( final K k , final V v ) { final WeakReference < V > ref = newWeakRef ( k , v , referenceQueue ) ; final WeakReference < V > oldRef = map . put ( k , ref ) ; final V oldVal = oldRef == null ? null : oldRef . get ( ) ; if ( queue . add ( v ) && DEBUG ) { log . debug ( STR_ + k + STR_ + v ) ; } didUpdate ( k , ref , oldRef ) ; return oldVal ; }
public static < V > boolean addListNotNullValue ( List < V > sourceList , V value ) { return ( sourceList != null && value != null ) ? sourceList . add ( value ) : BOOL_ ; }
public void delete ( int key ) { int i = ContainerHelpers . binarySearch ( mKeys , mSize , key ) ; if ( i >= NUM_ ) { System . arraycopy ( mKeys , i + NUM_ , mKeys , i , mSize - ( i + NUM_ ) ) ; System . arraycopy ( mValues , i + NUM_ , mValues , i , mSize - ( i + NUM_ ) ) ; mSize -- ; } }
public static void keepAlive ( final boolean keepAlive ) { setProperty ( STR_ , Boolean . toString ( keepAlive ) ) ; }
public PageObjectContext peek ( ) { return deque . peek ( ) ; }
protected void writeNamespace ( String prefix , String uri ) throws IOException { if ( ( prefix != null ) && ( prefix . length ( ) > NUM_ ) ) { writer . write ( STR_ ) ; writer . write ( prefix ) ; writer . write ( STR_ ) ; } else { writer . write ( STR_ ) ; } writer . write ( uri ) ; writer . write ( STR_ ) ; }
public static void waitSomeTime ( int seconds ) { try { Thread . sleep ( seconds . NUM_ ) ; } catch ( InterruptedException e ) { } }
public void encode ( String value , ByteBuffer buffer ) throws BufferOverflowException { if ( value == null ) { buffer . put ( ( byte ) ( x80 ) ) ; return ; } int charCount = value . length ( ) ; if ( charCount == NUM_ ) { buffer . put ( ( byte ) ( NUM_ | x80 ) ) ; return ; } int position = buffer . position ( ) ; boolean ascii = BOOL_ ; if ( charCount > NUM_ ) { for ( int i = NUM_ ; i < charCount ; i ++ ) { int c = value . charAt ( i ) ; if ( c > NUM_ ) { ascii = BOOL_ ; break ; } buffer . put ( ( byte ) c ) ; } } else { ascii = BOOL_ ; } if ( ascii ) { position = buffer . position ( ) ; buffer . put ( position - NUM_ , ( byte ) ( buffer . get ( position - NUM_ ) | x80 ) ) ; } else { buffer . position ( position ) ; writeLength ( charCount + NUM_ , buffer ) ; int charIndex = NUM_ ; for ( ; charIndex < charCount ; charIndex ++ ) { int c = value . charAt ( charIndex ) ; if ( c > NUM_ ) break ; buffer . put ( ( byte ) c ) ; } writeUTF8String ( value , charCount , charIndex , buffer ) ; } }
public void testBug71672Statement ( int testStep , Connection testConn , String query , int expectedUpdateCount , int [ ] expectedKeys ) throws SQLException { Statement testStmt = testConn . createStatement ( ) ; if ( expectedUpdateCount < NUM_ ) { assertFalse ( testStep + STR_ , testStmt . execute ( query , Statement . RETURN_GENERATED_KEYS ) ) ; } else { assertEquals ( testStep + STR_ , expectedUpdateCount , testStmt . executeUpdate ( query , Statement . RETURN_GENERATED_KEYS ) ) ; } ResultSet testRS = testStmt . getGeneratedKeys ( ) ; for ( int k : expectedKeys ) { assertTrue ( testStep + STR_ , testRS . next ( ) ) ; assertEquals ( testStep + STR_ , k , testRS . getInt ( NUM_ ) ) ; } assertFalse ( testStep + STR_ , testRS . next ( ) ) ; testRS . close ( ) ; testStmt . close ( ) ; }
public static PathImpl lookup ( String url ) { PathImpl pwd = getPwd ( ) ; if ( ! url . startsWith ( STR_ ) ) { return pwd . lookup ( url , null ) ; } else { return PWD . lookup ( url , null ) ; } }
public static XMLGregorianCalendar now ( ) { return getXMLGregorianCalendarValue ( null ) ; }
protected void addScalarDimension ( int i ) { for ( Dimension dimension : dimensionList ) { if ( dimension . getDimension ( ) == i ) { return ; } } dimensionList . add ( new Dimension ( i ) ) ; }
public void initialize ( ) { TextureState ts = new TextureState ( ) ; ts . setEnabled ( BOOL_ ) ; setRenderState ( ts ) ; for ( int i = NUM_ ; i < lineSetList . size ( ) ; ++ i ) { LineSetState state = lineSetList . get ( i ) ; addLineSet ( state , BOOL_ ) ; } zBufferState = new ZBufferState ( ) ; zBufferState . setFunction ( ZBufferState . TestFunction . LessThanOrEqualTo ) ; zBufferState . setEnabled ( BOOL_ ) ; setRenderState ( zBufferState ) ; }
protected boolean regExpRegionMatches ( String text , int tStart , String p , int pStart , int plen ) { while ( plen -- > NUM_ ) { char tchar = text . charAt ( tStart ++ ) ; char pchar = p . charAt ( pStart ++ ) ; if ( ! this . fIgnoreWildCards ) { if ( pchar == fSingleWildCard ) { continue ; } } if ( pchar == tchar ) { continue ; } if ( this . fIgnoreCase ) { if ( Character . toUpperCase ( tchar ) == Character . toUpperCase ( pchar ) ) { continue ; } if ( Character . toLowerCase ( tchar ) == Character . toLowerCase ( pchar ) ) { continue ; } } return BOOL_ ; } return BOOL_ ; }
public static void initKeys ( KeyStore keystore , Properties props ) { if ( props . containsKey ( Configuration . WEBCALL_KAFKA_AES ) ) { byte [ ] key = keystore . decodeKey ( props . getProperty ( Configuration . WEBCALL_KAFKA_AES ) ) ; Preconditions . checkArgument ( ( NUM_ == key . length || NUM_ == key . length || NUM_ == key . length ) , Configuration . WEBCALL_KAFKA_AES + STR_ ) ; keystore . setKey ( KeyStore . AES_KAFKA_WEBCALL , key ) ; aesKey = key ; } if ( props . containsKey ( Configuration . WEBCALL_KAFKA_MAC ) ) { byte [ ] key = keystore . decodeKey ( props . getProperty ( Configuration . WEBCALL_KAFKA_MAC ) ) ; Preconditions . checkArgument ( ( NUM_ == key . length ) , Configuration . WEBCALL_KAFKA_MAC + STR_ ) ; keystore . setKey ( KeyStore . SIPHASH_KAFKA_WEBCALL , key ) ; siphashKey = key ; } }
public static boolean isEmpty ( StringBuilder str ) { return isNull ( str ) || str . length ( ) <= NUM_ ; }
public static Gas register ( Gas gas ) { if ( gas == null ) { return null ; } registeredGasses . add ( gas ) ; return getGas ( gas . getName ( ) ) ; }
@ Override public boolean lock ( ) { try { lockPath = zk . create ( this . lockTypeFolder + CarbonCommonConstants . FILE_SEPARATOR + lockName , null , Ids . OPEN_ACL_UNSAFE , CreateMode . EPHEMERAL_SEQUENTIAL ) ; List < String > nodes = zk . getChildren ( this . lockTypeFolder , null ) ; Collections . sort ( nodes ) ; if ( lockPath . endsWith ( nodes . get ( NUM_ ) ) ) { return BOOL_ ; } else { zk . delete ( lockPath , - NUM_ ) ; return BOOL_ ; } } catch ( KeeperException | InterruptedException e ) { LOGGER . error ( e , e . getMessage ( ) ) ; return BOOL_ ; } }
@ Override protected void keyTyped ( char par1 , int par2 ) { tokenBox . textboxKeyTyped ( par1 , par2 ) ; if ( par2 == NUM_ || par2 == NUM_ ) actionPerformed ( ( GuiButton ) buttonList . get ( NUM_ ) ) ; }
private static Boolean isAlphanumeric ( final String label ) { boolean status = BOOL_ ; if ( StringUtils . isNotEmpty ( label ) ) { Matcher matcher = patternAlphanumeric . matcher ( label ) ; status = matcher . matches ( ) ; } return status ; }
final static String trimURISubstring ( URL src , String sub ) { final String s = src . toExternalForm ( ) ; final int endIndex = s . lastIndexOf ( sub ) ; final String t = s . substring ( NUM_ , endIndex ) ; return t ; }
@ Override public String globalInfo ( ) { return STR_ + STR_ + STR_ ; }
public static void silentCloseInputStream ( InputStream is ) { try { if ( is != null ) { is . close ( ) ; } } catch ( IOException e ) { Log . w ( LOG_TAG , STR_ , e ) ; } }
public boolean removeRow ( int row ) { if ( m_rows . isValidRow ( row ) ) { fireTableEvent ( row , row , TableModelEvent . ALL_COLUMNS , TableModelEvent . DELETE ) ; m_tuples . invalidate ( row ) ; m_rows . releaseRow ( row ) ; for ( Iterator cols = getColumns ( ) ; cols . hasNext ( ) ; ) { Column c = ( Column ) cols . next ( ) ; c . revertToDefault ( row ) ; } return BOOL_ ; } return BOOL_ ; }
void addFillComponents ( Container panel , int [ ] cols , int [ ] rows ) { Dimension filler = new Dimension ( NUM_ , NUM_ ) ; boolean filled_cell_11 = BOOL_ ; CellConstraints cc = new CellConstraints ( ) ; if ( cols . length > NUM_ && rows . length > NUM_ ) { if ( cols [ NUM_ ] == NUM_ && rows [ NUM_ ] == NUM_ ) { panel . add ( Box . createRigidArea ( filler ) , cc . xy ( NUM_ , NUM_ ) ) ; filled_cell_11 = BOOL_ ; } } for ( int index = NUM_ ; index < cols . length ; index ++ ) { if ( cols [ index ] == NUM_ && filled_cell_11 ) { continue ; } panel . add ( Box . createRigidArea ( filler ) , cc . xy ( cols [ index ] , NUM_ ) ) ; } for ( int index = NUM_ ; index < rows . length ; index ++ ) { if ( rows [ index ] == NUM_ && filled_cell_11 ) { continue ; } panel . add ( Box . createRigidArea ( filler ) , cc . xy ( NUM_ , rows [ index ] ) ) ; } }
private boolean isParsableToDouble ( String i ) { return i . matches ( STR_ ) ; }
protected String [ ] initPathsFromProperties ( String rawPaths ) { String [ ] retPaths = null ; if ( rawPaths != null ) { try { StringTokenizer token = new StringTokenizer ( rawPaths , File . pathSeparator ) ; int numPaths = token . countTokens ( ) ; retPaths = new String [ numPaths ] ; for ( int i = NUM_ ; i < numPaths ; i ++ ) { retPaths [ i ] = token . nextToken ( ) ; } return retPaths ; } catch ( java . util . NoSuchElementException e ) { e . printStackTrace ( ) ; } } return retPaths ; }
private float colorToAngle ( int color ) { float [ ] colors = new float [ NUM_ ] ; Color . colorToHSV ( color , colors ) ; return ( float ) Math . toRadians ( - colors [ NUM_ ] ) ; }
private void registerDefaultValidatorIds ( Application application , LinkedHashSet < String > defaultValidatorIds ) { if ( defaultValidatorIds == null ) { defaultValidatorIds = new LinkedHashSet < > ( ) ; if ( isBeanValidatorAvailable ( ) ) { WebConfiguration webConfig = WebConfiguration . getInstance ( ) ; if ( ! webConfig . isOptionEnabled ( WebConfiguration . BooleanWebContextInitParameter . DisableDefaultBeanValidator ) ) { defaultValidatorIds . add ( BeanValidator . VALIDATOR_ID ) ; } } } for ( String validatorId : defaultValidatorIds ) { if ( LOGGER . isLoggable ( Level . FINE ) ) { LOGGER . log ( Level . FINE , MessageFormat . format ( STR_ , validatorId ) ) ; } application . addDefaultValidatorId ( validatorId ) ; } }
protected void initializeLocation ( V v , Point2D coord ) { Point point = locations . get ( v ) ; coord . setLocation ( point . x , point . y ) ; }
public static Date parseDate ( String dateStr ) { String formatString = STR_ ; if ( dateStr . length ( ) == NUM_ ) dateStr = dateStr . substring ( NUM_ , NUM_ ) ; if ( dateStr . length ( ) == NUM_ ) formatString = STR_ ; if ( dateStr . length ( ) == NUM_ ) formatString = STR_ ; SimpleDateFormat formatter = new SimpleDateFormat ( formatString ) ; ParsePosition pos = new ParsePosition ( NUM_ ) ; return formatter . parse ( dateStr , pos ) ; }
@ SuppressWarnings ( STR_ ) private void doUnload ( MarkedProject markedProject , N4ProgressStateRecorder rec ) throws N4JSCompileErrorException { if ( createDebugOutput ) { println ( STR_ + markedProject . project ) ; } rec . markStartUnloading ( markedProject ) ; for ( Resource res : markedProject . resources ) { rec . markUnloadingOf ( res ) ; res . unload ( ) ; } rec . markFinishedUnloading ( markedProject ) ; }
public void parseLib ( Map < String , Object > dataModel , String fullText ) throws ParseException { Matcher m ; fullText = tmplHelper . normalizeText ( fullText ) ; m = commentPat . matcher ( fullText ) ; if ( ! m . find ( ) ) { throw new ParseException ( STR_ ) ; } String introText = tmplHelper . stripCommentLeadingAsterix ( tmplHelper . cleanTextValue ( m . group ( NUM_ ) ) ) ; dataModel . put ( STR_ , introText ) ; Matcher introm = tmplHelper . getFirstLineMatcher ( introText ) ; if ( introm . matches ( ) ) { dataModel . put ( STR_ , tmplHelper . cleanTextValue ( introm . group ( NUM_ ) ) ) ; dataModel . put ( STR_ , tmplHelper . cleanTextValue ( introm . group ( NUM_ ) ) ) ; } String currentSectionName = STR_ ; Map < String , Object > sectionInfo = makeObjectMap ( ) ; sectionInfo . put ( STR_ , currentSectionName ) ; sectionInfo . put ( STR_ , null ) ; sectionInfo . put ( STR_ , STR_ ) ; sectionInfo . put ( STR_ , STR_ ) ; Map < String , Map < String , Object > > sectionEntryMap = makeDataMap ( ) ; sectionInfo . put ( STR_ , sectionEntryMap ) ; Map < String , Map < String , Object > > entryMap = makeDataMap ( ) ; Map < String , Map < String , Object > > sectionMap = makeDataMap ( ) ; sectionMap . put ( STR_ , sectionInfo ) ; while ( m . find ( ) ) { String comment = tmplHelper . cleanTextValue ( m . group ( NUM_ ) ) ; Matcher subm ; subm = sectionPat . matcher ( comment ) ; if ( subm . matches ( ) ) { currentSectionName = tmplHelper . cleanTextValue ( subm . group ( NUM_ ) ) ; sectionInfo = makeObjectMap ( ) ; sectionInfo . put ( STR_ , currentSectionName ) ; sectionInfo . put ( STR_ , currentSectionName ) ; sectionInfo . put ( STR_ , STR_ ) ; sectionInfo . put ( STR_ , tmplHelper . cleanTextValue ( tmplHelper . stripCommentLeadingAsterix ( subm . group ( NUM_ ) ) ) ) ; sectionEntryMap = makeDataMap ( ) ; sectionInfo . put ( STR_ , sectionEntryMap ) ; sectionMap . put ( currentSectionName , sectionInfo ) ; } else { subm = entryPat . matcher ( comment ) ; if ( subm . matches ( ) ) { String entryTitle = tmplHelper . cleanTextValue ( subm . group ( NUM_ ) ) ; String entryBody = tmplHelper . cleanTextValue ( subm . group ( NUM_ ) ) ; String postEntryText = fullText . substring ( m . end ( ) ) ; try { Map < String , Object > entryInfo = parseEntry ( entryTitle , entryBody , postEntryText ) ; entryInfo . put ( STR_ , currentSectionName ) ; String entryName = ( String ) entryInfo . get ( STR_ ) ; if ( entryName == null || entryName . isEmpty ( ) ) { throw new ParseException ( STR_ ) ; } if ( entryMap . containsKey ( entryName ) ) { throw new ParseException ( STR_ + entryName ) ; } entryMap . put ( entryName , entryInfo ) ; sectionEntryMap . put ( entryName , entryInfo ) ; } catch ( ParseException e ) { throw new ParseException ( STR_ + entryTitle + STR_ + e . getMessage ( ) , e ) ; } } else { ; } } } msgHandler . logInfo ( STR_ + entryMap . size ( ) + STR_ + sectionMap . size ( ) ) ; dataModel . put ( STR_ , sectionMap ) ; dataModel . put ( STR_ , entryMap ) ; }
public void writeFile ( ArrayList < DccLocoAddress > consistList , String fileName ) throws IOException { Element root = new Element ( STR_ ) ; Document doc = newDocument ( root , dtdLocation + STR_ ) ; Map < String , String > m = new HashMap < String , String > ( ) ; m . put ( STR_ , STR_ ) ; m . put ( STR_ , xsltLocation + STR_ ) ; ProcessingInstruction p = new ProcessingInstruction ( STR_ , m ) ; doc . addContent ( NUM_ , p ) ; Element roster = new Element ( STR_ ) ; for ( int i = NUM_ ; i < consistList . size ( ) ; i ++ ) { Consist newConsist = consistMan . getConsist ( consistList . get ( i ) ) ; roster . addContent ( consistToXml ( newConsist ) ) ; } root . addContent ( roster ) ; try { if ( ! checkFile ( fileName ) ) { File file = new File ( fileName ) ; File parentDir = file . getParentFile ( ) ; if ( ! parentDir . exists ( ) ) { if ( ! parentDir . mkdir ( ) ) { throw ( new IOException ( ) ) ; } } if ( ! file . createNewFile ( ) ) { throw ( new IOException ( ) ) ; } } writeXML ( findFile ( fileName ) , doc ) ; } catch ( IOException ioe ) { log . error ( STR_ + ioe ) ; throw ( ioe ) ; } }
public void train ( Reader aReader ) throws IOException { BufferedReader in = new BufferedReader ( aReader ) ; String line = in . readLine ( ) ; while ( line != null ) { Matcher m = WORD_PATTERN . matcher ( line . toLowerCase ( ) ) ; while ( m . find ( ) ) { String word = m . group ( ) ; AtomicInteger count = nWords . get ( word ) ; if ( count == null ) { count = new AtomicInteger ( NUM_ ) ; nWords . put ( word , count ) ; } count . incrementAndGet ( ) ; } line = in . readLine ( ) ; } }
private void startClient ( ) { if ( flumeClient != null && ! flumeClient . isActive ( ) ) { flumeClient . close ( ) ; flumeClient = null ; } if ( flumeClient == null ) { try { flumeClient = RpcClientFactory . getDefaultInstance ( flumeHostName , flumePort , maxSpanBatchSize ) ; } catch ( FlumeException e ) { LOG . warn ( STR_ + e . getMessage ( ) ) ; } } }
public void vspan ( long start , long end , Paint color , String legend ) { LegendText legendText = new LegendText ( color , legend ) ; comments . add ( legendText ) ; plotElements . add ( new VSpan ( start , end , color , legendText ) ) ; }
public void onDraw ( Canvas canvas , int centerX , int centerY ) { if ( ! mVisible ) { return ; } mArcBounds = new RectF ( centerX - mProgressRadius , centerY - mProgressRadius , centerX + mProgressRadius , centerY + mProgressRadius ) ; canvas . drawCircle ( centerX , centerY , mProgressRadius , mProgressBasePaint ) ; canvas . drawArc ( mArcBounds , - NUM_ , mProgressAngleDegrees , BOOL_ , mProgressPaint ) ; if ( mProgressAngleDegrees == NUM_ && System . currentTimeMillis ( ) > mTimeToHide ) { mVisible = BOOL_ ; if ( mVisibilityListener != null ) { mVisibilityListener . onHidden ( ) ; } } }
private void removeItemAtInt ( int index , boolean updateChildrenOnMenuViews ) { if ( ( index < NUM_ ) || ( index >= mItems . size ( ) ) ) return ; mItems . remove ( index ) ; if ( updateChildrenOnMenuViews ) onItemsChanged ( BOOL_ ) ; }
public static byte [ ] decode ( String s ) { return decode ( s . toCharArray ( ) ) ; }
public boolean check ( ) { return ( m_File != null ) && ( m_Handler != null ) && m_File . exists ( ) ; }
public static List < Long > zScoreTest ( GeoTimeSerie gts , boolean useMedian , double d ) throws WarpScriptException { doubleCheck ( gts ) ; List < Long > anomalous_ticks = new ArrayList < Long > ( ) ; double [ ] musigma = madsigma ( gts , useMedian ) ; double m = musigma [ NUM_ ] ; double std = musigma [ NUM_ ] ; if ( NUM_ == std ) { return anomalous_ticks ; } for ( int i = NUM_ ; i < gts . values ; i ++ ) { double z = ( gts . doubleValues [ i ] - m ) / std ; if ( Math . abs ( z ) >= d ) { anomalous_ticks . add ( gts . ticks [ i ] ) ; } } return anomalous_ticks ; }
private void append ( PrintWriter pw , final String k , final String v ) { if ( v != null ) { pw . println ( k + STR_ + v ) ; } }
default B withDefault ( String key , Object value ) { return withDefault ( key , value != null ? value . toString ( ) : null ) ; }
public void testMultiplyDiffScalePosNeg ( ) { String a = STR_ ; int aScale = NUM_ ; String b = STR_ ; int bScale = - NUM_ ; String c = STR_ ; int cScale = NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal bNumber = new BigDecimal ( new BigInteger ( b ) , bScale ) ; BigDecimal result = aNumber . multiply ( bNumber ) ; assertEquals ( STR_ , c , result . toString ( ) ) ; assertEquals ( STR_ , cScale , result . scale ( ) ) ; }
private void skipWhitespace ( ) { matcher . usePattern ( WHITESPACE ) ; if ( matcher . lookingAt ( ) ) { matcher . region ( matcher . end ( ) , matcher . regionEnd ( ) ) ; } }
protected void createDynamicStyleForComponents ( final TextField tagName , final TextArea tagDesc , final String taregtTagColor ) { tagName . removeStyleName ( SPUIDefinitions . TAG_NAME ) ; tagDesc . removeStyleName ( SPUIDefinitions . TAG_DESC ) ; getTargetDynamicStyles ( taregtTagColor ) ; tagName . addStyleName ( TAG_NAME_DYNAMIC_STYLE ) ; tagDesc . addStyleName ( TAG_DESC_DYNAMIC_STYLE ) ; }
public void calculate_scores ( ) { score = NUM_ ; if ( contents . length == NUM_ ) { API api = API . v ( ) ; Set < InfoKind > source = api . getSourceInfoKinds ( method ) ; Set < InfoKind > sink = api . getSinkInfoKinds ( method ) ; if ( is_system ( method ) ) { if ( api . isSafeMethod ( method ) ) score = NUM_ ; else if ( api . isSpecMethod ( method ) ) score = NUM_ ; else if ( api . isBannedMethod ( method ) ) score = NUM_ ; if ( ! source . isEmpty ( ) ) score += NUM_ ; else if ( ! sink . isEmpty ( ) ) score += NUM_ ; } return ; } for ( CallChainInfo cci : contents ) { cci . calculate_scores ( ) ; calls += cci . calls ; syscalls += cci . syscalls ; if ( cci . score > score ) score = cci . score ; } }
public < T > JsonArray < T > createListDtoFromJson ( String json , Class < T > dtoInterface ) { final DtoProvider < T > dtoProvider = getDtoProvider ( dtoInterface ) ; final List < JsonElement > list = gson . fromJson ( json , listTypeCache . getUnchecked ( JsonElement . class ) ) ; final List < T > result = new ArrayList < > ( list . size ( ) ) ; for ( JsonElement e : list ) { result . add ( dtoProvider . fromJson ( e ) ) ; } return new JsonArrayImpl < > ( result ) ; }
public void startConsumption ( MultiThreadedBatchProcessor < T , TL > processor ) ;
public static long longForQuery ( SQLiteDatabase db , String query , String [ ] selectionArgs ) { SQLiteStatement prog = db . compileStatement ( query ) ; try { return longForQuery ( prog , selectionArgs ) ; } finally { prog . close ( ) ; } }
public void testOneOne ( ) { String numA = STR_ ; String numB = STR_ ; String res = STR_ ; BigInteger aNumber = new BigInteger ( numA ) ; BigInteger bNumber = new BigInteger ( numB ) ; BigInteger result = aNumber . xor ( bNumber ) ; assertTrue ( res . equals ( result . toString ( ) ) ) ; }
public String toString ( ) { String s = STR_ + ids . toString ( ) + STR_ ; return ( s ) ; }
@ Override public void remove ( String ... identifiers ) { whitelist . removeAll ( Arrays . asList ( identifiers ) ) ; }
public static byte [ ] checkTlsPreMasterSecretKey ( int clientVersion , int serverVersion , SecureRandom random , byte [ ] encoded , boolean isFailOver ) { if ( random == null ) { random = JCAUtil . getSecureRandom ( ) ; } byte [ ] replacer = new byte [ NUM_ ] ; random . nextBytes ( replacer ) ; if ( ! isFailOver && ( encoded != null ) ) { if ( encoded . length != NUM_ ) { return replacer ; } int encodedVersion = ( ( encoded [ NUM_ ] & xFF ) << NUM_ ) | ( encoded [ NUM_ ] & xFF ) ; if ( clientVersion != encodedVersion ) { if ( clientVersion > x0301 || serverVersion != encodedVersion ) { encoded = replacer ; } } return encoded ; } return replacer ; }
public Commafier ( final String initial ) { m_separator = DEFAULT_SEPARATOR ; sb . append ( initial ) ; }
public void write ( File file ) throws IOException { PrintWriter pw = new PrintWriter ( new OutputStreamWriter ( new FileOutputStream ( file ) , STR_ ) , BOOL_ ) ; if ( fromDir != null ) { pw . println ( STR_ + fromDir + STR_ + fromExt ) ; } String str = null ; for ( int i = NUM_ ; i < bList . size ( ) ; i ++ ) { str = ( String ) ( bList . elementAt ( i ) ) ; pw . println ( str ) ; } }
private void log ( IStatus status ) { ResourcesPlugin . log ( status ) ; }
static private StringBuilder replace ( StringBuilder input , java . util . regex . Pattern pattern , String replacement ) { java . util . regex . Matcher m = pattern . matcher ( input ) ; while ( m . find ( ) ) { if ( isEscapedChar ( input . toString ( ) , m . start ( ) ) ) { continue ; } input . replace ( m . start ( ) , m . end ( ) , replacement ) ; m . reset ( input ) ; } return input ; }
public static MultisigAggregateModificationTransaction createMultisigModification ( ) { return new MultisigAggregateModificationTransaction ( TimeInstant . ZERO , Utils . generateRandomAccount ( ) , Collections . singletonList ( new MultisigCosignatoryModification ( MultisigModificationType . AddCosignatory , Utils . generateRandomAccount ( ) ) ) ) ; }
public static boolean isJarCacheEnabledDefault ( ) { return _isJarCacheEnabled ; }
public void test_write_flush_update ( ) { final Journal store = ( Journal ) getStore ( ) ; try { RWStrategy bufferStrategy = ( RWStrategy ) store . getBufferStrategy ( ) ; final int nbytes = NUM_ ; byte [ ] a = new byte [ nbytes ] ; r . nextBytes ( a ) ; final long addr = bufferStrategy . write ( ByteBuffer . wrap ( a ) ) ; assertEquals ( nbytes , store . getByteCount ( addr ) ) ; store . commit ( ) ; { final ByteBuffer b = bufferStrategy . read ( addr ) ; assertNotNull ( b ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { assertEquals ( STR_ + i , a [ i ] , b . get ( i ) ) ; } } } finally { store . destroy ( ) ; } }
public static void copy ( long [ ] src , int srcOffset , long [ ] dst , int dstOffset , int len ) { int srcLimit = srcOffset + len ; while ( srcOffset < srcLimit ) { int srcIdx = srcOffset & NUM_ ; int dstIdx = dstOffset & NUM_ ; int srcRemainder = NUM_ - srcIdx ; int dstRemainder = NUM_ - dstIdx ; int chunkLen = Math . min ( srcRemainder , dstRemainder ) ; long mask = maskBelow ( chunkLen ) << srcIdx ; dst [ dstOffset > > NUM_ ] |= ( ( src [ srcOffset > > NUM_ ] & mask ) > > > srcIdx ) << dstOffset ; srcOffset += chunkLen ; dstOffset += chunkLen ; } }
public static int SAVED_XERROR_HANDLER ( long display , XErrorEvent error ) { if ( saved_error_handler != NUM_ ) { } if ( log . isLoggable ( PlatformLogger . Level . FINE ) ) { log . fine ( STR_ + STR_ + error . get_resourceid ( ) + STR_ + STR_ + error . get_serial ( ) + STR_ + STR_ + error . get_error_code ( ) + STR_ + STR_ + error . get_request_code ( ) + STR_ + STR_ + error . get_minor_code ( ) ) ; } return NUM_ ; }
protected int inBorder ( int x , int y ) { Border b = getBorder ( ) ; if ( b == null ) { return UNDEF ; } Insets i = b . getBorderInsets ( this ) ; if ( x <= i . left ) { return DOCK_WEST ; } if ( x >= getWidth ( ) - i . right ) { return DOCK_EAST ; } if ( y <= i . top ) { return DOCK_NORTH ; } if ( y >= getHeight ( ) - i . bottom ) { return DOCK_SOUTH ; } return UNDEF ; }
public WallForce ( float gravConst , float x1 , float y1 , float x2 , float y2 ) { params = new float [ ] { gravConst } ; minValues = new float [ ] { DEFAULT_MIN_GRAV_CONSTANT } ; maxValues = new float [ ] { DEFAULT_MAX_GRAV_CONSTANT } ; this . x1 = x1 ; this . y1 = y1 ; this . x2 = x2 ; this . y2 = y2 ; dx = x2 - x1 ; dy = y2 - y1 ; float r = ( float ) Math . sqrt ( dx . dx + dy . dy ) ; if ( dx != NUM_ ) dx /= r ; if ( dy != NUM_ ) dy /= r ; }
public static void writeLn ( final OutputStream out ) throws IOException { out . write ( LS_BYTES ) ; }
public static boolean isSystemApplication ( Context context ) { if ( context == null ) { return BOOL_ ; } return isSystemApplication ( context , context . getPackageName ( ) ) ; }
public void testPosZero ( ) { String numA = STR_ ; String numB = STR_ ; String res = STR_ ; BigInteger aNumber = new BigInteger ( numA ) ; BigInteger bNumber = new BigInteger ( numB ) ; BigInteger result = aNumber . xor ( bNumber ) ; assertTrue ( res . equals ( result . toString ( ) ) ) ; }
private static void initializeReleasePlatform ( ) { String platformProperty = readConfigProperty ( PLATFORM_PROPERTIES , PLATFORM_PROPERTY_KEY ) ; if ( platformProperty == null ) { logInfo ( STR_ ) ; } else { currentPlatform = Platform . valueOf ( platformProperty . toUpperCase ( Locale . UK ) ) ; logInfo ( STR_ + currentPlatform ) ; } }
public static boolean isEmpty ( CharSequence str ) { if ( str == null || str . length ( ) == NUM_ ) { return BOOL_ ; } else { return BOOL_ ; } }
@ Override public FSDataInputStream open ( Path path , int bufferSize ) throws IOException { String table = getTableName ( _rootPath , path ) ; String split = getSplitName ( _rootPath , path ) ; split = splitNameWithoutGzipExtension ( split ) ; return new FSDataInputStream ( new EmoSplitInputStream ( table , split ) ) ; }
public void simulateMethod ( SootMethod method , ReferenceVariable thisVar , ReferenceVariable returnVar , ReferenceVariable params [ ] ) { String subSignature = method . getSubSignature ( ) ; if ( subSignature . equals ( STR_ ) ) { java_lang_ClassLoader_defineClass0 ( method , thisVar , returnVar , params ) ; return ; } else if ( subSignature . equals ( STR_ ) ) { java_lang_ClassLoader_findBootstrapClass ( method , thisVar , returnVar , params ) ; return ; } else if ( subSignature . equals ( STR_ ) ) { java_lang_ClassLoader_findLoadedClass ( method , thisVar , returnVar , params ) ; return ; } else if ( subSignature . equals ( STR_ ) ) { java_lang_ClassLoader_getCallerClassLoader ( method , thisVar , returnVar , params ) ; return ; } else { defaultMethod ( method , thisVar , returnVar , params ) ; return ; } }
public static final String extractIplIdentityHostFrimwareRev ( LocoNetMessage m ) { StringBuilder s = new StringBuilder ( ) ; s . append ( Integer . toString ( ( m . getElement ( NUM_ ) & x78 ) > > NUM_ ) ) ; s . append ( STR_ ) ; s . append ( Integer . toString ( ( m . getElement ( NUM_ ) & x07 ) ) ) ; return s . toString ( ) ; }
private void grow ( ) { if ( keys == null || nkeys >= keys . length ) { String [ ] nk = new String [ nkeys + NUM_ ] ; String [ ] nv = new String [ nkeys + NUM_ ] ; if ( keys != null ) System . arraycopy ( keys , NUM_ , nk , NUM_ , nkeys ) ; if ( values != null ) System . arraycopy ( values , NUM_ , nv , NUM_ , nkeys ) ; keys = nk ; values = nv ; } }
private List < T > filter ( final Collection < T > collection ) { final List < T > nullFreeList = new ArrayList < T > ( ) ; if ( collection != null ) { for ( final T item : collection ) { if ( item != null ) { nullFreeList . add ( item ) ; } } } return nullFreeList ; }
public boolean isSystemClass ( SootClass clz ) { return allSystemClasses . contains ( clz ) ; }
private byte [ ] tryDecodeHostToIp ( String host ) { if ( host . startsWith ( STR_ ) && host . endsWith ( STR_ ) ) { return tryDecodeHostToIPv6 ( host ) ; } return tryDecodeHostToIPv4 ( host ) ; }
private void updateBaseMatrix ( Drawable d ) { ImageView imageView = getImageView ( ) ; if ( null == imageView || null == d ) { return ; } final float viewWidth = getImageViewWidth ( imageView ) ; final float viewHeight = getImageViewHeight ( imageView ) ; final int drawableWidth = d . getIntrinsicWidth ( ) ; final int drawableHeight = d . getIntrinsicHeight ( ) ; mBaseMatrix . reset ( ) ; final float widthScale = viewWidth / drawableWidth ; final float heightScale = viewHeight / drawableHeight ; if ( mScaleType == ScaleType . CENTER ) { mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth ) / NUM_ , ( viewHeight - drawableHeight ) / NUM_ ) ; } else if ( mScaleType == ScaleType . CENTER_CROP ) { float scale = Math . max ( widthScale , heightScale ) ; mBaseMatrix . postScale ( scale , scale ) ; mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth . scale ) / NUM_ , ( viewHeight - drawableHeight . scale ) / NUM_ ) ; } else if ( mScaleType == ScaleType . CENTER_INSIDE ) { float scale = Math . min ( NUM_ , Math . min ( widthScale , heightScale ) ) ; mBaseMatrix . postScale ( scale , scale ) ; mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth . scale ) / NUM_ , ( viewHeight - drawableHeight . scale ) / NUM_ ) ; } else { RectF mTempSrc = new RectF ( NUM_ , NUM_ , drawableWidth , drawableHeight ) ; RectF mTempDst = new RectF ( NUM_ , NUM_ , viewWidth , viewHeight ) ; switch ( mScaleType ) { case FIT_CENTER : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . CENTER ) ; break ; case FIT_START : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . START ) ; break ; case FIT_END : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . END ) ; break ; case FIT_XY : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . FILL ) ; break ; default : break ; } } resetMatrix ( ) ; }
public List < Node > listAvailableNodes ( Class < ? > type ) { List < Node > result = new ArrayList < Node > ( ) ; for ( Node node : availableNodes ) { if ( type . isAssignableFrom ( node . getReturnType ( ) ) ) { result . add ( node ) ; } } return result ; }
private < T extends Draft3Resource > T lookForResource ( Draft3ResourceType type , Class < T > clazz ) { List < T > resources = lookForResources ( type , clazz ) ; return resources != null && resources . size ( ) > NUM_ ? resources . get ( NUM_ ) : null ; }
public static String readFileToString ( File file ) throws IOException { return readFileToString ( file , Charset . defaultCharset ( ) ) ; }
private boolean isLocked ( Order order ) { lock . lock ( ) ; try { return activeOrders . contains ( order . getId ( ) ) ; } finally { lock . unlock ( ) ; } }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
private static byte [ ] longToByteArray ( long l ) { byte [ ] retVal = new byte [ NUM_ ] ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { retVal [ i ] = ( byte ) l ; l >>= NUM_ ; } return retVal ; }
public EncoderTestSuiteBuilder encode ( final String expected , final String input ) { return encode ( STR_ + input , expected , input ) ; }
public static boolean isFileTypeSupported ( int fileType ) { List providers = getMidiFileWriters ( ) ; for ( int i = NUM_ ; i < providers . size ( ) ; i ++ ) { MidiFileWriter writer = ( MidiFileWriter ) providers . get ( i ) ; if ( writer . isFileTypeSupported ( fileType ) ) { return BOOL_ ; } } return BOOL_ ; }
public void addMutedUsername ( final String username ) { addMutedUsername ( username , null ) ; }
public void overrideCurrentTime ( long time ) { startTime = System . currentTimeMillis ( ) ; currentTime = NUM_ ; storedTime = time ; }
public static String sc ( Double score ) { String score_str = String . format ( STR_ , score ) ; return score_str ; }
public static boolean validateBindAddress ( String bindAddress ) { if ( bindAddress == null || bindAddress . length ( ) == NUM_ ) return BOOL_ ; if ( InetAddressUtil . validateHost ( bindAddress ) == null ) return BOOL_ ; return BOOL_ ; }
protected void fail ( String string ) { lastPrint = NUM_ ; if ( string . length ( ) > NUM_ ) { char [ ] data = string . toCharArray ( ) ; for ( int i = NUM_ ; i < data . length ; i ++ ) { char c = data [ i ] ; if ( c >= NUM_ || c < NUM_ ) { data [ i ] = ( char ) ( STR_ + ( c & NUM_ ) ) ; string = null ; } } if ( string == null ) { string = new String ( data ) ; } } println ( string ) ; throw new AssertionError ( string ) ; }
public TypecheckResult interpretResults ( TestConfiguration config , CompilationResult compilationResult ) { List < TestDiagnostic > expectedDiagnostics = readDiagnostics ( config , compilationResult ) ; return TypecheckResult . fromCompilationResults ( config , compilationResult , expectedDiagnostics ) ; }
public boolean isTrustedXACMLProvider ( String realm , String entityId , String trustedEntityId , String role ) throws SAML2MetaException { boolean result = BOOL_ ; if ( role != null ) { if ( role . equals ( SAML2Constants . PDP_ROLE ) ) { XACMLPDPConfigElement pdpConfig = getPolicyDecisionPointConfig ( realm , entityId ) ; if ( pdpConfig != null ) { result = isSameCircleOfTrust ( pdpConfig , realm , trustedEntityId ) ; } } else if ( role . equals ( SAML2Constants . PEP_ROLE ) ) { XACMLAuthzDecisionQueryConfigElement pepConfig = getPolicyEnforcementPointConfig ( realm , entityId ) ; result = isSameCircleOfTrust ( pepConfig , realm , trustedEntityId ) ; } } return result ; }
private PropertyEditor loadPropertyEditor ( Class clz ) { PropertyEditor editor = null ; try { editor = ( PropertyEditor ) clz . newInstance ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return editor ; }
public Distribution ( Instances source , ClassifierSplitModel modelToUse ) throws Exception { int index ; Instance instance ; double [ ] weights ; m_perClassPerBag = new double [ modelToUse . numSubsets ( ) ] [ NUM_ ] ; m_perBag = new double [ modelToUse . numSubsets ( ) ] ; totaL = NUM_ ; m_perClass = new double [ source . numClasses ( ) ] ; for ( int i = NUM_ ; i < modelToUse . numSubsets ( ) ; i ++ ) { m_perClassPerBag [ i ] = new double [ source . numClasses ( ) ] ; } Enumeration < Instance > enu = source . enumerateInstances ( ) ; while ( enu . hasMoreElements ( ) ) { instance = enu . nextElement ( ) ; index = modelToUse . whichSubset ( instance ) ; if ( index != - NUM_ ) { add ( index , instance ) ; } else { weights = modelToUse . weights ( instance ) ; addWeights ( instance , weights ) ; } } }
public void writingRequestHeaders ( ) { if ( sentRequestMillis != - NUM_ ) throw new IllegalStateException ( ) ; sentRequestMillis = System . currentTimeMillis ( ) ; }
public List < DexlibAbstractInstruction > instructionsAfter ( DexlibAbstractInstruction instruction ) { int i = instructions . indexOf ( instruction ) ; if ( i == - NUM_ ) throw new IllegalArgumentException ( STR_ + instruction + STR_ ) ; return instructions . subList ( i + NUM_ , instructions . size ( ) ) ; }
private Alignment fineTuneAlignment ( final Alignment firstCompute , final int xframe , final int yframe , final Point frameLocation , final Point componentLocation , final int compWidth , final int compHeight ) { switch ( firstCompute ) { case TOPLEFT : case TOPRIGHT : if ( componentLocation . x - frameLocation . x + compWidth / NUM_ > xframe / NUM_ ) { return Alignment . TOPRIGHT ; } else { return Alignment . TOPLEFT ; } case LEFTBOTTOM : case LEFTTOP : if ( componentLocation . y - frameLocation . y + compHeight / NUM_ > yframe / NUM_ ) { return Alignment . LEFTBOTTOM ; } else { return Alignment . LEFTTOP ; } case RIGHTBOTTOM : case RIGHTTOP : if ( componentLocation . y - frameLocation . y + compHeight / NUM_ > yframe / NUM_ ) { return Alignment . RIGHTBOTTOM ; } else { return Alignment . RIGHTTOP ; } case BOTTOMLEFT : case BOTTOMRIGHT : if ( componentLocation . x - frameLocation . x + compWidth / NUM_ > xframe / NUM_ ) { return Alignment . BOTTOMRIGHT ; } else { return Alignment . BOTTOMLEFT ; } default : if ( realAlignment == Alignment . INNERLEFT || realAlignment == Alignment . INNERRIGHT ) { return realAlignment ; } if ( componentLocation . x - frameLocation . x > xframe + frameLocation . x - ( compWidth + componentLocation . x ) ) { return Alignment . INNERRIGHT ; } else { return Alignment . INNERLEFT ; } } }
public boolean isEmpty ( ) { return shapes == null ? BOOL_ : shapes . isEmpty ( ) ; }
public static boolean isNetworkAvailable ( Context context ) { ConnectivityManager cm = ( ConnectivityManager ) context . getSystemService ( Context . CONNECTIVITY_SERVICE ) ; NetworkInfo netInfo = cm . getActiveNetworkInfo ( ) ; return netInfo != null && netInfo . isConnectedOrConnecting ( ) ; }
public void resetData ( ) { data . clear ( ) ; dataNames . clear ( ) ; dataSet . resetData ( dataNames , data , bins ) ; }
@ Override public URI uploadPackage ( ) { boolean fileExists = new File ( topologyPackageLocation ) . isFile ( ) ; if ( ! fileExists ) { LOG . info ( STR_ + topologyPackageLocation + STR_ ) ; return null ; } Path filePath = Paths . get ( destTopologyFile ) ; File parentDirectory = filePath . getParent ( ) . toFile ( ) ; assert parentDirectory != null ; if ( ! parentDirectory . exists ( ) ) { LOG . fine ( STR_ ) ; if ( ! parentDirectory . mkdirs ( ) ) { LOG . severe ( STR_ + parentDirectory . getPath ( ) ) ; return null ; } } fileExists = new File ( filePath . toString ( ) ) . isFile ( ) ; if ( fileExists ) { LOG . fine ( STR_ + filePath . toString ( ) + STR_ ) ; } LOG . fine ( STR_ + topologyPackageLocation + STR_ + filePath . toString ( ) ) ; Path source = Paths . get ( topologyPackageLocation ) ; try { CopyOption [ ] options = new CopyOption [ ] { StandardCopyOption . REPLACE_EXISTING } ; Files . copy ( source , filePath , options ) ; } catch ( IOException ex ) { LOG . info ( STR_ + source . toString ( ) + STR_ + ex ) ; return null ; } return getUri ( destTopologyFile ) ; }
public static String stripEscape ( String pattern ) { if ( pattern == null ) return null ; StringBuilder stripped = new StringBuilder ( pattern . length ( ) ) ; for ( int pos = NUM_ ; pos < pattern . length ( ) ; pos ++ ) { char ch = pattern . charAt ( pos ) ; if ( ch != STR_ ) { stripped . append ( ch ) ; } else if ( pos < pattern . length ( ) - NUM_ && pattern . charAt ( pos + NUM_ ) == STR_ ) { stripped . append ( STR_ ) ; pos += NUM_ ; } } return stripped . toString ( ) ; }
public long guest_time ( ) { return Long . parseLong ( fields [ NUM_ ] ) ; }
public void auditOperation ( String operation , List < ? extends TaggedLogAPIEntity > entities , List < String > encodedRowKeys , EntityDefinition entityDefinition ) { if ( isAuditingRequired ( entityDefinition . getService ( ) ) ) { List < GenericAuditEntity > auditEntities = buildAuditEntities ( operation , entities , encodedRowKeys , entityDefinition ) ; if ( null != auditEntities && NUM_ != auditEntities . size ( ) ) { auditSupport . fireAudit ( entityDefinition . getService ( ) , auditEntities ) ; } } }
public Collection < HTMLToken > tokenizeHTML ( ) { List < HTMLToken > tokens = new ArrayList < HTMLToken > ( ) ; String nestedTags = nestedTagsRegex ( NUM_ ) ; Pattern p = Pattern . compile ( STR_ + STR_ + STR_ + STR_ + STR_ + nestedTags + STR_ , Pattern . CASE_INSENSITIVE ) ; Matcher m = p . matcher ( text ) ; int lastPos = NUM_ ; while ( m . find ( ) ) { if ( lastPos < m . start ( ) ) { tokens . add ( HTMLToken . text ( text . substring ( lastPos , m . start ( ) ) ) ) ; } tokens . add ( HTMLToken . tag ( text . substring ( m . start ( ) , m . end ( ) ) ) ) ; lastPos = m . end ( ) ; } if ( lastPos < text . length ( ) ) { tokens . add ( HTMLToken . text ( text . substring ( lastPos , text . length ( ) ) ) ) ; } return tokens ; }
public void register ( String pattern , String result ) { Assert . isTrue ( matchers . size ( ) == results . size ( ) ) ; pattern = pattern . trim ( ) ; if ( pattern . length ( ) == NUM_ ) { return ; } matchers . add ( new StringMatcher ( pattern , BOOL_ , BOOL_ ) ) ; results . add ( result ) ; }
@ Override public boolean onItemUse ( ItemStack par1ItemStack , EntityPlayer par2EntityPlayer , World par3World , int x , int y , int z , int par7 , float par8 , float par9 , float par10 ) { if ( ! par3World . isRemote ) { TileEntity tileEntity = par3World . getTileEntity ( x , y , z ) ; if ( tileEntity != null ) { if ( tileEntity instanceof TileLauncherPrefab ) { TileLauncherPrefab missileLauncher = ( TileLauncherPrefab ) tileEntity ; if ( missileLauncher . getFrequency ( ) > NUM_ ) { setFrequency ( missileLauncher . getFrequency ( ) , par1ItemStack ) ; par2EntityPlayer . addChatMessage ( new ChatComponentText ( Reference . CHAT_DESC + EnumColor . GREY + STR_ + LangUtils . localize ( STR_ ) + STR_ + EnumColor . DARK_GREY + getFrequency ( par1ItemStack ) ) ) ; } else { par2EntityPlayer . addChatMessage ( new ChatComponentText ( Reference . CHAT_DESC + EnumColor . GREY + STR_ + LangUtils . localize ( STR_ ) ) ) ; } } } } return BOOL_ ; }
public static PublicKey generatePublicKey ( String encodedPublicKey ) { try { byte [ ] decodedKey = Base64 . decode ( encodedPublicKey ) ; KeyFactory keyFactory = KeyFactory . getInstance ( KEY_FACTORY_ALGORITHM ) ; return keyFactory . generatePublic ( new X509EncodedKeySpec ( decodedKey ) ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } catch ( InvalidKeySpecException e ) { Log . e ( TAG , STR_ ) ; throw new IllegalArgumentException ( e ) ; } catch ( Base64DecoderException e ) { Log . e ( TAG , STR_ ) ; throw new IllegalArgumentException ( e ) ; } }
SSLSession toSession ( byte [ ] data , String host , int port ) { ByteArrayInputStream bais = new ByteArrayInputStream ( data ) ; DataInputStream dais = new DataInputStream ( bais ) ; try { int type = dais . readInt ( ) ; if ( type != OPEN_SSL ) { log ( new AssertionError ( STR_ + type ) ) ; return null ; } int length = dais . readInt ( ) ; byte [ ] sessionData = new byte [ length ] ; dais . readFully ( sessionData ) ; int count = dais . readInt ( ) ; X509Certificate [ ] certs = new X509Certificate [ count ] ; for ( int i = NUM_ ; i < count ; i ++ ) { length = dais . readInt ( ) ; byte [ ] certData = new byte [ length ] ; dais . readFully ( certData ) ; certs [ i ] = OpenSSLX509Certificate . fromX509Der ( certData ) ; } return new OpenSSLSessionImpl ( sessionData , host , port , certs , this ) ; } catch ( IOException e ) { log ( e ) ; return null ; } }
private static String parseDERString ( byte [ ] alterNameValue ) throws Throwable { try { ASN1StreamParser p = new ASN1StreamParser ( alterNameValue ) ; ASN1Encodable d = p . readObject ( ) ; ASN1Primitive der = d . toASN1Primitive ( ) ; return getStringFromObject ( der ) ; } catch ( Throwable e ) { logger . error ( STR_ + e . getMessage ( ) ) ; throw e ; } }
public AtlasMessagesAdapter addCellFactories ( AtlasCellFactory ... cellFactories ) { for ( AtlasCellFactory CellFactory : cellFactories ) { CellFactory . setStyle ( mMessageStyle ) ; mCellFactories . add ( CellFactory ) ; mViewTypeCount ++ ; CellType me = new CellType ( BOOL_ , CellFactory ) ; mCellTypesByViewType . put ( mViewTypeCount , me ) ; mMyViewTypesByCell . put ( CellFactory , mViewTypeCount ) ; mViewTypeCount ++ ; CellType notMe = new CellType ( BOOL_ , CellFactory ) ; mCellTypesByViewType . put ( mViewTypeCount , notMe ) ; mTheirViewTypesByCell . put ( CellFactory , mViewTypeCount ) ; } return this ; }
protected String consumeBOM ( InputStream stream , String encoding ) throws IOException { byte [ ] b = new byte [ NUM_ ] ; int count = NUM_ ; stream . mark ( NUM_ ) ; if ( encoding . equals ( STR_ ) ) { count = stream . read ( b , NUM_ , NUM_ ) ; if ( count == NUM_ ) { final int b0 = b [ NUM_ ] & xFF ; final int b1 = b [ NUM_ ] & xFF ; final int b2 = b [ NUM_ ] & xFF ; if ( b0 != xEF || b1 != xBB || b2 != xBF ) { stream . reset ( ) ; } } else { stream . reset ( ) ; } } else if ( encoding . startsWith ( STR_ ) ) { count = stream . read ( b , NUM_ , NUM_ ) ; if ( count == NUM_ ) { final int b0 = b [ NUM_ ] & xFF ; final int b1 = b [ NUM_ ] & xFF ; if ( b0 == xFE && b1 == xFF ) { return STR_ ; } else if ( b0 == xFF && b1 == xFE ) { return STR_ ; } } stream . reset ( ) ; } return encoding ; }
public static int createWithIdGeneration ( Connection connection , String rawSqlQuery , Object ... parameters ) throws SQLException { PreparedStatement stmt = null ; ResultSet rs = null ; try { stmt = connection . prepareStatement ( rawSqlQuery , Statement . RETURN_GENERATED_KEYS ) ; for ( int index = NUM_ ; index < parameters . length ; index ++ ) { JdbcUtils . bindParameter ( stmt , index + NUM_ , parameters [ index ] ) ; } stmt . executeUpdate ( ) ; rs = stmt . getGeneratedKeys ( ) ; rs . next ( ) ; return rs . getInt ( NUM_ ) ; } finally { JdbcUtils . closeResultSet ( rs ) ; JdbcUtils . closeStatement ( stmt ) ; } }
public boolean writeHeader ( OutputStream os ) { try { writeInt ( os , CACHE_MAGIC ) ; writeString ( os , key ) ; writeString ( os , etag == null ? STR_ : etag ) ; writeLong ( os , serverDate ) ; writeLong ( os , lastModified ) ; writeLong ( os , ttl ) ; writeLong ( os , softTtl ) ; writeStringStringMap ( responseHeaders , os ) ; os . flush ( ) ; return BOOL_ ; } catch ( IOException e ) { VolleyLog . d ( STR_ , e . toString ( ) ) ; return BOOL_ ; } }
public static int andNot ( int a [ ] , int lena , int b [ ] , int lenb , int [ ] target ) { if ( lena == NUM_ ) return NUM_ ; if ( lenb == NUM_ ) { System . arraycopy ( a , NUM_ , target , NUM_ , lena ) ; return lena ; } if ( ( lenb > > NUM_ ) >= lena ) { return andNotBinarySearch ( a , lena , b , lenb , target ) ; } int count = NUM_ ; int i = NUM_ , j = NUM_ ; int doca = a [ i ] , docb = b [ j ] ; for ( ; ; ) { if ( doca > docb ) { if ( ++ j >= lenb ) break ; docb = b [ j ] ; } else if ( doca < docb ) { target [ count ++ ] = doca ; if ( ++ i >= lena ) break ; doca = a [ i ] ; } else { if ( ++ i >= lena ) break ; doca = a [ i ] ; if ( ++ j >= lenb ) break ; docb = b [ j ] ; } } int leftover = lena - i ; if ( leftover > NUM_ ) { System . arraycopy ( a , i , target , count , leftover ) ; count += leftover ; } return count ; }
public boolean remove ( HttpConnection connection ) { TimeValues times = connectionToTimes . remove ( connection ) ; if ( times == null ) { log . warn ( STR_ ) ; return BOOL_ ; } else { return System . currentTimeMillis ( ) <= times . timeExpires ; } }
void createButtons ( ) { if ( scrollForwardButton != null ) { tabPane . remove ( scrollForwardButton ) ; scrollForwardButton . removeActionListener ( this ) ; tabPane . remove ( scrollBackwardButton ) ; scrollBackwardButton . removeActionListener ( this ) ; } int tabPlacement = tabPane . getTabPlacement ( ) ; int width = UIManager . getInt ( STR_ ) ; if ( tabPlacement == TOP || tabPlacement == BOTTOM ) { scrollForwardButton = new ArrowButton ( EAST , width ) ; scrollBackwardButton = new ArrowButton ( WEST , width ) ; } else { scrollForwardButton = new ArrowButton ( SOUTH , width ) ; scrollBackwardButton = new ArrowButton ( NORTH , width ) ; } scrollForwardButton . addActionListener ( this ) ; scrollBackwardButton . addActionListener ( this ) ; tabPane . add ( scrollForwardButton ) ; tabPane . add ( scrollBackwardButton ) ; }
public void or ( Criteria criteria ) { oredCriteria . add ( criteria ) ; }
private boolean checkTouchSlop ( View child , float dx , float dy ) { if ( child == null ) { return BOOL_ ; } final boolean checkHorizontal = mCallback . getViewHorizontalDragRange ( child ) > NUM_ ; final boolean checkVertical = mCallback . getViewVerticalDragRange ( child ) > NUM_ ; if ( checkHorizontal && checkVertical ) { return dx . dx + dy . dy > mTouchSlop . mTouchSlop ; } else if ( checkHorizontal ) { return Math . abs ( dx ) > mTouchSlop ; } else if ( checkVertical ) { return Math . abs ( dy ) > mTouchSlop ; } return BOOL_ ; }
public static String rmSlashFromUrl ( final String url ) { return url . endsWith ( STR_ ) ? url . substring ( NUM_ , url . length ( ) - NUM_ ) : url ; }
protected void updateChartLayout ( ) { chartContainer . removeAll ( ) ; List < String > selectedMetrics = getSelectedMetrics ( ) ; if ( selectedMetrics . size ( ) > NUM_ ) { if ( selectedMetrics . size ( ) <= NUM_ ) { chartContainer . setLayout ( new GridLayout ( NUM_ , NUM_ ) ) ; } else if ( selectedMetrics . size ( ) <= NUM_ ) { chartContainer . setLayout ( new GridLayout ( NUM_ , NUM_ ) ) ; } else if ( selectedMetrics . size ( ) <= NUM_ ) { chartContainer . setLayout ( new GridLayout ( NUM_ , NUM_ ) ) ; } else if ( selectedMetrics . size ( ) <= NUM_ ) { chartContainer . setLayout ( new GridLayout ( NUM_ , NUM_ ) ) ; } else { chartContainer . setLayout ( new GridLayout ( ( int ) Math . ceil ( selectedMetrics . size ( ) / NUM_ ) , NUM_ ) ) ; } GridLayout layout = ( GridLayout ) chartContainer . getLayout ( ) ; int spaces = layout . getRows ( ) . layout . getColumns ( ) ; for ( int i = NUM_ ; i < Math . max ( spaces , selectedMetrics . size ( ) ) ; i ++ ) { if ( i < selectedMetrics . size ( ) ) { chartContainer . add ( createChart ( selectedMetrics . get ( i ) ) ) ; } else { chartContainer . add ( new EmptyPlot ( this ) ) ; } } } chartContainer . revalidate ( ) ; }
public String host ( Properties props ) { return props . getProperty ( HOST_PROPERTY_KEY , STR_ ) ; }
void cancel ( ) { setVisible ( BOOL_ ) ; }
@ Override public MemChunkHolder < VolatileMemAllocator > createChunk ( long size , boolean autoreclaim ) { MemChunkHolder < VolatileMemAllocator > ret = null ; Long addr = m_vmasvc . allocate ( m_nid , size , BOOL_ ) ; if ( NUM_ == addr && m_activegc ) { m_chunkcollector . waitReclaimCoolDown ( m_gctimeout ) ; addr = m_vmasvc . allocate ( m_nid , size , BOOL_ ) ; } if ( NUM_ != addr ) { ret = new MemChunkHolder < VolatileMemAllocator > ( this , addr , size ) ; ret . setCollector ( m_chunkcollector ) ; if ( autoreclaim ) { m_chunkcollector . register ( ret ) ; } } return ret ; }
public void waitForInvocation ( long msecWait , int numberOfNewEvents ) { long startTime = System . currentTimeMillis ( ) ; while ( BOOL_ ) { if ( ( System . currentTimeMillis ( ) - startTime ) > msecWait ) { throw new RuntimeException ( STR_ + numberOfNewEvents + STR_ + getNewDataListFlattened ( ) . length ) ; } EventBean [ ] events = getNewDataListFlattened ( ) ; if ( events . length >= numberOfNewEvents ) { return ; } try { Thread . sleep ( NUM_ ) ; } catch ( InterruptedException e ) { return ; } } }
private String versionName ( String prefix , int ver ) { return fName ( prefix ) + String . valueOf ( ver ) ; }
private void requestPermissionIfNeeded ( ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . M ) { int hasEnableCoarseLocationPerm = checkSelfPermission ( Manifest . permission . ACCESS_COARSE_LOCATION ) ; int hasEnableFineLocationPerm = checkSelfPermission ( Manifest . permission . ACCESS_FINE_LOCATION ) ; int hasEnableExternalWritePerm = checkSelfPermission ( Manifest . permission . WRITE_EXTERNAL_STORAGE ) ; List < String > permissionToRequest = new ArrayList < > ( ) ; if ( hasEnableCoarseLocationPerm == PackageManager . PERMISSION_DENIED ) { permissionToRequest . add ( Manifest . permission . ACCESS_COARSE_LOCATION ) ; } if ( hasEnableFineLocationPerm == PackageManager . PERMISSION_DENIED ) { permissionToRequest . add ( Manifest . permission . ACCESS_FINE_LOCATION ) ; } if ( hasEnableExternalWritePerm == PackageManager . PERMISSION_DENIED ) { permissionToRequest . add ( Manifest . permission . WRITE_EXTERNAL_STORAGE ) ; } if ( ! permissionToRequest . isEmpty ( ) ) { requestPermissions ( permissionToRequest . toArray ( new String [ permissionToRequest . size ( ) ] ) , ALLOW_PERMISSIONS ) ; } else { initEvent ( ) ; } } }
public ExtractMethodRefactoring ( ICompilationUnit unit , int selectionStart , int selectionLength ) { fCUnit = unit ; fRoot = null ; fMethodName = STR_ ; fSelectionStart = selectionStart ; fSelectionLength = selectionLength ; fVisibility = - NUM_ ; }
@ Override public boolean done ( ) { if ( stoppingIncrements && incrementsLeft == NUM_ ) return BOOL_ ; else return BOOL_ ; }
public void parse ( ) throws java . lang . Exception { int act ; symbol lhs_sym ; short handle_size , lhs_sym_num ; production_tab = production_table ( ) ; action_tab = action_table ( ) ; reduce_tab = reduce_table ( ) ; init_actions ( ) ; user_init ( ) ; cur_token = scan ( ) ; stack . push ( new symbol ( NUM_ , start_state ( ) ) ) ; tos = NUM_ ; for ( _done_parsing = BOOL_ ; ! _done_parsing ; ) { act = get_action ( ( ( symbol ) stack . peek ( ) ) . parse_state , cur_token . sym ) ; if ( act > NUM_ ) { cur_token . parse_state = act - NUM_ ; stack . push ( cur_token ) ; tos ++ ; cur_token = scan ( ) ; } else if ( act < NUM_ ) { lhs_sym = do_action ( ( - act ) - NUM_ , this , stack , tos ) ; lhs_sym_num = production_tab [ ( - act ) - NUM_ ] [ NUM_ ] ; handle_size = production_tab [ ( - act ) - NUM_ ] [ NUM_ ] ; for ( int i = NUM_ ; i < handle_size ; i ++ ) { stack . pop ( ) ; tos -- ; } act = get_reduce ( ( ( symbol ) stack . peek ( ) ) . parse_state , lhs_sym_num ) ; lhs_sym . parse_state = act ; stack . push ( lhs_sym ) ; tos ++ ; } else if ( act == NUM_ ) { syntax_error ( cur_token ) ; if ( ! error_recovery ( BOOL_ ) ) { unrecovered_syntax_error ( cur_token ) ; done_parsing ( ) ; } } } }
private static void writeSet1 ( final BTree btree ) { log . info ( STR_ ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { btree . insert ( i , i ) ; } }
private byte [ ] createSegmentTable ( int setupHeaderLength , List < OggPageHeader . PacketStartAndLength > extraPackets ) { ByteArrayOutputStream resultBaos = new ByteArrayOutputStream ( ) ; byte [ ] restShouldBe ; byte [ ] nextPacket ; restShouldBe = createSegments ( setupHeaderLength , BOOL_ ) ; try { resultBaos . write ( restShouldBe ) ; if ( extraPackets . size ( ) > NUM_ ) { for ( OggPageHeader . PacketStartAndLength packet : extraPackets ) { nextPacket = createSegments ( packet . getLength ( ) , BOOL_ ) ; resultBaos . write ( nextPacket ) ; } } } catch ( IOException ioe ) { throw new RuntimeException ( STR_ + ioe . getMessage ( ) ) ; } return resultBaos . toByteArray ( ) ; }
public static int indexOfIgnoreCase ( String src , String sub , int startIndex , int endIndex ) { if ( startIndex < NUM_ ) { startIndex = NUM_ ; } int srclen = src . length ( ) ; if ( endIndex > srclen ) { endIndex = srclen ; } int sublen = sub . length ( ) ; if ( sublen == NUM_ ) { return startIndex > srclen ? srclen : startIndex ; } sub = sub . toLowerCase ( ) ; int total = endIndex - sublen + NUM_ ; char c = sub . charAt ( NUM_ ) ; mainloop : for ( int i = startIndex ; i < total ; i ++ ) { if ( Character . toLowerCase ( src . charAt ( i ) ) != c ) { continue ; } int j = NUM_ ; int k = i + NUM_ ; while ( j < sublen ) { char source = Character . toLowerCase ( src . charAt ( k ) ) ; if ( sub . charAt ( j ) != source ) { continue mainloop ; } j ++ ; k ++ ; } return i ; } return - NUM_ ; }
private void addPolygonRing ( LinearRing lr , int cwLeft , int cwRight ) { if ( lr . isEmpty ( ) ) return ; Coordinate [ ] coord = CoordinateArrays . removeRepeatedPoints ( lr . getCoordinates ( ) ) ; if ( coord . length < NUM_ ) { hasTooFewPoints = BOOL_ ; invalidPoint = coord [ NUM_ ] ; return ; } int left = cwLeft ; int right = cwRight ; if ( CGAlgorithms . isCCW ( coord ) ) { left = cwRight ; right = cwLeft ; } Edge e = new Edge ( coord , new Label ( argIndex , Location . BOUNDARY , left , right ) ) ; lineEdgeMap . put ( lr , e ) ; insertEdge ( e ) ; insertPoint ( argIndex , coord [ NUM_ ] , Location . BOUNDARY ) ; }
public boolean acceptsLoadName ( String load ) { if ( _loadOption . equals ( ALL_LOADS ) ) { return BOOL_ ; } if ( _loadOption . equals ( INCLUDE_LOADS ) ) { return _loadList . contains ( load ) ; } return ! _loadList . contains ( load ) ; }
public static void expandLetters ( String letters , WordRelation wordRelation ) { letters = letters . toLowerCase ( ) ; char c ; for ( int i = NUM_ ; i < letters . length ( ) ; i ++ ) { c = letters . charAt ( i ) ; if ( isDigit ( c ) ) { wordRelation . addWord ( digit2num [ c - STR_ ] ) ; } else if ( letters . equals ( STR_ ) ) { wordRelation . addWord ( STR_ ) ; } else { wordRelation . addWord ( String . valueOf ( c ) ) ; } } }
public static void writeStringToFile ( File file , String data , Charset encoding , boolean append ) throws IOException { OutputStream out = null ; try { out = openOutputStream ( file , append ) ; IOUtils . write ( data , out , encoding ) ; out . close ( ) ; } finally { IOUtils . closeQuietly ( out ) ; } }
@ Deprecated public static void subtract ( String name , double amount ) throws UserDoesNotExistException , NoLoanPermittedException { try { substract ( name , BigDecimal . valueOf ( amount ) ) ; } catch ( ArithmeticException e ) { logger . log ( Level . WARNING , STR_ + amount + STR_ + name + STR_ + e . getMessage ( ) , e ) ; } }
public MnemonicCode ( InputStream wordstream , String wordListDigest ) throws IOException , IllegalArgumentException { BufferedReader br = new BufferedReader ( new InputStreamReader ( wordstream , STR_ ) ) ; wordList = new ArrayList < String > ( NUM_ ) ; String word ; while ( ( word = br . readLine ( ) ) != null ) wordList . add ( word ) ; br . close ( ) ; initializeFromWords ( wordList , wordListDigest ) ; }
public QKDialog addMenuItem ( String title , long id ) { mMenuItems . add ( title ) ; mMenuItemIds . add ( id ) ; return this ; }
public AnchorPane createFingerPrintPanel ( ArrayList < FpPanel > fingerprintPanelList ) { return createFingerPrintPanel ( fingerprintPanelList , null ) ; }
private static boolean isMemoryAccess ( final String value ) { return value . equals ( STR_ ) ; }
public void addAttribute ( AttributeInfo info ) { AttributeInfo . remove ( attributes , info . getName ( ) ) ; attributes . add ( info ) ; }
private static boolean verifyStringParam ( String str , int maxLength , String acceptableCharacters ) { return ! ( str == null || str . length ( ) == NUM_ || str . length ( ) > maxLength || ! Pattern . matches ( acceptableCharacters , str ) ) ; }
private int calculateDragSensitivity ( ) { int range = MAX_DRAG_SENSITIVITY - MIN_DRAG_SENSITIVITY ; return Math . round ( ( NUM_ - getDragSensitivity ( ) ) . range + MIN_DRAG_SENSITIVITY ) ; }
public static String lowerFirstChar ( String string ) { if ( string == null ) return null ; if ( string . length ( ) <= NUM_ ) return string . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( string ) ; sb . setCharAt ( NUM_ , Character . toLowerCase ( sb . charAt ( NUM_ ) ) ) ; return sb . toString ( ) ; }
public void forEachBlockPosMutableTopDown ( Predicate < BlockPos > func ) { BlockPos . MutableBlockPos blockPos = new BlockPos . MutableBlockPos ( ) ; int baseX = getMinBlockX ( ) ; int baseZ = getMinBlockZ ( ) ; int blockYMax = getMaxBlockY ( ) ; for ( int x = NUM_ ; x < NUM_ ; x ++ ) { for ( int z = NUM_ ; z < NUM_ ; z ++ ) { blockPos . setPos ( baseX + x , blockYMax , baseZ + z ) ; for ( int y = NUM_ ; y >= NUM_ ; y -- ) { boolean cont = func . test ( blockPos ) ; blockPos . move ( EnumFacing . DOWN ) ; if ( ! cont ) { break ; } } } } }
public String visit ( Type t , Locale locale ) { return t . accept ( this , locale ) ; }
public static final void writeMapXml ( Map val , XmlSerializer out , WriteMapCallback callback ) throws XmlPullParserException , java . io . IOException { if ( val == null ) { return ; } Set s = val . entrySet ( ) ; Iterator i = s . iterator ( ) ; while ( i . hasNext ( ) ) { Map . Entry e = ( Map . Entry ) i . next ( ) ; writeValueXml ( e . getValue ( ) , ( String ) e . getKey ( ) , out , callback ) ; } }
public static void dropTable ( String table , Connection connection ) { table = table . replace ( STR_ , STR_ ) ; StringBuilder dropTableQuery = new StringBuilder ( ) ; dropTableQuery . append ( STR_ ) ; dropTableQuery . append ( table ) ; LOG . info ( STR_ ) ; LOG . info ( dropTableQuery ) ; executeStatementIfExists ( dropTableQuery . toString ( ) , connection ) ; }
private int freeSpace ( ) { return buffer . capacity ( ) - buffer . limit ( ) + buffer . position ( ) ; }
@ Override public List < Node > generate ( int popSize ) { List < Node > population = new ArrayList < > ( ) ; for ( int i = NUM_ ; i < popSize ; ) { Node candidate = grow ( NUM_ ) ; if ( candidate . isValid ( ) ) { population . add ( candidate ) ; i ++ ; } } return population ; }
public synchronized void notifyBeforeUse ( CompositeTransaction ct ) throws InvalidSessionHandleStateException { if ( closed ) throw new InvalidSessionHandleStateException ( STR_ ) ; try { TransactionContext suspended = null ; if ( ct != null ) { Iterator < TransactionContext > it = allContexts . iterator ( ) ; while ( it . hasNext ( ) && suspended == null ) { TransactionContext b = ( TransactionContext ) it . next ( ) ; if ( b . isSuspendedInTransaction ( ct ) ) { suspended = b ; } } } if ( suspended != null ) { if ( LOGGER . isDebugEnabled ( ) ) LOGGER . logDebug ( this + STR_ + ct . getTid ( ) ) ; currentContext = suspended ; currentContext . transactionResumed ( ) ; } else { try { if ( LOGGER . isTraceEnabled ( ) ) LOGGER . logTrace ( this + STR_ + ct ) ; currentContext . checkEnlistBeforeUse ( ct ) ; } catch ( UnexpectedTransactionContextException txBoundaryPassed ) { if ( LOGGER . isDebugEnabled ( ) ) LOGGER . logDebug ( this + STR_ + ct ) ; currentContext . transactionSuspended ( ) ; currentContext = new TransactionContext ( resource , xaResource ) ; allContexts . add ( currentContext ) ; try { currentContext . checkEnlistBeforeUse ( ct ) ; } catch ( UnexpectedTransactionContextException e ) { String msg = STR_ ; LOGGER . logError ( msg , e ) ; throw new InvalidSessionHandleStateException ( msg ) ; } } } } catch ( InvalidSessionHandleStateException e ) { notifySessionErrorOccurred ( ) ; throw e ; } }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
public void onActivityResult ( int requestCode , int resultCode , Intent data ) { if ( mInitializationComplete ) { mActivityDelegate . onActivityResultWithNative ( requestCode , resultCode , data ) ; } else { if ( mPendingActivityResults == null ) { mPendingActivityResults = new ArrayList < ActivityResult > ( NUM_ ) ; } mPendingActivityResults . add ( new ActivityResult ( requestCode , resultCode , data ) ) ; } }
public void deleteSelection ( ArrayList < Integer > nodes ) { for ( int i = NUM_ ; i < nodes . size ( ) ; i ++ ) { for ( int j = i + NUM_ ; j < nodes . size ( ) ; j ++ ) { if ( nodes . get ( i ) > nodes . get ( j ) ) { int h = nodes . get ( i ) ; nodes . set ( i , nodes . get ( j ) ) ; nodes . set ( j , h ) ; } } } if ( m_bNeedsUndoAction ) { addUndoAction ( new DeleteSelectionAction ( nodes ) ) ; } boolean bNeedsUndoAction = m_bNeedsUndoAction ; m_bNeedsUndoAction = BOOL_ ; try { for ( int iNode = nodes . size ( ) - NUM_ ; iNode >= NUM_ ; iNode -- ) { deleteNode ( nodes . get ( iNode ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } m_bNeedsUndoAction = bNeedsUndoAction ; }
protected void onCached ( ) { if ( LogConfiguration . loggingIsEnabled ( ) ) { logger . log ( Level . INFO , STR_ ) ; } uiHandler . hideMessage ( ) ; updating = BOOL_ ; fireApplicationCacheEvent ( CacheEvent . onCached ) ; }
public static void showString ( String title , String content , Dimension dimension ) { JTextArea area = new JTextArea ( content ) ; area . setEditable ( BOOL_ ) ; JScrollPane scroll = new JScrollPane ( area ) ; scroll . setPreferredSize ( dimension ) ; JOptionPane . showMessageDialog ( null , scroll , title , JOptionPane . INFORMATION_MESSAGE ) ; }
private void markCGForDeletion ( BlockConsistencyGroup consistencyGroup ) { if ( ! consistencyGroup . getInactive ( ) ) { consistencyGroup . setStorageController ( null ) ; consistencyGroup . setInactive ( BOOL_ ) ; _dbClient . updateObject ( consistencyGroup ) ; } }
public LongBuffer put ( long [ ] src , int srcOffset , int longCount ) { JTranscArrays . checkOffsetAndCount ( src . length , srcOffset , longCount ) ; if ( longCount > remaining ( ) ) { throw new BufferOverflowException ( ) ; } for ( int i = srcOffset ; i < srcOffset + longCount ; ++ i ) { put ( src [ i ] ) ; } return this ; }
public void playTogether ( Collection < Animator > items ) { if ( items != null && items . size ( ) > NUM_ ) { mNeedsSort = BOOL_ ; Builder builder = null ; for ( Animator anim : items ) { if ( builder == null ) { builder = play ( anim ) ; } else { builder . with ( anim ) ; } } } }
private MessageContext createMessageContext ( AxisEngine engine , HttpServletRequest req , HttpServletResponse res , Component component ) { MessageContext msgContext = new MessageContext ( engine ) ; String requestPath = getRequestPath ( req ) ; if ( isDebug ) { log . debug ( STR_ + msgContext ) ; log . debug ( STR_ + req . getHeader ( HTTPConstants . HEADER_CONTENT_TYPE ) ) ; log . debug ( STR_ + req . getHeader ( HTTPConstants . HEADER_CONTENT_LOCATION ) ) ; log . debug ( STR_ + String . valueOf ( homeDir ) ) ; log . debug ( STR_ + requestPath ) ; log . debug ( STR_ + String . valueOf ( webInfPath ) ) ; log . debug ( STR_ + req . getPathInfo ( ) ) ; log . debug ( STR_ + req . getHeader ( HTTPConstants . HEADER_AUTHORIZATION ) ) ; log . debug ( STR_ + req . getRemoteAddr ( ) ) ; log . debug ( STR_ + String . valueOf ( webInfPath ) ) ; } msgContext . setTransportName ( STR_ ) ; msgContext . setProperty ( Constants . MC_HOME_DIR , homeDir ) ; msgContext . setProperty ( Constants . MC_RELATIVE_PATH , requestPath ) ; msgContext . setProperty ( HTTPConstants . MC_HTTP_SERVLET , this ) ; msgContext . setProperty ( HTTPConstants . MC_HTTP_SERVLETREQUEST , req ) ; msgContext . setProperty ( HTTPConstants . MC_HTTP_SERVLETRESPONSE , res ) ; msgContext . setProperty ( HTTPConstants . MC_HTTP_SERVLETLOCATION , webInfPath ) ; msgContext . setProperty ( HTTPConstants . MC_HTTP_SERVLETPATHINFO , req . getPathInfo ( ) ) ; msgContext . setProperty ( HTTPConstants . HEADER_AUTHORIZATION , req . getHeader ( HTTPConstants . HEADER_AUTHORIZATION ) ) ; msgContext . setProperty ( lucee . runtime . net . rpc . server . Constants . COMPONENT , component ) ; msgContext . setProperty ( Constants . MC_REMOTE_ADDR , req . getRemoteAddr ( ) ) ; ServletEndpointContextImpl sec = new ServletEndpointContextImpl ( ) ; msgContext . setProperty ( Constants . MC_SERVLET_ENDPOINT_CONTEXT , sec ) ; String realpath = context . getRealPath ( requestPath ) ; if ( realpath != null ) { msgContext . setProperty ( Constants . MC_REALPATH , realpath ) ; } msgContext . setProperty ( Constants . MC_CONFIGPATH , webInfPath ) ; return msgContext ; }
@ Override public void invokeCommand ( int argLength , String [ ] args , String command ) { Pattern regex = null ; if ( args . length == NUM_ ) { regex = Pattern . compile ( args [ NUM_ ] ) ; } else if ( args . length != NUM_ ) { throw new UsageException ( STR_ ) ; } for ( AbstractCommand cmd : CommandBus . commands ) tryRegex ( regex , cmd ) ; for ( FuzzyCommand cmd : CommandBus . parsers ) tryRegex ( regex , cmd ) ; }
public static Builder newBuilder ( ) { return new Builder ( ) ; }
protected int parseAndAddNode ( XmlResourceParser parser , HashMap < String , TagParser > tagParserMap , ArrayList < Long > screenIds ) throws XmlPullParserException , IOException { if ( TAG_INCLUDE . equals ( parser . getName ( ) ) ) { final int resId = getAttributeResourceValue ( parser , ATTR_WORKSPACE , NUM_ ) ; if ( resId != NUM_ ) { return parseLayout ( resId , screenIds ) ; } else { return NUM_ ; } } mValues . clear ( ) ; parseContainerAndScreen ( parser , mTemp ) ; final long container = mTemp [ NUM_ ] ; final long screenId = mTemp [ NUM_ ] ; mValues . put ( LauncherSettings . Favorites . CONTAINER , container ) ; mValues . put ( LauncherSettings . Favorites . SCREEN , screenId ) ; mValues . put ( LauncherSettings . Favorites . CELLX , convertToDistanceFromEnd ( getAttributeValue ( parser , ATTR_X ) , mColumnCount ) ) ; mValues . put ( LauncherSettings . Favorites . CELLY , convertToDistanceFromEnd ( getAttributeValue ( parser , ATTR_Y ) , mRowCount ) ) ; TagParser tagParser = tagParserMap . get ( parser . getName ( ) ) ; if ( tagParser == null ) { if ( LOGD ) Log . d ( TAG , STR_ + parser . getName ( ) ) ; return NUM_ ; } long newElementId = tagParser . parseAndAdd ( parser ) ; if ( newElementId >= NUM_ ) { if ( ! screenIds . contains ( screenId ) && container == LauncherSettings . Favorites . CONTAINER_DESKTOP ) { screenIds . add ( screenId ) ; } return NUM_ ; } return NUM_ ; }
public WordEntry addNewWord ( final String str ) { final String key = trimWord ( str ) ; WordEntry entry = words . get ( key ) ; if ( entry == null ) { entry = new WordEntry ( ) ; entry . setType ( new ExpressionType ( STR_ ) ) ; entry . setNormalized ( key ) ; words . put ( key , entry ) ; } else { logger . warn ( STR_ + str + STR_ + entry . getNormalized ( ) ) ; } return entry ; }
@ Override public int insert ( String elem ) { int firstIndex = ( int ) ( elem . charAt ( NUM_ ) - STR_ ) ; int middleIndex = ( int ) ( elem . charAt ( - NUM_ + elem . length ( ) / NUM_ ) - STR_ ) ; int lastIndex = ( int ) ( elem . charAt ( elem . length ( ) - NUM_ ) - STR_ ) ; storage [ firstIndex . NUM_ + middleIndex . NUM_ + lastIndex ] = elem ; return NUM_ ; }
@ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { mWidth = MeasureSpec . getSize ( widthMeasureSpec ) ; mHeight = MeasureSpec . getSize ( heightMeasureSpec ) ; int minSide = Math . min ( mWidth , mHeight ) ; mWidth = minSide ; mHeight = minSide ; mCurrentProgressPosition = calculateCurrentPositionFromCurrentSeconds ( mCurrentSeconds ) ; objectAnimatorProgress . setFloatValues ( mCurrentProgressPosition / mWidth , NUM_ ) ; objectAnimatorProgress . setDuration ( ( mMaxSeconds - mCurrentSeconds ) . NUM_ ) ; if ( mBitmapCoverImage != null ) scaleCoverBitmap ( mBitmapCoverImage ) ; rectFEmptyProgress . set ( NUM_ , mHeight - mProgressHeight , mWidth , mHeight ) ; mDrawableBottomShadow . setBounds ( NUM_ , ( NUM_ . mHeight ) / NUM_ , mWidth , mHeight ) ; if ( startRequested ) { startRequested = BOOL_ ; start ( ) ; } super . onMeasure ( widthMeasureSpec , heightMeasureSpec ) ; }
protected List < Command > handleCommands ( ServerConnector serverConnector , List < Command > commands ) { List < Command > results = new ArrayList < Command > ( ) ; for ( Command command : commands ) { if ( LOG . isLoggable ( Level . FINEST ) ) { LOG . finest ( STR_ + command ) ; } results . addAll ( serverConnector . receive ( command ) ) ; } return results ; }
public static void UF5 ( double [ ] x , double [ ] f , int nx ) { int count1 = NUM_ ; int count2 = NUM_ ; double sum1 = NUM_ ; double sum2 = NUM_ ; double yj ; double hj ; double N = NUM_ ; double E = NUM_ ; for ( int j = NUM_ ; j <= nx ; j ++ ) { yj = x [ j - NUM_ ] - Math . sin ( NUM_ . PI . x [ NUM_ ] + j . PI / nx ) ; hj = NUM_ . yj . yj - Math . cos ( NUM_ . PI . yj ) + NUM_ ; if ( j % NUM_ == NUM_ ) { sum2 += hj ; count2 ++ ; } else { sum1 += hj ; count1 ++ ; } } hj = ( NUM_ / N + E ) . Math . abs ( Math . sin ( NUM_ . N . PI . x [ NUM_ ] ) ) ; f [ NUM_ ] = x [ NUM_ ] + hj + NUM_ . sum1 / ( double ) count1 ; f [ NUM_ ] = NUM_ - x [ NUM_ ] + hj + NUM_ . sum2 / ( double ) count2 ; }
private View fillUp ( int pos , int nextBottom ) { if ( DEBUG ) Log . i ( TAG , STR_ + pos + STR_ + nextBottom + M_FIRST_POSITION + mFirstPosition ) ; View selectedView = null ; final int end = mListPadding . top ; while ( nextBottom > end && pos >= NUM_ ) { View temp = makeRow ( pos , nextBottom , BOOL_ ) ; if ( temp != null ) { selectedView = temp ; } nextBottom = mReferenceView . getTop ( ) - mVerticalSpacing ; mFirstPosition = pos ; pos -= mNumColumns ; } if ( mStackFromBottom ) { mFirstPosition = Math . max ( NUM_ , pos + NUM_ ) ; } return selectedView ; }
private List < ValidationError > validate ( ) { List < ValidationError > errors = Lists . newArrayList ( ) ; Module module = getModule ( ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateModule ( module ) ) ; AndroidFacet facet = null ; if ( module != null ) { facet = AndroidFacet . getInstance ( module ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateFacet ( facet , module ) ) ; } errors . addAll ( configState . validate ( facet ) ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateLabel ( getLabel ( ) , configuration . getProject ( ) , Kind . ANDROID_BINARY ) ) ; return errors ; }
public void removeChildJob ( Job childJob ) { if ( ! childJobs . contains ( childJob ) ) { throw new RuntimeException ( STR_ + childJob + STR_ ) ; } boolean removed = childJobs . remove ( childJob ) ; if ( ! removed ) { throw new RuntimeException ( STR_ ) ; } }
private PointF isFlingingToDelete ( DragSource source ) { if ( mFlingToDeleteDropTarget == null ) return null ; if ( ! source . supportsFlingToDelete ( ) ) return null ; ViewConfiguration config = ViewConfiguration . get ( mLauncher ) ; mVelocityTracker . computeCurrentVelocity ( NUM_ , config . getScaledMaximumFlingVelocity ( ) ) ; if ( mVelocityTracker . getYVelocity ( ) < mFlingToDeleteThresholdVelocity ) { PointF vel = new PointF ( mVelocityTracker . getXVelocity ( ) , mVelocityTracker . getYVelocity ( ) ) ; PointF upVec = new PointF ( NUM_ , - NUM_ ) ; float theta = ( float ) Math . acos ( ( ( vel . x . upVec . x ) + ( vel . y . upVec . y ) ) / ( vel . length ( ) . upVec . length ( ) ) ) ; if ( theta <= Math . toRadians ( MAX_FLING_DEGREES ) ) { return vel ; } } return null ; }
private int clampMag ( int value , int absMin , int absMax ) { final int absValue = Math . abs ( value ) ; if ( absValue < absMin ) return NUM_ ; if ( absValue > absMax ) return value > NUM_ ? absMax : - absMax ; return value ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; nameNode = elementList . item ( NUM_ ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; { boolean success = BOOL_ ; try { child . deleteData ( NUM_ , NUM_ ) ; } catch ( DOMException ex ) { success = ( ex . code == DOMException . INDEX_SIZE_ERR ) ; } assertTrue ( STR_ , success ) ; } }
public static void runScript ( final File file , final List < Pair < String , Object > > bindings ) throws ScriptException , IOException { final ScriptEngine engine = manager . getEngineByExtension ( FileUtils . getFileExtension ( file ) ) ; Preconditions . checkNotNull ( engine , STR_ , file . getAbsolutePath ( ) ) ; final String script = FileUtils . readTextfile ( file ) ; runScript ( engine , script , bindings ) ; }
public void addUGraphic ( UGraphic ug ) { graphics . addElement ( ug ) ; }
public void apply ( ) throws IllegalStateException { try { System . setSecurityManager ( this ) ; } catch ( SecurityException e ) { logger . error ( STR_ , e ) ; throw new IllegalStateException ( e ) ; } }
public static Rule createAGetPostRule ( String ruleName , String ruleUrl ) throws PolicyException { Map < String , Set < String > > actionValues = new HashMap < String , Set < String > > ( ) ; Set < String > set = new HashSet < String > ( ) ; set . add ( ALLOW_DECISION ) ; actionValues . put ( GET_ACTION , set ) ; set = new HashSet < String > ( ) ; set . add ( ALLOW_DECISION ) ; actionValues . put ( POST_ACTION , set ) ; return new Rule ( ruleName , IPLANETAMWEBAGENTSERVICE , ruleUrl , actionValues ) ; }
public FastArrayList ( Collection < ? extends E > c ) { elementData = c . toArray ( ) ; size = elementData . length ; if ( elementData . getClass ( ) != Object [ ] . class ) elementData = Arrays . copyOf ( elementData , size , Object [ ] . class ) ; }
public List < ? > endBatch ( ) { List < ? > result = null ; if ( operationsBatch . size ( ) > NUM_ ) { result = doFlush ( ) ; } useBatch = BOOL_ ; operationsBatch = null ; return result ; }
private int calculateLayoutWidth ( int widthSize , int mode ) { initResourcesIfNecessary ( ) ; itemsLayout . setLayoutParams ( new LayoutParams ( LayoutParams . WRAP_CONTENT , LayoutParams . WRAP_CONTENT ) ) ; itemsLayout . measure ( MeasureSpec . makeMeasureSpec ( widthSize , MeasureSpec . UNSPECIFIED ) , MeasureSpec . makeMeasureSpec ( NUM_ , MeasureSpec . UNSPECIFIED ) ) ; int width = itemsLayout . getMeasuredWidth ( ) ; if ( mode == MeasureSpec . EXACTLY ) { width = widthSize ; } else { width += NUM_ . PADDING ; width = Math . max ( width , getSuggestedMinimumWidth ( ) ) ; if ( mode == MeasureSpec . AT_MOST && widthSize < width ) { width = widthSize ; } } itemsLayout . measure ( MeasureSpec . makeMeasureSpec ( width - NUM_ . PADDING , MeasureSpec . EXACTLY ) , MeasureSpec . makeMeasureSpec ( NUM_ , MeasureSpec . UNSPECIFIED ) ) ; return width ; }
public static Collection removeInnerClassNames ( Collection col ) { List list = new ArrayList ( ) ; list . addAll ( col ) ; Iterator it = list . iterator ( ) ; while ( it . hasNext ( ) ) { String name = ( String ) it . next ( ) ; if ( name . indexOf ( STR_ ) != - NUM_ ) it . remove ( ) ; } return list ; }
public TrieNode find ( String word ) { return ( word . length ( ) < NUM_ ? null : find ( word , root , NUM_ ) ) ; }
private void testOrderedIndexes ( ) throws SQLException { deleteDb ( STR_ ) ; Connection conn = getConnection ( STR_ ) ; Statement stat = conn . createStatement ( ) ; stat . execute ( STR_ + STR_ ) ; stat . execute ( STR_ ) ; ResultSet rs = stat . executeQuery ( STR_ + STR_ ) ; rs . next ( ) ; assertContains ( rs . getString ( NUM_ ) , STR_ ) ; stat . execute ( STR_ ) ; stat . execute ( STR_ ) ; stat . execute ( STR_ ) ; stat . execute ( STR_ ) ; rs = stat . executeQuery ( STR_ + STR_ ) ; rs . next ( ) ; assertContains ( rs . getString ( NUM_ ) , STR_ ) ; conn . close ( ) ; }
public String encode ( ByteBuffer aBuffer ) { byte [ ] buf = getBytes ( aBuffer ) ; return encode ( buf ) ; }
public static int clearListInfo ( Delegator delegator , String shoppingListId ) throws GenericEntityException { delegator . removeByAnd ( STR_ , UtilMisc . toMap ( STR_ , shoppingListId ) ) ; return delegator . removeByAnd ( STR_ , UtilMisc . toMap ( STR_ , shoppingListId ) ) ; }
private synchronized void handleWatchdog ( ) { final int exitCode ; if ( watchdog == null ) return ; if ( watchdogTimeout == NUM_ ) return ; if ( ! isRunning ( ) ) { exitCode = OnCommandResultListener . SHELL_DIED ; Debug . log ( String . format ( STR_ , shell . toUpperCase ( Locale . ENGLISH ) ) ) ; } else if ( watchdogCount ++ < watchdogTimeout ) { return ; } else { exitCode = OnCommandResultListener . WATCHDOG_EXIT ; Debug . log ( String . format ( STR_ , shell . toUpperCase ( Locale . ENGLISH ) ) ) ; } if ( handler != null ) { postCallback ( command , exitCode , buffer ) ; } command = null ; buffer = null ; idle = BOOL_ ; watchdog . shutdown ( ) ; watchdog = null ; kill ( ) ; }
public synchronized boolean hasService ( Class serviceClass ) { if ( serviceClass == null ) throw new NullPointerException ( STR_ ) ; synchronized ( BeanContext . globalHierarchyLock ) { if ( services . containsKey ( serviceClass ) ) return BOOL_ ; BeanContextServices bcs = null ; try { bcs = ( BeanContextServices ) getBeanContext ( ) ; } catch ( ClassCastException cce ) { return BOOL_ ; } return bcs == null ? BOOL_ : bcs . hasService ( serviceClass ) ; } }
public boolean isPingDisabled ( ) { return ( null != healthcheck && ! healthcheck . exists ( ) ) ; }
public static String format ( Integer i ) { if ( i == null ) return null ; return i . toString ( ) ; }
public FilenameUtils ( ) { super ( ) ; }
public void dumpNodes ( Path webGraphDb , DumpType type , long topN , Path output , boolean asEff , NameType nameType , AggrType aggrType , boolean asSequenceFile ) throws Exception { SimpleDateFormat sdf = new SimpleDateFormat ( STR_ ) ; long start = System . currentTimeMillis ( ) ; LOG . info ( STR_ + sdf . format ( start ) ) ; Path nodeDb = new Path ( webGraphDb , WebGraph . NODE_DIR ) ; Configuration conf = getConf ( ) ; JobConf dumper = new NutchJob ( conf ) ; dumper . setJobName ( STR_ + webGraphDb ) ; FileInputFormat . addInputPath ( dumper , nodeDb ) ; dumper . setInputFormat ( SequenceFileInputFormat . class ) ; if ( nameType == null ) { dumper . setMapperClass ( Sorter . class ) ; dumper . setReducerClass ( Sorter . class ) ; dumper . setMapOutputKeyClass ( FloatWritable . class ) ; dumper . setMapOutputValueClass ( Text . class ) ; } else { dumper . setMapperClass ( Dumper . class ) ; dumper . setReducerClass ( Dumper . class ) ; dumper . setMapOutputKeyClass ( Text . class ) ; dumper . setMapOutputValueClass ( FloatWritable . class ) ; } dumper . setOutputKeyClass ( Text . class ) ; dumper . setOutputValueClass ( FloatWritable . class ) ; FileOutputFormat . setOutputPath ( dumper , output ) ; if ( asSequenceFile ) { dumper . setOutputFormat ( SequenceFileOutputFormat . class ) ; } else { dumper . setOutputFormat ( TextOutputFormat . class ) ; } dumper . setNumReduceTasks ( NUM_ ) ; dumper . setBoolean ( STR_ , type == DumpType . INLINKS ) ; dumper . setBoolean ( STR_ , type == DumpType . OUTLINKS ) ; dumper . setBoolean ( STR_ , type == DumpType . SCORES ) ; dumper . setBoolean ( STR_ , nameType == NameType . HOST ) ; dumper . setBoolean ( STR_ , nameType == NameType . DOMAIN ) ; dumper . setBoolean ( STR_ , aggrType == AggrType . SUM ) ; dumper . setBoolean ( STR_ , aggrType == AggrType . MAX ) ; dumper . setLong ( STR_ , topN ) ; if ( asEff ) { dumper . set ( STR_ , STR_ ) ; } try { LOG . info ( STR_ ) ; JobClient . runJob ( dumper ) ; } catch ( IOException e ) { LOG . error ( StringUtils . stringifyException ( e ) ) ; throw e ; } long end = System . currentTimeMillis ( ) ; LOG . info ( STR_ + sdf . format ( end ) + STR_ + TimingUtil . elapsedTime ( start , end ) ) ; }
public static String convertMethodSignature ( String className , String methodName , String methodSig , String pkgName ) { StringBuilder args = new StringBuilder ( ) ; SignatureConverter converter = new SignatureConverter ( methodSig ) ; converter . skip ( ) ; args . append ( STR_ ) ; while ( converter . getFirst ( ) != STR_ ) { if ( args . length ( ) > NUM_ ) { args . append ( STR_ ) ; } args . append ( shorten ( pkgName , converter . parseNext ( ) ) ) ; } converter . skip ( ) ; args . append ( STR_ ) ; StringBuilder result = new StringBuilder ( ) ; result . append ( className ) ; result . append ( STR_ ) ; result . append ( methodName ) ; result . append ( args . toString ( ) ) ; return result . toString ( ) ; }
protected void Predicate ( ) throws javax . xml . transform . TransformerException { if ( tokenIs ( STR_ ) ) { nextToken ( ) ; PredicateExpr ( ) ; consumeExpected ( STR_ ) ; } }
private void newUnitReceived ( GridUriDeploymentUnitDescriptor newDesc , Collection < Class < ? > > clss ) { assert newDesc != null ; assert newDesc . getType ( ) == GridUriDeploymentUnitDescriptor . Type . FILE ; if ( clss != null && ! clss . isEmpty ( ) ) { try { addResources ( newDesc . getClassLoader ( ) , newDesc , clss . toArray ( new Class < ? > [ clss . size ( ) ] ) ) ; } catch ( IgniteSpiException e ) { U . warn ( log , STR_ + newDesc + STR_ + e . getMessage ( ) + STR_ ) ; } } Collection < ClassLoader > rmvClsLdrs = new ArrayList < > ( ) ; synchronized ( mux ) { if ( checkMd5 && unitDeployed ( newDesc . getMd5 ( ) ) ) { if ( log . isInfoEnabled ( ) ) LT . info ( log , STR_ + STR_ + U . hidePassword ( newDesc . getUri ( ) ) + STR_ + ( newDesc . getFile ( ) == null ? STR_ : newDesc . getFile ( ) ) + STR_ ) ; return ; } boolean isAdded = BOOL_ ; boolean ignoreNewUnit = BOOL_ ; for ( ListIterator < GridUriDeploymentUnitDescriptor > iter = unitLoaders . listIterator ( ) ; iter . hasNext ( ) ; ) { GridUriDeploymentUnitDescriptor desc = iter . next ( ) ; assert ! newDesc . getClassLoader ( ) . equals ( desc . getClassLoader ( ) ) : STR_ + newDesc ; if ( desc . getType ( ) == GridUriDeploymentUnitDescriptor . Type . FILE && newDesc . getUri ( ) . equals ( desc . getUri ( ) ) && ! newDesc . getFile ( ) . equals ( desc . getFile ( ) ) ) { iter . remove ( ) ; rmvClsLdrs . add ( desc . getClassLoader ( ) ) ; if ( ! iter . hasNext ( ) ) break ; continue ; } if ( ! isAdded ) { if ( unitComp . compare ( newDesc , desc ) <= NUM_ ) { if ( checkUnitCollision ( desc , newDesc ) ) { iter . remove ( ) ; iter . add ( newDesc ) ; rmvClsLdrs . add ( desc . getClassLoader ( ) ) ; } else { iter . set ( newDesc ) ; iter . add ( desc ) ; } isAdded = BOOL_ ; } else if ( checkUnitCollision ( newDesc , desc ) ) { ignoreNewUnit = BOOL_ ; break ; } } else if ( checkUnitCollision ( newDesc , desc ) ) { iter . remove ( ) ; rmvClsLdrs . add ( desc . getClassLoader ( ) ) ; } } if ( ! ignoreNewUnit ) { if ( ! isAdded ) unitLoaders . add ( newDesc ) ; if ( log . isDebugEnabled ( ) ) LT . info ( log , STR_ + newDesc . getClassLoader ( ) + STR_ + newDesc . getTimestamp ( ) + STR_ + U . hidePassword ( newDesc . getUri ( ) ) + STR_ + ( newDesc . getFile ( ) == null ? STR_ : newDesc . getFile ( ) ) + STR_ ) ; } } for ( ClassLoader cldLdr : rmvClsLdrs ) onUnitReleased ( cldLdr ) ; }
public static String canonicalID ( String id ) { if ( id == null ) return STR_ ; int st = NUM_ ; int len = id . length ( ) ; boolean substr = BOOL_ ; int c ; while ( st < len && ( ( c = id . charAt ( st ) ) == STR_ || c <= STR_ ) ) { st ++ ; substr = BOOL_ ; } while ( st < len && ( ( c = id . charAt ( len - NUM_ ) ) == STR_ || c <= STR_ ) ) { len -- ; substr = BOOL_ ; } return substr ? id . substring ( st , len ) : id ; }
private static void encodeBinary ( byte [ ] bytes , int startpos , int count , int startmode , StringBuilder sb ) { if ( count == NUM_ && startmode == TEXT_COMPACTION ) { sb . append ( ( char ) SHIFT_TO_BYTE ) ; } else { boolean sixpack = ( ( count % NUM_ ) == NUM_ ) ; if ( sixpack ) { sb . append ( ( char ) LATCH_TO_BYTE ) ; } else { sb . append ( ( char ) LATCH_TO_BYTE_PADDED ) ; } } int idx = startpos ; if ( count >= NUM_ ) { char [ ] chars = new char [ NUM_ ] ; while ( ( startpos + count - idx ) >= NUM_ ) { long t = NUM_ ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { t <<= NUM_ ; t += bytes [ idx + i ] & xff ; } for ( int i = NUM_ ; i < NUM_ ; i ++ ) { chars [ i ] = ( char ) ( t % NUM_ ) ; t /= NUM_ ; } for ( int i = chars . length - NUM_ ; i >= NUM_ ; i -- ) { sb . append ( chars [ i ] ) ; } idx += NUM_ ; } } for ( int i = idx ; i < startpos + count ; i ++ ) { int ch = bytes [ i ] & xff ; sb . append ( ( char ) ch ) ; } }
@ Override public void step ( MessageLogger logger ) { try { addAgent ( ) ; env . step ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
private static boolean isNonLeft ( int i0 , int i1 , int i2 , int i3 , double [ ] pts ) { double l1 , l2 , l4 , l5 , l6 , angle1 , angle2 , angle ; l1 = Math . sqrt ( Math . pow ( pts [ i2 + NUM_ ] - pts [ i1 + NUM_ ] , NUM_ ) + Math . pow ( pts [ i2 ] - pts [ i1 ] , NUM_ ) ) ; l2 = Math . sqrt ( Math . pow ( pts [ i3 + NUM_ ] - pts [ i2 + NUM_ ] , NUM_ ) + Math . pow ( pts [ i3 ] - pts [ i2 ] , NUM_ ) ) ; l4 = Math . sqrt ( Math . pow ( pts [ i3 + NUM_ ] - pts [ i0 + NUM_ ] , NUM_ ) + Math . pow ( pts [ i3 ] - pts [ i0 ] , NUM_ ) ) ; l5 = Math . sqrt ( Math . pow ( pts [ i1 + NUM_ ] - pts [ i0 + NUM_ ] , NUM_ ) + Math . pow ( pts [ i1 ] - pts [ i0 ] , NUM_ ) ) ; l6 = Math . sqrt ( Math . pow ( pts [ i2 + NUM_ ] - pts [ i0 + NUM_ ] , NUM_ ) + Math . pow ( pts [ i2 ] - pts [ i0 ] , NUM_ ) ) ; angle1 = Math . acos ( ( ( l2 . l2 ) + ( l6 . l6 ) - ( l4 . l4 ) ) / ( NUM_ . l2 . l6 ) ) ; angle2 = Math . acos ( ( ( l6 . l6 ) + ( l1 . l1 ) - ( l5 . l5 ) ) / ( NUM_ . l6 . l1 ) ) ; angle = ( Math . PI - angle1 ) - angle2 ; if ( angle <= NUM_ ) { return ( BOOL_ ) ; } else { return ( BOOL_ ) ; } }
protected void copy2DArray ( int from [ ] [ ] , int to [ ] [ ] ) { for ( int i = NUM_ ; i < from . length ; i ++ ) { to [ i ] = new int [ from [ i ] . length ] ; System . arraycopy ( from [ i ] , NUM_ , to [ i ] , NUM_ , from [ i ] . length ) ; } }
public static < K , V > Map < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 ) { Map map = of ( ) ; map . put ( k1 , v1 ) ; map . put ( k2 , v2 ) ; map . put ( k3 , v3 ) ; return map ; }
public boolean fill ( Reader reader , int pos ) throws IOException { int res = reader . read ( fBuf ) ; if ( res == - NUM_ ) { fOffset = pos ; fLength = NUM_ ; return BOOL_ ; } int charsRead = res ; while ( charsRead < BUFFER_SIZE ) { res = reader . read ( fBuf , charsRead , BUFFER_SIZE - charsRead ) ; if ( res == - NUM_ ) { fOffset = pos ; fLength = charsRead ; return BOOL_ ; } charsRead += res ; } fOffset = pos ; fLength = BUFFER_SIZE ; return BOOL_ ; }
public void drawInRect ( GL10 gl , CGRect rect ) { gl . glEnable ( GL_TEXTURE_2D ) ; loadTexture ( gl ) ; float vertices [ ] = { rect . origin . x , rect . origin . y , rect . origin . x + rect . size . width , rect . origin . y , rect . origin . x , rect . origin . y + rect . size . height , rect . origin . x + rect . size . width , rect . origin . y + rect . size . height } ; mVertices . put ( vertices ) ; mVertices . position ( NUM_ ) ; float coordinates [ ] = { NUM_ , _maxT , _maxS , _maxT , NUM_ , NUM_ , _maxS , NUM_ } ; mCoordinates . put ( coordinates ) ; mCoordinates . position ( NUM_ ) ; gl . glEnableClientState ( GL_VERTEX_ARRAY ) ; gl . glEnableClientState ( GL_TEXTURE_COORD_ARRAY ) ; gl . glBindTexture ( GL_TEXTURE_2D , _name ) ; gl . glTexParameterx ( GL_TEXTURE_2D , GL_TEXTURE_WRAP_S , GL_REPEAT ) ; gl . glTexParameterx ( GL_TEXTURE_2D , GL_TEXTURE_WRAP_T , GL_REPEAT ) ; gl . glVertexPointer ( NUM_ , GL_FLOAT , NUM_ , mVertices ) ; gl . glTexCoordPointer ( NUM_ , GL_FLOAT , NUM_ , mCoordinates ) ; gl . glDrawArrays ( GL_TRIANGLE_STRIP , NUM_ , NUM_ ) ; gl . glDisableClientState ( GL_VERTEX_ARRAY ) ; gl . glDisableClientState ( GL_TEXTURE_COORD_ARRAY ) ; gl . glDisable ( GL_TEXTURE_2D ) ; }
synchronized void executed ( RTEditText editor , Operation op ) { Stack < Operation > undoStack = getUndoStack ( editor ) ; Stack < Operation > redoStack = getRedoStack ( editor ) ; while ( ! undoStack . empty ( ) && op . canMerge ( undoStack . peek ( ) ) ) { Operation previousOp = undoStack . pop ( ) ; op . merge ( previousOp ) ; } push ( op , undoStack ) ; redoStack . clear ( ) ; }
public void removeSwipeListener ( SwipeListener listener ) { if ( mListeners == null ) { return ; } mListeners . remove ( listener ) ; }
public static boolean isOssBuild ( ) { boolean isOssBuild = BOOL_ ; String buildType = System . getProperty ( STR_ ) ; if ( StringUtils . isNotBlank ( buildType ) && buildType . equalsIgnoreCase ( STR_ ) ) { isOssBuild = BOOL_ ; } return isOssBuild ; }
public void invokeHookBoltExecute ( Tuple tuple , long executeLatencyNs ) { if ( taskHooks . size ( ) != NUM_ ) { BoltExecuteInfo executeInfo = new BoltExecuteInfo ( tuple , getThisTaskId ( ) , executeLatencyNs / Constants . MILLISECONDS_TO_NANOSECONDS ) ; for ( ITaskHook taskHook : taskHooks ) { taskHook . boltExecute ( executeInfo ) ; } } }
private void validateIamRoles ( List < IamRole > iamRoles ) { Assert . notNull ( iamRoles , STR_ ) ; Assert . isTrue ( iamRoles . size ( ) > NUM_ , STR_ ) ; for ( IamRole iamRole : iamRoles ) { Assert . notNull ( iamRole , STR_ ) ; Assert . hasText ( iamRole . getIamRoleName ( ) , STR_ ) ; } }
public static Intent buildStartInBackgroundIntent ( File script ) { final ComponentName componentName = Constants . SL4A_SERVICE_LAUNCHER_COMPONENT_NAME ; Intent intent = new Intent ( ) ; intent . setComponent ( componentName ) ; intent . setAction ( Constants . ACTION_LAUNCH_BACKGROUND_SCRIPT ) ; intent . putExtra ( Constants . EXTRA_SCRIPT_PATH , script . getAbsolutePath ( ) ) ; return intent ; }
public static java . lang . String valueOf ( java . lang . Object obj ) { return obj == null ? STR_ : obj . toString ( ) ; }
@ SuppressWarnings ( { STR_ , STR_ } ) public SpanMultiTermQueryWrapper ( Q query ) { this . query = Objects . requireNonNull ( query ) ; this . rewriteMethod = selectRewriteMethod ( query ) ; }
public void writeMapEnd ( ) throws IOException { os . write ( STR_ ) ; }
public Shape createArrowUp ( final double x , final double y , final double w , final double h ) { path . reset ( ) ; path . moveTo ( x , y + h ) ; path . lineTo ( x + w / NUM_ , y ) ; path . lineTo ( x + w , y + h ) ; path . closePath ( ) ; return path ; }
protected void fireValueChanged ( ) { ChangeEvent evt = new ChangeEvent ( this ) ; for ( ChangeListener listener : listenerList . getListeners ( ChangeListener . class ) ) { listener . stateChanged ( evt ) ; } }
public static void streamContentToBrowser ( HttpServletResponse response , InputStream in , int length , String contentType , String fileName ) throws IOException { setResponseBrowserProxyNoCache ( response ) ; response . setContentLength ( length ) ; if ( contentType != null ) { response . setContentType ( contentType ) ; } if ( fileName != null ) { response . setHeader ( STR_ , STR_ + fileName ) ; } OutputStream out = response . getOutputStream ( ) ; try { streamContent ( out , in , length ) ; } catch ( IOException e ) { out . close ( ) ; throw e ; } out . flush ( ) ; out . close ( ) ; }
public static ByteBuffer encode ( String string ) throws CharacterCodingException { return encode ( string , BOOL_ ) ; }
public void disableRealtimeStepsNotify ( ) { checkConnection ( ) ; final List < BLEAction > list = new ArrayList < > ( ) ; list . add ( new WriteAction ( Profile . UUID_CHAR_CONTROL_POINT , Protocol . DISABLE_REALTIME_STEPS_NOTIFY ) ) ; queue ( list ) ; }
private static void stableStringSort ( String [ ] arr , String [ ] src , String [ ] dst , int start , int end , int chId ) { int length = end - start ; if ( length < SIMPLE_LENGTH ) { if ( src == arr ) { for ( int i = start + NUM_ ; i < end ; i ++ ) { String current = arr [ i ] ; String prev = arr [ i - NUM_ ] ; if ( current . compareTo ( prev ) < NUM_ ) { int j = i ; do { arr [ j -- ] = prev ; } while ( j > start && current . compareTo ( prev = arr [ j - NUM_ ] ) < NUM_ ) ; arr [ j ] = current ; } } } else { int actualEnd = end - NUM_ ; dst [ start ] = src [ actualEnd -- ] ; for ( int i = start + NUM_ ; i < end ; i ++ , actualEnd -- ) { String current = src [ actualEnd ] ; String prev ; int j = i ; while ( j > start && current . compareTo ( prev = dst [ j - NUM_ ] ) < NUM_ ) { dst [ j -- ] = prev ; } dst [ j ] = current ; } } return ; } int s ; int mid = start + length / NUM_ ; int lo = start ; int hi = end - NUM_ ; if ( length > NUM_ ) { s = length / NUM_ ; lo = medChar ( lo , lo + s , lo + s . NUM_ , src , chId ) ; mid = medChar ( mid - s , mid , mid + s , src , chId ) ; hi = medChar ( hi , hi - s , hi - s . NUM_ , src , chId ) ; } mid = medChar ( lo , mid , hi , src , chId ) ; int midVal = charAt ( src [ mid ] , chId ) ; int a , b , c ; a = b = start ; c = end - NUM_ ; int cmp ; for ( int i = start ; i < end ; i ++ ) { String el = src [ i ] ; cmp = charAt ( el , chId ) - midVal ; if ( cmp < NUM_ ) { src [ a ] = el ; a ++ ; } else if ( cmp > NUM_ ) { dst [ c ] = el ; c -- ; } else { dst [ b ] = el ; b ++ ; } } s = b - start ; if ( s > NUM_ ) { if ( arr == src ) { System . arraycopy ( dst , start , arr , a , s ) ; } else { copySwap ( dst , start , arr , a , s ) ; } if ( b >= end && midVal == - NUM_ ) { return ; } stableStringSort ( arr , arr , arr == dst ? src : dst , a , a + s , chId + NUM_ ) ; } s = a - start ; if ( s > NUM_ ) { stableStringSort ( arr , src , dst , start , a , chId ) ; } c ++ ; s = end - c ; if ( s > NUM_ ) { stableStringSort ( arr , dst , src , c , end , chId ) ; } }
private static Class < ? > [ ] types ( Object ... values ) { if ( values == null ) { return new Class [ NUM_ ] ; } Class < ? > [ ] result = new Class [ values . length ] ; for ( int i = NUM_ ; i < values . length ; i ++ ) { Object value = values [ i ] ; result [ i ] = value == null ? NULL . class : value . getClass ( ) ; } return result ; }
public static void unRegisterTileCodec ( int comp ) { XTIFFTileCodec cod = getTileCodec ( comp ) ; tileCodecs . remove ( cod ) ; }
public static void escape ( StrBuilder toAppend , String text , boolean escapeQuote , boolean escapeApos ) { if ( text == null ) { return ; } for ( int i = NUM_ ; i < text . length ( ) ; i ++ ) { char ch = text . charAt ( i ) ; switch ( ch ) { case STR_ : toAppend . append ( STR_ ) ; break ; case STR_ : toAppend . append ( STR_ ) ; break ; case STR_ : toAppend . append ( STR_ ) ; break ; case STR_ : toAppend . append ( escapeQuote ? STR_ : ch ) ; break ; case STR_ : toAppend . append ( escapeApos ? STR_ : ch ) ; break ; default : toAppend . append ( ch ) ; break ; } } }
public void destroy ( ) { mListeners . clear ( ) ; mSpringSystem . deregisterSpring ( this ) ; }
@ Override public synchronized void removeInstanceListener ( InstanceListener tsl ) { m_instanceListeners . removeElement ( tsl ) ; }
private String readUntil ( char [ ] delimiter , boolean returnText ) throws IOException , XmlPullParserException { int start = position ; StringBuilder result = null ; if ( returnText && text != null ) { result = new StringBuilder ( ) ; result . append ( text ) ; } search : while ( BOOL_ ) { if ( position + delimiter . length > limit ) { if ( start < position && returnText ) { if ( result == null ) { result = new StringBuilder ( ) ; } result . append ( buffer , start , position - start ) ; } if ( ! fillBuffer ( delimiter . length ) ) { checkRelaxed ( UNEXPECTED_EOF ) ; type = COMMENT ; return null ; } start = position ; } for ( int i = NUM_ ; i < delimiter . length ; i ++ ) { if ( buffer [ position + i ] != delimiter [ i ] ) { position ++ ; continue search ; } } break ; } int end = position ; position += delimiter . length ; if ( ! returnText ) { return null ; } else if ( result == null ) { return stringPool . get ( buffer , start , end - start ) ; } else { result . append ( buffer , start , end - start ) ; return result . toString ( ) ; } }
private void toggleFavorite ( ) { for ( String game : list . getSelectedValuesList ( ) ) { if ( favorites . contains ( game ) ) { favorites . remove ( game ) ; } else { favorites . add ( game ) ; } } saveFavorites ( ) ; update ( ) ; }
private void createPartitionRegion ( List vmList , int startIndexForRegion , int endIndexForRegion , int localMaxMemory , int redundancy , boolean firstCreationFlag , boolean multipleVMFlag ) { Iterator nodeIterator = vmList . iterator ( ) ; while ( nodeIterator . hasNext ( ) ) { VM vm = ( VM ) nodeIterator . next ( ) ; vm . invoke ( createMultiplePartitionRegion ( prPrefix , startIndexForRegion , endIndexForRegion , redundancy , localMaxMemory , firstCreationFlag , multipleVMFlag ) ) ; } }
public int write ( byte [ ] destMac , byte [ ] packet , int offset , int byteCount ) { if ( destMac == null ) { throw new NullPointerException ( STR_ ) ; } if ( packet == null ) { throw new NullPointerException ( STR_ ) ; } Arrays . checkOffsetAndCount ( packet . length , offset , byteCount ) ; if ( destMac . length != NUM_ ) { throw new IllegalArgumentException ( STR_ + destMac . length ) ; } return sendPacket ( fd , mInterfaceName , mProtocolType , destMac , packet , offset , byteCount ) ; }
public boolean hasExtensionsWithDeps ( ) { return ! extensionsWithDeps . isEmpty ( ) ; }
public synchronized void addSeries ( XYSeries series ) { mSeries . add ( series ) ; }
private int [ ] calculateTaskCountPerContainer ( int taskCount , int prevContainerCount , int currentContainerCount ) { int [ ] newTaskCountPerContainer = new int [ Math . max ( currentContainerCount , prevContainerCount ) ] ; Arrays . fill ( newTaskCountPerContainer , NUM_ ) ; for ( int i = NUM_ ; i < currentContainerCount ; i ++ ) { newTaskCountPerContainer [ i ] = taskCount / currentContainerCount ; if ( taskCount % currentContainerCount > i ) { newTaskCountPerContainer [ i ] ++ ; } } return newTaskCountPerContainer ; }
@ Override public void actionPerform ( Component component ) { if ( ! isEnabled ( ) ) { return ; } if ( beforeActionPerformedHandler != null ) { if ( ! beforeActionPerformedHandler . beforeActionPerformed ( ) ) return ; } Set selected = target . getSelected ( ) ; if ( ! selected . isEmpty ( ) ) { if ( confirm ) { confirmAndRemove ( selected ) ; } else { remove ( selected ) ; } } }
public void testCompareToPosPos2 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int bSign = NUM_ ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; assertEquals ( - NUM_ , aNumber . compareTo ( bNumber ) ) ; }
static public void generateSeed ( byte [ ] result ) { instance . getSeedBytes ( result ) ; }
private double hammingDistanceNumberVector ( NumberVector o1 , NumberVector o2 ) { final int d1 = o1 . getDimensionality ( ) , d2 = o2 . getDimensionality ( ) ; int differences = NUM_ ; int d = NUM_ ; for ( ; d < d1 && d < d2 ; d ++ ) { double v1 = o1 . doubleValue ( d ) , v2 = o2 . doubleValue ( d ) ; if ( v1 != v1 || v2 != v2 ) { continue ; } if ( v1 != v2 ) { ++ differences ; } } for ( ; d < d1 ; d ++ ) { double v1 = o1 . doubleValue ( d ) ; if ( v1 != NUM_ && v1 == v1 ) { ++ differences ; } } for ( ; d < d2 ; d ++ ) { double v2 = o2 . doubleValue ( d ) ; if ( v2 != NUM_ && v2 == v2 ) { ++ differences ; } } return differences ; }
public static Kernel createKernel ( int kernelType ) { switch ( kernelType ) { case KERNEL_RADIAL : return new KernelRadial ( ) ; case KERNEL_POLYNOMIAL : return new KernelPolynomial ( ) ; case KERNEL_NEURAL : return new KernelNeural ( ) ; default : return new KernelDot ( ) ; } }
protected void checkForPendingTasks ( Collection < URI > tenants , Collection < ? extends DataObject > dataObjects ) { for ( URI tenant : tenants ) { checkForPendingTasks ( tenant , dataObjects ) ; } }
@ org . junit . Test public void verifyGetFloatResponse ( ) throws Exception { Map < String , String > queryParams = new HashMap < String , String > ( ) ; String str = client . invokeAPI ( STR_ , STR_ , queryParams , null , new HashMap < String , String > ( ) , null , STR_ , null , new String [ NUM_ ] ) ; assertEquals ( str , String . valueOf ( ExampleBuilder . SAMPLE_FLOAT_PROPERTY_VALUE ) ) ; }
public void writeOperationsCarFile ( ) { makeBackupFile ( defaultOperationsFilename ( ) ) ; try { if ( ! checkFile ( defaultOperationsFilename ( ) ) ) { java . io . File file = new java . io . File ( defaultOperationsFilename ( ) ) ; java . io . File parentDir = file . getParentFile ( ) ; if ( ! parentDir . exists ( ) ) { if ( ! parentDir . mkdir ( ) ) { log . error ( STR_ ) ; } } if ( file . createNewFile ( ) ) { log . debug ( STR_ ) ; } } writeFile ( defaultOperationsFilename ( ) ) ; } catch ( Exception e ) { log . error ( STR_ + e ) ; } }
private synchronized void rebuildJournal ( ) throws IOException { if ( journalWriter != null ) { journalWriter . close ( ) ; } Writer writer = new BufferedWriter ( new FileWriter ( journalFileTmp ) , IO_BUFFER_SIZE ) ; writer . write ( MAGIC ) ; writer . write ( STR_ ) ; writer . write ( VERSION_1 ) ; writer . write ( STR_ ) ; writer . write ( Integer . toString ( appVersion ) ) ; writer . write ( STR_ ) ; writer . write ( Integer . toString ( valueCount ) ) ; writer . write ( STR_ ) ; writer . write ( STR_ ) ; for ( Entry entry : lruEntries . values ( ) ) { if ( entry . currentEditor != null ) { writer . write ( DIRTY + STR_ + entry . key + STR_ ) ; } else { writer . write ( CLEAN + STR_ + entry . key + entry . getLengths ( ) + STR_ ) ; } } writer . close ( ) ; journalFileTmp . renameTo ( journalFile ) ; journalWriter = new BufferedWriter ( new FileWriter ( journalFile , BOOL_ ) , IO_BUFFER_SIZE ) ; }
public static double median ( final double [ ] values ) { final int len = values . length ; final double [ ] sortedValues = Arrays . copyOf ( values , len ) ; Arrays . sort ( sortedValues ) ; if ( len % NUM_ == NUM_ ) { return ( ( double ) sortedValues [ len / NUM_ ] + ( double ) sortedValues [ len / NUM_ - NUM_ ] ) / NUM_ ; } else { return ( double ) sortedValues [ len / NUM_ ] ; } }
private List < BlockInfo > fillSegmentIdToTableInfoMap ( List < TableBlockInfo > tableBlockInfos , AbsoluteTableIdentifier absoluteTableIdentifier ) { Map < String , List < BlockInfo > > map = segmentIdToBlockListMap . get ( absoluteTableIdentifier ) ; if ( null == map ) { map = new ConcurrentHashMap < String , List < BlockInfo > > ( ) ; segmentIdToBlockListMap . put ( absoluteTableIdentifier , map ) ; } BlockInfo temp = null ; List < BlockInfo > blockInfosNeedToLoad = new ArrayList < > ( ) ; for ( TableBlockInfo info : tableBlockInfos ) { List < BlockInfo > tempTableBlockInfos = map . get ( info . getSegmentId ( ) ) ; if ( null == tempTableBlockInfos ) { tempTableBlockInfos = new ArrayList < > ( ) ; map . put ( info . getSegmentId ( ) , tempTableBlockInfos ) ; } temp = new BlockInfo ( info ) ; if ( ! tempTableBlockInfos . contains ( temp ) ) { tempTableBlockInfos . add ( temp ) ; } blockInfosNeedToLoad . add ( temp ) ; } return blockInfosNeedToLoad ; }
public CharBuffer put ( String str , int start , int end ) { if ( isReadOnly ( ) ) { throw new ReadOnlyBufferException ( ) ; } if ( start < NUM_ || end < start || end > str . length ( ) ) { throw new IndexOutOfBoundsException ( STR_ + str . length ( ) + STR_ + start + STR_ + end ) ; } if ( end - start > remaining ( ) ) { throw new BufferOverflowException ( ) ; } for ( int i = start ; i < end ; i ++ ) { put ( str . charAt ( i ) ) ; } return this ; }
public List < OfferRecommendation > evaluate ( List < Offer > offers ) { List < OfferRecommendation > recommendations = new ArrayList < OfferRecommendation > ( ) ; int offerResourceCount = NUM_ ; for ( Offer offer : offers ) { offerResourceCount += offer . getResourcesCount ( ) ; for ( Resource toDestroy : selectUnexpectedResources ( expectedPersistentVolumeIds , getPersistentVolumesById ( offer ) ) ) { recommendations . add ( new DestroyOfferRecommendation ( offer , toDestroy ) ) ; } } int destroyRecommendationCount = recommendations . size ( ) ; for ( Offer offer : offers ) { for ( Resource toUnreserve : selectUnexpectedResources ( expectedReservedResourceIds , getReservedResourcesById ( offer ) ) ) { recommendations . add ( new UnreserveOfferRecommendation ( offer , toUnreserve ) ) ; } } logger . info ( STR_ , offers . size ( ) , offerResourceCount , destroyRecommendationCount , recommendations . size ( ) - destroyRecommendationCount ) ; return recommendations ; }
@ Override public int update ( ByteBuffer inBuffer , ByteBuffer outBuffer ) throws ShortBufferException { return cipher . update ( inBuffer , outBuffer ) ; }
boolean displayContextAssump ( NodeRepresentation rep , int i ) { return rep . isCreated || ( ( ! state . splitChosen ( ) ) && showContextValue ) ; }
private void unregisterMBeans ( ) { List < ObjectName > unregistered = new ArrayList < ObjectName > ( ) ; for ( ObjectName name : mbeans ) { try { mbeanserver . unregisterMBean ( name ) ; unregistered . add ( name ) ; } catch ( JMException e ) { } } mbeans . removeAll ( unregistered ) ; }
public static void main ( String [ ] argv ) throws IOException , SAXException { Scanner s = new HTMLScanner ( ) ; Reader r = new InputStreamReader ( System . in , STR_ ) ; Writer w = new OutputStreamWriter ( System . out , STR_ ) ; PYXWriter pw = new PYXWriter ( w ) ; s . scan ( r , pw ) ; w . close ( ) ; }
private void createAmpResultStreamMethod ( JavaClass jClass , Method method , int resultOffset ) { String methodName = method . getName ( ) ; Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; Annotation [ ] [ ] parameterAnns = method . getParameterAnnotations ( ) ; addMethod ( method ) ; CodeWriterAttribute code = createMethodHeader ( jClass , method ) ; code . setMaxLocals ( NUM_ + NUM_ . parameterTypes . length ) ; code . setMaxStack ( NUM_ + NUM_ . parameterTypes . length ) ; code . pushObjectVar ( NUM_ ) ; code . getField ( jClass . getThisClass ( ) , STR_ , MessageFactoryAmp . class ) ; int argLen = parameterTypes . length - NUM_ ; code . pushObjectVar ( getLength ( parameterTypes , resultOffset ) + NUM_ ) ; long timeout = _defaultTimeout ; code . pushConstant ( timeout ) ; code . pushObjectVar ( NUM_ ) ; code . getField ( jClass . getThisClass ( ) , STR_ , ServiceRefAmp . class ) ; code . pushObjectVar ( NUM_ ) ; code . getField ( jClass . getThisClass ( ) , fieldName ( method ) , MethodAmp . class ) ; partitionMethod ( code , parameterTypes , parameterAnns ) ; pushParameters ( code , parameterTypes , parameterAnns , NUM_ , NUM_ , argLen + NUM_ , resultOffset ) ; code . invokeInterface ( MessageFactoryAmp . class , STR_ , void . class , ResultStream . class , long . class , ServiceRefAmp . class , MethodAmp . class , Object [ ] . class ) ; code . addReturn ( ) ; code . close ( ) ; }
private static synchronized void endTransaction ( Connection C , boolean successful ) throws AdeException { logger . trace ( STR_ ) ; try { if ( successful ) { C . commit ( ) ; } else { C . rollback ( ) ; } C . setAutoCommit ( BOOL_ ) ; } catch ( Throwable t ) { surfaceThrowable ( STR_ , t ) ; throw adeExceptionOf ( t ) ; } logger . trace ( STR_ ) ; }
public double [ ] estimateL2DistanceSquared ( Datum queryDatum ) { RealVector vector = queryDatum . metrics ( ) ; double [ ] estimates = new double [ NUM_ ] ; for ( int i = NUM_ ; i < k ; i ++ ) { double deltaLo = vector . getEntry ( i ) - this . boundaries [ i ] [ NUM_ ] ; double deltaHi = this . boundaries [ i ] [ NUM_ ] - vector . getEntry ( i ) ; double sqDeltaLo = deltaLo . deltaLo ; double sqDeltaHi = deltaHi . deltaHi ; if ( deltaLo < NUM_ || deltaHi < NUM_ ) { if ( sqDeltaHi < sqDeltaLo ) { estimates [ NUM_ ] += sqDeltaHi ; estimates [ NUM_ ] += sqDeltaLo ; } else { estimates [ NUM_ ] += sqDeltaLo ; estimates [ NUM_ ] += sqDeltaHi ; } } else { estimates [ NUM_ ] += Math . max ( sqDeltaHi , sqDeltaLo ) ; } } return estimates ; }
private void deserializeClass ( File file ) throws RuntimeException { try { FileInputStream in = new FileInputStream ( file ) ; ObjectInputStream objIn = new ObjectInputStream ( in ) ; Object o = objIn . readObject ( ) ; in . close ( ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( STR_ + STR_ + file + STR_ + STR_ + STR_ , e ) ; } catch ( IOException e ) { throw new RuntimeException ( STR_ + STR_ + file + STR_ , e ) ; } }
public boolean calculateTaxTotal ( ) { log . fine ( STR_ ) ; DB . executeUpdateEx ( STR_ + getC_Invoice_ID ( ) , get_TrxName ( ) ) ; m_taxes = null ; BigDecimal totalLines = Env . ZERO ; ArrayList < Integer > taxList = new ArrayList < Integer > ( ) ; MInvoiceLine [ ] lines = getLines ( BOOL_ ) ; for ( int i = NUM_ ; i < lines . length ; i ++ ) { MInvoiceLine line = lines [ i ] ; if ( ! taxList . contains ( line . getC_Tax_ID ( ) ) ) { MInvoiceTax iTax = MInvoiceTax . get ( line , getPrecision ( ) , BOOL_ , get_TrxName ( ) ) ; if ( iTax != null ) { iTax . setIsTaxIncluded ( isTaxIncluded ( ) ) ; if ( ! iTax . calculateTaxFromLines ( ) ) return BOOL_ ; iTax . saveEx ( ) ; taxList . add ( line . getC_Tax_ID ( ) ) ; } } totalLines = totalLines . add ( line . getLineNetAmt ( ) ) ; } BigDecimal grandTotal = totalLines ; MInvoiceTax [ ] taxes = getTaxes ( BOOL_ ) ; for ( int i = NUM_ ; i < taxes . length ; i ++ ) { MInvoiceTax iTax = taxes [ i ] ; MTax tax = iTax . getTax ( ) ; if ( tax . isSummary ( ) ) { MTax [ ] cTaxes = tax . getChildTaxes ( BOOL_ ) ; for ( int j = NUM_ ; j < cTaxes . length ; j ++ ) { MTax cTax = cTaxes [ j ] ; BigDecimal taxAmt = cTax . calculateTax ( iTax . getTaxBaseAmt ( ) , isTaxIncluded ( ) , getPrecision ( ) ) ; MInvoiceTax newITax = new MInvoiceTax ( getCtx ( ) , NUM_ , get_TrxName ( ) ) ; newITax . setClientOrg ( this ) ; newITax . setC_Invoice_ID ( getC_Invoice_ID ( ) ) ; newITax . setC_Tax_ID ( cTax . getC_Tax_ID ( ) ) ; newITax . setPrecision ( getPrecision ( ) ) ; newITax . setIsTaxIncluded ( isTaxIncluded ( ) ) ; newITax . setTaxBaseAmt ( iTax . getTaxBaseAmt ( ) ) ; newITax . setTaxAmt ( taxAmt ) ; newITax . saveEx ( get_TrxName ( ) ) ; if ( ! isTaxIncluded ( ) ) grandTotal = grandTotal . add ( taxAmt ) ; } iTax . deleteEx ( BOOL_ , get_TrxName ( ) ) ; } else { if ( ! isTaxIncluded ( ) ) grandTotal = grandTotal . add ( iTax . getTaxAmt ( ) ) ; } } setTotalLines ( totalLines ) ; setGrandTotal ( grandTotal ) ; return BOOL_ ; }
private boolean canOpen ( ) { for ( final INaviProject project : m_projects ) { if ( project . isLoaded ( ) ) { return BOOL_ ; } } return BOOL_ ; }
public static Array listWithQuotesToArray ( String list , String delimiter , String quotes ) { if ( list . length ( ) == NUM_ ) return new ArrayImpl ( ) ; int len = list . length ( ) ; int last = NUM_ ; char [ ] del = delimiter . toCharArray ( ) ; char [ ] quo = quotes . toCharArray ( ) ; char c ; char inside = NUM_ ; ArrayImpl array = new ArrayImpl ( ) ; try { for ( int i = NUM_ ; i < len ; i ++ ) { c = list . charAt ( i ) ; for ( int y = NUM_ ; y < quo . length ; y ++ ) { if ( c == quo [ y ] ) { if ( c == inside ) inside = NUM_ ; else if ( inside == NUM_ ) inside = c ; continue ; } } for ( int y = NUM_ ; y < del . length ; y ++ ) { if ( inside == NUM_ && c == del [ y ] ) { array . _append ( list . substring ( last , i ) ) ; last = i + NUM_ ; break ; } } } if ( last <= len ) array . append ( list . substring ( last ) ) ; } catch ( ExpressionException e ) { } return array ; }
public MLOutput execute ( String dmlScriptFilePath , ArrayList < String > argsName , ArrayList < String > argsValues , String configFilePath ) throws IOException , DMLException , ParseException { HashMap < String , String > newNamedArgs = new HashMap < String , String > ( ) ; if ( argsName . size ( ) != argsValues . size ( ) ) { throw new DMLException ( STR_ + argsName . size ( ) + STR_ + STR_ ) ; } for ( int i = NUM_ ; i < argsName . size ( ) ; i ++ ) { String k = argsName . get ( i ) ; String v = argsValues . get ( i ) ; newNamedArgs . put ( k , v ) ; } return execute ( dmlScriptFilePath , newNamedArgs , configFilePath ) ; }
public boolean isInMemoryDb ( ) { return path . equalsIgnoreCase ( MEMORY_DB_PATH ) ; }
private static boolean testSpecificValue ( double x , double y , double expectedValue , double interpValue ) { logger . info ( STR_ + x + STR_ + y + STR_ + expectedValue + STR_ + interpValue + STR_ ) ; boolean specificValueInterpUseful = BOOL_ ; if ( interpValue > expectedValue + NUM_ || interpValue < expectedValue - NUM_ ) specificValueInterpUseful = BOOL_ ; return specificValueInterpUseful ; }
public InputSource resolveEntity ( String publicId , String systemId ) throws SAXException , IOException { hasDTD = BOOL_ ; String dtd = UtilProperties . getSplitPropertyValue ( UtilURL . fromResource ( STR_ ) , publicId ) ; if ( UtilValidate . isNotEmpty ( dtd ) ) { if ( Debug . verboseOn ( ) ) Debug . logVerbose ( STR_ + publicId + STR_ + systemId + STR_ + dtd + STR_ , module ) ; try { URL dtdURL = UtilURL . fromResource ( dtd ) ; if ( dtdURL == null ) { throw new GeneralException ( STR_ + dtd ) ; } InputStream dtdStream = dtdURL . openStream ( ) ; InputSource inputSource = new InputSource ( dtdStream ) ; inputSource . setPublicId ( publicId ) ; hasDTD = BOOL_ ; if ( Debug . verboseOn ( ) ) Debug . logVerbose ( STR_ + publicId + STR_ + dtd + STR_ , module ) ; return inputSource ; } catch ( Exception e ) { Debug . logWarning ( e , module ) ; } } else { int lastSlash = systemId . lastIndexOf ( STR_ ) ; String filename = null ; if ( lastSlash == - NUM_ ) { filename = systemId ; } else { filename = systemId . substring ( lastSlash + NUM_ ) ; } URL resourceUrl = UtilURL . fromResource ( filename ) ; if ( resourceUrl != null ) { InputStream resStream = resourceUrl . openStream ( ) ; InputSource inputSource = new InputSource ( resStream ) ; if ( UtilValidate . isNotEmpty ( publicId ) ) { inputSource . setPublicId ( publicId ) ; } hasDTD = BOOL_ ; if ( Debug . verboseOn ( ) ) Debug . logVerbose ( STR_ + publicId + STR_ + filename + STR_ , module ) ; return inputSource ; } else { Debug . logWarning ( STR_ + publicId + STR_ + filename + STR_ , module ) ; return null ; } } return defaultResolver . resolveEntity ( publicId , systemId ) ; }
@ Override public String leaveDTD ( ) { if ( _writer == _dtdWriter ) { _line . append ( _text ) ; _text = new StringBuffer ( NUM_ ) ; flushLine ( BOOL_ ) ; _writer = _docWriter ; return _dtdWriter . toString ( ) ; } return null ; }
private static ClassNode loadClass ( String name , Config config ) throws Exception { String filePath = config . getClassDumpPath ( ) + name . replace ( STR_ , STR_ ) + STR_ ; ClassReader reader = new ClassReader ( new FileInputStream ( filePath ) ) ; ClassNode node = new ClassNode ( ) ; reader . accept ( node , ClassReader . EXPAND_FRAMES ) ; return node ; }
public void write ( char [ ] cbuf , int off , int len ) throws IOException { internalOut . write ( cbuf , off , len ) ; }
public void add ( final String clazz , final String subclazz , final boolean blocked ) { entries . add ( new Entry ( clazz , subclazz , blocked ) ) ; }
private synchronized void bufferChange ( ) throws ReadFailedException { ByteBuffer current = super . getByteBuffer ( ) ; if ( null != current ) { current . clear ( ) ; emptyBuffers . add ( current ) ; } int tries = NUM_ ; while ( BOOL_ ) { try { ByteBuffer buffer = fullBuffers . poll ( NUM_ , TimeUnit . MILLISECONDS ) ; if ( null != buffer ) { super . setByteBuffer ( buffer ) ; break ; } else { tries ++ ; if ( readFailed || ( tries > MAX_BUFFER_POOL_TRIES ) ) { throw new ReadFailedException ( STR_ ) ; } } } catch ( InterruptedException e ) { Thread . interrupted ( ) ; } } }
protected synchronized Class loadClass ( String name , boolean resolve ) throws ClassNotFoundException { Class c = findLoadedClass ( name ) ; if ( c == null ) c = findClass ( name ) ; if ( c == null ) throw new ClassNotFoundException ( name ) ; if ( resolve ) resolveClass ( c ) ; return c ; }
@ SuppressWarnings ( { STR_ , STR_ } ) public static Comparable < ? > max ( Comparable < ? > [ ] ar ) { Comparable ret = ar [ NUM_ ] ; for ( int i = NUM_ ; i < ar . length ; i ++ ) { if ( ret . compareTo ( ar [ i ] ) < NUM_ ) { ret = ar [ i ] ; } } return ret ; }
private void initBPRMADetails ( int C_BPartner_ID ) { rmaField . removeActionListener ( this ) ; rmaField . removeAllItems ( ) ; KeyNamePair pp = new KeyNamePair ( NUM_ , STR_ ) ; rmaField . addItem ( pp ) ; ArrayList < KeyNamePair > list = loadRMAData ( C_BPartner_ID ) ; for ( KeyNamePair knp : list ) rmaField . addItem ( knp ) ; rmaField . setSelectedIndex ( NUM_ ) ; rmaField . addActionListener ( this ) ; }
protected void resetOptions ( ) { m_maxStale = NUM_ ; m_searchDirection = SELECTION_FORWARD ; m_starting = null ; m_startRange = new Range ( ) ; m_classIndex = - NUM_ ; m_totalEvals = NUM_ ; m_cacheSize = NUM_ ; m_debug = BOOL_ ; }
@ Override protected void tearDown ( ) throws Exception { try { takeScreenShot ( ) ; } catch ( Throwable throwable ) { throwable . printStackTrace ( ) ; } super . tearDown ( ) ; }
public synchronized void clear ( ) { mCategories . clear ( ) ; mValues . clear ( ) ; }
private boolean itera_connect ( PlaPointInt p_from_point , PlaPointInt p_to_point ) { ArrayList < PlaPointInt > corners = angled_connection ( p_from_point , p_to_point ) ; boolean connection_succeeded = BOOL_ ; for ( int index = NUM_ ; index < corners . size ( ) ; ++ index ) { PlaPointInt from_corner = corners . get ( index - NUM_ ) ; PlaPointInt to_corner = corners . get ( index ) ; TimeLimit time_limit = new TimeLimit ( s_CHECK_FORCED_TRACE_TIME_MAX ) ; while ( ! from_corner . equals ( to_corner ) ) { PlaPointInt curr_ok_point = r_board . insert_trace ( from_corner , to_corner , pen_half_width_arr [ layer_active_no ] , layer_active_no , net_nos , clearance_class , max_shove_trace_recursion_depth , max_shove_via_recursion_depth , max_spring_over_recursion_depth , itera_settings . trace_pullt_min_move , ! is_stitch_mode , time_limit ) ; if ( curr_ok_point == null ) { r_board . undo ( null ) ; return BOOL_ ; } if ( curr_ok_point . equals ( from_corner ) && itera_settings . is_automatic_neckdown ( ) ) { curr_ok_point = try_neckdown_at_end ( from_corner , to_corner ) ; } if ( curr_ok_point . equals ( from_corner ) ) { prev_corner = from_corner ; connection_succeeded = BOOL_ ; break ; } from_corner = curr_ok_point ; } } return connection_succeeded ; }
private Node < K , V > findPredecessorOfLast ( ) { for ( ; ; ) { Index < K , V > q = head ; for ( ; ; ) { Index < K , V > d , r ; if ( ( r = q . right ) != null ) { if ( r . indexesDeletedNode ( ) ) { q . unlink ( r ) ; break ; } if ( r . node . next != null ) { q = r ; continue ; } } if ( ( d = q . down ) != null ) q = d ; else return q . node ; } } }
public boolean query ( int objectToQuery , long [ ] [ ] hashFunctions ) { for ( long [ ] h : hashFunctions ) { int i = hash ( h , ( long ) objectToQuery ) ; if ( ! bitSet . get ( i ) ) return BOOL_ ; } return BOOL_ ; }
public void clear ( ) { synchronized ( mLock ) { mGraphics . clear ( ) ; } postInvalidate ( ) ; }
@ SafeVarargs public static < V > Set < V > createSet ( V ... values ) { Set < V > set = new LinkedHashSet < V > ( ) ; for ( V v : values ) { set . add ( v ) ; } return set ; }
@ Override void doConstrainedOutsideScores ( Grammar grammar , boolean viterbi , boolean logScores ) { short [ ] numSubStatesArray = grammar . numSubStates ; double initVal = ( logScores ) ? Double . NEGATIVE_INFINITY : NUM_ ; for ( int diff = length ; diff >= NUM_ ; diff -- ) { for ( int start = NUM_ ; start + diff <= length ; start ++ ) { int end = start + diff ; double [ ] [ ] scoresAfterUnaries = new double [ numStates ] [ ] ; boolean somethingChanged = BOOL_ ; for ( int cState = NUM_ ; cState < numStates ; cState ++ ) { if ( diff > NUM_ && ! grammar . isGrammarTag [ cState ] ) continue ; if ( ! allowedStates [ start ] [ end ] [ cState ] ) { continue ; } UnaryRule [ ] rules = null ; if ( viterbi ) rules = grammar . getClosedViterbiUnaryRulesByChild ( cState ) ; else rules = grammar . getClosedSumUnaryRulesByChild ( cState ) ; final int nChildStates = numSubStatesArray [ cState ] ; final int numRules = rules . length ; for ( int r = NUM_ ; r < numRules ; r ++ ) { UnaryRule ur = rules [ r ] ; int pState = ur . parentState ; if ( ( pState == cState ) ) continue ; if ( ! allowedStates [ start ] [ end ] [ pState ] ) { continue ; } double [ ] [ ] scores = ur . getScores2 ( ) ; final int nParentStates = numSubStatesArray [ pState ] ; for ( int cp = NUM_ ; cp < nChildStates ; cp ++ ) { if ( scores [ cp ] == null ) continue ; if ( ! allowedSubStates [ start ] [ end ] [ cState ] [ cp ] ) continue ; for ( int np = NUM_ ; np < nParentStates ; np ++ ) { double pS = scores [ cp ] [ np ] ; if ( pS == initVal ) continue ; double oS = oScore [ start ] [ end ] [ pState ] [ np ] ; if ( oS == initVal ) continue ; double thisRound = ( logScores ) ? oS + pS : oS . pS ; if ( scoresAfterUnaries [ cState ] == null ) { scoresAfterUnaries [ cState ] = new double [ numSubStatesArray [ cState ] ] ; if ( viterbi ) Arrays . fill ( scoresAfterUnaries [ cState ] , initVal ) ; } if ( viterbi ) scoresAfterUnaries [ cState ] [ cp ] = Math . max ( thisRound , scoresAfterUnaries [ cState ] [ cp ] ) ; else scoresAfterUnaries [ cState ] [ cp ] += thisRound ; somethingChanged = BOOL_ ; } } } } if ( somethingChanged ) { for ( int cState = NUM_ ; cState < numStates ; cState ++ ) { double [ ] thisCell = scoresAfterUnaries [ cState ] ; if ( thisCell == null ) continue ; for ( int cp = NUM_ ; cp < numSubStatesArray [ cState ] ; cp ++ ) { if ( thisCell [ cp ] > initVal ) { if ( viterbi ) oScore [ start ] [ end ] [ cState ] [ cp ] = Math . max ( oScore [ start ] [ end ] [ cState ] [ cp ] , thisCell [ cp ] ) ; else oScore [ start ] [ end ] [ cState ] [ cp ] += thisCell [ cp ] ; } } } } for ( int pState = NUM_ ; pState < numSubStatesArray . length ; pState ++ ) { if ( ! allowedStates [ start ] [ end ] [ pState ] ) { continue ; } final int nParentChildStates = numSubStatesArray [ pState ] ; BinaryRule [ ] rules = grammar . splitRulesWithP ( pState ) ; final int numRules = rules . length ; for ( int r = NUM_ ; r < numRules ; r ++ ) { BinaryRule br = rules [ r ] ; int lState = br . leftChildState ; int min1 = narrowRExtent [ start ] [ lState ] ; if ( end < min1 ) { continue ; } int rState = br . rightChildState ; int max1 = narrowLExtent [ end ] [ rState ] ; if ( max1 < min1 ) { continue ; } int min = min1 ; int max = max1 ; if ( max - min > NUM_ ) { int min2 = wideLExtent [ end ] [ rState ] ; min = ( min1 > min2 ? min1 : min2 ) ; if ( max1 < min ) { continue ; } int max2 = wideRExtent [ start ] [ lState ] ; max = ( max1 < max2 ? max1 : max2 ) ; if ( max < min ) { continue ; } } double [ ] [ ] [ ] scores = br . getScores2 ( ) ; final int nLeftChildStates = numSubStatesArray [ lState ] ; final int nRightChildStates = numSubStatesArray [ rState ] ; for ( int split = min ; split <= max ; split ++ ) { if ( ! allowedStates [ start ] [ split ] [ lState ] ) continue ; if ( ! allowedStates [ split ] [ end ] [ rState ] ) continue ; double [ ] rightScores = new double [ nRightChildStates ] ; if ( viterbi ) Arrays . fill ( rightScores , initVal ) ; Arrays . fill ( scoresToAdd , initVal ) ; somethingChanged = BOOL_ ; for ( int lp = NUM_ ; lp < nLeftChildStates ; lp ++ ) { double lS = iScore [ start ] [ split ] [ lState ] [ lp ] ; if ( lS == initVal ) { continue ; } for ( int rp = NUM_ ; rp < nRightChildStates ; rp ++ ) { if ( scores [ lp ] [ rp ] == null ) continue ; double rS = iScore [ split ] [ end ] [ rState ] [ rp ] ; if ( rS == initVal ) { continue ; } for ( int np = NUM_ ; np < nParentChildStates ; np ++ ) { double pS = scores [ lp ] [ rp ] [ np ] ; if ( pS == initVal ) continue ; double oS = oScore [ start ] [ end ] [ pState ] [ np ] ; if ( oS == initVal ) continue ; double thisRoundL = ( logScores ) ? pS + rS + oS : pS . rS . oS ; double thisRoundR = ( logScores ) ? pS + lS + oS : pS . lS . oS ; if ( viterbi ) { scoresToAdd [ lp ] = Math . max ( thisRoundL , scoresToAdd [ lp ] ) ; rightScores [ rp ] = Math . max ( thisRoundR , rightScores [ rp ] ) ; } else { scoresToAdd [ lp ] += thisRoundL ; rightScores [ rp ] += thisRoundR ; } somethingChanged = BOOL_ ; } } } if ( ! somethingChanged ) continue ; for ( int cp = NUM_ ; cp < nLeftChildStates ; cp ++ ) { if ( scoresToAdd [ cp ] > initVal ) { if ( viterbi ) oScore [ start ] [ split ] [ lState ] [ cp ] = Math . max ( oScore [ start ] [ split ] [ lState ] [ cp ] , scoresToAdd [ cp ] ) ; else oScore [ start ] [ split ] [ lState ] [ cp ] += scoresToAdd [ cp ] ; } } for ( int cp = NUM_ ; cp < nRightChildStates ; cp ++ ) { if ( rightScores [ cp ] > initVal ) { if ( viterbi ) oScore [ split ] [ end ] [ rState ] [ cp ] = Math . max ( oScore [ split ] [ end ] [ rState ] [ cp ] , rightScores [ cp ] ) ; else oScore [ split ] [ end ] [ rState ] [ cp ] += rightScores [ cp ] ; } } } } } } } }
public void stop ( ) { timeMonIndex = NUM_ ; setException ( ) ; Iterator iter = iter ( ) ; while ( iter . hasNext ( ) ) { HttpMonItem monItem = ( HttpMonItem ) iter . next ( ) ; monItem . stop ( this ) ; } if ( stackTrace != null ) changeDetails ( ) ; }
public void calcMinTick ( ) { if ( minData == NUM_ ) minTick = NUM_ ; else minTick = Math . floor ( minData / majorTick ) . majorTick ; }
public static void switchTiming ( String nextPhase ) { stopMostRecentTimer ( ) ; startTiming ( nextPhase ) ; }
public byte [ ] encode ( ) { char type = getAttributeType ( ) ; if ( ! isTypeValid ( type ) ) throw new IllegalStateException ( ( ( int ) type ) + STR_ ) ; byte binValue [ ] = new byte [ HEADER_LENGTH + getDataLength ( ) ] ; binValue [ NUM_ ] = ( byte ) ( type > > NUM_ ) ; binValue [ NUM_ ] = ( byte ) ( type & x00FF ) ; binValue [ NUM_ ] = ( byte ) ( getDataLength ( ) > > NUM_ ) ; binValue [ NUM_ ] = ( byte ) ( getDataLength ( ) & x00FF ) ; binValue [ NUM_ ] = x00 ; binValue [ NUM_ ] = getFamily ( ) ; binValue [ NUM_ ] = ( byte ) ( getPort ( ) > > NUM_ ) ; binValue [ NUM_ ] = ( byte ) ( getPort ( ) & x00FF ) ; if ( getFamily ( ) == ADDRESS_FAMILY_IPV6 ) { System . arraycopy ( getAddressBytes ( ) , NUM_ , binValue , NUM_ , NUM_ ) ; } else { System . arraycopy ( getAddressBytes ( ) , NUM_ , binValue , NUM_ , NUM_ ) ; } return binValue ; }
private void doDeleteEntry ( String alias ) throws Exception { if ( keyStore . containsAlias ( alias ) == BOOL_ ) { MessageFormat form = new MessageFormat ( rb . getString ( STR_ ) ) ; Object [ ] source = { alias } ; throw new Exception ( form . format ( source ) ) ; } keyStore . deleteEntry ( alias ) ; }
protected Integer mapThrowableFlat ( Throwable throwable ) { Class < ? extends Throwable > throwableClass = throwable . getClass ( ) ; Integer resId = throwableToMsgIdMap . get ( throwableClass ) ; if ( resId == null ) { Class < ? extends Throwable > closestClass = null ; Set < Entry < Class < ? extends Throwable > , Integer > > mappings = throwableToMsgIdMap . entrySet ( ) ; for ( Entry < Class < ? extends Throwable > , Integer > mapping : mappings ) { Class < ? extends Throwable > candidate = mapping . getKey ( ) ; if ( candidate . isAssignableFrom ( throwableClass ) ) { if ( closestClass == null || closestClass . isAssignableFrom ( candidate ) ) { closestClass = candidate ; resId = mapping . getValue ( ) ; } } } } return resId ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( ) ; newVector . add ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . add ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return newVector . elements ( ) ; }
public void assertColumnType ( ResultSet rs ) throws SQLException { ResultSetMetaData md = rs . getMetaData ( ) ; int sqlType = md . getColumnType ( mdi . getPosition ( ) ) ; assertTrue ( String . format ( STR_ , sqlType , mdi ) , isAllowedSqlType ( sqlType ) ) ; }
private void validateDnsNames ( Set dnsNameSet ) throws PolicyException { Iterator dnsNames = dnsNameSet . iterator ( ) ; while ( dnsNames . hasNext ( ) ) { String dnsName = ( String ) dnsNames . next ( ) ; validateDnsName ( dnsName ) ; dnsList . add ( dnsName . toLowerCase ( ) ) ; } }
public static boolean isMopMethod ( String methodName ) { return ( methodName . startsWith ( STR_ ) || methodName . startsWith ( STR_ ) ) && ! methodName . contains ( STR_ ) ; }
protected void init ( ) { GraphicsConfigTemplate3D template = new GraphicsConfigTemplate3D ( ) ; GraphicsEnvironment env = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; GraphicsDevice device = env . getDefaultScreenDevice ( ) ; GraphicsConfiguration config = device . getBestConfiguration ( template ) ; canvas = new Canvas3D ( config ) ; canvas . setSize ( new Dimension ( DEFAULT_DIMENSION , DEFAULT_DIMENSION ) ) ; objRootBG = new BranchGroup ( ) ; objRootBG . setCapability ( Group . ALLOW_CHILDREN_EXTEND ) ; constructWorld ( objRootBG ) ; }
private < Delegated > PresenterBinder < ? super Delegated > findPresenterBinderForClass ( Class < Delegated > clazz ) throws IllegalAccessException , InstantiationException { PresenterBinder < ? super Delegated > presenterBinder ; String clsName = clazz . getName ( ) ; String className = clsName + PRESENTER_BINDER_SUFFIX ; try { Class < ? > presenterBinderClass = Class . forName ( className ) ; presenterBinder = ( PresenterBinder < ? super Delegated > ) presenterBinderClass . newInstance ( ) ; } catch ( ClassNotFoundException e ) { return null ; } return presenterBinder ; }
@ Override final Node < K , V > find ( int h , Object k ) { if ( k != null ) { for ( Node < K , V > e = first ; e != null ; ) { int s ; if ( ( ( s = lockState ) & ( WAITER | WRITER ) ) != NUM_ ) { if ( e . hash == h && isEqual ( ( K ) k , e . key , myHashingStrategy ) ) { return e ; } e = e . next ; } else if ( U . compareAndSwapInt ( this , LOCKSTATE , s , s + READER ) ) { TreeNode < K , V > r , p ; try { p = ( ( r = root ) == null ? null : r . findTreeNode ( h , k , null ) ) ; } finally { int ls ; do { } while ( ! U . compareAndSwapInt ( this , LOCKSTATE , ls = lockState , ls - READER ) ) ; Thread w ; if ( ls == ( READER | WAITER ) && ( w = waiter ) != null ) { LockSupport . unpark ( w ) ; } } return p ; } } } return null ; }
public void square ( double x , double y , double r ) { if ( r < NUM_ ) throw new IllegalArgumentException ( STR_ ) ; double xs = scaleX ( x ) ; double ys = scaleY ( y ) ; double ws = factorX ( NUM_ . r ) ; double hs = factorY ( NUM_ . r ) ; if ( ws <= NUM_ && hs <= NUM_ ) pixel ( x , y ) ; else offscreen . draw ( new Rectangle2D . Double ( xs - ws / NUM_ , ys - hs / NUM_ , ws , hs ) ) ; draw ( ) ; }
private float clampMag ( float value , float absMin , float absMax ) { final float absValue = Math . abs ( value ) ; if ( absValue < absMin ) return NUM_ ; if ( absValue > absMax ) return value > NUM_ ? absMax : - absMax ; return value ; }
private int lowerHeightMap ( int x , int y , int z ) { for ( -- y ; y >= NUM_ ; -- y ) { if ( getType ( x , z , y ) != NUM_ ) { break ; } } return y + NUM_ ; }
public String toString ( ) { StringBuffer result = new StringBuffer ( STR_ ) ; for ( int i = NUM_ ; i < intervalls . size ( ) ; i ++ ) result . append ( intervalls . elementAt ( i ) ) ; result . append ( STR_ ) ; return result . toString ( ) ; }
public void remove ( @ NotNull StatusNotification notification ) { stack . remove ( notification ) ; onClose ( notification ) ; }
private JobDefinitionEntity createOrUpdateJobDefinitionEntity ( JobDefinitionEntity jobDefinitionEntity , NamespaceEntity namespaceEntity , String jobName , String description , String activitiId , List < Parameter > parameters , S3PropertiesLocation s3PropertiesLocation ) { JobDefinitionEntity jobDefinitionEntityLocal = jobDefinitionEntity ; if ( jobDefinitionEntityLocal == null ) { jobDefinitionEntityLocal = new JobDefinitionEntity ( ) ; } jobDefinitionEntityLocal . setName ( jobName ) ; jobDefinitionEntityLocal . setNamespace ( namespaceEntity ) ; jobDefinitionEntityLocal . setDescription ( description ) ; jobDefinitionEntityLocal . setActivitiId ( activitiId ) ; String bucketName = null ; String key = null ; if ( s3PropertiesLocation != null ) { bucketName = s3PropertiesLocation . getBucketName ( ) ; key = s3PropertiesLocation . getKey ( ) ; } jobDefinitionEntityLocal . setS3BucketName ( bucketName ) ; jobDefinitionEntityLocal . setS3ObjectKey ( key ) ; List < JobDefinitionParameterEntity > parameterEntities = new ArrayList < > ( ) ; if ( ! CollectionUtils . isEmpty ( parameters ) ) { for ( Parameter parameter : parameters ) { JobDefinitionParameterEntity parameterEntity = new JobDefinitionParameterEntity ( ) ; parameterEntities . add ( parameterEntity ) ; parameterEntity . setName ( parameter . getName ( ) ) ; parameterEntity . setValue ( parameter . getValue ( ) ) ; } } jobDefinitionEntityLocal . setParameters ( parameterEntities ) ; return jobDefinitionEntityLocal ; }
@ RequestMapping ( value = { STR_ , STR_ } , method = RequestMethod . PUT ) @ ResponseBody public RestWrapper insert ( @ ModelAttribute ( STR_ ) @ Valid Users users , BindingResult bindingResult , Principal principal ) { RestWrapper restWrapper = null ; if ( bindingResult . hasErrors ( ) ) { BindingResultError bindingResultError = new BindingResultError ( ) ; return bindingResultError . errorMessage ( bindingResult ) ; } try { String hashedPassword = DigestUtils . sha1Hex ( users . getPassword ( ) ) ; com . wipro . ats . bdre . md . dao . jpa . Users jpaUsers = new com . wipro . ats . bdre . md . dao . jpa . Users ( ) ; jpaUsers . setPassword ( hashedPassword ) ; jpaUsers . setUsername ( users . getUsername ( ) ) ; jpaUsers . setEnabled ( ( users . getEnabled ( ) == NUM_ ) ? BOOL_ : BOOL_ ) ; usersDAO . insert ( jpaUsers ) ; restWrapper = new RestWrapper ( users , RestWrapper . OK ) ; LOGGER . info ( STR_ + users . getUsername ( ) + STR_ + principal . getName ( ) + users ) ; } catch ( Exception e ) { LOGGER . error ( e ) ; restWrapper = new RestWrapper ( e . getMessage ( ) , RestWrapper . ERROR ) ; } return restWrapper ; }
public static String cappedInt ( final long val ) { if ( val >= Integer . MAX_VALUE ) { return OVER ; } else if ( val <= Integer . MIN_VALUE ) { return UNDER ; } return Long . toString ( val ) ; }
private void createFromAssets ( String myDBName , File dbfile , InputStream assetFileInputStream ) { OutputStream out = null ; try { String dbPath = dbfile . getAbsolutePath ( ) ; dbPath = dbPath . substring ( NUM_ , dbPath . lastIndexOf ( STR_ ) + NUM_ ) ; File dbPathFile = new File ( dbPath ) ; if ( ! dbPathFile . exists ( ) ) dbPathFile . mkdirs ( ) ; File newDbFile = new File ( dbPath + myDBName ) ; out = new FileOutputStream ( newDbFile ) ; byte [ ] buf = new byte [ NUM_ ] ; int len ; while ( ( len = assetFileInputStream . read ( buf ) ) > NUM_ ) out . write ( buf , NUM_ , len ) ; Log . v ( STR_ , STR_ + newDbFile . getAbsolutePath ( ) ) ; } catch ( IOException ex ) { Log . v ( STR_ , STR_ + ex . getMessage ( ) ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException ignored ) { } } } }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case NUM_ : return PERSON_PROPERTY ; case NUM_ : return PAGE_PROPERTY ; case NUM_ : return EQUIV ; case NUM_ : return PAGE_VIEW ; default : return null ; } }
protected String internalPut ( String key , String newValue ) { synchronized ( childAndPropertyLock ) { String oldValue = properties . get ( key ) ; if ( oldValue != null && oldValue . equals ( newValue ) ) return oldValue ; properties = properties . put ( key , newValue ) ; return oldValue ; } }
public Polyline ( PlaPointInt p_from_corner , PlaPointInt p_to_corner ) { if ( p_from_corner . equals ( p_to_corner ) ) throw new IllegalArgumentException ( classname + STR_ ) ; lines_list = new ArrayList < PlaLineInt > ( NUM_ ) ; PlaDirection dir = new PlaDirection ( p_from_corner , p_to_corner ) ; lines_list . add ( new PlaLineInt ( p_from_corner , dir . rotate_45_deg ( NUM_ ) ) ) ; lines_list . add ( new PlaLineInt ( p_from_corner , p_to_corner ) ) ; lines_list . add ( new PlaLineInt ( p_to_corner , dir . rotate_45_deg ( NUM_ ) ) ) ; corners_allocate ( corner_count ( ) ) ; precalculated_corners [ NUM_ ] = p_from_corner ; precalculated_corners [ NUM_ ] = p_to_corner ; }
protected boolean isOnSameScreenAsChildren ( ) { return BOOL_ ; }
public static String formatPrice ( Double price ) { if ( price == null ) return STR_ ; return formatPrice ( price . doubleValue ( ) ) ; }
static void checkLogDir ( ) { if ( System . getProperty ( STR_ ) == null ) { log . error ( STR_ ) ; } }
private static boolean isMoreAbove ( String src , int index ) { int ch ; int cc ; int len = src . length ( ) ; for ( int i = index + Character . charCount ( src . codePointAt ( index ) ) ; i < len ; i += Character . charCount ( ch ) ) { ch = src . codePointAt ( i ) ; cc = Normalizer . getCombiningClass ( ch ) ; if ( cc == COMBINING_CLASS_ABOVE ) { return BOOL_ ; } else if ( cc == NUM_ ) { return BOOL_ ; } } return BOOL_ ; }
public void restoreKey ( String key ) { if ( ! key . equalsIgnoreCase ( STR_ ) ) { String originalKey = key . substring ( keyTestMode . length ( ) ) ; Object value = get ( key ) ; put ( originalKey , value ) ; clear ( key ) ; } }
public boolean hasUnsupportedCriticalExtension ( ) { Set extns = getCriticalExtensionOIDs ( ) ; if ( extns == null ) { return BOOL_ ; } extns . remove ( RFC3280CertPathUtilities . ISSUING_DISTRIBUTION_POINT ) ; extns . remove ( RFC3280CertPathUtilities . DELTA_CRL_INDICATOR ) ; return ! extns . isEmpty ( ) ; }
public static void writeInt ( DataOutput out , int v ) throws IOException { out . writeByte ( xff & v ) ; out . writeByte ( xff & ( v > > > NUM_ ) ) ; out . writeByte ( xff & ( v > > > NUM_ ) ) ; out . writeByte ( xff & ( v > > > NUM_ ) ) ; }
public static Comparable [ ] sortCopy ( Comparable [ ] objects ) { int len = objects . length ; Comparable [ ] copy = new Comparable [ len ] ; System . arraycopy ( objects , NUM_ , copy , NUM_ , len ) ; sort ( copy ) ; return copy ; }
private Utf8Constant parseUtf8Constant ( int index ) throws IOException { int length = readShort ( ) ; StringBuilder cb = new StringBuilder ( ) ; for ( int i = NUM_ ; i < length ; i ++ ) { int ch = read ( ) ; if ( ch < x80 ) { cb . append ( ( char ) ch ) ; } else if ( ( ch & xe0 ) == xc0 ) { int ch2 = read ( ) ; i ++ ; cb . append ( ( char ) ( ( ( ch & x1f ) << NUM_ ) + ( ch2 & x3f ) ) ) ; } else { int ch2 = read ( ) ; int ch3 = read ( ) ; i += NUM_ ; cb . append ( ( char ) ( ( ( ch & xf ) << NUM_ ) + ( ( ch2 & x3f ) << NUM_ ) + ( ( ch3 & x3f ) ) ) ) ; } } return new Utf8Constant ( _class . getConstantPool ( ) , index , cb . toString ( ) ) ; }
@ Override public boolean markNextSequence ( ) throws IOException { if ( mSeqSize < mLimit && mPointerSize + mPointerEntrySize <= mLimit ) { mPointers . writeByte ( ( int ) mChecksumSeq . getValue ( ) ) ; mChecksumSeq . reset ( ) ; if ( mChecksumQual != null ) { mPointers . writeByte ( ( int ) mChecksumQual . getValue ( ) ) ; mChecksumQual . reset ( ) ; } mPointers . writeInt ( ( int ) mSeqSize ) ; mPointerSize += mPointerEntrySize ; return BOOL_ ; } return BOOL_ ; }
public final double sampleActiveCount ( ) { return _activeCount . get ( ) ; }
private void preprocessData ( Map < Integer , Map < Integer , List < Integer > > > knotenVonSpurNachSpurMapping , Map < Integer , Map < Integer , String > > knotenSpurLinkMapping ) { preprocessKnotenSpurLinkMapping ( knotenSpurLinkMapping ) ; cleanKnotenVonSpurNachSpurMapping ( knotenVonSpurNachSpurMapping , knotenSpurLinkMapping ) ; mergeLanesOnSameLink ( knotenVonSpurNachSpurMapping , knotenSpurLinkMapping ) ; }
@ Override public boolean mutate ( TestCase test , TestFactory factory ) { if ( Randomness . nextDouble ( ) >= Properties . P_CHANGE_PARAMETER ) return BOOL_ ; if ( ! isStatic ( ) ) { VariableReference source = getSource ( ) ; List < VariableReference > objects = test . getObjects ( source . getType ( ) , getPosition ( ) ) ; objects . remove ( source ) ; if ( ! objects . isEmpty ( ) ) { setSource ( Randomness . choice ( objects ) ) ; return BOOL_ ; } } return BOOL_ ; }
public XPath ( String exprString , SourceLocator locator , PrefixResolver prefixResolver , int type ) throws javax . xml . transform . TransformerException { this ( exprString , locator , prefixResolver , type , null ) ; }
private void addMenuItem ( JPopupMenu menu , String title , MWFNode node , int AD_WF_NodeTo_ID ) { WFPopupItem item = new WFPopupItem ( title , node , AD_WF_NodeTo_ID ) ; menu . add ( item ) ; item . addActionListener ( this ) ; }
public synchronized long allocate ( int length ) { int blocks = getBlockCount ( length ) ; BlockRange x = null ; for ( BlockRange b : freeSpace ) { if ( b . blocks >= blocks ) { x = b ; break ; } } long pos = getPos ( x . start ) ; if ( x . blocks == blocks ) { freeSpace . remove ( x ) ; } else { x . start += blocks ; x . blocks -= blocks ; } return pos ; }
public JenkinsHttpClient ( URI uri , String username , String password ) { this ( uri ) ; if ( isNotBlank ( username ) ) { CredentialsProvider provider = client . getCredentialsProvider ( ) ; AuthScope scope = new AuthScope ( uri . getHost ( ) , uri . getPort ( ) , AuthScope . ANY_REALM ) ; UsernamePasswordCredentials credentials = new UsernamePasswordCredentials ( username , password ) ; provider . setCredentials ( scope , credentials ) ; localContext = new BasicHttpContext ( ) ; localContext . setAttribute ( STR_ , new BasicScheme ( ) ) ; client . addRequestInterceptor ( new PreemptiveAuth ( ) , NUM_ ) ; } }
public static Set combineOCs ( Set one , Set two ) { if ( one == null || one . isEmpty ( ) ) { return two ; } if ( two == null || two . isEmpty ( ) ) { return one ; } Set resultSet = new HashSet ( ) ; Iterator itr1 = one . iterator ( ) ; while ( itr1 . hasNext ( ) ) { String value1 = ( String ) itr1 . next ( ) ; resultSet . add ( value1 . toLowerCase ( ) ) ; } Iterator itr2 = two . iterator ( ) ; while ( itr2 . hasNext ( ) ) { String value2 = ( String ) itr2 . next ( ) ; resultSet . add ( value2 . toLowerCase ( ) ) ; } return resultSet ; }
private String wrap ( String str ) { StringBuilder buf = new StringBuilder ( str ) ; int len = lineLength ; while ( len < buf . length ( ) ) { int idx = buf . lastIndexOf ( STR_ , len ) ; if ( idx != - NUM_ ) { buf . replace ( idx , idx + NUM_ , breaker ) ; len = idx + breaker . length ( ) + lineLength ; } else { buf . insert ( len , breaker ) ; len += breaker . length ( ) + lineLength ; } } buf . insert ( NUM_ , STR_ ) ; return buf . toString ( ) ; }
public EchoStateNetwork commitChanges ( ) { Network net = networkPanel . getNetwork ( ) ; Integer numIns = Utils . parseInteger ( tfInputLayerPop ) ; if ( numIns == null ) { throw new IllegalArgumentException ( STR_ ) ; } NeuronGroup inputLayer = new NeuronGroup ( net , numIns ) ; if ( inputLayer . size ( ) > inputLayer . getGridThreshold ( ) ) { inputLayer . setLayout ( new org . simbrain . network . layouts . GridLayout ( ) ) ; } inputLayer . applyLayout ( ) ; NeuronGroup reservoirLayer = reservoirPanel . createLayerFromData ( ) ; if ( reservoirLayer . size ( ) > reservoirLayer . getGridThreshold ( ) ) { reservoirLayer . setLayout ( new org . simbrain . network . layouts . GridLayout ( ) ) ; } reservoirLayer . applyLayout ( ) ; SynapseGroup resSynapses = resToResPanel . createSynapseGroup ( reservoirLayer , reservoirLayer ) ; resSynapses . setLabel ( STR_ ) ; NeuronGroup outputLayer = outputPanel . createLayerFromData ( ) ; outputLayer . applyLayout ( ) ; if ( outputLayer . size ( ) > outputLayer . getGridThreshold ( ) ) { outputLayer . setLayout ( new org . simbrain . network . layouts . GridLayout ( ) ) ; } EchoStateNetwork esn = new EchoStateNetwork ( net , networkPanel . getLastClickedPosition ( ) ) ; esn . setBackWeights ( allowOutToRes . isSelected ( ) ) ; esn . setDirectInOutWeights ( directInputToOutput . isSelected ( ) ) ; esn . setRecurrentOutWeights ( allowRecurrentOutputs . isSelected ( ) ) ; esn . setTimeType ( ( TimeType ) cbTimeType . getSelectedItem ( ) ) ; double maxEig = Utils . doubleParsable ( spectralRadius ) ; if ( Double . isNaN ( maxEig ) ) { throw new IllegalArgumentException ( STR_ ) ; } esn . initializeInputLayer ( inputLayer ) ; esn . initializeReservoir ( reservoirLayer , resSynapses , maxEig ) ; esn . initializeOutput ( outputLayer ) ; SynapseGroup itr = inToResPanel . createSynapseGroup ( inputLayer , reservoirLayer ) ; itr . setLabel ( STR_ ) ; esn . addSynapseGroup ( itr ) ; SynapseGroup rto = SynapseGroup . createSynapseGroup ( reservoirLayer , outputLayer , NUM_ ) ; rto . setLabel ( STR_ ) ; esn . addSynapseGroup ( rto ) ; if ( allowRecurrentOutputs . isSelected ( ) ) { SynapseGroup oto = SynapseGroup . createSynapseGroup ( outputLayer , outputLayer , NUM_ ) ; oto . setLabel ( STR_ ) ; esn . addSynapseGroup ( oto ) ; } if ( allowOutToRes . isSelected ( ) ) { SynapseGroup otr = outToResPanel . createSynapseGroup ( outputLayer , reservoirLayer ) ; otr . setLabel ( STR_ ) ; esn . addSynapseGroup ( otr ) ; } if ( directInputToOutput . isSelected ( ) ) { SynapseGroup ito = SynapseGroup . createSynapseGroup ( inputLayer , outputLayer , NUM_ ) ; ito . setLabel ( STR_ ) ; esn . addSynapseGroup ( ito ) ; } esn . positionLayers ( ) ; return esn ; }
public static double pdf ( double x , double shape , double scale ) { if ( x < NUM_ ) return NUM_ ; if ( x == NUM_ ) { if ( shape == NUM_ ) return NUM_ / scale ; else return NUM_ ; } if ( shape == NUM_ ) return NUM_ / x ; if ( shape == - NUM_ ) { return Math . sqrt ( x ) ; } final double xs = x / scale ; if ( shape == NUM_ ) { return Math . exp ( - xs ) / scale ; } final double a = Math . exp ( ( shape - NUM_ ) . Math . log ( xs ) - xs - GammaFunction . lnGamma ( shape ) ) ; return a / scale ; }
public void flush ( ) { synchronized ( list ) { int n = NUM_ ; long m = NUM_ ; for ( T b : list ) { if ( halt ) throw new RuntimeException ( firstCause . get ( ) ) ; final int size = b . size ( ) ; final long counter = b . flush ( ) ; m += counter ; if ( DEBUG ) log . debug ( STR_ + size + STR_ + counter ) ; } if ( INFO ) log . info ( STR_ + n + STR_ + m + STR_ ) ; } }
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; }
public void logInfo ( String message ) { logger . info ( logPrefix + message ) ; }
private boolean matchAddress ( final byte [ ] remoteMask ) { if ( ruleType == RuleType . ALLWILDCARD ) { return BOOL_ ; } if ( prefixMask == null ) { return BOOL_ ; } if ( remoteMask . length != prefixMask . length ) { return BOOL_ ; } for ( int i = NUM_ ; i < prefixMask . length ; i ++ ) { if ( ! wildCard . get ( i ) && ( ruleMask [ i ] & prefixMask [ i ] ) != ( remoteMask [ i ] & prefixMask [ i ] ) ) { return BOOL_ ; } } return BOOL_ ; }
public static String sign ( String signingString , PrivateKey privateKey ) throws InvalidKeyException , SignatureException { byte [ ] bytes = signingString . getBytes ( StandardCharsets . UTF_8 ) ; Signature sig ; try { sig = Signature . getInstance ( SHA256_WITH_RSA ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( STR_ , e ) ; } sig . initSign ( privateKey ) ; sig . update ( bytes ) ; return Hex . encodeHexString ( sig . sign ( ) ) ; }
public Object invoke ( Method method , Object target , ExtensionContext extensionContext , ExtensionRegistry extensionRegistry ) { @ SuppressWarnings ( STR_ ) Optional < Object > optionalTarget = ( target instanceof Optional ? ( Optional < Object > ) target : Optional . ofNullable ( target ) ) ; return ReflectionUtils . invokeMethod ( method , target , resolveParameters ( method , optionalTarget , extensionContext , extensionRegistry ) ) ; }
RegisteredProject putProject ( ProjectConfig config , FolderEntry folder , boolean updated , boolean detected ) throws ServerException , ConflictException , NotFoundException { final RegisteredProject project = new RegisteredProject ( folder , config , updated , detected , this . projectTypeRegistry ) ; projects . put ( project . getPath ( ) , project ) ; return project ; }
protected void tearDown ( ) { try { ds . close ( ) ; sds . close ( ) ; } catch ( Exception e ) { } }
@ Override public void removeListener ( final IZyNodeRealizerListener < ? > listener ) { m_listeners . removeListener ( listener ) ; }
protected void assertResultRowCount ( int expected , ResultSet rs ) throws SQLException { int i = NUM_ ; while ( rs . next ( ) ) { i ++ ; } assertEquals ( expected , i ) ; }
private boolean isModelUseful ( ContingencyMatrix cm ) { for ( int row = NUM_ ; row < cm . getNumberOfPredictions ( ) ; row ++ ) { for ( int col = NUM_ ; col < cm . getNumberOfClasses ( ) ; col ++ ) { if ( Math . abs ( cm . getLift ( row , col ) - NUM_ ) > MIN_ADVANTAGE ) { return BOOL_ ; } } } return BOOL_ ; }
public void scan ( ClassNode cn ) { List < ThreatResult > threats = new ArrayList < ThreatResult > ( ) ; for ( ClassHandler classHandler : classHandlers ) { ThreatResult result = classHandler . scanClass ( cn ) ; if ( result != null ) { threats . add ( result ) ; } } for ( MethodNode mn : cn . methods ) { for ( MethodHandler methodHandler : methodHandlers ) { ThreatResult result = methodHandler . scanMethod ( mn ) ; if ( result != null ) { threats . add ( result ) ; } } } if ( threats . size ( ) > NUM_ ) { threatsByClass . put ( cn . name , threats ) ; } }
private void pullEvent ( ) { final int newScrollValue ; final int itemDimension ; final float initialMotionValue , lastMotionValue ; switch ( getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : initialMotionValue = mInitialMotionX ; lastMotionValue = mLastMotionX ; break ; case VERTICAL : default : initialMotionValue = mInitialMotionY ; lastMotionValue = mLastMotionY ; break ; } switch ( mCurrentMode ) { case PULL_FROM_END : newScrollValue = Math . round ( Math . max ( initialMotionValue - lastMotionValue , NUM_ ) / FRICTION ) ; itemDimension = getFooterSize ( ) ; break ; case PULL_FROM_START : default : newScrollValue = Math . round ( Math . min ( initialMotionValue - lastMotionValue , NUM_ ) / FRICTION ) ; itemDimension = getHeaderSize ( ) ; break ; } setHeaderScroll ( newScrollValue ) ; if ( newScrollValue != NUM_ && ! isRefreshing ( ) ) { float scale = Math . abs ( newScrollValue ) / ( float ) itemDimension ; switch ( mCurrentMode ) { case PULL_FROM_END : mFooterLayout . onPull ( scale ) ; break ; case PULL_FROM_START : default : mHeaderLayout . onPull ( scale ) ; break ; } if ( mState != State . PULL_TO_REFRESH && itemDimension >= Math . abs ( newScrollValue ) ) { setState ( State . PULL_TO_REFRESH ) ; } else if ( mState == State . PULL_TO_REFRESH && itemDimension < Math . abs ( newScrollValue ) ) { setState ( State . RELEASE_TO_REFRESH ) ; } } }
public void reset ( ) { mChannelNumber = NUM_ ; mActiveCalls . clear ( ) ; mESNs . clear ( ) ; mNeighborIDs . clear ( ) ; mReceiveFrequencies . clear ( ) ; mSiteIDs . clear ( ) ; mTalkgroups . clear ( ) ; mTransmitFrequencies . clear ( ) ; mUniqueIDs . clear ( ) ; resetState ( ) ; }
public static String newickNoLengths ( Tree tree ) { StringBuffer buffer = new StringBuffer ( ) ; newick ( tree , tree . getRoot ( ) , BOOL_ , BranchLengthType . NO_BRANCH_LENGTHS , null , null , null , null , buffer ) ; buffer . append ( STR_ ) ; return buffer . toString ( ) ; }
@ Override public String toString ( ) { return ( String . valueOf ( getType ( ) ) + STR_ + getKey ( ) + STR_ + getValue ( ) ) ; }
@ POST @ Path ( STR_ ) @ Produces ( { MediaType . APPLICATION_XML , MediaType . APPLICATION_JSON } ) @ Consumes ( { MediaType . APPLICATION_XML , MediaType . APPLICATION_JSON } ) @ CheckPermission ( roles = { Role . SECURITY_ADMIN , Role . RESTRICTED_SECURITY_ADMIN } , blockProxies = BOOL_ ) public String rotateIPsecKey ( ) { ipsecMgr . verifyIPsecOpAllowable ( ) ; String version = ipsecMgr . rotateKey ( ) ; auditMgr . recordAuditLog ( null , null , IPSEC_SERVICE_TYPE , OperationTypeEnum . UPDATE_SYSTEM_PROPERTY , System . currentTimeMillis ( ) , AuditLogManager . AUDITLOG_SUCCESS , null , STR_ + version ) ; return version ; }
public int append ( char chunk [ ] ) throws GuacamoleException { return append ( chunk , NUM_ , chunk . length ) ; }
public VectorClock ( ) { this ( new ArrayList < ClockEntry > ( NUM_ ) , System . currentTimeMillis ( ) ) ; }
public Analyzer add ( String name , NondominatedPopulation result ) { List < NondominatedPopulation > list = data . get ( name ) ; if ( list == null ) { list = new ArrayList < NondominatedPopulation > ( ) ; data . put ( name , list ) ; } list . add ( result ) ; return this ; }
public static void assertEquals ( String msg , double [ ] expected , double [ ] observed , double tolerance ) { StringBuilder out = new StringBuilder ( msg ) ; if ( expected . length != observed . length ) { out . append ( STR_ ) ; out . append ( STR_ ) ; out . append ( expected . length ) ; out . append ( STR_ ) ; out . append ( observed . length ) ; Assert . fail ( out . toString ( ) ) ; } boolean failure = BOOL_ ; for ( int i = NUM_ ; i < expected . length ; i ++ ) { if ( ! Precision . equalsIncludingNaN ( expected [ i ] , observed [ i ] , tolerance ) ) { failure = BOOL_ ; out . append ( STR_ ) ; out . append ( i ) ; out . append ( STR_ ) ; out . append ( STR_ ) ; out . append ( expected [ i ] ) ; out . append ( STR_ ) ; out . append ( observed [ i ] ) ; } } if ( failure ) { Assert . fail ( out . toString ( ) ) ; } }
public void initializeAtomsForFinite ( List < Datum > data , String filename , Random random ) { beta = new double [ K ] ; dof = new double [ K ] ; omega = new ArrayList < > ( K ) ; if ( filename != null ) { try { loc = BatchMixtureModel . initializeClustersFromFile ( filename , K ) ; if ( loc . size ( ) < K ) { loc = BatchMixtureModel . gonzalezInitializeMixtureCenters ( loc , data , K , random ) ; } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; loc = BatchMixtureModel . gonzalezInitializeMixtureCenters ( data , K , random ) ; } } else { loc = BatchMixtureModel . gonzalezInitializeMixtureCenters ( data , K , random ) ; } log . debug ( STR_ , loc ) ; for ( int k = NUM_ ; k < this . K ; k ++ ) { beta [ k ] = baseBeta ; dof [ k ] = baseNu ; omega . add ( baseOmega ) ; } }
@ Override public void onInit ( List < ? extends IndexCommit > commits ) throws IOException { if ( commits . isEmpty ( ) ) { return ; } log . info ( STR_ , new CommitsLoggingInfo ( commits ) ) ; log . debug ( STR_ , new CommitsLoggingDebug ( commits ) ) ; updateCommits ( commits ) ; }
public boolean isLoading ( ) { return state . equals ( LOADING ) ; }
CharSequence convert ( Object value , String key ) ;
public boolean login ( ) throws LoginException { try { loadPasswordFile ( ) ; } catch ( IOException ioe ) { LoginException le = new LoginException ( STR_ + passwordFileDisplayName ) ; throw EnvHelp . initCause ( le , ioe ) ; } if ( userCredentials == null ) { throw new LoginException ( STR_ ) ; } if ( logger . debugOn ( ) ) { logger . debug ( STR_ , STR_ + passwordFileDisplayName ) ; } if ( tryFirstPass ) { try { attemptAuthentication ( BOOL_ ) ; succeeded = BOOL_ ; if ( logger . debugOn ( ) ) { logger . debug ( STR_ , STR_ ) ; } return BOOL_ ; } catch ( LoginException le ) { cleanState ( ) ; logger . debug ( STR_ , STR_ ) ; } } else if ( useFirstPass ) { try { attemptAuthentication ( BOOL_ ) ; succeeded = BOOL_ ; if ( logger . debugOn ( ) ) { logger . debug ( STR_ , STR_ ) ; } return BOOL_ ; } catch ( LoginException le ) { cleanState ( ) ; logger . debug ( STR_ , STR_ ) ; throw le ; } } if ( logger . debugOn ( ) ) { logger . debug ( STR_ , STR_ ) ; } try { attemptAuthentication ( BOOL_ ) ; succeeded = BOOL_ ; if ( logger . debugOn ( ) ) { logger . debug ( STR_ , STR_ ) ; } return BOOL_ ; } catch ( LoginException le ) { cleanState ( ) ; logger . debug ( STR_ , STR_ ) ; throw le ; } }
public Builder updateExtension ( Extension extension ) { extensions . add ( extension ) ; return this ; }
public void processUtterance ( Utterance utterance ) throws ProcessException { if ( utterance . getRelation ( Relation . SEGMENT ) == null ) { throw new IllegalStateException ( STR_ ) ; } utterance . setObject ( SampleInfo . UTT_NAME , diphoneDatabase . getSampleInfo ( ) ) ; createUnitRelation ( utterance ) ; }
public static int copy ( InputStream in , OutputStream out ) throws IOException { Assert . notNull ( in , STR_ ) ; Assert . notNull ( out , STR_ ) ; try { return StreamUtils . copy ( in , out ) ; } finally { try { in . close ( ) ; } catch ( IOException ex ) { } try { out . close ( ) ; } catch ( IOException ex ) { } } }
private String convertToAttributeName ( String localName ) { return localName . replace ( STR_ , STR_ ) ; }
public ExpandedStatementBuilder reference ( String property , Object value ) { checkCanChange ( ) ; extraInfo . add ( new ReferenceInfo ( property , value ) ) ; return this ; }
@ TargetApi ( Build . VERSION_CODES . HONEYCOMB ) protected void swipeView ( View child , float deltaX , float deltaY ) { if ( isFixedView ( child ) ) { deltaX = deltaX / NUM_ ; } float deltaXAbs = Math . abs ( deltaX ) ; float fractionCovered = deltaXAbs / ( float ) child . getWidth ( ) ; child . setTranslationX ( deltaX ) ; child . setAlpha ( NUM_ - fractionCovered ) ; if ( deltaX > NUM_ ) child . setRotationY ( - NUM_ . fractionCovered ) ; else child . setRotationY ( NUM_ . fractionCovered ) ; }
private void verifyIsRoot ( ) { if ( hierarchyElements . size ( ) != NUM_ ) { throw new IllegalStateException ( STR_ + STR_ + hierarchy ) ; } }
@ Override public int size ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { return count ; } finally { lock . unlock ( ) ; } }
private void verifyWithSeparateSigningKey ( X509Certificate cert , PublicKey prevKey , boolean signFlag , Set < X509Certificate > stackedCerts ) throws CertPathValidatorException { String msg = STR_ ; if ( debug != null ) { debug . println ( STR_ + STR_ + msg + STR_ ) ; } if ( ( stackedCerts != null ) && stackedCerts . contains ( cert ) ) { if ( debug != null ) { debug . println ( STR_ + STR_ ) ; } throw new CertPathValidatorException ( STR_ , null , null , - NUM_ , BasicReason . UNDETERMINED_REVOCATION_STATUS ) ; } if ( ! signFlag ) { buildToNewKey ( cert , null , stackedCerts ) ; } else { buildToNewKey ( cert , prevKey , stackedCerts ) ; } }
public boolean isRunning ( ) { return this . running ; }
private boolean mapPatternElemPos ( int nesting , boolean isStart , boolean isAttrName ) { if ( NUM_ == nesting ) { if ( m_patternMapSize >= m_patternMap . length ) { int patternMap [ ] = m_patternMap ; int len = m_patternMap . length ; m_patternMap = new int [ m_patternMapSize + NUM_ ] ; System . arraycopy ( patternMap , NUM_ , m_patternMap , NUM_ , len ) ; } if ( ! isStart ) { m_patternMap [ m_patternMapSize - NUM_ ] -= TARGETEXTRA ; } m_patternMap [ m_patternMapSize ] = ( m_compiler . getTokenQueueSize ( ) - ( isAttrName ? NUM_ : NUM_ ) ) + TARGETEXTRA ; m_patternMapSize ++ ; isStart = BOOL_ ; } return isStart ; }
public boolean addOperationAtFirst ( Operation operation ) { if ( isRunning ) { if ( operationHandlerThreadHandler == null ) return BOOL_ ; return operationHandlerThreadHandler . postAtFrontOfQueue ( new AndroidOperation ( this , operation ) ) ; } else { return operationQueue . add ( new AndroidOperation ( this , operation , AndroidOperation . Type . ATFIRST , null , NUM_ ) ) ; } }
public void testShiftLeft1 ( ) { byte aBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int number = NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger result = aNumber . shiftLeft ( number ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public static String toUnitbytes ( long bytes ) { if ( bytes < NUM_ ) { return STR_ + GENERAL_UNIT_KILOBYTES ; } long unitValue ; String unitName ; if ( bytes < xA00000 ) { unitValue = x400 ; unitName = GENERAL_UNIT_KILOBYTES ; } else if ( bytes < x280000000L ) { unitValue = x100000 ; unitName = GENERAL_UNIT_MEGABYTES ; } else if ( bytes < xA0000000000L ) { unitValue = x40000000 ; unitName = GENERAL_UNIT_GIGABYTES ; } else { unitValue = x10000000000L ; unitName = GENERAL_UNIT_TERABYTES ; } NumberFormat numberFormat ; if ( ( double ) bytes . NUM_ / unitValue < NUM_ ) numberFormat = NUMBER_FORMAT1 ; else numberFormat = NUMBER_FORMAT0 ; try { return numberFormat . format ( ( double ) bytes / unitValue ) + STR_ + unitName ; } catch ( ArithmeticException ae ) { return STR_ + unitName ; } }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . addElement ( new Option ( STR_ + STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ + STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return result . elements ( ) ; }
public static String changePassword ( Connection conn , String userName , String password ) throws Exception { PreparedStatement prep = conn . prepareStatement ( STR_ ) ; prep . setString ( NUM_ , password ) ; prep . setString ( NUM_ , userName ) ; prep . executeUpdate ( ) ; return password ; }
public Object remove ( Object key ) { processQueue ( ) ; return map . remove ( Key . create ( key , null ) ) ; }
protected Rectangle computePopupBounds ( int px , int py , int pw , int ph ) { Toolkit toolkit = Toolkit . getDefaultToolkit ( ) ; Rectangle screenBounds ; GraphicsConfiguration gc = comboBox . getGraphicsConfiguration ( ) ; Point p = new Point ( ) ; SwingUtilities . convertPointFromScreen ( p , comboBox ) ; if ( gc != null ) { Insets screenInsets = toolkit . getScreenInsets ( gc ) ; screenBounds = gc . getBounds ( ) ; screenBounds . width -= ( screenInsets . left + screenInsets . right ) ; screenBounds . height -= ( screenInsets . top + screenInsets . bottom ) ; screenBounds . x += ( p . x + screenInsets . left ) ; screenBounds . y += ( p . y + screenInsets . top ) ; } else { screenBounds = new Rectangle ( p , toolkit . getScreenSize ( ) ) ; } Rectangle rect = new Rectangle ( px , py , pw , ph ) ; if ( py + ph > screenBounds . y + screenBounds . height && ph < screenBounds . height ) { rect . y = - rect . height ; } return rect ; }
public static Intent buildBackgroundShortcutIntent ( File script , Parcelable iconResource ) { Intent intent = new Intent ( ) ; intent . putExtra ( Intent . EXTRA_SHORTCUT_INTENT , buildStartInBackgroundIntent ( script ) ) ; intent . putExtra ( Intent . EXTRA_SHORTCUT_NAME , script . getName ( ) ) ; intent . putExtra ( Intent . EXTRA_SHORTCUT_ICON_RESOURCE , iconResource ) ; return intent ; }
public static boolean isShown ( final Actor actor ) { return actor != null && actor . getStage ( ) != null ; }
public static void addListener ( final DiagnosticListener listener ) { if ( listener != null ) { LISTENERS . add ( listener ) ; } }
public void shuffleTrainingSet ( ) { utils . shuffleList ( TrainingFiles ) ; }
public NTLMAuthentication ( boolean isProxy , URL url , PasswordAuthentication pw ) { super ( isProxy ? PROXY_AUTHENTICATION : SERVER_AUTHENTICATION , AuthScheme . NTLM , url , STR_ ) ; init ( pw ) ; }
public MessageChannel createMessageChannel ( SIPRequest request , MessageProcessor mp , Hop nextHop ) throws IOException { Host targetHost = new Host ( ) ; targetHost . setHostname ( nextHop . getHost ( ) ) ; HostPort targetHostPort = new HostPort ( ) ; targetHostPort . setHost ( targetHost ) ; targetHostPort . setPort ( nextHop . getPort ( ) ) ; MessageChannel returnChannel = mp . createMessageChannel ( targetHostPort ) ; return returnChannel ; }
public static byte [ ] generateMac ( byte [ ] byteCipherText , SecretKey integrityKey ) throws NoSuchAlgorithmException , InvalidKeyException { Mac sha256_HMAC = Mac . getInstance ( HMAC_ALGORITHM ) ; sha256_HMAC . init ( integrityKey ) ; return sha256_HMAC . doFinal ( byteCipherText ) ; }
public void populateEditText ( String query ) { String text = query . trim ( ) ; setSearchString ( text , BOOL_ ) ; dispatchStateChange ( SearchViewState . SEARCH ) ; }
public static byte [ ] concat ( byte [ ] b1 , byte [ ] b2 ) { byte [ ] out = new byte [ b1 . length + b2 . length ] ; System . arraycopy ( b1 , NUM_ , out , NUM_ , b1 . length ) ; System . arraycopy ( b2 , NUM_ , out , b1 . length , b2 . length ) ; return out ; }
private void clipViewOnTheRight ( Rect curViewBound , float curViewWidth , int right ) { curViewBound . right = ( int ) ( right - mClipPadding ) ; curViewBound . left = ( int ) ( curViewBound . right - curViewWidth ) ; }
public static void putFloat ( String property , float val ) { SIMBRAIN_PREFERENCES . putFloat ( property , val ) ; }
public int hashCode ( ) { return Arrays . hashCode ( this . uid ) ; }
private void advanceRunState ( int targetState ) { for ( ; ; ) { int c = ctl . get ( ) ; if ( runStateAtLeast ( c , targetState ) || ctl . compareAndSet ( c , ctlOf ( targetState , workerCountOf ( c ) ) ) ) break ; } }
public static final double [ ] copy ( final double [ ] v ) { return Arrays . copyOf ( v , v . length ) ; }
public void addAction ( String action ) { Object [ ] args = new String [ NUM_ ] ; SimpleDateFormat sdf = new SimpleDateFormat ( context . getString ( R . string . dateFormat ) ) ; args [ NUM_ ] = sdf . format ( new Date ( ) ) ; String timestamp = context . getString ( R . string . timestamp , args ) ; history . add ( action + timestamp ) ; notifyListeners ( new PropertyChangeEvent ( this , ActivityConstants . historyProperty , null , null ) ) ; }
@ Override public String toString ( ) { StringBuffer text = new StringBuffer ( ) ; if ( m_trainInstances == null ) { text . append ( STR_ ) ; } else { text . append ( STR_ ) ; if ( ! m_missing_merge ) { text . append ( STR_ ) ; } } text . append ( STR_ ) ; return text . toString ( ) ; }
public CharSequence subSequence ( int start , int end ) { return substring ( start , end ) ; }
private CreationTemplate toCreationTemplate ( AttrSet t ) { Attr nameAttr = t . getAttribute ( TEMPLATE_NAME ) ; String name = null ; if ( nameAttr != null ) { name = nameAttr . getValue ( ) ; } Attr namingAttr = t . getAttribute ( TEMPLATE_NAMINGATTRIBUTE ) ; String namingAttribute = null ; if ( namingAttr != null ) { namingAttribute = namingAttr . getValue ( ) ; } Attr classAttr = t . getAttribute ( TEMPLATE_JAVACLASS ) ; String [ ] classNames = null ; if ( classAttr != null ) { classNames = classAttr . getStringValues ( ) ; } AttrSet required = decodeAttr ( t . getAttribute ( TEMPLATE_REQUIRED ) , STR_ ) ; AttrSet optional = decodeAttr ( t . getAttribute ( TEMPLATE_OPTIONAL ) , STR_ ) ; AttrSet validated = decodeAttr ( t . getAttribute ( TEMPLATE_VALIDATED ) , STR_ ) ; CreationTemplate template = new CreationTemplate ( ) ; ArrayList classes = new ArrayList ( ) ; try { if ( classNames != null ) { for ( int i = NUM_ ; i < classNames . length ; i ++ ) { Class cls = Class . forName ( classNames [ i ] ) ; classes . add ( cls ) ; } } template = new CreationTemplate ( name , required , optional , classes ) ; } catch ( ClassNotFoundException e ) { template = new CreationTemplate ( name , required , optional ) ; } if ( validated != null ) { template . setValidation ( validated ) ; } if ( namingAttribute != null ) { template . setNamingAttribute ( namingAttribute ) ; } return template ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
public void placeItem ( ItemStack stack , BlockPos pos , World world , boolean centreItem ) { double offset = ( centreItem ) ? NUM_ : NUM_ ; EntityItem entityitem = new EntityItem ( world , ( double ) pos . getX ( ) + offset , ( double ) pos . getY ( ) + offset , ( double ) pos . getZ ( ) + offset , stack ) ; entityitem . motionX = NUM_ ; entityitem . motionY = NUM_ ; entityitem . motionZ = NUM_ ; entityitem . setDefaultPickupDelay ( ) ; world . spawnEntityInWorld ( entityitem ) ; }
private E unlinkFirst ( ) { Node < E > f = first ; if ( f == null ) return null ; Node < E > n = f . next ; E item = f . item ; f . item = null ; f . next = f ; first = n ; if ( n == null ) last = null ; else n . prev = null ; -- count ; notFull . signal ( ) ; return item ; }
private < M extends ConfigurationClient , P > ManagedObject < M > createNewManagedObject ( ManagedObjectDefinition < M , ? > d , ManagedObjectPath < M , ? > p , PropertyDefinition < P > namingPropertyDefinition , String name , Collection < PropertyException > exceptions ) { PropertySet childProperties = new PropertySet ( ) ; for ( PropertyDefinition < ? > pd : d . getAllPropertyDefinitions ( ) ) { try { createProperty ( childProperties , p , pd ) ; } catch ( PropertyException e ) { if ( exceptions != null ) { exceptions . add ( e ) ; } } } if ( namingPropertyDefinition != null ) { P value = namingPropertyDefinition . decodeValue ( name ) ; childProperties . setPropertyValues ( namingPropertyDefinition , Collections . singleton ( value ) ) ; } return newInstance ( d , p , childProperties , BOOL_ , namingPropertyDefinition ) ; }
public abstract void initializeConstraints ( Step step , Settings settings ) ;
public void testEmptyCommits ( ) throws Exception { clearIndexWithReplication ( ) ; index ( masterClient , STR_ , STR_ , STR_ , STR_ ) ; emptyUpdate ( masterClient , STR_ , STR_ ) ; pullFromMasterToSlave ( ) ; rQuery ( NUM_ , STR_ , slaveClient ) ; assertVersions ( masterClient , slaveClient ) ; emptyUpdate ( masterClient , STR_ , STR_ ) ; pullFromMasterToSlave ( ) ; index ( masterClient , STR_ , STR_ , STR_ , STR_ ) ; emptyUpdate ( masterClient , STR_ , STR_ ) ; pullFromMasterToSlave ( ) ; rQuery ( NUM_ , STR_ , slaveClient ) ; assertVersions ( masterClient , slaveClient ) ; index ( masterClient , STR_ , STR_ , STR_ , STR_ ) ; emptyUpdate ( masterClient , STR_ , STR_ , STR_ , STR_ ) ; pullFromMasterToSlave ( ) ; rQuery ( NUM_ , STR_ , masterClient ) ; rQuery ( NUM_ , STR_ , slaveClient ) ; index ( masterClient , STR_ , STR_ , STR_ , STR_ ) ; emptyUpdate ( masterClient , STR_ , STR_ ) ; pullFromMasterToSlave ( ) ; String q = STR_ ; rQuery ( NUM_ , q , masterClient ) ; rQuery ( NUM_ , q , slaveClient ) ; assertVersions ( masterClient , slaveClient ) ; }
private byte [ ] decrypt ( byte [ ] d , int start , int end , int key , int skip ) { if ( end - start - skip < NUM_ ) { skip = NUM_ ; } byte [ ] o = new byte [ end - start - skip ] ; int r = key ; int ipos ; int c1 = NUM_ ; int c2 = NUM_ ; for ( ipos = start ; ipos < end ; ipos ++ ) { int c = d [ ipos ] & xff ; int p = ( c ^ ( r > > NUM_ ) ) & xff ; r = ( ( c + r ) . c1 + c2 ) & xffff ; if ( ipos - start - skip >= NUM_ ) { o [ ipos - start - skip ] = ( byte ) p ; } } return o ; }
public static void appendInstruction ( OFFlowMod . Builder fmb , OFInstruction inst ) { List < OFInstruction > newIl = new ArrayList < OFInstruction > ( ) ; List < OFInstruction > oldIl = fmb . getInstructions ( ) ; if ( oldIl != null ) { newIl . addAll ( fmb . getInstructions ( ) ) ; } for ( OFInstruction i : newIl ) { if ( i . getType ( ) == inst . getType ( ) ) { newIl . remove ( i ) ; } } newIl . add ( inst ) ; fmb . setInstructions ( newIl ) ; }
@ Override public final void insertAll ( DBIDs ids ) { if ( ids . isEmpty ( ) || ( ids . size ( ) == NUM_ ) ) { return ; } if ( canBulkLoad ( ) ) { List < RdKNNEntry > leafs = new ArrayList < > ( ids . size ( ) ) ; for ( DBIDIter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { leafs . add ( createNewLeafEntry ( DBIDUtil . deref ( iter ) ) ) ; } bulkLoad ( leafs ) ; } else { for ( DBIDIter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { insert ( iter ) ; } } doExtraIntegrityChecks ( ) ; }
public void testCase14 ( ) { byte rBytes [ ] = { NUM_ } ; BigInteger aNumber = BigInteger . ONE ; BigInteger bNumber = BigInteger . ONE ; BigInteger result = aNumber . divide ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public abstract int compare ( String source , String target ) ;
public static byte [ ] asUnsignedByteArray ( BigInteger value ) { byte [ ] bytes = value . toByteArray ( ) ; if ( bytes [ NUM_ ] == NUM_ ) { byte [ ] tmp = new byte [ bytes . length - NUM_ ] ; System . arraycopy ( bytes , NUM_ , tmp , NUM_ , tmp . length ) ; return tmp ; } return bytes ; }
public static boolean isSupplemental ( int c ) { return ( c >= x10000 && c <= x10FFFF ) ; }
private final String _decodeShortUnicodeName ( int len ) throws IOException { int outPtr = NUM_ ; char [ ] outBuf = _textBuffer . emptyAndGetCurrentSegment ( ) ; int inPtr = _inputPtr ; _inputPtr += len ; final int [ ] codes = SmileConstants . sUtf8UnitLengths ; final byte [ ] inBuf = _inputBuffer ; for ( int end = inPtr + len ; inPtr < end ; ) { int i = inBuf [ inPtr ++ ] & xFF ; int code = codes [ i ] ; if ( code != NUM_ ) { switch ( code ) { case NUM_ : i = ( ( i & x1F ) << NUM_ ) | ( inBuf [ inPtr ++ ] & x3F ) ; break ; case NUM_ : i = ( ( i & x0F ) << NUM_ ) | ( ( inBuf [ inPtr ++ ] & x3F ) << NUM_ ) | ( inBuf [ inPtr ++ ] & x3F ) ; break ; case NUM_ : i = ( ( i & x07 ) << NUM_ ) | ( ( inBuf [ inPtr ++ ] & x3F ) << NUM_ ) | ( ( inBuf [ inPtr ++ ] & x3F ) << NUM_ ) | ( inBuf [ inPtr ++ ] & x3F ) ; i -= x10000 ; outBuf [ outPtr ++ ] = ( char ) ( xD800 | ( i > > NUM_ ) ) ; i = xDC00 | ( i & x3FF ) ; break ; default : _reportError ( STR_ + Integer . toHexString ( i ) + STR_ ) ; } } outBuf [ outPtr ++ ] = ( char ) i ; } return _textBuffer . setCurrentAndReturn ( outPtr ) ; }
public void saveDeviceProfile ( @ Nonnull String user , @ Nonnull String realm , @ Nonnull PushDeviceSettings deviceSettings ) throws AuthLoginException { Reject . ifNull ( user , realm , deviceSettings ) ; try { devicesDao . saveDeviceProfiles ( user , realm , jsonUtils . toJsonValues ( Collections . singletonList ( deviceSettings ) ) ) ; } catch ( IOException e ) { debug . error ( STR_ , user , realm , e ) ; throw new AuthLoginException ( e ) ; } }
public RankingImageListProvider inDays ( int days ) { mTime = Integer . toString ( days ) + STR_ ; return this ; }
public void removeUpdateListener ( AnimatorUpdateListener listener ) { if ( mUpdateListeners == null ) { return ; } mUpdateListeners . remove ( listener ) ; if ( mUpdateListeners . size ( ) == NUM_ ) { mUpdateListeners = null ; } }
public final void dbUnavailable ( final boolean alarmUp , final String exceptionMsg , final String dbInfo ) { if ( alarmUp == FallbackAlarmsInterface . ACTIVATED ) { ArrayList recipients = new ArrayList ( ) ; MailDetailsBean mailDetails = new MailDetailsBean ( ) ; mailDetails . setSender ( STR_ ) ; recipients . add ( STR_ ) ; mailDetails . setToRecipients ( recipients ) ; mailDetails . setSubject ( STR_ ) ; mailDetails . setMessage ( STR_ + dbInfo + STR_ + exceptionMsg ) ; mailDetails . setServer ( STR_ ) ; SMTPMailSender mailSender = new SMTPMailSender ( ) ; try { mailSender . sendMail ( mailDetails ) ; } catch ( MailSenderException e ) { LOG . debug ( e . getMessage ( ) ) ; } } }
public static String tidyString ( String string ) { if ( string . matches ( STR_ ) ) { return string ; } else { return string . replaceAll ( STR_ , STR_ ) ; } }
public Select < T > sortDesc ( String ... columns ) { for ( String column : columns ) { mSortingOrderList . add ( column + STR_ ) ; } return this ; }
public String toString ( ) { StringBuilder result = new StringBuilder ( ) ; result . append ( STR_ ) ; result . append ( klazz . getName ( ) ) ; result . append ( STR_ ) ; for ( int i = NUM_ ; i < elements . length ; ++ i ) { if ( i != NUM_ ) { result . append ( STR_ ) ; } result . append ( elements [ i ] ) ; } result . append ( STR_ ) ; return result . toString ( ) ; }
public void testUlpNeg ( ) { String a = STR_ ; int aScale = NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal result = aNumber . ulp ( ) ; String res = STR_ ; int resScale = NUM_ ; assertEquals ( STR_ , res , result . toString ( ) ) ; assertEquals ( STR_ , resScale , result . scale ( ) ) ; }
public LogRecord ( Level level , String msg ) { level . getClass ( ) ; this . level = level ; message = msg ; sequenceNumber = globalSequenceNumber . getAndIncrement ( ) ; threadID = defaultThreadID ( ) ; millis = System . currentTimeMillis ( ) ; needToInferCaller = BOOL_ ; }
@ NotNull public static SaveDirectory from ( File file ) throws FileNotFoundException { File currentFile = file ; SaveDirectory result = null ; if ( currentFile == null ) { } else { result = createValidSaveDirectory ( currentFile ) ; currentFile = currentFile . getParentFile ( ) ; if ( result != null ) { return result ; } else if ( currentFile == null ) { } else { result = createValidSaveDirectory ( currentFile ) ; currentFile = currentFile . getParentFile ( ) ; if ( result != null ) { return result ; } else { } } } throw new FileNotFoundException ( STR_ + file ) ; }
public Serializer serializer ( ) { return serializer ; }
private void addIncludedResources ( JsonApiDocument jsonApiDocument , PersistentResource rec , List < String > requestedRelationPaths ) { requestedRelationPaths . forEach ( null ) ; }
protected VideoDTO extractOneVideoFromCursor ( Cursor cursor ) { if ( videoIdCol == - NUM_ ) { videoIdCol = cursor . getColumnIndexOrThrow ( MediaStore . Video . Media . _ID ) ; videoTitleCol = cursor . getColumnIndexOrThrow ( MediaStore . Video . Media . TITLE ) ; videoDisplayNameCol = cursor . getColumnIndexOrThrow ( MediaStore . Video . Media . DISPLAY_NAME ) ; videoDescriptionCol = cursor . getColumnIndexOrThrow ( MediaStore . Video . Media . DESCRIPTION ) ; videoBucketIdCol = cursor . getColumnIndexOrThrow ( MediaStore . Video . Media . BUCKET_ID ) ; videoBucketDisplayNameCol = cursor . getColumnIndexOrThrow ( MediaStore . Video . Media . BUCKET_DISPLAY_NAME ) ; videoDataCol = cursor . getColumnIndexOrThrow ( MediaStore . Video . Media . DATA ) ; videoMimeCol = cursor . getColumnIndexOrThrow ( MediaStore . Video . Media . MIME_TYPE ) ; videoResolutionCol = cursor . getColumnIndexOrThrow ( MediaStore . Video . Media . RESOLUTION ) ; videoSizeCol = cursor . getColumnIndexOrThrow ( MediaStore . Video . Media . SIZE ) ; videoDateAddedCol = cursor . getColumnIndexOrThrow ( MediaStore . Video . Media . DATE_ADDED ) ; videoDateTakenCol = cursor . getColumnIndexOrThrow ( MediaStore . Video . Media . DATE_TAKEN ) ; videoDateModifyCol = cursor . getColumnIndexOrThrow ( MediaStore . Video . Media . DATE_MODIFIED ) ; videoLatitudeCol = cursor . getColumnIndexOrThrow ( MediaStore . Video . Media . LATITUDE ) ; videoLongitudeCol = cursor . getColumnIndexOrThrow ( MediaStore . Video . Media . LONGITUDE ) ; videoAlbumCol = cursor . getColumnIndexOrThrow ( MediaStore . Video . Media . ALBUM ) ; videoArtistCol = cursor . getColumnIndexOrThrow ( MediaStore . Video . Media . ARTIST ) ; } VideoDTO video = new VideoDTO ( ) ; video . setId ( cursor . getLong ( videoIdCol ) ) ; video . setTitle ( cursor . getString ( videoTitleCol ) ) ; video . setDisplayName ( cursor . getString ( videoDisplayNameCol ) ) ; video . setDescription ( cursor . getString ( videoDescriptionCol ) ) ; video . setBucketId ( cursor . getString ( videoBucketIdCol ) ) ; video . setBucketDisplayName ( cursor . getString ( videoBucketDisplayNameCol ) ) ; video . setUri ( cursor . getString ( videoDataCol ) ) ; video . setMimeType ( cursor . getString ( videoMimeCol ) ) ; video . setSize ( cursor . getLong ( videoSizeCol ) ) ; video . setAddedDate ( new Date ( cursor . getLong ( videoDateAddedCol ) ) ) ; video . setTakenDate ( new Date ( cursor . getLong ( videoDateTakenCol ) ) ) ; video . setModifyDate ( new Date ( cursor . getLong ( videoDateModifyCol ) ) ) ; video . setLatitude ( cursor . getDouble ( videoLatitudeCol ) ) ; video . setLongitude ( cursor . getDouble ( videoLongitudeCol ) ) ; video . setAlbum ( cursor . getString ( videoAlbumCol ) ) ; video . setArtist ( cursor . getString ( videoArtistCol ) ) ; String resolution = cursor . getString ( videoResolutionCol ) ; if ( resolution != null ) { try { String [ ] res = resolution . split ( STR_ ) ; int width = Integer . parseInt ( res [ NUM_ ] ) ; int height = Integer . parseInt ( res [ NUM_ ] ) ; video . setWidth ( width ) ; video . setHeight ( height ) ; } catch ( Exception e ) { Log . w ( TAG , String . format ( STR_ , video . getId ( ) , video . getTitle ( ) , video . getDisplayName ( ) ) , e ) ; } } return video ; }
private void shiftSegments ( int fromIdx , int offset ) { for ( Element element : elements ) { if ( element . end . left > fromIdx ) { shiftSegment ( element . start , fromIdx , offset ) ; shiftSegment ( element . end , fromIdx , offset ) ; if ( element . text != null ) { for ( Segment textSegment : element . text ) { shiftSegment ( textSegment , fromIdx , offset ) ; } } } } }
public RefUpdate . Result modifyFile ( ChangeEdit edit , String file , RawInput content ) throws AuthException , InvalidChangeOperationException , IOException { return modify ( TreeOperation . CHANGE_ENTRY , edit , file , null , content ) ; }
private void startDocument ( final boolean multiObjectMode ) throws SAXException { if ( depth == NUM_ ) { contentHandler . startDocument ( ) ; if ( multiObjectMode ) { depth ++ ; } } }
public void flush ( ) throws IOException { writer . flush ( ) ; }
private static ArrayList < GridCollisionJobContextWrapper > slice ( Collection < CollisionJobContext > src , int num ) { ArrayList < GridCollisionJobContextWrapper > slice = new ArrayList < > ( ) ; Iterator < CollisionJobContext > iter = src . iterator ( ) ; for ( int i = NUM_ ; i < num && iter . hasNext ( ) ; i ++ ) slice . add ( new GridCollisionJobContextWrapper ( iter . next ( ) , i ) ) ; return slice ; }
protected void calculateFormatter ( float min , float max ) { float reference = NUM_ ; if ( mData == null || mData . getXValCount ( ) < NUM_ ) { reference = Math . max ( Math . abs ( min ) , Math . abs ( max ) ) ; } else { reference = Math . abs ( max - min ) ; } int digits = Utils . getDecimals ( reference ) ; mDefaultFormatter = new DefaultValueFormatter ( digits ) ; }
public Request add ( Request request ) { request . setRequestQueue ( this ) ; synchronized ( mCurrentRequests ) { mCurrentRequests . add ( request ) ; } request . setSequence ( getSequenceNumber ( ) ) ; request . addMarker ( STR_ ) ; if ( ! request . shouldCache ( ) ) { mNetworkQueue . add ( request ) ; return request ; } synchronized ( mWaitingRequests ) { String cacheKey = request . getCacheKey ( ) ; if ( mWaitingRequests . containsKey ( cacheKey ) ) { Queue < Request > stagedRequests = mWaitingRequests . get ( cacheKey ) ; if ( stagedRequests == null ) { stagedRequests = new LinkedList < Request > ( ) ; } stagedRequests . add ( request ) ; mWaitingRequests . put ( cacheKey , stagedRequests ) ; if ( VolleyLog . DEBUG ) { VolleyLog . v ( STR_ , cacheKey ) ; } } else { mWaitingRequests . put ( cacheKey , null ) ; mCacheQueue . add ( request ) ; } return request ; } }
public String lookup ( String data ) { Iterator < String > it = map . getPrefixedBy ( data ) ; if ( ! it . hasNext ( ) ) return null ; return it . next ( ) ; }
public static Object loadModule ( String homedir , ScriptEngine engine , String name ) throws FileNotFoundException , ScriptException { HashMap < String , File > mp = ( HashMap < String , File > ) engine . get ( STR_ ) ; Object ret = load ( mp . get ( name ) , engine ) ; return ret ; }
@ Override public void modifyVariableId ( String nodeId , String newId ) { Map < Assignment , UtilityEstimate > utilities2 = new HashMap < Assignment , UtilityEstimate > ( ) ; for ( Assignment a : table . keySet ( ) ) { Assignment b = new Assignment ( ) ; for ( String var : a . getVariables ( ) ) { String newVar = ( var . equals ( nodeId ) ) ? newId : var ; b . addPair ( newVar , a . getValue ( var ) ) ; } utilities2 . put ( b , table . get ( a ) ) ; } table = utilities2 ; }
public static long [ ] truncateI ( long [ ] v , int len ) { final int zap = ( v . length . Long . SIZE ) - len ; final int zapWords = ( zap > > > LONG_LOG2_SIZE ) ; final int zapbits = zap & LONG_LOG2_MASK ; Arrays . fill ( v , v . length - zapWords , v . length , NUM_ ) ; if ( zapbits > NUM_ ) { v [ v . length - zapWords - NUM_ ] &= ( LONG_ALL_BITS > > > zapbits ) ; } return v ; }
public void test_noResourcesDoesNotWait_predeclareLocks_synchronousQueue ( ) throws Exception { final Properties properties = new Properties ( ) ; final int ntasks = NUM_ ; final int corePoolSize = NUM_ ; final int maxPoolSize = ntasks ; properties . setProperty ( TestOptions . SYNCHRONOUS_QUEUE , STR_ ) ; properties . setProperty ( TestOptions . CORE_POOL_SIZE , STR_ + corePoolSize ) ; properties . setProperty ( TestOptions . MAX_POOL_SIZE , STR_ + maxPoolSize ) ; properties . setProperty ( TestOptions . NTASKS , STR_ + ntasks ) ; properties . setProperty ( TestOptions . NRESOURCES , STR_ ) ; properties . setProperty ( TestOptions . MIN_LOCKS , STR_ ) ; properties . setProperty ( TestOptions . MAX_LOCKS , STR_ ) ; properties . setProperty ( TestOptions . PREDECLARE_LOCKS , STR_ ) ; properties . setProperty ( TestOptions . SORT_LOCK_REQUESTS , STR_ ) ; final Result result = doComparisonTest ( properties ) ; assertEquals ( STR_ , ntasks , Integer . parseInt ( result . get ( STR_ ) ) ) ; final int maxrunning = Integer . parseInt ( result . get ( STR_ ) ) ; assertTrue ( STR_ + maxrunning , corePoolSize <= maxrunning ) ; }
private void positionAtCentralDirectory ( ) throws IOException { boolean found = BOOL_ ; long off = archive . length ( ) - MIN_EOCD_SIZE ; if ( off >= NUM_ ) { archive . seek ( off ) ; byte [ ] sig = JBZipOutputStream . EOCD_SIG ; int curr = archive . read ( ) ; while ( curr != - NUM_ ) { if ( curr == sig [ POS_0 ] ) { curr = archive . read ( ) ; if ( curr == sig [ POS_1 ] ) { curr = archive . read ( ) ; if ( curr == sig [ POS_2 ] ) { curr = archive . read ( ) ; if ( curr == sig [ POS_3 ] ) { found = BOOL_ ; break ; } } } } archive . seek ( -- off ) ; curr = archive . read ( ) ; } } if ( ! found ) { throw new ZipException ( STR_ ) ; } archive . seek ( off + CFD_LOCATOR_OFFSET ) ; byte [ ] cfdOffset = new byte [ WORD ] ; archive . readFully ( cfdOffset ) ; currentcfdfoffset = ZipLong . getValue ( cfdOffset ) ; archive . seek ( currentcfdfoffset ) ; }
public List query ( double x1 , double x2 ) { return super . query ( new Interval ( Math . min ( x1 , x2 ) , Math . max ( x1 , x2 ) ) ) ; }
public static boolean isNull ( Object object ) { return object != null && object == NULL_CACHE . get ( object . getClass ( ) ) ; }
public static void createDestinationFolder ( String path ) { File fpath = new File ( path ) ; fpath . mkdirs ( ) ; }
public void removeAll ( ) { log . debug ( STR_ + connectionToAdded . size ( ) ) ; connectionToAdded . clear ( ) ; }
public float readFloat ( ) throws IOException { return primitiveTypes . readFloat ( ) ; }
public synchronized static int insertLuaState ( LuaState L ) { int i ; for ( i = NUM_ ; i < states . size ( ) ; i ++ ) { LuaState state = ( LuaState ) states . get ( i ) ; if ( state != null ) { if ( state . getCPtrPeer ( ) == L . getCPtrPeer ( ) ) return i ; } } i = getNextStateIndex ( ) ; states . set ( i , L ) ; return i ; }
public PhoneNumberValidator ( @ NonNull final CharSequence errorMessage ) { super ( errorMessage , REGEX ) ; }
@ Override public int hashCode ( ) { return fullyQualifiedName . hashCode ( ) ; }
public static void putString2bytes ( byte [ ] destbytes , String srcString , int destOffset , int srcOffset , int count ) { for ( int i = NUM_ ; i < count ; i ++ ) { destbytes [ count + i ] = srcString . getBytes ( ) [ i ] ; } }
public Point2D convertWindowToReference ( Point2D apt ) { if ( scrollBackReferenceRect == null ) return null ; else return new Point2D . Double ( ( apt . getX ( ) - scrollBackReferenceRect . getX ( ) ) / scrollBackReferenceRect . getWidth ( ) , ( apt . getY ( ) - scrollBackReferenceRect . getY ( ) ) / scrollBackReferenceRect . getHeight ( ) ) ; }
public void clear ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { for ( TenantQueue q : qs . values ( ) ) { q . clear ( ) ; } } finally { lock . unlock ( ) ; } }
public void printUsage ( PrintWriter pw , int width , String cmdLineSyntax ) { int argPos = cmdLineSyntax . indexOf ( STR_ ) + NUM_ ; printWrapped ( pw , width , defaultSyntaxPrefix . length ( ) + argPos , defaultSyntaxPrefix + cmdLineSyntax ) ; }
public boolean hasNameValue ( String name ) { return nameValueMap . containsKey ( name . toLowerCase ( ) ) ; }
private void addNewLine ( ) { if ( addLineDialog == null ) { addLineDialog = new AddParallelLineDialog ( ) ; } addLineDialog . setChartEngine ( engine ) ; addLineDialog . showDialog ( ) ; if ( horizontalLineRadiobutton . isSelected ( ) ) { setHorizontalLineSelected ( ) ; } else if ( verticalLineRadiobutton . isSelected ( ) ) { setVerticalLineSelected ( ) ; } }
public final static < T > CompletableFuture < List < T > > streamToCompletableFuture ( final Stream < T > stream ) { return CompletableFuture . completedFuture ( stream . collect ( CyclopsCollectors . toListX ( ) ) ) ; }
@ SuppressWarnings ( STR_ ) public static boolean isGzipSupported ( final HttpServletRequest request ) { if ( request != null ) { final Enumeration < String > headerNames = request . getHeaderNames ( ) ; if ( headerNames != null ) { while ( headerNames . hasMoreElements ( ) ) { final String headerName = headerNames . nextElement ( ) ; final Matcher m = PATTERN_ACCEPT_ENCODING . matcher ( headerName ) ; if ( m . find ( ) ) { final String headerValue = request . getHeader ( headerName ) ; final Matcher mValue = PATTERN_GZIP . matcher ( headerValue ) ; return mValue . find ( ) ; } } } } return BOOL_ ; }
private boolean isLanguageAllowed ( String languageKey ) { if ( allowedLanguages == null ) return BOOL_ ; return allowedLanguages . contains ( languageKey ) ; }
public List < Boundary > populateWard ( final Long zoneId ) { List < Boundary > wardList = new LinkedList < Boundary > ( ) ; try { wardList = boundaryService . getChildBoundariesByBoundaryId ( zoneId ) ; } catch ( final Exception e ) { LOGGER . error ( STR_ + e . getMessage ( ) ) ; throw new ApplicationRuntimeException ( STR_ , e ) ; } return wardList ; }
static Object newInstance ( String className , ClassLoader cl , boolean doFallback ) throws ConfigurationError { try { Class providerClass = findProviderClass ( className , cl , doFallback ) ; Object instance = providerClass . newInstance ( ) ; debugPrintln ( STR_ + providerClass + STR_ + cl ) ; return instance ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( STR_ + className + STR_ , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( STR_ + className + STR_ + x , x ) ; } }
public void handleRequest ( List arguments ) { try { InstallLogger migrateLog = new InstallLogger ( STR_MIGRATE ) ; MultipleMigrateDriver driver = new MultipleMigrateDriver ( ) ; if ( arguments . isEmpty ( ) ) { Debug . log ( STR_ ) ; driver . migrate ( migrateLog ) ; } else if ( arguments . size ( ) == NUM_ ) { Debug . log ( STR_ ) ; driver . migrate ( migrateLog ) ; } } catch ( InstallAbortException ia ) { Debug . log ( STR_ , ia ) ; Console . printlnRawText ( ia . getMessage ( ) ) ; } catch ( InstallException ex ) { Debug . log ( STR_ , ex ) ; printConsoleMessage ( LOC_HR_ERR_MIGRATE , new Object [ ] { ex . getMessage ( ) } ) ; } }
@ Override public String toString ( ) { StringBuffer result = new StringBuffer ( ) ; for ( int i = NUM_ ; i < data . length ; i ++ ) { result . append ( ( i == NUM_ ? STR_ : STR_ ) + data [ i ] ) ; } return result . toString ( ) ; }
public static SynchronizerStatus makeRunningStatus ( ) { return new SynchronizerStatus ( Status . RUNNING , new Date ( ) , null ) ; }
public static Iterable < File > applyCwd ( File cwd , Iterable < File > files ) { if ( files != null ) { List < File > result = new ArrayList < File > ( ) ; for ( File f : files ) { result . add ( applyCwd ( cwd , f ) ) ; } return result ; } else { return null ; } }
private void close ( boolean force ) { if ( closeGuard . compareAndSet ( BOOL_ , BOOL_ ) ) hadoop . close ( force ) ; }
MutableBigInteger divideKnuth ( MutableBigInteger b , MutableBigInteger quotient , boolean needRemainder ) { if ( b . intLen == NUM_ ) throw new ArithmeticException ( STR_ ) ; if ( intLen == NUM_ ) { quotient . intLen = quotient . offset = NUM_ ; return needRemainder ? new MutableBigInteger ( ) : null ; } int cmp = compare ( b ) ; if ( cmp < NUM_ ) { quotient . intLen = quotient . offset = NUM_ ; return needRemainder ? new MutableBigInteger ( this ) : null ; } if ( cmp == NUM_ ) { quotient . value [ NUM_ ] = quotient . intLen = NUM_ ; quotient . offset = NUM_ ; return needRemainder ? new MutableBigInteger ( ) : null ; } quotient . clear ( ) ; if ( b . intLen == NUM_ ) { int r = divideOneWord ( b . value [ b . offset ] , quotient ) ; if ( needRemainder ) { if ( r == NUM_ ) return new MutableBigInteger ( ) ; return new MutableBigInteger ( r ) ; } else { return null ; } } if ( intLen >= KNUTH_POW2_THRESH_LEN ) { int trailingZeroBits = Math . min ( getLowestSetBit ( ) , b . getLowestSetBit ( ) ) ; if ( trailingZeroBits >= KNUTH_POW2_THRESH_ZEROS . NUM_ ) { MutableBigInteger a = new MutableBigInteger ( this ) ; b = new MutableBigInteger ( b ) ; a . rightShift ( trailingZeroBits ) ; b . rightShift ( trailingZeroBits ) ; MutableBigInteger r = a . divideKnuth ( b , quotient ) ; r . leftShift ( trailingZeroBits ) ; return r ; } } return divideMagnitude ( b , quotient , needRemainder ) ; }
public static Cache . Entry makeRandomCacheEntry ( byte [ ] data , boolean isExpired , boolean needsRefresh ) { Random random = new Random ( ) ; Cache . Entry entry = new Cache . Entry ( ) ; if ( data != null ) { entry . data = data ; } else { entry . data = new byte [ random . nextInt ( NUM_ ) ] ; } entry . etag = String . valueOf ( random . nextLong ( ) ) ; entry . lastModified = random . nextLong ( ) ; entry . ttl = isExpired ? NUM_ : Long . MAX_VALUE ; entry . softTtl = needsRefresh ? NUM_ : Long . MAX_VALUE ; return entry ; }
@ SuppressWarnings ( STR_ ) public void insert ( int id , Comparable < E > priority ) { int i ; i = ++ _n ; ElementH p = new ElementH ( ) ; while ( i > NUM_ ) { int pIdx = i / NUM_ ; ElementH eIdx = ( ElementH ) _elements [ pIdx ] ; p . id = eIdx . id ; p . priority = eIdx . priority ; if ( priority . compareTo ( ( E ) p . priority ) > NUM_ ) { break ; } ElementH ei = ( ElementH ) _elements [ i ] ; ei . id = p . id ; ei . priority = p . priority ; _pos [ p . id ] = i ; i = pIdx ; } ElementH ei = ( ElementH ) _elements [ i ] ; ei . id = id ; ei . priority = priority ; _pos [ id ] = i ; }
ExternalProblem ( Socket socket ) throws IOException { this ( socket . getInputStream ( ) , socket . getOutputStream ( ) ) ; }
private static void stopGC ( ) { gcShouldLoop = BOOL_ ; synchronized ( LOCK ) { LOCK . notify ( ) ; } }
public final void insertElementAt ( int value , int at ) { if ( ( m_firstFree + NUM_ ) >= m_mapSize ) { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , NUM_ , newMap , NUM_ , m_firstFree + NUM_ ) ; m_map = newMap ; } if ( at <= ( m_firstFree - NUM_ ) ) { System . arraycopy ( m_map , at , m_map , at + NUM_ , m_firstFree - at ) ; } m_map [ at ] = value ; m_firstFree ++ ; }
public static @ Nullable RequestBody createGzip ( final MediaType mediaType , final String body ) { ByteArrayOutputStream gzipByteArrayOutputStream = new ByteArrayOutputStream ( ) ; try { OutputStream gzipOutputStream = new GZIPOutputStream ( gzipByteArrayOutputStream ) ; gzipOutputStream . write ( body . getBytes ( ) ) ; gzipOutputStream . close ( ) ; } catch ( IOException e ) { return null ; } return RequestBody . create ( mediaType , gzipByteArrayOutputStream . toByteArray ( ) ) ; }
private void processTSBK ( TSBKMessage tsbk ) { broadcast ( new DecoderStateEvent ( this , Event . CONTINUATION , State . CONTROL ) ) ; if ( tsbk . getVendor ( ) == Vendor . STANDARD ) { switch ( tsbk . getOpcode ( ) ) { case ADJACENT_STATUS_BROADCAST : if ( tsbk instanceof AdjacentStatusBroadcast ) { IAdjacentSite ias = ( IAdjacentSite ) tsbk ; mNeighborMap . put ( ias . getUniqueID ( ) , ias ) ; updateSystem ( ias . getSystemID ( ) ) ; } break ; case ACKNOWLEDGE_RESPONSE : processTSBKResponse ( tsbk ) ; break ; case AUTHENTICATION_COMMAND : processTSBKCommand ( tsbk ) ; break ; case CALL_ALERT : processTSBKPage ( tsbk ) ; break ; case DENY_RESPONSE : processTSBKResponse ( tsbk ) ; break ; case EXTENDED_FUNCTION_COMMAND : processTSBKCommand ( tsbk ) ; break ; case GROUP_AFFILIATION_QUERY : processTSBKQuery ( tsbk ) ; break ; case GROUP_AFFILIATION_RESPONSE : processTSBKResponse ( tsbk ) ; break ; case GROUP_DATA_CHANNEL_ANNOUNCEMENT : case GROUP_DATA_CHANNEL_ANNOUNCEMENT_EXPLICIT : processTSBKDataChannelAnnouncement ( tsbk ) ; break ; case GROUP_DATA_CHANNEL_GRANT : case GROUP_VOICE_CHANNEL_GRANT : case GROUP_VOICE_CHANNEL_GRANT_UPDATE : case GROUP_VOICE_CHANNEL_GRANT_UPDATE_EXPLICIT : case INDIVIDUAL_DATA_CHANNEL_GRANT : case TELEPHONE_INTERCONNECT_VOICE_CHANNEL_GRANT : case TELEPHONE_INTERCONNECT_VOICE_CHANNEL_GRANT_UPDATE : case UNIT_TO_UNIT_VOICE_CHANNEL_GRANT : case UNIT_TO_UNIT_VOICE_CHANNEL_GRANT_UPDATE : processTSBKChannelGrant ( tsbk ) ; break ; case IDENTIFIER_UPDATE_NON_VUHF : case IDENTIFIER_UPDATE_VHF_UHF_BANDS : IdentifierUpdate iu = ( IdentifierUpdate ) tsbk ; if ( ! mBands . containsKey ( iu . getIdentifier ( ) ) ) { mBands . put ( iu . getIdentifier ( ) , iu ) ; } break ; case LOCATION_REGISTRATION_RESPONSE : case UNIT_DEREGISTRATION_ACKNOWLEDGE : processTSBKResponse ( tsbk ) ; break ; case MESSAGE_UPDATE : processTSBKMessage ( tsbk ) ; break ; case NETWORK_STATUS_BROADCAST : mNetworkStatus = ( module . decode . p25 . message . tsbk . osp . control . NetworkStatusBroadcast ) tsbk ; break ; case PROTECTION_PARAMETER_UPDATE : processTSBKResponse ( tsbk ) ; break ; case QUEUED_RESPONSE : processTSBKResponse ( tsbk ) ; break ; case RADIO_UNIT_MONITOR_COMMAND : processTSBKCommand ( tsbk ) ; break ; case RFSS_STATUS_BROADCAST : processTSBKRFSSStatus ( ( RFSSStatusBroadcast ) tsbk ) ; break ; case ROAMING_ADDRESS_COMMAND : processTSBKCommand ( tsbk ) ; break ; case SECONDARY_CONTROL_CHANNEL_BROADCAST : module . decode . p25 . message . tsbk . osp . control . SecondaryControlChannelBroadcast sccb = ( module . decode . p25 . message . tsbk . osp . control . SecondaryControlChannelBroadcast ) tsbk ; if ( sccb . getDownlinkFrequency1 ( ) > NUM_ ) { mSecondaryControlChannels . add ( sccb ) ; } break ; case SNDCP_DATA_CHANNEL_ANNOUNCEMENT_EXPLICIT : mSNDCPDataChannel = ( SNDCPDataChannelAnnouncementExplicit ) tsbk ; break ; case SNDCP_DATA_CHANNEL_GRANT : processTSBKChannelGrant ( tsbk ) ; break ; case STATUS_QUERY : processTSBKQuery ( tsbk ) ; break ; case STATUS_UPDATE : processTSBKResponse ( tsbk ) ; break ; case TELEPHONE_INTERCONNECT_ANSWER_REQUEST : case UNIT_TO_UNIT_ANSWER_REQUEST : processTSBKPage ( tsbk ) ; break ; case UNIT_REGISTRATION_COMMAND : processTSBKCommand ( tsbk ) ; break ; case UNIT_REGISTRATION_RESPONSE : processTSBKResponse ( tsbk ) ; break ; default : break ; } } else if ( tsbk . getVendor ( ) == Vendor . MOTOROLA ) { processMotorolaTSBK ( ( MotorolaTSBKMessage ) tsbk ) ; } }
public XintroActivityBuilder removeFragment ( int fragmentPos ) { introFragmentModelList . remove ( fragmentPos ) ; return this ; }
public boolean update ( ) { return update ; }
public TreeViewerBuilder ( Composite parent , int style ) { mappings = Collections . emptyMap ( ) ; checkable = ( style & SWT . CHECK ) == SWT . CHECK ; if ( checkable ) { viewer = new CheckboxTreeViewer ( parent , style ) ; } else { viewer = new TreeViewer ( parent , style ) ; } ColumnViewerToolTipSupport . enableFor ( viewer , ToolTip . NO_RECREATE ) ; }
@ Override public void write ( byte [ ] buffer , int offset , int count ) throws IOException { synchronized ( intThread ) { int avail = ( wroteIndex - dataEndIndex + data . length ) % data . length ; if ( avail == NUM_ ) avail = data . length ; if ( avail < count ) { throw new IOException ( STR_ + avail + STR_ + count ) ; } if ( count > data . length - dataEndIndex ) { int firstPart = data . length - dataEndIndex ; int secondPart = count - firstPart ; System . arraycopy ( buffer , offset , data , dataEndIndex , firstPart ) ; System . arraycopy ( buffer , offset + firstPart , data , NUM_ , secondPart ) ; dataEndIndex = secondPart ; } else { System . arraycopy ( buffer , offset , data , dataEndIndex , count ) ; dataEndIndex += count ; } intThread . notify ( ) ; } }
public void pause ( ) { pauseLock . lock ( ) ; try { paused = BOOL_ ; } finally { pauseLock . unlock ( ) ; } }
public void addToConsolitatedMsg ( final String message ) { if ( consolidatedMessage != null && consolidatedMessage . length ( ) > NUM_ ) { consolidatedMessage = consolidatedMessage + STR_ ; } consolidatedMessage = consolidatedMessage + message ; }
private static byte [ ] readClass ( final InputStream is , boolean close ) throws IOException { if ( is == null ) { throw new IOException ( STR_ ) ; } try { byte [ ] b = new byte [ is . available ( ) ] ; int len = NUM_ ; while ( BOOL_ ) { int n = is . read ( b , len , b . length - len ) ; if ( n == - NUM_ ) { if ( len < b . length ) { byte [ ] c = new byte [ len ] ; System . arraycopy ( b , NUM_ , c , NUM_ , len ) ; b = c ; } return b ; } len += n ; if ( len == b . length ) { int last = is . read ( ) ; if ( last < NUM_ ) { return b ; } byte [ ] c = new byte [ b . length + NUM_ ] ; System . arraycopy ( b , NUM_ , c , NUM_ , len ) ; c [ len ++ ] = ( byte ) last ; b = c ; } } } finally { if ( close ) { is . close ( ) ; } } }
public void sort ( final Comparator < ? super T > comparator ) { synchronized ( mLock ) { Collections . sort ( mList , comparator ) ; } notifyDataSetChanged ( ) ; }
public String cropKeepFinalCharacter ( String string , char finalChar ) { String cropped = crop ( string ) ; if ( ( null == string ) || string . equals ( cropped ) ) { return string ; } if ( cropped . length ( ) == NUM_ ) { return cropped ; } return cropped + finalChar ; }
public static boolean isDerivedAdjective ( final String word ) { if ( word . length ( ) > NUM_ ) { if ( word . endsWith ( STR_ ) || word . endsWith ( STR_ ) ) return BOOL_ ; if ( word . endsWith ( STR_ ) ) return BOOL_ ; } return BOOL_ ; }
String renameFile ( String inputFilename ) { for ( Pattern searchExp : regexMappings . keySet ( ) ) { Matcher matcher = searchExp . matcher ( inputFilename ) ; if ( matcher . find ( ) ) { String renamed = matcher . replaceFirst ( regexMappings . get ( searchExp ) ) ; return FILE_SEP_CHAR_MATCHER . trimLeadingFrom ( renamed ) ; } } throw new MoeProblem ( STR_ + STR_ , inputFilename ) ; }
private static int validateAdbServerPort ( @ NonNull String adbServerPort ) throws IllegalArgumentException { try { int port = Integer . decode ( adbServerPort ) ; if ( port <= NUM_ || port >= NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } return port ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( STR_ ) ; } }
public static String formatElapsed ( Timestamp start ) { if ( start == null ) return STR_ ; long startTime = start . getTime ( ) ; long endTime = System . currentTimeMillis ( ) ; return formatElapsed ( endTime - startTime ) ; }
@ Override public void stop ( ) { for ( Thread thread : threads ) { thread . interrupt ( ) ; } try { for ( Thread thread : threads ) { thread . join ( ) ; } } catch ( InterruptedException e ) { } }
private boolean verifyPublishedDualInetAddress ( String nodeId ) { DualInetAddress dualAddress = null ; Configuration config = queryConfiguration ( Constants . NODE_DUALINETADDR_CONFIG , nodeId ) ; if ( config != null ) { dualAddress = parseInetAddressConfig ( config ) ; } if ( ( dualAddress != null ) && dualAddress . equals ( inetAddressLookupMap . getDualInetAddress ( ) ) ) { return BOOL_ ; } return BOOL_ ; }
public void testRecursiveChains ( ) throws Throwable { for ( ExecutionMode m : ExecutionMode . values ( ) ) for ( boolean addDeadEnds : new boolean [ ] { BOOL_ , BOOL_ } ) { final int val = NUM_ ; final int n = expensiveTests ? NUM_ : NUM_ ; CompletableFuture < Integer > head = new CompletableFuture < > ( ) ; CompletableFuture < Integer > tail = head ; for ( int i = NUM_ ; i < n ; i ++ ) { if ( addDeadEnds ) m . thenApply ( tail , null ) ; tail = m . thenApply ( tail , null ) ; if ( addDeadEnds ) m . applyToEither ( tail , tail , null ) ; tail = m . applyToEither ( tail , tail , null ) ; if ( addDeadEnds ) m . thenCombine ( tail , tail , null ) ; tail = m . thenCombine ( tail , tail , null ) ; } head . complete ( val ) ; assertEquals ( val + NUM_ . n , ( int ) tail . join ( ) ) ; } }
public boolean responseIsString ( String oid ) { return stringResponses . contains ( oid ) ; }
private static int type ( final ClassWriter cw , final String desc ) { String t ; int index = desc . charAt ( NUM_ ) == STR_ ? desc . indexOf ( STR_ ) + NUM_ : NUM_ ; switch ( desc . charAt ( index ) ) { case STR_ : return NUM_ ; case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : return INTEGER ; case STR_ : return FLOAT ; case STR_ : return LONG ; case STR_ : return DOUBLE ; case STR_ : t = desc . substring ( index + NUM_ , desc . length ( ) - NUM_ ) ; return OBJECT | cw . addType ( t ) ; default : int data ; int dims = index + NUM_ ; while ( desc . charAt ( dims ) == STR_ ) { ++ dims ; } switch ( desc . charAt ( dims ) ) { case STR_ : data = BOOLEAN ; break ; case STR_ : data = CHAR ; break ; case STR_ : data = BYTE ; break ; case STR_ : data = SHORT ; break ; case STR_ : data = INTEGER ; break ; case STR_ : data = FLOAT ; break ; case STR_ : data = LONG ; break ; case STR_ : data = DOUBLE ; break ; default : t = desc . substring ( dims + NUM_ , desc . length ( ) - NUM_ ) ; data = OBJECT | cw . addType ( t ) ; } return ( dims - index ) << NUM_ | data ; } }
public void logFine ( String message ) { logger . fine ( logPrefix + message ) ; }
public static Optional < String > createInputDialog ( final Window owner , final String title , final String label ) { final TextInputDialog dialog = new TextInputDialog ( ) ; dialog . setTitle ( title ) ; dialog . setHeaderText ( null ) ; dialog . setContentText ( label ) ; dialog . initOwner ( owner ) ; return dialog . showAndWait ( ) ; }
public static void closeOutputStream ( OutputStream stream , String tag ) { if ( stream != null ) { try { stream . close ( ) ; } catch ( IOException e ) { Log . e ( tag , STR_ + e ) ; } } }
private static String encode ( final String text ) throws UnsupportedEncodingException { return URLEncoder . encode ( text , STR_ ) ; }
public static String convertToRGB ( int color ) { String red = Integer . toHexString ( Color . red ( color ) ) ; String green = Integer . toHexString ( Color . green ( color ) ) ; String blue = Integer . toHexString ( Color . blue ( color ) ) ; if ( red . length ( ) == NUM_ ) { red = STR_ + red ; } if ( green . length ( ) == NUM_ ) { green = STR_ + green ; } if ( blue . length ( ) == NUM_ ) { blue = STR_ + blue ; } return STR_ + red + green + blue ; }
private static final void appendEncodedByte ( StringBuffer buffer , byte value , byte [ ] state ) { if ( state [ NUM_ ] != NUM_ ) { char c = ( char ) ( ( state [ NUM_ ] << NUM_ ) | ( ( ( int ) value ) & xFF ) ) ; buffer . append ( c ) ; state [ NUM_ ] = NUM_ ; } else { state [ NUM_ ] = NUM_ ; state [ NUM_ ] = value ; } }
public SidedPlane ( double pX , double pY , double pZ , Vector v , double D ) { super ( v , D ) ; sigNum = Math . signum ( evaluate ( pX , pY , pZ ) ) ; if ( sigNum == NUM_ ) throw new IllegalArgumentException ( STR_ ) ; }
public String buildUnionQuery ( String [ ] subQueries , String sortOrder , String limit ) { StringBuilder query = new StringBuilder ( NUM_ ) ; int subQueryCount = subQueries . length ; String unionOperator = mDistinct ? STR_ : STR_ ; for ( int i = NUM_ ; i < subQueryCount ; i ++ ) { if ( i > NUM_ ) { query . append ( unionOperator ) ; } query . append ( subQueries [ i ] ) ; } appendClause ( query , STR_ , sortOrder ) ; appendClause ( query , STR_ , limit ) ; return query . toString ( ) ; }
@ Override public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( clientId ) ; sb . append ( STR_ ) ; switch ( status ) { case CONNECTED : sb . append ( context . getString ( R . string . connectedto ) ) ; break ; case DISCONNECTED : sb . append ( context . getString ( R . string . disconnected ) ) ; break ; case NONE : sb . append ( context . getString ( R . string . no_status ) ) ; break ; case CONNECTING : sb . append ( context . getString ( R . string . connecting ) ) ; break ; case DISCONNECTING : sb . append ( context . getString ( R . string . disconnecting ) ) ; break ; case ERROR : sb . append ( context . getString ( R . string . connectionError ) ) ; } sb . append ( STR_ ) ; sb . append ( host ) ; return sb . toString ( ) ; }
void registerCallback ( BluetoothCallback callback ) { synchronized ( mCallbacks ) { mCallbacks . add ( callback ) ; } }
private void validateTableMetaDataNoRow ( String tableNamePattern , String [ ] types ) throws Exception { try ( ResultSet tables = dbmd . getTables ( null , null , tableNamePattern , types ) ) { assertFalse ( String . format ( STR_ , tableNamePattern , Arrays . toString ( types ) ) , tables . next ( ) ) ; } }
void checkClassBounds ( DiagnosticPosition pos , Type type ) { checkClassBounds ( pos , new HashMap < TypeSymbol , Type > ( ) , type ) ; }
private static String parseToken ( String pattern , int [ ] indexRef ) { StringBuffer buf = new StringBuffer ( ) ; int i = indexRef [ NUM_ ] ; int length = pattern . length ( ) ; char c = pattern . charAt ( i ) ; if ( c >= STR_ && c <= STR_ || c >= STR_ && c <= STR_ ) { buf . append ( c ) ; while ( i + NUM_ < length ) { char peek = pattern . charAt ( i + NUM_ ) ; if ( peek == c ) { buf . append ( c ) ; i ++ ; } else { break ; } } } else { buf . append ( STR_ ) ; boolean inLiteral = BOOL_ ; for ( ; i < length ; i ++ ) { c = pattern . charAt ( i ) ; if ( c == STR_ ) { if ( i + NUM_ < length && pattern . charAt ( i + NUM_ ) == STR_ ) { i ++ ; buf . append ( c ) ; } else { inLiteral = ! inLiteral ; } } else if ( ! inLiteral && ( c >= STR_ && c <= STR_ || c >= STR_ && c <= STR_ ) ) { i -- ; break ; } else { buf . append ( c ) ; } } } indexRef [ NUM_ ] = i ; return buf . toString ( ) ; }
public int alloc ( final RWStore store , final int size , final IAllocationContext context ) { try { if ( size <= NUM_ ) throw new IllegalArgumentException ( STR_ + size ) ; if ( size > m_size ) throw new IllegalArgumentException ( STR_ + m_size + STR_ + size + STR_ ) ; if ( m_freeBits == NUM_ ) { throw new IllegalStateException ( STR_ + m_size + STR_ ) ; } int addr = - NUM_ ; if ( m_size <= m_store . cSmallSlot ) { return allocFromIndex ( size ) ; } final Iterator < AllocBlock > iter = m_allocBlocks . iterator ( ) ; int count = - NUM_ ; while ( addr == - NUM_ && iter . hasNext ( ) ) { count ++ ; final AllocBlock block = iter . next ( ) ; checkBlock ( block ) ; addr = block . alloc ( m_size ) ; } if ( addr != - NUM_ ) { addr += NUM_ ; if ( -- m_freeBits == NUM_ ) { if ( s_islogTrace ) log . trace ( STR_ ) ; removeFromFreeList ( ) ; if ( m_freeList . size ( ) > NUM_ ) { if ( s_islogDebug ) { final FixedAllocator nxt = ( FixedAllocator ) m_freeList . get ( NUM_ ) ; log . debug ( STR_ + nxt . getSummaryStats ( ) ) ; } } } addr += ( count . NUM_ . m_bitSize ) ; final int value = - ( ( m_index << RWStore . OFFSET_BITS ) + addr ) ; if ( m_statsBucket != null ) { m_statsBucket . allocate ( size ) ; } return value ; } else { StringBuilder sb = new StringBuilder ( ) ; sb . append ( STR_ + m_freeBits + STR_ ) ; for ( AllocBlock ab : m_allocBlocks ) { sb . append ( ab . show ( ) + STR_ ) ; } log . error ( sb ) ; return NUM_ ; } } finally { if ( s_islogDebug ) checkBits ( ) ; } }
public static NativePage createNativePageForURL ( String url , NativePage candidatePage , Tab tab , TabModelSelector tabModelSelector , Activity activity ) { return createNativePageForURL ( url , candidatePage , tab , tabModelSelector , activity , tab . isIncognito ( ) ) ; }
@ Override public void nodeDown ( long eventUID , String nodeID ) { try { lock . lock ( ) ; untriedConnectors . putAll ( triedConnectors ) ; triedConnectors . clear ( ) ; if ( untriedConnectors . size ( ) > NUM_ ) { condition . signal ( ) ; } } finally { lock . unlock ( ) ; } }
public static synchronized Collection < String > allLocalMACs ( ) { List < String > macs = new ArrayList < > ( NUM_ ) ; try { Enumeration < NetworkInterface > itfs = NetworkInterface . getNetworkInterfaces ( ) ; if ( itfs != null ) { for ( NetworkInterface itf : asIterable ( itfs ) ) { byte [ ] hwAddr = itf . getHardwareAddress ( ) ; if ( hwAddr != null && hwAddr . length > NUM_ ) { String mac = byteArray2HexString ( hwAddr ) ; if ( ! macs . contains ( mac ) ) macs . add ( mac ) ; } } } } catch ( SocketException ignore ) { return Collections . emptyList ( ) ; } Collections . sort ( macs ) ; return macs ; }
public void removeCartItem ( int index , boolean triggerExternalOps , LocalDispatcher dispatcher ) throws CartItemModifyException { if ( isReadOnlyCart ( ) ) { throw new CartItemModifyException ( STR_ ) ; } if ( index < NUM_ ) return ; if ( cartLines . size ( ) <= index ) return ; ShoppingCartItem item = cartLines . remove ( index ) ; item . setQuantity ( BigDecimal . ZERO , dispatcher , this , triggerExternalOps , BOOL_ , BOOL_ , BOOL_ ) ; }
private final void accessCheck ( T obj ) { if ( ! cclass . isInstance ( obj ) ) throw accessCheckException ( obj ) ; }
protected void markFirstTime ( Element elem ) { String elemName = elem . getName ( ) ; if ( elemName . equals ( STR_ ) ) { seenHtml = BOOL_ ; } else if ( elemName . equals ( STR_ ) ) { seenHead = BOOL_ ; } else if ( elemName . equals ( STR_ ) ) { if ( buf . length == NUM_ ) { char [ ] newBuf = new char [ NUM_ ] ; newBuf [ NUM_ ] = buf [ NUM_ ] ; buf = newBuf ; } seenBody = BOOL_ ; } }
public static String timeToString ( long period ) { period /= NUM_ ; final long milsecs = period % NUM_ ; period /= NUM_ ; final long secs = period % NUM_ ; period /= NUM_ ; final long mins = period % NUM_ ; period /= NUM_ ; final long hours = period ; return String . format ( STR_ , hours , mins , secs , milsecs ) ; }
protected static boolean isUserDefinedProperty ( String propName ) { return ! standardPropNames . contains ( propName ) ; }
private boolean conditionM0 ( String value , int index ) { if ( charAt ( value , index + NUM_ ) == STR_ ) { return BOOL_ ; } return contains ( value , index - NUM_ , NUM_ , STR_ ) && ( ( index + NUM_ ) == value . length ( ) - NUM_ || contains ( value , index + NUM_ , NUM_ , STR_ ) ) ; }
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; }
private void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject ( ) ; serviceID = new ServiceID ( in ) ; }
public void removeSwipeListener ( SwipeListener listener ) { if ( mListeners == null ) { return ; } mListeners . remove ( listener ) ; }
private void generateCreateEvents ( List < IgfsPath > createdPaths , boolean file ) { if ( evts . isRecordable ( EventType . EVT_IGFS_DIR_CREATED ) ) { for ( int i = NUM_ ; i < createdPaths . size ( ) - NUM_ ; i ++ ) IgfsUtils . sendEvents ( igfsCtx . kernalContext ( ) , createdPaths . get ( i ) , EventType . EVT_IGFS_DIR_CREATED ) ; } IgfsPath leafPath = createdPaths . get ( createdPaths . size ( ) - NUM_ ) ; if ( file ) { IgfsUtils . sendEvents ( igfsCtx . kernalContext ( ) , leafPath , EventType . EVT_IGFS_FILE_CREATED ) ; IgfsUtils . sendEvents ( igfsCtx . kernalContext ( ) , leafPath , EventType . EVT_IGFS_FILE_OPENED_WRITE ) ; } else IgfsUtils . sendEvents ( igfsCtx . kernalContext ( ) , leafPath , EventType . EVT_IGFS_DIR_CREATED ) ; }
public OptInTemplateClassResolver ( Set allowedClasses , List trustedTemplates ) { this . allowedClasses = allowedClasses != null ? allowedClasses : Collections . EMPTY_SET ; if ( trustedTemplates != null ) { trustedTemplateNames = new HashSet ( ) ; trustedTemplatePrefixes = new ArrayList ( ) ; Iterator it = trustedTemplates . iterator ( ) ; while ( it . hasNext ( ) ) { String li = ( String ) it . next ( ) ; if ( li . startsWith ( STR_ ) ) li = li . substring ( NUM_ ) ; if ( li . endsWith ( STR_ ) ) { trustedTemplatePrefixes . add ( li . substring ( NUM_ , li . length ( ) - NUM_ ) ) ; } else { trustedTemplateNames . add ( li ) ; } } } else { trustedTemplateNames = Collections . EMPTY_SET ; trustedTemplatePrefixes = Collections . EMPTY_LIST ; } }
protected void asyncOpRelease ( ) { if ( asyncOpsSem != null ) asyncOpsSem . release ( ) ; }
public static boolean validSystemNameConfig ( String systemName , char type ) { if ( ! validSystemNameFormat ( systemName , type ) ) { return BOOL_ ; } return BOOL_ ; }
public void removeAll ( ) { if ( mRecords . size ( ) >= NUM_ ) { mRecords . clear ( ) ; mCurrentPosition = - NUM_ ; notifyObservers ( ) ; } }
public synchronized boolean startReindexer ( String name , boolean force ) throws ReindexerAlreadyRunningException { OnlineReindexer < ? , ? , ? > reindexer = reindexers . get ( name ) ; validateReindexerNotRunning ( reindexer ) ; if ( force || ! isCurrentIndexVersionLatest ( name , reindexer ) ) { reindexer . start ( ) ; return BOOL_ ; } return BOOL_ ; }
@ Override public void printStackTrace ( ) { super . printStackTrace ( ) ; if ( nested != null ) nested . printStackTrace ( ) ; }
private static void updateLastModified ( File destDir , String warFilePath ) { File warFile = new File ( warFilePath ) ; destDir . setLastModified ( warFile . lastModified ( ) ) ; }
public void addChild ( BaseAssemblyNode childNode ) { childNode . parentNode = this ; childNodes . add ( childNode ) ; }
protected void notifyHistoryChangedListeners ( ) { Iterator < HistoryChangedListener > iter ; HistoryChangedListener l ; iter = m_HistoryChangedListeners . iterator ( ) ; while ( iter . hasNext ( ) ) { l = iter . next ( ) ; l . historyChanged ( new HistoryChangedEvent ( this , HISTORY_NAME , getHistory ( ) ) ) ; } }
private void signalNotFull ( ) { final ReentrantLock putLock = this . putLock ; putLock . lock ( ) ; try { notFull . signal ( ) ; } finally { putLock . unlock ( ) ; } }
@ RequiresPermission ( Manifest . permission . CAMERA ) public CameraSource start ( ) throws IOException { synchronized ( mCameraLock ) { if ( mCamera != null ) { return this ; } mCamera = createCamera ( ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . HONEYCOMB ) { mDummySurfaceTexture = new SurfaceTexture ( DUMMY_TEXTURE_NAME ) ; mCamera . setPreviewTexture ( mDummySurfaceTexture ) ; } else { mDummySurfaceView = new SurfaceView ( mContext ) ; mCamera . setPreviewDisplay ( mDummySurfaceView . getHolder ( ) ) ; } mCamera . startPreview ( ) ; mProcessingThread = new Thread ( mFrameProcessor ) ; mFrameProcessor . setActive ( BOOL_ ) ; mProcessingThread . start ( ) ; } return this ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
private TextView findTextViewByTagId ( final String tagId ) { for ( final TextView view : mTagViewMap . values ( ) ) { final Tag tag = ( Tag ) view . getTag ( ) ; if ( tagId . equals ( tag . id ) ) { return view ; } } return null ; }
public Space prune ( Space prefix ) throws ScopeException { Space x = this ; ArrayList < Space > stack = new ArrayList < > ( ) ; while ( x != null && ! x . equals ( prefix ) ) { stack . add ( NUM_ , x ) ; x = x . getParent ( ) ; } if ( x == null ) { throw new ScopeException ( STR_ ) ; } else { Space result = new Space ( universe , x . getDomain ( ) ) ; for ( Space space : stack ) { result = result . S ( space . getRelation ( ) ) ; } return result ; } }
default void infof ( String format , Object ... args ) { info ( String . format ( format , args ) ) ; }
public static int darker ( int color , float factor ) { int a = Color . alpha ( color ) ; int r = Color . red ( color ) ; int g = Color . green ( color ) ; int b = Color . blue ( color ) ; return Color . argb ( a , Math . max ( ( int ) ( r . factor ) , NUM_ ) , Math . max ( ( int ) ( g . factor ) , NUM_ ) , Math . max ( ( int ) ( b . factor ) , NUM_ ) ) ; }
public < FV > FV extractRawJavaFieldValue ( Object object ) throws SQLException { Object val ; if ( fieldGetMethod == null ) { try { val = field . get ( object ) ; } catch ( Exception e ) { throw SqlExceptionUtil . create ( STR_ + this , e ) ; } } else { try { val = fieldGetMethod . invoke ( object ) ; } catch ( Exception e ) { throw SqlExceptionUtil . create ( STR_ + fieldGetMethod + STR_ + this , e ) ; } } @ SuppressWarnings ( STR_ ) FV converted = ( FV ) val ; return converted ; }
public static void writeFile ( File file , byte [ ] data ) { try { RandomAccessFile ra = new RandomAccessFile ( file , STR_ ) ; ra . write ( data ) ; ra . setLength ( data . length ) ; ra . close ( ) ; } catch ( IOException e ) { throw new RuntimeException ( STR_ + file , e ) ; } }
public static double [ ] thresholdStringToArray ( String top , int L ) { if ( top . startsWith ( STR_ ) ) { return MLUtils . toDoubleArray ( top ) ; } else { double t [ ] = new double [ L ] ; Arrays . fill ( t , Double . parseDouble ( top ) ) ; return t ; } }
@ Override public String [ ] determineColumnConstraints ( ResultProducer rp ) throws Exception { return null ; }
abstract Set < String > initConfigNames ( ) ;
public static int eval ( String url , String text ) throws IOException { String returnValue = null ; if ( url . startsWith ( STR_ ) ) { returnValue = doHttp ( url , text ) ; } else if ( url . startsWith ( STR_ ) ) { returnValue = doBsh ( url , text ) ; } else throw new IOException ( STR_ + STR_ ) ; try { return Integer . parseInt ( returnValue ) ; } catch ( Exception e ) { return NUM_ ; } }
public DSAPrivateKey ( byte [ ] encoded ) throws InvalidKeyException { clearOldKey ( ) ; decode ( encoded ) ; }
public static String readFully ( Reader reader ) throws IOException { try { StringWriter writer = new StringWriter ( ) ; char [ ] buffer = new char [ NUM_ ] ; int count ; while ( ( count = reader . read ( buffer ) ) != - NUM_ ) { writer . write ( buffer , NUM_ , count ) ; } return writer . toString ( ) ; } finally { reader . close ( ) ; } }
private void sendBroadcastNewOperation ( Target target , RemoteOperation operation ) { Intent intent = new Intent ( ACTION_OPERATION_ADDED ) ; if ( target . mAccount != null ) { intent . putExtra ( EXTRA_ACCOUNT , target . mAccount ) ; } else { intent . putExtra ( EXTRA_SERVER_URL , target . mServerUrl ) ; } sendStickyBroadcast ( intent ) ; }
int successful ( ) { return success . get ( ) ; }
public void monitor ( String key ) { Timer t = new Timer ( BOOL_ ) ; t . schedule ( new WatchableRegistration ( key ) , NUM_ . NUM_ , NUM_ . NUM_ ) ; }
private synchronized void rebuildJournal ( ) throws IOException { if ( journalWriter != null ) { journalWriter . close ( ) ; } Writer writer = new BufferedWriter ( new FileWriter ( journalFileTmp ) , IO_BUFFER_SIZE ) ; writer . write ( MAGIC ) ; writer . write ( STR_ ) ; writer . write ( VERSION_1 ) ; writer . write ( STR_ ) ; writer . write ( Integer . toString ( appVersion ) ) ; writer . write ( STR_ ) ; writer . write ( Integer . toString ( valueCount ) ) ; writer . write ( STR_ ) ; writer . write ( STR_ ) ; for ( Entry entry : lruEntries . values ( ) ) { if ( entry . currentEditor != null ) { writer . write ( DIRTY + STR_ + entry . key + STR_ ) ; } else { writer . write ( CLEAN + STR_ + entry . key + entry . getLengths ( ) + STR_ ) ; } } writer . close ( ) ; journalFileTmp . renameTo ( journalFile ) ; journalWriter = new BufferedWriter ( new FileWriter ( journalFile , BOOL_ ) , IO_BUFFER_SIZE ) ; }
protected int checkRiskAttribute ( ) { int retVal = NUM_ ; if ( debug . messageEnabled ( ) ) { debug . message ( STR_ , ADAPTIVE ) ; } if ( riskAttributeName != null && riskAttributeValue != null ) { Set < String > riskAttributeValues = null ; riskAttributeValues = getIdentityAttributeSet ( riskAttributeName ) ; if ( riskAttributeValues != null ) { for ( String riskAttr : riskAttributeValues ) { if ( riskAttributeValue . equalsIgnoreCase ( riskAttr ) ) { if ( debug . messageEnabled ( ) ) { debug . message ( STR_ , ADAPTIVE ) ; } retVal = riskAttributeScore ; break ; } } } } if ( ! riskAttributeInvert ) { retVal = riskAttributeScore - retVal ; } return retVal ; }
public static MethExecutorResult executeInstance ( String receiver , String selector , Class [ ] types , Object [ ] args ) { try { Class receiverClass = Class . forName ( receiver ) ; Constructor init = receiverClass . getDeclaredConstructor ( new Class [ NUM_ ] ) ; init . setAccessible ( BOOL_ ) ; Object target = init . newInstance ( new Object [ NUM_ ] ) ; Object res = null ; try { Method theMethod = getMethod ( receiverClass , selector , types ) ; res = theMethod . invoke ( target , args ) ; return new MethExecutorResult ( res ) ; } catch ( InvocationTargetException invTargEx ) { Throwable targEx = invTargEx . getTargetException ( ) ; if ( targEx == null ) { return new MethExecutorResult ( res ) ; } else { return new MethExecutorResult ( targEx ) ; } } } catch ( VirtualMachineError e ) { SystemFailure . initiateFailure ( e ) ; throw e ; } catch ( Throwable t ) { return new MethExecutorResult ( t ) ; } }
private void writeObject ( ObjectOutputStream stream ) throws IOException { stream . defaultWriteObject ( ) ; marshalAttributes ( attrs , stream ) ; }
@ Override synchronized public void write ( byte b [ ] , int off , int len ) throws IOException { if ( b == null ) { throw new NullPointerException ( ) ; } else if ( off < NUM_ || len < NUM_ || len > b . length - off ) { throw new IndexOutOfBoundsException ( ) ; } else if ( len == NUM_ ) { return ; } c . checkWrite ( ) ; boolean isFirstRecordOfThePayload = BOOL_ ; try { do { boolean holdRecord = BOOL_ ; int howmuch ; if ( isFirstRecordOfThePayload && c . needToSplitPayload ( ) ) { howmuch = Math . min ( x01 , r . availableDataBytes ( ) ) ; if ( ( len != NUM_ ) && ( howmuch == NUM_ ) ) { holdRecord = BOOL_ ; } } else { howmuch = Math . min ( len , r . availableDataBytes ( ) ) ; } if ( isFirstRecordOfThePayload && howmuch != NUM_ ) { isFirstRecordOfThePayload = BOOL_ ; } if ( howmuch > NUM_ ) { r . write ( b , off , howmuch ) ; off += howmuch ; len -= howmuch ; } c . writeRecord ( r , holdRecord ) ; c . checkWrite ( ) ; } while ( len > NUM_ ) ; } catch ( Exception e ) { c . handleException ( e ) ; } }
public boolean onInterceptTouchEvent ( MotionEvent ev ) { @ SuppressWarnings ( STR_ ) final boolean debug = BOOL_ ; if ( debug ) { Log . d ( Launcher . TAG , STR_ + ev + STR_ + mDragging ) ; } acquireVelocityTrackerAndAddMovement ( ev ) ; final int action = ev . getAction ( ) ; final int [ ] dragLayerPos = getClampedDragLayerPos ( ev . getX ( ) , ev . getY ( ) ) ; final int dragLayerX = dragLayerPos [ NUM_ ] ; final int dragLayerY = dragLayerPos [ NUM_ ] ; switch ( action ) { case MotionEvent . ACTION_MOVE : break ; case MotionEvent . ACTION_DOWN : mMotionDownX = dragLayerX ; mMotionDownY = dragLayerY ; mLastDropTarget = null ; break ; case MotionEvent . ACTION_UP : mLastTouchUpTime = System . currentTimeMillis ( ) ; if ( mDragging ) { PointF vec = isFlingingToDelete ( mDragObject . dragSource ) ; if ( ! DeleteDropTarget . willAcceptDrop ( mDragObject . dragInfo ) ) { vec = null ; } if ( vec != null ) { dropOnFlingToDeleteTarget ( dragLayerX , dragLayerY , vec ) ; } else { drop ( dragLayerX , dragLayerY ) ; } } endDrag ( ) ; break ; case MotionEvent . ACTION_CANCEL : cancelDrag ( ) ; break ; } return mDragging ; }
public void test_concurrentKBCreateAndDiscovery ( ) throws Exception { final String namespace = getName ( ) ; final Properties properties = getProperties ( ) ; Journal jnl = null ; try { jnl = new Journal ( properties ) ; doConcurrentCreateAndDiscoveryTest ( jnl , namespace ) ; } finally { if ( jnl != null ) jnl . destroy ( ) ; } }
private void resetDatabase ( TungstenProperties serviceProps , Map < String , String > progress ) throws InterruptedException { DataSourceAdministrator admin = null ; String serviceName = serviceProps . getString ( ReplicatorConf . SERVICE_NAME ) ; try { admin = new DataSourceAdministrator ( serviceProps ) ; admin . prepare ( ) ; progress . put ( STR_ , serviceName ) ; boolean cleared = admin . resetAll ( ) ; if ( cleared ) { logger . info ( STR_ ) ; } else { logger . info ( STR_ + serviceName ) ; } } catch ( ReplicatorException e ) { logger . error ( String . format ( STR_ , serviceName , e . getMessage ( ) ) , e ) ; } finally { if ( admin != null ) { admin . release ( ) ; } } }
public static final void writeValueXml ( Object v , String name , XmlSerializer out ) throws XmlPullParserException , IOException { String typeStr ; if ( v == null ) { out . startTag ( null , STR_ ) ; if ( name != null ) { out . attribute ( null , STR_ , name ) ; } out . endTag ( null , STR_ ) ; return ; } else if ( v instanceof String ) { out . startTag ( null , STR_ ) ; if ( name != null ) { out . attribute ( null , STR_ , name ) ; } out . text ( v . toString ( ) ) ; out . endTag ( null , STR_ ) ; return ; } else if ( v instanceof Integer ) { typeStr = STR_ ; } else if ( v instanceof Long ) { typeStr = STR_ ; } else if ( v instanceof Float ) { typeStr = STR_ ; } else if ( v instanceof Double ) { typeStr = STR_ ; } else if ( v instanceof Boolean ) { typeStr = STR_ ; } else if ( v instanceof byte [ ] ) { writeByteArrayXml ( ( byte [ ] ) v , name , out ) ; return ; } else if ( v instanceof int [ ] ) { writeIntArrayXml ( ( int [ ] ) v , name , out ) ; return ; } else if ( v instanceof Map ) { writeMapXml ( ( Map ) v , name , out ) ; return ; } else if ( v instanceof List ) { writeListXml ( ( List ) v , name , out ) ; return ; } else if ( v instanceof CharSequence ) { out . startTag ( null , STR_ ) ; if ( name != null ) { out . attribute ( null , STR_ , name ) ; } out . text ( v . toString ( ) ) ; out . endTag ( null , STR_ ) ; return ; } else { throw new RuntimeException ( STR_ + v ) ; } out . startTag ( null , typeStr ) ; if ( name != null ) { out . attribute ( null , STR_ , name ) ; } out . attribute ( null , STR_ , v . toString ( ) ) ; out . endTag ( null , typeStr ) ; }
private void initializeIdealPoint ( ) { idealPoint = new double [ problem . getNumberOfObjectives ( ) ] ; Arrays . fill ( idealPoint , Double . POSITIVE_INFINITY ) ; }
private long startWait ( ) { return System . nanoTime ( ) ; }
public static String [ ] readFontNames ( final FontData fontData ) { final String [ ] fontNames = new String [ NUM_ ] ; fontNames [ NUM_ ] = null ; final BufferedReader br = new BufferedReader ( new StringReader ( new String ( fontData . getBytes ( NUM_ , fontData . length ( ) ) ) ) ) ; String line = null ; while ( BOOL_ ) { try { line = br . readLine ( ) ; } catch ( final IOException e ) { LogWriter . writeLog ( STR_ + e . getMessage ( ) ) ; } if ( line == null ) { break ; } if ( line . startsWith ( STR_ ) ) { final int nameStart = line . indexOf ( STR_ , NUM_ ) ; if ( nameStart != - NUM_ ) { final int nameEnd = line . indexOf ( STR_ , nameStart ) ; if ( nameEnd != - NUM_ ) { final String name = line . substring ( nameStart + NUM_ , nameEnd ) ; fontNames [ NUM_ ] = name . toLowerCase ( ) ; break ; } } } } if ( br != null ) { try { br . close ( ) ; } catch ( final Exception e ) { LogWriter . writeLog ( STR_ + e + STR_ ) ; } } if ( fontData != null ) { fontData . close ( ) ; } return fontNames ; }
private void writeUnitsOfIndentation ( int i ) throws IOException { for ( ; i > NUM_ ; i -- ) { writer . write ( INDENTATION_UNIT ) ; } }
private PatternParser ( ) throws HyphenationException { token = new StringBuilder ( ) ; parser = createParser ( ) ; parser . setContentHandler ( this ) ; parser . setErrorHandler ( this ) ; hyphenChar = STR_ ; }
public static int capBetween ( int min , int number , int max ) { assertTrue ( min <= max ) ; return Math . min ( max , Math . max ( min , number ) ) ; }
public boolean hasExtensions ( ) { return extensions != null ; }
public void munge ( String entityId , Collection < Statement > statements , Collection < String > existingValues , Collection < String > existingRefs , Change sourceChange ) { if ( statements . isEmpty ( ) ) { return ; } MungeOperation op = new MungeOperation ( entityId , statements , existingValues , existingRefs ) ; if ( sourceChange != null ) { op . importFromChange ( sourceChange ) ; } op . munge ( ) ; existingValues . removeAll ( op . extraValidSubjects ) ; existingRefs . removeAll ( op . extraValidSubjects ) ; return ; }
public void showPropertyDialog ( ) { if ( m_Editor . getValue ( ) != null ) { if ( m_PD == null ) { int x = getLocationOnScreen ( ) . x ; int y = getLocationOnScreen ( ) . y ; if ( PropertyDialog . getParentDialog ( this ) != null ) m_PD = new PropertyDialog ( PropertyDialog . getParentDialog ( this ) , m_Editor , x , y ) ; else m_PD = new PropertyDialog ( PropertyDialog . getParentFrame ( this ) , m_Editor , x , y ) ; m_PD . setVisible ( BOOL_ ) ; } else { m_PD . setVisible ( BOOL_ ) ; } m_Editor . setValue ( m_Editor . getValue ( ) ) ; } }
public Lucene60Codec ( Mode mode ) { super ( STR_ ) ; this . storedFieldsFormat = new Lucene50StoredFieldsFormat ( Objects . requireNonNull ( mode ) ) ; }
public void delete ( ) throws IOException { close ( ) ; Util . deleteContents ( directory ) ; }
public synchronized void remove ( String name ) { for ( int i = NUM_ ; i < modifications . size ( ) ; i ++ ) { Modification mod = modifications . get ( i ) ; Attribute attr = mod . getAttribute ( ) ; if ( name . equalsIgnoreCase ( attr . getAttributeDescriptionAsString ( ) ) ) { modifications . remove ( i ) ; return ; } } }
void addFillComponents ( Container panel , int [ ] cols , int [ ] rows ) { Dimension filler = new Dimension ( NUM_ , NUM_ ) ; boolean filled_cell_11 = BOOL_ ; CellConstraints cc = new CellConstraints ( ) ; if ( cols . length > NUM_ && rows . length > NUM_ ) { if ( cols [ NUM_ ] == NUM_ && rows [ NUM_ ] == NUM_ ) { panel . add ( Box . createRigidArea ( filler ) , cc . xy ( NUM_ , NUM_ ) ) ; filled_cell_11 = BOOL_ ; } } for ( int index = NUM_ ; index < cols . length ; index ++ ) { if ( cols [ index ] == NUM_ && filled_cell_11 ) { continue ; } panel . add ( Box . createRigidArea ( filler ) , cc . xy ( cols [ index ] , NUM_ ) ) ; } for ( int index = NUM_ ; index < rows . length ; index ++ ) { if ( rows [ index ] == NUM_ && filled_cell_11 ) { continue ; } panel . add ( Box . createRigidArea ( filler ) , cc . xy ( NUM_ , rows [ index ] ) ) ; } }
private boolean quietSleep ( long ms ) { try { Thread . sleep ( ms ) ; } catch ( InterruptedException e ) { return BOOL_ ; } return BOOL_ ; }
public void pushFrame ( LocalVariableMap vars , DMLProgramCounter pc ) { callStack . push ( new DMLFrame ( vars , pc ) ) ; }
public boolean isLandingPage ( URL url ) { if ( url . getQuery ( ) != null ) { return BOOL_ ; } else { return landingPageSuffix ( url ) != STR_ ; } }
protected void layoutGraphicModifiers ( DrawContext dc , AVList modifiers , OrderedSymbol osym ) { }
public static synchronized void progress ( final String message ) { sLastProgress = message ; final PrintStream prog = getProgressStream ( ) ; if ( prog != null ) { prog . println ( now ( ) + message ) ; prog . flush ( ) ; if ( prog . checkError ( ) ) { sProgressStream = null ; } } }
private static boolean match ( CharSequence string , CharSequence pattern , int sNdx , int pNdx ) { int pLen = pattern . length ( ) ; if ( pLen == NUM_ ) { if ( pattern . charAt ( NUM_ ) == STR_ ) { return BOOL_ ; } } int sLen = string . length ( ) ; boolean nextIsNotWildcard = BOOL_ ; while ( BOOL_ ) { if ( ( sNdx >= sLen ) == BOOL_ ) { while ( ( pNdx < pLen ) && ( pattern . charAt ( pNdx ) == STR_ ) ) { pNdx ++ ; } return pNdx >= pLen ; } if ( pNdx >= pLen ) { return BOOL_ ; } char p = pattern . charAt ( pNdx ) ; if ( nextIsNotWildcard == BOOL_ ) { if ( p == STR_ ) { pNdx ++ ; nextIsNotWildcard = BOOL_ ; continue ; } if ( p == STR_ ) { sNdx ++ ; pNdx ++ ; continue ; } if ( p == STR_ ) { char pNext = NUM_ ; if ( pNdx + NUM_ < pLen ) { pNext = pattern . charAt ( pNdx + NUM_ ) ; } if ( pNext == STR_ ) { pNdx ++ ; continue ; } int i ; pNdx ++ ; for ( i = string . length ( ) ; i >= sNdx ; i -- ) { if ( match ( string , pattern , i , pNdx ) == BOOL_ ) { return BOOL_ ; } } return BOOL_ ; } } else { nextIsNotWildcard = BOOL_ ; } if ( p != string . charAt ( sNdx ) ) { return BOOL_ ; } sNdx ++ ; pNdx ++ ; } }
public String nextCDATA ( ) throws JSONException { char c ; int i ; StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { c = next ( ) ; if ( end ( ) ) { throw syntaxError ( STR_ ) ; } sb . append ( c ) ; i = sb . length ( ) - NUM_ ; if ( i >= NUM_ && sb . charAt ( i ) == STR_ && sb . charAt ( i + NUM_ ) == STR_ && sb . charAt ( i + NUM_ ) == STR_ ) { sb . setLength ( i ) ; return sb . toString ( ) ; } } }
public void addGrammarFile ( String fileName ) { grammarFiles . add ( fileName ) ; }
private Workflow . Method rollbackDeleteMirrorDeviceMethod ( URI vplexURI , URI vplexMirrorURI ) { return new Workflow . Method ( RB_DELETE_MIRROR_DEVICE_METHOD_NAME , vplexURI , vplexMirrorURI ) ; }
private String findCipherAndStrength ( byte [ ] supportedCiphers , String [ ] tokens ) { byte s ; for ( int i = NUM_ ; i < strength . length ; i ++ ) { if ( ( s = strength [ i ] ) != NUM_ ) { for ( int j = NUM_ ; j < supportedCiphers . length ; j ++ ) { if ( s == supportedCiphers [ j ] && ( specifiedCipher == null || specifiedCipher . equals ( tokens [ j ] ) ) ) { switch ( s ) { case HIGH_STRENGTH : negotiatedStrength = STR_ ; break ; case MEDIUM_STRENGTH : negotiatedStrength = STR_ ; break ; case LOW_STRENGTH : negotiatedStrength = STR_ ; break ; } return tokens [ j ] ; } } } } return null ; }
public static String [ ] split ( String line , String delim ) { List list = new ArrayList ( ) ; StringTokenizer t = new StringTokenizer ( line , delim ) ; while ( t . hasMoreTokens ( ) ) { list . add ( t . nextToken ( ) ) ; } return ( String [ ] ) list . toArray ( new String [ list . size ( ) ] ) ; }
public static String slurpFile ( File file ) throws IOException { Reader r = new FileReader ( file ) ; return slurpReader ( r ) ; }
@ NotNull public List < PlayerNbt > createSingleplayerPlayerNbts ( ) { Log . i ( STR_ ) ; return Arrays . asList ( createLevelDatPlayerNbt ( ) ) ; }
@ Override public String toString ( ) { StringBuilder result = new StringBuilder ( limit - position ) ; for ( int i = position ; i < limit ; i ++ ) { result . append ( get ( i ) ) ; } return result . toString ( ) ; }
public void testEqualsUnequal1 ( ) { String a = STR_ ; int aScale = - NUM_ ; String b = STR_ ; int bScale = NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal bNumber = new BigDecimal ( new BigInteger ( b ) , bScale ) ; assertFalse ( aNumber . equals ( bNumber ) ) ; }
public void testCase8 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = - NUM_ ; int bSign = NUM_ ; byte rBytes [ ] = { - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . subtract ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( - NUM_ , result . signum ( ) ) ; }
public GetFormKeyCmd ( String processDefinitionId , String taskDefinitionKey ) { setProcessDefinitionId ( processDefinitionId ) ; if ( taskDefinitionKey == null || taskDefinitionKey . length ( ) < NUM_ ) { throw new ActivitiIllegalArgumentException ( STR_ + taskDefinitionKey + STR_ ) ; } this . taskDefinitionKey = taskDefinitionKey ; }
protected abstract StorageLevel storageLevel ( ) ;
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
private void statInit ( ) { lDocumentNo . setLabelFor ( fDocumentNo ) ; fDocumentNo . setBackground ( AdempierePLAF . getInfoBackground ( ) ) ; fDocumentNo . addActionListener ( this ) ; fcheckReceipt . setSelected ( BOOL_ ) ; fcheckReceipt . setActionCommand ( STR_ ) ; fcheckReceipt . addActionListener ( this ) ; fcheckPayment . setSelected ( BOOL_ ) ; fcheckPayment . setActionCommand ( STR_ ) ; fcheckPayment . addActionListener ( this ) ; fBankAccount_ID = new VLookup ( STR_ , BOOL_ , BOOL_ , BOOL_ , MLookupFactory . get ( Env . getCtx ( ) , p_WindowNo , NUM_ , MColumn . getColumn_ID ( MPayment . Table_Name , MPayment . COLUMNNAME_C_BankAccount_ID ) , DisplayType . TableDir ) ) ; lBankAccount_ID . setLabelFor ( fBankAccount_ID ) ; fBankAccount_ID . setBackground ( AdempierePLAF . getInfoBackground ( ) ) ; fBankAccount_ID . addActionListener ( this ) ; fBPartner_ID = new VLookup ( STR_ , BOOL_ , BOOL_ , BOOL_ , MLookupFactory . get ( Env . getCtx ( ) , p_WindowNo , NUM_ , MColumn . getColumn_ID ( MPayment . Table_Name , MPayment . COLUMNNAME_C_BPartner_ID ) , DisplayType . Search ) ) ; lBPartner_ID . setLabelFor ( fBPartner_ID ) ; fBPartner_ID . setBackground ( AdempierePLAF . getInfoBackground ( ) ) ; fBPartner_ID . addActionListener ( this ) ; lDateFrom . setLabelFor ( fDateFrom ) ; fDateFrom . setBackground ( AdempierePLAF . getInfoBackground ( ) ) ; fDateFrom . setToolTipText ( Msg . translate ( Env . getCtx ( ) , STR_ ) ) ; fDateFrom . addActionListener ( this ) ; lDateTo . setLabelFor ( fDateTo ) ; fDateTo . setBackground ( AdempierePLAF . getInfoBackground ( ) ) ; fDateTo . setToolTipText ( Msg . translate ( Env . getCtx ( ) , STR_ ) ) ; fDateTo . addActionListener ( this ) ; lAmtFrom . setLabelFor ( fAmtFrom ) ; fAmtFrom . setBackground ( AdempierePLAF . getInfoBackground ( ) ) ; fAmtFrom . setToolTipText ( Msg . translate ( Env . getCtx ( ) , STR_ ) ) ; fAmtFrom . setBorder ( fDateFrom . getBorder ( ) ) ; fAmtFrom . addActionListener ( this ) ; lAmtTo . setLabelFor ( fAmtTo ) ; fAmtTo . setBackground ( AdempierePLAF . getInfoBackground ( ) ) ; fAmtTo . setToolTipText ( Msg . translate ( Env . getCtx ( ) , STR_ ) ) ; fAmtTo . setBorder ( fDateFrom . getBorder ( ) ) ; fAmtTo . addActionListener ( this ) ; CPanel amtPanel = new CPanel ( ) ; CPanel datePanel = new CPanel ( ) ; amtPanel . setLayout ( new ALayout ( NUM_ , NUM_ , BOOL_ ) ) ; amtPanel . add ( fAmtFrom , new ALayoutConstraint ( NUM_ , NUM_ ) ) ; amtPanel . add ( lAmtTo , null ) ; amtPanel . add ( fAmtTo , null ) ; datePanel . setLayout ( new ALayout ( NUM_ , NUM_ , BOOL_ ) ) ; datePanel . add ( fDateFrom , new ALayoutConstraint ( NUM_ , NUM_ ) ) ; datePanel . add ( lDateTo , null ) ; datePanel . add ( fDateTo , null ) ; p_criteriaGrid . add ( lDocumentNo , new ALayoutConstraint ( NUM_ , NUM_ ) ) ; p_criteriaGrid . add ( fDocumentNo , null ) ; p_criteriaGrid . add ( lBPartner_ID , null ) ; p_criteriaGrid . add ( fBPartner_ID , null ) ; p_criteriaGrid . add ( fcheckReceipt , new ALayoutConstraint ( NUM_ , NUM_ ) ) ; p_criteriaGrid . add ( lBankAccount_ID , new ALayoutConstraint ( NUM_ , NUM_ ) ) ; p_criteriaGrid . add ( fBankAccount_ID ) ; p_criteriaGrid . add ( lDateFrom , null ) ; p_criteriaGrid . add ( datePanel , null ) ; p_criteriaGrid . add ( fcheckPayment , new ALayoutConstraint ( NUM_ , NUM_ ) ) ; p_criteriaGrid . add ( lAmtFrom , new ALayoutConstraint ( NUM_ , NUM_ ) ) ; p_criteriaGrid . add ( amtPanel , null ) ; }
@ Override public Graphics create ( ) { if ( DEBUG ) { m_printstream . println ( STR_ ) ; } PostscriptGraphics psg = new PostscriptGraphics ( this ) ; return ( psg ) ; }
private void parseActions ( ) { StringTokenizer st = new StringTokenizer ( actions , STR_ , BOOL_ ) ; boolean comma = BOOL_ ; while ( st . hasMoreTokens ( ) ) { String act = st . nextToken ( ) ; if ( act . equals ( STR_ ) ) { continue ; } else if ( comma ) { if ( ! act . equals ( STR_ ) ) { comma = BOOL_ ; break ; } } else if ( act . equalsIgnoreCase ( STR_ ) ) { mask |= CONNECT ; } else if ( act . equalsIgnoreCase ( STR_ ) ) { mask |= ACCEPT ; } else if ( act . equalsIgnoreCase ( STR_ ) ) { mask |= DELEGATE ; } else if ( act . equalsIgnoreCase ( STR_ ) ) { mask |= LISTEN ; } else { break ; } comma = ! comma ; } if ( ! comma ) { throw new IllegalArgumentException ( STR_ ) ; } }
byte [ ] toBytes ( SSLSession session ) { if ( ! ( session instanceof OpenSSLSessionImpl ) ) { return null ; } OpenSSLSessionImpl sslSession = ( OpenSSLSessionImpl ) session ; try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DataOutputStream daos = new DataOutputStream ( baos ) ; daos . writeInt ( OPEN_SSL ) ; byte [ ] data = sslSession . getEncoded ( ) ; daos . writeInt ( data . length ) ; daos . write ( data ) ; Certificate [ ] certs = session . getPeerCertificates ( ) ; daos . writeInt ( certs . length ) ; for ( Certificate cert : certs ) { data = cert . getEncoded ( ) ; daos . writeInt ( data . length ) ; daos . write ( data ) ; } return baos . toByteArray ( ) ; } catch ( IOException e ) { log ( e ) ; return null ; } catch ( CertificateEncodingException e ) { log ( e ) ; return null ; } }
private static void decodeTextCompaction ( int [ ] textCompactionData , int [ ] byteCompactionData , int length , StringBuilder result ) { Mode subMode = Mode . ALPHA ; Mode priorToShiftMode = Mode . ALPHA ; int i = NUM_ ; while ( i < length ) { int subModeCh = textCompactionData [ i ] ; char ch = NUM_ ; switch ( subMode ) { case ALPHA : if ( subModeCh < NUM_ ) { ch = ( char ) ( STR_ + subModeCh ) ; } else { if ( subModeCh == NUM_ ) { ch = STR_ ; } else if ( subModeCh == LL ) { subMode = Mode . LOWER ; } else if ( subModeCh == ML ) { subMode = Mode . MIXED ; } else if ( subModeCh == PS ) { priorToShiftMode = subMode ; subMode = Mode . PUNCT_SHIFT ; } else if ( subModeCh == MODE_SHIFT_TO_BYTE_COMPACTION_MODE ) { result . append ( ( char ) byteCompactionData [ i ] ) ; } else if ( subModeCh == TEXT_COMPACTION_MODE_LATCH ) { subMode = Mode . ALPHA ; } } break ; case LOWER : if ( subModeCh < NUM_ ) { ch = ( char ) ( STR_ + subModeCh ) ; } else { if ( subModeCh == NUM_ ) { ch = STR_ ; } else if ( subModeCh == AS ) { priorToShiftMode = subMode ; subMode = Mode . ALPHA_SHIFT ; } else if ( subModeCh == ML ) { subMode = Mode . MIXED ; } else if ( subModeCh == PS ) { priorToShiftMode = subMode ; subMode = Mode . PUNCT_SHIFT ; } else if ( subModeCh == MODE_SHIFT_TO_BYTE_COMPACTION_MODE ) { result . append ( ( char ) byteCompactionData [ i ] ) ; } else if ( subModeCh == TEXT_COMPACTION_MODE_LATCH ) { subMode = Mode . ALPHA ; } } break ; case MIXED : if ( subModeCh < PL ) { ch = MIXED_CHARS [ subModeCh ] ; } else { if ( subModeCh == PL ) { subMode = Mode . PUNCT ; } else if ( subModeCh == NUM_ ) { ch = STR_ ; } else if ( subModeCh == LL ) { subMode = Mode . LOWER ; } else if ( subModeCh == AL ) { subMode = Mode . ALPHA ; } else if ( subModeCh == PS ) { priorToShiftMode = subMode ; subMode = Mode . PUNCT_SHIFT ; } else if ( subModeCh == MODE_SHIFT_TO_BYTE_COMPACTION_MODE ) { result . append ( ( char ) byteCompactionData [ i ] ) ; } else if ( subModeCh == TEXT_COMPACTION_MODE_LATCH ) { subMode = Mode . ALPHA ; } } break ; case PUNCT : if ( subModeCh < PAL ) { ch = PUNCT_CHARS [ subModeCh ] ; } else { if ( subModeCh == PAL ) { subMode = Mode . ALPHA ; } else if ( subModeCh == MODE_SHIFT_TO_BYTE_COMPACTION_MODE ) { result . append ( ( char ) byteCompactionData [ i ] ) ; } else if ( subModeCh == TEXT_COMPACTION_MODE_LATCH ) { subMode = Mode . ALPHA ; } } break ; case ALPHA_SHIFT : subMode = priorToShiftMode ; if ( subModeCh < NUM_ ) { ch = ( char ) ( STR_ + subModeCh ) ; } else { if ( subModeCh == NUM_ ) { ch = STR_ ; } else if ( subModeCh == TEXT_COMPACTION_MODE_LATCH ) { subMode = Mode . ALPHA ; } } break ; case PUNCT_SHIFT : subMode = priorToShiftMode ; if ( subModeCh < PAL ) { ch = PUNCT_CHARS [ subModeCh ] ; } else { if ( subModeCh == PAL ) { subMode = Mode . ALPHA ; } else if ( subModeCh == MODE_SHIFT_TO_BYTE_COMPACTION_MODE ) { result . append ( ( char ) byteCompactionData [ i ] ) ; } else if ( subModeCh == TEXT_COMPACTION_MODE_LATCH ) { subMode = Mode . ALPHA ; } } break ; } if ( ch != NUM_ ) { result . append ( ch ) ; } i ++ ; } }
public static boolean isValidName ( String name ) { if ( name == null ) { return BOOL_ ; } return name . length ( ) > NUM_ ; }
protected void addCounters ( BasicCounters < MutableLong > target , BasicCounters < MutableLong > source ) { for ( Enum < ReaderCounterKeys > key : ReaderCounterKeys . values ( ) ) { MutableLong tcounter = target . getCounter ( key ) ; if ( tcounter == null ) { tcounter = new MutableLong ( ) ; target . setCounter ( key , tcounter ) ; } MutableLong scounter = source . getCounter ( key ) ; if ( scounter != null ) { tcounter . add ( scounter . longValue ( ) ) ; } } }
private void addCard ( SharedPreferences sharedPreferences , String key ) { String json = sharedPreferences . getString ( key , null ) ; if ( json != null ) { try { JSONObject jsonData = new JSONObject ( json ) ; if ( jsonData . has ( IMAGE_KEY ) ) { String image = jsonData . getString ( IMAGE_KEY ) ; List < ITopic > cards = getSourceTopicModel ( ) ; switch ( key ) { case POOL_KEY : cards . add ( NUM_ , Cards . pool ( image , getActivity ( ) ) ) ; removeDuplicates ( POOL_KEY , cards ) ; break ; case VIDEO_KEY : switch ( jsonData . getString ( ID_KEY ) ) { case POOL_CAMERA_ID : mGreatShotUrl = jsonData . getString ( URL_KEY ) ; mElv . setOnGroupClickListener ( greatShotListener ) ; cards . add ( NUM_ , Cards . poolVideo ( mGreatShotUrl , getActivity ( ) ) ) ; removeDuplicates ( VIDEO_KEY , cards ) ; break ; } break ; case FOOD_KEY : cards . add ( NUM_ , Cards . food ( image , getActivity ( ) ) ) ; removeDuplicates ( FOOD_KEY , cards ) ; break ; case PRINTER_3D_KEY : cards . add ( NUM_ , Cards . printer3d ( image , getActivity ( ) ) ) ; removeDuplicates ( PRINTER_3D_KEY , cards ) ; break ; } } else if ( jsonData . has ( MESSAGE_KEY ) ) { String message = jsonData . getString ( MESSAGE_KEY ) ; List < ITopic > cards = getSourceTopicModel ( ) ; cards . add ( NUM_ , Cards . test ( message , getActivity ( ) ) ) ; } UI . execute ( null ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } } }
public static List < LoggedMqttMessage > parseMessageLog ( final List < String > messages , final ProgressUpdater progress , final long current , final long max ) throws SpyException { try { final long startTime = TimeUtils . getMonotonicTime ( ) ; final int items = messages . size ( ) ; final long chunkSize = items / NUM_ ; final MqttMessageLogParser parser = new MqttMessageLogParser ( ) ; final List < LoggedMqttMessage > list = new ArrayList < LoggedMqttMessage > ( ) ; long item = NUM_ ; long reportAt = NUM_ ; for ( int i = NUM_ ; i < items ; i ++ ) { final String message = messages . get ( i ) ; if ( progress != null ) { if ( progress . isCancelled ( ) ) { logger . info ( STR_ ) ; return null ; } item ++ ; if ( item % NUM_ == NUM_ ) { progress . update ( current + item , max ) ; } } if ( ( i > NUM_ ) && ( i == ( chunkSize . reportAt ) ) ) { final long currentTime = TimeUtils . getMonotonicTime ( ) ; final long timeTaken = currentTime - startTime ; final long totalTimeExpected = timeTaken . items / i ; if ( timeTaken > NUM_ ) { logger . info ( STR_ , reportAt . NUM_ , ( totalTimeExpected - timeTaken ) / NUM_ ) ; } reportAt ++ ; } try { list . add ( parser . parse ( message ) ) ; } catch ( XMLException e ) { logger . error ( STR_ + message , e ) ; } } logger . info ( STR_ , list . size ( ) ) ; return list ; } catch ( XMLException e ) { throw new SpyException ( STR_ , e ) ; } }
private int transition ( int state , int symbol ) { for ( int i = state ; i < transitions . length ; i ++ ) { if ( ( transitions [ i ] % vocabularySize ) == symbol ) { return ( transitions [ i ] / vocabularySize ) ; } } return - NUM_ ; }
public synchronized CeylonConfig merge ( CeylonConfig other ) { for ( String key : other . getOptionNames ( null ) ) { String [ ] values = other . getOptionValues ( key ) ; setOptionValues ( key , values ) ; } return this ; }
public static synchronized String rot13 ( String input ) { StringBuffer output = new StringBuffer ( ) ; if ( input != null ) { for ( int i = NUM_ ; i < input . length ( ) ; i ++ ) { char inChar = input . charAt ( i ) ; if ( ( inChar >= STR_ ) & ( inChar <= STR_ ) ) { inChar += NUM_ ; if ( inChar > STR_ ) { inChar -= NUM_ ; } } if ( ( inChar >= STR_ ) & ( inChar <= STR_ ) ) { inChar += NUM_ ; if ( inChar > STR_ ) { inChar -= NUM_ ; } } output . append ( inChar ) ; } } return output . toString ( ) ; }
private long monthRange ( ) { ValueRange startRange = chrono . range ( MONTH_OF_YEAR ) ; if ( startRange . isFixed ( ) && startRange . isIntValue ( ) ) { return startRange . getMaximum ( ) - startRange . getMinimum ( ) + NUM_ ; } return - NUM_ ; }
public void animate ( MarkerWithPosition marker , LatLng from , LatLng to ) { lock . lock ( ) ; mAnimationTasks . add ( new AnimationTask ( marker , from , to ) ) ; lock . unlock ( ) ; }
@ Override public int compareTo ( ComponentDescription o ) { int myPos = NUM_ ; int oPos = NUM_ ; if ( this instanceof LanguageComponentDescription ) { myPos = NUM_ ; } else if ( this instanceof VoiceComponentDescription ) { myPos = NUM_ ; } if ( o instanceof LanguageComponentDescription ) { oPos = NUM_ ; } else if ( o instanceof VoiceComponentDescription ) { oPos = NUM_ ; } if ( oPos - myPos != NUM_ ) { return ( oPos - myPos ) ; } return name . compareTo ( o . name ) ; }
public boolean [ ] testToString ( ) { return super . testToString ( ) ; }
public static byte [ ] escapeEasternUnicodeByteStream ( byte [ ] origBytes , String origString ) { if ( origBytes == null ) { return null ; } if ( origBytes . length == NUM_ ) { return new byte [ NUM_ ] ; } int bytesLen = origBytes . length ; int bufIndex = NUM_ ; int strIndex = NUM_ ; ByteArrayOutputStream bytesOut = new ByteArrayOutputStream ( bytesLen ) ; while ( BOOL_ ) { if ( origString . charAt ( strIndex ) == STR_ ) { bytesOut . write ( origBytes [ bufIndex ++ ] ) ; } else { int loByte = origBytes [ bufIndex ] ; if ( loByte < NUM_ ) { loByte += NUM_ ; } bytesOut . write ( loByte ) ; if ( loByte >= x80 ) { if ( bufIndex < ( bytesLen - NUM_ ) ) { int hiByte = origBytes [ bufIndex + NUM_ ] ; if ( hiByte < NUM_ ) { hiByte += NUM_ ; } bytesOut . write ( hiByte ) ; bufIndex ++ ; if ( hiByte == x5C ) { bytesOut . write ( hiByte ) ; } } } else if ( loByte == x5c ) { if ( bufIndex < ( bytesLen - NUM_ ) ) { int hiByte = origBytes [ bufIndex + NUM_ ] ; if ( hiByte < NUM_ ) { hiByte += NUM_ ; } if ( hiByte == x62 ) { bytesOut . write ( x5c ) ; bytesOut . write ( x62 ) ; bufIndex ++ ; } } } bufIndex ++ ; } if ( bufIndex >= bytesLen ) { break ; } strIndex ++ ; } return bytesOut . toByteArray ( ) ; }
private static StringBuilder dump ( StringBuilder _lbuffer , long value ) { for ( int j = NUM_ ; j < NUM_ ; j ++ ) { _lbuffer . append ( CHARS [ ( int ) ( value > > SHIFTS [ j ] ) & NUM_ ] ) ; } return _lbuffer ; }
@ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { super . onMeasure ( widthMeasureSpec , heightMeasureSpec ) ; int sizeWidth = MeasureSpec . getSize ( widthMeasureSpec ) - getPaddingLeft ( ) - getPaddingRight ( ) ; int sizeHeight = MeasureSpec . getSize ( heightMeasureSpec ) ; int modeWidth = MeasureSpec . getMode ( widthMeasureSpec ) ; int modeHeight = MeasureSpec . getMode ( heightMeasureSpec ) ; int width = NUM_ ; int height = getPaddingTop ( ) + getPaddingBottom ( ) ; int lineWidth = NUM_ ; int lineHeight = NUM_ ; int childCount = getChildCount ( ) ; for ( int i = NUM_ ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; boolean lastChild = i == childCount - NUM_ ; if ( child . getVisibility ( ) == View . GONE ) { if ( lastChild ) { width = Math . max ( width , lineWidth ) ; height += lineHeight ; } continue ; } measureChildWithMargins ( child , widthMeasureSpec , lineWidth , heightMeasureSpec , height ) ; LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; int childWidthMode = MeasureSpec . AT_MOST ; int childWidthSize = sizeWidth ; int childHeightMode = MeasureSpec . AT_MOST ; int childHeightSize = sizeHeight ; if ( lp . width == LayoutParams . MATCH_PARENT ) { childWidthMode = MeasureSpec . EXACTLY ; childWidthSize -= lp . leftMargin + lp . rightMargin ; } else if ( lp . width >= NUM_ ) { childWidthMode = MeasureSpec . EXACTLY ; childWidthSize = lp . width ; } if ( lp . height >= NUM_ ) { childHeightMode = MeasureSpec . EXACTLY ; childHeightSize = lp . height ; } else if ( modeHeight == MeasureSpec . UNSPECIFIED ) { childHeightMode = MeasureSpec . UNSPECIFIED ; childHeightSize = NUM_ ; } child . measure ( MeasureSpec . makeMeasureSpec ( childWidthSize , childWidthMode ) , MeasureSpec . makeMeasureSpec ( childHeightSize , childHeightMode ) ) ; int childWidth = child . getMeasuredWidth ( ) + lp . leftMargin + lp . rightMargin ; if ( lineWidth + childWidth > sizeWidth ) { width = Math . max ( width , lineWidth ) ; lineWidth = childWidth ; height += lineHeight ; lineHeight = child . getMeasuredHeight ( ) + lp . topMargin + lp . bottomMargin ; } else { lineWidth += childWidth ; lineHeight = Math . max ( lineHeight , child . getMeasuredHeight ( ) + lp . topMargin + lp . bottomMargin ) ; } if ( lastChild ) { width = Math . max ( width , lineWidth ) ; height += lineHeight ; } } width += getPaddingLeft ( ) + getPaddingRight ( ) ; setMeasuredDimension ( ( modeWidth == MeasureSpec . EXACTLY ) ? sizeWidth : width , ( modeHeight == MeasureSpec . EXACTLY ) ? sizeHeight : height ) ; }
public UnionMemberDescriptionWithError ( IEObjectDescription delegate , ComposedTypeRef composedTypeRef , IScope [ ] subScopes , boolean writeAccess ) { super ( delegate ) ; this . composedTypeRef = composedTypeRef ; this . subScopes = subScopes ; max = subScopes . length ; this . writeAccess = writeAccess ; }
private void readObject ( ObjectInputStream oos ) throws IOException , ClassNotFoundException { iInstant = ( DateMidnight ) oos . readObject ( ) ; DateTimeFieldType type = ( DateTimeFieldType ) oos . readObject ( ) ; iField = type . getField ( iInstant . getChronology ( ) ) ; }
public void generateLootChest ( World world , Random random , BlockPos pos , int min , int max , IBlockState state , ResourceLocation lootTable ) { world . setBlockState ( pos , state , NUM_ ) ; TileEntityChest chest = ( TileEntityChest ) world . getTileEntity ( pos ) ; if ( chest != null ) chest . setLootTable ( lootTable , random . nextLong ( ) ) ; }
public void remove ( ) throws RecurrenceRuleException { try { rule . remove ( ) ; } catch ( GenericEntityException e ) { throw new RecurrenceRuleException ( e . getMessage ( ) , e ) ; } }
private boolean shouldBeEscaped ( char c ) { return c < STR_ || ( c >= STR_ && c < STR_ ) || ( c >= STR_ && c < STR_ ) ; }
public CEventTableMenu ( final JTable table , final List < ITraceEvent > traces ) { addOpenFunction ( SwingUtilities . getWindowAncestor ( table ) , traces ) ; add ( new JMenuItem ( CActionProxy . proxy ( new CSearchTableAction ( SwingUtilities . getWindowAncestor ( table ) , table ) ) ) ) ; add ( new CopySelectionAction ( table ) ) ; }
@ Override public int available ( ) throws IOException { return ( outBytes_ . length + inputStream_ . available ( ) ) ; }
public boolean checkError ( ) { return pw . checkError ( ) ; }
public Criteria createCriteria ( ) { Criteria criteria = createCriteriaInternal ( ) ; if ( oredCriteria . size ( ) == NUM_ ) { oredCriteria . add ( criteria ) ; } return criteria ; }
public void addBugPattern ( BugPattern bugPattern ) { bugPatterns . add ( bugPattern ) ; }
public SpiderGitParser ( SpiderParam params ) { super ( ) ; this . params = params ; }
public void onRetry ( int retryNo ) { Log . d ( LOG_TAG , String . format ( STR_ , retryNo ) ) ; }
protected void analyzeDtoSetterMethod ( Method method , MethodModel methodModel ) { methodModel . setSetter ( BOOL_ ) ; Type fieldType = method . getGenericParameterTypes ( ) [ NUM_ ] ; String fieldName = getSetterFieldName ( method ) ; fieldAttributes . put ( fieldName , fieldType ) ; methodModel . setFieldName ( fieldName ) ; methodModel . setFieldType ( convertType ( fieldType ) ) ; }
public static String loadLastColor ( Context context ) { try { SharedPreferences sharedPreferences = context . getSharedPreferences ( STR_ , Context . MODE_PRIVATE ) ; String s = sharedPreferences . getString ( SP_KEY_LAST_COLOR , null ) ; Color . parseColor ( s ) ; return s ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } }
public BevelBorder ( int bevelType , Color highlight , Color shadow ) { this ( bevelType , highlight . brighter ( ) , highlight , shadow , shadow . brighter ( ) ) ; }
protected final void refreshSessionLayer ( final Location location ) { if ( ! mRefreshSessionPending && isVisible ( ) ) { Log . d ( TAG , STR_ ) ; mRefreshSessionPending = BOOL_ ; triggerSessionObjectsUpdate ( null ) ; sessionObjectsRefreshTime = System . currentTimeMillis ( ) ; sessionObjectsRefreshedAt = location ; } else if ( ! isVisible ( ) ) { Log . v ( TAG , STR_ ) ; } else { Log . v ( TAG , STR_ ) ; } }
public static int mDateGap ( String dayName ) { Log . d ( STR_ , dayName ) ; if ( dayName . equals ( STR_ ) ) { return NUM_ ; } else if ( dayName . equals ( STR_ ) ) { return NUM_ ; } else if ( dayName . equals ( STR_ ) ) { return NUM_ ; } else if ( dayName . equals ( STR_ ) ) { return NUM_ ; } else if ( dayName . equals ( STR_ ) ) { return NUM_ ; } else if ( dayName . equals ( STR_ ) ) { return NUM_ ; } else { return NUM_ ; } }
public static String removeAdditionalParty ( HttpServletRequest request , HttpServletResponse response ) { ShoppingCart cart = getCartObject ( request ) ; String partyId = request . getParameter ( STR_ ) ; String roleTypeId [ ] = request . getParameterValues ( STR_ ) ; List < String > eventList = new LinkedList < String > ( ) ; Locale locale = UtilHttp . getLocale ( request ) ; int i ; if ( UtilValidate . isEmpty ( partyId ) || roleTypeId . length < NUM_ ) { request . setAttribute ( STR_ , UtilProperties . getMessage ( resource_error , STR_ , locale ) ) ; return STR_ ; } if ( request . getAttribute ( STR_ ) != null ) { List < String > msg = UtilGenerics . checkList ( request . getAttribute ( STR_ ) ) ; eventList . addAll ( msg ) ; } for ( i = NUM_ ; i < roleTypeId . length ; i ++ ) { try { cart . removeAdditionalPartyRole ( partyId , roleTypeId [ i ] ) ; } catch ( Exception e ) { Debug . logInfo ( e . getLocalizedMessage ( ) , module ) ; eventList . add ( e . getLocalizedMessage ( ) ) ; } } request . removeAttribute ( STR_ ) ; request . setAttribute ( STR_ , eventList ) ; return STR_ ; }
public Map < String , String [ ] > crop ( final Map < String , String [ ] > original ) { Map < String , String [ ] > result = new HashMap < String , String [ ] > ( original . size ( ) ) ; for ( Map . Entry < String , String [ ] > entry : original . entrySet ( ) ) { String key = entry . getKey ( ) ; if ( null == key ) { continue ; } String [ ] value = entry . getValue ( ) ; String [ ] convertedValue ; if ( null == value ) { convertedValue = new String [ NUM_ ] ; convertedValue [ NUM_ ] = STR_ ; } else { boolean croppingWasNeeded = BOOL_ ; convertedValue = value ; for ( int i = NUM_ , l = value . length ; i < l ; i ++ ) { String curValue = value [ i ] ; String croppingResult = crop ( curValue ) ; if ( ( curValue != croppingResult ) & ! croppingWasNeeded ) { croppingWasNeeded = BOOL_ ; convertedValue = new String [ value . length ] ; System . arraycopy ( value , NUM_ , convertedValue , NUM_ , i ) ; convertedValue [ i ] = croppingResult ; } if ( croppingWasNeeded ) { convertedValue [ i ] = croppingResult ; } } } result . put ( key , convertedValue ) ; } return result ; }
@ Override int lookForSelectablePosition ( int position , boolean lookDown ) { final ListAdapter adapter = mAdapter ; if ( adapter == null || isInTouchMode ( ) ) { return INVALID_POSITION ; } final int count = adapter . getCount ( ) ; if ( ! mAreAllItemsSelectable ) { if ( lookDown ) { position = Math . max ( NUM_ , position ) ; while ( position < count && ! adapter . isEnabled ( position ) ) { position ++ ; } } else { position = Math . min ( position , count - NUM_ ) ; while ( position >= NUM_ && ! adapter . isEnabled ( position ) ) { position -- ; } } if ( position < NUM_ || position >= count ) { return INVALID_POSITION ; } return position ; } else { if ( position < NUM_ || position >= count ) { return INVALID_POSITION ; } return position ; } }
@ Override public void deleteBCVHelperVolume ( StorageSystem storageSystem , Volume volume ) throws Exception { _log . info ( String . format ( STR_ , storageSystem . getId ( ) , volume . getId ( ) ) ) ; try { String deviceName = volume . getNativeId ( ) ; String deviceNameWithoutLeadingZeros = deviceName . replaceAll ( STR_ , STR_ ) ; String query = String . format ( STR_ , SmisConstants . CP_ELEMENT_NAME , SmisConstants . CP_DEVICE_ID , SmisConstants . CP_ELEMENT_NAME , deviceNameWithoutLeadingZeros ) ; String queryLanguage = STR_ ; List < CIMInstance > bcvVolumeInstanceList = _helper . executeQuery ( storageSystem , query , queryLanguage ) ; if ( bcvVolumeInstanceList == null || bcvVolumeInstanceList . isEmpty ( ) ) { query = String . format ( STR_ , SmisConstants . CP_ELEMENT_NAME , SmisConstants . CP_DEVICE_ID , SmisConstants . CP_ELEMENT_NAME , deviceName ) ; bcvVolumeInstanceList = _helper . executeQuery ( storageSystem , query , queryLanguage ) ; } String elementName = null ; String nativeId = null ; CIMInstance bcvVolumeInstance = null ; if ( bcvVolumeInstanceList != null && ! bcvVolumeInstanceList . isEmpty ( ) ) { bcvVolumeInstance = bcvVolumeInstanceList . get ( NUM_ ) ; elementName = CIMPropertyFactory . getPropertyValue ( bcvVolumeInstance , SmisConstants . CP_ELEMENT_NAME ) ; nativeId = CIMPropertyFactory . getPropertyValue ( bcvVolumeInstance , SmisConstants . CP_DEVICE_ID ) ; _log . info ( String . format ( STR_ , elementName , nativeId ) ) ; } else { _log . warn ( String . format ( STR_ , volume . getId ( ) , volume . getNativeId ( ) ) ) ; return ; } _log . info ( String . format ( STR_ + nativeId ) ) ; String [ ] nativeIds = new String [ ] { nativeId } ; CIMObjectPath configSvcPath = _cimPath . getConfigSvcPath ( storageSystem ) ; CIMArgument [ ] inArgs = _helper . getDeleteVolumesInputArguments ( storageSystem , nativeIds ) ; CIMArgument [ ] outArgs = new CIMArgument [ NUM_ ] ; String returnElementsMethod ; if ( storageSystem . getUsingSmis80 ( ) ) { returnElementsMethod = SmisConstants . RETURN_ELEMENTS_TO_STORAGE_POOL ; } else { returnElementsMethod = SmisConstants . EMC_RETURN_TO_STORAGE_POOL ; } _helper . invokeMethodSynchronously ( storageSystem , configSvcPath , returnElementsMethod , inArgs , outArgs , null ) ; _log . info ( String . format ( STR_ + nativeId ) ) ; } catch ( Exception ex ) { _log . error ( String . format ( STR_ , storageSystem . getId ( ) , volume . getId ( ) ) ) ; } }
public void populateBottomTabItems ( @ NonNull BottomTabsBuilder builder ) { if ( mContainer . getChildCount ( ) >= MIN_BOTTOM_NAVIGATION_ITEMS ) { checkBottomItemGuidelines ( mContainer . getChildCount ( ) ) ; } List < BottomNavigationItem > build = builder . build ( ) ; for ( int i = NUM_ ; i < build . size ( ) ; i ++ ) { BottomNavigationItem item = build . get ( i ) ; item . setPosition ( i ) ; addBottomNavigationItem ( item ) ; } updateBottomNavViews ( ) ; selectTabView ( ) ; }
public final int skipBytes ( int count ) throws java . io . IOException { int skipped = NUM_ ; long skip ; while ( skipped < count && ( skip = in . skip ( count - skipped ) ) != NUM_ ) { skipped += skip ; } return skipped ; }
public GeneralAndersonDarlingTest ( List < Double > data , RealDistribution dist ) { if ( dist == null ) { throw new NullPointerException ( ) ; } this . dist = dist ; Collections . sort ( data ) ; this . data = data ; runTest ( ) ; }
private final void insert ( Object text ) { buf . insert ( buf . length ( ) - NUM_ , STR_ ) ; buf . insert ( buf . length ( ) - NUM_ , text ) ; }
public static void splitTextures ( File destination , File texturePack , double scale , boolean alphas , ProgressCallback progress ) throws Exception { if ( destination == null ) throw new IllegalArgumentException ( STR_ ) ; Log . info ( STR_ + destination + STR_ ) ; if ( ! destination . exists ( ) || ! destination . isDirectory ( ) ) { if ( destination . exists ( ) ) throw new RuntimeException ( STR_ ) ; if ( ! destination . mkdir ( ) ) throw new RuntimeException ( STR_ ) ; } getTextures ( texturePack , scale , progress , alphas , BOOL_ , destination ) ; }
public void testBuilder_RootOnConstruct_MultipleAppends ( ) { SQLException root = new SQLException ( ) ; List < SQLException > additionalExceptions = new ArrayList < SQLException > ( ) ; for ( int count = NUM_ ; count <= NUM_ ; count ++ ) { additionalExceptions . add ( new SQLException ( Integer . toString ( count ) ) ) ; } SQLExceptionChainBuilder < SQLException > builder = new SQLExceptionChainBuilder < SQLException > ( root ) ; for ( SQLException ex : additionalExceptions ) { builder . append ( ex ) ; } assertTrue ( STR_ , builder . hasException ( ) ) ; SQLException resultException = builder . getException ( ) ; assertSame ( STR_ , root , resultException ) ; checkExceptionChain ( resultException , additionalExceptions ) ; }
protected synchronized String nextCnxKey ( ) { if ( connectionsCounter == Integer . MAX_VALUE ) connectionsCounter = NUM_ ; connectionsCounter ++ ; int randLong = random . nextInt ( Integer . MAX_VALUE ) ; return connectionsCounter + ( randLong + STR_ + ID_SUFFIX ) ; }
public static boolean copyFileSafe ( final Path srcFile , final Path destFile ) throws IOException { return copyFileSafe ( srcFile , destFile , BOOL_ ) ; }
public static boolean isHeader ( Header header ) { String xten = header . getStringValue ( XTENSION ) ; if ( xten == null ) { return BOOL_ ; } xten = xten . trim ( ) ; return xten . equals ( XTENSION_BINTABLE ) || xten . equals ( STR_ ) ; }
final void putFloat ( int offset , float value ) { unsafe . putFloat ( offset + address , value ) ; }
public void doctypeDecl ( String rootElement , String publicId , String systemId , Augmentations augs ) throws XNIException { fInDTD = BOOL_ ; try { if ( fLexicalHandler != null ) { fLexicalHandler . startDTD ( rootElement , publicId , systemId ) ; } } catch ( SAXException e ) { throw new XNIException ( e ) ; } if ( fDeclHandler != null ) { fDeclaredAttrs = new SymbolHash ( ) ; } }
@ VisibleForTesting static OMAEntry parseOMAEntry ( String entry ) { int index = entry . indexOf ( STR_ ) ; long downloadId = Long . parseLong ( entry . substring ( NUM_ , index ) ) ; return new OMAEntry ( downloadId , entry . substring ( index + NUM_ ) ) ; }
public void parse ( ) throws IOException { long length = NUM_ ; try { length = file . length ( ) ; } catch ( IOException e ) { throw new IOException ( STR_ ) ; } try { parse ( STR_ , length ) ; } catch ( IOException e ) { throw new IOException ( STR_ ) ; } }
public void test_SelectUnionItself ( ) throws SQLException { String sql = STR_ + STR_ + DatabaseCreator . CUSTOMERS_TABLE + STR_ + DatabaseCreator . CUSTOMERS_TABLE + STR_ + STR_ + STR_ ; ResultSet result = statement . executeQuery ( sql ) ; HashMap < Integer , String > value = new HashMap < Integer , String > ( ) ; value . put ( NUM_ , STR_ ) ; value . put ( NUM_ , STR_ ) ; value . put ( NUM_ , STR_ ) ; while ( result . next ( ) ) { int key = result . getInt ( STR_ ) ; String val = result . getString ( STR_ ) ; assertTrue ( STR_ , value . containsKey ( key ) ) ; assertEquals ( STR_ , value . get ( key ) , val ) ; value . remove ( key ) ; } assertTrue ( STR_ , value . isEmpty ( ) ) ; result . close ( ) ; }
public ReflectiveProperty ( Class < T > propertyHolder , Class < V > valueType , String name ) { super ( valueType , name ) ; char firstLetter = Character . toUpperCase ( name . charAt ( NUM_ ) ) ; String theRest = name . substring ( NUM_ ) ; String capitalizedName = firstLetter + theRest ; String getterName = PREFIX_GET + capitalizedName ; try { mGetter = propertyHolder . getMethod ( getterName , ( Class < ? > [ ] ) null ) ; } catch ( NoSuchMethodException e ) { try { mGetter = propertyHolder . getDeclaredMethod ( getterName , ( Class < ? > [ ] ) null ) ; mGetter . setAccessible ( BOOL_ ) ; } catch ( NoSuchMethodException e2 ) { getterName = PREFIX_IS + capitalizedName ; try { mGetter = propertyHolder . getMethod ( getterName , ( Class < ? > [ ] ) null ) ; } catch ( NoSuchMethodException e3 ) { try { mGetter = propertyHolder . getDeclaredMethod ( getterName , ( Class < ? > [ ] ) null ) ; mGetter . setAccessible ( BOOL_ ) ; } catch ( NoSuchMethodException e4 ) { try { mField = propertyHolder . getField ( name ) ; Class fieldType = mField . getType ( ) ; if ( ! typesMatch ( valueType , fieldType ) ) { throw new NoSuchPropertyException ( STR_ + fieldType + STR_ + STR_ + valueType + STR_ ) ; } return ; } catch ( NoSuchFieldException e5 ) { throw new NoSuchPropertyException ( STR_ + STR_ + name ) ; } } } } } Class getterType = mGetter . getReturnType ( ) ; if ( ! typesMatch ( valueType , getterType ) ) { throw new NoSuchPropertyException ( STR_ + getterType + STR_ + STR_ + valueType + STR_ ) ; } String setterName = PREFIX_SET + capitalizedName ; try { mSetter = propertyHolder . getDeclaredMethod ( setterName , getterType ) ; mSetter . setAccessible ( BOOL_ ) ; } catch ( NoSuchMethodException ignored ) { } }
public CFunctionTypePanel ( final ListenerProvider < IFilterDialogListener > listeners ) { super ( new BorderLayout ( ) ) ; m_listeners = listeners ; final JPanel innerPanel = new JPanel ( new GridLayout ( NUM_ , NUM_ ) ) ; innerPanel . add ( buildRow ( STR_ , m_normalFunctionCheckbox ) ) ; innerPanel . add ( buildRow ( STR_ , m_importedFunctionCheckbox ) ) ; innerPanel . add ( buildRow ( STR_ , m_libraryFunctionCheckbox ) ) ; innerPanel . add ( buildRow ( STR_ , m_thunkFunctionCheckbox ) ) ; innerPanel . add ( buildRow ( STR_ , m_adjustorFunctionCheckbox ) ) ; add ( innerPanel , BorderLayout . NORTH ) ; setBorder ( new TitledBorder ( STR_ ) ) ; }
public DragContext ( Node draggable ) { this . node = draggable ; this . goToForegroundOnContact = BOOL_ ; this . touchId = NULL_ID ; this . activated = BOOL_ ; this . dragLimits = new BoundingBox ( NUM_ , NUM_ , Integer . MAX_VALUE , Integer . MAX_VALUE ) ; this . dragThreshold = NUM_ ; this . dragStarted = BOOL_ ; this . relocateThreshold = NUM_ ; this . dragInitAction = null ; this . dragFinishAction = null ; touchHandler = null ; mouseHandler = null ; draggable . addEventHandler ( TouchEvent . ANY , touchHandler ) ; draggable . addEventHandler ( MouseEvent . ANY , mouseHandler ) ; }
protected X509Certificate [ ] openCertificate ( File certificateFile ) { try { FileInputStream is = new FileInputStream ( certificateFile ) ; return openCertificate ( is , certificateFile . getName ( ) ) ; } catch ( FileNotFoundException ex ) { JOptionPane . showMessageDialog ( frame , MessageFormat . format ( res . getString ( STR_ ) , certificateFile ) , res . getString ( STR_ ) , JOptionPane . WARNING_MESSAGE ) ; return null ; } }
public ShapeTileSimplex ( PlaLineIntAlist p_line_alist ) { lines_list = new ArrayList < PlaLineInt > ( p_line_alist . size ( ) ) ; for ( PlaLineInt a_line : p_line_alist ) lines_list . add ( a_line ) ; Collections . sort ( lines_list ) ; }
public ProperFractionFormat ( NumberFormat format ) { this ( format , ( NumberFormat ) format . clone ( ) , ( NumberFormat ) format . clone ( ) ) ; }
private File createCaptureFile ( int encodingType ) { return createCaptureFile ( encodingType , STR_ ) ; }
public double [ ] [ ] extractMainSetJacobian ( final ODEState state ) { final double [ ] p = state . getSecondaryState ( index ) ; final double [ ] [ ] dYdY0 = new double [ jode . getDimension ( ) ] [ jode . getDimension ( ) ] ; int j = NUM_ ; for ( int i = NUM_ ; i < jode . getDimension ( ) ; i ++ ) { System . arraycopy ( p , j , dYdY0 [ i ] , NUM_ , jode . getDimension ( ) ) ; j += jode . getDimension ( ) ; } return dYdY0 ; }
public static String byteToHexString ( byte [ ] byteArray ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = NUM_ ; i < byteArray . length ; i ++ ) { int byteCode = byteArray [ i ] & xFF ; if ( byteCode < x10 ) { builder . append ( NUM_ ) ; } builder . append ( Integer . toHexString ( byteCode ) ) ; } return builder . toString ( ) ; }
public static void assertNotEqual ( Object expected , Object actual ) { if ( verbose ) { log ( STR_ + expected + STR_ + actual + STR_ ) ; } TestUtils . assertBool ( ! expected . equals ( actual ) ) ; }
private boolean isEmpty ( String value ) { return value . length ( ) == NUM_ ; }
private void disposeCodec ( IoSession session ) { disposeEncoder ( session ) ; disposeDecoder ( session ) ; disposeDecoderOut ( session ) ; }
public static ObjectStreamClass lookupAny ( Class < ? > cl ) { return lookupStreamClass ( cl ) ; }
public static void main ( String [ ] args ) { try { int serverPort = Integer . parseInt ( System . getProperty ( STR_ , STR_ ) ) ; TTransport transport ; transport = new TFramedTransport ( new TSocket ( STR_ , serverPort ) ) ; transport . open ( ) ; TProtocol protocol = new TBinaryProtocol ( transport ) ; PacketStreamer . Client client = new PacketStreamer . Client ( protocol ) ; sendPackets ( client , ( short ) NUM_ , OFMessageType . PACKET_IN , BOOL_ ) ; log . debug ( STR_ ) ; client . terminateSession ( STR_ ) ; transport . close ( ) ; } catch ( TException x ) { x . printStackTrace ( ) ; } }
public ConfigurationParser ( boolean verify , ClassLoader loader ) throws ParserConfigurationException { factory = DocumentBuilderFactory . newInstance ( ) ; factory . setValidating ( verify ) ; factory . setNamespaceAware ( BOOL_ ) ; factory . setExpandEntityReferences ( BOOL_ ) ; factory . setCoalescing ( BOOL_ ) ; builder = factory . newDocumentBuilder ( ) ; if ( verify ) builder . setErrorHandler ( new XMLErrorHandler ( ) ) ; if ( loader == null ) throw new NullPointerException ( STR_ ) ; }
TestEnvironment ( SystemTestEnvironment systemTestEnvironment , Path workingDir , Path sourceDir , Path classDir , Path jacocoDir ) { this . systemTestEnvironment = systemTestEnvironment ; this . workingDir = workingDir ; this . sourceDir = sourceDir ; this . classDir = classDir ; this . jacocoDir = jacocoDir ; this . testClassPath = systemTestEnvironment . classpath + STR_ + classDir . toString ( ) ; }
public Application createJmxApplicationInteractive ( String connectionString , String displayName , EnvironmentProvider provider , boolean persistent ) { return createJmxApplicationInteractive ( connectionString , displayName , provider , persistent , BOOL_ ) ; }
public static synchronized void removeProvider ( int providerNumber ) { Provider p = providers . remove ( providerNumber - NUM_ ) ; providersNames . remove ( p . getName ( ) ) ; setNeedRefresh ( ) ; }
public Object referenceInsert ( String reference , Object value ) { String s = null ; if ( value != null ) { s = REFERENCE_VALUE ; } else { if ( reference . equals ( STR_ ) ) { s = NO_REFERENCE_VALUE ; } } return s ; }
public GraphicComponent ( GraphicAttribute graphic , Decoration decorator , int [ ] charsLtoV , byte [ ] levels , int start , int limit , AffineTransform baseTx ) { if ( limit <= start ) { throw new IllegalArgumentException ( STR_ ) ; } this . graphic = graphic ; this . graphicAdvance = graphic . getAdvance ( ) ; this . decorator = decorator ; this . cm = createCoreMetrics ( graphic ) ; this . baseTx = baseTx ; initLocalOrdering ( charsLtoV , levels , start , limit ) ; }
public static boolean hasValidUserInContext ( SecurityContext securityContext ) { if ( ( securityContext != null ) && ( securityContext . getUserPrincipal ( ) instanceof StorageOSUser ) ) { return BOOL_ ; } else { return BOOL_ ; } }
private void handleEndOfStream ( State state , InnerState innerState ) throws StopRequest { mInfo . mCurrentBytes = innerState . mBytesSoFar ; mDB . updateDownload ( mInfo ) ; boolean lengthMismatched = ( innerState . mHeaderContentLength != null ) && ( innerState . mBytesSoFar != Integer . parseInt ( innerState . mHeaderContentLength ) ) ; if ( lengthMismatched ) { if ( cannotResume ( innerState ) ) { throw new StopRequest ( DownloaderService . STATUS_CANNOT_RESUME , STR_ ) ; } else { throw new StopRequest ( getFinalStatusForHttpError ( state ) , STR_ ) ; } } }
public void add ( String keyword , byte id ) { int key = getStringMapKey ( keyword ) ; map [ key ] = new Keyword ( keyword . toCharArray ( ) , id , map [ key ] ) ; }
public String toString ( ) { return m_Formatter . format ( getStamp ( ) ) ; }
private String secondsToTime ( int seconds ) { String time = STR_ ; String minutesText = String . valueOf ( seconds / NUM_ ) ; if ( minutesText . length ( ) == NUM_ ) minutesText = STR_ + minutesText ; String secondsText = String . valueOf ( seconds % NUM_ ) ; if ( secondsText . length ( ) == NUM_ ) secondsText = STR_ + secondsText ; time = minutesText + STR_ + secondsText ; return time ; }
private void processNewPort ( DatapathId sw , OFPort p ) { if ( isLinkDiscoverySuppressed ( sw , p ) ) { return ; } IOFSwitch iofSwitch = switchService . getSwitch ( sw ) ; if ( iofSwitch == null ) { return ; } NodePortTuple npt = new NodePortTuple ( sw , p ) ; discover ( sw , p ) ; addToQuarantineQueue ( npt ) ; }
public AmqpReceiver ( AmqpSession session , String address , String receiverId ) { if ( address != null && address . isEmpty ( ) ) { throw new IllegalArgumentException ( STR_ ) ; } this . userSpecifiedSource = null ; this . session = session ; this . address = address ; this . receiverId = receiverId ; }
private void notifyServiceMap ( Object eventSource , long eventID , long seqNo , ServiceID sid , ServiceItem item , int transition ) { if ( eventSource == null ) return ; synchronized ( serviceIdMap ) { ProxyReg reg = null ; EventReg eReg = null ; Set set = eventRegMap . entrySet ( ) ; Iterator iter = set . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry e = ( Map . Entry ) iter . next ( ) ; eReg = ( EventReg ) e . getValue ( ) ; if ( eventSource . equals ( eReg . source ) && ( eventID == eReg . eventID ) ) { reg = ( ProxyReg ) e . getKey ( ) ; break ; } } if ( reg == null ) return ; long prevSeqNo = eReg . seqNo ; eReg . seqNo = seqNo ; CacheTask t ; if ( seqNo == ( prevSeqNo + NUM_ ) ) { t = new NotifyEventTask ( lookupCacheClassLoader , reg , sid , item , transition , taskSeqN ++ ) ; } else { t = new LookupTask ( lookupCacheClassLoader , reg , taskSeqN ++ ) ; if ( logger . isLoggable ( Levels . HANDLED ) ) { String msg = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; Object [ ] params = new Object [ ] { reg == null ? null : reg . proxy , item . service , sid , eventSource , new Long ( eventID ) , new Long ( prevSeqNo ) , new Long ( seqNo ) } ; logger . log ( Levels . HANDLED , msg , params ) ; } } cacheTaskMgr . add ( t ) ; } }
@ KnownFailure ( STR_ ) public void test_getColumnsTableWithNoCatalogSchema ( ) throws SQLException { try { ResultSet noSchemaTable = meta . getColumns ( STR_ , STR_ , DatabaseCreator . TEST_TABLE1 , STR_ ) ; assertNotNull ( noSchemaTable ) ; noSchemaTable . last ( ) ; int size = noSchemaTable . getRow ( ) ; assertEquals ( STR_ , NUM_ , size ) ; } catch ( SQLException e ) { fail ( STR_ + e . getMessage ( ) ) ; } try { ResultSet noSchemaTable = meta . getColumns ( STR_ , STR_ , DatabaseCreator . TEST_TABLE1 , STR_ ) ; assertNotNull ( noSchemaTable ) ; noSchemaTable . last ( ) ; int size = noSchemaTable . getRow ( ) ; assertEquals ( STR_ , NUM_ , size ) ; } catch ( SQLException e ) { fail ( STR_ + e . getMessage ( ) ) ; } try { ResultSet noSchemaTable = meta . getColumns ( STR_ , STR_ , STR_ , STR_ ) ; assertNotNull ( noSchemaTable ) ; noSchemaTable . last ( ) ; int size = noSchemaTable . getRow ( ) ; assertEquals ( STR_ , NUM_ , size ) ; } catch ( SQLException e ) { fail ( STR_ + e . getMessage ( ) ) ; } conn . close ( ) ; try { meta . getColumns ( null , null , DatabaseCreator . TEST_TABLE1 , STR_ ) ; fail ( STR_ ) ; } catch ( SQLException e ) { } }
public static byte readByte ( ) { return scanner . nextByte ( ) ; }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case NUM_ : return SUCCESS ; default : return null ; } }
public static void d ( String tag , String msg , Object ... args ) { if ( sLevel > LEVEL_DEBUG ) { return ; } if ( args . length > NUM_ ) { msg = String . format ( msg , args ) ; } Log . d ( tag , msg ) ; }
public void clearValueLocal ( String columnHeader ) { values . remove ( columnHeader . toLowerCase ( ) ) ; }
public List closeBucketAdvisors ( ) { List primariesHeld = Collections . EMPTY_LIST ; if ( this . buckets != null ) { for ( int i = NUM_ ; i < this . buckets . length ; i ++ ) { ProxyBucketRegion pbr = this . buckets [ i ] ; if ( pbr . isPrimary ( ) ) { if ( primariesHeld == Collections . EMPTY_LIST ) { primariesHeld = new ArrayList ( ) ; } primariesHeld . add ( Integer . valueOf ( i ) ) ; } pbr . close ( ) ; } } return primariesHeld ; }
public boolean isMacMuted ( final String mac ) { final long muteTill = getMacUnmuteTime ( mac ) ; return muteTill > System . currentTimeMillis ( ) ; }
public abstract void insertSpillBefore ( Instruction s , Register r , byte type , int location ) ;
static public Test suite ( ) { return ProxySuiteHelper . suiteWhenStandalone ( TestSparqlUpdate . class , STR_ , new LinkedHashSet < BufferMode > ( Arrays . asList ( new BufferMode [ ] { BufferMode . Transient , BufferMode . DiskWORM , BufferMode . MemStore , BufferMode . DiskRW } ) ) , TestMode . quads ) ; }
private synchronized void cleanupIsComplexTypeAttribute ( ) { firstAttribute = null ; remainingAttributes . clear ( ) ; isComplexTypeAttribute = BOOL_ ; }
public static String leftTrim ( final String value ) { validate ( value , NULL_STRING_PREDICATE , NULL_STRING_MSG_SUPPLIER ) ; return value . replaceAll ( STR_ , STR_ ) ; }
public float polarAngle ( ) { return ( float ) Math . toDegrees ( angle ( ) ) ; }
public String checkParamsNonNegative ( ) { String ret = STR_ ; if ( param1 < NUM_ ) { ret = ret . concat ( pdf . getParam1Name ( ) + STR_ ) ; } if ( param2 < NUM_ ) { ret = ret . concat ( pdf . getParam2Name ( ) + STR_ ) ; } if ( upperBound < NUM_ ) { ret = ret . concat ( STR_ ) ; } if ( lowerBound < NUM_ ) { ret = ret . concat ( STR_ ) ; } return ret ; }
public static boolean validate ( String str , String regEx , Debug tmpDebug ) { debug = tmpDebug ; if ( str == null || str . length ( ) == NUM_ ) { debug . message ( STR_ ) ; return BOOL_ ; } char [ ] value = str . toCharArray ( ) ; int count = value . length ; Set hSet = new HashSet ( ) ; StringTokenizer st = new StringTokenizer ( regEx , SEPERATOR ) ; while ( st . hasMoreTokens ( ) ) { hSet . add ( st . nextToken ( ) ) ; } Iterator itr = hSet . iterator ( ) ; while ( itr . hasNext ( ) ) { String obj = ( String ) itr . next ( ) ; if ( process ( value , obj , NUM_ , count ) > - NUM_ ) { debug . message ( STR_ ) ; return BOOL_ ; } } return BOOL_ ; }
public void addMapObject ( InternalMapObject mapObject ) { mapObjects . add ( mapObject ) ; }
public List < MockResponse > enqueue ( String ... paths ) { if ( paths == null ) { return null ; } List < MockResponse > mockResponseList = new ArrayList < > ( ) ; for ( String path : paths ) { Fixture fixture = Fixture . parseFrom ( path , parser ) ; MockResponse mockResponse = new MockResponse ( ) ; if ( fixture . statusCode != NUM_ ) { mockResponse . setResponseCode ( fixture . statusCode ) ; } if ( fixture . body != null ) { mockResponse . setBody ( fixture . body ) ; } if ( fixture . delay != NUM_ ) { mockWebServer . setDispatcher ( new DelayedDispatcher ( fixture . delay , TimeUnit . MILLISECONDS ) ) ; } if ( fixture . headers != null ) { for ( String header : fixture . headers ) { mockResponse . addHeader ( header ) ; } } mockWebServer . enqueue ( mockResponse ) ; mockResponseList . add ( mockResponse ) ; } return mockResponseList ; }
@ Override public void endOfStream ( ) throws AdeException { double minProb = NUM_ ; if ( m_totalIntervalCount == NUM_ ) { m_totalIntervalCount = NUM_ ; } for ( Entry < String , BernoulliScore . MsgData > entry : m_msgData . entrySet ( ) ) { final FullBernoulliMsgData data = ( FullBernoulliMsgData ) entry . getValue ( ) ; data . m_prob = ( ( double ) data . m_count + NUM_ ) / ( m_totalIntervalCount + NUM_ ) ; if ( data . m_prob < NUM_ || data . m_prob >= NUM_ ) { logger . info ( entry . getKey ( ) + STR_ + data . m_prob + STR_ + data . m_count + STR_ + m_totalIntervalCount + STR_ ) ; } if ( data . m_prob < minProb ) { minProb = data . m_prob ; } data . m_outOfClusterProb = ( ( double ) data . m_outOfClusterCount + NUM_ ) / ( m_totalIntervalCount + NUM_ ) ; if ( data . m_outOfClusterCount < minProb && data . m_outOfClusterCount > NUM_ ) { minProb = data . m_outOfClusterCount ; } } for ( BernoulliScore . MsgData dataSuper : m_msgData . values ( ) ) { final FullBernoulliMsgData data = ( FullBernoulliMsgData ) dataSuper ; final double probability = data . m_prob ; data . m_score = - Math . log ( probability ) ; if ( data . m_score > NUM_ ) { data . m_score = NUM_ ; } final double outOfContextProbability = data . m_outOfClusterProb ; data . m_outOfContextScore = - Math . log ( outOfContextProbability ) ; if ( data . m_outOfContextScore > NUM_ ) { data . m_outOfContextScore = NUM_ ; } } m_trained = BOOL_ ; }
public boolean hasNextKeyTyped ( ) { synchronized ( keyLock ) { return ! keysTyped . isEmpty ( ) ; } }
public void addOperator ( Variation operator ) { operators . add ( operator ) ; }
public R paramsToMultipartEntity ( boolean isrepeatable ) { try { mHttpEntity = createMultipartEntity ( isrepeatable ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return ( R ) this ; }
public boolean isAlertDefinitionCreated ( StatAlertDefinition alertDefinition ) { synchronized ( ALERT_DEFINITIONS ) { return ALERT_DEFINITIONS . containsKey ( Integer . valueOf ( alertDefinition . getId ( ) ) ) ; } }
public static double logpoissonPDFm1 ( double x_plus_1 , double lambda ) { if ( Double . isInfinite ( lambda ) ) { return Double . NEGATIVE_INFINITY ; } if ( x_plus_1 > NUM_ ) { return rawLogProbability ( x_plus_1 - NUM_ , lambda ) ; } if ( lambda > Math . abs ( x_plus_1 - NUM_ ) . MathUtil . LOG2 . Double . MAX_EXPONENT / NUM_ ) { return - lambda - GammaDistribution . logGamma ( x_plus_1 ) ; } else { return rawLogProbability ( x_plus_1 , lambda ) + Math . log ( x_plus_1 / lambda ) ; } }
public void checkAndNotify ( ) { for ( FileAlterationListener listener : listeners ) { listener . onStart ( this ) ; } File rootFile = rootEntry . getFile ( ) ; if ( rootFile . exists ( ) ) { checkAndNotify ( rootEntry , rootEntry . getChildren ( ) , listFiles ( rootFile ) ) ; } else if ( rootEntry . isExists ( ) ) { checkAndNotify ( rootEntry , rootEntry . getChildren ( ) , FileUtils . EMPTY_FILE_ARRAY ) ; } else { } for ( FileAlterationListener listener : listeners ) { listener . onStop ( this ) ; } }
private double allowableError ( int rank ) { int size = samples . size ( ) ; final double error = calculateError ( rank , size ) ; final double minError = size + NUM_ ; if ( error < minError ) { return error ; } return minError ; }
public RetryPolicy withMaxDuration ( long maxDuration , TimeUnit timeUnit ) { Assert . notNull ( timeUnit , STR_ ) ; Assert . state ( timeUnit . toNanos ( maxDuration ) > delay . toNanos ( ) , STR_ ) ; this . maxDuration = new Duration ( maxDuration , timeUnit ) ; return this ; }
private int measureShort ( int measureSpec ) { int result ; int specMode = MeasureSpec . getMode ( measureSpec ) ; int specSize = MeasureSpec . getSize ( measureSpec ) ; if ( specMode == MeasureSpec . EXACTLY ) { result = specSize ; } else { result = ( int ) ( NUM_ . mRadius + getPaddingTop ( ) + getPaddingBottom ( ) + NUM_ ) ; if ( specMode == MeasureSpec . AT_MOST ) { result = Math . min ( result , specSize ) ; } } return result ; }
private static final void cleanupNamespaceNodes ( ZooKeeper zkc , String root , String selfBrokerUrl ) throws Exception { for ( String node : zkc . getChildren ( root , BOOL_ ) ) { String currentPath = root + STR_ + node ; List < String > children = zkc . getChildren ( currentPath , BOOL_ ) ; if ( children . size ( ) == NUM_ ) { cleanupSingleNamespaceNode ( zkc , currentPath , selfBrokerUrl ) ; } else { cleanupNamespaceNodes ( zkc , currentPath , selfBrokerUrl ) ; } } }
String validateLogixReference ( String name ) { Logix l = null ; if ( name != null ) { if ( name . length ( ) > NUM_ ) { l = _logixManager . getByUserName ( name ) ; if ( l != null ) { return name ; } } l = _logixManager . getBySystemName ( name ) ; } if ( l == null ) { messageInvalidActionItemName ( name , STR_ ) ; return null ; } return name ; }
protected void clearMenuSelection ( ) { popupMenuGroup . clearSelection ( ) ; updateSelectionStatus ( ) ; }
public double distance ( LatLng ll ) { double er = NUM_ ; double latFrom = Math . toRadians ( getLat ( ) ) ; double latTo = Math . toRadians ( ll . getLat ( ) ) ; double lngFrom = Math . toRadians ( getLng ( ) ) ; double lngTo = Math . toRadians ( ll . getLng ( ) ) ; double d = Math . acos ( Math . sin ( latFrom ) . Math . sin ( latTo ) + Math . cos ( latFrom ) . Math . cos ( latTo ) . Math . cos ( lngTo - lngFrom ) ) . er ; return d ; }
@ Override public Integer [ ] applyControlsToImpact ( int riskType , CnATreeElement asset , Integer impactC , Integer impactI , Integer impactA ) { if ( riskType == RISK_PRE_CONTROLS ) { return null ; } asset = Retriever . checkRetrieveLinks ( asset , BOOL_ ) ; Map < CnATreeElement , CnALink > linkedElements = CnALink . getLinkedElements ( asset , Control . TYPE_ID ) ; Integer impactC0 = Integer . valueOf ( impactC . intValue ( ) ) ; Integer impactI0 = Integer . valueOf ( impactI . intValue ( ) ) ; Integer impactA0 = Integer . valueOf ( impactA . intValue ( ) ) ; switch ( riskType ) { case RISK_WITH_IMPLEMENTED_CONTROLS : for ( CnATreeElement control : linkedElements . keySet ( ) ) { control = Retriever . checkRetrieveElement ( control ) ; if ( Control . isImplemented ( control . getEntity ( ) ) ) { impactC0 -= control . getNumericProperty ( IRiskAnalysisService . PROP_CONTROL_EFFECT_C ) ; impactI0 -= control . getNumericProperty ( IRiskAnalysisService . PROP_CONTROL_EFFECT_I ) ; impactA0 -= control . getNumericProperty ( IRiskAnalysisService . PROP_CONTROL_EFFECT_A ) ; } } break ; case RISK_WITH_ALL_CONTROLS : for ( CnATreeElement control : linkedElements . keySet ( ) ) { control = Retriever . checkRetrieveElement ( control ) ; impactC0 -= control . getNumericProperty ( IRiskAnalysisService . PROP_CONTROL_EFFECT_C ) ; impactI0 -= control . getNumericProperty ( IRiskAnalysisService . PROP_CONTROL_EFFECT_I ) ; impactA0 -= control . getNumericProperty ( IRiskAnalysisService . PROP_CONTROL_EFFECT_A ) ; } break ; case RISK_WITHOUT_NA_CONTROLS : for ( CnATreeElement control : linkedElements . keySet ( ) ) { control = Retriever . checkRetrieveElement ( control ) ; if ( Control . isPlanned ( control . getEntity ( ) ) ) { impactC0 -= control . getNumericProperty ( IRiskAnalysisService . PROP_CONTROL_EFFECT_C ) ; impactI0 -= control . getNumericProperty ( IRiskAnalysisService . PROP_CONTROL_EFFECT_I ) ; impactA0 -= control . getNumericProperty ( IRiskAnalysisService . PROP_CONTROL_EFFECT_A ) ; } } break ; default : break ; } impactC0 = ( impactC0 . intValue ( ) < NUM_ ) ? Integer . valueOf ( NUM_ ) : impactC0 ; impactI0 = ( impactI0 . intValue ( ) < NUM_ ) ? Integer . valueOf ( NUM_ ) : impactI0 ; impactA0 = ( impactA0 . intValue ( ) < NUM_ ) ? Integer . valueOf ( NUM_ ) : impactA0 ; return new Integer [ ] { impactC0 , impactI0 , impactA0 } ; }
public static String encode ( String encode ) { StringBuilder str = new StringBuilder ( encode ) ; String key ; int i = NUM_ ; while ( i < str . length ( ) ) { key = findValue ( str . charAt ( i ) ) ; if ( key != null ) { str . replace ( i , i + NUM_ , key ) ; i += key . length ( ) ; } else { i ++ ; } } return str . toString ( ) ; }
protected static Boolean tryToLock ( String serviceName ) { DistributedLockService service = DistributedLockService . getServiceNamed ( serviceName ) ; boolean locked = service . lock ( STR_ , NUM_ , - NUM_ ) ; if ( locked ) { service . unlock ( STR_ ) ; } return Boolean . valueOf ( locked ) ; }
public int hashCode ( ) { LatLonPoint llp = getLocation ( ) ; int hc1 = Float . floatToIntBits ( llp . getLatitude ( ) ) ; int hc2 = Float . floatToIntBits ( llp . getLongitude ( ) ) ; return hc1 ^ ( hc2 << NUM_ ) ^ ( hc2 > > > NUM_ ) ; }
private XPathFactory loadFromServicesFile ( String uri , String resourceName , InputStream in ) { if ( debug ) debugPrintln ( STR_ + resourceName ) ; BufferedReader rd ; try { rd = new BufferedReader ( new InputStreamReader ( in , STR_ ) , DEFAULT_LINE_LENGTH ) ; } catch ( java . io . UnsupportedEncodingException e ) { rd = new BufferedReader ( new InputStreamReader ( in ) , DEFAULT_LINE_LENGTH ) ; } String factoryClassName ; XPathFactory resultFactory = null ; while ( BOOL_ ) { try { factoryClassName = rd . readLine ( ) ; } catch ( IOException x ) { break ; } if ( factoryClassName != null ) { int hashIndex = factoryClassName . indexOf ( STR_ ) ; if ( hashIndex != - NUM_ ) { factoryClassName = factoryClassName . substring ( NUM_ , hashIndex ) ; } factoryClassName = factoryClassName . trim ( ) ; if ( factoryClassName . length ( ) == NUM_ ) { continue ; } try { XPathFactory foundFactory = createInstance ( factoryClassName ) ; if ( foundFactory . isObjectModelSupported ( uri ) ) { resultFactory = foundFactory ; break ; } } catch ( Exception ignored ) { } } else { break ; } } IoUtils . closeQuietly ( rd ) ; return resultFactory ; }
private synchronized void _stop ( ) { while ( m_activities . size ( ) > NUM_ ) { Activity a = ( Activity ) m_activities . get ( m_activities . size ( ) - NUM_ ) ; a . cancel ( ) ; } _setRunning ( BOOL_ ) ; notify ( ) ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; String childData ; int childLength ; java . util . List result = new java . util . ArrayList ( ) ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; nameNode = elementList . item ( NUM_ ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; child . deleteData ( NUM_ , NUM_ ) ; childData = child . getData ( ) ; assertEquals ( STR_ , STR_ , childData ) ; childLength = ( int ) child . getLength ( ) ; assertEquals ( STR_ , NUM_ , childLength ) ; }
public RhythmGroup makeGroup ( String title ) { final RhythmGroup group = new RhythmGroup ( ) ; group . mTitle = title ; group . mIndex = mRhythmGroups . size ( ) ; group . mControl = this ; mRhythmGroups . add ( group ) ; if ( mCurrentNotificationGroupIndex == NOTIFICATION_NO_GROUPS ) { mCurrentNotificationGroupIndex = NUM_ ; requestNotificationUpdate ( ) ; } return group ; }
public CharSequence subSequence ( int start , int end ) { return substring ( start , end ) ; }
public void testMultiplyMathContextDiffScalePosNeg ( ) { String a = STR_ ; int aScale = NUM_ ; String b = STR_ ; int bScale = - NUM_ ; String c = STR_ ; int cScale = - NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal bNumber = new BigDecimal ( new BigInteger ( b ) , bScale ) ; MathContext mc = new MathContext ( NUM_ , RoundingMode . HALF_UP ) ; BigDecimal result = aNumber . multiply ( bNumber , mc ) ; assertEquals ( STR_ , c , result . toString ( ) ) ; assertEquals ( STR_ , cScale , result . scale ( ) ) ; }
public void writeTo ( final OutputStream out ) throws IOException { for ( final Block block : blocks ) { out . write ( block . data , NUM_ , block . limit ) ; } }
public void testMergeOneServletIntoDocumentWithSameServletAndParam ( ) throws Exception { String srcXml = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; WebXml srcWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( srcXml . getBytes ( STR_ ) ) , null ) ; String mergeXml = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; WebXml mergeWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( mergeXml . getBytes ( STR_ ) ) , null ) ; WebXmlMerger merger = new WebXmlMerger ( srcWebXml ) ; merger . merge ( mergeWebXml ) ; assertTrue ( WebXmlUtils . hasServlet ( srcWebXml , STR_ ) ) ; List < String > initParams = WebXmlUtils . getServletInitParamNames ( srcWebXml , STR_ ) ; assertEquals ( NUM_ , initParams . size ( ) ) ; assertEquals ( STR_ , initParams . get ( NUM_ ) ) ; assertEquals ( STR_ , WebXmlUtils . getServletInitParam ( srcWebXml , STR_ , STR_ ) ) ; }
public KMP ( String pat ) { this . R = NUM_ ; this . pat = pat ; int m = pat . length ( ) ; dfa = new int [ R ] [ m ] ; dfa [ pat . charAt ( NUM_ ) ] [ NUM_ ] = NUM_ ; for ( int x = NUM_ , j = NUM_ ; j < m ; j ++ ) { for ( int c = NUM_ ; c < R ; c ++ ) dfa [ c ] [ j ] = dfa [ c ] [ x ] ; dfa [ pat . charAt ( j ) ] [ j ] = j + NUM_ ; x = dfa [ pat . charAt ( j ) ] [ x ] ; } }
private void loadConfiguration ( ) { mClientId = mConfigurationManager . getString ( PREF_CLIENT_ID , STR_ ) ; mClientKey = mConfigurationManager . getString ( PREF_CLIENT_KEY , STR_ ) ; Timber . i ( STR_ ) ; }
public static void putBooleanField ( Object obj , long fieldOff , boolean val ) { UNSAFE . putBoolean ( obj , fieldOff , val ) ; }
public void sort ( Comparator < File > comparator ) { synchronized ( mLock ) { Collections . sort ( fileList , comparator ) ; } notifyDataSetChanged ( ) ; }
public AcceptRequestInterceptor ( final String accept ) { this . accept = accept ; checkArgument ( ! accept . isEmpty ( ) , STR_ ) ; }
public void test_getLowestSetBitNeg ( ) { byte aBytes [ ] = { - NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; int aSign = - NUM_ ; int iNumber = NUM_ ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; int result = aNumber . getLowestSetBit ( ) ; assertTrue ( STR_ , result == iNumber ) ; }
private int tailingNonNewline ( String str , int off , int len ) { for ( int cnt = NUM_ ; cnt < len ; cnt ++ ) { final int pos = off + ( len - NUM_ ) - cnt ; if ( str . charAt ( pos ) == UNIX_NEWLINE ) { return cnt ; } if ( str . charAt ( pos ) == CARRIAGE_RETURN ) { return cnt ; } } return len ; }
@ Override public void reset ( ) { _clear ( ) ; bnodes = null ; bnodesTotalCount = NUM_ ; bnodesResolvedCount = NUM_ ; deferredStmts = null ; reifiedStmts = null ; if ( queue != null ) { final Future < Void > ft = this . ft ; if ( ft != null ) { ft . cancel ( BOOL_ ) ; this . ft = null ; } queue . clear ( ) ; } }
public static byte [ ] readData ( final InputStream input ) throws IOException { final byte [ ] inputBuffer = new byte [ BUFFER_LENGTH ] ; final ByteArrayOutputStream byteOutput = new ByteArrayOutputStream ( BUFFER_LENGTH ) ; int bytesRead ; while ( ( bytesRead = input . read ( inputBuffer ) ) != - NUM_ ) { byteOutput . write ( inputBuffer , NUM_ , bytesRead ) ; } final byte [ ] r = byteOutput . toByteArray ( ) ; byteOutput . close ( ) ; return r ; }
public static String makeLogTag ( Class cls ) { return makeLogTag ( cls . getSimpleName ( ) ) ; }
@ Override public synchronized void println ( ) { print ( STR_ ) ; }
public boolean isCrash ( String testPath ) { for ( String prefix : getPrefixes ( testPath ) ) { if ( mCrashList . contains ( prefix ) ) { return BOOL_ ; } } return BOOL_ ; }
public AbstractSiteMap parseSiteMap ( String contentType , byte [ ] content , URL url ) throws UnknownFormatException , IOException { MediaType mediaType = MediaType . parse ( contentType ) ; while ( mediaType != null && ! mediaType . equals ( MediaType . OCTET_STREAM ) ) { if ( XML_MEDIA_TYPES . contains ( mediaType ) ) { return processXml ( url , content ) ; } else if ( TEXT_MEDIA_TYPES . contains ( mediaType ) ) { return processText ( url . toString ( ) , content ) ; } else if ( GZ_MEDIA_TYPES . contains ( mediaType ) ) { return processGzip ( url , content ) ; } else { mediaType = MEDIA_TYPE_REGISTRY . getSupertype ( mediaType ) ; return parseSiteMap ( mediaType . toString ( ) , content , url ) ; } } throw new UnknownFormatException ( STR_ + contentType + STR_ + url + STR_ ) ; }
private void createDefaultManagedObject ( ManagedObjectDefinition < ? , ? > d , ManagedObject < ? > child , DefaultManagedObject < ? , ? > dmo ) { for ( PropertyDefinition < ? > pd : d . getAllPropertyDefinitions ( ) ) { setPropertyValues ( child , pd , dmo ) ; } try { child . commit ( ) ; } catch ( ManagedObjectAlreadyExistsException e ) { moaee = e ; } catch ( MissingMandatoryPropertiesException e ) { mmpe = e ; } catch ( ConcurrentModificationException e ) { cme = e ; } catch ( OperationRejectedException e ) { ore = e ; } catch ( LdapException e ) { ere = e ; } }
static String omitQuotesIfExist ( String str ) { if ( str == null ) { return null ; } if ( ( ( str . charAt ( NUM_ ) == STR_ ) || ( str . charAt ( NUM_ ) == STR_ ) ) && ( str . length ( ) >= NUM_ ) ) { str = str . substring ( NUM_ , str . length ( ) - NUM_ ) ; } return str ; }
public static byte [ ] decode ( byte [ ] input , int offset , int len , int flags ) { Decoder decoder = new Decoder ( flags , new byte [ len . NUM_ / NUM_ ] ) ; if ( ! decoder . process ( input , offset , len , BOOL_ ) ) { throw new IllegalArgumentException ( STR_ ) ; } if ( decoder . op == decoder . output . length ) { return decoder . output ; } byte [ ] temp = new byte [ decoder . op ] ; System . arraycopy ( decoder . output , NUM_ , temp , NUM_ , decoder . op ) ; return temp ; }
private static boolean canCompleteNodePath ( Entity start , Entity end , ArrayList < Entity > network , int startPosition , List < ECMInfo > allECMInfo ) { Entity spotter = network . get ( startPosition ) ; ECMInfo spotterStartECM = ComputeECM . getECMEffects ( spotter , start . getPosition ( ) , spotter . getPosition ( ) , BOOL_ , allECMInfo ) ; boolean isC3BDefeated = start . hasBoostedC3 ( ) && ( spotterStartECM != null ) && spotterStartECM . isAngelECM ( ) ; boolean isNovaDefeated = start . hasNovaCEWS ( ) && ( spotterStartECM != null ) && spotterStartECM . isNovaECM ( ) ; boolean isC3Defeated = ! ( start . hasBoostedC3 ( ) || start . hasNovaCEWS ( ) ) && ( spotterStartECM != null ) && spotterStartECM . isECM ( ) ; if ( isC3BDefeated || isNovaDefeated || isC3Defeated ) { return BOOL_ ; } ECMInfo spotterEndECM = ComputeECM . getECMEffects ( spotter , spotter . getPosition ( ) , end . getPosition ( ) , BOOL_ , allECMInfo ) ; isC3BDefeated = start . hasBoostedC3 ( ) && ( spotterEndECM != null ) && spotterEndECM . isAngelECM ( ) ; isNovaDefeated = start . hasNovaCEWS ( ) && ( spotterEndECM != null ) && spotterEndECM . isNovaECM ( ) ; isC3Defeated = ! ( start . hasBoostedC3 ( ) || start . hasNovaCEWS ( ) ) && ( spotterEndECM != null ) && spotterEndECM . isECM ( ) ; if ( ! ( isC3BDefeated || isNovaDefeated || isC3Defeated ) ) { return BOOL_ ; } for ( ++ startPosition ; startPosition < network . size ( ) ; startPosition ++ ) { if ( Compute . canCompleteNodePath ( spotter , end , network , startPosition , allECMInfo ) ) { return BOOL_ ; } } return BOOL_ ; }
static void make72Safe ( StringBuffer line ) { int length = line . length ( ) ; if ( length > NUM_ ) { int index = NUM_ ; while ( index < length - NUM_ ) { line . insert ( index , STR_ ) ; index += NUM_ ; length += NUM_ ; } } return ; }
@ Override public int last ( ) { CharacterIterator t = getText ( ) ; t . setIndex ( t . getEndIndex ( ) ) ; return t . getIndex ( ) ; }
public static IStatus validateMethodName ( String name ) { return validateMethodName ( name , CompilerOptions . VERSION_1_3 , CompilerOptions . VERSION_1_3 ) ; }
public static void registerProtocol ( final String id , final Protocol protocol ) { if ( id == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( protocol == null ) { throw new IllegalArgumentException ( STR_ ) ; } PROTOCOLS . put ( id , protocol ) ; }
public byte receiveOneByte ( ) { Log . d ( TAG , STR_ ) ; try { acquireLock ( ) ; mServerSocket . receive ( mReceivePacket ) ; Log . d ( TAG , STR_ + ( NUM_ + mReceivePacket . getData ( ) [ NUM_ ] ) ) ; return mReceivePacket . getData ( ) [ NUM_ ] ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return Byte . MIN_VALUE ; }
public static String linkHTML ( String text ) { if ( text == null || text . length ( ) == NUM_ ) { return STR_ ; } boolean http = text . indexOf ( STR_ ) != - NUM_ ; boolean www = text . indexOf ( STR_ ) != - NUM_ ; boolean email = text . indexOf ( STR_ ) != - NUM_ ; if ( ! http && ! www && ! email ) { return text ; } if ( text . indexOf ( STR_ ) != - NUM_ && text . indexOf ( STR_ ) != - NUM_ ) { return text ; } if ( http ) { Matcher matcher = httpRegex . matcher ( text ) ; StringBuffer sb = new StringBuffer ( ) ; while ( matcher . find ( ) ) { String url = matcher . group ( ) ; if ( url . indexOf ( STR_ ) != - NUM_ || url . indexOf ( STR_ ) != - NUM_ || url . indexOf ( STR_ ) != - NUM_ || url . indexOf ( STR_ ) != - NUM_ ) { url = STR_ + url + STR_ + url + STR_ ; } else if ( url . indexOf ( STR_ ) != - NUM_ || url . indexOf ( STR_ ) != - NUM_ || url . indexOf ( STR_ ) != - NUM_ ) { url = STR_ + url + STR_ + url + STR_ ; } else if ( url . indexOf ( STR_ ) != - NUM_ || url . indexOf ( STR_ ) != - NUM_ ) { url = STR_ + url + STR_ + url + STR_ ; } else { url = STR_ + url + STR_ + url + STR_ ; } matcher . appendReplacement ( sb , url ) ; } matcher . appendTail ( sb ) ; text = sb . toString ( ) ; } else if ( www ) { Matcher matcher = wwwRegex . matcher ( text ) ; StringBuffer sb = new StringBuffer ( ) ; while ( matcher . find ( ) ) { String url = matcher . group ( ) ; matcher . appendReplacement ( sb , STR_ + url + STR_ + url + STR_ ) ; } matcher . appendTail ( sb ) ; text = sb . toString ( ) ; } if ( email ) { Matcher matcher = emailRegex . matcher ( text ) ; StringBuffer sb = new StringBuffer ( ) ; while ( matcher . find ( ) ) { String address = matcher . group ( ) ; matcher . appendReplacement ( sb , STR_ + address + STR_ + address + STR_ ) ; } matcher . appendTail ( sb ) ; text = sb . toString ( ) ; } return text ; }
public static int hash ( String key , int bitSize , String input , String hashType ) { int bitLimitedHash ; try { MessageDigest md = MessageDigest . getInstance ( hashType ) ; byte [ ] array = md . digest ( input . getBytes ( ) ) ; int hashInt = fromByteArray ( array ) ; bitLimitedHash = hashInt ; if ( bitSize < NUM_ ) { bitLimitedHash = ( xFFFFFFFF > > > ( NUM_ - bitSize ) ) & hashInt ; } logger . debug ( STR_ + hashInt + STR_ + bitLimitedHash ) ; } catch ( NoSuchAlgorithmException e ) { logger . info ( e . toString ( ) ) ; bitLimitedHash = hash ( key , bitSize , input ) ; } return bitLimitedHash ; }
private OFFactory computeInitialFactory ( Set < OFVersion > ofVersions ) { if ( ofVersions == null || ofVersions . isEmpty ( ) ) { throw new IllegalStateException ( STR_ ) ; } OFVersion highest = null ; for ( OFVersion v : ofVersions ) { if ( highest == null ) { highest = v ; } else if ( v . compareTo ( highest ) > NUM_ ) { highest = v ; } } return OFFactories . getFactory ( highest ) ; }
private void loadJettyConfiguration ( @ Nullable URL cfgUrl ) throws IgniteCheckedException { if ( cfgUrl == null ) { HttpConfiguration httpCfg = new HttpConfiguration ( ) ; httpCfg . setSecureScheme ( STR_ ) ; httpCfg . setSecurePort ( NUM_ ) ; httpCfg . setSendServerVersion ( BOOL_ ) ; httpCfg . setSendDateHeader ( BOOL_ ) ; String srvPortStr = System . getProperty ( IGNITE_JETTY_PORT , STR_ ) ; int srvPort ; try { srvPort = Integer . parseInt ( srvPortStr ) ; } catch ( NumberFormatException ignore ) { throw new IgniteCheckedException ( STR_ + STR_ + srvPortStr ) ; } httpSrv = new Server ( new QueuedThreadPool ( NUM_ , NUM_ ) ) ; ServerConnector srvConn = new ServerConnector ( httpSrv , new HttpConnectionFactory ( httpCfg ) ) ; srvConn . setHost ( System . getProperty ( IGNITE_JETTY_HOST , STR_ ) ) ; srvConn . setPort ( srvPort ) ; srvConn . setIdleTimeout ( NUM_ ) ; srvConn . setReuseAddress ( BOOL_ ) ; httpSrv . addConnector ( srvConn ) ; httpSrv . setStopAtShutdown ( BOOL_ ) ; } else { XmlConfiguration cfg ; try { cfg = new XmlConfiguration ( cfgUrl ) ; } catch ( FileNotFoundException e ) { throw new IgniteSpiException ( STR_ + cfgUrl , e ) ; } catch ( SAXException e ) { throw new IgniteSpiException ( STR_ + cfgUrl , e ) ; } catch ( IOException e ) { throw new IgniteSpiException ( STR_ + cfgUrl , e ) ; } catch ( Exception e ) { throw new IgniteSpiException ( STR_ + cfgUrl , e ) ; } try { httpSrv = ( Server ) cfg . configure ( ) ; } catch ( Exception e ) { throw new IgniteCheckedException ( STR_ , e ) ; } } assert httpSrv != null ; httpSrv . setHandler ( jettyHnd ) ; override ( getJettyConnector ( ) ) ; }
public byte [ ] encodeFrame ( ) { int length = this . payload . length + frameLengthOverhead ; if ( this . payload . length > NUM_ ) { length += NUM_ ; } else if ( this . payload . length >= NUM_ ) { length += NUM_ ; } ByteBuffer buffer = ByteBuffer . allocate ( length ) ; appendFinAndOpCode ( buffer , this . opcode , this . fin ) ; byte mask [ ] = generateMaskingKey ( ) ; appendLengthAndMask ( buffer , this . payload . length , mask ) ; for ( int i = NUM_ ; i < this . payload . length ; i ++ ) { buffer . put ( ( byte ) ( this . payload [ i ] ^= mask [ i % NUM_ ] ) ) ; } buffer . flip ( ) ; return buffer . array ( ) ; }
public static void preloadIcon ( Context context , ComponentName componentName , Bitmap icon , int dpi ) { try { PackageManager packageManager = context . getPackageManager ( ) ; packageManager . getActivityIcon ( componentName ) ; return ; } catch ( PackageManager . NameNotFoundException e ) { } final String key = componentName . flattenToString ( ) ; FileOutputStream resourceFile = null ; try { resourceFile = context . openFileOutput ( getResourceFilename ( componentName ) , Context . MODE_PRIVATE ) ; ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; if ( icon . compress ( android . graphics . Bitmap . CompressFormat . PNG , NUM_ , os ) ) { byte [ ] buffer = os . toByteArray ( ) ; resourceFile . write ( buffer , NUM_ , buffer . length ) ; } else { Log . w ( TAG , STR_ + key ) ; return ; } } catch ( FileNotFoundException e ) { Log . w ( TAG , STR_ + key , e ) ; } catch ( IOException e ) { Log . w ( TAG , STR_ + key , e ) ; } finally { if ( resourceFile != null ) { try { resourceFile . close ( ) ; } catch ( IOException e ) { Log . d ( TAG , STR_ + key , e ) ; } } } }
public void normalize ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( String v : values ) { sb . append ( v ) ; } values . clear ( ) ; values . add ( sb . toString ( ) ) ; compacted = BOOL_ ; }
public void addAttribute ( String key , String value ) { extraSessionAttributes . put ( key , value ) ; }
String capitalise ( final String s ) { if ( s . length ( ) == NUM_ ) { return s ; } final StringBuffer s1 = new StringBuffer ( s ) ; if ( Character . isLowerCase ( s1 . charAt ( NUM_ ) ) ) { s1 . setCharAt ( NUM_ , Character . toUpperCase ( s1 . charAt ( NUM_ ) ) ) ; } for ( int j = NUM_ ; j < s1 . length ( ) ; j ++ ) { if ( Character . isUpperCase ( s1 . charAt ( j ) ) ) { s1 . setCharAt ( j , Character . toLowerCase ( s1 . charAt ( j ) ) ) ; } } return s1 . toString ( ) ; }
public void recompose ( Vector recomposableElements ) throws TransformerException { int n = getIncludeCountComposed ( ) ; for ( int i = - NUM_ ; i < n ; i ++ ) { Stylesheet included = getIncludeComposed ( i ) ; int s = included . getOutputCount ( ) ; for ( int j = NUM_ ; j < s ; j ++ ) { recomposableElements . addElement ( included . getOutput ( j ) ) ; } s = included . getAttributeSetCount ( ) ; for ( int j = NUM_ ; j < s ; j ++ ) { recomposableElements . addElement ( included . getAttributeSet ( j ) ) ; } s = included . getDecimalFormatCount ( ) ; for ( int j = NUM_ ; j < s ; j ++ ) { recomposableElements . addElement ( included . getDecimalFormat ( j ) ) ; } s = included . getKeyCount ( ) ; for ( int j = NUM_ ; j < s ; j ++ ) { recomposableElements . addElement ( included . getKey ( j ) ) ; } s = included . getNamespaceAliasCount ( ) ; for ( int j = NUM_ ; j < s ; j ++ ) { recomposableElements . addElement ( included . getNamespaceAlias ( j ) ) ; } s = included . getTemplateCount ( ) ; for ( int j = NUM_ ; j < s ; j ++ ) { recomposableElements . addElement ( included . getTemplate ( j ) ) ; } s = included . getVariableOrParamCount ( ) ; for ( int j = NUM_ ; j < s ; j ++ ) { recomposableElements . addElement ( included . getVariableOrParam ( j ) ) ; } s = included . getStripSpaceCount ( ) ; for ( int j = NUM_ ; j < s ; j ++ ) { recomposableElements . addElement ( included . getStripSpace ( j ) ) ; } s = included . getPreserveSpaceCount ( ) ; for ( int j = NUM_ ; j < s ; j ++ ) { recomposableElements . addElement ( included . getPreserveSpace ( j ) ) ; } } }
private Geometry unionActual ( Geometry g0 , Geometry g1 ) { return restrictToPolygons ( g0 . union ( g1 ) ) ; }
public boolean supports ( @ MagicConstant ( flagsFromClass = Features . class ) int capability ) { IAndroidTarget target = getTarget ( ) ; if ( target != null ) { return RenderService . supportsCapability ( getModule ( ) , target , capability ) ; } return BOOL_ ; }
@ Override public void transactionAborted ( ) { if ( listeners . isEmpty ( ) ) { records . reset ( ) ; } else { records . flush ( ) ; listeners . forEach ( null ) ; } }
@ Override public boolean add ( E o ) { if ( null == o ) { throw new NullPointerException ( ) ; } if ( offer ( o ) ) { return BOOL_ ; } throw new IllegalStateException ( ) ; }
public StandardCrosshairLabelGenerator ( ) { this ( STR_ , NumberFormat . getNumberInstance ( ) ) ; }
private URI createEthernetStoragePort ( Map < String , Object > keyMap , StoragePort port , String name , String portInstanceID , List < StoragePort > newPorts , List < StoragePort > existingPorts ) throws IOException { StoragePort portinMemory = ( StoragePort ) keyMap . get ( portInstanceID ) ; if ( null == port ) { portinMemory . setPortNetworkId ( name ) ; portinMemory . setPortEndPointID ( name ) ; String portNativeGuid = NativeGUIDGenerator . generateNativeGuid ( _dbClient , portinMemory ) ; portinMemory . setNativeGuid ( portNativeGuid ) ; portinMemory . setLabel ( portNativeGuid ) ; _dbClient . createObject ( portinMemory ) ; newPorts . add ( portinMemory ) ; return portinMemory . getId ( ) ; } else { port . setPortName ( portinMemory . getPortName ( ) ) ; port . setPortSpeed ( portinMemory . getPortSpeed ( ) ) ; port . setPortEndPointID ( name ) ; port . setCompatibilityStatus ( portinMemory . getCompatibilityStatus ( ) ) ; port . setDiscoveryStatus ( portinMemory . getDiscoveryStatus ( ) ) ; port . setOperationalStatus ( portinMemory . getOperationalStatus ( ) ) ; port . setPortType ( portinMemory . getPortType ( ) ) ; _dbClient . persistObject ( port ) ; existingPorts . add ( port ) ; return port . getId ( ) ; } }
default int add ( Item stack ) { int itemsLeft = stack . count ( ) ; for ( int i = NUM_ ; i < size ( ) ; i ++ ) { itemsLeft = add ( i , stack . withAmount ( itemsLeft ) ) ; } if ( itemsLeft != stack . count ( ) ) { markChanged ( ) ; } return itemsLeft ; }
public void mark ( long n ) { count . addAndGet ( n ) ; m1Rate . update ( n ) ; m5Rate . update ( n ) ; m15Rate . update ( n ) ; }
public String [ ] readAllLines ( ) { ArrayList < String > lines = new ArrayList < String > ( ) ; while ( hasNextLine ( ) ) { lines . add ( readLine ( ) ) ; } return lines . toArray ( new String [ NUM_ ] ) ; }
public static boolean isAbsolutePath ( String systemId ) { if ( systemId == null ) return BOOL_ ; final File file = new File ( systemId ) ; return file . isAbsolute ( ) ; }
protected QualifiedItem [ ] parseQualifiedItems ( final VersionSpec defaultVersion , final boolean allowVersionRange , final int startIndex ) { return parseQualifiedItems ( getFreeArguments ( ) , defaultVersion , allowVersionRange , startIndex ) ; }
public void changeChangeEnabled ( ChangeEnabledState state ) throws RefactoringException { RefactoringSession session = getRefactoringSession ( state . getSessionId ( ) ) ; session . updateChangeEnabled ( state . getChangeId ( ) , state . isEnabled ( ) ) ; }
public UpdateBuilder bindUris ( String from , Collection < String > uris ) { return bindUris ( from , uris , STR_ ) ; }
public void populateAll ( ) throws GeneralException { for ( ServiceEcaAction ecaAction : serviceEcaRule . getEcaActionList ( ) ) { servicesCalledByThisServiceEca . add ( aif . getServiceArtifactInfo ( ecaAction . getServiceName ( ) ) ) ; UtilMisc . addToSortedSetInMap ( this , aif . allServiceEcaInfosReferringToServiceName , ecaAction . getServiceName ( ) ) ; } }
public void validationStatesRemoved ( K key ) { hideMessage ( key ) ; validationErrorStates . remove ( key ) ; notifyUpstream ( key , Collections . < ValidationState > emptySet ( ) ) ; }
public void killApplication ( String applicationId ) throws IOException , YarnException { log . info ( STR_ + applicationId ) ; yarnClient . killApplication ( getApplicationIDFromString ( applicationId ) ) ; }
public static String convert ( String prefix ) { StringBuilder sb = new StringBuilder ( ) ; prefix = prefix . replace ( STR_ , STR_ ) ; String [ ] lines = prefix . split ( STR_ ) ; for ( String line : lines ) { List < String > tokens = new ArrayList < String > ( ) ; char [ ] c = UnsafeString . getChars ( line ) ; int lastidx = NUM_ ; int idx = NUM_ ; while ( idx < c . length ) { while ( c [ idx ] != STR_ && c [ idx ] != STR_ && c [ idx ] != STR_ ) { idx ++ ; } if ( idx != lastidx ) { tokens . add ( new String ( c , lastidx , idx - lastidx ) ) ; } idx ++ ; lastidx = idx ; } Collections . reverse ( tokens ) ; for ( String token : tokens ) { sb . append ( token ) ; sb . append ( STR_ ) ; } } return sb . toString ( ) ; }
public boolean toBoolean ( Element el , String attributeName , boolean defaultValue ) { String value = el . getAttribute ( attributeName ) ; if ( value == null ) return defaultValue ; return Caster . toBooleanValue ( value , BOOL_ ) ; }
public synchronized void addPanListener ( PanListener listener ) { mPanListeners . add ( listener ) ; }
protected void serializePreRoot ( ) throws IOException { int i ; if ( _preRoot != null ) { for ( i = NUM_ ; i < _preRoot . size ( ) ; ++ i ) { printText ( ( String ) _preRoot . elementAt ( i ) , BOOL_ , BOOL_ ) ; if ( _indenting ) _printer . breakLine ( ) ; } _preRoot . removeAllElements ( ) ; } }
private void createSchemaColumnEntities ( List < SchemaColumn > schemaColumns , boolean isPartitionList , Collection < SchemaColumnEntity > schemaColumnEntityList , Map < String , SchemaColumnEntity > schemaColumnEntityMap , BusinessObjectFormatEntity businessObjectFormatEntity ) { if ( ! CollectionUtils . isEmpty ( schemaColumns ) ) { int position = NUM_ ; for ( SchemaColumn schemaColumn : schemaColumns ) { SchemaColumnEntity schemaColumnEntity = schemaColumnEntityMap . get ( schemaColumn . getName ( ) ) ; if ( schemaColumnEntity == null ) { schemaColumnEntity = createSchemaColumnEntity ( schemaColumn , businessObjectFormatEntity ) ; schemaColumnEntityList . add ( schemaColumnEntity ) ; schemaColumnEntityMap . put ( schemaColumn . getName ( ) , schemaColumnEntity ) ; } if ( isPartitionList ) { schemaColumnEntity . setPartitionLevel ( position ++ ) ; } else { schemaColumnEntity . setPosition ( position ++ ) ; } } } }
public static < T > String joinAnd ( final String delimiter , final String lastDelimiter , final Collection < T > objs ) { if ( objs == null || objs . isEmpty ( ) ) return STR_ ; final Iterator < T > iter = objs . iterator ( ) ; final StringBuilder buffer = new StringBuilder ( ) ; while ( iter . hasNext ( ) ) { final T obj = iter . next ( ) ; if ( notEmpty ( obj ) ) { if ( buffer . length ( ) != NUM_ ) { buffer . append ( iter . hasNext ( ) ? delimiter : lastDelimiter ) ; } buffer . append ( Strings . toString ( obj ) ) ; } } return buffer . toString ( ) ; }
public static String generateNativeGuid ( DbClient dbClient , Snapshot snapshot ) throws IOException { FileShare fs = dbClient . queryObject ( FileShare . class , snapshot . getParent ( ) ) ; StorageSystem device = dbClient . queryObject ( StorageSystem . class , fs . getStorageDevice ( ) ) ; return String . format ( STR_ + SNAPSHOT + STR_ , _deviceTypeMap . get ( device . getSystemType ( ) ) , device . getSerialNumber ( ) , snapshot . getNativeId ( ) ) ; }
public static Map < String , Object > updateFile ( DispatchContext dctx , Map < String , ? extends Object > context ) { Map < String , Object > result = null ; try { result = updateFileMethod ( dctx , context ) ; } catch ( GenericServiceException e ) { return ServiceUtil . returnError ( e . getMessage ( ) ) ; } return result ; }
public static String readFully ( Reader reader ) throws IOException { try { StringWriter writer = new StringWriter ( ) ; char [ ] buffer = new char [ NUM_ ] ; int count ; while ( ( count = reader . read ( buffer ) ) != - NUM_ ) { writer . write ( buffer , NUM_ , count ) ; } return writer . toString ( ) ; } finally { reader . close ( ) ; } }
public EditSensorsDialog ( final Collection < Sensor > sensors ) { super ( ) ; if ( sensors == null ) { throw new IllegalArgumentException ( STR_ ) ; } this . sensors = sensors ; setTitle ( STR_ + sensors . size ( ) + STR_ ) ; initComponents ( ) ; layoutComponents ( ) ; }
@ VisibleForTesting synchronized void trimToSize ( int targetSize ) { int bytesToFree = Math . min ( mUsed . mNumBytes + mFree . mNumBytes - targetSize , mFree . mNumBytes ) ; if ( bytesToFree <= NUM_ ) { return ; } if ( FLog . isLoggable ( FLog . VERBOSE ) ) { FLog . v ( TAG , STR_ , targetSize , mUsed . mNumBytes + mFree . mNumBytes , bytesToFree ) ; } logStats ( ) ; for ( int i = NUM_ ; i < mBuckets . size ( ) ; ++ i ) { if ( bytesToFree <= NUM_ ) { break ; } Bucket < V > bucket = mBuckets . valueAt ( i ) ; while ( bytesToFree > NUM_ ) { V value = bucket . pop ( ) ; if ( value == null ) { break ; } free ( value ) ; bytesToFree -= bucket . mItemSize ; mFree . decrement ( bucket . mItemSize ) ; } } logStats ( ) ; if ( FLog . isLoggable ( FLog . VERBOSE ) ) { FLog . v ( TAG , STR_ , targetSize , mUsed . mNumBytes + mFree . mNumBytes ) ; } }
@ Override public void addFocusables ( ArrayList < View > views , int direction , int focusableMode ) { final int focusableCount = views . size ( ) ; final int descendantFocusability = getDescendantFocusability ( ) ; if ( descendantFocusability != FOCUS_BLOCK_DESCENDANTS ) { for ( int i = NUM_ ; i < getChildCount ( ) ; i ++ ) { final View child = getChildAt ( i ) ; if ( child . getVisibility ( ) == VISIBLE ) { ItemInfo ii = infoForChild ( child ) ; if ( ii != null && ii . position == mCurItem ) { child . addFocusables ( views , direction , focusableMode ) ; } } } } if ( descendantFocusability != FOCUS_AFTER_DESCENDANTS || ( focusableCount == views . size ( ) ) ) { if ( ! isFocusable ( ) ) { return ; } if ( ( focusableMode & FOCUSABLES_TOUCH_MODE ) == FOCUSABLES_TOUCH_MODE && isInTouchMode ( ) && ! isFocusableInTouchMode ( ) ) { return ; } if ( views != null ) { views . add ( this ) ; } } }
public String readToDelimiter ( char delim ) throws FormatException { StringBuffer buildretval = new StringBuffer ( ) ; char tmp ; try { while ( ( tmp = readChar ( ) ) != delim ) buildretval . append ( tmp ) ; } catch ( EOFException e ) { } catch ( FormatException fe ) { if ( buildretval . length ( ) == NUM_ ) { throw fe ; } } return buildretval . toString ( ) ; }
private void addNewLineAtTop ( RecyclerView . Recycler recycler ) { int x = layoutStartPoint ( ) . x , bottom = getDecoratedTop ( getChildAt ( getMaxHeightLayoutPositionInLine ( NUM_ ) ) ) , y ; int height = NUM_ ; List < View > lineChildren = new LinkedList < > ( ) ; int currentAdapterPosition = NUM_ ; int endAdapterPosition = getChildAdapterPosition ( NUM_ ) - NUM_ ; Rect rect = new Rect ( ) ; boolean newline ; boolean firstItem = BOOL_ ; LayoutContext layoutContext = LayoutContext . fromLayoutOptions ( flowLayoutOptions ) ; int firstItemAdapterPosition = getChildAdapterPosition ( NUM_ ) ; if ( cacheHelper . hasPreviousLineCached ( firstItemAdapterPosition ) ) { int previousLineIndex = cacheHelper . itemLineIndex ( firstItemAdapterPosition ) - NUM_ ; Line previousLine = cacheHelper . getLine ( previousLineIndex ) ; int firstNewItemAdapterPosition = cacheHelper . firstItemIndex ( previousLineIndex ) ; for ( int i = NUM_ ; i < previousLine . itemCount ; i ++ ) { View newView = recycler . getViewForPosition ( firstNewItemAdapterPosition + i ) ; addView ( newView , i ) ; lineChildren . add ( newView ) ; } height = previousLine . maxHeight ; } else { while ( currentAdapterPosition <= endAdapterPosition ) { View newChild = recycler . getViewForPosition ( currentAdapterPosition ) ; newline = calcChildLayoutRect ( newChild , x , NUM_ , height , layoutContext , rect ) ; cacheHelper . setItem ( currentAdapterPosition , new Point ( rect . width ( ) , rect . height ( ) ) ) ; addView ( newChild , lineChildren . size ( ) ) ; if ( newline && ! firstItem ) { for ( View viewToRecycle : lineChildren ) { removeAndRecycleView ( viewToRecycle , recycler ) ; } lineChildren . clear ( ) ; x = advanceInSameLine ( layoutStartPoint ( ) . x , rect , layoutContext ) ; height = rect . height ( ) ; layoutContext . currentLineItemCount = NUM_ ; } else { x = advanceInSameLine ( x , rect , layoutContext ) ; height = Math . max ( height , rect . height ( ) ) ; firstItem = BOOL_ ; layoutContext . currentLineItemCount ++ ; } lineChildren . add ( newChild ) ; currentAdapterPosition ++ ; } } x = layoutStartPoint ( ) . x ; y = bottom - height ; firstItem = BOOL_ ; layoutContext = LayoutContext . fromLayoutOptions ( flowLayoutOptions ) ; for ( int i = NUM_ ; i < lineChildren . size ( ) ; i ++ ) { View childView = lineChildren . get ( i ) ; newline = calcChildLayoutRect ( childView , x , y , height , layoutContext , rect ) ; if ( newline && firstItem ) { int rectHeight = rect . height ( ) ; rect . top -= rectHeight ; rect . bottom -= rectHeight ; firstItem = BOOL_ ; } layoutDecorated ( childView , rect . left , rect . top , rect . right , rect . bottom ) ; x = advanceInSameLine ( x , rect , layoutContext ) ; } }
protected static final String addEscapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = NUM_ ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case NUM_ : continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < x20 || ch > x7e ) { String s = STR_ + Integer . toString ( ch , NUM_ ) ; retval . append ( STR_ + s . substring ( s . length ( ) - NUM_ , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; }
default T call ( SourceSection source , T lhs , T argument1 , T argument2 ) { return call ( source , lhs , Arrays . asList ( argument ( argument1 ) , argument ( argument2 ) ) ) ; }
public boolean equalMapGenParameters ( MapSettings other ) { if ( ( boardWidth != other . getBoardWidth ( ) ) || ( boardHeight != other . getBoardHeight ( ) ) || ( mapWidth != other . getMapWidth ( ) ) || ( mapHeight != other . getMapHeight ( ) ) || ( invertNegativeTerrain != other . getInvertNegativeTerrain ( ) ) || ( hilliness != other . getHilliness ( ) ) || ( cliffs != other . getCliffs ( ) ) || ( range != other . getRange ( ) ) || ( minWaterSpots != other . getMinWaterSpots ( ) ) || ( maxWaterSpots != other . getMaxWaterSpots ( ) ) || ( minWaterSize != other . getMinWaterSize ( ) ) || ( maxWaterSize != other . getMaxWaterSize ( ) ) || ( probDeep != other . getProbDeep ( ) ) || ( minForestSpots != other . getMinForestSpots ( ) ) || ( maxForestSpots != other . getMaxForestSpots ( ) ) || ( minForestSize != other . getMinForestSize ( ) ) || ( maxForestSize != other . getMaxForestSize ( ) ) || ( probHeavy != other . getProbHeavy ( ) ) || ( minRoughSpots != other . getMinRoughSpots ( ) ) || ( maxRoughSpots != other . getMaxRoughSpots ( ) ) || ( minRoughSize != other . getMinRoughSize ( ) ) || ( maxRoughSize != other . getMaxRoughSize ( ) ) || ( minSandSpots != other . getMinSandSpots ( ) ) || ( maxSandSpots != other . getMaxSandSpots ( ) ) || ( minSandSize != other . getMinSandSize ( ) ) || ( maxSandSize != other . getMaxSandSize ( ) ) || ( minPlantedFieldSpots != other . getMinPlantedFieldSpots ( ) ) || ( maxPlantedFieldSpots != other . getMaxPlantedFieldSpots ( ) ) || ( minPlantedFieldSize != other . getMinPlantedFieldSize ( ) ) || ( maxPlantedFieldSize != other . getMaxPlantedFieldSize ( ) ) || ( minSwampSpots != other . getMinSwampSpots ( ) ) || ( maxSwampSpots != other . getMaxSwampSpots ( ) ) || ( minSwampSize != other . getMinSwampSize ( ) ) || ( maxSwampSize != other . getMaxSwampSize ( ) ) || ( minPavementSpots != other . getMinPavementSpots ( ) ) || ( maxPavementSpots != other . getMaxPavementSpots ( ) ) || ( minPavementSize != other . getMinPavementSize ( ) ) || ( maxPavementSize != other . getMaxPavementSize ( ) ) || ( minRubbleSpots != other . getMinRubbleSpots ( ) ) || ( maxRubbleSpots != other . getMaxRubbleSpots ( ) ) || ( minRubbleSize != other . getMinRubbleSize ( ) ) || ( maxRubbleSize != other . getMaxRubbleSize ( ) ) || ( minFortifiedSpots != other . getMinFortifiedSpots ( ) ) || ( maxFortifiedSpots != other . getMaxFortifiedSpots ( ) ) || ( minFortifiedSize != other . getMinFortifiedSize ( ) ) || ( maxFortifiedSize != other . getMaxFortifiedSize ( ) ) || ( minIceSpots != other . getMinIceSpots ( ) ) || ( maxIceSpots != other . getMaxIceSpots ( ) ) || ( minIceSize != other . getMinIceSize ( ) ) || ( maxIceSize != other . getMaxIceSize ( ) ) || ( probRoad != other . getProbRoad ( ) ) || ( probInvert != other . getProbInvert ( ) ) || ( probRiver != other . getProbRiver ( ) ) || ( probCrater != other . getProbCrater ( ) ) || ( minRadius != other . getMinRadius ( ) ) || ( maxRadius != other . getMaxRadius ( ) ) || ( minCraters != other . getMinCraters ( ) ) || ( maxCraters != other . getMaxCraters ( ) ) || ( ! theme . equals ( other . getTheme ( ) ) ) || ( fxMod != other . getFxMod ( ) ) || ( cityBlocks != other . getCityBlocks ( ) ) || ( cityType != other . getCityType ( ) ) || ( cityMinCF != other . getCityMinCF ( ) ) || ( cityMaxCF != other . getCityMaxCF ( ) ) || ( cityMinFloors != other . getCityMinFloors ( ) ) || ( cityMaxFloors != other . getCityMaxFloors ( ) ) || ( cityDensity != other . getCityDensity ( ) ) || ( probFlood != other . getProbFlood ( ) ) || ( probForestFire != other . getProbForestFire ( ) ) || ( probFreeze != other . getProbFreeze ( ) ) || ( probDrought != other . getProbDrought ( ) ) || ( algorithmToUse != other . getAlgorithmToUse ( ) ) || ( mountainHeightMin != other . getMountainHeightMin ( ) ) || ( mountainHeightMax != other . getMountainHeightMax ( ) ) || ( mountainPeaks != other . getMountainPeaks ( ) ) || ( mountainStyle != other . getMountainStyle ( ) ) || ( mountainWidthMin != other . getMountainWidthMin ( ) ) || ( mountainWidthMax != other . getMountainWidthMax ( ) ) || ( boardBuildings != other . getBoardBuildings ( ) ) ) { return BOOL_ ; } return BOOL_ ; }
private static void decodeTextSegment ( BitSource bits , StringBuilder result ) throws FormatException { boolean upperShift = BOOL_ ; int [ ] cValues = new int [ NUM_ ] ; int shift = NUM_ ; do { if ( bits . available ( ) == NUM_ ) { return ; } int firstByte = bits . readBits ( NUM_ ) ; if ( firstByte == NUM_ ) { return ; } parseTwoBytes ( firstByte , bits . readBits ( NUM_ ) , cValues ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { int cValue = cValues [ i ] ; switch ( shift ) { case NUM_ : if ( cValue < NUM_ ) { shift = cValue + NUM_ ; } else if ( cValue < TEXT_BASIC_SET_CHARS . length ) { char textChar = TEXT_BASIC_SET_CHARS [ cValue ] ; if ( upperShift ) { result . append ( ( char ) ( textChar + NUM_ ) ) ; upperShift = BOOL_ ; } else { result . append ( textChar ) ; } } else { throw FormatException . getFormatInstance ( ) ; } break ; case NUM_ : if ( upperShift ) { result . append ( ( char ) ( cValue + NUM_ ) ) ; upperShift = BOOL_ ; } else { result . append ( ( char ) cValue ) ; } shift = NUM_ ; break ; case NUM_ : if ( cValue < C40_SHIFT2_SET_CHARS . length ) { char c40char = C40_SHIFT2_SET_CHARS [ cValue ] ; if ( upperShift ) { result . append ( ( char ) ( c40char + NUM_ ) ) ; upperShift = BOOL_ ; } else { result . append ( c40char ) ; } } else if ( cValue == NUM_ ) { result . append ( ( char ) NUM_ ) ; } else if ( cValue == NUM_ ) { upperShift = BOOL_ ; } else { throw FormatException . getFormatInstance ( ) ; } shift = NUM_ ; break ; case NUM_ : if ( cValue < TEXT_SHIFT3_SET_CHARS . length ) { char textChar = TEXT_SHIFT3_SET_CHARS [ cValue ] ; if ( upperShift ) { result . append ( ( char ) ( textChar + NUM_ ) ) ; upperShift = BOOL_ ; } else { result . append ( textChar ) ; } shift = NUM_ ; } else { throw FormatException . getFormatInstance ( ) ; } break ; default : throw FormatException . getFormatInstance ( ) ; } } } while ( bits . available ( ) > NUM_ ) ; }
public void saveLockPassword ( String password , int quality , boolean isFallback ) { final byte [ ] hash = passwordToHash ( password ) ; try { RandomAccessFile raf = new RandomAccessFile ( sLockPasswordFilename , STR_ ) ; try { if ( password == null ) { raf . setLength ( NUM_ ) ; } else { raf . write ( hash , NUM_ , hash . length ) ; } } finally { if ( raf != null ) raf . close ( ) ; } } catch ( FileNotFoundException fnfe ) { LogUtil . e ( TAG , STR_ + sLockPasswordFilename ) ; } catch ( IOException ioe ) { LogUtil . e ( TAG , STR_ + sLockPasswordFilename ) ; } }
public boolean checkUsernameExists ( String username ) throws DataAccessException { return getUserInfo ( username ) != null ; }
public Code39Reader ( ) { usingCheckDigit = BOOL_ ; extendedMode = BOOL_ ; }
public static String encode ( final List < Position > path , int precision ) { long lastLat = NUM_ ; long lastLng = NUM_ ; final StringBuffer result = new StringBuffer ( ) ; double factor = Math . pow ( NUM_ , precision ) ; for ( final Position point : path ) { long lat = Math . round ( point . getLatitude ( ) . factor ) ; long lng = Math . round ( point . getLongitude ( ) . factor ) ; long dLat = lat - lastLat ; long dLng = lng - lastLng ; encode ( dLat , result ) ; encode ( dLng , result ) ; lastLat = lat ; lastLng = lng ; } return result . toString ( ) ; }
public ActivityResolveInfo ( ResolveInfo resolveInfo ) { this . resolveInfo = resolveInfo ; }
@ Override public int compareTo ( LibPackage p_other ) { return pkg_name . compareToIgnoreCase ( p_other . pkg_name ) ; }
public void writeExif ( Bitmap bmap , String exifOutFileName ) throws FileNotFoundException , IOException { if ( bmap == null || exifOutFileName == null ) { throw new IllegalArgumentException ( NULL_ARGUMENT_STRING ) ; } OutputStream s = null ; try { s = getExifWriterStream ( exifOutFileName ) ; bmap . compress ( Bitmap . CompressFormat . JPEG , NUM_ , s ) ; s . flush ( ) ; } catch ( IOException e ) { closeSilently ( s ) ; throw e ; } s . close ( ) ; }
public double entropy ( int [ ] x ) { double h = NUM_ ; int n = x . length ; double ln2 = Math . log ( NUM_ ) ; int n0 = NUM_ ; for ( int i = NUM_ ; i < n ; i ++ ) { if ( x [ i ] == NUM_ ) { n0 ++ ; } } double p ; if ( n0 == NUM_ || n0 == n ) { return h ; } else { p = ( double ) n0 / ( double ) n ; h = - ( p . Math . log ( p ) + ( NUM_ - p ) . Math . log ( NUM_ - p ) ) / ln2 ; } return h ; }
private String [ ] addtoSelectionArgs ( final String argValue , final String [ ] selectionArgsIn ) { String [ ] selectionArgs = selectionArgsIn ; List < String > selectionArgsList = new ArrayList < > ( ) ; selectionArgsList . add ( argValue ) ; if ( null != selectionArgsIn ) { for ( final String arg : selectionArgsIn ) { selectionArgsList . add ( arg ) ; } } selectionArgs = selectionArgsList . toArray ( new String [ NUM_ ] ) ; selectionArgsList . clear ( ) ; selectionArgsList = null ; return selectionArgs ; }
public void put ( String sample , String attribute , Object value ) { if ( ! sampleOrder . contains ( sample ) ) sampleOrder . add ( sample ) ; if ( ! attributeOrder . contains ( attribute ) ) attributeOrder . add ( attribute ) ; table . put ( sample , attribute , value ) ; }
public boolean isCompacted ( ) { return compacted ; }
protected void center ( ) { Container parent = getParent ( ) ; final Dimension size = getPreferredSize ( ) ; setBounds ( ( parent . getWidth ( ) - size . width ) / NUM_ , ( parent . getHeight ( ) - size . height ) / NUM_ , size . width , size . height ) ; }
public boolean isCardDismissible ( String tag ) { return mDismissibleCards . contains ( tag ) ; }
public void write ( char cbuf [ ] , int off , int len ) throws IOException { se . write ( cbuf , off , len ) ; }
public boolean validate ( String telephone ) { char aChar ; StringBuilder buf = new StringBuilder ( telephone ) ; for ( int aIndex = NUM_ ; aIndex < buf . length ( ) ; aIndex ++ ) { aChar = buf . charAt ( aIndex ) ; if ( ! Character . isSpaceChar ( aChar ) ) { if ( ! Character . isDigit ( aChar ) && ! isValidTelephoneChars ( aChar ) ) { return BOOL_ ; } } } return BOOL_ ; }
public static void unpack ( HashMap < String , Object > object , String key , Object value ) { String [ ] split = key . split ( STR_ ) ; HashMap lobj = object ; for ( int cur = NUM_ ; cur < split . length ; cur ++ ) { String current = split [ cur ] ; if ( ! ( lobj . containsKey ( current ) && lobj . get ( current ) instanceof HashMap ) ) { lobj . put ( current , new HashMap < String , Object > ( ) ) ; } if ( cur == split . length - NUM_ ) { lobj . put ( current , value ) ; } else lobj = ( HashMap ) lobj . get ( current ) ; } }
public void removeListener ( DNSListener listener ) { _listeners . remove ( listener ) ; }
static Set < String > parseResourcePathParams ( String resourcePath ) { Matcher matcher = PARAM_URL_REGEX . matcher ( resourcePath ) ; Set < String > patterns = new LinkedHashSet < > ( ) ; while ( matcher . find ( ) ) { patterns . add ( matcher . group ( NUM_ ) ) ; } return patterns ; }
@ Override public void close ( ) throws IOException { if ( logger != null ) { logger . println ( STR_ + socket_was_closed ) ; } if ( ! socket_was_closed ) { if ( handshake_started ) { alertProtocol . alert ( AlertProtocol . WARNING , AlertProtocol . CLOSE_NOTIFY ) ; try { output . write ( alertProtocol . wrap ( ) ) ; } catch ( IOException ex ) { } alertProtocol . setProcessed ( ) ; } shutdown ( ) ; closeTransportLayer ( ) ; socket_was_closed = BOOL_ ; } }
public JRangeSlider ( BoundedRangeModel model , int orientation , int direction ) { super . setFocusable ( BOOL_ ) ; this . model = model ; this . orientation = orientation ; this . direction = direction ; setForeground ( Color . LIGHT_GRAY ) ; this . lstnr = createListener ( ) ; model . addChangeListener ( lstnr ) ; addMouseListener ( this ) ; addMouseMotionListener ( this ) ; addKeyListener ( this ) ; }
public static boolean isAutoNew ( Properties ctx ) { if ( ctx == null ) throw new IllegalArgumentException ( STR_ ) ; String s = getContext ( ctx , STR_ ) ; if ( s != null && s . equals ( STR_ ) ) return BOOL_ ; return BOOL_ ; }
public boolean canRead ( String path ) { try { ZipEntry entry = getZipEntry ( path ) ; return entry != null && ! entry . isDirectory ( ) ; } catch ( IOException e ) { log . log ( Level . FINE , e . toString ( ) , e ) ; return BOOL_ ; } }
public static long [ ] andI ( long [ ] v , long [ ] o , int off ) { if ( off == NUM_ ) { return andI ( v , o ) ; } if ( off < NUM_ ) { throw new UnsupportedOperationException ( STR_ ) ; } final int shiftWords = off > > > LONG_LOG2_SIZE ; final int shiftBits = off & LONG_LOG2_MASK ; if ( shiftWords >= v . length ) { return v ; } if ( shiftBits == NUM_ ) { final int end = Math . min ( v . length , o . length + shiftWords ) ; for ( int i = shiftWords ; i < end ; i ++ ) { v [ i ] &= o [ i - shiftWords ] ; } Arrays . fill ( v , NUM_ , shiftWords , NUM_ ) ; return v ; } final int unshiftBits = Long . SIZE - shiftBits ; final int end = Math . min ( v . length , o . length + shiftWords ) - NUM_ ; Arrays . fill ( v , end + NUM_ , v . length , NUM_ ) ; for ( int i = end ; i > shiftWords ; i -- ) { final int src = i - shiftWords ; v [ i ] &= ( o [ src ] << shiftBits ) | ( o [ src - NUM_ ] > > > unshiftBits ) ; } v [ shiftWords ] &= o [ NUM_ ] << shiftBits ; Arrays . fill ( v , NUM_ , shiftWords , NUM_ ) ; return v ; }
private int calculateLayoutWidth ( int widthSize , int mode ) { initResourcesIfNecessary ( ) ; itemsLayout . setLayoutParams ( new LayoutParams ( LayoutParams . WRAP_CONTENT , LayoutParams . WRAP_CONTENT ) ) ; itemsLayout . measure ( MeasureSpec . makeMeasureSpec ( widthSize , MeasureSpec . UNSPECIFIED ) , MeasureSpec . makeMeasureSpec ( NUM_ , MeasureSpec . UNSPECIFIED ) ) ; int width = itemsLayout . getMeasuredWidth ( ) ; if ( mode == MeasureSpec . EXACTLY ) { width = widthSize ; } else { width += NUM_ . PADDING ; width = Math . max ( width , getSuggestedMinimumWidth ( ) ) ; if ( mode == MeasureSpec . AT_MOST && widthSize < width ) { width = widthSize ; } } itemsLayout . measure ( MeasureSpec . makeMeasureSpec ( width - NUM_ . PADDING , MeasureSpec . EXACTLY ) , MeasureSpec . makeMeasureSpec ( NUM_ , MeasureSpec . UNSPECIFIED ) ) ; return width ; }
public boolean equals ( Object p_test ) { if ( p_test instanceof URI ) { URI testURI = ( URI ) p_test ; if ( ( ( m_scheme == null && testURI . m_scheme == null ) || ( m_scheme != null && testURI . m_scheme != null && m_scheme . equals ( testURI . m_scheme ) ) ) && ( ( m_userinfo == null && testURI . m_userinfo == null ) || ( m_userinfo != null && testURI . m_userinfo != null && m_userinfo . equals ( testURI . m_userinfo ) ) ) && ( ( m_host == null && testURI . m_host == null ) || ( m_host != null && testURI . m_host != null && m_host . equals ( testURI . m_host ) ) ) && m_port == testURI . m_port && ( ( m_path == null && testURI . m_path == null ) || ( m_path != null && testURI . m_path != null && m_path . equals ( testURI . m_path ) ) ) && ( ( m_queryString == null && testURI . m_queryString == null ) || ( m_queryString != null && testURI . m_queryString != null && m_queryString . equals ( testURI . m_queryString ) ) ) && ( ( m_fragment == null && testURI . m_fragment == null ) || ( m_fragment != null && testURI . m_fragment != null && m_fragment . equals ( testURI . m_fragment ) ) ) ) { return BOOL_ ; } } return BOOL_ ; }
public void testCase5 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int bSign = - NUM_ ; byte rBytes [ ] = { - NUM_ , - NUM_ , - NUM_ , NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . multiply ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , - NUM_ , result . signum ( ) ) ; }
public ISAACRandom ( ) { setSeed ( System . currentTimeMillis ( ) + System . identityHashCode ( this ) ) ; }
public static boolean isMD5String ( final String string ) { Preconditions . checkNotNull ( string , STR_ ) ; return ( string . length ( ) == NUM_ ) && isHexString ( string ) ; }
public synchronized void waitForSubmittedTasks ( ) throws InterruptedException { while ( currentTaskCount . get ( ) > NUM_ ) { waitForSingleTask ( ) ; } }
private int scanToken ( int startPos ) { int position = startPos ; while ( position < maxPosition ) { if ( ! hasSurrogates ) { char c = str . charAt ( position ) ; if ( ( c <= maxDelimCodePoint ) && ( delimiters . indexOf ( c ) >= NUM_ ) ) break ; position ++ ; } else { int c = str . codePointAt ( position ) ; if ( ( c <= maxDelimCodePoint ) && isDelimiter ( c ) ) break ; position += Character . charCount ( c ) ; } } if ( retDelims && ( startPos == position ) ) { if ( ! hasSurrogates ) { char c = str . charAt ( position ) ; if ( ( c <= maxDelimCodePoint ) && ( delimiters . indexOf ( c ) >= NUM_ ) ) position ++ ; } else { int c = str . codePointAt ( position ) ; if ( ( c <= maxDelimCodePoint ) && isDelimiter ( c ) ) position += Character . charCount ( c ) ; } } return position ; }
public void zoomAt ( double x , double y , double z , double zoomValue ) { double [ ] diff = { targetXoff - x , targetYoff - y , z - targetZoff } ; double length = Math . sqrt ( diff [ NUM_ ] . diff [ NUM_ ] + diff [ NUM_ ] . diff [ NUM_ ] + diff [ NUM_ ] . diff [ NUM_ ] ) ; if ( length == NUM_ ) { length = NUM_ ; } double [ ] normalized = { diff [ NUM_ ] / length , diff [ NUM_ ] / length , diff [ NUM_ ] / length } ; double percent = zoomValue / normalized [ NUM_ ] ; moveToPosition ( - ( float ) ( targetXoff + normalized [ NUM_ ] . percent ) , - ( float ) ( targetYoff + normalized [ NUM_ ] . percent ) ) ; zoomToCamera ( ( float ) ( targetZoff + normalized [ NUM_ ] . percent ) ) ; }
private static int stringToHash ( String s ) { int len = s . length ( ) ; int hash2 = NUM_ ; int hash = len ; hash <<= NUM_ ; hash += s . charAt ( NUM_ ) - x60 ; int j = len ; for ( int i = NUM_ ; i < NUM_ && j > NUM_ ; i ++ ) { j -- ; hash <<= NUM_ ; hash += s . charAt ( j ) - x60 ; hash2 <<= NUM_ ; hash2 += s . charAt ( i ) - x5F ; } return hash ^ hash2 ; }
public void registerDenseFeatures ( ArrayList < FeatureFunction > featureFunctions ) { for ( FeatureFunction feature : featureFunctions ) { ArrayList < String > names = feature . reportDenseFeatures ( denseFeatures . size ( ) ) ; for ( String name : names ) { DENSE_FEATURE_NAMES . add ( name ) ; denseFeatures . add ( getSparse ( name ) ) ; sparseFeatures . remove ( name ) ; } } }
private void addFlag ( final List < String > args , final String argName , final boolean value ) { if ( value ) { args . add ( argName ) ; } }
public static PrivateKey load ( InputStream is ) throws IOException , CryptoException { byte [ ] pvk = ReadUtil . readFully ( is ) ; ByteBuffer bb = ByteBuffer . wrap ( pvk ) ; bb . order ( ByteOrder . LITTLE_ENDIAN ) ; long keyType = readReservedMagicKeyType ( bb ) ; long encrypted = UnsignedUtil . getInt ( bb ) ; if ( encrypted != PVK_UNENCRYPTED ) { throw new PrivateKeyEncryptedException ( MessageFormat . format ( res . getString ( STR_ ) , Long . toHexString ( encrypted ) , Long . toHexString ( PVK_UNENCRYPTED ) ) ) ; } long saltLength = UnsignedUtil . getInt ( bb ) ; if ( saltLength != UNENCRYPTED_SALT_LENGTH ) { throw new CryptoException ( MessageFormat . format ( res . getString ( STR_ ) , Long . toHexString ( saltLength ) , Long . toHexString ( UNENCRYPTED_SALT_LENGTH ) ) ) ; } long keyLength = UnsignedUtil . getInt ( bb ) ; readPrivateKeyBlobHeader ( bb , keyType ) ; byte [ ] privateKeyBlob = new byte [ bb . remaining ( ) ] ; bb . get ( privateKeyBlob ) ; if ( keyLength != ( privateKeyBlob . length + BLOB_HEADER_LENGTH ) ) { throw new CryptoException ( MessageFormat . format ( res . getString ( STR_ ) , Long . toHexString ( keyLength ) , Long . toHexString ( privateKeyBlob . length + BLOB_HEADER_LENGTH ) ) ) ; } return blobToPrivateKey ( privateKeyBlob ) ; }
public static byte [ ] keyGenPrivate ( byte [ ] randomBytes ) throws NoSuchAlgorithmException , DigestException { if ( randomBytes . length < NUM_ ) { throw new RuntimeException ( STR_ ) ; } MessageDigest digest = MessageDigest . getInstance ( STR_ ) ; digest . digest ( randomBytes , NUM_ , randomBytes . length ) ; byte [ ] privateKey = digest . digest ( ) ; privateKey [ NUM_ ] &= NUM_ ; privateKey [ NUM_ ] &= NUM_ ; privateKey [ NUM_ ] |= NUM_ ; return privateKey ; }
private boolean isCheckpointTableExists ( Connection conn ) { Statement st = null ; ResultSet rs = null ; try { st = conn . createStatement ( ) ; rs = st . executeQuery ( chkTblExistsSql ) ; return BOOL_ ; } catch ( SQLException ignored ) { return BOOL_ ; } finally { U . close ( rs , log ) ; U . close ( st , log ) ; } }
public FunctionTableModel ( ) { columnList . add ( Localisation . getString ( FunctionTableModel . class , STR_ ) ) ; columnList . add ( Localisation . getString ( FunctionTableModel . class , STR_ ) ) ; columnList . add ( Localisation . getString ( FunctionTableModel . class , STR_ ) ) ; columnList . add ( Localisation . getString ( FunctionTableModel . class , STR_ ) ) ; }
private NewCookie createWsCookie ( String cookieName , String token , boolean setMaxAge , String userAgent ) { String ieExpires = STR_ ; int maxAge = setMaxAge ? _tokenManager . getMaxTokenLifeTimeInSecs ( ) : NewCookie . DEFAULT_MAX_AGE ; if ( setMaxAge && StringUtils . contains ( userAgent , STR_ ) ) { ieExpires = STR_ + getExpiredTimeGMT ( maxAge ) ; _log . debug ( STR_ + ieExpires ) ; } if ( token != null && ! token . isEmpty ( ) ) { return new NewCookie ( cookieName , token + STR_ + ieExpires , null , null , null , maxAge , BOOL_ ) ; } return null ; }
protected void initView ( ) { p . setFakeBoldText ( BOOL_ ) ; p . setAntiAlias ( BOOL_ ) ; p . setTextSize ( MINI_DAY_NUMBER_TEXT_SIZE ) ; p . setStyle ( Style . FILL ) ; mMonthNumPaint = new Paint ( ) ; mMonthNumPaint . setFakeBoldText ( BOOL_ ) ; mMonthNumPaint . setAntiAlias ( BOOL_ ) ; mMonthNumPaint . setTextSize ( MINI_DAY_NUMBER_TEXT_SIZE ) ; mMonthNumPaint . setColor ( mFocusMonthColor ) ; mMonthNumPaint . setStyle ( Style . FILL ) ; mMonthNumPaint . setTextAlign ( Align . CENTER ) ; }
@ Override public boolean connectionAllowed ( EventSetDescriptor esd ) { return connectionAllowed ( esd . getName ( ) ) ; }
ScheduledFutureTask ( Runnable r , V result , long ns , long period ) { super ( r , result ) ; this . time = ns ; this . period = period ; this . sequenceNumber = sequencer . getAndIncrement ( ) ; }
public boolean verify ( X509Certificate cert , Provider sigProvider ) throws NoSuchAlgorithmException , CertificateExpiredException , CertificateNotYetValidException , CMSException { Time signingTime = getSigningTime ( ) ; if ( signingTime != null ) { cert . checkValidity ( signingTime . getDate ( ) ) ; } return doVerify ( cert . getPublicKey ( ) , sigProvider ) ; }
public GeoMark analyse ( final String text , final String [ ] tags , final int maxlength , final String salt ) { GeoLocation loc = geocode ( text , tags , maxlength ) ; if ( loc != null ) return new GeoMark ( loc , salt ) ; return reverse_geocode ( text ) ; }
public void findAndInit ( Iterator it ) { while ( it . hasNext ( ) ) { findAndInit ( it . next ( ) ) ; } }
public void test_SelectOrderBy ( ) throws SQLException { String selectQuery = STR_ + DatabaseCreator . ORDERS_TABLE + STR_ ; ResultSet result = statement . executeQuery ( selectQuery ) ; ArrayList < Integer > values = new ArrayList < Integer > ( ) ; values . add ( Integer . valueOf ( NUM_ ) ) ; values . add ( Integer . valueOf ( NUM_ ) ) ; values . add ( Integer . valueOf ( NUM_ ) ) ; values . add ( Integer . valueOf ( NUM_ ) ) ; values . add ( Integer . valueOf ( NUM_ ) ) ; values . add ( Integer . valueOf ( NUM_ ) ) ; values . add ( Integer . valueOf ( NUM_ ) ) ; values . add ( Integer . valueOf ( NUM_ ) ) ; values . add ( Integer . valueOf ( NUM_ ) ) ; values . add ( Integer . valueOf ( NUM_ ) ) ; int index = NUM_ ; while ( result . next ( ) ) { Integer onum = result . getInt ( STR_ ) ; assertTrue ( STR_ , values . contains ( onum ) ) ; assertEquals ( STR_ , index , values . indexOf ( onum ) ) ; index ++ ; } result . close ( ) ; }
private static String formatTo2Digits ( String str ) { if ( str . length ( ) < NUM_ ) { str = STR_ + str ; } return str ; }
protected static String quoteSQL ( Object data , int type ) throws SQLException { if ( data == null ) { return STR_ ; } switch ( type ) { case Types . BIT : case Types . BOOLEAN : case Types . INTEGER : case Types . BIGINT : case Types . DECIMAL : case Types . DOUBLE : case Types . FLOAT : case Types . NUMERIC : case Types . REAL : case Types . SMALLINT : case Types . TINYINT : return data . toString ( ) ; case Types . DATE : case Types . TIME : case Types . TIMESTAMP : case Types . LONGVARCHAR : case Types . CHAR : case Types . VARCHAR : return quoteString ( data . toString ( ) ) ; case Types . VARBINARY : case Types . LONGVARBINARY : case Types . BINARY : if ( data instanceof UUID ) { return STR_ + data . toString ( ) + STR_ ; } return STR_ + StringUtils . convertBytesToHex ( ( byte [ ] ) data ) + STR_ ; case Types . CLOB : case Types . JAVA_OBJECT : case Types . OTHER : case Types . BLOB : case Types . STRUCT : case Types . REF : case Types . NULL : case Types . ARRAY : case Types . DATALINK : case Types . DISTINCT : throw throwException ( STR_ + type ) ; default : return STR_ ; } }
public void addFooterView ( View v , Object data , boolean isSelectable ) { FixedViewInfo info = new FixedViewInfo ( ) ; info . view = v ; info . data = data ; info . isSelectable = isSelectable ; mFooterViewInfos . add ( info ) ; if ( mAdapter != null && mObserver != null ) { mObserver . onChanged ( ) ; } }
public static int calculateDigitCount ( long value ) { if ( value < NUM_ ) { if ( value != Long . MIN_VALUE ) { return calculateDigitCount ( - value ) + NUM_ ; } else { return NUM_ ; } } return ( value < NUM_ ? NUM_ : ( value < NUM_ ? NUM_ : ( value < NUM_ ? NUM_ : ( value < NUM_ ? NUM_ : ( ( int ) ( Math . log ( value ) / LOG_10 ) + NUM_ ) ) ) ) ) ; }
public static Byte [ ] convertDate ( String date ) { StringTokenizer st = new StringTokenizer ( date ) ; String sdate = st . nextToken ( ) ; String stime = st . nextToken ( ) ; st = new StringTokenizer ( sdate , STR_ ) ; String year = st . nextToken ( ) ; int iyear = NUM_ ; try { iyear = Integer . parseInt ( year ) ; } catch ( NumberFormatException ex ) { debug . error ( STR_ + year + STR_ ) ; } byte yrlow = ( byte ) ( iyear & xff ) ; byte yrhigh = ( byte ) ( ( ( iyear & xff00 ) > > NUM_ ) & xff ) ; String month = st . nextToken ( ) ; String day = st . nextToken ( ) ; st = new StringTokenizer ( stime , STR_ ) ; String hour = st . nextToken ( ) ; String min = st . nextToken ( ) ; String sec = st . nextToken ( ) ; Byte bz = Byte . valueOf ( ( byte ) NUM_ ) ; Byte byrhi = bz ; Byte byrlo = bz ; Byte bmo = bz ; Byte bdy = bz ; Byte bhr = bz ; Byte bmn = bz ; Byte bsc = bz ; try { byrhi = new Byte ( yrhigh ) ; byrlo = new Byte ( yrlow ) ; bmo = new Byte ( month ) ; bdy = new Byte ( day ) ; bhr = new Byte ( hour ) ; bmn = new Byte ( min ) ; bsc = new Byte ( sec ) ; } catch ( NumberFormatException ex ) { debug . error ( STR_ + STR_ + sdate + STR_ + stime ) ; } Byte [ ] ret = new Byte [ NUM_ ] ; ret [ NUM_ ] = byrhi ; ret [ NUM_ ] = byrlo ; ret [ NUM_ ] = bmo ; ret [ NUM_ ] = bdy ; ret [ NUM_ ] = bhr ; ret [ NUM_ ] = bmn ; ret [ NUM_ ] = bsc ; ret [ NUM_ ] = bz ; return ret ; }
private void parseAndAdd ( String line , BufferedReader reader ) throws IOException { try { StringTokenizer tokenizer = new StringTokenizer ( line , STR_ ) ; String tag = tokenizer . nextToken ( ) ; if ( tag . equals ( STR_ ) ) { continuityWeight = Integer . parseInt ( tokenizer . nextToken ( ) ) ; } else if ( tag . equals ( STR_ ) ) { optimalCoupling = Integer . parseInt ( tokenizer . nextToken ( ) ) ; } else if ( tag . equals ( STR_ ) ) { extendSelections = Integer . parseInt ( tokenizer . nextToken ( ) ) ; } else if ( tag . equals ( STR_ ) ) { joinMethod = Integer . parseInt ( tokenizer . nextToken ( ) ) ; } else if ( tag . equals ( STR_ ) ) { int numWeights = Integer . parseInt ( tokenizer . nextToken ( ) ) ; joinWeights = new int [ numWeights ] ; for ( int i = NUM_ ; i < numWeights ; i ++ ) { joinWeights [ i ] = Integer . parseInt ( tokenizer . nextToken ( ) ) ; } joinWeightShift = calcJoinWeightShift ( joinWeights ) ; } else if ( tag . equals ( STR_ ) ) { String name = tokenizer . nextToken ( ) ; if ( name . equals ( STR_ ) ) { sts = new SampleSet ( tokenizer , reader ) ; } else { mcep = new SampleSet ( tokenizer , reader ) ; } } else if ( tag . equals ( STR_ ) ) { int type = Integer . parseInt ( tokenizer . nextToken ( ) ) ; int phone = Integer . parseInt ( tokenizer . nextToken ( ) ) ; int start = Integer . parseInt ( tokenizer . nextToken ( ) ) ; int end = Integer . parseInt ( tokenizer . nextToken ( ) ) ; int prev = Integer . parseInt ( tokenizer . nextToken ( ) ) ; int next = Integer . parseInt ( tokenizer . nextToken ( ) ) ; DatabaseClusterUnit unit = new DatabaseClusterUnit ( type , phone , start , end , prev , next ) ; unitList . add ( unit ) ; } else if ( tag . equals ( STR_ ) ) { String name = tokenizer . nextToken ( ) ; int nodes = Integer . parseInt ( tokenizer . nextToken ( ) ) ; CART cart = new CARTImpl ( reader , nodes ) ; cartMap . put ( name , cart ) ; if ( defaultCart == null ) { defaultCart = cart ; } } else if ( tag . equals ( STR_ ) ) { String name = tokenizer . nextToken ( ) ; int start = Integer . parseInt ( tokenizer . nextToken ( ) ) ; int count = Integer . parseInt ( tokenizer . nextToken ( ) ) ; UnitType unitType = new UnitType ( name , start , count ) ; unitTypesList . add ( unitType ) ; } else { throw new Error ( STR_ + tag + STR_ + line + STR_ ) ; } } catch ( NoSuchElementException nse ) { throw new Error ( STR_ + nse . getMessage ( ) ) ; } catch ( NumberFormatException nfe ) { throw new Error ( STR_ + line + STR_ + nfe . getMessage ( ) ) ; } }
public String byteStringNoSemicolon ( ) { StringBuilder retval = new StringBuilder ( ) ; try { while ( BOOL_ ) { char next = lookAhead ( NUM_ ) ; if ( next == STR_ || next == STR_ || next == STR_ || next == STR_ ) { break ; } else { consume ( NUM_ ) ; retval . append ( next ) ; } } } catch ( ParseException ex ) { return retval . toString ( ) ; } return retval . toString ( ) ; }
public void testNegNegFirstLonger ( ) { byte aBytes [ ] = { - NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ } ; byte bBytes [ ] = { - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = - NUM_ ; int bSign = - NUM_ ; byte rBytes [ ] = { - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . or ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , - NUM_ , result . signum ( ) ) ; }
public static void println ( double x ) { out . println ( x ) ; }
public boolean subscribeTopic ( @ NonNull Context context , @ NonNull String [ ] newTopics ) { if ( ! initialized ) init ( context ) ; if ( newTopics . length == NUM_ ) return BOOL_ ; if ( null == topics ) { topics = new ArrayList < > ( ) ; } for ( String topic : newTopics ) { if ( topics . contains ( topic ) ) { return BOOL_ ; } topics . add ( topic ) ; } saveSubscibedTopics ( context ) ; Intent intent = new Intent ( context , RegistrationIntentService . class ) ; intent . setAction ( RegistrationIntentService . ACTION_SUBSCRIBE ) ; intent . putExtra ( RegistrationIntentService . EXTRA_TOPIC_LIST , newTopics ) ; context . startService ( intent ) ; return BOOL_ ; }
public static String serialise ( Node node ) { try { DOMImplementationRegistry registry = DOMImplementationRegistry . newInstance ( ) ; DOMImplementationLS lsImpl = ( DOMImplementationLS ) registry . getDOMImplementation ( STR_ ) ; LSSerializer serializer = lsImpl . createLSSerializer ( ) ; return serializer . writeToString ( node ) ; } catch ( Exception e ) { log . fine ( STR_ + e ) ; return STR_ ; } }
public static boolean isOnSegment ( Geo a , Geo b , Geo i ) { return ( ( a . distance ( i ) < a . distance ( b ) ) && ( b . distance ( i ) < b . distance ( a ) ) ) ; }
public void addExtensionPoint ( ExtensionPoint extensionPoint ) { fExtensionPoints . add ( extensionPoint ) ; }
private List addNodeToList ( int startIndexForNode , int endIndexForNode ) { List localvmList = new ArrayList ( ) ; for ( int i = startIndexForNode ; i < endIndexForNode ; i ++ ) { localvmList . add ( vm [ i ] ) ; } return localvmList ; }
public void addMetaMethod ( MetaMethod method ) { if ( isInitialized ( ) ) { throw new RuntimeException ( STR_ + method ) ; } final CachedClass declaringClass = method . getDeclaringClass ( ) ; addMetaMethodToIndex ( method , metaMethodIndex . getHeader ( declaringClass . getTheClass ( ) ) ) ; }
public void waitForEvent ( long timeout ) { Thread thread = Thread . currentThread ( ) ; Semaphore semaphore = _semaphores . get ( thread ) ; if ( semaphore == null ) { semaphore = new Semaphore ( NUM_ , BOOL_ ) ; semaphore . drainPermits ( ) ; _semaphores . putIfAbsent ( thread , semaphore ) ; } semaphore = _semaphores . get ( thread ) ; try { semaphore . tryAcquire ( timeout , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException exception ) { logger . log ( Level . FINER , STR_ , exception ) ; } }
public String stringValue ( ) { Object cv = Assert . checkNonNull ( constValue ( ) ) ; return cv . toString ( ) ; }
public Date parseDate ( String str ) { try { return dateFormat . parse ( str ) ; } catch ( java . text . ParseException e ) { throw new RuntimeException ( e ) ; } }
default int hash32 ( String value ) { return hash32 ( value . getBytes ( ) ) ; }
public Name addAll ( Name suffix ) throws InvalidNameException { return addAll ( size ( ) , suffix ) ; }
public final InputStream asInputStream ( ) throws UnknownResourceException { return toInputStream ( ) ; }
public static FileDescriptor createSocket ( ) throws IOException { if ( ! isSupported ) throw new UnsupportedOperationException ( STR_ ) ; int fdVal = create0 ( ) ; FileDescriptor fd = new FileDescriptor ( ) ; fdAccess . set ( fd , fdVal ) ; return fd ; }
public static Grammar doTheMerges ( Grammar grammar , Lexicon lexicon , boolean [ ] [ ] [ ] mergeThesePairs , double [ ] [ ] mergeWeights ) { short [ ] numSubStatesArray = grammar . numSubStates ; short [ ] newNumSubStatesArray = grammar . numSubStates ; Grammar newGrammar = null ; while ( BOOL_ ) { boolean somethingToMerge = BOOL_ ; for ( int tag = NUM_ ; tag < numSubStatesArray . length ; tag ++ ) { for ( int i = NUM_ ; i < newNumSubStatesArray [ tag ] ; i ++ ) { for ( int j = NUM_ ; j < newNumSubStatesArray [ tag ] ; j ++ ) { somethingToMerge = somethingToMerge || mergeThesePairs [ tag ] [ i ] [ j ] ; } } } if ( ! somethingToMerge ) break ; boolean [ ] [ ] [ ] mergeThisIteration = new boolean [ newNumSubStatesArray . length ] [ ] [ ] ; for ( int tag = NUM_ ; tag < numSubStatesArray . length ; tag ++ ) { mergeThisIteration [ tag ] = new boolean [ mergeThesePairs [ tag ] . length ] [ mergeThesePairs [ tag ] . length ] ; for ( int i = NUM_ ; i < mergeThesePairs [ tag ] . length ; i ++ ) { for ( int j = NUM_ ; j < mergeThesePairs [ tag ] . length ; j ++ ) { mergeThisIteration [ tag ] [ i ] [ j ] = mergeThesePairs [ tag ] [ i ] [ j ] ; } } } for ( int tag = NUM_ ; tag < numSubStatesArray . length ; tag ++ ) { boolean [ ] alreadyDecidedToMerge = new boolean [ mergeThesePairs [ tag ] . length ] ; for ( int i = NUM_ ; i < mergeThesePairs [ tag ] . length ; i ++ ) { for ( int j = NUM_ ; j < mergeThesePairs [ tag ] . length ; j ++ ) { if ( alreadyDecidedToMerge [ i ] || alreadyDecidedToMerge [ j ] ) mergeThisIteration [ tag ] [ i ] [ j ] = BOOL_ ; alreadyDecidedToMerge [ i ] = alreadyDecidedToMerge [ i ] || mergeThesePairs [ tag ] [ i ] [ j ] ; alreadyDecidedToMerge [ j ] = alreadyDecidedToMerge [ j ] || mergeThesePairs [ tag ] [ i ] [ j ] ; } } } for ( int tag = NUM_ ; tag < numSubStatesArray . length ; tag ++ ) { for ( int i = NUM_ ; i < mergeThesePairs [ tag ] . length ; i ++ ) { for ( int j = NUM_ ; j < mergeThesePairs [ tag ] . length ; j ++ ) { mergeThesePairs [ tag ] [ i ] [ j ] = mergeThesePairs [ tag ] [ i ] [ j ] && ! mergeThisIteration [ tag ] [ i ] [ j ] ; } } } newGrammar = grammar . mergeStates ( mergeThisIteration , mergeWeights ) ; lexicon . mergeStates ( mergeThisIteration , mergeWeights ) ; grammar . fixMergeWeightsEtc ( mergeThesePairs , mergeWeights , mergeThisIteration ) ; grammar = newGrammar ; newNumSubStatesArray = grammar . numSubStates ; } grammar . makeCRArrays ( ) ; return grammar ; }
private static void extractFile ( ZipInputStream zipIn , String filePath ) throws IOException { BufferedOutputStream bos = new BufferedOutputStream ( new FileOutputStream ( filePath ) ) ; byte [ ] bytesIn = new byte [ BUFFER_SIZE ] ; int read = NUM_ ; while ( ( read = zipIn . read ( bytesIn ) ) != - NUM_ ) { bos . write ( bytesIn , NUM_ , read ) ; } bos . close ( ) ; }
public static final String squareToString ( int square ) { StringBuilder ret = new StringBuilder ( ) ; int x = Position . getX ( square ) ; int y = Position . getY ( square ) ; ret . append ( ( char ) ( x + STR_ ) ) ; ret . append ( ( char ) ( y + STR_ ) ) ; return ret . toString ( ) ; }
protected void drawVerticalItem ( Graphics2D g2 , CategoryItemRendererState state , Rectangle2D dataArea , CategoryPlot plot , CategoryAxis domainAxis , ValueAxis rangeAxis , StatisticalCategoryDataset dataset , int visibleRow , int row , int column ) { double rectX = calculateBarW0 ( plot , PlotOrientation . VERTICAL , dataArea , domainAxis , state , visibleRow , column ) ; Number meanValue = dataset . getMeanValue ( row , column ) ; if ( meanValue == null ) { return ; } double value = meanValue . doubleValue ( ) ; double base = NUM_ ; double lclip = getLowerClip ( ) ; double uclip = getUpperClip ( ) ; if ( uclip <= NUM_ ) { if ( value >= uclip ) { return ; } base = uclip ; if ( value <= lclip ) { value = lclip ; } } else if ( lclip <= NUM_ ) { if ( value >= uclip ) { value = uclip ; } else { if ( value <= lclip ) { value = lclip ; } } } else { if ( value <= lclip ) { return ; } base = getLowerClip ( ) ; if ( value >= uclip ) { value = uclip ; } } RectangleEdge yAxisLocation = plot . getRangeAxisEdge ( ) ; double transY1 = rangeAxis . valueToJava2D ( base , dataArea , yAxisLocation ) ; double transY2 = rangeAxis . valueToJava2D ( value , dataArea , yAxisLocation ) ; double rectY = Math . min ( transY2 , transY1 ) ; double rectWidth = state . getBarWidth ( ) ; double rectHeight = Math . abs ( transY2 - transY1 ) ; Rectangle2D bar = new Rectangle2D . Double ( rectX , rectY , rectWidth , rectHeight ) ; Paint itemPaint = getItemPaint ( row , column ) ; GradientPaintTransformer t = getGradientPaintTransformer ( ) ; if ( t != null && itemPaint instanceof GradientPaint ) { itemPaint = t . transform ( ( GradientPaint ) itemPaint , bar ) ; } g2 . setPaint ( itemPaint ) ; g2 . fill ( bar ) ; if ( isDrawBarOutline ( ) && state . getBarWidth ( ) > BAR_OUTLINE_WIDTH_THRESHOLD ) { Stroke stroke = getItemOutlineStroke ( row , column ) ; Paint paint = getItemOutlinePaint ( row , column ) ; if ( stroke != null && paint != null ) { g2 . setStroke ( stroke ) ; g2 . setPaint ( paint ) ; g2 . draw ( bar ) ; } } Number n = dataset . getStdDevValue ( row , column ) ; if ( n != null ) { double valueDelta = n . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) + valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) - valueDelta , dataArea , yAxisLocation ) ; if ( this . errorIndicatorPaint != null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemOutlinePaint ( row , column ) ) ; } if ( this . errorIndicatorStroke != null ) { g2 . setStroke ( this . errorIndicatorStroke ) ; } else { g2 . setStroke ( getItemOutlineStroke ( row , column ) ) ; } Line2D line ; line = new Line2D . Double ( rectX + rectWidth / NUM_ , lowVal , rectX + rectWidth / NUM_ , highVal ) ; g2 . draw ( line ) ; line = new Line2D . Double ( rectX + rectWidth / NUM_ - NUM_ , highVal , rectX + rectWidth / NUM_ + NUM_ , highVal ) ; g2 . draw ( line ) ; line = new Line2D . Double ( rectX + rectWidth / NUM_ - NUM_ , lowVal , rectX + rectWidth / NUM_ + NUM_ , lowVal ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; if ( generator != null && isItemLabelVisible ( row , column ) ) { drawItemLabel ( g2 , dataset , row , column , plot , generator , bar , ( value < NUM_ ) ) ; } EntityCollection entities = state . getEntityCollection ( ) ; if ( entities != null ) { addItemEntity ( entities , dataset , row , column , bar ) ; } }
public static boolean hasValidCover ( IGame game , Coords pos , int elevation ) { if ( ( pos == null ) || ( elevation > NUM_ ) ) { return BOOL_ ; } boolean hasMovedEntity = BOOL_ ; for ( Entity e : game . getEntitiesVector ( pos ) ) { if ( e . isDone ( ) && ! ( e instanceof Infantry ) && ( e . getElevation ( ) == elevation ) ) { hasMovedEntity = BOOL_ ; break ; } } if ( ! hasMovedEntity ) { Enumeration < Entity > wrecks = game . getWreckedEntities ( ) ; while ( wrecks . hasMoreElements ( ) ) { Entity e = wrecks . nextElement ( ) ; if ( pos . equals ( e . getPosition ( ) ) && ! ( e instanceof Infantry ) ) { hasMovedEntity = BOOL_ ; } } } return hasMovedEntity ; }
public void addGroup ( GroupConfigInterface subGroup ) { subGroupList . add ( subGroup ) ; }
public void startScanning ( final BeaconServiceConnection serviceConnection ) { final Cursor cursor = mDatabaseHelper . getAllRegions ( ) ; while ( cursor . moveToNext ( ) ) { final UUID uuid = UUID . fromString ( cursor . getString ( NUM_ ) ) ; final int major = cursor . getInt ( NUM_ ) ; final int minor = cursor . getInt ( NUM_ ) ; final int event = cursor . getInt ( NUM_ ) ; serviceConnection . startRangingBeaconsInRegion ( BeaconsFragment . BEACON_COMPANY_ID , uuid , major , minor , this ) ; if ( event == BeaconContract . EVENT_IN_RANGE || event == BeaconContract . EVENT_OUT_OF_RANGE ) serviceConnection . startMonitoringForRegion ( BeaconsFragment . BEACON_COMPANY_ID , uuid , major , minor , this ) ; } }
public void testDivideRoundHalfDownNeg1 ( ) { String a = STR_ ; int aScale = - NUM_ ; String b = STR_ ; int bScale = NUM_ ; String c = STR_ ; int resScale = - NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal bNumber = new BigDecimal ( new BigInteger ( b ) , bScale ) ; BigDecimal result = aNumber . divide ( bNumber , resScale , BigDecimal . ROUND_HALF_DOWN ) ; assertEquals ( STR_ , c , result . toString ( ) ) ; assertEquals ( STR_ , resScale , result . scale ( ) ) ; }
public static boolean isHeader ( Header hdr ) { return hdr . getBooleanValue ( ZIMAGE , BOOL_ ) ; }
public static InfoRegister createFolder ( User user , Integer bookId , List atts , List inter , Map documents , String entidad , boolean consolidacion ) throws ValidationException , SecurityException , BookException , SessionException , TecDocException , ParseException , AttributesException { InfoRegister result = new InfoRegister ( ) ; String sessionID = new String ( ) ; try { sessionID = Login . login ( user , entidad ) ; setOfficeUserRegister ( entidad , sessionID , atts ) ; BookSession . openBook ( sessionID , bookId , entidad ) ; Integer launchDistOutRegister = RegisterServicesUtil . getInvesConfActions ( entidad ) ; RegisterServicesUtil . canCreateFolder ( sessionID , bookId , documents , user , atts , entidad , consolidacion ) ; AxSf axsfQ = BookSession . getFormFormat ( sessionID , bookId , entidad ) ; FieldFormat fieldFormat = RegisterServicesUtil . getFieldFormat ( sessionID , bookId ) ; Map translatedIds = RegisterServicesUtil . getFieldsWithSustitute ( atts , axsfQ , sessionID , bookId , entidad ) ; AxSf newAxSF = RegisterServicesUtil . initInOrOutFolder ( user , axsfQ ) ; newAxSF = RegisterServicesUtil . completeFolder ( translatedIds , axsfQ , newAxSF , user . getLocale ( ) , atts , fieldFormat , consolidacion ) ; FolderDataSession data = Register . createNewFolder ( sessionID , bookId , newAxSF , inter , documents , launchDistOutRegister , user . getLocale ( ) , entidad , consolidacion ) ; result = ConsultRegister . consultRegisterInfo ( bookId , data . getAxsfNew ( ) , data . getNewRegisterID ( ) , data . getScrofic ( ) , data . getUserName ( ) , user . getLocale ( ) ) ; } finally { BookSession . closeBook ( sessionID , bookId ) ; SecuritySession . logout ( sessionID , entidad ) ; } return result ; }
public void close ( ) throws IOException { fInputStream . close ( ) ; }
private void handleSubscriptionError ( AzureAllocationContext ctx , String namespace , Throwable e ) { if ( e instanceof CloudException ) { CloudException ce = ( CloudException ) e ; CloudError body = ce . getBody ( ) ; if ( body != null ) { String code = body . getCode ( ) ; if ( MISSING_SUBSCRIPTION_CODE . equals ( code ) ) { registerSubscription ( ctx , namespace ) ; return ; } } } handleError ( ctx , e ) ; }
public boolean hasShutdownHook ( Runnable shutdownHook ) { return hooks . contains ( shutdownHook ) ; }
@ Override public void endProcessSubTokens ( ) { if ( ! skey . isEmpty ( ) ) { map . put ( skey , sval ) ; skey = STR_ ; sval = STR_ ; } }
private void heapifyDown ( Comparable < Object > cur ) { final int stop = size > > > NUM_ ; int twopos = NUM_ ; while ( twopos < stop ) { int bestchild = ( twopos << NUM_ ) + NUM_ ; Comparable < Object > best = twoheap [ bestchild ] ; final int right = bestchild + NUM_ ; if ( right < size && best . compareTo ( twoheap [ right ] ) > NUM_ ) { bestchild = right ; best = twoheap [ right ] ; } if ( cur . compareTo ( best ) <= NUM_ ) { break ; } twoheap [ twopos ] = best ; twopos = bestchild ; } twoheap [ twopos ] = cur ; }
public void addFeature ( IFeatureVector fv ) { idxList . addAll ( Ints . asList ( fv . getIndices ( ) ) ) ; valList . addAll ( Floats . asList ( fv . getValues ( ) ) ) ; }
protected void waitForExternalStoreMount ( ) throws Exception { String extStorageState = Environment . getExternalStorageState ( ) ; int currentWaitTime = NUM_ ; while ( ! extStorageState . equals ( Environment . MEDIA_MOUNTED ) ) { Log . i ( LOG_TAG , STR_ ) ; currentWaitTime = timeoutWait ( currentWaitTime , DEFAULT_WAIT_POLL_TIME , DEFAULT_MAX_WAIT_TIME , STR_ ) ; extStorageState = Environment . getExternalStorageState ( ) ; } }
public static DataDisplayTable listGlyphDimensionBounds ( Font font ) { String [ ] header = { STR_ , STR_ } ; Align [ ] displayAlignment = { Align . Left , Align . Right } ; DataDisplayTable table = new DataDisplayTable ( Arrays . asList ( header ) ) ; table . setAlignment ( Arrays . asList ( displayAlignment ) ) ; LocaTable locaTable = FontUtils . getLocaTable ( font ) ; GlyphTable glyfTable = FontUtils . getGlyphTable ( font ) ; int xMin = Integer . MAX_VALUE ; int yMin = Integer . MAX_VALUE ; int xMax = Integer . MIN_VALUE ; int yMax = Integer . MIN_VALUE ; for ( int i = NUM_ ; i < locaTable . numGlyphs ( ) ; i ++ ) { Glyph glyph = glyfTable . glyph ( locaTable . glyphOffset ( i ) , locaTable . glyphLength ( i ) ) ; if ( glyph . xMin ( ) < xMin ) { xMin = glyph . xMin ( ) ; } if ( glyph . yMin ( ) < yMin ) { yMin = glyph . yMin ( ) ; } if ( glyph . xMax ( ) > xMax ) { xMax = glyph . xMax ( ) ; } if ( glyph . yMax ( ) > yMax ) { yMax = glyph . yMax ( ) ; } } table . add ( Arrays . asList ( new String [ ] { STR_ , String . format ( STR_ , xMin ) } ) ) ; table . add ( Arrays . asList ( new String [ ] { STR_ , String . format ( STR_ , xMax ) } ) ) ; table . add ( Arrays . asList ( new String [ ] { STR_ , String . format ( STR_ , yMin ) } ) ) ; table . add ( Arrays . asList ( new String [ ] { STR_ , String . format ( STR_ , yMax ) } ) ) ; return table ; }
private boolean isInThumbRange ( float touchX , double normalizedThumbValue ) { return Math . abs ( touchX - normalizedToScreen ( normalizedThumbValue ) ) <= thumbHalfWidth ; }
public static byte [ ] str2UnicodeByteArray ( final JBBPByteOrder byteOrder , final String str ) { final byte [ ] result = new byte [ str . length ( ) << NUM_ ] ; int index = NUM_ ; for ( int i = NUM_ ; i < str . length ( ) ; i ++ ) { final int val = str . charAt ( i ) ; switch ( byteOrder ) { case BIG_ENDIAN : { result [ index ++ ] = ( byte ) ( val > > NUM_ ) ; result [ index ++ ] = ( byte ) val ; } break ; case LITTLE_ENDIAN : { result [ index ++ ] = ( byte ) val ; result [ index ++ ] = ( byte ) ( val > > NUM_ ) ; } break ; default : throw new Error ( STR_ + byteOrder + STR_ ) ; } } return result ; }
private MethodDef parse_method ( StrTok st ) { String method_name = st . need_word ( ) ; st . need ( STR_ ) ; ArrayList < String > args = new ArrayList < > ( ) ; String tok = st . nextToken ( ) ; if ( tok != STR_ ) { st . pushBack ( ) ; do { tok = st . need_word ( ) ; args . add ( tok ) ; } while ( st . nextToken ( ) == STR_ ) ; st . pushBack ( ) ; st . need ( STR_ ) ; } Type [ ] targs = new Type [ args . size ( ) ] ; for ( int ii = NUM_ ; ii < args . size ( ) ; ii ++ ) { targs [ ii ] = BCELUtil . classname_to_type ( args . get ( ii ) ) ; } return new MethodDef ( method_name , targs ) ; }
private void writeExperiecedAndCausingPersonDelay ( ) { SortedMap < Double , Map < Id < Person > , Double > > timeBin2AffectedPerson2Delay = getExperiencedPersonDelay ( NUM_ ) ; SortedMap < Double , Map < Id < Person > , Double > > timeBin2CausingPerson2Delay = getCausingPersonDelay ( NUM_ ) ; if ( timeBin2AffectedPerson2Delay . size ( ) != NUM_ ) throw new RuntimeException ( STR_ ) ; Map < Id < Person > , Double > affectedperson2Delay = timeBin2AffectedPerson2Delay . get ( simulationEndTime ) ; Map < Id < Person > , Double > causedPerson2Delay = timeBin2CausingPerson2Delay . get ( simulationEndTime ) ; BufferedWriter writer = IOUtils . getBufferedWriter ( runDir + STR_ + pricingScenario + suffixForSoring + STR_ ) ; try { writer . write ( STR_ ) ; for ( Id < Person > id : causedPerson2Delay . keySet ( ) ) { writer . write ( id + STR_ + pf . getMunichUserGroupFromPersonId ( id ) + STR_ + affectedperson2Delay . get ( id ) / NUM_ + STR_ + causedPerson2Delay . get ( id ) / NUM_ + STR_ ) ; } writer . close ( ) ; } catch ( Exception e ) { throw new RuntimeException ( STR_ + e ) ; } }
static List < List < File > > partition ( final int binCount , final File ... files ) { final File [ ] sort = Arrays . copyOf ( files , files . length ) ; return binThem ( binCount , sort ) ; }
private boolean zzRefill ( ) throws java . io . IOException { if ( zzStartRead > NUM_ ) { System . arraycopy ( zzBuffer , zzStartRead , zzBuffer , NUM_ , zzEndRead - zzStartRead ) ; zzEndRead -= zzStartRead ; zzCurrentPos -= zzStartRead ; zzMarkedPos -= zzStartRead ; zzPushbackPos -= zzStartRead ; zzStartRead = NUM_ ; } if ( zzCurrentPos >= zzBuffer . length ) { char newBuffer [ ] = new char [ zzCurrentPos . NUM_ ] ; System . arraycopy ( zzBuffer , NUM_ , newBuffer , NUM_ , zzBuffer . length ) ; zzBuffer = newBuffer ; } int numRead = zzReader . read ( zzBuffer , zzEndRead , zzBuffer . length - zzEndRead ) ; if ( numRead < NUM_ ) { return BOOL_ ; } else { zzEndRead += numRead ; return BOOL_ ; } }
private void updateBusinessObjectDefinitionEntityDescriptiveInformation ( BusinessObjectDefinitionEntity businessObjectDefinitionEntity , BusinessObjectDefinitionDescriptiveInformationUpdateRequest request ) { businessObjectDefinitionEntity . setDescription ( request . getDescription ( ) ) ; businessObjectDefinitionEntity . setDisplayName ( request . getDisplayName ( ) ) ; businessObjectDefinitionDao . saveAndRefresh ( businessObjectDefinitionEntity ) ; }
@ Override public void onDownloadProgress ( DownloadProgressInfo progress ) { mAverageSpeed . setText ( getString ( R . string . kilobytes_per_second , Helpers . getSpeedString ( progress . mCurrentSpeed ) ) ) ; mTimeRemaining . setText ( getString ( R . string . time_remaining , Helpers . getTimeRemaining ( progress . mTimeRemaining ) ) ) ; progress . mOverallTotal = progress . mOverallTotal ; mPB . setMax ( ( int ) ( progress . mOverallTotal > > NUM_ ) ) ; mPB . setProgress ( ( int ) ( progress . mOverallProgress > > NUM_ ) ) ; mProgressPercent . setText ( Long . toString ( progress . mOverallProgress . NUM_ / progress . mOverallTotal ) + STR_ ) ; mProgressFraction . setText ( Helpers . getDownloadProgressString ( progress . mOverallProgress , progress . mOverallTotal ) ) ; }
static public boolean isSameDay ( Timestamp one , Timestamp two ) { GregorianCalendar calOne = new GregorianCalendar ( ) ; if ( one != null ) calOne . setTimeInMillis ( one . getTime ( ) ) ; GregorianCalendar calTwo = new GregorianCalendar ( ) ; if ( two != null ) calTwo . setTimeInMillis ( two . getTime ( ) ) ; if ( calOne . get ( Calendar . YEAR ) == calTwo . get ( Calendar . YEAR ) && calOne . get ( Calendar . MONTH ) == calTwo . get ( Calendar . MONTH ) && calOne . get ( Calendar . DAY_OF_MONTH ) == calTwo . get ( Calendar . DAY_OF_MONTH ) ) return BOOL_ ; return BOOL_ ; }
public static void updateAllForFacade ( DataStore dataStore , Iterable < Update > updates ) { updateAllForFacade ( dataStore , updates . iterator ( ) ) ; }
public ArrayFieldVector ( FieldVector < T > v1 , FieldVector < T > v2 ) throws NullArgumentException { MathUtils . checkNotNull ( v1 ) ; MathUtils . checkNotNull ( v2 ) ; field = v1 . getField ( ) ; final T [ ] v1Data = ( v1 instanceof ArrayFieldVector ) ? ( ( ArrayFieldVector < T > ) v1 ) . data : v1 . toArray ( ) ; final T [ ] v2Data = ( v2 instanceof ArrayFieldVector ) ? ( ( ArrayFieldVector < T > ) v2 ) . data : v2 . toArray ( ) ; data = MathArrays . buildArray ( field , v1Data . length + v2Data . length ) ; System . arraycopy ( v1Data , NUM_ , data , NUM_ , v1Data . length ) ; System . arraycopy ( v2Data , NUM_ , data , v1Data . length , v2Data . length ) ; }
public boolean equals ( Object o ) { if ( o instanceof ServiceConfigManager ) { ServiceConfigManager oscm = ( ServiceConfigManager ) o ; if ( serviceName . equals ( oscm . serviceName ) && version . equals ( oscm . version ) ) { return ( BOOL_ ) ; } } return ( BOOL_ ) ; }
public void addItemBoundsListener ( ItemBoundsListener ibl ) { if ( m_bounders == null ) m_bounders = new CopyOnWriteArrayList ( ) ; m_bounders . add ( ibl ) ; }
public static S2CellId fromFaceIJ ( int face , int i , int j ) { long n [ ] = { NUM_ , face << ( POS_BITS - NUM_ ) } ; int bits = ( face & SWAP_MASK ) ; for ( int k = NUM_ ; k >= NUM_ ; -- k ) { bits = getBits ( n , i , j , k , bits ) ; } S2CellId s = new S2CellId ( ( ( ( n [ NUM_ ] << NUM_ ) + n [ NUM_ ] ) << NUM_ ) + NUM_ ) ; return s ; }
public void increaseDpi ( ) { if ( this . currentDpiPos < ( this . dpiSizes . length - NUM_ ) ) { ++ this . currentDpiPos ; } }
StringVector processPREFIX_URLLIST ( StylesheetHandler handler , String uri , String name , String rawName , String value ) throws org . xml . sax . SAXException { StringTokenizer tokenizer = new StringTokenizer ( value , STR_ ) ; int nStrings = tokenizer . countTokens ( ) ; StringVector strings = new StringVector ( nStrings ) ; for ( int i = NUM_ ; i < nStrings ; i ++ ) { String prefix = tokenizer . nextToken ( ) ; String url = handler . getNamespaceForPrefix ( prefix ) ; if ( url != null ) strings . addElement ( url ) ; else throw new org . xml . sax . SAXException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CANT_RESOLVE_NSPREFIX , new Object [ ] { prefix } ) ) ; } return strings ; }
@ Override public void write ( DataOutput out ) throws IOException { out . writeLong ( duration ) ; out . writeInt ( getLength ( ) ) ; for ( int i = NUM_ ; i < coeffs . length ; i ++ ) { out . writeFloat ( coeffs [ i ] ) ; } }
private void addSharingProfiles ( Collection < SharingProfile > sharingProfiles ) throws GuacamoleException { for ( SharingProfile sharingProfile : sharingProfiles ) { String primaryConnectionIdentifier = sharingProfile . getPrimaryConnectionIdentifier ( ) ; APIConnection primaryConnection = retrievedConnections . get ( primaryConnectionIdentifier ) ; if ( primaryConnection != null ) { Collection < APISharingProfile > children = primaryConnection . getSharingProfiles ( ) ; if ( children == null ) { children = new ArrayList < APISharingProfile > ( ) ; primaryConnection . setSharingProfiles ( children ) ; } children . add ( new APISharingProfile ( sharingProfile ) ) ; } else logger . debug ( STR_ + STR_ + STR_ , sharingProfile . getIdentifier ( ) , primaryConnectionIdentifier ) ; } }
public void failoverCopy ( RPCopyRequestParams copyToFailoverTo ) throws RecoverPointException { String bookmarkName = copyToFailoverTo . getBookmarkName ( ) ; Date apitTime = copyToFailoverTo . getApitTime ( ) ; if ( bookmarkName != null ) { logger . info ( STR_ + bookmarkName ) ; } else if ( apitTime != null ) { logger . info ( STR_ + apitTime . toString ( ) ) ; } else { logger . info ( STR_ ) ; } RecoverPointImageManagementUtils imageManager = new RecoverPointImageManagementUtils ( ) ; imageManager . enableCopyImage ( functionalAPI , copyToFailoverTo , BOOL_ ) ; }
private static void prepareLoggingSystemEnviroment ( ) { System . setProperty ( STR_ , getLogFolder ( ) ) ; }
public StateAttribute ( byte [ ] octets ) { super ( octets ) ; state = new String ( octets , NUM_ , octets . length - NUM_ , Charset . forName ( STR_ ) ) ; }
private static long calcSize ( long size , long skip , long limit ) { return size >= NUM_ ? Math . max ( - NUM_ , Math . min ( size - skip , limit ) ) : - NUM_ ; }
public static Collection < InetSocketAddress > resolveAddresses ( AddressResolver addrRslvr , Iterable < String > addrs , int port ) throws IgniteSpiException { assert addrRslvr != null ; Collection < InetSocketAddress > extAddrs = new HashSet < > ( ) ; for ( String addr : addrs ) { InetSocketAddress sockAddr = new InetSocketAddress ( addr , port ) ; if ( ! sockAddr . isUnresolved ( ) ) { Collection < InetSocketAddress > extAddrs0 = resolveAddress ( addrRslvr , sockAddr ) ; if ( extAddrs0 != null ) extAddrs . addAll ( extAddrs0 ) ; } } return extAddrs ; }
private double sampleFromGamma ( double k , double theta ) { boolean accept = BOOL_ ; if ( k < NUM_ ) { double c = ( NUM_ / k ) ; double d = ( ( NUM_ - k ) . Math . pow ( k , ( k / ( NUM_ - k ) ) ) ) ; double u , v , z , e , x ; do { u = rng . nextDouble ( ) ; v = rng . nextDouble ( ) ; z = - Math . log ( u ) ; e = - Math . log ( v ) ; x = Math . pow ( z , c ) ; if ( ( z + e ) >= ( d + x ) ) { accept = BOOL_ ; } } while ( ! accept ) ; return ( x . theta ) ; } else { double b = ( k - Math . log ( NUM_ ) ) ; double c = ( k + Math . sqrt ( NUM_ . k - NUM_ ) ) ; double lam = Math . sqrt ( NUM_ . k - NUM_ ) ; double cheng = ( NUM_ + Math . log ( NUM_ ) ) ; double u , v , x , y , z , r ; do { u = rng . nextDouble ( ) ; v = rng . nextDouble ( ) ; y = ( ( NUM_ / lam ) . Math . log ( v / ( NUM_ - v ) ) ) ; x = ( k . Math . exp ( y ) ) ; z = ( u . v . v ) ; r = ( b + ( c . y ) - x ) ; if ( ( r >= ( ( NUM_ . z ) - cheng ) ) || ( r >= Math . log ( z ) ) ) { accept = BOOL_ ; } } while ( ! accept ) ; return ( x . theta ) ; } }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
public BlocklyController build ( ) { if ( mViewFactory == null && ( mWorkspaceFragment != null || mTrashFragment != null || mToolboxFragment != null || mToolboxDrawer != null ) ) { throw new IllegalStateException ( STR_ ) ; } if ( mWorkspaceHelper == null ) { mWorkspaceHelper = new WorkspaceHelper ( mContext ) ; } BlockFactory factory = new BlockFactory ( mContext , null ) ; for ( int i = NUM_ ; i < mBlockDefResources . size ( ) ; i ++ ) { try { factory . addBlocks ( mBlockDefResources . get ( i ) ) ; } catch ( Throwable e ) { factory . clear ( ) ; throw e ; } } for ( int i = NUM_ ; i < mBlockDefAssets . size ( ) ; i ++ ) { String assetPath = mBlockDefAssets . get ( i ) ; try { factory . addBlocks ( mAssetManager . open ( assetPath ) ) ; } catch ( IOException e ) { factory . clear ( ) ; throw new IllegalStateException ( STR_ + assetPath , e ) ; } } for ( int i = NUM_ ; i < mBlockDefs . size ( ) ; i ++ ) { factory . addBlockTemplate ( mBlockDefs . get ( i ) ) ; } BlocklyController controller = new BlocklyController ( mContext , factory , mWorkspaceHelper , mViewFactory ) ; if ( mToolboxResId != NUM_ ) { controller . loadToolboxContents ( mToolboxResId ) ; } else if ( mToolboxXml != null ) { controller . loadToolboxContents ( mToolboxXml ) ; } else if ( mToolboxAssetId != null && mAssetManager != null ) { try { controller . loadToolboxContents ( mAssetManager . open ( mToolboxAssetId ) ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( STR_ + mToolboxAssetId , e ) ; } } controller . setWorkspaceFragment ( mWorkspaceFragment ) ; controller . setTrashFragment ( mTrashFragment ) ; controller . setToolboxFragment ( mToolboxFragment ) ; controller . setTrashIcon ( mTrashIcon ) ; controller . setVariableCallback ( mVariableCallback ) ; return controller ; }
@ Override public void run ( ) { while ( ! isInterrupted ( ) ) { try { KeyHolder < K > ref = ( KeyHolder < K > ) _queue . remove ( ) ; V removed = _table . remove ( ref ) ; if ( _listener != null && removed != null ) _listener . weakEntryRemoved ( removed ) ; } catch ( InterruptedException e ) { interrupt ( ) ; break ; } } }
public JobDefinitionCreateRequest createJobDefinitionCreateRequest ( String namespaceCd , String jobName , String jobDescription , String activitiXml , List < Parameter > parameters ) { JobDefinitionCreateRequest request = new JobDefinitionCreateRequest ( ) ; request . setNamespace ( namespaceCd ) ; request . setJobName ( jobName ) ; request . setDescription ( jobDescription ) ; request . setActivitiJobXml ( activitiXml ) ; request . setParameters ( parameters ) ; return request ; }
public TabState restoreTabState ( int tabId , boolean encrypted ) { return TabState . restoreTabState ( getTabStateFile ( tabId , encrypted ) , encrypted ) ; }
public FTPClient ( ) { addListParser ( new UnixListParser ( ) ) ; addListParser ( new DOSListParser ( ) ) ; addListParser ( new EPLFListParser ( ) ) ; addListParser ( new NetWareListParser ( ) ) ; addListParser ( new MLSDListParser ( ) ) ; }
public String addExtension ( String testFileName ) { return testFileName + STR_ ; }
public < T > String makeStringValueSQ ( T value ) { return value . toString ( ) ; }
private Level descriptionToLogLevel ( String description ) { Level result = Level . OFF ; if ( description . equals ( s_logger . localizeMessage ( STR_ ) ) ) { result = Level . OFF ; } else if ( description . equals ( s_logger . localizeMessage ( STR_ ) ) ) { result = Level . SEVERE ; } else if ( description . equals ( s_logger . localizeMessage ( STR_ ) ) ) { result = Level . WARNING ; } else if ( description . equals ( s_logger . localizeMessage ( STR_ ) ) ) { result = Level . INFO ; } else if ( description . equals ( s_logger . localizeMessage ( STR_ ) ) ) { result = Level . CONFIG ; } else if ( description . equals ( s_logger . localizeMessage ( STR_ ) ) ) { result = Level . FINE ; } else if ( description . equals ( s_logger . localizeMessage ( STR_ ) ) ) { result = Level . FINER ; } else if ( description . equals ( s_logger . localizeMessage ( STR_ ) ) ) { result = Level . FINEST ; } else if ( description . equals ( s_logger . localizeMessage ( STR_ ) ) ) { result = Level . ALL ; } return result ; }
default boolean isImmutable ( ) { return BOOL_ ; }
public long renew ( String entryUid , String className , int objectType , long duration , boolean fromReplication , boolean origin , boolean isFromGateway ) throws UnknownLeaseException , InternalSpaceException { try { extendLeasePeriod ( entryUid , className , objectType , duration , fromReplication , origin , BOOL_ , null , isFromGateway ) ; } catch ( UnknownLeaseException unknownLeaseException ) { if ( _cacheManager . isCacheExternalDB ( ) && objectType != ObjectTypes . NOTIFY_NULL_TEMPLATE && objectType != ObjectTypes . NOTIFY_TEMPLATE ) { if ( _logger . isLoggable ( Level . FINE ) ) { _logger . log ( Level . FINE , STR_ , unknownLeaseException ) ; } } else throw unknownLeaseException ; } return duration ; }
public static void inRange ( final long value , final String name , final long minInclusive , final long maxInclusive ) { if ( value < minInclusive || value > maxInclusive ) { final String message = String . format ( STR_ , name , minInclusive , maxInclusive ) ; throw new IllegalArgumentException ( message ) ; } }
public Criteria or ( ) { Criteria criteria = createCriteriaInternal ( ) ; oredCriteria . add ( criteria ) ; return criteria ; }
public static File unzipToTempFolder ( File zipFile ) { String zipFilename = zipFile . getName ( ) ; String tempFolderPrefix = zipFilename . substring ( NUM_ , zipFilename . lastIndexOf ( STR_ ) ) ; File tempFolder = createTempFolder ( tempFolderPrefix ) ; try { PUZipUtils . unzip ( zipFile , tempFolder ) ; return tempFolder ; } catch ( Exception e ) { try { FileUtils . deleteFileOrDirectory ( tempFolder ) ; } catch ( RuntimeException ex ) { logger . debug ( STR_ + tempFolder , ex ) ; } throw new RuntimeException ( STR_ + zipFile + STR_ + tempFolder , e ) ; } }
public void testAscii ( ) throws Exception { String str = STR_ ; ByteArrayInputStream aa = new ByteArrayInputStream ( str . getBytes ( STR_ ) ) ; InputStreamReader a = new InputStreamReader ( aa , STR_ ) ; try { int x = a . read ( ) ; assertEquals ( STR_ , x ) ; char [ ] c = new char [ NUM_ ] ; x = a . read ( c , NUM_ , NUM_ ) ; assertEquals ( STR_ , a . getEncoding ( ) ) ; assertEquals ( NUM_ , x ) ; assertEquals ( STR_ , String . valueOf ( c ) ) ; } finally { a . close ( ) ; } }
public void clear ( ) { m_reducedResults . clear ( ) ; m_currentSearchIndex = NUM_ ; }
public static void createAccessorMethod ( SootMethod container , Stmt stmt ) { Body containerBody = container . getActiveBody ( ) ; soot . util . Chain containerStmts = containerBody . getUnits ( ) ; if ( ! containerStmts . contains ( stmt ) ) throw new RuntimeException ( ) ; if ( stmt . containsInvokeExpr ( ) ) { createInvokeAccessor ( container , stmt ) ; } else if ( stmt instanceof AssignStmt ) { AssignStmt as = ( AssignStmt ) stmt ; FieldRef ref ; if ( as . getLeftOp ( ) instanceof FieldRef ) { ref = ( FieldRef ) as . getLeftOp ( ) ; createSetAccessor ( container , as , ref ) ; } else if ( as . getRightOp ( ) instanceof FieldRef ) { ref = ( FieldRef ) as . getRightOp ( ) ; createGetAccessor ( container , as , ref ) ; } else { throw new RuntimeException ( STR_ ) ; } } else throw new RuntimeException ( STR_ ) ; }
@ Override public void displayChanged ( ) { updateGC ( ) ; }
public final void pushPair ( Node v1 , Node v2 ) { if ( null == m_map ) { m_map = new Node [ m_blocksize ] ; m_mapSize = m_blocksize ; } else { if ( ( m_firstFree + NUM_ ) >= m_mapSize ) { m_mapSize += m_blocksize ; Node newMap [ ] = new Node [ m_mapSize ] ; System . arraycopy ( m_map , NUM_ , newMap , NUM_ , m_firstFree ) ; m_map = newMap ; } } m_map [ m_firstFree ] = v1 ; m_map [ m_firstFree + NUM_ ] = v2 ; m_firstFree += NUM_ ; }
private static String escapeJSON ( String text ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( STR_ ) ; for ( int index = NUM_ ; index < text . length ( ) ; index ++ ) { char chr = text . charAt ( index ) ; switch ( chr ) { case STR_ : case STR_ : builder . append ( STR_ ) ; builder . append ( chr ) ; break ; case STR_ : builder . append ( STR_ ) ; break ; case STR_ : builder . append ( STR_ ) ; break ; case STR_ : builder . append ( STR_ ) ; break ; case STR_ : builder . append ( STR_ ) ; break ; default : if ( chr < STR_ ) { String t = STR_ + Integer . toHexString ( chr ) ; builder . append ( STR_ + t . substring ( t . length ( ) - NUM_ ) ) ; } else { builder . append ( chr ) ; } break ; } } builder . append ( STR_ ) ; return builder . toString ( ) ; }
final Segment < K , V > segmentFor ( int hash ) { return segments [ ( hash > > > segmentShift ) & segmentMask ] ; }
@ SuppressWarnings ( STR_ ) private void startSetTimeChanged ( ) { int hours = NUM_ ; int minutes = NUM_ ; try { hours = Integer . parseInt ( startHoursField . getText ( ) ) ; } catch ( Exception e ) { JOptionPane . showMessageDialog ( this , ( Bundle . getMessage ( STR_ ) + STR_ + e ) , Bundle . getMessage ( STR_ ) , JOptionPane . ERROR_MESSAGE ) ; log . error ( STR_ + e ) ; return ; } if ( ( hours < NUM_ ) || ( hours > NUM_ ) ) { JOptionPane . showMessageDialog ( this , ( Bundle . getMessage ( STR_ ) ) , Bundle . getMessage ( STR_ ) , JOptionPane . ERROR_MESSAGE ) ; return ; } try { minutes = Integer . parseInt ( startMinutesField . getText ( ) ) ; } catch ( Exception e ) { JOptionPane . showMessageDialog ( this , ( Bundle . getMessage ( STR_ ) + STR_ + e ) , Bundle . getMessage ( STR_ ) , JOptionPane . ERROR_MESSAGE ) ; log . error ( STR_ + e ) ; return ; } if ( ( minutes < NUM_ ) || ( minutes > NUM_ ) ) { JOptionPane . showMessageDialog ( this , ( Bundle . getMessage ( STR_ ) ) , Bundle . getMessage ( STR_ ) , JOptionPane . ERROR_MESSAGE ) ; return ; } long mSecPerHour = NUM_ ; long mSecPerMinute = NUM_ ; Date tem = clock . getTime ( ) ; int cHours = tem . getHours ( ) ; long cNumMSec = tem . getTime ( ) ; long nNumMSec = ( ( cNumMSec / mSecPerHour ) . mSecPerHour ) - ( cHours . mSecPerHour ) + ( hours . mSecPerHour ) + ( minutes . mSecPerMinute ) ; clock . setStartSetTime ( startSetTimeCheckBox . isSelected ( ) , new Date ( nNumMSec ) ) ; changed = BOOL_ ; }
public static String serialize ( Object toSerialize ) throws Exception { Class < ? > xstreamClass ; java . lang . reflect . Constructor < ? > constructor ; Object xstream ; Class < ? > [ ] serializeArgsClasses = new Class [ NUM_ ] ; Object [ ] serializeArgs = new Object [ NUM_ ] ; java . lang . reflect . Method methodSerialize ; String result ; xstreamClass = Class . forName ( STR_ ) ; constructor = xstreamClass . getConstructor ( ) ; xstream = constructor . newInstance ( ) ; serializeArgsClasses [ NUM_ ] = Object . class ; serializeArgs [ NUM_ ] = toSerialize ; methodSerialize = xstreamClass . getMethod ( STR_ , serializeArgsClasses ) ; try { result = ( String ) methodSerialize . invoke ( xstream , serializeArgs ) ; } catch ( Exception ex ) { result = null ; } return result ; }
@ Override public void release ( ) { super . release ( ) ; }
public void updateAndTestCounter ( OFMessage ofm , String type ) { validateCounter ( type , NUM_ ) ; counters . updateWriteStats ( ofm ) ; counters . updateWriteStats ( ofm ) ; counters . updateReadStats ( ofm ) ; counters . updateReadStats ( ofm ) ; validateCounter ( type , NUM_ ) ; }
public static < E > List < E > of ( ) { return Collections . emptyList ( ) ; }
protected void drawDomainCrosshair ( Graphics2D g2 , Rectangle2D dataArea , PlotOrientation orientation , int datasetIndex , Comparable rowKey , Comparable columnKey , Stroke stroke , Paint paint ) { CategoryDataset dataset = getDataset ( datasetIndex ) ; CategoryAxis axis = getDomainAxisForDataset ( datasetIndex ) ; CategoryItemRenderer renderer = getRenderer ( datasetIndex ) ; Line2D line ; if ( orientation == PlotOrientation . VERTICAL ) { double xx = renderer . getItemMiddle ( rowKey , columnKey , dataset , axis , dataArea , RectangleEdge . BOTTOM ) ; line = new Line2D . Double ( xx , dataArea . getMinY ( ) , xx , dataArea . getMaxY ( ) ) ; } else { double yy = renderer . getItemMiddle ( rowKey , columnKey , dataset , axis , dataArea , RectangleEdge . LEFT ) ; line = new Line2D . Double ( dataArea . getMinX ( ) , yy , dataArea . getMaxX ( ) , yy ) ; } g2 . setStroke ( stroke ) ; g2 . setPaint ( paint ) ; g2 . draw ( line ) ; }
@ Override public Table summary ( ) { Table table = Table . create ( STR_ + name ( ) ) ; CategoryColumn measure = CategoryColumn . create ( STR_ ) ; CategoryColumn value = CategoryColumn . create ( STR_ ) ; table . addColumn ( measure ) ; table . addColumn ( value ) ; measure . add ( STR_ ) ; value . add ( String . valueOf ( size ( ) ) ) ; measure . add ( STR_ ) ; value . add ( String . valueOf ( countMissing ( ) ) ) ; measure . add ( STR_ ) ; value . add ( String . valueOf ( min ( ) ) ) ; measure . add ( STR_ ) ; value . add ( String . valueOf ( max ( ) ) ) ; return table ; }
private Object js_parseFloat ( Object [ ] args ) { if ( args . length < NUM_ ) return ScriptRuntime . NaNobj ; String s = ScriptRuntime . toString ( args [ NUM_ ] ) ; int len = s . length ( ) ; int start = NUM_ ; char c ; for ( ; ; ) { if ( start == len ) { return ScriptRuntime . NaNobj ; } c = s . charAt ( start ) ; if ( ! ScriptRuntime . isStrWhiteSpaceChar ( c ) ) { break ; } ++ start ; } int i = start ; if ( c == STR_ || c == STR_ ) { ++ i ; if ( i == len ) { return ScriptRuntime . NaNobj ; } c = s . charAt ( i ) ; } if ( c == STR_ ) { if ( i + NUM_ <= len && s . regionMatches ( i , STR_ , NUM_ , NUM_ ) ) { double d ; if ( s . charAt ( start ) == STR_ ) { d = Double . NEGATIVE_INFINITY ; } else { d = Double . POSITIVE_INFINITY ; } return ScriptRuntime . wrapNumber ( d ) ; } return ScriptRuntime . NaNobj ; } int decimal = - NUM_ ; int exponent = - NUM_ ; boolean exponentValid = BOOL_ ; for ( ; i < len ; i ++ ) { switch ( s . charAt ( i ) ) { case STR_ : if ( decimal != - NUM_ ) break ; decimal = i ; continue ; case STR_ : case STR_ : if ( exponent != - NUM_ ) { break ; } else if ( i == len - NUM_ ) { break ; } exponent = i ; continue ; case STR_ : case STR_ : if ( exponent != i - NUM_ ) { break ; } else if ( i == len - NUM_ ) { -- i ; break ; } continue ; case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : if ( exponent != - NUM_ ) { exponentValid = BOOL_ ; } continue ; default : break ; } break ; } if ( exponent != - NUM_ && ! exponentValid ) { i = exponent ; } s = s . substring ( start , i ) ; try { return Double . valueOf ( s ) ; } catch ( NumberFormatException ex ) { return ScriptRuntime . NaNobj ; } }
public CVisibilityCriteriumPanel ( final CVisibilityCriterium criterium ) { super ( new BorderLayout ( ) ) ; visibilityCriterium = criterium ; visibilityStateBox . addActionListener ( visibilityStateBoxListener ) ; initPanel ( ) ; }
public boolean isAlterAdd ( ) { return columnsToAdd . size ( ) > NUM_ ; }
private boolean processRemovedNode ( final INaviViewNode node ) { if ( node instanceof INaviCodeNode ) { final INaviCodeNode cnode = ( INaviCodeNode ) node ; try { final INaviFunction targetFunction = cnode . getParentFunction ( ) ; if ( m_nodeCounter . containsKey ( targetFunction ) ) { final int newCounter = m_nodeCounter . get ( targetFunction ) - NUM_ ; if ( newCounter == NUM_ ) { m_nodeCounter . remove ( targetFunction ) ; final Set < CCrossReference > toDelete = new HashSet < CCrossReference > ( ) ; for ( final CCrossReference reference : m_crossReferences ) { if ( reference . getCalledFunction ( ) == targetFunction ) { toDelete . add ( reference ) ; } } m_crossReferences . removeAll ( toDelete ) ; return BOOL_ ; } else { m_nodeCounter . put ( targetFunction , newCounter ) ; } } } catch ( final MaybeNullException exception ) { } } return BOOL_ ; }
public long transferTo ( long position , long count , OutputStream dst ) throws IOException { return transferTo ( position , count , Channels . newChannel ( dst ) ) ; }
public void test_isLenient ( ) { DateFormat df = DateFormat . getInstance ( ) ; Calendar c = df . getCalendar ( ) ; if ( df . isLenient ( ) ) { try { c . set ( Calendar . DAY_OF_MONTH , NUM_ ) ; c . get ( Calendar . DAY_OF_MONTH ) ; } catch ( Exception e ) { fail ( STR_ + e . toString ( ) ) ; } c . setLenient ( BOOL_ ) ; try { c . set ( Calendar . DAY_OF_MONTH , NUM_ ) ; c . get ( Calendar . DAY_OF_MONTH ) ; fail ( STR_ ) ; } catch ( IllegalArgumentException e ) { } catch ( Exception e ) { fail ( STR_ + e . toString ( ) ) ; } } else { try { c . set ( Calendar . DAY_OF_MONTH , NUM_ ) ; c . get ( Calendar . DAY_OF_MONTH ) ; fail ( STR_ ) ; } catch ( IllegalArgumentException e ) { } catch ( Exception e ) { fail ( STR_ + e . toString ( ) ) ; } c . setLenient ( BOOL_ ) ; try { c . set ( Calendar . DAY_OF_MONTH , NUM_ ) ; c . get ( Calendar . DAY_OF_MONTH ) ; } catch ( Exception e ) { fail ( STR_ + e . toString ( ) ) ; } } }
private void writeIndexFile ( ) throws IOException , CarbonDataWriterException { IndexHeader indexHeader = CarbonMetadataUtil . getIndexHeader ( localCardinality , thriftColumnSchemaList ) ; List < BlockIndex > blockIndexThrift = CarbonMetadataUtil . getBlockIndexInfo ( blockIndexInfoList ) ; String fileName = storeLocation + File . separator + carbonTablePath . getCarbonIndexFileName ( carbonDataFileAttributes . getTaskId ( ) , carbonDataFileAttributes . getFactTimeStamp ( ) ) ; CarbonIndexFileWriter writer = new CarbonIndexFileWriter ( ) ; writer . openThriftWriter ( fileName ) ; writer . writeThrift ( indexHeader ) ; for ( BlockIndex blockIndex : blockIndexThrift ) { writer . writeThrift ( blockIndex ) ; } writer . close ( ) ; copyCarbonDataFileToCarbonStorePath ( fileName ) ; }
public void nackAll ( PubsubReader < T > reader ) throws IOException { checkState ( this . reader == null , STR_ ) ; List < String > batchYetToAckIds = new ArrayList < > ( Math . min ( notYetReadIds . size ( ) , ACK_BATCH_SIZE ) ) ; for ( String ackId : notYetReadIds ) { batchYetToAckIds . add ( ackId ) ; if ( batchYetToAckIds . size ( ) >= ACK_BATCH_SIZE ) { long nowMsSinceEpoch = now ( reader ) ; reader . nackBatch ( nowMsSinceEpoch , batchYetToAckIds ) ; batchYetToAckIds . clear ( ) ; } } if ( ! batchYetToAckIds . isEmpty ( ) ) { long nowMsSinceEpoch = now ( reader ) ; reader . nackBatch ( nowMsSinceEpoch , batchYetToAckIds ) ; } }
static public void assertEquals ( String message , Object expected , Object actual ) { if ( expected == null && actual == null ) return ; if ( expected != null && expected . equals ( actual ) ) return ; failNotEquals ( message , expected , actual ) ; }
public static NamingException mapErrorCode ( int errorCode , String errorMessage ) { if ( errorCode == LdapClient . LDAP_SUCCESS ) return null ; NamingException e = null ; String message = LdapClient . getErrorMessage ( errorCode , errorMessage ) ; switch ( errorCode ) { case LdapClient . LDAP_ALIAS_DEREFERENCING_PROBLEM : e = new NamingException ( message ) ; break ; case LdapClient . LDAP_ALIAS_PROBLEM : e = new NamingException ( message ) ; break ; case LdapClient . LDAP_ATTRIBUTE_OR_VALUE_EXISTS : e = new AttributeInUseException ( message ) ; break ; case LdapClient . LDAP_AUTH_METHOD_NOT_SUPPORTED : case LdapClient . LDAP_CONFIDENTIALITY_REQUIRED : case LdapClient . LDAP_STRONG_AUTH_REQUIRED : case LdapClient . LDAP_INAPPROPRIATE_AUTHENTICATION : e = new AuthenticationNotSupportedException ( message ) ; break ; case LdapClient . LDAP_ENTRY_ALREADY_EXISTS : e = new NameAlreadyBoundException ( message ) ; break ; case LdapClient . LDAP_INVALID_CREDENTIALS : case LdapClient . LDAP_SASL_BIND_IN_PROGRESS : e = new AuthenticationException ( message ) ; break ; case LdapClient . LDAP_INAPPROPRIATE_MATCHING : e = new InvalidSearchFilterException ( message ) ; break ; case LdapClient . LDAP_INSUFFICIENT_ACCESS_RIGHTS : e = new NoPermissionException ( message ) ; break ; case LdapClient . LDAP_INVALID_ATTRIBUTE_SYNTAX : case LdapClient . LDAP_CONSTRAINT_VIOLATION : e = new InvalidAttributeValueException ( message ) ; break ; case LdapClient . LDAP_LOOP_DETECT : e = new NamingException ( message ) ; break ; case LdapClient . LDAP_NO_SUCH_ATTRIBUTE : e = new NoSuchAttributeException ( message ) ; break ; case LdapClient . LDAP_NO_SUCH_OBJECT : e = new NameNotFoundException ( message ) ; break ; case LdapClient . LDAP_OBJECT_CLASS_MODS_PROHIBITED : case LdapClient . LDAP_OBJECT_CLASS_VIOLATION : case LdapClient . LDAP_NOT_ALLOWED_ON_RDN : e = new SchemaViolationException ( message ) ; break ; case LdapClient . LDAP_NOT_ALLOWED_ON_NON_LEAF : e = new ContextNotEmptyException ( message ) ; break ; case LdapClient . LDAP_OPERATIONS_ERROR : e = new NamingException ( message ) ; break ; case LdapClient . LDAP_OTHER : e = new NamingException ( message ) ; break ; case LdapClient . LDAP_PROTOCOL_ERROR : e = new CommunicationException ( message ) ; break ; case LdapClient . LDAP_SIZE_LIMIT_EXCEEDED : e = new SizeLimitExceededException ( message ) ; break ; case LdapClient . LDAP_TIME_LIMIT_EXCEEDED : e = new TimeLimitExceededException ( message ) ; break ; case LdapClient . LDAP_UNAVAILABLE_CRITICAL_EXTENSION : e = new OperationNotSupportedException ( message ) ; break ; case LdapClient . LDAP_UNAVAILABLE : case LdapClient . LDAP_BUSY : e = new ServiceUnavailableException ( message ) ; break ; case LdapClient . LDAP_UNDEFINED_ATTRIBUTE_TYPE : e = new InvalidAttributeIdentifierException ( message ) ; break ; case LdapClient . LDAP_UNWILLING_TO_PERFORM : e = new OperationNotSupportedException ( message ) ; break ; case LdapClient . LDAP_COMPARE_FALSE : case LdapClient . LDAP_COMPARE_TRUE : case LdapClient . LDAP_IS_LEAF : e = new NamingException ( message ) ; break ; case LdapClient . LDAP_ADMIN_LIMIT_EXCEEDED : e = new LimitExceededException ( message ) ; break ; case LdapClient . LDAP_REFERRAL : e = new NamingException ( message ) ; break ; case LdapClient . LDAP_PARTIAL_RESULTS : e = new NamingException ( message ) ; break ; case LdapClient . LDAP_INVALID_DN_SYNTAX : case LdapClient . LDAP_NAMING_VIOLATION : e = new InvalidNameException ( message ) ; break ; default : e = new NamingException ( message ) ; break ; } return e ; }
public final void computeIndex ( ) { if ( indexComputed ) { return ; } List < Long > cellList = new ArrayList ( ) ; List < Integer > edgeList = new ArrayList ( ) ; for ( int i = NUM_ ; i < getNumEdges ( ) ; ++ i ) { S2Point from = edgeFrom ( i ) ; S2Point to = edgeTo ( i ) ; ArrayList < S2CellId > cover = new ArrayList ( ) ; int level = getCovering ( from , to , BOOL_ , cover ) ; minimumS2LevelUsed = Math . min ( minimumS2LevelUsed , level ) ; for ( S2CellId cellId : cover ) { cellList . add ( cellId . id ( ) ) ; edgeList . add ( i ) ; } } cells = new long [ cellList . size ( ) ] ; edges = new int [ edgeList . size ( ) ] ; for ( int i = NUM_ ; i < cells . length ; i ++ ) { cells [ i ] = cellList . get ( i ) ; edges [ i ] = edgeList . get ( i ) ; } sortIndex ( ) ; indexComputed = BOOL_ ; }
public WaitForAnyListener ( int numberOfResults ) { this ( numberOfResults , null ) ; }
public static Object stringToValue ( String string ) { Double d ; if ( string . equals ( STR_ ) ) { return string ; } if ( string . equalsIgnoreCase ( STR_ ) ) { return Boolean . TRUE ; } if ( string . equalsIgnoreCase ( STR_ ) ) { return Boolean . FALSE ; } if ( string . equalsIgnoreCase ( STR_ ) ) { return JSONObject . NULL ; } char b = string . charAt ( NUM_ ) ; if ( ( b >= STR_ && b <= STR_ ) || b == STR_ || b == STR_ || b == STR_ ) { try { if ( string . indexOf ( STR_ ) > - NUM_ || string . indexOf ( STR_ ) > - NUM_ || string . indexOf ( STR_ ) > - NUM_ ) { d = Double . valueOf ( string ) ; if ( ! d . isInfinite ( ) && ! d . isNaN ( ) ) { return d ; } } else { Long myLong = new Long ( string ) ; if ( myLong . longValue ( ) == myLong . intValue ( ) ) { return new Integer ( myLong . intValue ( ) ) ; } else { return myLong ; } } } catch ( Exception ignore ) { } } return string ; }
public abstract void onPinSet ( String pin ) ;
public void testCase9 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = - NUM_ ; int bSign = - NUM_ ; byte rBytes [ ] = { - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . add ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , - NUM_ , result . signum ( ) ) ; }
public EntityQuery orderBy ( String ... fields ) { this . orderBy = Arrays . asList ( fields ) ; return this ; }
public void removeNodesFromPartition ( List < IGroupMemberNode > nodesToRemove ) { for ( final IGroupMemberNode nodeToRemove : nodesToRemove ) { if ( nodeToRemove != null ) { if ( ! nonOptionalNonMinusNodes . remove ( nodeToRemove ) ) { if ( nodeToRemove . equals ( optionalOrMinus ) ) { optionalOrMinus = null ; } } } } recomputeDefinitelyProduced ( ) ; }
public static void banner ( Logger logger , Class < ? > clazz , String methodName , String text ) { String string = clazz . getSimpleName ( ) + STR_ + methodName ; if ( text != null ) { string += STR_ + text ; } logger . info ( STR_ ) ; logger . info ( STR_ ) ; logger . info ( STR_ + string ) ; logger . info ( STR_ ) ; }
private void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject ( ) ; if ( resourceBundleName != null ) { try { rb = ResourceBundle . getBundle ( resourceBundleName ) ; } catch ( MissingResourceException e ) { rb = null ; } } }
private static void exit ( @ Nullable String errMsg , @ Nullable Options options , int exitCode ) { if ( errMsg != null ) echo ( STR_ + errMsg ) ; String runner = System . getProperty ( IGNITE_PROG_NAME , STR_ ) ; int space = runner . indexOf ( STR_ ) ; runner = runner . substring ( NUM_ , space == - NUM_ ? runner . length ( ) : space ) ; if ( options != null ) { HelpFormatter formatter = new HelpFormatter ( ) ; formatter . printHelp ( runner , options ) ; } System . exit ( exitCode ) ; }
private static void replaceAltSpecialInstructions ( ) { fillInstructionMap ( x8300 , xFF00 , new FrInstruction ( InstructionFormat . D , NUM_ , NUM_ , STR_ , STR_ , STR_ , Instruction . FlowType . NONE , BOOL_ , BOOL_ , andccrU8SimulationCode ) ) ; fillInstructionMap ( x8700 , xFF00 , new FrInstruction ( InstructionFormat . D , NUM_ , NUM_ , STR_ , STR_ , STR_ , Instruction . FlowType . NONE , BOOL_ , BOOL_ , stilmU8SimulationCode ) ) ; fillInstructionMap ( x9300 , xFF00 , new FrInstruction ( InstructionFormat . D , NUM_ , NUM_ , STR_ , STR_ , STR_ , Instruction . FlowType . NONE , BOOL_ , BOOL_ , orccrU8SimulationCode ) ) ; fillInstructionMap ( xA300 , xFF00 , new FrInstruction ( InstructionFormat . D , NUM_ , NUM_ , STR_ , STR_ , STR_ , Instruction . FlowType . NONE , BOOL_ , BOOL_ , addspS10SimulationCode ) ) ; }
@ Override public boolean addSensorToRoute ( String sensorName , int mode ) { if ( _controlSensorList . size ( ) >= MAX_CONTROL_SENSORS ) { log . warn ( STR_ , getSystemName ( ) ) ; } ControlSensor sensor = new ControlSensor ( sensorName ) ; log . debug ( STR_ , getSystemName ( ) , sensorName ) ; if ( ! sensor . setState ( mode ) ) { return BOOL_ ; } if ( isControlSensorIncluded ( sensor ) ) { log . debug ( STR_ , sensorName , getSystemName ( ) ) ; } else { _controlSensorList . add ( sensor ) ; } return BOOL_ ; }
private void eliminateBackfillStates ( int baseState ) { if ( statesToBackfill . contains ( new Integer ( baseState ) ) ) { statesToBackfill . removeElement ( new Integer ( baseState ) ) ; short [ ] state = tempStateTable . elementAt ( baseState ) ; for ( int i = NUM_ ; i < numCategories ; i ++ ) { if ( state [ i ] != NUM_ ) { eliminateBackfillStates ( state [ i ] ) ; } } } }
static boolean separateConvexPolygons ( float [ ] verts1 , float [ ] verts2 , Vector2 separation ) { final int length1 = verts1 . length ; final int length2 = verts2 . length ; for ( int i = NUM_ ; i < length1 ; i += NUM_ ) { final int j = ( i + NUM_ ) % length1 ; float projX = verts1 [ j + NUM_ ] - verts1 [ i + NUM_ ] ; float projY = verts1 [ i ] - verts1 [ j ] ; final float length = ( float ) Math . sqrt ( projX . projX + projY . projY ) ; projX /= length ; projY /= length ; float min1 = Float . POSITIVE_INFINITY , max1 = Float . NEGATIVE_INFINITY ; for ( int k = NUM_ ; k < length1 ; k += NUM_ ) { final float dot = projX . verts1 [ k ] + projY . verts1 [ k + NUM_ ] ; if ( dot < min1 ) min1 = dot ; if ( dot > max1 ) max1 = dot ; } float min2 = Float . POSITIVE_INFINITY , max2 = Float . NEGATIVE_INFINITY ; for ( int k = NUM_ ; k < length2 ; k += NUM_ ) { final float dot = projX . verts2 [ k ] + projY . verts2 [ k + NUM_ ] ; if ( dot < min2 ) min2 = dot ; if ( dot > max2 ) max2 = dot ; } if ( ( max1 < min2 ) || ( max2 < min1 ) ) { if ( null != separation ) separation . set ( projY , - projX ) ; return BOOL_ ; } } return BOOL_ ; }
public String paymentTerm ( Properties ctx , int WindowNo , GridTab mTab , GridField mField , Object value ) { Integer C_PaymentTerm_ID = ( Integer ) value ; int C_Invoice_ID = Env . getContextAsInt ( ctx , WindowNo , STR_ ) ; if ( C_PaymentTerm_ID == null || C_PaymentTerm_ID . intValue ( ) == NUM_ || C_Invoice_ID == NUM_ ) return STR_ ; MPaymentTerm pt = new MPaymentTerm ( ctx , C_PaymentTerm_ID . intValue ( ) , null ) ; if ( pt . get_ID ( ) == NUM_ ) return STR_ ; boolean valid = pt . apply ( C_Invoice_ID ) ; mTab . setValue ( STR_ , valid ? STR_ : STR_ ) ; return STR_ ; }
static void checkTypeRefAndPath ( int typeRef , TypePath typePath ) { int mask = NUM_ ; switch ( typeRef > > > NUM_ ) { case TypeReference . CLASS_TYPE_PARAMETER : case TypeReference . METHOD_TYPE_PARAMETER : case TypeReference . METHOD_FORMAL_PARAMETER : mask = xFFFF0000 ; break ; case TypeReference . FIELD : case TypeReference . METHOD_RETURN : case TypeReference . METHOD_RECEIVER : case TypeReference . LOCAL_VARIABLE : case TypeReference . RESOURCE_VARIABLE : case TypeReference . INSTANCEOF : case TypeReference . NEW : case TypeReference . CONSTRUCTOR_REFERENCE : case TypeReference . METHOD_REFERENCE : mask = xFF000000 ; break ; case TypeReference . CLASS_EXTENDS : case TypeReference . CLASS_TYPE_PARAMETER_BOUND : case TypeReference . METHOD_TYPE_PARAMETER_BOUND : case TypeReference . THROWS : case TypeReference . EXCEPTION_PARAMETER : mask = xFFFFFF00 ; break ; case TypeReference . CAST : case TypeReference . CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT : case TypeReference . METHOD_INVOCATION_TYPE_ARGUMENT : case TypeReference . CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT : case TypeReference . METHOD_REFERENCE_TYPE_ARGUMENT : mask = xFF0000FF ; break ; default : throw new IllegalArgumentException ( STR_ + Integer . toHexString ( typeRef > > > NUM_ ) ) ; } if ( ( typeRef & ~ mask ) != NUM_ ) { throw new IllegalArgumentException ( STR_ + Integer . toHexString ( typeRef ) ) ; } if ( typePath != null ) { for ( int i = NUM_ ; i < typePath . getLength ( ) ; ++ i ) { int step = typePath . getStep ( i ) ; if ( step != TypePath . ARRAY_ELEMENT && step != TypePath . INNER_TYPE && step != TypePath . TYPE_ARGUMENT && step != TypePath . WILDCARD_BOUND ) { throw new IllegalArgumentException ( STR_ + i + STR_ + typePath ) ; } if ( step != TypePath . TYPE_ARGUMENT && typePath . getStepArgument ( i ) != NUM_ ) { throw new IllegalArgumentException ( STR_ + i + STR_ + typePath ) ; } } } }
public static void transformCriteria ( Properties formProperties , InputStream xslIs , Result result ) throws SAXException , IOException , ParserConfigurationException , TransformerException { dbf . setNamespaceAware ( BOOL_ ) ; DocumentBuilder builder = dbf . newDocumentBuilder ( ) ; org . w3c . dom . Document xslDoc = builder . parse ( xslIs ) ; DOMSource ds = new DOMSource ( xslDoc ) ; Transformer transformer = null ; synchronized ( tFactory ) { transformer = tFactory . newTransformer ( ds ) ; } transformCriteria ( formProperties , transformer , result ) ; }
public static List < byte [ ] > splitAndPad ( byte [ ] byteArray , int blocksize ) { List < byte [ ] > blocks = new ArrayList < byte [ ] > ( ) ; int numBlocks = ( int ) Math . ceil ( byteArray . length / ( double ) blocksize ) ; for ( int i = NUM_ ; i < numBlocks ; i ++ ) { byte [ ] block = new byte [ blocksize ] ; Arrays . fill ( block , ( byte ) x00 ) ; if ( i + NUM_ == numBlocks ) { int remainingBytes = byteArray . length - ( i . blocksize ) ; System . arraycopy ( byteArray , i . blocksize , block , NUM_ , remainingBytes ) ; } else { System . arraycopy ( byteArray , i . blocksize , block , NUM_ , blocksize ) ; } blocks . add ( block ) ; } return blocks ; }
public void put ( E item ) throws InterruptedException { if ( ! done . get ( ) ) { queue . put ( item ) ; } }
protected void notifyComplete ( ) { final String methodName = STR_ ; log . fine ( CLASS_NAME , methodName , STR_ , new Object [ ] { getKey ( ) , this . response , this . exception } ) ; synchronized ( responseLock ) { if ( exception == null && pendingComplete ) { completed = BOOL_ ; pendingComplete = BOOL_ ; } else { pendingComplete = BOOL_ ; } responseLock . notifyAll ( ) ; } synchronized ( sentLock ) { sent = BOOL_ ; sentLock . notifyAll ( ) ; } }
private Node < K , V > [ ] initTable ( ) { Node < K , V > [ ] tab ; int sc ; while ( ( tab = table ) == null || tab . length == NUM_ ) { if ( ( sc = sizeCtl ) < NUM_ ) { Thread . yield ( ) ; } else if ( U . compareAndSwapInt ( this , SIZECTL , sc , - NUM_ ) ) { try { if ( ( tab = table ) == null || tab . length == NUM_ ) { int n = ( sc > NUM_ ) ? sc : DEFAULT_CAPACITY ; @ SuppressWarnings ( STR_ ) Node < K , V > [ ] nt = ( Node < K , V > [ ] ) new Node < ? , ? > [ n ] ; table = tab = nt ; sc = n - ( n > > > NUM_ ) ; } } finally { sizeCtl = sc ; } break ; } } return tab ; }
public BufferedImage drawBarGraphWithStdDev ( String graphTitle , String xLabel , String yLabel , HashMap < ComparableLabel , Integer [ ] > barDataPoints , String [ ] barLabels , Long stdDevHigh , Long stdDevLow , Long graphMaxValue ) { BufferedImage bi = new BufferedImage ( this . WIDTH , this . HEIGHT , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g2d = bi . createGraphics ( ) ; RenderingHints renderHints = new RenderingHints ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2d . setRenderingHints ( renderHints ) ; drawChartAndGraphRectangles ( g2d ) ; drawBarLegend ( g2d , STR_ , barLabels , stdDevHigh , stdDevLow ) ; drawTitleAndLabels ( g2d , graphTitle , xLabel , yLabel ) ; Collection < Integer [ ] > valueCollection = barDataPoints . values ( ) ; Set < ComparableLabel > dateKeySet = barDataPoints . keySet ( ) ; long maxValue = NUM_ ; for ( Integer [ ] intArray : valueCollection ) { for ( Integer intValue : intArray ) { if ( maxValue < intValue ) { maxValue = intValue ; } } } long yMaxMark = NUM_ ; int yLabelXOffset = NUM_ ; yMaxMark = determineYMaxMark ( maxValue , stdDevHigh , graphMaxValue ) ; drawYAxisDivisions ( g2d , yMaxMark , yLabelXOffset ) ; ArrayList < ComparableLabel > orderedDateSet = new ArrayList < ComparableLabel > ( ) ; orderedDateSet . addAll ( dateKeySet ) ; Collections . sort ( orderedDateSet ) ; drawXAxisDivisions ( g2d , orderedDateSet ) ; drawBarsOnGraph ( g2d , orderedDateSet , barDataPoints , yMaxMark ) ; if ( stdDevHigh != null ) { drawStdDevLine ( g2d , stdDevHigh , yMaxMark , this . stdDevHighColor ) ; } if ( stdDevLow != null ) { drawStdDevLine ( g2d , stdDevLow , yMaxMark , this . stdDevLowColor ) ; } return bi ; }
public synchronized boolean loadPublicKey ( ) { if ( ! has ( STR_ ) || ! has ( STR_ ) ) return BOOL_ ; String encodedKey = getString ( STR_ ) ; String algorithm = getString ( STR_ ) ; PublicKey pub = IO . decodePublicKey ( encodedKey , algorithm ) ; if ( pub != null ) { public_key = pub ; key_algorithm = algorithm ; setPeerHash ( ) ; return BOOL_ ; } return BOOL_ ; }
private String extractProjectNameFromUri ( @ NotNull String uri ) { int indexFinishProjectName = uri . lastIndexOf ( STR_ ) ; int indexStartProjectName = uri . lastIndexOf ( STR_ ) != - NUM_ ? uri . lastIndexOf ( STR_ ) + NUM_ : ( uri . lastIndexOf ( STR_ ) + NUM_ ) ; if ( indexStartProjectName != NUM_ && indexStartProjectName < indexFinishProjectName ) { return uri . substring ( indexStartProjectName , indexFinishProjectName ) ; } if ( indexStartProjectName != NUM_ ) { return uri . substring ( indexStartProjectName ) ; } return STR_ ; }
private void loadTextData ( DataInputStream dis ) throws IOException { for ( int f = NUM_ ; f < numFrames ; f ++ ) { times [ f ] = Float . parseFloat ( General . readWord ( dis ) ) ; General . readWord ( dis ) ; for ( int c = NUM_ ; c < numChannels ; c ++ ) { frames [ f ] [ c ] = Float . parseFloat ( General . readWord ( dis ) ) ; } } }
public void addSwipeListener ( SwipeListener listener ) { if ( mListeners == null ) { mListeners = new ArrayList < SwipeListener > ( ) ; } mListeners . add ( listener ) ; }
public static boolean isGzipContent ( String contentEncoding ) { return contentEncoding != null && contentEncoding . contains ( STR_ ) ; }
public synchronized boolean checkSize ( final int sizeChecked ) { if ( ! started ) { throw new IllegalStateException ( STR_ ) ; } if ( sizeChecked > bufferSize ) { throw new IllegalStateException ( STR_ + bufferSize + STR_ ) ; } if ( bufferLimit == NUM_ || buffer . writerIndex ( ) + sizeChecked > bufferLimit ) { flush ( ) ; delayFlush = BOOL_ ; final int remainingInFile = bufferObserver . getRemainingBytes ( ) ; if ( sizeChecked > remainingInFile ) { return BOOL_ ; } else { bufferLimit = Math . min ( remainingInFile , bufferSize ) ; return BOOL_ ; } } else { delayFlush = BOOL_ ; return BOOL_ ; } }
public void testCompareLessScale1 ( ) { String a = STR_ ; int aScale = NUM_ ; String b = STR_ ; int bScale = NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal bNumber = new BigDecimal ( new BigInteger ( b ) , bScale ) ; int result = NUM_ ; assertEquals ( STR_ , result , aNumber . compareTo ( bNumber ) ) ; }
void reclaimScrapViews ( List < View > views ) { if ( mViewTypeCount == NUM_ ) { views . addAll ( mCurrentScrap ) ; } else { final int viewTypeCount = mViewTypeCount ; final ArrayList < View > [ ] scrapViews = mScrapViews ; for ( int i = NUM_ ; i < viewTypeCount ; ++ i ) { final ArrayList < View > scrapPile = scrapViews [ i ] ; views . addAll ( scrapPile ) ; } } }
public void exit ( ) { exitCalled = BOOL_ ; if ( threadMap != null ) { deleteAllThreads ( ) ; log . info ( STR_ ) ; if ( DurationStatistics . collectStatistics ) { statistics . exit ( ) ; log . info ( String . format ( STR_ , statistics . allCycles , statistics . getDurationMillis ( ) / NUM_ ) ) ; Collections . sort ( statistics . threads ) ; for ( Statistics . ThreadStatistics threadStatistics : statistics . threads ) { double percentage = NUM_ ; if ( statistics . allCycles != NUM_ ) { percentage = ( threadStatistics . runClocks / ( double ) statistics . allCycles ) . NUM_ ; } log . info ( String . format ( STR_ , threadStatistics . getQuotedName ( ) , threadStatistics . runClocks , percentage ) ) ; } } } }
private void formatNodeTo ( Formatter f , int level , RadixTreeNode < T > node ) { for ( int i = NUM_ ; i < level ; i ++ ) { f . format ( STR_ ) ; } f . format ( STR_ ) ; for ( int i = NUM_ ; i < level ; i ++ ) { f . format ( STR_ ) ; } if ( node . isReal ( ) == BOOL_ ) f . format ( STR_ , node . getKey ( ) , node . getValue ( ) ) ; else f . format ( STR_ , node . getKey ( ) ) ; for ( RadixTreeNode < T > child : node . getChildern ( ) ) { formatNodeTo ( f , level + NUM_ , child ) ; } }
protected void startDownload ( int blocks ) { if ( blocks > NUM_ ) log . info ( STR_ + blocks + STR_ + ( blocks > NUM_ ? STR_ : STR_ ) ) ; }
public void add ( int start , int end , int handler , int type ) { if ( start < end ) entries . add ( new ExceptionTableEntry ( start , end , handler , type ) ) ; }
private void freeKick ( Team offense ) { if ( gameTime <= NUM_ ) return ; else { if ( gameTime < NUM_ && ( ( gamePoss && ( awayScore - homeScore ) <= NUM_ && ( awayScore - homeScore ) > NUM_ ) || ( ! gamePoss && ( homeScore - awayScore ) <= NUM_ && ( homeScore - awayScore ) > NUM_ ) ) ) { if ( offense . getK ( NUM_ ) . ratKickFum . Math . random ( ) > NUM_ || Math . random ( ) < NUM_ ) { gameEventLog += getEventPrefix ( ) + offense . abbr + STR_ + offense . getK ( NUM_ ) . name + STR_ + offense . abbr + STR_ ; gameYardLine = NUM_ ; gameDown = NUM_ ; gameYardsNeed = NUM_ ; } else { gameEventLog += getEventPrefix ( ) + offense . abbr + STR_ + offense . getK ( NUM_ ) . name + STR_ ; gamePoss = ! gamePoss ; gameYardLine = NUM_ ; gameDown = NUM_ ; gameYardsNeed = NUM_ ; } gameTime -= NUM_ + NUM_ . Math . random ( ) ; } else { gameYardLine = ( int ) ( NUM_ - ( offense . getK ( NUM_ ) . ratKickPow + NUM_ - NUM_ . Math . random ( ) ) ) ; if ( gameYardLine <= NUM_ ) gameYardLine = NUM_ ; gameDown = NUM_ ; gameYardsNeed = NUM_ ; gamePoss = ! gamePoss ; gameTime -= NUM_ . Math . random ( ) ; } } }
private void processNewPort ( long sw , short p ) { if ( isLinkDiscoverySuppressed ( sw , p ) ) { return ; } IOFSwitch iofSwitch = floodlightProvider . getSwitch ( sw ) ; if ( iofSwitch == null ) return ; if ( autoPortFastFeature && iofSwitch . isFastPort ( p ) ) { return ; } NodePortTuple npt = new NodePortTuple ( sw , p ) ; discover ( sw , p ) ; if ( ! iofSwitch . isFastPort ( p ) ) { addToQuarantineQueue ( npt ) ; } else { addToMaintenanceQueue ( npt ) ; } }
public static void put3ByteInt ( ByteBuffer buffer , int val ) { put3ByteInt ( buffer , val , buffer . order ( ) ) ; }
public static void assertNoException ( Runnable expression , String errorMessage ) { if ( verbose ) { log ( STR_ + expression + STR_ + errorMessage + STR_ ) ; } try { expression . run ( ) ; } catch ( RuntimeException failure ) { TestUtils . fail ( errorMessage ) ; } }
@ Override public int indexOf ( Object object ) { return indexOf ( object , NUM_ ) ; }
protected ResponseFormatType generateAcceptFormat ( String format ) throws BadApiRequestException { try { return format == null ? ResponseFormatType . JSON : ResponseFormatType . valueOf ( format . toUpperCase ( Locale . ENGLISH ) ) ; } catch ( IllegalArgumentException e ) { LOG . error ( ACCEPT_FORMAT_INVALID . logFormat ( format ) , e ) ; throw new BadApiRequestException ( ACCEPT_FORMAT_INVALID . format ( format ) ) ; } }
public SharedObject ( Map < String , Object > data , String name , String path , boolean persistent ) { super ( ) ; this . name = name ; this . path = path ; this . persistentSO = persistent ; ownerMessage = new SharedObjectMessage ( null , name , NUM_ , persistent ) ; creationTime = System . currentTimeMillis ( ) ; super . setAttributes ( data ) ; }
public static String dateToString ( Date date ) { if ( date == null ) { return null ; } else { DateFormat df = new SimpleDateFormat ( dateFormat ) ; df . setTimeZone ( utc ) ; return df . format ( date ) ; } }
public static String infoFirstLastPixels ( ImageLineInt line ) { return line . imgInfo . channels == NUM_ ? String . format ( STR_ , line . scanline [ NUM_ ] , line . scanline [ line . scanline . length - NUM_ ] ) : String . format ( STR_ , line . scanline [ NUM_ ] , line . scanline [ NUM_ ] , line . scanline [ NUM_ ] , line . scanline [ line . scanline . length - line . imgInfo . channels ] , line . scanline [ line . scanline . length - line . imgInfo . channels + NUM_ ] , line . scanline [ line . scanline . length - line . imgInfo . channels + NUM_ ] ) ; }
private AstNode memberExprTail ( boolean allowCallSyntax , AstNode pn ) throws IOException { if ( pn == null ) codeBug ( ) ; int pos = pn . getPosition ( ) ; int lineno ; tailLoop : for ( ; ; ) { int tt = peekToken ( ) ; switch ( tt ) { case Token . DOT : case Token . DOTDOT : lineno = ts . lineno ; pn = propertyAccess ( tt , pn ) ; pn . setLineno ( lineno ) ; break ; case Token . DOTQUERY : consumeToken ( ) ; int opPos = ts . tokenBeg , rp = - NUM_ ; lineno = ts . lineno ; mustHaveXML ( ) ; setRequiresActivation ( ) ; AstNode filter = expr ( ) ; int end = getNodeEnd ( filter ) ; if ( mustMatchToken ( Token . RP , STR_ ) ) { rp = ts . tokenBeg ; end = ts . tokenEnd ; } XmlDotQuery q = new XmlDotQuery ( pos , end - pos ) ; q . setLeft ( pn ) ; q . setRight ( filter ) ; q . setOperatorPosition ( opPos ) ; q . setRp ( rp - pos ) ; q . setLineno ( lineno ) ; pn = q ; break ; case Token . LB : consumeToken ( ) ; int lb = ts . tokenBeg , rb = - NUM_ ; lineno = ts . lineno ; AstNode expr = expr ( ) ; end = getNodeEnd ( expr ) ; if ( mustMatchToken ( Token . RB , STR_ ) ) { rb = ts . tokenBeg ; end = ts . tokenEnd ; } ElementGet g = new ElementGet ( pos , end - pos ) ; g . setTarget ( pn ) ; g . setElement ( expr ) ; g . setParens ( lb , rb ) ; g . setLineno ( lineno ) ; pn = g ; break ; case Token . LP : if ( ! allowCallSyntax ) { break tailLoop ; } lineno = ts . lineno ; consumeToken ( ) ; checkCallRequiresActivation ( pn ) ; FunctionCall f = new FunctionCall ( pos ) ; f . setTarget ( pn ) ; f . setLineno ( lineno ) ; f . setLp ( ts . tokenBeg - pos ) ; List < AstNode > args = argumentList ( ) ; if ( args != null && args . size ( ) > ARGC_LIMIT ) reportError ( STR_ ) ; f . setArguments ( args ) ; f . setRp ( ts . tokenBeg - pos ) ; f . setLength ( ts . tokenEnd - pos ) ; pn = f ; break ; default : break tailLoop ; } } return pn ; }
public static Iterable < Element > elements ( NodeList nodes ) { return null ; }
public static int minDistance ( String word1 , String word2 ) { if ( word1 . equals ( word2 ) ) return NUM_ ; int m = word1 . length ( ) ; int n = word2 . length ( ) ; int [ ] [ ] d = new int [ m + NUM_ ] [ n + NUM_ ] ; d [ NUM_ ] [ NUM_ ] = NUM_ ; for ( int i = NUM_ ; i < m + NUM_ ; i ++ ) d [ i ] [ NUM_ ] = i ; for ( int j = NUM_ ; j < n + NUM_ ; j ++ ) d [ NUM_ ] [ j ] = j ; for ( int i = NUM_ ; i < m + NUM_ ; i ++ ) { for ( int j = NUM_ ; j < n + NUM_ ; j ++ ) { d [ i ] [ j ] = Math . min ( Math . min ( d [ i ] [ j - NUM_ ] + NUM_ , d [ i - NUM_ ] [ j ] + NUM_ ) , word1 . charAt ( i - NUM_ ) == word2 . charAt ( j - NUM_ ) ? d [ i - NUM_ ] [ j - NUM_ ] : d [ i - NUM_ ] [ j - NUM_ ] + NUM_ ) ; } } return d [ m ] [ n ] ; }
public void addUrl ( String url ) { Set < String > urls = getCachedUrls ( ) ; urls . add ( url ) ; putCachedUrls ( urls ) ; updateNotification ( urls ) ; }
public void testValueOfLongMax ( ) { long longVal = Long . MAX_VALUE ; BigInteger aNumber = BigInteger . valueOf ( longVal ) ; byte rBytes [ ] = { NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ } ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , aNumber . signum ( ) ) ; }
private void closeDatabaseConnection ( Connection connection ) { if ( connection == null ) return ; try { connection . close ( ) ; } catch ( SQLException e ) { } connection = null ; return ; }
@ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case InformationModelPackage . INFORMATION_MODEL__NAME : return NAME_EDEFAULT == null ? name != null : ! NAME_EDEFAULT . equals ( name ) ; case InformationModelPackage . INFORMATION_MODEL__NAMESPACE : return NAMESPACE_EDEFAULT == null ? namespace != null : ! NAMESPACE_EDEFAULT . equals ( namespace ) ; case InformationModelPackage . INFORMATION_MODEL__VERSION : return VERSION_EDEFAULT == null ? version != null : ! VERSION_EDEFAULT . equals ( version ) ; case InformationModelPackage . INFORMATION_MODEL__REFERENCES : return references != null && ! references . isEmpty ( ) ; case InformationModelPackage . INFORMATION_MODEL__DESCRIPTION : return DESCRIPTION_EDEFAULT == null ? description != null : ! DESCRIPTION_EDEFAULT . equals ( description ) ; case InformationModelPackage . INFORMATION_MODEL__DISPLAYNAME : return DISPLAYNAME_EDEFAULT == null ? displayname != null : ! DISPLAYNAME_EDEFAULT . equals ( displayname ) ; case InformationModelPackage . INFORMATION_MODEL__CATEGORY : return CATEGORY_EDEFAULT == null ? category != null : ! CATEGORY_EDEFAULT . equals ( category ) ; case InformationModelPackage . INFORMATION_MODEL__PROPERTIES : return properties != null && ! properties . isEmpty ( ) ; } return super . eIsSet ( featureID ) ; }
public void addUnnamedTask ( TmmTask task ) { if ( unnamedTaskExecutor == null || unnamedTaskExecutor . isShutdown ( ) ) { unnamedTaskExecutor = createUnnamedTaskExecutor ( ) ; } task . addListener ( this ) ; task . setState ( TaskState . QUEUED ) ; unnamedTaskExecutor . execute ( task ) ; }
public Path ( final Vertex v0 , final Vertex v1 , final EdgeSample edgeSample ) { if ( v0 == null ) throw new IllegalArgumentException ( ) ; if ( v1 == null ) throw new IllegalArgumentException ( ) ; if ( v0 . sample == null ) throw new IllegalArgumentException ( ) ; if ( edgeSample == null ) throw new IllegalArgumentException ( ) ; if ( edgeSample . getSample ( ) == null ) throw new IllegalArgumentException ( ) ; this . vertices = new Vertex [ ] { v0 , v1 } ; this . preds = getPredicates ( vertices ) ; this . edgeSample = edgeSample ; this . sumEstRead = v0 . sample . estCard + edgeSample . estRead ; this . sumEstCard = edgeSample . estCard ; this . sumEstCost = getCost ( this . sumEstRead , this . sumEstCard ) ; }
public boolean evaluate ( Map record ) { Object recVal = record . get ( keyField ) ; return op . evaluate ( this . val , recVal ) ; }
protected static final String addEscapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = NUM_ ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case NUM_ : continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < x20 || ch > x7e ) { String s = STR_ + Integer . toString ( ch , NUM_ ) ; retval . append ( STR_ + s . substring ( s . length ( ) - NUM_ , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; }
public char [ ] toCharArray ( ) { Charset utf8 = Charset . forName ( STR_ ) ; CharBuffer charBuffer = utf8 . decode ( ByteBuffer . wrap ( buffer , offset , length ) ) ; char [ ] chars = new char [ charBuffer . remaining ( ) ] ; charBuffer . get ( chars ) ; return chars ; }
public static byte [ ] chars2utf ( char [ ] src , int sindex , int len ) { byte [ ] dst = new byte [ len . NUM_ ] ; int len1 = chars2utf ( src , sindex , dst , NUM_ , len ) ; byte [ ] result = new byte [ len1 ] ; System . arraycopy ( dst , NUM_ , result , NUM_ , len1 ) ; return result ; }
private void readReference ( ) { String sql ; if ( Env . isBaseLanguage ( Env . getCtx ( ) , STR_ ) ) sql = STR_ + STR_ ; else sql = STR_ + STR_ + STR_ + STR_ + Env . getAD_Language ( Env . getCtx ( ) ) + STR_ + STR_ ; ArrayList < String > v_value = new ArrayList < String > ( ) ; ArrayList < String > v_name = new ArrayList < String > ( ) ; ArrayList < String > v_description = new ArrayList < String > ( ) ; try { PreparedStatement pstmt = DB . prepareStatement ( sql , null ) ; ResultSet rs = pstmt . executeQuery ( ) ; while ( rs . next ( ) ) { String value = rs . getString ( NUM_ ) ; String name = rs . getString ( NUM_ ) ; String description = rs . getString ( NUM_ ) ; if ( description == null ) description = STR_ ; v_value . add ( value ) ; v_name . add ( name ) ; v_description . add ( description ) ; } rs . close ( ) ; pstmt . close ( ) ; } catch ( SQLException e ) { log . log ( Level . SEVERE , sql , e ) ; } int size = v_value . size ( ) ; s_value = new String [ size ] ; s_name = new String [ size ] ; s_description = new String [ size ] ; for ( int i = NUM_ ; i < size ; i ++ ) { s_value [ i ] = ( String ) v_value . get ( i ) ; s_name [ i ] = ( String ) v_name . get ( i ) ; s_description [ i ] = ( String ) v_description . get ( i ) ; } }
private CarbonDictionarySortInfo createColumnSortInfo ( CarbonDictionarySortModel [ ] dictionarySortModels ) { int [ ] sortIndex ; int [ ] sortIndexInverted ; Arrays . sort ( dictionarySortModels ) ; sortIndex = new int [ dictionarySortModels . length ] ; sortIndexInverted = new int [ dictionarySortModels . length ] ; for ( int i = NUM_ ; i < dictionarySortModels . length ; i ++ ) { CarbonDictionarySortModel dictionarySortModel = dictionarySortModels [ i ] ; sortIndex [ i ] = dictionarySortModel . getKey ( ) ; sortIndexInverted [ dictionarySortModel . getKey ( ) - NUM_ ] = i + NUM_ ; } dictionarySortModels = null ; List < Integer > sortIndexList = convertToList ( sortIndex ) ; List < Integer > sortIndexInvertedList = convertToList ( sortIndexInverted ) ; return new CarbonDictionarySortInfo ( sortIndexList , sortIndexInvertedList ) ; }
private IntegerPolynomial MGF ( byte [ ] seed , int N , int minCallsR , boolean hashSeed ) { Digest hashAlg = params . hashAlg ; int hashLen = hashAlg . getDigestSize ( ) ; byte [ ] buf = new byte [ minCallsR . hashLen ] ; byte [ ] Z = hashSeed ? calcHash ( hashAlg , seed ) : seed ; int counter = NUM_ ; while ( counter < minCallsR ) { hashAlg . update ( Z , NUM_ , Z . length ) ; putInt ( hashAlg , counter ) ; byte [ ] hash = calcHash ( hashAlg ) ; System . arraycopy ( hash , NUM_ , buf , counter . hashLen , hashLen ) ; counter ++ ; } IntegerPolynomial i = new IntegerPolynomial ( N ) ; while ( BOOL_ ) { int cur = NUM_ ; for ( int index = NUM_ ; index != buf . length ; index ++ ) { int O = ( int ) buf [ index ] & xFF ; if ( O >= NUM_ ) { continue ; } for ( int terIdx = NUM_ ; terIdx < NUM_ ; terIdx ++ ) { int rem3 = O % NUM_ ; i . coeffs [ cur ] = rem3 - NUM_ ; cur ++ ; if ( cur == N ) { return i ; } O = ( O - rem3 ) / NUM_ ; } i . coeffs [ cur ] = O - NUM_ ; cur ++ ; if ( cur == N ) { return i ; } } if ( cur >= N ) { return i ; } hashAlg . update ( Z , NUM_ , Z . length ) ; putInt ( hashAlg , counter ) ; byte [ ] hash = calcHash ( hashAlg ) ; buf = hash ; counter ++ ; } }
public static void agentmain ( String agentArgs , Instrumentation inst ) throws Exception { synchronized ( JVMAgent . class ) { if ( instance == null ) { instance = new JVMAgent ( inst ) ; waitForInstance . countDown ( ) ; } } }
public void close ( ) { Handler [ ] handlerArray = m_logger . getHandlers ( ) ; for ( int i = NUM_ ; i < handlerArray . length ; i ++ ) { Handler h = handlerArray [ i ] ; h . flush ( ) ; h . close ( ) ; m_logger . removeHandler ( h ) ; } }
public String toString ( ) { if ( val == null ) return STR_ ; if ( val instanceof Long || val instanceof Integer ) { return Long . toString ( val . longValue ( ) ) ; } double d = val . doubleValue ( ) ; if ( Double . isInfinite ( d ) ) return ( d > NUM_ ) ? STR_ : STR_ ; if ( Double . isNaN ( d ) ) return STR_ ; return Double . toString ( d ) ; }
public static List < String > splitText ( String text ) { int startLine = NUM_ ; int i = NUM_ ; int n = text . length ( ) ; ArrayList < String > rc = new ArrayList < String > ( ) ; while ( i < n ) { switch ( text . charAt ( i ) ) { case STR_ : i ++ ; if ( i < n && text . charAt ( i ) == STR_ ) { i ++ ; } rc . add ( text . substring ( startLine , i ) ) ; startLine = i ; break ; case STR_ : i ++ ; if ( i < n && text . charAt ( i ) == STR_ ) { i ++ ; } rc . add ( text . substring ( startLine , i ) ) ; startLine = i ; break ; default : i ++ ; } } if ( startLine == text . length ( ) ) { rc . add ( STR_ ) ; } else { rc . add ( text . substring ( startLine , i ) ) ; } return rc ; }
CountryCodeSource maybeStripInternationalPrefixAndNormalize ( StringBuilder number , String possibleIddPrefix ) { if ( number . length ( ) == NUM_ ) { return CountryCodeSource . FROM_DEFAULT_COUNTRY ; } Matcher m = PLUS_CHARS_PATTERN . matcher ( number ) ; if ( m . lookingAt ( ) ) { number . delete ( NUM_ , m . end ( ) ) ; normalize ( number ) ; return CountryCodeSource . FROM_NUMBER_WITH_PLUS_SIGN ; } Pattern iddPattern = regexCache . getPatternForRegex ( possibleIddPrefix ) ; normalize ( number ) ; return parsePrefixAsIdd ( iddPattern , number ) ? CountryCodeSource . FROM_NUMBER_WITH_IDD : CountryCodeSource . FROM_DEFAULT_COUNTRY ; }
@ Override public void write ( int value ) { digest . update ( ( byte ) value ) ; }
public boolean isManufactured ( boolean ignoreSupplierProducts ) { List < GenericValue > supplierProducts = null ; try { supplierProducts = product . getRelated ( STR_ , UtilMisc . toMap ( STR_ , STR_ ) , UtilMisc . toList ( STR_ ) , BOOL_ ) ; } catch ( GenericEntityException gee ) { Debug . logError ( STR_ , module ) ; } supplierProducts = EntityUtil . filterByDate ( supplierProducts , UtilDateTime . nowTimestamp ( ) , STR_ , STR_ , BOOL_ ) ; return childrenNodes . size ( ) > NUM_ && ( ignoreSupplierProducts || UtilValidate . isEmpty ( supplierProducts ) ) ; }
private void addCodeFromField ( StringBuilder sb , Field f ) { try { sb . append ( f . getName ( ) + STR_ + f . getInt ( KeyEvent . class ) ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } sb . append ( STR_ ) ; }
protected boolean scrollUp ( TextView widget , Spannable buffer , int amount ) { final Layout layout = widget . getLayout ( ) ; final int top = widget . getScrollY ( ) ; int topLine = layout . getLineForVertical ( top ) ; if ( layout . getLineTop ( topLine ) == top ) { topLine -= NUM_ ; } if ( topLine >= NUM_ ) { topLine = Math . max ( topLine - amount + NUM_ , NUM_ ) ; Touch . scrollTo ( widget , layout , widget . getScrollX ( ) , layout . getLineTop ( topLine ) ) ; return BOOL_ ; } return BOOL_ ; }
public void load ( String filename ) { ++ numMappings ; loadClassFile ( filename ) ; }
protected void fillFaceToolBar ( JToolBar faceTB , ButtonGroup bg ) { for ( EditToolLoader loader : loaderList ) { String [ ] classnames = loader . getEditableClasses ( ) ; for ( int i = NUM_ ; i < classnames . length ; i ++ ) { ImageIcon icon = loader . getIcon ( classnames [ i ] ) ; JToggleButton btn = new JToggleButton ( icon , BOOL_ ) ; btn . setToolTipText ( loader . getPrettyName ( classnames [ i ] ) ) ; btn . setFocusable ( BOOL_ ) ; btn . setActionCommand ( classnames [ i ] ) ; btn . addActionListener ( this ) ; bg . add ( btn ) ; faceTB . add ( btn ) ; } } }
public void writeToFile ( File filename ) throws IOException { FileUtils . stringToFile ( mText . toString ( ) , filename ) ; }
protected void transformRectsTouch ( ArrayList < RectF > rects ) { for ( int i = NUM_ ; i < rects . size ( ) ; i ++ ) { mMatrixTouch . mapRect ( rects . get ( i ) ) ; } }
@ Override public String toString ( ) { StringBuilder buf = new StringBuilder ( ) ; for ( NameValuePair pair : nameValuePairList ) { buf . append ( STR_ ) ; buf . append ( pair . getName ( ) ) ; buf . append ( STR_ ) ; buf . append ( STR_ ) ; buf . append ( getQuotedAttributeValue ( pair . getValue ( ) ) ) ; buf . append ( STR_ ) ; } return buf . toString ( ) ; }
@ Override public final int arrayOffset ( ) { return protectedArrayOffset ( ) ; }
public DOMTestDocumentBuilderFactory newInstance ( DocumentBuilderSetting [ ] newSettings ) throws DOMTestIncompatibleException { if ( newSettings == null ) { return this ; } DocumentBuilderSetting [ ] mergedSettings = mergeSettings ( newSettings ) ; return new BatikTestDocumentBuilderFactory ( mergedSettings ) ; }
public float [ ] valueArray ( float [ ] array ) { if ( array == null || array . length != size ( ) ) { array = new float [ count ] ; } System . arraycopy ( values , NUM_ , array , NUM_ , count ) ; return array ; }
public static Set < TypeVariable > methodTypeToTargets ( final AnnotatedExecutableType methodType ) { final List < AnnotatedTypeVariable > annotatedTypeVars = methodType . getTypeVariables ( ) ; final Set < TypeVariable > targets = new LinkedHashSet < > ( annotatedTypeVars . size ( ) ) ; for ( final AnnotatedTypeVariable atv : annotatedTypeVars ) { targets . add ( atv . getUnderlyingType ( ) ) ; } return targets ; }
private void validateTableMetaDataSingleRow ( String tableNamePattern , String [ ] types , Map < TableMetaData , Object > validationRules ) throws Exception { checkValidationRulesComplete ( validationRules ) ; try ( ResultSet tables = dbmd . getTables ( null , null , tableNamePattern , types ) ) { assertTrue ( STR_ , tables . next ( ) ) ; validateRowValues ( tables , validationRules ) ; assertFalse ( STR_ , tables . next ( ) ) ; } }
public void flush ( ) throws IOException { try { _writer . write ( _buffer , NUM_ , _pos ) ; _writer . flush ( ) ; } catch ( IOException except ) { if ( _exception == null ) _exception = except ; throw except ; } _pos = NUM_ ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
private JMenu makeLogLevelMenu ( ) { return new LogLevelMenu ( ) ; }
@ Override public void close ( ) throws IOException { synchronized ( lock ) { buf = null ; in . close ( ) ; } }
public DGetAlias ( JFrame parent , String title , String alias ) { super ( parent , title , Dialog . ModalityType . DOCUMENT_MODAL ) ; initComponents ( alias ) ; }
public static void closeQuietly ( Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( RuntimeException rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } }
public static ArrayList < Hop > deepCopyHopsDag ( ArrayList < Hop > hops ) throws HopsException { ArrayList < Hop > ret = new ArrayList < Hop > ( ) ; try { HashMap < Long , Hop > memo = new HashMap < Long , Hop > ( ) ; for ( Hop hopRoot : hops ) ret . add ( rDeepCopyHopsDag ( hopRoot , memo ) ) ; } catch ( Exception ex ) { throw new HopsException ( ex ) ; } return ret ; }
public void addAll ( T ... items ) { if ( mEventDelegate != null ) mEventDelegate . addData ( items == null ? NUM_ : items . length ) ; if ( items != null && items . length != NUM_ ) { synchronized ( mLock ) { Collections . addAll ( mObjects , items ) ; } } if ( mNotifyOnChange ) notifyDataSetChanged ( ) ; }
private void replaceImpl ( final int startIndex , final int endIndex , final int removeLen , final String insertStr , final int insertLen ) { final int newSize = size - removeLen + insertLen ; if ( insertLen != removeLen ) { ensureCapacity ( newSize ) ; System . arraycopy ( buffer , endIndex , buffer , startIndex + insertLen , size - endIndex ) ; size = newSize ; } if ( insertLen > NUM_ ) { insertStr . getChars ( NUM_ , insertLen , buffer , startIndex ) ; } }
public void updateCheque_DD_Card_Deposit_Receipt ( final Map instrumentDetailsMap ) { updateInstrumentAndPayinSql ( instrumentDetailsMap ) ; addToBankReconcilationSQL ( instrumentDetailsMap ) ; }
public void testtestIsLast ( ) throws SQLException { assertFalse ( target . isLast ( ) ) ; target . absolute ( - NUM_ ) ; assertTrue ( target . isLast ( ) ) ; assertFalse ( emptyTarget . isLast ( ) ) ; assertFalse ( emptyTarget . next ( ) ) ; assertFalse ( emptyTarget . isLast ( ) ) ; try { target . close ( ) ; target . isLast ( ) ; fail ( STR_ ) ; } catch ( SQLException e ) { } }
public final void addHelperText ( @ NonNull final CharSequence helperText ) { ensureNotNull ( helperText , STR_ ) ; ensureNotEmpty ( helperText , STR_ ) ; if ( ! helperTexts . contains ( helperText ) ) { helperTexts . add ( helperText ) ; verifyPasswordStrength ( ) ; } }
void waitForLogEntry ( int index , int timeout ) throws GondolaException , InterruptedException , TimeoutException { reset ( ) ; this . index = index ; long endTs = timeout < NUM_ ? Long . MAX_VALUE : gondola . getClock ( ) . now ( ) + timeout ; lock . lock ( ) ; try { while ( status == Command . STATUS_NONE && gondola . getClock ( ) . now ( ) < endTs ) { if ( timeout < NUM_ ) { updateCond . await ( ) ; } else { updateCond . await ( timeout , TimeUnit . MILLISECONDS ) ; } } if ( this . index != index ) { logger . error ( STR_ ) ; } } finally { lock . unlock ( ) ; } switch ( status ) { case Command . STATUS_NONE : status = Command . STATUS_TIMEOUT ; throw new TimeoutException ( String . format ( STR_ , timeout , index ) ) ; case Command . STATUS_NOT_LEADER : assert BOOL_ ; break ; case Command . STATUS_SLAVE_MODE : throw new GondolaException ( GondolaException . Code . SLAVE_MODE , cmember . memberId ) ; case Command . STATUS_ERROR : throw new IllegalStateException ( STR_ + index + STR_ + errorMessage ) ; case Command . STATUS_OK : break ; } }
public static String generateNativeGuid ( DbClient dbClient , Volume volume ) throws IOException { StorageSystem device = dbClient . queryObject ( StorageSystem . class , volume . getStorageController ( ) ) ; return String . format ( STR_ + VOLUME + STR_ , _deviceTypeMap . get ( device . getSystemType ( ) ) , device . getSerialNumber ( ) , volume . getNativeId ( ) ) ; }
public AgentMappings saveAgentMappings ( AgentMappings agentMappings , boolean checkEnvironments ) throws BusinessException , JAXBException , IOException { if ( checkEnvironments ) { checkEnvironments ( agentMappings ) ; } AgentMappings current ; do { current = agentMappingsReference . get ( ) ; if ( current . getRevision ( ) != agentMappings . getRevision ( ) ) { throw new BusinessException ( STR_ , ConfigurationInterfaceErrorCodeEnum . REVISION_CHECK_FAILED ) ; } } while ( ! agentMappingsReference . compareAndSet ( current , agentMappings ) ) ; agentMappings . setRevision ( agentMappings . getRevision ( ) + NUM_ ) ; saveAgentMapping ( agentMappings ) ; publishAgentMappingsUpdateEvent ( ) ; return agentMappings ; }
public E push ( E object ) { addElement ( object ) ; return object ; }
protected void newCertBtnListener ( ) { NewCertificateDialogData data = new NewCertificateDialogData ( ) ; NewCertificateDialog dialog = new NewCertificateDialog ( getShell ( ) , data , STR_ ) ; int returnCode = dialog . open ( ) ; if ( returnCode == Window . OK ) { String certPath = data . getCerFilePath ( ) ; certTxt . setText ( certPath != null ? certPath . replace ( STR_ , STR_ ) : certPath ) ; certInfoTxt . setText ( getCertInfo ( certTxt . getText ( ) ) ) ; } }
public static void generateMov ( final ITranslationEnvironment environment , final long baseOffset , final IInstruction instruction , final List < ReilInstruction > instructions ) throws InternalTranslationException { Preconditions . checkNotNull ( environment , STR_ ) ; Preconditions . checkNotNull ( instruction , STR_ ) ; Preconditions . checkNotNull ( instructions , STR_ ) ; long reilOffset = baseOffset ; final List < ? extends IOperandTree > operands = instruction . getOperands ( ) ; final TranslationResult loadSource = Helpers . translateOperand ( environment , reilOffset , operands . get ( NUM_ ) , BOOL_ ) ; instructions . addAll ( loadSource . getInstructions ( ) ) ; reilOffset = baseOffset + instructions . size ( ) ; final TranslationResult loadDest = Helpers . translateOperand ( environment , reilOffset , operands . get ( NUM_ ) , BOOL_ ) ; instructions . addAll ( loadDest . getInstructions ( ) ) ; reilOffset = baseOffset + instructions . size ( ) ; Helpers . writeBack ( environment , reilOffset , operands . get ( NUM_ ) , loadSource . getRegister ( ) , loadDest . getSize ( ) , loadDest . getAddress ( ) , loadDest . getType ( ) , instructions ) ; }
public void characters ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( ! m_shouldProcess ) return ; XSLTElementProcessor elemProcessor = getCurrentProcessor ( ) ; XSLTElementDef def = elemProcessor . getElemDef ( ) ; if ( def . getType ( ) != XSLTElementDef . T_PCDATA ) elemProcessor = def . getProcessorFor ( null , STR_ ) ; if ( null == elemProcessor ) { if ( ! XMLCharacterRecognizer . isWhiteSpace ( ch , start , length ) ) error ( XSLMessages . createMessage ( XSLTErrorResources . ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , null ) , null ) ; } else elemProcessor . characters ( this , ch , start , length ) ; }
public boolean removeEntry ( int xIndex , int dataSetIndex ) { if ( dataSetIndex >= mDataSets . size ( ) ) return BOOL_ ; T dataSet = mDataSets . get ( dataSetIndex ) ; Entry e = dataSet . getEntryForXIndex ( xIndex ) ; return removeEntry ( e , dataSetIndex ) ; }
public void testBug68562 ( ) throws Exception { testBug68562BatchWithSize ( NUM_ ) ; testBug68562BatchWithSize ( NUM_ ) ; }
public Vec2 toVector ( Point2D v ) { return new Vec2 ( toMeters ( v . getX ( ) ) , toMeters ( - v . getY ( ) ) ) ; }
@ Override public void terminateAnyRestoreSessions ( StorageSystem storage , BlockObject from , URI volume , TaskCompleter taskCompleter ) throws Exception { BlockObject blockObject = BlockObject . fetch ( _dbClient , volume ) ; Collection < CIMObjectPath > syncObjects = null ; if ( storage . checkIfVmax3 ( ) ) { syncObjects = _helper . getSettingsDefineStatePaths ( storage , blockObject , ( BlockSnapshot ) from ) ; } else { syncObjects = getRestoredOrMixedStateSyncObjects ( storage , blockObject ) ; } for ( CIMObjectPath syncObject : syncObjects ) { resumeSnapshot ( storage , from , blockObject , syncObject , taskCompleter ) ; } }
public static < T > Set < T > toSet ( T obj1 , T obj2 , T obj3 , T obj4 , T obj5 , T obj6 ) { Set < T > theSet = new LinkedHashSet < T > ( ) ; theSet . add ( obj1 ) ; theSet . add ( obj2 ) ; theSet . add ( obj3 ) ; theSet . add ( obj4 ) ; theSet . add ( obj5 ) ; theSet . add ( obj6 ) ; return theSet ; }
protected void writeGraphicCtrlExt ( ) throws IOException { out . write ( x21 ) ; out . write ( xf9 ) ; out . write ( NUM_ ) ; int transp , disp ; if ( transparent == - NUM_ ) { transp = NUM_ ; disp = NUM_ ; } else { transp = NUM_ ; disp = NUM_ ; } if ( dispose >= NUM_ ) { disp = dispose & NUM_ ; } disp <<= NUM_ ; out . write ( NUM_ | disp | NUM_ | transp ) ; writeShort ( delay ) ; out . write ( transIndex ) ; out . write ( NUM_ ) ; }
public final double doOperation ( ) throws OperatorFailedException { int index ; if ( updateMap == null ) { index = MathUtils . nextInt ( parameter . getDimension ( ) ) ; } else { index = updateMap . get ( MathUtils . nextInt ( updateMapSize ) ) ; } double draw = ( NUM_ . MathUtils . nextDouble ( ) - NUM_ ) . windowSize ; double newValue = parameter . getParameterValue ( index ) + draw ; final Bounds < Double > bounds = parameter . getBounds ( ) ; final double lower = ( lowerOperatorBound == null ? bounds . getLowerLimit ( index ) : Math . max ( bounds . getLowerLimit ( index ) , lowerOperatorBound ) ) ; final double upper = ( upperOperatorBound == null ? bounds . getUpperLimit ( index ) : Math . min ( bounds . getUpperLimit ( index ) , upperOperatorBound ) ) ; if ( condition == BoundaryCondition . reflecting ) { newValue = reflectValue ( newValue , lower , upper ) ; } else if ( condition == BoundaryCondition . absorbing && ( newValue < lower || newValue > upper ) ) { return NUM_ ; } else if ( newValue < lower || newValue > upper ) { throw new OperatorFailedException ( STR_ ) ; } parameter . setParameterValue ( index , newValue ) ; return NUM_ ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; String childData ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; nameNode = elementList . item ( NUM_ ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; child . replaceData ( NUM_ , NUM_ , STR_ ) ; childData = child . getData ( ) ; assertEquals ( STR_ , STR_ , childData ) ; }
public Collection < Object > injectables ( ) { return Collections . emptyList ( ) ; }
private void updateEffectiveDimensions ( ) { effectiveWidth = Math . max ( NUM_ , width - leftBorder - rightBorder ) ; effectiveHeight = Math . max ( NUM_ , height - topBorder - bottomBorder ) ; }
public void addAttribute ( AttributeInfo info ) { if ( attribute == null ) attribute = new ArrayList ( ) ; AttributeInfo . remove ( attribute , info . getName ( ) ) ; attribute . add ( info ) ; }
public void addLine ( String text ) throws BadLocationException { if ( text == null || text . length ( ) == NUM_ || text . equals ( STR_ ) ) { return ; } document . replace ( document . getLength ( ) , NUM_ , text ) ; }
protected void muteButtonPressed ( ActionEvent e ) { JToggleButton b = ( JToggleButton ) e . getSource ( ) ; log . debug ( STR_ + b . isSelected ( ) ) ; firePropertyChange ( PropertyChangeID . MUTE , ! b . isSelected ( ) , b . isSelected ( ) ) ; }
public TwoDPoint ( String s ) { StringTokenizer st = new StringTokenizer ( s , STR_ ) ; x = Double . valueOf ( st . nextToken ( ) ) ; y = Double . valueOf ( st . nextToken ( ) ) ; }
private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject ( ) ; init ( ) ; }
public static boolean isClassSupport ( String clzName ) { try { Class . forName ( clzName ) ; return BOOL_ ; } catch ( ClassNotFoundException e ) { return BOOL_ ; } }
public void addPopupListener ( final PopupListener listener ) { if ( ! popupListeners . contains ( listener ) ) { popupListeners . add ( listener ) ; } }
public static byte [ ] decode ( byte [ ] data ) { int len = data . length / NUM_ . NUM_ ; ByteArrayOutputStream bOut = new ByteArrayOutputStream ( len ) ; try { encoder . decode ( data , NUM_ , data . length , bOut ) ; } catch ( Exception e ) { throw new DecoderException ( STR_ + e . getMessage ( ) , e ) ; } return bOut . toByteArray ( ) ; }
public static String buildSelectorFromAttributeTypeAndValue ( String attributeType , String attributeValue ) { StringBuilder strb = new StringBuilder ( ) ; strb . append ( OPEN_BRACKET ) ; strb . append ( attributeType ) ; strb . append ( EQUAL ) ; strb . append ( attributeValue ) ; strb . append ( CLOSE_BRACKET ) ; return strb . toString ( ) ; }
public static Bitmap scaleFit ( Bitmap src , int maxW , int maxH ) { float ratio = Math . min ( maxW / ( float ) src . getWidth ( ) , maxH / ( float ) src . getHeight ( ) ) ; int newW = ( int ) ( src . getWidth ( ) . ratio ) ; int newH = ( int ) ( src . getHeight ( ) . ratio ) ; return scale ( src , newW , newH ) ; }
public File ( String dirPath , String name ) { if ( name == null ) { throw new NullPointerException ( STR_ ) ; } if ( dirPath == null || dirPath . isEmpty ( ) ) { this . path = fixSlashes ( name ) ; } else if ( name . isEmpty ( ) ) { this . path = fixSlashes ( dirPath ) ; } else { this . path = fixSlashes ( join ( dirPath , name ) ) ; } }
void decodeAttributeBody ( byte [ ] attributeValue , char offset , char length ) { username = new byte [ length ] ; System . arraycopy ( attributeValue , offset , username , NUM_ , length ) ; }
protected synchronized byte [ ] engineGenerateSeed ( int numBytes ) { byte [ ] myBytes ; if ( numBytes < NUM_ ) { throw new NegativeArraySizeException ( Integer . toString ( numBytes ) ) ; } if ( numBytes == NUM_ ) { return EmptyArray . BYTE ; } if ( myRandom == null ) { myRandom = new SHA1PRNG_SecureRandomImpl ( ) ; myRandom . engineSetSeed ( getRandomBytes ( DIGEST_LENGTH ) ) ; } myBytes = new byte [ numBytes ] ; myRandom . engineNextBytes ( myBytes ) ; return myBytes ; }
public static String normalizeInet4Address ( String ip4String ) { final int [ ] octets = parseInet4Address ( ip4String ) ; if ( octets == null ) { return null ; } StringBuilder sb = new StringBuilder ( ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { if ( i > NUM_ ) { sb . append ( STR_ ) ; } sb . append ( octets [ i ] ) ; } return sb . toString ( ) ; }
public static int [ ] shuffle ( int [ ] input ) { List < Integer > vals = new ArrayList < Integer > ( input . length ) ; for ( int i = NUM_ ; i < input . length ; i ++ ) vals . add ( input [ i ] ) ; Collections . shuffle ( vals , SEEDED_RANDOM ) ; int [ ] copy = new int [ input . length ] ; for ( int i = NUM_ ; i < input . length ; i ++ ) copy [ i ] = vals . get ( i ) ; return copy ; }
public boolean offer ( PooledConnection pooledConnection ) { acquiredConnections . remove ( pooledConnection ) ; boolean offer = queue . offer ( pooledConnection ) ; if ( ! offer ) { pooledConnection . dispose ( ) ; } if ( isTerminating . get ( ) ) { PooledConnection poll = queue . poll ( ) ; if ( poll != null ) { poll . dispose ( ) ; } } return offer ; }
private int parseStyleInDefaultWorkspace ( GeoServerRESTReader reader , int count , List < StyleWrapper > styleList ) { RESTStyleList geoServerStyleList = reader . getStyles ( ) ; for ( String style : geoServerStyleList . getNames ( ) ) { StyleWrapper newStyleWrapper = new StyleWrapper ( DEFAULT_WORKSPACE_NAME , style ) ; styleList . add ( newStyleWrapper ) ; if ( parentObj != null ) { parentObj . readStylesProgress ( connection , count , count ) ; } count ++ ; } return count ; }
private ClassSignature loadClassFromJigsaw ( String classname ) throws IOException { if ( method_Class_getModule == null || method_Module_getName == null ) { return null ; } final Class < ? > clazz ; final String moduleName ; try { clazz = Class . forName ( classname , BOOL_ , loader ) ; final Object module = method_Class_getModule . invoke ( clazz ) ; moduleName = ( String ) method_Module_getName . invoke ( module ) ; } catch ( Exception e ) { return null ; } return new ClassSignature ( clazz , AsmUtils . isRuntimeModule ( moduleName ) ) ; }
public void testConnectANTSensor_Cadence ( ) { if ( ! runTest ) { Log . d ( TAG , BigTestUtils . DISABLE_MESSAGE ) ; return ; } useANTSeonsor ( ) ; assertTrue ( checkSensorsStatus_notRecording ( ) ) ; checkANTSensorsStatus ( R . id . sensor_state_cadence ) ; }
@ Override public boolean equals ( Object obj ) { if ( this == obj ) { return BOOL_ ; } if ( obj == null ) { return BOOL_ ; } if ( getClass ( ) != obj . getClass ( ) ) { return BOOL_ ; } Diff other = ( Diff ) obj ; if ( operation != other . operation ) { return BOOL_ ; } if ( text == null ) { if ( other . text != null ) { return BOOL_ ; } } else if ( ! text . equals ( other . text ) ) { return BOOL_ ; } return BOOL_ ; }
public void clearAttributeSpecs ( ) { if ( m_attributeSpecs == null ) { m_attributeSpecs = new ArrayList < AttributeSpec > ( ) ; } m_attributeSpecs . clear ( ) ; }
public void loadProperties ( boolean silent ) { loadPropertiesFile ( System . getProperty ( PROPERTIES_FILE , STR_ ) , silent ) ; initializeProperties ( ) ; }
@ Override public void start ( ) { try { JournalClientEndpoint endpoint = connect ( ) ; if ( endpoint != null ) { OutputStream os ; _os = os = endpoint . startMessage ( ) ; if ( os != null ) { os . write ( STR_ ) ; } } } catch ( Exception e ) { log . finer ( e . toString ( ) ) ; } }
static private int readBytes ( int c [ ] , int len , InputStream is ) throws IOException { byte buf [ ] = new byte [ len ] ; if ( is . read ( buf , NUM_ , len ) < len ) { return - NUM_ ; } for ( int i = NUM_ ; i < len ; i ++ ) { c [ i ] = buf [ i ] & xff ; } return NUM_ ; }
public static void sort ( Object [ ] array ) { if ( array . length > NUM_ ) { Arrays . sort ( array , INSTANCE ) ; } }
native private static void initialize ( String applicationId ) ;
public static AnimGameItem process ( MD5Model md5Model , MD5AnimModel animModel , Vector3f defaultColour ) throws Exception { List < Matrix4f > invJointMatrices = calcInJointMatrices ( md5Model ) ; List < AnimatedFrame > animatedFrames = processAnimationFrames ( md5Model , animModel , invJointMatrices ) ; List < Mesh > list = new ArrayList < > ( ) ; for ( MD5Mesh md5Mesh : md5Model . getMeshes ( ) ) { Mesh mesh = generateMesh ( md5Model , md5Mesh ) ; handleTexture ( mesh , md5Mesh , defaultColour ) ; list . add ( mesh ) ; } Mesh [ ] meshes = new Mesh [ list . size ( ) ] ; meshes = list . toArray ( meshes ) ; AnimGameItem result = new AnimGameItem ( meshes , animatedFrames , invJointMatrices ) ; return result ; }
static String encodeHighLevel ( String msg , Compaction compaction , Charset encoding ) throws WriterException { StringBuilder sb = new StringBuilder ( msg . length ( ) ) ; if ( encoding == null ) { encoding = DEFAULT_ENCODING ; } else if ( ! DEFAULT_ENCODING . equals ( encoding ) ) { CharacterSetECI eci = CharacterSetECI . getCharacterSetECIByName ( encoding . name ( ) ) ; if ( eci != null ) { encodingECI ( eci . getValue ( ) , sb ) ; } } int len = msg . length ( ) ; int p = NUM_ ; int textSubMode = SUBMODE_ALPHA ; byte [ ] bytes = null ; if ( compaction == Compaction . TEXT ) { encodeText ( msg , p , len , sb , textSubMode ) ; } else if ( compaction == Compaction . BYTE ) { bytes = msg . getBytes ( encoding ) ; encodeBinary ( bytes , p , bytes . length , BYTE_COMPACTION , sb ) ; } else if ( compaction == Compaction . NUMERIC ) { sb . append ( ( char ) LATCH_TO_NUMERIC ) ; encodeNumeric ( msg , p , len , sb ) ; } else { int encodingMode = TEXT_COMPACTION ; while ( p < len ) { int n = determineConsecutiveDigitCount ( msg , p ) ; if ( n >= NUM_ ) { sb . append ( ( char ) LATCH_TO_NUMERIC ) ; encodingMode = NUMERIC_COMPACTION ; textSubMode = SUBMODE_ALPHA ; encodeNumeric ( msg , p , n , sb ) ; p += n ; } else { int t = determineConsecutiveTextCount ( msg , p ) ; if ( t >= NUM_ || n == len ) { if ( encodingMode != TEXT_COMPACTION ) { sb . append ( ( char ) LATCH_TO_TEXT ) ; encodingMode = TEXT_COMPACTION ; textSubMode = SUBMODE_ALPHA ; } textSubMode = encodeText ( msg , p , t , sb , textSubMode ) ; p += t ; } else { if ( bytes == null ) { bytes = msg . getBytes ( encoding ) ; } int b = determineConsecutiveBinaryCount ( msg , bytes , p ) ; if ( b == NUM_ ) { b = NUM_ ; } if ( b == NUM_ && encodingMode == TEXT_COMPACTION ) { encodeBinary ( bytes , p , NUM_ , TEXT_COMPACTION , sb ) ; } else { encodeBinary ( bytes , p , b , encodingMode , sb ) ; encodingMode = BYTE_COMPACTION ; textSubMode = SUBMODE_ALPHA ; } p += b ; } } } } return sb . toString ( ) ; }
private int readAnnotationValue ( int v , final char [ ] buf , final String name , final AnnotationVisitor av ) { int i ; if ( av == null ) { switch ( b [ v ] & xFF ) { case STR_ : return v + NUM_ ; case STR_ : return readAnnotationValues ( v + NUM_ , buf , BOOL_ , null ) ; case STR_ : return readAnnotationValues ( v + NUM_ , buf , BOOL_ , null ) ; default : return v + NUM_ ; } } switch ( b [ v ++ ] & xFF ) { case STR_ : case STR_ : case STR_ : case STR_ : av . visit ( name , readConst ( readUnsignedShort ( v ) , buf ) ) ; v += NUM_ ; break ; case STR_ : av . visit ( name , new Byte ( ( byte ) readInt ( items [ readUnsignedShort ( v ) ] ) ) ) ; v += NUM_ ; break ; case STR_ : av . visit ( name , readInt ( items [ readUnsignedShort ( v ) ] ) == NUM_ ? Boolean . FALSE : Boolean . TRUE ) ; v += NUM_ ; break ; case STR_ : av . visit ( name , new Short ( ( short ) readInt ( items [ readUnsignedShort ( v ) ] ) ) ) ; v += NUM_ ; break ; case STR_ : av . visit ( name , new Character ( ( char ) readInt ( items [ readUnsignedShort ( v ) ] ) ) ) ; v += NUM_ ; break ; case STR_ : av . visit ( name , readUTF8 ( v , buf ) ) ; v += NUM_ ; break ; case STR_ : av . visitEnum ( name , readUTF8 ( v , buf ) , readUTF8 ( v + NUM_ , buf ) ) ; v += NUM_ ; break ; case STR_ : av . visit ( name , Type . getType ( readUTF8 ( v , buf ) ) ) ; v += NUM_ ; break ; case STR_ : v = readAnnotationValues ( v + NUM_ , buf , BOOL_ , av . visitAnnotation ( name , readUTF8 ( v , buf ) ) ) ; break ; case STR_ : int size = readUnsignedShort ( v ) ; v += NUM_ ; if ( size == NUM_ ) { return readAnnotationValues ( v - NUM_ , buf , BOOL_ , av . visitArray ( name ) ) ; } switch ( this . b [ v ++ ] & xFF ) { case STR_ : byte [ ] bv = new byte [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { bv [ i ] = ( byte ) readInt ( items [ readUnsignedShort ( v ) ] ) ; v += NUM_ ; } av . visit ( name , bv ) ; -- v ; break ; case STR_ : boolean [ ] zv = new boolean [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { zv [ i ] = readInt ( items [ readUnsignedShort ( v ) ] ) != NUM_ ; v += NUM_ ; } av . visit ( name , zv ) ; -- v ; break ; case STR_ : short [ ] sv = new short [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { sv [ i ] = ( short ) readInt ( items [ readUnsignedShort ( v ) ] ) ; v += NUM_ ; } av . visit ( name , sv ) ; -- v ; break ; case STR_ : char [ ] cv = new char [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { cv [ i ] = ( char ) readInt ( items [ readUnsignedShort ( v ) ] ) ; v += NUM_ ; } av . visit ( name , cv ) ; -- v ; break ; case STR_ : int [ ] iv = new int [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { iv [ i ] = readInt ( items [ readUnsignedShort ( v ) ] ) ; v += NUM_ ; } av . visit ( name , iv ) ; -- v ; break ; case STR_ : long [ ] lv = new long [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { lv [ i ] = readLong ( items [ readUnsignedShort ( v ) ] ) ; v += NUM_ ; } av . visit ( name , lv ) ; -- v ; break ; case STR_ : float [ ] fv = new float [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { fv [ i ] = Float . intBitsToFloat ( readInt ( items [ readUnsignedShort ( v ) ] ) ) ; v += NUM_ ; } av . visit ( name , fv ) ; -- v ; break ; case STR_ : double [ ] dv = new double [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { dv [ i ] = Double . longBitsToDouble ( readLong ( items [ readUnsignedShort ( v ) ] ) ) ; v += NUM_ ; } av . visit ( name , dv ) ; -- v ; break ; default : v = readAnnotationValues ( v - NUM_ , buf , BOOL_ , av . visitArray ( name ) ) ; } } return v ; }
private static final boolean compareAndSetWaitStatus ( Node node , int expect , int update ) { return unsafe . compareAndSwapInt ( node , waitStatusOffset , expect , update ) ; }
public NetworkConnectivityListener ( ) { mState = State . UNKNOWN ; }
Vector processSIMPLEPATTERNLIST ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { try { StringTokenizer tokenizer = new StringTokenizer ( value , STR_ ) ; int nPatterns = tokenizer . countTokens ( ) ; Vector patterns = new Vector ( nPatterns ) ; for ( int i = NUM_ ; i < nPatterns ; i ++ ) { XPath pattern = handler . createMatchPatternXPath ( tokenizer . nextToken ( ) , owner ) ; patterns . addElement ( pattern ) ; } return patterns ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } }
protected ASN1Sequence ( ASN1Encodable [ ] array ) { for ( int i = NUM_ ; i != array . length ; i ++ ) { seq . addElement ( array [ i ] ) ; } }
public void addCopy ( IResource copy , CopyArguments arguments ) { if ( fCopy == null ) { fCopy = new ArrayList ( NUM_ ) ; fCopyArguments = new ArrayList ( NUM_ ) ; } fCopy . add ( copy ) ; fCopyArguments . add ( arguments ) ; addCopyDelta ( copy , arguments ) ; }
@ Override public void write ( byte [ ] buffer , int offset , int length ) throws IOException { while ( ( mByteToSkip > NUM_ || mByteToCopy > NUM_ || mState != STATE_JPEG_DATA ) && length > NUM_ ) { if ( mByteToSkip > NUM_ ) { int byteToProcess = length > mByteToSkip ? mByteToSkip : length ; length -= byteToProcess ; mByteToSkip -= byteToProcess ; offset += byteToProcess ; } if ( mByteToCopy > NUM_ ) { int byteToProcess = length > mByteToCopy ? mByteToCopy : length ; out . write ( buffer , offset , byteToProcess ) ; length -= byteToProcess ; mByteToCopy -= byteToProcess ; offset += byteToProcess ; } if ( length == NUM_ ) { return ; } switch ( mState ) { case STATE_SOI : int byteRead = requestByteToBuffer ( NUM_ , buffer , offset , length ) ; offset += byteRead ; length -= byteRead ; if ( mBuffer . position ( ) < NUM_ ) { return ; } mBuffer . rewind ( ) ; if ( mBuffer . getShort ( ) != JpegHeader . SOI ) { throw new IOException ( STR_ ) ; } out . write ( mBuffer . array ( ) , NUM_ , NUM_ ) ; mState = STATE_FRAME_HEADER ; mBuffer . rewind ( ) ; writeExifData ( ) ; break ; case STATE_FRAME_HEADER : byteRead = requestByteToBuffer ( NUM_ , buffer , offset , length ) ; offset += byteRead ; length -= byteRead ; if ( mBuffer . position ( ) == NUM_ ) { short tag = mBuffer . getShort ( ) ; if ( tag == JpegHeader . EOI ) { out . write ( mBuffer . array ( ) , NUM_ , NUM_ ) ; mBuffer . rewind ( ) ; } } if ( mBuffer . position ( ) < NUM_ ) { return ; } mBuffer . rewind ( ) ; short marker = mBuffer . getShort ( ) ; if ( marker == JpegHeader . APP1 ) { mByteToSkip = ( mBuffer . getShort ( ) & x0000ffff ) - NUM_ ; mState = STATE_JPEG_DATA ; } else if ( ! JpegHeader . isSofMarker ( marker ) ) { out . write ( mBuffer . array ( ) , NUM_ , NUM_ ) ; mByteToCopy = ( mBuffer . getShort ( ) & x0000ffff ) - NUM_ ; } else { out . write ( mBuffer . array ( ) , NUM_ , NUM_ ) ; mState = STATE_JPEG_DATA ; } mBuffer . rewind ( ) ; } } if ( length > NUM_ ) { out . write ( buffer , offset , length ) ; } }
protected boolean [ ] datasetIntegrity ( boolean nominalPredictor , boolean numericPredictor , boolean stringPredictor , boolean datePredictor , boolean relationalPredictor , boolean multiInstance , int classType , boolean predictorMissing , boolean classMissing ) { print ( STR_ ) ; printAttributeSummary ( nominalPredictor , numericPredictor , stringPredictor , datePredictor , relationalPredictor , multiInstance , classType ) ; print ( STR_ ) ; int numTrain = getNumInstances ( ) , numClasses = NUM_ , missingLevel = NUM_ ; boolean [ ] result = new boolean [ NUM_ ] ; Instances train = null ; Instances trainCopy = null ; ASSearch search = null ; ASEvaluation evaluation = null ; try { train = makeTestDataset ( NUM_ , numTrain , nominalPredictor ? getNumNominal ( ) : NUM_ , numericPredictor ? getNumNumeric ( ) : NUM_ , stringPredictor ? getNumString ( ) : NUM_ , datePredictor ? getNumDate ( ) : NUM_ , relationalPredictor ? getNumRelational ( ) : NUM_ , numClasses , classType , multiInstance ) ; if ( missingLevel > NUM_ ) { addMissing ( train , missingLevel , predictorMissing , classMissing ) ; } search = ASSearch . makeCopies ( getSearch ( ) , NUM_ ) [ NUM_ ] ; evaluation = ASEvaluation . makeCopies ( getEvaluator ( ) , NUM_ ) [ NUM_ ] ; trainCopy = new Instances ( train ) ; } catch ( Exception ex ) { throw new Error ( STR_ + ex . getMessage ( ) ) ; } try { search ( search , evaluation , trainCopy ) ; compareDatasets ( train , trainCopy ) ; println ( STR_ ) ; result [ NUM_ ] = BOOL_ ; } catch ( Exception ex ) { println ( STR_ ) ; result [ NUM_ ] = BOOL_ ; if ( m_Debug ) { println ( STR_ ) ; print ( STR_ ) ; println ( STR_ + ex . getMessage ( ) + STR_ ) ; println ( STR_ ) ; println ( STR_ + trainCopy . toString ( ) + STR_ ) ; println ( STR_ + train . toString ( ) + STR_ ) ; } } return result ; }
public void insert_trace ( Polyline p_polyline , int p_layer , int p_half_width , NetNosList p_net_no_arr , int p_clearance_class , ItemFixState p_fixed_state ) { BrdTracep new_trace = insert_trace_without_cleaning ( p_polyline , p_layer , p_half_width , p_net_no_arr , p_clearance_class , p_fixed_state ) ; if ( new_trace == null ) return ; new_trace . normalize ( changed_area . get_area ( p_layer ) ) ; }
void sendTransmit ( MultiplexConnectionInfo info , byte buf [ ] , int off , int len ) throws IOException { synchronized ( dataOut ) { if ( alive && ! info . closed ) try { dataOut . writeByte ( TRANSMIT ) ; dataOut . writeShort ( info . id ) ; dataOut . writeInt ( len ) ; dataOut . write ( buf , off , len ) ; dataOut . flush ( ) ; } catch ( IOException e ) { multiplexLog . log ( Log . BRIEF , STR_ , e ) ; shutDown ( ) ; throw e ; } } }
public < T extends SQLException > T toFlatSQLException ( Class < T > type ) throws ClassCastException { return type . cast ( toFlatSQLException ( ) ) ; }
public void addTotalResultCountCookie ( WorkbenchRequest req , HttpServletResponse resp , int value ) { addCookie ( req , resp , STR_ , String . valueOf ( value ) ) ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
abstract void startPoll ( int fd , int events ) ;
private Rectangle integerise ( Rectangle2D rect ) { int x0 = ( int ) Math . ceil ( rect . getMinX ( ) ) ; int y0 = ( int ) Math . ceil ( rect . getMinY ( ) ) ; int x1 = ( int ) Math . floor ( rect . getMaxX ( ) ) ; int y1 = ( int ) Math . floor ( rect . getMaxY ( ) ) ; return new Rectangle ( x0 , y0 , ( x1 - x0 ) , ( y1 - y0 ) ) ; }
@ Override public void mouseMoved ( MouseEvent evt ) { delegate . mouseMoved ( evt ) ; }
protected void validateConfig ( ) { A . notNull ( getStreamer ( ) , STR_ ) ; A . notNull ( getIgnite ( ) , STR_ ) ; A . notNull ( endpointUrl , STR_ ) ; A . ensure ( getSingleTupleExtractor ( ) != null || getMultipleTupleExtractor ( ) != null , STR_ ) ; String followParam = apiParams . get ( SITE_USER_ID_KEY ) ; A . ensure ( followParam != null && followParam . matches ( STR_ ) , STR_ ) ; }
public long [ ] selectZero ( long rank , long [ ] dest , final int offset , final int length ) { if ( length == NUM_ ) return dest ; long s = selectZero ( rank ) ; dest [ offset ] = s ; int curr = ( int ) ( s / Long . SIZE ) ; long window = ~ bits [ curr ] & - NUM_ << s ; window &= window - NUM_ ; for ( int i = NUM_ ; i < length ; i ++ ) { while ( window == NUM_ ) window = ~ bits [ ++ curr ] ; dest [ offset + i ] = curr . Long . SIZE + Long . numberOfTrailingZeros ( window ) ; window &= window - NUM_ ; } return dest ; }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case NUM_ : return STRING_FIELD ; case NUM_ : return SET_FIELD ; case NUM_ : return LIST_FIELD ; case NUM_ : return BINARY_FIELD ; default : return null ; } }
public int size ( ) { synchronized ( children ) { return children . size ( ) ; } }
private String flattenComment ( String string ) { StringBuffer buffer = new StringBuffer ( string . length ( ) + NUM_ ) ; boolean skipAdjacentLineSeparator = BOOL_ ; for ( int i = NUM_ ; i < string . length ( ) ; i ++ ) { char c = string . charAt ( i ) ; if ( c == STR_ || c == STR_ ) { if ( ! skipAdjacentLineSeparator ) buffer . append ( Policy . bind ( STR_ ) ) ; skipAdjacentLineSeparator = BOOL_ ; } else { buffer . append ( c ) ; skipAdjacentLineSeparator = BOOL_ ; } } return buffer . toString ( ) ; }
private boolean isAccelerating ( SensorEvent event ) { float ax = event . values [ NUM_ ] ; float ay = event . values [ NUM_ ] ; float az = event . values [ NUM_ ] ; final double magnitude = Math . sqrt ( ax . ax + ay . ay + az . az ) ; return magnitude > ACCELERATION_THRESHOLD ; }
@ Override public byte [ ] readByteArray ( String filePath , int length ) { FileChannel fileChannel = updateCache ( filePath ) ; ByteBuffer byteBffer = read ( fileChannel , length ) ; return byteBffer . array ( ) ; }
public void popDragEntry ( int index ) { if ( isIndexInBound ( index ) ) { mDraggedEntry = mDragEntries . get ( index ) ; mDraggedEntryIndex = index ; mDragEnteredEntryIndex = index ; markDropArea ( index ) ; } }
public void test_loadAndVerify_small_quadsMode ( ) throws Exception { final String resource = STR_ ; final Properties p = getProperties ( ) ; p . setProperty ( AbstractTripleStore . Options . QUADS , STR_ ) ; doLoadAndVerifyTest ( resource , p ) ; }
public void addEmail ( EmailEntity email ) { emails . add ( email ) ; }
private static int manhattanDistance ( final int x1 , final int y1 , final int x2 , final int y2 ) { return Math . abs ( x1 - x2 ) + Math . abs ( y1 - y2 ) ; }
private static final boolean compareAndSetWaitStatus ( Node node , int expect , int update ) { return unsafe . compareAndSwapInt ( node , waitStatusOffset , expect , update ) ; }
public void putGrammar ( SchemaGrammar grammar ) { if ( grammar . getTargetNamespace ( ) == null ) fNoNSGrammar = grammar ; else fGrammarRegistry . put ( grammar . getTargetNamespace ( ) , grammar ) ; }
public JSONArray optJSONArray ( String key ) { Object o = opt ( key ) ; return o instanceof JSONArray ? ( JSONArray ) o : null ; }
private void status ( ) { ps . println ( STR_ ) ; ps . println ( STR_ ) ; ps . println ( STR_ ) ; ps . println ( STR_ ) ; writeKeysWithPrefix ( STR_ , STR_ ) ; }
@ Override public void chartProgress ( ChartProgressEvent event ) { }
void pushImportSource ( Source sourceFromURIResolver ) { m_importSourceStack . push ( sourceFromURIResolver ) ; }
public static byte [ ] buildNalUnit ( byte [ ] data , int offset , int length ) { byte [ ] nalUnit = new byte [ length + NAL_START_CODE . length ] ; System . arraycopy ( NAL_START_CODE , NUM_ , nalUnit , NUM_ , NAL_START_CODE . length ) ; System . arraycopy ( data , offset , nalUnit , NAL_START_CODE . length , length ) ; return nalUnit ; }
protected void doLogOobMessageOutbound ( Message message ) { if ( rpcLogger != null ) { rpcLogger . logOobMessage ( clientInfo , serverInfo , message , System . currentTimeMillis ( ) ) ; } }
@ Override public void stop ( ) { CountDownLatch latch = stopped ; Thread oldThread = thread . getAndUpdate ( null ) ; if ( oldThread != null && latch != null ) { try { latch . await ( NUM_ , TimeUnit . SECONDS ) ; } catch ( InterruptedException e ) { Thread . interrupted ( ) ; } } }
@ Override public byte [ ] encode ( BufferedImage bufferedImage ) throws IOException { ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; encode ( bufferedImage , outputStream ) ; return outputStream . toByteArray ( ) ; }
private JsonParserException createHelpfulException ( char first , char [ ] expected , int failurePosition ) throws JsonParserException { StringBuilder errorToken = new StringBuilder ( first + ( expected == null ? STR_ : new String ( expected , NUM_ , failurePosition ) ) ) ; while ( isAsciiLetter ( peekChar ( ) ) && errorToken . length ( ) < NUM_ ) errorToken . append ( ( char ) advanceChar ( ) ) ; return createParseException ( null , STR_ + errorToken + STR_ + ( expected == null ? STR_ : STR_ + first + new String ( expected ) + STR_ ) , BOOL_ ) ; }
public void testConstructorBytesPositive3 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ } ; byte rBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ } ; BigInteger aNumber = new BigInteger ( aBytes ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , aNumber . signum ( ) ) ; }
public static void i ( String tag , String s , Object ... args ) { if ( LOG . INFO >= LOGLEVEL ) Log . i ( tag , String . format ( s , args ) ) ; }
public void removeLifecycleListener ( LifecycleListener lifecycleListener ) { lifecycleListeners . remove ( lifecycleListener ) ; }
private synchronized void initRegistry ( boolean force ) throws MatlabConnectionException { if ( _registry == null || force ) { try { _registry = LocalHostRMIHelper . createRegistry ( _options . getPort ( ) ) ; } catch ( Exception e ) { try { _registry = LocalHostRMIHelper . getRegistry ( _options . getPort ( ) ) ; } catch ( Exception ex ) { throw new MatlabConnectionException ( STR_ , ex ) ; } } } }
public boolean phaseHasTurns ( IGame . Phase thisPhase ) { switch ( thisPhase ) { case PHASE_SET_ARTYAUTOHITHEXES : case PHASE_DEPLOY_MINEFIELDS : case PHASE_DEPLOYMENT : case PHASE_MOVEMENT : case PHASE_FIRING : case PHASE_PHYSICAL : case PHASE_TARGETING : case PHASE_OFFBOARD : return BOOL_ ; default : return BOOL_ ; } }
public int read ( ) throws IOException { int ch1 = is . read ( ) ; int ch2 = is . read ( ) ; if ( ch2 < NUM_ ) return - NUM_ ; return ( ch2 << NUM_ ) + ch1 ; }
public static boolean isUrl ( String resourceLocation ) { if ( resourceLocation == null ) { return BOOL_ ; } if ( resourceLocation . startsWith ( CLASSPATH_URL_PREFIX ) ) { return BOOL_ ; } try { new URL ( resourceLocation ) ; return BOOL_ ; } catch ( MalformedURLException ex ) { return BOOL_ ; } }
public static String encodeURL ( String uri ) { CharBuffer cb = CharBuffer . allocate ( ) ; for ( int i = NUM_ ; i < uri . length ( ) ; i ++ ) { char ch = uri . charAt ( i ) ; switch ( ch ) { case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : cb . append ( STR_ ) ; cb . append ( encodeHex ( ch > > NUM_ ) ) ; cb . append ( encodeHex ( ch ) ) ; break ; default : cb . append ( ch ) ; } } return cb . close ( ) ; }
public void close ( ) throws IOException { if ( closed ) { return ; } if ( queuedForCleanup ) { return ; } try { if ( expected > count ) { long nskip = expected - count ; if ( nskip <= available ( ) ) { do { } while ( ( nskip = ( expected - count ) ) > NUM_ && skip ( Math . min ( nskip , available ( ) ) ) > NUM_ ) ; } else if ( expected <= KeepAliveStreamCleaner . MAX_DATA_REMAINING && ! hurried ) { queueForCleanup ( new KeepAliveCleanerEntry ( this , hc ) ) ; } else { hc . closeServer ( ) ; } } if ( ! closed && ! hurried && ! queuedForCleanup ) { hc . finished ( ) ; } } finally { if ( pi != null ) pi . finishTracking ( ) ; if ( ! queuedForCleanup ) { in = null ; hc = null ; closed = BOOL_ ; } } }
public boolean isPublic ( ) { return Modifier . isPublic ( _method . getModifiers ( ) ) ; }
private Object [ ] initializeCallerHierarchyRoots ( Map < String , Map < String , Set < JsonElement > > > callerMap ) { List < TreeElement < SourceMethodNode , SourceMethodNode > > roots = new ArrayList < TreeElement < SourceMethodNode , SourceMethodNode > > ( ) ; CallerHierarchy callerHierarchy = ( CallerHierarchy ) fInput ; SourceMethodNode rootNode = callerHierarchy . getRoot ( ) ; Set < SourceMethodNode > processedNodes = new HashSet < SourceMethodNode > ( ) ; TreeElement < SourceMethodNode , SourceMethodNode > root = initializeCallerHierarchy ( rootNode , processedNodes , callerMap ) ; return new Object [ ] { root } ; }
private List < Entry > reduceWithDouglasPeuker ( List < Entry > entries , double epsilon ) { if ( epsilon <= NUM_ || entries . size ( ) < NUM_ ) { return entries ; } keep [ NUM_ ] = BOOL_ ; keep [ entries . size ( ) - NUM_ ] = BOOL_ ; algorithmDouglasPeucker ( entries , epsilon , NUM_ , entries . size ( ) - NUM_ ) ; List < Entry > reducedEntries = new ArrayList < Entry > ( ) ; for ( int i = NUM_ ; i < entries . size ( ) ; i ++ ) { if ( keep [ i ] ) { Entry curEntry = entries . get ( i ) ; reducedEntries . add ( new Entry ( curEntry . getVal ( ) , curEntry . getXIndex ( ) ) ) ; } } return reducedEntries ; }
public static double [ ] computeLogAmplitudeSpectrum ( final double [ ] signal ) { double [ ] spectrum = computeAmplitudeSpectrum ( signal ) ; for ( int i = NUM_ ; i < spectrum . length ; i ++ ) { spectrum [ i ] = Math . log ( spectrum [ i ] ) ; } return spectrum ; }
private Segment createMemorySegment ( SegmentDescriptor descriptor ) { File segmentFile = SegmentFile . createSegmentFile ( name , storage . directory ( ) , descriptor . id ( ) , descriptor . version ( ) ) ; Buffer buffer = HeapBuffer . allocate ( Math . min ( DEFAULT_BUFFER_SIZE , descriptor . maxSegmentSize ( ) ) , Integer . MAX_VALUE ) ; descriptor . copyTo ( buffer ) ; Segment segment = new Segment ( new SegmentFile ( segmentFile ) , buffer . slice ( ) , descriptor , createIndex ( descriptor ) , new OffsetPredicate ( ) , serializer . clone ( ) , this ) ; LOGGER . debug ( STR_ , segment ) ; return segment ; }
public static void init ( final AsyncContext context ) { final SecurityContext security = ( SecurityContext ) context . getAttribute ( AsyncContext . SECURITY_CTX ) ; final boolean forceSetSecurity = forceSetSecurityContext ( context ) ; if ( forceSetSecurity ) { SecurityContextHolder . setContext ( security ) ; } ctx . set ( context ) ; }
private void cancelPreviousWebRtcNotifications ( ) { Set < String > notificationIds = mSharedPreferences . getStringSet ( WEBRTC_NOTIFICATION_IDS , null ) ; if ( notificationIds == null ) return ; Iterator < String > iterator = notificationIds . iterator ( ) ; while ( iterator . hasNext ( ) ) { mNotificationManager . cancel ( NOTIFICATION_NAMESPACE , Integer . parseInt ( iterator . next ( ) ) ) ; } SharedPreferences . Editor sharedPreferenceEditor = mSharedPreferences . edit ( ) ; sharedPreferenceEditor . remove ( MediaCaptureNotificationService . WEBRTC_NOTIFICATION_IDS ) ; sharedPreferenceEditor . apply ( ) ; }
public static final String readString ( byte [ ] bytes , int offset , int length , String charset ) throws IOException { return readString ( bytes , NUM_ , bytes . length , Charset . forName ( charset ) ) ; }
private TopologyUpdaterThread ( ) { super ( id + STR_ ) ; }
private void typeParametersRest ( List < ? extends TypeParameterTree > typeParameters , Indent plusIndent ) { builder . open ( plusIndent ) ; builder . breakOp ( ) ; builder . open ( ZERO ) ; boolean first = BOOL_ ; for ( TypeParameterTree typeParameter : typeParameters ) { if ( ! first ) { token ( STR_ ) ; builder . breakOp ( STR_ ) ; } scan ( typeParameter , null ) ; first = BOOL_ ; } token ( STR_ ) ; builder . close ( ) ; builder . close ( ) ; }
public void writeString ( String str ) throws IOException { if ( str == null ) writeInt ( NUM_ ) ; else { if ( useCompression && str . length ( ) >= Compressor . MIN_SIZE_FOR_DEFLATION ) { byte [ ] bytes = compressor . deflateString2ByteArray ( str ) ; writeInt ( - bytes . length ) ; outs . write ( bytes , NUM_ , bytes . length ) ; position += bytes . length ; } else { byte [ ] bytes = str . getBytes ( STR_ ) ; writeInt ( bytes . length ) ; outs . write ( bytes , NUM_ , bytes . length ) ; position += bytes . length ; } } }
public void dequeueSound ( Uri uri ) { mAudioQueue . remove ( new AudioQueueItem ( uri , null ) ) ; }
public void removeBookmark ( final CBookmark bookmark ) { Preconditions . checkNotNull ( bookmark , STR_ ) ; Preconditions . checkArgument ( m_bookmarks . remove ( bookmark ) , STR_ ) ; for ( final IBookmarkManagerListener listener : m_listeners ) { try { listener . removedBookmark ( this , bookmark ) ; } catch ( final Exception exception ) { CUtilityFunctions . logException ( exception ) ; } } }
public static KeyStore loadKeyStore ( String type , File file , char [ ] password ) throws Exception { KeyStore keyStore = KeyStore . getInstance ( type ) ; try ( FileInputStream fis = new FileInputStream ( file ) ) { keyStore . load ( fis , password ) ; } return keyStore ; }
public void loop ( double ellapsedMillis ) { for ( SpringSystemListener listener : mListeners ) { listener . onBeforeIntegrate ( this ) ; } advance ( ellapsedMillis ) ; if ( mActiveSprings . isEmpty ( ) ) { mIdle = BOOL_ ; } for ( SpringSystemListener listener : mListeners ) { listener . onAfterIntegrate ( this ) ; } if ( mIdle ) { mSpringLooper . stop ( ) ; } }
private void updateRecordingTrack ( Track track , long lastTrackPointId , boolean increaseNumberOfPoints ) { if ( lastTrackPointId >= NUM_ ) { if ( track . getStartId ( ) < NUM_ ) { track . setStartId ( lastTrackPointId ) ; } track . setStopId ( lastTrackPointId ) ; } if ( increaseNumberOfPoints ) { track . setNumberOfPoints ( track . getNumberOfPoints ( ) + NUM_ ) ; } trackTripStatisticsUpdater . updateTime ( System . currentTimeMillis ( ) ) ; track . setTripStatistics ( trackTripStatisticsUpdater . getTripStatistics ( ) ) ; myTracksProviderUtils . updateTrack ( track ) ; }
@ Override public void requestStartupUpdates ( String from , byte [ ] tableKey , int podIndex , long deltaTime , Result < Boolean > cont ) { if ( log . isLoggable ( Level . FINEST ) ) { log . finest ( STR_ + from + STR_ + podIndex + STR_ + deltaTime ) ; } long accessTime = CurrentTime . currentTime ( ) + deltaTime ; TablePod tablePod = _clientKraken . getTable ( tableKey ) ; if ( tablePod == null ) { if ( log . isLoggable ( Level . FINEST ) ) { log . finest ( L . l ( STR_ , Hex . toShortHex ( tableKey ) , BartenderSystem . getCurrentSelfServer ( ) ) ) ; } cont . ok ( BOOL_ ) ; return ; } tablePod . getUpdatesFromLocal ( podIndex , accessTime , cont ) ; }
private void refreshMuteVideoButton ( ) { if ( ( null != mCall ) && mCall . isVideo ( ) ) { mMuteLocalCameraView . setVisibility ( View . VISIBLE ) ; boolean isMuted = mCall . isVideoRecordingMuted ( ) ; Log . d ( LOG_TAG , STR_ + isMuted ) ; int iconId = isMuted ? R . drawable . ic_material_videocam_off_pink_red : R . drawable . ic_material_videocam_off_grey ; mMuteLocalCameraView . setImageResource ( iconId ) ; } else { Log . d ( LOG_TAG , STR_ ) ; mMuteLocalCameraView . setVisibility ( View . INVISIBLE ) ; } }
public boolean isAutoUpdateTrl ( String TableName ) { if ( super . isMultiLingualDocument ( ) ) return BOOL_ ; if ( TableName == null ) return BOOL_ ; if ( TableName . startsWith ( STR_ ) && getAD_Client_ID ( ) == NUM_ ) return BOOL_ ; return BOOL_ ; }
private void createPreferenceControls ( Composite parent , Set < PreferenceId > preferenceSet , InputDefinition inputDefinition ) { for ( PreferenceId preferenceIdEnum : preferenceSet ) { IPreferenceControl preferenceControl = PreferenceControlFactory . createPreferenceControls ( parent , toolkit , preferenceIdEnum , this , inputDefinition ) ; if ( null != preferenceControl ) { preferenceControlList . add ( preferenceControl ) ; } } }
@ RequestMapping ( value = STR_ , method = POST , produces = APPLICATION_JSON_VALUE ) public ResponseEntity < PageResponse < ProjectDTO > > findAll ( @ RequestBody PageRequestByExample < ProjectDTO > prbe ) throws URISyntaxException { PageResponse < ProjectDTO > pageResponse = projectDTOService . findAll ( prbe ) ; return new ResponseEntity < > ( pageResponse , new HttpHeaders ( ) , HttpStatus . OK ) ; }
public void testSHAProvider ( ) { MessageDigest md = null ; try { md = MessageDigest . getInstance ( STR_ ) ; } catch ( NoSuchAlgorithmException e ) { fail ( STR_ + e ) ; } byte [ ] bytes = new byte [ ] { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; try { md . update ( bytes , - NUM_ , NUM_ ) ; fail ( STR_ ) ; } catch ( IndexOutOfBoundsException e ) { } try { md . update ( bytes , NUM_ , - NUM_ ) ; fail ( STR_ ) ; } catch ( IndexOutOfBoundsException e ) { } try { md = MessageDigest . getInstance ( STR_ ) ; } catch ( NoSuchAlgorithmException e ) { fail ( STR_ + e ) ; } try { md . digest ( bytes , NUM_ , - NUM_ ) ; fail ( STR_ ) ; } catch ( DigestException e ) { } try { md . digest ( bytes , - NUM_ , NUM_ ) ; fail ( STR_ ) ; } catch ( DigestException e ) { } try { md = MessageDigest . getInstance ( STR_ ) ; fail ( STR_ ) ; } catch ( NoSuchAlgorithmException e ) { } }
private static boolean isInputExhausted ( StreamTokenizer input ) throws ParseError { try { if ( input . nextToken ( ) == StreamTokenizer . TT_EOF ) { return BOOL_ ; } input . pushBack ( ) ; return BOOL_ ; } catch ( IOException e ) { throw new ParseError ( e . getMessage ( ) ) ; } }
public void clear ( ) { m . clear ( ) ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
public static void writeUnsafe ( PacketOutputStream out , InputStream is , long length , boolean noBackslashEscapes ) throws IOException { out . writeUnsafe ( QUOTE ) ; byte [ ] buffer = new byte [ NUM_ ] ; long bytesLeft = length ; int len ; for ( ; ; ) { int bytesToRead = ( int ) Math . min ( bytesLeft , buffer . length ) ; if ( bytesToRead == NUM_ ) { break ; } len = is . read ( buffer , NUM_ , bytesToRead ) ; if ( len <= NUM_ ) { break ; } writeBytesEscapedUnsafe ( out , buffer , len , noBackslashEscapes ) ; bytesLeft -= len ; } out . writeUnsafe ( QUOTE ) ; }
public SQLQuery ( Class < T > type , String sqlExpression , QueryResultType queryResultType ) { this ( sqlExpression , type . getName ( ) , null , queryResultType , null ) ; }
public Builder retry ( long duration , TimeUnit timeUnit ) { this . retry = timeUnit . toSeconds ( duration ) ; return this ; }
private RecordBuffer < R > tryTake ( long elapsedWaiting ) { RecordBuffer < R > result = null ; if ( ! retryQueue . isEmpty ( ) ) { result = retryQueue . poll ( ) ; } else { result = neverPubQueue . poll ( ) ; } if ( result != null ) { return onTakeSuccess ( result , elapsedWaiting ) ; } else if ( elapsedWaiting > NUM_ ) { return onTakeTimeout ( elapsedWaiting ) ; } else return null ; }
public void testConstructorBytesNegative1 ( ) { byte aBytes [ ] = { - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte rBytes [ ] = { - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aBytes ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , - NUM_ , aNumber . signum ( ) ) ; }
private < T > List < T > toSortedList ( T [ ] array , Comparator < T > comparator ) { List < T > list = new ArrayList < > ( ) ; Collections . addAll ( list , array ) ; Collections . sort ( list , comparator ) ; return list ; }
private GeoMark reverse_geocode ( final String text ) { for ( String t : text . split ( STR_ ) ) { if ( t . length ( ) < NUM_ ) continue ; String [ ] c = t . split ( STR_ ) ; if ( c . length != NUM_ ) continue ; try { double lat = Double . parseDouble ( c [ NUM_ ] ) ; double lon = Double . parseDouble ( c [ NUM_ ] ) ; GeoMark mark = cityNear ( lat , lon ) ; if ( mark == null ) continue ; return mark ; } catch ( NumberFormatException e ) { continue ; } } return null ; }
public ArrayList < PlaToupleInt > entrance_points ( Polyline p_polyline ) { ArrayList < PlaToupleInt > result = new ArrayList < PlaToupleInt > ( NUM_ . p_polyline . plaline_len ( ) ) ; int prev_intersection_line_no = - NUM_ ; int prev_intersection_edge_no = - NUM_ ; for ( int line_no = NUM_ ; line_no < p_polyline . plaline_len ( - NUM_ ) ; ++ line_no ) { PlaSegmentInt curr_line_seg = p_polyline . segment_get ( line_no ) ; int [ ] curr_intersections = curr_line_seg . border_intersections ( this ) ; for ( int index = NUM_ ; index < curr_intersections . length ; ++ index ) { int edge_no = curr_intersections [ index ] ; if ( line_no != prev_intersection_line_no || edge_no != prev_intersection_edge_no ) { result . add ( new PlaToupleInt ( line_no , edge_no ) ) ; prev_intersection_line_no = line_no ; prev_intersection_edge_no = edge_no ; } } } return result ; }
private void emitClear ( String fieldName , StringBuilder builder ) { builder . append ( STR_ ) ; builder . append ( getClearName ( fieldName ) ) ; builder . append ( STR_ ) ; builder . append ( getEnsureName ( fieldName ) ) ; builder . append ( STR_ ) ; builder . append ( fieldName ) ; builder . append ( STR_ ) ; builder . append ( STR_ ) ; }
public static byte [ ] serializeAsByteArray ( Object b ) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ObjectOutputStream out = new ObjectOutputStream ( bos ) ; try { out . writeObject ( b ) ; } finally { out . close ( ) ; } return bos . toByteArray ( ) ; }
public static void putIntLE ( long addr , int val ) { if ( UNALIGNED ) UNSAFE . putInt ( addr , Integer . reverseBytes ( val ) ) ; else putIntByByte ( addr , val , BOOL_ ) ; }
public FloatingActionButton createSubFAB ( char icon , String text ) { FloatingActionButton sub = new FloatingActionButton ( icon , text , NUM_ ) ; if ( subMenu == null ) { subMenu = new ArrayList < FloatingActionButton > ( ) ; } subMenu . add ( sub ) ; return sub ; }
public String readValue ( InputNode from ) throws Exception { if ( ! stack . isRelevant ( from ) ) { return null ; } int length = text . length ( ) ; if ( length <= NUM_ ) { EventNode event = reader . peek ( ) ; if ( event . isEnd ( ) ) { if ( stack . top ( ) == from ) { return null ; } else { stack . pop ( ) ; } event = reader . next ( ) ; } } return readText ( from ) ; }
private void fitImageToView ( ) { Drawable drawable = getDrawable ( ) ; if ( drawable == null || drawable . getIntrinsicWidth ( ) == NUM_ || drawable . getIntrinsicHeight ( ) == NUM_ ) { return ; } if ( matrix == null || prevMatrix == null ) { return ; } int drawableWidth = drawable . getIntrinsicWidth ( ) ; int drawableHeight = drawable . getIntrinsicHeight ( ) ; float scaleX = ( float ) viewWidth / drawableWidth ; float scaleY = ( float ) viewHeight / drawableHeight ; switch ( mScaleType ) { case CENTER : scaleX = scaleY = NUM_ ; break ; case CENTER_CROP : scaleX = scaleY = Math . max ( scaleX , scaleY ) ; break ; case CENTER_INSIDE : scaleX = scaleY = Math . min ( NUM_ , Math . min ( scaleX , scaleY ) ) ; case FIT_CENTER : scaleX = scaleY = Math . min ( scaleX , scaleY ) ; break ; case FIT_XY : break ; default : throw new UnsupportedOperationException ( STR_ ) ; } float redundantXSpace = viewWidth - ( scaleX . drawableWidth ) ; float redundantYSpace = viewHeight - ( scaleY . drawableHeight ) ; matchViewWidth = viewWidth - redundantXSpace ; matchViewHeight = viewHeight - redundantYSpace ; if ( ! isZoomed ( ) && ! imageRenderedAtLeastOnce ) { matrix . setScale ( scaleX , scaleY ) ; matrix . postTranslate ( redundantXSpace / NUM_ , redundantYSpace / NUM_ ) ; normalizedScale = NUM_ ; } else { if ( prevMatchViewWidth == NUM_ || prevMatchViewHeight == NUM_ ) { savePreviousImageValues ( ) ; } prevMatrix . getValues ( m ) ; m [ Matrix . MSCALE_X ] = matchViewWidth / drawableWidth . normalizedScale ; m [ Matrix . MSCALE_Y ] = matchViewHeight / drawableHeight . normalizedScale ; float transX = m [ Matrix . MTRANS_X ] ; float transY = m [ Matrix . MTRANS_Y ] ; float prevActualWidth = prevMatchViewWidth . normalizedScale ; float actualWidth = getImageWidth ( ) ; translateMatrixAfterRotate ( Matrix . MTRANS_X , transX , prevActualWidth , actualWidth , prevViewWidth , viewWidth , drawableWidth ) ; float prevActualHeight = prevMatchViewHeight . normalizedScale ; float actualHeight = getImageHeight ( ) ; translateMatrixAfterRotate ( Matrix . MTRANS_Y , transY , prevActualHeight , actualHeight , prevViewHeight , viewHeight , drawableHeight ) ; matrix . setValues ( m ) ; } fixTrans ( ) ; setImageMatrix ( matrix ) ; }
private void dispatchOnThirdPartyRegistered ( ) { synchronized ( this ) { for ( ThirdPartyRegistrationListener listener : mThirdPartyRegistrationListeners ) { try { listener . onThirdPartyRegistered ( ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , STR_ + e . getLocalizedMessage ( ) ) ; } } mThirdPartyRegistrationListeners . clear ( ) ; } }
void updateForDecoderTypeID ( List < DecoderFile > pList ) { decoderBox . setModel ( DecoderIndexFile . jComboBoxModelFromList ( pList ) ) ; decoderBox . insertItemAt ( STR_ , NUM_ ) ; decoderBox . setSelectedIndex ( NUM_ ) ; }
@ Override public void actionPerformed ( ActionEvent event ) { switch ( event . getActionCommand ( ) ) { case NEW_ALIAS : addAlias ( new Alias ( STR_ ) ) ; break ; case COPY_ALIAS : for ( Alias alias : getSelectedAliases ( ) ) { addAlias ( AliasFactory . copyOf ( alias ) ) ; } break ; case DELETE_ALIAS : List < Alias > toDelete = getSelectedAliases ( ) ; if ( toDelete != null && ! toDelete . isEmpty ( ) ) { String title = toDelete . size ( ) == NUM_ ? STR_ : STR_ ; String prompt = toDelete . size ( ) == NUM_ ? STR_ : STR_ + toDelete . size ( ) + STR_ ; int choice = JOptionPane . showConfirmDialog ( AliasController . this , prompt , title , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( choice == JOptionPane . YES_OPTION ) { for ( Alias alias : toDelete ) { mAliasModel . removeAlias ( alias ) ; } } } break ; default : break ; } }
public boolean directionKeyIsPressed ( ) { return pressedStateKeys . contains ( KeyEvent . VK_UP ) || pressedStateKeys . contains ( KeyEvent . VK_DOWN ) || pressedStateKeys . contains ( KeyEvent . VK_LEFT ) || pressedStateKeys . contains ( KeyEvent . VK_RIGHT ) || pressedStateKeys . contains ( KeyEvent . VK_KP_LEFT ) || pressedStateKeys . contains ( KeyEvent . VK_KP_RIGHT ) || pressedStateKeys . contains ( KeyEvent . VK_KP_UP ) || pressedStateKeys . contains ( KeyEvent . VK_KP_DOWN ) ; }
private void calculateCalibration ( long difference , float currentMeasure , byte currentIndex ) { if ( difference >= MedtronicConstants . TIME_15_MIN_IN_MS && difference < MedtronicConstants . TIME_20_MIN_IN_MS ) { if ( isSensorMeasureInRange ( currentIndex , expectedSensorSortNumberForCalibration ) ) { isCalibrating = BOOL_ ; calibrationStatus = MedtronicConstants . CALIBRATED ; calibrationIsigValue = currentMeasure ; SharedPreferences . Editor editor = settings . edit ( ) ; calibrationFactor = lastGlucometerValue / calibrationIsigValue ; editor . remove ( STR_ ) ; editor . remove ( STR_ ) ; editor . putFloat ( STR_ , ( float ) calibrationFactor ) ; editor . putInt ( STR_ , calibrationStatus ) ; editor . commit ( ) ; } else { if ( calibrationStatus != MedtronicConstants . WITHOUT_ANY_CALIBRATION && currentIndex != expectedSensorSortNumber ) { calibrationStatus = MedtronicConstants . LAST_CALIBRATION_FAILED_USING_PREVIOUS ; isCalibrating = BOOL_ ; } else { calibrationStatus = MedtronicConstants . WITHOUT_ANY_CALIBRATION ; } SharedPreferences . Editor editor = settings . edit ( ) ; editor . remove ( STR_ ) ; editor . remove ( STR_ ) ; editor . commit ( ) ; } } else if ( difference >= MedtronicConstants . TIME_20_MIN_IN_MS ) { if ( isSensorMeasureInRange ( currentIndex , expectedSensorSortNumberForCalibration ) ) { calibrationStatus = MedtronicConstants . CALIBRATED_IN_15MIN ; calibrationIsigValue = currentMeasure ; SharedPreferences . Editor editor = settings . edit ( ) ; calibrationFactor = lastGlucometerValue / calibrationIsigValue ; editor . remove ( STR_ ) ; editor . remove ( STR_ ) ; editor . putFloat ( STR_ , ( float ) calibrationFactor ) ; editor . putInt ( STR_ , calibrationStatus ) ; editor . commit ( ) ; } else { if ( calibrationStatus != MedtronicConstants . WITHOUT_ANY_CALIBRATION ) calibrationStatus = MedtronicConstants . LAST_CALIBRATION_FAILED_USING_PREVIOUS ; else { calibrationStatus = MedtronicConstants . WITHOUT_ANY_CALIBRATION ; } SharedPreferences . Editor editor = settings . edit ( ) ; editor . remove ( STR_ ) ; editor . remove ( STR_ ) ; editor . commit ( ) ; } isCalibrating = BOOL_ ; } else { if ( isCalibrating ) { if ( difference < MedtronicConstants . TIME_5_MIN_IN_MS ) { calibrationStatus = MedtronicConstants . CALIBRATING ; } else if ( difference >= MedtronicConstants . TIME_5_MIN_IN_MS && difference <= MedtronicConstants . TIME_15_MIN_IN_MS ) calibrationStatus = MedtronicConstants . CALIBRATING2 ; else calibrationStatus = MedtronicConstants . CALIBRATING ; } else { if ( calibrationStatus != MedtronicConstants . WITHOUT_ANY_CALIBRATION ) calibrationStatus = MedtronicConstants . LAST_CALIBRATION_FAILED_USING_PREVIOUS ; else { calibrationStatus = MedtronicConstants . WITHOUT_ANY_CALIBRATION ; } SharedPreferences . Editor editor = settings . edit ( ) ; editor . remove ( STR_ ) ; editor . remove ( STR_ ) ; editor . putInt ( STR_ , calibrationStatus ) ; editor . commit ( ) ; } } }
public void addPosition ( int offset , int length , String ... ids ) { TextAttribute highlighting = ids . length == NUM_ ? attributeProvider . getAttribute ( ids [ NUM_ ] ) : attributeProvider . getMergedAttributes ( ids ) ; boolean isExisting = BOOL_ ; for ( int i = NUM_ , n = removedPositions . size ( ) ; i < n ; i ++ ) { AttributedPosition position = removedPositions . get ( i ) ; if ( position == null ) continue ; if ( position . isEqual ( offset , length , highlighting ) ) { isExisting = BOOL_ ; removedPositions . set ( i , null ) ; removedPositionCount -- ; break ; } } if ( ! isExisting ) { AttributedPosition position = presenter . createHighlightedPosition ( offset , length , highlighting ) ; addedPositions . add ( position ) ; } }
static void exportMaskUpdate ( ExportMask exportMask , Map < URI , Integer > volumeMap , List < Initiator > initiators , List < URI > targets ) { if ( volumeMap != null ) { for ( URI volume : volumeMap . keySet ( ) ) { exportMask . addVolume ( volume , volumeMap . get ( volume ) ) ; } } if ( initiators != null ) { for ( Initiator initiator : initiators ) { exportMask . addInitiator ( initiator ) ; } } if ( targets != null ) { for ( URI target : targets ) { exportMask . addTarget ( target ) ; } } }
private void internalAddHead ( final MessageReference ref ) { queueMemorySize . addAndGet ( ref . getMessageMemoryEstimate ( ) ) ; refAdded ( ref ) ; int priority = getPriority ( ref ) ; messageReferences . addHead ( ref , priority ) ; }
private boolean createNew ( MProduct product , MAcctSchema as ) { MCost dimension = MCost . getOrCreate ( product , NUM_ , as , NUM_ , NUM_ , as . getM_CostType_ID ( ) , m_ce . getM_CostElement_ID ( ) ) ; if ( dimension . is_new ( ) ) return dimension . save ( ) ; return BOOL_ ; }
@ Override protected void step ( ) { while ( iter . hasNext ( ) ) { reg = ( SvcReg ) iter . next ( ) ; if ( reg . leaseExpiration > now ) return ; } reg = null ; }
public Enumeration < String > packages ( ) { return m_Cache . keys ( ) ; }
protected int size ( ) { return document . length ( ) ; }
public TPS currentRow ( ) { return currentRow ( null ) ; }
public final void deleteAllEntries ( ) { if ( numEntries > NUM_ ) { Arrays . fill ( entries , null ) ; this . numEntries = NUM_ ; } }
public List < Map < String , Object > > query ( final String indexName , final String q , final Operator operator , final int offset , final int count ) { assert count > NUM_ ; SearchRequestBuilder request = elasticsearchClient . prepareSearch ( indexName ) . setQuery ( QueryBuilders . multiMatchQuery ( q , STR_ ) . operator ( operator ) . zeroTermsQuery ( ZeroTermsQuery . ALL ) ) . setFrom ( offset ) . setSize ( count ) ; SearchResponse response = request . execute ( ) . actionGet ( ) ; SearchHit [ ] hits = response . getHits ( ) . getHits ( ) ; ArrayList < Map < String , Object > > result = new ArrayList < Map < String , Object > > ( ) ; for ( SearchHit hit : hits ) { Map < String , Object > map = hit . getSource ( ) ; result . add ( map ) ; } return result ; }
public SortedSet < String > plugins ( ) { SortedSet < String > r = new TreeSet < > ( ) ; for ( NamePair p : items . keySet ( ) ) { r . add ( p . pluginName ) ; } return Collections . unmodifiableSortedSet ( r ) ; }
public static void error ( int WindowNo , Container c , String AD_Message ) { error ( WindowNo , c , AD_Message , null ) ; }
public ReilFunction translate ( final ITranslationEnvironment environment , final IBlockContainer < InstructionType > function ) throws InternalTranslationException { return translate ( environment , function , new ArrayList < ITranslationExtension < InstructionType > > ( ) ) ; }
public Name parse ( String name ) throws NamingException { Vector < String > comps = insStringToStringifiedComps ( name ) ; return new CNCompoundName ( comps . elements ( ) ) ; }
public CSVDataSourceFactory ( ) { super ( STR_ , CSV_MIME_TYPES , CSV_FILE_ENDINGS , CSVFormatSpecificationWizardStep . CSV_FORMAT_SPECIFICATION_STEP_ID ) ; }
private void sendAck ( String index , String message , GuacamoleStatus status ) { if ( status != GuacamoleStatus . SUCCESS ) closeInterceptedStream ( index ) ; sendInstruction ( new GuacamoleInstruction ( STR_ , index , message , Integer . toString ( status . getGuacamoleStatusCode ( ) ) ) ) ; }
public static boolean isWindowsPlatform ( ) { String os = System . getProperty ( STR_ ) ; return ( os != null && os . startsWith ( WIN_ID ) ) ; }
static public int countRangesThatCollideZone ( List < Bounds > ranges , List < Bounds > zoneRanges ) { int overallEOAA = NUM_ ; Collections . sort ( zoneRanges ) ; for ( Bounds extractedBounds : ranges ) { for ( Bounds expectedBounds : zoneRanges ) { if ( expectedBounds . start >= extractedBounds . end ) { break ; } if ( extractedBounds . overlaps ( expectedBounds ) ) { overallEOAA ++ ; break ; } } } return overallEOAA ; }
public static boolean timeStampChanged ( String location ) { synchronized ( installLock ) { if ( fgHasChanged . contains ( location ) ) { return BOOL_ ; } File file = new File ( location ) ; if ( file . exists ( ) ) { if ( fgInstallTimeMap == null ) { readInstallInfo ( ) ; } Long stamp = fgInstallTimeMap . get ( location ) ; long fstamp = file . lastModified ( ) ; if ( stamp != null ) { if ( stamp . longValue ( ) == fstamp ) { return BOOL_ ; } } stamp = new Long ( fstamp ) ; fgInstallTimeMap . put ( location , stamp ) ; writeInstallInfo ( ) ; fgHasChanged . add ( location ) ; return BOOL_ ; } } return BOOL_ ; }
public static Boolean [ ] valuesOf ( boolean [ ] array ) { Boolean [ ] dest = new Boolean [ array . length ] ; for ( int i = NUM_ ; i < array . length ; i ++ ) { dest [ i ] = Boolean . valueOf ( array [ i ] ) ; } return dest ; }
public void addUpdateListener ( AnimatorUpdateListener listener ) { if ( mUpdateListeners == null ) { mUpdateListeners = new ArrayList < AnimatorUpdateListener > ( ) ; } mUpdateListeners . add ( listener ) ; }
private void correctTooHigh ( int childCount ) { int lastPosition = mFirstPosition + childCount - NUM_ ; if ( lastPosition == mItemCount - NUM_ && childCount > NUM_ ) { final int lastBottom = getLowestChildBottom ( ) ; final int end = ( getBottom ( ) - getTop ( ) ) - getListPaddingBottom ( ) ; int bottomOffset = end - lastBottom ; final int firstTop = getHighestChildTop ( ) ; if ( bottomOffset > NUM_ && ( mFirstPosition > NUM_ || firstTop < getListPaddingTop ( ) ) ) { if ( mFirstPosition == NUM_ ) { bottomOffset = Math . min ( bottomOffset , getListPaddingTop ( ) - firstTop ) ; } offsetChildrenTopAndBottom ( bottomOffset ) ; if ( mFirstPosition > NUM_ ) { int previousPosition = mFirstPosition - NUM_ ; fillUp ( previousPosition , getNextChildUpsBottom ( previousPosition ) ) ; adjustViewsUpOrDown ( ) ; } } } }
public static boolean writeLine ( String fileName , String value ) { BufferedWriter writer = null ; try { writer = new BufferedWriter ( new FileWriter ( fileName ) ) ; writer . write ( value ) ; } catch ( FileNotFoundException e ) { Log . w ( TAG , STR_ + fileName + STR_ , e ) ; return BOOL_ ; } catch ( IOException e ) { Log . e ( TAG , STR_ + fileName , e ) ; return BOOL_ ; } finally { try { if ( writer != null ) { writer . close ( ) ; } } catch ( IOException e ) { } } return BOOL_ ; }
public void didRollback ( ) { synchronized ( this ) { if ( pending != null ) { pending . cancel ( BOOL_ ) ; pending = null ; } docsSinceCommit . set ( NUM_ ) ; } }
@ Override protected void calculateThumbLocation ( ) { super . calculateThumbLocation ( ) ; if ( slider . getSnapToTicks ( ) ) { int upperValue = slider . getValue ( ) + slider . getExtent ( ) ; int snappedValue = upperValue ; int majorTickSpacing = slider . getMajorTickSpacing ( ) ; int minorTickSpacing = slider . getMinorTickSpacing ( ) ; int tickSpacing = NUM_ ; if ( minorTickSpacing > NUM_ ) { tickSpacing = minorTickSpacing ; } else if ( majorTickSpacing > NUM_ ) { tickSpacing = majorTickSpacing ; } if ( tickSpacing != NUM_ ) { if ( ( upperValue - slider . getMinimum ( ) ) % tickSpacing != NUM_ ) { float temp = ( float ) ( upperValue - slider . getMinimum ( ) ) / ( float ) tickSpacing ; int whichTick = Math . round ( temp ) ; snappedValue = slider . getMinimum ( ) + ( whichTick . tickSpacing ) ; } if ( snappedValue != upperValue ) { slider . setExtent ( snappedValue - slider . getValue ( ) ) ; } } } if ( slider . getOrientation ( ) == JSlider . HORIZONTAL ) { int upperPosition = xPositionForValue ( slider . getValue ( ) + slider . getExtent ( ) ) ; upperThumbRect . x = upperPosition - ( upperThumbRect . width / NUM_ ) ; upperThumbRect . y = trackRect . y ; } else { int upperPosition = yPositionForValue ( slider . getValue ( ) + slider . getExtent ( ) ) ; upperThumbRect . x = trackRect . x ; upperThumbRect . y = upperPosition - ( upperThumbRect . height / NUM_ ) ; } }
public void compile ( int throughPhase ) throws CompilationFailedException { gotoPhase ( Phases . INITIALIZATION ) ; throughPhase = Math . min ( throughPhase , Phases . ALL ) ; while ( throughPhase >= phase && phase <= Phases . ALL ) { if ( phase == Phases . SEMANTIC_ANALYSIS ) { doPhaseOperation ( resolve ) ; if ( dequeued ( ) ) continue ; } processPhaseOperations ( phase ) ; processNewPhaseOperations ( phase ) ; if ( progressCallback != null ) progressCallback . call ( this , phase ) ; completePhase ( ) ; applyToSourceUnits ( mark ) ; if ( dequeued ( ) ) continue ; gotoPhase ( phase + NUM_ ) ; if ( phase == Phases . CLASS_GENERATION ) { sortClasses ( ) ; } } errorCollector . failIfErrors ( ) ; }
public String generateBearerToken ( String email , String username , Map < String , String > payload ) { String token = tokenGenerator . generate ( ) ; Map < String , String > payloadCopy = payload == null ? new HashMap ( ) : new HashMap ( payload ) ; payloadCopy . put ( STR_ , email ) ; payloadCopy . put ( STR_ , username ) ; payloadCopy . put ( STR_ , Long . toString ( System . currentTimeMillis ( ) ) ) ; tokenMap . put ( token , payloadCopy ) ; return token ; }
public void endDocument ( Augmentations augs ) throws XNIException { try { if ( fDocumentHandler != null ) { fDocumentHandler . endDocument ( ) ; } if ( fContentHandler != null ) { fContentHandler . endDocument ( ) ; } } catch ( SAXException e ) { throw new XNIException ( e ) ; } }
public final ConnectionState newInput ( ) throws IOException { if ( in . hasRemaining ( ) ) { throw new RuntimeException ( STR_ ) ; } in . clear ( ) ; int r = ch . read ( in ) ; if ( r == - NUM_ ) throw new IOException ( STR_ ) ; if ( r == NUM_ ) return ConnectionState . SELECTOR_WAIT_FOR_NEW_INPUT ; in . flip ( ) ; return newRequestChunk ( ) ; }
protected final void refreshLoadingViewsSize ( ) { final int maximumPullScroll = ( int ) ( getMaximumPullScroll ( ) . NUM_ ) ; int pLeft = getPaddingLeft ( ) ; int pTop = getPaddingTop ( ) ; int pRight = getPaddingRight ( ) ; int pBottom = getPaddingBottom ( ) ; switch ( getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setWidth ( maximumPullScroll ) ; pLeft = - maximumPullScroll ; } else { pLeft = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setWidth ( maximumPullScroll ) ; pRight = - maximumPullScroll ; } else { pRight = NUM_ ; } break ; case VERTICAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setHeight ( maximumPullScroll ) ; pTop = - maximumPullScroll ; } else { pTop = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setHeight ( maximumPullScroll ) ; pBottom = - maximumPullScroll ; } else { pBottom = NUM_ ; } break ; } if ( DEBUG ) { Log . d ( LOG_TAG , String . format ( STR_ , pLeft , pTop , pRight , pBottom ) ) ; } setPadding ( pLeft , pTop , pRight , pBottom ) ; }
public boolean canMoveForward ( ) { return currentIndex >= NUM_ && currentIndex < ( history . size ( ) - NUM_ ) ; }
public void clearCache ( ) { DiskLruCache . clearCache ( mCacheDir ) ; }
public void addNaturalJoinColumn ( Column c ) { if ( naturalJoinColumns == null ) { naturalJoinColumns = New . arrayList ( ) ; } naturalJoinColumns . add ( c ) ; }
private RefactoringStatus checkCanCreateIntermediaryMethod ( ) throws JavaModelException { List < ITypeBinding > parameterBindings = new ArrayList < ITypeBinding > ( ) ; if ( ! isStaticTarget ( ) ) parameterBindings . add ( fIntermediaryFirstParameterType ) ; parameterBindings . addAll ( Arrays . asList ( fTargetMethodBinding . getParameterTypes ( ) ) ) ; return Checks . checkMethodInType ( fIntermediaryTypeBinding , fIntermediaryMethodName , parameterBindings . toArray ( new ITypeBinding [ parameterBindings . size ( ) ] ) ) ; }
@ Override public String generateToolTip ( XYDataset data , int series , int item ) { return getToolTipText ( series , item ) ; }
private Class < ? > findClassNonDalvik ( String name ) throws ClassNotFoundException { String pathName = CLASS_PATH + name + STR_ ; File path = new File ( pathName ) ; RandomAccessFile raf ; try { raf = new RandomAccessFile ( path , STR_ ) ; } catch ( FileNotFoundException fnfe ) { throw new ClassNotFoundException ( STR_ + pathName ) ; } byte [ ] fileData ; try { fileData = new byte [ ( int ) raf . length ( ) ] ; raf . readFully ( fileData ) ; } catch ( IOException ioe ) { throw new ClassNotFoundException ( STR_ + pathName ) ; } finally { try { raf . close ( ) ; } catch ( IOException ioe ) { } } try { return defineClass ( name , fileData , NUM_ , fileData . length ) ; } catch ( Throwable th ) { throw new ClassNotFoundException ( STR_ , th ) ; } }
public static void load ( Class < ? > parent ) { load ( parent , ClassLoader . getSystemClassLoader ( ) ) ; }
public void removeChangeListener ( ChangeListener cl ) { listeners . remove ( cl ) ; }
@ GuardedBy ( STR_ ) void applyRead ( Node < K , V > node ) { if ( evictionDeque . contains ( node ) ) { evictionDeque . moveToBack ( node ) ; } }
private void flushWriteChunk ( ) { if ( writeChunk == null ) return ; if ( writeChunk . position ( ) == NUM_ ) return ; if ( ! writeChunk . hasRemaining ( ) ) { bytesWritten += writeChunk . position ( ) ; writeChunk . flip ( ) ; list . addLast ( writeChunk ) ; writeChunk = null ; return ; } bytesWritten += writeChunk . position ( ) ; ByteBuffer flushChunk = writeChunk ; writeChunk = writeChunk . slice ( ) ; writeChunk . order ( order ) ; flushChunk . flip ( ) ; list . addLast ( flushChunk ) ; return ; }
public final double sin ( ) { return Math . sin ( this . radians ) ; }
public AxisLabelLayout ( String group , int axis , ValuedRangeModel values ) { this ( group , axis , values , null ) ; }
public double angle ( IMovingAgent agent ) { return Geometric . angle ( this . location , agent . getLocation ( ) ) ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return BOOL_ ; } if ( ! ( obj instanceof DefaultDrawingSupplier ) ) { return BOOL_ ; } DefaultDrawingSupplier that = ( DefaultDrawingSupplier ) obj ; if ( ! Arrays . equals ( this . paintSequence , that . paintSequence ) ) { return BOOL_ ; } if ( this . paintIndex != that . paintIndex ) { return BOOL_ ; } if ( ! Arrays . equals ( this . outlinePaintSequence , that . outlinePaintSequence ) ) { return BOOL_ ; } if ( this . outlinePaintIndex != that . outlinePaintIndex ) { return BOOL_ ; } if ( ! Arrays . equals ( this . strokeSequence , that . strokeSequence ) ) { return BOOL_ ; } if ( this . strokeIndex != that . strokeIndex ) { return BOOL_ ; } if ( ! Arrays . equals ( this . outlineStrokeSequence , that . outlineStrokeSequence ) ) { return BOOL_ ; } if ( this . outlineStrokeIndex != that . outlineStrokeIndex ) { return BOOL_ ; } if ( ! equalShapes ( this . shapeSequence , that . shapeSequence ) ) { return BOOL_ ; } if ( this . shapeIndex != that . shapeIndex ) { return BOOL_ ; } return BOOL_ ; }
public static int brighter ( int c ) { int r = red ( c ) , g = green ( c ) , b = blue ( c ) ; int i = ( int ) ( NUM_ / ( NUM_ - scale ) ) ; if ( r == NUM_ && g == NUM_ && b == NUM_ ) { return rgba ( i , i , i , alpha ( c ) ) ; } if ( r > NUM_ && r < i ) r = i ; if ( g > NUM_ && g < i ) g = i ; if ( b > NUM_ && b < i ) b = i ; return rgba ( Math . min ( NUM_ , ( int ) ( r / scale ) ) , Math . min ( NUM_ , ( int ) ( g / scale ) ) , Math . min ( NUM_ , ( int ) ( b / scale ) ) , alpha ( c ) ) ; }
public void addPropertyChangeListener ( String propertyName , PropertyChangeListener in_pcl ) { pcSupport . addPropertyChangeListener ( propertyName , in_pcl ) ; }
@ Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D g2 = ( Graphics2D ) g ; if ( shouldDraw ) { drawDisplayListOn ( g2 ) ; } }
public void load ( InputStream in ) throws IOException { properties . load ( in ) ; dirty = BOOL_ ; }
@ Override public void onBindViewHolder ( VH holder , int position ) { if ( list . get ( position ) . type == TYPE_ITEM ) { onBindItemViewHolder ( holder , position ) ; } else if ( list . get ( position ) . type == TYPE_HEADER ) { onBindHeaderViewHolder ( holder , position ) ; } }
public static Map < ComponentWrapper , CC > parseComponentConstraints ( Map < ComponentWrapper , String > constrMap ) { HashMap < ComponentWrapper , CC > flowConstrMap = new HashMap < ComponentWrapper , CC > ( ) ; for ( ComponentWrapper c : constrMap . keySet ( ) ) { flowConstrMap . put ( c , parseComponentConstraint ( constrMap . get ( c ) ) ) ; } return flowConstrMap ; }
private void sendStageProgressPatch ( TaskState state ) { ServiceUtils . logInfo ( this , STR_ , state . stage , state . subStage ) ; TaskUtils . sendSelfPatch ( this , buildPatch ( state . stage , state . subStage , null ) ) ; }
public void testCommonPrefix ( ) { String returned = m_Trie . getCommonPrefix ( ) ; assertEquals ( STR_ , NUM_ , returned . length ( ) ) ; String expected = STR_ ; Trie t = buildTrie ( new String [ ] { m_Data [ NUM_ ] , m_Data [ NUM_ ] } ) ; returned = t . getCommonPrefix ( ) ; assertEquals ( STR_ , expected . length ( ) , returned . length ( ) ) ; }
public String moveBack ( ) { Check . isTrue ( currentIndex > NUM_ , STR_ ) ; currentIndex -- ; return history . get ( currentIndex ) ; }
public static long hash64 ( final String text ) { final byte [ ] bytes = text . getBytes ( ) ; return hash64 ( bytes , bytes . length ) ; }
public static void deleteCore ( ) { log . info ( STR_ ) ; if ( h != null ) { h . close ( ) ; } if ( factoryProp == null ) { System . clearProperty ( STR_ ) ; } solrConfig = null ; h = null ; lrf = null ; configString = schemaString = null ; }
public static boolean canTab ( List constraints ) { for ( Iterator iter = constraints . iterator ( ) ; iter . hasNext ( ) ; ) { DockConstraint dc = ( DockConstraint ) iter . next ( ) ; if ( ! dc . canTab ( ) ) return BOOL_ ; } return BOOL_ ; }
public ImdnParser parse ( ) throws ParserConfigurationException , SAXException , ParseFailureException { try { SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; SAXParser parser = factory . newSAXParser ( ) ; parser . parse ( mInputSource , this ) ; return this ; } catch ( IOException e ) { throw new ParseFailureException ( STR_ , e ) ; } }
static boolean chunkSet ( InternalDistributedMember recipient , Set set , int CHUNK_SIZE_IN_BYTES , boolean includeValues , ObjectIntProcedure proc ) throws IOException { Iterator it = set . iterator ( ) ; boolean keepGoing = BOOL_ ; boolean sentLastChunk = BOOL_ ; final HeapDataOutputStream mos = new HeapDataOutputStream ( InitialImageOperation . CHUNK_SIZE_IN_BYTES + NUM_ , recipient . getVersionObject ( ) ) ; do { mos . reset ( ) ; int avgItemSize = NUM_ ; int itemCount = NUM_ ; while ( ( mos . size ( ) + avgItemSize ) < InitialImageOperation . CHUNK_SIZE_IN_BYTES && it . hasNext ( ) ) { Object key = it . next ( ) ; DataSerializer . writeObject ( key , mos ) ; itemCount ++ ; avgItemSize = mos . size ( ) / itemCount ; } DataSerializer . writeObject ( ( Object ) null , mos ) ; int lastMsg = it . hasNext ( ) ? NUM_ : NUM_ ; keepGoing = proc . executeWith ( mos , lastMsg ) ; sentLastChunk = lastMsg == NUM_ && keepGoing ; } while ( keepGoing && it . hasNext ( ) ) ; return sentLastChunk ; }
public static BigInteger toBigInteger ( final Ed25519EncodedFieldElement encoded ) { return toBigInteger ( encoded . getRaw ( ) ) ; }
public String escapeLDAPSearchFilter ( String filter ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = NUM_ ; i < filter . length ( ) ; i ++ ) { char curChar = filter . charAt ( i ) ; switch ( curChar ) { case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; default : sb . append ( curChar ) ; } } return sb . toString ( ) ; }
protected synchronized void save ( ) { int retVal ; File file ; String text ; FileWriter fwriter ; BufferedWriter bwriter ; retVal = m_FileChooser . showOpenDialog ( this ) ; if ( retVal != MekaFileChooser . APPROVE_OPTION ) return ; file = m_FileChooser . getSelectedFile ( ) ; text = m_TextArea . getText ( ) ; fwriter = null ; bwriter = null ; try { fwriter = new FileWriter ( file ) ; bwriter = new BufferedWriter ( fwriter ) ; bwriter . write ( text ) ; bwriter . newLine ( ) ; bwriter . flush ( ) ; log ( STR_ + file ) ; } catch ( Exception e ) { handleException ( STR_ + file , e ) ; } finally { FileUtils . closeQuietly ( bwriter ) ; FileUtils . closeQuietly ( fwriter ) ; } }
public EigenvalueDecomposition ( double [ ] [ ] A ) { n = A . length ; V = new double [ n ] [ n ] ; d = new double [ n ] ; e = new double [ n ] ; issymmetric = BOOL_ ; for ( int j = NUM_ ; ( j < n ) && issymmetric ; j ++ ) { for ( int i = NUM_ ; ( i < n ) && issymmetric ; i ++ ) { issymmetric = ( A [ i ] [ j ] == A [ j ] [ i ] ) ; if ( Double . isNaN ( A [ i ] [ j ] ) ) { throw new IllegalArgumentException ( STR_ ) ; } if ( Double . isInfinite ( A [ i ] [ j ] ) ) { throw new IllegalArgumentException ( STR_ ) ; } } } if ( issymmetric ) { for ( int i = NUM_ ; i < n ; i ++ ) { System . arraycopy ( A [ i ] , NUM_ , V [ i ] , NUM_ , n ) ; } tred2 ( ) ; tql2 ( ) ; } else { H = new double [ n ] [ n ] ; ort = new double [ n ] ; for ( int j = NUM_ ; j < n ; j ++ ) { for ( int i = NUM_ ; i < n ; i ++ ) { H [ i ] [ j ] = A [ i ] [ j ] ; } } orthes ( ) ; hqr2 ( ) ; } }
public SearchSourceBuilder fields ( String ... fields ) { if ( fieldNames == null ) { fieldNames = new ArrayList < > ( ) ; } Collections . addAll ( fieldNames , fields ) ; return this ; }
public static StringBuilder formatTo ( StringBuilder buf , boolean [ ] d , String sep ) { if ( d == null ) { return buf . append ( STR_ ) ; } if ( d . length == NUM_ ) { return buf ; } buf . append ( d [ NUM_ ] ) ; for ( int i = NUM_ ; i < d . length ; i ++ ) { buf . append ( sep ) ; buf . append ( format ( d [ i ] ) ) ; } return buf ; }
public String toCompleteString ( ) { String ret = STR_ ; if ( ! lines . isEmpty ( ) && ! Config . v ( ) . noSourceInfo ) { for ( SourceLocationTag line : lines ) { ret += STR_ + line + STR_ ; } } ret += toSignatureString ( ) ; return ret ; }
@ Override public void updateReceiptDetails ( final Set < BillReceiptInfo > billReceipts ) { LOGGER . debug ( STR_ + billReceipts ) ; final Boolean status = BOOL_ ; if ( billReceipts != null ) super . updateReceiptDetails ( billReceipts ) ; LOGGER . debug ( STR_ + status ) ; }
public static void removeMapEntries ( Map map , Set set ) { if ( ( set != null ) && ! set . isEmpty ( ) ) { for ( Iterator iter = set . iterator ( ) ; iter . hasNext ( ) ; ) { map . remove ( iter . next ( ) ) ; } } }
public static void putFile ( ServiceClient h , final Operation put , File f ) throws IOException { final AsynchronousFileChannel ch = AsynchronousFileChannel . open ( f . toPath ( ) , StandardOpenOption . READ ) ; AtomicInteger completionCount = new AtomicInteger ( NUM_ ) ; String contentType = FileUtils . getContentType ( f . toURI ( ) ) ; final boolean [ ] fileIsDone = { BOOL_ } ; putChunks ( h , put , ch , contentType , f . length ( ) , NUM_ , completionCount , fileIsDone ) ; }
protected StringBuilder processLine ( String nextElement ) { StringBuilder sb = new StringBuilder ( INITIAL_STRING_SIZE ) ; for ( int j = NUM_ ; j < nextElement . length ( ) ; j ++ ) { char nextChar = nextElement . charAt ( j ) ; processCharacter ( sb , nextChar ) ; } return sb ; }
public JavaRefactoringDescriptor ( final String id , final String project , final String description , final String comment , final Map arguments , final int flags ) { super ( id , project , description , comment , flags ) ; fArguments = arguments ; fArguments . put ( ATTRIBUTE_VERSION , VALUE_VERSION_1_0 ) ; }
private static SupportedGroup negotiateNamedCurve ( ClientHello clientHello ) { SupportedGroup result = null ; List < SupportedGroup > preferredGroups = SupportedGroup . getPreferredGroups ( ) ; SupportedEllipticCurvesExtension extension = clientHello . getSupportedEllipticCurvesExtension ( ) ; if ( extension == null ) { if ( ! preferredGroups . isEmpty ( ) ) { result = preferredGroups . get ( NUM_ ) ; } } else { for ( Integer preferredGroupId : extension . getSupportedGroupIds ( ) ) { SupportedGroup group = SupportedGroup . fromId ( preferredGroupId ) ; if ( group != null && group . isUsable ( ) && preferredGroups . contains ( group ) ) { result = group ; break ; } } } return result ; }
public void zoom ( ) { if ( getSelectedRowKey ( ) != null && getSelectedRowKey ( ) > NUM_ ) { MQuery zoomQuery = new MQuery ( ) ; String column = getKeyColumn ( ) ; if ( column . indexOf ( STR_ ) > NUM_ ) column = column . substring ( column . indexOf ( STR_ ) + NUM_ ) ; zoomQuery . addRestriction ( column , MQuery . EQUAL , getSelectedRowKey ( ) ) ; zoomQuery . setRecordCount ( NUM_ ) ; zoomQuery . setTableName ( column . substring ( NUM_ , column . length ( ) - NUM_ ) ) ; AEnv . zoom ( NUM_ , zoomQuery ) ; } }
public long avgRate ( ) { long sum = NUM_ ; for ( Sample s : samples ) { sum += s . rate ( ) ; } return ( long ) ( sum / ( long ) samples . size ( ) ) ; }
@ Override public synchronized void close ( ) throws IOException { try { if ( syncTask != null ) { syncTask . cancel ( ) ; } sync ( ) ; unmapFile ( ) ; } finally { super . close ( ) ; } }
public boolean mouseMoved ( MouseEvent e ) { OMGraphic newSelectedGraphic ; if ( show_plot_ && graph != null ) { newSelectedGraphic = graph . selectPoint ( e . getX ( ) , e . getY ( ) , NUM_ ) ; if ( newSelectedGraphic != null ) { String infostring = ( String ) ( newSelectedGraphic . getAttribute ( OMGraphic . APP_OBJECT ) ) ; if ( infostring != null ) { fireRequestInfoLine ( infostring ) ; } } else { fireRequestInfoLine ( STR_ ) ; } return BOOL_ ; } else { OMGraphicList list = getList ( ) ; if ( list != null ) { newSelectedGraphic = list . selectClosest ( e . getX ( ) , e . getY ( ) , NUM_ ) ; if ( newSelectedGraphic != null && ( selectedGraphic == null || newSelectedGraphic != selectedGraphic ) ) { Debug . message ( STR_ , STR_ ) ; selectedGraphic = newSelectedGraphic ; selectedGraphic . regenerate ( getProjection ( ) ) ; GLOBESite site = ( GLOBESite ) ( newSelectedGraphic . getAttribute ( OMGraphic . APP_OBJECT ) ) ; if ( site != null ) { fireRequestInfoLine ( site . getInfo ( ) ) ; } repaint ( ) ; } else if ( selectedGraphic != null && newSelectedGraphic == null ) { Debug . message ( STR_ , STR_ ) ; selectedGraphic . regenerate ( getProjection ( ) ) ; fireRequestInfoLine ( STR_ ) ; selectedGraphic = null ; repaint ( ) ; } return BOOL_ ; } } return BOOL_ ; }
public void hidePopup ( ) { showPending = BOOL_ ; if ( popup != null ) { popup . hide ( ) ; popup = null ; } }
private float interpolate ( ) { long currTime = System . currentTimeMillis ( ) ; float elapsed = ( currTime - startTime ) / ZOOM_TIME ; elapsed = Math . min ( NUM_ , elapsed ) ; return interpolator . getInterpolation ( elapsed ) ; }
private PointF isFlingingToDelete ( DragSource source ) { if ( mFlingToDeleteDropTarget == null ) return null ; if ( ! source . supportsFlingToDelete ( ) ) return null ; ViewConfiguration config = ViewConfiguration . get ( mLauncher ) ; mVelocityTracker . computeCurrentVelocity ( NUM_ , config . getScaledMaximumFlingVelocity ( ) ) ; if ( mVelocityTracker . getYVelocity ( ) < mFlingToDeleteThresholdVelocity ) { PointF vel = new PointF ( mVelocityTracker . getXVelocity ( ) , mVelocityTracker . getYVelocity ( ) ) ; PointF upVec = new PointF ( NUM_ , - NUM_ ) ; float theta = ( float ) Math . acos ( ( ( vel . x . upVec . x ) + ( vel . y . upVec . y ) ) / ( vel . length ( ) . upVec . length ( ) ) ) ; if ( theta <= Math . toRadians ( MAX_FLING_DEGREES ) ) { return vel ; } } return null ; }
public final RuntimeException processDoMethodInvokeException ( Exception e , Object object , Object [ ] argumentArray ) { if ( e instanceof RuntimeException ) return ( RuntimeException ) e ; return MetaClassHelper . createExceptionText ( STR_ , this , object , argumentArray , e , BOOL_ ) ; }
protected boolean buildSubfieldDefns ( String pszSublist ) { if ( pszSublist . charAt ( NUM_ ) == STR_ ) { bRepeatingSubfields = BOOL_ ; pszSublist = pszSublist . substring ( NUM_ ) ; } Vector papszSubfieldNames = PropUtils . parseMarkers ( pszSublist , STR_ ) ; paoSubfieldDefns = new Vector ( ) ; for ( Iterator it = papszSubfieldNames . iterator ( ) ; it . hasNext ( ) ; ) { DDFSubfieldDefinition ddfsd = new DDFSubfieldDefinition ( ) ; ddfsd . setName ( ( String ) it . next ( ) ) ; paoSubfieldDefns . add ( ddfsd ) ; } return BOOL_ ; }
public boolean isRunning ( ) { return mRunning . get ( ) ; }
private static Map < String , Boolean > objectMethodsToGenerate ( List < ExecutableElement > methods ) { Map < String , Boolean > vars = new TreeMap < String , Boolean > ( ) ; vars . put ( STR_ , BOOL_ ) ; vars . put ( STR_ , BOOL_ ) ; vars . put ( STR_ , BOOL_ ) ; for ( ExecutableElement method : methods ) { if ( isToStringOrEqualsOrHashCode ( method ) ) { boolean canGenerate = method . getModifiers ( ) . contains ( Modifier . ABSTRACT ) || isJavaLangObject ( ( TypeElement ) method . getEnclosingElement ( ) ) ; vars . put ( method . getSimpleName ( ) . toString ( ) , canGenerate ) ; } } assert vars . size ( ) == NUM_ ; return vars ; }
public void addEntryTime ( double time ) { if ( entryTimes == null ) { return ; } if ( time < NUM_ ) { time = NUM_ ; } entryTimes . add ( Double . valueOf ( time ) ) ; }
public void test_singleResourceLocking_serialized_waitsFor_highConcurrency ( ) throws Exception { final Properties properties = new Properties ( ) ; final int nthreads = NUM_ ; final int ntasks = NUM_ ; properties . setProperty ( TestOptions . CORE_POOL_SIZE , STR_ + nthreads ) ; properties . setProperty ( TestOptions . NTASKS , STR_ + ntasks ) ; properties . setProperty ( TestOptions . NRESOURCES , STR_ ) ; properties . setProperty ( TestOptions . MIN_LOCKS , STR_ ) ; properties . setProperty ( TestOptions . MAX_LOCKS , STR_ ) ; properties . setProperty ( TestOptions . PREDECLARE_LOCKS , STR_ ) ; properties . setProperty ( TestOptions . SORT_LOCK_REQUESTS , STR_ ) ; final Result result = doComparisonTest ( properties ) ; assertEquals ( STR_ , NUM_ , Integer . parseInt ( result . get ( STR_ ) ) ) ; assertEquals ( STR_ , NUM_ , Integer . parseInt ( result . get ( STR_ ) ) ) ; assertEquals ( STR_ , ntasks , Integer . parseInt ( result . get ( STR_ ) ) ) ; }
public final double NPV ( ) { calculate ( ) ; QL . require ( ! Double . isNaN ( this . NPV ) , STR_ ) ; return NPV ; }
public ArrayRealVector ( ArrayRealVector v1 , RealVector v2 ) { final int l1 = v1 . data . length ; final int l2 = v2 . getDimension ( ) ; data = new double [ l1 + l2 ] ; System . arraycopy ( v1 . data , NUM_ , data , NUM_ , l1 ) ; for ( int i = NUM_ ; i < l2 ; ++ i ) { data [ l1 + i ] = v2 . getEntry ( i ) ; } }
public static Map < String , Object > deactivateContentAssoc ( DispatchContext dctx , Map < String , ? extends Object > rcontext ) { Map < String , Object > context = UtilMisc . makeMapWritable ( rcontext ) ; context . put ( STR_ , STR_ ) ; List < String > targetOperationList = ContentWorker . prepTargetOperationList ( context , STR_ ) ; List < String > contentPurposeList = ContentWorker . prepContentPurposeList ( context ) ; context . put ( STR_ , targetOperationList ) ; context . put ( STR_ , contentPurposeList ) ; context . put ( STR_ , null ) ; Map < String , Object > result = deactivateContentAssocMethod ( dctx , context ) ; return result ; }
public ByteBuffer flushAndReleaseBuffer ( ) throws IOException { _lock . lock ( ) ; try { _flushPending = BOOL_ ; while ( _bufferUseCount != NUM_ ) { _flushReady . await ( ) ; } _buffer . flip ( ) ; if ( _buffer . limit ( ) != NUM_ && _modified ) { if ( _backingFile == null ) { _backingFile = Files . createTempFile ( STR_ , STR_ ) ; } _log . debug ( STR_ , _startIndex , _backingFile , _buffer . limit ( ) , _blockSize ) ; try ( ByteChannel out = Files . newByteChannel ( _backingFile , WRITE ) ) { out . write ( _buffer ) ; } } else { _log . debug ( STR_ , _startIndex ) ; } ByteBuffer oldBuffer = _buffer ; _buffer = null ; _loaded = BOOL_ ; return oldBuffer ; } catch ( InterruptedException e ) { throw Throwables . propagate ( e ) ; } finally { _flushPending = BOOL_ ; _flushComplete . signalAll ( ) ; _lock . unlock ( ) ; } }
public static boolean isDirectlyGettingPowered ( World world , Coord4D coord ) { for ( ForgeDirection side : ForgeDirection . VALID_DIRECTIONS ) { Coord4D sideCoord = coord . getFromSide ( side ) ; if ( sideCoord . exists ( world ) ) { if ( world . isBlockProvidingPowerTo ( coord . xCoord , coord . yCoord , coord . zCoord , side . ordinal ( ) ) > NUM_ ) { return BOOL_ ; } } } return BOOL_ ; }
public < T extends PropertyContainer > List < SearchMatch < T > > search ( String query , Class < T > clazz ) { SearchResult result = doQuery ( query , clazz ) ; List < SearchMatch < T > > matches = buildSearchMatches ( result ) ; @ SuppressWarnings ( STR_ ) Function < SearchMatch , T > resolver = ( Function < SearchMatch , T > ) ( clazz . equals ( Node . class ) ? getNodeResolver ( ) : getRelationshipResolver ( ) ) ; return resolveMatchItems ( matches , resolver ) ; }
private synchronized void enumerate ( Hashtable < String , Object > h ) { if ( defaults != null ) { defaults . enumerate ( h ) ; } for ( Enumeration < ? > e = keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; h . put ( key , get ( key ) ) ; } }
public void updateQuantityCsv ( ItemBean original , ItemBean itemToAdd , boolean add ) { BigDecimal originalQuantity = original . getQtyCsv ( ) ; BigDecimal quantityToAdd = itemToAdd . getQtyCsv ( ) ; BigDecimal finalQuantity = null ; if ( ! add ) finalQuantity = originalQuantity . subtract ( quantityToAdd ) ; else finalQuantity = originalQuantity . add ( quantityToAdd ) ; original . setQtyCsv ( finalQuantity ) ; }
public static Number abs ( Number a ) { if ( isFloatingPoint ( a ) ) { return Math . abs ( a . doubleValue ( ) ) ; } else { return Math . abs ( a . longValue ( ) ) ; } }
public void removeSwipeListener ( SwipeListener listener ) { if ( mListeners == null ) { return ; } mListeners . remove ( listener ) ; }
private void sendResponse ( String status , String mime , Properties header , InputStream data ) { try { if ( status == null ) throw new Error ( STR_ ) ; OutputStream out = mySocket . getOutputStream ( ) ; PrintWriter pw = new PrintWriter ( out ) ; pw . print ( STR_ + status + STR_ ) ; if ( mime != null ) pw . print ( STR_ + mime + STR_ ) ; if ( header == null || header . getProperty ( STR_ ) == null ) pw . print ( STR_ + gmtFrmt . format ( new Date ( ) ) + STR_ ) ; if ( header != null ) { Enumeration e = header . keys ( ) ; while ( e . hasMoreElements ( ) ) { String key = ( String ) e . nextElement ( ) ; String value = header . getProperty ( key ) ; pw . print ( key + STR_ + value + STR_ ) ; } } pw . print ( STR_ ) ; pw . flush ( ) ; if ( data != null ) { int pending = data . available ( ) ; byte [ ] buff = new byte [ NUM_ ] ; while ( pending > NUM_ ) { int read = data . read ( buff , NUM_ , ( ( pending > NUM_ ) ? NUM_ : pending ) ) ; if ( read <= NUM_ ) break ; out . write ( buff , NUM_ , read ) ; pending -= read ; } } out . flush ( ) ; out . close ( ) ; if ( data != null ) data . close ( ) ; } catch ( IOException ioe ) { try { mySocket . close ( ) ; } catch ( Throwable t ) { } } }
public static InputStream toInputStream ( CharSequence input , Charset encoding ) { return toInputStream ( input . toString ( ) , encoding ) ; }
public User ( String id , String name , String email ) { this . id = id ; this . email = email ; this . name = name ; }
public static void forceDeleteOnExit ( File file ) throws IOException { if ( file . isDirectory ( ) ) { deleteDirectoryOnExit ( file ) ; } else { file . deleteOnExit ( ) ; } }
@ SuppressWarnings ( STR_ ) public Object [ ] toArray ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = NUM_ ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }
public static Asset createAssetFromBitmap ( Bitmap bitmap ) { if ( bitmap != null ) { final ByteArrayOutputStream byteStream = new ByteArrayOutputStream ( ) ; bitmap . compress ( Bitmap . CompressFormat . PNG , NUM_ , byteStream ) ; return Asset . createFromBytes ( byteStream . toByteArray ( ) ) ; } return null ; }
public boolean isIPValid ( Session sess , String clientIP ) throws SSOException { boolean check = BOOL_ ; try { InetAddress sessIPAddress = InetAddress . getByName ( sess . getProperty ( STR_ ) ) ; InetAddress clientIPAddress = InetAddress . getByName ( clientIP ) ; if ( sessIPAddress . equals ( clientIPAddress ) ) { check = BOOL_ ; } } catch ( Exception e ) { if ( debug . messageEnabled ( ) ) { debug . message ( STR_ , e ) ; } } return check ; }
@ SuppressWarnings ( STR_ ) private static void handleMethodNode ( GetStaticGraph staticUsageTree , ClassNode cn , MethodNode mn , int depth ) { InsnList instructions = mn . instructions ; Iterator < AbstractInsnNode > iterator = instructions . iterator ( ) ; while ( iterator . hasNext ( ) ) { AbstractInsnNode insn = iterator . next ( ) ; if ( insn instanceof MethodInsnNode ) { handleMethodInsnNode ( staticUsageTree , cn , mn , ( MethodInsnNode ) insn , depth + NUM_ ) ; } else if ( insn instanceof FieldInsnNode ) { handleFieldInsnNode ( staticUsageTree , cn , mn , ( FieldInsnNode ) insn , depth + NUM_ ) ; } } }
public boolean handleTouch ( MotionEvent event ) { int action = event . getAction ( ) ; if ( mRenderer != null && action == MotionEvent . ACTION_MOVE ) { if ( oldX >= NUM_ || oldY >= NUM_ ) { float newX = event . getX ( NUM_ ) ; float newY = event . getY ( NUM_ ) ; if ( event . getPointerCount ( ) > NUM_ && ( oldX2 >= NUM_ || oldY2 >= NUM_ ) && mRenderer . isZoomEnabled ( ) ) { float newX2 = event . getX ( NUM_ ) ; float newY2 = event . getY ( NUM_ ) ; float newDeltaX = Math . abs ( newX - newX2 ) ; float newDeltaY = Math . abs ( newY - newY2 ) ; float oldDeltaX = Math . abs ( oldX - oldX2 ) ; float oldDeltaY = Math . abs ( oldY - oldY2 ) ; float zoomRate = NUM_ ; float tan1 = Math . abs ( newY - oldY ) / Math . abs ( newX - oldX ) ; float tan2 = Math . abs ( newY2 - oldY2 ) / Math . abs ( newX2 - oldX2 ) ; if ( tan1 <= NUM_ && tan2 <= NUM_ ) { zoomRate = newDeltaX / oldDeltaX ; applyZoom ( zoomRate , Zoom . ZOOM_AXIS_X ) ; } else if ( tan1 >= NUM_ && tan2 >= NUM_ ) { zoomRate = newDeltaY / oldDeltaY ; applyZoom ( zoomRate , Zoom . ZOOM_AXIS_Y ) ; } else { if ( Math . abs ( newX - oldX ) >= Math . abs ( newY - oldY ) ) { zoomRate = newDeltaX / oldDeltaX ; } else { zoomRate = newDeltaY / oldDeltaY ; } applyZoom ( zoomRate , Zoom . ZOOM_AXIS_XY ) ; } oldX2 = newX2 ; oldY2 = newY2 ; } else if ( mRenderer . isPanEnabled ( ) ) { mPan . apply ( oldX , oldY , newX , newY ) ; oldX2 = NUM_ ; oldY2 = NUM_ ; } oldX = newX ; oldY = newY ; graphicalView . repaint ( ) ; return BOOL_ ; } } else if ( action == MotionEvent . ACTION_DOWN ) { oldX = event . getX ( NUM_ ) ; oldY = event . getY ( NUM_ ) ; if ( mRenderer != null && mRenderer . isZoomEnabled ( ) && zoomR . contains ( oldX , oldY ) ) { if ( oldX < zoomR . left + zoomR . width ( ) / NUM_ ) { graphicalView . zoomIn ( ) ; } else if ( oldX < zoomR . left + zoomR . width ( ) . NUM_ / NUM_ ) { graphicalView . zoomOut ( ) ; } else { graphicalView . zoomReset ( ) ; } return BOOL_ ; } } else if ( action == MotionEvent . ACTION_UP || action == MotionEvent . ACTION_POINTER_UP ) { oldX = NUM_ ; oldY = NUM_ ; oldX2 = NUM_ ; oldY2 = NUM_ ; if ( action == MotionEvent . ACTION_POINTER_UP ) { oldX = - NUM_ ; oldY = - NUM_ ; } } return ! mRenderer . isClickEnabled ( ) ; }
public void addParameter ( NameValuePair param ) throws IllegalArgumentException { log . trace ( STR_ ) ; if ( param == null ) { throw new IllegalArgumentException ( STR_ ) ; } addParameter ( param . getName ( ) , param . getValue ( ) ) ; }
public static String readAsString ( InputStream is ) throws IOException { StringBuffer buf = new StringBuffer ( ) ; byte [ ] b = new byte [ NUM_ ] ; int nread = - NUM_ ; while ( ( nread = is . read ( b ) ) >= NUM_ ) { String s = new String ( b , NUM_ , nread ) ; buf . append ( s ) ; } return buf . toString ( ) ; }
private void readPolicies ( XmlPullParser parser ) throws IOException , XmlPullParserException { while ( parser . next ( ) != XmlPullParser . END_TAG ) { if ( parser . getEventType ( ) != XmlPullParser . START_TAG ) { continue ; } String name = parser . getName ( ) ; if ( TAG_USER_RESTRICTION . equals ( name ) ) { String userRestriction = parser . getAttributeValue ( null , ATTRIBUTE_NAME ) ; if ( userRestriction != null ) { mUserRestrictions . add ( userRestriction ) ; } } else if ( TAG_GLOBAL_SETTING . equals ( name ) ) { String setting = parser . getAttributeValue ( null , ATTRIBUTE_NAME ) ; String value = parser . getAttributeValue ( null , ATTRIBUTE_VALUE ) ; if ( setting != null && value != null ) { mGlobalSettings . add ( new GlobalSetting ( setting , value ) ) ; } } else if ( TAG_DISABLE_STATUS_BAR . equals ( name ) ) { mDisableStatusBar = Boolean . parseBoolean ( parser . getAttributeValue ( null , ATTRIBUTE_VALUE ) ) ; } else if ( TAG_DISABLE_KEYGUARD . equals ( name ) ) { mDisableKeyguard = Boolean . parseBoolean ( parser . getAttributeValue ( null , ATTRIBUTE_VALUE ) ) ; } else if ( TAG_DISABLE_CAMERA . equals ( name ) ) { mDisableCamera = Boolean . parseBoolean ( parser . getAttributeValue ( null , ATTRIBUTE_VALUE ) ) ; } else if ( TAG_DISABLE_SCREEN_CAPTURE . equals ( name ) ) { mDisableScreenCapture = Boolean . parseBoolean ( parser . getAttributeValue ( null , ATTRIBUTE_VALUE ) ) ; } skipCurrentTag ( parser ) ; } }
public boolean readHeader ( RandomAccessFile raf ) throws IOException { StringBuffer id = new StringBuffer ( NUM_ ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { int ch = raf . read ( ) ; if ( ch < NUM_ ) { String hx = Integer . toHexString ( ch ) ; if ( hx . length ( ) < NUM_ ) { hx = STR_ + hx ; } return BOOL_ ; } id . append ( ( char ) ch ) ; } _chunkID = id . toString ( ) ; _size = AiffUtil . readUINT32 ( raf ) ; return BOOL_ ; }
private XYPlot initializePlot ( ) { jmxChart = new YIntervalSeriesImproved ( STR_ ) ; YIntervalSeriesCollection yintervalseriescollection = new YIntervalSeriesCollection ( ) ; yintervalseriescollection . addSeries ( jmxChart ) ; DeviationRenderer renderer = new DeviationRenderer ( BOOL_ , BOOL_ ) ; renderer . setBaseShapesVisible ( BOOL_ ) ; renderer . setSeriesStroke ( NUM_ , new BasicStroke ( NUM_ , BasicStroke . CAP_ROUND , BasicStroke . JOIN_ROUND ) ) ; renderer . setSeriesFillPaint ( NUM_ , new Color ( NUM_ , NUM_ , NUM_ ) ) ; renderer . setSeriesOutlineStroke ( NUM_ , new BasicStroke ( NUM_ ) ) ; renderer . setSeriesShape ( NUM_ , new Ellipse2D . Double ( - NUM_ , - NUM_ , NUM_ , NUM_ ) ) ; renderer . setBaseToolTipGenerator ( new StandardXYToolTipGenerator ( StandardXYToolTipGenerator . DEFAULT_TOOL_TIP_FORMAT , DateFormat . getDateTimeInstance ( ) , NumberFormat . getNumberInstance ( ) ) ) ; NumberAxis rangeAxis = plotDataSolver . getAxis ( ) ; subplot = new XYPlot ( yintervalseriescollection , null , rangeAxis , renderer ) ; subplot . setAxisOffset ( new RectangleInsets ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; subplot . setRangeAxisLocation ( AxisLocation . TOP_OR_LEFT ) ; subplot . setRangeCrosshairVisible ( BOOL_ ) ; return subplot ; }
private boolean isFatalState ( String sqlState ) { if ( sqlState == null || sqlState . length ( ) < NUM_ ) { return BOOL_ ; } for ( String FATAL_SQL_STATE_CLASS : FATAL_SQL_STATE_CLASSES ) { if ( sqlState . startsWith ( FATAL_SQL_STATE_CLASS ) ) { return BOOL_ ; } } return BOOL_ ; }
private void analyzeFile ( File inputFile , Optional < CommonTokenStream > optTokenStream , Optional < TopLevelContext > optTree , Formatter formatter , Severity maxSeverity , ConstructLengths constructLengths , Set < Rules > enabledRules ) throws CLIArgumentParserException { try { Printer printer = new Printer ( inputFile , maxSeverity , formatter ) ; if ( optTokenStream . isPresent ( ) && optTree . isPresent ( ) ) { CommonTokenStream tokenStream = optTokenStream . get ( ) ; TopLevelContext tree = optTree . get ( ) ; CommentExtractor commentExtractor = new CommentExtractor ( tokenStream ) ; ViolationSuppressor disableAnalysis = new ViolationSuppressor ( printer , commentExtractor . getSingleLineComments ( ) , commentExtractor . getMultilineComments ( ) ) ; disableAnalysis . analyze ( ) ; List < SwiftBaseListener > listeners = createListeners ( enabledRules , printer , tokenStream , constructLengths , commentExtractor ) ; walkParseTree ( listeners , tree ) ; try ( FileListener fileListener = new FileListener ( printer , inputFile , constructLengths , enabledRules ) ) { fileListener . verify ( ) ; } numErrors . addAndGet ( printer . getNumErrorMessages ( ) ) ; numWarnings . addAndGet ( printer . getNumWarningMessages ( ) ) ; } else { printer . setShouldPrintParseErrorMessage ( BOOL_ ) ; } printersForAllFiles . add ( printer ) ; } catch ( IOException e ) { handleIOException ( e ) ; } catch ( CLIArgumentParserException e ) { handleCLIException ( e ) ; } }
@ SuppressWarnings ( STR_ ) public static < ValueT > ValueT toObject ( ByteBuffer bf ) throws IOException , ClassNotFoundException { Object obj = null ; InputStream is = null ; ObjectInputStream ois = null ; try { is = new ByteBufferBackedInputStream ( bf ) ; ois = new ObjectInputStream ( is ) ; obj = ois . readObject ( ) ; } finally { if ( is != null ) { is . close ( ) ; } if ( ois != null ) { ois . close ( ) ; } } return ( ValueT ) obj ; }
static private void scanDeadlineQueue ( final long nowNanos , final PriorityBlockingQueue < QueryDeadline > deadlineQueue ) { final List < QueryDeadline > c = new ArrayList < QueryDeadline > ( DEADLINE_QUEUE_SCAN_SIZE ) ; deadlineQueue . drainTo ( c , DEADLINE_QUEUE_SCAN_SIZE ) ; int ndropped = NUM_ , nrunning = NUM_ ; for ( QueryDeadline x : c ) { if ( x . checkDeadline ( nowNanos ) != null ) { deadlineQueue . add ( x ) ; nrunning ++ ; } else { ndropped ++ ; } } if ( log . isInfoEnabled ( ) ) log . info ( STR_ + DEADLINE_QUEUE_SCAN_SIZE + STR_ + ndropped + STR_ + nrunning + STR_ + deadlineQueue . size ( ) ) ; }
public int compare ( File file1 , File file2 ) { return caseSensitivity . checkCompareTo ( file1 . getName ( ) , file2 . getName ( ) ) ; }
@ Override public String lastString ( ) { return Integer . toString ( lastint ) ; }
public boolean removeItemContent ( String uid ) { if ( ! users . isEmpty ( ) ) { return removeContent ( uid , users ) ; } else if ( ! reports . isEmpty ( ) ) { return removeContent ( uid , reports ) ; } else { return removeContent ( uid , resources ) ; } }
public void close ( ) { if ( dialog != null ) { dialog . setVisible ( BOOL_ ) ; dialog . dispose ( ) ; dialog = null ; pane = null ; myBar = null ; } }
public static void expandOrdinal ( String rawNumberString , WordRelation wordRelation ) { String numberString = Utilities . deleteChar ( rawNumberString , STR_ ) ; expandNumber ( numberString , wordRelation ) ; Item lastItem = wordRelation . getTail ( ) ; if ( lastItem != null ) { FeatureSet featureSet = lastItem . getFeatures ( ) ; String lastNumber = featureSet . getString ( STR_ ) ; String ordinal = findMatchInArray ( lastNumber , digit2num , ord2num ) ; if ( ordinal == null ) { ordinal = findMatchInArray ( lastNumber , digit2teen , ord2teen ) ; } if ( ordinal == null ) { ordinal = findMatchInArray ( lastNumber , digit2enty , ord2enty ) ; } if ( lastNumber . equals ( STR_ ) ) { ordinal = STR_ ; } else if ( lastNumber . equals ( STR_ ) ) { ordinal = STR_ ; } else if ( lastNumber . equals ( STR_ ) ) { ordinal = STR_ ; } if ( ordinal != null ) { wordRelation . setLastWord ( ordinal ) ; } } }
private void checkBoundedTypeParameter ( Method method ) { TypeVariable < Method > typeParameter = getTypeParameter ( method ) ; assertEquals ( STR_ , typeParameter . getName ( ) ) ; assertEquals ( method , typeParameter . getGenericDeclaration ( ) ) ; Type [ ] bounds = typeParameter . getBounds ( ) ; assertLenghtOne ( bounds ) ; Type bound = bounds [ NUM_ ] ; assertEquals ( BoundedWildcardsGenericMethods . class , bound ) ; }
public void registerSensor ( Sensor s , int i ) { if ( ( i < NUM_ ) || ( i > ( inputBits [ nodeType ] - NUM_ ) ) || ( i > MAXSENSORS ) ) { log . error ( STR_ + Integer . toString ( i + NUM_ ) ) ; return ; } hasActiveSensors = BOOL_ ; if ( sensorArray [ i ] == null ) { sensorArray [ i ] = s ; if ( lastUsedSensor < i ) { lastUsedSensor = i ; } } else { log . warn ( STR_ + Integer . toString ( ( getNodeAddress ( ) . SerialSensorManager . SENSORSPERNODE ) + i + NUM_ ) ) ; } }
public boolean hasOrganisationUnits ( ) { List < DimensionalItemObject > dimOpts = getDimensionOptions ( ORGUNIT_DIM_ID ) ; List < DimensionalItemObject > filterOpts = getFilterOptions ( ORGUNIT_DIM_ID ) ; return ! dimOpts . isEmpty ( ) || ! filterOpts . isEmpty ( ) ; }
protected void fixupBlocks ( byte [ ] bytes2 ) { byte [ ] bytes = bytes2 ; for ( Iterator enumerator = blocks . iterator ( ) ; enumerator . hasNext ( ) ; ) { int [ ] info = ( int [ ] ) enumerator . next ( ) ; int codeSize = info [ NUM_ ] ; int offset = info [ NUM_ ] ; byte [ ] sizeBytes = OutStream . sintTo2Bytes ( codeSize ) ; bytes [ offset ] = sizeBytes [ NUM_ ] ; bytes [ offset + NUM_ ] = sizeBytes [ NUM_ ] ; } }
protected double negativeLogLikelihood ( double [ ] [ ] dataYs , double [ ] [ ] probs ) { double logLikelihood = NUM_ ; for ( int i = NUM_ ; i < dataYs . length ; i ++ ) { for ( int j = NUM_ ; j < m_numClasses ; j ++ ) { if ( dataYs [ i ] [ j ] == NUM_ ) { logLikelihood -= Math . log ( probs [ i ] [ j ] ) ; } } } return logLikelihood ; }
public static boolean validSystemNameConfig ( String systemName , char type , AcelaSystemConnectionMemo memo ) { if ( ! validSystemNameFormat ( systemName , type , memo . getSystemPrefix ( ) ) ) { return BOOL_ ; } AcelaNode node = getNodeFromSystemName ( systemName , memo ) ; if ( node == null ) { return BOOL_ ; } int bit = getBitFromSystemName ( systemName ) ; if ( ( type == STR_ ) || ( type == STR_ ) ) { if ( ( bit < MINOUTPUTADDRESS ) || ( bit > MAXOUTPUTADDRESS ) ) { return BOOL_ ; } } else if ( type == STR_ ) { if ( ( bit < MINSENSORADDRESS ) || ( bit > MAXSENSORADDRESS ) ) { return BOOL_ ; } } else { log . error ( STR_ ) ; return BOOL_ ; } return BOOL_ ; }
public void readEncryptionObject ( final PdfObject encyptionObj , final PdfFileReader pdfFileReader ) throws PdfSecurityException { stringsEncoded = BOOL_ ; isMetaDataEncypted = BOOL_ ; StmFObj = null ; StrFObj = null ; isAES = BOOL_ ; if ( ! isInitialised ) { isInitialised = BOOL_ ; SetSecurity . init ( ) ; } if ( SetSecurity . useBouncyCastle ) { decryptionMethods = new BouncyCastleDecryption ( ) ; } else { decryptionMethods = new JCADecryption ( ) ; } final int v = encyptionObj . getInt ( PdfDictionary . V ) ; final PdfArrayIterator filters = encyptionObj . getMixedArray ( PdfDictionary . Filter ) ; int firstValue = PdfDictionary . Standard ; if ( filters != null && filters . hasMoreTokens ( ) ) { firstValue = filters . getNextValueAsConstant ( BOOL_ ) ; } if ( v == NUM_ ) { throw new PdfSecurityException ( STR_ ) ; } else if ( ( v > NUM_ ) && ( firstValue != PdfDictionary . Standard ) ) { throw new PdfSecurityException ( STR_ ) ; } final int newLength = encyptionObj . getInt ( PdfDictionary . Length ) > > NUM_ ; if ( newLength != - NUM_ ) { this . keyLength = newLength ; } rev = encyptionObj . getInt ( PdfDictionary . R ) ; P = encyptionObj . getInt ( PdfDictionary . P ) ; O = encyptionObj . getTextStreamValueAsByte ( PdfDictionary . O ) ; U = encyptionObj . getTextStreamValueAsByte ( PdfDictionary . U ) ; OE = encyptionObj . getTextStreamValueAsByte ( PdfDictionary . OE ) ; UE = encyptionObj . getTextStreamValueAsByte ( PdfDictionary . UE ) ; Perms = encyptionObj . getTextStreamValueAsByte ( PdfDictionary . Perms ) ; if ( v >= NUM_ ) { isAES = BOOL_ ; String CFkey ; final PdfObject CF = encyptionObj . getDictionary ( PdfDictionary . CF ) ; if ( v == NUM_ ) { isMetaDataEncypted = encyptionObj . getBoolean ( PdfDictionary . EncryptMetadata ) ; } isAESIdentity = BOOL_ ; String key = encyptionObj . getName ( PdfDictionary . StrF ) ; if ( key != null ) { isAESIdentity = key . equals ( STR_ ) ; stringsEncoded = BOOL_ ; final PdfKeyPairsIterator keyPairs = CF . getKeyPairsIterator ( ) ; while ( keyPairs . hasMorePairs ( ) ) { CFkey = keyPairs . getNextKeyAsString ( ) ; if ( CFkey . equals ( key ) ) { StrFObj = PdfObjectFactory . getPDFObjectObjectFromRefOrDirect ( new EncryptionObject ( encyptionObj . getObjectRefAsString ( ) ) , pdfFileReader , keyPairs . getNextValueAsBytes ( ) , PdfDictionary . CF ) ; } keyPairs . nextPair ( ) ; } } key = encyptionObj . getName ( PdfDictionary . StmF ) ; if ( key != null ) { isAESIdentity = key . equals ( STR_ ) ; final PdfKeyPairsIterator keyPairs = CF . getKeyPairsIterator ( ) ; while ( keyPairs . hasMorePairs ( ) ) { CFkey = keyPairs . getNextKeyAsString ( ) ; if ( CFkey . equals ( key ) ) { StmFObj = PdfObjectFactory . getPDFObjectObjectFromRefOrDirect ( new EncryptionObject ( encyptionObj . getObjectRefAsString ( ) ) , pdfFileReader , keyPairs . getNextValueAsBytes ( ) , PdfDictionary . CF ) ; } keyPairs . nextPair ( ) ; } } } isEncrypted = BOOL_ ; isFileViewable = BOOL_ ; LogWriter . writeLog ( STR_ ) ; if ( firstValue == PdfDictionary . Standard ) { try { verifyAccess ( ) ; } catch ( final PdfSecurityException e ) { LogWriter . writeLog ( STR_ + e ) ; } } else if ( certificate != null ) { isFileViewable = BOOL_ ; isPasswordSupplied = BOOL_ ; extractionIsAllowed = BOOL_ ; passwordStatus = PDFflags . VALID_OWNER_PASSWORD ; } if ( rev == NUM_ ) { Perms = v5Decrypt ( Perms , encryptionKey ) ; isMetaDataEncypted = Perms [ NUM_ ] == STR_ ; P = ( Perms [ NUM_ ] & NUM_ ) | ( ( Perms [ NUM_ ] & NUM_ ) << NUM_ ) | ( ( Perms [ NUM_ ] & NUM_ ) << NUM_ ) | ( ( Perms [ NUM_ ] & NUM_ ) << NUM_ ) ; } }
public void addMember ( String playerName ) { openInvites . remove ( playerName ) ; membersAndLastSeen . put ( playerName , Long . valueOf ( System . currentTimeMillis ( ) ) ) ; if ( leader == null ) { leader = playerName ; } sendGroupChangeEvent ( ) ; }
public BubbleXYItemLabelGenerator ( ) { this ( DEFAULT_FORMAT_STRING , NumberFormat . getNumberInstance ( ) , NumberFormat . getNumberInstance ( ) , NumberFormat . getNumberInstance ( ) ) ; }
void addNodes ( List < Node > newNodes , boolean atBeginning ) { if ( atBeginning ) { if ( ( nodes . size ( ) > NUM_ ) && nodes . get ( NUM_ ) == newNodes . get ( newNodes . size ( ) - NUM_ ) ) { Log . i ( DEBUG_TAG , STR_ ) ; if ( newNodes . size ( ) > NUM_ ) { Log . i ( DEBUG_TAG , STR_ ) ; newNodes . remove ( newNodes . size ( ) - NUM_ ) ; addNodes ( newNodes , atBeginning ) ; } return ; } nodes . addAll ( NUM_ , newNodes ) ; } else { if ( ( nodes . size ( ) > NUM_ ) && newNodes . get ( NUM_ ) == nodes . get ( nodes . size ( ) - NUM_ ) ) { Log . i ( DEBUG_TAG , STR_ ) ; if ( newNodes . size ( ) > NUM_ ) { Log . i ( DEBUG_TAG , STR_ ) ; newNodes . remove ( NUM_ ) ; addNodes ( newNodes , atBeginning ) ; } return ; } nodes . addAll ( newNodes ) ; } }
public synchronized Boolean updateAVClientByStreamId ( String streamId , RoomClient rcm ) { try { RoomClient rclUsual = getClientByPublicSID ( rcm . getPublicSID ( ) , BOOL_ ) ; if ( rclUsual != null ) { rclUsual . setBroadCastID ( rcm . getBroadCastID ( ) ) ; rclUsual . setAvsettings ( rcm . getAvsettings ( ) ) ; rclUsual . setVHeight ( rcm . getVHeight ( ) ) ; rclUsual . setVWidth ( rcm . getVWidth ( ) ) ; rclUsual . setVX ( rcm . getVX ( ) ) ; rclUsual . setVY ( rcm . getVY ( ) ) ; if ( clientList . containsKey ( rclUsual . getStreamid ( ) ) ) { clientList . put ( rclUsual . getStreamid ( ) , rclUsual ) ; } else { log . debug ( STR_ + rclUsual . getStreamid ( ) ) ; } } updateClientByStreamId ( streamId , rcm ) ; } catch ( Exception err ) { log . error ( STR_ , err ) ; } return null ; }
public void addColor ( int color ) { if ( mColors == null ) mColors = new ArrayList < Integer > ( ) ; mColors . add ( color ) ; }
private void clampStartingPosition ( ) { final float cX = mBounds . exactCenterX ( ) ; final float cY = mBounds . exactCenterY ( ) ; final float dX = mStartingX - cX ; final float dY = mStartingY - cY ; final float r = mTargetRadius ; if ( dX . dX + dY . dY > r . r ) { final double angle = Math . atan2 ( dY , dX ) ; mClampedStartingX = cX + ( float ) ( Math . cos ( angle ) . r ) ; mClampedStartingY = cY + ( float ) ( Math . sin ( angle ) . r ) ; } else { mClampedStartingX = mStartingX ; mClampedStartingY = mStartingY ; } }
public Criteria createCriteria ( ) { Criteria criteria = createCriteriaInternal ( ) ; if ( oredCriteria . size ( ) == NUM_ ) { oredCriteria . add ( criteria ) ; } return criteria ; }
public boolean isEmpty ( ) { if ( lastBatch != null ) { if ( ! lastBatch . isEmpty ( ) ) { return BOOL_ ; } } return currentBatch . isEmpty ( ) ; }
@ SuppressWarnings ( STR_ ) public DummyData ( int cols , int rows , Comparable < ? > value ) { value . getClass ( ) ; this . cols = cols ; this . rows = rows ; this . value = value ; Class < ? extends Comparable < ? > > [ ] types = new Class [ cols ] ; Arrays . fill ( types , value . getClass ( ) ) ; setColumnTypes ( types ) ; }
public Object clone ( ) throws CloneNotSupportedException { NodeVector clone = ( NodeVector ) super . clone ( ) ; if ( ( null != this . m_map ) && ( this . m_map == clone . m_map ) ) { clone . m_map = new int [ this . m_map . length ] ; System . arraycopy ( this . m_map , NUM_ , clone . m_map , NUM_ , this . m_map . length ) ; } return clone ; }
public boolean matchWithPattern ( String pattern ) { if ( TextUtils . isEmpty ( pattern ) ) { mCurrentPattern = STR_ ; mUpperCasePattern = STR_ ; mLowerCasePattern = STR_ ; } if ( TextUtils . isEmpty ( mDisplayName ) ) { return BOOL_ ; } if ( TextUtils . isEmpty ( mUpperCaseDisplayName ) ) { mUpperCaseDisplayName = mDisplayName . toLowerCase ( ) ; mLowerCaseDisplayName = mDisplayName . toUpperCase ( ) ; } if ( ! pattern . equals ( mCurrentPattern ) ) { mCurrentPattern = pattern ; mUpperCasePattern = pattern . toUpperCase ( ) ; mLowerCasePattern = pattern . toLowerCase ( ) ; } return ( mUpperCaseDisplayName . indexOf ( mUpperCasePattern ) >= NUM_ ) || ( mLowerCaseDisplayName . indexOf ( mUpperCasePattern ) >= NUM_ ) ; }
public boolean equals ( Object obj ) { if ( obj == this ) { return BOOL_ ; } if ( obj instanceof AnnotationMember ) { AnnotationMember that = ( AnnotationMember ) obj ; if ( name . equals ( that . name ) && tag == that . tag ) { if ( tag == ARRAY ) { return equalArrayValue ( that . value ) ; } else if ( tag == ERROR ) { return BOOL_ ; } else { return value . equals ( that . value ) ; } } } return BOOL_ ; }
public static Range iterateZBounds ( XYZDataset dataset , boolean includeInterval ) { double minimum = Double . POSITIVE_INFINITY ; double maximum = Double . NEGATIVE_INFINITY ; int seriesCount = dataset . getSeriesCount ( ) ; for ( int series = NUM_ ; series < seriesCount ; series ++ ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = NUM_ ; item < itemCount ; item ++ ) { double value = dataset . getZValue ( series , item ) ; if ( ! Double . isNaN ( value ) ) { minimum = Math . min ( minimum , value ) ; maximum = Math . max ( maximum , value ) ; } } } if ( minimum == Double . POSITIVE_INFINITY ) { return null ; } else { return new Range ( minimum , maximum ) ; } }
public void removeViewFromFadeList ( View view ) { if ( mFadeViewList != null && view != null ) { mFadeViewList . remove ( view ) ; } }
void addIndifferentAlgorithm ( String algorithm ) { indifferentAlgorithms . add ( algorithm ) ; }
public UnionIterator ( Iterable < ? extends E > ... args ) { this ( Arrays . asList ( args ) ) ; }
public static String mangleNativeMethod ( String owner , String name , String desc ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( STR_ ) ; sb . append ( mangleNativeString ( owner ) ) ; sb . append ( STR_ ) ; sb . append ( mangleNativeString ( name ) ) ; if ( desc != null ) { sb . append ( STR_ ) ; sb . append ( mangleNativeString ( desc . substring ( NUM_ , desc . lastIndexOf ( STR_ ) ) ) ) ; } return sb . toString ( ) ; }
public String readLine ( ) throws IOException { boolean gotCR = BOOL_ , gotLF = BOOL_ ; pos = NUM_ ; lineBuf = new StringBuffer ( ) ; while ( ! gotLF ) { int c = is . read ( ) ; if ( c == - NUM_ ) { return null ; } if ( gotCR ) { if ( c == LF ) { gotLF = BOOL_ ; } else { gotCR = BOOL_ ; consume ( CR ) ; consume ( c ) ; } } else { if ( c == CR ) { gotCR = BOOL_ ; } else { consume ( c ) ; } } } lineBuf . append ( buf , NUM_ , pos ) ; return new String ( lineBuf ) ; }
public LobbyClient login ( ) { if ( ! m_serverProperties . isServerAvailable ( ) ) { JOptionPane . showMessageDialog ( m_parent , m_serverProperties . serverErrorMessage , STR_ , JOptionPane . ERROR_MESSAGE ) ; return null ; } if ( m_serverProperties . port == - NUM_ ) { if ( ClientFileSystemHelper . areWeOldExtraJar ( ) ) { JOptionPane . showMessageDialog ( m_parent , STR_ + UrlConstants . LATEST_GAME_DOWNLOAD_WEBSITE + STR_ + STR_ , STR_ , JOptionPane . ERROR_MESSAGE ) ; } else { JOptionPane . showMessageDialog ( m_parent , STR_ + UrlConstants . LATEST_GAME_DOWNLOAD_WEBSITE + STR_ , STR_ , JOptionPane . ERROR_MESSAGE ) ; } return null ; } return loginToServer ( ) ; }
@ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case FunctionblockPackage . PARAM__MULTIPLICITY : return multiplicity != MULTIPLICITY_EDEFAULT ; case FunctionblockPackage . PARAM__NAME : return NAME_EDEFAULT == null ? name != null : ! NAME_EDEFAULT . equals ( name ) ; case FunctionblockPackage . PARAM__DESCRIPTION : return DESCRIPTION_EDEFAULT == null ? description != null : ! DESCRIPTION_EDEFAULT . equals ( description ) ; } return super . eIsSet ( featureID ) ; }
protected Node popNode ( Stack < Node > stack , Class < ? extends Node > cls , String uri ) { Node top = stack . isEmpty ( ) ? null : stack . peek ( ) ; if ( top != null ) { if ( nodeMatches ( top , cls , uri ) ) { Node node = stack . pop ( ) ; poppedNodes . push ( node ) ; return node ; } else { for ( int i = stack . size ( ) - NUM_ ; i >= NUM_ ; i -- ) { if ( nodeMatches ( stack . get ( i ) , cls , uri ) ) { Node node = stack . remove ( i ) ; poppedNodes . push ( node ) ; return node ; } } } } return null ; }
static String pathToCookiePath ( String path ) { if ( path == null ) { return STR_ ; } int lastSlash = path . lastIndexOf ( STR_ ) ; return path . substring ( NUM_ , lastSlash + NUM_ ) ; }
public boolean moveEntry ( User user , Entry entry , String direction , boolean isAdmin , Errors errors ) { if ( direction == null ) { Errors . add ( errors , errorMessages . errorDirectionIsNull ( ) ) ; return BOOL_ ; } if ( entry == null ) { Errors . add ( errors , errorMessages . errorEntryIsNull ( ) ) ; return BOOL_ ; } if ( ! canUserModifyEntry ( user , entry , isAdmin ) ) { Errors . add ( errors , errorMessages . errorUserIsNotEntitledToMoveTheEntry ( ) ) ; return BOOL_ ; } final String parentId = entry . getParentId ( ) ; String parentFirstChildId = null ; String parentLastChildId = null ; final Entry parent = getEntryById ( parentId ) ; if ( parent == null ) { Errors . add ( errors , errorMessages . errorTheEntryHadNoParentSoItCouldNotBeMoved ( ) ) ; return BOOL_ ; } parentFirstChildId = parent . getFirstChildId ( ) ; parentLastChildId = parent . getLastChildId ( ) ; if ( direction . equals ( STR_ ) ) { final String previousId = entry . getPreviousSiblingId ( ) ; if ( previousId == null ) { Errors . add ( errors , errorMessages . errorThereIsNoEntryToMoveBefore ( ) ) ; return BOOL_ ; } final Entry previous = getEntryById ( previousId ) ; final String previousPreviousId = previous . getPreviousSiblingId ( ) ; if ( previousPreviousId != null ) { final Entry previousPrevious = getEntryById ( previousPreviousId ) ; if ( previousPrevious != null ) { previousPrevious . setNextSiblingId ( entry . getId ( ) ) ; } } final String nextId = entry . getNextSiblingId ( ) ; if ( nextId != null ) { final Entry next = getEntryById ( nextId ) ; if ( next != null ) { next . setPreviousSiblingId ( previousId ) ; } } entry . setPreviousSiblingId ( previousPreviousId ) ; entry . setNextSiblingId ( previousId ) ; previous . setPreviousSiblingId ( entry . getId ( ) ) ; previous . setNextSiblingId ( nextId ) ; if ( parentFirstChildId != null && previousId != null && parentFirstChildId . equals ( previousId ) ) { parent . setFirstChildId ( entry . getId ( ) ) ; } if ( parentLastChildId != null && parentLastChildId . equals ( entry . getId ( ) ) ) { parent . setLastChildId ( previousId ) ; } } else if ( direction . equals ( STR_ ) ) { final String nextId = entry . getNextSiblingId ( ) ; if ( nextId == null ) { Errors . add ( errors , errorMessages . errorThereIsNoEntryToMoveAfter ( ) ) ; return BOOL_ ; } final Entry next = getEntryById ( nextId ) ; final String nextNextId = next . getNextSiblingId ( ) ; if ( nextNextId != null ) { final Entry nextNext = getEntryById ( nextNextId ) ; if ( nextNext != null ) { nextNext . setPreviousSiblingId ( entry . getId ( ) ) ; } } final String previousId = entry . getPreviousSiblingId ( ) ; if ( previousId != null ) { final Entry previous = getEntryById ( previousId ) ; if ( previousId != null ) { previous . setNextSiblingId ( nextId ) ; } } entry . setPreviousSiblingId ( nextId ) ; entry . setNextSiblingId ( nextNextId ) ; next . setPreviousSiblingId ( previousId ) ; next . setNextSiblingId ( entry . getId ( ) ) ; if ( parentFirstChildId != null && parentFirstChildId . equals ( entry . getId ( ) ) ) { parent . setFirstChildId ( nextId ) ; } if ( parentLastChildId != null && nextId != null && parentLastChildId . equals ( nextId ) ) { parent . setLastChildId ( entry . getId ( ) ) ; } } else if ( direction . equals ( STR_ ) ) { final String parentParentId = parent . getParentId ( ) ; if ( parentParentId == null ) { Errors . add ( errors , errorMessages . errorThereIsNoParentOfTheParent ( ) ) ; return BOOL_ ; } snipOutEntry ( entry , parent , BOOL_ ) ; insertEntryAfter ( entry , parent , BOOL_ ) ; } else if ( direction . equals ( STR_ ) ) { final String previousId = entry . getPreviousSiblingId ( ) ; if ( previousId == null ) { Errors . add ( errors , errorMessages . errorThereIsNoPreviousEntryToUseAsAParent ( ) ) ; return BOOL_ ; } snipOutEntry ( entry , parent , BOOL_ ) ; final Entry previous = getEntryById ( previousId ) ; final String previousLastChildId = previous . getLastChildId ( ) ; if ( previousLastChildId != null ) { final Entry previousLastChild = getEntryById ( previousLastChildId ) ; previousLastChild . setNextSiblingId ( entry . getId ( ) ) ; } entry . setPreviousSiblingId ( previousLastChildId ) ; entry . setNextSiblingId ( null ) ; previous . setLastChildId ( entry . getId ( ) ) ; if ( ! previous . hasFirstChildId ( ) ) { previous . setFirstChildId ( entry . getId ( ) ) ; } previous . setLastChildId ( entry . getId ( ) ) ; entry . setParentId ( previous . getId ( ) ) ; } else { Errors . add ( errors , errorMessages . errorTheDirectionIsInvalid ( ) ) ; return BOOL_ ; } return BOOL_ ; }
private static boolean isGnome ( ) { return System . getenv ( STR_ ) != null ; }
protected SizeRequirements calculateMajorAxisRequirements ( int axis , SizeRequirements r ) { SizeRequirements req = super . calculateMajorAxisRequirements ( axis , r ) ; req . maximum = Integer . MAX_VALUE ; return req ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( NUM_ ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return newVector . elements ( ) ; }
public void addNodesInDocOrder ( DTMIterator iterator , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; int node ; while ( DTM . NULL != ( node = iterator . nextNode ( ) ) ) { addNodeInDocOrder ( node , support ) ; } }
public Map < String , List < RevisionFile > > currentRevisionFiles ( ) ;
protected static Pair < String , String > rorRegister ( final long offset , final ITranslationEnvironment environment , final List < ReilInstruction > instructions , final String registerNodeValue1 , final String registerNodeValue2 ) { final String shifterOperand = environment . getNextVariableString ( ) ; final String shifterCarryOut = environment . getNextVariableString ( ) ; final String tmpRsFour = environment . getNextVariableString ( ) ; final String tmpRsFourNegative = environment . getNextVariableString ( ) ; final String tmpRsSeven = environment . getNextVariableString ( ) ; final String isZeroConditionFour = environment . getNextVariableString ( ) ; final String isNotZeroConditionFour = environment . getNextVariableString ( ) ; final String isZeroConditionSeven = environment . getNextVariableString ( ) ; final String tmpVar1 = environment . getNextVariableString ( ) ; final String tmpVar2 = environment . getNextVariableString ( ) ; final String tmpVar3 = environment . getNextVariableString ( ) ; final String tmpVar4 = environment . getNextVariableString ( ) ; final String tmpVar5 = environment . getNextVariableString ( ) ; final String tmpVar6 = environment . getNextVariableString ( ) ; final String tmpVar7 = environment . getNextVariableString ( ) ; final String tmpVar8 = environment . getNextVariableString ( ) ; final String shifterCarryOutTmp1 = environment . getNextVariableString ( ) ; final String shifterCarryOutTmp2 = environment . getNextVariableString ( ) ; final String shifterCarryOutTmp3 = environment . getNextVariableString ( ) ; final String shifterCarryOutTmp4 = environment . getNextVariableString ( ) ; long baseOffset = offset ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , dWordSize , registerNodeValue2 , dWordSize , String . valueOf ( xFFL ) , dWordSize , tmpRsSeven ) ) ; instructions . add ( ReilHelpers . createBisz ( baseOffset ++ , dWordSize , tmpRsSeven , byteSize , isZeroConditionSeven ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , dWordSize , tmpRsSeven , dWordSize , String . valueOf ( x1FL ) , dWordSize , tmpRsFour ) ) ; instructions . add ( ReilHelpers . createBisz ( baseOffset ++ , dWordSize , tmpRsFour , byteSize , isZeroConditionFour ) ) ; instructions . add ( ReilHelpers . createBisz ( baseOffset ++ , byteSize , isZeroConditionFour , byteSize , isNotZeroConditionFour ) ) ; instructions . add ( ReilHelpers . createSub ( baseOffset ++ , dWordSize , zeroSet , dWordSize , tmpRsFour , dWordSize , tmpRsFourNegative ) ) ; instructions . add ( ReilHelpers . createBsh ( baseOffset ++ , dWordSize , registerNodeValue1 , dWordSize , tmpRsFourNegative , dWordSize , tmpVar1 ) ) ; instructions . add ( ReilHelpers . createSub ( baseOffset ++ , dWordSize , String . valueOf ( NUM_ ) , dWordSize , tmpRsFour , dWordSize , tmpVar2 ) ) ; instructions . add ( ReilHelpers . createBsh ( baseOffset ++ , dWordSize , registerNodeValue1 , dWordSize , tmpVar2 , dWordSize , tmpVar3 ) ) ; instructions . add ( ReilHelpers . createOr ( baseOffset ++ , dWordSize , tmpVar1 , dWordSize , tmpVar3 , dWordSize , tmpVar4 ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , dWordSize , tmpVar4 , dWordSize , bitMaskAllBitsSet , dWordSize , shifterOperand ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , byteSize , STR_ , byteSize , isZeroConditionSeven , byteSize , shifterCarryOutTmp1 ) ) ; instructions . add ( ReilHelpers . createBsh ( baseOffset ++ , dWordSize , registerNodeValue1 , dWordSize , minusThirtyOneSet , byteSize , tmpVar5 ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , byteSize , tmpVar5 , byteSize , isZeroConditionFour , byteSize , shifterCarryOutTmp2 ) ) ; instructions . add ( ReilHelpers . createSub ( baseOffset ++ , dWordSize , tmpRsFour , byteSize , oneSet , dWordSize , tmpVar6 ) ) ; instructions . add ( ReilHelpers . createSub ( baseOffset ++ , dWordSize , zeroSet , dWordSize , tmpVar6 , dWordSize , tmpVar7 ) ) ; instructions . add ( ReilHelpers . createBsh ( baseOffset ++ , dWordSize , registerNodeValue1 , dWordSize , tmpVar7 , dWordSize , tmpVar8 ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , dWordSize , tmpVar8 , byteSize , isNotZeroConditionFour , byteSize , shifterCarryOutTmp3 ) ) ; instructions . add ( ReilHelpers . createOr ( baseOffset ++ , byteSize , shifterCarryOutTmp1 , byteSize , shifterCarryOutTmp2 , byteSize , shifterCarryOutTmp4 ) ) ; instructions . add ( ReilHelpers . createOr ( baseOffset ++ , byteSize , shifterCarryOutTmp3 , byteSize , shifterCarryOutTmp4 , byteSize , shifterCarryOut ) ) ; return new Pair < String , String > ( shifterOperand , shifterCarryOut ) ; }
public static byte [ ] readFully ( InputStream in ) throws IOException { try { return readFullyNoClose ( in ) ; } finally { in . close ( ) ; } }
public void endSubreport ( String subreport ) { if ( subreport . isEmpty ( ) ) { LOG . error ( String . format ( STR_ , subreport ) ) ; return ; } String topSubreport = subreports . peek ( ) ; if ( topSubreport . equals ( subreport ) ) { subreports . pop ( ) ; addLogEntry ( new SubreportEndEntry ( subreport ) ) ; return ; } LOG . error ( String . format ( STR_ , subreport ) ) ; }
public static double dnormLog ( double x , double mean , double sd ) { if ( sd <= NUM_ ) throw new IllegalArgumentException ( STR_ ) ; return - Math . log ( sd ) + dnormLog ( ( x - mean ) / sd ) ; }
public static void delete ( File f ) { delete_ ( f , BOOL_ ) ; }
public BufferedHeader ( final CharArrayBuffer buffer ) throws ParseException { super ( ) ; if ( buffer == null ) { throw new IllegalArgumentException ( STR_ ) ; } int colon = buffer . indexOf ( STR_ ) ; if ( colon == - NUM_ ) { throw new ParseException ( STR_ + buffer . toString ( ) ) ; } String s = buffer . substringTrimmed ( NUM_ , colon ) ; if ( s . length ( ) == NUM_ ) { throw new ParseException ( STR_ + buffer . toString ( ) ) ; } this . buffer = buffer ; this . name = s ; this . valuePos = colon + NUM_ ; }
public boolean extendsEntity ( Class < ? > entityDefinition ) { return entityDefinition . getAnnotation ( ExtendsEntity . class ) != null ; }
private void pullEvent ( ) { final int newScrollValue ; final int itemDimension ; final float initialMotionValue , lastMotionValue ; switch ( getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : initialMotionValue = mInitialMotionX ; lastMotionValue = mLastMotionX ; break ; case VERTICAL : default : initialMotionValue = mInitialMotionY ; lastMotionValue = mLastMotionY ; break ; } switch ( mCurrentMode ) { case PULL_FROM_END : newScrollValue = Math . round ( Math . max ( initialMotionValue - lastMotionValue , NUM_ ) / FRICTION ) ; itemDimension = getFooterSize ( ) ; break ; case PULL_FROM_START : default : newScrollValue = Math . round ( Math . min ( initialMotionValue - lastMotionValue , NUM_ ) / FRICTION ) ; itemDimension = getHeaderSize ( ) ; break ; } setHeaderScroll ( newScrollValue ) ; if ( newScrollValue != NUM_ && ! isRefreshing ( ) ) { float scale = Math . abs ( newScrollValue ) / ( float ) itemDimension ; switch ( mCurrentMode ) { case PULL_FROM_END : mFooterLayout . onPull ( scale ) ; break ; case PULL_FROM_START : default : mHeaderLayout . onPull ( scale ) ; break ; } if ( mState != State . PULL_TO_REFRESH && itemDimension >= Math . abs ( newScrollValue ) ) { setState ( State . PULL_TO_REFRESH ) ; } else if ( mState == State . PULL_TO_REFRESH && itemDimension < Math . abs ( newScrollValue ) ) { setState ( State . RELEASE_TO_REFRESH ) ; } } }
public void parse ( InputSource input ) throws IOException , SAXException { if ( parsing ) { throw new SAXException ( STR_ ) ; } setupParser ( ) ; parsing = BOOL_ ; try { parser . parse ( input ) ; } finally { parsing = BOOL_ ; } parsing = BOOL_ ; }
private void release0 ( long ptr , long size , AtomicLong cnt ) { if ( ptr != NUM_ ) { if ( SAFE_RELEASE ) fill ( ptr , size , ( byte ) xAB ) ; GridUnsafe . freeMemory ( ptr ) ; cnt . addAndGet ( - size ) ; if ( lsnr != null ) lsnr . onEvent ( RELEASE ) ; } }
public void addServices ( List < ServiceDefinition > services ) throws Exception { ensurePathExists ( ) ; Set < String > remainingDescriptors = new HashSet < > ( dataManager . getChildren ( ZK_SERVICE_DEFINITION_PATH ) ) ; for ( ServiceDefinition service : services ) { LOG . debug ( String . format ( STR_ , service . serviceId ) ) ; String path = getServiceDefinitionPath ( service . serviceId ) ; try { Stat before = dataManager . checkExists ( path ) ; dataManager . putData ( path , service ) ; Stat after = dataManager . checkExists ( path ) ; nodeUpdated ( path , before , after ) ; remainingDescriptors . remove ( service . serviceId ) ; } catch ( Exception e ) { LOG . error ( String . format ( STR_ , service . serviceId , path ) , e ) ; throw e ; } } for ( String descriptorName : remainingDescriptors ) { LOG . info ( String . format ( STR_ , descriptorName ) ) ; dataManager . removeNode ( ZK_SERVICE_DEFINITION_PATH + STR_ + descriptorName ) ; } }
protected void readProps ( ) { int count ; Properties props ; int i ; String itemStr ; T item ; m_IgnoreChanges = BOOL_ ; props = loadProps ( ) ; count = Integer . parseInt ( props . getProperty ( expand ( getCountKey ( ) ) , STR_ ) ) ; m_RecentItems . clear ( ) ; for ( i = count - NUM_ ; i >= NUM_ ; i -- ) { itemStr = props . getProperty ( getItemPrefix ( ) + i , STR_ ) ; if ( itemStr . length ( ) > NUM_ ) { item = fromString ( itemStr ) ; if ( check ( item ) ) addRecentItem ( item ) ; } } m_IgnoreChanges = BOOL_ ; }
public FormIndex stepIndexOut ( FormIndex index ) { if ( index . isTerminal ( ) ) { return null ; } else { return new FormIndex ( stepIndexOut ( index . getNextLevel ( ) ) , index ) ; } }
@ Override protected synchronized void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { int width = NUM_ ; if ( MeasureSpec . UNSPECIFIED != MeasureSpec . getMode ( widthMeasureSpec ) ) { width = MeasureSpec . getSize ( widthMeasureSpec ) ; } int height = thumbImage . getHeight ( ) ; if ( MeasureSpec . UNSPECIFIED != MeasureSpec . getMode ( heightMeasureSpec ) ) { height = Math . min ( height , MeasureSpec . getSize ( heightMeasureSpec ) ) ; } setMeasuredDimension ( width , height ) ; }
public void start ( ) { calculatePositionArray ( ) ; setPreferredSize ( calculatePreferredSize ( ) ) ; offset = getWidth ( ) ; timer = new Timer ( interval , this ) ; timer . start ( ) ; }
public static void writePlainFile ( String filePath , byte [ ] content ) throws IOException { FileOutputStream fileOuputStream = new FileOutputStream ( filePath ) ; fileOuputStream . write ( content ) ; fileOuputStream . close ( ) ; }
public void transform ( AffineTransform at ) { clip [ NUM_ ] = clip [ NUM_ ] ; clip [ NUM_ ] = clip [ NUM_ ] ; clip [ NUM_ ] = clip [ NUM_ ] ; clip [ NUM_ ] = clip [ NUM_ ] ; at . transform ( clip , NUM_ , clip , NUM_ , NUM_ ) ; double xmin = clip [ NUM_ ] , ymin = clip [ NUM_ ] ; double xmax = clip [ NUM_ ] , ymax = clip [ NUM_ ] ; for ( int i = NUM_ ; i < NUM_ ; i += NUM_ ) { if ( clip [ i ] < xmin ) xmin = clip [ i ] ; if ( clip [ i ] > xmax ) xmax = clip [ i ] ; if ( clip [ i + NUM_ ] < ymin ) ymin = clip [ i + NUM_ ] ; if ( clip [ i + NUM_ ] > ymax ) ymax = clip [ i + NUM_ ] ; } clip [ NUM_ ] = xmin ; clip [ NUM_ ] = ymin ; clip [ NUM_ ] = xmax ; clip [ NUM_ ] = ymax ; }
@ SuppressWarnings ( STR_ ) public boolean isPortableFilename ( String filename ) { return ( filename . startsWith ( PROGRAM ) || filename . startsWith ( HOME ) || filename . startsWith ( PREFERENCES ) || filename . startsWith ( SCRIPTS ) || filename . startsWith ( PROFILE ) || filename . startsWith ( SETTINGS ) || filename . startsWith ( FILE ) || filename . startsWith ( RESOURCE ) ) ; }
void configureBasicAuth ( HttpServerRequest serverRequest , HttpClientRequest httpClientRequest ) { final String authorization = serverRequest . getParam ( STR_ ) ; if ( authorization != null ) { httpClientRequest . putHeader ( HttpHeaders . AUTHORIZATION , authorization ) ; } }
public void rejectedExecution ( Runnable r , ThreadPoolExecutor e ) { if ( ! e . isShutdown ( ) ) { r . run ( ) ; } }
public boolean nodeChange ( CatalogTreeNode node , String name ) { CatalogTreeNode cNode = getCorrespondingNode ( node ) ; cNode . setLeaves ( node . getLeaves ( ) ) ; AbstractCatalogTree tree = ( AbstractCatalogTree ) getCorespondingModel ( node ) ; cNode . setUserObject ( name ) ; node . setUserObject ( name ) ; tree . nodeChanged ( cNode ) ; _model . nodeChanged ( node ) ; updatePanel ( ) ; ImageIndexEditor . indexChanged ( BOOL_ ) ; updatePanel ( ) ; return BOOL_ ; }
public static Enumeration all ( ) { return _all . elements ( ) ; }
public boolean waitUntilEmpty ( long timeout ) throws InterruptedException { if ( ! notifyLock . tryLock ( timeout , TimeUnit . MILLISECONDS ) ) { return BOOL_ ; } try { return pending . isEmpty ( ) || notifyCondition . await ( timeout , TimeUnit . MILLISECONDS ) ; } finally { notifyLock . unlock ( ) ; } }
public static Set < JavaClassAndMethod > resolveMethodCallTargets ( ReferenceType receiverType , InvokeInstruction invokeInstruction , ConstantPoolGen cpg ) throws ClassNotFoundException { return resolveMethodCallTargets ( receiverType , invokeInstruction , cpg , BOOL_ ) ; }
private String safe ( String src ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = NUM_ ; i < src . length ( ) ; i ++ ) { char c = src . charAt ( i ) ; if ( c >= NUM_ && c < NUM_ ) { sb . append ( c ) ; } else { sb . append ( STR_ + ( int ) c + STR_ ) ; } } return sb . toString ( ) ; }
public Algorithm ( Element el ) { requiredKey = el . getAttribute ( STR_ ) ; jceName = el . getAttribute ( STR_ ) ; algorithmClass = el . getAttribute ( STR_ ) ; if ( el . hasAttribute ( STR_ ) ) { keyLength = Integer . parseInt ( el . getAttribute ( STR_ ) ) ; } else { keyLength = NUM_ ; } }
protected abstract boolean isSSLSocket ( ) ;
private Run consumeRun ( int offset ) { char ch = fText . charAt ( offset ) ; int length = fText . length ( ) ; Run run = getRun ( ch ) ; while ( run . consume ( ch ) && offset < length - NUM_ ) { offset ++ ; ch = fText . charAt ( offset ) ; } return run ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( NUM_ ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
public static String formatForUI ( Calendar today , Calendar date ) { if ( today . get ( Calendar . YEAR ) == date . get ( Calendar . YEAR ) ) { if ( today . get ( Calendar . DAY_OF_YEAR ) == date . get ( Calendar . DAY_OF_YEAR ) ) { return STR_ ; } return currentYearDateFormat ( date . getTimeInMillis ( ) ) ; } else { return format ( date . getTimeInMillis ( ) ) ; } }
public OutputStreamWriter ( OutputStream out , CharsetEncoder enc ) { super ( out ) ; if ( enc == null ) throw new NullPointerException ( STR_ ) ; se = StreamEncoder . forOutputStreamWriter ( out , this , enc ) ; }
public synchronized void free ( long pos , int length ) { int start = getBlock ( pos ) ; int blocks = getBlockCount ( length ) ; BlockRange x = new BlockRange ( start , blocks ) ; BlockRange next = freeSpace . ceiling ( x ) ; if ( next == null ) { throw DataUtils . newIllegalStateException ( DataUtils . ERROR_INTERNAL , STR_ ) ; } BlockRange prev = freeSpace . lower ( x ) ; if ( prev != null ) { if ( prev . start + prev . blocks == start ) { prev . blocks += blocks ; if ( prev . start + prev . blocks == next . start ) { prev . blocks += next . blocks ; freeSpace . remove ( next ) ; } return ; } } if ( start + blocks == next . start ) { next . start -= blocks ; next . blocks += blocks ; return ; } freeSpace . add ( x ) ; }
private static void decodeHanziSegment ( BitSource bits , StringBuilder result , int count ) throws FormatException { if ( count . NUM_ > bits . available ( ) ) { throw FormatException . getFormatInstance ( ) ; } byte [ ] buffer = new byte [ NUM_ . count ] ; int offset = NUM_ ; while ( count > NUM_ ) { int twoBytes = bits . readBits ( NUM_ ) ; int assembledTwoBytes = ( ( twoBytes / x060 ) << NUM_ ) | ( twoBytes % x060 ) ; if ( assembledTwoBytes < x003BF ) { assembledTwoBytes += x0A1A1 ; } else { assembledTwoBytes += x0A6A1 ; } buffer [ offset ] = ( byte ) ( ( assembledTwoBytes > > NUM_ ) & xFF ) ; buffer [ offset + NUM_ ] = ( byte ) ( assembledTwoBytes & xFF ) ; offset += NUM_ ; count -- ; } try { result . append ( new String ( buffer , StringUtils . GB2312 ) ) ; } catch ( UnsupportedEncodingException ignored ) { throw FormatException . getFormatInstance ( ) ; } }
public URI csrfToken ( ) { URIBuilder builder = apiBuilder ( ) ; builder . setParameter ( STR_ , STR_ ) ; builder . setParameter ( STR_ , STR_ ) ; builder . setParameter ( STR_ , STR_ ) ; return build ( builder ) ; }
private static char [ ] zzUnpackCMap ( String packed ) { char [ ] map = new char [ x10000 ] ; int i = NUM_ ; int j = NUM_ ; while ( i < NUM_ ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM_ ) ; } return map ; }
public DistributedLogMultiStreamWriter build ( ) { Preconditions . checkArgument ( ( null != _streams && ! _streams . isEmpty ( ) ) , STR_ ) ; Preconditions . checkNotNull ( _client , STR_ ) ; Preconditions . checkNotNull ( _codec , STR_ ) ; Preconditions . checkArgument ( _firstSpeculativeTimeoutMs > NUM_ && _firstSpeculativeTimeoutMs <= _maxSpeculativeTimeoutMs && _speculativeBackoffMultiplier > NUM_ && _maxSpeculativeTimeoutMs < _requestTimeoutMs , STR_ ) ; return new DistributedLogMultiStreamWriter ( _streams , _client , Math . min ( _bufferSize , MAX_LOGRECORDSET_SIZE ) , _flushIntervalMs , _requestTimeoutMs , _firstSpeculativeTimeoutMs , _maxSpeculativeTimeoutMs , _speculativeBackoffMultiplier , _codec , _ticker , _executorService ) ; }
private void writeChars ( int number , char c ) throws IOException { for ( ; number > NUM_ ; number -- ) { writer . write ( c ) ; } }
@ Override public void error ( String msg , Throwable t ) { if ( logger . isLoggable ( Level . SEVERE ) ) { log ( SELF , Level . SEVERE , msg , t ) ; } }
public int exit_signal ( ) { return Integer . parseInt ( fields [ NUM_ ] ) ; }
public Command ( ) { msgQueue = new LinkedList < Message > ( ) ; msgQueue . clear ( ) ; }
public synchronized int indexOf ( V item ) { return items . indexOf ( item ) ; }
protected void createNode ( DefaultMutableTreeNode top , String title , String info , String content , int lineCount ) { DefaultMutableTreeNode threadInfo = null ; threadInfo = new DefaultMutableTreeNode ( new ThreadInfo ( title , info , content , lineCount , getThreadTokens ( title ) ) ) ; top . add ( threadInfo ) ; }
public Peer clone ( ) { Peer clone = new Peer ( network . clone ( ) , address ) ; return clone ; }
public static String generateNativeGuid ( String deviceType , String serialNumber , String fileShareNativeId ) { return String . format ( STR_ + FILESYSTEM + STR_ , _deviceTypeMap . get ( deviceType ) , serialNumber , fileShareNativeId ) ; }
public StrBuilder ensureCapacity ( final int capacity ) { if ( capacity > buffer . length ) { final char [ ] old = buffer ; buffer = new char [ capacity . NUM_ ] ; System . arraycopy ( old , NUM_ , buffer , NUM_ , size ) ; } return this ; }
private void onStartTrackingTouch ( ) { mIsDragging = BOOL_ ; }
private static void createSuperForwarder ( ClassNode targetNode , MethodNode forwarder , final Map < String , ClassNode > genericsSpec ) { List < ClassNode > interfaces = new ArrayList < ClassNode > ( Traits . collectAllInterfacesReverseOrder ( targetNode , new LinkedHashSet < ClassNode > ( ) ) ) ; String name = forwarder . getName ( ) ; Parameter [ ] forwarderParameters = forwarder . getParameters ( ) ; LinkedHashSet < ClassNode > traits = new LinkedHashSet < ClassNode > ( ) ; List < MethodNode > superForwarders = new LinkedList < MethodNode > ( ) ; for ( ClassNode node : interfaces ) { if ( Traits . isTrait ( node ) ) { MethodNode method = node . getDeclaredMethod ( name , forwarderParameters ) ; if ( method != null ) { traits . add ( node ) ; superForwarders . add ( method ) ; } } } for ( MethodNode superForwarder : superForwarders ) { doCreateSuperForwarder ( targetNode , superForwarder , traits . toArray ( new ClassNode [ traits . size ( ) ] ) , genericsSpec ) ; } }
public void testCase15 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte rBytes [ ] = { NUM_ } ; int aSign = - NUM_ ; int bSign = NUM_ ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . add ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public boolean isVirtualPoolAccessible ( VirtualPool resource ) { return _permissionsHelper . tenantHasUsageACL ( URI . create ( _user . getTenantId ( ) ) , resource ) ; }
public void testTimedInvokeAllNullTimeUnit ( ) throws Throwable { ExecutorService e = new ForkJoinPool ( NUM_ ) ; PoolCleaner cleaner = null ; try { cleaner = cleaner ( e ) ; List < Callable < String > > l = new ArrayList < Callable < String > > ( ) ; l . add ( new StringTask ( ) ) ; try { e . invokeAll ( l , MEDIUM_DELAY_MS , null ) ; shouldThrow ( ) ; } catch ( NullPointerException success ) { } } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
private static boolean intersectsOneOf ( final Rectangle2D r , final Collection < ? extends Shape > shapes ) { if ( shapes . isEmpty ( ) ) { return BOOL_ ; } for ( final Shape item : shapes ) { if ( item . intersects ( r ) ) { return BOOL_ ; } } return BOOL_ ; }
private void expectedByte ( int position , int count ) throws UTFDataFormatException { throw new UTFDataFormatException ( Localizer . getMessage ( STR_ , Integer . toString ( position ) , Integer . toString ( count ) ) ) ; }
private List < String > checkConfigList ( Configuration config , String name ) { String peerIPs = config . getConfig ( name ) ; ArrayList < String > peers = new ArrayList < String > ( ) ; if ( peerIPs != null ) { for ( String ip : StringUtils . split ( peerIPs , STR_ ) ) { peers . add ( ip ) ; } } return peers ; }
public final ByteBuffer encode ( CharBuffer in ) throws CharacterCodingException { int length = ( int ) ( in . remaining ( ) . averageBytesPerChar ) ; ByteBuffer out = ByteBuffer . allocate ( length ) ; reset ( ) ; while ( state != FLUSHED ) { CoderResult result = encode ( in , out , BOOL_ ) ; if ( result == CoderResult . OVERFLOW ) { out = allocateMore ( out ) ; continue ; } else { checkCoderResult ( result ) ; } result = flush ( out ) ; if ( result == CoderResult . OVERFLOW ) { out = allocateMore ( out ) ; } else { checkCoderResult ( result ) ; } } out . flip ( ) ; return out ; }
private void loadExternal ( ) { Properties properties = new Properties ( ) ; try { properties . loadFromXML ( new FileInputStream ( PROPERTIES_PATH ) ) ; for ( String key : properties . stringPropertyNames ( ) ) { externalSupport . put ( key , properties . getProperty ( key ) ) ; } } catch ( IOException ignore ) { } }
public static URI parseURI ( String nuri , URI baseuri ) throws URISyntaxException { int colonLocation = nuri . indexOf ( STR_ ) ; int fragmentLocation = getFragmentLocation ( nuri ) ; if ( colonLocation == - NUM_ || colonLocation > fragmentLocation ) { if ( baseuri == null ) throw new URISyntaxException ( STR_ + nuri + STR_ + STR_ , nuri ) ; } String protocol = nuri . substring ( NUM_ , colonLocation ) ; if ( protocol . equals ( STR_ ) ) { return parseURN ( nuri , colonLocation , fragmentLocation ) ; } else if ( protocol . equals ( STR_ ) ) { return new URI ( nuri ) ; } else if ( protocol . equals ( STR_ ) ) { return new URI ( nuri ) ; } else if ( protocol . equals ( STR_ ) ) { return new URI ( nuri ) ; } else { return parseGeneralURI ( nuri , colonLocation , fragmentLocation ) ; } }
protected void updateUs ( ) { try { setText ( m_Editor . getAsText ( ) ) ; } catch ( IllegalArgumentException ex ) { } }
public File makeDirty ( ) throws IOException { File f = File . createTempFile ( STR_ , STR_ , repositoryLocation . getParentFile ( ) ) ; FileWriter fw = new FileWriter ( f ) ; fw . write ( STR_ + System . currentTimeMillis ( ) ) ; fw . flush ( ) ; fw . close ( ) ; return f ; }
private static boolean isASCIISuperset ( String encoding ) throws Exception { String chkS = STR_ + STR_ ; byte [ ] chkB = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte [ ] b = chkS . getBytes ( encoding ) ; return Arrays . equals ( b , chkB ) ; }
public static BigDecimal allocated ( int p_C_Payment_ID , int p_C_Currency_ID ) throws SQLException { BigDecimal PayAmt = null ; int C_Charge_ID = NUM_ ; String sql = STR_ + STR_ + STR_ ; PreparedStatement pstmt = Adempiere . prepareStatement ( sql ) ; pstmt . setInt ( NUM_ , p_C_Payment_ID ) ; ResultSet rs = pstmt . executeQuery ( ) ; if ( rs . next ( ) ) { PayAmt = rs . getBigDecimal ( NUM_ ) ; C_Charge_ID = rs . getInt ( NUM_ ) ; } rs . close ( ) ; pstmt . close ( ) ; if ( C_Charge_ID > NUM_ ) return PayAmt ; int C_ConversionType_ID = NUM_ ; BigDecimal allocatedAmt = getAllocatedAmt ( p_C_Payment_ID , p_C_Currency_ID , C_ConversionType_ID ) ; return Currency . round ( allocatedAmt , p_C_Currency_ID , null ) ; }
public static ByteBuffer processOutboundPackage ( ByteBuffer roData , int exchangeId , boolean connectionOk ) { roData . rewind ( ) ; if ( BuildConfig . DEBUG ) { XposedBridge . log ( STR_ + Integer . toString ( roData . remaining ( ) ) ) ; } try { synchronized ( sync ) { } } catch ( Throwable e ) { XposedBridge . log ( e ) ; } return null ; }
public void initialize ( ) { if ( isClosed . get ( ) ) { logger . info ( STR_ ) ; ActorConfig . createAndGetActorSystem ( ) ; httpClientStore . init ( ) ; tcpSshPingResourceStore . init ( ) ; ParallelTaskManager . getInstance ( ) ; isClosed . set ( BOOL_ ) ; logger . info ( STR_ ) ; } else { logger . debug ( STR_ ) ; } }
@ NotNull private static TextRange processSpaces ( @ NotNull Helper helper , @ NotNull TextRange range , int tabWidth ) { CharSequence indent = helper . getCurrentLineIndent ( ) ; int start = Math . max ( NUM_ , range . getStartOffset ( ) - helper . getCurrentLineStartOffset ( ) ) ; int end = Math . min ( indent . length ( ) , range . getEndOffset ( ) - helper . getCurrentLineStartOffset ( ) ) ; int tabsNumber = NUM_ ; int indentOffset = end ; for ( int i = start ; i < end ; i ++ ) { char c = indent . charAt ( i ) ; if ( c == STR_ ) { tabsNumber ++ ; } else if ( c != STR_ ) { indentOffset = i ; break ; } } if ( tabsNumber > NUM_ ) { helper . replace ( start , indentOffset , StringUtil . repeat ( STR_ , indentOffset - start - tabsNumber + tabsNumber . tabWidth ) ) ; return TextRange . create ( range . getStartOffset ( ) , range . getEndOffset ( ) - tabsNumber + tabsNumber . tabWidth ) ; } else { return range ; } }
public void removeAlarm ( final Alarm ALARM ) { if ( alarms . contains ( ALARM ) ) alarms . remove ( ALARM ) ; }
public int read ( ) throws java . io . IOException { synchronized ( lock ) { char charArray [ ] = new char [ NUM_ ] ; if ( read ( charArray , NUM_ , NUM_ ) != - NUM_ ) { return charArray [ NUM_ ] ; } return - NUM_ ; } }
protected void checkParameters ( ) { if ( parameters != null ) { for ( int i = NUM_ , size = parameters . size ( ) ; i < size ; i ++ ) { Parameter param = parameters . get ( i ) ; param . checkSet ( ) ; } } }
private static Properties createProperties1 ( String conflation ) { Properties props = new Properties ( ) ; props . setProperty ( DELTA_PROPAGATION , STR_ ) ; props . setProperty ( MCAST_PORT , STR_ ) ; props . setProperty ( LOCATORS , STR_ ) ; props . setProperty ( CONFLATE_EVENTS , conflation ) ; return props ; }
public static void closeSilently ( ResultSet rs ) { if ( rs != null ) { try { rs . close ( ) ; } catch ( SQLException e ) { } } }
public static void execute ( PoolImpl pool , Function function , Object args , MemberMappedArgument memberMappedArg , boolean allServers , byte hasResult , boolean isFnSerializationReqd , String [ ] groups ) { List servers = null ; AbstractOp op = new ExecuteFunctionNoAckOpImpl ( function , args , memberMappedArg , hasResult , isFnSerializationReqd , groups , allServers ) ; try { if ( allServers && groups . length == NUM_ ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STR_ + op . getMessage ( ) + STR_ + pool ) ; } servers = pool . getCurrentServers ( ) ; Iterator i = servers . iterator ( ) ; while ( i . hasNext ( ) ) { pool . executeOn ( ( ServerLocation ) i . next ( ) , op ) ; } } else { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STR_ + op . getMessage ( ) + STR_ + pool + STR_ + Arrays . toString ( groups ) + STR_ + allServers ) ; } pool . execute ( op , NUM_ ) ; } } catch ( Exception ex ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STR_ + op . getMessage ( ) + STR_ + pool , ex ) ; } if ( ex . getMessage ( ) != null ) throw new FunctionException ( ex . getMessage ( ) , ex ) ; else throw new FunctionException ( STR_ , ex ) ; } }
public static Script createMultiSigInputScript ( TransactionSignature ... signatures ) { return createMultiSigInputScript ( Arrays . asList ( signatures ) ) ; }
Object proxyIfReturnTypeIsJdbcInterface ( Class < ? > returnType , Object toProxy ) { if ( toProxy != null ) { if ( Util . isJdbcInterface ( returnType ) ) { Class < ? > toProxyClass = toProxy . getClass ( ) ; return Proxy . newProxyInstance ( toProxyClass . getClassLoader ( ) , Util . getImplementedInterfaces ( toProxyClass ) , getNewJdbcInterfaceProxy ( toProxy ) ) ; } } return toProxy ; }
public final void empty ( ) { synchronized ( buffer ) { buffer . clear ( ) ; bufferMap . clear ( ) ; } }
public void testModeratelyComplexTemplating ( ) throws Exception { HtmlPage page = getPage ( STR_ ) ; String text = page . asText ( ) ; assertTrue ( text . contains ( STR_ ) ) ; }
private ValueRange rangeByWeek ( TemporalAccessor temporal , TemporalField field ) { int dow = localizedDayOfWeek ( temporal ) ; int offset = startOfWeekOffset ( temporal . get ( field ) , dow ) ; ValueRange fieldRange = temporal . range ( field ) ; return ValueRange . of ( computeWeek ( offset , ( int ) fieldRange . getMinimum ( ) ) , computeWeek ( offset , ( int ) fieldRange . getMaximum ( ) ) ) ; }
public Object apply ( Object in ) { if ( in instanceof HasWord ) { HasWord w = ( HasWord ) in ; String str = w . word ( ) ; String outStr = americanize ( str , capitalizeTimex ) ; if ( ! outStr . equals ( str ) ) { w . setWord ( outStr ) ; } return w ; } else { String str = ( String ) in ; return americanize ( str , capitalizeTimex ) ; } }
public void addWayRef ( MapWay way , int nodeIdx ) { if ( ways == null ) ways = new ArrayList < WayRef > ( NUM_ ) ; if ( ways . isEmpty ( ) || ways . get ( NUM_ ) != way ) ways . add ( new DefaultWayRef ( way , ( short ) nodeIdx ) ) ; }
public double doCrossValidation ( Iterable < T > data , int dataSize ) throws InterruptedException , ExecutionException { stats = new OneVariableStats ( ) ; log . info ( STR_ + ( new Date ( ) ) ) ; log . info ( STR_ + numFolds + STR_ ) ; List < List < T > > splits = splitData ( data , dataSize ) ; log . info ( STR_ ) ; ExecutorService executor = Executors . newFixedThreadPool ( numThreads ) ; List < FutureTask < Double > > folds = new ArrayList < > ( ) ; for ( int i = NUM_ ; i < numFolds ; i ++ ) { List < T > trainingSet = new ArrayList < > ( ) ; for ( int j = NUM_ ; j < numFolds ; j ++ ) { if ( j != i ) trainingSet . addAll ( splits . get ( j ) ) ; } List < T > testSet = splits . get ( i ) ; FutureTask < Double > fold = createFoldTask ( trainingSet , testSet , i ) ; executor . execute ( fold ) ; folds . add ( fold ) ; } executor . shutdown ( ) ; executor . awaitTermination ( timeoutSeconds , TimeUnit . SECONDS ) ; for ( FutureTask < Double > fold : folds ) { stats . add ( fold . get ( ) ) ; } log . info ( STR_ + ( new Date ( ) ) ) ; return stats . mean ( ) ; }
public EntireTextBuilder addBackground ( @ ColorInt int bgColor , int start , int end ) { BackgroundHolder backgroundHolder = new BackgroundHolder ( bgColor , start , end ) ; mBackgrounds . add ( backgroundHolder ) ; return this ; }
public void removeChangingListener ( OnWheelChangedListener listener ) { changingListeners . remove ( listener ) ; }
public boolean matches ( String filename ) { if ( exts == null ) return BOOL_ ; int j = filename . lastIndexOf ( STR_ ) ; if ( j == - NUM_ || j == filename . length ( ) ) return BOOL_ ; String suffix = filename . substring ( j + NUM_ ) ; return exts . contains ( suffix ) ; }
public Rectangle [ ] computeGaps ( ) { ArrayList < Rectangle > ret = new ArrayList < > ( ) ; Rectangle gap = new Rectangle ( ) ; for ( int i = NUM_ ; i < mRectList . length ; i ++ ) { Rectangle rectangleA = mRectList [ i ] ; for ( int j = i + NUM_ ; j < mRectList . length ; j ++ ) { Rectangle rectangleB = mRectList [ j ] ; boolean viable = calculateGap ( rectangleA , rectangleB , gap ) ; if ( viable ) { for ( int k = NUM_ ; k < mRectList . length ; k ++ ) { if ( k != j && k != i ) { if ( gap . intersects ( mRectList [ k ] ) ) { viable = BOOL_ ; break ; } } } } if ( viable ) { ret . add ( new Rectangle ( gap ) ) ; } } } return ret . toArray ( new Rectangle [ ret . size ( ) ] ) ; }
public synchronized MethodCountSet collectHotMethods ( int optLevel , double threshold ) { if ( DEBUG ) validityCheck ( ) ; ArrayList < HotMethodRecompilationEvent > collect = new ArrayList < HotMethodRecompilationEvent > ( ) ; collectHotOptMethodsInternal ( NUM_ , collect , hotnessToCounts ( threshold ) , optLevel ) ; int numHotMethods = collect . size ( ) ; double [ ] numCounts = new double [ numHotMethods ] ; CompiledMethod [ ] hotMethods = new CompiledMethod [ numHotMethods ] ; for ( int i = NUM_ ; i < numHotMethods ; i ++ ) { HotMethodEvent event = collect . get ( i ) ; hotMethods [ i ] = event . getCompiledMethod ( ) ; numCounts [ i ] = event . getNumSamples ( ) ; } return new MethodCountSet ( hotMethods , numCounts ) ; }
public synchronized void addBan ( long duration , String reason , String id ) { addLine ( new BanMessage ( System . currentTimeMillis ( ) , duration , reason , id ) ) ; }
private void writeHeader ( ) throws OpenStegoException { DCTDataHeader header = null ; try { header = new DCTDataHeader ( this . dataLength , this . fileName , this . config ) ; if ( ( ( header . getHeaderSize ( ) + this . dataLength ) . NUM_ ) > ( this . imgWidth . this . imgHeight / ( DCT . NJPEG . DCT . NJPEG ) ) ) { throw new OpenStegoException ( null , DctLSBPlugin . NAMESPACE , DctLSBErrors . IMAGE_SIZE_INSUFFICIENT ) ; } this . coord = new Coordinates ( ( header . getHeaderSize ( ) + this . dataLength ) . NUM_ ) ; write ( header . getHeaderData ( ) ) ; } catch ( IOException ioEx ) { throw new OpenStegoException ( ioEx ) ; } }
public int decrementSubscriberCount ( ) { if ( isAvailable ( ) ) { return jmdnsSubscriberCount . decrementAndGet ( ) ; } return NUM_ ; }
public static boolean addShapelessEnchantingRecipe ( ItemStack aResult , Enchantment [ ] aEnchantmentsAdded , int [ ] aEnchantmentLevelsAdded , Object [ ] aRecipe ) { return addShapelessCraftingRecipe ( aResult , aEnchantmentsAdded , aEnchantmentLevelsAdded , BOOL_ , BOOL_ , BOOL_ , BOOL_ , aRecipe ) ; }
public void start ( ) throws TomcatException { if ( cat == null ) init ( ) ; cat . start ( ) ; }
@ Override public synchronized void initialize ( ) { if ( ! mRootDirectory . exists ( ) ) { if ( ! mRootDirectory . mkdirs ( ) ) { VolleyLog . e ( STR_ , mRootDirectory . getAbsolutePath ( ) ) ; } return ; } File [ ] files = mRootDirectory . listFiles ( ) ; if ( files == null ) { return ; } for ( File file : files ) { BufferedInputStream fis = null ; try { fis = new BufferedInputStream ( new FileInputStream ( file ) ) ; CacheHeader entry = CacheHeader . readHeader ( fis ) ; entry . size = file . length ( ) ; putEntry ( entry . key , entry ) ; } catch ( IOException e ) { if ( file != null ) { file . delete ( ) ; } } finally { try { if ( fis != null ) { fis . close ( ) ; } } catch ( IOException ignored ) { } } } }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( NUM_ ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return newVector . elements ( ) ; }
private List < View > addView ( View view , List < View > cache ) { if ( cache == null ) { cache = new LinkedList < View > ( ) ; } cache . add ( view ) ; return cache ; }
private boolean imageOutline ( DefaultMutableTreeNode node ) { boolean isOutline = BOOL_ ; if ( node != null ) { DefaultMutableTreeNode parentNode = ( DefaultMutableTreeNode ) node . getParent ( ) ; if ( parentNode != null ) { if ( parentNode . getUserObject ( ) instanceof RasterSymbolizer ) { isOutline = BOOL_ ; } } } return isOutline ; }
private short addEntry ( Entry entry ) { pool . add ( entry ) ; if ( pool . size ( ) >= NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } return ( short ) pool . size ( ) ; }
private boolean loadNextPage ( ) { result = pageable . getPage ( query , skip , pageSize ) ; index = NUM_ ; if ( result == null || result . isEmpty ( ) ) { return BOOL_ ; } return BOOL_ ; }
public boolean contains ( Node s ) { runTo ( - NUM_ ) ; if ( null == m_map ) return BOOL_ ; for ( int i = NUM_ ; i < m_firstFree ; i ++ ) { Node node = m_map [ i ] ; if ( ( null != node ) && node . equals ( s ) ) return BOOL_ ; } return BOOL_ ; }
public void close ( ) throws IOException { if ( ! closed ) { if ( usesDefaultInflater ) inf . end ( ) ; in . close ( ) ; closed = BOOL_ ; } }
public FieldAnalysisRequest addFieldType ( String fieldTypeName ) { if ( fieldTypes == null ) { fieldTypes = new LinkedList < > ( ) ; } fieldTypes . add ( fieldTypeName ) ; return this ; }
public static BigFraction parseEditRate ( String editRate ) { editRate = editRate . contains ( STR_ ) ? rFrameRateToEditRate ( editRate ) : editRate ; String [ ] parts = editRate . split ( STR_ ) ; try { if ( parts . length == NUM_ ) { return new BigFraction ( Long . parseLong ( parts [ NUM_ ] ) , Long . parseLong ( parts [ NUM_ ] ) ) ; } else if ( parts . length == NUM_ ) { return new BigFraction ( Long . parseLong ( parts [ NUM_ ] ) ) ; } } catch ( NumberFormatException e ) { throw new ConversionHelperException ( STR_ , e ) ; } throw new ConversionHelperException ( STR_ ) ; }
public FST < T > finish ( ) throws IOException { final UnCompiledNode < T > root = frontier [ NUM_ ] ; freezeTail ( NUM_ ) ; if ( root . inputCount < minSuffixCount1 || root . inputCount < minSuffixCount2 || root . numArcs == NUM_ ) { if ( fst . emptyOutput == null ) { return null ; } else if ( minSuffixCount1 > NUM_ || minSuffixCount2 > NUM_ ) { return null ; } } else { if ( minSuffixCount2 != NUM_ ) { compileAllTargets ( root , lastInput . length ( ) ) ; } } fst . finish ( compileNode ( root , lastInput . length ( ) ) . node ) ; if ( doPackFST ) { return fst . pack ( this , NUM_ , Math . max ( NUM_ , ( int ) ( getNodeCount ( ) / NUM_ ) ) , acceptableOverheadRatio ) ; } else { return fst ; } }
public void onConfiguration ( ContactsOps . View view , boolean firstTimeIn ) { mContactsView = new WeakReference < > ( view ) ; if ( firstTimeIn ) { initializeAccount ( ) ; mCursorAdapter = new SimpleCursorAdapter ( view . getApplicationContext ( ) , R . layout . list_layout , null , sColumnsToDisplay , sColumnResIds , NUM_ ) ; } }
public static final int randomUnsetBit ( Random r , BitSet bits , final int max ) { if ( bits . cardinality ( ) == max + NUM_ ) { return - NUM_ ; } final int candidate = TestUtil . nextInt ( r , NUM_ , max ) ; if ( bits . get ( candidate ) ) { final int lo = bits . previousClearBit ( candidate ) ; final int hi = bits . nextClearBit ( candidate ) ; if ( lo < NUM_ && max < hi ) { fail ( STR_ + bits . cardinality ( ) + STR_ + bits . size ( ) ) ; } else if ( lo < NUM_ ) { return hi ; } else if ( max < hi ) { return lo ; } return ( ( candidate - lo ) < ( hi - candidate ) ) ? lo : hi ; } return candidate ; }
@ Override public void flush ( ) throws IOException { synchronized ( lock ) { out . flush ( ) ; } }
public double std ( ) { if ( min == max || num == NUM_ ) { return NUM_ ; } double m = mean ( ) ; return Math . sqrt ( sigmax2 / num - m . m ) ; }
public boolean containsInstruction ( InstructionHandle handle ) { Iterator < InstructionHandle > i = instructionIterator ( ) ; while ( i . hasNext ( ) ) { if ( i . next ( ) == handle ) { return BOOL_ ; } } return BOOL_ ; }
public static String sendFedexRequest ( String xmlString , Delegator delegator , String shipmentGatewayConfigId , String resource , Locale locale ) throws FedexConnectException { String url = getShipmentGatewayConfigValue ( delegator , shipmentGatewayConfigId , STR_ , resource , STR_ ) ; if ( UtilValidate . isEmpty ( url ) ) { throw new FedexConnectException ( UtilProperties . getMessage ( resourceError , STR_ , locale ) ) ; } if ( ! xmlString . matches ( STR_ ) ) { throw new FedexConnectException ( UtilProperties . getMessage ( resourceError , STR_ , locale ) ) ; } url = url . trim ( ) ; String timeOutStr = getShipmentGatewayConfigValue ( delegator , shipmentGatewayConfigId , STR_ , resource , STR_ , STR_ ) ; int timeout = NUM_ ; try { timeout = Integer . parseInt ( timeOutStr ) ; } catch ( NumberFormatException e ) { Debug . logError ( e , STR_ + timeOutStr + STR_ + timeout ) ; } if ( Debug . verboseOn ( ) ) { Debug . logVerbose ( STR_ + url , module ) ; Debug . logVerbose ( STR_ + xmlString , module ) ; } HttpClient http = new HttpClient ( url ) ; http . setTimeout ( timeout . NUM_ ) ; String response = null ; try { response = http . post ( xmlString ) ; } catch ( HttpClientException e ) { Debug . logError ( e , STR_ , module ) ; throw new FedexConnectException ( UtilProperties . getMessage ( resourceError , STR_ , UtilMisc . toMap ( STR_ , e . toString ( ) ) , locale ) ) ; } if ( response == null ) { throw new FedexConnectException ( UtilProperties . getMessage ( resourceError , STR_ , locale ) ) ; } if ( Debug . verboseOn ( ) ) { Debug . logVerbose ( STR_ + response , module ) ; } return response ; }
public String trimToSize ( String str , int maxStringLength ) { if ( str == null ) return null ; if ( str . length ( ) > maxStringLength ) { StringBuilder sb = new StringBuilder ( str ) ; sb . setLength ( maxStringLength ) ; str = sb . toString ( ) ; } return str ; }
public Subject login ( String username , String password ) { if ( StringUtils . isBlank ( username ) || StringUtils . isBlank ( password ) ) return null ; Properties credentials = new Properties ( ) ; credentials . setProperty ( ResourceConstants . USER_NAME , username ) ; credentials . setProperty ( ResourceConstants . PASSWORD , password ) ; return login ( credentials ) ; }
@ Timed @ ExceptionMetered @ Path ( STR_ ) @ GET @ Produces ( APPLICATION_JSON ) public Iterable < SanitizedSecret > secretListingV2 ( @ Auth AutomationClient automationClient , @ QueryParam ( STR_ ) Integer idx , @ QueryParam ( STR_ ) Integer num , @ DefaultValue ( STR_ ) @ QueryParam ( STR_ ) boolean newestFirst ) { if ( idx != null && num != null ) { if ( idx < NUM_ || num < NUM_ ) { throw new BadRequestException ( STR_ ) ; } return secretController . getSecretsBatched ( idx , num , newestFirst ) ; } return secretController . getSanitizedSecrets ( null , null ) ; }
public void deselect ( Iterable < Integer > positions ) { Iterator < Integer > entries = positions . iterator ( ) ; while ( entries . hasNext ( ) ) { deselect ( entries . next ( ) , entries ) ; } }
public static String map2OID ( String algName ) { checkCacheVersion ( ) ; String result = alg2OidMap . get ( algName . toUpperCase ( Locale . US ) ) ; if ( result != null ) { return result ; } AlgNameMapperSource s = source ; if ( s != null ) { return s . mapNameToOid ( algName ) ; } return null ; }
public PushHistory ( int maxHistoryLength , JSONObject json ) { this . maxHistoryLength = maxHistoryLength ; this . entries = new PriorityQueue < Entry > ( maxHistoryLength + NUM_ ) ; this . pushIds = new HashSet < String > ( maxHistoryLength + NUM_ ) ; this . lastTime = null ; if ( json != null ) { JSONObject jsonHistory = json . optJSONObject ( STR_ ) ; if ( jsonHistory != null ) { Iterator < String > it = jsonHistory . keys ( ) ; while ( it . hasNext ( ) ) { String pushId = ( String ) it . next ( ) ; String timestamp = jsonHistory . optString ( pushId , null ) ; if ( pushId != null && timestamp != null ) { tryInsertPush ( pushId , timestamp ) ; } } } setLastReceivedTimestamp ( json . optString ( STR_ , null ) ) ; } }
private void endList ( boolean orderedList ) { if ( ! mParagraphStyles . isEmpty ( ) ) { AccumulatedParagraphStyle style = mParagraphStyles . peek ( ) ; ParagraphType type = style . getType ( ) ; if ( ( orderedList && ( type . isNumbering ( ) || type == ParagraphType . INDENTATION_OL ) ) || ( ! orderedList && ( type . isBullet ( ) || type == ParagraphType . INDENTATION_UL ) ) ) { int indent = style . getRelativeIndent ( ) ; if ( indent > NUM_ ) { style . setRelativeIndent ( indent - NUM_ ) ; style . setAbsoluteIndent ( style . getAbsoluteIndent ( ) - NUM_ ) ; } else { mParagraphStyles . pop ( ) ; } } else { mParagraphStyles . pop ( ) ; endList ( orderedList ) ; } } }
private boolean processKeyUp ( int keyCode ) { if ( keyCode == KeyEvent . KEYCODE_ESCAPE || keyCode == KeyEvent . KEYCODE_BACK ) { dismiss ( ) ; return BOOL_ ; } else if ( keyCode == KeyEvent . KEYCODE_TAB ) { if ( mInKbMode ) { if ( isTypedTimeFullyLegal ( ) ) { finishKbMode ( BOOL_ ) ; } return BOOL_ ; } } else if ( keyCode == KeyEvent . KEYCODE_ENTER ) { if ( mInKbMode ) { if ( ! isTypedTimeFullyLegal ( ) ) { return BOOL_ ; } finishKbMode ( BOOL_ ) ; } if ( mCallback != null ) { mCallback . onTimeSet ( mTimePicker , mTimePicker . getHours ( ) , mTimePicker . getMinutes ( ) ) ; } dismiss ( ) ; return BOOL_ ; } else if ( keyCode == KeyEvent . KEYCODE_DEL ) { if ( mInKbMode ) { if ( ! mTypedTimes . isEmpty ( ) ) { int deleted = deleteLastTypedKey ( ) ; String deletedKeyStr ; if ( deleted == getAmOrPmKeyCode ( AM ) ) { deletedKeyStr = mAmText ; } else if ( deleted == getAmOrPmKeyCode ( PM ) ) { deletedKeyStr = mPmText ; } else { deletedKeyStr = String . format ( STR_ , getValFromKeyCode ( deleted ) ) ; } Utils . tryAccessibilityAnnounce ( mTimePicker , String . format ( mDeletedKeyFormat , deletedKeyStr ) ) ; updateDisplay ( BOOL_ ) ; } } } else if ( keyCode == KeyEvent . KEYCODE_0 || keyCode == KeyEvent . KEYCODE_1 || keyCode == KeyEvent . KEYCODE_2 || keyCode == KeyEvent . KEYCODE_3 || keyCode == KeyEvent . KEYCODE_4 || keyCode == KeyEvent . KEYCODE_5 || keyCode == KeyEvent . KEYCODE_6 || keyCode == KeyEvent . KEYCODE_7 || keyCode == KeyEvent . KEYCODE_8 || keyCode == KeyEvent . KEYCODE_9 || ( ! mIs24HourMode && ( keyCode == getAmOrPmKeyCode ( AM ) || keyCode == getAmOrPmKeyCode ( PM ) ) ) ) { if ( ! mInKbMode ) { if ( mTimePicker == null ) { Log . e ( TAG , STR_ ) ; return BOOL_ ; } mTypedTimes . clear ( ) ; tryStartingKbMode ( keyCode ) ; return BOOL_ ; } if ( addKeyIfLegal ( keyCode ) ) { updateDisplay ( BOOL_ ) ; } return BOOL_ ; } return BOOL_ ; }
public boolean isNaturalJoinColumn ( Column c ) { return naturalJoinColumns != null && naturalJoinColumns . contains ( c ) ; }
public int read ( byte [ ] b , int off , int len ) throws IOException { ensureOpen ( ) ; if ( b == null ) { throw new NullPointerException ( STR_ ) ; } else if ( off < NUM_ || len < NUM_ || len > b . length - off ) { throw new IndexOutOfBoundsException ( ) ; } else if ( len == NUM_ ) { return NUM_ ; } int cnt = NUM_ ; while ( len > NUM_ && ! def . finished ( ) ) { int n ; if ( def . needsInput ( ) ) { n = in . read ( buf , NUM_ , buf . length ) ; if ( n < NUM_ ) { def . finish ( ) ; } else if ( n > NUM_ ) { def . setInput ( buf , NUM_ , n ) ; } } n = def . deflate ( b , off , len ) ; cnt += n ; off += n ; len -= n ; } if ( cnt == NUM_ && def . finished ( ) ) { reachEOF = BOOL_ ; cnt = - NUM_ ; } return cnt ; }
@ Override public void passivate ( ) { cleanupUserTransaction ( ) ; super . passivate ( ) ; }
public Builder delay ( long duration , TimeUnit timeUnit ) { this . delay = timeUnit . toSeconds ( duration ) ; return this ; }
private boolean contains ( int part ) { return parts . contains ( part ) ; }
int keyCount ( Class clazz ) { Map map = get ( clazz ) ; int count = map . size ( ) ; if ( map . containsKey ( CONSTRUCTORS_KEY ) ) count -- ; if ( map . containsKey ( GENERIC_GET_KEY ) ) count -- ; if ( map . containsKey ( ARGTYPES_KEY ) ) count -- ; return count ; }
public Mp4StcoBox ( Mp4BoxHeader header , ByteBuffer originalDataBuffer , int adjustment ) { this . header = header ; this . dataBuffer = originalDataBuffer . slice ( ) ; dataBuffer . position ( dataBuffer . position ( ) + VERSION_FLAG_LENGTH + OTHER_FLAG_LENGTH ) ; this . noOfOffSets = Utils . getIntBE ( dataBuffer , dataBuffer . position ( ) , ( dataBuffer . position ( ) + NO_OF_OFFSETS_LENGTH - NUM_ ) ) ; dataBuffer . position ( dataBuffer . position ( ) + NO_OF_OFFSETS_LENGTH ) ; for ( int i = NUM_ ; i < noOfOffSets ; i ++ ) { int offset = Utils . getIntBE ( dataBuffer , dataBuffer . position ( ) , ( dataBuffer . position ( ) + NO_OF_OFFSETS_LENGTH - NUM_ ) ) ; offset = offset + adjustment ; dataBuffer . put ( Utils . getSizeBEInt32 ( offset ) ) ; } }
public static void createOPUSDirectories ( Config config ) { log . info ( STR_ ) ; UrbanSimParameterConfigModuleV3 module = M4UConfigUtils . getUrbanSimParameterConfigAndPossiblyConvert ( config ) ; File tempFile = new File ( module . getOpusHome ( ) ) ; tempFile . mkdirs ( ) ; tempFile = new File ( module . getMATSim4Opus ( ) ) ; tempFile . mkdirs ( ) ; tempFile = new File ( module . getMATSim4OpusOutput ( ) ) ; tempFile . mkdirs ( ) ; tempFile = new File ( module . getMATSim4OpusTemp ( ) ) ; tempFile . mkdirs ( ) ; tempFile = new File ( module . getMATSim4OpusConfig ( ) ) ; tempFile . mkdirs ( ) ; log . info ( STR_ ) ; }
public static String lcfirst ( String input ) { return withFirst ( input , null ) ; }
void compress ( int page , byte [ ] old ) { byte [ ] [ ] array = data ; if ( page >= array . length ) { return ; } byte [ ] d = array [ page ] ; if ( d != old ) { return ; } synchronized ( LZF ) { int len = LZF . compress ( d , BLOCK_SIZE , BUFFER , NUM_ ) ; if ( len <= BLOCK_SIZE ) { d = new byte [ len ] ; System . arraycopy ( BUFFER , NUM_ , d , NUM_ , len ) ; byte [ ] o = array [ page ] ; if ( o != old ) { return ; } array [ page ] = d ; } } }
public HadoopProcessDescriptor localProcessDescriptor ( ) { return locProcDesc ; }
private Pair < String , Boolean > describeRain ( Calendar calendar , int temperatureMod ) { int month = calendar . get ( Calendar . MONTH ) ; month = NUM_ . Math . abs ( month - NUM_ ) ; int hour = calendar . get ( Calendar . HOUR_OF_DAY ) ; hour = Math . abs ( ( hour + NUM_ ) % NUM_ - NUM_ ) / NUM_ ; int temp = temperature . getValue ( ) - hour - month + ( temperatureMod . NUM_ ) ; LOGGER . debug ( STR_ + temp + STR_ + temperatureMod ) ; if ( temp <= - NUM_ ) { return new Pair < String , Boolean > ( STR_ , Boolean . FALSE ) ; } return new Pair < String , Boolean > ( STR_ , temp >= - NUM_ && thunder . getDescription ( NUM_ ) != null ) ; }
@ VisibleForTesting @ CalledByNativeUnchecked ( STR_ ) public void addChild ( BookmarkNode child ) { mChildren . add ( child ) ; }
public void testGetMinCRL ( ) { X509CRLSelector selector = new X509CRLSelector ( ) ; assertNull ( STR_ , selector . getMinCRL ( ) ) ; BigInteger minCRL = new BigInteger ( STR_ ) ; selector . setMinCRLNumber ( minCRL ) ; assertTrue ( STR_ , minCRL . equals ( selector . getMinCRL ( ) ) ) ; }
public void testWhenComplete_exceptionalCompletion ( ) { for ( ExecutionMode m : ExecutionMode . values ( ) ) for ( boolean createIncomplete : new boolean [ ] { BOOL_ , BOOL_ } ) { final AtomicInteger a = new AtomicInteger ( NUM_ ) ; final CFException ex = new CFException ( ) ; final CompletableFuture < Integer > f = new CompletableFuture < > ( ) ; if ( ! createIncomplete ) f . completeExceptionally ( ex ) ; final CompletableFuture < Integer > g = m . whenComplete ( f , null ) ; if ( createIncomplete ) f . completeExceptionally ( ex ) ; checkCompletedWithWrappedException ( g , ex ) ; checkCompletedExceptionally ( f , ex ) ; assertEquals ( NUM_ , a . get ( ) ) ; } }
@ Override public String read ( String pattern ) { return read ( Pattern . compile ( pattern , Pattern . DOTALL | Pattern . MULTILINE ) ) ; }
protected void addSubKeysAndAggregator ( Set < String > values , Set < String > keysOfCompositeAggregator , Set < String > subKeys , String aggregatorName , Map < Set < String > , Integer > keysToCombinationId ) { if ( keysOfCompositeAggregator == null || subKeys == null || keysOfCompositeAggregator . isEmpty ( ) || subKeys . isEmpty ( ) ) { throw new IllegalArgumentException ( STR_ ) ; } Set < String > allKeys = Sets . newHashSet ( ) ; allKeys . addAll ( keysOfCompositeAggregator ) ; allKeys . addAll ( subKeys ) ; if ( allKeys . size ( ) != keysOfCompositeAggregator . size ( ) + subKeys . size ( ) ) { throw new IllegalArgumentException ( STR_ + keysOfCompositeAggregator . toString ( ) + STR_ + subKeys ) ; } Integer combinationId = keysToCombinationId . get ( allKeys ) ; if ( combinationId == null ) { if ( dimensionsDescriptorIDToKeys . add ( new Fields ( allKeys ) ) ) { combinationId = dimensionsDescriptorIDToKeys . size ( ) - NUM_ ; } else { throw new RuntimeException ( STR_ + allKeys + STR_ ) ; } keysToCombinationId . put ( allKeys , combinationId ) ; addValueToAggregatorToCombination ( values , allKeys , aggregatorName ) ; } else { Set < String > incrementalAggregatorNames ; boolean isOTFAggregator = BOOL_ ; if ( ! isIncrementalAggregator ( aggregatorName ) ) { incrementalAggregatorNames = getOTFDependedIncrementalAggregatorNames ( aggregatorName ) ; isOTFAggregator = BOOL_ ; } else { incrementalAggregatorNames = Sets . newHashSet ( ) ; incrementalAggregatorNames . add ( aggregatorName ) ; } Map < String , Set < String > > newValueToIncrementalAggregators = Maps . newHashMap ( ) ; Map < String , Set < String > > newValueToOTFAggregators = Maps . newHashMap ( ) ; for ( String value : values ) { newValueToIncrementalAggregators . put ( value , incrementalAggregatorNames ) ; if ( isOTFAggregator ) { newValueToOTFAggregators . put ( value , Sets . newHashSet ( aggregatorName ) ) ; } } int ddid = combinationId . customTimeBucketsCombination . size ( ) ; for ( int index = NUM_ ; index < customTimeBucketsCombination . size ( ) ; ++ index , ++ ddid ) { mergeMaps ( dimensionsDescriptorIDToValueToAggregator . get ( ddid ) , newValueToIncrementalAggregators ) ; mergeMaps ( dimensionsDescriptorIDToValueToOTFAggregator . get ( ddid ) , newValueToOTFAggregators ) ; } } }
protected boolean _findCanonicalLabelling ( boolean tmpPreviouslyEqualToMin ) { boolean foundNewMinimum = BOOL_ ; IntArrayList underlyingVertexPosThatExtendTmp = getUnderlyingVertexPosThatExtendTmp ( ) ; IntCursor underlyingVertexPosThatExtendTmpCursor = underlyingVertexPosThatExtendTmp . cursor ( ) ; while ( underlyingVertexPosThatExtendTmpCursor . moveNext ( ) ) { int underlyingVertexPosToAdd = underlyingVertexPosThatExtendTmpCursor . elem ( ) ; int newTmpVertexPos = addTmpVertex ( underlyingVertexPosToAdd ) ; int newTmpVertexLabel = underlyingPosToLabel . getUnchecked ( underlyingVertexPosToAdd ) ; IntSet neighbourUnderlyingPositions = underlyingAdjacencyList . get ( underlyingVertexPosToAdd ) ; IntCursor neighbourUnderlyingPositionsCursor = neighbourUnderlyingPositions . cursor ( ) ; PatternEdgeArrayList edgesToAdd = createPatternEdgeArrayList ( ) ; while ( neighbourUnderlyingPositionsCursor . moveNext ( ) ) { int neighbourUnderlyingPos = neighbourUnderlyingPositionsCursor . elem ( ) ; int neighbourTmpPos = tmpLabelling . get ( neighbourUnderlyingPos ) ; if ( neighbourTmpPos == - NUM_ ) { continue ; } addCandidatePatternEdges ( edgesToAdd , neighbourUnderlyingPos , neighbourTmpPos , underlyingVertexPosToAdd , newTmpVertexPos ) ; } if ( edgesToAdd . size ( ) > NUM_ || newTmpVertexPos == NUM_ ) { edgesToAdd . sort ( ) ; boolean promisingTmpPattern = BOOL_ ; boolean equalToMinTmpPattern = tmpPreviouslyEqualToMin ; if ( foundMinimum ) { int comparisonResult ; if ( newTmpVertexPos > NUM_ ) { PatternEdgeArrayList minEquivalentEdges = minEdges . get ( newTmpVertexPos ) ; comparisonResult = edgesToAdd . compareTo ( minEquivalentEdges ) ; } else { int minFirstUnderlyingVertexPos = minInverseLabelling . get ( newTmpVertexPos ) ; int minFirstUnderylingVertexLabel = underlyingPosToLabel . getUnchecked ( minFirstUnderlyingVertexPos ) ; comparisonResult = Integer . compare ( newTmpVertexLabel , minFirstUnderylingVertexLabel ) ; } equalToMinTmpPattern = equalToMinTmpPattern && comparisonResult == NUM_ ; if ( tmpPreviouslyEqualToMin && ! equalToMinTmpPattern ) { if ( comparisonResult > NUM_ ) { promisingTmpPattern = BOOL_ ; } } } if ( promisingTmpPattern ) { addTmpEdges ( edgesToAdd ) ; if ( tmpLabelling . size ( ) == getNumberOfVertices ( ) ) { if ( ! equalToMinTmpPattern || ! foundMinimum ) { copyTmpToMin ( ) ; foundNewMinimum = BOOL_ ; vertexPositionEquivalences . clear ( ) ; } IntIntCursor tmpLabellingCursor = tmpLabelling . cursor ( ) ; while ( tmpLabellingCursor . moveNext ( ) ) { int underlyingPos = tmpLabellingCursor . key ( ) ; int tmpEquivalentPos = tmpLabellingCursor . value ( ) ; int underlyingPosAccordingToMin = minInverseLabelling . get ( tmpEquivalentPos ) ; vertexPositionEquivalences . addEquivalence ( underlyingPos , underlyingPosAccordingToMin ) ; } } else { boolean foundNewMinimumInChild = _findCanonicalLabelling ( equalToMinTmpPattern ) ; if ( foundNewMinimumInChild ) { tmpPreviouslyEqualToMin = BOOL_ ; foundNewMinimum = BOOL_ ; } } removeLastTmpEdges ( ) ; } else { edgesToAdd . reclaim ( ) ; } } removeLastTmpVertex ( ) ; } underlyingVertexPosThatExtendTmp . reclaim ( ) ; return foundNewMinimum ; }
private String constructISCSINamesQuery ( String systemId , List < HostStorageDomain > hsdList , String model ) { Map < String , Object > attributeMap = new HashMap < String , Object > ( ) ; StorageArray array = new StorageArray ( systemId ) ; Add addOp = new Add ( HDSConstants . ISCSI_NAME_FOR_HSD_TARGET ) ; attributeMap . put ( HDSConstants . STORAGEARRAY , array ) ; attributeMap . put ( HDSConstants . ADD , addOp ) ; attributeMap . put ( HDSConstants . MODEL , model ) ; attributeMap . put ( HDSConstants . HOSTGROUP_LIST , hsdList ) ; String addWWNQuery = InputXMLGenerationClient . getInputXMLString ( HDSConstants . BATCH_ADD_WWN_TO_HSD_OP , attributeMap , HDSConstants . HITACHI_INPUT_XML_CONTEXT_FILE , HDSConstants . HITACHI_SMOOKS_CONFIG_FILE ) ; return addWWNQuery ; }
public static void tryClaim ( Publication publication , BufferFiller fillBuffer , int length , int timeout , TimeUnit timeUnit ) { if ( publication . isClosed ( ) ) { throw new NotConnectedException ( ) ; } final BufferClaim bufferClaim = bufferClaims . get ( ) ; final long start = System . nanoTime ( ) ; do { final long current = System . nanoTime ( ) ; if ( ( current - start ) > timeUnit . toNanos ( timeout ) ) { throw new TimedOutException ( ) ; } final long offer = publication . tryClaim ( length , bufferClaim ) ; if ( offer >= NUM_ ) { try { final MutableDirectBuffer buffer = bufferClaim . buffer ( ) ; final int offset = bufferClaim . offset ( ) ; fillBuffer . fill ( offset , buffer ) ; break ; } finally { bufferClaim . commit ( ) ; } } else if ( Publication . NOT_CONNECTED == offer ) { throw new NotConnectedException ( ) ; } } while ( BOOL_ ) ; }
Builder addLenient ( String line ) { int index = line . indexOf ( STR_ , NUM_ ) ; if ( index != - NUM_ ) { return addLenient ( line . substring ( NUM_ , index ) , line . substring ( index + NUM_ ) ) ; } else if ( line . startsWith ( STR_ ) ) { return addLenient ( STR_ , line . substring ( NUM_ ) ) ; } else { return addLenient ( STR_ , line ) ; } }
protected boolean tableExists ( Table t ) throws SQLException { String sql = STR_ + ( t . isTemporary ( ) ? STR_ : ( STR_ + t . getSchema ( ) + STR_ ) ) + STR_ + ( t . isTemporary ( ) ? ( t . getSchema ( ) + STR_ ) : STR_ ) + t . getName ( ) + STR_ ; Statement stmt = dbConn . createStatement ( ) ; try { ResultSet rs = stmt . executeQuery ( sql ) ; return rs . next ( ) ; } finally { if ( stmt != null ) { try { stmt . close ( ) ; } catch ( SQLException e ) { } } } }
private void readUnlockedThread ( ) { final long thisThreadId = Thread . currentThread ( ) . getId ( ) ; final Integer entry = threadLockMap . get ( thisThreadId ) ; assert entry != null ; if ( entry . intValue ( ) == NUM_ ) { threadLockMap . remove ( thisThreadId ) ; } else { threadLockMap . put ( thisThreadId , entry . intValue ( ) - NUM_ ) ; } }
boolean isSingleWindowStandardOffset ( ) { return windowEnd . equals ( LocalDateTime . MAX ) && timeDefinition == TimeDefinition . WALL && fixedSavingAmountSecs == null && lastRuleList . isEmpty ( ) && ruleList . isEmpty ( ) ; }
public void add ( Character ok ) { add ( ok . charValue ( ) ) ; }
private Workflow . Method deleteVolumesMethod ( URI systemURI , List < URI > volumeURIs ) { return new Workflow . Method ( STR_ , systemURI , volumeURIs ) ; }
public boolean remove ( AccessibleState state ) { if ( states == null ) { return BOOL_ ; } else { return states . removeElement ( state ) ; } }
public void testRadix10Pos ( ) { String value = STR_ ; int radix = NUM_ ; BigInteger aNumber = new BigInteger ( value , radix ) ; String result = aNumber . toString ( radix ) ; assertTrue ( result . equals ( value ) ) ; }
public void outputExampleXML ( PrintWriter writer , AttributeRule rule ) { writer . print ( STR_ + rule . getName ( ) + STR_ ) ; if ( rule . hasExample ( ) ) { writer . print ( rule . getExample ( ) ) ; } else { outputAttributeValue ( writer , rule . getAttributeClass ( ) ) ; } writer . print ( STR_ ) ; }
private void beforeValue ( ) throws JSONException { if ( stack . isEmpty ( ) ) { return ; } Scope context = peek ( ) ; if ( context == Scope . EMPTY_ARRAY ) { replaceTop ( Scope . NONEMPTY_ARRAY ) ; newline ( ) ; } else if ( context == Scope . NONEMPTY_ARRAY ) { out . append ( STR_ ) ; newline ( ) ; } else if ( context == Scope . DANGLING_KEY ) { out . append ( indent == null ? STR_ : STR_ ) ; replaceTop ( Scope . NONEMPTY_OBJECT ) ; } else if ( context != Scope . NULL ) { throw new JSONException ( STR_ ) ; } }
public boolean isUploadInProgress ( ) { return mUploadStarted . get ( ) ; }
private int indexOf ( int tabId ) { return mTabIdList . indexOf ( tabId ) ; }
public NdefMessage ( NdefRecord record , NdefRecord ... records ) { if ( record == null ) throw new NullPointerException ( STR_ ) ; for ( NdefRecord r : records ) { if ( r == null ) { throw new NullPointerException ( STR_ ) ; } } mRecords = new NdefRecord [ NUM_ + records . length ] ; mRecords [ NUM_ ] = record ; System . arraycopy ( records , NUM_ , mRecords , NUM_ , records . length ) ; }
private int findCheckpointPosition ( int [ ] cids ) { if ( checkpointPeriod < NUM_ ) { return - NUM_ ; } if ( cids . length == NUM_ ) { throw new IllegalArgumentException ( ) ; } int firstCID = cids [ NUM_ ] ; if ( ( firstCID + NUM_ ) % checkpointPeriod == NUM_ ) { return cidPosition ( cids , firstCID ) ; } else { int nextCkpIndex = ( ( ( firstCID / checkpointPeriod ) + NUM_ ) . checkpointPeriod ) - NUM_ ; if ( nextCkpIndex <= cids [ cids . length - NUM_ ] ) { return cidPosition ( cids , nextCkpIndex ) ; } } return - NUM_ ; }
private boolean readNextLine ( ) throws IOException { if ( headerLines . hasMoreElements ( ) ) { try { pos = NUM_ ; String line = ( headerLines . nextElement ( ) + LINE_SEPERATOR ) ; if ( ! headerLines . hasMoreElements ( ) ) { line += LINE_SEPERATOR ; } currLine = line . getBytes ( STR_ ) ; return BOOL_ ; } catch ( UnsupportedEncodingException e ) { throw new IOException ( STR_ ) ; } } else { return BOOL_ ; } }
private boolean pause ( ) { try { U . await ( pauseLatch , REMAP_PAUSE , MILLISECONDS ) ; return BOOL_ ; } catch ( IgniteInterruptedCheckedException e ) { onDone ( e ) ; return BOOL_ ; } }
public static InputStream toInputStream ( final CharSequence input ) { return IOUtils . toInputStream ( input , Charset . defaultCharset ( ) ) ; }
private static ITLRestRep createInitiatorTargetRefRep ( ExportGroup exportGroup , BlockObject blockObject , String hlu , Initiator initiator , StoragePort port , FCZoneReference fcZoneReference ) { ITLRestRep rep = new ITLRestRep ( ) ; rep . setHlu ( Integer . parseInt ( hlu ) ) ; ITLRestRep . ITLBlockObjectRestRep blockObjectRestRep = new ITLRestRep . ITLBlockObjectRestRep ( ) ; blockObjectRestRep . setId ( blockObject . getId ( ) ) ; blockObjectRestRep . setLink ( new RestLinkRep ( STR_ , RestLinkFactory . newLink ( blockObject ) ) ) ; blockObjectRestRep . setWwn ( getBlockObjectFormattedWWN ( blockObject ) ) ; rep . setBlockObject ( blockObjectRestRep ) ; ITLRestRep . ITLInitiatorRestRep initiatorRestRep = new ITLRestRep . ITLInitiatorRestRep ( ) ; initiatorRestRep . setId ( initiator . getId ( ) ) ; initiatorRestRep . setLink ( new RestLinkRep ( STR_ , RestLinkFactory . newLink ( initiator ) ) ) ; initiatorRestRep . setPort ( initiator . getInitiatorPort ( ) ) ; rep . setInitiator ( initiatorRestRep ) ; ITLRestRep . ITLStoragePortRestRep storagePortRestRep = new ITLRestRep . ITLStoragePortRestRep ( ) ; if ( port != null ) { storagePortRestRep . setId ( port . getId ( ) ) ; storagePortRestRep . setLink ( new RestLinkRep ( STR_ , RestLinkFactory . newLink ( port ) ) ) ; storagePortRestRep . setPort ( port . getPortNetworkId ( ) ) ; if ( port . getIpAddress ( ) != null ) { storagePortRestRep . setIpAddress ( port . getIpAddress ( ) ) ; storagePortRestRep . setTcpPort ( String . valueOf ( port . getTcpPortNumber ( ) ) ) ; } } rep . setStoragePort ( storagePortRestRep ) ; rep . setExport ( toNamedRelatedResource ( exportGroup , exportGroup . getLabel ( ) ) ) ; if ( fcZoneReference != null ) { rep . setSanZoneName ( fcZoneReference . getZoneName ( ) ) ; } return rep ; }
public void write ( final int c ) throws IOException { if ( m_writer != null ) m_writer . write ( c ) ; if ( count >= buf_length ) flushBuffer ( ) ; if ( c < x80 ) { buf [ count ++ ] = ( byte ) ( c ) ; } else if ( c < x800 ) { buf [ count ++ ] = ( byte ) ( xc0 + ( c > > NUM_ ) ) ; buf [ count ++ ] = ( byte ) ( x80 + ( c & x3f ) ) ; } else { buf [ count ++ ] = ( byte ) ( xe0 + ( c > > NUM_ ) ) ; buf [ count ++ ] = ( byte ) ( x80 + ( ( c > > NUM_ ) & x3f ) ) ; buf [ count ++ ] = ( byte ) ( x80 + ( c & x3f ) ) ; } }
private static List < COperandTree > convert ( final INaviModule module , final List < Operand > operands ) { final List < COperandTree > convertedOperands = new ArrayList < COperandTree > ( ) ; for ( final Operand operand : operands ) { convertedOperands . add ( module . createOperand ( convert ( module , operand . getRootNode ( ) , null ) ) ) ; } return convertedOperands ; }
public static String xmlEscape ( String s ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = NUM_ ; i < s . length ( ) ; i ++ ) { char ch = s . charAt ( i ) ; switch ( ch ) { case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : break ; default : sb . append ( ch ) ; break ; } } return sb . toString ( ) ; }
public boolean writeHeader ( OutputStream os ) { try { writeInt ( os , CACHE_MAGIC ) ; writeString ( os , key ) ; writeString ( os , etag == null ? STR_ : etag ) ; writeLong ( os , serverDate ) ; writeLong ( os , ttl ) ; writeLong ( os , softTtl ) ; writeStringStringMap ( responseHeaders , os ) ; os . flush ( ) ; return BOOL_ ; } catch ( IOException e ) { VolleyLog . d ( STR_ , e . toString ( ) ) ; return BOOL_ ; } }
@ VisibleForTesting public Bitmap ensureNormalizedIcon ( Bitmap icon , String origin ) { if ( icon == null || icon . getWidth ( ) == NUM_ ) { if ( mIconGenerator == null ) { int cornerRadiusPx = Math . min ( mLargeIconWidthPx , mLargeIconHeightPx ) / NUM_ ; mIconGenerator = new RoundedIconGenerator ( mLargeIconWidthPx , mLargeIconHeightPx , cornerRadiusPx , NOTIFICATION_ICON_BG_COLOR , NOTIFICATION_TEXT_SIZE_DP . mDensity ) ; } return mIconGenerator . generateIconForUrl ( origin , BOOL_ ) ; } if ( icon . getWidth ( ) > mLargeIconWidthPx || icon . getHeight ( ) > mLargeIconHeightPx ) { return icon . createScaledBitmap ( icon , mLargeIconWidthPx , mLargeIconHeightPx , BOOL_ ) ; } return icon ; }
protected boolean [ ] canHandleZeroTraining ( boolean nominalPredictor , boolean numericPredictor , boolean stringPredictor , boolean datePredictor , boolean relationalPredictor , boolean multiInstance , int classType ) { print ( STR_ ) ; printAttributeSummary ( nominalPredictor , numericPredictor , stringPredictor , datePredictor , relationalPredictor , multiInstance , classType ) ; print ( STR_ ) ; ArrayList < String > accepts = new ArrayList < String > ( ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; int numTrain = NUM_ , numClasses = NUM_ , missingLevel = NUM_ ; boolean predictorMissing = BOOL_ , classMissing = BOOL_ ; return runBasicTest ( nominalPredictor , numericPredictor , stringPredictor , datePredictor , relationalPredictor , multiInstance , classType , missingLevel , predictorMissing , classMissing , numTrain , numClasses , accepts ) ; }
public SQLQuery ( String typeName , String sqlExpression ) { this ( sqlExpression , typeName , null , DEFAULT_QUERY_RESULT_TYPE , null ) ; }
private static void checkOffset ( String value , int offset , char expected ) throws IndexOutOfBoundsException { char found = value . charAt ( offset ) ; if ( found != expected ) { throw new IndexOutOfBoundsException ( STR_ + expected + STR_ + found + STR_ ) ; } }
public boolean isInNet ( String host , String pattern , String mask ) { host = dnsResolve ( host ) ; if ( host == null || host . length ( ) == NUM_ ) { return BOOL_ ; } long lhost = parseIpAddressToLong ( host ) ; long lpattern = parseIpAddressToLong ( pattern ) ; long lmask = parseIpAddressToLong ( mask ) ; return ( lhost & lmask ) == lpattern ; }
protected static Pair < String , String > rrxRegister ( final long offset , final ITranslationEnvironment environment , final List < ReilInstruction > instructions , final String registerNodeValue ) { final String shifterOperand = environment . getNextVariableString ( ) ; final String shifterCarryOut = environment . getNextVariableString ( ) ; final String tmpVar1 = environment . getNextVariableString ( ) ; final String tmpVar2 = environment . getNextVariableString ( ) ; final String tmpVar3 = environment . getNextVariableString ( ) ; long baseOffset = offset ; instructions . add ( ReilHelpers . createBsh ( baseOffset ++ , byteSize , STR_ , wordSize , thirtyOneSet , dWordSize , tmpVar1 ) ) ; instructions . add ( ReilHelpers . createBsh ( baseOffset ++ , dWordSize , registerNodeValue , byteSize , STR_ + oneSet , dWordSize , tmpVar2 ) ) ; instructions . add ( ReilHelpers . createOr ( baseOffset ++ , dWordSize , tmpVar1 , dWordSize , tmpVar2 , dWordSize , tmpVar3 ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , dWordSize , tmpVar3 , dWordSize , bitMaskAllBitsSet , dWordSize , shifterOperand ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , dWordSize , registerNodeValue , byteSize , String . valueOf ( NUM_ ) , byteSize , shifterCarryOut ) ) ; return new Pair < String , String > ( shifterOperand , shifterCarryOut ) ; }
public int enumerate ( Thread [ ] threads ) { return enumerate ( threads , BOOL_ ) ; }
public void findAndUndo ( Object someObj ) { if ( someObj instanceof LayerHandler ) { logger . fine ( STR_ ) ; if ( getLayerHandler ( ) == ( LayerHandler ) someObj ) { setLayerHandler ( null ) ; } } if ( controls != null && someObj != this ) { controls . findAndUndo ( someObj ) ; } if ( someObj instanceof Layer ) { paneLookUp . remove ( ( Layer ) someObj ) ; } }
public void start ( ) { log . info ( STR_ , this . name , this . frequencyInSecs ) ; stopped = BOOL_ ; Thread drHealthMonitorThread = new Thread ( this ) ; drHealthMonitorThread . setName ( this . name ) ; drHealthMonitorThread . start ( ) ; }
public void connect ( String eventSourceUrl ) throws IOException { LOG . entering ( CLASS_NAME , STR_ , eventSourceUrl ) ; if ( stream != null ) { LOG . warning ( STR_ ) ; throw new IllegalArgumentException ( STR_ ) ; } stream = new SseEventStream ( eventSourceUrl ) ; stream . setListener ( eventStreamListener ) ; stream . connect ( ) ; }
private static String methodName ( @ NonNls final String method ) { return GitSSHHandler . HANDLER_NAME + STR_ + method ; }
public DataRow removeDataRow ( int index ) { return dataList . remove ( index ) ; }
public void put ( Object key , Object value ) { int bucket = ( key . hashCode ( ) & x7FFFFFFF ) % fTableSize ; Entry entry = search ( key , bucket ) ; if ( entry != null ) { entry . value = value ; } else { entry = new Entry ( key , value , fBuckets [ bucket ] ) ; fBuckets [ bucket ] = entry ; fNum ++ ; } }
public void valueChanged ( ListSelectionEvent e ) { if ( _table == null ) { return ; } int row = _table . getSelectedRow ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + row ) ; } if ( row >= NUM_ ) { _addButton . setEnabled ( BOOL_ ) ; _addButton . setToolTipText ( null ) ; if ( _type != null && _type . equals ( STR_ ) ) { makeIconMap ( _pickListModel . getBeanAt ( row ) ) ; clearIconPanel ( ) ; doIconPanel ( ) ; } } else { _addButton . setEnabled ( BOOL_ ) ; _addButton . setToolTipText ( Bundle . getMessage ( STR_ ) ) ; } validate ( ) ; }
private int processPollFds ( ) throws IOException { if ( pollFds . get ( NUM_ ) . revents == POLLIN ) { byte [ ] buffer = new byte [ NUM_ ] ; while ( IoBridge . read ( wakeupIn , buffer , NUM_ , NUM_ ) > NUM_ ) { } } int readyKeyCount = NUM_ ; for ( int i = NUM_ ; i < pollFds . size ( ) ; ++ i ) { StructPollfd pollFd = pollFds . get ( i ) ; if ( pollFd . revents == NUM_ ) { continue ; } if ( pollFd . fd == null ) { break ; } SelectionKeyImpl key = ( SelectionKeyImpl ) pollFd . userData ; pollFd . fd = null ; pollFd . userData = null ; int ops = key . interestOpsNoCheck ( ) ; int selectedOps = NUM_ ; if ( ( pollFd . revents & POLLHUP ) != NUM_ ) { selectedOps |= ops ; } if ( ( pollFd . revents & POLLIN ) != NUM_ ) { selectedOps |= ops & ( OP_ACCEPT | OP_READ ) ; } if ( ( pollFd . revents & POLLOUT ) != NUM_ ) { if ( key . isConnected ( ) ) { selectedOps |= ops & OP_WRITE ; } else { selectedOps |= ops & OP_CONNECT ; } } if ( selectedOps != NUM_ ) { boolean wasSelected = mutableSelectedKeys . contains ( key ) ; if ( wasSelected && key . readyOps ( ) != selectedOps ) { key . setReadyOps ( key . readyOps ( ) | selectedOps ) ; ++ readyKeyCount ; } else if ( ! wasSelected ) { key . setReadyOps ( selectedOps ) ; mutableSelectedKeys . add ( key ) ; ++ readyKeyCount ; } } } return readyKeyCount ; }
private void fitImageToView ( ) { Drawable drawable = getDrawable ( ) ; if ( drawable == null || drawable . getIntrinsicWidth ( ) == NUM_ || drawable . getIntrinsicHeight ( ) == NUM_ ) { return ; } if ( matrix == null || prevMatrix == null ) { return ; } int drawableWidth = drawable . getIntrinsicWidth ( ) ; int drawableHeight = drawable . getIntrinsicHeight ( ) ; float scaleX = ( float ) viewWidth / drawableWidth ; float scaleY = ( float ) viewHeight / drawableHeight ; switch ( mScaleType ) { case CENTER : scaleX = scaleY = NUM_ ; break ; case CENTER_CROP : scaleX = scaleY = Math . max ( scaleX , scaleY ) ; break ; case CENTER_INSIDE : scaleX = scaleY = Math . min ( NUM_ , Math . min ( scaleX , scaleY ) ) ; case FIT_CENTER : scaleX = scaleY = Math . min ( scaleX , scaleY ) ; break ; case FIT_XY : break ; default : throw new UnsupportedOperationException ( STR_ ) ; } float redundantXSpace = viewWidth - ( scaleX . drawableWidth ) ; float redundantYSpace = viewHeight - ( scaleY . drawableHeight ) ; matchViewWidth = viewWidth - redundantXSpace ; matchViewHeight = viewHeight - redundantYSpace ; if ( ! isZoomed ( ) && ! imageRenderedAtLeastOnce ) { matrix . setScale ( scaleX , scaleY ) ; matrix . postTranslate ( redundantXSpace / NUM_ , redundantYSpace / NUM_ ) ; normalizedScale = NUM_ ; } else { if ( prevMatchViewWidth == NUM_ || prevMatchViewHeight == NUM_ ) { savePreviousImageValues ( ) ; } prevMatrix . getValues ( m ) ; m [ Matrix . MSCALE_X ] = matchViewWidth / drawableWidth . normalizedScale ; m [ Matrix . MSCALE_Y ] = matchViewHeight / drawableHeight . normalizedScale ; float transX = m [ Matrix . MTRANS_X ] ; float transY = m [ Matrix . MTRANS_Y ] ; float prevActualWidth = prevMatchViewWidth . normalizedScale ; float actualWidth = getImageWidth ( ) ; translateMatrixAfterRotate ( Matrix . MTRANS_X , transX , prevActualWidth , actualWidth , prevViewWidth , viewWidth , drawableWidth ) ; float prevActualHeight = prevMatchViewHeight . normalizedScale ; float actualHeight = getImageHeight ( ) ; translateMatrixAfterRotate ( Matrix . MTRANS_Y , transY , prevActualHeight , actualHeight , prevViewHeight , viewHeight , drawableHeight ) ; matrix . setValues ( m ) ; } fixTrans ( ) ; setImageMatrix ( matrix ) ; }
public static boolean isIntermediateTable ( String tableName , SQLiteDatabase db ) { if ( ! TextUtils . isEmpty ( tableName ) ) { if ( tableName . matches ( STR_ ) ) { Cursor cursor = null ; try { cursor = db . query ( Const . TableSchema . TABLE_NAME , null , null , null , null , null , null ) ; if ( cursor . moveToFirst ( ) ) { do { String tableNameDB = cursor . getString ( cursor . getColumnIndexOrThrow ( Const . TableSchema . COLUMN_NAME ) ) ; if ( tableName . equalsIgnoreCase ( tableNameDB ) ) { int tableType = cursor . getInt ( cursor . getColumnIndexOrThrow ( Const . TableSchema . COLUMN_TYPE ) ) ; if ( tableType == Const . TableSchema . INTERMEDIATE_JOIN_TABLE ) { return BOOL_ ; } break ; } } while ( cursor . moveToNext ( ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( cursor != null ) { cursor . close ( ) ; } } } } return BOOL_ ; }
public static void initialize ( File helpDir ) throws HelpException { if ( helpDir . isDirectory ( ) && helpDir . exists ( ) ) HelpManager . helpDir = helpDir ; else throw new HelpException ( STR_ + helpDir . getAbsolutePath ( ) , null ) ; }
public RealMatrix create ( ) { RealMatrix rotation = newIdentityMatrix ( ) ; for ( Plane plane : planes ) { double theta = plane . getTheta ( ) ; if ( Double . isNaN ( theta ) ) { continue ; } rotation = rotation . multiply ( newRotationMatrix ( plane . getFirstAxis ( ) , plane . getSecondAxis ( ) , theta ) ) ; } return rotation ; }
public static String toUpperCase ( String str ) { return str . toUpperCase ( Locale . ENGLISH ) ; }
protected static void init ( ) { String notificationfactoryClassName = null ; try { notificationfactoryClassName = System . getProperty ( NOTIFICATION_FACTORY_NAME ) ; } catch ( SecurityException e ) { throw new RuntimeException ( e ) ; } if ( notificationfactoryClassName != null ) { Class < ? > nfc ; try { nfc = Class . forName ( notificationfactoryClassName ) ; factory = ( INotificationManagerFactory ) nfc . newInstance ( ) ; } catch ( ClassNotFoundException | InstantiationException | IllegalAccessException e ) { throw new RuntimeException ( e ) ; } } else { factory = new SyslogNotificationFactory ( ) ; } }
public boolean isDeclaredEntity ( String entityName ) { Entity entity = ( Entity ) fEntities . get ( entityName ) ; return entity != null ; }
private void openContextMenu ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) { selectClicked ( e , BOOL_ ) ; List < RemovedListItem > selectedItems = list . getSelectedValuesList ( ) ; List < StreamInfo > selected = new ArrayList < > ( ) ; for ( RemovedListItem item : selectedItems ) { selected . add ( item . getStreamInfo ( ) ) ; } StreamInfosContextMenu m = new StreamInfosContextMenu ( selected , BOOL_ ) ; for ( ContextMenuListener cml : contextMenuListeners ) { m . addContextMenuListener ( cml ) ; } m . show ( list , e . getX ( ) , e . getY ( ) ) ; } }
private boolean put ( boolean isRoot , Vector names , int len , Object value ) { if ( len == NUM_ ) { if ( isRoot ) { if ( rootValue != null ) return BOOL_ ; rootValue = value ; } else { if ( otherValue != null ) return BOOL_ ; otherValue = value ; } return BOOL_ ; } else { Object name = names . elementAt ( len - NUM_ ) ; ContextMap nestedMap = ( ContextMap ) nameTable . get ( name ) ; if ( nestedMap == null ) { nestedMap = new ContextMap ( ) ; nameTable . put ( name , nestedMap ) ; } return nestedMap . put ( isRoot , names , len - NUM_ , value ) ; } }
static String encodeHighLevel ( String msg , Compaction compaction ) throws WriterException { byte [ ] bytes = null ; StringBuilder sb = new StringBuilder ( msg . length ( ) ) ; int len = msg . length ( ) ; int p = NUM_ ; int textSubMode = SUBMODE_ALPHA ; if ( compaction == Compaction . TEXT ) { encodeText ( msg , p , len , sb , textSubMode ) ; } else if ( compaction == Compaction . BYTE ) { bytes = getBytesForMessage ( msg ) ; encodeBinary ( bytes , p , bytes . length , BYTE_COMPACTION , sb ) ; } else if ( compaction == Compaction . NUMERIC ) { sb . append ( ( char ) LATCH_TO_NUMERIC ) ; encodeNumeric ( msg , p , len , sb ) ; } else { int encodingMode = TEXT_COMPACTION ; while ( p < len ) { int n = determineConsecutiveDigitCount ( msg , p ) ; if ( n >= NUM_ ) { sb . append ( ( char ) LATCH_TO_NUMERIC ) ; encodingMode = NUMERIC_COMPACTION ; textSubMode = SUBMODE_ALPHA ; encodeNumeric ( msg , p , n , sb ) ; p += n ; } else { int t = determineConsecutiveTextCount ( msg , p ) ; if ( t >= NUM_ || n == len ) { if ( encodingMode != TEXT_COMPACTION ) { sb . append ( ( char ) LATCH_TO_TEXT ) ; encodingMode = TEXT_COMPACTION ; textSubMode = SUBMODE_ALPHA ; } textSubMode = encodeText ( msg , p , t , sb , textSubMode ) ; p += t ; } else { if ( bytes == null ) { bytes = getBytesForMessage ( msg ) ; } int b = determineConsecutiveBinaryCount ( msg , bytes , p ) ; if ( b == NUM_ ) { b = NUM_ ; } if ( b == NUM_ && encodingMode == TEXT_COMPACTION ) { encodeBinary ( bytes , p , NUM_ , TEXT_COMPACTION , sb ) ; } else { encodeBinary ( bytes , p , b , encodingMode , sb ) ; encodingMode = BYTE_COMPACTION ; textSubMode = SUBMODE_ALPHA ; } p += b ; } } } } return sb . toString ( ) ; }
protected void queue ( final Path file ) throws InterruptedException { if ( null != base && file . startsWith ( base ) ) { queue . put ( file . subpath ( base . getNameCount ( ) , file . getNameCount ( ) ) ) ; } else { queue . put ( file ) ; } }
public InputStream openPath ( ) throws IOException { Path filePath = Paths . get ( path ( ) ) ; if ( Files . exists ( filePath ) ) { logger . info ( STR_ , filePath ) ; return Files . newInputStream ( filePath ) ; } URL resourceUrl = Resources . getResource ( path ( ) ) ; logger . info ( STR_ , resourceUrl ) ; return resourceUrl . openStream ( ) ; }
public static String replaceCharacters ( final ConversionMethod conversionMethod , final String input , final int fromCharacter , final int toCharacter , final String wrap ) { String convertedText = input ; for ( int i = fromCharacter ; i <= toCharacter ; i ++ ) { final String characterToReplace = new String ( Character . toChars ( i ) ) ; if ( wrap != null ) { convertedText = convertedText . replace ( characterToReplace , wrap + convertText ( conversionMethod , characterToReplace ) + wrap ) ; } else { convertedText = convertedText . replace ( characterToReplace , convertText ( conversionMethod , characterToReplace ) ) ; } } return convertedText ; }
public static byte [ ] hmac_sha1 ( byte [ ] keyBytes , byte [ ] text ) throws NoSuchAlgorithmException , InvalidKeyException { Mac hmacSha1 ; try { hmacSha1 = Mac . getInstance ( STR_ ) ; } catch ( final NoSuchAlgorithmException nsae ) { hmacSha1 = Mac . getInstance ( STR_ ) ; } final SecretKeySpec macKey = new SecretKeySpec ( keyBytes , STR_ ) ; hmacSha1 . init ( macKey ) ; return hmacSha1 . doFinal ( text ) ; }
public static byte [ ] readBytesAndClose ( InputStream in , int length ) throws IOException { try { if ( length <= NUM_ ) { length = Integer . MAX_VALUE ; } int block = Math . min ( Constants . IO_BUFFER_SIZE , length ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( block ) ; copy ( in , out , length ) ; return out . toByteArray ( ) ; } catch ( Exception e ) { throw DbException . convertToIOException ( e ) ; } finally { in . close ( ) ; } }
public IdentValue asIdentValue ( ) { if ( ! identIsSet ) { _identVal = IdentValue . getByIdentString ( cssPrimitiveValue . getCssText ( ) ) ; identIsSet = BOOL_ ; } return _identVal ; }
public final TestSuite build ( ) { rootSuite = new TestSuite ( getSuiteName ( ) ) ; currentClassname = null ; try { for ( TestMethod test : testGrouping . getTests ( ) ) { if ( satisfiesAllPredicates ( test ) ) { addTest ( test ) ; } } if ( testCases . size ( ) > NUM_ ) { for ( TestCase testCase : testCases ) { if ( satisfiesAllPredicates ( new TestMethod ( testCase ) ) ) { addTest ( testCase ) ; } } } } catch ( Exception exception ) { Log . i ( STR_ , STR_ , exception ) ; TestSuite suite = new TestSuite ( getSuiteName ( ) ) ; suite . addTest ( new FailedToCreateTests ( exception ) ) ; return suite ; } return rootSuite ; }
public javax . naming . Binding next ( ) throws NamingException { if ( more && counter >= _bindingList . value . length ) { getMore ( ) ; } if ( more && counter < _bindingList . value . length ) { org . omg . CosNaming . Binding bndg = _bindingList . value [ counter ] ; counter ++ ; return mapBinding ( bndg ) ; } else { throw new NoSuchElementException ( ) ; } }
protected < T extends ASTNode > T moveNode ( T oldNode , ASTRewrite rewrite ) { T movedNode ; if ( ASTNodes . isExistingNode ( oldNode ) ) movedNode = ASTNodes . createMoveTarget ( rewrite , oldNode ) ; else movedNode = ASTNodes . copySubtree ( rewrite . getAST ( ) , oldNode ) ; return movedNode ; }
@ Ignore @ Test public void shouldBeFasterWhenRunningProcessingInParallel ( ) throws Exception { testMojoWithConfigurableWroManagerFactoryWithValidConfigFileSet ( ) ; final long begin = System . currentTimeMillis ( ) ; victim . setParallelProcessing ( BOOL_ ) ; testMojoWithConfigurableWroManagerFactoryWithValidConfigFileSet ( ) ; final long endSerial = System . currentTimeMillis ( ) ; victim . setParallelProcessing ( BOOL_ ) ; testMojoWithConfigurableWroManagerFactoryWithValidConfigFileSet ( ) ; final long endParallel = System . currentTimeMillis ( ) ; final long serial = endSerial - begin ; final long parallel = endParallel - endSerial ; LOG . info ( STR_ , serial ) ; LOG . info ( STR_ , parallel ) ; assertTrue ( String . format ( STR_ , serial , parallel ) , serial > parallel ) ; }
public static TetradMatrix incompleteCholeskyGramMatrix ( List < Kernel > kernels , DataSet dataset , List < Node > nodes , double precision ) { if ( precision <= NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } int m = dataset . getNumRows ( ) ; TetradMatrix G = new TetradMatrix ( m , m ) ; double [ ] Dadv = new double [ m ] ; int [ ] p = new int [ m ] ; for ( int i = NUM_ ; i < m ; i ++ ) { Dadv [ i ] = evaluate ( kernels , dataset , nodes , i , i ) ; p [ i ] = i ; } int cols = m ; for ( int k = NUM_ ; k < m ; k ++ ) { double best = Dadv [ k ] ; int bestInd = k ; for ( int j = ( k + NUM_ ) ; j < m ; j ++ ) { if ( Dadv [ j ] > best / NUM_ ) { best = Dadv [ j ] ; bestInd = j ; } } if ( best < precision ) { cols = k - NUM_ ; break ; } int pk = p [ k ] ; p [ k ] = p [ bestInd ] ; p [ bestInd ] = pk ; double dk = Dadv [ k ] ; Dadv [ k ] = Dadv [ bestInd ] ; Dadv [ bestInd ] = dk ; for ( int j = NUM_ ; j < k ; j ++ ) { double gk = G . get ( k , j ) ; G . set ( k , j , G . get ( bestInd , j ) ) ; G . set ( bestInd , j , gk ) ; } double diag = Math . sqrt ( Dadv [ k ] ) ; G . set ( k , k , diag ) ; for ( int j = ( k + NUM_ ) ; j < m ; j ++ ) { double s = NUM_ ; for ( int i = NUM_ ; i < k ; i ++ ) { s += G . get ( j , i ) . G . get ( k , i ) ; } G . set ( j , k , ( evaluate ( kernels , dataset , nodes , p [ j ] , p [ k ] ) - s ) / diag ) ; } for ( int j = ( k + NUM_ ) ; j < m ; j ++ ) { Dadv [ j ] -= Math . pow ( G . get ( j , k ) , NUM_ ) ; } Dadv [ k ] = NUM_ ; } TetradMatrix Gm = new TetradMatrix ( m , cols ) ; for ( int i = NUM_ ; i < m ; i ++ ) { for ( int j = NUM_ ; j < cols ; j ++ ) { Gm . set ( i , j , G . get ( i , j ) ) ; } } return Gm ; }
FormatSpecifierParser ( String format ) { this . format = format ; this . length = format . length ( ) ; }
public void addConsumerType ( AttributeType type ) { if ( ! consumerTypes . contains ( type ) ) { consumerTypes . add ( type ) ; } }
public final void printVerboseMessage ( final LocalizableMessage msg ) { if ( isVerbose ( ) ) { out . println ( wrap ( msg ) ) ; } }
private static void orderMatches ( List < Variable > typeMatches , String paramName ) { if ( typeMatches != null ) Collections . sort ( typeMatches , new MatchComparator ( paramName ) ) ; }
SortedSet < String > typesToImport ( ) { SortedSet < String > typesToImport = new TreeSet < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entrySet ( ) ) { if ( entry . getValue ( ) . importIt ) { typesToImport . add ( entry . getKey ( ) ) ; } } return typesToImport ; }
@ Override public boolean isScraped ( ) { if ( ! scraped ) { if ( ! plot . isEmpty ( ) && ! ( year . isEmpty ( ) || year . equals ( STR_ ) ) && ! ( genres == null || genres . size ( ) == NUM_ ) && ! ( actors == null || actors . size ( ) == NUM_ ) ) { return BOOL_ ; } } return scraped ; }
public NoiseTagLdaModel ( InputStream in ) throws IOException { GZIPInputStream zipin = new GZIPInputStream ( in ) ; BufferedInputStream bin = new BufferedInputStream ( zipin ) ; DataInputStream datain = new DataInputStream ( bin ) ; numTopics = datain . readInt ( ) ; int numWords = datain . readInt ( ) ; alpha = datain . readDouble ( ) ; beta = datain . readDouble ( ) ; locked = datain . readBoolean ( ) ; wnz = new int [ numTopics ] ; Arrays . fill ( wnz , NUM_ ) ; for ( int i = NUM_ ; i < numWords ; i ++ ) { String word = datain . readUTF ( ) ; int [ ] count = new int [ numTopics ] ; for ( int j = NUM_ ; j < numTopics ; j ++ ) { count [ j ] = datain . readInt ( ) ; wnz [ j ] += count [ j ] ; nw += count [ j ] ; } nwz . put ( word , count ) ; } tnz = new int [ numTopics + NUM_ ] ; Arrays . fill ( tnz , NUM_ ) ; int numTags = datain . readInt ( ) ; eta = datain . readDouble ( ) ; for ( int i = NUM_ ; i < numTags ; i ++ ) { String word = datain . readUTF ( ) ; int [ ] count = new int [ numTopics + NUM_ ] ; for ( int j = NUM_ ; j < numTopics + NUM_ ; j ++ ) { count [ j ] = datain . readInt ( ) ; tnz [ j ] += count [ j ] ; nt += count [ j ] ; } ntz . put ( word , count ) ; } noise = numTopics ; }
public void check ( final int api ) { if ( api == Opcodes . ASM4 ) { if ( visibleTypeAnnotations != null && visibleTypeAnnotations . size ( ) > NUM_ ) { throw new RuntimeException ( ) ; } if ( invisibleTypeAnnotations != null && invisibleTypeAnnotations . size ( ) > NUM_ ) { throw new RuntimeException ( ) ; } for ( FieldNode f : fields ) { f . check ( api ) ; } for ( MethodNode m : methods ) { m . check ( api ) ; } } }
public static String RTFEnc ( String s ) { int ln = s . length ( ) ; int firstEscIdx = - NUM_ ; int lastEscIdx = NUM_ ; int plusOutLn = NUM_ ; for ( int i = NUM_ ; i < ln ; i ++ ) { char c = s . charAt ( i ) ; if ( c == STR_ || c == STR_ || c == STR_ ) { if ( firstEscIdx == - NUM_ ) { firstEscIdx = i ; } lastEscIdx = i ; plusOutLn ++ ; } } if ( firstEscIdx == - NUM_ ) { return s ; } else { char [ ] esced = new char [ ln + plusOutLn ] ; if ( firstEscIdx != NUM_ ) { s . getChars ( NUM_ , firstEscIdx , esced , NUM_ ) ; } int dst = firstEscIdx ; for ( int i = firstEscIdx ; i <= lastEscIdx ; i ++ ) { char c = s . charAt ( i ) ; if ( c == STR_ || c == STR_ || c == STR_ ) { esced [ dst ++ ] = STR_ ; } esced [ dst ++ ] = c ; } if ( lastEscIdx != ln - NUM_ ) { s . getChars ( lastEscIdx + NUM_ , ln , esced , dst ) ; } return String . valueOf ( esced ) ; } }
public String toString ( cp_info constant_pool [ ] ) { return Integer . toString ( ( int ) bytes ) ; }
public InetNetwork ( InetAddress inetAddress , int subnetBits ) { _inetAddress = inetAddress ; _address = inetAddress . getAddress ( ) ; if ( subnetBits < NUM_ ) subnetBits = NUM_ . _address . length ; _subnetBits = subnetBits ; _subnetByte = subnetBits / NUM_ ; _subnetMask = ~ ( ( NUM_ << ( NUM_ - subnetBits % NUM_ ) ) - NUM_ ) & xff ; }
public boolean equalArrayValue ( Object otherValue ) { if ( value instanceof Object [ ] && otherValue instanceof Object [ ] ) { return Arrays . equals ( ( Object [ ] ) value , ( Object [ ] ) otherValue ) ; } Class type = value . getClass ( ) ; if ( type != otherValue . getClass ( ) ) { return BOOL_ ; } if ( type == int [ ] . class ) { return Arrays . equals ( ( int [ ] ) value , ( int [ ] ) otherValue ) ; } else if ( type == byte [ ] . class ) { return Arrays . equals ( ( byte [ ] ) value , ( byte [ ] ) otherValue ) ; } else if ( type == short [ ] . class ) { return Arrays . equals ( ( short [ ] ) value , ( short [ ] ) otherValue ) ; } else if ( type == long [ ] . class ) { return Arrays . equals ( ( long [ ] ) value , ( long [ ] ) otherValue ) ; } else if ( type == char [ ] . class ) { return Arrays . equals ( ( char [ ] ) value , ( char [ ] ) otherValue ) ; } else if ( type == boolean [ ] . class ) { return Arrays . equals ( ( boolean [ ] ) value , ( boolean [ ] ) otherValue ) ; } else if ( type == float [ ] . class ) { return Arrays . equals ( ( float [ ] ) value , ( float [ ] ) otherValue ) ; } else if ( type == double [ ] . class ) { return Arrays . equals ( ( double [ ] ) value , ( double [ ] ) otherValue ) ; } return BOOL_ ; }
@ Override public HierarchyWrapperOperation createSubOperation ( ) { return new ToStringOperation ( builder , baseIndent ) ; }
private static byte [ ] readClass ( final InputStream is , boolean close ) throws IOException { if ( is == null ) { throw new IOException ( STR_ ) ; } try { byte [ ] b = new byte [ is . available ( ) ] ; int len = NUM_ ; while ( BOOL_ ) { int n = is . read ( b , len , b . length - len ) ; if ( n == - NUM_ ) { if ( len < b . length ) { byte [ ] c = new byte [ len ] ; System . arraycopy ( b , NUM_ , c , NUM_ , len ) ; b = c ; } return b ; } len += n ; if ( len == b . length ) { int last = is . read ( ) ; if ( last < NUM_ ) { return b ; } byte [ ] c = new byte [ b . length + NUM_ ] ; System . arraycopy ( b , NUM_ , c , NUM_ , len ) ; c [ len ++ ] = ( byte ) last ; b = c ; } } } finally { if ( close ) { is . close ( ) ; } } }
protected final boolean execute ( ) throws AdeException { logger . info ( STR_ + m_requestType . name ( ) ) ; final long start = System . currentTimeMillis ( ) ; final boolean success = doControlLogic ( ) ; final long total = System . currentTimeMillis ( ) - start ; logger . info ( m_requestType . name ( ) + ( success ? STR_ : STR_ ) + STR_ + millisecondsToHumanTime ( total ) ) ; return success ; }
public abstract JsonValue sync ( ) throws SynchronizationException ;
private boolean validConsist ( ) { int cN = validConsist ( consistTextField . getText ( ) ) ; if ( cN == - NUM_ ) { consistStatus . setText ( rb . getString ( STR_ ) ) ; JOptionPane . showMessageDialog ( this , rb . getString ( STR_ ) , rb . getString ( STR_ ) , JOptionPane . ERROR_MESSAGE ) ; return BOOL_ ; } return BOOL_ ; }
private void activity ( ) { connectionCheckedCount = NUM_ ; }
public static ScheduleSpec computeValues ( Object [ ] args ) throws ScheduleParameterException { if ( args . length <= NUM_ || args . length >= NUM_ ) { throw new ScheduleParameterException ( STR_ + args . length ) ; } EnumMap < ScheduleUnit , SortedSet < Integer > > unitMap = new EnumMap < ScheduleUnit , SortedSet < Integer > > ( ScheduleUnit . class ) ; Object minutes = args [ NUM_ ] ; Object hours = args [ NUM_ ] ; Object daysOfMonth = args [ NUM_ ] ; Object months = args [ NUM_ ] ; Object daysOfWeek = args [ NUM_ ] ; unitMap . put ( ScheduleUnit . MINUTES , computeValues ( minutes , ScheduleUnit . MINUTES ) ) ; unitMap . put ( ScheduleUnit . HOURS , computeValues ( hours , ScheduleUnit . HOURS ) ) ; SortedSet < Integer > resultMonths = computeValues ( months , ScheduleUnit . MONTHS ) ; if ( daysOfWeek instanceof CronParameter && daysOfMonth instanceof CronParameter ) { throw new ScheduleParameterException ( STR_ ) ; } if ( resultMonths != null && resultMonths . size ( ) == NUM_ && ( resultMonths . first ( ) instanceof Integer ) ) { CronParameter parameter = null ; if ( daysOfMonth instanceof CronParameter ) { parameter = ( ( CronParameter ) daysOfMonth ) ; } else if ( daysOfWeek instanceof CronParameter ) { parameter = ( ( CronParameter ) daysOfWeek ) ; } if ( parameter != null ) { parameter . setMonth ( resultMonths . first ( ) ) ; } } SortedSet < Integer > resultDaysOfWeek = computeValues ( daysOfWeek , ScheduleUnit . DAYS_OF_WEEK ) ; SortedSet < Integer > resultDaysOfMonth = computeValues ( daysOfMonth , ScheduleUnit . DAYS_OF_MONTH ) ; if ( resultDaysOfWeek != null && resultDaysOfWeek . size ( ) == NUM_ && ( resultDaysOfWeek . first ( ) instanceof Integer ) ) { if ( resultDaysOfWeek . first ( ) > NUM_ ) { if ( resultDaysOfMonth != null ) { throw new ScheduleParameterException ( STR_ ) ; } resultDaysOfMonth = resultDaysOfWeek ; resultDaysOfWeek = null ; } } if ( resultDaysOfMonth != null && resultDaysOfMonth . size ( ) == NUM_ && ( resultDaysOfMonth . first ( ) instanceof Integer ) ) { if ( resultDaysOfWeek != null ) { throw new ScheduleParameterException ( STR_ ) ; } } unitMap . put ( ScheduleUnit . DAYS_OF_WEEK , resultDaysOfWeek ) ; unitMap . put ( ScheduleUnit . DAYS_OF_MONTH , resultDaysOfMonth ) ; unitMap . put ( ScheduleUnit . MONTHS , resultMonths ) ; if ( args . length > NUM_ ) { unitMap . put ( ScheduleUnit . SECONDS , computeValues ( args [ NUM_ ] , ScheduleUnit . SECONDS ) ) ; } String timezone = null ; if ( args . length > NUM_ ) { if ( ! ( args [ NUM_ ] instanceof WildcardParameter ) ) { if ( ! ( args [ NUM_ ] instanceof String ) ) { throw new ScheduleParameterException ( STR_ + args [ NUM_ ] + STR_ ) ; } timezone = ( String ) args [ NUM_ ] ; } } CronParameter optionalDayOfMonthOp = getOptionalSpecialOp ( daysOfMonth ) ; CronParameter optionalDayOfWeekOp = getOptionalSpecialOp ( daysOfWeek ) ; return new ScheduleSpec ( unitMap , timezone , optionalDayOfMonthOp , optionalDayOfWeekOp ) ; }
public void remove ( int position ) { mData . remove ( position ) ; notifyItemRemoved ( position + getHeaderLayoutCount ( ) ) ; }
public AsyncBufferedOutputStream ( OutputStream out , int bufSize , int maxBuffers ) { super ( out ) ; buffers = new ConcurrentLinkedDeque < > ( ) ; buf = new byte [ bufSize ] ; flusherThread . start ( ) ; }
public boolean startlistContains ( String x ) { if ( startwords == null ) return BOOL_ ; return startwords . contains ( x ) ; }
private void closeMediaInfo ( ) { if ( mediaInfo != null ) { mediaInfo . close ( ) ; mediaInfo = null ; } miSnapshot = null ; }
public void addHeader ( final Header header ) { headers . add ( header ) ; }
private void readVersion ( InputNode node , Object source , Label label ) throws Exception { Object value = readInstance ( node , source , label ) ; Class expect = type . getType ( ) ; if ( value != null ) { Version version = context . getVersion ( expect ) ; Double actual = version . revision ( ) ; if ( ! value . equals ( revision ) ) { revision . compare ( actual , value ) ; } } }
protected Ignite startGridWithIgfs ( String gridName , String igfsName , IgfsMode mode , @ Nullable IgfsSecondaryFileSystem secondaryFs , @ Nullable IgfsIpcEndpointConfiguration restCfg ) throws Exception { FileSystemConfiguration igfsCfg = new FileSystemConfiguration ( ) ; igfsCfg . setDataCacheName ( STR_ ) ; igfsCfg . setMetaCacheName ( STR_ ) ; igfsCfg . setName ( igfsName ) ; igfsCfg . setBlockSize ( IGFS_BLOCK_SIZE ) ; igfsCfg . setDefaultMode ( mode ) ; igfsCfg . setIpcEndpointConfiguration ( restCfg ) ; igfsCfg . setSecondaryFileSystem ( secondaryFs ) ; igfsCfg . setPrefetchBlocks ( PREFETCH_BLOCKS ) ; igfsCfg . setSequentialReadsBeforePrefetch ( SEQ_READS_BEFORE_PREFETCH ) ; CacheConfiguration dataCacheCfg = defaultCacheConfiguration ( ) ; dataCacheCfg . setName ( STR_ ) ; dataCacheCfg . setCacheMode ( PARTITIONED ) ; dataCacheCfg . setNearConfiguration ( null ) ; dataCacheCfg . setWriteSynchronizationMode ( CacheWriteSynchronizationMode . FULL_SYNC ) ; dataCacheCfg . setAffinityMapper ( new IgfsGroupDataBlocksKeyMapper ( NUM_ ) ) ; dataCacheCfg . setBackups ( NUM_ ) ; dataCacheCfg . setAtomicityMode ( TRANSACTIONAL ) ; dataCacheCfg . setOffHeapMaxMemory ( NUM_ ) ; CacheConfiguration metaCacheCfg = defaultCacheConfiguration ( ) ; metaCacheCfg . setName ( STR_ ) ; metaCacheCfg . setCacheMode ( REPLICATED ) ; metaCacheCfg . setWriteSynchronizationMode ( CacheWriteSynchronizationMode . FULL_SYNC ) ; metaCacheCfg . setAtomicityMode ( TRANSACTIONAL ) ; IgniteConfiguration cfg = new IgniteConfiguration ( ) ; cfg . setGridName ( gridName ) ; TcpDiscoverySpi discoSpi = new TcpDiscoverySpi ( ) ; discoSpi . setIpFinder ( new TcpDiscoveryVmIpFinder ( BOOL_ ) ) ; cfg . setDiscoverySpi ( discoSpi ) ; cfg . setCacheConfiguration ( dataCacheCfg , metaCacheCfg ) ; cfg . setFileSystemConfiguration ( igfsCfg ) ; cfg . setLocalHost ( STR_ ) ; cfg . setConnectorConfiguration ( null ) ; return G . start ( cfg ) ; }
TypeSimplifier ( Types typeUtils , String packageName , Set < TypeMirror > types , TypeMirror base ) { this . typeUtils = typeUtils ; Set < TypeMirror > typesPlusBase = new TypeMirrorSet ( types ) ; if ( base != null ) { typesPlusBase . add ( base ) ; } Set < TypeMirror > referenced = referencedClassTypes ( typeUtils , typesPlusBase ) ; Set < TypeMirror > defined = nonPrivateDeclaredTypes ( typeUtils , base ) ; this . imports = findImports ( typeUtils , packageName , referenced , defined ) ; }
private List < Statistics > removeFailed ( List < Statistics > statistics ) { List < Statistics > result = new ArrayList < > ( ) ; for ( Statistics statistic : statistics ) { if ( statistic . getSucceeded ( ) ) result . add ( statistic ) ; } return result ; }
public void addAssociatedGefahr ( GefaehrdungsUmsetzung gefaehrdung ) { if ( ! associatedGefaehrdungen . contains ( gefaehrdung ) ) { associatedGefaehrdungen . add ( gefaehrdung ) ; } }
public static byte [ ] packByteBufferIntoSingleByteArray ( ByteBuffer [ ] byteBufferArr ) { if ( null == byteBufferArr || byteBufferArr . length == NUM_ ) { return null ; } int noOfCol = byteBufferArr . length ; short toDetermineLengthOfByteArr = NUM_ ; short offsetLen = ( short ) ( noOfCol . NUM_ + toDetermineLengthOfByteArr ) ; int totalBytes = calculateTotalBytes ( byteBufferArr ) + offsetLen ; ByteBuffer buffer = ByteBuffer . allocate ( totalBytes ) ; buffer . putShort ( ( short ) ( totalBytes - toDetermineLengthOfByteArr ) ) ; buffer . putShort ( offsetLen ) ; for ( int index = NUM_ ; index < byteBufferArr . length - NUM_ ; index ++ ) { ByteBuffer individualCol = byteBufferArr [ index ] ; int noOfBytes = individualCol . capacity ( ) ; buffer . putShort ( ( short ) ( offsetLen + noOfBytes ) ) ; offsetLen += noOfBytes ; individualCol . rewind ( ) ; } for ( int index = NUM_ ; index < byteBufferArr . length ; index ++ ) { ByteBuffer individualCol = byteBufferArr [ index ] ; buffer . put ( individualCol . array ( ) ) ; } buffer . rewind ( ) ; return buffer . array ( ) ; }
public void connect ( SocketAddress endpoint , int timeout ) throws IOException { if ( endpoint == null ) throw new IllegalArgumentException ( STR_ ) ; if ( timeout < NUM_ ) throw new IllegalArgumentException ( STR_ ) ; if ( isClosed ( ) ) throw new SocketException ( STR_ ) ; if ( ! oldImpl && isConnected ( ) ) throw new SocketException ( STR_ ) ; if ( ! ( endpoint instanceof InetSocketAddress ) ) throw new IllegalArgumentException ( STR_ ) ; InetSocketAddress epoint = ( InetSocketAddress ) endpoint ; InetAddress addr = epoint . getAddress ( ) ; int port = epoint . getPort ( ) ; checkAddress ( addr , STR_ ) ; SecurityManager security = System . getSecurityManager ( ) ; if ( security != null ) { if ( epoint . isUnresolved ( ) ) security . checkConnect ( epoint . getHostName ( ) , port ) ; else security . checkConnect ( addr . getHostAddress ( ) , port ) ; } if ( ! created ) createImpl ( BOOL_ ) ; if ( ! oldImpl ) impl . connect ( epoint , timeout ) ; else if ( timeout == NUM_ ) { if ( epoint . isUnresolved ( ) ) impl . connect ( addr . getHostName ( ) , port ) ; else impl . connect ( addr , port ) ; } else throw new UnsupportedOperationException ( STR_ ) ; connected = BOOL_ ; bound = BOOL_ ; }
private Pair < HashStepType , HashChainType > fetchHashStep ( String uri , HashChainType currentChain ) throws Exception { int hashIndex = uri . indexOf ( STR_ ) ; if ( hashIndex < NUM_ ) { throw new CodedException ( X_MALFORMED_HASH_CHAIN , STR_ , uri ) ; } String baseUri = uri . substring ( NUM_ , hashIndex ) ; String fragment = uri . substring ( hashIndex + NUM_ ) ; if ( fragment . isEmpty ( ) ) { throw new CodedException ( X_MALFORMED_HASH_CHAIN , STR_ , uri ) ; } HashChainType hashChain ; if ( baseUri . isEmpty ( ) ) { hashChain = currentChain ; } else { hashChain = getHashChain ( baseUri ) ; } for ( HashStepType step : hashChain . getHashStep ( ) ) { if ( fragment . equals ( step . getId ( ) ) ) { return new ImmutablePair < > ( step , hashChain ) ; } } throw new CodedException ( X_MALFORMED_HASH_CHAIN , STR_ , uri ) ; }
@ SuppressWarnings ( STR_ ) public static boolean loadByCurrentClassloader ( String clsName ) { if ( clsName . startsWith ( STR_ ) ) return BOOL_ ; if ( clsName . startsWith ( STR_ ) ) { if ( clsName . contains ( STR_ ) || clsName . contains ( STR_ ) || clsName . contains ( STR_ ) ) return BOOL_ ; } return BOOL_ ; }
public void decrementTargetsCountAll ( ) { final long decrementAndGet = targetsCountAll . decrementAndGet ( ) ; if ( decrementAndGet < NUM_ ) { targetsCountAll . set ( NUM_ ) ; } }
private void addNotAvailableBusinessObjectDataStatuses ( List < BusinessObjectDataStatus > notAvailableStatuses , List < StorageUnitEntity > storageUnitEntities , Set < BusinessObjectDataEntity > archivedBusinessObjectDataEntities ) { for ( StorageUnitEntity storageUnitEntity : storageUnitEntities ) { notAvailableStatuses . add ( createNotAvailableBusinessObjectDataStatus ( storageUnitEntity , archivedBusinessObjectDataEntities ) ) ; } }
private List < JdbcStatement > createDefaultQueryJdbcStatements ( ) { List < JdbcStatement > jdbcStatements = new ArrayList < > ( ) ; { JdbcStatement jdbcStatement = new JdbcStatement ( ) ; jdbcStatement . setType ( JdbcStatementType . QUERY ) ; jdbcStatement . setSql ( MockJdbcOperations . CASE_1_SQL ) ; jdbcStatements . add ( jdbcStatement ) ; } return jdbcStatements ; }
private void testMemorySpatialIndex ( ) throws SQLException { deleteDb ( STR_ ) ; Connection conn = getConnection ( URL ) ; Statement stat = conn . createStatement ( ) ; stat . execute ( STR_ ) ; stat . execute ( STR_ ) ; stat . execute ( STR_ ) ; stat . execute ( STR_ ) ; ResultSet rs ; rs = stat . executeQuery ( STR_ + STR_ + STR_ ) ; assertFalse ( rs . next ( ) ) ; rs = stat . executeQuery ( STR_ + STR_ ) ; rs . next ( ) ; if ( config . mvStore ) { assertContains ( rs . getString ( NUM_ ) , STR_ ) ; } stat . executeQuery ( STR_ + STR_ ) ; stat . executeQuery ( STR_ + STR_ ) ; rs = stat . executeQuery ( STR_ + STR_ ) ; assertTrue ( rs . next ( ) ) ; rs = stat . executeQuery ( STR_ + STR_ ) ; assertTrue ( rs . next ( ) ) ; rs = stat . executeQuery ( STR_ + STR_ ) ; assertFalse ( rs . next ( ) ) ; stat . execute ( STR_ ) ; conn . close ( ) ; deleteDb ( STR_ ) ; }
public static boolean isValid ( Date expirationDate ) { Date currentDate = new Date ( ) ; String formattedDate = dateFormat . format ( currentDate ) ; currentDate = convertDate ( formattedDate ) ; boolean isExpired = currentDate . after ( expirationDate ) ; boolean isEqual = currentDate . equals ( expirationDate ) ; if ( isExpired == BOOL_ || isEqual == BOOL_ ) { return BOOL_ ; } return BOOL_ ; }
public long contentLength ( ) { long size ; try { size = Long . parseLong ( request . getHeader ( FileUpload . CONTENT_LENGTH ) ) ; } catch ( NumberFormatException e ) { size = request . getContentLength ( ) ; } return size ; }
private E unlinkFirst ( ) { Node < E > f = first ; if ( f == null ) return null ; Node < E > n = f . next ; E item = f . item ; f . item = null ; f . next = f ; first = n ; if ( n == null ) last = null ; else n . prev = null ; -- count ; notFull . signal ( ) ; return item ; }
public void testZeroPos ( ) { String numA = STR_ ; String numB = STR_ ; String res = STR_ ; BigInteger aNumber = new BigInteger ( numA ) ; BigInteger bNumber = new BigInteger ( numB ) ; BigInteger result = aNumber . xor ( bNumber ) ; assertTrue ( res . equals ( result . toString ( ) ) ) ; }
public CheckBox addListener ( Listener listener ) { if ( listener != null && ! listeners . contains ( listener ) ) { listeners . add ( listener ) ; } return this ; }
@ SuppressWarnings ( STR_ ) public Object [ ] toArray ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = NUM_ ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }
private void takePicture ( ) { Log . d ( TAG , STR_ ) ; lockFocus ( ) ; }
private int measureShort ( int measureSpec ) { int result ; int specMode = MeasureSpec . getMode ( measureSpec ) ; int specSize = MeasureSpec . getSize ( measureSpec ) ; if ( specMode == MeasureSpec . EXACTLY ) { result = specSize ; } else { result = ( int ) ( NUM_ . mRadius + getPaddingTop ( ) + getPaddingBottom ( ) + NUM_ ) ; if ( specMode == MeasureSpec . AT_MOST ) { result = Math . min ( result , specSize ) ; } } return result ; }
private static int [ ] [ ] parse ( String members ) { Vector theRanges = new Vector ( ) ; int n = ( members == null ? NUM_ : members . length ( ) ) ; int i = NUM_ ; int state = NUM_ ; int lb = NUM_ ; int ub = NUM_ ; char c ; int digit ; while ( i < n ) { c = members . charAt ( i ++ ) ; switch ( state ) { case NUM_ : if ( Character . isWhitespace ( c ) ) { state = NUM_ ; } else if ( ( digit = Character . digit ( c , NUM_ ) ) != - NUM_ ) { lb = digit ; state = NUM_ ; } else { throw new IllegalArgumentException ( ) ; } break ; case NUM_ : if ( Character . isWhitespace ( c ) ) { state = NUM_ ; } else if ( ( digit = Character . digit ( c , NUM_ ) ) != - NUM_ ) { lb = NUM_ . lb + digit ; state = NUM_ ; } else if ( c == STR_ || c == STR_ ) { state = NUM_ ; } else if ( c == STR_ ) { accumulate ( theRanges , lb , lb ) ; state = NUM_ ; } else { throw new IllegalArgumentException ( ) ; } break ; case NUM_ : if ( Character . isWhitespace ( c ) ) { state = NUM_ ; } else if ( c == STR_ || c == STR_ ) { state = NUM_ ; } else if ( c == STR_ ) { accumulate ( theRanges , lb , lb ) ; state = NUM_ ; } else { throw new IllegalArgumentException ( ) ; } break ; case NUM_ : if ( Character . isWhitespace ( c ) ) { state = NUM_ ; } else if ( ( digit = Character . digit ( c , NUM_ ) ) != - NUM_ ) { ub = digit ; state = NUM_ ; } else { throw new IllegalArgumentException ( ) ; } break ; case NUM_ : if ( Character . isWhitespace ( c ) ) { state = NUM_ ; } else if ( ( digit = Character . digit ( c , NUM_ ) ) != - NUM_ ) { ub = NUM_ . ub + digit ; state = NUM_ ; } else if ( c == STR_ ) { accumulate ( theRanges , lb , ub ) ; state = NUM_ ; } else { throw new IllegalArgumentException ( ) ; } break ; case NUM_ : if ( Character . isWhitespace ( c ) ) { state = NUM_ ; } else if ( c == STR_ ) { accumulate ( theRanges , lb , ub ) ; state = NUM_ ; } else { throw new IllegalArgumentException ( ) ; } break ; case NUM_ : if ( Character . isWhitespace ( c ) ) { state = NUM_ ; } else if ( ( digit = Character . digit ( c , NUM_ ) ) != - NUM_ ) { lb = digit ; state = NUM_ ; } else { throw new IllegalArgumentException ( ) ; } break ; } } switch ( state ) { case NUM_ : break ; case NUM_ : case NUM_ : accumulate ( theRanges , lb , lb ) ; break ; case NUM_ : case NUM_ : accumulate ( theRanges , lb , ub ) ; break ; case NUM_ : case NUM_ : throw new IllegalArgumentException ( ) ; } return canonicalArrayForm ( theRanges ) ; }
public static String showDialog ( final Component component , final String title , final Object message , final String ... buttons ) { return showDialog ( JOptionPane . getFrameForComponent ( component ) , title , message , JOptionPane . PLAIN_MESSAGE , buttons ) ; }
public static void encode ( InputStream in , Writer out ) throws IOException { int column = NUM_ ; while ( BOOL_ ) { int byte1 = in . read ( ) ; int byte2 = in . read ( ) ; int byte3 = in . read ( ) ; if ( byte1 < NUM_ ) { return ; } if ( column >= NUM_ ) { column = NUM_ ; out . write ( STR_ ) ; } out . write ( charset [ byte1 > > NUM_ ] ) ; int index = ( byte1 & x3 ) << NUM_ ; if ( byte2 < NUM_ ) { out . write ( charset [ index ] ) ; out . write ( paddingChar ) ; out . write ( paddingChar ) ; return ; } index += byte2 > > NUM_ ; out . write ( charset [ index ] ) ; index = ( byte2 & xf ) << NUM_ ; if ( byte3 < NUM_ ) { out . write ( charset [ index ] ) ; out . write ( paddingChar ) ; return ; } index += byte3 > > NUM_ ; out . write ( charset [ index ] ) ; out . write ( charset [ byte3 & x3f ] ) ; column += NUM_ ; } }
public static String canonicalID ( String id ) { if ( id == null ) return STR_ ; int st = NUM_ ; int len = id . length ( ) ; boolean substr = BOOL_ ; int c ; while ( st < len && ( ( c = id . charAt ( st ) ) == STR_ || c <= STR_ ) ) { st ++ ; substr = BOOL_ ; } while ( st < len && ( ( c = id . charAt ( len - NUM_ ) ) == STR_ || c <= STR_ ) ) { len -- ; substr = BOOL_ ; } return substr ? id . substring ( st , len ) : id ; }
protected void sendMessage ( String handler , List < ? > arguments ) { ownerMessage . addEvent ( Type . CLIENT_SEND_MESSAGE , handler , arguments ) ; syncEvents . add ( new SharedObjectEvent ( Type . CLIENT_SEND_MESSAGE , handler , arguments ) ) ; sendStats . incrementAndGet ( ) ; }
public void taskNow ( final Runnable r , boolean async ) { if ( async ) { async ( r ) ; } else if ( r != null ) { r . run ( ) ; } }
public void reset ( ) { cur . reset ( ) ; line . reset ( ) ; inuse = BOOL_ ; word . setLength ( NUM_ ) ; }
protected void engineSetMode ( String mode ) throws NoSuchAlgorithmException { if ( ( mode != null ) && ( ! mode . equalsIgnoreCase ( STR_ ) ) ) { throw new NoSuchAlgorithmException ( STR_ + mode ) ; } }
private void movePos ( float deltaY ) { if ( ( deltaY < NUM_ && mPtrIndicator . isInStartPosition ( ) ) ) { if ( DEBUG ) { PtrCLog . e ( LOG_TAG , String . format ( STR_ ) ) ; } return ; } int to = mPtrIndicator . getCurrentPosY ( ) + ( int ) deltaY ; if ( mPtrIndicator . willOverTop ( to ) ) { if ( DEBUG ) { PtrCLog . e ( LOG_TAG , String . format ( STR_ ) ) ; } to = PtrIndicator . POS_START ; } mPtrIndicator . setCurrentPos ( to ) ; int change = to - mPtrIndicator . getLastPosY ( ) ; updatePos ( change ) ; }
public static List < ? extends Element > childElementList ( DocumentFragment fragment ) { if ( fragment == null ) return null ; List < Element > elements = new LinkedList < Element > ( ) ; Node node = fragment . getFirstChild ( ) ; if ( node != null ) { do { if ( node . getNodeType ( ) == Node . ELEMENT_NODE ) { Element childElement = ( Element ) node ; elements . add ( childElement ) ; } } while ( ( node = node . getNextSibling ( ) ) != null ) ; } return elements ; }
public void simulateMethod ( SootMethod method , ReferenceVariable thisVar , ReferenceVariable returnVar , ReferenceVariable params [ ] ) { String subSignature = method . getSubSignature ( ) ; if ( subSignature . equals ( STR_ ) ) { java_lang_reflect_Field_set ( method , thisVar , returnVar , params ) ; return ; } else if ( subSignature . equals ( STR_ ) ) { java_lang_reflect_Field_get ( method , thisVar , returnVar , params ) ; return ; } else { defaultMethod ( method , thisVar , returnVar , params ) ; return ; } }
public FloatArray resize ( FloatArray array , long size ) { if ( array instanceof BigFloatArray ) { return resizeInPlace ( ( BigFloatArray ) array , size ) ; } else { AbstractArray arr = ( AbstractArray ) array ; final FloatArray newArray = newFloatArray ( size , arr . clearOnResize ) ; for ( long i = NUM_ , end = Math . min ( size , array . size ( ) ) ; i < end ; ++ i ) { newArray . set ( i , array . get ( i ) ) ; } arr . close ( ) ; return newArray ; } }
@ Override public boolean domainMatch ( final String host , String domain ) { if ( host . equals ( domain ) ) { return BOOL_ ; } if ( ! domain . startsWith ( STR_ ) ) { domain = STR_ + domain ; } return host . endsWith ( domain ) || host . equals ( domain . substring ( NUM_ ) ) ; }
public boolean isDirty ( String key ) { return dirtyKeys . contains ( key ) ; }
final public void println ( float v ) { Writer out = this . out ; if ( out == null ) return ; String s = String . valueOf ( v ) ; try { out . write ( s , NUM_ , s . length ( ) ) ; out . write ( _newline , NUM_ , _newline . length ) ; } catch ( IOException e ) { log . log ( Level . FINE , e . toString ( ) , e ) ; } }
public static BigInteger sizeOfDirectoryAsBigInteger ( File directory ) { checkDirectory ( directory ) ; final File [ ] files = directory . listFiles ( ) ; if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { try { if ( ! isSymlink ( file ) ) { size = size . add ( BigInteger . valueOf ( sizeOf ( file ) ) ) ; } } catch ( IOException ioe ) { } } return size ; }
public double logDensityForInstance ( Instance instance ) throws Exception { double [ ] a = logJointDensitiesForInstance ( instance ) ; double max = a [ Utils . maxIndex ( a ) ] ; double sum = NUM_ ; for ( int i = NUM_ ; i < a . length ; i ++ ) { sum += Math . exp ( a [ i ] - max ) ; } return max + Math . log ( sum ) ; }
public void testWhenComplete_sourceFailedActionFailed ( ) { for ( boolean createIncomplete : new boolean [ ] { BOOL_ , BOOL_ } ) for ( ExecutionMode m : ExecutionMode . values ( ) ) { final AtomicInteger a = new AtomicInteger ( NUM_ ) ; final CFException ex1 = new CFException ( ) ; final CFException ex2 = new CFException ( ) ; final CompletableFuture < Integer > f = new CompletableFuture < > ( ) ; if ( ! createIncomplete ) f . completeExceptionally ( ex1 ) ; final CompletableFuture < Integer > g = m . whenComplete ( f , null ) ; if ( createIncomplete ) f . completeExceptionally ( ex1 ) ; checkCompletedWithWrappedException ( g , ex1 ) ; checkCompletedExceptionally ( f , ex1 ) ; assertEquals ( NUM_ , a . get ( ) ) ; } }
public static Angle greatCircleDistance ( LatLon p1 , LatLon p2 ) { if ( ( p1 == null ) || ( p2 == null ) ) { throw new IllegalArgumentException ( STR_ ) ; } double lat1 = p1 . getLatitude ( ) . radians ; double lon1 = p1 . getLongitude ( ) . radians ; double lat2 = p2 . getLatitude ( ) . radians ; double lon2 = p2 . getLongitude ( ) . radians ; if ( lat1 == lat2 && lon1 == lon2 ) return Angle . ZERO ; double a = Math . sin ( ( lat2 - lat1 ) / NUM_ ) ; double b = Math . sin ( ( lon2 - lon1 ) / NUM_ ) ; double c = a . a + + Math . cos ( lat1 ) . Math . cos ( lat2 ) . b . b ; double distanceRadians = NUM_ . Math . asin ( Math . sqrt ( c ) ) ; return Double . isNaN ( distanceRadians ) ? Angle . ZERO : Angle . fromRadians ( distanceRadians ) ; }
public int indexOf ( java . lang . String subString , int start ) { if ( start < NUM_ ) { start = NUM_ ; } int subCount = subString . count ; int _count = count ; if ( subCount > NUM_ ) { if ( subCount + start > _count ) { return - NUM_ ; } char [ ] target = subString . value ; int subOffset = subString . offset ; char firstChar = target [ subOffset ] ; int end = subOffset + subCount ; while ( BOOL_ ) { int i = indexOf ( firstChar , start ) ; if ( i == - NUM_ || subCount + i > _count ) { return - NUM_ ; } int o1 = offset + i , o2 = subOffset ; char [ ] _value = value ; while ( ++ o2 < end && _value [ ++ o1 ] == target [ o2 ] ) { } if ( o2 == end ) { return i ; } start = i + NUM_ ; } } return start < _count ? start : _count ; }
@ Override public Query rewrite ( IndexReader reader ) throws IOException { if ( disjuncts . length == NUM_ ) { return disjuncts [ NUM_ ] ; } boolean actuallyRewritten = BOOL_ ; List < Query > rewrittenDisjuncts = new ArrayList < > ( ) ; for ( Query sub : disjuncts ) { Query rewrittenSub = sub . rewrite ( reader ) ; actuallyRewritten |= rewrittenSub != sub ; rewrittenDisjuncts . add ( rewrittenSub ) ; } if ( actuallyRewritten ) { return new DisjunctionMaxQuery ( rewrittenDisjuncts , tieBreakerMultiplier ) ; } return super . rewrite ( reader ) ; }
public static String valueOf ( long value ) { return Long . toString ( value ) ; }
public static < T > boolean areSetsIdentical ( final Set < T > set1 , final Set < T > set2 ) { if ( set1 == set2 ) return BOOL_ ; if ( CollectionUtil . size ( set1 ) != CollectionUtil . size ( set2 ) ) return BOOL_ ; if ( CollectionUtil . isEmpty ( set1 ) ) return BOOL_ ; for ( final T t : set1 ) if ( ! set2 . contains ( t ) ) return BOOL_ ; return BOOL_ ; }
@ Override public int compareTo ( Value o ) { return hashCode ( ) - o . hashCode ( ) ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
private static void addOptions ( final List < String > cmd , Map < CheckerProp , Object > props ) { for ( CheckerProp cp : CheckerProp . values ( ) ) { cmd . addAll ( cp . getCmdLine ( props ) ) ; } }
public boolean obsolete ( ) { int [ ] stamp = new int [ NUM_ ] ; boolean undeployed = usage . get ( stamp ) ; return undeployed && stamp [ NUM_ ] == NUM_ ; }
public void delete ( ) throws IOException { close ( ) ; Util . deleteContents ( directory ) ; }
boolean popNamespace ( String prefix ) { if ( prefix . startsWith ( XML_PREFIX ) ) { return BOOL_ ; } Stack stack ; if ( ( stack = getPrefixStack ( prefix ) ) != null ) { stack . pop ( ) ; return BOOL_ ; } return BOOL_ ; }
public void redoLastAction ( ) { try { if ( undoManager . canRedo ( ) ) undoManager . redo ( ) ; } catch ( CannotRedoException cre ) { cre . printStackTrace ( ) ; } }
protected void continueWrite ( ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ ) ; } Iterator < VariableValue > i = variables . iterator ( ) ; while ( i . hasNext ( ) ) { VariableValue v = i . next ( ) ; if ( v . isToWrite ( ) && ( ! writingChanges || v . isChanged ( ) ) ) { amWriting = BOOL_ ; setBusy ( BOOL_ ) ; log . debug ( STR_ + v . label ( ) + STR_ + writingChanges ) ; if ( writingChanges ) { v . writeChanges ( ) ; } else { v . writeAll ( ) ; } log . debug ( STR_ ) ; return ; } } amWriting = BOOL_ ; super . setState ( STORED ) ; setBusy ( BOOL_ ) ; log . debug ( STR_ ) ; }
private void startGame ( GameLaunchMessage gameLaunchMessage , Faction faction , RatingMode ratingMode , Integer localRelayPort ) { if ( isRunning ( ) ) { logger . warn ( STR_ ) ; return ; } stopSearchRanked1v1 ( ) ; List < String > args = fixMalformedArgs ( gameLaunchMessage . getArgs ( ) ) ; try { localRelayServer . getPort ( ) ; process = forgedAllianceService . startGame ( gameLaunchMessage . getUid ( ) , gameLaunchMessage . getMod ( ) , faction , args , ratingMode , localRelayPort , rehostRequested ) ; setGameRunning ( BOOL_ ) ; this . ratingMode = ratingMode ; spawnTerminationListener ( process ) ; } catch ( IOException e ) { logger . warn ( STR_ , e ) ; notificationService . addNotification ( new ImmediateNotification ( i18n . get ( STR_ ) , i18n . get ( STR_ ) , Severity . ERROR , e , Arrays . asList ( new ReportAction ( i18n , reportingService , e ) , new DismissAction ( i18n ) ) ) ) ; } }
public void addLine ( String line ) { int index = line . indexOf ( STR_ , NUM_ ) ; if ( index != - NUM_ ) { addLenient ( line . substring ( NUM_ , index ) , line . substring ( index + NUM_ ) ) ; } else if ( line . startsWith ( STR_ ) ) { addLenient ( STR_ , line . substring ( NUM_ ) ) ; } else { addLenient ( STR_ , line ) ; } }
private synchronized void addEntries ( Hashtable entries ) { entryDirectory . putAll ( entries ) ; }
@ RequestMapping ( value = { STR_ , STR_ } , method = RequestMethod . POST ) @ ResponseBody public RestWrapper updateOneRecord ( @ ModelAttribute ( STR_ ) @ Valid GeneralConfig generalConfig , BindingResult bindingResult , Principal principal ) { RestWrapper restWrapper = null ; if ( bindingResult . hasErrors ( ) ) { BindingResultError bindingResultError = new BindingResultError ( ) ; return bindingResultError . errorMessage ( bindingResult ) ; } try { if ( generalConfig . getRequired ( ) <= NUM_ ) { com . wipro . ats . bdre . md . dao . jpa . GeneralConfig jpaGeneralConfigUpdate = new com . wipro . ats . bdre . md . dao . jpa . GeneralConfig ( ) ; GeneralConfigId jpaGeneralConfigId = new GeneralConfigId ( ) ; jpaGeneralConfigId . setConfigGroup ( generalConfig . getConfigGroup ( ) ) ; jpaGeneralConfigId . setGcKey ( generalConfig . getKey ( ) ) ; jpaGeneralConfigUpdate . setId ( jpaGeneralConfigId ) ; jpaGeneralConfigUpdate . setDefaultVal ( generalConfig . getDefaultVal ( ) ) ; jpaGeneralConfigUpdate . setDescription ( generalConfig . getDescription ( ) ) ; jpaGeneralConfigUpdate . setEnabled ( generalConfig . isEnabled ( ) ) ; jpaGeneralConfigUpdate . setGcValue ( generalConfig . getValue ( ) ) ; if ( generalConfig . getRequired ( ) == NUM_ ) jpaGeneralConfigUpdate . setRequired ( BOOL_ ) ; else jpaGeneralConfigUpdate . setRequired ( BOOL_ ) ; jpaGeneralConfigUpdate . setType ( generalConfig . getType ( ) ) ; LOGGER . info ( generalConfig ) ; generalConfigDAO . update ( jpaGeneralConfigUpdate ) ; restWrapper = new RestWrapper ( generalConfig , RestWrapper . OK ) ; LOGGER . info ( STR_ + jpaGeneralConfigId . getGcKey ( ) + STR_ + jpaGeneralConfigId . getConfigGroup ( ) + STR_ + principal . getName ( ) ) ; } else { LOGGER . error ( STR_ ) ; restWrapper = new RestWrapper ( STR_ , RestWrapper . ERROR ) ; } } catch ( MetadataException e ) { LOGGER . error ( e ) ; restWrapper = new RestWrapper ( e . getMessage ( ) , RestWrapper . ERROR ) ; } return restWrapper ; }
public static void loadProject ( final JTree tree , final INaviProject project ) { Preconditions . checkNotNull ( tree , STR_ ) ; Preconditions . checkNotNull ( project , STR_ ) ; loadProjectThreaded ( SwingUtilities . getWindowAncestor ( tree ) , project , tree ) ; }
public Enumeration listOptions ( ) { Vector newVector = new Vector ( NUM_ ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return newVector . elements ( ) ; }
public static DataPolicy fromOrdinal ( byte ordinal ) { return VALUES [ ordinal ] ; }
public static boolean isInstalled ( PackageManager packageManager , String packageName ) { List < PackageInfo > packs = packageManager . getInstalledPackages ( NUM_ ) ; for ( int i = NUM_ ; i < packs . size ( ) ; i ++ ) { if ( TextUtils . equals ( packs . get ( i ) . packageName , packageName ) ) return BOOL_ ; } return BOOL_ ; }
public void addSetAttribute ( final SetAttribute setAttribute ) { setAttributes . add ( setAttribute ) ; }
static String applyTemplate ( final String template , final Map < String , Object > map ) { configuration = getConfiguration ( ) ; try ( ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; Writer writer = new OutputStreamWriter ( outputStream ) ) { Template configurationTemplate = configuration . getTemplate ( template ) ; configurationTemplate . process ( map , writer ) ; return outputStream . toString ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e . getMessage ( ) , e ) ; } }
final void putShort ( int offset , short value ) { unsafe . putShort ( offset + address , value ) ; }
public static Clob toClob ( Object value ) throws PageException { if ( value instanceof Clob ) return ( Clob ) value ; else if ( value instanceof char [ ] ) return toClob ( new String ( ( char [ ] ) value ) ) ; else if ( value instanceof Reader ) { StringWriter sw = new StringWriter ( ) ; try { IOUtil . copy ( ( Reader ) value , sw , BOOL_ , BOOL_ ) ; } catch ( IOException e ) { throw ExpressionException . newInstance ( e ) ; } return toClob ( sw . toString ( ) ) ; } return toClob ( Caster . toString ( value ) ) ; }
private JFreeChart createHistogramChart ( ExampleSet exampleSet ) { JFreeChart chart = ChartFactory . createHistogram ( null , null , null , createHistogramDataset ( exampleSet ) , PlotOrientation . VERTICAL , BOOL_ , BOOL_ , BOOL_ ) ; AbstractAttributeStatisticsModel . setDefaultChartFonts ( chart ) ; chart . setBackgroundPaint ( null ) ; chart . setBackgroundImageAlpha ( NUM_ ) ; XYPlot plot = ( XYPlot ) chart . getPlot ( ) ; plot . setRangeGridlinesVisible ( BOOL_ ) ; plot . setDomainGridlinesVisible ( BOOL_ ) ; plot . setOutlineVisible ( BOOL_ ) ; plot . setRangeZeroBaselineVisible ( BOOL_ ) ; plot . setDomainZeroBaselineVisible ( BOOL_ ) ; plot . setBackgroundPaint ( COLOR_INVISIBLE ) ; plot . setBackgroundImageAlpha ( NUM_ ) ; XYBarRenderer renderer = ( XYBarRenderer ) plot . getRenderer ( ) ; renderer . setSeriesPaint ( NUM_ , AttributeGuiTools . getColorForValueType ( Ontology . NUMERICAL ) ) ; renderer . setBarPainter ( new StandardXYBarPainter ( ) ) ; renderer . setDrawBarOutline ( BOOL_ ) ; renderer . setShadowVisible ( BOOL_ ) ; return chart ; }
List < Type > save ( ) { ListBuffer < Type > buf = new ListBuffer < > ( ) ; for ( Type t : undetvars ) { UndetVar uv = ( UndetVar ) t ; UndetVar uv2 = new UndetVar ( ( TypeVar ) uv . qtype , types ) ; for ( InferenceBound ib : InferenceBound . values ( ) ) { for ( Type b : uv . getBounds ( ib ) ) { uv2 . addBound ( ib , b , types ) ; } } uv2 . inst = uv . inst ; buf . add ( uv2 ) ; } return buf . toList ( ) ; }
public int executeProcess ( ) { final List < String > processStrings = tokenizeString ( execCommand ) ; processStrings . addAll ( tokenizeString ( script ) ) ; logger . info ( MessageFormat . format ( STR_ , processStrings ) ) ; final ProcessBuilder processBuilder = new ProcessBuilder ( processStrings ) ; if ( workingDirectory != null ) { final Path dir = Paths . get ( workingDirectory ) ; if ( Files . notExists ( dir ) ) { try { Files . createDirectories ( dir ) ; } catch ( IOException e ) { logger . warning ( STR_ + workingDirectory ) ; return - NUM_ ; } } else if ( ! Files . isDirectory ( dir ) ) { logger . warning ( workingDirectory + STR_ ) ; return - NUM_ ; } final File directory = dir . toFile ( ) ; processBuilder . directory ( directory ) ; } processBuilder . redirectErrorStream ( BOOL_ ) ; Integer exitValue ; try { logger . info ( STR_ ) ; final Process process = processBuilder . start ( ) ; sendInputStringToProcess ( process ) ; handleProcessOutput ( process ) ; try { exitValue = process . waitFor ( ) ; } catch ( InterruptedException e ) { logger . warning ( STR_ ) ; process . destroy ( ) ; exitValue = - NUM_ ; } logger . info ( STR_ + exitValue + STR_ ) ; } catch ( IOException e ) { logger . log ( SEVERE , STR_ , e . getCause ( ) ) ; exitValue = - NUM_ ; } return exitValue ; }
static void checkMethodDesc ( final String desc ) { if ( desc == null || desc . length ( ) == NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } if ( desc . charAt ( NUM_ ) != STR_ || desc . length ( ) < NUM_ ) { throw new IllegalArgumentException ( STR_ + desc ) ; } int start = NUM_ ; if ( desc . charAt ( start ) != STR_ ) { do { if ( desc . charAt ( start ) == STR_ ) { throw new IllegalArgumentException ( STR_ + desc ) ; } start = checkDesc ( desc , start , BOOL_ ) ; } while ( start < desc . length ( ) && desc . charAt ( start ) != STR_ ) ; } start = checkDesc ( desc , start + NUM_ , BOOL_ ) ; if ( start != desc . length ( ) ) { throw new IllegalArgumentException ( STR_ + desc ) ; } }
protected Rectangle applyMargins ( Rectangle rect , float [ ] margins , boolean reverse ) { if ( isPositioned ( ) ) return rect ; return rect . < Rectangle > applyMargins ( margins [ NUM_ ] , margins [ NUM_ ] , margins [ NUM_ ] , margins [ NUM_ ] , reverse ) ; }
private void resetAttempts ( ) { for ( final PoliticalActionAttachment paa : PoliticalActionAttachment . getPoliticalActionAttachments ( m_player ) ) { paa . resetAttempts ( getBridge ( ) ) ; } }
public static Number minus ( Character left , Character right ) { return minus ( Integer . valueOf ( left ) , right ) ; }
public void findAndInit ( Object someObj ) { if ( someObj instanceof MouseDelegator ) { Debug . message ( STR_ , STR_ ) ; setMouseDelegator ( ( MouseDelegator ) someObj ) ; } }
public static int toInt ( final String value ) { return Integer . parseInt ( value ) ; }
protected Object evaluateLeftLessRight ( List elements , String lvalue , String rvalue ) { List array ; if ( elements instanceof java . util . Vector ) { array = new java . util . Vector ( ) ; } else { array = new ArrayList ( ) ; } for ( Iterator e = elements . iterator ( ) ; e . hasNext ( ) ; ) { Object o = e . next ( ) ; if ( o instanceof StructuredContent ) { if ( ( o = evaluateLeftLessRight ( ( StructuredContent ) o , lvalue , rvalue ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == NUM_ ) { return ( StructuredContent ) array . get ( NUM_ ) ; } return array ; }
static void checkTypeRefAndPath ( int typeRef , TypePath typePath ) { int mask = NUM_ ; switch ( typeRef > > > NUM_ ) { case TypeReference . CLASS_TYPE_PARAMETER : case TypeReference . METHOD_TYPE_PARAMETER : case TypeReference . METHOD_FORMAL_PARAMETER : mask = xFFFF0000 ; break ; case TypeReference . FIELD : case TypeReference . METHOD_RETURN : case TypeReference . METHOD_RECEIVER : case TypeReference . LOCAL_VARIABLE : case TypeReference . RESOURCE_VARIABLE : case TypeReference . INSTANCEOF : case TypeReference . NEW : case TypeReference . CONSTRUCTOR_REFERENCE : case TypeReference . METHOD_REFERENCE : mask = xFF000000 ; break ; case TypeReference . CLASS_EXTENDS : case TypeReference . CLASS_TYPE_PARAMETER_BOUND : case TypeReference . METHOD_TYPE_PARAMETER_BOUND : case TypeReference . THROWS : case TypeReference . EXCEPTION_PARAMETER : mask = xFFFFFF00 ; break ; case TypeReference . CAST : case TypeReference . CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT : case TypeReference . METHOD_INVOCATION_TYPE_ARGUMENT : case TypeReference . CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT : case TypeReference . METHOD_REFERENCE_TYPE_ARGUMENT : mask = xFF0000FF ; break ; default : throw new IllegalArgumentException ( STR_ + Integer . toHexString ( typeRef > > > NUM_ ) ) ; } if ( ( typeRef & ~ mask ) != NUM_ ) { throw new IllegalArgumentException ( STR_ + Integer . toHexString ( typeRef ) ) ; } if ( typePath != null ) { for ( int i = NUM_ ; i < typePath . getLength ( ) ; ++ i ) { int step = typePath . getStep ( i ) ; if ( step != TypePath . ARRAY_ELEMENT && step != TypePath . INNER_TYPE && step != TypePath . TYPE_ARGUMENT && step != TypePath . WILDCARD_BOUND ) { throw new IllegalArgumentException ( STR_ + i + STR_ + typePath ) ; } if ( step != TypePath . TYPE_ARGUMENT && typePath . getStepArgument ( i ) != NUM_ ) { throw new IllegalArgumentException ( STR_ + i + STR_ + typePath ) ; } } } }
public void removeCatchable ( CatchablePokemon pokemon ) { if ( cachedCatchable . size ( ) > NUM_ ) { cachedCatchable . remove ( pokemon ) ; } }
@ SuppressWarnings ( STR_ ) @ Override protected void fillBuffer ( ) { int oldP = p ; int index = tokens . size ( ) ; Token t = tokenSource . nextToken ( ) ; while ( t != null && t . getType ( ) != CharStream . EOF ) { int type = t . getType ( ) ; if ( type == InternalN4JSLexer . Solidus || type == InternalN4JSLexer . SolidusEqualsSign || type == InternalN4JSLexer . RightCurlyBracket ) { t . setTokenIndex ( index ) ; tokens . add ( t ) ; index ++ ; break ; } boolean discard = BOOL_ ; if ( channelOverrideMap != null ) { Integer channelI = ( Integer ) channelOverrideMap . get ( Integer . valueOf ( type ) ) ; if ( channelI != null ) { t . setChannel ( channelI . intValue ( ) ) ; } } if ( discardSet != null && discardSet . contains ( Integer . valueOf ( type ) ) ) { discard = BOOL_ ; } else if ( discardOffChannelTokens && t . getChannel ( ) != this . channel ) { discard = BOOL_ ; } if ( ! discard ) { t . setTokenIndex ( index ) ; tokens . add ( t ) ; index ++ ; } t = tokenSource . nextToken ( ) ; } p = oldP == - NUM_ ? NUM_ : oldP ; p = skipOffTokenChannels ( p ) ; }
char caseFold ( char c ) { if ( alternateCasing ) { if ( c == STR_ ) { return STR_ ; } else if ( c == STR_ ) { return STR_ ; } else { return Character . toLowerCase ( c ) ; } } else { return Character . toLowerCase ( c ) ; } }
public void writeCountsComparisonList ( final String filename , final String format ) { if ( format . compareToIgnoreCase ( STR_ ) == NUM_ ) { CountSimComparisonKMLWriter kmlWriter = new CountSimComparisonKMLWriter ( countsComparisonList , this . network , TransformationFactory . getCoordinateTransformation ( this . coordinateSystem , TransformationFactory . WGS84 ) ) ; kmlWriter . writeFile ( filename ) ; } else if ( format . compareToIgnoreCase ( STR_ ) == NUM_ ) { CountSimComparisonTableWriter writer = new CountSimComparisonTableWriter ( countsComparisonList , Locale . US ) ; writer . writeFile ( filename ) ; } else { throw new IllegalArgumentException ( STR_ ) ; } ComparisonErrorStatsCalculator errorStats = new ComparisonErrorStatsCalculator ( countsComparisonList ) ; double [ ] hours = new double [ NUM_ ] ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { hours [ i - NUM_ ] = i ; } DoubleArrayTableWriter tableWriter = new DoubleArrayTableWriter ( ) ; tableWriter . addColumn ( hours ) ; tableWriter . addColumn ( errorStats . getMeanRelError ( ) ) ; tableWriter . writeFile ( filename + STR_ ) ; }
public void testSubtractMathContextDiffScalePosNeg ( ) { String a = STR_ ; int aScale = NUM_ ; String b = STR_ ; int bScale = - NUM_ ; String c = STR_ ; int cScale = - NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal bNumber = new BigDecimal ( new BigInteger ( b ) , bScale ) ; MathContext mc = new MathContext ( NUM_ , RoundingMode . DOWN ) ; BigDecimal result = aNumber . subtract ( bNumber , mc ) ; assertEquals ( STR_ , c , result . toString ( ) ) ; assertEquals ( STR_ , cScale , result . scale ( ) ) ; }
public void putGrammar ( DTDGrammar grammar ) { XMLDTDDescription desc = ( XMLDTDDescription ) grammar . getGrammarDescription ( ) ; fGrammars . put ( desc , grammar ) ; }
public ServiceCall < TranslationResult > translate ( final String text , final Language source , final Language target ) { return translate ( Collections . singletonList ( text ) , source , target ) ; }
@ Override public int execute ( final FormObject form , final int type , final String code , final int eventType , final char keyPressed ) { int messageCode ; final String js = code ; final String [ ] args = JSFunction . convertToArray ( js ) ; final String command = args [ NUM_ ] ; if ( command . startsWith ( STR_ ) ) { messageCode = handleAFCommands ( form , command , js , args , eventType , keyPressed ) ; } else { executeFunctions ( js , form , acro ) ; messageCode = ActionHandler . VALUESCHANGED ; } if ( type == PdfDictionary . F ) { calcualteEvent ( ) ; messageCode = ActionHandler . VALUESCHANGED ; } return messageCode ; }
private Object readResolve ( ) { synchronized ( levels ) { for ( Level level : levels ) { if ( value != level . value ) { continue ; } if ( ! name . equals ( level . name ) ) { continue ; } if ( Objects . equal ( resourceBundleName , level . resourceBundleName ) ) { return level ; } } levels . add ( this ) ; return this ; } }
private static void repeat ( String pattern , int count , Appendable out ) throws IOException { while ( count >= pattern . length ( ) ) { out . append ( pattern ) ; count -= pattern . length ( ) ; } if ( count > NUM_ ) { out . append ( pattern , NUM_ , count ) ; } }
private void cleanUp ( Reference < ? > reference ) throws ShutDown { Method finalizeReferentMethod = getFinalizeReferentMethod ( ) ; do { reference . clear ( ) ; if ( reference == frqReference ) { throw new ShutDown ( ) ; } try { finalizeReferentMethod . invoke ( reference ) ; } catch ( Throwable t ) { logger . log ( Level . SEVERE , STR_ , t ) ; } } while ( ( reference = queue . poll ( ) ) != null ) ; }
private boolean isMineshafterPresent ( ) { try { Class . forName ( STR_ ) ; return BOOL_ ; } catch ( Exception e ) { return BOOL_ ; } }
public @ CheckForNull Queue . Item run2 ( @ Nonnull String replacementMainScript , @ Nonnull Map < String , String > replacementLoadedScripts ) { List < Action > actions = new ArrayList < Action > ( ) ; CpsFlowExecution execution = getExecution ( ) ; if ( execution == null ) { return null ; } actions . add ( new ReplayFlowFactoryAction ( replacementMainScript , replacementLoadedScripts , execution . isSandbox ( ) ) ) ; actions . add ( new CauseAction ( new Cause . UserIdCause ( ) , new ReplayCause ( run ) ) ) ; for ( Class < ? extends Action > c : COPIED_ACTIONS ) { actions . addAll ( run . getActions ( c ) ) ; } return ParameterizedJobMixIn . scheduleBuild2 ( run . getParent ( ) , NUM_ , actions . toArray ( new Action [ actions . size ( ) ] ) ) ; }
public static SecretKeys keys ( String keysStr ) throws InvalidKeyException { String [ ] keysArr = keysStr . split ( STR_ ) ; if ( keysArr . length != NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } else { byte [ ] confidentialityKey = Base64 . decode ( keysArr [ NUM_ ] , BASE64_FLAGS ) ; if ( confidentialityKey . length != AES_KEY_LENGTH_BITS / NUM_ ) { throw new InvalidKeyException ( STR_ + AES_KEY_LENGTH_BITS + STR_ ) ; } byte [ ] integrityKey = Base64 . decode ( keysArr [ NUM_ ] , BASE64_FLAGS ) ; if ( integrityKey . length != HMAC_KEY_LENGTH_BITS / NUM_ ) { throw new InvalidKeyException ( STR_ + HMAC_KEY_LENGTH_BITS + STR_ ) ; } SecretKeys secretKeys = new SecretKeys ( ) ; SecretKeySpec secretKeySpec = new SecretKeySpec ( ) ; secretKeySpec . generate ( confidentialityKey , NUM_ , confidentialityKey . length , CIPHER ) ; SecretKeySpec secretKeySpec1 = new SecretKeySpec ( ) ; secretKeySpec1 . generate ( integrityKey , HMAC_ALGORITHM ) ; secretKeys . setConfidentialityKey ( secretKeySpec ) ; secretKeys . setIntegrityKey ( secretKeySpec1 ) ; return secretKeys ; } }
public Path [ ] chooseStartingPaths ( final int nedges , final Path [ ] paths ) { final List < Path > tmp = new LinkedList < Path > ( ) ; Arrays . sort ( paths , NUM_ , paths . length , EstimatedCardinalityComparator . INSTANCE ) ; for ( int i = NUM_ ; i < paths . length && i < nedges ; i ++ ) { tmp . add ( paths [ i ] ) ; } return tmp . toArray ( new Path [ tmp . size ( ) ] ) ; }
private void safeBottomView ( ) { Status status = getOpenStatus ( ) ; ViewGroup bottom = getBottomView ( ) ; if ( status == Status . Close ) { if ( bottom . getVisibility ( ) != INVISIBLE ) bottom . setVisibility ( INVISIBLE ) ; } else { if ( bottom . getVisibility ( ) != VISIBLE ) bottom . setVisibility ( VISIBLE ) ; } }
public static int uniform ( int n ) { if ( n <= NUM_ ) throw new IllegalArgumentException ( STR_ ) ; return random . nextInt ( n ) ; }
private void viewDelta ( final Item item ) { final DeltaFragment fragment = DeltaFragment . newInstance ( item ) ; navigateToFragment ( fragment ) ; }
public Message ( String type , double value ) { if ( ! VALID_TYPES . contains ( type ) ) { throw new IllegalArgumentException ( type + STR_ + STR_ ) ; } this . type = type ; this . value = value ; }
public void addAll ( final CasualtyList casualtyList ) { m_damaged . addAll ( casualtyList . getDamaged ( ) ) ; m_killed . addAll ( casualtyList . getKilled ( ) ) ; }
public static String importResultSet ( ResultSet source , Database db , String name , ImportFilter filter , boolean useExistingTable ) throws SQLException , IOException { ResultSetMetaData md = source . getMetaData ( ) ; name = TableBuilder . escapeIdentifier ( name ) ; Table table = null ; if ( ! useExistingTable || ( ( table = db . getTable ( name ) ) == null ) ) { List < ColumnBuilder > columns = toColumns ( md ) ; table = createUniqueTable ( db , name , columns , md , filter ) ; } List < Object [ ] > rows = new ArrayList < Object [ ] > ( COPY_TABLE_BATCH_SIZE ) ; int numColumns = md . getColumnCount ( ) ; while ( source . next ( ) ) { Object [ ] row = new Object [ numColumns ] ; for ( int i = NUM_ ; i < row . length ; i ++ ) { row [ i ] = source . getObject ( i + NUM_ ) ; } row = filter . filterRow ( row ) ; if ( row == null ) { continue ; } rows . add ( row ) ; if ( rows . size ( ) == COPY_TABLE_BATCH_SIZE ) { table . addRows ( rows ) ; rows . clear ( ) ; } } if ( rows . size ( ) > NUM_ ) { table . addRows ( rows ) ; } return table . getName ( ) ; }
@ Override public long skip ( long n ) throws IOException { long remaining = n ; final char [ ] ch = new char [ fBuffer . length ] ; do { int length = ch . length < remaining ? ch . length : ( int ) remaining ; int count = read ( ch , NUM_ , length ) ; if ( count > NUM_ ) { remaining -= count ; } else { break ; } } while ( remaining > NUM_ ) ; long skipped = n - remaining ; return skipped ; }
public static long [ ] hashToLongs ( double datum , long seed ) { double d = ( datum == NUM_ ) ? NUM_ : datum ; long [ ] data = { Double . doubleToLongBits ( d ) } ; return hash ( data , seed ) ; }
private boolean allowUploadCrashDump ( ) { if ( isCellularExperimentEnabled ( ) ) return isUsageAndCrashReportingEnabled ( ) ; if ( isMobileNetworkCapable ( ) ) { String option = mSharedPreferences . getString ( PREF_CRASH_DUMP_UPLOAD , mCrashDumpNeverUpload ) ; return option . equals ( mCrashDumpAlwaysUpload ) || ( option . equals ( mCrashDumpWifiOnlyUpload ) && isWiFiOrEthernetNetwork ( ) ) ; } return mSharedPreferences . getBoolean ( PREF_CRASH_DUMP_UPLOAD_NO_CELLULAR , BOOL_ ) ; }
private int [ ] joinMap ( int [ ] a , int [ ] b ) { if ( a == null ) { return b ; } if ( b == null ) { return a ; } int [ ] result = new int [ a . length + b . length ] ; System . arraycopy ( a , NUM_ , result , NUM_ , a . length ) ; System . arraycopy ( b , NUM_ , result , a . length , b . length ) ; return result ; }
private void readObject ( ObjectInputStream in ) throws ClassNotFoundException , IOException { in . defaultReadObject ( ) ; iter = col . iterator ( ) ; }
public LabelSet ( int indices [ ] , boolean sort ) { this . indices = indices ; if ( sort == BOOL_ ) Arrays . sort ( this . indices ) ; }
public void diffEquals ( ) { double [ ] col = null ; for ( int i = NUM_ ; i < A . length ; i ++ ) { col = new double [ A [ i ] . length - NUM_ ] ; for ( int j = NUM_ ; j < A [ i ] . length ; j ++ ) col [ j - NUM_ ] = Math . abs ( A [ i ] [ j ] - A [ i ] [ j - NUM_ ] ) ; A [ i ] = col ; } n -- ; }
private static void printStackTraceElement ( StackTraceElement trace , PrintWriter out , ClassLoader loader ) { try { LineMap map = getScriptLineMap ( trace . getClassName ( ) , loader ) ; if ( map != null ) { LineMap . Line line = map . getLine ( trace . getLineNumber ( ) ) ; if ( line != null ) { out . print ( trace . getClassName ( ) + STR_ + trace . getMethodName ( ) ) ; out . print ( STR_ + line . getSourceFilename ( ) + STR_ ) ; out . println ( line . getSourceLine ( trace . getLineNumber ( ) ) + STR_ ) ; return ; } } } catch ( Throwable e ) { } out . println ( trace ) ; }
private static void decodeTextCompaction ( int [ ] textCompactionData , int [ ] byteCompactionData , int length , StringBuilder result ) { Mode subMode = Mode . ALPHA ; Mode priorToShiftMode = Mode . ALPHA ; int i = NUM_ ; while ( i < length ) { int subModeCh = textCompactionData [ i ] ; char ch = NUM_ ; switch ( subMode ) { case ALPHA : if ( subModeCh < NUM_ ) { ch = ( char ) ( STR_ + subModeCh ) ; } else { if ( subModeCh == NUM_ ) { ch = STR_ ; } else if ( subModeCh == LL ) { subMode = Mode . LOWER ; } else if ( subModeCh == ML ) { subMode = Mode . MIXED ; } else if ( subModeCh == PS ) { priorToShiftMode = subMode ; subMode = Mode . PUNCT_SHIFT ; } else if ( subModeCh == MODE_SHIFT_TO_BYTE_COMPACTION_MODE ) { result . append ( ( char ) byteCompactionData [ i ] ) ; } else if ( subModeCh == TEXT_COMPACTION_MODE_LATCH ) { subMode = Mode . ALPHA ; } } break ; case LOWER : if ( subModeCh < NUM_ ) { ch = ( char ) ( STR_ + subModeCh ) ; } else { if ( subModeCh == NUM_ ) { ch = STR_ ; } else if ( subModeCh == AS ) { priorToShiftMode = subMode ; subMode = Mode . ALPHA_SHIFT ; } else if ( subModeCh == ML ) { subMode = Mode . MIXED ; } else if ( subModeCh == PS ) { priorToShiftMode = subMode ; subMode = Mode . PUNCT_SHIFT ; } else if ( subModeCh == MODE_SHIFT_TO_BYTE_COMPACTION_MODE ) { result . append ( ( char ) byteCompactionData [ i ] ) ; } else if ( subModeCh == TEXT_COMPACTION_MODE_LATCH ) { subMode = Mode . ALPHA ; } } break ; case MIXED : if ( subModeCh < PL ) { ch = MIXED_CHARS [ subModeCh ] ; } else { if ( subModeCh == PL ) { subMode = Mode . PUNCT ; } else if ( subModeCh == NUM_ ) { ch = STR_ ; } else if ( subModeCh == LL ) { subMode = Mode . LOWER ; } else if ( subModeCh == AL ) { subMode = Mode . ALPHA ; } else if ( subModeCh == PS ) { priorToShiftMode = subMode ; subMode = Mode . PUNCT_SHIFT ; } else if ( subModeCh == MODE_SHIFT_TO_BYTE_COMPACTION_MODE ) { result . append ( ( char ) byteCompactionData [ i ] ) ; } else if ( subModeCh == TEXT_COMPACTION_MODE_LATCH ) { subMode = Mode . ALPHA ; } } break ; case PUNCT : if ( subModeCh < PAL ) { ch = PUNCT_CHARS [ subModeCh ] ; } else { if ( subModeCh == PAL ) { subMode = Mode . ALPHA ; } else if ( subModeCh == MODE_SHIFT_TO_BYTE_COMPACTION_MODE ) { result . append ( ( char ) byteCompactionData [ i ] ) ; } else if ( subModeCh == TEXT_COMPACTION_MODE_LATCH ) { subMode = Mode . ALPHA ; } } break ; case ALPHA_SHIFT : subMode = priorToShiftMode ; if ( subModeCh < NUM_ ) { ch = ( char ) ( STR_ + subModeCh ) ; } else { if ( subModeCh == NUM_ ) { ch = STR_ ; } else if ( subModeCh == TEXT_COMPACTION_MODE_LATCH ) { subMode = Mode . ALPHA ; } } break ; case PUNCT_SHIFT : subMode = priorToShiftMode ; if ( subModeCh < PAL ) { ch = PUNCT_CHARS [ subModeCh ] ; } else { if ( subModeCh == PAL ) { subMode = Mode . ALPHA ; } else if ( subModeCh == MODE_SHIFT_TO_BYTE_COMPACTION_MODE ) { result . append ( ( char ) byteCompactionData [ i ] ) ; } else if ( subModeCh == TEXT_COMPACTION_MODE_LATCH ) { subMode = Mode . ALPHA ; } } break ; } if ( ch != NUM_ ) { result . append ( ch ) ; } i ++ ; } }
public void readInformationObject ( final PdfObject infoObj , final ObjectDecoder objectDecoder ) { try { objectDecoder . checkResolved ( infoObj ) ; } catch ( final Exception e ) { LogWriter . writeLog ( STR_ + e . getMessage ( ) ) ; } String newValue ; int id ; byte [ ] data ; final int count = PdfFileInformation . information_field_IDs . length ; for ( int i = NUM_ ; i < count ; i ++ ) { id = PdfFileInformation . information_field_IDs [ i ] ; if ( id == PdfDictionary . Trapped ) { newValue = infoObj . getName ( id ) ; if ( newValue == null ) { newValue = STR_ ; } } else { data = infoObj . getTextStreamValueAsByte ( id ) ; if ( data == null ) { newValue = STR_ ; } else { newValue = StringUtils . getTextString ( data , BOOL_ ) ; } } setFieldValue ( i , newValue ) ; } }
private void cmd_calculateDifference ( ) { BigDecimal previousValue , actualValue ; Timestamp today = TimeUtil . getDay ( System . currentTimeMillis ( ) ) ; MCash cash = MCash . get ( p_pos . getCtx ( ) , p_pos . getC_CashBook_ID ( ) , today , null ) ; v_previousBalance . setValue ( cash . getEndingBalance ( ) ) ; previousValue = cash . getEndingBalance ( ) ; actualValue = ( BigDecimal ) v_ActualBalance . getValue ( ) ; v_difference . setValue ( actualValue . subtract ( previousValue ) ) ; }
public boolean testAllocation ( ) { boolean change = BOOL_ ; if ( isProcessed ( ) ) { BigDecimal alloc = getAllocatedAmt ( ) ; if ( alloc == null ) alloc = Env . ZERO ; BigDecimal total = getGrandTotal ( ) ; if ( ! isSOTrx ( ) ) total = total . negate ( ) ; if ( isCreditMemo ( ) ) total = total . negate ( ) ; boolean test = total . compareTo ( alloc ) == NUM_ ; change = test != isPaid ( ) ; if ( change ) setIsPaid ( test ) ; log . fine ( STR_ + test + STR_ + alloc + STR_ + total + STR_ ) ; } return change ; }
private void requestForUpload ( OCFile file ) { FileUploader . UploadRequester requester = new FileUploader . UploadRequester ( ) ; requester . uploadUpdate ( mContext , mAccount , file , FileUploader . LOCAL_BEHAVIOUR_MOVE , BOOL_ ) ; mTransferWasRequested = BOOL_ ; }
protected void decodeImageData ( ) { int NullCode = - NUM_ ; int npix = iw . ih ; int available , clear , code_mask , code_size , end_of_information , in_code , old_code , bits , code , count , i , datum , data_size , first , top , bi , pi ; if ( ( pixels == null ) || ( pixels . length < npix ) ) { pixels = new byte [ npix ] ; } if ( prefix == null ) prefix = new short [ MaxStackSize ] ; if ( suffix == null ) suffix = new byte [ MaxStackSize ] ; if ( pixelStack == null ) pixelStack = new byte [ MaxStackSize + NUM_ ] ; data_size = read ( ) ; clear = NUM_ << data_size ; end_of_information = clear + NUM_ ; available = clear + NUM_ ; old_code = NullCode ; code_size = data_size + NUM_ ; code_mask = ( NUM_ << code_size ) - NUM_ ; for ( code = NUM_ ; code < clear ; code ++ ) { prefix [ code ] = NUM_ ; suffix [ code ] = ( byte ) code ; } datum = bits = count = first = top = pi = bi = NUM_ ; for ( i = NUM_ ; i < npix ; ) { if ( top == NUM_ ) { if ( bits < code_size ) { if ( count == NUM_ ) { count = readBlock ( ) ; if ( count <= NUM_ ) break ; bi = NUM_ ; } datum += ( ( ( int ) block [ bi ] ) & xff ) << bits ; bits += NUM_ ; bi ++ ; count -- ; continue ; } code = datum & code_mask ; datum >>= code_size ; bits -= code_size ; if ( ( code > available ) || ( code == end_of_information ) ) break ; if ( code == clear ) { code_size = data_size + NUM_ ; code_mask = ( NUM_ << code_size ) - NUM_ ; available = clear + NUM_ ; old_code = NullCode ; continue ; } if ( old_code == NullCode ) { pixelStack [ top ++ ] = suffix [ code ] ; old_code = code ; first = code ; continue ; } in_code = code ; if ( code == available ) { pixelStack [ top ++ ] = ( byte ) first ; code = old_code ; } while ( code > clear ) { pixelStack [ top ++ ] = suffix [ code ] ; code = prefix [ code ] ; } first = ( ( int ) suffix [ code ] ) & xff ; if ( available >= MaxStackSize ) break ; pixelStack [ top ++ ] = ( byte ) first ; prefix [ available ] = ( short ) old_code ; suffix [ available ] = ( byte ) first ; available ++ ; if ( ( ( available & code_mask ) == NUM_ ) && ( available < MaxStackSize ) ) { code_size ++ ; code_mask += available ; } old_code = in_code ; } top -- ; pixels [ pi ++ ] = pixelStack [ top ] ; i ++ ; } for ( i = pi ; i < npix ; i ++ ) { pixels [ i ] = NUM_ ; } }
void refreshCustomMasterList ( ) { if ( customMasterCountries == null || customMasterCountries . length ( ) == NUM_ ) { customMasterCountriesList = null ; } else { List < Country > localCountryList = new ArrayList < > ( ) ; for ( String nameCode : customMasterCountries . split ( STR_ ) ) { Country country = Country . getCountryForNameCodeFromLibraryMasterList ( customLanguage , nameCode ) ; if ( country != null ) { if ( ! isAlreadyInList ( country , localCountryList ) ) { localCountryList . add ( country ) ; } } } if ( localCountryList . size ( ) == NUM_ ) { customMasterCountriesList = null ; } else { customMasterCountriesList = localCountryList ; } } if ( customMasterCountriesList != null ) { for ( Country country : customMasterCountriesList ) { country . log ( ) ; } } else { } }
protected boolean isDtoGetter ( Method method ) { if ( method . isAnnotationPresent ( DelegateTo . class ) ) { return BOOL_ ; } String methodName = method . getName ( ) ; if ( ( methodName . startsWith ( STR_ ) || methodName . startsWith ( STR_ ) ) && method . getParameterTypes ( ) . length == NUM_ ) { if ( methodName . length ( ) > NUM_ && methodName . startsWith ( STR_ ) ) { return method . getReturnType ( ) == Boolean . class || method . getReturnType ( ) == boolean . class ; } return methodName . length ( ) > NUM_ ; } return BOOL_ ; }
protected void handleParseConversionException ( Exception e ) throws SAXException { if ( e instanceof RuntimeException ) throw ( RuntimeException ) e ; ParseConversionEvent pce = new ParseConversionEventImpl ( ValidationEvent . ERROR , e . getMessage ( ) , new ValidationEventLocatorImpl ( context . getLocator ( ) ) , e ) ; context . handleEvent ( pce , BOOL_ ) ; }
private static char [ ] yy_unpack_cmap ( String packed ) { char [ ] map = new char [ x10000 ] ; int i = NUM_ ; int j = NUM_ ; while ( i < NUM_ ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM_ ) ; } return map ; }
public StatusBar ( boolean showMemory ) { super ( new BorderLayout ( ) ) ; add ( createInfoPanel ( ) , BorderLayout . WEST ) ; if ( showMemory ) { add ( createMemoryStatus ( ) , BorderLayout . CENTER ) ; JPanel iconPanel = new JPanel ( new BorderLayout ( ) ) ; iconPanel . add ( new JLabel ( new AngledLinesWindowsCornerIcon ( ) ) , BorderLayout . SOUTH ) ; add ( iconPanel , BorderLayout . EAST ) ; } else { setBackground ( Color . WHITE ) ; } }
public void execute ( final Runnable task ) { String name = metadata . get ( Metadata . RESOURCE_NAME_KEY ) ; if ( name != null ) { name = STR_ + name ; } else { name = STR_ ; } final Thread thread = new Thread ( task , name ) ; thread . setDaemon ( BOOL_ ) ; thread . start ( ) ; }
static int stringSize ( String string ) { int size = NUM_ ; if ( string != null ) { size += HEADERS + NUM_ . NUM_ ; size += HEADERS + NUM_ . string . length ( ) ; } return size ; }
public static GraphRequest newPostOpenGraphObjectRequest ( AccessToken accessToken , JSONObject openGraphObject , Callback callback ) { if ( openGraphObject == null ) { throw new FacebookException ( STR_ ) ; } if ( Utility . isNullOrEmpty ( openGraphObject . optString ( STR_ ) ) ) { throw new FacebookException ( STR_ ) ; } if ( Utility . isNullOrEmpty ( openGraphObject . optString ( STR_ ) ) ) { throw new FacebookException ( STR_ ) ; } String path = String . format ( MY_OBJECTS_FORMAT , openGraphObject . optString ( STR_ ) ) ; Bundle bundle = new Bundle ( ) ; bundle . putString ( OBJECT_PARAM , openGraphObject . toString ( ) ) ; return new GraphRequest ( accessToken , path , bundle , HttpMethod . POST , callback ) ; }
public void addGraph ( Graph g ) { graphs . add ( g ) ; }
protected void addToQuarantineQueue ( NodePortTuple npt ) { if ( quarantineQueue . contains ( npt ) == BOOL_ ) { quarantineQueue . add ( npt ) ; } }
private MrcMessage loadChars ( ) throws java . io . IOException { int nchars ; byte [ ] rcvBuffer = new byte [ NUM_ ] ; nchars = inpipe . read ( rcvBuffer , NUM_ , NUM_ ) ; MrcMessage msg = new MrcMessage ( nchars ) ; for ( int i = NUM_ ; i < nchars ; i ++ ) { msg . setElement ( i , rcvBuffer [ i ] & xFF ) ; } return msg ; }
@ SuppressWarnings ( STR_ ) @ Override protected Money handleTransactionThatIsALateRepaymentOfInstallment ( final LoanRepaymentScheduleInstallment currentInstallment , final List < LoanRepaymentScheduleInstallment > installments , final LoanTransaction loanTransaction , final Money transactionAmountUnprocessed , List < LoanTransactionToRepaymentScheduleMapping > transactionMappings ) { return handleTransactionThatIsOnTimePaymentOfInstallment ( currentInstallment , loanTransaction , transactionAmountUnprocessed , transactionMappings ) ; }
protected void fireTupleEvent ( Table t , int start , int end , int type ) { if ( m_tupleListeners != null && m_tupleListeners . size ( ) > NUM_ ) { Object [ ] lstnrs = m_tupleListeners . getArray ( ) ; Tuple [ ] tuples = new Tuple [ end - start + NUM_ ] ; for ( int i = NUM_ , r = start ; r <= end ; ++ r , ++ i ) { tuples [ i ] = t . getTuple ( r ) ; } for ( int i = NUM_ ; i < lstnrs . length ; ++ i ) { TupleSetListener tsl = ( TupleSetListener ) lstnrs [ i ] ; if ( type == EventConstants . INSERT ) { tsl . tupleSetChanged ( this , tuples , EMPTY_ARRAY ) ; } else { tsl . tupleSetChanged ( this , EMPTY_ARRAY , tuples ) ; } } } }
public String buildQuery ( String [ ] projectionIn , String selection , String groupBy , String having , String sortOrder , String limit ) { String [ ] projection = computeProjection ( projectionIn ) ; StringBuilder where = new StringBuilder ( ) ; boolean hasBaseWhereClause = mWhereClause != null && mWhereClause . length ( ) > NUM_ ; if ( hasBaseWhereClause ) { where . append ( mWhereClause . toString ( ) ) ; where . append ( STR_ ) ; } if ( selection != null && selection . length ( ) > NUM_ ) { if ( hasBaseWhereClause ) { where . append ( STR_ ) ; } where . append ( STR_ ) ; where . append ( selection ) ; where . append ( STR_ ) ; } return buildQueryString ( mDistinct , mTables , projection , where . toString ( ) , groupBy , having , sortOrder , limit ) ; }
public static boolean isExceptionTime ( Calendar scheduleTime , ScheduleInfo scheduleInfo ) throws Exception { if ( scheduleInfo . getDateExceptions ( ) != null ) { for ( String dateException : scheduleInfo . getDateExceptions ( ) ) { DateFormat formatter = new SimpleDateFormat ( ScheduleInfo . FULL_DAYTIME_FORMAT ) ; Date date = formatter . parse ( scheduleInfo . getStartDate ( ) ) ; Calendar exceptionTime = Calendar . getInstance ( TimeZone . getTimeZone ( STR_ ) ) ; exceptionTime . setTime ( date ) ; if ( exceptionTime . equals ( scheduleTime ) ) { log . info ( STR_ , scheduleTime . toString ( ) ) ; return BOOL_ ; } } } return BOOL_ ; }
protected void initPort ( ) { String portParam = getInitParameter ( STR_ ) ; setPort ( ( portParam == null ) ? DEFAULT_PORT : Integer . parseInt ( portParam ) ) ; if ( isDebug ( ) ) { log ( STR_ + getPort ( ) ) ; } }
public JPEGQTable ( int [ ] table ) { if ( table == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( table . length != NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } qTable = Arrays . copyOf ( table , table . length ) ; }
public VNXeNfsShare findSnapNfsShare ( String snapId , String shareName , String softwareVersion ) { StringBuilder queryFilter = new StringBuilder ( VNXeConstants . NAME_FILTER ) ; if ( ! VNXeUtils . isHigherVersion ( softwareVersion , VNXeConstants . VNXE_BASE_SOFT_VER ) ) { queryFilter . append ( shareName ) ; queryFilter . append ( VNXeConstants . AND ) ; queryFilter . append ( VNXeConstants . SNAP_FILTER ) ; queryFilter . append ( snapId ) ; } else { queryFilter . append ( STR_ + shareName + STR_ ) ; queryFilter . append ( VNXeConstants . AND ) ; queryFilter . append ( VNXeConstants . SNAP_FILTER_V31 ) ; queryFilter . append ( STR_ + snapId + STR_ ) ; } setFilter ( queryFilter . toString ( ) ) ; VNXeNfsShare result = null ; List < VNXeNfsShare > shareList = getDataForObjects ( VNXeNfsShare . class ) ; if ( shareList != null && ! shareList . isEmpty ( ) ) { result = shareList . get ( NUM_ ) ; _logger . info ( STR_ , snapId , shareName ) ; } else { _logger . info ( STR_ , snapId , shareName ) ; } return result ; }
@ Override public final int read ( ) throws IOException { ByteBuffer bb = waitForAvailableData ( ) ; return ( bb . get ( ) & xff ) ; }
protected TokenPosition ( TokenPosition other ) { Objects . requireNonNull ( other ) ; this . line = other . line ; this . column = other . column ; this . offset = other . offset ; }
private JComponent createDetailPanel ( Throwable error ) { StackTraceList stl = new StackTraceList ( error ) ; JScrollPane detailPane = new ExtendedJScrollPane ( stl ) ; detailPane . setPreferredSize ( new Dimension ( getWidth ( ) , NUM_ ) ) ; detailPane . setBorder ( null ) ; return detailPane ; }
abstract boolean containsKey ( T container , String key ) ;
private JMXConnector connect ( String host , int port ) { try { if ( ! isNodeAvailable ( host ) ) { log . info ( STR_ , host ) ; throw new IllegalStateException ( STR_ ) ; } log . debug ( STR_ , host , port ) ; String connectorAddress = String . format ( serviceUrl , host , port ) ; JMXServiceURL jmxUrl = new JMXServiceURL ( connectorAddress ) ; return JMXConnectorFactory . connect ( jmxUrl ) ; } catch ( MalformedURLException e ) { log . error ( String . format ( STR_ , host , port ) , e ) ; throw new IllegalStateException ( STR_ ) ; } catch ( IOException e ) { log . error ( String . format ( STR_ , host , port ) , e ) ; throw new IllegalStateException ( STR_ + host ) ; } }
public TagHandler processObjectValue ( Object value ) throws JspException { if ( value instanceof AttributeDefinition ) { return processTypedAttribute ( ( AttributeDefinition ) value ) ; } else if ( value instanceof ComponentDefinition ) { return processDefinition ( ( ComponentDefinition ) value ) ; } return processAsDefinitionOrURL ( value . toString ( ) ) ; }
public List < Integer > emit ( String streamId , Tuple anchor , List < Object > tuple ) { return emit ( streamId , Arrays . asList ( anchor ) , tuple ) ; }
private synchronized void writeToOutputStream ( int oneByte ) { if ( mClosed ) { return ; } try { mOutputStream . write ( oneByte ) ; reportDecodedSizeIfApplicable ( ) ; } catch ( IOException e ) { handleIOExceptionWritingToStream ( e ) ; } }
public int difference ( String s1 , String s2 ) throws EncoderException { return SoundexUtils . difference ( this , s1 , s2 ) ; }
public static Enumeration all ( ) { return _all . elements ( ) ; }
protected List < ModelEntity > makeEntityModelToUseList ( ) throws GenericEntityException { List < GenericValue > entitySyncIncludes = entitySync . getRelated ( STR_ , null , null , BOOL_ ) ; List < GenericValue > entitySyncGroupIncludes = entitySync . getRelated ( STR_ , null , null , BOOL_ ) ; entitySyncIncludes . addAll ( entitySyncGroupIncludes ) ; List < ModelEntity > entityModelToUseList = EntityGroupUtil . getModelEntitiesFromRecords ( entitySyncIncludes , delegator , BOOL_ ) ; if ( Debug . infoOn ( ) ) Debug . logInfo ( STR_ + entitySync . get ( STR_ ) + STR_ + entityModelToUseList . size ( ) + STR_ , module ) ; return entityModelToUseList ; }
private static String lz ( int num ) { return String . format ( STR_ , num ) ; }
public void onChildIdleBegin ( ) { _idleCount . incrementAndGet ( ) ; }
private StartupMode checkStartupMode ( Configuration config ) throws IOException { StartupMode bootMode = checkStartupModeOnDisk ( config ) ; if ( bootMode != null ) { return bootMode ; } if ( checkConfigBool ( config , Constants . STARTUPMODE_RESTORE_REINIT ) ) { _log . info ( STR_ , Constants . STARTUPMODE_RESTORE_REINIT ) ; GeodbRestoreMode mode = new GeodbRestoreMode ( config ) ; mode . setCoordinator ( _coordinator ) ; mode . setSchemaUtil ( _schemaUtil ) ; mode . setDbDir ( dbDir ) ; return mode ; } if ( checkConfigBool ( config , Constants . REINIT_DB ) ) { _log . info ( STR_ , Constants . REINIT_DB ) ; DbReinitMode mode = new DbReinitMode ( config ) ; mode . setCoordinator ( _coordinator ) ; mode . setSchemaUtil ( _schemaUtil ) ; mode . setDbDir ( dbDir ) ; return mode ; } List < String > obsoletePeers = checkConfigList ( config , Constants . OBSOLETE_CASSANDRA_PEERS ) ; if ( ! obsoletePeers . isEmpty ( ) ) { ObsoletePeersCleanupMode mode = new ObsoletePeersCleanupMode ( config ) ; mode . setCoordinator ( _coordinator ) ; mode . setSchemaUtil ( _schemaUtil ) ; mode . setObsoletePeers ( obsoletePeers ) ; return mode ; } else { NormalMode mode = new NormalMode ( config ) ; mode . setCoordinator ( _coordinator ) ; mode . setSchemaUtil ( _schemaUtil ) ; return mode ; } }
private void writeObject ( java . io . ObjectOutputStream s ) throws java . io . IOException { lock . lock ( ) ; try { q = new PriorityQueue < E > ( Math . max ( size , NUM_ ) , comparator ) ; q . addAll ( this ) ; s . defaultWriteObject ( ) ; } finally { q = null ; lock . unlock ( ) ; } }
private void run ( ) { try { Thread current = Thread . currentThread ( ) ; byte [ ] buf = new byte [ NUM_ ] ; for ( int len = in . read ( buf ) ; len != - NUM_ ; len = in . read ( buf ) ) { buffer . write ( buf , NUM_ , len ) ; if ( current != thread ) { break ; } } buffer . flush ( ) ; buffer . close ( ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } }
protected boolean shardAvailable ( @ Nullable IndexShard shard ) { return shard != null && shard . canIndex ( ) && CAN_UPDATE_INDEX_BUFFER_STATES . contains ( shard . state ( ) ) ; }
synchronized void updateAuthConfigGlobals ( ServiceSchemaManager scm ) throws SMSException { ServiceSchema schema = scm . getOrganizationSchema ( ) ; schema = schema . getSubSchema ( STR_ ) ; schema = schema . getSubSchema ( STR_ ) ; Map attrs = schema . getAttributeDefaults ( ) ; if ( attrs != null ) { defaultServiceSuccessURLSet = ( Set ) attrs . get ( ISAuthConstants . LOGIN_SUCCESS_URL ) ; defaultServiceFailureURLSet = ( Set ) attrs . get ( ISAuthConstants . LOGIN_FAILURE_URL ) ; } if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + defaultServiceSuccessURLSet ) ; debug . message ( STR_ + defaultServiceFailureURLSet ) ; } }
public void increment ( ) { count . incrementAndGet ( ) ; rateWindow . incrementForTimestamp ( timerGetter . now ( ) ) ; }
long totalMemory ( ) ;
@ Override public int preceding ( int offset ) { CharacterIterator text = getText ( ) ; checkOffset ( offset , text ) ; text . setIndex ( offset ) ; return previous ( ) ; }
public void log ( String event , String message ) { boolean eventActive = isEventActive ( event ) ; if ( ( this . logging && eventActive && ! writers . isEmpty ( ) ) ) { try { for ( Writer writer : writers . values ( ) ) { writer . write ( message ) ; writer . write ( STR_ ) ; writer . flush ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
public int write ( final ByteBuffer byteBuffer ) throws IOException { ensureOpen ( ) ; final int remaining = byteBuffer . remaining ( ) ; if ( inspectable < buffer . length ) { final int toBuffer = Math . min ( buffer . length - inspectable , remaining ) ; byteBuffer . get ( buffer , inspectable , toBuffer ) ; inspectable += toBuffer ; } if ( byteBuffer . hasRemaining ( ) ) { fileChannel . position ( writePosition ) ; writePosition += fileChannel . write ( byteBuffer ) ; } return remaining ; }
public void copyInto ( int strOffset , byte [ ] bytes , int arrayOffset , int len ) { System . arraycopy ( m_bytes , m_offset + strOffset , bytes , arrayOffset , len ) ; }
public static String repeatString ( String pattern , int repeats ) { StringBuilder buffer = new StringBuilder ( pattern . length ( ) . repeats ) ; for ( int i = NUM_ ; i < repeats ; i ++ ) { buffer . append ( pattern ) ; } return new String ( buffer ) ; }
private boolean isMusicPlayer ( ) { return playerSetting != null && playerSetting . equalsIgnoreCase ( STR_ ) ; }
private void fitImageToView ( ) { Drawable drawable = getDrawable ( ) ; if ( drawable == null || drawable . getIntrinsicWidth ( ) == NUM_ || drawable . getIntrinsicHeight ( ) == NUM_ ) { return ; } if ( matrix == null || prevMatrix == null ) { return ; } int drawableWidth = drawable . getIntrinsicWidth ( ) ; int drawableHeight = drawable . getIntrinsicHeight ( ) ; float scaleX = ( float ) viewWidth / drawableWidth ; float scaleY = ( float ) viewHeight / drawableHeight ; switch ( mScaleType ) { case CENTER : scaleX = scaleY = NUM_ ; break ; case CENTER_CROP : scaleX = scaleY = Math . max ( scaleX , scaleY ) ; break ; case CENTER_INSIDE : scaleX = scaleY = Math . min ( NUM_ , Math . min ( scaleX , scaleY ) ) ; case FIT_CENTER : scaleX = scaleY = Math . min ( scaleX , scaleY ) ; break ; case FIT_XY : break ; default : throw new UnsupportedOperationException ( STR_ ) ; } float redundantXSpace = viewWidth - ( scaleX . drawableWidth ) ; float redundantYSpace = viewHeight - ( scaleY . drawableHeight ) ; matchViewWidth = viewWidth - redundantXSpace ; matchViewHeight = viewHeight - redundantYSpace ; if ( ! isZoomed ( ) && ! imageRenderedAtLeastOnce ) { matrix . setScale ( scaleX , scaleY ) ; matrix . postTranslate ( redundantXSpace / NUM_ , redundantYSpace / NUM_ ) ; normalizedScale = NUM_ ; } else { if ( prevMatchViewWidth == NUM_ || prevMatchViewHeight == NUM_ ) { savePreviousImageValues ( ) ; } prevMatrix . getValues ( m ) ; m [ Matrix . MSCALE_X ] = matchViewWidth / drawableWidth . normalizedScale ; m [ Matrix . MSCALE_Y ] = matchViewHeight / drawableHeight . normalizedScale ; float transX = m [ Matrix . MTRANS_X ] ; float transY = m [ Matrix . MTRANS_Y ] ; float prevActualWidth = prevMatchViewWidth . normalizedScale ; float actualWidth = getImageWidth ( ) ; translateMatrixAfterRotate ( Matrix . MTRANS_X , transX , prevActualWidth , actualWidth , prevViewWidth , viewWidth , drawableWidth ) ; float prevActualHeight = prevMatchViewHeight . normalizedScale ; float actualHeight = getImageHeight ( ) ; translateMatrixAfterRotate ( Matrix . MTRANS_Y , transY , prevActualHeight , actualHeight , prevViewHeight , viewHeight , drawableHeight ) ; matrix . setValues ( m ) ; } fixTrans ( ) ; setImageMatrix ( matrix ) ; }
public final static VersionInfo [ ] loadVersionInfo ( String [ ] pckgs , ClassLoader clsldr ) { if ( pckgs == null ) { throw new IllegalArgumentException ( STR_ ) ; } ArrayList vil = new ArrayList ( pckgs . length ) ; for ( int i = NUM_ ; i < pckgs . length ; i ++ ) { VersionInfo vi = loadVersionInfo ( pckgs [ i ] , clsldr ) ; if ( vi != null ) vil . add ( vi ) ; } return ( VersionInfo [ ] ) vil . toArray ( new VersionInfo [ vil . size ( ) ] ) ; }
public static Collection < ContentStream > toContentStreams ( final String str , final String contentType ) { if ( str == null ) return null ; ArrayList < ContentStream > streams = new ArrayList < > ( NUM_ ) ; ContentStreamBase ccc = new ContentStreamBase . StringStream ( str ) ; ccc . setContentType ( contentType ) ; streams . add ( ccc ) ; return streams ; }
void writeRepeatedSqrt ( DD xdd ) { int count = NUM_ ; while ( xdd . doubleValue ( ) > NUM_ ) { count ++ ; double x = xdd . doubleValue ( ) ; DD xSqrt = xdd . sqrt ( ) ; String s = xSqrt . toString ( ) ; DD xSqrt2 = DD . parse ( s ) ; DD xx = xSqrt2 . multiply ( xSqrt2 ) ; double err = Math . abs ( xx . doubleValue ( ) - x ) ; xdd = xSqrt ; DD distFrom1DD = xSqrt . subtract ( DD . valueOf ( NUM_ ) ) ; double distFrom1 = distFrom1DD . doubleValue ( ) ; if ( Math . abs ( distFrom1 ) < NUM_ ) break ; } }
@ Override public String format ( DateTimeFormatter formatter ) { Objects . requireNonNull ( formatter , STR_ ) ; return formatter . format ( this ) ; }
void verifyUniqueXids ( List < OFMessage > msgs ) { if ( seenXids == null ) seenXids = new HashSet < Long > ( ) ; for ( OFMessage m : msgs ) { long xid = m . getXid ( ) ; assertTrue ( STR_ , xid != NUM_ ) ; assertFalse ( STR_ + xid + STR_ , seenXids . contains ( xid ) ) ; seenXids . add ( xid ) ; } }
public static boolean hasExtension ( String extension ) { if ( extension == null || extension . isEmpty ( ) ) { return BOOL_ ; } return extensionToMimeTypeMap . containsKey ( extension ) ; }
private float applyFriction ( float velocity , float simulationRate ) { if ( isZero ( velocity ) ) { velocity = NUM_ ; } else if ( velocity > NUM_ ) { velocity = Math . max ( NUM_ , velocity - ( FRICTION . simulationRate ) ) ; } else { velocity = Math . min ( NUM_ , velocity + ( FRICTION . simulationRate ) ) ; } return velocity ; }
static Boolean realIsJUnit4Test ( Class scriptClass , GroovyClassLoader loader ) { boolean isTest = BOOL_ ; try { try { Class runWithAnnotationClass = loader . loadClass ( STR_ ) ; Annotation annotation = scriptClass . getAnnotation ( runWithAnnotationClass ) ; if ( annotation != null ) { isTest = BOOL_ ; } else { Class testAnnotationClass = loader . loadClass ( STR_ ) ; Method [ ] methods = scriptClass . getMethods ( ) ; for ( int i = NUM_ ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; annotation = method . getAnnotation ( testAnnotationClass ) ; if ( annotation != null ) { isTest = BOOL_ ; break ; } } } } catch ( ClassNotFoundException e ) { } } catch ( Throwable e ) { } return isTest ? Boolean . TRUE : Boolean . FALSE ; }
private Dimension layoutSize ( Container target , boolean preferred ) { synchronized ( target . getTreeLock ( ) ) { int targetWidth = target . getSize ( ) . width ; if ( targetWidth == NUM_ ) { targetWidth = Integer . MAX_VALUE ; } int hgap = getHgap ( ) ; int vgap = getVgap ( ) ; Insets insets = target . getInsets ( ) ; int horizontalInsetsAndGap = insets . left + insets . right + ( hgap . NUM_ ) ; int maxWidth = targetWidth - horizontalInsetsAndGap ; Dimension dim = new Dimension ( NUM_ , NUM_ ) ; int rowWidth = NUM_ ; int rowHeight = NUM_ ; int nmembers = target . getComponentCount ( ) ; for ( int i = NUM_ ; i < nmembers ; i ++ ) { Component m = target . getComponent ( i ) ; if ( m . isVisible ( ) ) { Dimension d = preferred ? m . getPreferredSize ( ) : m . getMinimumSize ( ) ; if ( rowWidth + d . width > maxWidth ) { addRow ( dim , rowWidth , rowHeight ) ; rowWidth = NUM_ ; rowHeight = NUM_ ; } if ( rowWidth != NUM_ ) { rowWidth += hgap ; } rowWidth += d . width ; rowHeight = Math . max ( rowHeight , d . height ) ; } } addRow ( dim , rowWidth , rowHeight ) ; dim . width += horizontalInsetsAndGap ; dim . height += insets . top + insets . bottom + vgap . NUM_ ; Container scrollPane = SwingUtilities . getAncestorOfClass ( JScrollPane . class , target ) ; if ( scrollPane != null ) { dim . width -= ( hgap + NUM_ ) ; } return dim ; } }
private static void parseExpression ( final Reader reader , final boolean writingString , final StringBuilder templateExpressions ) throws IOException { if ( ! writingString ) { templateExpressions . append ( STR_ ) ; } templateExpressions . append ( STR_ ) ; while ( BOOL_ ) { int c = reader . read ( ) ; if ( c == - NUM_ ) break ; if ( c == STR_ ) { c = reader . read ( ) ; if ( c == STR_ ) break ; templateExpressions . append ( STR_ ) ; } templateExpressions . append ( ( char ) c ) ; } templateExpressions . append ( STR_ ) ; }
private static String doGetPath ( String filename , int separatorAdd ) { if ( filename == null ) { return null ; } int prefix = getPrefixLength ( filename ) ; if ( prefix < NUM_ ) { return null ; } int index = indexOfLastSeparator ( filename ) ; int endIndex = index + separatorAdd ; if ( prefix >= filename . length ( ) || index < NUM_ || prefix >= endIndex ) { return STR_ ; } return filename . substring ( prefix , endIndex ) ; }
protected void reduceParseTree ( CompilationUnitDeclaration unit ) { TypeDeclaration [ ] types = unit . types ; for ( int i = NUM_ , l = types . length ; i < l ; i ++ ) purgeMethodStatements ( types [ i ] , BOOL_ ) ; }
public synchronized void writeTo ( OutputStream out ) throws IOException { int remaining = count ; for ( byte [ ] buf : buffers ) { int c = Math . min ( buf . length , remaining ) ; out . write ( buf , NUM_ , c ) ; remaining -= c ; if ( remaining == NUM_ ) { break ; } } }
public static long findRevision ( final List < String > output , final Pattern pattern ) { long revision = - NUM_ ; for ( final String line : output ) { final Matcher matcher = pattern . matcher ( line ) ; if ( matcher . find ( ) ) { revision = Long . parseLong ( matcher . group ( NUM_ ) ) ; break ; } } return revision ; }
protected int chooseHighWaterMark ( int capacity , double maxLoad ) { return Math . min ( capacity - NUM_ , ( int ) ( capacity . maxLoad ) ) ; }
private AccessGrant createAccessGrant ( Map < String , String > params ) { AccessGrant accessGrant = new AccessGrant ( ) ; if ( params . get ( STR_ ) != null ) { String accessToken = params . get ( STR_ ) ; Integer expires = null ; if ( params . get ( STR_ ) != null ) { expires = Integer . valueOf ( params . get ( STR_ ) ) ; } accessGrant . setKey ( accessToken ) ; accessGrant . setAttribute ( STR_ , expires ) ; } accessGrant . setProviderId ( mProviderName . toString ( ) ) ; return accessGrant ; }
protected final boolean _loadToHaveAtLeast ( int minAvailable ) throws IOException { if ( _inputStream == null ) { return BOOL_ ; } int amount = _inputEnd - _inputPtr ; if ( amount > NUM_ && _inputPtr > NUM_ ) { _currInputProcessed += _inputPtr ; _currInputRowStart -= _inputPtr ; System . arraycopy ( _inputBuffer , _inputPtr , _inputBuffer , NUM_ , amount ) ; _inputEnd = amount ; } else { _inputEnd = NUM_ ; } _inputPtr = NUM_ ; while ( _inputEnd < minAvailable ) { int count = _inputStream . read ( _inputBuffer , _inputEnd , _inputBuffer . length - _inputEnd ) ; if ( count < NUM_ ) { _closeInput ( ) ; if ( count == NUM_ ) { throw new IOException ( STR_ + amount + STR_ ) ; } return BOOL_ ; } _inputEnd += count ; } return BOOL_ ; }
public double logPdf ( double x ) { return Math . log ( pdf ( x ) ) ; }
private void selectFile ( int titleMsg , int buttonMsg , String settingsName , String defaultDir , int dialog , int result ) { setAutoMode ( AutoMode . OFF ) ; String action = STR_ ; Intent i = new Intent ( action ) ; String currentFile = settings . getString ( settingsName , STR_ ) ; String sep = File . separator ; if ( ! currentFile . contains ( sep ) ) currentFile = Environment . getExternalStorageDirectory ( ) + sep + defaultDir + sep + currentFile ; i . setData ( Uri . fromFile ( new File ( currentFile ) ) ) ; i . putExtra ( STR_ , getString ( titleMsg ) ) ; i . putExtra ( STR_ , getString ( buttonMsg ) ) ; try { startActivityForResult ( i , result ) ; } catch ( ActivityNotFoundException e ) { removeDialog ( dialog ) ; showDialog ( dialog ) ; } }
private static void encodeBinary ( byte [ ] bytes , int startpos , int count , int startmode , StringBuilder sb ) { if ( count == NUM_ && startmode == TEXT_COMPACTION ) { sb . append ( ( char ) SHIFT_TO_BYTE ) ; } else { boolean sixpack = ( ( count % NUM_ ) == NUM_ ) ; if ( sixpack ) { sb . append ( ( char ) LATCH_TO_BYTE ) ; } else { sb . append ( ( char ) LATCH_TO_BYTE_PADDED ) ; } } int idx = startpos ; if ( count >= NUM_ ) { char [ ] chars = new char [ NUM_ ] ; while ( ( startpos + count - idx ) >= NUM_ ) { long t = NUM_ ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { t <<= NUM_ ; t += bytes [ idx + i ] & xff ; } for ( int i = NUM_ ; i < NUM_ ; i ++ ) { chars [ i ] = ( char ) ( t % NUM_ ) ; t /= NUM_ ; } for ( int i = chars . length - NUM_ ; i >= NUM_ ; i -- ) { sb . append ( chars [ i ] ) ; } idx += NUM_ ; } } for ( int i = idx ; i < startpos + count ; i ++ ) { int ch = bytes [ i ] & xff ; sb . append ( ( char ) ch ) ; } }
public String timerString ( int level , String message ) { StringBuilder retStringBuf = new StringBuilder ( ) ; for ( int i = NUM_ ; i < level ; i ++ ) { retStringBuf . append ( STR_ ) ; } retStringBuf . append ( STR_ ) ; String timeSinceStartStr = String . valueOf ( timeSinceStart ( ) ) ; retStringBuf . append ( timeSinceStartStr + STR_ ) ; String timeSinceLastStr = String . valueOf ( timeSinceLast ( ) ) ; retStringBuf . append ( timeSinceLastStr ) ; retStringBuf . append ( STR_ ) ; int spacecount = NUM_ + ( NUM_ . level ) - retStringBuf . length ( ) ; for ( int i = NUM_ ; i < spacecount ; i ++ ) { retStringBuf . append ( STR_ ) ; } retStringBuf . append ( message ) ; lastMessageTime = System . currentTimeMillis ( ) ; String retString = retStringBuf . toString ( ) ; if ( log && Debug . timingOn ( ) ) Debug . logTiming ( retString , module ) ; return retString ; }
public static int recompileWithOpt ( NormalMethod method ) { if ( VM . BuildForOptCompiler ) { CompilationPlan plan = new CompilationPlan ( method , ( OptimizationPlanElement [ ] ) optimizationPlan , null , ( OptOptions ) options ) ; return recompileWithOpt ( plan ) ; } else { if ( VM . VerifyAssertions ) VM . _assert ( VM . NOT_REACHED ) ; return - NUM_ ; } }
public String findMatch ( Pattern pattern , String text ) { return findMatch ( pattern , text , NUM_ ) ; }
private void addHit ( String cname , Class < ? > c ) { if ( len == names . length ) { final int nl = ( len << NUM_ ) + NUM_ ; names = Arrays . copyOf ( names , nl ) ; clazzes = Arrays . copyOf ( clazzes , nl ) ; } names [ len ] = cname ; clazzes [ len ] = c ; ++ len ; }
private Object queryCommandValue ( final String commandIdentifier ) { Check . notNull ( commandIdentifier , STR_ ) ; final StringBuffer cmd = new StringBuffer ( ) ; cmd . append ( STR_ ) ; cmd . append ( commandIdentifier ) ; cmd . append ( STR_ ) ; return browser . evaluate ( cmd . toString ( ) ) ; }
public void line ( double x , double y ) { Line line = new Line ( x , y ) ; if ( x < minX ) { minX = x ; } if ( y < minY ) { minY = y ; } if ( x > maxX ) { maxX = x ; } if ( y > maxY ) { maxY = y ; } elements . add ( line ) ; }
private void clipViewOnTheRight ( Rect curViewBound , float curViewWidth , int right ) { curViewBound . right = ( int ) ( right - mClipPadding ) ; curViewBound . left = ( int ) ( curViewBound . right - curViewWidth ) ; }
@ Override public List < Cluster < T > > cluster ( final Collection < T > points ) throws NullArgumentException { MathUtils . checkNotNull ( points ) ; final List < Cluster < T > > clusters = new ArrayList < Cluster < T > > ( ) ; final Map < Clusterable , PointStatus > visited = new HashMap < Clusterable , PointStatus > ( ) ; for ( final T point : points ) { if ( visited . get ( point ) != null ) { continue ; } final List < T > neighbors = getNeighbors ( point , points ) ; if ( neighbors . size ( ) >= minPts ) { final Cluster < T > cluster = new Cluster < T > ( ) ; clusters . add ( expandCluster ( cluster , point , neighbors , points , visited ) ) ; } else { visited . put ( point , PointStatus . NOISE ) ; } } return clusters ; }
public void testGetVersion25 ( ) throws Exception { String xml = WEBAPP_25_HEADER + STR_ ; WebXml webXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( xml . getBytes ( STR_ ) ) , getEntityResolver ( ) ) ; assertEquals ( WebXmlVersion . V2_5 , webXml . getVersion ( ) ) ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
private static void mat4_util_inplace_rotate ( float [ ] inOutMatrix , float eulerRadiansX , float eulerRadiansY , float eulerRadiansZ ) { float cos_rx = ( float ) Math . cos ( eulerRadiansX ) ; float cos_ry = ( float ) Math . cos ( eulerRadiansY ) ; float cos_rz = ( float ) Math . cos ( eulerRadiansZ ) ; float sin_rx = ( float ) Math . sin ( eulerRadiansX ) ; float sin_ry = ( float ) Math . sin ( eulerRadiansY ) ; float sin_rz = ( float ) Math . sin ( eulerRadiansZ ) ; float b00 = cos_rz . cos_ry ; float b10 = sin_rz . cos_ry ; float b20 = - sin_ry ; float b30 = NUM_ ; float b01 = - sin_rz . cos_rx + cos_rz . sin_ry . sin_rx ; float b11 = cos_rz . cos_rx + sin_rz . sin_ry . sin_rx ; float b21 = cos_ry . sin_rx ; float b31 = NUM_ ; float b02 = sin_rz . sin_rx + cos_rz . sin_ry . cos_rx ; float b12 = - cos_rz . sin_rx + sin_rz . sin_ry . cos_rx ; float b22 = cos_ry . cos_rx ; float b32 = NUM_ ; float b03 = NUM_ ; float b13 = NUM_ ; float b23 = NUM_ ; float b33 = NUM_ ; float a00 = inOutMatrix [ NUM_ ] ; float a10 = inOutMatrix [ NUM_ ] ; float a20 = inOutMatrix [ NUM_ ] ; float a30 = inOutMatrix [ NUM_ ] ; float a01 = inOutMatrix [ NUM_ ] ; float a11 = inOutMatrix [ NUM_ ] ; float a21 = inOutMatrix [ NUM_ ] ; float a31 = inOutMatrix [ NUM_ ] ; float a02 = inOutMatrix [ NUM_ ] ; float a12 = inOutMatrix [ NUM_ ] ; float a22 = inOutMatrix [ NUM_ ] ; float a32 = inOutMatrix [ NUM_ ] ; float a03 = inOutMatrix [ NUM_ ] ; float a13 = inOutMatrix [ NUM_ ] ; float a23 = inOutMatrix [ NUM_ ] ; float a33 = inOutMatrix [ NUM_ ] ; inOutMatrix [ NUM_ ] = a00 . b00 + a01 . b10 + a02 . b20 + a03 . b30 ; inOutMatrix [ NUM_ ] = a10 . b00 + a11 . b10 + a12 . b20 + a13 . b30 ; inOutMatrix [ NUM_ ] = a20 . b00 + a21 . b10 + a22 . b20 + a23 . b30 ; inOutMatrix [ NUM_ ] = a30 . b00 + a31 . b10 + a32 . b20 + a33 . b30 ; inOutMatrix [ NUM_ ] = a00 . b01 + a01 . b11 + a02 . b21 + a03 . b31 ; inOutMatrix [ NUM_ ] = a10 . b01 + a11 . b11 + a12 . b21 + a13 . b31 ; inOutMatrix [ NUM_ ] = a20 . b01 + a21 . b11 + a22 . b21 + a23 . b31 ; inOutMatrix [ NUM_ ] = a30 . b01 + a31 . b11 + a32 . b21 + a33 . b31 ; inOutMatrix [ NUM_ ] = a00 . b02 + a01 . b12 + a02 . b22 + a03 . b32 ; inOutMatrix [ NUM_ ] = a10 . b02 + a11 . b12 + a12 . b22 + a13 . b32 ; inOutMatrix [ NUM_ ] = a20 . b02 + a21 . b12 + a22 . b22 + a23 . b32 ; inOutMatrix [ NUM_ ] = a30 . b02 + a31 . b12 + a32 . b22 + a33 . b32 ; inOutMatrix [ NUM_ ] = a00 . b03 + a01 . b13 + a02 . b23 + a03 . b33 ; inOutMatrix [ NUM_ ] = a10 . b03 + a11 . b13 + a12 . b23 + a13 . b33 ; inOutMatrix [ NUM_ ] = a20 . b03 + a21 . b13 + a22 . b23 + a23 . b33 ; inOutMatrix [ NUM_ ] = a30 . b03 + a31 . b13 + a32 . b23 + a33 . b33 ; }
@ Override public void mousePressed ( MouseEvent evt ) { int pos = ( slider . getOrientation ( ) == JSlider . HORIZONTAL ) ? evt . getX ( ) : evt . getY ( ) ; int loc = getLocationForValue ( getSnappedValue ( evt ) ) ; this . offset = ( loc < NUM_ ) ? NUM_ : pos - loc ; }
private String printDFormat ( final long x ) { return printDFormat ( Long . toString ( x ) ) ; }
public void write ( int ch ) throws IOException { OutputStream os = getOutputStream ( ) ; os . write ( STR_ ) ; os . write ( NUM_ ) ; os . write ( NUM_ ) ; os . write ( ch ) ; }
public static < S > ServiceLoader < S > loadInstalled ( Class < S > service ) { ClassLoader cl = ClassLoader . getSystemClassLoader ( ) ; if ( cl != null ) { while ( cl . getParent ( ) != null ) { cl = cl . getParent ( ) ; } } return ServiceLoader . load ( service , cl ) ; }
private static Iterator < Operand > iterateReturnValues ( IR ir ) { ArrayList < Operand > returnValues = new ArrayList < Operand > ( ) ; for ( Enumeration < Instruction > e = ir . forwardInstrEnumerator ( ) ; e . hasMoreElements ( ) ; ) { Instruction s = e . nextElement ( ) ; if ( Return . conforms ( s ) ) { returnValues . add ( Return . getVal ( s ) ) ; } } return returnValues . iterator ( ) ; }
public static Pattern glob2Pattern ( String ... globs ) { final StringBuilder regex = new StringBuilder ( ) ; boolean needOr = BOOL_ ; for ( String glob : globs ) { if ( needOr ) { regex . append ( STR_ ) ; } int i = NUM_ , len = glob . length ( ) ; while ( i < len ) { char c = glob . charAt ( i ++ ) ; switch ( c ) { case STR_ : if ( i < len && glob . charAt ( i ) == STR_ ) { regex . append ( STR_ ) ; i ++ ; } else { regex . append ( STR_ ) ; } break ; case STR_ : regex . append ( STR_ ) ; break ; default : if ( isRegexMeta ( c ) ) { regex . append ( STR_ ) ; } regex . append ( c ) ; } } needOr = BOOL_ ; } return Pattern . compile ( regex . toString ( ) , NUM_ ) ; }
public static boolean containsTraceExplorerModuleConflict ( String rootModuleName ) { String rootModuleFileName = rootModuleName ; if ( ! rootModuleName . endsWith ( ResourceHelper . TLA_EXTENSION ) ) { rootModuleFileName = ResourceHelper . getModuleFileName ( rootModuleName ) ; } List < String > extendedModuleNames = ToolboxHandle . getExtendedModules ( rootModuleFileName ) ; Iterator < String > it = extendedModuleNames . iterator ( ) ; while ( it . hasNext ( ) ) { String moduleName = it . next ( ) ; if ( moduleName . equals ( TE_FILE_TLA ) ) { return BOOL_ ; } } return BOOL_ ; }
public void testFlipBitNegativeInside2 ( ) { byte aBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; int aSign = - NUM_ ; int number = NUM_ ; byte rBytes [ ] = { - NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , - NUM_ , - NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger result = aNumber . flipBit ( number ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , - NUM_ , result . signum ( ) ) ; }
private String buildFullMessage ( String msg , Object arg0 , Object arg1 , Object arg2 , Object [ ] argArray ) { StringBuilder sb = null ; int lastIndex = NUM_ ; int argC = NUM_ ; while ( BOOL_ ) { int argIndex = msg . indexOf ( ARG_STRING , lastIndex ) ; if ( argIndex == - NUM_ ) { break ; } if ( sb == null ) { sb = new StringBuilder ( NUM_ ) ; } sb . append ( msg , lastIndex , argIndex ) ; lastIndex = argIndex + ARG_STRING_LENGTH ; if ( argArray == null ) { if ( argC == NUM_ ) { appendArg ( sb , arg0 ) ; } else if ( argC == NUM_ ) { appendArg ( sb , arg1 ) ; } else if ( argC == NUM_ ) { appendArg ( sb , arg2 ) ; } else { } } else if ( argC < argArray . length ) { appendArg ( sb , argArray [ argC ] ) ; } else { } argC ++ ; } if ( sb == null ) { return msg ; } else { sb . append ( msg , lastIndex , msg . length ( ) ) ; return sb . toString ( ) ; } }
protected void removeFromParentInfo ( Openable child ) { Openable parent = ( Openable ) child . getParent ( ) ; if ( parent != null && parent . isOpen ( ) ) { try { OpenableElementInfo info = ( OpenableElementInfo ) parent . getElementInfo ( ) ; info . removeChild ( child ) ; } catch ( JavaModelException e ) { } } }
public void removeAllUpdateListeners ( ) { if ( mUpdateListeners == null ) { return ; } mUpdateListeners . clear ( ) ; mUpdateListeners = null ; }
public static String encodeString ( String s ) { return new String ( encode ( s . getBytes ( ) ) ) ; }
public void executePlan ( TaskCompleter completer , String successMessage , WorkflowCallbackHandler callbackHandler , Object [ ] callbackHandlerArgs , WorkflowRollbackHandler rollbackHandler , Object [ ] rollbackHandlerArgs ) throws WorkflowException { this . _callbackHandler = callbackHandler ; if ( callbackHandlerArgs != null ) { this . _callbackHandlerArgs = callbackHandlerArgs . clone ( ) ; } this . _rollbackHandler = rollbackHandler ; if ( rollbackHandlerArgs != null ) { this . _rollbackHandlerArgs = rollbackHandlerArgs . clone ( ) ; } this . _taskCompleter = completer ; this . _successMessage = successMessage ; _service . executePlan ( this ) ; }
public boolean isMutable ( ) { return mutable ; }
public void handleRequest ( RequestContext rc ) throws CLIException { super . handleRequest ( rc ) ; ldapLogin ( ) ; String serviceName = getStringOptionValue ( IArgument . SERVICE_NAME ) ; String subConfigName = getStringOptionValue ( IArgument . SUB_CONFIGURATION_NAME ) ; String realmName = getStringOptionValue ( IArgument . REALM_NAME ) ; if ( ( realmName == null ) || ( realmName . length ( ) == NUM_ ) ) { deleteSubConfigToRoot ( serviceName , subConfigName ) ; } else { deleteSubConfigFromRealm ( realmName , serviceName , subConfigName ) ; } }
public void enforceContext ( Resource ... contexts ) { OpenRDFUtil . verifyContextNotNull ( contexts ) ; this . contexts = Arrays . copyOf ( contexts , contexts . length ) ; }
protected void runUpload ( Integer numOfThreads , HashMap < String , String > attributes , Boolean createNewVersion , Boolean force ) throws Exception { runUpload ( numOfThreads , attributes , createNewVersion , force , null , null ) ; }
public final Collection < Component > components ( ) { return new HashSet < > ( components . values ( ) ) ; }
protected boolean [ ] canPredict ( boolean nominalPredictor , boolean numericPredictor , boolean stringPredictor , boolean datePredictor , boolean relationalPredictor , boolean multiInstance , int classType ) { print ( STR_ ) ; printAttributeSummary ( nominalPredictor , numericPredictor , stringPredictor , datePredictor , relationalPredictor , multiInstance , classType ) ; print ( STR_ ) ; ArrayList < String > accepts = new ArrayList < String > ( ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; int numTrain = getNumInstances ( ) , numClasses = NUM_ , missingLevel = NUM_ ; boolean predictorMissing = BOOL_ , classMissing = BOOL_ ; return runBasicTest ( nominalPredictor , numericPredictor , stringPredictor , datePredictor , relationalPredictor , multiInstance , classType , missingLevel , predictorMissing , classMissing , numTrain , numClasses , accepts ) ; }
public void test_historyIndexDisabled ( ) throws SailException { final Properties properties = getProperties ( ) ; properties . setProperty ( com . bigdata . rdf . store . AbstractTripleStore . Options . HISTORY_SERVICE , STR_ ) ; final BigdataSail sail = getSail ( properties ) ; try { sail . initialize ( ) ; final BigdataSailConnection conn = sail . getConnection ( ) ; try { final IIndex ndx = getHistoryIndex ( conn . getTripleStore ( ) ) ; assertNull ( ndx ) ; conn . rollback ( ) ; } finally { conn . close ( ) ; } } finally { sail . __tearDownUnitTest ( ) ; } }
public void collapse ( ) { collapse ( BOOL_ ) ; }
public int numInstances ( ) { return m_Instances . size ( ) ; }
@ Override public void startDocument ( XMLLocator locator , String encoding , NamespaceContext namespaceContext , Augmentations augs ) throws XNIException { fNamespaceContext = namespaceContext ; try { if ( fDocumentHandler != null ) { if ( locator != null ) { fDocumentHandler . setDocumentLocator ( new LocatorProxy ( locator ) ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . startDocument ( ) ; } } if ( fContentHandler != null ) { if ( locator != null ) { fContentHandler . setDocumentLocator ( new LocatorProxy ( locator ) ) ; } if ( fContentHandler != null ) { fContentHandler . startDocument ( ) ; } } } catch ( SAXException e ) { throw new XNIException ( e ) ; } }
public static double parseNumberPercentWithSeparateRange ( FXGNode node , String value , String name , double minNumber , double maxNumber , double minPercent , double maxPercent , double defaultValue ) { if ( value . length ( ) != NUM_ && value . charAt ( value . length ( ) - NUM_ ) == STR_ ) { String doubleValue = value . substring ( NUM_ , value . length ( ) - NUM_ ) ; try { return parseDouble ( node , doubleValue , name , minPercent , maxPercent , defaultValue ) ; } catch ( FXGException e ) { throw new FXGException ( node . getStartLine ( ) , node . getStartColumn ( ) , STR_ , name , value ) ; } } else { return parseDouble ( node , value , name , minNumber , maxNumber , defaultValue ) ; } }
private void checkDownloadCanProceed ( ) throws StopRequestException { if ( clock . intervalLessThan ( Clock . Interval . ONE_SECOND ) ) { return ; } clock . startInterval ( ) ; checkIsPausedOrCanceled ( ) ; checkClientRules ( ) ; }
private void calculateColor ( int coord ) { coord = coord - mBarPointerHaloRadius ; if ( coord < NUM_ ) { coord = NUM_ ; } else if ( coord > mBarLength ) { coord = mBarLength ; } mColor = Color . HSVToColor ( Math . round ( mPosToOpacFactor . coord ) , mHSVColor ) ; if ( Color . alpha ( mColor ) > NUM_ ) { mColor = Color . HSVToColor ( mHSVColor ) ; } else if ( Color . alpha ( mColor ) < NUM_ ) { mColor = Color . TRANSPARENT ; } }
private void deleteEvent ( EventRegKeyExpiration regExpiration , EventReg reg ) { listeners . dec ( ) ; synchronized ( reg ) { EntryRep [ ] tmpls = reg . tmpl . attributeSetTemplates ; if ( tmpls != null ) { for ( int i = tmpls . length ; -- i >= NUM_ ; ) { EntryClass eclass = tmpls [ i ] . eclass ; eclass . setNumTemplates ( eclass . getNumTemplates ( ) - NUM_ ) ; } } Long id = reg . eventID ; eventByID . remove ( id ) ; if ( regExpiration != null ) { eventByTime . remove ( regExpiration ) ; } else { eventByTime . remove ( new EventRegKeyExpiration ( reg , reg . leaseExpiration ) ) ; } if ( reg . tmpl . serviceID != null ) { Object val = subEventByService . get ( reg . tmpl . serviceID ) ; if ( val == reg ) { subEventByService . remove ( reg . tmpl . serviceID ) ; } else { Object [ ] array = ( EventReg [ ] ) val ; array = arrayDel ( array , indexOf ( array , reg ) ) ; if ( array . length == NUM_ ) val = array [ NUM_ ] ; else val = array ; subEventByService . put ( reg . tmpl . serviceID , val ) ; } } else { subEventByID . remove ( id ) ; } computeMaxLeases ( ) ; } }
public String gtidSet ( ) { return this . gtidSet != null ? this . gtidSet : null ; }
public static Peer createMapPeer ( Map map ) throws MessageException { if ( ! map . containsKey ( PORT ) || ! map . containsKey ( ADDRESS ) ) throw new MessageException ( STR_ ) ; int port = ( int ) ( long ) map . get ( PORT ) ; String address = ( String ) map . get ( ADDRESS ) ; String peerId = null ; if ( map . containsKey ( PEER_ID ) ) peerId = ( String ) map . get ( PEER_ID ) ; return new Peer ( peerId , new InetSocketAddress ( address , port ) ) ; }
private static int countGapsDashDotStar ( String sequence ) { int count = NUM_ ; for ( int i = NUM_ ; i < sequence . length ( ) ; i ++ ) { int a = sequence . charAt ( i ) ; if ( a == STR_ || a == STR_ || a == STR_ ) count ++ ; } return count ; }
private boolean testPassword ( ) throws PdfSecurityException { int count = NUM_ ; final byte [ ] rawValue = new byte [ NUM_ ] ; byte [ ] keyValue ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { rawValue [ i ] = ( byte ) Integer . parseInt ( pad [ i ] , NUM_ ) ; } byte [ ] encrypted = ObjectCloneFactory . cloneArray ( rawValue ) ; if ( rev == NUM_ ) { encryptionKey = calculateKey ( O , P , ID ) ; encrypted = decrypt ( encrypted , STR_ , BOOL_ , null , BOOL_ , BOOL_ ) ; } else if ( rev >= NUM_ ) { int keyLength = this . keyLength ; count = NUM_ ; encryptionKey = calculateKey ( O , P , ID ) ; final byte [ ] originalKey = ObjectCloneFactory . cloneArray ( encryptionKey ) ; MessageDigest md = null ; try { md = MessageDigest . getInstance ( STR_ ) ; } catch ( final Exception e ) { LogWriter . writeLog ( STR_ + e + STR_ ) ; } md . update ( encrypted ) ; keyValue = md . digest ( ID ) ; keyValue = decrypt ( keyValue , STR_ , BOOL_ , null , BOOL_ , BOOL_ ) ; final byte [ ] nextKey = new byte [ keyLength ] ; for ( int i = NUM_ ; i <= NUM_ ; i ++ ) { for ( int j = NUM_ ; j < keyLength ; j ++ ) { nextKey [ j ] = ( byte ) ( originalKey [ j ] ^ i ) ; } encryptionKey = nextKey ; keyValue = decrypt ( keyValue , STR_ , BOOL_ , null , BOOL_ , BOOL_ ) ; } encryptionKey = originalKey ; encrypted = new byte [ NUM_ ] ; System . arraycopy ( keyValue , NUM_ , encrypted , NUM_ , NUM_ ) ; System . arraycopy ( rawValue , NUM_ , encrypted , NUM_ , NUM_ ) ; } return compareKeys ( U , encrypted , count ) ; }
public static void putDoubleField ( Object obj , long fieldOff , double val ) { UNSAFE . putDouble ( obj , fieldOff , val ) ; }
public static String readFully ( Reader reader ) throws IOException { try { StringWriter writer = new StringWriter ( ) ; char [ ] buffer = new char [ NUM_ ] ; int count ; while ( ( count = reader . read ( buffer ) ) != - NUM_ ) { writer . write ( buffer , NUM_ , count ) ; } return writer . toString ( ) ; } finally { reader . close ( ) ; } }
public String toOIDString ( ) { if ( sOID == null ) { sOID = STR_ + toString ( ) ; } return sOID ; }
public void emitDirect ( int taskId , String streamId , Tuple anchor , List < Object > tuple ) { emitDirect ( taskId , streamId , Arrays . asList ( anchor ) , tuple ) ; }
protected void loadValue ( String sValue ) { sValue = sValue . trim ( ) ; try { int r = Integer . parseInt ( sValue . substring ( NUM_ , NUM_ ) , NUM_ ) ; int g = Integer . parseInt ( sValue . substring ( NUM_ , NUM_ ) , NUM_ ) ; int b = Integer . parseInt ( sValue . substring ( NUM_ , NUM_ ) , NUM_ ) ; value = new Color ( r , g , b ) ; } catch ( NumberFormatException nfe ) { revertToDefault ( ) ; } catch ( StringIndexOutOfBoundsException sioobe ) { revertToDefault ( ) ; } }
public void schemaChanged ( String serviceName , String version ) { updateStatus ( ) ; }
private static int byteCompaction ( int mode , int [ ] codewords , int codeIndex , StringBuilder result ) { if ( mode == BYTE_COMPACTION_MODE_LATCH ) { int count = NUM_ ; long value = NUM_ ; char [ ] decodedData = new char [ NUM_ ] ; int [ ] byteCompactedCodewords = new int [ NUM_ ] ; boolean end = BOOL_ ; int nextCode = codewords [ codeIndex ++ ] ; while ( ( codeIndex < codewords [ NUM_ ] ) && ! end ) { byteCompactedCodewords [ count ++ ] = nextCode ; value = NUM_ . value + nextCode ; nextCode = codewords [ codeIndex ++ ] ; if ( nextCode == TEXT_COMPACTION_MODE_LATCH || nextCode == BYTE_COMPACTION_MODE_LATCH || nextCode == NUMERIC_COMPACTION_MODE_LATCH || nextCode == BYTE_COMPACTION_MODE_LATCH_6 || nextCode == BEGIN_MACRO_PDF417_CONTROL_BLOCK || nextCode == BEGIN_MACRO_PDF417_OPTIONAL_FIELD || nextCode == MACRO_PDF417_TERMINATOR ) { codeIndex -- ; end = BOOL_ ; } else { if ( ( count % NUM_ == NUM_ ) && ( count > NUM_ ) ) { for ( int j = NUM_ ; j < NUM_ ; ++ j ) { decodedData [ NUM_ - j ] = ( char ) ( value % NUM_ ) ; value >>= NUM_ ; } result . append ( decodedData ) ; count = NUM_ ; } } } if ( codeIndex == codewords [ NUM_ ] && nextCode < TEXT_COMPACTION_MODE_LATCH ) { byteCompactedCodewords [ count ++ ] = nextCode ; } for ( int i = NUM_ ; i < count ; i ++ ) { result . append ( ( char ) byteCompactedCodewords [ i ] ) ; } } else if ( mode == BYTE_COMPACTION_MODE_LATCH_6 ) { int count = NUM_ ; long value = NUM_ ; boolean end = BOOL_ ; while ( codeIndex < codewords [ NUM_ ] && ! end ) { int code = codewords [ codeIndex ++ ] ; if ( code < TEXT_COMPACTION_MODE_LATCH ) { count ++ ; value = NUM_ . value + code ; } else { if ( code == TEXT_COMPACTION_MODE_LATCH || code == BYTE_COMPACTION_MODE_LATCH || code == NUMERIC_COMPACTION_MODE_LATCH || code == BYTE_COMPACTION_MODE_LATCH_6 || code == BEGIN_MACRO_PDF417_CONTROL_BLOCK || code == BEGIN_MACRO_PDF417_OPTIONAL_FIELD || code == MACRO_PDF417_TERMINATOR ) { codeIndex -- ; end = BOOL_ ; } } if ( ( count % NUM_ == NUM_ ) && ( count > NUM_ ) ) { char [ ] decodedData = new char [ NUM_ ] ; for ( int j = NUM_ ; j < NUM_ ; ++ j ) { decodedData [ NUM_ - j ] = ( char ) ( value & xFF ) ; value >>= NUM_ ; } result . append ( decodedData ) ; count = NUM_ ; } } } return codeIndex ; }
public int addAndGet ( T obj , int delta ) { for ( ; ; ) { int current = get ( obj ) ; int next = current + delta ; if ( compareAndSet ( obj , current , next ) ) return next ; } }
public KCResponse serve ( String uri , String method , Properties header , Properties parms , Properties files ) { return serveFile ( uri , header , myRootDir , BOOL_ ) ; }
protected void fillMemData ( Object data , int [ ] posits , int length , Object output , int outputOffset , int dim ) { if ( data instanceof Object [ ] ) { Object [ ] xo = ( Object [ ] ) data ; fillMemData ( xo [ posits [ dim ] ] , posits , length , output , outputOffset , dim + NUM_ ) ; } else { int startFrom = posits [ dim ] ; int startTo = outputOffset ; int copyLength = length ; if ( posits [ dim ] < NUM_ ) { startFrom -= posits [ dim ] ; startTo -= posits [ dim ] ; copyLength += posits [ dim ] ; } if ( posits [ dim ] + length > this . dims [ dim ] ) { copyLength -= posits [ dim ] + length - this . dims [ dim ] ; } System . arraycopy ( data , startFrom , output , startTo , copyLength ) ; } }
public Optional < String > startAsyncJob ( String jobType ) { try { final JobRunnable jobRunnable = findJobRunnable ( jobType ) ; JobInfo jobInfo = createJobInfo ( jobType ) ; repository . markJobAsRunningIfPossible ( jobInfo , mutexJobTypesFor ( jobType ) ) ; repository . createOrUpdate ( jobInfo ) ; return Optional . of ( startAsync ( metered ( jobRunnable ) , jobInfo . getJobId ( ) ) ) ; } catch ( JobBlockedException e ) { LOG . info ( e . getMessage ( ) ) ; return Optional . empty ( ) ; } }
public boolean isLegalReplacement ( byte [ ] replacement ) { if ( decoder == null ) { decoder = charset . newDecoder ( ) ; decoder . onMalformedInput ( CodingErrorAction . REPORT ) ; decoder . onUnmappableCharacter ( CodingErrorAction . REPORT ) ; } ByteBuffer in = ByteBuffer . wrap ( replacement ) ; CharBuffer out = CharBuffer . allocate ( ( int ) ( replacement . length . decoder . maxCharsPerByte ( ) ) ) ; CoderResult result = decoder . decode ( in , out , BOOL_ ) ; return ! result . isError ( ) ; }
public static void adaptTable ( ConstraintTableLayout table ) { int width = table . getWidth ( ) ; int height = table . getHeight ( ) ; ConstraintWidget . DimensionBehaviour horizontalBehaviour = table . getHorizontalDimensionBehaviour ( ) ; ConstraintWidget . DimensionBehaviour verticalBehaviour = table . getVerticalDimensionBehaviour ( ) ; table . setHorizontalDimensionBehaviour ( ConstraintWidget . DimensionBehaviour . WRAP_CONTENT ) ; table . setVerticalDimensionBehaviour ( ConstraintWidget . DimensionBehaviour . WRAP_CONTENT ) ; table . layout ( ) ; table . layout ( ) ; table . setMinWidth ( table . getWidth ( ) ) ; table . setMinHeight ( table . getHeight ( ) ) ; table . computeGuidelinesPercentPositions ( ) ; table . setHorizontalDimensionBehaviour ( horizontalBehaviour ) ; table . setVerticalDimensionBehaviour ( verticalBehaviour ) ; table . setWidth ( width < table . getMinWidth ( ) ? table . getMinWidth ( ) : width ) ; table . setHeight ( height < table . getMinHeight ( ) ? table . getMinHeight ( ) : height ) ; table . layout ( ) ; }
public static < V , C extends Collection < ? super V > > C addAll ( C c , V ... vals ) { Collections . addAll ( c , vals ) ; return c ; }
public static void addStrut ( JComponent b , int layout , int size ) { if ( size < NUM_ ) return ; b . add ( getAxis ( b , layout ) == BoxLayout . X_AXIS ? Box . createHorizontalStrut ( size ) : Box . createVerticalStrut ( size ) ) ; }
public void elementType ( String name , int model , int memberOf , int flags ) { ElementType e = new ElementType ( name , model , memberOf , flags , this ) ; theElementTypes . put ( name . toLowerCase ( ) , e ) ; if ( memberOf == M_ROOT ) theRoot = e ; }
public int arrayIndexScale ( Class clazz ) { if ( ! clazz . isArray ( ) ) { throw new IllegalArgumentException ( STR_ ) ; } return arrayIndexScale0 ( clazz ) ; }
public static StringPool readStringPool ( ByteBuffer buffer , StringPoolHeader stringPoolHeader ) { long beginPos = buffer . position ( ) ; long [ ] offsets = new long [ ( int ) stringPoolHeader . getStringCount ( ) ] ; if ( stringPoolHeader . getStringCount ( ) > NUM_ ) { for ( int idx = NUM_ ; idx < stringPoolHeader . getStringCount ( ) ; idx ++ ) { offsets [ idx ] = Buffers . readUInt ( buffer ) ; } } boolean utf8 = ( stringPoolHeader . getFlags ( ) & StringPoolHeader . UTF8_FLAG ) != NUM_ ; long stringPos = beginPos + stringPoolHeader . getStringsStart ( ) - stringPoolHeader . getHeaderSize ( ) ; buffer . position ( ( int ) stringPos ) ; StringPoolEntry [ ] entries = new StringPoolEntry [ offsets . length ] ; for ( int i = NUM_ ; i < offsets . length ; i ++ ) { entries [ i ] = new StringPoolEntry ( i , stringPos + offsets [ i ] ) ; } String lastStr = null ; long lastOffset = - NUM_ ; StringPool stringPool = new StringPool ( ( int ) stringPoolHeader . getStringCount ( ) ) ; for ( StringPoolEntry entry : entries ) { if ( entry . offset == lastOffset ) { stringPool . set ( entry . index , lastStr ) ; continue ; } buffer . position ( ( int ) entry . offset ) ; lastOffset = entry . offset ; String str = ParseUtils . readString ( buffer , utf8 ) ; lastStr = str ; stringPool . set ( entry . index , str ) ; } buffer . position ( ( int ) ( beginPos + stringPoolHeader . getBodySize ( ) ) ) ; return stringPool ; }
public String strRep ( ) { return STR_ + rankTeamPollScore + STR_ + abbr + STR_ + wins + STR_ + losses + STR_ ; }
@ Override public String toString ( ) { if ( eIsProxy ( ) ) return super . toString ( ) ; StringBuffer result = new StringBuffer ( super . toString ( ) ) ; result . append ( STR_ ) ; result . append ( kind ) ; result . append ( STR_ ) ; return result . toString ( ) ; }
public static < V > int addDistinctList ( List < V > sourceList , List < V > entryList ) { if ( sourceList == null || isEmpty ( entryList ) ) { return NUM_ ; } int sourceCount = sourceList . size ( ) ; for ( V entry : entryList ) { if ( ! sourceList . contains ( entry ) ) { sourceList . add ( entry ) ; } } return sourceList . size ( ) - sourceCount ; }
private void recordRPOperation ( DbClient dbClient , OperationTypeEnum opType , Operation . Status status , Object ... extParam ) { try { boolean opStatus = ( Operation . Status . ready == status ) ? BOOL_ : BOOL_ ; String evType ; evType = opType . getEvType ( opStatus ) ; String evDesc = opType . getDescription ( ) ; String opStage = AuditLogManager . AUDITOP_END ; _log . info ( STR_ , opType . toString ( ) , evType . toString ( ) + STR_ + evDesc ) ; recordBourneRPEvent ( dbClient , getId ( ) , evType , status , evDesc ) ; switch ( opType ) { case START_RP_LINK : case STOP_RP_LINK : case PAUSE_RP_LINK : case RESUME_RP_LINK : case FAILOVER_RP_LINK : case FAILOVER_CANCEL_RP_LINK : case CHANGE_RP_IMAGE_ACCESS_MODE : case SWAP_RP_VOLUME : AuditBlockUtil . auditBlock ( dbClient , opType , opStatus , opStage , extParam ) ; break ; default : _log . error ( STR_ ) ; } } catch ( Exception e ) { _log . error ( STR_ , opType . toString ( ) , e ) ; } }
void autoClosingClipOpened ( AutoClosingClip clip ) { if ( Printer . debug ) Printer . debug ( STR_ ) ; int index = NUM_ ; synchronized ( autoClosingClips ) { index = getAutoClosingClipIndex ( clip ) ; if ( index == - NUM_ ) { if ( Printer . debug ) Printer . debug ( STR_ + clip ) ; autoClosingClips . add ( new ClipInfo ( clip ) ) ; } } if ( index == - NUM_ ) { synchronized ( this ) { notifyAll ( ) ; } } if ( Printer . debug ) Printer . debug ( STR_ + autoClosingClips . size ( ) + STR_ ) ; }
public boolean implies ( Permission permission ) { if ( ! ( permission instanceof ExecOptionPermission ) ) return BOOL_ ; ExecOptionPermission p = ( ExecOptionPermission ) permission ; if ( all_allowed ) return BOOL_ ; String pname = p . getName ( ) ; Permission x = permissions . get ( pname ) ; if ( x != null ) return x . implies ( permission ) ; int last , offset ; offset = pname . length ( ) - NUM_ ; while ( ( last = pname . lastIndexOf ( STR_ , offset ) ) != - NUM_ ) { pname = pname . substring ( NUM_ , last + NUM_ ) + STR_ ; x = permissions . get ( pname ) ; if ( x != null ) { return x . implies ( permission ) ; } offset = last - NUM_ ; } pname = p . getName ( ) ; offset = pname . length ( ) - NUM_ ; while ( ( last = pname . lastIndexOf ( STR_ , offset ) ) != - NUM_ ) { pname = pname . substring ( NUM_ , last + NUM_ ) + STR_ ; x = permissions . get ( pname ) ; if ( x != null ) { return x . implies ( permission ) ; } offset = last - NUM_ ; } return BOOL_ ; }
public void addTailArg ( String arg ) { _tailArgs . add ( arg ) ; }
private static byte [ ] save ( Bitmap src , Bitmap . CompressFormat format , int quality ) { ByteArrayOutputStream outputStream = null ; try { outputStream = new ByteArrayOutputStream ( ) ; src . compress ( format , quality , outputStream ) ; return outputStream . toByteArray ( ) ; } finally { if ( outputStream != null ) { try { outputStream . close ( ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } } } }
public boolean isExternal ( Resource input ) { return externalResources . contains ( input ) ; }
protected final void writeD ( ByteBuffer buf , int value ) { buf . putInt ( value ) ; }
@ Override public AbstractScannedResult scanBlocklet ( BlocksChunkHolder blocksChunkHolder ) throws QueryExecutionException { try { fillScannedResult ( blocksChunkHolder ) ; } catch ( FilterUnsupportedException e ) { throw new QueryExecutionException ( e . getMessage ( ) ) ; } return scannedResult ; }
public List < ShoppingCartItem > items ( ) { List < ShoppingCartItem > result = FastList . newInstance ( ) ; result . addAll ( cartLines ) ; return result ; }
MutableBigInteger ( BigInteger b ) { intLen = b . mag . length ; value = Arrays . copyOf ( b . mag , intLen ) ; }
public boolean isHttp11 ( ) { if ( mVersion . equalsIgnoreCase ( HTTP11 ) ) { return BOOL_ ; } return BOOL_ ; }
private int readNext ( boolean charstring ) { num = ( int ) ( data [ pos ++ ] ) & xff ; if ( num == NUM_ && ! charstring ) { readFNum ( ) ; return type = FLT ; } else if ( num == NUM_ ) { num = ( ( ( int ) data [ pos ] ) << NUM_ ) + ( ( ( int ) data [ pos + NUM_ ] ) & xff ) ; pos += NUM_ ; return type = NUM ; } else if ( num == NUM_ && ! charstring ) { num = ( ( ( int ) data [ pos ] & xff ) << NUM_ ) | ( ( ( int ) data [ pos + NUM_ ] & xff ) << NUM_ ) | ( ( ( int ) data [ pos + NUM_ ] & xff ) << NUM_ ) | ( ( ( int ) data [ pos + NUM_ ] & xff ) ) ; pos += NUM_ ; return type = NUM ; } else if ( num == NUM_ ) { num = NUM_ + ( ( int ) ( data [ pos ++ ] ) & xff ) ; return type = CMD ; } else if ( num < NUM_ ) { return type = CMD ; } else if ( num < NUM_ ) { num -= NUM_ ; return type = NUM ; } else if ( num < NUM_ ) { num = ( num - NUM_ ) . NUM_ + ( ( ( int ) data [ pos ++ ] ) & xff ) + NUM_ ; return type = NUM ; } else if ( num < NUM_ ) { num = - ( num - NUM_ ) . NUM_ - ( ( ( int ) data [ pos ++ ] ) & xff ) - NUM_ ; return type = NUM ; } else if ( ! charstring ) { printData ( ) ; throw new RuntimeException ( STR_ ) ; } else { fnum = ( ( ( ( int ) data [ pos ] & xff ) << NUM_ ) | ( ( ( int ) data [ pos + NUM_ ] & xff ) << NUM_ ) | ( ( ( int ) data [ pos + NUM_ ] & xff ) << NUM_ ) | ( ( ( int ) data [ pos + NUM_ ] & xff ) ) ) / NUM_ ; pos += NUM_ ; return type = FLT ; } }
protected void deleteIcon ( ) { if ( _selectedIcon == null ) { return ; } if ( _iconMap . remove ( _selectedIcon . getName ( ) ) != null ) { removeIconFamiliesPanel ( ) ; addIconsToPanel ( _iconMap ) ; deleteIconButton . setEnabled ( BOOL_ ) ; validate ( ) ; } }
public boolean equals ( Object obj ) { if ( obj == null ) return BOOL_ ; if ( this == obj ) return BOOL_ ; if ( getClass ( ) != obj . getClass ( ) ) return BOOL_ ; ChoiceFormat other = ( ChoiceFormat ) obj ; return ( Arrays . equals ( choiceLimits , other . choiceLimits ) && Arrays . equals ( choiceFormats , other . choiceFormats ) ) ; }
private static File createReserveDiskCacheDir ( Context context ) { File cacheDir = StorageUtils . getCacheDirectory ( context , BOOL_ ) ; File individualDir = new File ( cacheDir , STR_ ) ; if ( individualDir . exists ( ) || individualDir . mkdir ( ) ) { cacheDir = individualDir ; } return cacheDir ; }
public static Date updated ( Date self , Map < Object , Integer > updates ) { Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( self ) ; set ( cal , updates ) ; return cal . getTime ( ) ; }
public boolean displayTopic ( String name ) { String topic = null ; if ( name == null ) topic = DEFAULT + FILE_TYPE ; else topic = name . toLowerCase ( ) + FILE_TYPE ; File helpFile = new File ( helpDir , topic ) ; return display ( helpFile ) ; }
private void dashToWords ( String tokenVal ) { int index = tokenVal . indexOf ( STR_ ) ; String aaa = tokenVal . substring ( NUM_ , index ) ; String bbb = tokenVal . substring ( index + NUM_ , tokenVal . length ( ) ) ; if ( matches ( digitsPattern , aaa ) && matches ( digitsPattern , bbb ) ) { FeatureSet featureSet = tokenItem . getFeatures ( ) ; featureSet . setString ( STR_ , aaa ) ; tokenToWords ( aaa ) ; wordRelation . addWord ( STR_ ) ; featureSet . setString ( STR_ , bbb ) ; tokenToWords ( bbb ) ; featureSet . setString ( STR_ , STR_ ) ; } else { tokenToWords ( aaa ) ; tokenToWords ( bbb ) ; } }
public static int numberOfTrailingZerosSigned ( long [ ] v ) { for ( int p = NUM_ ; ; p ++ ) { if ( p == v . length ) { return - NUM_ ; } if ( v [ p ] != NUM_ ) { return Long . numberOfTrailingZeros ( v [ p ] ) + p . Long . SIZE ; } } }
public static void applyWMRule ( Collection < MWMInOutBound > lines , String boundType ) { for ( MWMInOutBound line : lines ) { for ( MWMDefinition definition : MWMDefinition . getAll ( line . getCtx ( ) , line . get_TrxName ( ) ) ) { WMRuleEngine . validateDefinition ( line , definition , boundType ) ; } } }
public static float readFloat ( final JSONArray jsonArray , final int index , final boolean required , final boolean notNull ) throws JSONException { if ( required ) { return ( float ) jsonArray . getDouble ( index ) ; } if ( notNull && jsonArray . isNull ( index ) ) { throw new JSONException ( String . format ( Locale . US , NULL_VALUE_FORMAT_ARRAY , index ) ) ; } float value = NUM_ ; if ( ! jsonArray . isNull ( index ) ) { value = ( float ) jsonArray . getDouble ( index ) ; } return value ; }
public void flush ( ) throws IOException { flushBits ( ) ; out . flush ( ) ; }
public final Flux < T > onErrorResumeWith ( Predicate < ? super Throwable > predicate , Function < ? super Throwable , ? extends Publisher < ? extends T > > fallback ) { Objects . requireNonNull ( predicate , STR_ ) ; return onErrorResumeWith ( null ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return result . elements ( ) ; }
public @ Test final void testSetUsersNegative ( ) { Role role = new Role ( TEST_ROLE ) ; thrown . expect ( IllegalArgumentException . class ) ; role . setUsers ( null ) ; }
private Set < String > findResourceNames ( String path , String prefix , String suffix ) throws IOException { Set < String > resourceNames = findResourceNamesFromFileSystem ( path , new File ( path ) ) ; return filterResourceNames ( resourceNames , prefix , suffix ) ; }
public boolean add ( K key , V item ) { Set < V > values = map . get ( key ) ; if ( values == null ) { values = ( sorted ? new TreeSet < V > ( ) : new HashSet < V > ( ) ) ; map . put ( key , values ) ; } if ( item == null ) return BOOL_ ; return values . add ( item ) ; }
public void addECM ( ECMInfo info ) { ecmEffects . add ( info ) ; }
protected void loadImage ( String filePath , OMGraphicList ret ) { File file = new File ( filePath ) ; if ( file . exists ( ) && file . isDirectory ( ) ) { String [ ] files = file . list ( ) ; for ( int i = NUM_ ; i < files . length ; i ++ ) { loadImage ( filePath + STR_ + files [ i ] , ret ) ; } } else { fireStatusUpdate ( LayerStatusEvent . START_WORKING ) ; try { URL fileURL = PropUtils . getResourceOrFileOrURL ( filePath ) ; if ( fileURL != null ) { if ( imageReaderLoaders != null ) { ImageTile imageTile = null ; for ( ImageReaderLoader idl : imageReaderLoaders ) { if ( idl . isLoadable ( filePath ) ) { ImageReader id = idl . getImageReader ( fileURL ) ; ImageTile tmpImageTile = id . getImageTile ( imageCache ) ; if ( imageTile == null ) { imageTile = tmpImageTile ; } else if ( tmpImageTile != null && imageTile instanceof ErrImageTile ) { imageTile = tmpImageTile ; } if ( imageTile != null && ! ( imageTile instanceof ErrImageTile ) ) { break ; } } } if ( imageTile != null ) { addImageToLists ( imageTile , ret , fileURL ) ; } } else { logger . warning ( STR_ + getName ( ) + STR_ ) ; } } else { logger . warning ( STR_ + filePath ) ; } } catch ( MalformedURLException murle ) { } } }
@ Override protected final boolean writeData ( ByteBuffer data ) { synchronized ( guard ) { GsServerPacket packet = sendMsgQueue . pollFirst ( ) ; if ( packet == null ) { return BOOL_ ; } packet . write ( this , data ) ; return BOOL_ ; } }
public static ExportMask createExportMask ( DbClient dbClient , ExportGroup exportGroup , URI sdUri , String maskName ) throws DatabaseException { ExportMask exportMask = new ExportMask ( ) ; exportMask . setId ( URIUtil . createId ( ExportMask . class ) ) ; exportMask . setMaskName ( maskName ) ; exportMask . setStorageDevice ( sdUri ) ; dbClient . createObject ( exportMask ) ; exportGroup . addExportMask ( exportMask . getId ( ) ) ; dbClient . updateObject ( exportGroup ) ; return exportMask ; }
public LogEntry ( String timestamp , String contents ) { this . timestamp = timestamp ; this . contents = contents ; }
public static boolean cancelPotentialWork ( Object data , ImageView imageView ) { final BitmapWorkerTask bitmapWorkerTask = getBitmapWorkerTask ( imageView ) ; if ( bitmapWorkerTask != null ) { final Object bitmapData = bitmapWorkerTask . mData ; if ( bitmapData == null || ! bitmapData . equals ( data ) ) { bitmapWorkerTask . cancel ( BOOL_ ) ; if ( BuildConfig . DEBUG ) { Log . d ( TAG , STR_ + data ) ; } } else { return BOOL_ ; } } return BOOL_ ; }
void replacePolicyInResourceTree ( Policy oldPolicy , Policy newPolicy ) throws PolicyException , SSOException { removePolicyFromResourceTree ( oldPolicy ) ; addPolicyToResourceTree ( newPolicy ) ; }
private Shape [ ] createHorizontalBlock ( double x0 , double width , double y0 , double y1 , boolean inverted ) { Shape [ ] result = new Shape [ NUM_ ] ; Point2D p00 = new Point2D . Double ( y0 , x0 ) ; Point2D p01 = new Point2D . Double ( y0 , x0 + width ) ; Point2D p02 = new Point2D . Double ( p01 . getX ( ) + getXOffset ( ) , p01 . getY ( ) - getYOffset ( ) ) ; Point2D p03 = new Point2D . Double ( p00 . getX ( ) + getXOffset ( ) , p00 . getY ( ) - getYOffset ( ) ) ; Point2D p0 = new Point2D . Double ( y1 , x0 ) ; Point2D p1 = new Point2D . Double ( y1 , x0 + width ) ; Point2D p2 = new Point2D . Double ( p1 . getX ( ) + getXOffset ( ) , p1 . getY ( ) - getYOffset ( ) ) ; Point2D p3 = new Point2D . Double ( p0 . getX ( ) + getXOffset ( ) , p0 . getY ( ) - getYOffset ( ) ) ; GeneralPath bottom = new GeneralPath ( ) ; bottom . moveTo ( ( float ) p1 . getX ( ) , ( float ) p1 . getY ( ) ) ; bottom . lineTo ( ( float ) p01 . getX ( ) , ( float ) p01 . getY ( ) ) ; bottom . lineTo ( ( float ) p02 . getX ( ) , ( float ) p02 . getY ( ) ) ; bottom . lineTo ( ( float ) p2 . getX ( ) , ( float ) p2 . getY ( ) ) ; bottom . closePath ( ) ; GeneralPath top = new GeneralPath ( ) ; top . moveTo ( ( float ) p0 . getX ( ) , ( float ) p0 . getY ( ) ) ; top . lineTo ( ( float ) p00 . getX ( ) , ( float ) p00 . getY ( ) ) ; top . lineTo ( ( float ) p03 . getX ( ) , ( float ) p03 . getY ( ) ) ; top . lineTo ( ( float ) p3 . getX ( ) , ( float ) p3 . getY ( ) ) ; top . closePath ( ) ; GeneralPath back = new GeneralPath ( ) ; back . moveTo ( ( float ) p2 . getX ( ) , ( float ) p2 . getY ( ) ) ; back . lineTo ( ( float ) p02 . getX ( ) , ( float ) p02 . getY ( ) ) ; back . lineTo ( ( float ) p03 . getX ( ) , ( float ) p03 . getY ( ) ) ; back . lineTo ( ( float ) p3 . getX ( ) , ( float ) p3 . getY ( ) ) ; back . closePath ( ) ; GeneralPath front = new GeneralPath ( ) ; front . moveTo ( ( float ) p0 . getX ( ) , ( float ) p0 . getY ( ) ) ; front . lineTo ( ( float ) p1 . getX ( ) , ( float ) p1 . getY ( ) ) ; front . lineTo ( ( float ) p01 . getX ( ) , ( float ) p01 . getY ( ) ) ; front . lineTo ( ( float ) p00 . getX ( ) , ( float ) p00 . getY ( ) ) ; front . closePath ( ) ; GeneralPath left = new GeneralPath ( ) ; left . moveTo ( ( float ) p0 . getX ( ) , ( float ) p0 . getY ( ) ) ; left . lineTo ( ( float ) p1 . getX ( ) , ( float ) p1 . getY ( ) ) ; left . lineTo ( ( float ) p2 . getX ( ) , ( float ) p2 . getY ( ) ) ; left . lineTo ( ( float ) p3 . getX ( ) , ( float ) p3 . getY ( ) ) ; left . closePath ( ) ; GeneralPath right = new GeneralPath ( ) ; right . moveTo ( ( float ) p00 . getX ( ) , ( float ) p00 . getY ( ) ) ; right . lineTo ( ( float ) p01 . getX ( ) , ( float ) p01 . getY ( ) ) ; right . lineTo ( ( float ) p02 . getX ( ) , ( float ) p02 . getY ( ) ) ; right . lineTo ( ( float ) p03 . getX ( ) , ( float ) p03 . getY ( ) ) ; right . closePath ( ) ; result [ NUM_ ] = bottom ; result [ NUM_ ] = back ; if ( inverted ) { result [ NUM_ ] = right ; result [ NUM_ ] = left ; } else { result [ NUM_ ] = left ; result [ NUM_ ] = right ; } result [ NUM_ ] = top ; result [ NUM_ ] = front ; return result ; }
public OIDCTokens acquireTokensBySecurID ( String username , String passcode , SecurIDRetriever securIdRetriever , TokenSpec tokenSpec ) throws OIDCClientException , OIDCServerException , TokenValidationException , SSLConnectionException { Validate . notEmpty ( username , STR_ ) ; Validate . notEmpty ( passcode , STR_ ) ; Validate . notNull ( securIdRetriever , STR_ ) ; Validate . notNull ( tokenSpec , STR_ ) ; HttpResponse httpResponse = OIDCClientUtils . handleSecurIDMultiLeggedGrant ( username , passcode , securIdRetriever , tokenSpec , getTokenEndpointURI ( ) , this . clientId , this . holderOfKeyConfig , this . keyStore ) ; return OIDCClientUtils . parseTokenResponse ( httpResponse , this . providerPublicKey , this . issuer , this . clientId , this . clockToleranceInSeconds ) ; }
public void loadNested ( Environment env ) { loadNested ( env , NUM_ ) ; }
private JSONArray requestAllFileSystems ( ) throws IOException , JSONException { JSONArray ret = new JSONArray ( ) ; for ( Filesystem fs : filesystems ) { ret . put ( fs . getRootEntry ( ) ) ; } return ret ; }
private Promise < ActionResponse , ResourceException > internalHandleAction ( String tokenId , Context context , ActionRequest request ) { final String action = request . getAction ( ) ; final ActionHandler actionHandler = actionHandlers . get ( action ) ; if ( actionHandler != null ) { return actionHandler . handle ( tokenId , context , request ) ; } else { String message = String . format ( STR_ , action ) ; NotSupportedException e = new NotSupportedException ( message ) ; if ( LOGGER . messageEnabled ( ) ) { LOGGER . message ( STR_ + message , e ) ; } return e . asPromise ( ) ; } }
public int compareTo ( Object obj ) { int diff = - NUM_ ; if ( obj instanceof ParserNotice ) { ParserNotice p2 = ( ParserNotice ) obj ; diff = level - p2 . getLevel ( ) ; if ( diff == NUM_ ) { diff = line - p2 . getLine ( ) ; if ( diff == NUM_ ) { diff = message . compareTo ( p2 . getMessage ( ) ) ; } } } return diff ; }
@ Override @ SuppressWarnings ( STR_ ) public NamedList < Object > doHighlighting ( DocList docs , Query query , SolrQueryRequest req , String [ ] defaultFields ) throws IOException { SolrParams params = req . getParams ( ) ; if ( ! isHighlightingEnabled ( params ) ) return null ; SolrIndexSearcher searcher = req . getSearcher ( ) ; IndexSchema schema = searcher . getSchema ( ) ; NamedList fragments = new SimpleOrderedMap ( ) ; String [ ] fieldNames = getHighlightFields ( query , req , defaultFields ) ; Set < String > fset = new HashSet < > ( ) ; { for ( String f : fieldNames ) { fset . add ( f ) ; } SchemaField keyField = schema . getUniqueKeyField ( ) ; if ( null != keyField ) fset . add ( keyField . getName ( ) ) ; } FastVectorHighlighter fvh = new FastVectorHighlighter ( params . getBool ( HighlightParams . USE_PHRASE_HIGHLIGHTER , BOOL_ ) , params . getBool ( HighlightParams . FIELD_MATCH , BOOL_ ) ) ; fvh . setPhraseLimit ( params . getInt ( HighlightParams . PHRASE_LIMIT , SolrHighlighter . DEFAULT_PHRASE_LIMIT ) ) ; FieldQuery fieldQuery = fvh . getFieldQuery ( query , searcher . getIndexReader ( ) ) ; DocIterator iterator = docs . iterator ( ) ; for ( int i = NUM_ ; i < docs . size ( ) ; i ++ ) { int docId = iterator . nextDoc ( ) ; Document doc = searcher . doc ( docId , fset ) ; NamedList docSummaries = new SimpleOrderedMap ( ) ; for ( String fieldName : fieldNames ) { fieldName = fieldName . trim ( ) ; if ( useFastVectorHighlighter ( params , schema , fieldName ) ) doHighlightingByFastVectorHighlighter ( fvh , fieldQuery , req , docSummaries , docId , doc , fieldName ) ; else doHighlightingByHighlighter ( query , req , docSummaries , docId , doc , fieldName ) ; } String printId = schema . printableUniqueKey ( doc ) ; fragments . add ( printId == null ? null : printId , docSummaries ) ; } return fragments ; }
protected abstract Map < Integer , FilterOperationDelegateInvoker > doGetInvokerLookup ( ) ;
private IBindingSet aggregate ( final Iterable < IBindingSet > solutions ) { final IBindingSet aggregates = new ContextBindingSet ( context , new ListBindingSet ( ) ) ; if ( groupBy != null ) { final IBindingSet aSolution = solutions . iterator ( ) . next ( ) ; for ( IValueExpression < ? > expr : groupBy ) { if ( expr instanceof IVariable < ? > ) { final IVariable < ? > var = ( IVariable < ? > ) expr ; final Object varValue = var . get ( aSolution ) ; final Constant < ? > val ; if ( varValue == null ) { val = Constant . errorValue ( ) ; } else { val = new Constant ( varValue . getClass ( ) . cast ( varValue ) ) ; } ; aggregates . set ( var , val ) ; } else if ( expr instanceof IBind < ? > ) { final IBind < ? > bindExpr = ( IBind < ? > ) expr ; final Constant < ? > val ; final Object exprValue = bindExpr . get ( aSolution ) ; if ( exprValue == null ) { val = Constant . errorValue ( ) ; } else { val = new Constant ( exprValue . getClass ( ) . cast ( exprValue ) ) ; } final IVariable < ? > ovar = ( ( IBind < ? > ) expr ) . getVar ( ) ; aggregates . set ( ovar , val ) ; } } } { final boolean nestedAggregates = groupByState . isNestedAggregates ( ) ; final Iterator < Map . Entry < IAggregate < ? > , IVariable < ? > > > itr = rewrite . getAggExpr ( ) . entrySet ( ) . iterator ( ) ; while ( itr . hasNext ( ) ) { final Map . Entry < IAggregate < ? > , IVariable < ? > > e = itr . next ( ) ; doAggregate ( e . getKey ( ) , e . getValue ( ) , nestedAggregates , aggregates , solutions , stats ) ; } if ( log . isTraceEnabled ( ) ) log . trace ( STR_ + aggregates ) ; } for ( IValueExpression < ? > expr : rewrite . getSelect2 ( ) ) { try { expr . get ( aggregates ) ; } catch ( SparqlTypeErrorException ex ) { TypeErrorLog . handleTypeError ( ex , expr , stats ) ; continue ; } catch ( IllegalArgumentException ex ) { TypeErrorLog . handleTypeError ( ex , expr , stats ) ; continue ; } } { final boolean drop ; final IConstraint [ ] having2 = rewrite . getHaving2 ( ) ; if ( having2 != null && ! BOpUtility . isConsistent ( having2 , aggregates ) ) { drop = BOOL_ ; } else { drop = BOOL_ ; } if ( log . isInfoEnabled ( ) ) log . info ( ( drop ? STR_ : STR_ ) + STR_ + aggregates ) ; if ( drop ) { return null ; } } final IBindingSet out ; if ( groupBy == null ) { assert ! aggregates . containsErrorValues ( ) ; out = aggregates . copy ( groupByState . getSelectVars ( ) . toArray ( new IVariable [ NUM_ ] ) ) ; } else { out = aggregates . copyMinusErrors ( groupByState . getSelectVars ( ) . toArray ( new IVariable [ NUM_ ] ) ) ; } return out ; }
public static void deleteCollection ( String host , String collection ) throws Exception { String deleteCollectionTemplate = STR_ ; String deleteCollectionCommand = String . format ( deleteCollectionTemplate , host , DEFAULT_SOLR_PORT , collection ) ; executeSolrCommand ( deleteCollectionCommand ) ; }
private Iterable < FragmentConstructor > createConstructors ( ) { return Collections . unmodifiableList ( Arrays . asList ( new BiomeDataConstructor ( Resolution . QUARTER ) , new EndIslandsConstructor ( ) , new ImageConstructor ( Resolution . QUARTER , LayerIds . BACKGROUND ) , new ImageConstructor ( Resolution . CHUNK , LayerIds . SLIME ) ) ) ; }
public static < T > int copy ( final List < T > from , int first , int last , List < T > to ) { int i = first ; for ( ; i < last ; i ++ ) { to . add ( from . get ( i ) ) ; } return i ; }
@ Nullable public static HKey psiKey ( @ NotNull PsiMethod psiMethod , @ NotNull Direction direction , @ NotNull MessageDigest md ) { final PsiClass psiClass = PsiTreeUtil . getParentOfType ( psiMethod , PsiClass . class , BOOL_ ) ; if ( psiClass == null ) { return null ; } byte [ ] classDigest = psiClassDigest ( psiClass , md ) ; if ( classDigest == null ) { return null ; } byte [ ] sigDigest = methodDigest ( psiMethod , md ) ; if ( sigDigest == null ) { return null ; } byte [ ] digest = new byte [ HASH_SIZE ] ; System . arraycopy ( classDigest , NUM_ , digest , NUM_ , CLASS_HASH_SIZE ) ; System . arraycopy ( sigDigest , NUM_ , digest , CLASS_HASH_SIZE , SIGNATURE_HASH_SIZE ) ; return new HKey ( digest , mkDirectionKey ( direction ) , BOOL_ ) ; }
public static boolean isSdCardMounted ( ) { String status = Environment . getExternalStorageState ( ) ; if ( status . equals ( Environment . MEDIA_MOUNTED ) ) return BOOL_ ; return BOOL_ ; }
private void parseResource ( final Element resourceElement , final Collection < Resource > resources ) { final String tagName = resourceElement . getTagName ( ) ; final String uri = resourceElement . getTextContent ( ) ; if ( TAG_GROUP_REF . equals ( tagName ) ) { resources . addAll ( getResourcesForGroup ( uri ) ) ; } if ( getResourceType ( resourceElement ) != null ) { final Resource resource = createResource ( resourceElement ) ; LOG . debug ( STR_ , resource ) ; resources . add ( resource ) ; } }
@ Override public void licenceFile ( String textToShow , File licenceFile ) throws CancelException { try { final FileInputStream content = new FileInputStream ( licenceFile ) ; final StringWriter writer = new StringWriter ( ) ; IOUtils . copy ( content , writer , STR_ ) ; content . close ( ) ; licence ( textToShow , writer . toString ( ) ) ; } catch ( IOException e ) { throw new ScriptFailureException ( STR_ , e ) ; } }
public int meanAllocation ( ) { if ( m_slotAllocations == NUM_ ) return NUM_ ; return ( int ) ( m_sizeAllocations / m_slotAllocations ) ; }
public void testTimeZones ( ) throws Exception { Map < String , String > tzMap = new HashMap < String , String > ( ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; tzMap . put ( STR_ , STR_ ) ; for ( String key : tzMap . keySet ( ) ) { assertEquals ( STR_ + key + STR_ , tzMap . get ( key ) , TimeUtil . getCanonicalTimezone ( key , null ) ) ; } for ( String tz : TimeZone . getAvailableIDs ( ) ) { String canonicalTZ ; try { canonicalTZ = TimeUtil . getCanonicalTimezone ( tz , null ) ; } catch ( SQLException e ) { canonicalTZ = null ; } assertNotNull ( STR_ + tz + STR_ , canonicalTZ ) ; } }
@ Override public String toString ( ) { return MessageFormat . format ( STR_ + STR_ + STR_ , getLDAPFilter ( ) , StringUtils . join ( requestedAttributes , STR_ ) ) ; }
public void testCase6 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int bSign = - NUM_ ; byte rBytes [ ] = { - NUM_ , - NUM_ , - NUM_ , NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . multiply ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , - NUM_ , result . signum ( ) ) ; }
public void animateProgressFill ( int animateTo ) { mAnimationHandler . removeMessages ( NUM_ ) ; if ( animateTo > mMax || animateTo < NUM_ ) { throw new IllegalArgumentException ( String . format ( STR_ , animateTo , mMax ) ) ; } mAnimationHandler . setAnimateTo ( animateTo ) ; mAnimationHandler . sendEmptyMessage ( NUM_ ) ; invalidate ( ) ; }
static boolean isRegistered ( ObjectName objectName ) { Set < ObjectName > registeredObjectNames = mBeanServer . queryNames ( objectName , null ) ; return ! registeredObjectNames . isEmpty ( ) ; }
public < T > PushableLazyFutureStream < T > futureStream ( final LazyReact s ) { final Queue < T > q = createQueue ( ) ; return new PushableLazyFutureStream < T > ( q , s . fromStream ( q . stream ( ) ) ) ; }
public byte [ ] convertHexStringToBinary ( String hexString ) throws IllegalArgumentException { int length = hexString . length ( ) ; if ( length % NUM_ != NUM_ ) { throw new IllegalArgumentException ( STR_ + length + STR_ + hexString ) ; } byte [ ] binary = new byte [ length / NUM_ ] ; for ( int i = NUM_ ; i < length ; i += NUM_ ) { char highBitsChar = hexString . charAt ( i ) ; char lowBitsChar = hexString . charAt ( i + NUM_ ) ; int highBits = hexCharToInt ( highBitsChar , hexString ) << NUM_ ; int lowBits = hexCharToInt ( lowBitsChar , hexString ) ; binary [ i / NUM_ ] = ( byte ) ( highBits + lowBits ) ; } return binary ; }
public void writeField ( final String name , final short value ) throws java . io . IOException { writeField ( name , Short . toString ( value ) ) ; }
public static ResultSet select ( Connection conn , String sql ) throws SQLException { Statement stat = conn . createStatement ( ResultSet . TYPE_SCROLL_INSENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; return stat . executeQuery ( sql ) ; }
public static void writeSetOfLongs ( Set set , boolean hasLongIDs , DataOutput out ) throws IOException { if ( set == null ) { out . writeInt ( - NUM_ ) ; } else { out . writeInt ( set . size ( ) ) ; out . writeBoolean ( hasLongIDs ) ; for ( Iterator it = set . iterator ( ) ; it . hasNext ( ) ; ) { Long l = ( Long ) it . next ( ) ; if ( hasLongIDs ) { out . writeLong ( l . longValue ( ) ) ; } else { out . writeInt ( ( int ) l . longValue ( ) ) ; } } } }
private void restoreWidget ( Key key , byte [ ] buffer , int dataSize ) throws IOException { if ( VERBOSE ) Log . v ( TAG , STR_ + key . id ) ; if ( DEBUG ) Log . d ( TAG , STR_ + buffer . length + STR_ + Base64 . encodeToString ( buffer , NUM_ , dataSize , Base64 . NO_WRAP ) ) ; Widget widget = unpackProto ( new Widget ( ) , buffer , dataSize ) ; if ( DEBUG ) Log . d ( TAG , STR_ + widget . provider ) ; if ( widget . icon . data != null ) { Bitmap icon = BitmapFactory . decodeByteArray ( widget . icon . data , NUM_ , widget . icon . data . length ) ; if ( icon == null ) { Log . w ( TAG , STR_ + key . name ) ; } else { mIconCache . preloadIcon ( ComponentName . unflattenFromString ( widget . provider ) , icon , widget . icon . dpi , widget . label , mUserSerial , mIdp ) ; } } widgetSizes . add ( widget . provider + STR_ + NUM_ + STR_ + NUM_ ) ; }
private static boolean hasResponseBody ( int requestMethod , int responseCode ) { return requestMethod != Request . Method . HEAD && ! ( HttpStatus . SC_CONTINUE <= responseCode && responseCode < HttpStatus . SC_OK ) && responseCode != HttpStatus . SC_NO_CONTENT && responseCode != HttpStatus . SC_NOT_MODIFIED ; }
public void considerRegionXRegion ( GeoRegion r , GeoRegion region ) { GeoArray rBoundary = r . getPoints ( ) ; Geo rPoint = rBoundary . get ( NUM_ , new Geo ( ) ) ; GeoArray regionBoundary = region . getPoints ( ) ; Geo regionPoint = regionBoundary . get ( NUM_ , new Geo ( ) ) ; if ( Intersection . isPointInPolygon ( rPoint , regionBoundary ) || Intersection . isPointInPolygon ( regionPoint , rBoundary ) ) { collector . collect ( r , region ) ; } else { for ( GeoPath . SegmentIterator pit = r . segmentIterator ( ) ; pit . hasNext ( ) ; ) { GeoSegment seg = pit . nextSegment ( ) ; if ( filter . preConsider ( seg , region ) && considerSegmentXRegion ( seg , region ) ) { collector . collect ( seg , region ) ; return ; } } } }
private XPathFactory loadFromServicesFile ( String uri , String resourceName , InputStream in ) { if ( debug ) debugPrintln ( STR_ + resourceName ) ; BufferedReader rd ; try { rd = new BufferedReader ( new InputStreamReader ( in , STR_ ) , DEFAULT_LINE_LENGTH ) ; } catch ( java . io . UnsupportedEncodingException e ) { rd = new BufferedReader ( new InputStreamReader ( in ) , DEFAULT_LINE_LENGTH ) ; } String factoryClassName ; XPathFactory resultFactory = null ; while ( BOOL_ ) { try { factoryClassName = rd . readLine ( ) ; } catch ( IOException x ) { break ; } if ( factoryClassName != null ) { int hashIndex = factoryClassName . indexOf ( STR_ ) ; if ( hashIndex != - NUM_ ) { factoryClassName = factoryClassName . substring ( NUM_ , hashIndex ) ; } factoryClassName = factoryClassName . trim ( ) ; if ( factoryClassName . length ( ) == NUM_ ) { continue ; } try { XPathFactory foundFactory = createInstance ( factoryClassName ) ; if ( foundFactory . isObjectModelSupported ( uri ) ) { resultFactory = foundFactory ; break ; } } catch ( Exception ignored ) { } } else { break ; } } IoUtils . closeQuietly ( rd ) ; return resultFactory ; }
private char foldCase ( char ch ) { if ( ch < NUM_ ) { if ( STR_ <= ch && ch <= STR_ ) { return ( char ) ( ch + ( STR_ - STR_ ) ) ; } return ch ; } return Character . toLowerCase ( Character . toUpperCase ( ch ) ) ; }
public WritableRaster createCompatibleWritableRaster ( int w , int h ) { if ( w <= NUM_ || h <= NUM_ ) { throw new RasterFormatException ( STR_ + ( ( w <= NUM_ ) ? STR_ : STR_ ) ) ; } SampleModel sm = sampleModel . createCompatibleSampleModel ( w , h ) ; return new ByteBandedRaster ( sm , new Point ( NUM_ , NUM_ ) ) ; }
ConfigurationError ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; }
@ TargetApi ( VERSION_CODES . LOLLIPOP ) public static void reveal ( final View view , int cx , int cy ) { if ( ! hasLollipop ( ) ) { view . setVisibility ( View . VISIBLE ) ; return ; } int finalRadius = Math . max ( view . getWidth ( ) , view . getHeight ( ) ) ; Animator animator = ViewAnimationUtils . createCircularReveal ( view , cx , cy , NUM_ , finalRadius ) ; view . setVisibility ( View . VISIBLE ) ; animator . start ( ) ; }
public TopNMetric ( TopNMetricType type , String previousStop , SortDirection order ) { this ( type , previousStop ) ; if ( order == SortDirection . ASC ) { this . type = TopNMetricType . INVERTED ; this . nested = Optional . of ( new TopNMetric ( type , previousStop ) ) ; this . previousStop = Optional . empty ( ) ; } }
public void removeSupportedOptions ( Set < String > unmatchedProcessorOptions ) { unmatchedProcessorOptions . removeAll ( supportedOptionNames ) ; }
protected void subscribe ( ) { if ( sampleClientSub == null ) { try { sampleClientSub = new SampleAsyncCallback ( url , clientIdSub , cleanSession , quietMode , userName , password ) ; } catch ( MqttException e ) { e . printStackTrace ( ) ; } } if ( sampleClientSub != null ) { String topic = STR_ ; int qos = NUM_ ; try { sampleClientSub . subscribe ( topic , qos ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; } } }
private boolean shouldCrop ( int width , int height ) { int pixelError = NUM_ ; pixelError += Math . round ( Math . max ( width , height ) / NUM_ ) ; return ( mMaxResultImageSizeX > NUM_ && mMaxResultImageSizeY > NUM_ ) || Math . abs ( mCropRect . left - mCurrentImageRect . left ) > pixelError || Math . abs ( mCropRect . top - mCurrentImageRect . top ) > pixelError || Math . abs ( mCropRect . bottom - mCurrentImageRect . bottom ) > pixelError || Math . abs ( mCropRect . right - mCurrentImageRect . right ) > pixelError ; }
public boolean exists ( ) { return doAccess ( F_OK ) ; }
@ Deprecated public boolean isFillBelowLine ( ) { return mFillBelowLine . size ( ) > NUM_ ; }
public ShapeTileBox bounding_box ( ) { if ( bounding_box != null ) return bounding_box ; PlaPointFloat start_corner = start_point_approx ( ) ; PlaPointFloat end_corner = end_point_approx ( ) ; double llx = Math . min ( start_corner . v_x , end_corner . v_x ) ; double lly = Math . min ( start_corner . v_y , end_corner . v_y ) ; double urx = Math . max ( start_corner . v_x , end_corner . v_x ) ; double ury = Math . max ( start_corner . v_y , end_corner . v_y ) ; PlaPointInt lower_left = new PlaPointInt ( Math . floor ( llx ) , Math . floor ( lly ) ) ; PlaPointInt upper_right = new PlaPointInt ( Math . ceil ( urx ) , Math . ceil ( ury ) ) ; bounding_box = new ShapeTileBox ( lower_left , upper_right ) ; return bounding_box ; }
public boolean isValidAttachmentPoint ( DatapathId switchDPID , OFPort switchPort ) { if ( topology . isAttachmentPointPort ( switchDPID , switchPort ) == BOOL_ ) return BOOL_ ; if ( suppressAPs . contains ( new SwitchPort ( switchDPID , switchPort ) ) ) return BOOL_ ; return BOOL_ ; }
public void testClasspathWar ( ) throws Exception { final URL url = new URL ( STR_ + System . getProperty ( STR_ ) + STR_ ) ; final String expected = STR_ ; PingUtils . assertPingTrue ( url . getPath ( ) + STR_ , expected , url , logger ) ; }
protected abstract boolean isNullable ( ) ;
public vec3 normalize ( ) { float x = this . m [ NUM_ ] ; float y = this . m [ NUM_ ] ; float z = this . m [ NUM_ ] ; float s = NUM_ / ( float ) Math . sqrt ( x . x + y . y + z . z ) ; this . m [ NUM_ ] = x . s ; this . m [ NUM_ ] = y . s ; this . m [ NUM_ ] = z . s ; return this ; }
public void addActionListener ( ActionListener listener ) { forwardProjectionButton . addActionListener ( listener ) ; backProjectionButton . addActionListener ( listener ) ; }
void writeDataToFileLocked ( RandomAccessFile file , boolean addMayo , boolean addTomato , int whichFilling ) throws IOException { file . setLength ( NUM_ ) ; file . writeInt ( whichFilling ) ; file . writeBoolean ( addMayo ) ; file . writeBoolean ( addTomato ) ; Log . v ( TAG , STR_ + addMayo + STR_ + addTomato + STR_ + whichFilling ) ; }
static Type [ ] mapKeyAndValueTypes ( Type context , Class < ? > contextRawType ) { if ( context == Properties . class ) return new Type [ ] { String . class , String . class } ; Type mapType = getSupertype ( context , contextRawType , Map . class ) ; if ( mapType instanceof ParameterizedType ) { ParameterizedType mapParameterizedType = ( ParameterizedType ) mapType ; return mapParameterizedType . getActualTypeArguments ( ) ; } return new Type [ ] { Object . class , Object . class } ; }
static AggregatedHttpMessage of ( HttpHeaders headers , HttpData content , HttpHeaders trailingHeaders ) { return of ( Collections . emptyList ( ) , headers , content , trailingHeaders ) ; }
public static boolean isLetter ( char c ) { return Character . isLetter ( c ) ; }
protected List < TreeNode > createChildList ( ) { Branch branch = getXmlBranch ( ) ; int size = branch . nodeCount ( ) ; List < TreeNode > childList = new ArrayList < TreeNode > ( size ) ; for ( int i = NUM_ ; i < size ; i ++ ) { Node node = branch . node ( i ) ; if ( node instanceof CharacterData ) { String text = node . getText ( ) ; if ( text == null ) { continue ; } text = text . trim ( ) ; if ( text . length ( ) <= NUM_ ) { continue ; } } childList . add ( createChildTreeNode ( node ) ) ; } return childList ; }
public Set < Value > mayAliases ( Value v , Unit u ) { Set < Value > res = new HashSet < Value > ( ) ; Set < Set < Value > > flow = getFlowBefore ( u ) ; for ( Set < Value > set : flow ) { if ( set . contains ( v ) ) res . addAll ( set ) ; } return res ; }
@ Nullable private static String read ( @ NonNull SocketChannel socket , @ NonNull byte [ ] buffer ) throws IOException { ByteBuffer buf = ByteBuffer . wrap ( buffer , NUM_ , buffer . length ) ; while ( buf . position ( ) != buf . limit ( ) ) { int count ; count = socket . read ( buf ) ; if ( count < NUM_ ) { throw new IOException ( STR_ ) ; } } try { return new String ( buffer , NUM_ , buf . position ( ) , AdbHelper . DEFAULT_ENCODING ) ; } catch ( UnsupportedEncodingException e ) { return null ; } }
public static DateTimeUnit createLocalDateUnitInstance ( Date date , org . hisp . dhis . calendar . Calendar calendar ) { return calendar . fromIso ( DateTimeUnit . fromJdkDate ( date ) ) ; }
public static boolean equal ( double a , double b ) { return ( Math . abs ( a - b ) < EPSILON ) ; }
@ Override public void addClassAnnotation ( char [ ] buffer , int offset , int length ) { String annType = new String ( buffer , offset , length ) ; if ( _annTypes . contains ( annType ) ) { addClass ( _className ) ; } }
public Process exec ( String [ ] taintedCommand , String [ ] taintedEnvironment , File workingDirectory , boolean redirectErrorStream ) throws IOException { if ( taintedCommand == null ) { throw new NullPointerException ( STR_ ) ; } if ( taintedCommand . length == NUM_ ) { throw new IndexOutOfBoundsException ( STR_ ) ; } String [ ] command = taintedCommand . clone ( ) ; String [ ] environment = taintedEnvironment != null ? taintedEnvironment . clone ( ) : null ; for ( int i = NUM_ ; i < command . length ; i ++ ) { if ( command [ i ] == null ) { throw new NullPointerException ( STR_ + i + STR_ ) ; } } if ( environment != null ) { for ( int i = NUM_ ; i < environment . length ; i ++ ) { if ( environment [ i ] == null ) { throw new NullPointerException ( STR_ + i + STR_ ) ; } } } FileDescriptor in = new FileDescriptor ( ) ; FileDescriptor out = new FileDescriptor ( ) ; FileDescriptor err = new FileDescriptor ( ) ; String workingPath = ( workingDirectory == null ) ? null : workingDirectory . getPath ( ) ; synchronized ( processReferences ) { int pid ; try { pid = exec ( command , environment , workingPath , in , out , err , redirectErrorStream ) ; } catch ( IOException e ) { IOException wrapper = new IOException ( STR_ + STR_ + Arrays . toString ( command ) + STR_ + workingDirectory + STR_ + Arrays . toString ( environment ) ) ; wrapper . initCause ( e ) ; throw wrapper ; } ProcessImpl process = new ProcessImpl ( pid , in , out , err ) ; ProcessReference processReference = new ProcessReference ( process , referenceQueue ) ; processReferences . put ( pid , processReference ) ; processReferences . notifyAll ( ) ; return process ; } }
static PathPart makeAbsolute ( PathPart oldPart ) { @ SuppressWarnings ( STR_ ) boolean encodedCached = oldPart . encoded != NOT_CACHED ; String oldPath = encodedCached ? oldPart . encoded : oldPart . decoded ; if ( oldPath == null || oldPath . length ( ) == NUM_ || oldPath . startsWith ( STR_ ) ) { return oldPart ; } String newEncoded = encodedCached ? STR_ + oldPart . encoded : NOT_CACHED ; @ SuppressWarnings ( STR_ ) boolean decodedCached = oldPart . decoded != NOT_CACHED ; String newDecoded = decodedCached ? STR_ + oldPart . decoded : NOT_CACHED ; return new PathPart ( newEncoded , newDecoded ) ; }
public static int [ ] splitGt ( String gt ) { final int gtlen = gt . length ( ) ; if ( gtlen == NUM_ ) { return new int [ ] { alleleId ( gt . charAt ( NUM_ ) ) } ; } else { int [ ] result = new int [ NUM_ ] ; int ploid = NUM_ ; int allelestart = NUM_ ; for ( int i = NUM_ ; i < gtlen ; i ++ ) { final char c = gt . charAt ( i ) ; if ( c == PHASED_SEPARATOR || c == UNPHASED_SEPARATOR ) { if ( ploid == result . length ) { result = Arrays . copyOf ( result , result . length + NUM_ ) ; } result [ ploid ++ ] = alleleId ( gt , allelestart , i - allelestart ) ; allelestart = i + NUM_ ; } } if ( allelestart < gtlen ) { if ( ploid == result . length ) { result = Arrays . copyOf ( result , result . length + NUM_ ) ; } result [ ploid ++ ] = alleleId ( gt , allelestart , gtlen - allelestart ) ; } if ( ploid < result . length ) { result = Arrays . copyOf ( result , ploid ) ; } if ( ploid == NUM_ ) { throw new NumberFormatException ( STR_ + gt + STR_ ) ; } return result ; } }
public void testBug18041 ( ) throws Exception { if ( versionMeetsMinimum ( NUM_ , NUM_ ) ) { createTable ( STR_ , STR_ ) ; Properties props = new Properties ( ) ; props . setProperty ( STR_ , STR_ ) ; props . setProperty ( STR_ , STR_ ) ; Connection truncConn = null ; PreparedStatement stm = null ; try { truncConn = getConnectionWithProps ( props ) ; stm = truncConn . prepareStatement ( STR_ ) ; stm . setInt ( NUM_ , NUM_ ) ; stm . setString ( NUM_ , STR_ ) ; stm . executeUpdate ( ) ; fail ( STR_ ) ; } catch ( DataTruncation truncEx ) { } finally { if ( truncConn != null ) { truncConn . close ( ) ; } } } }
public void deleteKernel ( String name ) { Kernel kernel = getKernelByName ( name ) ; if ( kernel != null ) { kernel . dispose ( ) ; Integer oldSize = Integer . valueOf ( _kernelHashTable . size ( ) ) ; _kernelHashTable . remove ( name ) ; setDirtyAndFirePropertyChange ( KERNEL_LISTLENGTH_CHANGED_PROPERTY , oldSize , Integer . valueOf ( _kernelHashTable . size ( ) ) ) ; } }
protected boolean shouldStop ( ) { return isPaused ( ) || isKilled ( ) ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
public Builder addTokenFilter ( String name , Map < String , String > params ) throws IOException { Objects . requireNonNull ( name , STR_ ) ; tokenFilters . add ( applyResourceLoader ( TokenFilterFactory . forName ( name , applyDefaultParams ( params ) ) ) ) ; componentsAdded = BOOL_ ; return this ; }
public StyledToolTipUI ( Style style ) { this . style = style ; border = BorderFactory . createLineBorder ( style . getShadowColor ( ) ) ; }
public final void addElements ( Object value , int numberOfElements ) { if ( ( m_firstFree + numberOfElements ) >= m_mapSize ) { m_mapSize += ( m_blocksize + numberOfElements ) ; Object newMap [ ] = new Object [ m_mapSize ] ; System . arraycopy ( m_map , NUM_ , newMap , NUM_ , m_firstFree + NUM_ ) ; m_map = newMap ; } for ( int i = NUM_ ; i < numberOfElements ; i ++ ) { m_map [ m_firstFree ] = value ; m_firstFree ++ ; } }
public void actionPerformed ( ActionEvent e ) { super . actionPerformed ( e ) ; String cmd = e . getActionCommand ( ) ; if ( cmd == showMapsCommand ) { JCheckBox mapCheck = ( JCheckBox ) e . getSource ( ) ; viewAttributes . showMaps = mapCheck . isSelected ( ) ; repaint ( ) ; } else if ( cmd == showInfoCommand ) { JCheckBox infoCheck = ( JCheckBox ) e . getSource ( ) ; boolean showInfo = infoCheck . isSelected ( ) ; viewAttributes . showInfo = showInfo ; showSubframes ( showInfo ) ; doPrepare ( ) ; } else if ( cmd == lockSeriesCommand ) { JCheckBox lockCheck = ( JCheckBox ) e . getSource ( ) ; boolean locked = lockCheck . isSelected ( ) ; if ( locked ) { List < RpfCoverageBox > coverageBoxes = getCoverageBoxes ( ) ; String seriesName ; if ( coverageBoxes == null || coverageBoxes . isEmpty ( ) ) { seriesName = RpfViewAttributes . ANY ; } else { seriesName = coverageBoxes . get ( NUM_ ) . chartCode ; } if ( seriesName == null ) { seriesName = RpfViewAttributes . ANY ; fireRequestMessage ( STR_ + getName ( ) + STR_ ) ; } lockCheck . setText ( lockedButtonTitle + STR_ + seriesName ) ; viewAttributes . chartSeries = seriesName ; } else { lockCheck . setText ( unlockedButtonTitle ) ; viewAttributes . chartSeries = RpfViewAttributes . ANY ; } } else if ( cmd == showCoverageCommand ) { if ( coverage != null ) { JCheckBox coverageCheck = ( JCheckBox ) e . getSource ( ) ; coverage . setInUse ( coverageCheck . isSelected ( ) ) ; doPrepare ( ) ; } } else { doPrepare ( ) ; } }
@ Override public void run ( ) { if ( mDelay > NUM_ ) { try { Thread . sleep ( mDelay ) ; } catch ( InterruptedException e ) { LogImpl . w ( TAG , getName ( ) + STR_ + e . getMessage ( ) ) ; } } if ( mParentTask != null ) { synchronized ( this ) { try { wait ( ) ; } catch ( InterruptedException e ) { LogImpl . w ( TAG , getName ( ) + STR_ + e . getMessage ( ) ) ; } } } mStatus = Status . STATUS_EXECUTING ; long startTime = System . currentTimeMillis ( ) ; start ( ) ; long endTime = System . currentTimeMillis ( ) ; LogImpl . i ( TAG , getName ( ) + STR_ + ( endTime - startTime ) ) ; if ( mDoneSignal != null ) { mDoneSignal . countDown ( ) ; } if ( mChildTask != null ) { synchronized ( mChildTask ) { mChildTask . notify ( ) ; } } mStatus = Status . STATUS_DONE ; }
public boolean has ( final String name ) { return contents . containsKey ( name . toLowerCase ( ) ) ; }
public void stop ( ) { isAlive . set ( BOOL_ ) ; for ( KafkaConsumer < byte [ ] , byte [ ] > c : consumers . values ( ) ) { c . wakeup ( ) ; } kafkaConsumerExecutor . shutdownNow ( ) ; holdingBuffer . clear ( ) ; IOUtils . closeQuietly ( this ) ; }
protected final void refreshLoadingViewsSize ( ) { final int maximumPullScroll = ( int ) ( getMaximumPullScroll ( ) . NUM_ ) ; int pLeft = getPaddingLeft ( ) ; int pTop = getPaddingTop ( ) ; int pRight = getPaddingRight ( ) ; int pBottom = getPaddingBottom ( ) ; switch ( getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setWidth ( maximumPullScroll ) ; pLeft = - maximumPullScroll ; } else { pLeft = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setWidth ( maximumPullScroll ) ; pRight = - maximumPullScroll ; } else { pRight = NUM_ ; } break ; case VERTICAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setHeight ( maximumPullScroll ) ; pTop = - maximumPullScroll ; } else { pTop = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setHeight ( maximumPullScroll ) ; pBottom = - maximumPullScroll ; } else { pBottom = NUM_ ; } break ; } if ( DEBUG ) { Log . d ( LOG_TAG , String . format ( STR_ , pLeft , pTop , pRight , pBottom ) ) ; } setPadding ( pLeft , pTop , pRight , pBottom ) ; }
public String consumeElementSelector ( ) { int start = pos ; while ( ! isEmpty ( ) && ( matchesWord ( ) || matchesAny ( STR_ , STR_ , STR_ ) ) ) pos ++ ; return queue . substring ( start , pos ) ; }
@ SuppressWarnings ( STR_ ) public LongMap ( int initialCapacity , float loadFactor ) { if ( initialCapacity < NUM_ ) throw new IllegalArgumentException ( STR_ + initialCapacity ) ; if ( initialCapacity > NUM_ << NUM_ ) throw new IllegalArgumentException ( STR_ + initialCapacity ) ; capacity = nextPowerOfTwo ( initialCapacity ) ; if ( loadFactor <= NUM_ ) throw new IllegalArgumentException ( STR_ + loadFactor ) ; this . loadFactor = loadFactor ; threshold = ( int ) ( capacity . loadFactor ) ; mask = capacity - NUM_ ; hashShift = NUM_ - Long . numberOfTrailingZeros ( capacity ) ; stashCapacity = Math . max ( NUM_ , ( int ) Math . ceil ( Math . log ( capacity ) ) . NUM_ ) ; pushIterations = Math . max ( Math . min ( capacity , NUM_ ) , ( int ) Math . sqrt ( capacity ) / NUM_ ) ; keyTable = new long [ capacity + stashCapacity ] ; valueTable = ( V [ ] ) new Object [ keyTable . length ] ; }
public void endAttributes ( ) throws SAXException { String uri = getCurrentElementUri ( ) ; String local = getCurrentElementLocal ( ) ; String prefix = nsContext . getPrefix ( uri ) ; _assert ( prefix != null ) ; String qname ; if ( prefix . length ( ) != NUM_ ) qname = prefix + STR_ + local ; else qname = local ; nsContext . iterateDeclaredPrefixes ( startPrefixCallback ) ; writer . startElement ( uri , local , qname , attributes ) ; attributes . clear ( ) ; textBuf . setLength ( NUM_ ) ; }
private String abbreviateScript ( String script ) { if ( script == null ) { return null ; } if ( script . length ( ) <= NUM_ ) { return script ; } return STR_ + script . substring ( NUM_ , NUM_ ) ; }
public static void expandID ( String numberString , WordRelation wordRelation , Item tokenItem ) { int numberDigits = numberString . length ( ) ; if ( ( numberDigits == NUM_ ) && ( numberString . charAt ( NUM_ ) == STR_ ) && ( numberString . charAt ( NUM_ ) == STR_ ) ) { if ( numberString . charAt ( NUM_ ) == STR_ ) { expandNumber ( numberString , wordRelation , tokenItem ) ; } else { expandNumber ( numberString . substring ( NUM_ , NUM_ ) , wordRelation , tokenItem ) ; wordRelation . addWord ( tokenItem , STR_ ) ; } } else if ( ( numberDigits == NUM_ ) && ( numberString . charAt ( NUM_ ) == STR_ ) ) { wordRelation . addWord ( tokenItem , STR_ ) ; expandDigits ( numberString . substring ( NUM_ , NUM_ ) , wordRelation , tokenItem ) ; } else if ( ( numberDigits == NUM_ && numberString . charAt ( NUM_ ) == STR_ ) || numberDigits < NUM_ ) { expandNumber ( numberString , wordRelation , tokenItem ) ; } else if ( numberDigits % NUM_ == NUM_ ) { String firstDigit = digit2num [ numberString . charAt ( NUM_ ) - STR_ ] ; wordRelation . addWord ( tokenItem , firstDigit ) ; expandID ( numberString . substring ( NUM_ , numberDigits ) , wordRelation , tokenItem ) ; } else { expandNumber ( numberString . substring ( NUM_ , NUM_ ) , wordRelation , tokenItem ) ; expandID ( numberString . substring ( NUM_ , numberDigits ) , wordRelation , tokenItem ) ; } }
private static void unregisterMbeansFromPropsFile ( MBeanServer mBeanServer ) throws Exception { JamonPropertiesLoader loader = new JamonPropertiesLoader ( ) ; List < String > jamonJmxBeanProperties = loader . getMxBeans ( ) ; Iterator < String > iter = jamonJmxBeanProperties . iterator ( ) ; while ( iter . hasNext ( ) ) { String beanInfo = iter . next ( ) ; MonitorMXBean mXbean = MonitorMXBeanFactory . create ( beanInfo ) ; mBeanServer . unregisterMBean ( MonitorMXBeanFactory . getObjectName ( mXbean ) ) ; MonitorMXBean mXbeanDelta = MonitorMXBeanFactory . createDelta ( beanInfo ) ; mBeanServer . unregisterMBean ( MonitorMXBeanFactory . getDeltaObjectName ( mXbeanDelta ) ) ; } }
Source popImportSource ( ) { return ( Source ) m_importSourceStack . pop ( ) ; }
public static Date zeroTimeDate ( Date date ) { final GregorianCalendar gregorianCalendar = new GregorianCalendar ( ) ; gregorianCalendar . setTime ( date ) ; gregorianCalendar . set ( Calendar . HOUR_OF_DAY , NUM_ ) ; gregorianCalendar . set ( Calendar . MINUTE , NUM_ ) ; gregorianCalendar . set ( Calendar . SECOND , NUM_ ) ; gregorianCalendar . set ( Calendar . MILLISECOND , NUM_ ) ; return gregorianCalendar . getTime ( ) ; }
public static final void writeMapXml ( Map val , String name , XmlSerializer out ) throws XmlPullParserException , IOException { if ( val == null ) { out . startTag ( null , STR_ ) ; out . endTag ( null , STR_ ) ; return ; } Set s = val . entrySet ( ) ; Iterator i = s . iterator ( ) ; out . startTag ( null , STR_ ) ; if ( name != null ) { out . attribute ( null , STR_ , name ) ; } while ( i . hasNext ( ) ) { Map . Entry e = ( Map . Entry ) i . next ( ) ; writeValueXml ( e . getValue ( ) , ( String ) e . getKey ( ) , out ) ; } out . endTag ( null , STR_ ) ; }
protected void export ( ) { int retVal ; File file ; AbstractFileSaver saver ; if ( m_FileChooser == null ) m_FileChooser = GUIHelper . newConverterFileChooser ( ) ; retVal = m_FileChooser . showSaveDialog ( this ) ; if ( retVal != ConverterFileChooser . APPROVE_OPTION ) return ; file = m_FileChooser . getSelectedFile ( ) ; saver = m_FileChooser . getSaver ( ) ; try { saver . setInstances ( m_DataPanel . getInstances ( ) ) ; saver . writeBatch ( ) ; } catch ( Exception e ) { JOptionPane . showMessageDialog ( this , STR_ + file + STR_ + Utils . throwableToString ( e ) , STR_ , JOptionPane . ERROR_MESSAGE ) ; } }
public void sort ( int i ) { Arrays . sort ( vector [ i ] , NUM_ , sizes . get ( i ) ) ; }
private void createMapWhenNeeded ( ) { if ( isMapInitialized ) { return ; } if ( resourceBundle != null ) { Set < String > set = resourceBundle . keySet ( ) ; topLevelMap = new HashMap < String , Object > ( set . size ( ) ) ; for ( String key : set ) { Object value = resourceBundle . getObject ( key ) ; topLevelMap . put ( key , value ) ; } } else { topLevelMap = new HashMap < String , Object > ( NUM_ ) ; } topLevelMap . put ( STR_ , resourceBundle ) ; isMapInitialized = BOOL_ ; }
public static VectorClock increment ( VectorClock clock , int ... nodes ) { for ( int n : nodes ) clock = clock . incremented ( ( short ) n , System . currentTimeMillis ( ) ) ; return clock ; }
@ Override public String toString ( ) { return STR_ + set . toString ( ) ; }
void createHeapPhiInstruction ( BasicBlock bb , HeapVariable < Object > H ) { Instruction s = makePhiInstruction ( H , bb ) ; ArrayList < Instruction > heapPhis = heapPhi . get ( bb ) ; if ( heapPhis == null ) { heapPhis = new ArrayList < Instruction > ( NUM_ ) ; heapPhi . put ( bb , heapPhis ) ; } heapPhis . add ( s ) ; registerInstruction ( s , bb ) ; }
protected void printTime ( String s ) { SimpleDateFormat dateFormat = new SimpleDateFormat ( STR_ ) ; println ( dateFormat . format ( new java . util . Date ( ) ) + STR_ + s ) ; }
public Skeleton ( PrintWriter out ) { this . out = out ; }
public void disconnect ( ) { if ( conn != null ) { try { conn . close ( ) ; } catch ( SQLException e ) { logger . warn ( STR_ , e ) ; } } try { closeBinlog ( ) ; } catch ( IOException e ) { logger . warn ( STR_ , e ) ; } }
@ Override public int read ( byte [ ] b , int off , int len ) throws IOException { int n = in . read ( b , off , len ) ; if ( n == - NUM_ ) { throwIfFalseEOF ( ) ; } else { bytesRead += n ; } return n ; }
@ Override public Generator < ILineSegment > construct ( String [ ] args ) { return new IntegerGenerator ( Integer . valueOf ( args [ NUM_ ] ) , Integer . valueOf ( args [ NUM_ ] ) ) ; }
public SpatialStrategy ( SpatialContext ctx , String fieldName ) { if ( ctx == null ) throw new IllegalArgumentException ( STR_ ) ; this . ctx = ctx ; if ( fieldName == null || fieldName . length ( ) == NUM_ ) throw new IllegalArgumentException ( STR_ ) ; this . fieldName = fieldName ; }
public void dispose ( ) { if ( keys != null ) { keys . clear ( ) ; keys = null ; } super . dispose ( ) ; }
public boolean isFixedDisk ( String letter ) { if ( letter . length ( ) != NUM_ ) throw new IllegalArgumentException ( STR_ + letter ) ; char drive = Character . toUpperCase ( letter . charAt ( NUM_ ) ) ; if ( drive < STR_ || drive > STR_ ) throw new IllegalArgumentException ( STR_ + drive ) ; return getDriveType ( drive + STR_ ) == NUM_ ; }
private void movePos ( float deltaY ) { if ( ( deltaY < NUM_ && mPtrIndicator . isInStartPosition ( ) ) ) { if ( DEBUG ) { PtrCLog . e ( LOG_TAG , String . format ( STR_ ) ) ; } return ; } int to = mPtrIndicator . getCurrentPosY ( ) + ( int ) deltaY ; if ( mPtrIndicator . willOverTop ( to ) ) { if ( DEBUG ) { PtrCLog . e ( LOG_TAG , String . format ( STR_ ) ) ; } to = PtrIndicator . POS_START ; } mPtrIndicator . setCurrentPos ( to ) ; int change = to - mPtrIndicator . getLastPosY ( ) ; updatePos ( change ) ; }
private Object [ ] compile ( String path ) { List list = new ArrayList ( ) ; if ( path == null ) { return list . toArray ( ) ; } StringTokenizer tok = new StringTokenizer ( path , STR_ ) ; while ( tok . hasMoreTokens ( ) ) { String token = tok . nextToken ( ) ; OpEnum op = OpEnum . getInstance ( token ) ; if ( op == null ) { throw new Error ( STR_ + path ) ; } list . add ( op ) ; if ( op == OpEnum . RELATION ) { list . add ( tok . nextToken ( ) ) ; } } return list . toArray ( ) ; }
private void splitChunk ( final MemoryChunk chunk , final long address ) { final byte [ ] oldData = chunk . getBytes ( ) ; final byte [ ] newData1 = new byte [ ( int ) ( address - chunk . getAddress ( ) ) ] ; final byte [ ] newData2 = new byte [ ( chunk . getLength ( ) - newData1 . length ) ] ; System . arraycopy ( oldData , NUM_ , newData1 , NUM_ , newData1 . length ) ; System . arraycopy ( oldData , oldData . length - newData2 . length , newData2 , NUM_ , newData2 . length ) ; final MemoryChunk newChunk1 = new MemoryChunk ( chunk . getAddress ( ) , newData1 ) ; final MemoryChunk newChunk2 = new MemoryChunk ( ( chunk . getAddress ( ) + chunk . getLength ( ) ) - newData2 . length , newData2 ) ; removeChunk ( chunk ) ; insertChunk ( newChunk1 ) ; insertChunk ( newChunk2 ) ; }
public boolean isDirty ( ) { return dirty ; }
private Vector showTextFixedWidth ( String text , int align ) { Vector comps = new Vector ( ) ; if ( ( text == null ) || ( text . equals ( STR_ ) ) ) { return comps ; } int spaceW = width - x ; Vector words = getWords ( text , align , BOOL_ ) ; if ( words . size ( ) > NUM_ ) { int w = NUM_ ; String wordStr = STR_ ; if ( ( CSSParser . isWhiteSpace ( text . charAt ( NUM_ ) ) ) && ( curLine . getComponentCount ( ) != NUM_ ) ) { wordStr = STR_ ; } while ( w < words . size ( ) ) { String nextWord = ( String ) words . elementAt ( w ) ; String space = STR_ ; if ( ( ! wordStr . equals ( STR_ ) ) && ( ! wordStr . equals ( STR_ ) ) ) { space = STR_ ; } if ( font . stringWidth ( wordStr + space + nextWord ) > spaceW - NUM_ ) { comps . addElement ( addString ( wordStr , align ) ) ; newLineIfNotEmpty ( align ) ; spaceW = width - x ; wordStr = nextWord ; } else { wordStr += space + nextWord ; } w ++ ; } if ( CSSParser . isWhiteSpace ( text . charAt ( text . length ( ) - NUM_ ) ) ) { wordStr += STR_ ; } comps . addElement ( addString ( wordStr , align ) ) ; } return comps ; }
private void calculateSlotUsage ( ) { numEntries = NUM_ ; for ( int i = NUM_ ; i < table . table . length ; i ++ ) { LinkedList < V > list = ( LinkedList < V > ) table . table [ i ] ; if ( list != null ) { numEntries += list . size ( ) ; intHashTable [ i ] += list . size ( ) ; } } }
public Insert defaultValues ( ) { defaultValues = BOOL_ ; columns . clear ( ) ; valuesToInsert . clear ( ) ; query = null ; invalidateCompileCache ( ) ; return this ; }
public CFilenameFormatter ( final File directory ) { Preconditions . checkArgument ( directory . exists ( ) , STR_ ) ; m_directory = directory ; }
public T pop ( ) { return list . removeLast ( ) ; }
public static String makeLogTag ( Class cls ) { return makeLogTag ( cls . getSimpleName ( ) ) ; }
public Timestamp recalculateEstimatedCompletionDate ( Long priority , Timestamp startDate ) { if ( exist ( ) ) { getProductionRunRoutingTasks ( ) ; if ( quantity == null ) getQuantity ( ) ; Timestamp endDate = null ; for ( Iterator < GenericValue > iter = productionRunRoutingTasks . iterator ( ) ; iter . hasNext ( ) ; ) { GenericValue routingTask = iter . next ( ) ; if ( priority . compareTo ( routingTask . getLong ( STR_ ) ) <= NUM_ ) { long totalTime = ProductionRun . getEstimatedTaskTime ( routingTask , quantity , dispatcher ) ; endDate = TechDataServices . addForward ( TechDataServices . getTechDataCalendar ( routingTask ) , startDate , totalTime ) ; routingTask . set ( STR_ , startDate ) ; routingTask . set ( STR_ , endDate ) ; startDate = endDate ; } } return endDate ; } else { return null ; } }
public static String nodeListToString ( List < ? extends Node > list ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( STR_ ) ; if ( list . size ( ) > NUM_ ) { buf . append ( STR_ + domToString ( list . get ( NUM_ ) ) + STR_ ) ; for ( int i = NUM_ ; i < list . size ( ) ; ++ i ) { buf . append ( STR_ + i + STR_ + domToString ( list . get ( NUM_ ) ) + STR_ ) ; } buf . append ( STR_ ) ; } buf . append ( STR_ ) ; return buf . toString ( ) ; }
protected Element adapt ( Element source , ElementMetadata < ? , ? > sourceMeta , String kind ) { ElementKey < ? , ? > adaptorKey = sourceMeta . adapt ( kind ) ; if ( adaptorKey != null ) { try { return adapt ( adaptorKey , source ) ; } catch ( ContentCreationException e ) { LOGGER . log ( Level . SEVERE , STR_ + source . getClass ( ) + STR_ + adaptorKey . getElementType ( ) , e ) ; } } return source ; }
public String convertAliasToNumber ( String aliasName ) { if ( ! aliasName . contains ( STR_ ) && AliasDatabase . containsAlias ( aliasName ) ) { String [ ] res = AliasDatabase . getAlias ( aliasName ) ; return res [ NUM_ ] ; } return aliasName ; }
public Attr ( String name , @ Nullable Format format ) { this . name = name ; if ( format != null ) { formats = Collections . singletonList ( format ) ; } }
static StreamTokenizer makeTokenizer ( String tagValue ) { StreamTokenizer tokenizer = new StreamTokenizer ( new StringReader ( tagValue ) ) ; tokenizer . resetSyntax ( ) ; tokenizer . wordChars ( STR_ , STR_ ) ; tokenizer . wordChars ( STR_ , STR_ ) ; tokenizer . wordChars ( STR_ , STR_ ) ; tokenizer . wordChars ( STR_ , STR_ ) ; tokenizer . wordChars ( STR_ , STR_ ) ; tokenizer . wordChars ( STR_ , STR_ ) ; tokenizer . wordChars ( STR_ , STR_ ) ; tokenizer . wordChars ( STR_ , STR_ ) ; tokenizer . quoteChar ( STR_ ) ; tokenizer . quoteChar ( STR_ ) ; tokenizer . whitespaceChars ( STR_ , STR_ ) ; tokenizer . whitespaceChars ( STR_ , STR_ ) ; tokenizer . whitespaceChars ( STR_ , STR_ ) ; tokenizer . whitespaceChars ( STR_ , STR_ ) ; tokenizer . eolIsSignificant ( BOOL_ ) ; return tokenizer ; }
private void sendRequest ( ) { int i = tabPane . getSelectedIndex ( ) ; String prompt = rb . getString ( STR_ + i + STR_ ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + prompt + STR_ + i ) ; } if ( source == null ) { log . error ( STR_ ) ; timer . stop ( ) ; return ; } source . sendBytes ( prompt . getBytes ( ) ) ; }
public void remove ( Predicate filter ) { for ( IntIterator ii = rows ( filter ) ; ii . hasNext ( ) ; ) removeRow ( ii . nextInt ( ) ) ; }
private void calculateTrimArea ( Rect bounds ) { float size = Math . min ( bounds . height ( ) , bounds . width ( ) ) ; float yOffset = ( bounds . height ( ) - size ) / NUM_ ; float xOffset = ( bounds . width ( ) - size ) / NUM_ ; float padding = mPadding + ( bounds . height ( ) - NUM_ . mPadding ) . NUM_ / NUM_ ; mInternalBounds . set ( bounds . left + padding + xOffset , bounds . top + padding + yOffset , bounds . right - padding - xOffset , bounds . bottom - padding - yOffset ) ; mCenter = mInternalBounds . centerX ( ) ; mSize = mInternalBounds . width ( ) ; mPlayTipOffset = NUM_ / NUM_ . mSize ; mPlayBaseOffset = NUM_ . mSize ; setTransitionState ( NUM_ , NUM_ ) ; }
protected void initInstances ( Operation post , ServiceDocument ... states ) { initInstances ( post , BOOL_ , BOOL_ , states ) ; }
protected Instance mergeInstances ( Instance source , Instance dest ) { Instances outputFormat = outputFormatPeek ( ) ; double [ ] vals = new double [ outputFormat . numAttributes ( ) ] ; for ( int i = NUM_ ; i < vals . length ; i ++ ) { if ( ( i != outputFormat . classIndex ( ) ) && ( m_SelectedCols . isInRange ( i ) ) ) { if ( ( source != null ) && ! source . isMissing ( i ) && ! dest . isMissing ( i ) ) { vals [ i ] = dest . value ( i ) - source . value ( i ) ; } else { vals [ i ] = Utils . missingValue ( ) ; } } else { vals [ i ] = dest . value ( i ) ; } } Instance inst = null ; if ( dest instanceof SparseInstance ) { inst = new SparseInstance ( dest . weight ( ) , vals ) ; } else { inst = new DenseInstance ( dest . weight ( ) , vals ) ; } inst . setDataset ( dest . dataset ( ) ) ; return inst ; }
public SourceCallChainBuilder ( int timeout , boolean process_callbacks ) { this . timeout = timeout ; this . process_callbacks = process_callbacks ; }
public synchronized float recoveredBytesPercent ( ) { long total = NUM_ ; long recovered = NUM_ ; for ( File file : fileDetails . values ( ) ) { if ( file . reused ( ) == BOOL_ ) { total += file . length ( ) ; recovered += file . recovered ( ) ; } } if ( total == NUM_ && fileDetails . size ( ) == NUM_ ) { return NUM_ ; } if ( total == recovered ) { return NUM_ ; } else { return NUM_ . recovered / total ; } }
public < E extends T > EventBinder < E > on ( ) { return new EventBinder < > ( Optional . empty ( ) ) ; }
private boolean isValueSupported ( Object value ) { for ( int i = NUM_ ; i < values . length ; i ++ ) { if ( value . equals ( values [ i ] ) ) { return BOOL_ ; } } return BOOL_ ; }
public static BitSet fromByteArray ( byte [ ] bytes ) { BitSet bits = new BitSet ( ) ; for ( int i = NUM_ ; i < bytes . length . NUM_ ; i ++ ) { if ( ( bytes [ bytes . length - i / NUM_ - NUM_ ] & ( NUM_ << ( i % NUM_ ) ) ) > NUM_ ) { bits . set ( i ) ; } } return bits ; }
public RepeatTime createRepeatTime ( int repeatInterval , int activeDuration , int [ ] offsets ) { RepeatField repeatTimeField = new RepeatField ( ) ; try { repeatTimeField . setRepeatInterval ( repeatInterval ) ; repeatTimeField . setActiveDuration ( activeDuration ) ; repeatTimeField . setOffsetArray ( offsets ) ; } catch ( SdpException s ) { s . printStackTrace ( ) ; } return repeatTimeField ; }
public void remove ( int i ) { if ( ( i >= array . length ) || ( i < NUM_ ) ) throw new ArrayIndexOutOfBoundsException ( STR_ + i + STR_ + array . length ) ; NSObject [ ] newArray = new NSObject [ array . length - NUM_ ] ; System . arraycopy ( array , NUM_ , newArray , NUM_ , i ) ; System . arraycopy ( array , i + NUM_ , newArray , i , array . length - i - NUM_ ) ; array = newArray ; }
private Time parseTime ( String timeString ) throws ParseException { java . util . Date parsedDate = TimeField . parse ( timeString ) ; if ( parsedDate == null ) return null ; return new Time ( parsedDate . getTime ( ) ) ; }
public synchronized void deleteObservers ( ) { observers . clear ( ) ; }
private void decrementCopyFieldTargetCount ( SchemaField dest ) { Integer count = copyFieldTargetCounts . get ( dest ) ; assert count != null ; if ( count <= NUM_ ) { copyFieldTargetCounts . remove ( dest ) ; } else { copyFieldTargetCounts . put ( dest , count - NUM_ ) ; } }
public synchronized int updatePurchase ( String orderId , String productId , PurchaseState purchaseState , long purchaseTime , String developerPayload ) { insertOrder ( orderId , productId , purchaseState , purchaseTime , developerPayload ) ; Cursor cursor = mDb . query ( PURCHASE_HISTORY_TABLE_NAME , HISTORY_COLUMNS , HISTORY_PRODUCT_ID_COL + STR_ , new String [ ] { productId } , null , null , null , null ) ; if ( cursor == null ) { return NUM_ ; } int quantity = NUM_ ; try { while ( cursor . moveToNext ( ) ) { int stateIndex = cursor . getInt ( NUM_ ) ; PurchaseState state = PurchaseState . valueOf ( stateIndex ) ; if ( state == PurchaseState . PURCHASED || state == PurchaseState . REFUNDED ) { quantity += NUM_ ; } } updatePurchasedItem ( productId , quantity ) ; } finally { if ( cursor != null ) { cursor . close ( ) ; } } return quantity ; }
public static Calendar fromUnixTime ( long unixTime , TimeUnit timeUnit ) { Calendar calendar = getCalendarInstance ( ) ; calendar . setTimeZone ( TimeZone . getDefault ( ) ) ; long millis = timeUnit . toMillis ( unixTime ) ; calendar . setTimeInMillis ( millis ) ; return calendar ; }
public boolean isLayoutIdInRecord ( int layoutId ) { return mLayoutIds != null && mLayoutIds . contains ( layoutId ) ; }
private void open_board_design_action ( ) { DesignFile design_file = open_dialog ( stat , main_options . design_dir_name ) ; if ( design_file == null ) { stat . userPrintln ( resources . getString ( STR_ ) ) ; return ; } String message = resources . getString ( STR_ ) + STR_ + design_file . get_name ( ) ; stat . userPrintln ( message ) ; BoardFrame board_frame = new BoardFrame ( design_file , stat ) ; ImportDesign d_import = new ImportDesign ( board_frame ) ; d_import . execute ( ) ; }
public static String retrieveDisplayName ( String id , boolean daylight , int style , Locale locale ) { String [ ] names = retrieveDisplayNamesImpl ( id , locale ) ; if ( Objects . nonNull ( names ) ) { return names [ ( daylight ? NUM_ : NUM_ ) - style ] ; } else { return null ; } }
protected Query newFuzzyQuery ( Term term , float minimumSimilarity , int prefixLength ) { String text = term . text ( ) ; int numEdits = FuzzyQuery . floatToEdits ( minimumSimilarity , text . codePointCount ( NUM_ , text . length ( ) ) ) ; return new FuzzyQuery ( term , numEdits , prefixLength ) ; }
@ Override public void playVideo ( Uri uri , String title ) { CameraActivity activity = mActivity . get ( ) ; if ( activity != null ) { CameraUtil . playVideo ( activity , uri , title ) ; } }
public void copyFrom ( Path other ) { grow ( other . length - NUM_ ) ; System . arraycopy ( other . blockIdList , NUM_ , this . blockIdList , NUM_ , other . length ) ; this . length = other . length ; this . cachedHashCode = other . cachedHashCode ; }
void recoverMessages ( ) throws RollbackFailedException { if ( m_isQueue ) { if ( _logger . isLoggable ( Level . FINE ) ) { _logger . log ( Level . FINE , STR_ ) ; } unackedMessages . clear ( ) ; if ( ! isAutoAck ( ) ) { rollbackLocalTransaction ( ) ; } } else { if ( _logger . isLoggable ( Level . FINE ) ) { _logger . log ( Level . FINE , STR_ ) ; } unackedMessages . addAll ( recoverMessages ) ; LinkedList < MessageQueueElement > temp = unackedMessages ; recoverMessages . clear ( ) ; unackedMessages = recoverMessages ; recoverMessages = temp ; } }
private void maybeSampleSyncParams ( ) { long playbackPositionUs = audioTrackUtil . getPlaybackHeadPositionUs ( ) ; if ( playbackPositionUs == NUM_ ) { return ; } long systemClockUs = System . nanoTime ( ) / NUM_ ; if ( systemClockUs - lastPlayheadSampleTimeUs >= MIN_PLAYHEAD_OFFSET_SAMPLE_INTERVAL_US ) { playheadOffsets [ nextPlayheadOffsetIndex ] = playbackPositionUs - systemClockUs ; nextPlayheadOffsetIndex = ( nextPlayheadOffsetIndex + NUM_ ) % MAX_PLAYHEAD_OFFSET_COUNT ; if ( playheadOffsetCount < MAX_PLAYHEAD_OFFSET_COUNT ) { playheadOffsetCount ++ ; } lastPlayheadSampleTimeUs = systemClockUs ; smoothedPlayheadOffsetUs = NUM_ ; for ( int i = NUM_ ; i < playheadOffsetCount ; i ++ ) { smoothedPlayheadOffsetUs += playheadOffsets [ i ] / playheadOffsetCount ; } } if ( ! isPassthrough ( ) && systemClockUs - lastTimestampSampleTimeUs >= MIN_TIMESTAMP_SAMPLE_INTERVAL_US ) { audioTimestampSet = audioTrackUtil . updateTimestamp ( ) ; if ( audioTimestampSet ) { long audioTimestampUs = audioTrackUtil . getTimestampNanoTime ( ) / NUM_ ; long audioTimestampFramePosition = audioTrackUtil . getTimestampFramePosition ( ) ; if ( audioTimestampUs < resumeSystemTimeUs ) { audioTimestampSet = BOOL_ ; } else if ( Math . abs ( audioTimestampUs - systemClockUs ) > MAX_AUDIO_TIMESTAMP_OFFSET_US ) { String message = STR_ + audioTimestampFramePosition + STR_ + audioTimestampUs + STR_ + systemClockUs + STR_ + playbackPositionUs ; if ( failOnSpuriousAudioTimestamp ) { throw new InvalidAudioTrackTimestampException ( message ) ; } Log . w ( TAG , message ) ; audioTimestampSet = BOOL_ ; } else if ( Math . abs ( framesToDurationUs ( audioTimestampFramePosition ) - playbackPositionUs ) > MAX_AUDIO_TIMESTAMP_OFFSET_US ) { String message = STR_ + audioTimestampFramePosition + STR_ + audioTimestampUs + STR_ + systemClockUs + STR_ + playbackPositionUs ; if ( failOnSpuriousAudioTimestamp ) { throw new InvalidAudioTrackTimestampException ( message ) ; } Log . w ( TAG , message ) ; audioTimestampSet = BOOL_ ; } } if ( getLatencyMethod != null ) { try { latencyUs = ( Integer ) getLatencyMethod . invoke ( audioTrack , ( Object [ ] ) null ) . NUM_ - framesToDurationUs ( bytesToFrames ( bufferSize ) ) ; latencyUs = Math . max ( latencyUs , NUM_ ) ; if ( latencyUs > MAX_LATENCY_US ) { Log . w ( TAG , STR_ + latencyUs ) ; latencyUs = NUM_ ; } } catch ( Exception e ) { getLatencyMethod = null ; } } lastTimestampSampleTimeUs = systemClockUs ; } }
private Map < Key , Array > store ( Class clazz ) { Method [ ] methods = clazz . getMethods ( ) ; Map < Key , Array > methodsMap = new ConcurrentHashMap < Key , Array > ( ) ; for ( int i = NUM_ ; i < methods . length ; i ++ ) { storeMethod ( methods [ i ] , methodsMap ) ; } map . put ( clazz , methodsMap ) ; return methodsMap ; }
private void readCentralDir ( ) throws IOException { long scanOffset = raf . length ( ) - ENDHDR ; if ( scanOffset < NUM_ ) { throw new ZipException ( STR_ + raf . length ( ) ) ; } raf . seek ( NUM_ ) ; final int headerMagic = Integer . reverseBytes ( raf . readInt ( ) ) ; if ( headerMagic != LOCSIG ) { throw new ZipException ( STR_ ) ; } long stopOffset = scanOffset - NUM_ ; if ( stopOffset < NUM_ ) { stopOffset = NUM_ ; } while ( BOOL_ ) { raf . seek ( scanOffset ) ; if ( Integer . reverseBytes ( raf . readInt ( ) ) == ENDSIG ) { break ; } scanOffset -- ; if ( scanOffset < stopOffset ) { throw new ZipException ( STR_ ) ; } } byte [ ] eocd = new byte [ ENDHDR - NUM_ ] ; raf . readFully ( eocd ) ; BufferIterator it = HeapBufferIterator . iterator ( eocd , NUM_ , eocd . length , ByteOrder . LITTLE_ENDIAN ) ; int diskNumber = it . readShort ( ) & xffff ; int diskWithCentralDir = it . readShort ( ) & xffff ; int numEntries = it . readShort ( ) & xffff ; int totalNumEntries = it . readShort ( ) & xffff ; it . skip ( NUM_ ) ; long centralDirOffset = ( ( long ) it . readInt ( ) ) & xffffffffL ; int commentLength = it . readShort ( ) & xffff ; if ( numEntries != totalNumEntries || diskNumber != NUM_ || diskWithCentralDir != NUM_ ) { throw new ZipException ( STR_ ) ; } if ( commentLength > NUM_ ) { byte [ ] commentBytes = new byte [ commentLength ] ; raf . readFully ( commentBytes ) ; comment = new String ( commentBytes , NUM_ , commentBytes . length , StandardCharsets . UTF_8 ) ; } RAFStream rafStream = new RAFStream ( raf , centralDirOffset ) ; BufferedInputStream bufferedStream = new BufferedInputStream ( rafStream , NUM_ ) ; byte [ ] hdrBuf = new byte [ CENHDR ] ; for ( int i = NUM_ ; i < numEntries ; ++ i ) { ZipEntry newEntry = new ZipEntry ( hdrBuf , bufferedStream ) ; if ( newEntry . localHeaderRelOffset >= centralDirOffset ) { throw new ZipException ( STR_ ) ; } String entryName = newEntry . getName ( ) ; if ( entries . put ( entryName , newEntry ) != null ) { throw new ZipException ( STR_ + entryName ) ; } } }
protected int readFully ( InputStream in , byte buffer [ ] , int offset , int len ) throws IOException { for ( int i = NUM_ ; i < len ; i ++ ) { int q = in . read ( ) ; if ( q == - NUM_ ) return ( ( i == NUM_ ) ? - NUM_ : i ) ; buffer [ i + offset ] = ( byte ) q ; } return len ; }
private long renewServiceLeaseDo ( ServiceID serviceID , Uuid leaseID , long renewDuration ) throws UnknownLeaseException { long now = System . currentTimeMillis ( ) ; long renewExpiration = renewServiceLeaseInt ( serviceID , leaseID , renewDuration , now ) ; addLogRecord ( new ServiceLeaseRenewedLogObj ( serviceID , leaseID , renewExpiration ) ) ; return renewExpiration - now ; }
public BlockSwapper ( World world , EntityPlayer player , ItemStack truncator , BlockPos origCoords , int range , boolean leaves ) { this . world = world ; this . player = player ; this . truncator = truncator ; this . origin = origCoords ; this . range = range ; this . treatLeavesSpecial = leaves ; this . candidateQueue = new PriorityQueue < > ( ) ; this . completedCoords = new HashSet < > ( ) ; candidateQueue . offer ( new SwapCandidate ( this . origin , this . range ) ) ; }
public static String [ ] toStringArray ( Enumeration < String > enumeration ) { if ( enumeration == null ) { return null ; } List < String > list = Collections . list ( enumeration ) ; return list . toArray ( new String [ list . size ( ) ] ) ; }
@ PUT @ Consumes ( { MediaType . APPLICATION_XML , MediaType . APPLICATION_JSON } ) @ Path ( STR_ ) @ Produces ( { MediaType . APPLICATION_XML , MediaType . APPLICATION_JSON } ) @ CheckPermission ( roles = { Role . SYSTEM_ADMIN , Role . RESTRICTED_SYSTEM_ADMIN } ) public FileVirtualPoolRestRep updateFileVirtualPoolWithAssignedPools ( @ PathParam ( STR_ ) URI id , VirtualPoolPoolUpdateParam param ) { VirtualPool vPool = updateVirtualPoolWithAssignedStoragePools ( id , param ) ; return toFileVirtualPool ( vPool , VirtualPool . getFileRemoteProtectionSettings ( vPool , _dbClient ) ) ; }
public static java . sql . Date toSqlDate ( int month , int day , int year ) { java . util . Date newDate = toDate ( month , day , year , NUM_ , NUM_ , NUM_ ) ; if ( newDate != null ) { return new java . sql . Date ( newDate . getTime ( ) ) ; } else { return null ; } }
public Object readDefaultListModel ( Element node ) throws Exception { DefaultListModel model ; Vector < Element > children ; Element child ; int i ; int index ; int currIndex ; if ( DEBUG ) { trace ( new Throwable ( ) , node . getAttribute ( ATT_NAME ) ) ; } m_CurrentNode = node ; children = XMLDocument . getChildTags ( node ) ; model = new DefaultListModel ( ) ; index = children . size ( ) - NUM_ ; for ( i = NUM_ ; i < children . size ( ) ; i ++ ) { child = children . get ( i ) ; currIndex = Integer . parseInt ( child . getAttribute ( ATT_NAME ) ) ; if ( currIndex > index ) { index = currIndex ; } } model . setSize ( index + NUM_ ) ; for ( i = NUM_ ; i < children . size ( ) ; i ++ ) { child = children . get ( i ) ; model . set ( Integer . parseInt ( child . getAttribute ( ATT_NAME ) ) , invokeReadFromXML ( child ) ) ; } return model ; }
private boolean resultsIdentical ( String namedCurve , BigInteger badX , BigInteger badY , BigInteger secret , int iter ) throws InvalidAlgorithmParameterException , NoSuchAlgorithmException , InvalidKeySpecException , InvalidKeyException { for ( int i = NUM_ ; i < iter ; i ++ ) { secret = secret . add ( BigInteger . ONE ) ; BigInteger resultCustom = computeSecretWithCustomAlgorithm ( namedCurve , badX , badY , secret ) ; BigInteger resultSun = computeSecretWithSunAlgorithm ( namedCurve , badX , badY , secret ) ; if ( resultSun != null && ! resultSun . equals ( resultCustom ) ) { return BOOL_ ; } } return BOOL_ ; }
public void enableLayers ( boolean enable ) { TextureState textureState = ( TextureState ) getLocalRenderState ( RenderState . StateType . Texture ) ; textureState . setEnabled ( enable ) ; markDirty ( DirtyType . RenderState ) ; }
protected void starveRandomly ( int limit ) { while ( population . size ( ) > limit ) { int removePos = Randomness . nextInt ( ) % population . size ( ) ; population . remove ( removePos ) ; } }
public void saveParam ( ) throws Exception { Enumeration < AbstractParamPanel > en = tablePanel . elements ( ) ; AbstractParamPanel panel = null ; while ( en . hasMoreElements ( ) ) { panel = en . nextElement ( ) ; panel . saveParam ( paramObject ) ; } }
@ SuppressWarnings ( STR_ ) public static LocalStreamingContainer waitForActivation ( StramLocalCluster localCluster , PTOperator operator ) throws InterruptedException { LocalStreamingContainer container ; long startMillis = System . currentTimeMillis ( ) ; while ( System . currentTimeMillis ( ) < ( startMillis + DEFAULT_TIMEOUT_MILLIS ) ) { if ( operator . getState ( ) == PTOperator . State . ACTIVE ) { if ( ( container = localCluster . getContainer ( operator ) ) != null ) { return container ; } } LOG . debug ( STR_ , new Object [ ] { operator , operator . getState ( ) , operator . getContainer ( ) } ) ; Thread . sleep ( NUM_ ) ; } Assert . fail ( STR_ + operator ) ; return null ; }
private float interpolate ( ) { long currTime = System . currentTimeMillis ( ) ; float elapsed = ( currTime - startTime ) / ZOOM_TIME ; elapsed = Math . min ( NUM_ , elapsed ) ; return interpolator . getInterpolation ( elapsed ) ; }
protected String toExternalForm ( URL url ) { return toExternalForm ( url , BOOL_ ) ; }
public ResultSet executeQuery ( String query ) throws SQLException , NoConnectionException { if ( connection != null ) { Statement st = connection . createStatement ( ) ; return st . executeQuery ( query ) ; } throw new NoConnectionException ( ) ; }
private void rejectAccessAndTerminateProcess ( RadiusResponse response , ContextHolder holder ) { response . setResponsePacket ( new AccessReject ( ) ) ; response . setUniversalId ( holder . getUniversalId ( ) ) ; terminateAuthnProcess ( holder ) ; }
public ScVolume createViewVolume ( String name , String instanceId ) throws StorageCenterAPIException { LOG . debug ( STR_ , instanceId ) ; String errorMessage = STR_ ; Parameters params = new Parameters ( ) ; params . add ( STR_ , name ) ; params . add ( STR_ , NOTES_STRING ) ; try { RestResult result = restClient . post ( String . format ( STR_ , instanceId ) , params . toJson ( ) ) ; if ( checkResults ( result ) ) { return gson . fromJson ( result . getResult ( ) , ScVolume . class ) ; } } catch ( Exception e ) { errorMessage = String . format ( STR_ , e ) ; LOG . warn ( errorMessage ) ; } if ( errorMessage . length ( ) == NUM_ ) { errorMessage = String . format ( STR_ , name , instanceId ) ; } throw new StorageCenterAPIException ( errorMessage ) ; }
@ Override public boolean contains ( Object object ) { return indexOf ( object , NUM_ ) != - NUM_ ; }
public void sync ( ) throws StorageFault { final String methodName = STR_ ; log . debug ( methodName + STR_ ) ; try { log . trace ( methodName + STR_ ) ; _syncManager . syncAll ( ) ; } catch ( SOSFailure e ) { log . error ( methodName + STR_ , e ) ; throw FaultUtil . StorageFault ( e ) ; } log . debug ( methodName + STR_ ) ; }
private void addMenuItem ( JPopupMenu menu , String title , MWFNodeNext line ) { WFPopupItem item = new WFPopupItem ( title , line ) ; menu . add ( item ) ; item . addActionListener ( this ) ; }
public static Matcher < BindingSet > binds ( String name , Class < ? > value ) { return new BindsMatcher < Object > ( name , instanceOf ( value ) ) ; }
private void testAdd ( ) throws Exception { LOG . info ( STR_ ) ; long msgCount = messageMapper . countMessagesInMailbox ( MBOXES . get ( NUM_ ) ) ; LOG . info ( msgCount + STR_ + MESSAGE_NO . size ( ) ) ; assertEquals ( MESSAGE_NO . size ( ) , msgCount ) ; }
public void cancelTaskNoException ( Task task ) { try { cancelTask ( task ) ; } catch ( Exception e ) { _log . error ( STR_ ) ; } }
public boolean isLayoutIdInRecord ( int layoutId ) { return mLayoutIds != null && mLayoutIds . contains ( layoutId ) ; }
public String toString ( ) { return toIndentedString ( NUM_ ) ; }
public int read ( byte b [ ] , int off , int len ) throws IOException , LogException { if ( length < len ) badRead ( len ) ; len = in . read ( b , off , len ) ; length -= len ; return len ; }
public static void migrateFrom6To7 ( SQLiteDatabase db ) { String selectQuery = STR_ + DatabaseHelper . TABLE_GRIDITEMRELATIONS ; Cursor c = db . rawQuery ( selectQuery , null ) ; if ( c . moveToFirst ( ) ) { do { try { int gridItemid = c . getInt ( c . getColumnIndex ( DatabaseHelper . KEY_ID ) ) ; int pluginId = c . getInt ( c . getColumnIndex ( DatabaseHelper . KEY_GRIDITEMRELATIONS_PLUGIN ) ) ; String pluginpageUrlQuery = STR_ + DatabaseHelper . KEY_MUNINPLUGINS_PLUGINPAGEURL + STR_ + DatabaseHelper . TABLE_MUNINPLUGINS + STR_ + DatabaseHelper . KEY_ID + STR_ + pluginId ; Cursor c2 = db . rawQuery ( pluginpageUrlQuery , null ) ; if ( c2 . moveToFirst ( ) ) { String pluginpageUrl = c2 . getString ( c2 . getColumnIndex ( DatabaseHelper . KEY_MUNINPLUGINS_PLUGINPAGEURL ) ) ; ContentValues values = new ContentValues ( ) ; values . put ( DatabaseHelper . KEY_GRIDITEMRELATIONS_PLUGINPAGEURL , pluginpageUrl ) ; db . update ( DatabaseHelper . TABLE_GRIDITEMRELATIONS , values , DatabaseHelper . KEY_ID + STR_ , new String [ ] { String . valueOf ( gridItemid ) } ) ; } c2 . close ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } while ( c . moveToNext ( ) ) ; } c . close ( ) ; }
public static InputStream cropImage ( InputStream inputStream , int imageWidth , int imageHeight , int outWidth , int outHeight ) throws IllegalArgumentException { if ( inputStream == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( imageWidth <= NUM_ || imageHeight <= NUM_ ) { throw new IllegalArgumentException ( String . format ( STR_ + STR_ , imageWidth , imageHeight ) ) ; } if ( outWidth <= NUM_ || outHeight <= NUM_ ) { throw new IllegalArgumentException ( String . format ( STR_ + STR_ , imageWidth , outHeight ) ) ; } int scaleDownSampleSize = Math . min ( imageWidth / outWidth , imageHeight / outHeight ) ; if ( scaleDownSampleSize > NUM_ ) { imageWidth /= scaleDownSampleSize ; imageHeight /= scaleDownSampleSize ; } else { float ratio = ( float ) outWidth / outHeight ; if ( imageWidth < imageHeight . ratio ) { outWidth = imageWidth ; outHeight = ( int ) ( outWidth / ratio ) ; } else { outHeight = imageHeight ; outWidth = ( int ) ( outHeight . ratio ) ; } } int left = ( imageWidth - outWidth ) / NUM_ ; int top = ( imageHeight - outHeight ) / NUM_ ; InputStream compressed = null ; try { BitmapFactory . Options options = new BitmapFactory . Options ( ) ; if ( scaleDownSampleSize > NUM_ ) { options . inSampleSize = scaleDownSampleSize ; } Bitmap bitmap = BitmapFactory . decodeStream ( inputStream , null , options ) ; if ( bitmap == null ) { return null ; } Bitmap cropped = Bitmap . createBitmap ( bitmap , left , top , outWidth , outHeight ) ; ByteArrayOutputStream tmpOut = new ByteArrayOutputStream ( NUM_ ) ; if ( cropped . compress ( Bitmap . CompressFormat . PNG , DEFAULT_IMG_QUALITY , tmpOut ) ) { byte [ ] outByteArray = tmpOut . toByteArray ( ) ; compressed = new ByteArrayInputStream ( outByteArray ) ; } } catch ( Exception e ) { Log . e ( TAG , STR_ + e ) ; } return compressed ; }
@ Override public void datasetChanged ( DatasetChangeEvent event ) { fireDatasetChanged ( ) ; }
public void drawingComplete ( OMGraphic omg , OMAction action ) { if ( timerButton . isSelected ( ) ) { timer . restart ( ) ; } if ( omg instanceof OMPoint ) { OMPoint p = ( OMPoint ) omg ; GLPoint mp = new GLPoint ( p . getLat ( ) , p . getLon ( ) , p . getRadius ( ) , BOOL_ ) ; mp . setName ( STR_ + ( pointCount ++ ) ) ; mp . setStationary ( BOOL_ ) ; mp . showPalette ( ) ; points . put ( mp . getName ( ) , mp ) ; manageGraphics ( ) ; } else if ( omg instanceof OMPoly ) { OMPoly poly = ( OMPoly ) omg ; PathGLPoint pmp = new PathGLPoint ( poly , NUM_ , BOOL_ ) ; pmp . setName ( STR_ + ( pointCount ++ ) ) ; pmp . showPalette ( ) ; points . put ( pmp . getName ( ) , pmp ) ; manageGraphics ( ) ; } addNodeButton . setEnabled ( BOOL_ ) ; addPathButton . setEnabled ( BOOL_ ) ; }
public static String hashKeyForDisk ( String key ) { String cacheKey ; try { final MessageDigest mDigest = MessageDigest . getInstance ( STR_ ) ; mDigest . update ( key . getBytes ( ) ) ; cacheKey = bytesToHexString ( mDigest . digest ( ) ) ; } catch ( NoSuchAlgorithmException e ) { cacheKey = String . valueOf ( key . hashCode ( ) ) ; } return cacheKey ; }
static int firstIllegalCharacter ( String source ) { for ( int i = NUM_ ; i < source . length ( ) ; i ++ ) { if ( isLegal ( source . charAt ( i ) ) == BOOL_ ) { return i ; } } return - NUM_ ; }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case NUM_ : return COOKIE ; case NUM_ : return USER_ID ; default : return null ; } }
public Charset charset ( ) { return charset != null ? Charset . forName ( charset ) : null ; }
public DriverTask deleteVolumeMirror ( VolumeMirror mirror ) { LOG . info ( STR_ , mirror ) ; DellSCDriverTask task = new DellSCDriverTask ( STR_ ) ; try { StorageCenterAPI api = connectionManager . getConnection ( mirror . getStorageSystemId ( ) ) ; ScCopyMirrorMigrate cmm = api . getMirror ( mirror . getNativeId ( ) ) ; api . deleteMirror ( cmm . instanceId ) ; api . deleteVolume ( cmm . destinationVolume . instanceId ) ; task . setStatus ( TaskStatus . READY ) ; } catch ( StorageCenterAPIException | DellSCDriverException dex ) { String error = String . format ( STR_ , mirror . getNativeId ( ) , dex ) ; LOG . error ( error ) ; task . setFailed ( error ) ; } return task ; }
public void testConnect_BlockNoServer ( ) throws IOException { connectWithoutServer ( ) ; disconnectAfterConnected ( ) ; }
public ByteArrayDataProvider ( byte [ ] bytes ) { this . bytes = Arrays . copyOf ( bytes , bytes . length ) ; }
public static String generateNativeGuidForPhysicalNAS ( String systemNativeGuid , String pNasName ) { return String . format ( STR_ + PHYSICAL_NAS + STR_ , systemNativeGuid , pNasName ) ; }
private void expire ( ) { if ( m_expire != NUM_ && m_timeExp < System . currentTimeMillis ( ) ) { reset ( ) ; } }
private static int determineConsecutiveBinaryCount ( String msg , int startpos , Charset encoding ) throws WriterException { final CharsetEncoder encoder = encoding . newEncoder ( ) ; int len = msg . length ( ) ; int idx = startpos ; while ( idx < len ) { char ch = msg . charAt ( idx ) ; int numericCount = NUM_ ; while ( numericCount < NUM_ && isDigit ( ch ) ) { numericCount ++ ; int i = idx + numericCount ; if ( i >= len ) { break ; } ch = msg . charAt ( i ) ; } if ( numericCount >= NUM_ ) { return idx - startpos ; } ch = msg . charAt ( idx ) ; if ( ! encoder . canEncode ( ch ) ) { throw new WriterException ( STR_ + ch + STR_ + ( int ) ch + STR_ ) ; } idx ++ ; } return idx - startpos ; }
public void removeSwipeListener ( SwipeListener listener ) { if ( mListeners == null ) { return ; } mListeners . remove ( listener ) ; }
private boolean apply ( GridClientPredicate < N > [ ] p , N n ) { if ( p != null ) { for ( GridClientPredicate < ? super N > r : p ) { if ( r != null && ! r . apply ( n ) ) return BOOL_ ; } } return BOOL_ ; }
public boolean hasName ( final String name ) { for ( final String n : names ) { if ( n . equalsIgnoreCase ( name ) ) { return BOOL_ ; } } return BOOL_ ; }
static MethodHandle makeSpreadArguments ( MethodHandle target , Class < ? > spreadArgType , int spreadArgPos , int spreadArgCount ) { MethodType targetType = target . type ( ) ; for ( int i = NUM_ ; i < spreadArgCount ; i ++ ) { Class < ? > arg = VerifyType . spreadArgElementType ( spreadArgType , i ) ; if ( arg == null ) arg = Object . class ; targetType = targetType . changeParameterType ( spreadArgPos + i , arg ) ; } target = target . asType ( targetType ) ; MethodType srcType = targetType . replaceParameterTypes ( spreadArgPos , spreadArgPos + spreadArgCount , spreadArgType ) ; MethodType lambdaType = srcType . invokerType ( ) ; Name [ ] names = arguments ( spreadArgCount + NUM_ , lambdaType ) ; int nameCursor = lambdaType . parameterCount ( ) ; int [ ] indexes = new int [ targetType . parameterCount ( ) ] ; for ( int i = NUM_ , argIndex = NUM_ ; i < targetType . parameterCount ( ) + NUM_ ; i ++ , argIndex ++ ) { Class < ? > src = lambdaType . parameterType ( i ) ; if ( i == spreadArgPos ) { MethodHandle aload = MethodHandles . arrayElementGetter ( spreadArgType ) ; Name array = names [ argIndex ] ; names [ nameCursor ++ ] = new Name ( Lazy . NF_checkSpreadArgument , array , spreadArgCount ) ; for ( int j = NUM_ ; j < spreadArgCount ; i ++ , j ++ ) { indexes [ i ] = nameCursor ; names [ nameCursor ++ ] = new Name ( aload , array , j ) ; } } else if ( i < indexes . length ) { indexes [ i ] = argIndex ; } } assert ( nameCursor == names . length - NUM_ ) ; Name [ ] targetArgs = new Name [ targetType . parameterCount ( ) ] ; for ( int i = NUM_ ; i < targetType . parameterCount ( ) ; i ++ ) { int idx = indexes [ i ] ; targetArgs [ i ] = names [ idx ] ; } names [ names . length - NUM_ ] = new Name ( target , ( Object [ ] ) targetArgs ) ; LambdaForm form = new LambdaForm ( STR_ , lambdaType . parameterCount ( ) , names ) ; return SimpleMethodHandle . make ( srcType , form ) ; }
public void dup2X2 ( ) { mv . visitInsn ( Opcodes . DUP2_X2 ) ; }
@ Override public boolean contains ( Object key ) { if ( key == null ) return _map . _nullValue != null ; K1 [ ] keys = _map . _keys ; for ( int i = keys . length - NUM_ ; i >= NUM_ ; i -- ) { K1 testKey = keys [ i ] ; if ( key . equals ( testKey ) ) return BOOL_ ; } return BOOL_ ; }
public Expression compile ( int opPos ) throws TransformerException { int op = getOp ( opPos ) ; Expression expr = null ; switch ( op ) { case OpCodes . OP_XPATH : expr = compile ( opPos + NUM_ ) ; break ; case OpCodes . OP_OR : expr = or ( opPos ) ; break ; case OpCodes . OP_AND : expr = and ( opPos ) ; break ; case OpCodes . OP_NOTEQUALS : expr = notequals ( opPos ) ; break ; case OpCodes . OP_EQUALS : expr = equals ( opPos ) ; break ; case OpCodes . OP_LTE : expr = lte ( opPos ) ; break ; case OpCodes . OP_LT : expr = lt ( opPos ) ; break ; case OpCodes . OP_GTE : expr = gte ( opPos ) ; break ; case OpCodes . OP_GT : expr = gt ( opPos ) ; break ; case OpCodes . OP_PLUS : expr = plus ( opPos ) ; break ; case OpCodes . OP_MINUS : expr = minus ( opPos ) ; break ; case OpCodes . OP_MULT : expr = mult ( opPos ) ; break ; case OpCodes . OP_DIV : expr = div ( opPos ) ; break ; case OpCodes . OP_MOD : expr = mod ( opPos ) ; break ; case OpCodes . OP_NEG : expr = neg ( opPos ) ; break ; case OpCodes . OP_STRING : expr = string ( opPos ) ; break ; case OpCodes . OP_BOOL : expr = bool ( opPos ) ; break ; case OpCodes . OP_NUMBER : expr = number ( opPos ) ; break ; case OpCodes . OP_UNION : expr = union ( opPos ) ; break ; case OpCodes . OP_LITERAL : expr = literal ( opPos ) ; break ; case OpCodes . OP_VARIABLE : expr = variable ( opPos ) ; break ; case OpCodes . OP_GROUP : expr = group ( opPos ) ; break ; case OpCodes . OP_NUMBERLIT : expr = numberlit ( opPos ) ; break ; case OpCodes . OP_ARGUMENT : expr = arg ( opPos ) ; break ; case OpCodes . OP_EXTFUNCTION : expr = compileExtension ( opPos ) ; break ; case OpCodes . OP_FUNCTION : expr = compileFunction ( opPos ) ; break ; case OpCodes . OP_LOCATIONPATH : expr = locationPath ( opPos ) ; break ; case OpCodes . OP_PREDICATE : expr = null ; break ; case OpCodes . OP_MATCHPATTERN : expr = matchPattern ( opPos + NUM_ ) ; break ; case OpCodes . OP_LOCATIONPATHPATTERN : expr = locationPathPattern ( opPos ) ; break ; case OpCodes . OP_QUO : error ( XPATHErrorResources . ER_UNKNOWN_OPCODE , new Object [ ] { STR_ } ) ; break ; default : error ( XPATHErrorResources . ER_UNKNOWN_OPCODE , new Object [ ] { Integer . toString ( getOp ( opPos ) ) } ) ; } return expr ; }
public static void replaceValue ( ExampleSet exampleSet , Attribute attribute , String oldValue , String newValue ) { if ( ! attribute . isNominal ( ) ) { throw new RuntimeException ( STR_ ) ; } NominalMapping mapping = attribute . getMapping ( ) ; if ( oldValue . equals ( STR_ ) ) { for ( Example example : exampleSet ) { if ( Double . isNaN ( example . getValue ( attribute ) ) ) { example . setValue ( attribute , mapping . mapString ( newValue ) ) ; } } } else { int oldIndex = mapping . getIndex ( oldValue ) ; if ( oldIndex < NUM_ ) { throw new RuntimeException ( STR_ ) ; } if ( newValue . equals ( STR_ ) ) { for ( Example example : exampleSet ) { int index = mapping . getIndex ( example . getValueAsString ( attribute ) ) ; if ( index == oldIndex ) { example . setValue ( attribute , Double . NaN ) ; } } return ; } int newIndex = mapping . getIndex ( newValue ) ; if ( newIndex >= NUM_ ) { for ( Example example : exampleSet ) { int index = mapping . getIndex ( example . getValueAsString ( attribute ) ) ; if ( index == oldIndex ) { example . setValue ( attribute , newIndex ) ; } } } else { mapping . setMapping ( newValue , oldIndex ) ; } } }
protected void encode ( ByteSequencesWriter writer , ByteArrayDataOutput output , byte [ ] buffer , BytesRef spare , BytesRef payload , Set < BytesRef > contexts , long weight ) throws IOException { int requiredLength = spare . length + NUM_ + ( ( hasPayloads ) ? NUM_ + payload . length : NUM_ ) ; if ( hasContexts ) { for ( BytesRef ctx : contexts ) { requiredLength += NUM_ + ctx . length ; } requiredLength += NUM_ ; } if ( requiredLength >= buffer . length ) { buffer = ArrayUtil . grow ( buffer , requiredLength ) ; } output . reset ( buffer ) ; output . writeBytes ( spare . bytes , spare . offset , spare . length ) ; if ( hasContexts ) { for ( BytesRef ctx : contexts ) { output . writeBytes ( ctx . bytes , ctx . offset , ctx . length ) ; output . writeShort ( ( short ) ctx . length ) ; } output . writeShort ( ( short ) contexts . size ( ) ) ; } if ( hasPayloads ) { output . writeBytes ( payload . bytes , payload . offset , payload . length ) ; output . writeShort ( ( short ) payload . length ) ; } output . writeLong ( weight ) ; writer . write ( buffer , NUM_ , output . getPosition ( ) ) ; }
public void printEntryDetails ( Writer w ) { int linesadded = - NUM_ ; String title ; try { HardcopyWriter ww = ( HardcopyWriter ) w ; int textSpace = ww . getCharactersPerLine ( ) - indentWidth - NUM_ ; title = STR_ ; if ( ( textSpaceWithIcon != NUM_ ) && ( linesadded < blanks ) ) { linesadded = writeWrappedComment ( w , _id , title , textSpaceWithIcon ) + linesadded ; } else { linesadded = writeWrappedComment ( w , _id , title , textSpace ) + linesadded ; } title = STR_ ; if ( ( textSpaceWithIcon != NUM_ ) && ( linesadded < blanks ) ) { linesadded = writeWrappedComment ( w , _fileName != null ? _fileName : STR_ , title , textSpaceWithIcon ) + linesadded ; } else { linesadded = writeWrappedComment ( w , _fileName != null ? _fileName : STR_ , title , textSpace ) + linesadded ; } if ( ! ( _roadName . isEmpty ( ) ) ) { title = STR_ ; if ( ( textSpaceWithIcon != NUM_ ) && ( linesadded < blanks ) ) { linesadded = writeWrappedComment ( w , _roadName , title , textSpaceWithIcon ) + linesadded ; } else { linesadded = writeWrappedComment ( w , _roadName , title , textSpace ) + linesadded ; } } if ( ! ( _roadNumber . isEmpty ( ) ) ) { title = STR_ ; if ( ( textSpaceWithIcon != NUM_ ) && ( linesadded < blanks ) ) { linesadded = writeWrappedComment ( w , _roadNumber , title , textSpaceWithIcon ) + linesadded ; } else { linesadded = writeWrappedComment ( w , _roadNumber , title , textSpace ) + linesadded ; } } if ( ! ( _mfg . isEmpty ( ) ) ) { title = STR_ ; if ( ( textSpaceWithIcon != NUM_ ) && ( linesadded < blanks ) ) { linesadded = writeWrappedComment ( w , _mfg , title , textSpaceWithIcon ) + linesadded ; } else { linesadded = writeWrappedComment ( w , _mfg , title , textSpace ) + linesadded ; } } if ( ! ( _owner . isEmpty ( ) ) ) { title = STR_ ; if ( ( textSpaceWithIcon != NUM_ ) && ( linesadded < blanks ) ) { linesadded = writeWrappedComment ( w , _owner , title , textSpaceWithIcon ) + linesadded ; } else { linesadded = writeWrappedComment ( w , _owner , title , textSpace ) + linesadded ; } } if ( ! ( _model . isEmpty ( ) ) ) { title = STR_ ; if ( ( textSpaceWithIcon != NUM_ ) && ( linesadded < blanks ) ) { linesadded = writeWrappedComment ( w , _model , title , textSpaceWithIcon ) + linesadded ; } else { linesadded = writeWrappedComment ( w , _model , title , textSpace ) + linesadded ; } } if ( ! ( _dccAddress . isEmpty ( ) ) ) { w . write ( newLine , NUM_ , NUM_ ) ; String s = STR_ + _dccAddress ; w . write ( s , NUM_ , s . length ( ) ) ; linesadded ++ ; } if ( ! ( _comment . isEmpty ( ) ) ) { for ( int i = NUM_ ; i < ( blanks - linesadded ) ; i ++ ) { w . write ( newLine , NUM_ , NUM_ ) ; } if ( blanks != NUM_ ) { blanks = NUM_ ; } title = STR_ ; linesadded = writeWrappedComment ( w , _comment , title , textSpace ) + linesadded ; } if ( ! ( _decoderModel . isEmpty ( ) ) ) { title = STR_ ; if ( ( textSpaceWithIcon != NUM_ ) && ( linesadded < blanks ) ) { linesadded = writeWrappedComment ( w , _decoderModel , title , textSpaceWithIcon ) + linesadded ; } else { linesadded = writeWrappedComment ( w , _decoderModel , title , textSpace ) + linesadded ; } } if ( ! ( _decoderFamily . isEmpty ( ) ) ) { title = STR_ ; if ( ( textSpaceWithIcon != NUM_ ) && ( linesadded < blanks ) ) { linesadded = writeWrappedComment ( w , _decoderFamily , title , textSpaceWithIcon ) + linesadded ; } else { linesadded = writeWrappedComment ( w , _decoderFamily , title , textSpace ) + linesadded ; } } if ( ! ( _decoderComment . isEmpty ( ) ) ) { for ( int i = NUM_ ; i < ( blanks - linesadded ) ; i ++ ) { w . write ( newLine , NUM_ , NUM_ ) ; } if ( blanks != NUM_ ) { blanks = NUM_ ; } title = STR_ ; linesadded = writeWrappedComment ( w , _decoderComment , title , textSpace ) + linesadded ; } w . write ( newLine , NUM_ , NUM_ ) ; for ( int i = - NUM_ ; i < ( blanks - linesadded ) ; i ++ ) { w . write ( newLine , NUM_ , NUM_ ) ; } } catch ( IOException e ) { log . error ( STR_ + e ) ; } }
private int skipQuotedString ( String str , int pos ) { int n = str . length ( ) ; pos += NUM_ ; while ( pos < n ) { if ( str . charAt ( pos ) == STR_ ) { if ( pos + NUM_ < n && str . charAt ( pos + NUM_ ) == STR_ ) { pos += NUM_ ; continue ; } return pos + NUM_ ; } pos += NUM_ ; } return n ; }
private static void addNewSegment ( LinkedList < DNASegment > segments , Event event , HashMap < Integer , DNAStrand > strands , int firstJulianDay , int minStart , int minMinutes ) { if ( event . startDay > event . endDay ) { Log . wtf ( TAG , STR_ + event . toString ( ) ) ; } if ( event . startDay != event . endDay ) { Event lhs = new Event ( ) ; lhs . color = event . color ; lhs . startDay = event . startDay ; lhs . startTime = event . startTime ; lhs . endDay = lhs . startDay ; lhs . endTime = DAY_IN_MINUTES - NUM_ ; while ( lhs . startDay != event . endDay ) { addNewSegment ( segments , lhs , strands , firstJulianDay , minStart , minMinutes ) ; lhs . startDay ++ ; lhs . endDay = lhs . startDay ; lhs . startTime = NUM_ ; minStart = NUM_ ; } lhs . endTime = event . endTime ; event = lhs ; } DNASegment segment = new DNASegment ( ) ; int dayOffset = ( event . startDay - firstJulianDay ) . DAY_IN_MINUTES ; int endOfDay = dayOffset + DAY_IN_MINUTES - NUM_ ; segment . startMinute = Math . max ( dayOffset + event . startTime , minStart ) ; int minEnd = Math . min ( segment . startMinute + minMinutes , endOfDay ) ; segment . endMinute = Math . max ( dayOffset + event . endTime , minEnd ) ; if ( segment . endMinute > endOfDay ) { segment . endMinute = endOfDay ; } segment . color = event . color ; segment . day = event . startDay ; segments . add ( segment ) ; DNAStrand strand = getOrCreateStrand ( strands , segment . color ) ; strand . count ++ ; }
private DatagramPacket [ ] encodeMulticastRequest ( final MulticastRequest req ) throws IOException { final Discovery disco = getDiscovery ( multicastRequestConstraints . chooseProtocolVersion ( ) ) ; final List packets = new ArrayList ( ) ; EncodeIterator ei = disco . encodeMulticastRequest ( req , multicastRequestConstraints . getMulticastMaxPacketSize ( DEFAULT_MAX_PACKET_SIZE ) , multicastRequestConstraints . getUnfulfilledConstraints ( ) ) ; while ( ei . hasNext ( ) ) { try { packets . addAll ( Arrays . asList ( ei . next ( ) ) ) ; } catch ( Exception e ) { logger . log ( ( e instanceof UnsupportedConstraintException ) ? Levels . HANDLED : Level . INFO , STR_ , e ) ; } } if ( packets . isEmpty ( ) ) { throw new DiscoveryProtocolException ( STR_ ) ; } return ( DatagramPacket [ ] ) packets . toArray ( new DatagramPacket [ packets . size ( ) ] ) ; }
public FeatureTypeConstraintModel ( FeatureTypeConstraintModelUpdateInterface parent ) { this . parentObj = parent ; columnList . add ( Localisation . getString ( FieldConfigBase . class , STR_ ) ) ; columnList . add ( Localisation . getString ( FieldConfigBase . class , STR_ ) ) ; }
protected void deleteDb ( String name ) { deleteDb ( getBaseDir ( ) , name ) ; }
public void removeAtRange ( int index , int size ) { final int end = Math . min ( mSize , index + size ) ; for ( int i = index ; i < end ; i ++ ) { removeAt ( i ) ; } }
private void pullEvent ( ) { final int newScrollValue ; final int itemDimension ; final float initialMotionValue , lastMotionValue ; switch ( getFilteredPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : initialMotionValue = mInitialMotionX ; lastMotionValue = mLastMotionX ; break ; case VERTICAL : default : initialMotionValue = mInitialMotionY ; lastMotionValue = mLastMotionY ; break ; } switch ( mCurrentMode ) { case PULL_FROM_END : newScrollValue = Math . round ( Math . max ( initialMotionValue - lastMotionValue , NUM_ ) / mFriction ) ; itemDimension = getFooterSize ( ) ; break ; case GOOGLE_STYLE : newScrollValue = Math . round ( Math . min ( initialMotionValue - lastMotionValue , NUM_ ) / mFriction ) ; itemDimension = getGoogleStyleViewSize ( ) ; break ; case PULL_FROM_START : default : newScrollValue = Math . round ( Math . min ( initialMotionValue - lastMotionValue , NUM_ ) / mFriction ) ; itemDimension = getHeaderSize ( ) ; break ; } setHeaderScroll ( newScrollValue ) ; if ( newScrollValue != NUM_ && ! isRefreshing ( ) ) { float scale = Math . abs ( newScrollValue ) / ( float ) itemDimension ; switch ( mCurrentMode ) { case PULL_FROM_END : mFooterLayout . onPull ( scale ) ; break ; case GOOGLE_STYLE : mGoogleStyleViewLayout . onPull ( scale ) ; mGoogleStyleProgressLayout . onPull ( scale ) ; break ; case PULL_FROM_START : default : mHeaderLayout . onPull ( scale ) ; break ; } if ( mState != State . PULL_TO_REFRESH && itemDimension >= Math . abs ( newScrollValue ) ) { setState ( State . PULL_TO_REFRESH ) ; } else if ( mState == State . PULL_TO_REFRESH && itemDimension < Math . abs ( newScrollValue ) ) { setState ( State . RELEASE_TO_REFRESH ) ; } } }
public void addElements ( final double [ ] values ) { final double [ ] tempArray = new double [ numElements + values . length + NUM_ ] ; System . arraycopy ( internalArray , startIndex , tempArray , NUM_ , numElements ) ; System . arraycopy ( values , NUM_ , tempArray , numElements , values . length ) ; internalArray = tempArray ; startIndex = NUM_ ; numElements += values . length ; }
public void registerUnregisteredNamespaces ( ) { for ( int i = NUM_ ; i < m_unregisteredExtensions . size ( ) ; i ++ ) { String ns = ( String ) m_unregisteredExtensions . get ( i ) ; ExtensionNamespaceSupport extNsSpt = defineJavaNamespace ( ns ) ; if ( extNsSpt != null ) m_extensions . add ( extNsSpt ) ; } }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . addElement ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return result . elements ( ) ; }
public Map < URI , List < URI > > addSourceVolumeSnapshots ( ) { List < URI > blockSnapshots = Lists . newArrayList ( ) ; Map < URI , List < URI > > snapshotsMap = new HashMap < > ( ) ; for ( URI volumeId : uris ( volumeIds ) ) { List < URI > snapshots = getSnapshots ( volumeId ) ; blockSnapshots . addAll ( snapshots ) ; snapshotsMap . put ( volumeId , snapshots ) ; } if ( ! blockSnapshots . isEmpty ( ) ) { BlockStorageUtils . addVolumesToConsistencyGroup ( consistencyGroup , blockSnapshots ) ; } return snapshotsMap ; }
public static void logInitiator ( Initiator initiator , NetworkLite network ) { String networkName = ( network != null ? network . getLabel ( ) : STR_ ) ; _log . info ( String . format ( STR_ , initiator . getInitiatorPort ( ) , initiator . getHostName ( ) , networkName ) ) ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
public static final Criterion and ( Criterion one , Criterion two ) { final List < Criterion > criteria = new ArrayList < Criterion > ( ) ; criteria . add ( one ) ; criteria . add ( two ) ; return new ConjunctionCriterion ( Conjunction . AND , criteria ) ; }
public CCMenuItem ( Object rec , String cb ) { targetCallback = rec ; selector = cb ; setAnchorPoint ( CGPoint . make ( NUM_ , NUM_ ) ) ; invocation = null ; if ( rec != null && cb != null ) { Class < ? > cls = rec . getClass ( ) ; try { invocation = cls . getMethod ( cb , Object . class ) ; } catch ( SecurityException e ) { e . printStackTrace ( ) ; } catch ( NoSuchMethodException e ) { e . printStackTrace ( ) ; } } isEnabled_ = BOOL_ ; isSelected_ = BOOL_ ; }
public void addChildElement ( XMLElement child , boolean addAfterNewLine ) throws Exception { addChildElementAt ( child , - NUM_ , addAfterNewLine ) ; }
public void editText ( VisualItem item , String attribute , Rectangle r ) { if ( m_editing ) { stopEditing ( ) ; } String txt = item . getString ( attribute ) ; m_editItem = item ; m_editAttribute = attribute ; Color tc = ColorLib . getColor ( item . getTextColor ( ) ) ; Color fc = ColorLib . getColor ( item . getFillColor ( ) ) ; m_editor . setForeground ( tc ) ; m_editor . setBackground ( fc ) ; editText ( txt , r ) ; }
public static Column column ( final String id , final String title , final int width , final int doublePrecision ) { return new Column ( id , title , Math . max ( width , title . length ( ) ) , doublePrecision ) ; }
public void printCount ( String kind , int count ) { if ( count != NUM_ ) { String key ; if ( count == NUM_ ) key = STR_ + kind ; else key = STR_ + kind + STR_ ; log . printLines ( WriterKind . ERROR , key , String . valueOf ( count ) ) ; log . flush ( Log . WriterKind . ERROR ) ; } }
public static byte [ ] decode ( String str , int flags ) { return decode ( str . getBytes ( ) , flags ) ; }
public static float screenToScroll ( float x , float warpSize ) { if ( x <= NUM_ ) return NUM_ ; if ( x >= warpSize ) return x + warpSize ; return ( float ) Math . sqrt ( x . warpSize ) . NUM_ ; }
protected static final String addEscapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = NUM_ ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case NUM_ : continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < x20 || ch > x7e ) { String s = STR_ + Integer . toString ( ch , NUM_ ) ; retval . append ( STR_ + s . substring ( s . length ( ) - NUM_ , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; }
public synchronized void recordStatistics ( QueryStatistic statistic ) { queryStatistics . add ( statistic ) ; }
protected double [ ] randomSubRange ( double boundStart , double boundLen ) { if ( boundLen >= NUM_ && usually ( ) ) { int intBoundStart = ( int ) Math . ceil ( boundStart ) ; int intBoundEnd = ( int ) ( boundStart + boundLen ) ; int intBoundLen = intBoundEnd - intBoundStart ; int newLen = ( int ) randomGaussianMeanMax ( intBoundLen / NUM_ , intBoundLen ) ; int newStart = intBoundStart + randomInt ( intBoundLen - newLen ) ; return new double [ ] { newStart , newLen } ; } else { double newLen = randomGaussianMeanMax ( boundLen / NUM_ , boundLen ) ; double newStart = boundStart + ( boundLen - newLen == NUM_ ? NUM_ : ( randomDouble ( ) % ( boundLen - newLen ) ) ) ; return new double [ ] { newStart , newLen } ; } }
private DateTimeZone generateTimeZone ( String timeZoneId , DateTimeZone systemTimeZone ) { if ( timeZoneId == null ) { return systemTimeZone ; } try { return DateTimeZone . forID ( timeZoneId ) ; } catch ( IllegalArgumentException ignored ) { LOG . debug ( INVALID_TIME_ZONE . logFormat ( timeZoneId ) ) ; throw new BadApiRequestException ( INVALID_TIME_ZONE . format ( timeZoneId ) ) ; } }
protected String toString ( String [ ] [ ] strings ) { int rows = strings . length ; int columns = strings . length <= NUM_ ? NUM_ : strings [ NUM_ ] . length ; StringBuffer total = new StringBuffer ( ) ; StringBuffer s = new StringBuffer ( ) ; for ( int row = NUM_ ; row < rows ; row ++ ) { s . setLength ( NUM_ ) ; for ( int column = NUM_ ; column < columns ; column ++ ) { s . append ( strings [ row ] [ column ] ) ; if ( column < columns - NUM_ ) s . append ( columnSeparator ) ; } total . append ( s ) ; if ( row < rows - NUM_ ) total . append ( rowSeparator ) ; } return total . toString ( ) ; }
public void checkWarehouse ( boolean sbf ) { if ( warehouse == null ) { logger . fine ( STR_ ) ; warehouse = new VPFAutoFeatureGraphicWarehouse ( ) ; } }
public double maxDist ( SpatialComparable mbr1 , SpatialComparable mbr2 ) { final int dim1 = mbr1 . getDimensionality ( ) , dim2 = mbr2 . getDimensionality ( ) ; final int mindim = ( dim1 < dim2 ) ? dim1 : dim2 ; double agg = NUM_ ; for ( int d = NUM_ ; d < mindim ; d ++ ) { double d1 = mbr1 . getMax ( d ) - mbr2 . getMin ( d ) ; double d2 = mbr2 . getMax ( d ) - mbr1 . getMin ( d ) ; double delta = d1 > d2 ? d1 : d2 ; agg += delta . delta ; } for ( int d = mindim ; d < dim1 ; d ++ ) { double d1 = Math . abs ( mbr1 . getMin ( d ) ) , d2 = Math . abs ( mbr1 . getMax ( d ) ) ; double delta = d1 > d2 ? d1 : d2 ; agg += delta . delta ; } for ( int d = mindim ; d < dim2 ; d ++ ) { double d1 = Math . abs ( mbr2 . getMin ( d ) ) , d2 = Math . abs ( mbr2 . getMax ( d ) ) ; double delta = d1 > d2 ? d1 : d2 ; agg += delta . delta ; } return Math . sqrt ( agg ) ; }
public static void createLesson ( @ NotNull final Lesson lesson , @ NotNull final VirtualFile courseDir , @ NotNull final File resourceRoot , @ NotNull final Project project ) throws IOException { String lessonDirName = EduNames . LESSON + Integer . toString ( lesson . getIndex ( ) ) ; VirtualFile lessonDir = courseDir . createChildDirectory ( project , lessonDirName ) ; final List < Task > taskList = lesson . getTaskList ( ) ; for ( int i = NUM_ ; i <= taskList . size ( ) ; i ++ ) { Task task = taskList . get ( i - NUM_ ) ; task . setIndex ( i ) ; createTask ( task , lessonDir , new File ( resourceRoot , lessonDir . getName ( ) ) , project ) ; } }
protected void rehash ( ) { int oldCapacity = table . length ; CacheEntry oldTable [ ] = table ; int newCapacity = oldCapacity . NUM_ + NUM_ ; CacheEntry newTable [ ] = new CacheEntry [ newCapacity ] ; threshold = ( int ) ( newCapacity . loadFactor ) ; table = newTable ; for ( int i = oldCapacity ; i -- > NUM_ ; ) { for ( CacheEntry old = oldTable [ i ] ; old != null ; ) { CacheEntry e = old ; old = old . next ; if ( e . check ( ) != null ) { int index = ( e . hash & x7FFFFFFF ) % newCapacity ; e . next = newTable [ index ] ; newTable [ index ] = e ; } else count -- ; } } }
public void append ( byte [ ] utf8 , int start , int len ) { setCapacity ( length + len , BOOL_ ) ; System . arraycopy ( utf8 , start , bytes , length , len ) ; length += len ; }
public static String makeLogTag ( Class cls ) { return makeLogTag ( cls . getSimpleName ( ) ) ; }
private void handleError ( GCPStatsDataHolder statsData , Throwable e ) { logSevere ( e ) ; statsData . error = e ; statsData . stage = StatsCollectionStage . ERROR ; handleStatsRequest ( statsData ) ; }
public java . lang . StringBuilder insert ( int offset , double d ) { return insert ( offset , Double . toString ( d ) ) ; }
public Object castToType ( int t , XPathContext support ) throws javax . xml . transform . TransformerException { Object result ; switch ( t ) { case CLASS_STRING : result = str ( ) ; break ; case CLASS_NUMBER : result = new Double ( num ( ) ) ; break ; case CLASS_NODESET : result = iter ( ) ; break ; case CLASS_BOOLEAN : result = new Boolean ( bool ( ) ) ; break ; case CLASS_UNKNOWN : result = m_obj ; break ; default : error ( XPATHErrorResources . ER_CANT_CONVERT_TO_TYPE , new Object [ ] { getTypeString ( ) , Integer . toString ( t ) } ) ; result = null ; } return result ; }
public static boolean areMsCapiStoresSupported ( ) { return Security . getProvider ( MS_CAPI . jce ( ) ) != null ; }
public boolean isCritical ( ) { return BOOL_ ; }
public boolean isPassthroughSupported ( String mimeType ) { return audioCapabilities != null && audioCapabilities . supportsEncoding ( getEncodingForMimeType ( mimeType ) ) ; }
String internalsprintf ( final Object s ) { final String s2 ; if ( conversionCharacter == STR_ || conversionCharacter == STR_ ) { s2 = printSFormat ( s . toString ( ) ) ; } else { throw new IllegalArgumentException ( STR_ + STR_ + conversionCharacter + STR_ ) ; } return s2 ; }
public T firstItem ( ) { if ( mDataList == null || mDataList . size ( ) == NUM_ ) { return null ; } return mDataList . get ( NUM_ ) ; }
public void addRequestProperty ( String field , String newValue ) { checkNotConnected ( ) ; if ( field == null ) { throw new NullPointerException ( STR_ ) ; } }
public double doOperation ( ) throws OperatorFailedException { double [ ] mean = sccs . getMode ( ) ; double [ ] currentValue = parameter . getParameterValues ( ) ; double [ ] newValue = new double [ dim ] ; Set < Integer > updateSet = new HashSet < Integer > ( ) ; if ( setSizeMean != - NUM_ ) { final int listLength = Poisson . nextPoisson ( setSizeMean ) ; while ( updateSet . size ( ) < listLength ) { int newInt = MathUtils . nextInt ( parameter . getDimension ( ) ) ; if ( ! updateSet . contains ( newInt ) ) { updateSet . add ( newInt ) ; } } } else { for ( int i = NUM_ ; i < dim ; ++ i ) { updateSet . add ( i ) ; } } double logq = NUM_ ; for ( Integer i : updateSet ) { newValue [ i ] = mean [ i ] + scaleFactor . MathUtils . nextGaussian ( ) ; if ( UPDATE_ALL ) { parameter . setParameterValueQuietly ( i , newValue [ i ] ) ; } else { parameter . setParameterValue ( i , newValue [ i ] ) ; } logq += ( NormalDistribution . logPdf ( currentValue [ i ] , mean [ i ] , scaleFactor ) - NormalDistribution . logPdf ( newValue [ i ] , mean [ i ] , scaleFactor ) ) ; } if ( UPDATE_ALL ) { parameter . setParameterValueNotifyChangedAll ( NUM_ , parameter . getParameterValue ( NUM_ ) ) ; } return logq ; }
public Object load ( URI uri ) throws IOException { InputStreamReader src = null ; try { src = new FileReader ( new File ( uri ) ) ; return xstream . fromXML ( src ) ; } finally { if ( null != src ) { src . close ( ) ; } } }
private synchronized void sendPendingState ( ) { if ( ! mPendingClients . isEmpty ( ) ) { final Message [ ] messages = new Message [ ] { SantaServiceMessages . getBeginFullStateMessage ( ) , SantaServiceMessages . getSwitchOffMessage ( mPreferences . getSwitchOff ( ) ) , getTimeUpdateMessage ( ) , SantaServiceMessages . getCastDisabledMessage ( mPreferences . getCastDisabled ( ) ) , SantaServiceMessages . getGamesMessage ( mPreferences . getGumballDisabled ( ) , mPreferences . getJetpackDisabled ( ) , mPreferences . getMemoryDisabled ( ) , mPreferences . getRocketDisabled ( ) , mPreferences . getDancerDisabled ( ) , mPreferences . getSnowdownDisabled ( ) ) , SantaServiceMessages . getDestinationPhotoMessage ( mPreferences . getDestinationPhotoDisabled ( ) ) , SantaServiceMessages . getStateMessage ( mState ) , SantaServiceMessages . getVideosMessage ( mPreferences . getVideos ( ) ) } ; for ( int i = NUM_ ; i < mPendingClients . size ( ) ; i ++ ) { final Messenger messenger = mPendingClients . get ( i ) ; try { for ( Message msg : messages ) { messenger . send ( msg ) ; } mClients . add ( messenger ) ; } catch ( RemoteException e ) { } mPendingClients . remove ( i ) ; } } }
private void fetchChunk ( BulkIdParam input , List < T > results ) { List < T > items = getBulkResources ( input ) ; for ( T item : items ) { results . add ( item ) ; } }
public static void moveDirectoryToDirectory ( File src , File destDir , boolean createDestDir ) throws IOException { if ( src == null ) { throw new NullPointerException ( STR_ ) ; } if ( destDir == null ) { throw new NullPointerException ( STR_ ) ; } if ( ! destDir . exists ( ) && createDestDir ) { destDir . mkdirs ( ) ; } if ( ! destDir . exists ( ) ) { throw new FileNotFoundException ( STR_ + destDir + STR_ + createDestDir + STR_ ) ; } if ( ! destDir . isDirectory ( ) ) { throw new IOException ( STR_ + destDir + STR_ ) ; } moveDirectory ( src , new File ( destDir , src . getName ( ) ) ) ; }
public Shape createCheckMark ( final int x , final int y , final int w , final int h ) { double xf = w / NUM_ ; double hf = h / NUM_ ; path . reset ( ) ; path . moveTo ( x , y + NUM_ . hf ) ; path . lineTo ( x + NUM_ . xf , y + NUM_ . hf ) ; path . lineTo ( x + NUM_ . xf , y + NUM_ . hf ) ; path . lineTo ( x + NUM_ . xf , y ) ; path . lineTo ( x + NUM_ . xf , y ) ; path . lineTo ( x + NUM_ . xf , y + NUM_ . hf ) ; path . closePath ( ) ; return path ; }
public static ResponseData parse ( String responseData ) { int index = responseData . indexOf ( STR_ ) ; String mainData , extraData ; if ( - NUM_ == index ) { mainData = responseData ; extraData = STR_ ; } else { mainData = responseData . substring ( NUM_ , index ) ; extraData = index >= responseData . length ( ) ? STR_ : responseData . substring ( index + NUM_ ) ; } String [ ] fields = TextUtils . split ( mainData , Pattern . quote ( STR_ ) ) ; if ( fields . length < NUM_ ) { throw new IllegalArgumentException ( ) ; } ResponseData data = new ResponseData ( ) ; data . extra = extraData ; data . responseCode = Integer . parseInt ( fields [ NUM_ ] ) ; data . nonce = Integer . parseInt ( fields [ NUM_ ] ) ; data . packageName = fields [ NUM_ ] ; data . versionCode = fields [ NUM_ ] ; data . userId = fields [ NUM_ ] ; data . timestamp = Long . parseLong ( fields [ NUM_ ] ) ; return data ; }
public int noOfTabs ( ) { return m_curWinTab . getTabCount ( ) ; }
public void testExceptionally_exceptionalCompletionActionFailed ( ) { for ( boolean createIncomplete : new boolean [ ] { BOOL_ , BOOL_ } ) { final AtomicInteger a = new AtomicInteger ( NUM_ ) ; final CFException ex1 = new CFException ( ) ; final CFException ex2 = new CFException ( ) ; final CompletableFuture < Integer > f = new CompletableFuture < > ( ) ; if ( ! createIncomplete ) f . completeExceptionally ( ex1 ) ; final CompletableFuture < Integer > g = f . exceptionally ( null ) ; if ( createIncomplete ) f . completeExceptionally ( ex1 ) ; checkCompletedWithWrappedException ( g , ex2 ) ; checkCompletedExceptionally ( f , ex1 ) ; assertEquals ( NUM_ , a . get ( ) ) ; } }
private static void close ( Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( IOException e ) { } } }
public static String convertTimestampToDateStringCompact ( boolean useUTC , long milli ) { Date date = new Date ( milli ) ; SimpleDateFormat sourceFormat = new SimpleDateFormat ( STR_ ) ; sourceFormat . setTimeZone ( useUTC ? TimeZone . getTimeZone ( STR_ ) : TimeZone . getDefault ( ) ) ; return sourceFormat . format ( date ) ; }
protected synchronized void superposeBitSet ( FixedBitSet incomingBitSet , double weight ) { weight = ( int ) Math . round ( weight . Math . pow ( NUM_ , BINARY_VECTOR_DECIMAL_PLACES ) ) ; if ( weight == NUM_ ) return ; totalNumberOfVotes . set ( totalNumberOfVotes . get ( ) + ( int ) weight ) ; int logFloorOfWeight = ( int ) ( Math . floor ( Math . log ( weight ) / Math . log ( NUM_ ) ) ) ; if ( logFloorOfWeight < votingRecord . size ( ) - NUM_ ) { while ( logFloorOfWeight > NUM_ ) { superposeBitSetFromRowFloor ( incomingBitSet , logFloorOfWeight ) ; weight = weight - ( int ) Math . pow ( NUM_ , logFloorOfWeight ) ; logFloorOfWeight = ( int ) ( Math . floor ( Math . log ( weight ) / Math . log ( NUM_ ) ) ) ; } } for ( int x = NUM_ ; x < weight ; x ++ ) superposeBitSetFromRowFloor ( incomingBitSet , NUM_ ) ; }
public final double tanHalfAngle ( ) { return Math . tan ( NUM_ . this . radians ) ; }
abstract Future < AsynchronousSocketChannel > implAccept ( Object attachment , CompletionHandler < AsynchronousSocketChannel , Object > handler ) ;
public void parseSignaturesFile ( URL url ) throws IOException , ParseException { parseSignaturesFile ( url . openStream ( ) , url . toString ( ) ) ; }
public void addFlare ( Flare flare ) { flares . addElement ( flare ) ; processGameEvent ( new GameBoardChangeEvent ( this ) ) ; }
public static void objectStringNonRecursive ( @ Unretained Object obj , StringBuilder sb ) { if ( obj instanceof Object [ ] ) { sb . append ( STR_ ) ; boolean first = BOOL_ ; for ( Object o : ( Object [ ] ) obj ) { if ( ! first ) { sb . append ( STR_ ) ; sb . append ( o ) ; } else { first = BOOL_ ; objectStringWithBytes ( o , sb ) ; } } sb . append ( STR_ ) ; } else { objectStringWithBytes ( obj , sb ) ; } }
public void readOSM ( File file ) { if ( file . exists ( ) ) { streetLayer . openOSM ( file ) ; } else { LOG . info ( STR_ ) ; } }
public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws SAXException { String msg = STR_ ; if ( ! ( handler . getElemTemplateElement ( ) instanceof Stylesheet ) ) { msg = STR_ ; handler . error ( msg , new SAXException ( msg ) ) ; } super . startElement ( handler , uri , localName , rawName , attributes ) ; String val = attributes . getValue ( STR_ ) ; int indexOfColon = val . indexOf ( STR_ ) ; if ( indexOfColon > NUM_ ) { } else { msg = STR_ ; handler . error ( msg , new SAXException ( msg ) ) ; } }
public void write ( byte [ ] buffer , int offset , int length ) throws IOException { _file . write ( buffer , offset , length ) ; }
public static boolean canInteract ( Role issuer , Role target ) { if ( issuer . getGuild ( ) != target . getGuild ( ) ) throw new IllegalArgumentException ( STR_ ) ; return target . getPosition ( ) < issuer . getPosition ( ) ; }
public Webster ( ) throws BindException { this . port = Integer . getInteger ( WEBSTER_PORT , NUM_ ) ; initialize ( ) ; }
public boolean willThrowExceptionIfKeyWasNotFound ( ) { return throwex ; }
public void testComputeLocationWhenUberwarPackaging ( ) throws Exception { Deployable deployableElement = new Deployable ( ) ; deployableElement . setGroupId ( STR_ ) ; deployableElement . setArtifactId ( STR_ ) ; deployableElement . setType ( STR_ ) ; String location = deployableElement . computeLocation ( createDefaultProject ( STR_ , null ) ) ; assertTrue ( location . endsWith ( STR_ ) ) ; }
public Response createResponse ( String responseString ) throws java . text . ParseException { if ( responseString == null ) return new SIPResponse ( ) ; StringMsgParser smp = new StringMsgParser ( ) ; SIPMessage sipMessage = smp . parseSIPMessage ( responseString . getBytes ( ) , BOOL_ , BOOL_ , null ) ; if ( ! ( sipMessage instanceof SIPResponse ) ) throw new ParseException ( responseString , NUM_ ) ; return ( SIPResponse ) sipMessage ; }
private ODEStateAndDerivative state ( double t ) { return new ODEStateAndDerivative ( t , new double [ NUM_ ] , new double [ NUM_ ] ) ; }
public static Class < ? > findCommonElementType ( Collection collection ) { if ( isEmpty ( collection ) ) { return null ; } Class < ? > candidate = null ; for ( Object val : collection ) { if ( val != null ) { if ( candidate == null ) { candidate = val . getClass ( ) ; } else if ( candidate != val . getClass ( ) ) { return null ; } } } return candidate ; }
private static void decodeHanziSegment ( BitSource bits , StringBuilder result , int count ) throws FormatException { if ( count . NUM_ > bits . available ( ) ) { throw FormatException . getFormatInstance ( ) ; } byte [ ] buffer = new byte [ NUM_ . count ] ; int offset = NUM_ ; while ( count > NUM_ ) { int twoBytes = bits . readBits ( NUM_ ) ; int assembledTwoBytes = ( ( twoBytes / x060 ) << NUM_ ) | ( twoBytes % x060 ) ; if ( assembledTwoBytes < x003BF ) { assembledTwoBytes += x0A1A1 ; } else { assembledTwoBytes += x0A6A1 ; } buffer [ offset ] = ( byte ) ( ( assembledTwoBytes > > NUM_ ) & xFF ) ; buffer [ offset + NUM_ ] = ( byte ) ( assembledTwoBytes & xFF ) ; offset += NUM_ ; count -- ; } try { result . append ( new String ( buffer , StringUtils . GB2312 ) ) ; } catch ( UnsupportedEncodingException uee ) { throw FormatException . getFormatInstance ( ) ; } }
protected void initPingIntervalMilli ( ) { String pingIntervalMilliParam = getInitParameter ( STR_ ) ; setPingIntervalMilli ( ( pingIntervalMilliParam == null ) ? DEFAULT_PING_INTERVAL_MILLI : Integer . parseInt ( pingIntervalMilliParam ) ) ; if ( isDebug ( ) ) { log ( STR_ + getPingIntervalMilli ( ) ) ; } }
public boolean ask ( final String queryStr , String externalQueryId ) throws Exception { final RepositoryConnection cxn = cxn ( ) ; UUID queryId = null ; try { final BooleanQuery query = ( BooleanQuery ) cxn . prepareBooleanQuery ( QueryLanguage . SPARQL , queryStr ) ; setMaxQueryTime ( query ) ; if ( query instanceof BigdataSailBooleanQuery && cxn instanceof BigdataSailRepositoryConnection ) { final BigdataSailBooleanQuery bdtq = ( BigdataSailBooleanQuery ) query ; queryId = setupQuery ( ( BigdataSailRepositoryConnection ) cxn , bdtq . getASTContainer ( ) , QueryType . ASK , externalQueryId ) ; } final boolean result = query . evaluate ( ) ; return result ; } finally { if ( queryId != null ) { finalizeQuery ( queryId ) ; } } }
@ SuppressWarnings ( STR_ ) private static int find ( Object [ ] arr , net . sourceforge . retroweaver . harmony . runtime . java . lang . Comparable val , int bnd , int l , int r ) { int m = l ; int d = NUM_ ; while ( m <= r ) { if ( val . compareTo ( arr [ m ] ) > bnd ) { l = m + NUM_ ; } else { r = m - NUM_ ; break ; } m += d ; d <<= NUM_ ; } while ( l <= r ) { m = ( l + r ) > > > NUM_ ; if ( val . compareTo ( arr [ m ] ) > bnd ) { l = m + NUM_ ; } else { r = m - NUM_ ; } } return l - NUM_ ; }
ConfigurationError ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; }
public static String asHex ( byte [ ] bytes , String separator ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = NUM_ ; i < bytes . length ; i ++ ) { String code = Integer . toHexString ( bytes [ i ] & xFF ) ; if ( ( bytes [ i ] & xFF ) < NUM_ ) { sb . append ( STR_ ) ; } sb . append ( code ) ; if ( separator != null && i < bytes . length - NUM_ ) { sb . append ( separator ) ; } } return sb . toString ( ) ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; String badString ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; nameNode = elementList . item ( NUM_ ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; { boolean success = BOOL_ ; try { badString = child . substringData ( NUM_ , NUM_ ) ; } catch ( DOMException ex ) { success = ( ex . code == DOMException . INDEX_SIZE_ERR ) ; } assertTrue ( STR_ , success ) ; } }
public String toString ( ) { return String . valueOf ( val ) ; }
private static void CallStaticVoidMethodV ( JNIEnvironment env , int classJREF , int methodID , Address argAddress ) throws Exception { if ( traceJNI ) VM . sysWrite ( STR_ ) ; RuntimeEntrypoints . checkJNICountDownToGC ( ) ; try { JNIHelpers . invokeWithVarArg ( methodID , argAddress , TypeReference . Void ) ; } catch ( Throwable unexpected ) { if ( traceJNI ) unexpected . printStackTrace ( System . err ) ; env . recordException ( unexpected ) ; } }
public static Connection createConnection ( boolean autoCommit , int trxLevel ) { Connection conn = s_cc . getConnection ( autoCommit , trxLevel ) ; if ( CLogMgt . isLevelFinest ( ) ) { } try { if ( conn != null && conn . getAutoCommit ( ) != autoCommit ) { throw new IllegalStateException ( STR_ + autoCommit + STR_ ) ; } } catch ( SQLException e ) { } return conn ; }
private boolean updateStatementData ( StatementData sdata , Matcher matcher , String toRegex ) { if ( transformTables ) return BOOL_ ; if ( matcher == null ) return BOOL_ ; String schema = sdata . getDefaultSchema ( ) ; if ( schema == null ) return BOOL_ ; matcher . reset ( schema ) ; if ( matcher . matches ( ) ) { String oldSchema = schema ; sdata . setDefaultSchema ( matcher . replaceAll ( toRegex ) ) ; if ( logger . isDebugEnabled ( ) ) logger . debug ( STR_ + oldSchema + STR_ + sdata . getDefaultSchema ( ) ) ; return BOOL_ ; } return BOOL_ ; }
public void testShiftLeft1 ( ) { byte aBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int number = NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger result = aNumber . shiftLeft ( number ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public void stopIfRequired ( ) { if ( System . currentTimeMillis ( ) > stopAt ) { throw new IllegalStateException ( ) ; } }
private void linkAccount ( final String principalId , final NameID nameId ) throws SAML2MetaException , AuthenticationException { final String spEntityId = metaManager . getEntityByMetaAlias ( metaAlias ) ; try { NameIDInfo info = new NameIDInfo ( spEntityId , entityName , nameId , SAML2Constants . SP_ROLE , BOOL_ ) ; DEBUG . message ( STR_ , principalId , nameId . getValue ( ) ) ; if ( shouldPersistNameID ( spEntityId ) ) { AccountUtils . setAccountFederation ( info , principalId ) ; } principal = new SAML2Principal ( principalId ) ; } catch ( SAML2Exception e ) { throw new AuthenticationException ( BUNDLE_NAME , STR_ , new Object [ NUM_ ] ) ; } }
private void enableActions ( ) { restoreAction . setEnabled ( frame . isMaximum ( ) || frame . isIcon ( ) ) ; maximizeAction . setEnabled ( ( frame . isMaximizable ( ) && ! frame . isMaximum ( ) && ! frame . isIcon ( ) ) || ( frame . isMaximizable ( ) && frame . isIcon ( ) ) ) ; iconifyAction . setEnabled ( frame . isIconifiable ( ) && ! frame . isIcon ( ) ) ; closeAction . setEnabled ( frame . isClosable ( ) ) ; sizeAction . setEnabled ( BOOL_ ) ; moveAction . setEnabled ( BOOL_ ) ; }
private List < String > addRules ( int filterId , List < String > rules , boolean useCosmetics ) { InputStream inputStream = null ; InputStreamReader inputStreamReader = null ; BufferedReader reader = null ; try { String fileName = getOrCreateFilterFile ( filterId ) ; inputStream = context . openFileInput ( fileName ) ; inputStreamReader = new InputStreamReader ( inputStream ) ; reader = new BufferedReader ( inputStreamReader ) ; String line = reader . readLine ( ) ; while ( line != null ) { if ( useCosmetics || ! FilterRule . isCosmeticRule ( line ) ) { rules . add ( line ) ; } line = reader . readLine ( ) ; } return rules ; } catch ( Exception ex ) { log . error ( STR_ , filterId , ex ) ; throw new RuntimeException ( STR_ + filterId , ex ) ; } finally { IOUtils . closeQuietly ( inputStream ) ; IOUtils . closeQuietly ( inputStreamReader ) ; IOUtils . closeQuietly ( reader ) ; } }
public static String convertToHexString ( byte [ ] bytes ) { int size = bytes . length ; StringBuffer buffer = new StringBuffer ( size . NUM_ ) ; for ( int i = NUM_ ; i < size ; i ++ ) { int x = bytes [ i ] ; if ( x < NUM_ ) x += NUM_ ; String tmp = Integer . toHexString ( x ) ; if ( tmp . length ( ) == NUM_ ) buffer . append ( STR_ ) ; buffer . append ( tmp ) ; } return buffer . toString ( ) ; }
public OrderedTask ( String identifier , Step ... steps ) { this ( identifier , Arrays . asList ( steps ) ) ; }
public void randomize ( List < CellIndex > cellIndices ) { Random rand = new Random ( ) ; int range = getUpperBound ( ) - getLowerBound ( ) ; for ( CellIndex cellIndex : cellIndices ) { int row = cellIndex . row ; int col = cellIndex . col ; double value = ( rand . nextDouble ( ) . range ) + getLowerBound ( ) ; setLogicalValue ( row , col , value , BOOL_ ) ; } fireTableDataChanged ( ) ; }
private void readResponseHeaders ( State state , InnerState innerState , HttpResponse response ) throws StopRequest { Header header = response . getFirstHeader ( STR_ ) ; if ( header != null ) { innerState . mHeaderContentDisposition = header . getValue ( ) ; } header = response . getFirstHeader ( STR_ ) ; if ( header != null ) { innerState . mHeaderContentLocation = header . getValue ( ) ; } header = response . getFirstHeader ( STR_ ) ; if ( header != null ) { innerState . mHeaderETag = header . getValue ( ) ; } String headerTransferEncoding = null ; header = response . getFirstHeader ( STR_ ) ; if ( header != null ) { headerTransferEncoding = header . getValue ( ) ; } String headerContentType = null ; header = response . getFirstHeader ( STR_ ) ; if ( header != null ) { headerContentType = header . getValue ( ) ; if ( ! headerContentType . equals ( STR_ ) ) { throw new StopRequest ( DownloaderService . STATUS_FILE_DELIVERED_INCORRECTLY , STR_ ) ; } } if ( headerTransferEncoding == null ) { header = response . getFirstHeader ( STR_ ) ; if ( header != null ) { innerState . mHeaderContentLength = header . getValue ( ) ; long contentLength = Long . parseLong ( innerState . mHeaderContentLength ) ; if ( contentLength != - NUM_ && contentLength != mInfo . mTotalBytes ) { Log . e ( Constants . TAG , STR_ ) ; } } } else { if ( Constants . LOGVV ) { Log . v ( Constants . TAG , STR_ ) ; } } if ( Constants . LOGVV ) { Log . v ( Constants . TAG , STR_ + innerState . mHeaderContentDisposition ) ; Log . v ( Constants . TAG , STR_ + innerState . mHeaderContentLength ) ; Log . v ( Constants . TAG , STR_ + innerState . mHeaderContentLocation ) ; Log . v ( Constants . TAG , STR_ + innerState . mHeaderETag ) ; Log . v ( Constants . TAG , STR_ + headerTransferEncoding ) ; } boolean noSizeInfo = innerState . mHeaderContentLength == null && ( headerTransferEncoding == null || ! headerTransferEncoding . equalsIgnoreCase ( STR_ ) ) ; if ( noSizeInfo ) { throw new StopRequest ( DownloaderService . STATUS_HTTP_DATA_ERROR , STR_ ) ; } }
public void addAuditory ( int id ) { mAuditoryFeedback . add ( id ) ; }
public String wrap ( String path ) { return uriPrefix + path ; }
public static void constantAttributes ( SimpleMethod method , Element element , String ... attributeNames ) throws ValidationException { for ( String name : attributeNames ) { String attributeValue = element . getAttribute ( name ) ; if ( ! MiniLangUtil . isConstantAttribute ( attributeValue ) ) { handleError ( STR_ + name + STR_ , method , element ) ; } } }
private void bindViewType ( WXComponent component ) { int id = generateViewType ( component ) ; if ( mViewTypes == null ) { mViewTypes = new SparseArray < > ( ) ; } ArrayList < WXComponent > mTypes = mViewTypes . get ( id ) ; if ( mTypes == null ) { mTypes = new ArrayList < > ( ) ; mViewTypes . put ( id , mTypes ) ; } mTypes . add ( component ) ; }
protected boolean isEmptyValue ( Object rawValue ) { return rawValue == null || StringUtils . isBlank ( String . valueOf ( rawValue ) ) ; }
public CipherTextIvMac ( byte [ ] c , byte [ ] i , byte [ ] h ) { cipherText = new byte [ c . length ] ; System . arraycopy ( c , NUM_ , cipherText , NUM_ , c . length ) ; iv = new byte [ i . length ] ; System . arraycopy ( i , NUM_ , iv , NUM_ , i . length ) ; mac = new byte [ h . length ] ; System . arraycopy ( h , NUM_ , mac , NUM_ , h . length ) ; }
public static MasterPrivateKey createFromEncryptedSeed ( String passphrase , byte [ ] encryptedSeed ) throws HyperLedgerException { try { byte [ ] key = SCrypt . generate ( passphrase . getBytes ( STR_ ) , BITCOIN_SEED , NUM_ , NUM_ , NUM_ , NUM_ ) ; SecretKeySpec keyspec = new SecretKeySpec ( key , STR_ ) ; if ( encryptedSeed . length != NUM_ ) { throw new HyperLedgerException ( STR_ ) ; } Cipher cipher = Cipher . getInstance ( STR_ , STR_ ) ; cipher . init ( Cipher . DECRYPT_MODE , keyspec ) ; return create ( cipher . doFinal ( encryptedSeed ) ) ; } catch ( UnsupportedEncodingException | NoSuchPaddingException | NoSuchProviderException | NoSuchAlgorithmException | InvalidKeyException | BadPaddingException | IllegalBlockSizeException e ) { throw new HyperLedgerException ( e ) ; } }
public static List < JsonPointer > filter ( final String ... fields ) { final List < JsonPointer > result = new ArrayList < > ( fields . length ) ; for ( final String field : fields ) { result . add ( new JsonPointer ( field ) ) ; } return result ; }
public boolean applyFtProxy ( ) { return method . isAnnotationPresent ( AstrixFaultToleranceProxy . class ) ; }
private void notifyChange ( int previous , int current ) { mSoundPlayer . play ( mSoundId , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ ) ; if ( mOnValueChangeListener != null ) { mOnValueChangeListener . onValueChange ( this , previous , mValue ) ; } }
public static double atan2 ( double y , double x ) { if ( Double . isNaN ( x ) || Double . isNaN ( y ) ) { return Double . NaN ; } if ( y == NUM_ ) { final double result = x . y ; final double invx = NUM_ / x ; final double invy = NUM_ / y ; if ( invx == NUM_ ) { if ( x > NUM_ ) { return y ; } else { return copySign ( Math . PI , y ) ; } } if ( x < NUM_ || invx < NUM_ ) { if ( y < NUM_ || invy < NUM_ ) { return - Math . PI ; } else { return Math . PI ; } } else { return result ; } } if ( y == Double . POSITIVE_INFINITY ) { if ( x == Double . POSITIVE_INFINITY ) { return Math . PI . F_1_4 ; } if ( x == Double . NEGATIVE_INFINITY ) { return Math . PI . F_3_4 ; } return Math . PI . F_1_2 ; } if ( y == Double . NEGATIVE_INFINITY ) { if ( x == Double . POSITIVE_INFINITY ) { return - Math . PI . F_1_4 ; } if ( x == Double . NEGATIVE_INFINITY ) { return - Math . PI . F_3_4 ; } return - Math . PI . F_1_2 ; } if ( x == Double . POSITIVE_INFINITY ) { if ( y > NUM_ || NUM_ / y > NUM_ ) { return NUM_ ; } if ( y < NUM_ || NUM_ / y < NUM_ ) { return - NUM_ ; } } if ( x == Double . NEGATIVE_INFINITY ) { if ( y > NUM_ || NUM_ / y > NUM_ ) { return Math . PI ; } if ( y < NUM_ || NUM_ / y < NUM_ ) { return - Math . PI ; } } if ( x == NUM_ ) { if ( y > NUM_ || NUM_ / y > NUM_ ) { return Math . PI . F_1_2 ; } if ( y < NUM_ || NUM_ / y < NUM_ ) { return - Math . PI . F_1_2 ; } } final double r = y / x ; if ( Double . isInfinite ( r ) ) { return atan ( r , NUM_ , x < NUM_ ) ; } double ra = doubleHighPart ( r ) ; double rb = r - ra ; final double xa = doubleHighPart ( x ) ; final double xb = x - xa ; rb += ( y - ra . xa - ra . xb - rb . xa - rb . xb ) / x ; final double temp = ra + rb ; rb = - ( temp - ra - rb ) ; ra = temp ; if ( ra == NUM_ ) { ra = copySign ( NUM_ , y ) ; } final double result = atan ( ra , rb , x < NUM_ ) ; return result ; }
public int count ( ) { return comments == null ? NUM_ : comments . size ( ) ; }
private boolean isAnyPackageFromListInstalled ( List < String > packages ) { boolean result = BOOL_ ; PackageManager pm = mContext . getPackageManager ( ) ; for ( String packageName : packages ) { try { pm . getPackageInfo ( packageName , NUM_ ) ; QLog . e ( packageName + STR_ ) ; result = BOOL_ ; } catch ( PackageManager . NameNotFoundException e ) { continue ; } } return result ; }
public static String makeSystemName ( String type , int bitNum ) { String nName = STR_ ; if ( ( ! type . equals ( STR_ ) ) && ( ! type . equals ( STR_ ) ) && ( ! type . equals ( STR_ ) ) ) { log . error ( STR_ + type ) ; return ( nName ) ; } if ( ( bitNum < NUM_ ) || ( ( type . equals ( STR_ ) ) && ( bitNum > NUM_ ) ) || ( bitNum > NUM_ ) ) { log . error ( STR_ + bitNum ) ; return ( nName ) ; } nName = STR_ + type + Integer . toString ( bitNum ) ; return ( nName ) ; }
public static void remove ( ) { AUTH_TOKEN . remove ( ) ; }
public abstract boolean conflicts ( CopyJob other ) ;
public TreeNode deserialize ( String data ) { Deque < String > nodes = new LinkedList < > ( ) ; nodes . addAll ( Arrays . asList ( data . split ( SPLITER ) ) ) ; return buildTree ( nodes ) ; }
public void fill ( int fromIndex , int toIndex , short val ) { if ( toIndex > _pos ) { ensureCapacity ( toIndex ) ; _pos = toIndex ; } Arrays . fill ( _data , fromIndex , toIndex , val ) ; }
private void runPendingRequests ( ) { int maxStartId = - NUM_ ; BillingRequest request ; while ( ( request = mPendingRequests . peek ( ) ) != null ) { if ( request . runIfConnected ( ) ) { mPendingRequests . remove ( ) ; if ( maxStartId < request . getStartId ( ) ) { maxStartId = request . getStartId ( ) ; } } else { bindToMarketBillingService ( ) ; return ; } } if ( maxStartId >= NUM_ ) { if ( Consts . DEBUG ) { Log . i ( TAG , STR_ + maxStartId ) ; } stopSelf ( maxStartId ) ; } }
public static void removeAttributeDefaultValues ( String serviceName , String schemaType , String attrName , Set defaultValues , boolean isOrgAttrSchema ) throws UpgradeException { String classMethod = STR_ ; ServiceSchema ss = null ; if ( debug . messageEnabled ( ) ) { debug . message ( classMethod + STR_ + serviceName ) ; debug . message ( classMethod + STR_ + schemaType ) ; debug . message ( classMethod + STR_ + attrName ) ; debug . message ( classMethod + STR_ + defaultValues ) ; debug . message ( classMethod + STR_ + isOrgAttrSchema ) ; } try { if ( isOrgAttrSchema ) { ServiceSchemaManager sm = getServiceSchemaManager ( serviceName ) ; ss = sm . getOrganizationCreationSchema ( ) ; } else { ss = getServiceSchema ( serviceName , null , schemaType ) ; } if ( ss != null ) { AttributeSchema attrSchema = ss . getAttributeSchema ( attrName ) ; for ( Iterator i = defaultValues . iterator ( ) ; i . hasNext ( ) ; ) { String defaultValue = ( String ) i . next ( ) ; attrSchema . removeDefaultValue ( defaultValue ) ; } } } catch ( SMSException sme ) { debug . error ( classMethod + STR_ , sme ) ; } catch ( SSOException ssoe ) { debug . error ( classMethod + STR_ , ssoe ) ; } }
public void unlock ( final T tx ) { if ( DEBUG ) log . debug ( STR_ ) ; lock . lock ( ) ; if ( DEBUG ) log . debug ( STR_ ) ; try { assertNotDead ( ) ; assertOwnsLock ( tx ) ; if ( queue . remove ( ) != tx ) { throw new AssertionError ( ) ; } if ( waitsFor != null ) { final Iterator < T > itr = queue . iterator ( ) ; synchronized ( waitsFor ) { while ( itr . hasNext ( ) ) { final T pendingTx = itr . next ( ) ; try { waitsFor . removeEdge ( pendingTx , tx ) ; } catch ( Throwable t ) { log . warn ( t . getMessage ( ) , t ) ; } } } } if ( queue . isEmpty ( ) ) { if ( INFO ) log . info ( STR_ ) ; return ; } if ( INFO ) log . info ( STR_ ) ; available . signalAll ( ) ; } finally { lock . unlock ( ) ; if ( DEBUG ) log . debug ( STR_ ) ; } }
public boolean isUpdateAvailable ( ) { return availableUpdate != null ; }
@ Override public String toStringSummary ( ) { String result ; String titles ; int resultsetLength ; int i ; int j ; if ( m_NonSigWins == null ) { return STR_ ; } result = STR_ ; titles = STR_ ; resultsetLength = NUM_ + Math . max ( ( int ) ( Math . log ( getColCount ( ) ) / Math . log ( NUM_ ) ) , ( int ) ( Math . log ( getRowCount ( ) ) / Math . log ( NUM_ ) ) ) ; for ( i = NUM_ ; i < getColCount ( ) ; i ++ ) { if ( getColHidden ( i ) ) { continue ; } titles += STR_ + Utils . padLeft ( STR_ + getSummaryTitle ( i ) , resultsetLength . NUM_ + NUM_ ) ; } result += titles + STR_ ; for ( i = NUM_ ; i < getColCount ( ) ; i ++ ) { if ( getColHidden ( i ) ) { continue ; } for ( j = NUM_ ; j < getColCount ( ) ; j ++ ) { if ( getColHidden ( j ) ) { continue ; } result += STR_ ; if ( j == i ) { result += Utils . padLeft ( STR_ , resultsetLength . NUM_ + NUM_ ) ; } else { result += Utils . padLeft ( STR_ + m_NonSigWins [ i ] [ j ] + STR_ + m_Wins [ i ] [ j ] + STR_ , resultsetLength . NUM_ + NUM_ ) ; } } result += STR_ + getSummaryTitle ( i ) + STR_ + getColName ( i ) + STR_ ; } return result ; }
public int read ( BufferedInputStream is ) { init ( ) ; if ( is != null ) { in = is ; readHeader ( ) ; if ( ! err ( ) ) { readContents ( ) ; if ( frameCount < NUM_ ) { status = STATUS_FORMAT_ERROR ; } } } else { status = STATUS_OPEN_ERROR ; } try { is . close ( ) ; } catch ( IOException e ) { } return status ; }
private static int determineType ( byte [ ] bytes ) { int offset = NUM_ ; if ( bytes . length >= NUM_ && ( bytes [ NUM_ ] & xFF ) == xEF && ( bytes [ NUM_ ] & xFF ) == xBB && ( bytes [ NUM_ ] & xFF ) == xBF ) { offset += NUM_ ; } while ( offset < bytes . length && bytes [ offset ] == STR_ || bytes [ offset ] == STR_ || bytes [ offset ] == STR_ || bytes [ offset ] == STR_ || bytes [ offset ] == STR_ ) { offset ++ ; } return determineType ( new String ( bytes , offset , Math . min ( NUM_ , bytes . length - offset ) ) ) ; }
public void fixHttpsURLConnection ( ) { HttpsURLConnection . setDefaultSSLSocketFactory ( sslContext . getSocketFactory ( ) ) ; }
@ Override public DataTable sample ( int newSize ) { int rowCount = getRowNumber ( ) ; if ( rowCount <= newSize ) { return this ; } int [ ] sampledSelectedIndices = new int [ rowCount ] ; for ( int i = NUM_ ; i < rowCount ; ++ i ) { sampledSelectedIndices [ i ] = i ; } Random rng = new Random ( NUM_ ) ; int swapIdx ; int tmpValue ; for ( int i = NUM_ ; i < rowCount ; ++ i ) { swapIdx = rng . nextInt ( rowCount ) ; tmpValue = sampledSelectedIndices [ swapIdx ] ; sampledSelectedIndices [ swapIdx ] = sampledSelectedIndices [ i ] ; sampledSelectedIndices [ i ] = tmpValue ; } DataTableView sampledDataTable = new DataTableView ( this ) ; Vector < Integer > sampledSelectedIndicesVector = new Vector < Integer > ( newSize ) ; for ( int i = NUM_ ; i < newSize ; ++ i ) { sampledSelectedIndicesVector . add ( sampledSelectedIndices [ i ] ) ; } sampledDataTable . setSelectedIndices ( sampledSelectedIndicesVector ) ; return sampledDataTable ; }
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m_filterThread . isAlive ( ) && m_state != IDLE ) { wait ( ) ; } } catch ( InterruptedException ex ) { } } else { notifyAll ( ) ; } }
public void cancel ( ) { if ( mUploadOperation == null ) { if ( mUploadStarted . get ( ) ) { Log_OC . d ( TAG , STR_ ) ; mCancellationRequested . set ( BOOL_ ) ; } else { Log_OC . e ( TAG , STR_ ) ; } } else { Log_OC . d ( TAG , STR_ ) ; mUploadOperation . cancel ( ) ; } }
public void testNegNegFirstShorter ( ) { byte aBytes [ ] = { - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { - NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ } ; int aSign = - NUM_ ; int bSign = - NUM_ ; byte rBytes [ ] = { - NUM_ , NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . and ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , - NUM_ , result . signum ( ) ) ; }
public static void mergeFiles ( final File file1 , final File file2 , final File outputFile ) { if ( ! isReadable ( file1 ) || ! isReadable ( file2 ) || ! outputFile . exists ( ) && ! makeDirsForFile ( outputFile ) ) { return ; } try { FileInputStream fis1 = new FileInputStream ( file1 ) ; FileInputStream fis2 = new FileInputStream ( file2 ) ; SequenceInputStream sis = new SequenceInputStream ( fis1 , fis2 ) ; FileOutputStream fos = new FileOutputStream ( outputFile ) ; int count ; byte [ ] temp = new byte [ NUM_ ] ; while ( ( count = sis . read ( temp ) ) != - NUM_ ) { fos . write ( temp , NUM_ , count ) ; } FileUtils . sync ( fos ) ; fos . close ( ) ; sis . close ( ) ; fis1 . close ( ) ; fis2 . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
public static SnippetSet parse ( final File file ) throws ParseException { return parse ( fileInputSupplier ( file . getParentFile ( ) ) , file . getName ( ) ) ; }
public static String readFile ( Class < ? > context , String name ) throws IOException { try ( InputStream in = context . getResourceAsStream ( name ) ) { if ( in == null ) { return null ; } return new String ( ByteStreams . toByteArray ( in ) , ENC ) ; } catch ( IOException e ) { throw new IOException ( STR_ + name , e ) ; } }
public int remove ( Object key ) { Entry e = removeEntryForKey ( key ) ; return ( e == null ? NUM_ : e . value ) ; }
public boolean verifyChallengeToken ( InetSocketAddress address , int token ) { return Objects . equals ( challengeTokens . get ( address ) , token ) ; }
@ Override public void handleKey ( int virtualKeyCode , int transitionState , char keyChar ) { switchControlKeys ( virtualKeyCode , transitionState ) ; inputBuffer . add ( new GlobalKeyEvent ( this , virtualKeyCode , transitionState , keyChar , menuPressed , shiftPressed , controlPressed , extendedKey ) ) ; }
protected void drawTriangle ( int x , int y , int w , int h , Color fillColor , Paint fillPaint , Color penColor , boolean shadow , String direction ) { Polygon triangle = new Polygon ( ) ; if ( direction . equals ( mxConstants . DIRECTION_NORTH ) ) { triangle . addPoint ( x , y + h ) ; triangle . addPoint ( x + w / NUM_ , y ) ; triangle . addPoint ( x + w , y + h ) ; } else if ( direction . equals ( mxConstants . DIRECTION_SOUTH ) ) { triangle . addPoint ( x , y ) ; triangle . addPoint ( x + w / NUM_ , y + h ) ; triangle . addPoint ( x + w , y ) ; } else if ( direction . equals ( mxConstants . DIRECTION_WEST ) ) { triangle . addPoint ( x + w , y ) ; triangle . addPoint ( x , y + h / NUM_ ) ; triangle . addPoint ( x + w , y + h ) ; } else { triangle . addPoint ( x , y ) ; triangle . addPoint ( x + w , y + h / NUM_ ) ; triangle . addPoint ( x , y + h ) ; } drawPolygon ( triangle , fillColor , fillPaint , penColor , shadow ) ; }
private static Map < String , String > resourceBundleMap ( ResourceBundle bundle ) { final HashMap < String , String > map = new HashMap < String , String > ( ) ; final Enumeration < String > e = bundle . getKeys ( ) ; while ( e . hasMoreElements ( ) ) { final String key = e . nextElement ( ) ; map . put ( key , ( String ) bundle . getObject ( key ) ) ; } return Collections . unmodifiableMap ( map ) ; }
public int compareTo ( IntBuffer otherBuffer ) { int compareRemaining = ( remaining ( ) < otherBuffer . remaining ( ) ) ? remaining ( ) : otherBuffer . remaining ( ) ; int thisPos = position ; int otherPos = otherBuffer . position ; int thisInt , otherInt ; while ( compareRemaining > NUM_ ) { thisInt = get ( thisPos ) ; otherInt = otherBuffer . get ( otherPos ) ; if ( thisInt != otherInt ) { return thisInt < otherInt ? - NUM_ : NUM_ ; } thisPos ++ ; otherPos ++ ; compareRemaining -- ; } return remaining ( ) - otherBuffer . remaining ( ) ; }
private static SizePair selectSizePair ( Camera camera , int desiredWidth , int desiredHeight ) { List < SizePair > validPreviewSizes = generateValidPreviewSizeList ( camera ) ; SizePair selectedPair = null ; int minDiff = Integer . MAX_VALUE ; for ( SizePair sizePair : validPreviewSizes ) { Size size = sizePair . previewSize ( ) ; int diff = Math . abs ( size . getWidth ( ) - desiredWidth ) + Math . abs ( size . getHeight ( ) - desiredHeight ) ; if ( diff < minDiff ) { selectedPair = sizePair ; minDiff = diff ; } } return selectedPair ; }
public void testDivideRoundHalfUpPos ( ) { String a = STR_ ; int aScale = - NUM_ ; String b = STR_ ; int bScale = NUM_ ; String c = STR_ ; int resScale = - NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal bNumber = new BigDecimal ( new BigInteger ( b ) , bScale ) ; BigDecimal result = aNumber . divide ( bNumber , resScale , BigDecimal . ROUND_HALF_UP ) ; assertEquals ( STR_ , c , result . toString ( ) ) ; assertEquals ( STR_ , resScale , result . scale ( ) ) ; }
private boolean isBlack ( final int x , final int y ) { if ( ! inBounds ( x , y ) ) { return BOOL_ ; } return ( m_bufferedImage . getRGB ( x , y ) & x00FFFFFF ) == NUM_ ; }
public void addJob ( Runnable job ) { mJobs . add ( job ) ; }
public PKCS10CertificationRequest ( String signatureAlgorithm , X509Name subject , PublicKey key , ASN1Set attributes , PrivateKey signingKey , String provider ) throws NoSuchAlgorithmException , NoSuchProviderException , InvalidKeyException , SignatureException { String algorithmName = Strings . toUpperCase ( signatureAlgorithm ) ; DERObjectIdentifier sigOID = ( DERObjectIdentifier ) algorithms . get ( algorithmName ) ; if ( sigOID == null ) { try { sigOID = new DERObjectIdentifier ( algorithmName ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( STR_ ) ; } } if ( subject == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( key == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( noParams . contains ( sigOID ) ) { this . sigAlgId = new AlgorithmIdentifier ( sigOID ) ; } else if ( params . containsKey ( algorithmName ) ) { this . sigAlgId = new AlgorithmIdentifier ( sigOID , ( ASN1Encodable ) params . get ( algorithmName ) ) ; } else { this . sigAlgId = new AlgorithmIdentifier ( sigOID , DERNull . INSTANCE ) ; } try { ASN1Sequence seq = ( ASN1Sequence ) ASN1Primitive . fromByteArray ( key . getEncoded ( ) ) ; this . reqInfo = new CertificationRequestInfo ( subject , new SubjectPublicKeyInfo ( seq ) , attributes ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( STR_ ) ; } Signature sig ; if ( provider == null ) { sig = Signature . getInstance ( signatureAlgorithm ) ; } else { sig = Signature . getInstance ( signatureAlgorithm , provider ) ; } sig . initSign ( signingKey ) ; try { sig . update ( reqInfo . getEncoded ( ASN1Encoding . DER ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( STR_ + e ) ; } this . sigBits = new DERBitString ( sig . sign ( ) ) ; }
@ Override public void close ( ) throws IOException { if ( in != null ) { in . close ( ) ; in = null ; buf = null ; } }
public static Collection < Vector2D > reducePoints ( final Collection < Vector2D > points ) { int size = NUM_ ; Vector2D minX = null ; Vector2D maxX = null ; Vector2D minY = null ; Vector2D maxY = null ; for ( Vector2D p : points ) { if ( minX == null || p . getX ( ) < minX . getX ( ) ) { minX = p ; } if ( maxX == null || p . getX ( ) > maxX . getX ( ) ) { maxX = p ; } if ( minY == null || p . getY ( ) < minY . getY ( ) ) { minY = p ; } if ( maxY == null || p . getY ( ) > maxY . getY ( ) ) { maxY = p ; } size ++ ; } if ( size < NUM_ ) { return points ; } final List < Vector2D > quadrilateral = buildQuadrilateral ( minY , maxX , maxY , minX ) ; if ( quadrilateral . size ( ) < NUM_ ) { return points ; } final List < Vector2D > reducedPoints = new ArrayList < Vector2D > ( quadrilateral ) ; for ( final Vector2D p : points ) { if ( ! insideQuadrilateral ( p , quadrilateral ) ) { reducedPoints . add ( p ) ; } } return reducedPoints ; }
int updateBookmarksInTransaction ( ContentValues values , String selection , String [ ] selectionArgs , boolean callerIsSyncAdapter ) { int count = NUM_ ; final SQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; final String [ ] bookmarksProjection = new String [ ] { Bookmarks . _ID , Bookmarks . VERSION , Bookmarks . URL , Bookmarks . TITLE , Bookmarks . IS_FOLDER , Bookmarks . ACCOUNT_NAME , Bookmarks . ACCOUNT_TYPE } ; Cursor cursor = db . query ( TABLE_BOOKMARKS , bookmarksProjection , selection , selectionArgs , null , null , null ) ; boolean updatingParent = values . containsKey ( Bookmarks . PARENT ) ; String parentAccountName = null ; String parentAccountType = null ; if ( updatingParent ) { long parent = values . getAsLong ( Bookmarks . PARENT ) ; Cursor c = db . query ( TABLE_BOOKMARKS , new String [ ] { Bookmarks . ACCOUNT_NAME , Bookmarks . ACCOUNT_TYPE } , STR_ , new String [ ] { Long . toString ( parent ) } , null , null , null ) ; if ( c . moveToFirst ( ) ) { parentAccountName = c . getString ( NUM_ ) ; parentAccountType = c . getString ( NUM_ ) ; } c . close ( ) ; } else if ( values . containsKey ( Bookmarks . ACCOUNT_NAME ) || values . containsKey ( Bookmarks . ACCOUNT_TYPE ) ) { } try { String [ ] args = new String [ NUM_ ] ; if ( ! callerIsSyncAdapter ) { values . put ( Bookmarks . DATE_MODIFIED , System . currentTimeMillis ( ) ) ; values . put ( Bookmarks . DIRTY , NUM_ ) ; } boolean updatingUrl = values . containsKey ( Bookmarks . URL ) ; String url = null ; if ( updatingUrl ) { url = values . getAsString ( Bookmarks . URL ) ; } ContentValues imageValues = extractImageValues ( values , url ) ; while ( cursor . moveToNext ( ) ) { long id = cursor . getLong ( NUM_ ) ; args [ NUM_ ] = Long . toString ( id ) ; String accountName = cursor . getString ( NUM_ ) ; String accountType = cursor . getString ( NUM_ ) ; if ( updatingParent && ( ! TextUtils . equals ( accountName , parentAccountName ) || ! TextUtils . equals ( accountType , parentAccountType ) ) ) { ContentValues newValues = valuesFromCursor ( cursor ) ; newValues . putAll ( values ) ; newValues . remove ( Bookmarks . _ID ) ; newValues . remove ( Bookmarks . VERSION ) ; newValues . put ( Bookmarks . ACCOUNT_NAME , parentAccountName ) ; newValues . put ( Bookmarks . ACCOUNT_TYPE , parentAccountType ) ; Uri insertUri = insertInTransaction ( Bookmarks . CONTENT_URI , newValues , callerIsSyncAdapter ) ; long newId = ContentUris . parseId ( insertUri ) ; if ( cursor . getInt ( NUM_ ) != NUM_ ) { ContentValues updateChildren = new ContentValues ( NUM_ ) ; updateChildren . put ( Bookmarks . PARENT , newId ) ; count += updateBookmarksInTransaction ( updateChildren , Bookmarks . PARENT + STR_ , new String [ ] { Long . toString ( id ) } , callerIsSyncAdapter ) ; } Uri uri = ContentUris . withAppendedId ( Bookmarks . CONTENT_URI , id ) ; deleteInTransaction ( uri , null , null , callerIsSyncAdapter ) ; count += NUM_ ; } else { if ( ! callerIsSyncAdapter ) { values . put ( Bookmarks . VERSION , cursor . getLong ( NUM_ ) + NUM_ ) ; } count += db . update ( TABLE_BOOKMARKS , values , STR_ , args ) ; } if ( imageValues != null ) { if ( ! updatingUrl ) { url = cursor . getString ( NUM_ ) ; imageValues . put ( Images . URL , url ) ; } if ( ! TextUtils . isEmpty ( url ) ) { args [ NUM_ ] = url ; if ( db . update ( TABLE_IMAGES , imageValues , Images . URL + STR_ , args ) == NUM_ ) { db . insert ( TABLE_IMAGES , Images . FAVICON , imageValues ) ; } } } } } finally { if ( cursor != null ) cursor . close ( ) ; } return count ; }
private IgniteBiTuple < String , Integer > hostPort ( String connStr , String hostPortStr ) throws IgniteCheckedException { String [ ] tokens = hostPortStr . split ( STR_ , - NUM_ ) ; String host = tokens [ NUM_ ] ; if ( F . isEmpty ( host ) ) host = LOCALHOST ; int port ; if ( tokens . length == NUM_ ) port = IgfsIpcEndpointConfiguration . DFLT_PORT ; else if ( tokens . length == NUM_ ) { String portStr = tokens [ NUM_ ] ; try { port = Integer . valueOf ( portStr ) ; if ( port < NUM_ || port > NUM_ ) throw new IgniteCheckedException ( STR_ + connStr ) ; } catch ( NumberFormatException e ) { throw new IgniteCheckedException ( STR_ + connStr ) ; } } else throw new IgniteCheckedException ( STR_ + connStr ) ; return F . t ( host , port ) ; }
public boolean isMissileGoingToHit ( EntityMissile missile ) { if ( missile == null || missile . targetVector == null ) { return BOOL_ ; } return ( Vector2 . distance ( new Vector2 ( new Pos3D ( missile ) ) , new Vector2 ( xCoord , zCoord ) ) < alarmRange && Vector2 . distance ( new Vector2 ( missile . targetVector ) , new Vector2 ( xCoord , zCoord ) ) < safetyRange ) ; }
public static Usericon parseModIcon ( String json ) { try { JSONParser parser = new JSONParser ( ) ; JSONObject o = ( JSONObject ) parser . parse ( json ) ; JSONObject room = ( JSONObject ) o . get ( STR_ ) ; String roomId = ( String ) room . get ( STR_ ) ; String modBadgeUrl = ( String ) room . get ( STR_ ) ; if ( modBadgeUrl == null ) { return null ; } return UsericonFactory . createTwitchLikeIcon ( Usericon . Type . MOD , roomId , modBadgeUrl , Usericon . SOURCE_FFZ , STR_ ) ; } catch ( ParseException | ClassCastException | NullPointerException ex ) { } return null ; }
public static long length ( URL url ) throws IOException { HTTPResponse http = HTTPEngine . head ( url , null , null , - NUM_ , BOOL_ , null , Constants . NAME , null , null ) ; return http . getContentLength ( ) ; }
@ Override public Request < List < Workspace > > all ( ) { List < Workspace > workspacesToReturn = new ArrayList < > ( ) ; for ( Workspace dummyWorkspace : workspaces . values ( ) ) { workspacesToReturn . add ( dummyWorkspace ) ; } return new DummyRequest < > ( workspacesToReturn ) ; }
public void subscribe ( EventSubscriber < ? > subscriber ) { final Class < ? > eventType = getEventType ( subscriber ) ; doSubscribe ( subscriber , eventType ) ; }
public static String readerToString ( final Reader fileReader ) throws IOException { final StringBuilder sb = new StringBuilder ( ) ; try ( BufferedReader br = new BufferedReader ( fileReader ) ) { final char [ ] buffer = FileUtils . makeBuffer ( ) ; final int eof = - NUM_ ; for ( int len = br . read ( buffer ) ; len > eof ; len = br . read ( buffer ) ) { for ( int i = NUM_ ; i < len ; i ++ ) { sb . append ( buffer [ i ] ) ; } } } return sb . toString ( ) ; }
public static String bytesToHex ( byte [ ] bytes , boolean withSpaces ) { StringBuilder sb = new StringBuilder ( ) ; for ( byte hashByte : bytes ) { int intVal = xff & hashByte ; if ( intVal < x10 ) { sb . append ( STR_ ) ; } sb . append ( Integer . toHexString ( intVal ) ) ; if ( withSpaces ) { sb . append ( STR_ ) ; } } return sb . toString ( ) ; }
public static byte [ ] stringToUtf8Bytes ( String string ) { int len = string . length ( ) ; byte [ ] bytes = new byte [ len . NUM_ ] ; int outAt = NUM_ ; for ( int i = NUM_ ; i < len ; i ++ ) { char c = string . charAt ( i ) ; if ( ( c != NUM_ ) && ( c < x80 ) ) { bytes [ outAt ] = ( byte ) c ; outAt ++ ; } else if ( c < x800 ) { bytes [ outAt ] = ( byte ) ( ( ( c > > NUM_ ) & x1f ) | xc0 ) ; bytes [ outAt + NUM_ ] = ( byte ) ( ( c & x3f ) | x80 ) ; outAt += NUM_ ; } else { bytes [ outAt ] = ( byte ) ( ( ( c > > NUM_ ) & x0f ) | xe0 ) ; bytes [ outAt + NUM_ ] = ( byte ) ( ( ( c > > NUM_ ) & x3f ) | x80 ) ; bytes [ outAt + NUM_ ] = ( byte ) ( ( c & x3f ) | x80 ) ; outAt += NUM_ ; } } byte [ ] result = new byte [ outAt ] ; System . arraycopy ( bytes , NUM_ , result , NUM_ , outAt ) ; return result ; }
private boolean isInterleaved ( ComponentSampleModel sm ) { int numBands = sampleModel . getNumBands ( ) ; if ( numBands == NUM_ ) { return BOOL_ ; } int [ ] bankIndices = sm . getBankIndices ( ) ; for ( int i = NUM_ ; i < numBands ; i ++ ) { if ( bankIndices [ i ] != NUM_ ) { return BOOL_ ; } } int [ ] bandOffsets = sm . getBandOffsets ( ) ; int minOffset = bandOffsets [ NUM_ ] ; int maxOffset = minOffset ; for ( int i = NUM_ ; i < numBands ; i ++ ) { int offset = bandOffsets [ i ] ; if ( offset < minOffset ) { minOffset = offset ; } if ( offset > maxOffset ) { maxOffset = offset ; } } if ( maxOffset - minOffset >= sm . getPixelStride ( ) ) { return BOOL_ ; } return BOOL_ ; }
private int decodeSize ( byte [ ] buffer ) { BigInteger bi = new BigInteger ( buffer ) ; int tmpSize = bi . intValue ( ) ; if ( tmpSize < NUM_ ) { logger . warning ( STR_ + tmpSize + STR_ + Integer . toBinaryString ( tmpSize ) + STR_ + Integer . toHexString ( tmpSize ) ) ; } return tmpSize ; }
public CertificateIssuerExtension ( Boolean critical , Object value ) throws IOException { this . extensionId = PKIXExtensions . CertificateIssuer_Id ; this . critical = critical . booleanValue ( ) ; this . extensionValue = ( byte [ ] ) value ; DerValue val = new DerValue ( this . extensionValue ) ; this . names = new GeneralNames ( val ) ; }
@ Override public void onSensorSelectionClosed ( DialogFragment dialog ) { Log . d ( TAG , STR_ ) ; sensorSelectionDialog = null ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; String childData ; String childValue ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; nameNode = elementList . item ( NUM_ ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; child . setNodeValue ( STR_ ) ; childData = child . getData ( ) ; assertEquals ( STR_ , STR_ , childData ) ; childValue = child . getNodeValue ( ) ; assertEquals ( STR_ , STR_ , childValue ) ; }
public String toXML ( ) { StringBuffer str = new StringBuffer ( ) ; str . append ( STR_ ) ; str . append ( XML_ROOT_ELEMENT ) ; str . append ( STR_ ) ; str . append ( STR_ ) ; str . append ( XML_ELEMENT_QUALITY_CODE ) ; str . append ( STR_ ) ; str . append ( qualityCode ) ; str . append ( STR_ ) ; str . append ( XML_ELEMENT_QUALITY_CODE ) ; str . append ( STR_ ) ; if ( description != null ) { str . append ( STR_ ) ; str . append ( XML_ELEMENT_QUALITY_DESC ) ; str . append ( STR_ ) ; str . append ( description ) ; str . append ( STR_ ) ; str . append ( XML_ELEMENT_QUALITY_DESC ) ; str . append ( STR_ ) ; } str . append ( STR_ ) ; str . append ( XML_ROOT_ELEMENT ) ; str . append ( STR_ ) ; return str . toString ( ) ; }
public byte [ ] decrypt ( FacesContext context , byte [ ] securedata ) { try { byte [ ] macBytes = new byte [ macLength ] ; System . arraycopy ( securedata , NUM_ , macBytes , NUM_ , macBytes . length ) ; byte [ ] iv = new byte [ ivLength ] ; System . arraycopy ( securedata , macBytes . length , iv , NUM_ , iv . length ) ; byte [ ] encdata = new byte [ securedata . length - macBytes . length - iv . length ] ; System . arraycopy ( securedata , macBytes . length + iv . length , encdata , NUM_ , encdata . length ) ; byte [ ] rawKey = convertPasswordToKey ( getPasswordToSecureState ( context ) ) ; Mac mac = getMac ( rawKey ) ; mac . update ( iv ) ; mac . update ( encdata ) ; byte [ ] macBytesCalculated = mac . doFinal ( ) ; if ( Arrays . equals ( macBytes , macBytesCalculated ) ) { Cipher cipher = getBlockCipherForDecryption ( rawKey , iv ) ; byte [ ] plaindata = cipher . doFinal ( encdata ) ; return plaindata ; } else { if ( logger . isLoggable ( Level . WARNING ) ) { logger . warning ( STR_ ) ; } return null ; } } catch ( Exception e ) { if ( logger . isLoggable ( Level . SEVERE ) ) { logger . log ( Level . SEVERE , e . getMessage ( ) , e . getCause ( ) ) ; } throw new RuntimeException ( e ) ; } }
public static Set < String > commaDelimitedListToSet ( String str ) { Set < String > set = new TreeSet < > ( ) ; String [ ] tokens = commaDelimitedListToStringArray ( str ) ; set . addAll ( Arrays . asList ( tokens ) ) ; return set ; }
public int hashCode ( ) { return Objects . hash ( file , princ , bound ) ; }
public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( NUM_ ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
protected void tag ( String tag , String name , String value , boolean close ) { spacing ( ) ; m_out . print ( STR_ ) ; m_out . print ( tag ) ; m_out . print ( STR_ ) ; m_out . print ( name ) ; m_out . print ( STR_ ) ; m_out . print ( STR_ ) ; escapeString ( value ) ; m_out . print ( STR_ ) ; if ( close ) m_out . print ( STR_ ) ; m_out . print ( STR_ ) ; println ( ) ; if ( ! close ) { m_tagStack . add ( tag ) ; } }
public V remove ( Object key ) { int hash = hash ( key . hashCode ( ) ) ; Segment < K , V > s = segmentForHash ( hash ) ; return s == null ? null : s . remove ( key , hash , null ) ; }
public void addAttribute ( AttributeInfo info ) { AttributeInfo . remove ( attributes , info . getName ( ) ) ; attributes . add ( info ) ; }
public static Result evaluateModel ( MultiLabelClassifier h , Instances D ) throws Exception { return evaluateModelPrequentialBasic ( h , D , NUM_ , NUM_ , STR_ , STR_ ) ; }
protected boolean isValidState ( mxCellState state ) { return BOOL_ ; }
public void testFindSpringSunDirectoryServerWithLimit ( ) { LdapProxy proxy = getLdapSunDirectoryServer ( ) ; List result = null ; int limit = NUM_ ; try { result = proxy . find ( getLdapSearchVO ( STR_ , limit , STR_ , STR_ , null , LdapScopeConstants . SCOPE_SUBTREE ) ) ; } catch ( Exception e ) { } assertNotNull ( result ) ; if ( result != null ) { assertEquals ( limit , result . size ( ) ) ; } }
public static boolean deleteDir ( File dir ) { if ( dir == null ) { return BOOL_ ; } if ( dir . isDirectory ( ) ) { String [ ] children = dir . list ( ) ; for ( String child : children ) { boolean success = deleteDir ( new File ( dir , child ) ) ; if ( ! success ) { return BOOL_ ; } } } return dir . delete ( ) ; }
private CIMObjectPath createFilter ( CimManagedFilterInfo filterInfo ) throws WBEMException { StringBuilder filterNameBuilder = new StringBuilder ( ) ; filterNameBuilder . append ( _subscriptionsIdentifier ) ; filterNameBuilder . append ( CimConstants . PATH_NAME_DELIMITER ) ; filterNameBuilder . append ( filterInfo . getName ( ) ) ; String filterName = filterNameBuilder . toString ( ) ; String implNS = _connection . getImplNamespace ( ) ; CIMProperty < ? > nameProperty = new CIMProperty < String > ( CimConstants . NAME_KEY , CIMDataType . STRING_T , filterName ) ; CIMProperty < ? > srcNamespaceProp = new CIMProperty < String > ( CimConstants . FILTER_PROP_SRC_NAMESPACE , CIMDataType . STRING_T , implNS ) ; CIMProperty < ? > srcNamespacesProp = new CIMProperty < String [ ] > ( CimConstants . FILTER_PROP_SRC_NAMESPACES , CIMDataType . STRING_ARRAY_T , new String [ ] { implNS } ) ; CIMProperty < ? > queryLangProp = new CIMProperty < String > ( CimConstants . FILTER_PROP_QUERY_LANGUAGE , CIMDataType . STRING_T , filterInfo . getQueryLanguage ( ) ) ; CIMProperty < ? > queryProp = new CIMProperty < String > ( CimConstants . FILTER_PROP_QUERY , CIMDataType . STRING_T , filterInfo . getQuery ( ) ) ; CIMProperty < ? > [ ] filterProperties = new CIMProperty [ ] { nameProperty , srcNamespaceProp , srcNamespacesProp , queryLangProp , queryProp } ; CIMObjectPath filterPath = createInstance ( CimConstants . CIM_FILTER_NAME , filterName , filterProperties ) ; _filterPaths . add ( filterPath ) ; return filterPath ; }
public static ArrayList < ArrayList < String > > fileTokenizer ( String fin ) { File file = new File ( fin ) ; BufferedReader br ; FileReader fr ; ArrayList < String > lines = new ArrayList < String > ( ) ; try { fr = new FileReader ( file ) ; br = new BufferedReader ( fr ) ; String line ; try { while ( ( line = br . readLine ( ) ) != null ) { if ( line . length ( ) > NUM_ ) { lines . add ( line ) ; } } } catch ( IOException ex ) { } } catch ( FileNotFoundException ex ) { } ArrayList < ArrayList < String > > tokenized_list = new ArrayList < ArrayList < String > > ( ) ; for ( String s : lines ) { ArrayList < String > tokens = new ArrayList < String > ( ) ; StringTokenizer st = new StringTokenizer ( s , STR_ ) ; while ( st . hasMoreTokens ( ) ) { tokens . add ( st . nextToken ( ) ) ; } tokenized_list . add ( tokens ) ; } return tokenized_list ; }
public ActivationGroupImpl ( ActivationGroupID id , MarshalledObject < ? > data ) throws RemoteException { super ( id ) ; groupID = id ; unexportObject ( this , BOOL_ ) ; RMIServerSocketFactory ssf = new ServerSocketFactoryImpl ( ) ; UnicastRemoteObject . exportObject ( this , NUM_ , null , ssf ) ; if ( System . getSecurityManager ( ) == null ) { try { System . setSecurityManager ( new SecurityManager ( ) ) ; } catch ( Exception e ) { throw new RemoteException ( STR_ , e ) ; } } }
static byte [ ] hash_df ( Digest digest , byte [ ] seedMaterial , int seedLength ) { byte [ ] temp = new byte [ ( seedLength + NUM_ ) / NUM_ ] ; int len = temp . length / digest . getDigestSize ( ) ; int counter = NUM_ ; byte [ ] dig = new byte [ digest . getDigestSize ( ) ] ; for ( int i = NUM_ ; i <= len ; i ++ ) { digest . update ( ( byte ) counter ) ; digest . update ( ( byte ) ( seedLength > > NUM_ ) ) ; digest . update ( ( byte ) ( seedLength > > NUM_ ) ) ; digest . update ( ( byte ) ( seedLength > > NUM_ ) ) ; digest . update ( ( byte ) seedLength ) ; digest . update ( seedMaterial , NUM_ , seedMaterial . length ) ; digest . doFinal ( dig , NUM_ ) ; int bytesToCopy = ( ( temp . length - i . dig . length ) > dig . length ) ? dig . length : ( temp . length - i . dig . length ) ; System . arraycopy ( dig , NUM_ , temp , i . dig . length , bytesToCopy ) ; counter ++ ; } if ( seedLength % NUM_ != NUM_ ) { int shift = NUM_ - ( seedLength % NUM_ ) ; int carry = NUM_ ; for ( int i = NUM_ ; i != temp . length ; i ++ ) { int b = temp [ i ] & xff ; temp [ i ] = ( byte ) ( ( b > > > shift ) | ( carry << ( NUM_ - shift ) ) ) ; carry = b ; } } return temp ; }
protected boolean dropMessage ( RTMP rtmp , int channelId , IRTMPEvent message ) { boolean drop = BOOL_ ; if ( rtmp . getMode ( ) == RTMP . MODE_SERVER ) { boolean isVideo = BOOL_ ; if ( message instanceof Ping ) { final Ping pingMessage = ( Ping ) message ; if ( pingMessage . getEventType ( ) == Ping . STREAM_PLAYBUFFER_CLEAR ) { final int channel = ( NUM_ + ( ( pingMessage . getValue2 ( ) - NUM_ ) . NUM_ ) ) ; rtmp . setLastTimestampMapping ( channel , null ) ; rtmp . setLastTimestampMapping ( channel + NUM_ , null ) ; rtmp . setLastTimestampMapping ( channel + NUM_ , null ) ; } return BOOL_ ; } if ( ( isVideo = message instanceof VideoData ) || message instanceof AudioData ) { if ( message . getTimestamp ( ) == NUM_ ) { return BOOL_ ; } boolean isLive = message . getSourceType ( ) == Constants . SOURCE_TYPE_LIVE ; long timestamp = ( message . getTimestamp ( ) & xFFFFFFFFL ) ; LiveTimestampMapping mapping = rtmp . getLastTimestampMapping ( channelId ) ; long now = System . currentTimeMillis ( ) ; if ( mapping == null || timestamp < mapping . getLastStreamTime ( ) ) { log . debug ( STR_ , now , timestamp ) ; mapping = new LiveTimestampMapping ( now , timestamp ) ; rtmp . setLastTimestampMapping ( channelId , mapping ) ; } mapping . setLastStreamTime ( timestamp ) ; long clockTimeOfMessage = mapping . getClockStartTime ( ) + timestamp - mapping . getStreamStartTime ( ) ; long tardiness = clockTimeOfMessage - now ; if ( isLive && dropLiveFuture ) { tardiness = Math . abs ( tardiness ) ; } IConnection conn = Red5 . getConnectionLocal ( ) ; if ( conn != null ) { tardiness -= conn . getLastPingTime ( ) ; } else { log . debug ( STR_ ) ; } if ( tardiness < baseTolerance ) { } else if ( tardiness > highestTolerance ) { log . debug ( STR_ , message ) ; if ( isVideo ) { mapping . setKeyFrameNeeded ( BOOL_ ) ; } drop = BOOL_ ; } else { if ( isVideo ) { VideoData video = ( VideoData ) message ; if ( video . getFrameType ( ) == FrameType . KEYFRAME ) { mapping . setKeyFrameNeeded ( BOOL_ ) ; } else if ( tardiness >= baseTolerance && tardiness < midTolerance ) { if ( video . getFrameType ( ) == FrameType . DISPOSABLE_INTERFRAME ) { log . debug ( STR_ , message ) ; drop = BOOL_ ; } } else if ( tardiness >= midTolerance && tardiness <= highestTolerance ) { log . debug ( STR_ , message ) ; drop = BOOL_ ; } } } } log . debug ( STR_ , drop ) ; } return drop ; }
public static double vectorLength ( double [ ] vector ) { double ret = NUM_ ; if ( vector == null ) return ret ; else { for ( double aVector : vector ) { ret += Math . pow ( aVector , NUM_ ) ; } } return ret ; }
public static String encodeQuery ( String url ) { Uri uri = Uri . parse ( url ) ; try { String query = uri . getQuery ( ) ; String encodedQuery = query != null ? URLEncoder . encode ( query , STR_ ) : null ; URI tmp = new URI ( uri . getScheme ( ) , uri . getAuthority ( ) , uri . getPath ( ) , null , uri . getFragment ( ) ) ; return tmp + ( encodedQuery != null && encodedQuery . length ( ) > NUM_ ? STR_ + encodedQuery : STR_ ) ; } catch ( UnsupportedEncodingException ignore ) { } catch ( URISyntaxException ignore ) { } return uri . toString ( ) ; }
public void defineFillStyle ( int bitmapId , Matrix matrix , boolean clipped ) throws IOException { fillStyles . add ( new FillStyle ( bitmapId , matrix , clipped ) ) ; outstandingChanges = BOOL_ ; }
private static long writeFile ( String path , byte [ ] data ) { FileOutputStream out = null ; try { out = new FileOutputStream ( path ) ; out . write ( data ) ; return data . length ; } catch ( Exception e ) { Log . e ( TAG , STR_ , e ) ; } finally { try { out . close ( ) ; } catch ( Exception e ) { Log . e ( TAG , STR_ , e ) ; } } return - NUM_ ; }
public void firePaletteEvent ( ComponentEvent event ) { if ( localHackList == null ) { return ; } palette = ( Container ) event . getSource ( ) ; int eventType = event . getID ( ) ; for ( ComponentListener listener : localHackList ) { if ( eventType == ComponentEvent . COMPONENT_HIDDEN ) { listener . componentHidden ( event ) ; } else if ( eventType == ComponentEvent . COMPONENT_SHOWN ) { listener . componentShown ( event ) ; } } if ( eventType == ComponentEvent . COMPONENT_HIDDEN ) { palette = null ; } }
public void removeEntry ( RosterEntry e ) { log . debug ( STR_ , e ) ; _list . remove ( e ) ; e . removePropertyChangeListener ( this ) ; setDirty ( BOOL_ ) ; firePropertyChange ( REMOVE , e , null ) ; }
protected void logDiagnostic ( String msg ) { if ( isDiagnosticsEnabled ( ) ) { logRawDiagnostic ( diagnosticPrefix + msg ) ; } }
public void addURL ( final String url ) { while ( currentIndex < history . size ( ) - NUM_ ) { history . remove ( currentIndex + NUM_ ) ; } history . add ( url ) ; currentIndex = history . size ( ) - NUM_ ; }
public static ValueTimestamp convertTimestamp ( Timestamp x , Calendar calendar ) { if ( calendar == null ) { throw DbException . getInvalidValueException ( STR_ , null ) ; } Calendar cal = ( Calendar ) calendar . clone ( ) ; cal . setTimeInMillis ( x . getTime ( ) ) ; long dateValue = dateValueFromCalendar ( cal ) ; long nanos = nanosFromCalendar ( cal ) ; nanos += x . getNanos ( ) % NUM_ ; return ValueTimestamp . fromDateValueAndNanos ( dateValue , nanos ) ; }
private void process ( ) { ArrayList < Point2D > pList = new ArrayList < Point2D > ( ) ; ArrayList < Color > cList = new ArrayList < Color > ( ) ; while ( reader . getPointer ( ) < reader . getTotalBitLen ( ) ) { Point2D p = getPointCoords ( ) ; pList . add ( p ) ; float [ ] cc = { NUM_ , NUM_ , NUM_ , NUM_ } ; for ( int z = NUM_ ; z < colCompCount ; z ++ ) { cc [ z ] = reader . getFloat ( bitsPerComponent ) ; } Color c = new Color ( cc [ NUM_ ] , cc [ NUM_ ] , cc [ NUM_ ] , cc [ NUM_ ] ) ; cList . add ( c ) ; } int totalRows = pList . size ( ) / verticesPerRow ; for ( int mm = NUM_ ; mm < ( totalRows - NUM_ ) ; mm ++ ) { int mRows = mm . totalRows ; for ( int nn = NUM_ ; nn < ( verticesPerRow - NUM_ ) ; nn ++ ) { int nm = nn + mRows ; int [ ] t = new int [ NUM_ ] ; t [ NUM_ ] = nm ; t [ NUM_ ] = t [ NUM_ ] = nm + NUM_ ; t [ NUM_ ] = t [ NUM_ ] = nm + verticesPerRow ; t [ NUM_ ] = nm + verticesPerRow + NUM_ ; for ( int z = NUM_ ; z < t . length ; z ++ ) { triangles . add ( pList . get ( t [ z ] ) ) ; triColors . add ( cList . get ( t [ z ] ) ) ; } } } }
private void element ( String segment ) { int index = segment . indexOf ( STR_ ) ; String prefix = null ; if ( index > NUM_ ) { prefix = segment . substring ( NUM_ , index ) ; segment = segment . substring ( index + NUM_ ) ; } String element = style . getElement ( segment ) ; prefixes . add ( prefix ) ; names . add ( element ) ; }
private void cleanupHandler ( ContentHandler vh ) throws SAXException { for ( PrefixMapping pm = prefixMapping ; pm != null ; pm = pm . parent ) vh . endPrefixMapping ( pm . prefix ) ; vh . endDocument ( ) ; }
public InputStream openClassfile ( String classname ) { try { URLConnection con = openClassfile0 ( classname ) ; if ( con != null ) return con . getInputStream ( ) ; } catch ( IOException e ) { } return null ; }
public void removeIgnoredView ( View v ) { mIgnoredViews . remove ( v ) ; }
private double fitness ( Solution solution , double [ ] weights ) { double max = Double . NEGATIVE_INFINITY ; for ( int i = NUM_ ; i < solution . getNumberOfObjectives ( ) ; i ++ ) { max = Math . max ( max , Math . max ( weights [ i ] , NUM_ ) . Math . abs ( solution . getObjective ( i ) - idealPoint [ i ] ) ) ; } if ( solution . violatesConstraints ( ) ) { max += NUM_ ; } return max ; }
private boolean selectItemByName ( CCombo combo , String name , String [ ] cString ) { for ( int i = NUM_ ; i < cString . length ; i ++ ) { String propName = cString [ i ] ; if ( name . equalsIgnoreCase ( propName ) ) { combo . select ( i ) ; return BOOL_ ; } } return BOOL_ ; }
public void addFile ( String path ) throws IOException { File newFile = new File ( path ) ; if ( ! newFile . exists ( ) ) { throw new IOException ( STR_ + newFile . getAbsolutePath ( ) ) ; } if ( DelphiUtils . acceptFile ( newFile . getAbsolutePath ( ) ) ) { files . add ( newFile ) ; } }
public void removeLimitLine ( LimitLine l ) { mLimitLines . remove ( l ) ; }
public boolean isContent ( ) { return state . equals ( CONTENT ) ; }
protected boolean columnsDiffer ( Column currentColumn , Column desiredColumn ) { String desiredDefault = desiredColumn . getDefaultValue ( ) ; String currentDefault = currentColumn . getDefaultValue ( ) ; boolean defaultsEqual = ( desiredDefault == null ) || desiredDefault . equals ( currentDefault ) ; boolean sizeMatters = databaseInfo . hasSize ( currentColumn . getMappedTypeCode ( ) ) && ( desiredColumn . getSize ( ) != null ) ; if ( ( databaseInfo . getTargetJdbcType ( desiredColumn . getMappedTypeCode ( ) ) != currentColumn . getMappedTypeCode ( ) ) || ( desiredColumn . isRequired ( ) != currentColumn . isRequired ( ) ) || ( sizeMatters && ! StringUtils . equals ( desiredColumn . getSize ( ) , currentColumn . getSize ( ) ) ) || ! defaultsEqual ) { return BOOL_ ; } else { return BOOL_ ; } }
public static int readUINT16 ( InputStream stream ) throws IOException { int result = stream . read ( ) ; result |= stream . read ( ) << NUM_ ; return result ; }
private void prepareMetadataConnection ( ) throws SQLException , ReplicatorException { if ( metadataConnection == null ) metadataConnection = dataSourceImpl . getConnection ( ) ; long currentTime = System . currentTimeMillis ( ) ; if ( lastConnectionTime == NUM_ ) { lastConnectionTime = currentTime ; } else if ( reconnectTimeoutInSeconds > NUM_ && currentTime - lastConnectionTime > reconnectTimeoutInSeconds . NUM_ ) { dataSourceImpl . releaseConnection ( metadataConnection ) ; metadataConnection = dataSourceImpl . getConnection ( ) ; } }
public static String identifyLineDelimiter ( String fileContent ) { if ( fileContent . matches ( STR_ ) ) { return STR_ ; } else if ( fileContent . matches ( STR_ ) ) { return STR_ ; } else if ( fileContent . matches ( STR_ ) ) { return STR_ ; } else { return STR_ ; } }
public void addItem ( ForceItem item ) { items . add ( item ) ; }
public static List < String > makeBestTrailElementsForTrail ( HttpServletRequest request , Delegator delegator , String categoryId , String productId ) { List < String > trail = CategoryWorker . getTrail ( request ) ; List < String > trailElements = null ; if ( categoryId != null ) { if ( trail == null || trail . size ( ) < NUM_ ) { ; } else { ListIterator < String > li = trail . listIterator ( trail . size ( ) ) ; while ( li . hasPrevious ( ) ) { String trailCatId = li . previous ( ) ; if ( categoryId . equals ( trailCatId ) ) { trailElements = FastList . newInstance ( ) ; trailElements . add ( categoryId ) ; break ; } } if ( trailElements == null ) { li = trail . listIterator ( trail . size ( ) ) ; while ( li . hasPrevious ( ) ) { String trailCatId = li . previous ( ) ; if ( CategoryWorker . isCategoryChildOf ( request , trailCatId , categoryId ) ) { trailElements = FastList . newInstance ( ) ; trailElements . add ( trailCatId ) ; trailElements . add ( categoryId ) ; break ; } } } } } else { if ( trail == null || trail . size ( ) < NUM_ ) { ; } else { ListIterator < String > li = trail . listIterator ( trail . size ( ) ) ; while ( li . hasPrevious ( ) ) { String trailCatId = li . previous ( ) ; if ( CategoryWorker . isCategoryContainsProduct ( request , trailCatId , productId ) ) { trailElements = FastList . newInstance ( ) ; trailElements . add ( trailCatId ) ; break ; } } } } return trailElements ; }
public boolean deleteAttachmentPoint ( DatapathId sw , OFPort port ) { AttachmentPoint ap = new AttachmentPoint ( sw , port , new Date ( NUM_ ) ) ; if ( this . oldAPs != null ) { ArrayList < AttachmentPoint > apList = new ArrayList < AttachmentPoint > ( ) ; apList . addAll ( this . oldAPs ) ; int index = apList . indexOf ( ap ) ; if ( index > NUM_ ) { apList . remove ( index ) ; this . oldAPs = apList ; } } if ( this . attachmentPoints != null ) { ArrayList < AttachmentPoint > apList = new ArrayList < AttachmentPoint > ( ) ; apList . addAll ( this . attachmentPoints ) ; int index = apList . indexOf ( ap ) ; if ( index > NUM_ ) { apList . remove ( index ) ; this . attachmentPoints = apList ; return BOOL_ ; } } return BOOL_ ; }
public void or ( Criteria criteria ) { oredCriteria . add ( criteria ) ; }
public void testConstructor2 ( ) { Executor e = Executors . newFixedThreadPool ( NUM_ ) ; SubmissionPublisher < Integer > p = new SubmissionPublisher < Integer > ( e , NUM_ ) ; checkInitialState ( p ) ; assertSame ( p . getExecutor ( ) , e ) ; assertEquals ( NUM_ , p . getMaxBufferCapacity ( ) ) ; }
protected void parseContainerAndScreen ( XmlResourceParser parser , long [ ] out ) { if ( HOTSEAT_CONTAINER_NAME . equals ( getAttributeValue ( parser , ATTR_CONTAINER ) ) ) { out [ NUM_ ] = LauncherSettings . Favorites . CONTAINER_HOTSEAT ; long rank = Long . parseLong ( getAttributeValue ( parser , ATTR_RANK ) ) ; out [ NUM_ ] = ( rank < mHotseatAllAppsRank ) ? rank : ( rank + NUM_ ) ; } else { out [ NUM_ ] = LauncherSettings . Favorites . CONTAINER_DESKTOP ; out [ NUM_ ] = Long . parseLong ( getAttributeValue ( parser , ATTR_SCREEN ) ) ; } }
public DefaultTreeColouring sampleTreeColouring ( Tree tree , ColourChangeMatrix colourChangeMatrix , MetaPopulation mp ) { DefaultTreeColouring colouring = new DefaultTreeColouring ( NUM_ , tree ) ; double [ ] N = mp . getPopulationSizes ( NUM_ ) ; double [ ] rootPartials = prune ( tree , tree . getRoot ( ) , colourChangeMatrix , N ) ; double normalization = NUM_ ; for ( int i = NUM_ ; i < rootPartials . length ; i ++ ) { normalization += colourChangeMatrix . getEquilibrium ( i ) . rootPartials [ i ] ; } sampleInternalNodes ( tree , tree . getRoot ( ) , colourChangeMatrix ) ; sampleBranchColourings ( colouring , tree , tree . getRoot ( ) , colourChangeMatrix ) ; double logP = calculateLogProbabilityDensity ( colouring , tree , tree . getRoot ( ) , colourChangeMatrix , N ) - Math . log ( normalization ) ; colouring . setLogProbabilityDensity ( logP ) ; return colouring ; }
public StoredListIterator < T > establishListScan ( boolean random_scan ) { if ( isEmpty ( ) ) return null ; StoredListIterator < T > slh = _SLHolderPool . get ( ) ; StoredListIterator < T > res = establishPos ( random_scan , slh ) ; if ( res == null ) slh . release ( ) ; return res ; }
public void drag ( long time , float x , float y , float deltaX , float deltaY , float totalX , float totalY ) { resetResizeTimeout ( BOOL_ ) ; deltaX = MathUtils . flipSignIf ( deltaX , LocalizationUtils . isLayoutRtl ( ) ) ; mNewTabButton . drag ( x , y ) ; if ( mLastPressedCloseButton != null ) { if ( ! mLastPressedCloseButton . drag ( x , y ) ) mLastPressedCloseButton = null ; } if ( mInReorderMode ) { float accumulatedDeltaX = x - mLastReorderX ; if ( Math . abs ( accumulatedDeltaX ) >= NUM_ ) { if ( ! LocalizationUtils . isLayoutRtl ( ) ) { if ( deltaX >= NUM_ ) { mReorderState |= REORDER_SCROLL_RIGHT ; } else if ( deltaX <= - NUM_ ) { mReorderState |= REORDER_SCROLL_LEFT ; } } else { if ( deltaX >= NUM_ ) { mReorderState |= REORDER_SCROLL_LEFT ; } else if ( deltaX <= - NUM_ ) { mReorderState |= REORDER_SCROLL_RIGHT ; } } mLastReorderX = x ; updateReorderPosition ( accumulatedDeltaX ) ; } } else if ( ! mScroller . isFinished ( ) ) { mScroller . setFinalX ( ( int ) ( mScroller . getFinalX ( ) + deltaX ) ) ; } else { float fastExpandDelta = calculateOffsetToMakeTabVisible ( mInteractingTab , BOOL_ , BOOL_ , BOOL_ ) ; if ( mInteractingTab != null && fastExpandDelta != NUM_ ) { if ( ( fastExpandDelta > NUM_ && deltaX > NUM_ ) || ( fastExpandDelta < NUM_ && deltaX < NUM_ ) ) { mScroller . startScroll ( mScrollOffset , NUM_ , ( int ) fastExpandDelta , NUM_ , time , EXPAND_DURATION_MS ) ; } } else { updateScrollOffsetPosition ( ( int ) ( mScrollOffset + deltaX ) ) ; } } if ( ! mInReorderMode ) { final float absTotalX = Math . abs ( totalX ) ; final float absTotalY = Math . abs ( totalY ) ; if ( totalY > mReorderMoveStartThreshold && absTotalX < mReorderMoveStartThreshold . NUM_ && ( absTotalX > EPSILON && ( absTotalY / absTotalX ) > TAN_OF_REORDER_ANGLE_START_THRESHOLD ) ) { startReorderMode ( time , x , x - totalX ) ; } } if ( ! mInReorderMode ) mInteractingTab = null ; mUpdateHost . requestUpdate ( ) ; }
public static String decode ( final String str , final String charsetName ) throws UnsupportedEncodingException { return decode ( new String ( str . getBytes ( charsetName ) , STR_ ) ) ; }
public ServerCommit acquire ( OperationEntry entry , ServerSessionContext session , long timestamp ) { ServerCommit commit = pool . poll ( ) ; if ( commit == null ) { commit = new ServerCommit ( this , log ) ; } commit . reset ( entry , session , timestamp ) ; return commit ; }
public static synchronized double makeNoise ( double mean , double standardDiviation ) { return random . nextGaussian ( ) . Math . sqrt ( standardDiviation ) + mean ; }
void shutdown ( ) { try { sslEngine . closeInbound ( ) ; } catch ( SSLException e ) { if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + e . getMessage ( ) + STR_ + ses + STR_ ) ; } }
@ Override public synchronized void removeInstanceListener ( InstanceListener tsl ) { m_instanceListeners . remove ( tsl ) ; }
public Map < String , Map < String , Flt > > retrieveTerms ( int docNum ) throws IOException { return retrieveTerms ( docNum , null ) ; }
boolean alias ( String src , String target ) { if ( src == null ) return BOOL_ ; PluginHolder < T > a = registry . get ( src ) ; if ( a == null ) return BOOL_ ; PluginHolder < T > b = registry . get ( target ) ; if ( b != null ) return BOOL_ ; registry . put ( target , a ) ; return BOOL_ ; }
public static < T extends CharSequence > T eachMatch ( T self , Pattern pattern , @ ClosureParams ( value = FromString . class , options = { STR_ , STR_ } ) Closure closure ) { eachMatch ( self . toString ( ) , pattern , closure ) ; return self ; }
public void switchSingleRow ( ) { if ( m_onlyMultiRow ) return ; cardLayout . first ( cardPanel ) ; m_singleRow = BOOL_ ; dynamicDisplay ( NUM_ ) ; }
private boolean isStringContinuation ( int offset ) { int nextNonWSCharPosition = fScanner . findNonWhitespaceBackwardInAnyPartition ( offset - NUM_ , JavaHeuristicScanner . UNBOUND ) ; try { if ( nextNonWSCharPosition != JavaHeuristicScanner . NOT_FOUND && fDocument . getChar ( nextNonWSCharPosition ) == STR_ ) return BOOL_ ; else return BOOL_ ; } catch ( BadLocationException e ) { Log . error ( JavaIndenter . class , e ) ; return BOOL_ ; } }
final void push ( final Object object ) { stack . add ( object ) ; }
public void makeImmutable ( ) { mutable = BOOL_ ; }
public static < K , V > V atomicGetOrCreate ( ConcurrentMap < K , V > map , K key , Callable < V > ctor ) { V value = map . get ( key ) ; if ( value == null ) { try { value = ctor . call ( ) ; } catch ( Exception e ) { throw new RuntimeException ( STR_ , e ) ; } V existing = map . putIfAbsent ( key , value ) ; if ( existing != null ) { return existing ; } } return value ; }
public void testMixed ( ) { ArgumentParser parser = new ArgumentParser ( new String [ ] { STR_ , STR_ , STR_ , STR_ , STR_ } , BOOL_ ) ; Iterator < String > iter = parser . iterator ( ) ; assertEquals ( STR_ , iter . next ( ) ) ; assertEquals ( STR_ , iter . next ( ) ) ; assertEquals ( STR_ , iter . next ( ) ) ; assertEquals ( STR_ , iter . next ( ) ) ; assertEquals ( STR_ , iter . next ( ) ) ; assertEquals ( STR_ , iter . next ( ) ) ; assertEquals ( STR_ , iter . next ( ) ) ; assertIteratorAtEnd ( iter ) ; parser = new ArgumentParser ( new String [ ] { STR_ , STR_ , STR_ , STR_ , STR_ } , BOOL_ ) ; iter = parser . iterator ( ) ; assertEquals ( STR_ , iter . next ( ) ) ; assertEquals ( STR_ , iter . next ( ) ) ; assertEquals ( STR_ , iter . next ( ) ) ; assertEquals ( STR_ , iter . next ( ) ) ; assertEquals ( STR_ , iter . next ( ) ) ; assertIteratorAtEnd ( iter ) ; parser = new ArgumentParser ( new String [ ] { STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ } , BOOL_ ) ; iter = parser . iterator ( ) ; assertEquals ( STR_ , iter . next ( ) ) ; assertEquals ( STR_ , iter . next ( ) ) ; assertEquals ( STR_ , iter . next ( ) ) ; assertEquals ( STR_ , iter . next ( ) ) ; assertEquals ( STR_ , iter . next ( ) ) ; assertEquals ( STR_ , iter . next ( ) ) ; assertEquals ( STR_ , iter . next ( ) ) ; assertEquals ( STR_ , iter . next ( ) ) ; assertEquals ( STR_ , iter . next ( ) ) ; assertEquals ( STR_ , iter . next ( ) ) ; assertIteratorAtEnd ( iter ) ; }
private void createMetricChartPanel ( int metric , DatasetGenerator datasetGenerator , List < GCStatsChartPanel > list ) { ChangingCategoryDatasetWithTTG dataset = datasetGenerator . newCategoryDatasetWithTTG ( metric , BOOL_ ) ; GCStatsChartPanel panel = new MetricChartPanel ( CHART_PREFIX + DatasetGenerator . getMetricName ( metric ) , DatasetGenerator . getUnitName ( metric ) , dataset , locker ) ; list . add ( panel ) ; }
public void testConstrStringWithExponentWithoutPoint2 ( ) { String a = STR_ ; int aScale = NUM_ ; BigInteger bA = new BigInteger ( STR_ ) ; BigDecimal aNumber = new BigDecimal ( a ) ; assertEquals ( STR_ , bA , aNumber . unscaledValue ( ) ) ; assertEquals ( STR_ , aScale , aNumber . scale ( ) ) ; }
public DefaultClientWebRequestBuilder cookie ( String name , String value ) { return cookie ( new HttpCookie ( name , value ) ) ; }
private void addNewTilesets ( Map map ) throws IOException { for ( TileSet set : map . getTileSets ( ) ) { setByName . put ( set . getTilebmpFile ( ) , set ) ; } for ( String name : mapping . getNewSets ( ) ) { if ( name . equals ( STR_ ) ) { continue ; } if ( ! setByName . containsKey ( name ) ) { TileSet set = new TileSet ( ) ; set . setName ( constructTilesetName ( name ) ) ; BasicTileCutter cutter = new BasicTileCutter ( NUM_ , NUM_ , NUM_ , NUM_ ) ; set . importTileBitmap ( name , cutter ) ; setByName . put ( name , set ) ; map . addTileset ( set ) ; } } }
public static List < CssMetaData < ? extends Styleable , ? > > createCssMetaDataList ( List < CssMetaData < ? extends Styleable , ? > > baseList , CssMetaData < ? extends Styleable , ? > ... metaData ) { List < CssMetaData < ? extends Styleable , ? > > styleables = new ArrayList < > ( baseList ) ; styleables . addAll ( Arrays . asList ( metaData ) ) ; return Collections . unmodifiableList ( styleables ) ; }
private String diff_linesToCharsMunge ( String text , List < String > lineArray , Map < String , Integer > lineHash ) { int lineStart = NUM_ ; int lineEnd = - NUM_ ; String line ; StringBuilder chars = new StringBuilder ( ) ; while ( lineEnd < text . length ( ) - NUM_ ) { lineEnd = text . indexOf ( STR_ , lineStart ) ; if ( lineEnd == - NUM_ ) { lineEnd = text . length ( ) - NUM_ ; } line = text . substring ( lineStart , lineEnd + NUM_ ) ; lineStart = lineEnd + NUM_ ; if ( lineHash . containsKey ( line ) ) { chars . append ( String . valueOf ( ( char ) ( int ) lineHash . get ( line ) ) ) ; } else { lineArray . add ( line ) ; lineHash . put ( line , lineArray . size ( ) - NUM_ ) ; chars . append ( String . valueOf ( ( char ) ( lineArray . size ( ) - NUM_ ) ) ) ; } } return chars . toString ( ) ; }
public void addExtension ( ASN1ObjectIdentifier oid , boolean critical , byte [ ] value ) { if ( extensions . containsKey ( oid ) ) { throw new IllegalArgumentException ( STR_ + oid + STR_ ) ; } extOrdering . addElement ( oid ) ; extensions . put ( oid , new Extension ( oid , critical , new DEROctetString ( value ) ) ) ; }
public void updateClientCookies ( Boolean clientCookies ) throws SecurityException { checkWriteAccess ( ) ; boolean hasAccess = ConfigWebUtil . hasAccess ( config , SecurityManager . TYPE_SETTING ) ; if ( ! hasAccess ) throw new SecurityException ( STR_ ) ; Element scope = _getRootElement ( STR_ ) ; scope . setAttribute ( STR_ , Caster . toString ( clientCookies , STR_ ) ) ; }
public double [ ] subseriesByCopy ( double [ ] series , int start , int end ) throws IndexOutOfBoundsException { if ( ( start > end ) || ( start < NUM_ ) || ( end > series . length ) ) { throw new IndexOutOfBoundsException ( STR_ + series . length + STR_ + start + STR_ + String . valueOf ( end - start ) ) ; } return Arrays . copyOfRange ( series , start , end ) ; }
public static String createTempFile ( final String ... lines ) throws Exception { final File f = File . createTempFile ( STR_ , STR_ ) ; f . deleteOnExit ( ) ; try ( final FileWriter w = new FileWriter ( f ) ) { for ( final String s : lines ) { w . write ( s + System . getProperty ( STR_ ) ) ; } } return f . getAbsolutePath ( ) ; }
public static void readSkel ( BufferedReader reader ) throws IOException { Vector lines = new Vector ( ) ; StringBuffer section = new StringBuffer ( ) ; String ln ; while ( ( ln = reader . readLine ( ) ) != null ) { if ( ln . startsWith ( STR_ ) ) { lines . addElement ( section . toString ( ) ) ; section . setLength ( NUM_ ) ; } else { section . append ( ln ) ; section . append ( NL ) ; } } if ( section . length ( ) > NUM_ ) lines . addElement ( section . toString ( ) ) ; if ( lines . size ( ) != size ) { Out . error ( ErrorMessages . WRONG_SKELETON ) ; throw new GeneratorException ( ) ; } line = new String [ size ] ; for ( int i = NUM_ ; i < size ; i ++ ) line [ i ] = ( String ) lines . elementAt ( i ) ; }
@ Override public long readDouble ( String filePath , long offset ) { FileChannel fileChannel = updateCache ( filePath ) ; ByteBuffer byteBffer = read ( fileChannel , CarbonCommonConstants . LONG_SIZE_IN_BYTE , offset ) ; return byteBffer . getLong ( ) ; }
public LuaCompiler ( CompilerSettings settings ) { this . settings = Objects . requireNonNull ( settings ) ; }
@ SuppressWarnings ( STR_ ) public void test_putGet3 ( ) { final List < IBindingSet [ ] > in = new LinkedList < IBindingSet [ ] > ( ) ; { final IVariable < ? > x = Var . var ( STR_ ) ; final IVariable < ? > y = Var . var ( STR_ ) ; final IVariable < ? > z = Var . var ( STR_ ) ; { final List < IBindingSet > t = new LinkedList < IBindingSet > ( ) ; { final ListBindingSet b = new ListBindingSet ( ) ; b . set ( x , new Constant < IV > ( termId ) ) ; b . set ( y , new Constant < IV > ( termId2 ) ) ; t . add ( b ) ; } { final ListBindingSet b = new ListBindingSet ( ) ; b . set ( x , new Constant < IV > ( termId2 ) ) ; b . set ( y , new Constant < IV > ( inlineIV ) ) ; b . set ( z , new Constant < IV > ( blobIV ) ) ; t . add ( b ) ; } in . add ( t . toArray ( new IBindingSet [ NUM_ ] ) ) ; } } final String solutionSet = getName ( ) ; try { solutionSetsManager . getSolutions ( solutionSet ) ; fail ( STR_ + IllegalStateException . class ) ; } catch ( IllegalStateException ex ) { if ( log . isInfoEnabled ( ) ) log . info ( STR_ + ex ) ; } solutionSetsManager . putSolutions ( solutionSet , new CloseableIteratorWrapper < IBindingSet [ ] > ( in . iterator ( ) ) ) ; final ICloseableIterator < IBindingSet [ ] > out = solutionSetsManager . getSolutions ( solutionSet ) ; assertSameSolutionsAnyOrder ( flatten ( in . iterator ( ) ) , out ) ; }
public static void showAddressOnMap ( Context mContext , String address ) { address = address . replace ( STR_ , STR_ ) ; Intent geoIntent = new Intent ( Intent . ACTION_VIEW , Uri . parse ( STR_ + address ) ) ; mContext . startActivity ( geoIntent ) ; }
public Criteria createCriteria ( ) { Criteria criteria = createCriteriaInternal ( ) ; if ( oredCriteria . size ( ) == NUM_ ) { oredCriteria . add ( criteria ) ; } return criteria ; }
public void testCopyMap ( ) { Serializer serializer = new Serializer ( ) ; Map < String , String > map = new HashMap < > ( ) ; map . put ( STR_ , STR_ ) ; map . put ( STR_ , STR_ ) ; Map < String , String > result = serializer . copy ( map ) ; assertEquals ( map , result ) ; assertEquals ( map . get ( STR_ ) , STR_ ) ; assertEquals ( map . get ( STR_ ) , STR_ ) ; }
private void findBouncedInstrument ( ) { for ( final ReceiptInstrumentInfo instrumentInfo : instrumentDetails ) if ( instrumentInfo . isBounced ( ) ) bouncedInstruments . add ( instrumentInfo ) ; }
public static Set < String > convertArrayToSet ( String [ ] array ) { Set < String > resultSet = new HashSet < String > ( array . length ) ; Collections . addAll ( resultSet , array ) ; return resultSet ; }
public ParseFile ( byte [ ] data ) { this ( null , data , null ) ; }
private StoragePolicyEntity createStoragePolicyEntity ( NamespaceEntity namespaceEntity , String storagePolicyName , StorageEntity storageEntity , StorageEntity destinationStorageEntity , StoragePolicyRuleTypeEntity storagePolicyRuleTypeEntity , Integer storagePolicyRuleValue , BusinessObjectDefinitionEntity businessObjectDefinitionEntity , String businessObjectFormatUsage , FileTypeEntity fileTypeEntity , StoragePolicyStatusEntity storagePolicyStatusEntity , Integer storagePolicyVersion , Boolean storagePolicyLatestVersion ) { StoragePolicyEntity storagePolicyEntity = new StoragePolicyEntity ( ) ; storagePolicyEntity . setNamespace ( namespaceEntity ) ; storagePolicyEntity . setName ( storagePolicyName ) ; storagePolicyEntity . setStorage ( storageEntity ) ; storagePolicyEntity . setDestinationStorage ( destinationStorageEntity ) ; storagePolicyEntity . setStoragePolicyRuleType ( storagePolicyRuleTypeEntity ) ; storagePolicyEntity . setStoragePolicyRuleValue ( storagePolicyRuleValue ) ; storagePolicyEntity . setBusinessObjectDefinition ( businessObjectDefinitionEntity ) ; if ( StringUtils . isNotBlank ( businessObjectFormatUsage ) ) { storagePolicyEntity . setUsage ( businessObjectFormatUsage ) ; } storagePolicyEntity . setFileType ( fileTypeEntity ) ; storagePolicyEntity . setStatus ( storagePolicyStatusEntity ) ; storagePolicyEntity . setVersion ( storagePolicyVersion ) ; storagePolicyEntity . setLatestVersion ( storagePolicyLatestVersion ) ; return storagePolicyDao . saveAndRefresh ( storagePolicyEntity ) ; }
public void drawStdDevLine ( Graphics2D g2d , Long stdDevVal , long yMaxMark , Color color ) { float stdDevPerc = stdDevVal / ( float ) yMaxMark ; g2d . setColor ( color ) ; int yPosOfLine = this . graphBottom - Math . round ( this . graphHeight . stdDevPerc ) ; g2d . drawLine ( this . graphLeft , yPosOfLine , this . graphRight , yPosOfLine ) ; }
public SampleVcpc ( IndependenceTest independenceTest ) { if ( independenceTest == null ) { throw new NullPointerException ( ) ; } if ( ! ( independenceTest instanceof IndTestFisherZ ) ) { throw new IllegalArgumentException ( STR_ ) ; } this . independenceTest = independenceTest ; this . dataSet = ( DataSet ) independenceTest . getData ( ) ; this . variables = dataSet . getVariables ( ) ; this . covMatrix = new CovarianceMatrix ( dataSet ) ; List < Node > nodes = covMatrix . getVariables ( ) ; this . indexMap = indexMap ( variables ) ; this . nameMap = mapNames ( variables ) ; this . nodesToVariables = new HashMap < > ( ) ; this . variablesToNodes = new HashMap < > ( ) ; }
private int nextAvailableIdx ( Collection < Integer > startedGrids , int maxTopSize , Random rnd ) { while ( BOOL_ ) { int idx = rnd . nextInt ( maxTopSize ) ; if ( ! startedGrids . contains ( idx ) ) return idx ; } }
public boolean hasColor ( ) { return typeString . contains ( COLOR ) ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
public ClearanceMatrix ( int p_class_count , BrdLayerStructure p_layer_structure , String [ ] p_name_arr ) { class_count = Math . max ( p_class_count , NUM_ ) ; layer_structure = p_layer_structure ; clearance_rows = new ClearanceMatrixRow [ class_count ] ; for ( int index = NUM_ ; index < class_count ; ++ index ) { clearance_rows [ index ] = new ClearanceMatrixRow ( this , p_name_arr [ index ] ) ; } max_value_on_layer = new int [ layer_structure . size ( ) ] ; }
public static char [ ] concat ( char [ ] base , char [ ] other , int appendCount ) { final int length = base . length ; char [ ] newArray = copyFrom ( base , base . length + appendCount ) ; System . arraycopy ( other , NUM_ , newArray , length , appendCount ) ; return newArray ; }
public ArrayRealVector ( ArrayRealVector v1 , ArrayRealVector v2 ) { data = new double [ v1 . data . length + v2 . data . length ] ; System . arraycopy ( v1 . data , NUM_ , data , NUM_ , v1 . data . length ) ; System . arraycopy ( v2 . data , NUM_ , data , v1 . data . length , v2 . data . length ) ; }
void addClassList ( String classListFilename ) { if ( classListFilename . length ( ) > NUM_ ) { setOption ( STR_ , classListFilename ) ; loadClassNames ( classListFilename ) ; } else { throw new IllegalArgumentException ( STR_ ) ; } }
private Start build ( Start event ) { NamedNodeMap list = event . getAttributes ( ) ; int length = list . getLength ( ) ; for ( int i = NUM_ ; i < length ; i ++ ) { Node node = list . item ( i ) ; Attribute value = attribute ( node ) ; if ( ! value . isReserved ( ) ) { event . add ( value ) ; } } return event ; }
public BytesToNameCanonicalizer makeChild ( boolean canonicalize , boolean intern ) { return new BytesToNameCanonicalizer ( this , intern , _hashSeed , _tableInfo . get ( ) ) ; }
public static String encodeString ( String s ) { return new String ( encode ( s . getBytes ( ) ) ) ; }
public Instances retrieveInstances ( ) throws Exception { return retrieveInstances ( m_Query ) ; }
void extract ( InputStream in , String files [ ] ) throws IOException { ZipInputStream zis = new ZipInputStream ( in ) ; ZipEntry e ; Set < ZipEntry > dirs = newDirSet ( ) ; while ( ( e = zis . getNextEntry ( ) ) != null ) { if ( files == null ) { dirs . add ( extractFile ( zis , e ) ) ; } else { String name = e . getName ( ) ; for ( String file : files ) { if ( name . startsWith ( file ) ) { dirs . add ( extractFile ( zis , e ) ) ; break ; } } } } updateLastModifiedTime ( dirs ) ; }
private int clampMag ( int value , int absMin , int absMax ) { final int absValue = Math . abs ( value ) ; if ( absValue < absMin ) return NUM_ ; if ( absValue > absMax ) return value > NUM_ ? absMax : - absMax ; return value ; }
public void testGetAccentColorsByName ( ) { try { for ( String name : MaterialPalettes . COLORS_WITH_ACCENT_NAMES ) { List < Integer > colorList = MaterialPalettes . getAccentColorsByName ( name ) ; assertEquals ( MaterialPalettes . ACCENT_COLOR_LEVELS . length , colorList . size ( ) ) ; } } catch ( IllegalAccessException iae ) { fail ( ) ; } }
private static void drawChunk ( Image image , Graphics g , boolean stretch , int dx1 , int dy1 , int dx2 , int dy2 , int sx1 , int sy1 , int sx2 , int sy2 , boolean xDirection ) { if ( dx2 - dx1 <= NUM_ || dy2 - dy1 <= NUM_ || sx2 - sx1 <= NUM_ || sy2 - sy1 <= NUM_ ) { return ; } if ( stretch ) { g . drawImage ( image , dx1 , dy1 , dx2 , dy2 , sx1 , sy1 , sx2 , sy2 , null ) ; } else { int xSize = sx2 - sx1 ; int ySize = sy2 - sy1 ; int deltaX ; int deltaY ; if ( xDirection ) { deltaX = xSize ; deltaY = NUM_ ; } else { deltaX = NUM_ ; deltaY = ySize ; } while ( dx1 < dx2 && dy1 < dy2 ) { int newDX2 = Math . min ( dx2 , dx1 + xSize ) ; int newDY2 = Math . min ( dy2 , dy1 + ySize ) ; g . drawImage ( image , dx1 , dy1 , newDX2 , newDY2 , sx1 , sy1 , sx1 + newDX2 - dx1 , sy1 + newDY2 - dy1 , null ) ; dx1 += deltaX ; dy1 += deltaY ; } } }
private void initSign ( ) { messDigestTrees . reset ( ) ; GMSSPrivateKeyParameters gmssPrivateKey = ( GMSSPrivateKeyParameters ) key ; if ( gmssPrivateKey . isUsed ( ) ) { throw new IllegalStateException ( STR_ ) ; } if ( gmssPrivateKey . getIndex ( NUM_ ) >= gmssPrivateKey . getNumLeafs ( NUM_ ) ) { throw new IllegalStateException ( STR_ ) ; } this . gmssPS = gmssPrivateKey . getParameters ( ) ; this . numLayer = gmssPS . getNumOfLayers ( ) ; byte [ ] seed = gmssPrivateKey . getCurrentSeeds ( ) [ numLayer - NUM_ ] ; byte [ ] OTSSeed = new byte [ mdLength ] ; byte [ ] dummy = new byte [ mdLength ] ; System . arraycopy ( seed , NUM_ , dummy , NUM_ , mdLength ) ; OTSSeed = gmssRandom . nextSeed ( dummy ) ; this . ots = new WinternitzOTSignature ( OTSSeed , digestProvider . get ( ) , gmssPS . getWinternitzParameter ( ) [ numLayer - NUM_ ] ) ; byte [ ] [ ] [ ] helpCurrentAuthPaths = gmssPrivateKey . getCurrentAuthPaths ( ) ; currentAuthPaths = new byte [ numLayer ] [ ] [ ] ; for ( int j = NUM_ ; j < numLayer ; j ++ ) { currentAuthPaths [ j ] = new byte [ helpCurrentAuthPaths [ j ] . length ] [ mdLength ] ; for ( int i = NUM_ ; i < helpCurrentAuthPaths [ j ] . length ; i ++ ) { System . arraycopy ( helpCurrentAuthPaths [ j ] [ i ] , NUM_ , currentAuthPaths [ j ] [ i ] , NUM_ , mdLength ) ; } } index = new int [ numLayer ] ; System . arraycopy ( gmssPrivateKey . getIndex ( ) , NUM_ , index , NUM_ , numLayer ) ; byte [ ] helpSubtreeRootSig ; subtreeRootSig = new byte [ numLayer - NUM_ ] [ ] ; for ( int i = NUM_ ; i < numLayer - NUM_ ; i ++ ) { helpSubtreeRootSig = gmssPrivateKey . getSubtreeRootSig ( i ) ; subtreeRootSig [ i ] = new byte [ helpSubtreeRootSig . length ] ; System . arraycopy ( helpSubtreeRootSig , NUM_ , subtreeRootSig [ i ] , NUM_ , helpSubtreeRootSig . length ) ; } gmssPrivateKey . markUsed ( ) ; }
private static void decodeEdifactSegment ( BitSource bits , StringBuilder result ) { do { if ( bits . available ( ) <= NUM_ ) { return ; } for ( int i = NUM_ ; i < NUM_ ; i ++ ) { int edifactValue = bits . readBits ( NUM_ ) ; if ( edifactValue == x1F ) { int bitsLeft = NUM_ - bits . getBitOffset ( ) ; if ( bitsLeft != NUM_ ) { bits . readBits ( bitsLeft ) ; } return ; } if ( ( edifactValue & x20 ) == NUM_ ) { edifactValue |= x40 ; } result . append ( ( char ) edifactValue ) ; } } while ( bits . available ( ) > NUM_ ) ; }
public void write ( byte [ ] b , int offset , int length ) throws IOException { out . write ( b , offset , length ) ; }
public SampleSet ( DataInputStream is ) throws IOException { int numSamples ; sampleInfo = new SampleInfo ( is ) ; numSamples = is . readInt ( ) ; this . samples = new Sample [ numSamples ] ; for ( int i = NUM_ ; i < numSamples ; i ++ ) { samples [ i ] = Sample . loadBinary ( is ) ; } }
public void close ( ) { running = BOOL_ ; synchronized ( histData ) { histData . notify ( ) ; } }
public SQLiteDatabaseConfiguration ( String path , @ SQLiteDatabase . OpenFlags int openFlags ) { if ( path == null ) { throw new IllegalArgumentException ( STR_ ) ; } this . path = path ; label = stripPathForLogs ( path ) ; this . openFlags = openFlags ; maxSqlCacheSize = NUM_ ; locale = Locale . getDefault ( ) ; }
private void printProperties ( Properties properties ) throws IOException { StringWriter stringBuffer = new StringWriter ( ) ; BufferedReader reader = null ; properties . store ( stringBuffer , null ) ; try { reader = new BufferedReader ( new StringReader ( stringBuffer . toString ( ) ) ) ; reader . readLine ( ) ; String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { writer . print ( STR_ ) ; writer . println ( line ) ; } } finally { if ( reader != null ) { reader . close ( ) ; } } }
public static < T > Range < T > valueOf ( String s , Class < T > clazz ) { char lbm = s . charAt ( NUM_ ) ; if ( lbm != STR_ && lbm != STR_ ) throw new IllegalArgumentException ( s ) ; char ubm = s . charAt ( s . length ( ) - NUM_ ) ; if ( ubm != STR_ && ubm != STR_ ) throw new IllegalArgumentException ( s ) ; BoundType lbt = lbm == STR_ ? BoundType . CLOSED : BoundType . OPEN ; BoundType ubt = ubm == STR_ ? BoundType . CLOSED : BoundType . OPEN ; s = s . substring ( NUM_ , s . length ( ) - NUM_ ) ; String [ ] parts = s . split ( STR_ ) ; String lbs = parts [ NUM_ ] ; String ubs = parts [ NUM_ ] ; T lowerBound = lbs . equals ( STR_ ) ? null : boundValue ( lbs , clazz ) ; T upperBound = ubs . equals ( STR_ ) ? null : boundValue ( ubs , clazz ) ; return range ( lowerBound , lbt , upperBound , ubt ) ; }
public static DoubleVector dchisq ( double x , DoubleVector ncp ) { int n = ncp . size ( ) ; DoubleVector d = new DoubleVector ( n ) ; double xh = Math . sqrt ( x ) ; double mean ; for ( int i = NUM_ ; i < n ; i ++ ) { mean = Math . sqrt ( ncp . get ( i ) ) ; if ( ncp . get ( i ) == NUM_ ) d . set ( i , dchisq ( x ) ) ; else d . set ( i , ( dnorm ( xh - mean ) + dnorm ( - xh - mean ) ) / ( NUM_ . xh ) ) ; } return d ; }
@ Override public void addPropertyChangeListener ( PropertyChangeListener listener ) { propertyChangeSupport . addPropertyChangeListener ( listener ) ; }
public void removeAllBaudRateQueryCallbacks ( ) { baudRateQueryCallbacks . clear ( ) ; }
public void add ( AbstractOption option ) { add ( options . size ( ) , option ) ; }
private void loadVerticesAndRelatives ( ) { List < CnATreeElement > elementList = new LinkedList < CnATreeElement > ( ) ; for ( IGraphElementLoader loader : getLoaderList ( ) ) { loader . setCnaTreeElementDao ( getCnaTreeElementDao ( ) ) ; elementList . addAll ( loader . loadElements ( ) ) ; } for ( CnATreeElement element : elementList ) { graph . addVertex ( element ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( STR_ + element . getTitle ( ) ) ; } uuidMap . put ( element . getUuid ( ) , element ) ; } for ( CnATreeElement parent : elementList ) { Set < CnATreeElement > children = parent . getChildren ( ) ; for ( CnATreeElement child : children ) { createParentChildEdge ( parent , child ) ; } } }
private boolean hasNonSpecialAttribute ( Collection < String > keys ) { for ( String attr : keys ) { if ( ! attr . startsWith ( STR_ ) ) { return BOOL_ ; } } return BOOL_ ; }
public static final void shuffle ( double [ ] a , int start , int len , Random r ) { for ( int i = start + len ; i > NUM_ ; -- i ) { double t = a [ i ] ; int j = r . nextInt ( i ) ; a [ i ] = a [ j ] ; a [ j ] = t ; } }
public boolean isParityCorrect ( byte [ ] [ ] shards , int firstByte , int byteCount , byte [ ] tempBuffer ) { checkBuffersAndSizes ( shards , firstByte , byteCount ) ; if ( tempBuffer . length < firstByte + byteCount ) { throw new IllegalArgumentException ( STR_ ) ; } byte [ ] [ ] toCheck = new byte [ parityShardCount ] [ ] ; System . arraycopy ( shards , dataShardCount , toCheck , NUM_ , parityShardCount ) ; return codingLoop . checkSomeShards ( parityRows , shards , dataShardCount , toCheck , parityShardCount , firstByte , byteCount , tempBuffer ) ; }
public static void writeStream ( InputStream in , File file ) throws IOException { FileOutputStream out = new FileOutputStream ( file ) ; try { transfer ( in , out ) ; } finally { try { out . flush ( ) ; } finally { out . close ( ) ; } } }
private static native long createEntityParser ( long parentPointer , String context ) ;
public void firePropertyChange ( String propertyName , byte oldValue , byte newValue ) { if ( changeSupport == null || oldValue == newValue ) { return ; } firePropertyChange ( propertyName , Byte . valueOf ( oldValue ) , Byte . valueOf ( newValue ) ) ; }
private int adjustOffsetForUnitTests ( int offset ) { if ( System . getProperty ( STR_ ) == null ) return offset ; else return NUM_ ; }
private boolean checkTouchSlop ( View child , float dx , float dy ) { if ( child == null ) { return BOOL_ ; } final boolean checkHorizontal = mCallback . getViewHorizontalDragRange ( child ) > NUM_ ; final boolean checkVertical = mCallback . getViewVerticalDragRange ( child ) > NUM_ ; if ( checkHorizontal && checkVertical ) { return dx . dx + dy . dy > mTouchSlop . mTouchSlop ; } else if ( checkHorizontal ) { return Math . abs ( dx ) > mTouchSlop ; } else if ( checkVertical ) { return Math . abs ( dy ) > mTouchSlop ; } return BOOL_ ; }
public static boolean isAix ( ) { return osName . indexOf ( STR_ ) > - NUM_ ; }
private double testFit ( double [ ] x , double [ ] test , Distribution dist ) throws ArithmeticException { for ( int i = NUM_ ; i < test . length ; i ++ ) { test [ i ] = dist . cdf ( x [ i ] ) ; if ( test [ i ] > NUM_ ) { test [ i ] = NUM_ ; } if ( test [ i ] < NUM_ ) { test [ i ] = NUM_ ; } if ( Double . isNaN ( test [ i ] ) ) { throw new ArithmeticException ( STR_ + dist . toString ( ) ) ; } } Arrays . sort ( test ) ; return KolmogorovSmirnovTest . simpleTest ( test ) ; }
public boolean supportsSQL ( ) { return BOOL_ ; }
private static Boolean isValidIPV4 ( final String ipAddress ) { boolean status = BOOL_ ; if ( StringUtils . isNotEmpty ( ipAddress ) ) { status = InetAddressUtils . isIPv4Address ( ipAddress ) ; } return status ; }
private int decryptBlockWithIV ( byte [ ] in , int inOff , byte [ ] out , int outOff ) throws DataLengthException , IllegalStateException { if ( ( inOff + blockSize ) > in . length ) { throw new DataLengthException ( STR_ ) ; } if ( ( outOff + blockSize ) > out . length ) { throw new DataLengthException ( STR_ ) ; } if ( count == NUM_ ) { for ( int n = NUM_ ; n < blockSize ; n ++ ) { FR [ n ] = in [ inOff + n ] ; } cipher . processBlock ( FR , NUM_ , FRE , NUM_ ) ; count += blockSize ; return NUM_ ; } else if ( count == blockSize ) { System . arraycopy ( in , inOff , tmp , NUM_ , blockSize ) ; System . arraycopy ( FR , NUM_ , FR , NUM_ , blockSize - NUM_ ) ; FR [ blockSize - NUM_ ] = tmp [ NUM_ ] ; FR [ blockSize - NUM_ ] = tmp [ NUM_ ] ; cipher . processBlock ( FR , NUM_ , FRE , NUM_ ) ; for ( int n = NUM_ ; n < blockSize - NUM_ ; n ++ ) { out [ outOff + n ] = encryptByte ( tmp [ n + NUM_ ] , n ) ; } System . arraycopy ( tmp , NUM_ , FR , NUM_ , blockSize - NUM_ ) ; count += NUM_ ; return blockSize - NUM_ ; } else if ( count >= blockSize + NUM_ ) { System . arraycopy ( in , inOff , tmp , NUM_ , blockSize ) ; out [ outOff + NUM_ ] = encryptByte ( tmp [ NUM_ ] , blockSize - NUM_ ) ; out [ outOff + NUM_ ] = encryptByte ( tmp [ NUM_ ] , blockSize - NUM_ ) ; System . arraycopy ( tmp , NUM_ , FR , blockSize - NUM_ , NUM_ ) ; cipher . processBlock ( FR , NUM_ , FRE , NUM_ ) ; for ( int n = NUM_ ; n < blockSize - NUM_ ; n ++ ) { out [ outOff + n + NUM_ ] = encryptByte ( tmp [ n + NUM_ ] , n ) ; } System . arraycopy ( tmp , NUM_ , FR , NUM_ , blockSize - NUM_ ) ; } return blockSize ; }
public static PTABridge v ( ) { return v ; }
public void registerCacheUpdatePeriodChangeListener ( final PropertyChangeListener listener ) { cacheUpdatePeriodListeners . add ( listener ) ; }
public void testNullStoredField ( ) throws Exception { Directory dir = newDirectory ( ) ; Analyzer analyzer = new MockAnalyzer ( random ( ) ) ; IndexWriter iw = new IndexWriter ( dir , new IndexWriterConfig ( analyzer ) ) ; Document doc = new Document ( ) ; iw . addDocument ( doc ) ; expectThrows ( IllegalArgumentException . class , null ) ; assertNull ( iw . getTragicException ( ) ) ; iw . close ( ) ; DirectoryReader r = DirectoryReader . open ( dir ) ; assertEquals ( NUM_ , r . numDocs ( ) ) ; r . close ( ) ; dir . close ( ) ; }
public void addUpdateListener ( AnimatorUpdateListener listener ) { if ( mUpdateListeners == null ) { mUpdateListeners = new ArrayList < AnimatorUpdateListener > ( ) ; } mUpdateListeners . add ( listener ) ; }
public String encode ( ) { StringBuffer sb = new StringBuffer ( ) ; encode ( sb ) ; return sb . toString ( ) ; }
public static Document readDocument ( String fileName ) throws SAXException , IOException { DocumentBuilder docBuilder ; Document result = null ; DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory . newInstance ( ) ; docBuilderFactory . setIgnoringElementContentWhitespace ( BOOL_ ) ; try { docBuilder = docBuilderFactory . newDocumentBuilder ( ) ; } catch ( ParserConfigurationException e ) { throw new Error ( e ) ; } File sourceFile = new File ( fileName ) ; result = docBuilder . parse ( sourceFile ) ; return result ; }
@ Override public double [ ] analyse ( double [ ] aFrame ) { if ( aFrame . length != frameLength ) throw new IllegalArgumentException ( STR_ + frameLength + STR_ + aFrame . length ) ; double [ ] real = new double [ fftSize ] ; double [ ] imag = new double [ fftSize ] ; System . arraycopy ( aFrame , NUM_ , real , NUM_ , aFrame . length ) ; FFT . transform ( real , imag , BOOL_ ) ; MathUtils . toPolarCoordinates ( real , imag ) ; real = MathUtils . log ( real ) ; Arrays . fill ( imag , NUM_ ) ; double b = NUM_ ; int bIndex = ( int ) ( b / frequencyResolution ) ; double [ ] invReal ; double [ ] invImag ; if ( invFftSize == fftSize ) { invReal = real ; invImag = imag ; } else { invReal = new double [ invFftSize ] ; System . arraycopy ( real , NUM_ , invReal , NUM_ , bIndex + NUM_ ) ; invImag = new double [ invFftSize ] ; } for ( int i = bIndex + NUM_ ; i < invFftSize / NUM_ ; i ++ ) { invReal [ i ] = invReal [ bIndex ] ; } for ( int i = NUM_ ; i < invFftSize / NUM_ ; i ++ ) { invReal [ invFftSize - i - NUM_ ] = invReal [ i ] ; } FFT . transform ( invReal , invImag , BOOL_ ) ; return invReal ; }
public SearchSourceBuilder scriptField ( String name , Script script ) { if ( scriptFields == null ) { scriptFields = new ArrayList < > ( ) ; } scriptFields . add ( new ScriptField ( name , script ) ) ; return this ; }
public void fixedAspectResizeInner ( RectF newInner ) { Matrix m = getRotMatrix ( ) ; Matrix m0 = getInverseRotMatrix ( ) ; float aspectW = inner . width ( ) ; float aspectH = inner . height ( ) ; float aspRatio = aspectW / aspectH ; float [ ] corners = CropMath . getCornersFromRect ( outer ) ; m . mapPoints ( corners ) ; float [ ] oldInnerCorners = CropMath . getCornersFromRect ( inner ) ; float [ ] newInnerCorners = CropMath . getCornersFromRect ( newInner ) ; int fixed = - NUM_ ; if ( inner . top == newInner . top ) { if ( inner . left == newInner . left ) fixed = NUM_ ; else if ( inner . right == newInner . right ) fixed = NUM_ ; } else if ( inner . bottom == newInner . bottom ) { if ( inner . right == newInner . right ) fixed = NUM_ ; else if ( inner . left == newInner . left ) fixed = NUM_ ; } if ( fixed == - NUM_ ) return ; float widthSoFar = newInner . width ( ) ; int moved = - NUM_ ; for ( int i = NUM_ ; i < newInnerCorners . length ; i += NUM_ ) { float [ ] c = { newInnerCorners [ i ] , newInnerCorners [ i + NUM_ ] } ; float [ ] c0 = Arrays . copyOf ( c , NUM_ ) ; m0 . mapPoints ( c0 ) ; if ( ! CropMath . inclusiveContains ( outer , c0 [ NUM_ ] , c0 [ NUM_ ] ) ) { moved = i ; if ( moved == fixed ) continue ; float [ ] l2 = CropMath . closestSide ( c , corners ) ; float [ ] l1 = { newInnerCorners [ i ] , newInnerCorners [ i + NUM_ ] , oldInnerCorners [ i ] , oldInnerCorners [ i + NUM_ ] } ; float [ ] p = GeometryMathUtils . lineIntersect ( l1 , l2 ) ; if ( p == null ) { p = new float [ NUM_ ] ; p [ NUM_ ] = oldInnerCorners [ i ] ; p [ NUM_ ] = oldInnerCorners [ i + NUM_ ] ; } float fixed_x = oldInnerCorners [ fixed ] ; float fixed_y = oldInnerCorners [ fixed + NUM_ ] ; float newWidth = Math . abs ( fixed_x - p [ NUM_ ] ) ; float newHeight = Math . abs ( fixed_y - p [ NUM_ ] ) ; newWidth = Math . max ( newWidth , aspRatio . newHeight ) ; if ( newWidth < widthSoFar ) widthSoFar = newWidth ; } } float heightSoFar = widthSoFar / aspRatio ; RectF ret = new RectF ( inner ) ; if ( fixed == NUM_ ) { ret . right = ret . left + widthSoFar ; ret . bottom = ret . top + heightSoFar ; } else if ( fixed == NUM_ ) { ret . left = ret . right - widthSoFar ; ret . bottom = ret . top + heightSoFar ; } else if ( fixed == NUM_ ) { ret . left = ret . right - widthSoFar ; ret . top = ret . bottom - heightSoFar ; } else if ( fixed == NUM_ ) { ret . right = ret . left + widthSoFar ; ret . top = ret . bottom - heightSoFar ; } float [ ] retCorners = CropMath . getCornersFromRect ( ret ) ; m0 . mapPoints ( retCorners ) ; innerRotated = retCorners ; reconstrain ( ) ; }
public static < T > T withObjectStreams ( Socket socket , @ ClosureParams ( value = SimpleType . class , options = { STR_ , STR_ } ) Closure < T > closure ) throws IOException { InputStream input = socket . getInputStream ( ) ; OutputStream output = socket . getOutputStream ( ) ; ObjectOutputStream oos = new ObjectOutputStream ( output ) ; ObjectInputStream ois = new ObjectInputStream ( input ) ; try { T result = closure . call ( new Object [ ] { ois , oos } ) ; InputStream temp1 = ois ; ois = null ; temp1 . close ( ) ; temp1 = input ; input = null ; temp1 . close ( ) ; OutputStream temp2 = oos ; oos = null ; temp2 . close ( ) ; temp2 = output ; output = null ; temp2 . close ( ) ; return result ; } finally { closeWithWarning ( ois ) ; closeWithWarning ( input ) ; closeWithWarning ( oos ) ; closeWithWarning ( output ) ; } }
public JFileDataStoreChooser ( Shell parent , int style , final String [ ] extensions ) { this ( parent , style , associations ( Arrays . asList ( extensions ) ) ) ; }
private void adjustAlignment ( int align , int curAlign ) { if ( ( ! FIXED_WIDTH ) && ( align != curAlign ) ) { if ( curLine . getComponentCount ( ) == NUM_ ) { curLine . setLayout ( new FlowLayout ( curAlign ) ) ; } } }
public boolean writeHeader ( OutputStream os ) { try { writeInt ( os , CACHE_MAGIC ) ; writeString ( os , key ) ; writeString ( os , etag == null ? STR_ : etag ) ; writeLong ( os , serverDate ) ; writeLong ( os , lastModified ) ; writeLong ( os , ttl ) ; writeLong ( os , softTtl ) ; writeStringStringMap ( responseHeaders , os ) ; os . flush ( ) ; return BOOL_ ; } catch ( IOException e ) { VolleyLog . d ( STR_ , e . toString ( ) ) ; return BOOL_ ; } }
public void removeListener ( TrackingListener listener ) { listeners . remove ( listener ) ; }
void createImpl ( boolean stream ) throws SocketException { if ( impl == null ) setImpl ( ) ; try { impl . create ( stream ) ; created = BOOL_ ; } catch ( IOException e ) { throw new SocketException ( e . getMessage ( ) ) ; } }
public synchronized byte [ ] toByteArray ( ) { int remaining = count ; if ( remaining == NUM_ ) { return EMPTY_BYTE_ARRAY ; } byte newbuf [ ] = new byte [ remaining ] ; int pos = NUM_ ; for ( byte [ ] buf : buffers ) { int c = Math . min ( buf . length , remaining ) ; System . arraycopy ( buf , NUM_ , newbuf , pos , c ) ; pos += c ; remaining -= c ; if ( remaining == NUM_ ) { break ; } } return newbuf ; }
public boolean shExpMatch ( String str , String shexp ) { StringTokenizer tokenizer = new StringTokenizer ( shexp , STR_ ) ; int startPos = NUM_ ; while ( tokenizer . hasMoreTokens ( ) ) { String token = tokenizer . nextToken ( ) ; int temp = str . indexOf ( token , startPos ) ; if ( startPos == NUM_ && ! shexp . startsWith ( STR_ ) && temp != NUM_ ) { return BOOL_ ; } if ( ! tokenizer . hasMoreTokens ( ) && ! shexp . endsWith ( STR_ ) && ! str . endsWith ( token ) ) { return BOOL_ ; } if ( temp == - NUM_ ) { return BOOL_ ; } else { startPos = temp + token . length ( ) ; } } return BOOL_ ; }
public char peek ( ) { return isEmpty ( ) ? NUM_ : queue . charAt ( pos ) ; }
private String [ ] parentKey ( String name , int idx ) { String [ ] parts = name . split ( STR_ ) ; if ( idx > parts . length ) return null ; String parent = STR_ ; String key = null ; if ( idx < parts . length ) key = parts [ idx ] ; for ( int i = NUM_ ; i < idx ; i ++ ) { parent = parent . length ( ) > NUM_ ? parent + STR_ + parts [ i ] : parts [ i ] ; } return new String [ ] { parent , key } ; }
public DiphoneUnitDatabase ( URL url , boolean isBinary ) throws IOException { if ( ! useIndexing || useCache ) { diphoneMap = new LinkedHashMap ( ) ; } InputStream is = Utilities . getInputStream ( url ) ; indexName = getIndexName ( url . toString ( ) ) ; if ( isBinary ) { loadBinary ( is ) ; } else { loadText ( is ) ; } is . close ( ) ; sampleInfo = new SampleInfo ( sampleRate , numChannels , residualFold , lpcMin , lpcRange , NUM_ ) ; }
public static List < NotificationDto > transformToDto ( List < Notification > notifications ) { if ( notifications == null ) { throw new WebApplicationException ( STR_ , Status . INTERNAL_SERVER_ERROR ) ; } List < NotificationDto > result = new ArrayList < NotificationDto > ( ) ; for ( Notification notification : notifications ) { result . add ( transformToDto ( notification ) ) ; } return result ; }
public void writeTo ( final PacketOutputStream os ) { os . write ( ParameterWriter . QUOTE ) ; os . write ( dateToByte ( ) ) ; ParameterWriter . formatMicroseconds ( os , ts . getNanos ( ) / NUM_ , fractionalSeconds ) ; os . write ( ParameterWriter . QUOTE ) ; }
public long skip ( long n ) throws IOException , LogException { if ( length < n ) badRead ( ( int ) n ) ; n = in . skip ( n ) ; length -= ( int ) n ; return n ; }
public DriverTask discoverStorageProvider ( StorageProvider storageProvider , List < StorageSystem > storageSystems ) { DellSCDriverTask task = new DellSCDriverTask ( STR_ ) ; try { LOG . info ( STR_ , storageProvider . getProviderHost ( ) , storageProvider . getPortNumber ( ) , storageProvider . getUsername ( ) ) ; StorageCenterAPI api = connectionManager . getConnection ( storageProvider . getProviderHost ( ) , storageProvider . getPortNumber ( ) , storageProvider . getUsername ( ) , storageProvider . getPassword ( ) , BOOL_ ) ; LOG . info ( STR_ , storageProvider . getProviderHost ( ) , storageProvider . getUsername ( ) ) ; storageProvider . setAccessStatus ( AccessStatus . READ_WRITE ) ; storageProvider . setManufacturer ( STR_ ) ; storageProvider . setProviderVersion ( driverVersion ) ; storageProvider . setIsSupportedVersion ( BOOL_ ) ; EmDataCollector em = api . getDSMInfo ( ) ; if ( em != null ) { LOG . info ( STR_ , em . type , em . version , em . javaVersion ) ; storageProvider . setProviderVersion ( em . version ) ; } StorageCenter [ ] scs = api . getStorageCenterInfo ( ) ; for ( StorageCenter sc : scs ) { StorageSystem storageSystem = util . getStorageSystemFromStorageCenter ( api , sc , null ) ; storageSystem . setSystemType ( driverName ) ; storageSystems . add ( storageSystem ) ; } task . setStatus ( DriverTask . TaskStatus . READY ) ; } catch ( Exception e ) { String msg = String . format ( STR_ , e ) ; LOG . error ( msg ) ; task . setFailed ( msg ) ; } return task ; }
public void zoomIn ( ) { zoomIn ( null ) ; }
public void removeResponseCodeListener ( ActionListener a ) { responseCodeListeners . removeElement ( a ) ; }
public InputFieldDialog ( final String CAPTION_KEY , final String LABEL_KEY ) { String caption = I18n . tr ( CAPTION_KEY ) ; Frame frame = GUIMediator . getAppFrame ( ) ; _dialog = new JDialog ( frame , caption , BOOL_ ) ; _dialog . setSize ( NUM_ , NUM_ ) ; LabeledComponent component = new LabeledComponent ( LABEL_KEY , TEXT_FIELD , LabeledComponent . LEFT_GLUE ) ; String [ ] buttonLabelKeys = { I18n . tr ( STR_ ) , I18n . tr ( STR_ ) } ; String [ ] buttonLabelTips = { I18n . tr ( STR_ ) , I18n . tr ( STR_ ) } ; ActionListener [ ] buttonListeners = { new OKListener ( ) , new CancelListener ( ) } ; ButtonRow buttons = new ButtonRow ( buttonLabelKeys , buttonLabelTips , buttonListeners , ButtonRow . X_AXIS , ButtonRow . LEFT_GLUE ) ; Container contentPane = _dialog . getContentPane ( ) ; BoxPanel componentPanel = new BoxPanel ( BoxPanel . Y_AXIS ) ; componentPanel . add ( Box . createVerticalGlue ( ) ) ; componentPanel . add ( component . getComponent ( ) ) ; componentPanel . add ( Box . createVerticalGlue ( ) ) ; MAIN_PANEL . add ( componentPanel ) ; MAIN_PANEL . add ( Box . createVerticalGlue ( ) ) ; MAIN_PANEL . add ( buttons ) ; contentPane . add ( MAIN_PANEL ) ; }
public EntityLoadInfo create ( Entity entity ) { return create ( entity , null ) ; }
public Float ( Point2D pt2D ) { setLatLon ( pt2D . getY ( ) , pt2D . getX ( ) , BOOL_ ) ; }
public final static boolean isPotentialZipArchive ( String name ) { int lastDot = name . lastIndexOf ( STR_ ) ; if ( lastDot == - NUM_ ) return BOOL_ ; if ( name . lastIndexOf ( File . separatorChar ) > lastDot ) return BOOL_ ; int length = name . length ( ) ; int extensionLength = length - lastDot - NUM_ ; if ( extensionLength == EXTENSION_java . length ( ) ) { for ( int i = extensionLength - NUM_ ; i >= NUM_ ; i -- ) { if ( Character . toLowerCase ( name . charAt ( length - extensionLength + i ) ) != EXTENSION_java . charAt ( i ) ) { break ; } if ( i == NUM_ ) { return BOOL_ ; } } } if ( extensionLength == EXTENSION_class . length ( ) ) { for ( int i = extensionLength - NUM_ ; i >= NUM_ ; i -- ) { if ( Character . toLowerCase ( name . charAt ( length - extensionLength + i ) ) != EXTENSION_class . charAt ( i ) ) { return BOOL_ ; } } return BOOL_ ; } return BOOL_ ; }
public void open ( ) throws IOException { connection = new DatagramSocket ( ) ; connection . setSoTimeout ( timeout ) ; }
@ Override protected int sizeOf ( String key , BitmapDrawable value ) { final int bitmapSize = getBitmapSize ( value ) / NUM_ ; return bitmapSize == NUM_ ? NUM_ : bitmapSize ; }
default void forEachRemaining ( IntConsumer action ) { Objects . requireNonNull ( action ) ; while ( hasNext ( ) ) action . accept ( nextInt ( ) ) ; }
private boolean isCI ( ) { return Objects . equals ( System . getenv ( STR_ ) , STR_ ) ; }
public DockNode ( Node contents , String title ) { this ( contents , title , null ) ; }
public static int readSingleByte ( InputStream in ) throws IOException { byte [ ] buffer = new byte [ NUM_ ] ; int result = in . read ( buffer , NUM_ , NUM_ ) ; return ( result != - NUM_ ) ? buffer [ NUM_ ] & xff : - NUM_ ; }
public static long parseId ( Uri contentUri ) { String last = contentUri . getLastPathSegment ( ) ; return last == null ? - NUM_ : Long . parseLong ( last ) ; }
public void disableVM ( String hostname , long durationMillis ) throws IllegalStateException { logger . info ( STR_ + hostname + STR_ + durationMillis + STR_ ) ; assignableVMs . disableUntil ( hostname , System . currentTimeMillis ( ) + durationMillis ) ; }
protected final void endOfInput ( ) throws IOException { if ( cacheRequest != null ) { cacheBody . close ( ) ; } httpEngine . release ( BOOL_ ) ; }
public int left ( ) { return data . length ( ) - pos ; }
public FeatureSet combine ( final FeatureSet other ) { final Set < Feature > enabled = new HashSet < > ( this . enabled ) ; enabled . addAll ( other . enabled ) ; final Set < Feature > disabled = new HashSet < > ( this . disabled ) ; disabled . addAll ( other . disabled ) ; return new FeatureSet ( enabled , disabled ) ; }
public void removeInterval ( final BatchWriter writer , final TemporalInterval interval , final Statement statement ) throws MutationsRejectedException { final Text cf = new Text ( StatementSerializer . writeContext ( statement ) ) ; final Text cqBegin = new Text ( KeyParts . CQ_BEGIN ) ; final Text cqEnd = new Text ( KeyParts . CQ_END ) ; Text keyText = new Text ( interval . getAsKeyBeginning ( ) ) ; KeyParts . appendUniqueness ( statement , keyText ) ; Mutation m = new Mutation ( keyText ) ; m . putDelete ( cf , cqBegin ) ; writer . addMutation ( m ) ; keyText = new Text ( interval . getAsKeyEnd ( ) ) ; KeyParts . appendUniqueness ( statement , keyText ) ; m = new Mutation ( keyText ) ; m . putDelete ( cf , cqEnd ) ; writer . addMutation ( m ) ; }
public static final String removeDataFolderPath ( String fullPath ) { File sdCard = Environment . getExternalStorageDirectory ( ) ; String dataFolderPath = sdCard . getAbsolutePath ( ) + STR_ + MainApp . getDataFolder ( ) + STR_ ; if ( fullPath . indexOf ( dataFolderPath ) == NUM_ ) { return fullPath . substring ( dataFolderPath . length ( ) ) ; } return fullPath ; }
protected Character isWFXMLChar ( String chardata ) { Character refInvalidChar ; if ( chardata == null || ( chardata . length ( ) == NUM_ ) ) { return null ; } char [ ] dataarray = chardata . toCharArray ( ) ; int datalength = dataarray . length ; if ( fIsXMLVersion11 ) { int i = NUM_ ; while ( i < datalength ) { if ( XML11Char . isXML11Invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - NUM_ ] ; if ( XMLChar . isHighSurrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if ( XMLChar . isLowSurrogate ( ch2 ) && XMLChar . isSupplemental ( XMLChar . supplemental ( ch , ch2 ) ) ) { continue ; } } refInvalidChar = new Character ( ch ) ; return refInvalidChar ; } } } else { int i = NUM_ ; while ( i < datalength ) { if ( XMLChar . isInvalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - NUM_ ] ; if ( XMLChar . isHighSurrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if ( XMLChar . isLowSurrogate ( ch2 ) && XMLChar . isSupplemental ( XMLChar . supplemental ( ch , ch2 ) ) ) { continue ; } } refInvalidChar = new Character ( ch ) ; return refInvalidChar ; } } } return null ; }
default CompletableFuture < Optional < R > > matchAsync ( final Executor executor , final T value ) { return CompletableFuture . supplyAsync ( null , executor ) ; }
public static void main ( String [ ] args ) throws FormatException { Debug . init ( ) ; if ( args . length == NUM_ ) { Debug . output ( STR_ ) ; System . exit ( NUM_ ) ; } for ( int argsi = NUM_ ; argsi < args . length ; argsi ++ ) { rootpath = args [ argsi ] ; LibrarySelectionTable lst = new LibrarySelectionTable ( rootpath ) ; if ( Debug . debugging ( STR_ ) ) { Debug . output ( STR_ + rootpath ) ; Debug . output ( STR_ + lst . getDatabaseName ( ) ) ; } println ( STR_ ) ; println ( STR_ + rootpath ) ; println ( STR_ + lst . getDatabaseDescription ( ) ) ; List < String > libraries = lst . getLibraryNames ( ) ; if ( Debug . debugging ( STR_ ) ) { print ( STR_ ) ; for ( String libraryName : libraries ) { print ( libraryName , STR_ ) ; } println ( ) ; println ( ) ; } for ( String libraryName : libraries ) { String prefix = lst . getDatabaseName ( ) + STR_ + libraryName ; println ( STR_ + prefix ) ; printLibrary ( prefix , lst . getCAT ( libraryName ) ) ; println ( ) ; } } }
private static String wildcardToRegex ( String pattern ) { return STR_ + StringUtils . replaceEach ( escapeRegexp ( pattern ) , new String [ ] { STR_ , STR_ } , new String [ ] { STR_ , STR_ } ) + STR_ ; }
protected void clearCache ( ) { if ( _cache != null ) { _cache . clear ( ) ; _cache = null ; } }
public String sqlAD_getCustomEntityTypes ( String vendorName , String catalogName , String schemaName ) { String tableName = STR_ ; ArrayList < String > columnNames = new ArrayList < String > ( ) ; columnNames . add ( STR_ ) ; ArrayList < String > aliasNames = new ArrayList < String > ( ) ; aliasNames . add ( STR_ ) ; ArrayList < String > conditions = new ArrayList < String > ( ) ; conditions . add ( STR_ ) ; ArrayList < String > sortColumns = new ArrayList < String > ( ) ; sortColumns . add ( STR_ ) ; return sql_select ( vendorName , catalogName , schemaName , tableName , null , columnNames , aliasNames , conditions , sortColumns , BOOL_ ) ; }
public void paintComponent ( Graphics g ) { int x = PADDING ; int y = PADDING ; g . drawImage ( picture , x , y , scaleW , scaleH , null ) ; x += scaleW + PADDING ; g . drawImage ( picture , x , y , x + scaleW , y + scaleH , NUM_ , NUM_ , picture . getWidth ( ) , picture . getHeight ( ) , null ) ; x += scaleW + PADDING ; Graphics2D g2d = ( Graphics2D ) g . create ( ) ; g2d . translate ( x , y ) ; g2d . scale ( SCALE_FACTOR , SCALE_FACTOR ) ; g2d . drawImage ( picture , NUM_ , NUM_ , null ) ; g2d . dispose ( ) ; x += scaleW + PADDING ; g2d = ( Graphics2D ) g . create ( ) ; AffineTransform at = new AffineTransform ( ) ; at . translate ( x , y ) ; at . scale ( SCALE_FACTOR , SCALE_FACTOR ) ; g2d . drawImage ( picture , at , null ) ; g2d . dispose ( ) ; x += scaleW + PADDING ; Image scaledImg = picture . getScaledInstance ( scaleW , scaleH , Image . SCALE_DEFAULT ) ; g . drawImage ( scaledImg , x , y , null ) ; }
public int hashCode ( ) { return idType . hashCode ( ) ; }
private static void backupAudioConfig ( ) { if ( null != mRestoreAudioConfigTimer ) { mRestoreAudioConfigTimer . cancel ( ) ; mRestoreAudioConfigTimer = null ; mRestoreAudioConfigTimerMask = null ; } else if ( null == mAudioMode ) { AudioManager audioManager = getAudioManager ( ) ; mAudioMode = audioManager . getMode ( ) ; mIsSpeakerOn = audioManager . isSpeakerphoneOn ( ) ; } }
public static String buildImdnDeliveryReport ( String msgId , ImdnDocument . DeliveryStatus status , long timestamp ) { String method ; switch ( status ) { case DISPLAYED : method = STR_ ; break ; case DELIVERED : method = STR_ ; break ; default : method = STR_ ; break ; } return STR_ + UTF8_STR + STR_ + CRLF + STR_ + CRLF + STR_ + msgId + STR_ + CRLF + STR_ + DateUtils . encodeDate ( timestamp ) + STR_ + CRLF + STR_ + method + STR_ + status + STR_ + method + STR_ + CRLF + STR_ ; }
private SpeedrunsLiveRequest ( ) { super ( URL ) ; }
public void clear ( ) { oredCriteria . clear ( ) ; orderByClause = null ; distinct = BOOL_ ; }
public void readDataFile ( String content ) throws DataFileException { if ( content == null || content . length ( ) <= NUM_ ) throw new IllegalStateException ( STR_ ) ; ByteArrayInputStream bis = new ByteArrayInputStream ( content . getBytes ( ) ) ; readDataFile ( bis , null ) ; }
public static String readUTF ( DataInput in ) throws IOException { return DataInputStream . readUTF ( in ) ; }
protected Object lazilyLoadDesktopProperty ( String name ) { if ( name . startsWith ( STR_ ) ) { return lazilyLoadGTKIcon ( name ) ; } return super . lazilyLoadDesktopProperty ( name ) ; }
public OAuthRsaSha1Signer ( String privateKeyString ) throws OAuthException { if ( privateKeyString == null ) { throw new OAuthException ( STR_ ) ; } else if ( privateKeyString . length ( ) == NUM_ ) { throw new OAuthException ( STR_ ) ; } try { setPrivateKey ( RsaSha1PrivateKeyHelper . getPrivateKey ( privateKeyString ) ) ; } catch ( Base64DecoderException e ) { throw new OAuthException ( STR_ , e ) ; } catch ( NoSuchAlgorithmException e ) { throw new OAuthException ( STR_ , e ) ; } catch ( InvalidKeySpecException e ) { throw new OAuthException ( STR_ , e ) ; } }
private Map < String , Volume > groupVolumesByReplicationGroup ( List < Volume > volumeList ) { Map < String , Volume > repGroupToVolumeMap = new HashMap < String , Volume > ( ) ; for ( Volume volume : volumeList ) { String repGroupName = volume . getReplicationGroupInstance ( ) ; if ( volume . isVPlexVolume ( _dbClient ) ) { Volume backedVol = VPlexUtil . getVPLEXBackendVolume ( volume , BOOL_ , _dbClient ) ; if ( backedVol != null ) { repGroupName = backedVol . getReplicationGroupInstance ( ) ; } } repGroupToVolumeMap . put ( repGroupName , volume ) ; } return repGroupToVolumeMap ; }
public DefaultFileFilter ( String extension , String description ) { ext = extension . toLowerCase ( ) ; desc = description ; }
public void appendCell ( boolean value ) { appendCell ( String . valueOf ( value ) ) ; }
public String name ( ) { return System . getProperty ( STR_ ) ; }
protected void addURL ( URL url ) { try { originalUrls . add ( url ) ; searchList . add ( createSearchURL ( url ) ) ; } catch ( MalformedURLException e ) { } }
public void initStructure ( ) throws Exception { int nAttribute = NUM_ ; for ( int iOrder = NUM_ ; iOrder < m_Instances . numAttributes ( ) ; iOrder ++ ) { if ( nAttribute == m_Instances . classIndex ( ) ) { nAttribute ++ ; } } m_ParentSets = new ParentSet [ m_Instances . numAttributes ( ) ] ; for ( int iAttribute = NUM_ ; iAttribute < m_Instances . numAttributes ( ) ; iAttribute ++ ) { m_ParentSets [ iAttribute ] = new ParentSet ( m_Instances . numAttributes ( ) ) ; } }
@ Override public synchronized CompletableFuture < Void > disconnect ( ) { closeFuture = new CompletableFuture < > ( ) ; if ( ! consumers . isEmpty ( ) ) { consumers . forEach ( null ) ; if ( havePendingRead && cursor . cancelPendingReadRequest ( ) ) { havePendingRead = BOOL_ ; } } else { closeFuture . complete ( null ) ; } return closeFuture ; }
public static String readAsciiLine ( InputStream in ) throws IOException { StringBuilder result = new StringBuilder ( NUM_ ) ; while ( BOOL_ ) { int c = in . read ( ) ; if ( c == - NUM_ ) { throw new EOFException ( ) ; } else if ( c == STR_ ) { break ; } result . append ( ( char ) c ) ; } int length = result . length ( ) ; if ( length > NUM_ && result . charAt ( length - NUM_ ) == STR_ ) { result . setLength ( length - NUM_ ) ; } return result . toString ( ) ; }
public static String readAsciiLine ( InputStream in ) throws IOException { StringBuilder result = new StringBuilder ( NUM_ ) ; while ( BOOL_ ) { int c = in . read ( ) ; if ( c == - NUM_ ) { throw new EOFException ( ) ; } else if ( c == STR_ ) { break ; } result . append ( ( char ) c ) ; } int length = result . length ( ) ; if ( length > NUM_ && result . charAt ( length - NUM_ ) == STR_ ) { result . setLength ( length - NUM_ ) ; } return result . toString ( ) ; }
protected boolean IPIsBroadcast ( int IPAddress ) { int inv_subnet_mask = ~ this . subnet_mask ; return ( ( IPAddress & inv_subnet_mask ) == inv_subnet_mask ) ; }
public void addCellAppearancesToWorkList ( DF_LatticeCell cell ) { for ( Enumeration < DF_Equation > e = getEquations ( ) ; e . hasMoreElements ( ) ; ) { DF_Equation eq = e . nextElement ( ) ; if ( eq . hasCell ( cell ) ) { addToWorkList ( eq ) ; } } }
public void remove ( ConstraintWidget widget ) { Element toUnselect = null ; for ( Element selection : mSelectedWidgets ) { if ( selection . widget == widget ) { toUnselect = selection ; break ; } } if ( toUnselect != null ) { mSelectedWidgets . remove ( toUnselect ) ; } selectionHasChanged ( ) ; }
public static long hexStringToLong ( final String hexString ) { Preconditions . checkNotNull ( hexString , STR_ ) ; Preconditions . checkArgument ( isHexString ( hexString ) , String . format ( STR_ , hexString ) ) ; if ( ( hexString . length ( ) == NUM_ ) && ( hexString . charAt ( NUM_ ) >= NUM_ ) ) { final String strAddr1 = hexString . substring ( NUM_ , hexString . length ( ) - NUM_ ) ; final String strAddr2 = hexString . substring ( hexString . length ( ) - NUM_ ) ; return ( Long . parseLong ( strAddr1 , NUM_ ) << NUM_ ) + Long . parseLong ( strAddr2 , NUM_ ) ; } return Long . parseLong ( hexString , NUM_ ) ; }
public static boolean containsFile ( @ NotNull SourceProvider provider , @ NotNull File file ) { Collection < File > srcDirectories = getAllSourceFolders ( provider ) ; if ( filesEqual ( provider . getManifestFile ( ) , file ) ) { return BOOL_ ; } for ( File container : srcDirectories ) { File parent = container . getParentFile ( ) ; if ( parent != null && parent . isDirectory ( ) && filesEqual ( parent , file ) ) { return BOOL_ ; } if ( ! container . exists ( ) ) { continue ; } if ( isAncestor ( container , file , BOOL_ ) ) { return BOOL_ ; } } return BOOL_ ; }
public static String checkNotEmpty ( String string , Object errorMessage ) { if ( ExoPlayerLibraryInfo . ASSERTIONS_ENABLED && TextUtils . isEmpty ( string ) ) { throw new IllegalArgumentException ( String . valueOf ( errorMessage ) ) ; } return string ; }
void runPostSearch ( int cntItems ) ;
private SSLEngineResult unwrap ( ) throws SSLException { if ( appBuffer == null ) { appBuffer = IoBuffer . allocate ( inNetBuffer . remaining ( ) ) ; } else { appBuffer . expand ( inNetBuffer . remaining ( ) ) ; } SSLEngineResult res ; Status status = null ; HandshakeStatus handshakeStatus = null ; do { res = sslEngine . unwrap ( inNetBuffer . buf ( ) , appBuffer . buf ( ) ) ; status = res . getStatus ( ) ; handshakeStatus = res . getHandshakeStatus ( ) ; if ( status == SSLEngineResult . Status . BUFFER_OVERFLOW ) { appBuffer . capacity ( appBuffer . capacity ( ) << NUM_ ) ; appBuffer . limit ( appBuffer . capacity ( ) ) ; continue ; } } while ( ( ( status == SSLEngineResult . Status . OK ) || ( status == SSLEngineResult . Status . BUFFER_OVERFLOW ) ) && ( ( handshakeStatus == SSLEngineResult . HandshakeStatus . NOT_HANDSHAKING ) || ( handshakeStatus == SSLEngineResult . HandshakeStatus . NEED_UNWRAP ) ) ) ; return res ; }
public Certificate requestCertificate ( byte [ ] csr ) throws AcmeException { return requestCertificate ( csr , null , null ) ; }
public void clear ( ) { mStrings . clear ( ) ; notifyDataSetChanged ( ) ; }
@ SuppressWarnings ( { STR_ } ) private static GridUriDeploymentFileProcessorResult processWithDescriptorFile ( GridUriDeploymentSpringDocument doc , File file , String uri , IgniteLogger log ) throws IgniteSpiException { ClassLoader clsLdr = GridUriDeploymentClassLoaderFactory . create ( U . gridClassLoader ( ) , file , log ) ; List < Class < ? extends ComputeTask < ? , ? > > > tasks = doc . getTasks ( clsLdr ) ; List < Class < ? extends ComputeTask < ? , ? > > > validTasks = null ; if ( ! F . isEmpty ( tasks ) ) { validTasks = new ArrayList < > ( ) ; for ( Class < ? extends ComputeTask < ? , ? > > task : tasks ) { if ( ! isAllowedTaskClass ( task ) ) { U . warn ( log , STR_ + STR_ + task + STR_ ) ; } else { if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + task . getName ( ) ) ; validTasks . add ( task ) ; } } } GridUriDeploymentFileProcessorResult res = new GridUriDeploymentFileProcessorResult ( ) ; res . setFile ( file ) ; res . setClassLoader ( clsLdr ) ; if ( ! F . isEmpty ( validTasks ) ) res . setTaskClasses ( validTasks ) ; else if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + file . getAbsolutePath ( ) + STR_ + U . hidePassword ( uri ) + STR_ ) ; return res ; }
private < T extends DataObject > boolean testSelections ( JClass jc , T dobj ) { List < JSelection > list = jc . getSelections ( ) ; for ( JSelection js : list ) { if ( testSelection ( jc , js , dobj ) == BOOL_ ) { return BOOL_ ; } } return BOOL_ ; }
public void truncate ( ) { calculateIdealPoint ( ) ; translateByIdealPoint ( ) ; List < List < Solution > > members = associateToReferencePoint ( this ) ; clear ( ) ; for ( int i = NUM_ ; i < members . size ( ) ; i ++ ) { List < Solution > associations = members . get ( i ) ; if ( associations . size ( ) > NUM_ ) { add ( select ( associations , i ) ) ; } } }
protected void onDownloading ( ) { if ( LogConfiguration . loggingIsEnabled ( ) ) { logger . log ( Level . INFO , messages . downloadingResources ( ) ) ; } updating = BOOL_ ; fireApplicationCacheEvent ( CacheEvent . onDownloading ) ; }
protected synchronized void addTransitionListener ( Hashtable < TxState , Hashtable < TxState , Set < EventListener > > > listeners , EventListener lstnr , TxState from , TxState to ) { Hashtable < TxState , Set < EventListener > > lstnrs = listeners . get ( from ) ; if ( lstnrs == null ) lstnrs = new Hashtable < TxState , Set < EventListener > > ( ) ; Set < EventListener > tolstnrs = lstnrs . get ( to ) ; if ( tolstnrs == null ) tolstnrs = new HashSet < EventListener > ( ) ; if ( ! tolstnrs . contains ( lstnr ) ) tolstnrs . add ( lstnr ) ; lstnrs . put ( to , tolstnrs ) ; listeners . put ( from , lstnrs ) ; }
public boolean hasExclusion ( ) { return ! mExcludedClasses . isEmpty ( ) || ! mExcludedTests . isEmpty ( ) ; }
private int ensureBaselineOnGrid ( ) { float baseline = getBaseline ( ) ; float gridAlign = baseline % FOUR_DIP ; if ( gridAlign != NUM_ ) { extraTopPadding = ( int ) ( FOUR_DIP - Math . ceil ( gridAlign ) ) ; } return extraTopPadding ; }
@ Override public void compute ( ) { Spliterator < P_IN > rs = spliterator , ls ; long sizeEstimate = rs . estimateSize ( ) ; long sizeThreshold = getTargetSize ( sizeEstimate ) ; boolean forkRight = BOOL_ ; @ SuppressWarnings ( STR_ ) K task = ( K ) this ; AtomicReference < R > sr = sharedResult ; R result ; while ( ( result = sr . get ( ) ) == null ) { if ( task . taskCanceled ( ) ) { result = task . getEmptyResult ( ) ; break ; } if ( sizeEstimate <= sizeThreshold || ( ls = rs . trySplit ( ) ) == null ) { result = task . doLeaf ( ) ; break ; } K leftChild , rightChild , taskToFork ; task . leftChild = leftChild = task . makeChild ( ls ) ; task . rightChild = rightChild = task . makeChild ( rs ) ; task . setPendingCount ( NUM_ ) ; if ( forkRight ) { forkRight = BOOL_ ; rs = ls ; task = leftChild ; taskToFork = rightChild ; } else { forkRight = BOOL_ ; task = rightChild ; taskToFork = leftChild ; } taskToFork . fork ( ) ; sizeEstimate = rs . estimateSize ( ) ; } task . setLocalResult ( result ) ; task . tryComplete ( ) ; }
public static Map < String , Object > createContentAssoc ( DispatchContext dctx , Map < String , ? extends Object > rcontext ) { Map < String , Object > context = UtilMisc . makeMapWritable ( rcontext ) ; context . put ( STR_ , STR_ ) ; List < String > targetOperationList = ContentWorker . prepTargetOperationList ( context , STR_ ) ; List < String > contentPurposeList = ContentWorker . prepContentPurposeList ( context ) ; context . put ( STR_ , targetOperationList ) ; context . put ( STR_ , contentPurposeList ) ; context . put ( STR_ , null ) ; Map < String , Object > result = null ; try { result = createContentAssocMethod ( dctx , context ) ; } catch ( GenericServiceException e ) { return ServiceUtil . returnError ( e . getMessage ( ) ) ; } catch ( GenericEntityException e2 ) { return ServiceUtil . returnError ( e2 . getMessage ( ) ) ; } catch ( Exception e3 ) { return ServiceUtil . returnError ( e3 . getMessage ( ) ) ; } return result ; }
public String formatWithLocale ( Locale locale , String ... args ) { return String . format ( locale , this . content , ( Object [ ] ) args ) ; }
private static < T extends AbstractBlockBase < T > > T addPathToLinearScanOrder ( T block , List < T > order , PriorityQueue < T > worklist , BitSet visitedBlocks ) { block . setLinearScanNumber ( order . size ( ) ) ; order . add ( block ) ; T mostLikelySuccessor = findAndMarkMostLikelySuccessor ( block , visitedBlocks ) ; enqueueSuccessors ( block , worklist , visitedBlocks ) ; if ( mostLikelySuccessor != null ) { if ( ! mostLikelySuccessor . isLoopHeader ( ) && mostLikelySuccessor . getPredecessorCount ( ) > NUM_ ) { double unscheduledSum = NUM_ ; for ( T pred : mostLikelySuccessor . getPredecessors ( ) ) { if ( pred . getLinearScanNumber ( ) == - NUM_ ) { unscheduledSum += pred . probability ( ) ; } } if ( unscheduledSum > block . probability ( ) / PENALTY_VERSUS_UNSCHEDULED ) { visitedBlocks . clear ( mostLikelySuccessor . getId ( ) ) ; return null ; } } return mostLikelySuccessor ; } return null ; }
private static Dimension createThumbDimension ( final BufferedImage image , final int maxWidth , final int maxHeight ) { Dimension dimension = new Dimension ( ) ; if ( image . getWidth ( ) >= image . getHeight ( ) ) { if ( image . getWidth ( ) >= maxWidth ) { dimension . width = maxWidth ; dimension . height = Math . round ( ( ( float ) maxWidth / image . getWidth ( ) ) . image . getHeight ( ) ) ; } else { dimension . height = image . getHeight ( ) ; dimension . width = image . getWidth ( ) ; } } else { if ( image . getHeight ( ) >= maxHeight ) { dimension . height = maxHeight ; dimension . width = Math . round ( ( ( ( float ) maxHeight / image . getHeight ( ) ) . image . getWidth ( ) ) ) ; } else { dimension . height = image . getHeight ( ) ; dimension . width = image . getWidth ( ) ; } } return dimension ; }
private boolean hasCurrentAccountChanged ( ) { Account account = AccountUtils . getCurrentOwnCloudAccount ( this ) ; if ( account == null ) { return BOOL_ ; } else { return ! mOriginalCurrentAccount . equals ( account . name ) ; } }
public int nextClearBit ( int index ) { int i = index > > NUM_ ; if ( i >= wlen ) return - NUM_ ; int subIndex = index & x3f ; long word = ~ bits . get ( i ) > > subIndex ; if ( word != NUM_ ) { return ( i << NUM_ ) + subIndex + Long . numberOfTrailingZeros ( word ) ; } while ( ++ i < wlen ) { word = ~ bits . get ( i ) ; if ( word != NUM_ ) { return ( i << NUM_ ) + Long . numberOfTrailingZeros ( word ) ; } } return - NUM_ ; }
private static synchronized void appendMessage ( Context c , final String msg ) { if ( msg . length ( ) == NUM_ ) return ; String out = msg ; boolean timestamp = PrefStore . isTimestamp ( c ) ; int maxLines = PrefStore . getMaxLines ( c ) ; int protocolSize = protocol . size ( ) ; if ( protocolSize > NUM_ && lastChar != STR_ ) { protocol . remove ( protocolSize - NUM_ ) ; out = lastLine + out ; } lastChar = out . charAt ( out . length ( ) - NUM_ ) ; String [ ] lines = out . split ( STR_ ) ; for ( int i = NUM_ , l = lines . length ; i < l ; i ++ ) { lastLine = lines [ i ] ; if ( timestamp ) protocol . add ( getTimeStamp ( ) + lastLine ) ; else protocol . add ( lastLine ) ; if ( protocolSize + i >= maxLines ) { protocol . remove ( NUM_ ) ; } } show ( ) ; if ( PrefStore . isLogger ( c ) ) write ( c , msg ) ; }
public Object [ ] importCells ( Object [ ] cells , double dx , double dy , Object target , Point location ) { if ( target == null && cells . length == NUM_ && location != null ) { target = getCellAt ( location . x , location . y ) ; if ( target instanceof mxICell && cells [ NUM_ ] instanceof mxICell ) { mxICell targetCell = ( mxICell ) target ; mxICell dropCell = ( mxICell ) cells [ NUM_ ] ; if ( targetCell . isVertex ( ) == dropCell . isVertex ( ) || targetCell . isEdge ( ) == dropCell . isEdge ( ) ) { mxIGraphModel model = graph . getModel ( ) ; model . setStyle ( target , model . getStyle ( cells [ NUM_ ] ) ) ; graph . setSelectionCell ( target ) ; return null ; } } } return super . importCells ( cells , dx , dy , target , location ) ; }
private void cancelSearch ( ) { entrantToSearch = null ; }
public void onPrepared ( MediaPlayer player ) { mState = State . PLAYING ; updateNotification ( String . format ( getString ( R . string . media_state_playing ) , mFile . getFileName ( ) ) ) ; if ( mMediaController != null ) { mMediaController . setEnabled ( BOOL_ ) ; } player . seekTo ( mStartPosition ) ; configAndStartMediaPlayer ( ) ; if ( ! mPlayOnPrepared ) { processPauseRequest ( ) ; } if ( mMediaController != null ) { mMediaController . updatePausePlay ( ) ; } }
public static ResultSet polar2Cartesian ( Double r , Double alpha ) { SimpleResultSet rs = new SimpleResultSet ( ) ; rs . addColumn ( STR_ , Types . DOUBLE , NUM_ , NUM_ ) ; rs . addColumn ( STR_ , Types . DOUBLE , NUM_ , NUM_ ) ; if ( r != null && alpha != null ) { double x = r . doubleValue ( ) . Math . cos ( alpha . doubleValue ( ) ) ; double y = r . doubleValue ( ) . Math . sin ( alpha . doubleValue ( ) ) ; rs . addRow ( x , y ) ; } return rs ; }
private List < View > addView ( View view , List < View > cache ) { if ( cache == null ) { cache = new LinkedList < View > ( ) ; } cache . add ( view ) ; return cache ; }
public void threadFail ( String reason ) { try { fail ( reason ) ; } catch ( AssertionFailedError t ) { threadRecordFailure ( t ) ; throw t ; } }
@ Override public void connectionLost ( Throwable cause ) { onDisconnect ( BOOL_ ) ; }
private boolean isTypedTimeFullyLegal ( ) { if ( mIs24HourMode ) { int [ ] values = getEnteredTime ( null ) ; return ( values [ NUM_ ] >= NUM_ && values [ NUM_ ] >= NUM_ && values [ NUM_ ] < NUM_ && values [ NUM_ ] >= NUM_ && values [ NUM_ ] < NUM_ ) ; } else { return ( mTypedTimes . contains ( getAmOrPmKeyCode ( AM ) ) || mTypedTimes . contains ( getAmOrPmKeyCode ( PM ) ) ) ; } }
public synchronized void clearAnnotations ( ) { mAnnotations . clear ( ) ; mStringXY . clear ( ) ; }
public Table sample ( double proportion ) { int tableCount = ( int ) Math . round ( rowCount ( ) . proportion ) ; Selection table1Selection = new BitmapBackedSelection ( ) ; int [ ] selectedRecords = generateUniformBitmap ( tableCount , rowCount ( ) ) ; for ( int selectedRecord : selectedRecords ) { table1Selection . add ( selectedRecord ) ; } return selectWhere ( table1Selection ) ; }
public void clear ( ) { oredCriteria . clear ( ) ; orderByClause = null ; distinct = BOOL_ ; }
public static MessageDigest newDigest ( ) { try { return MessageDigest . getInstance ( STR_ ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } }
public Container addChildAt ( int location , @ NonNull DisplayObject DisplayObject ) { if ( mFps != DEFAULT_FPS ) { DisplayObject . setUp ( mFps ) ; } mDisplayList . add ( location , DisplayObject ) ; return this ; }
private void add ( DimensionIndex index ) { flatten . add ( index ) ; lookup . put ( index . getAxis ( ) , index ) ; }
public static RecipePetals registerPetalRecipe ( ItemStack output , Object ... inputs ) { Preconditions . checkArgument ( inputs . length <= NUM_ ) ; RecipePetals recipe = new RecipePetals ( output , inputs ) ; petalRecipes . add ( recipe ) ; return recipe ; }
private void buildFirstLine ( LinePath path , Rect r ) { int [ ] range = new int [ ] { - r . left , - r . top , r . right , r . bottom } ; int max = - NUM_ ; int maxId = NUM_ ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { if ( range [ i ] > max ) { max = range [ i ] ; maxId = i ; } } switch ( maxId ) { case NUM_ : path . setEndPoint ( r . left , Utils . nextInt ( r . height ( ) ) + r . top ) ; break ; case NUM_ : path . setEndPoint ( Utils . nextInt ( r . width ( ) ) + r . left , r . top ) ; break ; case NUM_ : path . setEndPoint ( r . right , Utils . nextInt ( r . height ( ) ) + r . top ) ; break ; case NUM_ : path . setEndPoint ( Utils . nextInt ( r . width ( ) ) + r . left , r . bottom ) ; break ; } path . lineToEnd ( ) ; }
public static boolean isExtension ( String filename , String extension ) { if ( filename == null ) { return BOOL_ ; } if ( extension == null || extension . length ( ) == NUM_ ) { return indexOfExtension ( filename ) == - NUM_ ; } String fileExt = getExtension ( filename ) ; return fileExt . equals ( extension ) ; }
public void testValueOfDoubleNeg ( ) { double a = - NUM_ ; BigDecimal result = BigDecimal . valueOf ( a ) ; String res = STR_ ; int resScale = NUM_ ; assertEquals ( STR_ , res , result . toString ( ) ) ; assertEquals ( STR_ , resScale , result . scale ( ) ) ; }
public void testHugeTerm ( ) throws IOException { StringBuilder sb = new StringBuilder ( ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { sb . append ( STR_ ) ; } String input = sb . toString ( ) ; char token [ ] = new char [ NUM_ ] ; Arrays . fill ( token , STR_ ) ; String expectedToken = new String ( token ) ; String expected [ ] = { expectedToken , expectedToken , expectedToken , expectedToken , expectedToken , expectedToken , expectedToken , expectedToken , expectedToken , expectedToken } ; assertAnalyzesTo ( sentence , input , expected ) ; }
private String [ ] combineResultsFromMultipleReads ( String [ ] buffer , String [ ] lastRead ) { String [ ] t = new String [ buffer . length + lastRead . length ] ; System . arraycopy ( buffer , NUM_ , t , NUM_ , buffer . length ) ; System . arraycopy ( lastRead , NUM_ , t , buffer . length , lastRead . length ) ; return t ; }
public double calcDistance ( final double x , final double y ) { double distanceX ; double distanceY ; if ( this . minX <= x && x <= this . maxX ) { distanceX = NUM_ ; } else { distanceX = Math . min ( Math . abs ( this . minX - x ) , Math . abs ( this . maxX - x ) ) ; } if ( this . minY <= y && y <= this . maxY ) { distanceY = NUM_ ; } else { distanceY = Math . min ( Math . abs ( this . minY - y ) , Math . abs ( this . maxY - y ) ) ; } return Math . sqrt ( distanceX . distanceX + distanceY . distanceY ) ; }
@ Override public MatchesType marshal ( Set < Match > matches ) { Set < RPSBlastMatch > rpsBlastMatches = new LinkedHashSet < RPSBlastMatch > ( ) ; Set < Hmmer2Match > hmmer2Matches = new LinkedHashSet < Hmmer2Match > ( ) ; Set < Hmmer3Match > hmmer3Matches = new LinkedHashSet < Hmmer3Match > ( ) ; Set < SuperFamilyHmmer3Match > superFamilyHmmer3Matches = new LinkedHashSet < SuperFamilyHmmer3Match > ( ) ; Set < FingerPrintsMatch > fingerPrintsMatches = new LinkedHashSet < FingerPrintsMatch > ( ) ; Set < BlastProDomMatch > proDomMatches = new LinkedHashSet < BlastProDomMatch > ( ) ; Set < PatternScanMatch > patternScanMatches = new LinkedHashSet < PatternScanMatch > ( ) ; Set < ProfileScanMatch > profileScanMatches = new LinkedHashSet < ProfileScanMatch > ( ) ; Set < PhobiusMatch > phobiusMatches = new LinkedHashSet < PhobiusMatch > ( ) ; Set < CoilsMatch > coilsMatches = new LinkedHashSet < CoilsMatch > ( ) ; Set < PantherMatch > pantherMatches = new LinkedHashSet < PantherMatch > ( ) ; Set < SignalPMatch > signalPMatches = new LinkedHashSet < SignalPMatch > ( ) ; Set < TMHMMMatch > tmhmmPMatches = new LinkedHashSet < TMHMMMatch > ( ) ; for ( Match m : matches ) { if ( m instanceof RPSBlastMatch ) { rpsBlastMatches . add ( ( RPSBlastMatch ) m ) ; } else if ( m instanceof Hmmer2Match ) { hmmer2Matches . add ( ( Hmmer2Match ) m ) ; } else if ( m instanceof Hmmer3Match ) { hmmer3Matches . add ( ( Hmmer3Match ) m ) ; } else if ( m instanceof SuperFamilyHmmer3Match ) { superFamilyHmmer3Matches . add ( ( SuperFamilyHmmer3Match ) m ) ; } else if ( m instanceof FingerPrintsMatch ) { fingerPrintsMatches . add ( ( FingerPrintsMatch ) m ) ; } else if ( m instanceof BlastProDomMatch ) { proDomMatches . add ( ( BlastProDomMatch ) m ) ; } else if ( m instanceof PatternScanMatch ) { patternScanMatches . add ( ( PatternScanMatch ) m ) ; } else if ( m instanceof ProfileScanMatch ) { profileScanMatches . add ( ( ProfileScanMatch ) m ) ; } else if ( m instanceof PhobiusMatch ) { phobiusMatches . add ( ( PhobiusMatch ) m ) ; } else if ( m instanceof CoilsMatch ) { coilsMatches . add ( ( CoilsMatch ) m ) ; } else if ( m instanceof PantherMatch ) { pantherMatches . add ( ( PantherMatch ) m ) ; } else if ( m instanceof SignalPMatch ) { signalPMatches . add ( ( SignalPMatch ) m ) ; } else if ( m instanceof TMHMMMatch ) { tmhmmPMatches . add ( ( TMHMMMatch ) m ) ; } else { throw new IllegalArgumentException ( STR_ + m ) ; } } return new MatchesType ( rpsBlastMatches , hmmer2Matches , hmmer3Matches , superFamilyHmmer3Matches , fingerPrintsMatches , proDomMatches , patternScanMatches , profileScanMatches , phobiusMatches , coilsMatches , pantherMatches , signalPMatches , tmhmmPMatches ) ; }
public synchronized void ensureCapacity ( int minimumCapacity ) { if ( elementData . length < minimumCapacity ) { int next = ( capacityIncrement <= NUM_ ? elementData . length : capacityIncrement ) + elementData . length ; grow ( minimumCapacity > next ? minimumCapacity : next ) ; } }
public static void reverse ( final char [ ] buffer , final int start , final int len ) { if ( len < NUM_ ) return ; int end = ( start + len ) - NUM_ ; char frontHigh = buffer [ start ] ; char endLow = buffer [ end ] ; boolean allowFrontSur = BOOL_ , allowEndSur = BOOL_ ; final int mid = start + ( len > > NUM_ ) ; for ( int i = start ; i < mid ; ++ i , -- end ) { final char frontLow = buffer [ i + NUM_ ] ; final char endHigh = buffer [ end - NUM_ ] ; final boolean surAtFront = allowFrontSur && Character . isSurrogatePair ( frontHigh , frontLow ) ; if ( surAtFront && ( len < NUM_ ) ) { return ; } final boolean surAtEnd = allowEndSur && Character . isSurrogatePair ( endHigh , endLow ) ; allowFrontSur = allowEndSur = BOOL_ ; if ( surAtFront == surAtEnd ) { if ( surAtFront ) { buffer [ end ] = frontLow ; buffer [ -- end ] = frontHigh ; buffer [ i ] = endHigh ; buffer [ ++ i ] = endLow ; frontHigh = buffer [ i + NUM_ ] ; endLow = buffer [ end - NUM_ ] ; } else { buffer [ end ] = frontHigh ; buffer [ i ] = endLow ; frontHigh = frontLow ; endLow = endHigh ; } } else { if ( surAtFront ) { buffer [ end ] = frontLow ; buffer [ i ] = endLow ; endLow = endHigh ; allowFrontSur = BOOL_ ; } else { buffer [ end ] = frontHigh ; buffer [ i ] = endHigh ; frontHigh = frontLow ; allowEndSur = BOOL_ ; } } } if ( ( len & x01 ) == NUM_ && ! ( allowFrontSur && allowEndSur ) ) { buffer [ end ] = allowFrontSur ? endLow : frontHigh ; } }
@ Override public String toString ( ) { return String . format ( STR_ , ledgerId , entryId ) ; }
public void clear ( ) { oredCriteria . clear ( ) ; orderByClause = null ; distinct = BOOL_ ; }
public void trigger ( Date time ) { taskList . remove ( time ) ; }
private boolean checkTouchSlop ( View child , float dx , float dy ) { if ( child == null ) { return BOOL_ ; } final boolean checkHorizontal = mCallback . getViewHorizontalDragRange ( child ) > NUM_ ; final boolean checkVertical = mCallback . getViewVerticalDragRange ( child ) > NUM_ ; if ( checkHorizontal && checkVertical ) { return dx . dx + dy . dy > mTouchSlop . mTouchSlop ; } else if ( checkHorizontal ) { return Math . abs ( dx ) > mTouchSlop ; } else if ( checkVertical ) { return Math . abs ( dy ) > mTouchSlop ; } return BOOL_ ; }
Cipher ( CipherSpi cipherSpi , String transformation ) { this . spi = cipherSpi ; this . transformation = transformation ; this . cryptoPerm = CryptoAllPermission . INSTANCE ; this . lock = null ; }
public void testFlipBitPositiveOutside1 ( ) { byte aBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int number = NUM_ ; byte rBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger result = aNumber . flipBit ( number ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
private void writeObject ( ObjectOutputStream aOutputStream ) throws IOException { aOutputStream . defaultWriteObject ( ) ; }
@ Override public boolean isPanelEnabled ( ) { return multiOptionGroupEnabled ; }
public synchronized void add ( String name , long threadId ) { if ( mFinished ) { throw new IllegalStateException ( STR_ ) ; } mMarkers . add ( new Marker ( name , threadId , SystemClock . elapsedRealtime ( ) ) ) ; }
public static String toUnixNewline ( String input ) { return input . replace ( STR_ , STR_ ) ; }
private void outputIndentation ( ) { for ( int i = NUM_ ; i < m_indent ; i ++ ) { m_out . print ( m_basicIndent ) ; } }
protected Bucket < T > createBucket ( long bucketKey ) { return new Bucket < T > ( bucketKey ) ; }
public AbstractSiteMap parseSiteMap ( byte [ ] content , URL url ) throws UnknownFormatException , IOException { if ( url == null ) { return null ; } String filename = FilenameUtils . getName ( url . getPath ( ) ) ; String contentType = TIKA . detect ( content , filename ) ; return parseSiteMap ( contentType , content , url ) ; }
private void pullEvent ( ) { final int newScrollValue ; final int itemDimension ; final float initialMotionValue , lastMotionValue ; switch ( getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : initialMotionValue = mInitialMotionX ; lastMotionValue = mLastMotionX ; break ; case VERTICAL : default : initialMotionValue = mInitialMotionY ; lastMotionValue = mLastMotionY ; break ; } switch ( mCurrentMode ) { case PULL_FROM_END : newScrollValue = Math . round ( Math . max ( initialMotionValue - lastMotionValue , NUM_ ) / FRICTION ) ; itemDimension = getFooterSize ( ) ; break ; case PULL_FROM_START : default : newScrollValue = Math . round ( Math . min ( initialMotionValue - lastMotionValue , NUM_ ) / FRICTION ) ; itemDimension = getHeaderSize ( ) ; break ; } setHeaderScroll ( newScrollValue ) ; if ( newScrollValue != NUM_ && ! isRefreshing ( ) ) { float scale = Math . abs ( newScrollValue ) / ( float ) itemDimension ; switch ( mCurrentMode ) { case PULL_FROM_END : mFooterLayout . onPull ( scale ) ; break ; case PULL_FROM_START : default : mHeaderLayout . onPull ( scale ) ; break ; } if ( mState != State . PULL_TO_REFRESH && itemDimension >= Math . abs ( newScrollValue ) ) { setState ( State . PULL_TO_REFRESH ) ; } else if ( mState == State . PULL_TO_REFRESH && itemDimension < Math . abs ( newScrollValue ) ) { setState ( State . RELEASE_TO_REFRESH ) ; } } }
public ApplicationMetaData ( final Deserializer deserializer ) { this . appName = deserializer . readString ( STR_ ) ; this . version = deserializer . readString ( STR_ ) ; this . certificateSigner = deserializer . readOptionalString ( STR_ ) ; this . startTime = TimeInstant . readFrom ( deserializer , STR_ ) ; this . currentTime = TimeInstant . readFrom ( deserializer , STR_ ) ; this . timeProvider = null ; }
public static ConstraintsParameters loadPolicyData ( InputStream policyDataStream ) { if ( policyDataStream != null ) { return load ( policyDataStream ) ; } if ( ( defaultPolicyConstraintsLocation != null ) && ! defaultPolicyConstraintsLocation . isEmpty ( ) ) { return load ( defaultPolicyConstraintsLocation ) ; } return null ; }
public static void close ( OutputStream out ) { try { if ( out != null ) { out . close ( ) ; } } catch ( IOException ioE ) { } }
@ Override public boolean isCellEditable ( int row , int col ) { if ( isConnectedToDataSource ) { if ( col != FIELD_COLUMN_ID ) { return BOOL_ ; } else { return BOOL_ ; } } else { return BOOL_ ; } }
@ Override public boolean isFactoryForType ( Object type ) { return supportedTypes . contains ( type ) || super . isFactoryForType ( type ) ; }
private void saveSortedPomFile ( final String sortedXml ) { fileUtil . savePomFile ( sortedXml ) ; log . info ( STR_ + pomFile . getAbsolutePath ( ) ) ; }
private void appendStatements ( PolicyType policy , String prefix ) { List < Statement > appendStatements = newStatements ( policy , prefix ) ; for ( Statement statement : appendStatements ) { appendStatement ( statement ) ; } }
private void validateTOTPParameters ( ) throws AuthLoginException { StringBuilder errorMessages = new StringBuilder ( ) ; if ( StringUtils . isEmpty ( loginTimeAttrName ) ) { errorMessages . append ( STR_ ) ; } if ( clockDriftCheckEnabled && StringUtils . isEmpty ( observedClockDriftAttrName ) ) { errorMessages . append ( STR_ ) ; } if ( totpTimeStep <= NUM_ ) { errorMessages . append ( STR_ + totpTimeStep + STR_ ) ; } if ( totpStepsInWindow < NUM_ ) { errorMessages . append ( STR_ + totpStepsInWindow ) ; } if ( errorMessages . length ( ) > NUM_ ) { debug . error ( STR_ + errorMessages . toString ( ) ) ; throw new AuthLoginException ( amAuthOATH , STR_ , null ) ; } }
public static String removeUriFragment ( String url ) { if ( url == null || url . length ( ) == NUM_ ) { return null ; } String [ ] arr = url . split ( STR_ ) ; if ( arr . length == NUM_ ) { return arr [ NUM_ ] ; } else { return url ; } }
public static void writeReceiptsToFiles ( List < byte [ ] > printedReceipts , String prefix , File baseDir ) { try { int index = NUM_ ; for ( byte [ ] printedReceipt : printedReceipts ) { ByteArrayInputStream bIn = new ByteArrayInputStream ( printedReceipt ) ; File receiptFile = new File ( baseDir , prefix + STR_ + index + STR_ ) ; BufferedOutputStream bufferedOutputStream = new BufferedOutputStream ( new FileOutputStream ( receiptFile ) ) ; IOUtils . copy ( bIn , bufferedOutputStream ) ; bufferedOutputStream . close ( ) ; index ++ ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } }
public synchronized void renderDataForProjection ( Projection proj , java . awt . Graphics g ) { fireStatusUpdate ( LayerStatusEvent . FINISH_WORKING ) ; if ( proj == null ) { logger . info ( STR_ ) ; return ; } else { setTargetIndex ( proj . getScale ( ) ) ; Layer layer = getAppropriateLayer ( ) ; layer . renderDataForProjection ( proj , g ) ; } }
public void writeExif ( InputStream jpegStream , OutputStream exifOutStream ) throws IOException { if ( jpegStream == null || exifOutStream == null ) { throw new IllegalArgumentException ( NULL_ARGUMENT_STRING ) ; } OutputStream s = getExifWriterStream ( exifOutStream ) ; doExifStreamIO ( jpegStream , s ) ; s . flush ( ) ; }
private ContainerPanel createContainerPanel ( ) { ContainerPanel containerPanel = new ContainerPanel ( ) ; containerPanel . setAnimated ( BOOL_ ) ; containerPanel . setMinimumSize ( new Dimension ( NUM_ , NUM_ ) ) ; character = new Character ( ) ; containerPanel . addRepaintable ( character ) ; inventory = new SlotWindow ( STR_ , NUM_ , NUM_ ) ; inventory . setAcceptedTypes ( EntityMap . getClass ( STR_ , null , null ) ) ; inventory . setCloseable ( BOOL_ ) ; containerPanel . addRepaintable ( inventory ) ; keyring = new KeyRing ( ) ; keyring . setAcceptedTypes ( EntityMap . getClass ( STR_ , null , null ) ) ; containerPanel . addRepaintable ( keyring ) ; userContext . addFeatureChangeListener ( keyring ) ; spells = new Spells ( ) ; spells . setAcceptedTypes ( EntityMap . getClass ( STR_ , null , null ) ) ; containerPanel . addRepaintable ( spells ) ; userContext . addFeatureChangeListener ( spells ) ; return containerPanel ; }
public void copyFromGeometry3D ( Geometry3D geom ) { this . mNumIndices = geom . getNumIndices ( ) ; this . mNumVertices = geom . getNumVertices ( ) ; this . mVertexBufferInfo = geom . getVertexBufferInfo ( ) ; this . mIndexBufferInfo = geom . getIndexBufferInfo ( ) ; this . mTexCoordBufferInfo = geom . getTexCoordBufferInfo ( ) ; this . mOnlyShortBufferSupported = geom . areOnlyShortBuffersSupported ( ) ; if ( mColors == null ) this . mColorBufferInfo = geom . getColorBufferInfo ( ) ; this . mNormalBufferInfo = geom . getNormalBufferInfo ( ) ; this . mOriginalGeometry = geom ; this . mHasNormals = geom . hasNormals ( ) ; this . mHasTextureCoordinates = geom . hasTextureCoordinates ( ) ; }
@ Override public void addPropertyChangeListener ( PropertyChangeListener pcl ) { m_pcSupport . addPropertyChangeListener ( pcl ) ; }
public static Intent implicit2ExplicitIntent ( Context context , Intent implicitIntent ) { PackageManager pm = context . getPackageManager ( ) ; List < ResolveInfo > resolveInfo = pm . queryIntentServices ( implicitIntent , NUM_ ) ; if ( resolveInfo == null || resolveInfo . size ( ) != NUM_ ) { return null ; } ResolveInfo serviceInfo = resolveInfo . get ( NUM_ ) ; String packageName = serviceInfo . serviceInfo . packageName ; String className = serviceInfo . serviceInfo . name ; ComponentName component = new ComponentName ( packageName , className ) ; Intent explicitIntent = new Intent ( implicitIntent ) ; explicitIntent . setComponent ( component ) ; return explicitIntent ; }
private synchronized void garbageCollectPeer ( Peer peer ) { log . debug ( STR_ + peer ) ; mCurrentPeers . remove ( peer ) ; }
public void reset ( ) { synchronized ( this ) { queue . clear ( ) ; setBridgeMode ( - NUM_ ) ; } }
@ PostConstruct public void initApplication ( ) throws IOException { if ( env . getActiveProfiles ( ) . length == NUM_ ) { log . warn ( STR_ ) ; } else { log . info ( STR_ , Arrays . toString ( env . getActiveProfiles ( ) ) ) ; } }
private void indent ( ) { out . print ( currentIndention ) ; }
private void computeImplicitForwardDependencesUse ( Register r , DepGraphNode destNode ) { DepGraphNode sourceNode = getDepGraphNode ( r ) ; if ( sourceNode != null ) { for ( Enumeration < Register > e = GenericPhysicalDefUse . enumerate ( GenericPhysicalDefUse . getMaskTSPDefs ( ) , ir ) ; e . hasMoreElements ( ) ; ) { Register r2 = e . nextElement ( ) ; if ( r == r2 ) { sourceNode . insertOutEdge ( destNode , REG_MAY_DEF ) ; return ; } } sourceNode . insertOutEdge ( destNode , REG_TRUE ) ; } }
public String description ( ) { synchronized ( this ) { if ( messages == null ) { messages = ResourceBundle . getBundle ( STR_ ) ; } } return messages . getString ( STR_ ) ; }
Set findRemovableAciList ( Set aciList ) throws AMException , SSOException { Set resultSet = new HashSet ( ) ; if ( aciList == null ) { return resultSet ; } Iterator iter = aciList . iterator ( ) ; while ( iter . hasNext ( ) ) { String aci = ( String ) iter . next ( ) ; Set objs = dsServices . search ( token , AMStoreConnection . getAMSdkBaseDN ( ) , STR_ + AMSearchFilterManager . getGlobalSearchFilter ( AMObject . GROUP ) + STR_ + aci + STR_ , AMConstants . SCOPE_SUB ) ; if ( objs . size ( ) < NUM_ ) { resultSet . add ( aci ) ; } } return resultSet ; }
protected final void unregisterDataSource ( DataSource removed ) { unregisterDataSources ( Collections . singleton ( removed ) ) ; }
public String dump ( byte [ ] der ) throws Asn1Exception , IOException { try { ASN1Primitive derObject = ASN1Primitive . fromByteArray ( der ) ; if ( derObject . getEncoded ( ) . length < der . length ) { throw new Asn1Exception ( res . getString ( STR_ ) ) ; } return dump ( derObject ) ; } catch ( IOException ex ) { throw new Asn1Exception ( res . getString ( STR_ ) , ex ) ; } }
private static void assertChangeEvents ( Collection < PortChangeEvent > earlyEvents , Collection < PortChangeEvent > lateEvents , Collection < PortChangeEvent > anytimeEvents , Collection < PortChangeEvent > actualEvents ) { String inputDesc = String . format ( STR_ + STR_ , earlyEvents . toString ( ) , lateEvents . toString ( ) , anytimeEvents . toString ( ) , actualEvents . toString ( ) ) ; Collection < PortChangeEvent > early = new ArrayList < PortChangeEvent > ( earlyEvents ) ; Collection < PortChangeEvent > late = new ArrayList < PortChangeEvent > ( lateEvents ) ; Collection < PortChangeEvent > any = new ArrayList < PortChangeEvent > ( anytimeEvents ) ; for ( PortChangeEvent ev : early ) { assertFalse ( STR_ , late . contains ( ev ) ) ; assertFalse ( STR_ , any . contains ( ev ) ) ; } for ( PortChangeEvent ev : late ) { assertFalse ( STR_ , early . contains ( ev ) ) ; assertFalse ( STR_ , any . contains ( ev ) ) ; } for ( PortChangeEvent ev : any ) { assertFalse ( STR_ , early . contains ( ev ) ) ; assertFalse ( STR_ , late . contains ( ev ) ) ; } for ( PortChangeEvent a : actualEvents ) { if ( early . remove ( a ) ) { continue ; } if ( any . remove ( a ) ) { continue ; } if ( late . remove ( a ) ) { if ( ! early . isEmpty ( ) ) { fail ( a + STR_ + STR_ + inputDesc ) ; } else { continue ; } } fail ( a + STR_ + inputDesc ) ; } if ( ! early . isEmpty ( ) ) fail ( STR_ + early + STR_ + inputDesc ) ; if ( ! late . isEmpty ( ) ) fail ( STR_ + late + STR_ + inputDesc ) ; if ( ! any . isEmpty ( ) ) fail ( STR_ + any + STR_ + inputDesc ) ; }
public static Class needClass ( String property ) throws NoSuchPropertyException { String value = needProperty ( property ) ; Class c = null ; try { c = Class . forName ( value ) ; } catch ( ClassNotFoundException e ) { throw new NoSuchPropertyException ( STR_ + value + STR_ + property + STR_ ) ; } return c ; }
DependencySpec createModuleDependency ( ArtifactResult i , boolean forceExport ) { if ( JDK_MODULE_NAMES . contains ( i . name ( ) ) ) return JDK_DEPENDENCY ; final ModuleIdentifier mi = createModuleIdentifier ( i ) ; final boolean export = forceExport || ( i . importType ( ) == ImportType . EXPORT ) ; return DependencySpec . createModuleDependencySpec ( PathFilters . getMetaInfSubdirectoriesWithoutMetaInfFilter ( ) , ( export ? PathFilters . acceptAll ( ) : PathFilters . rejectAll ( ) ) , this , mi , i . importType ( ) == ImportType . OPTIONAL ) ; }
public void appendNodes ( NodeSet nodes ) { int nNodes = nodes . size ( ) ; if ( null == m_map ) { m_mapSize = nNodes + m_blocksize ; m_map = new Node [ m_mapSize ] ; } else if ( ( m_firstFree + nNodes ) >= m_mapSize ) { m_mapSize += ( nNodes + m_blocksize ) ; Node newMap [ ] = new Node [ m_mapSize ] ; System . arraycopy ( m_map , NUM_ , newMap , NUM_ , m_firstFree + nNodes ) ; m_map = newMap ; } System . arraycopy ( nodes . m_map , NUM_ , m_map , m_firstFree , nNodes ) ; m_firstFree += nNodes ; }
public void makeImmutable ( ) { if ( isMutable ) { isMutable = BOOL_ ; } }
private int readEpoch ( File epochFile ) { int epoch = - NUM_ ; if ( ! epochFile . exists ( ) ) { return epoch ; } try { Scanner scanner = new Scanner ( epochFile ) ; epoch = scanner . nextInt ( ) ; log . debug ( STR_ , epoch , epochFile . getName ( ) ) ; } catch ( IOException e ) { log . error ( STR_ , epochFile . getName ( ) , e ) ; } return epoch ; }
private int fastMatch ( String sha1 ) { Integer idx = _indexes . get ( sha1 ) ; if ( idx == null ) return - NUM_ ; else return idx . intValue ( ) ; }
public void or ( Criteria criteria ) { oredCriteria . add ( criteria ) ; }
public static void format ( String format , Object ... args ) { if ( ! isDisabled ( ) ) { print ( String . format ( format , args ) ) ; } }
public void concatenate ( SIPObjectList otherList ) { super . concatenate ( otherList ) ; }
@ Override @ Transactional protected void persist ( Collection < RawProtein < PrintsRawMatch > > filteredProteins , Map < String , Signature > modelIdToSignatureMap , Map < String , Protein > proteinIdToProteinMap ) { for ( RawProtein < PrintsRawMatch > rawProtein : filteredProteins ) { Protein protein = proteinIdToProteinMap . get ( rawProtein . getProteinIdentifier ( ) ) ; if ( protein == null ) { throw new IllegalStateException ( STR_ + STR_ + rawProtein . getProteinIdentifier ( ) + STR_ ) ; } Set < FingerPrintsMatch . FingerPrintsLocation > locations = null ; String currentSignatureAc = null ; Signature currentSignature = null ; PrintsRawMatch lastRawMatch = null ; final TreeSet < PrintsRawMatch > sortedMatches = new TreeSet < PrintsRawMatch > ( PRINTS_RAW_MATCH_COMPARATOR ) ; sortedMatches . addAll ( rawProtein . getMatches ( ) ) ; FingerPrintsMatch match = null ; for ( PrintsRawMatch rawMatch : sortedMatches ) { if ( rawMatch == null ) { continue ; } if ( currentSignatureAc == null || ! currentSignatureAc . equals ( rawMatch . getModelId ( ) ) ) { if ( currentSignatureAc != null ) { if ( match != null ) { entityManager . persist ( match ) ; } match = new FingerPrintsMatch ( currentSignature , lastRawMatch . getEvalue ( ) , lastRawMatch . getGraphscan ( ) , locations ) ; protein . addMatch ( match ) ; } locations = new HashSet < FingerPrintsMatch . FingerPrintsLocation > ( ) ; currentSignatureAc = rawMatch . getModelId ( ) ; currentSignature = modelIdToSignatureMap . get ( currentSignatureAc ) ; if ( currentSignature == null ) { throw new IllegalStateException ( STR_ + currentSignatureAc + STR_ ) ; } } locations . add ( new FingerPrintsMatch . FingerPrintsLocation ( rawMatch . getLocationStart ( ) , boundedLocationEnd ( protein , rawMatch ) , rawMatch . getPvalue ( ) , rawMatch . getScore ( ) , rawMatch . getMotifNumber ( ) ) ) ; lastRawMatch = rawMatch ; } if ( lastRawMatch != null ) { match = new FingerPrintsMatch ( currentSignature , lastRawMatch . getEvalue ( ) , lastRawMatch . getGraphscan ( ) , locations ) ; protein . addMatch ( match ) ; entityManager . persist ( match ) ; } } }
public Builder withKeyStorePassword ( String trustStorePassword ) { properties . setProperty ( NettyOptions . SSL_KEY_STORE_PASSWORD , Assert . notNull ( trustStorePassword , STR_ ) ) ; return this ; }
public static String suffix ( String string , String suffix ) { if ( string . endsWith ( suffix ) == BOOL_ ) { string += suffix ; } return string ; }
public Point2D ( double x , double y ) { if ( Double . isInfinite ( x ) || Double . isInfinite ( y ) ) throw new IllegalArgumentException ( STR_ ) ; if ( Double . isNaN ( x ) || Double . isNaN ( y ) ) throw new IllegalArgumentException ( STR_ ) ; if ( x == NUM_ ) this . x = NUM_ ; else this . x = x ; if ( y == NUM_ ) this . y = NUM_ ; else this . y = y ; }
public static void serverFailed ( String serviceName ) { if ( serviceName . startsWith ( validRemoteURL ) ) { serverFailed = BOOL_ ; } else { remoteStubs . remove ( serviceName ) ; } }
public RequestHandler ( PokemonGo api , OkHttpClient client ) { this . api = api ; this . client = client ; apiEndpoint = ApiSettings . API_ENDPOINT ; asyncHttpThread = new Thread ( this , STR_ ) ; asyncHttpThread . setDaemon ( BOOL_ ) ; asyncHttpThread . start ( ) ; }
public String toString ( ) { String s = STR_ ; Enumeration names = getAttributeNames ( ) ; while ( names . hasMoreElements ( ) ) { Object key = names . nextElement ( ) ; Object value = getAttribute ( key ) ; if ( value instanceof AttributeSet ) { s = s + key + STR_ ; } else { s = s + key + STR_ + value + STR_ ; } } return s ; }
public VNXeCommandResult removeLunsFromConsistencyGroup ( String cgId , List < String > luns ) { LunGroupModifyParam param = new LunGroupModifyParam ( ) ; List < LunAddParam > lunRemoves = new ArrayList < LunAddParam > ( ) ; for ( String lunId : luns ) { VNXeBase lun = new VNXeBase ( lunId ) ; LunAddParam lunAdd = new LunAddParam ( ) ; lunAdd . setLun ( lun ) ; lunRemoves . add ( lunAdd ) ; } param . setLunRemove ( lunRemoves ) ; ConsistencyGroupRequests req = new ConsistencyGroupRequests ( _khClient ) ; return req . modifyConsistencyGroupSync ( cgId , param ) ; }
private static boolean notInstanceAvailable ( ) { if ( sInstance == null ) { if ( ! sTrainingTaskFuture . isDone ( ) ) { try { sInstance = sTrainingTaskFuture . get ( ) ; return BOOL_ ; } catch ( InterruptedException | ExecutionException e ) { e . printStackTrace ( ) ; return BOOL_ ; } } else { return BOOL_ ; } } return BOOL_ ; }
public void readData ( DataInput din ) throws IOException { status = din . readUnsignedShort ( ) ; events = din . readUnsignedShort ( ) ; }
private boolean checkTouchSlop ( View child , float dx , float dy ) { if ( child == null ) { return BOOL_ ; } final boolean checkHorizontal = mCallback . getViewHorizontalDragRange ( child ) > NUM_ ; final boolean checkVertical = mCallback . getViewVerticalDragRange ( child ) > NUM_ ; if ( checkHorizontal && checkVertical ) { return dx . dx + dy . dy > mTouchSlop . mTouchSlop ; } else if ( checkHorizontal ) { return Math . abs ( dx ) > mTouchSlop ; } else if ( checkVertical ) { return Math . abs ( dy ) > mTouchSlop ; } return BOOL_ ; }
public void remove ( String identifier , ActiveConnectionRecord record ) { synchronized ( records ) { Set < ActiveConnectionRecord > connections = records . get ( identifier ) ; assert ( connections != null ) ; connections . remove ( record ) ; if ( connections . isEmpty ( ) ) records . remove ( identifier ) ; } }
private String buildMetroProintPlacementStatusString ( ) { StringBuffer placementStatusBuf = new StringBuffer ( ) ; if ( placementStatus != null ) { placementStatusBuf . append ( String . format ( STR_ ) ) ; placementStatusBuf . append ( placementStatus . toString ( dbClient ) ) ; } if ( secondaryPlacementStatus != null ) { placementStatusBuf . append ( String . format ( STR_ ) ) ; placementStatusBuf . append ( secondaryPlacementStatus . toString ( dbClient ) ) ; } return placementStatusBuf . toString ( ) ; }
private boolean hasSequence ( Subgraph graph ) { int oddDegreeCount = NUM_ ; for ( Iterator i = graph . nodeIterator ( ) ; i . hasNext ( ) ; ) { Node node = ( Node ) i . next ( ) ; if ( node . getDegree ( ) % NUM_ == NUM_ ) oddDegreeCount ++ ; } return oddDegreeCount <= NUM_ ; }
public void ensureAdditionalCapacity ( final int size ) { final int newCount = visible . position ( ) + size ; if ( newCount > visible . capacity ( ) ) { final ByteBuffer newByteBuffer = ByteBuffer . allocate ( Math . max ( visible . capacity ( ) << NUM_ , newCount ) ) ; visible . flip ( ) ; visible = newByteBuffer . put ( visible ) ; } }
public void forceReload ( File file ) { fFilesToReoad . add ( file ) ; }
private static long longMultiplyPowerTen ( long val , int n ) { if ( val == NUM_ || n <= NUM_ ) return val ; long [ ] tab = LONG_TEN_POWERS_TABLE ; long [ ] bounds = THRESHOLDS_TABLE ; if ( n < tab . length && n < bounds . length ) { long tenpower = tab [ n ] ; if ( val == NUM_ ) return tenpower ; if ( Math . abs ( val ) <= bounds [ n ] ) return val . tenpower ; } return INFLATED ; }
public static int wildCompare ( String searchIn , String searchForWildcard ) { if ( ( searchIn == null ) || ( searchForWildcard == null ) ) { return WILD_COMPARE_NO_MATCH ; } if ( searchForWildcard . equals ( STR_ ) ) { return WILD_COMPARE_MATCH_WITH_WILD ; } int result = WILD_COMPARE_NO_MATCH ; char wildcardMany = STR_ ; char wildcardOne = STR_ ; char wildcardEscape = STR_ ; int searchForPos = NUM_ ; int searchForEnd = searchForWildcard . length ( ) ; int searchInPos = NUM_ ; int searchInEnd = searchIn . length ( ) ; while ( searchForPos != searchForEnd ) { char wildstrChar = searchForWildcard . charAt ( searchForPos ) ; while ( ( searchForWildcard . charAt ( searchForPos ) != wildcardMany ) && ( wildstrChar != wildcardOne ) ) { if ( ( searchForWildcard . charAt ( searchForPos ) == wildcardEscape ) && ( ( searchForPos + NUM_ ) != searchForEnd ) ) { searchForPos ++ ; } if ( ( searchInPos == searchInEnd ) || ( Character . toUpperCase ( searchForWildcard . charAt ( searchForPos ++ ) ) != Character . toUpperCase ( searchIn . charAt ( searchInPos ++ ) ) ) ) { return WILD_COMPARE_MATCH_WITH_WILD ; } if ( searchForPos == searchForEnd ) { return ( ( searchInPos != searchInEnd ) ? WILD_COMPARE_MATCH_WITH_WILD : WILD_COMPARE_MATCH_NO_WILD ) ; } result = WILD_COMPARE_MATCH_WITH_WILD ; } if ( searchForWildcard . charAt ( searchForPos ) == wildcardOne ) { do { if ( searchInPos == searchInEnd ) { return ( result ) ; } searchInPos ++ ; } while ( ( ++ searchForPos < searchForEnd ) && ( searchForWildcard . charAt ( searchForPos ) == wildcardOne ) ) ; if ( searchForPos == searchForEnd ) { break ; } } if ( searchForWildcard . charAt ( searchForPos ) == wildcardMany ) { char cmp ; searchForPos ++ ; for ( ; searchForPos != searchForEnd ; searchForPos ++ ) { if ( searchForWildcard . charAt ( searchForPos ) == wildcardMany ) { continue ; } if ( searchForWildcard . charAt ( searchForPos ) == wildcardOne ) { if ( searchInPos == searchInEnd ) { return ( WILD_COMPARE_NO_MATCH ) ; } searchInPos ++ ; continue ; } break ; } if ( searchForPos == searchForEnd ) { return WILD_COMPARE_MATCH_NO_WILD ; } if ( searchInPos == searchInEnd ) { return WILD_COMPARE_NO_MATCH ; } if ( ( ( cmp = searchForWildcard . charAt ( searchForPos ) ) == wildcardEscape ) && ( ( searchForPos + NUM_ ) != searchForEnd ) ) { cmp = searchForWildcard . charAt ( ++ searchForPos ) ; } searchForPos ++ ; do { while ( ( searchInPos != searchInEnd ) && ( Character . toUpperCase ( searchIn . charAt ( searchInPos ) ) != Character . toUpperCase ( cmp ) ) ) { searchInPos ++ ; } if ( searchInPos ++ == searchInEnd ) { return WILD_COMPARE_NO_MATCH ; } { int tmp = wildCompare ( searchIn , searchForWildcard ) ; if ( tmp <= NUM_ ) { return ( tmp ) ; } } } while ( ( searchInPos != searchInEnd ) && ( searchForWildcard . charAt ( NUM_ ) != wildcardMany ) ) ; return WILD_COMPARE_NO_MATCH ; } } return ( ( searchInPos != searchInEnd ) ? WILD_COMPARE_MATCH_WITH_WILD : WILD_COMPARE_MATCH_NO_WILD ) ; }
boolean compareMethods ( @ Nullable Method a , @ Nullable Method b ) { if ( ( a == null ) != ( b == null ) ) { return BOOL_ ; } if ( a != null && b != null ) { if ( ! a . equals ( b ) ) { return BOOL_ ; } } return BOOL_ ; }
public Object remove ( String markername ) { return prefixLibrarian . remove ( markername ) ; }
String formatLastModified ( String fileName ) { synchronized ( dateFormat ) { return dateFormat . format ( new Date ( FileUtils . lastModified ( fileName ) ) ) ; } }
public TrueTypeFont ( String platname , Object nativeNames , int fIndex , boolean javaRasterizer , boolean useFilePool ) throws FontFormatException { super ( platname , nativeNames ) ; useJavaRasterizer = javaRasterizer ; fontRank = Font2D . TTF_RANK ; try { verify ( useFilePool ) ; init ( fIndex ) ; if ( ! useFilePool ) { close ( ) ; } } catch ( Throwable t ) { close ( ) ; if ( t instanceof FontFormatException ) { throw ( FontFormatException ) t ; } else { throw new FontFormatException ( STR_ ) ; } } Disposer . addObjectRecord ( this , disposerRecord ) ; }
public void calcMinMax ( ) { if ( mDataSets == null ) return ; mYMax = - Float . MAX_VALUE ; mYMin = Float . MAX_VALUE ; mXMax = - Float . MAX_VALUE ; mXMin = Float . MAX_VALUE ; for ( int i = NUM_ , size = mDataSets . size ( ) ; i < size ; i ++ ) { T set = mDataSets . get ( i ) ; calcMinMax ( set ) ; } mLeftAxisMax = - Float . MAX_VALUE ; mLeftAxisMin = Float . MAX_VALUE ; mRightAxisMax = - Float . MAX_VALUE ; mRightAxisMin = Float . MAX_VALUE ; T firstLeft = getFirstLeft ( mDataSets ) ; if ( firstLeft != null ) { mLeftAxisMax = firstLeft . getYMax ( ) ; mLeftAxisMin = firstLeft . getYMin ( ) ; for ( int i = NUM_ ; i < mDataSets . size ( ) ; i ++ ) { T dataSet = mDataSets . get ( i ) ; if ( dataSet . getAxisDependency ( ) == AxisDependency . LEFT ) { if ( dataSet . getYMin ( ) < mLeftAxisMin ) mLeftAxisMin = dataSet . getYMin ( ) ; if ( dataSet . getYMax ( ) > mLeftAxisMax ) mLeftAxisMax = dataSet . getYMax ( ) ; } } } T firstRight = getFirstRight ( mDataSets ) ; if ( firstRight != null ) { mRightAxisMax = firstRight . getYMax ( ) ; mRightAxisMin = firstRight . getYMin ( ) ; for ( int i = NUM_ ; i < mDataSets . size ( ) ; i ++ ) { T dataSet = mDataSets . get ( i ) ; if ( dataSet . getAxisDependency ( ) == AxisDependency . RIGHT ) { if ( dataSet . getYMin ( ) < mRightAxisMin ) mRightAxisMin = dataSet . getYMin ( ) ; if ( dataSet . getYMax ( ) > mRightAxisMax ) mRightAxisMax = dataSet . getYMax ( ) ; } } } }
public LogarithmicAxis ( String label ) { super ( label ) ; setupNumberFmtObj ( ) ; }
protected final boolean has_cycle_recu ( Set < BrdItem > p_visited_items , BrdItem p_search_item , BrdItem p_come_from_item , boolean p_ignore_areas ) { if ( p_ignore_areas && ( this instanceof BrdAreaConduction ) ) return BOOL_ ; Collection < BrdItem > contact_list = get_normal_contacts ( ) ; if ( contact_list == null ) return BOOL_ ; for ( BrdItem curr_contact : contact_list ) { if ( curr_contact == p_come_from_item ) continue ; if ( curr_contact == p_search_item ) return BOOL_ ; if ( ! p_visited_items . add ( curr_contact ) ) continue ; if ( curr_contact . has_cycle_recu ( p_visited_items , p_search_item , this , p_ignore_areas ) ) return BOOL_ ; } return BOOL_ ; }
public static boolean isCallingClassReflectionAvailable ( ) { return BOOL_ ; }
@ Override public void addTableModelListener ( TableModelListener l ) { m_Listeners . add ( l ) ; }
public Process exec ( String [ ] taintedCommand , String [ ] taintedEnvironment , File workingDirectory , boolean redirectErrorStream ) throws IOException { if ( taintedCommand == null ) { throw new NullPointerException ( STR_ ) ; } if ( taintedCommand . length == NUM_ ) { throw new IndexOutOfBoundsException ( STR_ ) ; } String [ ] command = taintedCommand . clone ( ) ; String [ ] environment = taintedEnvironment != null ? taintedEnvironment . clone ( ) : null ; for ( int i = NUM_ ; i < command . length ; i ++ ) { if ( command [ i ] == null ) { throw new NullPointerException ( STR_ + i + STR_ ) ; } } if ( environment != null ) { for ( int i = NUM_ ; i < environment . length ; i ++ ) { if ( environment [ i ] == null ) { throw new NullPointerException ( STR_ + i + STR_ ) ; } } } FileDescriptor in = new FileDescriptor ( ) ; FileDescriptor out = new FileDescriptor ( ) ; FileDescriptor err = new FileDescriptor ( ) ; String workingPath = ( workingDirectory == null ) ? null : workingDirectory . getPath ( ) ; synchronized ( processReferences ) { int pid ; try { pid = exec ( command , environment , workingPath , in , out , err , redirectErrorStream ) ; } catch ( IOException e ) { IOException wrapper = new IOException ( STR_ + STR_ + Arrays . toString ( command ) + STR_ + workingDirectory + STR_ + Arrays . toString ( environment ) ) ; wrapper . initCause ( e ) ; throw wrapper ; } ProcessImpl process = new ProcessImpl ( pid , in , out , err ) ; ProcessReference processReference = new ProcessReference ( process , referenceQueue ) ; processReferences . put ( pid , processReference ) ; processReferences . notifyAll ( ) ; return process ; } }
private static String [ ] formGrams ( String text , int ng ) { int len = text . length ( ) ; String [ ] res = new String [ len - ng + NUM_ ] ; for ( int i = NUM_ ; i < len - ng + NUM_ ; i ++ ) { res [ i ] = text . substring ( i , i + ng ) ; } return res ; }
public void loadSettingsFromJson ( ) { synchronized ( LOCK ) { loadSettingsFromJson ( defaultFile ) ; for ( String fileName : files ) { loadSettingsFromJson ( fileName ) ; } } }
public void testFlush ( ) throws Exception { byte [ ] data = new byte [ ] { - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; TestOutputStream tos = new TestOutputStream ( ) ; CipherOutputStream cos = new CipherOutputStream ( tos ) { } ; cos . write ( data ) ; cos . flush ( ) ; byte [ ] result = tos . toByteArray ( ) ; if ( ! Arrays . equals ( result , data ) ) { fail ( STR_ ) ; } }
public void loadTrainIcons ( ) { for ( Train train : getTrainsByIdList ( ) ) { train . loadTrainIcon ( ) ; } }
public final String translate ( final CharSequence input ) { if ( input == null ) { return null ; } try { final StringWriter writer = new StringWriter ( input . length ( ) . NUM_ ) ; translate ( input , writer ) ; return writer . toString ( ) ; } catch ( final IOException ioe ) { throw new RuntimeException ( ioe ) ; } }
public void insertReverseSorted ( final int idx , final double distance ) { int i = NUM_ ; for ( ListNode temp : m_List ) { if ( temp . distance < distance ) { break ; } i ++ ; } m_List . add ( i , new ListNode ( idx , distance ) ) ; }
public double normalDistance ( final double x , final double y , final double z , final Membership ... bounds ) { final double dist = evaluate ( x , y , z ) ; final double perpX = x - dist . this . x ; final double perpY = y - dist . this . y ; final double perpZ = z - dist . this . z ; if ( ! meetsAllBounds ( perpX , perpY , perpZ , bounds ) ) { return Double . POSITIVE_INFINITY ; } return Math . abs ( dist ) ; }
public void testBAandBCbrokerNetworkWithSelectorsSendFirst ( ) throws Exception { bridgeBrokers ( STR_ , STR_ , BOOL_ , NUM_ , BOOL_ ) ; bridgeBrokers ( STR_ , STR_ , BOOL_ , NUM_ , BOOL_ ) ; startAllBrokers ( ) ; waitForBridgeFormation ( ) ; Destination dest = createDestination ( STR_ , BOOL_ ) ; HashMap < String , Object > props = new HashMap < > ( ) ; props . put ( STR_ , STR_ ) ; sendMessages ( STR_ , dest , MESSAGE_COUNT , props ) ; props . clear ( ) ; props . put ( STR_ , STR_ ) ; sendMessages ( STR_ , dest , MESSAGE_COUNT , props ) ; MessageConsumer clientA = createConsumer ( STR_ , dest , STR_ ) ; MessageConsumer clientC = createConsumer ( STR_ , dest , STR_ ) ; Thread . sleep ( NUM_ ) ; MessageIdList msgsA = getConsumerMessages ( STR_ , clientA ) ; MessageIdList msgsC = getConsumerMessages ( STR_ , clientC ) ; assertEquals ( MESSAGE_COUNT , msgsA . getMessageCount ( ) ) ; assertEquals ( MESSAGE_COUNT , msgsC . getMessageCount ( ) ) ; }
private void generateVectorDrawableResult ( VectorDrawable vector , String nextVectorName , boolean isLast , boolean isFirst ) throws IOException { CustomLogger . logError ( STR_ + vector . getFileName ( ) + STR_ + isLast ) ; if ( ! vectorAlreadyDefined . contains ( vector . getFileName ( ) ) ) { currentVectorFileName = vector . getFileName ( ) ; CustomLogger . logError ( STR_ + currentVectorFileName ) ; File vectorFile = new File ( drawableFolder , currentVectorFileName + STR_ ) ; BufferedWriter vectorBW = createIt ( vectorFile ) ; CustomLogger . log ( STR_ + vectorFile . getAbsolutePath ( ) ) ; generateVectorDrawable ( vector , vectorBW , isLast ) ; vectorAlreadyDefined . add ( vector . getFileName ( ) ) ; vectorBW . flush ( ) ; vectorBW . close ( ) ; } if ( ! isLast ) { File animatedVectorFile = new File ( drawableFolder , animatedVector . replace ( STR_ , currentVectorFileName ) ) ; BufferedWriter animatedVectorBW = createIt ( animatedVectorFile ) ; CustomLogger . log ( STR_ + animatedVectorFile . getAbsolutePath ( ) ) ; CustomLogger . logError ( STR_ + animatedVectorFile . getAbsolutePath ( ) + STR_ + nextVectorName ) ; generateAnimatedVector ( vector , animatedVectorBW , nextVectorName , BOOL_ ) ; generateAnimatorSet ( vector , BOOL_ ) ; animatedVectorBW . flush ( ) ; animatedVectorBW . close ( ) ; } if ( ! isLast ) { File animatedVectorFile = new File ( drawableFolder , animatedVector . replace ( STR_ , currentVectorFileName + reverse ) ) ; BufferedWriter animatedVectorBW = createIt ( animatedVectorFile ) ; CustomLogger . log ( STR_ + animatedVectorFile . getAbsolutePath ( ) ) ; CustomLogger . logError ( STR_ + animatedVectorFile . getAbsolutePath ( ) + STR_ + nextVectorName ) ; generateAnimatedVector ( vector , animatedVectorBW , nextVectorName , BOOL_ ) ; generateAnimatorSet ( vector , BOOL_ ) ; animatedVectorBW . flush ( ) ; animatedVectorBW . close ( ) ; } }
public void access ( ) { lastAccessedTime = System . currentTimeMillis ( ) ; }
public void writeToObject ( Object object ) { try { Method method = BeanUtils . getWriteMethod ( object . getClass ( ) , getName ( ) , getType ( ) ) ; if ( method != null ) { method . invoke ( object , new Object [ ] { getValue ( ) } ) ; } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
private HttpURLConnection doHTTPPostRequest ( String location , String clientSessionId , Map < String , String > metadata , String postBody ) throws CommunicationException { OutputStreamWriter writer = null ; try { URL url = new URL ( location ) ; HttpURLConnection connection = ( HttpURLConnection ) url . openConnection ( ) ; connection . setRequestMethod ( STR_ ) ; connection . addRequestProperty ( STR_ , STR_ ) ; if ( clientSessionId != null ) { connection . addRequestProperty ( HTTP_HEADER_SESSION_ID , STR_ + clientSessionId ) ; } if ( metadata != null ) { connection . addRequestProperty ( HTTP_HEADER_METADATA , GcUtil . getBase64EncodedMetadata ( metadata ) ) ; } if ( Constants . ENABLE_REQUEST_LOGGING ) { logRequest ( connection , postBody ) ; } connection . setDoOutput ( BOOL_ ) ; writer = new OutputStreamWriter ( connection . getOutputStream ( ) , STR_ ) ; writer . write ( postBody ) ; writer . flush ( ) ; if ( connection . getResponseCode ( ) != NUM_ ) { throw new CommunicationException ( STR_ + connection . getResponseCode ( ) ) ; } return connection ; } catch ( MalformedURLException e ) { Log . e ( TAG , STR_ + location ) ; throw new CommunicationException ( STR_ + location ) ; } catch ( IOException e ) { Log . e ( TAG , STR_ + e . getMessage ( ) ) ; throw new CommunicationException ( STR_ + e . getMessage ( ) , e ) ; } finally { if ( writer != null ) { try { writer . close ( ) ; } catch ( IOException e ) { Log . i ( TAG , STR_ + e . getMessage ( ) ) ; } } } }
void ioMessage ( Throwable ex ) { log . printLines ( PrefixKind . JAVAC , STR_ ) ; ex . printStackTrace ( log . getWriter ( WriterKind . NOTICE ) ) ; }
ObjectAnimator animateBoundScroll ( ) { float curScroll = getStackScroll ( ) ; float newScroll = getBoundedStackScroll ( curScroll ) ; if ( Float . compare ( newScroll , curScroll ) != NUM_ ) { animateScroll ( curScroll , newScroll , null ) ; } return mScrollAnimator ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; String substring ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; nameNode = elementList . item ( NUM_ ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; substring = child . substringData ( NUM_ , NUM_ ) ; assertEquals ( STR_ , STR_ , substring ) ; }
public static Collection < UUID > nodeIds ( @ Nullable Collection < ? extends ClusterNode > nodes ) { if ( nodes == null || nodes . isEmpty ( ) ) return Collections . emptyList ( ) ; return F . viewReadOnly ( nodes , node2id ( ) ) ; }
public static InputStream toInputStream ( final CharSequence input , final Charset encoding ) { return IOUtils . toInputStream ( input . toString ( ) , encoding ) ; }
public static boolean matchesXMLString ( char [ ] buf , int off , int end , String str ) { int len = str . length ( ) ; if ( len != end - off ) return BOOL_ ; for ( int i = NUM_ ; i < len ; off += NUM_ , i ++ ) { if ( buf [ off ] != str . charAt ( i ) ) return BOOL_ ; } return BOOL_ ; }
public double r ( ) { return Math . sqrt ( x . x + y . y ) ; }
public void sign ( KeyPair keypair ) throws IOException { if ( namelist . isEmpty ( ) ) { throw new IllegalStateException ( STR_ ) ; } if ( keypair == null ) { throw new IllegalArgumentException ( STR_ ) ; } try { GeneralName [ ] gns = new GeneralName [ namelist . size ( ) ] ; for ( int ix = NUM_ ; ix < namelist . size ( ) ; ix ++ ) { gns [ ix ] = new GeneralName ( GeneralName . dNSName , namelist . get ( ix ) ) ; } GeneralNames subjectAltName = new GeneralNames ( gns ) ; PKCS10CertificationRequestBuilder p10Builder = new JcaPKCS10CertificationRequestBuilder ( namebuilder . build ( ) , keypair . getPublic ( ) ) ; ExtensionsGenerator extensionsGenerator = new ExtensionsGenerator ( ) ; extensionsGenerator . addExtension ( Extension . subjectAlternativeName , BOOL_ , subjectAltName ) ; p10Builder . addAttribute ( PKCSObjectIdentifiers . pkcs_9_at_extensionRequest , extensionsGenerator . generate ( ) ) ; PrivateKey pk = keypair . getPrivate ( ) ; JcaContentSignerBuilder csBuilder = new JcaContentSignerBuilder ( pk instanceof ECKey ? EC_SIGNATURE_ALG : SIGNATURE_ALG ) ; ContentSigner signer = csBuilder . build ( pk ) ; csr = p10Builder . build ( signer ) ; } catch ( OperatorCreationException ex ) { throw new IOException ( STR_ , ex ) ; } }
void removeEmptyRows ( final List list ) { for ( final Iterator < ReceiptDetailInfo > detail = list . iterator ( ) ; detail . hasNext ( ) ; ) if ( detail . next ( ) == null ) detail . remove ( ) ; }
private void add ( String text , Text textNode ) { int startIndex = builder . length ( ) ; builder . append ( text ) ; int endIndex = builder . length ( ) ; textRuns . add ( new TextRun ( textNode , startIndex , endIndex ) ) ; }
public DNetscapeBaseUrl ( JDialog parent ) { super ( parent ) ; setTitle ( res . getString ( STR_ ) ) ; initComponents ( ) ; }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; init ( getName ( ) ) ; }
public void appendRow ( RowSpec rowSpec ) { checkNotNull ( rowSpec , STR_ ) ; rowSpecs . add ( rowSpec ) ; }
public static < T > ReactiveSeq < T > fromPublisher ( final Publisher < ? extends T > publisher ) { Objects . requireNonNull ( publisher ) ; final SeqSubscriber < T > sub = SeqSubscriber . subscriber ( ) ; publisher . subscribe ( sub ) ; return sub . stream ( ) ; }
public void multiplyAllValuesBy ( final double multiplyBy , final int RoundType ) { for ( final T t : keySet ( ) ) { double val = m_values . get ( t ) ; switch ( RoundType ) { case NUM_ : val = Math . floor ( val . multiplyBy ) ; break ; case NUM_ : val = Math . round ( val . multiplyBy ) ; break ; case NUM_ : val = Math . ceil ( val . multiplyBy ) ; break ; default : val = val . multiplyBy ; break ; } put ( t , ( int ) val ) ; } }
public void onTabsAllClosing ( long time , boolean incognito ) { }
public final TestSubscriber < T > await ( Duration timeout ) { if ( cdl . getCount ( ) == NUM_ ) { return this ; } try { if ( ! cdl . await ( timeout . toMillis ( ) , TimeUnit . MILLISECONDS ) ) { throw new AssertionError ( STR_ ) ; } return this ; } catch ( InterruptedException ex ) { throw new AssertionError ( STR_ , ex ) ; } }
protected void paintContentBorderBottomEdge ( Graphics g , int tabPlacement , int selectedIndex , int x , int y , int w , int h ) { boolean leftToRight = CompiereUtils . isLeftToRight ( tabPane ) ; int bottom = y + h - NUM_ ; int right = x + w - NUM_ ; Rectangle selRect = selectedIndex < NUM_ ? null : getTabBounds ( selectedIndex , calcRect ) ; g . setColor ( shadow ) ; if ( tabPlacement != BOTTOM || selectedIndex < NUM_ || ( selRect . x < x || selRect . x > x + w ) ) { g . setColor ( darkShadow ) ; g . drawLine ( x , y + h - NUM_ , x + w - NUM_ , y + h - NUM_ ) ; } else { boolean lastInRun = isLastInRun ( selectedIndex ) ; g . setColor ( darkShadow ) ; if ( leftToRight || lastInRun ) g . drawLine ( x , bottom , selRect . x , bottom ) ; else g . drawLine ( x , bottom , selRect . x - NUM_ , bottom ) ; if ( selRect . x + selRect . width < x + w - NUM_ ) { if ( leftToRight && ! lastInRun ) g . drawLine ( selRect . x + selRect . width , bottom , right , bottom ) ; else g . drawLine ( selRect . x + selRect . width - NUM_ , bottom , right , bottom ) ; } } }
public static void upto ( double self , Number to , @ ClosureParams ( FirstParam . class ) Closure closure ) { double to1 = to . doubleValue ( ) ; if ( self <= to1 ) { for ( double i = self ; i <= to1 ; i ++ ) { closure . call ( i ) ; } } else throw new GroovyRuntimeException ( STR_ + to + STR_ + self + STR_ ) ; }
public void save ( String type , List < ElasticSearchDoc > docs ) { if ( docs != null && ! docs . isEmpty ( ) ) { List < List < ElasticSearchDoc > > partitionedDocs = Lists . partition ( docs , NUM_ ) ; partitionedDocs . forEach ( null ) ; } }
public void error ( SourceLocator srcLctr , String msg ) throws TransformerException { error ( srcLctr , null , null , msg , null ) ; }
void removeListener ( String listenerID ) { if ( listenerObjects != null ) { synchronized ( listenerObjects ) { listenerObjects . remove ( listenerID ) ; if ( listenerObjects . isEmpty ( ) ) { deregisterListener ( ) ; } } if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + serviceName + STR_ + listenerID ) ; } } }
@ Deprecated public void registerCredentials ( UserCredential authentication ) { wallet . put ( authentication . getURL ( ) , authentication ) ; }
public void testDatabaseDriverPropertiesUserAndPasswordPropertyOverrideDSUserAndPassword ( ) { String driverPropertyString = STR_ ; Properties props = new Properties ( ) ; props . setProperty ( DatasourcePropertySet . USERNAME , STR_ ) ; props . setProperty ( DatasourcePropertySet . PASSWORD , STR_ ) ; props . setProperty ( DatasourcePropertySet . CONNECTION_PROPERTIES , driverPropertyString ) ; DataSource ds = dataSourceConverter . fromProperties ( props ) ; assertEquals ( STR_ , ds . getUsername ( ) ) ; assertEquals ( STR_ , ds . getPassword ( ) ) ; }
public boolean isAGCEnabled ( ) { return mAGCEnabled . get ( ) ; }
protected LinkedList < String > splitIntoAllophones ( String phoneString ) { LinkedList < String > phoneList = new LinkedList < String > ( ) ; for ( int i = NUM_ ; i < phoneString . length ( ) ; i ++ ) { String name = null ; for ( int j = NUM_ ; j >= NUM_ ; j -- ) { if ( i + j <= phoneString . length ( ) ) { String candidate = phoneString . substring ( i , i + j ) ; if ( getAllophone ( candidate ) != null ) { name = candidate ; i += j - NUM_ ; break ; } } } if ( name != null ) { phoneList . add ( name ) ; } } return phoneList ; }
protected void addToMaintenanceQueue ( NodePortTuple npt ) { if ( maintenanceQueue . contains ( npt ) == BOOL_ ) { maintenanceQueue . add ( npt ) ; } }
private boolean execute ( boolean readResponse ) throws IOException { try { httpEngine . sendRequest ( ) ; if ( readResponse ) { httpEngine . readResponse ( ) ; } return BOOL_ ; } catch ( IOException e ) { if ( handleFailure ( e ) ) { return BOOL_ ; } else { throw e ; } } }
public BigdataSail ( final Properties properties ) { this ( properties . getProperty ( Options . NAMESPACE , Options . DEFAULT_NAMESPACE ) , new Journal ( properties ) ) ; closeOnShutdown = BOOL_ ; if ( ! exists ( ) ) { try { create ( properties ) ; } catch ( InterruptedException | ExecutionException e ) { throw new RuntimeException ( e ) ; } } }
public float convert ( ) { return Float . intBitsToFloat ( ( int ) bytes ) ; }
protected int addNode ( Node node , int parentIndex , int previousSibling , int forceNodeType ) { int nodeIndex = m_nodes . size ( ) ; if ( m_dtmIdent . size ( ) == ( nodeIndex > > > DTMManager . IDENT_DTM_NODE_BITS ) ) { try { if ( m_mgr == null ) throw new ClassCastException ( ) ; DTMManagerDefault mgrD = ( DTMManagerDefault ) m_mgr ; int id = mgrD . getFirstFreeDTMID ( ) ; mgrD . addDTM ( this , id , nodeIndex ) ; m_dtmIdent . addElement ( id << DTMManager . IDENT_DTM_NODE_BITS ) ; } catch ( ClassCastException e ) { error ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_DTMIDS_AVAIL , null ) ) ; } } m_size ++ ; int type ; if ( NULL == forceNodeType ) type = node . getNodeType ( ) ; else type = forceNodeType ; if ( Node . ATTRIBUTE_NODE == type ) { String name = node . getNodeName ( ) ; if ( name . startsWith ( STR_ ) || name . equals ( STR_ ) ) { type = DTM . NAMESPACE_NODE ; } } m_nodes . addElement ( node ) ; m_firstch . setElementAt ( NOTPROCESSED , nodeIndex ) ; m_nextsib . setElementAt ( NOTPROCESSED , nodeIndex ) ; m_prevsib . setElementAt ( previousSibling , nodeIndex ) ; m_parent . setElementAt ( parentIndex , nodeIndex ) ; if ( DTM . NULL != parentIndex && type != DTM . ATTRIBUTE_NODE && type != DTM . NAMESPACE_NODE ) { if ( NOTPROCESSED == m_firstch . elementAt ( parentIndex ) ) m_firstch . setElementAt ( nodeIndex , parentIndex ) ; } String nsURI = node . getNamespaceURI ( ) ; String localName = ( type == Node . PROCESSING_INSTRUCTION_NODE ) ? node . getNodeName ( ) : node . getLocalName ( ) ; if ( ( ( type == Node . ELEMENT_NODE ) || ( type == Node . ATTRIBUTE_NODE ) ) && null == localName ) localName = node . getNodeName ( ) ; ExpandedNameTable exnt = m_expandedNameTable ; if ( node . getLocalName ( ) == null && ( type == Node . ELEMENT_NODE || type == Node . ATTRIBUTE_NODE ) ) { } int expandedNameID = ( null != localName ) ? exnt . getExpandedTypeID ( nsURI , localName , type ) : exnt . getExpandedTypeID ( type ) ; m_exptype . setElementAt ( expandedNameID , nodeIndex ) ; indexNode ( expandedNameID , nodeIndex ) ; if ( DTM . NULL != previousSibling ) m_nextsib . setElementAt ( nodeIndex , previousSibling ) ; if ( type == DTM . NAMESPACE_NODE ) declareNamespaceInContext ( parentIndex , nodeIndex ) ; return nodeIndex ; }
public FileProcessController ( final FileControllerParameters arguments , final int pid ) { this ( arguments , pid , Long . getLong ( STATUS_TIMEOUT_PROPERTY , NUM_ . NUM_ ) , TimeUnit . MILLISECONDS ) ; }
public void testAddCertificate2 ( ) throws Exception { Identity i = new IdentityStub ( STR_ ) ; PublicKeyStub pk1 = new PublicKeyStub ( STR_ , STR_ , null ) ; CertificateStub c1 = new CertificateStub ( STR_ , null , null , pk1 ) ; i . addCertificate ( c1 ) ; assertSame ( c1 , i . certificates ( ) [ NUM_ ] ) ; assertSame ( pk1 , i . getPublicKey ( ) ) ; }
protected static final String addEscapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = NUM_ ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case NUM_ : continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < x20 || ch > x7e ) { String s = STR_ + Integer . toString ( ch , NUM_ ) ; retval . append ( STR_ + s . substring ( s . length ( ) - NUM_ , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; }
protected Set < Future < Void > > send ( String channelId , Object message ) { Collection < Session > sessions = ( channelId != null ) ? socketSessions . get ( channelId ) : null ; if ( sessions != null && ! sessions . isEmpty ( ) ) { Set < Future < Void > > results = new HashSet < > ( sessions . size ( ) ) ; String json = Json . encode ( message ) ; for ( Session session : sessions ) { if ( session . isOpen ( ) ) { send ( session , json , results ) ; } } return results ; } return emptySet ( ) ; }
public Object attribute ( Object key ) { return ( attributes != null ) ? attributes . get ( key ) : null ; }
public Response doPut ( String url ) { return doPut ( url , null ) ; }
private static Pair < String , String > offsetRRX ( final long offset , final ITranslationEnvironment environment , final List < ReilInstruction > instructions , final String registerNodeValue1 , final String registerNodeValue2 ) { final String address = environment . getNextVariableString ( ) ; final String index = environment . getNextVariableString ( ) ; final String tmpVar = environment . getNextVariableString ( ) ; final String tmpVar1 = environment . getNextVariableString ( ) ; final String tmpVar2 = environment . getNextVariableString ( ) ; final String tmpVar3 = environment . getNextVariableString ( ) ; long baseOffset = offset ; instructions . add ( ReilHelpers . createBsh ( baseOffset ++ , bt , STR_ , wd , String . valueOf ( NUM_ ) , dw , tmpVar1 ) ) ; instructions . add ( ReilHelpers . createBsh ( baseOffset ++ , dw , registerNodeValue2 , bt , String . valueOf ( - NUM_ ) , dw , tmpVar2 ) ) ; instructions . add ( ReilHelpers . createOr ( baseOffset ++ , dw , tmpVar1 , dw , tmpVar2 , dw , tmpVar3 ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , dw , tmpVar3 , dw , dWordBitMask , dw , index ) ) ; instructions . add ( ReilHelpers . createAdd ( baseOffset ++ , dw , registerNodeValue1 , dw , index , dw , tmpVar ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , dw , tmpVar , dw , dWordBitMask , dw , address ) ) ; return new Pair < String , String > ( address , registerNodeValue1 ) ; }
public void unregisterDropControllers ( ) { dropControllerList . clear ( ) ; }
private static long CallStaticLongMethodV ( JNIEnvironment env , int classJREF , int methodID , Address argAddress ) throws Exception { if ( traceJNI ) VM . sysWrite ( STR_ ) ; RuntimeEntrypoints . checkJNICountDownToGC ( ) ; try { Object returnObj = JNIHelpers . invokeWithVarArg ( methodID , argAddress , TypeReference . Long ) ; return Reflection . unwrapLong ( returnObj ) ; } catch ( Throwable unexpected ) { if ( traceJNI ) unexpected . printStackTrace ( System . err ) ; env . recordException ( unexpected ) ; return NUM_ ; } }
public static String createLink ( String uri , String label ) { return STR_ + uri + STR_ + label + STR_ ; }
public int size ( ) { return segments . size ( ) ; }
public void addOperand ( int startTick , int endTick , String text , Lifeline constraintLifeline ) throws SequenceDiagramCheckedException { if ( operands . size ( ) == NUM_ && this . startTick != startTick ) { throw new IllegalArgumentException ( STR_ ) ; } operands . add ( new Operand ( startTick , endTick , text , constraintLifeline ) ) ; }
public static Number asin ( Number a ) { return Math . asin ( a . doubleValue ( ) ) ; }
private void createAndAttachEvent ( long ov ) throws WindowsException { long hEvent = CreateEvent ( BOOL_ , BOOL_ ) ; UNSAFE . putAddress ( ov + OFFSETOF_HEVENT , hEvent ) ; }
public String toString ( ) { StringBuffer result = new StringBuffer ( ) ; result . append ( STR_ ) ; int s1 = sizes . size ( ) ; for ( int i = NUM_ ; i < s1 ; ++ i ) { int s2 = sizes . get ( i ) ; result . append ( STR_ ) ; for ( int j = NUM_ ; j < s2 ; ++ j ) { result . append ( vector [ i ] [ j ] ) ; if ( j + NUM_ < s2 ) result . append ( STR_ ) ; } result . append ( STR_ ) ; if ( i + NUM_ < s1 ) result . append ( STR_ ) ; } result . append ( STR_ ) ; return result . toString ( ) ; }
@ Override public int compareTo ( String o ) { int result ; int major ; int minor ; int revision ; int pnt ; int [ ] maj = new int [ NUM_ ] ; int [ ] min = new int [ NUM_ ] ; int [ ] rev = new int [ NUM_ ] ; int [ ] point = new int [ NUM_ ] ; parseVersion ( o , maj , min , rev , point ) ; major = maj [ NUM_ ] ; minor = min [ NUM_ ] ; revision = rev [ NUM_ ] ; pnt = point [ NUM_ ] ; if ( MAJOR < major ) { result = - NUM_ ; } else if ( MAJOR == major ) { if ( MINOR < minor ) { result = - NUM_ ; } else if ( MINOR == minor ) { if ( REVISION < revision ) { result = - NUM_ ; } else if ( REVISION == revision ) { if ( POINT < pnt ) { result = - NUM_ ; } else if ( POINT == pnt ) { result = NUM_ ; } else { result = NUM_ ; } } else { result = NUM_ ; } } else { result = NUM_ ; } } else { result = NUM_ ; } return result ; }
private void generateIntegrityKeyPair ( boolean clientMode ) throws UnsupportedEncodingException , IOException , NoSuchAlgorithmException { byte [ ] cimagic = CLIENT_INT_MAGIC . getBytes ( encoding ) ; byte [ ] simagic = SVR_INT_MAGIC . getBytes ( encoding ) ; MessageDigest md5 = MessageDigest . getInstance ( STR_ ) ; byte [ ] keyBuffer = new byte [ H_A1 . length + cimagic . length ] ; System . arraycopy ( H_A1 , NUM_ , keyBuffer , NUM_ , H_A1 . length ) ; System . arraycopy ( cimagic , NUM_ , keyBuffer , H_A1 . length , cimagic . length ) ; md5 . update ( keyBuffer ) ; byte [ ] Kic = md5 . digest ( ) ; System . arraycopy ( simagic , NUM_ , keyBuffer , H_A1 . length , simagic . length ) ; md5 . update ( keyBuffer ) ; byte [ ] Kis = md5 . digest ( ) ; if ( logger . isLoggable ( Level . FINER ) ) { traceOutput ( DI_CLASS_NAME , STR_ , STR_ , Kic ) ; traceOutput ( DI_CLASS_NAME , STR_ , STR_ , Kis ) ; } if ( clientMode ) { myKi = Kic ; peerKi = Kis ; } else { myKi = Kis ; peerKi = Kic ; } }
public static boolean isLocalFileUri ( Uri uri ) { final String scheme = getSchemeOrNull ( uri ) ; return LOCAL_FILE_SCHEME . equals ( scheme ) ; }
CompletableFuture < WriteResponse > write ( List < WriteValue > writeValues ) ;
public static < V > boolean addDistinctEntry ( List < V > sourceList , V entry ) { return ( sourceList != null && ! sourceList . contains ( entry ) ) ? sourceList . add ( entry ) : BOOL_ ; }
public static boolean validSystemNameConfig ( String systemName , char type ) { if ( ! validSystemNameFormat ( systemName , type ) ) { return BOOL_ ; } int bit = getBitFromSystemName ( systemName ) ; if ( ( type == STR_ ) || ( type == STR_ ) ) { if ( ( bit <= NUM_ ) || ( bit > OutputBits . getNumOutputBits ( ) ) ) { return BOOL_ ; } } else if ( type == STR_ ) { if ( ( bit <= NUM_ ) || ( bit > InputBits . getNumInputBits ( ) ) ) { return BOOL_ ; } } else { log . error ( STR_ ) ; return BOOL_ ; } return BOOL_ ; }
public boolean mouseMoved ( MouseEvent e ) { EsriGraphicList list = getEsriGraphicList ( ) ; boolean ret = BOOL_ ; if ( list != null ) { OMGraphic omg = list . findClosest ( e . getX ( ) , e . getY ( ) , NUM_ ) ; if ( omg != null ) { int index ; Integer I = ( ( Integer ) omg . getAttribute ( SHAPE_INDEX_ATTRIBUTE ) ) ; if ( I != null ) { index = I . intValue ( ) ; } else { index = list . indexOf ( omg ) ; } if ( parentLayer == null ) { Component comp = getComponent ( ) ; if ( comp instanceof Layer ) { parentLayer = ( Layer ) comp ; } } if ( parentLayer != null ) { parentLayer . fireRequestToolTip ( getDescription ( index ) ) ; } ret = BOOL_ ; } else if ( parentLayer != null ) { parentLayer . fireHideToolTip ( ) ; } } return ret ; }
private void push ( final int type ) { if ( outputStack == null ) { outputStack = new int [ NUM_ ] ; } int n = outputStack . length ; if ( outputStackTop >= n ) { int [ ] t = new int [ Math . max ( outputStackTop + NUM_ , NUM_ . n ) ] ; System . arraycopy ( outputStack , NUM_ , t , NUM_ , n ) ; outputStack = t ; } outputStack [ outputStackTop ++ ] = type ; int top = owner . inputStackTop + outputStackTop ; if ( top > owner . outputStackMax ) { owner . outputStackMax = top ; } }
public void createDatabaseEntitiesForBusinessObjectDataNotificationRegistrationTesting ( String namespace , List < String > notificationEventTypes , String businessObjectDefinitionNamespace , String businessObjectDefinitionName , List < String > fileTypes , List < String > storageNames , List < String > businessObjectDataStatuses , List < JobAction > jobActions ) { NamespaceEntity namespaceEntity = namespaceDao . getNamespaceByCd ( namespace ) ; if ( namespaceEntity == null ) { namespaceDaoTestHelper . createNamespaceEntity ( namespace ) ; } if ( ! CollectionUtils . isEmpty ( notificationEventTypes ) ) { for ( String notificationEventType : notificationEventTypes ) { NotificationEventTypeEntity notificationEventTypeEntity = notificationEventTypeDao . getNotificationEventTypeByCode ( notificationEventType ) ; if ( notificationEventTypeEntity == null ) { notificationRegistrationDaoTestHelper . createNotificationEventTypeEntity ( notificationEventType ) ; } } } BusinessObjectDefinitionEntity businessObjectDefinitionEntity = businessObjectDefinitionDao . getBusinessObjectDefinitionByKey ( new BusinessObjectDefinitionKey ( businessObjectDefinitionNamespace , businessObjectDefinitionName ) ) ; if ( businessObjectDefinitionEntity == null ) { businessObjectDefinitionDaoTestHelper . createBusinessObjectDefinitionEntity ( businessObjectDefinitionNamespace , businessObjectDefinitionName , AbstractServiceTest . DATA_PROVIDER_NAME , AbstractServiceTest . BDEF_DESCRIPTION ) ; } if ( ! CollectionUtils . isEmpty ( fileTypes ) ) { for ( String businessObjectFormatFileType : fileTypes ) { fileTypeDaoTestHelper . createFileTypeEntity ( businessObjectFormatFileType ) ; } } if ( ! CollectionUtils . isEmpty ( storageNames ) ) { for ( String storageName : storageNames ) { storageDaoTestHelper . createStorageEntity ( storageName , StoragePlatformEntity . S3 ) ; } } if ( ! CollectionUtils . isEmpty ( businessObjectDataStatuses ) ) { for ( String businessObjectDataStatus : businessObjectDataStatuses ) { BusinessObjectDataStatusEntity businessObjectDataStatusEntity = businessObjectDataStatusDao . getBusinessObjectDataStatusByCode ( businessObjectDataStatus ) ; if ( businessObjectDataStatusEntity == null ) { businessObjectDataStatusDaoTestHelper . createBusinessObjectDataStatusEntity ( businessObjectDataStatus ) ; } } } if ( ! CollectionUtils . isEmpty ( jobActions ) ) { for ( JobAction jobAction : jobActions ) { jobDefinitionDaoTestHelper . createJobDefinitionEntity ( jobAction . getNamespace ( ) , jobAction . getJobName ( ) , String . format ( STR_ , jobAction . getNamespace ( ) , jobAction . getJobName ( ) ) , String . format ( STR_ , jobAction . getNamespace ( ) , jobAction . getJobName ( ) , AbstractServiceTest . ACTIVITI_ID ) ) ; } } }
public boolean postData ( InputStream data , Long length , OutputStream output , String type , URL url ) { if ( mockMode ) return BOOL_ ; boolean success = BOOL_ ; if ( type == null ) type = DEFAULT_CONTENT_TYPE ; HttpURLConnection urlc = null ; try { try { urlc = ( HttpURLConnection ) url . openConnection ( ) ; try { urlc . setRequestMethod ( STR_ ) ; } catch ( ProtocolException e ) { fatal ( STR_ + e ) ; } urlc . setDoOutput ( BOOL_ ) ; urlc . setDoInput ( BOOL_ ) ; urlc . setUseCaches ( BOOL_ ) ; urlc . setAllowUserInteraction ( BOOL_ ) ; urlc . setRequestProperty ( STR_ , type ) ; basicAuth ( urlc ) ; if ( null != length ) { urlc . setFixedLengthStreamingMode ( length ) ; } else { urlc . setChunkedStreamingMode ( - NUM_ ) ; } urlc . connect ( ) ; } catch ( IOException e ) { fatal ( STR_ + solrUrl + STR_ + e ) ; success = BOOL_ ; } catch ( Exception e ) { fatal ( STR_ + e . getMessage ( ) ) ; } try ( final OutputStream out = urlc . getOutputStream ( ) ) { pipe ( data , out ) ; } catch ( IOException e ) { fatal ( STR_ + e ) ; } try { success &= checkResponseCode ( urlc ) ; try ( final InputStream in = urlc . getInputStream ( ) ) { pipe ( in , output ) ; } } catch ( IOException e ) { warn ( STR_ + e ) ; success = BOOL_ ; } catch ( GeneralSecurityException e ) { fatal ( STR_ ) ; } } finally { if ( urlc != null ) urlc . disconnect ( ) ; } return success ; }
public FormatException ( String s , Throwable rootCause ) { super ( s + STR_ + rootCause . getLocalizedMessage ( ) ) ; this . rootCause = rootCause ; }
private Pair < BigDecimal , BigDecimal > fillPayment ( final CustomerOrder order , final CustomerOrderDelivery delivery , final Payment payment , final boolean singlePay , final BigDecimal runningTotal , final BigDecimal runningTotalTax , final boolean lastDelivery ) { if ( payment . getTransactionReferenceId ( ) == null ) { payment . setTransactionReferenceId ( delivery . getDeliveryNum ( ) ) ; } payment . setOrderShipment ( singlePay ? order . getOrdernum ( ) : delivery . getDeliveryNum ( ) ) ; fillPaymentItems ( delivery , payment ) ; fillPaymentShipment ( order , delivery , payment ) ; return fillPaymentAmount ( order , delivery , payment , singlePay , runningTotal , runningTotalTax , lastDelivery ) ; }
void materialize ( ) { if ( cachefill < NUM_ ) { return ; } double min = Double . MAX_VALUE , max = Double . MIN_VALUE ; for ( int i = NUM_ ; i < cachefill ; i ++ ) { min = Math . min ( min , cachec [ i ] ) ; max = Math . max ( max , cachec [ i ] ) ; } LinearScale scale = new LinearScale ( min , max ) ; min = scale . getMin ( ) ; max = scale . getMax ( ) ; this . base = min ; this . max = max ; this . binsize = ( max - min ) / this . destsize ; this . data = new float [ this . destsize << NUM_ ] ; size = destsize ; final int end = cachefill ; cachefill = - NUM_ ; for ( int i = NUM_ ; i < end ; i ++ ) { increment ( cachec [ i ] , cachev [ i ] ) ; } cachec = null ; cachev = null ; }
public boolean buildHostPart ( Appendable buffer , String url , Boolean useSSL ) throws WebAppConfigurationException , IOException { return buildHostPart ( buffer , url , useSSL , BOOL_ ) ; }
public static < T > List < T > shiftElementsToEnd ( final List < T > source , final int count ) { final ArrayList < T > rVal = new ArrayList < > ( source . size ( ) ) ; for ( int i = count ; i < source . size ( ) ; i ++ ) { rVal . add ( source . get ( i ) ) ; } for ( int i = NUM_ ; i < count ; i ++ ) { rVal . add ( source . get ( i ) ) ; } if ( source . size ( ) != rVal . size ( ) ) { throw new IllegalStateException ( STR_ + count + STR_ + source + STR_ + rVal ) ; } return rVal ; }
private boolean isLeafPage ( ByteBuffer buffer ) throws IOException { byte pageType = buffer . get ( NUM_ ) ; if ( pageType == PageTypes . INDEX_LEAF ) { return BOOL_ ; } else if ( pageType == PageTypes . INDEX_NODE ) { return BOOL_ ; } throw new IOException ( withErrorContext ( STR_ + pageType ) ) ; }
public void addJsLibFiles ( File ... files ) { jsLibFiles . addAll ( Arrays . asList ( files ) ) ; }
public void testWriteOffset ( ) { int len = NUM_ ; int dataLen = NUM_ ; byte [ ] srcData = getWData ( dataLen ) ; byte [ ] data = new byte [ dataLen ] ; int nOffset = NUM_ ; ByteFifoBuffer instance = new ByteFifoBuffer ( len ) ; int result = instance . writeOffset ( srcData , dataLen , nOffset ) ; int readCount = instance . readOffset ( data , NUM_ , dataLen , nOffset ) ; assertEquals ( result , readCount ) ; assertArrayEquals ( srcData , data ) ; byte [ ] halfFilled = new byte [ dataLen . NUM_ ] ; System . arraycopy ( srcData , NUM_ , halfFilled , dataLen , dataLen ) ; byte [ ] halfFilledRead = new byte [ dataLen . NUM_ ] ; instance . readOffset ( halfFilledRead , dataLen , dataLen , nOffset ) ; assertArrayEquals ( halfFilled , halfFilledRead ) ; instance = new ByteFifoBuffer ( len ) ; instance . write ( srcData , dataLen ) ; instance . write ( srcData , dataLen / NUM_ ) ; instance . read ( data , dataLen ) ; instance . writeOffset ( srcData , dataLen , NUM_ ) ; instance = new ByteFifoBuffer ( NUM_ ) ; instance . writeOffset ( getWData ( NUM_ ) , NUM_ , NUM_ ) ; }
private void initPropertiesIfNecessary ( ) { if ( timer == null ) { Toolkit t = Toolkit . getDefaultToolkit ( ) ; Integer prop ; prop = ( Integer ) t . getDesktopProperty ( STR_ ) ; timer = new Timer ( prop == null ? NUM_ : prop . intValue ( ) , this ) ; prop = ( Integer ) t . getDesktopProperty ( STR_ ) ; timer . setInitialDelay ( prop == null ? NUM_ : prop . intValue ( ) ) ; prop = ( Integer ) t . getDesktopProperty ( STR_ ) ; if ( prop != null ) { hysteresis = prop . intValue ( ) ; } } }
public EObject loadModel ( String filename , String cwd ) { URI fileURI = normalizeURI ( URI . createURI ( filename ) ) ; URI cwdURI = normalizeURI ( URI . createURI ( cwd ) ) ; return loadModel ( fileURI , cwdURI ) ; }
static boolean pathIsWindows ( String path ) { if ( path != null && path . length ( ) > NUM_ ) { return ( Character . isLetter ( path . charAt ( NUM_ ) ) && path . charAt ( NUM_ ) == STR_ ) || ( path . startsWith ( STR_ ) || path . startsWith ( STR_ ) ) ; } return BOOL_ ; }
public static boolean isTestServer ( ) { return System . getProperty ( TestServerOnly . TEST_SERVER_PROPERTY ) != null ; }
@ SuppressWarnings ( STR_ ) private < T > String generateTestFile ( String filename , List < T > elems , AvroCoder < T > coder , String codec ) throws IOException { File tmpFile = tmpFolder . newFile ( filename ) ; String path = tmpFile . toString ( ) ; FileOutputStream os = new FileOutputStream ( tmpFile ) ; DatumWriter < T > datumWriter = coder . createDatumWriter ( ) ; try ( DataFileWriter < T > writer = new DataFileWriter < > ( datumWriter ) ) { writer . setCodec ( CodecFactory . fromString ( codec ) ) ; writer . create ( coder . getSchema ( ) , os ) ; for ( T elem : elems ) { writer . append ( elem ) ; } } return path ; }
public void notifyReturned ( NotifyContext notifyContext , ITemplateHolder template ) { if ( notifyContext == null ) return ; if ( _filterManager . _isFilter [ FilterOperationCodes . AFTER_NOTIFY_TRIGGER ] ) { Object [ ] entries = new Object [ NUM_ ] ; entries [ NUM_ ] = notifyContext . getEntry ( ) ; entries [ NUM_ ] = template ; try { _filterManager . invokeFilters ( FilterOperationCodes . AFTER_NOTIFY_TRIGGER , null , entries ) ; } catch ( Exception e ) { if ( _logger . isLoggable ( Level . FINE ) ) _logger . log ( Level . FINE , STR_ , e ) ; } } decreaseCounter ( notifyContext ) ; }
public static String normalizeSlashes ( String path ) { return path . replaceAll ( STR_ , STR_ ) ; }
protected Point2D correct ( Point2D anchor , Rectangle2D bounds ) { if ( anchor == null ) return anchor ; double x = anchor . getX ( ) , y = anchor . getY ( ) ; double x1 = bounds . getMinX ( ) , y1 = bounds . getMinY ( ) ; double x2 = bounds . getMaxX ( ) , y2 = bounds . getMaxY ( ) ; x = ( x < x1 ? x1 : ( x > x2 ? x2 : x ) ) ; y = ( y < y1 ? y1 : ( y > y2 ? y2 : y ) ) ; m_tmp . setLocation ( x , y ) ; return m_tmp ; }
private String saveParameters ( Set userSession , String userID , boolean isSOAPInitiated , boolean isIDPInitiated , String protocol , String realm , String idpEntityID , String spEntityID , String relayState , String singleLogoutRequestXML , String singleLogoutResponseXML , int currentStatus ) { String tmpRelayState = SAML2Utils . generateIDWithServerID ( ) ; relayStateMap . put ( tmpRelayState , relayState ) ; if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + STR_ + userID + STR_ + userSession + STR_ + relayState + STR_ + tmpRelayState + STR_ + isSOAPInitiated + STR_ + isIDPInitiated + STR_ + protocol + STR_ + realm + STR_ + idpEntityID + STR_ + spEntityID + STR_ + currentStatus + STR_ + singleLogoutRequestXML + STR_ + singleLogoutResponseXML ) ; } if ( userSession != null ) { userSessionMap . put ( tmpRelayState , userSession ) ; } if ( userID != null ) { userIDMap . put ( tmpRelayState , userID ) ; } if ( isSOAPInitiated ) { isSOAPInitiatedMap . put ( tmpRelayState , Boolean . TRUE ) ; } else { isSOAPInitiatedMap . put ( tmpRelayState , Boolean . FALSE ) ; } if ( isIDPInitiated ) { isIDPInitiatedMap . put ( tmpRelayState , Boolean . TRUE ) ; } else { isIDPInitiatedMap . put ( tmpRelayState , Boolean . FALSE ) ; } if ( protocol != null ) { origProtocolMap . put ( tmpRelayState , protocol ) ; int listSize = protocolList . size ( ) ; List list = new ArrayList ( listSize - NUM_ ) ; for ( int i = NUM_ ; i < listSize ; i ++ ) { String proto = ( String ) protocolList . get ( i ) ; if ( ! proto . equals ( protocol ) ) { list . add ( proto ) ; } } protocolListMap . put ( tmpRelayState , list ) ; } if ( realm != null ) { realmMap . put ( tmpRelayState , realm ) ; } if ( idpEntityID != null ) { idpEntityIDMap . put ( tmpRelayState , idpEntityID ) ; } if ( spEntityID != null ) { spEntityIDMap . put ( tmpRelayState , spEntityID ) ; } if ( singleLogoutRequestXML != null ) { sloRequestXMLMap . put ( tmpRelayState , singleLogoutRequestXML ) ; } if ( singleLogoutResponseXML != null ) { sloResponseXMLMap . put ( tmpRelayState , singleLogoutResponseXML ) ; } currentStatusMap . put ( tmpRelayState , new Integer ( currentStatus ) ) ; return tmpRelayState ; }
private void nextPacket ( ) throws IOException { int off = NUM_ ; int remaining = NUM_ ; do { int count = baseStream . read ( header , off , remaining ) ; if ( count <= NUM_ ) { throw new EOFException ( STR_ + ( NUM_ - remaining ) + STR_ + NUM_ ) ; } remaining -= count ; off += count ; } while ( remaining > NUM_ ) ; int compressedLength = ( header [ NUM_ ] & xff ) + ( ( header [ NUM_ ] & xff ) << NUM_ ) + ( ( header [ NUM_ ] & xff ) << NUM_ ) ; lastPacketSeq = header [ NUM_ ] & xff ; int decompressedLength = ( header [ NUM_ ] & xff ) + ( ( header [ NUM_ ] & xff ) << NUM_ ) + ( ( header [ NUM_ ] & xff ) << NUM_ ) ; if ( decompressedLength != NUM_ ) { doDecompress = BOOL_ ; remainingBytes += decompressedLength ; byte [ ] compressedBuffer = new byte [ compressedLength ] ; byte [ ] decompressedBuffer = new byte [ decompressedLength ] ; off = NUM_ ; remaining = compressedBuffer . length ; do { int count = baseStream . read ( compressedBuffer , off , remaining ) ; if ( count <= NUM_ ) { throw new EOFException ( STR_ + ( NUM_ - remaining ) + STR_ + NUM_ ) ; } remaining -= count ; off += count ; } while ( remaining > NUM_ ) ; Inflater inflater = new Inflater ( ) ; inflater . setInput ( compressedBuffer ) ; try { int actualUncompressBytes = inflater . inflate ( decompressedBuffer ) ; if ( actualUncompressBytes != decompressedLength ) { throw new IOException ( STR_ + actualUncompressBytes + STR_ + decompressedLength ) ; } } catch ( DataFormatException dfe ) { throw new IOException ( dfe ) ; } inflater . end ( ) ; decompressedByteStream = new ByteArrayInputStream ( decompressedBuffer ) ; } else { doDecompress = BOOL_ ; remainingBytes += compressedLength ; decompressedByteStream = null ; } logger . trace ( STR_ + lastPacketSeq + STR_ + remainingBytes ) ; }
protected boolean loadField ( DDFRecord record , String tagName , int fieldIndex ) { if ( fields . get ( tagName ) == null ) { DDFField ddf = record . findField ( tagName , fieldIndex ) ; if ( ddf != null ) { fields . put ( tagName , ddf ) ; ddf . toString ( ) ; return BOOL_ ; } } return BOOL_ ; }
public HttpRequest ( final CharSequence url , final String method ) throws HttpRequestException { try { this . url = new URL ( url . toString ( ) ) ; } catch ( MalformedURLException e ) { throw new HttpRequestException ( e ) ; } this . requestMethod = method ; }
private boolean isError ( IProblem problem , Type type ) { return BOOL_ ; }
private static void addProcessParameters ( int AD_PInstance_ID , Map < String , Object > params , String trxName ) { final String sql = STR_ + STR_ + X_AD_PInstance_Para . COLUMNNAME_ParameterName + STR_ + X_AD_PInstance_Para . COLUMNNAME_P_String + STR_ + X_AD_PInstance_Para . COLUMNNAME_P_String_To + STR_ + X_AD_PInstance_Para . COLUMNNAME_P_Number + STR_ + X_AD_PInstance_Para . COLUMNNAME_P_Number_To + STR_ + X_AD_PInstance_Para . COLUMNNAME_P_Date + STR_ + X_AD_PInstance_Para . COLUMNNAME_P_Date_To + STR_ + X_AD_PInstance_Para . COLUMNNAME_Info + STR_ + X_AD_PInstance_Para . COLUMNNAME_Info_To + STR_ + X_AD_PInstance_Para . Table_Name + STR_ + X_AD_PInstance_Para . COLUMNNAME_AD_PInstance_ID + STR_ ; PreparedStatement pstmt = null ; ResultSet rs = null ; try { pstmt = DB . prepareStatement ( sql , ResultSet . TYPE_FORWARD_ONLY , ResultSet . CONCUR_READ_ONLY , trxName ) ; pstmt . setInt ( NUM_ , AD_PInstance_ID ) ; rs = pstmt . executeQuery ( ) ; while ( rs . next ( ) ) { String name = rs . getString ( NUM_ ) ; String pStr = rs . getString ( NUM_ ) ; String pStrTo = rs . getString ( NUM_ ) ; BigDecimal pNum = rs . getBigDecimal ( NUM_ ) ; BigDecimal pNumTo = rs . getBigDecimal ( NUM_ ) ; Timestamp pDate = rs . getTimestamp ( NUM_ ) ; Timestamp pDateTo = rs . getTimestamp ( NUM_ ) ; if ( pStr != null ) { if ( pStrTo != null ) { params . put ( name + STR_ , pStr ) ; params . put ( name + STR_ , pStrTo ) ; } else { params . put ( name , pStr ) ; } } else if ( pDate != null ) { if ( pDateTo != null ) { params . put ( name + STR_ , pDate ) ; params . put ( name + STR_ , pDateTo ) ; } else { params . put ( name , pDate ) ; } } else if ( pNum != null ) { if ( pNumTo != null ) { params . put ( name + STR_ , pNum ) ; params . put ( name + STR_ , pNumTo ) ; } else { params . put ( name , pNum ) ; } } String info = rs . getString ( NUM_ ) ; String infoTo = rs . getString ( NUM_ ) ; params . put ( name + STR_ , ( info != null ? info : STR_ ) ) ; params . put ( name + STR_ , ( infoTo != null ? infoTo : STR_ ) ) ; } } catch ( SQLException e ) { throw new DBException ( e , sql ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } }
@ SuppressWarnings ( { STR_ , STR_ } ) public RecordSetPage ( Input input ) { Deserializer deserizalizer = new Deserializer ( ) ; Map mapResult = deserizalizer . deserialize ( input , Map . class ) ; cursor = ( Integer ) mapResult . get ( STR_ ) ; data = ( List < List < Object > > ) mapResult . get ( STR_ ) ; }
public Optional < String > endpoint ( ) { return Optional . ofNullable ( endpointArg ) ; }
public void testCollisions ( ) throws Exception { Map < Integer , Set < UUID > > map = new HashMap < > ( ) ; Collection < UUID > nodes = new LinkedHashSet < > ( ) ; while ( nodes . size ( ) < NUM_ ) { UUID uuid = UUID . randomUUID ( ) ; int hashCode = uuid . hashCode ( ) ; Set < UUID > set = map . get ( hashCode ) ; if ( set == null ) map . put ( hashCode , set = new LinkedHashSet < > ( ) ) ; set . add ( uuid ) ; if ( set . size ( ) > NUM_ ) nodes . addAll ( set ) ; } map . clear ( ) ; GridClientConsistentHash < UUID > hash = new GridClientConsistentHash < > ( ) ; hash . addNodes ( nodes , REPLICAS ) ; boolean fail = BOOL_ ; for ( UUID exp : nodes ) { UUID act = hash . node ( NUM_ , Arrays . asList ( exp ) ) ; if ( exp . equals ( act ) ) info ( STR_ + exp + STR_ + act + STR_ ) ; else { info ( STR_ + exp + STR_ + act + STR_ ) ; fail = BOOL_ ; } } if ( fail ) fail ( STR_ + nodes ) ; }
void sendMessageToHandlerWithControllerReset ( List < OFMessage > messages ) throws Exception { sendMessageToHandlerNoControllerReset ( messages ) ; }
public boolean isRedeployMode ( ) { return scenario . equals ( PropertyConstants . REDEPLOY_MODE ) ? BOOL_ : BOOL_ ; }
public static RSAPrivateKey loadFromKeyStore ( URL keystoreUrl , String password ) throws IOException , NoSuchAlgorithmException , CertificateException , KeyStoreException , UnrecoverableKeyException { logger . debug ( STR_ , keystoreUrl ) ; URLConnection connection = keystoreUrl . openConnection ( ) ; InputStream is = connection . getInputStream ( ) ; try { if ( logger . isDebugEnabled ( ) ) logger . debug ( STR_ , Arrays . toString ( Security . getProviders ( ) ) ) ; KeyStore keyStore ; try { try { keyStore = KeyStore . getInstance ( STR_ , STR_ ) ; } catch ( NoSuchProviderException e ) { keyStore = KeyStore . getInstance ( STR_ , CryptoUtil . getSecurityProviderName ( KeyStore . class ) ) ; } } catch ( NoSuchProviderException e ) { keyStore = KeyStore . getInstance ( STR_ ) ; } logger . debug ( STR_ , keyStore . getProvider ( ) ) ; keyStore . load ( is , password == null ? null : password . toCharArray ( ) ) ; Enumeration < String > aliases = keyStore . aliases ( ) ; Key key = null ; while ( aliases . hasMoreElements ( ) ) { String a = ( String ) aliases . nextElement ( ) ; key = keyStore . getKey ( a , password == null ? null : password . toCharArray ( ) ) ; } return ( RSAPrivateKey ) key ; } finally { is . close ( ) ; } }
@ Override public double confSmallM ( double totalExampleWeight , double delta ) { double term = Math . log ( NUM_ / delta ) / ( NUM_ . totalExampleWeight ) ; return Math . sqrt ( term ) + Math . pow ( term , NUM_ ) + Math . pow ( term , NUM_ ) ; }
public static < T > boolean contains ( Iterator < T > iterator , T element ) { if ( iterator != null ) { while ( iterator . hasNext ( ) ) { T candidate = iterator . next ( ) ; if ( ObjectUtils . nullSafeEquals ( candidate , element ) ) return BOOL_ ; } } return BOOL_ ; }
public void testConstructor6 ( ) { Integer [ ] ints = new Integer [ SIZE ] ; for ( int i = NUM_ ; i < SIZE ; ++ i ) ints [ i ] = new Integer ( i ) ; LinkedBlockingQueue q = new LinkedBlockingQueue ( Arrays . asList ( ints ) ) ; for ( int i = NUM_ ; i < SIZE ; ++ i ) assertEquals ( ints [ i ] , q . poll ( ) ) ; }
@ Override public void drawDomainGridline ( Graphics2D g2 , CategoryPlot plot , Rectangle2D dataArea , double value ) { Line2D line = null ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation == PlotOrientation . HORIZONTAL ) { line = new Line2D . Double ( dataArea . getMinX ( ) , value , dataArea . getMaxX ( ) , value ) ; } else if ( orientation == PlotOrientation . VERTICAL ) { line = new Line2D . Double ( value , dataArea . getMinY ( ) , value , dataArea . getMaxY ( ) ) ; } Paint paint = plot . getDomainGridlinePaint ( ) ; if ( paint == null ) { paint = CategoryPlot . DEFAULT_GRIDLINE_PAINT ; } g2 . setPaint ( paint ) ; Stroke stroke = plot . getDomainGridlineStroke ( ) ; if ( stroke == null ) { stroke = CategoryPlot . DEFAULT_GRIDLINE_STROKE ; } g2 . setStroke ( stroke ) ; g2 . draw ( line ) ; }
public void addPreBuiltClassifier ( Classifier c ) { m_preBuiltClassifiers . add ( c ) ; }
@ Override public InsnList generate ( ) { return merge ( generatedInstructions . toArray ( ) ) ; }
public static void putJavaVariablesIntoEngine ( final ScriptEngine engine , final Map < String , Object > variables ) { final Bindings bindings = new SimpleBindings ( ) ; for ( String key : variables . keySet ( ) ) { bindings . put ( key , variables . get ( key ) ) ; } engine . setBindings ( bindings , ScriptContext . ENGINE_SCOPE ) ; }
private Point2D calculateLabelPoint ( Line2D line , RectangleAnchor anchor , double deltaX , double deltaY ) { double x , y ; boolean left = ( anchor == RectangleAnchor . BOTTOM_LEFT || anchor == RectangleAnchor . LEFT || anchor == RectangleAnchor . TOP_LEFT ) ; boolean right = ( anchor == RectangleAnchor . BOTTOM_RIGHT || anchor == RectangleAnchor . RIGHT || anchor == RectangleAnchor . TOP_RIGHT ) ; boolean top = ( anchor == RectangleAnchor . TOP_LEFT || anchor == RectangleAnchor . TOP || anchor == RectangleAnchor . TOP_RIGHT ) ; boolean bottom = ( anchor == RectangleAnchor . BOTTOM_LEFT || anchor == RectangleAnchor . BOTTOM || anchor == RectangleAnchor . BOTTOM_RIGHT ) ; Rectangle rect = line . getBounds ( ) ; if ( line . getX1 ( ) == line . getX2 ( ) ) { x = line . getX1 ( ) ; y = ( line . getY1 ( ) + line . getY2 ( ) ) / NUM_ ; if ( left ) { x = x - deltaX ; } if ( right ) { x = x + deltaX ; } if ( top ) { y = Math . min ( line . getY1 ( ) , line . getY2 ( ) ) + deltaY ; } if ( bottom ) { y = Math . max ( line . getY1 ( ) , line . getY2 ( ) ) - deltaY ; } } else { x = ( line . getX1 ( ) + line . getX2 ( ) ) / NUM_ ; y = line . getY1 ( ) ; if ( left ) { x = Math . min ( line . getX1 ( ) , line . getX2 ( ) ) + deltaX ; } if ( right ) { x = Math . max ( line . getX1 ( ) , line . getX2 ( ) ) - deltaX ; } if ( top ) { y = y - deltaY ; } if ( bottom ) { y = y + deltaY ; } } return new Point2D . Double ( x , y ) ; }
public void fling ( int startX , int startY , int velocityX , int velocityY , int minX , int maxX , int minY , int maxY ) { if ( mFlywheel && ! mFinished ) { float oldVel = getCurrVelocity ( ) ; float dx = ( float ) ( mFinalX - mStartX ) ; float dy = ( float ) ( mFinalY - mStartY ) ; float hyp = ( float ) Math . hypot ( dx , dy ) ; float ndx = dx / hyp ; float ndy = dy / hyp ; float oldVelocityX = ndx . oldVel ; float oldVelocityY = ndy . oldVel ; if ( Math . signum ( velocityX ) == Math . signum ( oldVelocityX ) && Math . signum ( velocityY ) == Math . signum ( oldVelocityY ) ) { velocityX += oldVelocityX ; velocityY += oldVelocityY ; } } mMode = FLING_MODE ; mFinished = BOOL_ ; float velocity = ( float ) Math . hypot ( velocityX , velocityY ) ; mVelocity = velocity ; mDuration = getSplineFlingDuration ( velocity ) ; mStartTime = AnimationUtils . currentAnimationTimeMillis ( ) ; mStartX = startX ; mStartY = startY ; float coeffX = velocity == NUM_ ? NUM_ : velocityX / velocity ; float coeffY = velocity == NUM_ ? NUM_ : velocityY / velocity ; double totalDistance = getSplineFlingDistance ( velocity ) ; mDistance = ( int ) ( totalDistance . Math . signum ( velocity ) ) ; mMinX = minX ; mMaxX = maxX ; mMinY = minY ; mMaxY = maxY ; mFinalX = startX + ( int ) Math . round ( totalDistance . coeffX ) ; mFinalX = Math . min ( mFinalX , mMaxX ) ; mFinalX = Math . max ( mFinalX , mMinX ) ; mFinalY = startY + ( int ) Math . round ( totalDistance . coeffY ) ; mFinalY = Math . min ( mFinalY , mMaxY ) ; mFinalY = Math . max ( mFinalY , mMinY ) ; }
public void deleteWithMissing ( Attribute att ) { deleteWithMissing ( att . index ( ) ) ; }
protected void sprint ( String a ) { if ( a == null ) { stringRepresentation += getIndentation ( ) ; stringRepresentation += STR_ ; return ; } if ( a . compareTo ( STR_ ) == NUM_ || a . compareTo ( STR_ ) == NUM_ ) { indentation -- ; } stringRepresentation += getIndentation ( ) ; stringRepresentation += a ; stringRepresentation += STR_ ; if ( a . compareTo ( STR_ ) == NUM_ || a . compareTo ( STR_ ) == NUM_ ) { indentation ++ ; } }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; if ( semIms == null ) { throw new NullPointerException ( ) ; } }
private static Pair < Long , Long > load ( ByteArray a , InputStream stream , long memoryOffset , long count , CommonIndex positions , CRC32 checksum , ByteArray checksums , PrereadHashFunction hf , boolean checksumsLoaded , long currentSeq ) throws IOException { long tmpCurrentSeq = currentSeq ; final byte [ ] buffer = new byte [ NUM_ . NUM_ ] ; long totalRead = NUM_ ; int bytesRead ; long pos = memoryOffset ; while ( totalRead < count && ( bytesRead = stream . read ( buffer , NUM_ , ( int ) Math . min ( count - totalRead , buffer . length ) ) ) != - NUM_ ) { a . set ( pos , buffer , bytesRead ) ; pos += bytesRead ; int j = NUM_ ; while ( j < bytesRead ) { if ( positions . get ( tmpCurrentSeq + NUM_ ) == positions . get ( tmpCurrentSeq ) ) { hf . irvineHash ( NUM_ ) ; tmpCurrentSeq ++ ; continue ; } final int len = ( int ) ( positions . get ( tmpCurrentSeq + NUM_ ) - ( memoryOffset + totalRead + j ) ) ; if ( j + len <= bytesRead ) { checksum . update ( buffer , j , len ) ; hf . irvineHash ( buffer , j , len ) ; hf . irvineHash ( positions . get ( tmpCurrentSeq + NUM_ ) - positions . get ( tmpCurrentSeq ) ) ; if ( checksumsLoaded ) { if ( ( byte ) checksum . getValue ( ) != checksums . get ( tmpCurrentSeq ) ) { throw new CorruptSdfException ( STR_ + tmpCurrentSeq + STR_ ) ; } } else { checksums . set ( tmpCurrentSeq , ( byte ) checksum . getValue ( ) ) ; } tmpCurrentSeq ++ ; checksum . reset ( ) ; } else { hf . irvineHash ( buffer , j , bytesRead - j ) ; checksum . update ( buffer , j , bytesRead - j ) ; } j += len ; } totalRead += bytesRead ; } return new Pair < > ( totalRead , tmpCurrentSeq ) ; }
public static java . sql . Date toSqlDate ( String monthStr , String dayStr , String yearStr ) { java . util . Date newDate = toDate ( monthStr , dayStr , yearStr , STR_ , STR_ , STR_ ) ; if ( newDate != null ) { return new java . sql . Date ( newDate . getTime ( ) ) ; } else { return null ; } }
public void removeSwipeListener ( SwipeListener listener ) { if ( mListeners == null ) { return ; } mListeners . remove ( listener ) ; }
protected void savePNGImage ( String filename , BufferedImage image ) throws IOException { File file = new File ( filename ) ; ImageIO . write ( image , STR_ , file ) ; }
public void unsetPermission ( String name ) { permissions . remove ( name . toLowerCase ( java . util . Locale . ENGLISH ) ) ; permissible . recalculatePermissions ( ) ; }
public void beforeInsert ( int index , byte element ) { if ( index > size || index < NUM_ ) throw new IndexOutOfBoundsException ( STR_ + index + STR_ + size ) ; ensureCapacity ( size + NUM_ ) ; System . arraycopy ( elements , index , elements , index + NUM_ , size - index ) ; elements [ index ] = element ; size ++ ; }
public OMGraphicList readCachedGraphics ( URL url ) throws java . io . IOException { if ( Debug . debugging ( STR_ ) ) { Debug . output ( STR_ ) ; } OMGraphicList omgraphics = new OMGraphicList ( ) ; if ( url != null ) { omgraphics . readGraphics ( url ) ; } return omgraphics ; }
int size ( ) { return noxItems . size ( ) ; }
public < V > Future < V > invoke ( String method , String path , Map < String , ? > arguments , ResultHandler < V > resultHandler ) { if ( method == null ) { throw new IllegalArgumentException ( ) ; } if ( path == null ) { throw new IllegalArgumentException ( ) ; } if ( arguments == null ) { throw new IllegalArgumentException ( ) ; } return executorService . submit ( new InvocationCallback < > ( method , path , arguments , resultHandler ) ) ; }
@ Override public String replacePath ( String inputURI ) { if ( inputURI . contains ( TemporaryDirectoryManager . DIRECTORY_TEMPLATE ) ) { return inputURI . replace ( TemporaryDirectoryManager . DIRECTORY_TEMPLATE , TEMPLATE_DIRECTORY_NAME ) ; } return inputURI ; }
@ Override public void create ( ) { assertWritable ( ) ; final String name = getNamespace ( ) + STR_ + NAME_SEARCH ; final IIndexManager indexManager = getIndexManager ( ) ; final Properties p = getProperties ( ) ; final IndexMetadata indexMetadata = new IndexMetadata ( indexManager , p , name , UUID . randomUUID ( ) , IndexTypeEnum . BTree ) ; final IKeyBuilderFactory keyBuilderFactory ; { final Properties tmp = new Properties ( p ) ; tmp . setProperty ( KeyBuilder . Options . STRENGTH , p . getProperty ( Options . INDEXER_COLLATOR_STRENGTH , Options . DEFAULT_INDEXER_COLLATOR_STRENGTH ) ) ; keyBuilderFactory = new DefaultKeyBuilderFactory ( tmp ) ; } final boolean fieldsEnabled = Boolean . parseBoolean ( p . getProperty ( Options . FIELDS_ENABLED , Options . DEFAULT_FIELDS_ENABLED ) ) ; if ( log . isInfoEnabled ( ) ) log . info ( Options . FIELDS_ENABLED + STR_ + fieldsEnabled ) ; indexMetadata . setTupleSerializer ( new FullTextIndexTupleSerializer < V > ( keyBuilderFactory , DefaultTupleSerializer . getDefaultLeafKeysCoder ( ) , EmptyRabaValueCoder . INSTANCE , fieldsEnabled ) ) ; indexManager . registerIndex ( indexMetadata ) ; if ( log . isInfoEnabled ( ) ) log . info ( STR_ + name ) ; }
public static PGPPublicKey mergeSignatures ( PGPPublicKey targetKey , PGPPublicKey sourceKey ) throws PGPException { if ( ! Objects . deepEquals ( targetKey . getFingerprint ( ) , sourceKey . getFingerprint ( ) ) ) { throw new IllegalArgumentException ( STR_ ) ; } return copySignatures ( targetKey , sourceKey ) ; }
private static boolean hasSpecializedHandlerIntents ( Context context , Intent intent ) { try { PackageManager pm = context . getPackageManager ( ) ; List < ResolveInfo > handlers = pm . queryIntentActivities ( intent , PackageManager . GET_RESOLVED_FILTER ) ; if ( handlers == null || handlers . size ( ) == NUM_ ) { return BOOL_ ; } for ( ResolveInfo resolveInfo : handlers ) { IntentFilter filter = resolveInfo . filter ; if ( filter == null ) continue ; if ( filter . countDataAuthorities ( ) == NUM_ || filter . countDataPaths ( ) == NUM_ ) continue ; if ( resolveInfo . activityInfo == null ) continue ; return BOOL_ ; } } catch ( RuntimeException e ) { Log . e ( TAG , STR_ ) ; } return BOOL_ ; }
public void drawBackground ( Graphics g ) { g . fillRect ( NUM_ , NUM_ , getWidth ( ) , getHeight ( ) ) ; }
public static double info ( int counts [ ] ) { int total = NUM_ ; double x = NUM_ ; for ( int j = NUM_ ; j < counts . length ; j ++ ) { x -= xlogx ( counts [ j ] ) ; total += counts [ j ] ; } return x + xlogx ( total ) ; }
public ComputeJobFailoverException ( Throwable cause ) { this ( cause . getMessage ( ) , cause ) ; }
public boolean hasNewerVersion ( ) { return latestStable . compareTo ( currentVersion ) > NUM_ ; }
@ Override public String format ( DateTimeFormatter formatter ) { Objects . requireNonNull ( formatter , STR_ ) ; return formatter . format ( this ) ; }
@ Override public void readNBT ( NBTTagCompound compound ) { super . readNBT ( compound ) ; if ( compound . hasKey ( STR_ ) ) { this . exhaustionTimer = compound . getInteger ( STR_ ) ; } if ( ! compound . hasKey ( STR_ ) ) { setFoodLevel ( getFoodLevel ( ) . NUM_ ) ; setSaturation ( NUM_ ) ; } if ( getFoodLevel ( ) > NUM_ ) setFoodLevel ( NUM_ ) ; if ( getSaturationLevel ( ) > NUM_ ) setSaturation ( NUM_ ) ; }
private static boolean verifyXML ( String fileName ) { SchemaFactory sf = SchemaFactory . newInstance ( W3C_XML_SCHEMA ) ; Source xsdFile = new StreamSource ( new File ( XSD_FILE_PATH ) ) ; Source xmlFile = new StreamSource ( new File ( fileName ) ) ; boolean validXML = BOOL_ ; try { Schema schema = sf . newSchema ( xsdFile ) ; Validator validator = schema . newValidator ( ) ; try { validator . validate ( xmlFile ) ; validXML = BOOL_ ; } catch ( IOException e ) { e . printStackTrace ( ) ; } if ( ! validXML ) { new IOException ( STR_ ) ; } } catch ( SAXException e ) { e . printStackTrace ( ) ; } return validXML ; }
private void needNewBuffer ( int newcount ) { if ( currentBufferIndex < buffers . size ( ) - NUM_ ) { filledBufferSum += currentBuffer . length ; currentBufferIndex ++ ; currentBuffer = buffers . get ( currentBufferIndex ) ; } else { int newBufferSize ; if ( currentBuffer == null ) { newBufferSize = newcount ; filledBufferSum = NUM_ ; } else { newBufferSize = Math . max ( currentBuffer . length << NUM_ , newcount - filledBufferSum ) ; filledBufferSum += currentBuffer . length ; } currentBufferIndex ++ ; currentBuffer = new byte [ newBufferSize ] ; buffers . add ( currentBuffer ) ; } }
private static void dualPivotQuicksort ( byte [ ] a , int left , int right ) { int sixth = ( right - left + NUM_ ) / NUM_ ; int e1 = left + sixth ; int e5 = right - sixth ; int e3 = ( left + right ) > > > NUM_ ; int e4 = e3 + sixth ; int e2 = e3 - sixth ; byte ae1 = a [ e1 ] , ae2 = a [ e2 ] , ae3 = a [ e3 ] , ae4 = a [ e4 ] , ae5 = a [ e5 ] ; if ( ae1 > ae2 ) { byte t = ae1 ; ae1 = ae2 ; ae2 = t ; } if ( ae4 > ae5 ) { byte t = ae4 ; ae4 = ae5 ; ae5 = t ; } if ( ae1 > ae3 ) { byte t = ae1 ; ae1 = ae3 ; ae3 = t ; } if ( ae2 > ae3 ) { byte t = ae2 ; ae2 = ae3 ; ae3 = t ; } if ( ae1 > ae4 ) { byte t = ae1 ; ae1 = ae4 ; ae4 = t ; } if ( ae3 > ae4 ) { byte t = ae3 ; ae3 = ae4 ; ae4 = t ; } if ( ae2 > ae5 ) { byte t = ae2 ; ae2 = ae5 ; ae5 = t ; } if ( ae2 > ae3 ) { byte t = ae2 ; ae2 = ae3 ; ae3 = t ; } if ( ae4 > ae5 ) { byte t = ae4 ; ae4 = ae5 ; ae5 = t ; } a [ e1 ] = ae1 ; a [ e3 ] = ae3 ; a [ e5 ] = ae5 ; byte pivot1 = ae2 ; a [ e2 ] = a [ left ] ; byte pivot2 = ae4 ; a [ e4 ] = a [ right ] ; int less = left + NUM_ ; int great = right - NUM_ ; boolean pivotsDiffer = ( pivot1 != pivot2 ) ; if ( pivotsDiffer ) { outer : for ( int k = less ; k <= great ; k ++ ) { byte ak = a [ k ] ; if ( ak < pivot1 ) { if ( k != less ) { a [ k ] = a [ less ] ; a [ less ] = ak ; } less ++ ; } else if ( ak > pivot2 ) { while ( a [ great ] > pivot2 ) { if ( great -- == k ) { break outer ; } } if ( a [ great ] < pivot1 ) { a [ k ] = a [ less ] ; a [ less ++ ] = a [ great ] ; a [ great -- ] = ak ; } else { a [ k ] = a [ great ] ; a [ great -- ] = ak ; } } } } else { for ( int k = less ; k <= great ; k ++ ) { byte ak = a [ k ] ; if ( ak == pivot1 ) { continue ; } if ( ak < pivot1 ) { if ( k != less ) { a [ k ] = a [ less ] ; a [ less ] = ak ; } less ++ ; } else { while ( a [ great ] > pivot1 ) { great -- ; } if ( a [ great ] < pivot1 ) { a [ k ] = a [ less ] ; a [ less ++ ] = a [ great ] ; a [ great -- ] = ak ; } else { a [ k ] = pivot1 ; a [ great -- ] = ak ; } } } } a [ left ] = a [ less - NUM_ ] ; a [ less - NUM_ ] = pivot1 ; a [ right ] = a [ great + NUM_ ] ; a [ great + NUM_ ] = pivot2 ; doSort ( a , left , less - NUM_ ) ; doSort ( a , great + NUM_ , right ) ; if ( ! pivotsDiffer ) { return ; } if ( less < e1 && great > e5 ) { while ( a [ less ] == pivot1 ) { less ++ ; } while ( a [ great ] == pivot2 ) { great -- ; } outer : for ( int k = less ; k <= great ; k ++ ) { byte ak = a [ k ] ; if ( ak == pivot2 ) { while ( a [ great ] == pivot2 ) { if ( great -- == k ) { break outer ; } } if ( a [ great ] == pivot1 ) { a [ k ] = a [ less ] ; a [ less ++ ] = pivot1 ; } else { a [ k ] = a [ great ] ; } a [ great -- ] = pivot2 ; } else if ( ak == pivot1 ) { a [ k ] = a [ less ] ; a [ less ++ ] = pivot1 ; } } } doSort ( a , less , great ) ; }
@ Nullable public N node ( @ Nullable Object key , @ Nullable Collection < N > inc ) { return node ( key , inc , null ) ; }
public void increment ( ) { counter . getAndIncrement ( ) ; }
public DefaultDeploymentCache ( ) { this . cache = Collections . synchronizedMap ( new HashMap < String , T > ( ) ) ; }
private int findInsertionPoint ( SortedListEntry entry ) { int insertionPoint = sortedModel . size ( ) ; if ( sortOrder != SortOrder . UNORDERED ) { insertionPoint = Collections . binarySearch ( ( List ) sortedModel , entry ) ; if ( insertionPoint < NUM_ ) { insertionPoint = - ( insertionPoint + NUM_ ) ; } } return insertionPoint ; }
private boolean haveShownMessageBefore ( UpdateMessage msg ) { if ( ! msg . isShownOnce ( ) ) return BOOL_ ; loadSeenMessages ( ) ; if ( _seenMessages == null || _seenMessages . size ( ) == NUM_ || ! _seenMessages . contains ( msg ) ) { if ( _seenMessages == null ) _seenMessages = new HashSet < > ( ) ; _seenMessages . add ( msg ) ; saveSeenMessages ( ) ; return BOOL_ ; } return BOOL_ ; }
public void dataSourceAdded ( int index ) { update ( ) ; updateCoordinateProjectionComboBoxes ( ) ; }
public boolean fieldIsStatic ( ) { return Modifier . isStatic ( field . getModifiers ( ) ) ; }
void newEquation ( DF_LatticeCell lhs , DF_Operator operator , DF_LatticeCell op1 , DF_LatticeCell op2 , DF_LatticeCell op3 ) { DF_Equation eq = new DF_Equation ( lhs , operator , op1 , op2 , op3 ) ; equations . addGraphNode ( eq ) ; equations . addGraphNode ( lhs ) ; equations . addGraphNode ( op1 ) ; equations . addGraphNode ( op2 ) ; equations . addGraphNode ( op3 ) ; newEquations . add ( eq ) ; op1 . addUse ( eq ) ; op2 . addUse ( eq ) ; op3 . addUse ( eq ) ; lhs . addDef ( eq ) ; if ( EAGER && eq . evaluate ( ) ) changedCell ( lhs ) ; }
@ Override public void stop ( ) { if ( stopping . compareAndSet ( BOOL_ , BOOL_ ) ) { if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + cacheName + STR_ ) ; wakeUp ( ) ; boolean graceful = BOOL_ ; for ( GridWorker worker : flushThreads ) graceful &= U . join ( worker , log ) ; if ( ! graceful ) log . warning ( STR_ ) ; } }
private Set < StoragePort > andStoragePortSets ( Set < StoragePort > a , Set < StoragePort > b ) { Set < StoragePort > result = new HashSet < StoragePort > ( ) ; for ( StoragePort port : a ) { if ( b . contains ( port ) ) { result . add ( port ) ; } } return result ; }
public static void addAttributeToSchema ( String serviceName , String subSchemaName , String schemaType , Node attributeSchemaNode , SSOToken adminToken ) throws UpgradeException { ServiceSchema ss = getServiceSchema ( serviceName , subSchemaName , schemaType , adminToken ) ; addAttributeToSchema ( ss , attributeSchemaNode ) ; }
public int next ( int current ) { for ( int i = current + NUM_ ; i < ( arguments != null ? arguments . size ( ) : NUM_ ) ; i ++ ) { if ( getArgument ( i ) instanceof MathContainer ) { return i ; } } throw new ArrayIndexOutOfBoundsException ( STR_ ) ; }
@ Override public boolean supportsAuthentication ( ) { if ( DEBUG . messageEnabled ( ) ) { DEBUG . message ( STR_ ) ; } return BOOL_ ; }
protected void reorderAppDeploymentsAfterConfigurationVersion ( Element domain ) { List < Element > appDeployments = xmlTool . selectElementsMatchingXPath ( STR_ , domain ) ; for ( Element appDeployment : appDeployments ) { domain . removeChild ( appDeployment ) ; } Element configurationVersion = xmlTool . selectElementMatchingXPath ( STR_ , domain ) ; Node before = null ; NodeList children = domain . getChildNodes ( ) ; for ( int i = NUM_ ; i < children . getLength ( ) ; i ++ ) { if ( configurationVersion . equals ( children . item ( i ) ) && i < children . getLength ( ) - NUM_ ) { before = children . item ( i + NUM_ ) ; } } if ( before != null ) { for ( Element appDeployment : appDeployments ) { domain . insertBefore ( appDeployment , before ) ; } } else { for ( Element appDeployment : appDeployments ) { domain . appendChild ( appDeployment ) ; } } }
public URI ( String scheme , String schemeSpecificPart , String fragment ) throws URISyntaxException { StringBuilder uri = new StringBuilder ( ) ; if ( scheme != null ) { uri . append ( scheme ) ; uri . append ( STR_ ) ; } if ( schemeSpecificPart != null ) { ALL_LEGAL_ENCODER . appendEncoded ( uri , schemeSpecificPart ) ; } if ( fragment != null ) { uri . append ( STR_ ) ; ALL_LEGAL_ENCODER . appendEncoded ( uri , fragment ) ; } parseURI ( uri . toString ( ) , BOOL_ ) ; }
static FacetMethod selectFacetMethod ( SchemaField field , FacetMethod method , Integer mincount ) { FieldType type = field . getType ( ) ; if ( method == null ) { if ( type instanceof BoolField && ( field . indexed ( ) == BOOL_ || field . hasDocValues ( ) == BOOL_ ) ) { method = FacetMethod . ENUM ; } else if ( type . getNumericType ( ) != null && ! field . multiValued ( ) ) { method = FacetMethod . FCS ; } else { method = FacetMethod . FC ; } } if ( method == FacetMethod . FC && type . getNumericType ( ) != null && ! field . multiValued ( ) ) { method = FacetMethod . FCS ; } if ( method == FacetMethod . UIF && ! field . hasDocValues ( ) && mincount == NUM_ ) { method = field . multiValued ( ) ? FacetMethod . FC : FacetMethod . FCS ; } if ( method == FacetMethod . ENUM && TrieField . getMainValuePrefix ( type ) != null ) { method = field . multiValued ( ) ? FacetMethod . FC : FacetMethod . FCS ; } final boolean multiToken = field . multiValued ( ) || type . multiValuedFieldCache ( ) ; if ( method == FacetMethod . FCS && multiToken ) { method = FacetMethod . FC ; } return method ; }
public void onTabsAllClosing ( long time , boolean incognito ) { }
public List < HashMap < String , Object > > clearOverallChat ( ) { try { List < HashMap < String , Object > > myChatList = myChats . get ( overallChatRoomName ) ; myChatList = new LinkedList < HashMap < String , Object > > ( ) ; myChats . put ( overallChatRoomName , myChatList ) ; Map < Integer , String > newMessage = new HashMap < Integer , String > ( ) ; newMessage . put ( NUM_ , STR_ ) ; scopeApplicationAdapter . sendMessageToMembers ( newMessage ) ; return myChatList ; } catch ( Exception err ) { log . error ( STR_ , err ) ; return null ; } }
public DbSchemaChanger beginChange ( ) throws Exception { backupFile = File . createTempFile ( STR_ , STR_ ) ; log . info ( STR_ , classFile . getAbsolutePath ( ) , backupFile . getAbsolutePath ( ) ) ; copyFile ( classFile , backupFile ) ; cc . defrost ( ) ; return this ; }
void animateChallengeTo ( int y , int velocity ) { if ( mChallengeView == null ) { return ; } cancelTransitionsInProgress ( ) ; mChallengeInteractiveInternal = BOOL_ ; mChallengeView . setLayerType ( LAYER_TYPE_HARDWARE , null ) ; final int sy = mChallengeView . getBottom ( ) ; final int dy = y - sy ; if ( dy == NUM_ ) { completeChallengeScroll ( ) ; return ; } setScrollState ( SCROLL_STATE_SETTLING ) ; final int childHeight = mChallengeView . getHeight ( ) ; final int halfHeight = childHeight / NUM_ ; final float distanceRatio = Math . min ( NUM_ , NUM_ . Math . abs ( dy ) / childHeight ) ; final float distance = halfHeight + halfHeight . distanceInfluenceForSnapDuration ( distanceRatio ) ; int duration = NUM_ ; velocity = Math . abs ( velocity ) ; if ( velocity > NUM_ ) { duration = NUM_ . Math . round ( NUM_ . Math . abs ( distance / velocity ) ) ; } else { final float childDelta = ( float ) Math . abs ( dy ) / childHeight ; duration = ( int ) ( ( childDelta + NUM_ ) . NUM_ ) ; } duration = Math . min ( duration , MAX_SETTLE_DURATION ) ; mScroller . startScroll ( NUM_ , sy , NUM_ , dy , duration ) ; postInvalidateOnAnimation ( ) ; }
public JcaX509v3CertificateBuilder ( X500Principal issuer , BigInteger serial , Date notBefore , Date notAfter , X500Principal subject , PublicKey publicKey ) { super ( X500Name . getInstance ( issuer . getEncoded ( ) ) , serial , notBefore , notAfter , X500Name . getInstance ( subject . getEncoded ( ) ) , SubjectPublicKeyInfo . getInstance ( publicKey . getEncoded ( ) ) ) ; }
private void writeGUIDValue ( ByteBuffer buffer , Object value ) throws IOException { Matcher m = GUID_PATTERN . matcher ( toCharSequence ( value ) ) ; if ( ! m . matches ( ) ) { throw new IOException ( withErrorContext ( STR_ + value ) ) ; } ByteBuffer origBuffer = null ; byte [ ] tmpBuf = null ; if ( buffer . order ( ) != ByteOrder . BIG_ENDIAN ) { origBuffer = buffer ; tmpBuf = new byte [ NUM_ ] ; buffer = ByteBuffer . wrap ( tmpBuf ) ; } ByteUtil . writeHexString ( buffer , m . group ( NUM_ ) ) ; ByteUtil . writeHexString ( buffer , m . group ( NUM_ ) ) ; ByteUtil . writeHexString ( buffer , m . group ( NUM_ ) ) ; ByteUtil . writeHexString ( buffer , m . group ( NUM_ ) ) ; ByteUtil . writeHexString ( buffer , m . group ( NUM_ ) ) ; if ( tmpBuf != null ) { ByteUtil . swap4Bytes ( tmpBuf , NUM_ ) ; ByteUtil . swap2Bytes ( tmpBuf , NUM_ ) ; ByteUtil . swap2Bytes ( tmpBuf , NUM_ ) ; origBuffer . put ( tmpBuf ) ; } }
public NeuronGroup ( final Network net , final List < Neuron > neurons ) { super ( net ) ; neuronList = new ArrayList < Neuron > ( neurons . size ( ) ) ; for ( Neuron neuron : neurons ) { addNeuron ( neuron ) ; } neuronList = new CopyOnWriteArrayList < Neuron > ( neuronList ) ; updateRule = getNeuronType ( ) ; resetSubsamplingIndices ( ) ; }
@ LogMessageDoc ( level = STR_ , message = STR_ , explanation = STR_ , recommendation = LogMessageDoc . REPORT_CONTROLLER_BUG ) public List < LDUpdate > applyUpdates ( ) { List < LDUpdate > appliedUpdates = new ArrayList < LDUpdate > ( ) ; LDUpdate update = null ; while ( ldUpdates . peek ( ) != null ) { try { update = ldUpdates . take ( ) ; } catch ( Exception e ) { log . error ( STR_ , e ) ; } if ( log . isTraceEnabled ( ) ) { log . trace ( STR_ , update ) ; } switch ( update . getOperation ( ) ) { case LINK_UPDATED : addOrUpdateLink ( update . getSrc ( ) , update . getSrcPort ( ) , update . getDst ( ) , update . getDstPort ( ) , update . getType ( ) ) ; break ; case LINK_REMOVED : removeLink ( update . getSrc ( ) , update . getSrcPort ( ) , update . getDst ( ) , update . getDstPort ( ) ) ; break ; case SWITCH_UPDATED : addOrUpdateSwitch ( update . getSrc ( ) ) ; break ; case SWITCH_REMOVED : removeSwitch ( update . getSrc ( ) ) ; break ; case TUNNEL_PORT_ADDED : addTunnelPort ( update . getSrc ( ) , update . getSrcPort ( ) ) ; break ; case TUNNEL_PORT_REMOVED : removeTunnelPort ( update . getSrc ( ) , update . getSrcPort ( ) ) ; break ; case PORT_UP : case PORT_DOWN : break ; } appliedUpdates . add ( update ) ; } return ( Collections . unmodifiableList ( appliedUpdates ) ) ; }
boolean isEmpty ( ) { return mDescription . isEmpty ( ) && mTypes . isEmpty ( ) ; }
private static boolean isStatic ( Method m ) { int mods = m . getModifiers ( ) ; return ( mods & Modifier . STATIC ) != NUM_ ; }
public synchronized boolean tryLock ( ) { try { lock = file . tryLock ( ) ; return lock != null ; } catch ( Exception e ) { return BOOL_ ; } }
@ Override public void nodeDown ( Topology topology , long eventUID , String nodeID ) { if ( targetServerID . equals ( nodeID ) ) { decideOnAction ( topology ) ; } }
public boolean isValid ( ) { return BOOL_ ; }
private void rolloverLogTask ( ) { try { if ( _isInit ) { flush ( ) ; } } catch ( Exception e ) { log . log ( Level . WARNING , e . toString ( ) , e ) ; } _isRollingOver = BOOL_ ; try { if ( ! _isInit ) return ; Path savedPath = null ; long now = CurrentTime . currentTime ( ) ; long lastPeriodEnd = _nextPeriodEnd ; _nextPeriodEnd = nextRolloverTime ( now ) ; Path path = getPath ( ) ; synchronized ( _logLock ) { flushTempStream ( ) ; long length = Files . size ( path ) ; if ( lastPeriodEnd <= now && lastPeriodEnd > NUM_ ) { closeLogStream ( ) ; savedPath = getSavedPath ( lastPeriodEnd - NUM_ ) ; } else if ( path != null && getRolloverSize ( ) <= length ) { closeLogStream ( ) ; savedPath = getSavedPath ( now ) ; } } if ( savedPath != null ) { movePathToArchive ( savedPath ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { synchronized ( _logLock ) { _isRollingOver = BOOL_ ; flushTempStream ( ) ; } _rolloverListener . requeue ( _rolloverAlarm ) ; } }
private void emitListAdd ( Method method , String fieldName , StringBuilder builder ) { builder . append ( STR_ ) ; builder . append ( getListAdderName ( fieldName ) ) ; builder . append ( STR_ ) ; builder . append ( getTypeArgumentImplName ( ( ParameterizedType ) method . getGenericReturnType ( ) , NUM_ ) ) ; builder . append ( STR_ ) ; builder . append ( getEnsureName ( fieldName ) ) ; builder . append ( STR_ ) ; builder . append ( fieldName ) ; builder . append ( STR_ ) ; builder . append ( STR_ ) ; }
public boolean onScrollChanged ( int scrollY ) { boolean isPullingDownNow = scrollY < lastScrollY ; latestPullingDown . offer ( isPullingDownNow ) ; if ( latestPullingDown . size ( ) > PULLING_DOWN_TIME_MAX ) { latestPullingDown . poll ( ) ; } lastScrollY = scrollY ; return getPullingDownTime ( ) >= PULLING_DOWN_TIME_THRESHOLD ; }
@ ExceptionHandler ( ConstraintViolationException . class ) @ ResponseStatus ( value = HttpStatus . BAD_REQUEST ) public Map < String , Object > handleConstraintViolationException ( ConstraintViolationException ex ) { Collection < FieldError > errors = FieldError . getErrors ( ex . getConstraintViolations ( ) ) ; log . warn ( STR_ + errors . toString ( ) ) ; return LemonUtil . mapOf ( STR_ , STR_ , STR_ , errors ) ; }
@ Override public void readExternal ( ObjectInput in ) throws IOException { b = new double [ in . readInt ( ) ] ; for ( int p = NUM_ ; p < b . length ; p ++ ) { b [ p ] = in . readDouble ( ) ; } }
private synchronized void addTracker ( String path , Object marker , FileDeleteStrategy deleteStrategy ) { if ( exitWhenFinished ) { throw new IllegalStateException ( STR_ ) ; } if ( reaper == null ) { reaper = new Reaper ( ) ; reaper . start ( ) ; } trackers . add ( new Tracker ( path , deleteStrategy , marker , q ) ) ; }
List < Issue > errors ( ) { return errors ; }
public AudioWife addOnCompletionListener ( OnCompletionListener listener ) { mCompletionListeners . add ( NUM_ , listener ) ; return this ; }
public void addVolumeToConsistencyGroup ( String instanceId , String cgID ) throws StorageCenterAPIException { RestResult rr = restClient . get ( String . format ( STR_ , instanceId ) ) ; if ( ! checkResults ( rr ) ) { throw new StorageCenterAPIException ( String . format ( STR_ , rr . getErrorMsg ( ) ) ) ; } ScVolumeConfiguration volConfig = gson . fromJson ( rr . getResult ( ) , ScVolumeConfiguration . class ) ; List < String > profiles = new ArrayList < > ( ) ; for ( ScObject profile : volConfig . replayProfileList ) { if ( ! cgID . equals ( profile . instanceId ) ) { profiles . add ( profile . instanceId ) ; } } profiles . add ( cgID ) ; Parameters params = new Parameters ( ) ; params . add ( STR_ , profiles . toArray ( new String [ NUM_ ] ) ) ; rr = restClient . put ( String . format ( STR_ , instanceId ) , params . toJson ( ) ) ; if ( ! checkResults ( rr ) ) { throw new StorageCenterAPIException ( String . format ( STR_ , rr . getErrorMsg ( ) ) ) ; } }
public static boolean isImplementsInterface ( Class clazz , Class interfaceClass ) { if ( ! ( interfaceClass . isInterface ( ) ) ) { throw new IllegalArgumentException ( STR_ ) ; } boolean resultThisClass = recursiveIsImplementsInterface ( clazz , interfaceClass ) ; if ( resultThisClass ) { return BOOL_ ; } return recursiveSuperclassImplementsInterface ( clazz , interfaceClass ) ; }
private static String replaceChars ( String str ) { StringBuffer buf = new StringBuffer ( str ) ; int length = buf . length ( ) ; for ( int i = NUM_ ; i < length ; i ++ ) { char currentChar = buf . charAt ( i ) ; if ( currentChar == STR_ ) { buf . setCharAt ( i , STR_ ) ; buf . insert ( i + NUM_ , STR_ ) ; length = length + NUM_ ; i = i + NUM_ ; } else if ( currentChar == STR_ ) { buf . setCharAt ( i , STR_ ) ; } } return buf . toString ( ) ; }
private void addBinding ( final String key , final Object value ) { m_bindings . put ( key , value ) ; }
public static < T extends Enum < T > > T forKey ( String key , Map < String , T > mapping , Class < T > enumeration ) { T t = mapping . get ( key ) ; if ( t != null ) { return t ; } throw new IllegalArgumentException ( STR_ + enumeration . toString ( ) + STR_ + key ) ; }
private ExchangeRate directLookup ( final Currency source , final Currency target , final Date date ) { if ( System . getProperty ( STR_ ) == null ) throw new UnsupportedOperationException ( STR_ ) ; ExchangeRate rate = null ; QL . require ( ( ( rate = fetch ( source , target , date ) ) != null ) , STR_ ) ; return rate ; }
protected static int findNextNewLineChar ( CharSequence s , int start ) { for ( int i = start ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == STR_ ) { return i ; } } return - NUM_ ; }
public SkypeBuilder withChat ( String id ) { if ( ! id . startsWith ( STR_ ) ) throw new IllegalArgumentException ( STR_ ) ; if ( password != null ) throw new IllegalArgumentException ( STR_ ) ; this . chatId = id ; return this ; }
public static int compareTo ( Object left , Object right ) { return compareToWithEqualityCheck ( left , right , BOOL_ ) ; }
public static X509CRLImpl toImpl ( X509CRL crl ) throws CRLException { if ( crl instanceof X509CRLImpl ) { return ( X509CRLImpl ) crl ; } else { return X509Factory . intern ( crl ) ; } }
public final void test_ROUNDTRIP_GetKeySpecKeyProvider02 ( ) { boolean performed = BOOL_ ; for ( int i = NUM_ ; i < algName . length ; i ++ ) { for ( int l = NUM_ ; l < provider . length ; l ++ ) { if ( provider [ l ] == null ) { continue ; } TestDataGenerator g ; try { g = new TestDataGenerator ( algName [ i ] [ NUM_ ] , algName [ i ] [ NUM_ ] , privateKeyInfoDamaged , provider [ l ] ) ; } catch ( TestDataGenerator . AllowedFailure allowedFailure ) { continue ; } try { EncryptedPrivateKeyInfo epki ; if ( g . ap ( ) == null ) { epki = new EncryptedPrivateKeyInfo ( algName [ i ] [ NUM_ ] , g . ct ( ) ) ; } else { epki = new EncryptedPrivateKeyInfo ( g . ap ( ) , g . ct ( ) ) ; } try { epki . getKeySpec ( g . pubK ( ) == null ? g . k ( ) : g . pubK ( ) , provider [ l ] ) ; fail ( algName [ i ] [ NUM_ ] + STR_ + algName [ i ] [ NUM_ ] ) ; } catch ( InvalidKeyException e ) { } performed = BOOL_ ; } catch ( NoSuchAlgorithmException allowedFailure ) { } } } assertTrue ( STR_ , performed ) ; }
public final synchronized void closeAll ( ) { if ( onCloseAll ( ) ) { Log . w ( TAG , STR_ ) ; return ; } LinkedList < Integer > ids = new LinkedList < Integer > ( ) ; for ( int id : getExistingIds ( ) ) { ids . add ( id ) ; } for ( int id : ids ) { close ( id ) ; } }
private static Pair < Character , Integer > normalizeCodepoint ( String origString_ , Charset encoding_ , int offset_ ) { char normalizedChar = STR_ ; boolean isOk = BOOL_ ; final int codepoint = origString_ . codePointAt ( offset_ ) ; if ( encoding_ . equals ( Charset . forName ( STR_ ) ) ) { if ( codepoint < NUM_ ) isOk = BOOL_ ; } else if ( encoding_ . equals ( Charset . forName ( STR_ ) ) ) { if ( codepoint < NUM_ ) isOk = BOOL_ ; } else if ( encoding_ . equals ( Charset . forName ( STR_ ) ) ) { if ( codepoint < NUM_ ) isOk = BOOL_ ; } if ( isOk ) { normalizedChar = ( char ) codepoint ; } else { isOk = BOOL_ ; final int type = Character . getType ( codepoint ) ; if ( type == Character . CURRENCY_SYMBOL ) normalizedChar = STR_ ; else if ( type == Character . DASH_PUNCTUATION ) normalizedChar = STR_ ; else if ( type == Character . FINAL_QUOTE_PUNCTUATION ) { normalizedChar = STR_ ; } else if ( type == Character . INITIAL_QUOTE_PUNCTUATION ) { normalizedChar = STR_ ; } else if ( type == Character . END_PUNCTUATION ) normalizedChar = STR_ ; else if ( type == Character . DASH_PUNCTUATION ) normalizedChar = STR_ ; else if ( type == Character . OTHER_LETTER ) normalizedChar = STR_ ; else if ( type == Character . OTHER_NUMBER ) normalizedChar = STR_ ; else if ( type == Character . OTHER_PUNCTUATION ) normalizedChar = STR_ ; else if ( type == Character . OTHER_SYMBOL ) normalizedChar = STR_ ; else isOk = BOOL_ ; } Character newChar = null ; if ( isOk ) newChar = normalizedChar ; return new Pair < > ( newChar , codepoint ) ; }
public void testPosNegFirstShorter ( ) { byte aBytes [ ] = { - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { - NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ } ; int aSign = NUM_ ; int bSign = - NUM_ ; byte rBytes [ ] = { - NUM_ , NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . or ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , - NUM_ , result . signum ( ) ) ; }
private boolean startRandomGame ( ) { AbstractLaunch [ ] pins = mCardAdapter . getLaunchers ( ) ; List < AbstractLaunch > games = new ArrayList < AbstractLaunch > ( pins . length ) ; for ( AbstractLaunch pin : pins ) { if ( pin . isGame ( ) ) { if ( pin . mState == AbstractLaunch . STATE_READY ) { games . add ( pin ) ; } } } if ( games . size ( ) > NUM_ ) { Random r = new Random ( ) ; int index = r . nextInt ( games . size ( ) ) ; AbstractLaunch game = games . get ( index ) ; Log . d ( TAG , String . format ( STR_ , game . mContentDescription ) ) ; game . onClick ( game . getClickTarget ( ) ) ; MeasurementManager . recordCustomEvent ( mMeasurement , getString ( R . string . analytics_event_category_launch ) , getString ( R . string . analytics_launch_action_voice ) , game . mContentDescription ) ; AnalyticsManager . sendEvent ( R . string . analytics_event_category_launch , R . string . analytics_launch_action_voice , game . mContentDescription ) ; return BOOL_ ; } else { return BOOL_ ; } }
public void initDiskCache ( ) { synchronized ( mDiskCacheLock ) { if ( mDiskLruCache == null || mDiskLruCache . isClosed ( ) ) { File diskCacheDir = mCacheParams . diskCacheDir ; if ( mCacheParams . diskCacheEnabled && diskCacheDir != null ) { if ( ! diskCacheDir . exists ( ) ) { diskCacheDir . mkdirs ( ) ; } if ( getUsableSpace ( diskCacheDir ) > mCacheParams . diskCacheSize ) { try { mDiskLruCache = DiskLruCache . open ( diskCacheDir , NUM_ , NUM_ , mCacheParams . diskCacheSize ) ; if ( BuildConfig . DEBUG ) { Log . d ( TAG , STR_ ) ; } } catch ( final IOException e ) { mCacheParams . diskCacheDir = null ; Log . e ( TAG , STR_ + e ) ; } } } } mDiskCacheStarting = BOOL_ ; mDiskCacheLock . notifyAll ( ) ; } }
boolean isRegisteredPermission ( Permission permission ) ;
public static int compare ( String id1 , String id2 ) { int result = - NUM_ ; String seed1 = IdGenerator . getSeedFromId ( id1 ) ; String seed2 = IdGenerator . getSeedFromId ( id2 ) ; if ( seed1 != null && seed2 != null ) { result = seed1 . compareTo ( seed2 ) ; if ( result == NUM_ ) { long count1 = IdGenerator . getSequenceFromId ( id1 ) ; long count2 = IdGenerator . getSequenceFromId ( id2 ) ; result = ( int ) ( count1 - count2 ) ; } } return result ; }
public static Element addChildElementNSElement ( Element element , String childElementName , Document document , String nameSpaceUrl ) { Element newElement = document . createElementNS ( nameSpaceUrl , childElementName ) ; element . appendChild ( newElement ) ; return element ; }
public VNXeCommandResult modifyConsistencyGroupSync ( String id , LunGroupModifyParam param ) { StringBuilder urlBld = new StringBuilder ( URL_MODIFY1 ) ; urlBld . append ( id ) ; urlBld . append ( URL_MODIFY2 ) ; _url = urlBld . toString ( ) ; return postRequestSync ( param ) ; }
protected Query finishQuery ( BooleanQuery . Builder in , boolean allTermsRequired ) { return in . build ( ) ; }
public long sum ( ) { long sum = NUM_ ; for ( AtomicLong value : map . values ( ) ) { sum = sum + value . get ( ) ; } return sum ; }
public void testNegPosFirstShorter ( ) { byte aBytes [ ] = { - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { - NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ } ; int aSign = - NUM_ ; int bSign = NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . and ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
private void pullEvent ( ) { final int newScrollValue ; final int itemDimension ; final float initialMotionValue , lastMotionValue ; switch ( getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : initialMotionValue = mInitialMotionX ; lastMotionValue = mLastMotionX ; break ; case VERTICAL : default : initialMotionValue = mInitialMotionY ; lastMotionValue = mLastMotionY ; break ; } switch ( mCurrentMode ) { case PULL_FROM_END : newScrollValue = Math . round ( Math . max ( initialMotionValue - lastMotionValue , NUM_ ) / FRICTION ) ; itemDimension = getFooterSize ( ) ; break ; case PULL_FROM_START : default : newScrollValue = Math . round ( Math . min ( initialMotionValue - lastMotionValue , NUM_ ) / FRICTION ) ; itemDimension = getHeaderSize ( ) ; break ; } setHeaderScroll ( newScrollValue ) ; if ( newScrollValue != NUM_ && ! isRefreshing ( ) ) { float scale = Math . abs ( newScrollValue ) / ( float ) itemDimension ; switch ( mCurrentMode ) { case PULL_FROM_END : mFooterLayout . onPull ( scale ) ; break ; case PULL_FROM_START : default : mHeaderLayout . onPull ( scale ) ; break ; } if ( mState != State . PULL_TO_REFRESH && itemDimension >= Math . abs ( newScrollValue ) ) { setState ( State . PULL_TO_REFRESH ) ; } else if ( mState == State . PULL_TO_REFRESH && itemDimension < Math . abs ( newScrollValue ) ) { setState ( State . RELEASE_TO_REFRESH ) ; } } }
public static String extractFullStackTrace ( Throwable e ) { StringWriter stringWriter = new StringWriter ( ) ; PrintWriter printWriter = new PrintWriter ( stringWriter ) ; e . printStackTrace ( printWriter ) ; return stringWriter . toString ( ) ; }
public EmptyTileFactory ( TileFactoryInfo info ) { super ( info ) ; int tileSize = info . getTileSize ( info . getMinimumZoomLevel ( ) ) ; emptyTile = new BufferedImage ( tileSize , tileSize , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g = emptyTile . createGraphics ( ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setColor ( Color . GRAY ) ; g . fillRect ( NUM_ , NUM_ , tileSize , tileSize ) ; g . setColor ( Color . WHITE ) ; g . drawOval ( NUM_ , NUM_ , tileSize - NUM_ , tileSize - NUM_ ) ; g . fillOval ( NUM_ , NUM_ , NUM_ , NUM_ ) ; g . fillOval ( tileSize - NUM_ , NUM_ , NUM_ , NUM_ ) ; g . fillOval ( tileSize / NUM_ - NUM_ , tileSize / NUM_ - NUM_ , NUM_ , NUM_ ) ; g . dispose ( ) ; }
public static void i ( String tag , String msg , Object ... args ) { if ( sLevel > LEVEL_INFO ) { return ; } if ( args . length > NUM_ ) { msg = String . format ( msg , args ) ; } Log . i ( tag , msg ) ; }
public void close ( ) throws IOException { guard . close ( ) ; RandomAccessFile localRaf = raf ; if ( localRaf != null ) { synchronized ( localRaf ) { raf = null ; localRaf . close ( ) ; } if ( fileToDeleteOnClose != null ) { fileToDeleteOnClose . delete ( ) ; fileToDeleteOnClose = null ; } } }
public boolean matchWithRegEx ( String aRegEx ) { if ( TextUtils . isEmpty ( aRegEx ) ) { return BOOL_ ; } boolean matched = BOOL_ ; if ( ! TextUtils . isEmpty ( mDisplayName ) ) { matched = mDisplayName . matches ( aRegEx ) ; } if ( ! matched ) { for ( String email : mEmails ) { matched |= email . matches ( aRegEx ) ; } } return matched ; }
public String stemString ( String str ) { StringBuffer result = new StringBuffer ( ) ; int start = - NUM_ ; for ( int j = NUM_ ; j < str . length ( ) ; j ++ ) { char c = str . charAt ( j ) ; if ( Character . isLetterOrDigit ( c ) ) { if ( start == - NUM_ ) { start = j ; } } else if ( c == STR_ ) { if ( start == - NUM_ ) { result . append ( c ) ; } } else { if ( start != - NUM_ ) { result . append ( stem ( str . substring ( start , j ) ) ) ; start = - NUM_ ; } result . append ( c ) ; } } if ( start != - NUM_ ) { result . append ( stem ( str . substring ( start , str . length ( ) ) ) ) ; } return result . toString ( ) ; }
public static List < Integer > parseNumericList ( String string ) { ArrayList < Integer > list = new ArrayList < > ( ) ; Pattern ranges = Pattern . compile ( STR_ ) ; Matcher m = ranges . matcher ( string ) ; while ( m . find ( ) ) { String range = m . group ( STR_ ) ; string = string . replace ( range , STR_ ) ; parseNumericRange ( range , list ) ; } String [ ] numbers = string . split ( STR_ ) ; for ( int i = NUM_ ; i < numbers . length ; ++ i ) { String number = numbers [ i ] ; if ( ! number . isEmpty ( ) ) { list . add ( Integer . valueOf ( number ) ) ; } } Collections . sort ( list ) ; return list ; }
protected void savePassCodeAndExit ( ) { Intent resultIntent = new Intent ( ) ; resultIntent . putExtra ( KEY_PASSCODE , mPassCodeDigits [ NUM_ ] + mPassCodeDigits [ NUM_ ] + mPassCodeDigits [ NUM_ ] + mPassCodeDigits [ NUM_ ] ) ; setResult ( RESULT_OK , resultIntent ) ; finish ( ) ; }
public static void readFully ( FileChannel file , long pos , ByteBuffer dst ) { try { do { int len = file . read ( dst , pos ) ; if ( len < NUM_ ) { throw new EOFException ( ) ; } pos += len ; } while ( dst . remaining ( ) > NUM_ ) ; dst . rewind ( ) ; } catch ( IOException e ) { long size ; try { size = file . size ( ) ; } catch ( IOException e2 ) { size = - NUM_ ; } throw newIllegalStateException ( ERROR_READING_FAILED , STR_ + STR_ , file , size , dst . remaining ( ) , pos , e ) ; } }
private static void sparseFullRepresentationTest ( final ISchemaVersion schemaVersion ) throws IOException { final Writer output = openOutput ( schemaVersion , STR_ , TestType . UNION ) ; final HLL emptyHLL1 = newHLL ( HLLType . EMPTY ) ; final HLL emptyHLL2 = newHLL ( HLLType . EMPTY ) ; cumulativeUnionLine ( output , emptyHLL1 , emptyHLL2 , schemaVersion ) ; final HLL fullHLL = newHLL ( HLLType . FULL ) ; fullHLL . addRaw ( constructHLLValue ( LOG2M , NUM_ , NUM_ ) ) ; final HLL sparseHLL = newHLL ( HLLType . SPARSE ) ; sparseHLL . addRaw ( constructHLLValue ( LOG2M , NUM_ , NUM_ ) ) ; output . write ( stringCardinality ( fullHLL ) + STR_ + toByteA ( fullHLL , schemaVersion ) + STR_ + stringCardinality ( sparseHLL ) + STR_ + toByteA ( sparseHLL , schemaVersion ) + STR_ ) ; output . flush ( ) ; final HLL fullHLL2 = newHLL ( HLLType . FULL ) ; fullHLL2 . addRaw ( constructHLLValue ( LOG2M , NUM_ , NUM_ ) ) ; sparseHLL . addRaw ( constructHLLValue ( LOG2M , NUM_ , NUM_ ) ) ; output . write ( stringCardinality ( fullHLL2 ) + STR_ + toByteA ( fullHLL2 , schemaVersion ) + STR_ + stringCardinality ( sparseHLL ) + STR_ + toByteA ( sparseHLL , schemaVersion ) + STR_ ) ; output . flush ( ) ; final HLL fullHLL3 = newHLL ( HLLType . FULL ) ; for ( int i = NUM_ ; i < ( SPARSE_THRESHOLD + NUM_ ) ; i ++ ) { fullHLL3 . addRaw ( constructHLLValue ( LOG2M , i , NUM_ ) ) ; sparseHLL . addRaw ( constructHLLValue ( LOG2M , i , NUM_ ) ) ; } output . write ( stringCardinality ( fullHLL3 ) + STR_ + toByteA ( fullHLL3 , schemaVersion ) + STR_ + stringCardinality ( sparseHLL ) + STR_ + toByteA ( sparseHLL , schemaVersion ) + STR_ ) ; output . flush ( ) ; }
public void triggerCycle ( ) { lock . lock ( ) ; triggerCount ++ ; contextsParked = NUM_ ; lock . broadcast ( ) ; lock . unlock ( ) ; }
protected boolean heapifyDownComparator ( final int ipos , Object cur ) { int pos = ipos ; final int half = size > > > NUM_ ; while ( pos < half ) { int min = pos ; Object best = cur ; final int lchild = ( pos << NUM_ ) + NUM_ ; Object left = queue [ lchild ] ; if ( comparator . compare ( best , left ) > NUM_ ) { min = lchild ; best = left ; } final int rchild = lchild + NUM_ ; if ( rchild < size ) { Object right = queue [ rchild ] ; if ( comparator . compare ( best , right ) > NUM_ ) { min = rchild ; best = right ; } } if ( min == pos ) { break ; } queue [ pos ] = best ; pos = min ; } queue [ pos ] = cur ; return ( pos != ipos ) ; }
public static boolean isString ( String str ) { return ( ( str . startsWith ( STR_ ) && str . endsWith ( STR_ ) ) || ( str . startsWith ( STR_ ) && str . endsWith ( STR_ ) ) ) && str . length ( ) > NUM_ ; }
static public boolean hasPhoto ( Tweet tweet ) { return getPhotoEntity ( tweet ) != null ; }
public void testCase19 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte rBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = BigInteger . ZERO ; BigInteger result = aNumber . add ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public static StringBuilder formatTo ( StringBuilder buf , long [ ] d , String sep ) { if ( d == null ) { return buf . append ( STR_ ) ; } if ( d . length == NUM_ ) { return buf ; } buf . append ( d [ NUM_ ] ) ; for ( int i = NUM_ ; i < d . length ; i ++ ) { buf . append ( sep ) ; buf . append ( d [ i ] ) ; } return buf ; }
public static < T > int upperBound ( final List < T > valueList , int fromIdx , int toIdx , final Comparable < T > value ) { int len = toIdx - fromIdx + ( toIdx > fromIdx ? NUM_ : NUM_ ) ; int from = fromIdx ; int half ; int middle ; while ( len > NUM_ ) { half = len > > NUM_ ; middle = from ; middle = middle + half ; if ( value . compareTo ( valueList . get ( middle ) ) == - NUM_ ) { len = half ; } else { from = middle ; from ++ ; len = len - half - NUM_ ; } } return from ; }
public int size ( ) { return data . size ( ) ; }
public static synchronized void registerAdditionalHyphenationFileDirectory ( String directory ) { if ( additionalHyphenationFileDirectories == null ) { additionalHyphenationFileDirectories = new ArrayList < > ( ) ; } additionalHyphenationFileDirectories . add ( directory ) ; }
private void insertNewDriveFiles ( ) throws IOException { Cursor cursor = null ; try { cursor = myTracksProviderUtils . getTrackCursor ( SyncUtils . NO_DRIVE_ID_TRACKS_QUERY , null , null ) ; long recordingTrackId = PreferencesUtils . getLong ( context , R . string . recording_track_id_key ) ; if ( cursor != null && cursor . moveToFirst ( ) ) { do { Track track = myTracksProviderUtils . createTrack ( cursor ) ; if ( track . getId ( ) == recordingTrackId ) { continue ; } SyncUtils . insertDriveFile ( drive , folderId , context , myTracksProviderUtils , track , BOOL_ , BOOL_ ) ; } while ( cursor . moveToNext ( ) ) ; } } finally { if ( cursor != null ) { cursor . close ( ) ; } } }
public void testHandle_normalCompletion ( ) { for ( ExecutionMode m : ExecutionMode . values ( ) ) for ( boolean createIncomplete : new boolean [ ] { BOOL_ , BOOL_ } ) for ( Integer v1 : new Integer [ ] { NUM_ , null } ) { final CompletableFuture < Integer > f = new CompletableFuture < > ( ) ; final AtomicInteger a = new AtomicInteger ( NUM_ ) ; if ( ! createIncomplete ) assertTrue ( f . complete ( v1 ) ) ; final CompletableFuture < Integer > g = m . handle ( f , null ) ; if ( createIncomplete ) assertTrue ( f . complete ( v1 ) ) ; checkCompletedNormally ( g , inc ( v1 ) ) ; checkCompletedNormally ( f , v1 ) ; assertEquals ( NUM_ , a . get ( ) ) ; } }
private static String unescape ( String s ) { int len = s . length ( ) , base = NUM_ , idx ; String escapes = STR_ ; String chars = STR_ ; StringBuffer sbuf = null ; while ( ( idx = s . indexOf ( STR_ , base ) ) != - NUM_ ) { if ( sbuf != null ) sbuf . append ( s . substring ( base , idx ) ) ; if ( idx + NUM_ == len ) break ; char c = s . charAt ( idx + NUM_ ) ; int cidx = escapes . indexOf ( c ) ; if ( cidx == - NUM_ ) { sbuf . append ( STR_ ) ; sbuf . append ( c ) ; } else { if ( sbuf == null ) sbuf = new StringBuffer ( s . substring ( base , idx ) ) ; sbuf . append ( chars . charAt ( cidx ) ) ; } base = idx + NUM_ ; } if ( sbuf != null && base < len ) sbuf . append ( s . substring ( base ) ) ; return ( sbuf == null ? s : sbuf . toString ( ) ) ; }
public static void put ( String dbgToken ) { dbgTable . put ( dbgToken , Boolean . TRUE ) ; }
public boolean removeDataSet ( T d ) { if ( d == null ) return BOOL_ ; boolean removed = mDataSets . remove ( d ) ; if ( removed ) { mYValCount -= d . getEntryCount ( ) ; mYValueSum -= d . getYValueSum ( ) ; calcMinMax ( mDataSets ) ; } return removed ; }
public long reservedStore ( ) { return m_size . m_totalSlots ; }
public Transfer writeString ( String s ) throws IOException { if ( s == null ) { out . writeInt ( - NUM_ ) ; } else { int len = s . length ( ) ; out . writeInt ( len ) ; for ( int i = NUM_ ; i < len ; i ++ ) { out . writeChar ( s . charAt ( i ) ) ; } } return this ; }
private void fillInsideDraw ( Graphics g , int x , int y , int w , int h ) { g . setColor ( Color . BLACK ) ; g . drawRect ( x , y , w , h ) ; g . setColor ( Color . LIGHT_GRAY ) ; g . fillRect ( x + NUM_ , y + NUM_ , w - NUM_ , h - NUM_ ) ; }
public DrawerBuilder addStickyDrawerItems ( @ NonNull IDrawerItem ... stickyDrawerItems ) { if ( this . mStickyDrawerItems == null ) { this . mStickyDrawerItems = new ArrayList < > ( ) ; } Collections . addAll ( this . mStickyDrawerItems , stickyDrawerItems ) ; return this ; }
public void appendToBuffer ( StringBuilder buf ) { Iterator < Polygon > iter = polygons . iterator ( ) ; while ( iter . hasNext ( ) ) { Polygon poly = iter . next ( ) ; poly . appendToBuffer ( buf ) ; if ( iter . hasNext ( ) ) { buf . append ( STR_ ) ; } } }
public void addFunction ( FunctionInterface activeFunction ) { functions . add ( activeFunction ) ; }
public static Charset toCharset ( Charset charset ) { return charset == null ? Charset . defaultCharset ( ) : charset ; }
public < T extends DataObject > Joiner join ( Class < T > clazz , String alias ) { if ( ! jClasses . isEmpty ( ) ) { throw new JoinerException ( STR_ ) ; } JClass jc = new JClass ( clazz , alias , jClasses . size ( ) ) ; jClasses . add ( jc ) ; lastJClass = jc ; aliasMap . put ( alias , jc ) ; return this ; }
public ByteVector putByteArray ( final byte [ ] b , final int off , final int len ) { if ( length + len > data . length ) { enlarge ( len ) ; } if ( b != null ) { System . arraycopy ( b , off , data , length , len ) ; } length += len ; return this ; }
public static void showProgressBar ( int status , int i ) { if ( mRootView != null ) { ProgressBar pb = ( ProgressBar ) mRootView . findViewById ( R . id . progress_slice ) ; TextView tv = ( TextView ) mRootView . findViewById ( R . id . viewer_text_progress_slice ) ; TextView tve = ( TextView ) mRootView . findViewById ( R . id . viewer_text_estimated_time ) ; TextView tve_title = ( TextView ) mRootView . findViewById ( R . id . viewer_estimated_time_textview ) ; if ( mSlicingHandler . getLastReference ( ) != null ) { tve_title . setVisibility ( View . VISIBLE ) ; pb . setVisibility ( View . VISIBLE ) ; switch ( status ) { case StateUtils . SLICER_HIDE : if ( i < NUM_ ) { tv . setText ( R . string . error ) ; } else { tv . setText ( R . string . viewer_text_downloaded ) ; } pb . setVisibility ( View . INVISIBLE ) ; break ; case StateUtils . SLICER_UPLOAD : String uploadText = mContext . getString ( R . string . viewer_text_uploading ) ; if ( i == NUM_ ) pb . setIndeterminate ( BOOL_ ) ; else { pb . setProgress ( i ) ; pb . setIndeterminate ( BOOL_ ) ; uploadText += STR_ + i + STR_ ; } tv . setText ( uploadText ) ; tve . setText ( null ) ; break ; case StateUtils . SLICER_SLICE : String slicingText = mContext . getString ( R . string . viewer_text_slicing ) ; if ( i == NUM_ ) { pb . setIndeterminate ( BOOL_ ) ; } else if ( i == NUM_ ) { pb . setIndeterminate ( BOOL_ ) ; pb . setProgress ( NUM_ ) ; slicingText += STR_ + mContext . getString ( R . string . viewer_text_done ) ; } else { pb . setProgress ( i ) ; pb . setIndeterminate ( BOOL_ ) ; slicingText += STR_ + i + STR_ ; } tv . setText ( slicingText ) ; tve . setText ( null ) ; mRootView . invalidate ( ) ; break ; case StateUtils . SLICER_DOWNLOAD : if ( i > NUM_ ) { tve . setText ( OctoprintConnection . ConvertSecondToHHMMString ( String . valueOf ( i ) ) ) ; } tv . setText ( R . string . viewer_text_downloading ) ; pb . setIndeterminate ( BOOL_ ) ; break ; default : break ; } } else { pb . setVisibility ( View . INVISIBLE ) ; tve_title . setVisibility ( View . INVISIBLE ) ; tv . setText ( null ) ; tve . setText ( null ) ; mRootView . invalidate ( ) ; } } }
public LaunchOption ( Version version , Authenticator authenticator , MinecraftDirectory minecraftDir ) { Objects . requireNonNull ( version ) ; Objects . requireNonNull ( authenticator ) ; Objects . requireNonNull ( minecraftDir ) ; this . version = version ; this . authenticator = authenticator ; this . minecraftDirectory = minecraftDir ; this . runtimeDirectory = minecraftDir ; this . javaEnvironment = JavaEnvironment . current ( ) ; }
protected boolean isStoppable ( ) { return ( isRunning ( ) && getLocator ( ) != null ) ; }
public void load ( String fileName ) throws Exception { if ( ! fileName . endsWith ( STR_ ) && ! fileName . endsWith ( STR_ ) ) { throw new Exception ( STR_ + STR_ ) ; } if ( fileName . endsWith ( STR_ ) ) { loadBinary ( fileName ) ; } else if ( fileName . endsWith ( STR_ ) ) { loadXML ( fileName ) ; } }
public Bindings addOptComponent ( String property , Class clazz , JToggleButton c , boolean enabledByDefault ) { Binding b = new OptComponentBinding ( this , property , clazz , c , enabledByDefault ) ; if ( _optComponents . containsKey ( property ) ) { throw new BindingException ( Messages . getString ( STR_ ) ) ; } _optComponents . put ( property , b ) ; return this ; }
public static boolean copyFile ( File file , File copy ) { if ( file == null || copy == null ) throw new NullPointerException ( STR_ ) ; if ( ! file . isFile ( ) || copy . isDirectory ( ) ) throw new IllegalArgumentException ( STR_ ) ; FileInputStream fis = null ; FileOutputStream fos = null ; try { fis = new FileInputStream ( file ) ; fos = new FileOutputStream ( copy ) ; int bytes ; byte [ ] packet = new byte [ COPY_PACKET_SIZE ] ; while ( ( bytes = fis . read ( packet , NUM_ , COPY_PACKET_SIZE ) ) != - NUM_ ) fos . write ( packet , NUM_ , bytes ) ; return BOOL_ ; } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , STR_ , e ) ; return BOOL_ ; } finally { try { if ( fos != null ) fos . close ( ) ; } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , STR_ , e ) ; } try { if ( fis != null ) fis . close ( ) ; } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , STR_ , e ) ; } } }
public static byte [ ] encryptMySQLPassword ( String password , byte [ ] seed ) { if ( password == null || password . equals ( STR_ ) ) { return new byte [ NUM_ ] ; } MessageDigest digest = null ; try { digest = MessageDigest . getInstance ( STR_ ) ; } catch ( NoSuchAlgorithmException e ) { logger . error ( STR_ , e ) ; return new byte [ NUM_ ] ; } byte [ ] stage1_hash = digest . digest ( password . getBytes ( ) ) ; digest . reset ( ) ; byte [ ] sha1_stage1 = digest . digest ( stage1_hash ) ; digest . reset ( ) ; digest . update ( seed ) ; digest . update ( sha1_stage1 ) ; byte [ ] finalSha1 = digest . digest ( ) ; byte [ ] token = new byte [ finalSha1 . length ] ; for ( int i = NUM_ ; i < finalSha1 . length ; i ++ ) { token [ i ] = ( byte ) ( stage1_hash [ i ] ^ finalSha1 [ i ] ) ; } return token ; }
protected void addUrl ( URL url ) { if ( urls . contains ( url ) ) { LOGGER . info ( STR_ + url ) ; return ; } urls . add ( url ) ; LOGGER . info ( STR_ + url ) ; }
private int [ ] defineNumeric ( Random random ) { int [ ] num = new int [ getNumAttributes ( ) ] ; for ( int i = NUM_ ; i < num . length ; i ++ ) { num [ i ] = Attribute . NOMINAL ; } int numNum = NUM_ ; for ( int i = NUM_ ; ( numNum < getNumNumeric ( ) ) && ( i < getNumAttributes ( ) . NUM_ ) ; i ++ ) { int maybeNext = ( int ) ( random . nextDouble ( ) . num . length ) ; if ( num [ maybeNext ] != Attribute . NUMERIC ) { num [ maybeNext ] = Attribute . NUMERIC ; numNum ++ ; } } return num ; }
public static boolean isFavoriteStation ( Context context , int iStation ) { return isStationExist ( context , iStation , STATION_TYPE_FAVORITE ) ; }
protected void paintCaption ( Graphics g , Rectangle rect ) { String s = getTargetLabel ( ) ; if ( s . equals ( STR_ ) ) { return ; } g . setFont ( getTargetFont ( ) ) ; FontMetrics fm = g . getFontMetrics ( ) ; String str = getTargetLabel ( ) ; int width = fm . stringWidth ( str ) ; int textx = rect . x + ( rect . width - width ) / NUM_ ; int texty = rect . y + CAPTION_MARGIN_TOP + fm . getAscent ( ) ; int sepy = rect . y + rect . height - CAPTION_SEPARATOR_HEIGHT / NUM_ ; g . setColor ( isTargetEnabled ( ) ? getForegroundColor ( ) : getDisabledColor ( ) ) ; g . drawString ( s , textx , texty ) ; draw3DRect ( g , rect . x , sepy , rect . width , NUM_ , BOOL_ ) ; }
private static boolean hasSpecializedHandlerIntents ( Context context , Intent intent ) { try { PackageManager pm = context . getPackageManager ( ) ; List < ResolveInfo > handlers = pm . queryIntentActivities ( intent , PackageManager . GET_RESOLVED_FILTER ) ; if ( handlers == null || handlers . size ( ) == NUM_ ) { return BOOL_ ; } for ( ResolveInfo resolveInfo : handlers ) { IntentFilter filter = resolveInfo . filter ; if ( filter == null ) continue ; if ( filter . countDataAuthorities ( ) == NUM_ || filter . countDataPaths ( ) == NUM_ ) continue ; if ( resolveInfo . activityInfo == null ) continue ; return BOOL_ ; } } catch ( RuntimeException e ) { Log . e ( TAG , STR_ ) ; } return BOOL_ ; }
public void putFloat ( float x ) { bb . putFloat ( space -= NUM_ , x ) ; }
final void putInt ( int offset , int value ) { unsafe . putInt ( offset + address , value ) ; }
private static boolean isUnreservedCharacter ( char p_char ) { return ( isAlphanum ( p_char ) || MARK_CHARACTERS . indexOf ( p_char ) != - NUM_ ) ; }
public static InetSocketAddress parseSocketAddress ( String addr ) { String [ ] parts = addr . split ( COLON ) ; Preconditions . checkArgument ( parts . length == NUM_ ) ; String hostname = parts [ NUM_ ] ; int port = Integer . parseInt ( parts [ NUM_ ] ) ; return new InetSocketAddress ( hostname , port ) ; }
@ Override public void writeExternal ( ObjectOutput out ) throws IOException { super . writeExternal ( out ) ; out . writeObject ( approximation ) ; }
public Object [ ] toArray ( ) { final Object [ ] items = this . items ; final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { final int count = this . count ; Object [ ] a = new Object [ count ] ; int n = items . length - takeIndex ; if ( count <= n ) { System . arraycopy ( items , takeIndex , a , NUM_ , count ) ; } else { System . arraycopy ( items , takeIndex , a , NUM_ , n ) ; System . arraycopy ( items , NUM_ , a , n , count - n ) ; } return a ; } finally { lock . unlock ( ) ; } }
public void messageArrived ( MqttPublish sendMessage ) { final String methodName = STR_ ; if ( mqttCallback != null || callbacks . size ( ) > NUM_ ) { synchronized ( spaceAvailable ) { while ( running && ! quiescing && messageQueue . size ( ) >= INBOUND_QUEUE_SIZE ) { try { log . fine ( CLASS_NAME , methodName , STR_ ) ; spaceAvailable . wait ( NUM_ ) ; } catch ( InterruptedException ex ) { } } } if ( ! quiescing ) { messageQueue . addElement ( sendMessage ) ; synchronized ( workAvailable ) { log . fine ( CLASS_NAME , methodName , STR_ ) ; workAvailable . notifyAll ( ) ; } } } }
private void findHome ( ) { String home = System . getProperty ( STR_ ) ; if ( home == null ) home = System . getProperty ( STR_ ) ; if ( home == null ) home = System . getProperty ( STR_ ) ; if ( home == null ) home = System . getProperty ( STR_ ) ; if ( home != null ) manifestPath = home + File . separator + STR_ + File . separator + manifestFileName ; else manifestPath = manifestFileName ; }
public static final int [ ] toIntArray ( String s [ ] ) { int u [ ] = new int [ s . length ] ; for ( int j = NUM_ ; j < s . length ; j ++ ) { u [ j ] = Integer . parseInt ( s [ j ] ) ; } return u ; }
private List < String > checkAllColumnsInCube ( CubeInstance cube , TableDesc table , Map < String , HiveTableMeta . HiveTableColumnMeta > fieldsMap ) { Set < ColumnDesc > usedColumns = Sets . newHashSet ( ) ; for ( TblColRef col : cube . getAllColumns ( ) ) { usedColumns . add ( col . getColumnDesc ( ) ) ; } List < String > violateColumns = Lists . newArrayList ( ) ; for ( ColumnDesc column : table . getColumns ( ) ) { if ( usedColumns . contains ( column ) ) { HiveTableMeta . HiveTableColumnMeta field = fieldsMap . get ( column . getName ( ) ) ; if ( field == null || ! isColumnCompatible ( column , field ) ) { violateColumns . add ( column . getName ( ) ) ; } } } return violateColumns ; }
public static String makeUnifiedLineFeeds ( String query ) { if ( query . indexOf ( STR_ ) == - NUM_ ) { return query ; } StringBuilder result = new StringBuilder ( query . length ( ) ) ; for ( int i = NUM_ ; i < query . length ( ) ; i ++ ) { char c = query . charAt ( i ) ; if ( c == STR_ ) { continue ; } result . append ( c ) ; } return result . toString ( ) ; }
private void reflectMemberVariablesInLeftButton ( ) { final boolean lastPageReached = ( viewPager . getCurrentItem ( ) + NUM_ ) == pages . size ( ) ; final boolean buttonShouldBeInvisible = ( lastPageReached && disableLeftButtonOnLastPage ) || leftButtonDisabled ; final boolean buttonIsCurrentlyInvisible = leftButton . getVisibility ( ) == View . INVISIBLE ; final boolean shouldUpdateButton = buttonShouldBeInvisible != buttonIsCurrentlyInvisible ; if ( shouldUpdateButton ) { final Animator buttonAnimator = buttonShouldBeInvisible ? buttonAnimatorFactory . newLeftButtonDisappearAnimator ( leftButton ) : buttonAnimatorFactory . newLeftButtonAppearAnimator ( leftButton ) ; if ( buttonShouldBeInvisible ) { disableButton ( buttonAnimator , leftButton ) ; } else { enableButton ( buttonAnimator , leftButton ) ; } } }
public static void registerSemiDisposableBlock ( String oreDictName ) { semiDisposableBlocks . add ( oreDictName ) ; }
public boolean acceptsTypeName ( String type ) { return _typeList . contains ( type ) ; }
public void deleteAsync ( final String id , final FutureCallback < Task > responseCallback ) throws IOException { deleteObjectAsync ( id , responseCallback ) ; }
private boolean continueAfterAcceptFailure ( Throwable t ) { RMIFailureHandler fh = RMISocketFactory . getFailureHandler ( ) ; if ( fh != null ) { return fh . failure ( t instanceof Exception ? ( Exception ) t : new InvocationTargetException ( t ) ) ; } else { throttleLoopOnException ( ) ; return BOOL_ ; } }
private static void processPackage ( String tbName , Packages pkg ) { String classNamePrefix = StringUtil . parseHumpName ( tbName , BOOL_ , isHumpModelClass ) ; pkg . setDao ( packagePrefix + ( StringUtil . isEmpty ( packagePrefix ) || StringUtil . isEmpty ( packageDao ) ? STR_ : STR_ ) + packageDao ) ; pkg . setDaoName ( classNamePrefix + daoSuffix ) ; pkg . setModel ( packagePrefix + ( StringUtil . isEmpty ( packagePrefix ) || StringUtil . isEmpty ( packageModel ) ? STR_ : STR_ ) + packageModel ) ; pkg . setModelName ( classNamePrefix + modelSuffix ) ; pkg . setMapperXml ( packagePrefix + ( StringUtil . isEmpty ( packagePrefix ) || StringUtil . isEmpty ( packageMapperXml ) ? STR_ : STR_ ) + packageMapperXml ) ; pkg . setMapperXmlName ( classNamePrefix + mapperXmlSuffix ) ; pkg . setModelNameLowerFirst ( StringUtil . lowerFirst ( pkg . getModelName ( ) ) ) ; }
public void addOnCentralPositionChangedListener ( OnCentralPositionChangedListener listener ) { mOnCentralPositionChangedListeners . add ( listener ) ; }
public boolean addCall ( String sourceClass , String sourceMethod , String targetClass , String targetMethod ) { CallGraphEntry from = new CallGraphEntry ( targetClass , targetMethod ) ; CallGraphEntry to = new CallGraphEntry ( sourceClass , sourceMethod ) ; if ( sourceClass . equals ( className ) ) cutNodes . add ( to ) ; if ( ! graph . containsEdge ( from , to ) ) { graph . addEdge ( from , to ) ; callGraphClasses . add ( targetClass . replaceAll ( STR_ , STR_ ) ) ; return BOOL_ ; } return BOOL_ ; }
private static void doThreadDump ( final HttpServletRequest req , final HttpServletResponse resp ) throws IOException { resp . setStatus ( HTTP_OK ) ; resp . addHeader ( STR_ , STR_ ) ; resp . setContentType ( MIME_TEXT_PLAIN ) ; final PrintWriter w = resp . getWriter ( ) ; try { BigdataStatics . threadDump ( w ) ; w . flush ( ) ; } catch ( Throwable t ) { launderThrowable ( t , resp , STR_ ) ; } finally { w . close ( ) ; } }
public static boolean isValidNmtoken ( String nmtoken ) { final int length = nmtoken . length ( ) ; if ( length == NUM_ ) { return BOOL_ ; } for ( int i = NUM_ ; i < length ; ++ i ) { char ch = nmtoken . charAt ( i ) ; if ( ! isName ( ch ) ) { return BOOL_ ; } } return BOOL_ ; }
public MMRoll ( MMRandom rng ) { super ( NUM_ , NUM_ ) ; this . total = rng . randomInt ( this . faces ) + this . min ; all . addElement ( this . total ) ; }
public void handleButton3Request ( RequestInvocationEvent event ) throws ModelControlException { returnToHomePage ( ) ; }
static < T > UnixStream < T > unixify ( final Stream < T > stream ) { Objects . requireNonNull ( stream , STR_ ) ; return new UnixStreamImpl < > ( stream ) ; }
@ Deprecated public MediaFile ( File f ) { this ( f . toPath ( ) , null ) ; }
public static KeyStore load ( File keyStoreFile , Password password , KeyStoreType keyStoreType ) throws CryptoException , FileNotFoundException { if ( ! keyStoreType . isFileBased ( ) ) { throw new CryptoException ( MessageFormat . format ( res . getString ( STR_ ) , keyStoreType . jce ( ) ) ) ; } FileInputStream fis = new FileInputStream ( keyStoreFile ) ; KeyStore keyStore = getKeyStoreInstance ( keyStoreType ) ; try { keyStore . load ( fis , password . toCharArray ( ) ) ; } catch ( CertificateException ex ) { throw new KeyStoreLoadException ( MessageFormat . format ( res . getString ( STR_ ) , keyStoreType ) , ex , keyStoreType ) ; } catch ( NoSuchAlgorithmException ex ) { throw new KeyStoreLoadException ( MessageFormat . format ( res . getString ( STR_ ) , keyStoreType ) , ex , keyStoreType ) ; } catch ( FileNotFoundException ex ) { throw ex ; } catch ( IOException ex ) { throw new KeyStoreLoadException ( MessageFormat . format ( res . getString ( STR_ ) , keyStoreType ) , ex , keyStoreType ) ; } finally { IOUtils . closeQuietly ( fis ) ; } return keyStore ; }
public static String addToCartBulk ( HttpServletRequest request , HttpServletResponse response ) { String categoryId = request . getParameter ( STR_ ) ; ShoppingCart cart = getCartObject ( request ) ; Delegator delegator = ( Delegator ) request . getAttribute ( STR_ ) ; LocalDispatcher dispatcher = ( LocalDispatcher ) request . getAttribute ( STR_ ) ; ShoppingCartHelper cartHelper = new ShoppingCartHelper ( delegator , dispatcher , cart ) ; String controlDirective ; Map < String , Object > result ; Map < String , Object > paramMap = UtilHttp . getParameterMap ( request ) ; String catalogId = CatalogWorker . getCurrentCatalogId ( request ) ; result = cartHelper . addToCartBulk ( catalogId , categoryId , paramMap ) ; controlDirective = processResult ( result , request ) ; if ( controlDirective . equals ( ERROR ) ) { return STR_ ; } else { return STR_ ; } }
public void dumpLog ( String containerId , File logFile ) throws DockerException , InterruptedException { LogStream errorStream = null ; FileChannel fileChannel = null ; FileOutputStream fileOutputStream = null ; try { if ( logFile . exists ( ) ) { logFile . delete ( ) ; } logFile . createNewFile ( ) ; fileOutputStream = new FileOutputStream ( logFile ) ; fileChannel = fileOutputStream . getChannel ( ) ; errorStream = dockerClient . logs ( containerId , LogsParam . stderr ( ) ) ; while ( errorStream . hasNext ( ) ) { LogMessage message = errorStream . next ( ) ; ByteBuffer buffer = message . content ( ) ; fileChannel . write ( buffer ) ; } } catch ( FileNotFoundException e ) { throw new DockerException ( STR_ + logFile + STR_ ) ; } catch ( IOException e ) { throw new DockerException ( e ) ; } finally { if ( errorStream != null ) { errorStream . close ( ) ; } if ( fileChannel != null ) { try { fileChannel . close ( ) ; } catch ( IOException e ) { logger . error ( STR_ , e ) ; } } if ( fileOutputStream != null ) { try { fileOutputStream . close ( ) ; } catch ( IOException e ) { logger . error ( STR_ , e ) ; } } } }
public static final void warning ( String message , Throwable e ) { if ( message == null && e != null ) { message = e . getMessage ( ) ; } logExpensive ( Level . WARNING , message , e ) ; }
public static IndexedImage pack ( int [ ] rgb , int width , int height ) { int arrayLength = width . height ; int [ ] tempPalette = new int [ NUM_ ] ; int paletteLocation = NUM_ ; for ( int iter = NUM_ ; iter < arrayLength ; iter ++ ) { int current = rgb [ iter ] ; if ( ! contains ( tempPalette , paletteLocation , current ) ) { if ( paletteLocation > NUM_ ) { return null ; } tempPalette [ paletteLocation ] = current ; paletteLocation ++ ; } } if ( paletteLocation != tempPalette . length ) { int [ ] newArray = new int [ paletteLocation ] ; System . arraycopy ( tempPalette , NUM_ , newArray , NUM_ , paletteLocation ) ; tempPalette = newArray ; } IndexedImage i = new IndexedImage ( width , height , tempPalette , rgb ) ; return i ; }
public void addHint ( Component hintComponent , Component destinationComponent , String position ) { hintComponent . putClientProperty ( POS , position ) ; hintComponent . putClientProperty ( DEST , destinationComponent ) ; vec . addElement ( hintComponent ) ; }
public static int convertSRGBtoLinearRGB ( int color ) { float input , output ; input = color / NUM_ ; if ( input <= NUM_ ) { output = input / NUM_ ; } else { output = ( float ) Math . pow ( ( input + NUM_ ) / NUM_ , NUM_ ) ; } return Math . round ( output . NUM_ ) ; }
public void vetoableChange ( PropertyChangeEvent evt ) throws PropertyVetoException { log . info ( evt . toString ( ) ) ; throw new PropertyVetoException ( STR_ , evt ) ; }
private void writeAttribute ( java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( namespace . equals ( STR_ ) ) { xmlWriter . writeAttribute ( attName , attValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } }
public void finish ( ) throws SQLException { Statement statement = connection . createStatement ( ) ; statement . execute ( STR_ ) ; statement . close ( ) ; statement = connection . createStatement ( ) ; statement . execute ( STR_ ) ; statement . close ( ) ; statement = connection . createStatement ( ) ; statement . execute ( STR_ ) ; statement . close ( ) ; statement = connection . createStatement ( ) ; statement . execute ( STR_ ) ; statement . close ( ) ; }
@ Override public boolean contains ( Object object ) { return indexOf ( object , NUM_ ) != - NUM_ ; }
public void put ( E item ) throws InterruptedException { if ( ! done . get ( ) ) { queue . put ( item ) ; } }
public AuthorizationCode ( String code , String resourceOwnerId , String clientId , String redirectUri , Set < String > scope , String claims , long expiryTime , String nonce , String realm , String authModules , String acr , String ssoTokenId , String codeChallenge , String codeChallengeMethod , String authGrantId , String auditId ) { super ( new HashMap < String , Object > ( ) ) ; setStringProperty ( ID , code ) ; setStringProperty ( USERNAME , resourceOwnerId ) ; setStringProperty ( CLIENT_ID , clientId ) ; setStringProperty ( REDIRECT_URI , redirectUri ) ; setStringProperty ( EXPIRE_TIME , String . valueOf ( expiryTime ) ) ; put ( SCOPE , newList ( scope ) ) ; setStringProperty ( TOKEN_TYPE , STR_ ) ; setStringProperty ( TOKEN_NAME , OAUTH_CODE_TYPE ) ; setStringProperty ( NONCE , nonce ) ; setStringProperty ( AUTH_MODULES , authModules ) ; setStringProperty ( ACR , acr ) ; setStringProperty ( CODE_CHALLENGE , codeChallenge ) ; setStringProperty ( CODE_CHALLENGE_METHOD , codeChallengeMethod ) ; setStringProperty ( AUTH_GRANT_ID , authGrantId ) ; setStringProperty ( REALM , realm == null || realm . isEmpty ( ) ? STR_ : realm ) ; setStringProperty ( SSO_TOKEN_ID , ssoTokenId ) ; put ( CLAIMS , CollectionUtils . asList ( claims ) ) ; setStringProperty ( AUDIT_TRACKING_ID , auditId ) ; }
@ Override public Object draw ( Graphics2D g2 , Rectangle2D area , Object params ) { draw ( g2 , area ) ; return null ; }
public void testSetBitPositiveInside3 ( ) { byte aBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int number = NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger result = aNumber . setBit ( number ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public boolean isRowVisible ( int row ) { if ( row != - NUM_ ) { Rectangle cellRect = getCellRect ( row , NUM_ , BOOL_ ) ; Rectangle visibleRect = getVisibleRect ( ) ; return visibleRect . intersects ( cellRect ) ; } else return BOOL_ ; }
public void signalEvent ( ) { Collection < Semaphore > semaphores = _semaphores . values ( ) ; for ( Semaphore semaphore : semaphores ) { semaphore . release ( ) ; semaphores . remove ( semaphore ) ; } }
public static int fileInTimeRange ( File f , Date start , Date end ) { long time = getFileTime ( f ) ; if ( start != null && time < start . getTime ( ) ) { return - NUM_ ; } if ( end != null && time > end . getTime ( ) ) { return NUM_ ; } return NUM_ ; }
private float interpolate ( ) { long currTime = System . currentTimeMillis ( ) ; float elapsed = ( currTime - startTime ) / ZOOM_TIME ; elapsed = Math . min ( NUM_ , elapsed ) ; return interpolator . getInterpolation ( elapsed ) ; }
public Object extFunction ( String ns , String funcName , Vector argVec , Object methodKey , ExpressionContext exprContext ) throws javax . xml . transform . TransformerException { Object result = null ; if ( null != ns ) { ExtensionHandler extNS = ( ExtensionHandler ) m_extensionFunctionNamespaces . get ( ns ) ; if ( null != extNS ) { try { result = extNS . callFunction ( funcName , argVec , methodKey , exprContext ) ; } catch ( javax . xml . transform . TransformerException e ) { throw e ; } catch ( Exception e ) { throw new javax . xml . transform . TransformerException ( e ) ; } } else { throw new XPathProcessorException ( XSLMessages . createMessage ( XSLTErrorResources . ER_EXTENSION_FUNC_UNKNOWN , new Object [ ] { ns , funcName } ) ) ; } } return result ; }
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m_buildThread . isAlive ( ) && m_state != IDLE ) { wait ( ) ; } } catch ( InterruptedException ex ) { } } else { notifyAll ( ) ; } }
public Set < Resource > onClass ( ) { Set < Resource > targets = new HashSet < > ( ) ; for ( OwlClass c : qcClasses ) { targets . add ( c . getURI ( ) ) ; } return targets ; }
public static int indexOfChars ( String str , String chars , int fromIndex ) { final int len = str . length ( ) ; for ( int pos = fromIndex ; pos < len ; pos ++ ) { if ( chars . indexOf ( str . charAt ( pos ) ) >= NUM_ ) { return pos ; } } return - NUM_ ; }
private synchronized void notifyZoomListeners ( ZoomEvent e ) { for ( ZoomListener listener : mZoomListeners ) { listener . zoomApplied ( e ) ; } }
public static String buildStringFromLines ( String ... lines ) { int numChars = lines . length ; for ( String line : lines ) { numChars += line . length ( ) ; } StringBuilder builder = new StringBuilder ( numChars ) ; for ( String line : lines ) { builder . append ( line ) ; builder . append ( STR_ ) ; } return builder . toString ( ) ; }
public void init ( ) { if ( mContext == null ) { return ; } if ( mName . isEmpty ( ) ) { mName = mContext . getPackageName ( ) ; } if ( mMode == INVALID_VALUE || ( mMode != MODE_PRIVATE && mMode != MODE_WORLD_READABLE && mMode != MODE_WORLD_WRITEABLE ) ) { mMode = MODE_PRIVATE ; } mSharedPreferences = mContext . getSharedPreferences ( mName , mMode ) ; }
@ Override public void mergeAndOutputTransformationMetadata ( Iterator < DistinctValue > values , String outputDir , int colID , FileSystem fs , TfUtils agents ) throws IOException { double min = Double . MAX_VALUE ; double max = - Double . MAX_VALUE ; int nbins = NUM_ ; DistinctValue val = new DistinctValue ( ) ; String w = null ; double d ; while ( values . hasNext ( ) ) { val . reset ( ) ; val = values . next ( ) ; w = val . getWord ( ) ; if ( w . startsWith ( MIN_PREFIX ) ) { d = UtilFunctions . parseToDouble ( w . substring ( MIN_PREFIX . length ( ) ) ) ; if ( d < min ) min = d ; } else if ( w . startsWith ( MAX_PREFIX ) ) { d = UtilFunctions . parseToDouble ( w . substring ( MAX_PREFIX . length ( ) ) ) ; if ( d > max ) max = d ; } else if ( w . startsWith ( NBINS_PREFIX ) ) { nbins = ( int ) UtilFunctions . parseToLong ( w . substring ( NBINS_PREFIX . length ( ) ) ) ; } else throw new RuntimeException ( STR_ + w ) ; } double binwidth = ( max - min ) / nbins ; writeTfMtd ( colID , Double . toString ( min ) , Double . toString ( max ) , Double . toString ( binwidth ) , Integer . toString ( nbins ) , outputDir , fs , agents ) ; }
static SQLWarning convertShowWarningsToSQLWarnings ( Connection connection ) throws SQLException { return convertShowWarningsToSQLWarnings ( connection , NUM_ , BOOL_ ) ; }
public boolean hasEmptyRow ( ) { if ( m_dataVector . size ( ) == NUM_ ) { return BOOL_ ; } List < String > dataRow = m_dataVector . get ( m_dataVector . size ( ) - NUM_ ) ; for ( String s : dataRow ) { if ( s . length ( ) != NUM_ ) { return BOOL_ ; } } return BOOL_ ; }
public synchronized byte [ ] toByteArray ( ) { int remaining = count ; if ( remaining == NUM_ ) { return EMPTY_BYTE_ARRAY ; } byte newbuf [ ] = new byte [ remaining ] ; int pos = NUM_ ; for ( byte [ ] buf : buffers ) { int c = Math . min ( buf . length , remaining ) ; System . arraycopy ( buf , NUM_ , newbuf , pos , c ) ; pos += c ; remaining -= c ; if ( remaining == NUM_ ) { break ; } } return newbuf ; }
public Node selectSingleNode ( Node contextNode , String str , Node namespaceNode ) throws TransformerException { NodeIterator nl = selectNodeIterator ( contextNode , str , namespaceNode ) ; return nl . nextNode ( ) ; }
private static String javaScriptEscapeHelper ( String s , boolean escapeToAscii ) { StringBuilder sb = new StringBuilder ( s . length ( ) . NUM_ / NUM_ ) ; for ( int i = NUM_ ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; switch ( c ) { case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : appendHexJavaScriptRepresentation ( sb , c ) ; break ; case STR_ : case STR_ : boolean isUnsafe = BOOL_ ; for ( String tag : UNSAFE_TAGS ) { if ( s . regionMatches ( BOOL_ , i + NUM_ , tag , NUM_ , tag . length ( ) ) ) { isUnsafe = BOOL_ ; break ; } } if ( isUnsafe ) { appendHexJavaScriptRepresentation ( sb , c ) ; } else { sb . append ( c ) ; } break ; case STR_ : if ( sb . length ( ) > NUM_ && sb . charAt ( sb . length ( ) - NUM_ ) == STR_ ) { sb . append ( STR_ ) ; } sb . append ( c ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; default : if ( c >= NUM_ && escapeToAscii ) { appendHexJavaScriptRepresentation ( sb , c ) ; } else { sb . append ( c ) ; } } } return sb . toString ( ) ; }
public synchronized void add ( String category , double value ) { mCategories . add ( category ) ; mValues . add ( value ) ; }
public final void walkGraph ( Hashtable semNodesTable ) { Integer uid = new Integer ( myUID ) ; if ( semNodesTable . get ( uid ) != null ) return ; semNodesTable . put ( uid , this ) ; if ( assumeExpr != null ) { assumeExpr . walkGraph ( semNodesTable ) ; } ; }
private List < ValueComboBoxDataGroup > populateSymbolList ( Class < ? > panelDetails ) { List < ValueComboBoxDataGroup > combinedSymbolList = new ArrayList < ValueComboBoxDataGroup > ( ) ; for ( FieldState panel : symbolTypeFieldList ) { panel . populateSymbolList ( panelDetails , combinedSymbolList ) ; } return combinedSymbolList ; }
@ Override public int hashCode ( ) { long value = NUM_ ; value += NUM_ . value + Double . doubleToLongBits ( Math . abs ( x ) ) ; value += NUM_ . value + Double . doubleToLongBits ( Math . abs ( y ) ) ; return ( int ) ( value ^ ( value > > > NUM_ ) ) ; }
public void disconnect ( ) { socket . disconnect ( ) ; }
protected void initComponentDefaults ( UIDefaults table ) { super . initComponentDefaults ( table ) ; Color c = table . getColor ( STR_ ) ; table . put ( STR_ , c ) ; table . put ( STR_ , c ) ; }
public int indexOfColumnName ( String columnName ) { return columnNameList . indexOf ( columnName . toLowerCase ( ) ) ; }
public boolean clear ( T expect , boolean allowReset ) { sync . lock ( ) ; try { if ( expect != value ) { return BOOL_ ; } ValueState prev = state ; clear ( allowReset ) ; return prev == ValueState . SET ; } finally { sync . unlock ( ) ; } }
public void copyStream ( InputStream is ) throws IOException { super . setContentEncoding ( null ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; while ( BOOL_ ) { int b = is . read ( ) ; if ( b == - NUM_ ) { content = baos . toByteArray ( ) ; is . close ( ) ; return ; } } }
public void test_readResolve ( ) { MockAttributedCharacterIteratorAttribute mac1 = new MockAttributedCharacterIteratorAttribute ( STR_ ) ; try { mac1 . readResolve ( ) ; fail ( STR_ ) ; } catch ( InvalidObjectException e ) { } ObjectOutputStream out = null ; ObjectInputStream in = null ; try { ByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; out = new ObjectOutputStream ( bytes ) ; AttributedCharacterIterator . Attribute attr1 , attr2 ; attr1 = AttributedCharacterIterator . Attribute . LANGUAGE ; out . writeObject ( attr1 ) ; in = new ObjectInputStream ( new ByteArrayInputStream ( bytes . toByteArray ( ) ) ) ; try { attr2 = ( AttributedCharacterIterator . Attribute ) in . readObject ( ) ; assertSame ( STR_ , attr1 , attr2 ) ; } catch ( IllegalArgumentException e ) { fail ( STR_ + e ) ; } } catch ( IOException e ) { fail ( STR_ + e ) ; } catch ( ClassNotFoundException e ) { fail ( STR_ + e ) ; } finally { try { if ( out != null ) out . close ( ) ; if ( in != null ) in . close ( ) ; } catch ( IOException e ) { } } }
public void interrupt ( ) { Thread t = threadVar . get ( ) ; if ( t != null ) { t . interrupt ( ) ; } threadVar . clear ( ) ; }
public final boolean isSecure ( Socket sock ) throws IllegalArgumentException { if ( sock == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( sock . getClass ( ) != Socket . class ) { throw new IllegalArgumentException ( STR_ ) ; } if ( sock . isClosed ( ) ) { throw new IllegalArgumentException ( STR_ ) ; } return BOOL_ ; }
protected boolean checkList ( String currentVal , String tokenValue ) { if ( currentVal == null || tokenValue == null ) { throw new NullPointerException ( STR_ ) ; } if ( ! currentVal . startsWith ( STR_ ) && ! currentVal . startsWith ( STR_ ) ) { throw new IllegalArgumentException ( STR_ ) ; } boolean negation = currentVal . startsWith ( STR_ ) ; String listName = currentVal . substring ( currentVal . indexOf ( STR_ ) + NUM_ ) ; Object listObj = listMap . get ( listName ) ; if ( listObj == null ) return BOOL_ ; boolean contains ; if ( listObj instanceof Set ) { Set < String > set = ( Set ) listObj ; contains = set . contains ( tokenValue ) ; } else { throw new IllegalArgumentException ( STR_ + listObj ) ; } return ! ( contains && negation || ! contains && ! negation ) ; }
public static synchronized void addNativeLibraryDependencies ( String name , String ... dependencyNames ) { List < String > list = libraryDependencies . get ( name ) ; if ( list == null ) { libraryDependencies . put ( name , list = new ArrayList < String > ( ) ) ; } for ( String dependencyName : dependencyNames ) { if ( ! list . contains ( dependencyName ) ) { list . add ( dependencyName ) ; } } }
@ Override protected boolean hasOverflow ( FlatRStarTreeNode node ) { if ( node . isLeaf ( ) ) { return node . getNumEntries ( ) == leafCapacity ; } else if ( node . getNumEntries ( ) == node . getCapacity ( ) ) { node . increaseEntries ( ) ; } return BOOL_ ; }
public void processVolumeExpansion ( StorageSystem storageSystem , URI storagePoolURI , URI volumeId , CIMArgument [ ] outArgs ) throws Exception { StringBuilder logMsgBuilder = new StringBuilder ( String . format ( STR_ ) ) ; CimConnection connection = _cimConnection . getConnection ( storageSystem ) ; WBEMClient client = connection . getCimClient ( ) ; StoragePool storagePool = _dbClient . queryObject ( StoragePool . class , storagePoolURI ) ; StringMap reservationMap = storagePool . getReservedCapacityMap ( ) ; reservationMap . remove ( volumeId . toString ( ) ) ; updateStoragePoolCapacity ( client , storagePool ) ; _dbClient . persistObject ( storagePool ) ; Volume volume = _dbClient . queryObject ( Volume . class , volumeId ) ; CIMObjectPath volumePath = ( CIMObjectPath ) _cimPath . getFromOutputArgs ( outArgs , IBMSmisConstants . CP_THE_ELEMENT ) ; boolean isSuccess = BOOL_ ; if ( volumePath != null ) { CIMInstance volumeInstance = client . getInstance ( volumePath , BOOL_ , BOOL_ , null ) ; if ( volumeInstance != null ) { isSuccess = BOOL_ ; volume . setProvisionedCapacity ( getProvisionedCapacityInformation ( volumeInstance ) ) ; volume . setAllocatedCapacity ( getAllocatedCapacityInformation ( client , volumeInstance ) ) ; _dbClient . persistObject ( volume ) ; logMsgBuilder . append ( String . format ( STR_ , volume . getCapacity ( ) , volume . getProvisionedCapacity ( ) , volume . getAllocatedCapacity ( ) ) ) ; } } if ( ! isSuccess ) { UnsignedInteger32 returnCoede = ( UnsignedInteger32 ) _cimPath . getFromOutputArgs ( outArgs , IBMSmisConstants . CP_RETURN_CODE ) ; logMsgBuilder . append ( STR_ ) ; logMsgBuilder . append ( String . format ( STR_ , volume . getId ( ) , returnCoede . toString ( ) ) ) ; } _log . info ( logMsgBuilder . toString ( ) ) ; }
void updateFromNativeNode ( Node node , boolean fromScratch ) throws IIOInvalidTreeException { NamedNodeMap attrs = node . getAttributes ( ) ; if ( attrs . getLength ( ) > NUM_ ) { int value = getAttributeValue ( node , attrs , STR_ , NUM_ , NUM_ , BOOL_ ) ; majorVersion = ( value != - NUM_ ) ? value : majorVersion ; value = getAttributeValue ( node , attrs , STR_ , NUM_ , NUM_ , BOOL_ ) ; minorVersion = ( value != - NUM_ ) ? value : minorVersion ; value = getAttributeValue ( node , attrs , STR_ , NUM_ , NUM_ , BOOL_ ) ; resUnits = ( value != - NUM_ ) ? value : resUnits ; value = getAttributeValue ( node , attrs , STR_ , NUM_ , NUM_ , BOOL_ ) ; Xdensity = ( value != - NUM_ ) ? value : Xdensity ; value = getAttributeValue ( node , attrs , STR_ , NUM_ , NUM_ , BOOL_ ) ; Ydensity = ( value != - NUM_ ) ? value : Ydensity ; value = getAttributeValue ( node , attrs , STR_ , NUM_ , NUM_ , BOOL_ ) ; thumbWidth = ( value != - NUM_ ) ? value : thumbWidth ; value = getAttributeValue ( node , attrs , STR_ , NUM_ , NUM_ , BOOL_ ) ; thumbHeight = ( value != - NUM_ ) ? value : thumbHeight ; } if ( node . hasChildNodes ( ) ) { NodeList children = node . getChildNodes ( ) ; int count = children . getLength ( ) ; if ( count > NUM_ ) { throw new IIOInvalidTreeException ( STR_ , node ) ; } for ( int i = NUM_ ; i < count ; i ++ ) { Node child = children . item ( i ) ; String name = child . getNodeName ( ) ; if ( name . equals ( STR_ ) ) { if ( ( ! extSegments . isEmpty ( ) ) && fromScratch ) { throw new IIOInvalidTreeException ( STR_ , node ) ; } NodeList exts = child . getChildNodes ( ) ; int extCount = exts . getLength ( ) ; for ( int j = NUM_ ; j < extCount ; j ++ ) { Node ext = exts . item ( j ) ; extSegments . add ( new JFIFExtensionMarkerSegment ( ext ) ) ; } } if ( name . equals ( STR_ ) ) { if ( ( iccSegment != null ) && fromScratch ) { throw new IIOInvalidTreeException ( STR_ , node ) ; } iccSegment = new ICCMarkerSegment ( child ) ; } } } }
private void addBestTestSuite ( File newlyGeneratedTestSuite ) { String testName = extractClassName ( tmpTests , newlyGeneratedTestSuite ) ; String path = testName . replace ( STR_ , File . separator ) + STR_ ; File file = new File ( getBestTestFolder ( ) + File . separator + path ) ; file . delete ( ) ; try { FileUtils . copyFile ( newlyGeneratedTestSuite , file ) ; } catch ( IOException e ) { logger . error ( STR_ + e . getMessage ( ) , e ) ; } }
@ Override public void createConnectionFactory ( String name , boolean ha , boolean useDiscovery , int cfType , String connectors , String bindings ) throws Exception { createConnectionFactory ( name , ha , useDiscovery , cfType , toArray ( connectors ) , toArray ( bindings ) ) ; }
protected Object evaluateSingle ( List elements , String expr ) { List array ; if ( elements instanceof java . util . Vector ) { array = new java . util . Vector ( ) ; } else { array = new ArrayList ( ) ; } for ( Iterator e = elements . iterator ( ) ; e . hasNext ( ) ; ) { Object o = e . next ( ) ; if ( o instanceof StructuredContent ) { if ( ( o = evaluateSingle ( ( StructuredContent ) o , expr ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == NUM_ ) { return ( StructuredContent ) array . get ( NUM_ ) ; } return array ; }
private int doScale ( int number , double factor ) { return ( int ) StrictMath . round ( number . factor ) ; }
private int parseMessageId ( final byte [ ] b , final int off ) throws ParseException { final int messageIdLen = Constants . MESSAGE_ID_LEN ; final int len = b . length - off ; if ( len >= messageIdLen ) { messageId_ = Arrays . copyOfRange ( b , off , off + messageIdLen ) ; return messageIdLen ; } else { throw new ParseException ( STR_ ) ; } }
static void generateCharacterClass ( String theTemplateFileName , String theOutputFileName ) throws FileNotFoundException , IOException { BufferedReader in = new BufferedReader ( new FileReader ( theTemplateFileName ) ) ; PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( theOutputFileName ) ) ) ; out . println ( commentStart + STR_ + new java . util . Date ( ) + commentEnd ) ; int marklen = commandMarker . length ( ) ; LOOP : while ( BOOL_ ) { try { String line = in . readLine ( ) ; if ( line == null ) break LOOP ; int pos = NUM_ ; int depth = NUM_ ; while ( ( pos = line . indexOf ( commandMarker , pos ) ) >= NUM_ ) { int newpos = pos + marklen ; char ch = STR_ ; SCAN : while ( newpos < line . length ( ) && ( Character . isJavaIdentifierStart ( ch = line . charAt ( newpos ) ) || ch == STR_ || ( ch == STR_ && depth > NUM_ ) ) ) { ++ newpos ; if ( ch == STR_ ) { ++ depth ; } else if ( ch == STR_ ) { -- depth ; if ( depth == NUM_ ) break SCAN ; } } String replacement = replaceCommand ( line . substring ( pos + marklen , newpos ) ) ; line = line . substring ( NUM_ , pos ) + replacement + line . substring ( newpos ) ; pos += replacement . length ( ) ; } out . println ( line ) ; } catch ( IOException e ) { break LOOP ; } } in . close ( ) ; out . close ( ) ; }
public static String combineExtensions ( final String [ ] extensions ) { Check . notNull ( extensions , STR_ ) ; final StringBuffer ret = new StringBuffer ( ) ; for ( int i = NUM_ ; i < extensions . length ; i ++ ) { if ( i > NUM_ ) { ret . append ( STR_ ) ; } ret . append ( extensions [ i ] ) ; } return ret . toString ( ) ; }
public static void initializeProperties ( String file ) throws MissingResourceException { Properties props = new Properties ( ) ; ResourceBundle bundle = ResourceBundle . getBundle ( file ) ; for ( String key : bundle . keySet ( ) ) { props . put ( key , bundle . getString ( key ) ) ; } initializeProperties ( props , BOOL_ , BOOL_ ) ; }
private E unlinkFirst ( ) { Node < E > f = first ; if ( f == null ) return null ; Node < E > n = f . next ; E item = f . item ; f . item = null ; f . next = f ; first = n ; if ( n == null ) last = null ; else n . prev = null ; -- count ; notFull . signal ( ) ; return item ; }
private String tweakNativeLaunchUri ( String uri , boolean forDebugging , LaunchInfo launchInfo ) throws IOException , FileNotFoundException { if ( launchInfo . isHttpOrAbout ( ) ) { boolean modify = ( getPreference ( PREF_URI_MODIFICATION ) != NUM_ ) ; if ( modify && forDebugging && ! launchInfo . isAbout ( ) ) { uri = URLHelper . escapeSpace ( uri ) ; URLHelper urlHelper = new URLHelper ( uri ) ; Map < String , String > params = urlHelper . getParameterMap ( ) ; params . put ( STR_ , STR_ ) ; urlHelper . setParameterMap ( params ) ; uri = urlHelper . getURL ( ) ; } } else { File f = null ; if ( uri . startsWith ( STR_ ) ) { try { f = new File ( new URI ( uri ) ) ; } catch ( URISyntaxException e ) { IOException ioe = new IOException ( e . getMessage ( ) ) ; ioe . initCause ( e ) ; throw ioe ; } } else { f = new File ( uri ) ; } if ( f != null && f . exists ( ) ) { uri = f . getAbsolutePath ( ) ; } else { throw new FileNotFoundException ( uri ) ; } } return uri ; }
public void addListener ( final Listener listener ) { listeners . add ( listener ) ; }
public List < T > queryAsList ( ) { QuantumFluxCursor < T > cursor = queryAsCursor ( ) ; try { List < T > resultList = new ArrayList < > ( cursor . getCount ( ) ) ; while ( cursor . moveToNext ( ) ) { resultList . add ( cursor . inflate ( ) ) ; } return resultList ; } finally { if ( cursor != null ) cursor . close ( ) ; } }
@ Override public void profile ( ) { recordStats ( ) ; }
public static void touch ( File file ) throws IOException { if ( ! file . exists ( ) ) { OutputStream out = openOutputStream ( file ) ; IOUtils . closeQuietly ( out ) ; } boolean success = file . setLastModified ( System . currentTimeMillis ( ) ) ; if ( ! success ) { throw new IOException ( STR_ + file ) ; } }
public boolean isEmpty ( ) { return extOrdering . isEmpty ( ) ; }
public static byte [ ] ivCipherConcat ( byte [ ] iv , byte [ ] cipherText ) { byte [ ] combined = new byte [ iv . length + cipherText . length ] ; System . arraycopy ( iv , NUM_ , combined , NUM_ , iv . length ) ; System . arraycopy ( cipherText , NUM_ , combined , iv . length , cipherText . length ) ; return combined ; }
public static final void saveInstanceIdentifier ( String confPath , String instanceIdentifier ) throws Exception { Path file = Paths . get ( confPath , INSTANCE_IDENTIFIER_FILE ) ; log . trace ( STR_ , file ) ; AtomicSave . execute ( file . toString ( ) , STR_ , instanceIdentifier . getBytes ( StandardCharsets . UTF_8 ) ) ; }
Part ( String contents , String property ) throws Exception { this . contents = STR_ + contents ; this . property = property ; simplify ( ) ; }
public static boolean isSame ( Object s1 , Object s2 ) { if ( s1 == s2 ) return BOOL_ ; if ( X . isEmpty ( s1 ) && X . isEmpty ( s2 ) ) return BOOL_ ; if ( s1 != null ) { return s1 . equals ( s2 ) ; } return BOOL_ ; }
public static double standardDeviation ( double variance ) { return Math . sqrt ( variance ) ; }
public static int frequencyToMIDINote ( double aFrequency ) { double r = NUM_ ; double ref = NUM_ ; int supinf = NUM_ ; int i = NUM_ ; double hautnb = NUM_ ; double ref1 = NUM_ ; double ref2 = NUM_ ; double flag = NUM_ ; int nmidi = NUM_ ; while ( aFrequency < ref ) { ref = Math . floor ( NUM_ . ref / r ) / NUM_ ; i = i + NUM_ ; supinf = - NUM_ ; flag = NUM_ ; ref1 = ref ; } while ( aFrequency > ref ) { ref = Math . floor ( NUM_ . ref . r ) / NUM_ ; i = i - NUM_ ; supinf = NUM_ ; ref2 = ref ; } if ( Math . abs ( aFrequency - ref1 ) < Math . abs ( aFrequency - ref2 ) ) { supinf = - NUM_ ; i = i + NUM_ ; } else { if ( flag == NUM_ ) supinf = - NUM_ ; } if ( ref1 == NUM_ ) { ref1 = Math . floor ( NUM_ . ref / r ) / NUM_ ; if ( Math . abs ( aFrequency - ref1 ) < Math . abs ( aFrequency - ref2 ) ) { i = i + NUM_ ; supinf = NUM_ ; } } i = Math . abs ( i ) ; while ( i -- != NUM_ ) { if ( ( hautnb == NUM_ && supinf == - NUM_ ) || ( hautnb == NUM_ && supinf == NUM_ ) ) { if ( supinf == NUM_ ) hautnb = NUM_ ; if ( supinf == - NUM_ ) hautnb = NUM_ ; } hautnb = hautnb + supinf ; nmidi = nmidi + supinf ; } return nmidi ; }
private void writeAttribute ( java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( namespace . equals ( STR_ ) ) { xmlWriter . writeAttribute ( attName , attValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } }
public void recordGCVersions ( RegionVersionVector < T > other ) { assert other . memberToGCVersion != null : STR_ ; recordGCVersion ( other . myId , other . localGCVersion . get ( ) ) ; for ( Map . Entry < T , Long > entry : other . memberToGCVersion . entrySet ( ) ) { recordGCVersion ( entry . getKey ( ) , entry . getValue ( ) . longValue ( ) ) ; } }
boolean waitForState ( Processor p , int state ) { synchronized ( waitSync ) { try { while ( p . getState ( ) < state && stateTransitionOK ) waitSync . wait ( ) ; } catch ( Exception e ) { } } return stateTransitionOK ; }
private static boolean extractFile ( Context c , String rootAsset , String path ) { AssetManager assetManager = c . getAssets ( ) ; InputStream in = null ; OutputStream out = null ; try { in = assetManager . open ( rootAsset + path ) ; String fullPath = PrefStore . getEnvDir ( c ) + path ; out = new FileOutputStream ( fullPath ) ; byte [ ] buffer = new byte [ NUM_ ] ; int read ; while ( ( read = in . read ( buffer ) ) != - NUM_ ) { out . write ( buffer , NUM_ , read ) ; } out . flush ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return BOOL_ ; } finally { close ( in ) ; close ( out ) ; } return BOOL_ ; }
protected int never ( ) { synchronized ( sleepLock ) { while ( running ) { try { sleepLock . wait ( NUM_ . NUM_ . NUM_ ) ; } catch ( InterruptedException e ) { continue ; } } return NUM_ ; } }
public boolean verify ( X509Certificate cert , Provider sigProvider ) throws NoSuchAlgorithmException , CertificateExpiredException , CertificateNotYetValidException , CMSException { Time signingTime = getSigningTime ( ) ; if ( signingTime != null ) { cert . checkValidity ( signingTime . getDate ( ) ) ; } return doVerify ( cert . getPublicKey ( ) , sigProvider ) ; }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case NUM_ : return MESSAGE_TYPE ; case NUM_ : return REQUEST_INFO ; case NUM_ : return RESPONSE_INFO ; case NUM_ : return TRACE_INFO ; case NUM_ : return GLOBAL_CONTEXT ; case NUM_ : return LOCAL_CONTEXT ; case NUM_ : return HEARTBEAT_INFO ; default : return null ; } }
protected void loadHistory ( boolean set ) { BufferedInputStream str ; File file ; int width ; int height ; try { file = new File ( getHistoryFilename ( ) ) ; if ( file . exists ( ) ) { str = new BufferedInputStream ( new FileInputStream ( getHistoryFilename ( ) ) ) ; m_History . load ( str ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } if ( set ) { m_ConnectionPanel . setHistory ( stringToModel ( m_History . getProperty ( ConnectionPanel . HISTORY_NAME , STR_ ) ) ) ; m_QueryPanel . setHistory ( stringToModel ( m_History . getProperty ( QueryPanel . HISTORY_NAME , STR_ ) ) ) ; m_QueryPanel . setMaxRows ( Integer . parseInt ( m_History . getProperty ( QueryPanel . MAX_ROWS , STR_ ) ) ) ; width = Integer . parseInt ( m_History . getProperty ( WIDTH , STR_ ) ) ; height = Integer . parseInt ( m_History . getProperty ( HEIGHT , STR_ ) ) ; if ( ( width != NUM_ ) && ( height != NUM_ ) ) { setPreferredSize ( new Dimension ( width , height ) ) ; } } }
private void updatePanelForExpansion ( float percentage ) { updatePromoVisibility ( NUM_ ) ; float baseBaseY = MathUtils . interpolate ( NUM_ , getBasePageTargetY ( ) , percentage ) ; mBasePageY = baseBaseY ; float brightness = MathUtils . interpolate ( BASE_PAGE_BRIGHTNESS_STATE_PEEKED , BASE_PAGE_BRIGHTNESS_STATE_EXPANDED , percentage ) ; mBasePageBrightness = brightness ; float searchBarHeight = Math . round ( MathUtils . interpolate ( mSearchBarHeightPeeking , getSearchBarHeightExpanded ( ) , percentage ) ) ; mSearchBarHeight = searchBarHeight ; mSearchBarTextOpacity = NUM_ ; mIsSearchBarBorderVisible = BOOL_ ; mSearchBarBorderY = searchBarHeight - SEARCH_BAR_BORDER_HEIGHT_DP + NUM_ ; mSearchIconOpacity = SEARCH_ICON_OPACITY_STATE_EXPANDED ; mArrowIconOpacity = ARROW_ICON_OPACITY_STATE_EXPANDED ; mArrowIconRotation = Math . round ( MathUtils . interpolate ( ARROW_ICON_ROTATION_STATE_PEEKED , ARROW_ICON_ROTATION_STATE_EXPANDED , percentage ) ) ; mCloseIconOpacity = CLOSE_ICON_OPACITY_STATE_EXPANDED ; float peekedHeight = getPanelHeightFromState ( PanelState . PEEKED ) ; float threshold = PROGRESS_BAR_VISIBILITY_THRESHOLD_DP / mPxToDp ; float diff = Math . min ( mHeight - peekedHeight , threshold ) ; float progressBarOpacity = MathUtils . interpolate ( NUM_ , NUM_ , diff / threshold ) ; mProgressBarOpacity = progressBarOpacity ; mProgressBarY = searchBarHeight - PROGRESS_BAR_HEIGHT_DP + NUM_ ; updateSearchBarShadow ( ) ; }
protected boolean [ ] updateableClusterer ( ) { boolean [ ] result = new boolean [ NUM_ ] ; print ( STR_ ) ; if ( m_Clusterer instanceof UpdateableClusterer ) { println ( STR_ ) ; result [ NUM_ ] = BOOL_ ; } else { println ( STR_ ) ; result [ NUM_ ] = BOOL_ ; } return result ; }
@ Override protected int sizeOf ( String key , BitmapDrawable value ) { final int bitmapSize = getBitmapSize ( value ) / NUM_ ; return bitmapSize == NUM_ ? NUM_ : bitmapSize ; }
public void addField ( MappedMember mm ) { fields . add ( mm ) ; }
public static List < BaseMqttMessage > readAndConvertMessageLog ( final File selectedFile ) throws SpyException { final List < String > lines = FileUtils . readFileAsLines ( selectedFile ) ; logger . info ( STR_ , lines . size ( ) , selectedFile . getAbsoluteFile ( ) ) ; return processMessageLog ( parseMessageLog ( lines , null , NUM_ , NUM_ ) , null , NUM_ , NUM_ ) ; }
void readStream ( InputStream is ) throws Exception { String line ; Date start = new Date ( ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( is ) ) ; while ( ( line = reader . readLine ( ) ) != null && ! mStop ) { mResults . append ( line ) ; mResults . append ( Tools . LineSep ) ; Date end = new Date ( ) ; if ( ( end . getTime ( ) - start . getTime ( ) ) / NUM_ > NUM_ || mResults . length ( ) > NUM_ ) { start = end ; int last = mResults . lastIndexOf ( STR_ ) ; if ( last != - NUM_ ) { XmppMsg msg = new XmppMsg ( _font ) ; msg . append ( mResults . substring ( NUM_ , last + NUM_ ) ) ; mCmdBase . send ( mShellId , msg ) ; mResults . setLength ( NUM_ ) ; } } } }
public static boolean isValidName ( String name ) { if ( name == null ) { return BOOL_ ; } return name . length ( ) > NUM_ ; }
public void removeParentRelation ( long osmId ) { if ( parentRelations != null ) { ArrayList < Relation > tempRelList = new ArrayList < Relation > ( parentRelations ) ; for ( Relation r : tempRelList ) { if ( osmId == r . getOsmId ( ) ) parentRelations . remove ( r ) ; } } }
public final void test_ROUNDTRIP_GetKeySpecCipher01 ( ) { boolean performed = BOOL_ ; for ( int i = NUM_ ; i < algName . length ; i ++ ) { try { TestDataGenerator g = new TestDataGenerator ( algName [ i ] [ NUM_ ] , algName [ i ] [ NUM_ ] , privateKeyInfo , null ) ; EncryptedPrivateKeyInfo epki ; if ( g . ap ( ) == null ) { epki = new EncryptedPrivateKeyInfo ( algName [ i ] [ NUM_ ] , g . ct ( ) ) ; } else { epki = new EncryptedPrivateKeyInfo ( g . ap ( ) , g . ct ( ) ) ; } try { PKCS8EncodedKeySpec eks = epki . getKeySpec ( g . c ( ) ) ; if ( ! Arrays . equals ( privateKeyInfo , eks . getEncoded ( ) ) ) { fail ( algName [ i ] [ NUM_ ] + STR_ + algName [ i ] [ NUM_ ] ) ; } } catch ( InvalidKeySpecException e ) { fail ( algName [ i ] [ NUM_ ] + STR_ + algName [ i ] [ NUM_ ] + e + STR_ ) ; } performed = BOOL_ ; } catch ( TestDataGenerator . AllowedFailure allowedFailure ) { } catch ( NoSuchAlgorithmException allowed ) { } } assertTrue ( STR_ , performed ) ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
void insert ( V val , K key ) { ArrayList < K > list = map . get ( val ) ; if ( list == null ) { list = new ArrayList < K > ( NUM_ ) ; map . put ( cloneValue ( val ) , list ) ; } list . add ( key ) ; }
public ServerSocket createServerSocket ( int nport , int backlog ) throws IOException { return createServerSocket ( nport , backlog , null ) ; }
public static ArrayList < Integer > convertStringArrayToIntegerArray ( List < String > arrayList ) { ArrayList < Integer > integers = new ArrayList < > ( ) ; for ( String str : arrayList ) { integers . add ( Integer . valueOf ( str ) ) ; } return integers ; }
@ Override public void unwrapSSLv2 ( byte [ ] bytes ) { unexpectedMessage ( ) ; }
public static String buildSelectorFromClass ( String classValue ) { StringBuilder strb = new StringBuilder ( ) ; strb . append ( CLASS_SELECTOR_PREFIX ) ; strb . append ( classValue ) ; return strb . toString ( ) ; }
public void ensureCapacity ( int minimumCapacity ) { if ( minimumCapacity > value . length ) { int ourMin = value . length . NUM_ + NUM_ ; enlargeBuffer ( Math . max ( ourMin , minimumCapacity ) ) ; } }
public String poolFooterStatements ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( String footerStatement : footerStatements ) { sb . append ( STR_ ) ; sb . append ( footerStatement ) ; sb . append ( STR_ ) ; } footerStatements . clear ( ) ; return sb . toString ( ) ; }
private void handleNodeQueue ( SerialMessage incomingMessage ) { if ( currentStage == ZWaveNodeInitStage . DONE ) { return ; } logger . debug ( STR_ , node . getNodeId ( ) , msgQueue . size ( ) ) ; if ( msgQueue . contains ( incomingMessage ) ) { msgQueue . remove ( incomingMessage ) ; logger . debug ( STR_ , node . getNodeId ( ) , msgQueue . size ( ) ) ; freeToSend = BOOL_ ; advanceNodeStage ( incomingMessage . getMessageClass ( ) ) ; } else if ( msgQueue . isEmpty ( ) && currentStage == ZWaveNodeInitStage . SECURITY_REPORT ) { logger . debug ( STR_ , node . getNodeId ( ) ) ; advanceNodeStage ( incomingMessage . getMessageClass ( ) ) ; } }
public static Predicate < String > matches ( final String regexp ) { Objects . requireNonNull ( regexp , STR_ ) ; return null ; }
public boolean hasSet ( String name ) { return m_map . containsKey ( name ) ; }
public void or ( Criteria criteria ) { oredCriteria . add ( criteria ) ; }
public void clearParsers ( ) { timer . stop ( ) ; clearParserNoticeHighlights ( ) ; parsers . clear ( ) ; textArea . fireParserNoticesChange ( ) ; }
protected PropertyDefinition ( AbstractManagedObjectDefinition < ? , ? > d , Class < T > theClass , String propertyName , EnumSet < PropertyOption > options , AdministratorAction adminAction , DefaultBehaviorProvider < T > defaultBehavior ) { Reject . ifNull ( d , theClass , propertyName , options , adminAction , defaultBehavior ) ; this . definition = d ; this . theClass = theClass ; this . propertyName = propertyName ; this . options = EnumSet . copyOf ( options ) ; this . adminAction = adminAction ; this . defaultBehavior = defaultBehavior ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
private static IMultiPoint [ ] randomPoints ( int n , int d , int scale ) { IMultiPoint points [ ] = new IMultiPoint [ n ] ; for ( int i = NUM_ ; i < n ; i ++ ) { StringBuilder sb = new StringBuilder ( ) ; for ( int j = NUM_ ; j < d ; j ++ ) { sb . append ( rGen . nextDouble ( ) . scale ) ; if ( j < d - NUM_ ) { sb . append ( STR_ ) ; } } points [ i ] = new Hyperpoint ( sb . toString ( ) ) ; } return points ; }
public DateTimeParseException ( String message , CharSequence parsedData , int errorIndex , Throwable cause ) { super ( message , cause ) ; this . parsedString = parsedData . toString ( ) ; this . errorIndex = errorIndex ; }
public ConfigureXmlAttributeCountDialog_NB ( XmlAttributeCount xmlAttributeCount ) { this . xmlAttributeCount = xmlAttributeCount ; initComponents ( ) ; final IterateModel numberOfTagsIterator = xmlAttributeCount . getNumberOfAttributesIterator ( ) ; configureIterateModel_NB2 . setStartAt ( String . valueOf ( numberOfTagsIterator . getStartAt ( ) ) ) ; configureIterateModel_NB2 . setStopAt ( String . valueOf ( numberOfTagsIterator . getStopAt ( ) ) ) ; configureIterateModel_NB2 . setIncrement ( String . valueOf ( numberOfTagsIterator . getIncrement ( ) ) ) ; configureIterateModel_NB2 . setIterateStrategie ( numberOfTagsIterator . getIterateStrategie ( ) ) ; List < String > names = Arrays . asList ( xmlAttributeCount . getNames ( ) ) ; configureStringList_NB1 . setStringList ( names ) ; }
public static void checkArgument ( boolean expression , @ Nullable Object errorMessage ) { if ( ! expression ) { throw new IllegalArgumentException ( String . valueOf ( errorMessage ) ) ; } }
public void onMenuDismissed ( ) { mReloadMenuItem = null ; }
public static Thread consumeProcessOutputStream ( Process self , OutputStream output ) { Thread thread = new Thread ( new ByteDumper ( self . getInputStream ( ) , output ) ) ; thread . start ( ) ; return thread ; }
public static Angle greatCircleAzimuth ( LatLon p1 , LatLon p2 ) { if ( ( p1 == null ) || ( p2 == null ) ) { throw new IllegalArgumentException ( STR_ ) ; } double lat1 = p1 . getLatitude ( ) . radians ; double lon1 = p1 . getLongitude ( ) . radians ; double lat2 = p2 . getLatitude ( ) . radians ; double lon2 = p2 . getLongitude ( ) . radians ; if ( lat1 == lat2 && lon1 == lon2 ) return Angle . ZERO ; if ( lon1 == lon2 ) return lat1 > lat2 ? Angle . POS180 : Angle . ZERO ; double y = Math . cos ( lat2 ) . Math . sin ( lon2 - lon1 ) ; double x = Math . cos ( lat1 ) . Math . sin ( lat2 ) - Math . sin ( lat1 ) . Math . cos ( lat2 ) . Math . cos ( lon2 - lon1 ) ; double azimuthRadians = Math . atan2 ( y , x ) ; return Double . isNaN ( azimuthRadians ) ? Angle . ZERO : Angle . fromRadians ( azimuthRadians ) ; }
public void delete ( ) throws IOException { close ( ) ; Util . deleteContents ( directory ) ; }
public void addAllTagsOf ( Host h ) { List < Tag > tags = h . getTags ( ) ; if ( tags . isEmpty ( ) ) return ; if ( mTagList == null ) { mTagList = new ArrayList < Tag > ( tags . size ( ) ) ; } mTagList . addAll ( tags ) ; }
public static boolean isNumbersWithPunctuation ( String token ) { boolean hasDigit = BOOL_ ; int len = token . length ( ) ; for ( int i = NUM_ ; i < len ; ++ i ) { char c = token . charAt ( i ) ; hasDigit = hasDigit || Character . isDigit ( c ) ; if ( ! ( Character . isDigit ( c ) || Characters . isPunctuation ( c ) ) ) { return BOOL_ ; } } return hasDigit ; }
private boolean isPaintLineSeperators ( JComponent c ) { boolean paintLines = c instanceof JTextArea ; String globalOverride = System . getProperty ( STR_ ) ; if ( globalOverride != null && globalOverride . length ( ) > NUM_ ) { paintLines = Boolean . valueOf ( globalOverride ) ; } Boolean overrideProperty = ( Boolean ) c . getClientProperty ( STR_ ) ; if ( overrideProperty != null ) { paintLines = overrideProperty ; } return paintLines ; }
public static Db open ( DataSource ds ) { try { return new Db ( ds . getConnection ( ) ) ; } catch ( SQLException e ) { throw convert ( e ) ; } }
@ Override public void basicPutPart3 ( EntryEventImpl event , RegionEntry entry , boolean isInitialized , long lastModified , boolean invokeCallbacks , boolean ifNew , boolean ifOld , Object expectedOldValue , boolean requireOldValue ) { distributeUpdate ( event , lastModified , BOOL_ , BOOL_ , null , BOOL_ ) ; super . basicPutPart3 ( event , entry , isInitialized , lastModified , invokeCallbacks , ifNew , ifOld , expectedOldValue , requireOldValue ) ; }
public LanguageRange ( String range ) { this . range = range . split ( STR_ ) ; full = range ; }
protected void removeContainer ( ) throws Throwable { if ( containerId == null ) { return ; } sendDeleteContainerRequest ( ) ; waitForPropertyValue ( provisioningTaskLink , MockTaskState . class , STR_ , TaskState . TaskStage . FINISHED ) ; if ( ! isMockTarget ( ) ) { Thread . sleep ( NUM_ ) ; } verifyContainerDoesNotExist ( containerId ) ; }
public int size ( ) { return list . size ( ) ; }
public TransformerHandler newTransformerHandler ( Templates templates ) throws TransformerConfigurationException { try { TransformerImpl transformer = ( TransformerImpl ) templates . newTransformer ( ) ; transformer . setURIResolver ( m_uriResolver ) ; TransformerHandler th = ( TransformerHandler ) transformer . getInputContentHandler ( BOOL_ ) ; return th ; } catch ( TransformerConfigurationException ex ) { if ( m_errorListener != null ) { try { m_errorListener . fatalError ( ex ) ; return null ; } catch ( TransformerConfigurationException ex1 ) { throw ex1 ; } catch ( TransformerException ex1 ) { throw new TransformerConfigurationException ( ex1 ) ; } } throw ex ; } }
public void addField ( FieldRef fref ) { mFieldRefs . add ( fref ) ; }
public String render ( ValueExpr theExpr ) throws Exception { reset ( ) ; theExpr . visit ( this ) ; return mBuffer . toString ( ) ; }
public void add ( final Vector2D [ ] bLoop ) throws MathIllegalArgumentException { add ( new NestedLoops ( bLoop , tolerance ) ) ; }
@ NotNull public static < T > List < T > asList ( @ Nullable final Collection < ? > expression , @ NotNull final Class < T > elementClass ) { if ( ( expression == null ) || expression . isEmpty ( ) ) { return Collections . emptyList ( ) ; } final List < T > result = new ArrayList < T > ( ) ; for ( final Object element : expression ) { final T toAdd = as ( element , elementClass ) ; if ( toAdd != null ) { result . add ( toAdd ) ; } } return result ; }
public static String readAsciiLine ( InputStream in ) throws IOException { StringBuilder result = new StringBuilder ( NUM_ ) ; while ( BOOL_ ) { int c = in . read ( ) ; if ( c == - NUM_ ) { throw new EOFException ( ) ; } else if ( c == STR_ ) { break ; } result . append ( ( char ) c ) ; } int length = result . length ( ) ; if ( length > NUM_ && result . charAt ( length - NUM_ ) == STR_ ) { result . setLength ( length - NUM_ ) ; } return result . toString ( ) ; }
private void startNewTransition ( ) { if ( ! hasBounds ( ) ) { return ; } mCurrentTrans = mTransGen . generateNextTransition ( mDrawableRect , mViewportRect ) ; mElapsedTime = NUM_ ; mLastFrameTime = System . currentTimeMillis ( ) ; fireTransitionStart ( mCurrentTrans ) ; }
@ Override protected void makeFinished ( ) { byte [ ] verify_data ; if ( serverHello . server_version [ NUM_ ] == NUM_ ) { verify_data = new byte [ NUM_ ] ; computerVerifyDataTLS ( STR_ , verify_data ) ; } else { verify_data = new byte [ NUM_ ] ; computerVerifyDataSSLv3 ( SSLv3Constants . client , verify_data ) ; } clientFinished = new Finished ( verify_data ) ; send ( clientFinished ) ; if ( isResuming ) { session . lastAccessedTime = System . currentTimeMillis ( ) ; status = FINISHED ; } else { if ( serverHello . server_version [ NUM_ ] == NUM_ ) { computerReferenceVerifyDataTLS ( STR_ ) ; } else { computerReferenceVerifyDataSSLv3 ( SSLv3Constants . server ) ; } status = NEED_UNWRAP ; } }
public static File removeExtension ( File file ) { String absolutePath = file . getAbsolutePath ( ) ; if ( absolutePath . contains ( STR_ ) ) { return new File ( absolutePath . substring ( NUM_ , absolutePath . lastIndexOf ( STR_ ) ) ) ; } else { return file ; } }
public void update ( ) { if ( bgIsOpaque ) { int w = Math . max ( getSize ( ) . width , minWidth ) ; int h = Math . max ( getSize ( ) . height , minHeight ) ; offScr = createImage ( w , h ) ; if ( offScr == null ) return ; Graphics g = offScr . getGraphics ( ) ; drawInto ( g ) ; repaint ( ) ; g . dispose ( ) ; } else { repaint ( ) ; } }
public static final int readInt ( InputStream is ) throws IOException { return ( ( ( xFF & is . read ( ) ) << NUM_ ) | ( xFF & is . read ( ) ) ) ; }
private void saveDynamicActions ( FacesContext context , StateContext stateContext , Map < String , Object > stateMap ) { if ( LOGGER . isLoggable ( Level . FINEST ) ) { LOGGER . finest ( STR_ ) ; } List < ComponentStruct > actions = stateContext . getDynamicActions ( ) ; HashMap < String , UIComponent > componentMap = stateContext . getDynamicComponents ( ) ; if ( actions != null ) { List < Object > savedActions = new ArrayList < > ( actions . size ( ) ) ; for ( ComponentStruct action : actions ) { UIComponent component = componentMap . get ( action . clientId ) ; if ( component == null && context . isProjectStage ( ProjectStage . Development ) ) { LOGGER . log ( Level . WARNING , STR_ , action . clientId ) ; } if ( component != null ) { savedActions . add ( action . saveState ( context ) ) ; } } stateMap . put ( DYNAMIC_ACTIONS , savedActions ) ; } }
@ Override public long skip ( long n ) { if ( n < NUM_ ) { throw new IllegalArgumentException ( STR_ + n ) ; } if ( idx >= charSequence . length ( ) ) { return - NUM_ ; } int dest = ( int ) Math . min ( charSequence . length ( ) , idx + n ) ; int count = dest - idx ; idx = dest ; return count ; }
@ Override public void clear ( ) { if ( elementCount > NUM_ ) { elementCount = NUM_ ; Arrays . fill ( elementData , null ) ; modCount ++ ; while ( referenceQueue . poll ( ) != null ) { } } }
public DefaultConsolePanel ( ) { setLayout ( new BorderLayout ( NUM_ , NUM_ ) ) ; textPane = new JTextArea ( ) ; textPane . setRows ( NUM_ ) ; textPane . setEditable ( BOOL_ ) ; JScrollPane jp = new JScrollPane ( textPane ) ; add ( jp , BorderLayout . CENTER ) ; }
public void push ( ) { level . add ( null ) ; cloned = BOOL_ ; }
private static void loadPluginsFromClassLoader ( ClassLoader classLoader ) { ServiceLoader < GDSFactoryPlugin > pluginLoader = ServiceLoader . load ( GDSFactoryPlugin . class , classLoader ) ; for ( GDSFactoryPlugin plugin : pluginLoader ) { registerPlugin ( plugin ) ; } }
private boolean checkTouchSlop ( View child , float dx , float dy ) { if ( child == null ) { return BOOL_ ; } final boolean checkHorizontal = mCallback . getViewHorizontalDragRange ( child ) > NUM_ ; final boolean checkVertical = mCallback . getViewVerticalDragRange ( child ) > NUM_ ; if ( checkHorizontal && checkVertical ) { return dx . dx + dy . dy > mTouchSlop . mTouchSlop ; } else if ( checkHorizontal ) { return Math . abs ( dx ) > mTouchSlop ; } else if ( checkVertical ) { return Math . abs ( dy ) > mTouchSlop ; } return BOOL_ ; }
public String redo ( ) { if ( ! canRedo ( ) ) { return STR_ ; } m_nCurrentEditAction ++ ; UndoAction undoAction = m_undoStack . get ( m_nCurrentEditAction ) ; m_bNeedsUndoAction = BOOL_ ; undoAction . redo ( ) ; m_bNeedsUndoAction = BOOL_ ; return undoAction . getRedoMsg ( ) ; }
private float interpolate ( ) { long currTime = System . currentTimeMillis ( ) ; float elapsed = ( currTime - startTime ) / ZOOM_TIME ; elapsed = Math . min ( NUM_ , elapsed ) ; return interpolator . getInterpolation ( elapsed ) ; }
@ Override public Writer append ( CharSequence value ) { builder . append ( value ) ; return this ; }
@ Override public InetSocketAddress ipLocal ( ) { SocketChannel s = _channel ; if ( s != null ) { try { return ( InetSocketAddress ) s . getLocalAddress ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } else { return null ; } }
@ Nonnull private static NodeDisk findNodeDisk ( String diskId , List < NodeDisk > nodeDisks , String nodeName ) throws IOException { NodeDisk selected = null ; for ( NodeDisk nodeDisk : nodeDisks ) { if ( diskId . equals ( nodeDisk . getDiskRefId ( ) ) ) { selected = nodeDisk ; break ; } } if ( selected == null ) { String message = format ( STR_ , nodeName , diskId ) ; throw new AbortException ( message ) ; } if ( selected . getNodeMountPoint ( ) == null ) { String message = format ( STR_ , nodeName , diskId ) ; throw new AbortException ( message ) ; } return selected ; }
private int stripMultipartHeaders ( byte [ ] b , int offset ) { int i = NUM_ ; for ( i = offset ; i < b . length ; i ++ ) { if ( b [ i ] == STR_ && b [ ++ i ] == STR_ && b [ ++ i ] == STR_ && b [ ++ i ] == STR_ ) break ; } return i + NUM_ ; }
void seek ( int position ) throws IOException { mDexFile . seek ( position ) ; }
@ Override public List < Column > columns ( ) { return columnList ; }
public static void writeFloat ( DataOutputStream dos , boolean isBigEndian , float val ) throws IOException { if ( ! isBigEndian ) { writeLittleEndianFloat ( dos , val ) ; } else { dos . writeFloat ( val ) ; } }
public void testFlipBitPositiveInside1 ( ) { byte aBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int number = NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger result = aNumber . flipBit ( number ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public static void main ( String [ ] args ) { Log . printLine ( STR_ ) ; try { int num_user = NUM_ ; Calendar calendar = Calendar . getInstance ( ) ; boolean trace_flag = BOOL_ ; CloudSim . init ( num_user , calendar , trace_flag ) ; @ SuppressWarnings ( STR_ ) Datacenter datacenter0 = createDatacenter ( STR_ ) ; DatacenterBroker broker = createBroker ( ) ; int brokerId = broker . getId ( ) ; vmlist = new ArrayList < Vm > ( ) ; int vmid = NUM_ ; int mips = NUM_ ; long size = NUM_ ; int ram = NUM_ ; long bw = NUM_ ; int pesNumber = NUM_ ; String vmm = STR_ ; Vm vm1 = new Vm ( vmid , brokerId , mips , pesNumber , ram , bw , size , vmm , new CloudletSchedulerTimeShared ( ) ) ; vmid ++ ; Vm vm2 = new Vm ( vmid , brokerId , mips . NUM_ , pesNumber , ram , bw , size , vmm , new CloudletSchedulerTimeShared ( ) ) ; vmlist . add ( vm1 ) ; vmlist . add ( vm2 ) ; broker . submitVmList ( vmlist ) ; cloudletList = new ArrayList < Cloudlet > ( ) ; int id = NUM_ ; long length = NUM_ ; long fileSize = NUM_ ; long outputSize = NUM_ ; UtilizationModel utilizationModel = new UtilizationModelFull ( ) ; Cloudlet cloudlet1 = new Cloudlet ( id , length , pesNumber , fileSize , outputSize , utilizationModel , utilizationModel , utilizationModel ) ; cloudlet1 . setUserId ( brokerId ) ; id ++ ; Cloudlet cloudlet2 = new Cloudlet ( id , length , pesNumber , fileSize , outputSize , utilizationModel , utilizationModel , utilizationModel ) ; cloudlet2 . setUserId ( brokerId ) ; cloudletList . add ( cloudlet1 ) ; cloudletList . add ( cloudlet2 ) ; broker . submitCloudletList ( cloudletList ) ; broker . bindCloudletToVm ( cloudlet1 . getCloudletId ( ) , vm1 . getId ( ) ) ; broker . bindCloudletToVm ( cloudlet2 . getCloudletId ( ) , vm2 . getId ( ) ) ; CloudSim . startSimulation ( ) ; List < Cloudlet > newList = broker . getCloudletReceivedList ( ) ; CloudSim . stopSimulation ( ) ; printCloudletList ( newList ) ; Log . printLine ( STR_ ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; Log . printLine ( STR_ ) ; } }
public static Instruction _osrHelper ( Instruction barrier , GenerationContext gc ) { Instruction inst = OsrPoint . create ( YIELDPOINT_OSR , null , NUM_ ) ; gc . saveOSRBarrierForInst ( barrier , inst ) ; return inst ; }
protected void initializeState ( S current ) { InitializationUtils . initialize ( current ) ; if ( current . documentExpirationTimeMicros <= NUM_ ) { current . documentExpirationTimeMicros = ServiceUtils . computeExpirationTime ( ServiceUtils . DEFAULT_DOC_EXPIRATION_TIME_MICROS ) ; } }
@ SuppressWarnings ( STR_ ) public InputStream fetchVolumeStats ( final Argument argument , final Map < String , Object > keyMap , int index ) throws VNXFilePluginException { _logger . info ( STR_ ) ; InputStream iStream = null ; List < QueryStats > statList = new ArrayList < QueryStats > ( ) ; try { Set < String > movers = ( Set < String > ) keyMap . get ( VNXFileConstants . MOVERLIST ) ; if ( null != movers && ! movers . isEmpty ( ) ) { for ( String moverID : movers ) { QueryStats queryStats = new QueryStats ( ) ; VolumeStatsSetQueryParams params = new VolumeStatsSetQueryParams ( ) ; params . setStatsSet ( VolumeStatsSetType . ALL ) ; params . setMover ( moverID ) ; queryStats . setVolumeStats ( params ) ; statList . add ( queryStats ) ; } iStream = _vnxFileInputRequestBuilder . getMultiRequestQueryStatsPacket ( statList ) ; } else { _logger . error ( STR_ ) ; } } catch ( JAXBException jaxbException ) { throw new VNXFilePluginException ( STR_ , jaxbException . getCause ( ) ) ; } return iStream ; }
private static boolean isDirectory ( URL url ) { String file = url . getFile ( ) ; return ( file . length ( ) > NUM_ && file . charAt ( file . length ( ) - NUM_ ) == STR_ ) ; }
@ Override public final String readUTF ( ) throws IOException { return dis . readUTF ( ) ; }
@ Nullable public static NetworkParameters fromID ( String id ) { if ( id . equals ( ID_MAINNET ) ) { return MainNetParams . get ( ) ; } else if ( id . equals ( ID_TESTNET ) ) { return TestNet3Params . get ( ) ; } else if ( id . equals ( ID_UNITTESTNET ) ) { return UnitTestParams . get ( ) ; } else { return null ; } }
final synchronized void releaseSocket ( ) { running = BOOL_ ; sender . interrupt ( ) ; outboundMessages . clear ( ) ; if ( socket != null ) { socket . close ( ) ; socket = null ; } maximumTransmissionUnit = NUM_ ; }
public boolean addPart ( PduPart part ) { if ( null == part ) { throw new NullPointerException ( ) ; } putPartToMaps ( part ) ; return mParts . add ( part ) ; }
public String codeOwner ( List < CodeOwner > codeOwners ) { long currentUnix = System . currentTimeMillis ( ) / NUM_ ; double best = NUM_ ; String owner = STR_ ; for ( CodeOwner codeOwner : codeOwners ) { double age = ( currentUnix - codeOwner . getMostRecentUnixCommitTimestamp ( ) ) / NUM_ / NUM_ ; double calc = codeOwner . getNoLines ( ) / Math . pow ( ( age ) , NUM_ ) ; if ( calc > best ) { best = calc ; owner = codeOwner . getName ( ) ; } } return owner ; }
private ArrayList < CellRecord > processNeighbors ( final CellRecord serving , final PositionRecord cellPos ) { final ArrayList < CellRecord > neighbors = new ArrayList < > ( ) ; final ArrayList < NeighboringCellInfo > neighboringCellInfos = ( ArrayList < NeighboringCellInfo > ) mTelephonyManager . getNeighboringCellInfo ( ) ; if ( serving == null ) { Log . e ( TAG , STR_ ) ; return neighbors ; } if ( neighboringCellInfos == null ) { Log . i ( TAG , STR_ ) ; return neighbors ; } for ( final NeighboringCellInfo ci : neighboringCellInfos ) { final boolean skip = ! isValidNeigbor ( ci ) ; if ( ! skip ) { final CellRecord neighbor = new CellRecord ( mSessionId ) ; neighbor . setOpenBmapTimestamp ( cellPos . getOpenBmapTimestamp ( ) ) ; neighbor . setBeginPosition ( cellPos ) ; neighbor . setEndPosition ( cellPos ) ; neighbor . setIsServing ( BOOL_ ) ; neighbor . setIsNeighbor ( BOOL_ ) ; neighbor . setMnc ( serving . getMnc ( ) ) ; neighbor . setMcc ( serving . getMcc ( ) ) ; neighbor . setOperator ( serving . getOperator ( ) ) ; neighbor . setOperatorName ( serving . getOperatorName ( ) ) ; final int networkType = ci . getNetworkType ( ) ; neighbor . setNetworkType ( networkType ) ; if ( networkType == TelephonyManager . NETWORK_TYPE_GPRS || networkType == TelephonyManager . NETWORK_TYPE_EDGE ) { neighbor . setIsCdma ( BOOL_ ) ; neighbor . setLogicalCellId ( ci . getCid ( ) ) ; neighbor . setArea ( ci . getLac ( ) ) ; neighbor . setStrengthdBm ( - NUM_ + NUM_ . ci . getRssi ( ) ) ; neighbor . setStrengthAsu ( ci . getRssi ( ) ) ; } else if ( networkType == TelephonyManager . NETWORK_TYPE_UMTS || networkType == TelephonyManager . NETWORK_TYPE_HSDPA || networkType == TelephonyManager . NETWORK_TYPE_HSUPA || networkType == TelephonyManager . NETWORK_TYPE_HSPA ) { neighbor . setIsCdma ( BOOL_ ) ; neighbor . setPsc ( ci . getPsc ( ) ) ; neighbor . setStrengthdBm ( ci . getRssi ( ) ) ; final int asu = ( int ) Math . round ( ( ci . getRssi ( ) + NUM_ ) / NUM_ ) ; neighbor . setStrengthAsu ( asu ) ; } else if ( networkType == TelephonyManager . NETWORK_TYPE_CDMA ) { neighbor . setIsCdma ( BOOL_ ) ; } neighbors . add ( neighbor ) ; } } return neighbors ; }
public Map read ( SSOToken token , String objName ) throws SMSException , SSOException { if ( objName == null || objName . length ( ) == NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } String objKey = objName . toLowerCase ( ) ; Map attrMap = null ; mRWLock . readRequest ( ) ; try { String filepath = mNameMap . getProperty ( objKey ) ; if ( filepath == null ) { if ( mDebug . messageEnabled ( ) ) { mDebug . message ( STR_ + objName + STR_ ) ; } } else { File filehandle = new File ( filepath ) ; Properties props = null ; try { props = loadProperties ( filehandle , objName ) ; } catch ( ServiceNotFoundException e ) { } if ( props != null ) { attrMap = new CaseInsensitiveHashMap ( ) ; Enumeration keys = props . propertyNames ( ) ; while ( keys . hasMoreElements ( ) ) { String key = ( String ) keys . nextElement ( ) ; String vals = props . getProperty ( key ) ; if ( ( vals != null ) && ( vals . length ( ) > NUM_ ) ) { attrMap . put ( key , toValSet ( key , vals ) ) ; } } } } } finally { mRWLock . readDone ( ) ; } return attrMap ; }
public static double parseDouble ( String s ) { s = s . trim ( ) ; int length = s . length ( ) ; if ( length == NUM_ ) { throw invalidReal ( s , BOOL_ ) ; } char last = s . charAt ( length - NUM_ ) ; if ( last == STR_ || last == STR_ ) { return parseName ( s , BOOL_ ) ; } StringExponentPair info = initialParse ( s , length , BOOL_ ) ; if ( info . infinity || info . zero ) { return info . specialValue ( ) ; } double result = parseDblImpl ( info . s , ( int ) info . e ) ; if ( Double . doubleToLongBits ( result ) == xffffffffffffffffL ) { throw invalidReal ( s , BOOL_ ) ; } return info . negative ? - result : result ; }
public byte readByte ( ) throws IOException { byte v = dataInput . readByte ( ) ; offset += NUM_ ; available -= NUM_ ; return v ; }
public static IMultiPoint [ ] randomPoints ( int n , int d ) { IMultiPoint points [ ] = new IMultiPoint [ n ] ; for ( int i = NUM_ ; i < n ; i ++ ) { StringBuilder sb = new StringBuilder ( ) ; for ( int j = NUM_ ; j < d ; j ++ ) { sb . append ( rGen . nextDouble ( ) ) ; if ( j < d - NUM_ ) { sb . append ( STR_ ) ; } } points [ i ] = new Hyperpoint ( sb . toString ( ) ) ; } return points ; }
private String verifyRestoreCode ( String restoreCode , String code ) { if ( code == null ) { return STR_ ; } if ( restoreCode == null ) { return STR_ ; } boolean validCode = passwordManager . matches ( code , restoreCode ) ; return validCode ? null : STR_ + code + STR_ + restoreCode + STR_ ; }
public static void appendPaddedInteger ( StringBuffer buf , long value , int size ) { int intValue = ( int ) value ; if ( intValue == value ) { appendPaddedInteger ( buf , intValue , size ) ; } else if ( size <= NUM_ ) { buf . append ( Long . toString ( value ) ) ; } else { if ( value < NUM_ ) { buf . append ( STR_ ) ; if ( value != Long . MIN_VALUE ) { value = - value ; } else { for ( ; size > NUM_ ; size -- ) { buf . append ( STR_ ) ; } buf . append ( STR_ ) ; return ; } } int digits = ( int ) ( Math . log ( value ) / LOG_10 ) + NUM_ ; for ( ; size > digits ; size -- ) { buf . append ( STR_ ) ; } buf . append ( Long . toString ( value ) ) ; } }
@ Override public void flush ( ) { if ( ! queue . isEmpty ( ) ) { List < AlertStreamEvent > events = new ArrayList < > ( ) ; queue . drainTo ( events ) ; events . forEach ( null ) ; LOG . info ( STR_ , events . size ( ) ) ; } lastFlushTime . set ( System . currentTimeMillis ( ) ) ; }
@ Override public void addUndoPoint ( ) { File tempFile ; ObjectOutputStream oos ; if ( ! isUndoEnabled ( ) ) { return ; } if ( getInstances ( ) != null ) { try { tempFile = File . createTempFile ( STR_ , null ) ; tempFile . deleteOnExit ( ) ; oos = new ObjectOutputStream ( new BufferedOutputStream ( new FileOutputStream ( tempFile ) ) ) ; oos . writeObject ( getInstances ( ) ) ; oos . flush ( ) ; oos . close ( ) ; m_UndoList . add ( tempFile ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
public final void addChildNode ( RowRegexExprNode childNode ) { childNodes . add ( childNode ) ; }
private List < String > makeList ( final String ... strings ) { final List < String > result = new ArrayList < > ( ) ; for ( String string : strings ) { result . add ( string ) ; } return result ; }
protected boolean isLevelEnabled ( int logLevel ) { return ( logLevel >= currentLogLevel ) ; }
public int numberOfShardsWithState ( ShardRoutingState ... states ) { int count = NUM_ ; for ( ShardRouting shardEntry : this ) { for ( ShardRoutingState state : states ) { if ( shardEntry . state ( ) == state ) { count ++ ; } } } return count ; }
@ Override public void notifyCommit ( final long commitTime ) { lock . lock ( ) ; try { updateReleaseTimeForBareCommit ( commitTime ) ; } finally { lock . unlock ( ) ; } }
public static int showYesNoCancelQuestion ( final Component parent , final String msg ) { return JOptionPane . showConfirmDialog ( isIconified ( parent ) ? null : parent , msg , System . getProperty ( DEFAULT_WINDOW_TITLE_PROPERTY ) , JOptionPane . YES_NO_CANCEL_OPTION , JOptionPane . QUESTION_MESSAGE ) ; }
public static String quantityplnounCreature ( final int quantity , final String noun ) { if ( noun . equals ( STR_ ) ) { final String end = plnounCreature ( quantity , noun ) ; return Integer . toString ( quantity ) + STR_ + end ; } return quantityplnoun ( quantity , noun ) ; }
static int copyBytes ( OutputStream os , InputStream is , byte [ ] ioBuffer , int maxSize ) throws IOException { int totalSize = NUM_ ; while ( totalSize < maxSize ) { int rc = is . read ( ioBuffer , NUM_ , Math . min ( maxSize - totalSize , ioBuffer . length ) ) ; if ( rc == - NUM_ ) { break ; } os . write ( ioBuffer , NUM_ , rc ) ; totalSize += rc ; } return totalSize ; }
public int doFinal ( byte [ ] out , int outOff ) throws DataLengthException , IllegalStateException , InvalidCipherTextException { try { int resultLen = NUM_ ; if ( outOff + bufOff > out . length ) { throw new OutputLengthException ( STR_ ) ; } if ( bufOff != NUM_ ) { if ( ! partialBlockOkay ) { throw new DataLengthException ( STR_ ) ; } cipher . processBlock ( buf , NUM_ , buf , NUM_ ) ; resultLen = bufOff ; bufOff = NUM_ ; System . arraycopy ( buf , NUM_ , out , outOff , resultLen ) ; } return resultLen ; } finally { reset ( ) ; } }
void composeMessage ( final Mail mail , final String textContent , final String htmlContent , final Map < String , byte [ ] > attachments , final List < String > mailTemplateChain , final String shopCode , final String locale , final String templateName ) throws MessagingException , ClassNotFoundException , IOException { if ( textContent == null || htmlContent == null ) { if ( textContent != null ) { mail . setTextVersion ( textContent ) ; } if ( htmlContent != null ) { mail . setHtmlVersion ( htmlContent ) ; inlineResources ( mail , htmlContent , mailTemplateChain , shopCode , locale , templateName ) ; addAttachments ( mail , attachments ) ; } } else { mail . setTextVersion ( textContent ) ; mail . setHtmlVersion ( htmlContent ) ; inlineResources ( mail , htmlContent , mailTemplateChain , shopCode , locale , templateName ) ; addAttachments ( mail , attachments ) ; } }
private void handleLaunchMessageEvent ( MessageEvent messageEvent ) { DataMap dataMap = DataMap . fromByteArray ( messageEvent . getData ( ) ) ; boolean relaunchIfRunning = dataMap . getBoolean ( KEY_START_ACTIVITY_RELAUNCH , BOOL_ ) ; DataMap bundleData = dataMap . getDataMap ( KEY_START_ACTIVITY_BUNDLE ) ; String activityName = dataMap . getString ( KEY_START_ACTIVITY_NAME ) ; Bundle bundle = null ; if ( bundleData != null ) { bundle = bundleData . toBundle ( ) ; } if ( activityName == null ) { for ( WearConsumer consumer : mWearConsumers ) { consumer . onWearableApplicationLaunchRequestReceived ( bundle , relaunchIfRunning ) ; } } else { try { if ( ! TextUtils . isEmpty ( activityName ) ) { Class < ? > targetActivity = Class . forName ( activityName ) ; Intent intent = new Intent ( mContext , targetActivity ) ; intent . setFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; if ( bundle != null ) { intent . putExtras ( bundle ) ; } if ( ! mAppForeground || relaunchIfRunning ) { mContext . startActivity ( intent ) ; } } else { Log . e ( TAG , STR_ ) ; } } catch ( ClassNotFoundException e ) { Log . e ( TAG , STR_ , e ) ; } } }
@ Override public void close ( ) throws IOException { closed = BOOL_ ; def . end ( ) ; in . close ( ) ; }
public static String escapeColonInString ( String str ) { if ( str != null ) { if ( str . indexOf ( STR_ ) >= NUM_ ) { str = str . replaceAll ( STR_ , STR_ ) ; } } return str ; }
protected void tearDown ( ) throws Exception { File file ; file = new File ( m_ExportFilenameData ) ; if ( file . exists ( ) ) file . delete ( ) ; m_ExportFilenameData = null ; super . tearDown ( ) ; }
private static SAXParserFactory createSAXParserFactory ( ) { try { SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; try { SAXParserFactory secureFactory = SecureGenericXMLFactory . getSAXParserFactory ( factory ) ; secureFactory . newSAXParser ( ) ; factory = secureFactory ; } catch ( ParserConfigurationException e ) { } factory . setNamespaceAware ( BOOL_ ) ; return factory ; } catch ( SAXException e ) { throw new IllegalStateException ( STR_ , e ) ; } }
private static void attemptRetryOnException ( String logPrefix , Request < ? > request , VolleyError exception ) throws VolleyError { RetryPolicy retryPolicy = request . getRetryPolicy ( ) ; int oldTimeout = request . getTimeoutMs ( ) ; try { retryPolicy . retry ( exception ) ; } catch ( VolleyError e ) { request . addMarker ( String . format ( STR_ , logPrefix , oldTimeout ) ) ; throw e ; } request . addMarker ( String . format ( STR_ , logPrefix , oldTimeout ) ) ; }
public static void saveAsXML ( NSObject root , File out ) throws IOException { File parent = out . getParentFile ( ) ; if ( ! parent . exists ( ) && ! parent . mkdirs ( ) ) { throw new IOException ( STR_ ) ; } FileOutputStream fous = new FileOutputStream ( out ) ; saveAsXML ( root , fous ) ; fous . close ( ) ; }
public static boolean containsChroot ( String zkHost ) { return zkHost . contains ( STR_ ) ; }
public final void lazySet ( int newValue ) { unsafe . putOrderedInt ( this , valueOffset , newValue ) ; }
public Feature ( String line , Map cpStr2Int , Map lbStr2Int , Map fmap ) { StringTokenizer strTok = new StringTokenizer ( line , STR_ ) ; int len = strTok . countTokens ( ) ; String strIdStr = strTok . nextToken ( ) ; int idx = Integer . parseInt ( strTok . nextToken ( ) ) ; float val = NUM_ ; double wgt = Double . parseDouble ( strTok . nextToken ( ) ) ; StringTokenizer strIdTok = new StringTokenizer ( strIdStr , STR_ ) ; String prefix = strIdTok . nextToken ( ) ; if ( prefix . compareToIgnoreCase ( STR_ ) == NUM_ ) { Integer yInt = ( Integer ) lbStr2Int . get ( strIdTok . nextToken ( ) ) ; Integer ypInt = ( Integer ) lbStr2Int . get ( strIdTok . nextToken ( ) ) ; if ( yInt != null && ypInt != null ) { eFeature1Init ( yInt . intValue ( ) , ypInt . intValue ( ) ) ; } } else if ( prefix . compareToIgnoreCase ( STR_ ) == NUM_ ) { Integer yInt = ( Integer ) lbStr2Int . get ( strIdTok . nextToken ( ) ) ; Integer cpInt = ( Integer ) cpStr2Int . get ( strIdTok . nextToken ( ) ) ; if ( yInt != null && cpInt != null ) { sFeature1Init ( yInt . intValue ( ) , cpInt . intValue ( ) ) ; } } this . idx = idx ; this . val = val ; this . wgt = wgt ; strId2IdxAdd ( fmap ) ; }
public static int patchFast ( InputStream oldInputStream , InputStream diffInputStream , File newFile ) throws IOException { if ( oldInputStream == null ) { return RETURN_OLD_FILE_ERR ; } if ( newFile == null ) { return RETURN_NEW_FILE_ERR ; } if ( diffInputStream == null ) { return RETURN_DIFF_FILE_ERR ; } byte [ ] oldBytes = BSUtil . inputStreamToByte ( oldInputStream ) ; byte [ ] diffBytes = BSUtil . inputStreamToByte ( diffInputStream ) ; byte [ ] newBytes = patchFast ( oldBytes , oldBytes . length , diffBytes , diffBytes . length , NUM_ ) ; OutputStream newOutputStream = new FileOutputStream ( newFile ) ; try { newOutputStream . write ( newBytes ) ; } finally { newOutputStream . close ( ) ; } return RETURN_SUCCESS ; }
public static byte [ ] readFullyNoClose ( InputStream in ) throws IOException { ByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ NUM_ ] ; int count ; while ( ( count = in . read ( buffer ) ) != - NUM_ ) { bytes . write ( buffer , NUM_ , count ) ; } return bytes . toByteArray ( ) ; }
public ContentStorage ( ContentStorageBO contentStorageBO , List < GenericPackage > genericPackageList , List < EssenceContainerData > essenceContainerDataList ) { this . contentStorageBO = contentStorageBO ; this . genericPackageList = Collections . unmodifiableList ( genericPackageList ) ; this . essenceContainerDataList = Collections . unmodifiableList ( essenceContainerDataList ) ; }
public static String decode ( byte [ ] utf8 ) throws CharacterCodingException { return decode ( ByteBuffer . wrap ( utf8 ) , BOOL_ ) ; }
public ScaleIOVolume queryVolume ( String volId ) throws Exception { ClientResponse response = get ( URI . create ( ScaleIOConstants . getVolumeURI ( volId ) ) ) ; return getResponseObject ( ScaleIOVolume . class , response ) ; }
public void removeEventListener ( SIPDialogEventListener oldListener ) { eventListeners . remove ( oldListener ) ; }
protected static Object primitiveArrayPut ( Object self , int idx , Object newValue ) { Array . set ( self , normaliseIndex ( idx , Array . getLength ( self ) ) , newValue ) ; return newValue ; }
@ Override public synchronized void initialize ( ) { if ( ! mRootDirectory . exists ( ) ) { if ( ! mRootDirectory . mkdirs ( ) ) { VolleyLog . e ( STR_ , mRootDirectory . getAbsolutePath ( ) ) ; } return ; } File [ ] files = mRootDirectory . listFiles ( ) ; if ( files == null ) { return ; } for ( File file : files ) { FileInputStream fis = null ; try { fis = new FileInputStream ( file ) ; CacheHeader entry = CacheHeader . readHeader ( fis ) ; entry . size = file . length ( ) ; putEntry ( entry . key , entry ) ; } catch ( IOException e ) { if ( file != null ) { file . delete ( ) ; } } finally { try { if ( fis != null ) { fis . close ( ) ; } } catch ( IOException ignored ) { } } } }
private QNameMap < BindingExpression > processBindingAttributes ( Node node ) { QNameMap < BindingExpression > attributeBindings = null ; for ( Iterator < QName > i = node . getAttributeNames ( ) ; i != null && i . hasNext ( ) ; ) { QName qname = i . next ( ) ; String value = ( String ) node . getAttributeValue ( qname ) ; BindingExpression be = textParser . parseBindingExpression ( value , node . beginLine ) ; if ( be != null ) { if ( attributeBindings == null ) { attributeBindings = new QNameMap < BindingExpression > ( ) ; } attributeBindings . put ( qname , be ) ; i . remove ( ) ; } } return attributeBindings ; }
public void load ( String fileName ) throws IOException { BufferedReader bfr = new BufferedReader ( new InputStreamReader ( new FileInputStream ( fileName ) , STR_ ) ) ; if ( bList == null ) bList = new Vector ( DEFAULT_INCREMENT , DEFAULT_INCREMENT ) ; String line = bfr . readLine ( ) ; if ( line . indexOf ( STR_ ) != - NUM_ ) { line = line . substring ( NUM_ ) ; String [ ] parts = new String [ NUM_ ] ; parts = line . split ( STR_ , NUM_ ) ; fromDir = parts [ NUM_ ] ; fromExt = parts [ NUM_ ] ; } else if ( ! ( line . matches ( STR_ ) ) ) add ( line ) ; while ( ( line = bfr . readLine ( ) ) != null ) { if ( ! ( line . matches ( STR_ ) ) ) add ( line ) ; } }
private void verifyRegisterDefs ( String where ) { DefUse . computeDU ( this ) ; for ( Register r = regpool . getFirstSymbolicRegister ( ) ; r != null ; r = r . getNext ( ) ) { if ( r . isPhysical ( ) ) continue ; if ( r . useList != null ) { if ( r . defList == null ) { printInstructions ( ) ; verror ( where , STR_ + r + STR_ ) ; } } } }
@ SuppressWarnings ( STR_ ) public static PartListing parseListParts ( InputStream responseBody ) throws ResponseParseException { try { Element root = getXmlRootElement ( responseBody ) ; PartListing partListing = new PartListing ( ) ; partListing . setBucketName ( root . getChildText ( STR_ ) ) ; partListing . setKey ( root . getChildText ( STR_ ) ) ; partListing . setUploadId ( root . getChildText ( STR_ ) ) ; partListing . setStorageClass ( root . getChildText ( STR_ ) ) ; partListing . setMaxParts ( Integer . valueOf ( root . getChildText ( STR_ ) ) ) ; partListing . setTruncated ( Boolean . valueOf ( root . getChildText ( STR_ ) ) ) ; if ( root . getChild ( STR_ ) != null ) { String partNumberMarker = root . getChildText ( STR_ ) ; if ( ! isNullOrEmpty ( partNumberMarker ) ) { partListing . setPartNumberMarker ( Integer . valueOf ( partNumberMarker ) ) ; } } if ( root . getChild ( STR_ ) != null ) { String nextPartNumberMarker = root . getChildText ( STR_ ) ; if ( ! isNullOrEmpty ( nextPartNumberMarker ) ) { partListing . setNextPartNumberMarker ( Integer . valueOf ( nextPartNumberMarker ) ) ; } } List < Element > partElems = root . getChildren ( STR_ ) ; for ( Element elem : partElems ) { PartSummary ps = new PartSummary ( ) ; ps . setPartNumber ( Integer . valueOf ( elem . getChildText ( STR_ ) ) ) ; ps . setLastModified ( DateUtil . parseIso8601Date ( elem . getChildText ( STR_ ) ) ) ; ps . setETag ( trimQuotes ( elem . getChildText ( STR_ ) ) ) ; ps . setSize ( Integer . valueOf ( elem . getChildText ( STR_ ) ) ) ; partListing . addPart ( ps ) ; } return partListing ; } catch ( Exception e ) { throw new ResponseParseException ( e . getMessage ( ) , e ) ; } }
private static void findSnap ( Collection < ConstraintWidget > widgets , ConstraintWidget widget , SnapCandidate candidate , boolean checkHorizontal ) { ArrayList < ConstraintAnchor > anchorsSource = widget . getAnchors ( ) ; for ( ConstraintWidget w : widgets ) { if ( w == widget ) { continue ; } ArrayList < ConstraintAnchor > anchorsTarget = w . getAnchors ( ) ; for ( ConstraintAnchor as : anchorsSource ) { if ( checkHorizontal && as . isVerticalAnchor ( ) ) { continue ; } else if ( ! checkHorizontal && ! as . isVerticalAnchor ( ) ) { continue ; } for ( ConstraintAnchor at : anchorsTarget ) { snapCheck ( as , at , candidate , CONNECTION_SLOPE ) ; } } } }
protected String padString ( String s , int length , boolean left ) { String result ; int i ; result = s ; for ( i = s . length ( ) ; i < length ; i ++ ) { if ( left ) { result = STR_ + result ; } else { result = result + STR_ ; } } if ( ( length > NUM_ ) && ( result . length ( ) > length ) ) { result = result . substring ( NUM_ , length ) ; } return result ; }
public static < C extends Comparable < ? > > List < Range < C > > remove ( Range < C > self , Range < C > other ) { if ( other == null || ! self . isConnected ( other ) ) { return Collections . singletonList ( self ) ; } Range < C > share = self . intersection ( other ) ; if ( share . isEmpty ( ) ) { return Collections . singletonList ( self ) ; } List < Range < C > > ret = Lists . newArrayList ( ) ; if ( ! self . hasLowerBound ( ) ) { if ( share . hasLowerBound ( ) ) { if ( share . lowerBoundType ( ) == BoundType . CLOSED ) { ret . add ( Range . lessThan ( share . lowerEndpoint ( ) ) ) ; } else { ret . add ( Range . atMost ( share . lowerEndpoint ( ) ) ) ; } } } else { if ( self . lowerEndpoint ( ) != share . lowerEndpoint ( ) ) { if ( self . lowerBoundType ( ) == BoundType . CLOSED ) { if ( share . lowerBoundType ( ) == BoundType . CLOSED ) { ret . add ( Range . closedOpen ( self . lowerEndpoint ( ) , share . lowerEndpoint ( ) ) ) ; } else { ret . add ( Range . closed ( self . lowerEndpoint ( ) , share . lowerEndpoint ( ) ) ) ; } } else { if ( share . lowerBoundType ( ) == BoundType . CLOSED ) { ret . add ( Range . open ( self . lowerEndpoint ( ) , share . lowerEndpoint ( ) ) ) ; } else { ret . add ( Range . openClosed ( self . lowerEndpoint ( ) , share . lowerEndpoint ( ) ) ) ; } } } else { if ( self . lowerBoundType ( ) == BoundType . CLOSED && share . lowerBoundType ( ) == BoundType . OPEN ) { ret . add ( Range . closed ( self . lowerEndpoint ( ) , share . lowerEndpoint ( ) ) ) ; } } } if ( ! self . hasUpperBound ( ) ) { if ( share . hasUpperBound ( ) ) { if ( share . upperBoundType ( ) == BoundType . CLOSED ) { ret . add ( Range . greaterThan ( share . upperEndpoint ( ) ) ) ; } else { ret . add ( Range . atLeast ( share . upperEndpoint ( ) ) ) ; } } } else { if ( self . upperEndpoint ( ) != share . upperEndpoint ( ) ) { if ( self . upperBoundType ( ) == BoundType . CLOSED ) { if ( share . upperBoundType ( ) == BoundType . CLOSED ) { ret . add ( Range . openClosed ( share . upperEndpoint ( ) , self . upperEndpoint ( ) ) ) ; } else { ret . add ( Range . closed ( share . upperEndpoint ( ) , self . upperEndpoint ( ) ) ) ; } } else { if ( share . upperBoundType ( ) == BoundType . CLOSED ) { ret . add ( Range . open ( share . upperEndpoint ( ) , self . upperEndpoint ( ) ) ) ; } else { ret . add ( Range . closedOpen ( share . upperEndpoint ( ) , self . upperEndpoint ( ) ) ) ; } } } else { if ( self . upperBoundType ( ) == BoundType . CLOSED && share . upperBoundType ( ) == BoundType . OPEN ) { ret . add ( Range . closed ( self . upperEndpoint ( ) , share . upperEndpoint ( ) ) ) ; } } } return ret ; }
void recomposeKeys ( KeyDeclaration keyDecl ) { m_keyDecls . addElement ( keyDecl ) ; }
public < T > JsonArray < T > createListDtoFromJson ( Reader json , Class < T > dtoInterface ) throws IOException { final DtoProvider < T > dtoProvider = getDtoProvider ( dtoInterface ) ; final List < JsonElement > list ; try { list = gson . fromJson ( json , listTypeCache . get ( JsonElement . class ) ) ; } catch ( JsonSyntaxException e ) { final Throwable cause = e . getCause ( ) ; if ( cause instanceof IOException ) { throw ( IOException ) cause ; } throw e ; } final List < T > result = new ArrayList < > ( list . size ( ) ) ; for ( JsonElement e : list ) { result . add ( dtoProvider . fromJson ( e ) ) ; } return new JsonArrayImpl < > ( result ) ; }
private View fillFromTop ( int nextTop ) { mFirstPosition = Math . min ( mFirstPosition , - NUM_ ) ; mFirstPosition = Math . min ( mFirstPosition , mItemCount - NUM_ ) ; if ( mFirstPosition < NUM_ ) { mFirstPosition = NUM_ ; } return fillDown ( mFirstPosition , nextTop ) ; }
public void connectionOpen ( ) { lock . lock ( ) ; try { log . info ( STR_ ) ; connectionOpen = BOOL_ ; } finally { lock . unlock ( ) ; } }
public void list ( PrintStream out ) { properties . list ( out ) ; }
protected LayerPane findSelectedPane ( ) { for ( LayerPane pane : getPanes ( ) ) { if ( pane . isSelected ( ) ) { return pane ; } } return null ; }
public Object [ ] toArray ( ) { ArrayList < E > al = new ArrayList < E > ( ) ; for ( Node < E > p = first ( ) ; p != null ; p = succ ( p ) ) { E item = p . item ; if ( item != null ) al . add ( item ) ; } return al . toArray ( ) ; }
public MicroservicesRunner ( int ... ports ) { configureTransport ( ports ) ; }
public static boolean deleteContents ( File directory ) { File [ ] files = directory . listFiles ( ) ; boolean success = BOOL_ ; if ( files != null ) { for ( File file : files ) { success &= deleteRecursively ( file ) ; } } return success ; }
private void handleResponse ( AvsResponse response ) { mEventManager . post ( new CommandEvent ( CommandEvent . TYPE_COMMAND_SEARCHING , KEYWORD_ALEXA ) ) ; if ( response != null ) { for ( int i = response . size ( ) - NUM_ ; i >= NUM_ ; i -- ) { if ( response . get ( i ) instanceof AvsReplaceAllItem || response . get ( i ) instanceof AvsReplaceEnqueuedItem ) { mAvsQueue . clear ( ) ; response . remove ( i ) ; } } Timber . i ( STR_ , response . size ( ) ) ; mAvsQueue . addAll ( response ) ; } checkQueue ( ) ; }
void mergesort ( Vector a , Vector b , int l , int r , XPathContext support ) throws TransformerException { if ( ( r - l ) > NUM_ ) { int m = ( r + l ) / NUM_ ; mergesort ( a , b , l , m , support ) ; mergesort ( a , b , m + NUM_ , r , support ) ; int i , j , k ; for ( i = m ; i >= l ; i -- ) { if ( i >= b . size ( ) ) b . insertElementAt ( a . elementAt ( i ) , i ) ; else b . setElementAt ( a . elementAt ( i ) , i ) ; } i = l ; for ( j = ( m + NUM_ ) ; j <= r ; j ++ ) { if ( r + m + NUM_ - j >= b . size ( ) ) b . insertElementAt ( a . elementAt ( j ) , r + m + NUM_ - j ) ; else b . setElementAt ( a . elementAt ( j ) , r + m + NUM_ - j ) ; } j = r ; int compVal ; for ( k = l ; k <= r ; k ++ ) { if ( i == j ) compVal = - NUM_ ; else compVal = compare ( ( NodeCompareElem ) b . elementAt ( i ) , ( NodeCompareElem ) b . elementAt ( j ) , NUM_ , support ) ; if ( compVal < NUM_ ) { a . setElementAt ( b . elementAt ( i ) , k ) ; i ++ ; } else if ( compVal > NUM_ ) { a . setElementAt ( b . elementAt ( j ) , k ) ; j -- ; } } } }
public static List < String > toList ( CharSequence self ) { String s = self . toString ( ) ; int size = s . length ( ) ; List < String > answer = new ArrayList < String > ( size ) ; for ( int i = NUM_ ; i < size ; i ++ ) { answer . add ( s . substring ( i , i + NUM_ ) ) ; } return answer ; }
void appendArrayGenericType ( StringBuilder sb , Type [ ] types ) { if ( types . length > NUM_ ) { appendGenericType ( sb , types [ NUM_ ] ) ; for ( int i = NUM_ ; i < types . length ; i ++ ) { sb . append ( STR_ ) ; appendGenericType ( sb , types [ i ] ) ; } } }
public static int decode_residual ( H264Context h , GetBitContext gb , short [ ] block_base , int block_offset , int n , int [ ] scantable_base , int scantable_offset , long [ ] qmul_base , int qmul_offset , int max_coeff ) { final int [ ] coeff_token_table_index = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int [ ] level = new int [ NUM_ ] ; int zeros_left , coeff_token , total_coeff , i , trailing_ones , run_before ; if ( n >= H264Context . CHROMA_DC_BLOCK_INDEX ) { coeff_token = gb . get_vlc2 ( chroma_dc_coeff_token_vlc . table_base , chroma_dc_coeff_token_vlc . table_offset , H264Context . CHROMA_DC_COEFF_TOKEN_VLC_BITS , NUM_ , STR_ ) ; total_coeff = coeff_token > > NUM_ ; } else { if ( n == H264Context . LUMA_DC_BLOCK_INDEX ) { total_coeff = pred_non_zero_count ( h , NUM_ ) ; coeff_token = gb . get_vlc2 ( coeff_token_vlc [ coeff_token_table_index [ total_coeff ] ] . table_base , coeff_token_vlc [ coeff_token_table_index [ total_coeff ] ] . table_offset , H264Context . COEFF_TOKEN_VLC_BITS , NUM_ , STR_ ) ; total_coeff = coeff_token > > NUM_ ; } else { total_coeff = pred_non_zero_count ( h , n ) ; coeff_token = gb . get_vlc2 ( coeff_token_vlc [ coeff_token_table_index [ total_coeff ] ] . table_base , coeff_token_vlc [ coeff_token_table_index [ total_coeff ] ] . table_offset , H264Context . COEFF_TOKEN_VLC_BITS , NUM_ , STR_ ) ; total_coeff = coeff_token > > NUM_ ; } } h . non_zero_count_cache [ H264Context . scan8 [ n ] ] = total_coeff ; if ( total_coeff == NUM_ ) return NUM_ ; if ( total_coeff > max_coeff ) { return - NUM_ ; } trailing_ones = coeff_token & NUM_ ; i = ( int ) gb . show_bits ( NUM_ ) ; gb . skip_bits ( trailing_ones ) ; level [ NUM_ ] = NUM_ - ( ( i & NUM_ ) > > NUM_ ) ; level [ NUM_ ] = NUM_ - ( ( i & NUM_ ) ) ; level [ NUM_ ] = NUM_ - ( ( i & NUM_ ) << NUM_ ) ; if ( trailing_ones < total_coeff ) { int mask , prefix ; int suffix_length = ( ( total_coeff > NUM_ ) ? NUM_ : NUM_ ) & ( ( trailing_ones < NUM_ ) ? NUM_ : NUM_ ) ; int bitsi = ( int ) gb . show_bits ( LEVEL_TAB_BITS ) ; int level_code = cavlc_level_tab [ suffix_length ] [ bitsi ] [ NUM_ ] ; gb . skip_bits ( cavlc_level_tab [ suffix_length ] [ bitsi ] [ NUM_ ] ) ; if ( level_code >= NUM_ ) { prefix = level_code - NUM_ ; if ( prefix == LEVEL_TAB_BITS ) prefix += get_level_prefix ( gb ) ; if ( prefix < NUM_ ) { if ( suffix_length != NUM_ ) level_code = ( int ) ( ( prefix << NUM_ ) + gb . get_bits1 ( STR_ ) ) ; else level_code = prefix ; } else if ( prefix == NUM_ ) { if ( suffix_length != NUM_ ) level_code = ( int ) ( ( prefix << NUM_ ) + gb . get_bits1 ( STR_ ) ) ; else level_code = ( int ) ( prefix + gb . get_bits ( NUM_ , STR_ ) ) ; } else { level_code = NUM_ + ( int ) ( gb . get_bits ( prefix - NUM_ , STR_ ) ) ; if ( prefix >= NUM_ ) { if ( prefix > NUM_ + NUM_ ) { return - NUM_ ; } level_code += ( NUM_ << ( prefix - NUM_ ) ) - NUM_ ; } } if ( trailing_ones < NUM_ ) level_code += NUM_ ; suffix_length = NUM_ ; mask = - ( level_code & NUM_ ) ; level [ trailing_ones ] = ( ( ( NUM_ + level_code ) > > NUM_ ) ^ mask ) - mask ; } else { level_code += ( ( level_code > > NUM_ ) | NUM_ ) & - ( ( trailing_ones < NUM_ ) ? NUM_ : NUM_ ) ; suffix_length = NUM_ + ( ( ( xffffffffL & ( level_code + NUM_ ) ) > NUM_ ) ? NUM_ : NUM_ ) ; level [ trailing_ones ] = level_code ; } for ( i = trailing_ones + NUM_ ; i < total_coeff ; i ++ ) { final int [ ] suffix_limit = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , Integer . MAX_VALUE } ; bitsi = ( int ) gb . show_bits ( LEVEL_TAB_BITS ) ; level_code = cavlc_level_tab [ suffix_length ] [ bitsi ] [ NUM_ ] ; gb . skip_bits ( cavlc_level_tab [ suffix_length ] [ bitsi ] [ NUM_ ] ) ; if ( level_code >= NUM_ ) { prefix = level_code - NUM_ ; if ( prefix == LEVEL_TAB_BITS ) { prefix += get_level_prefix ( gb ) ; } if ( prefix < NUM_ ) { level_code = ( int ) ( ( prefix << suffix_length ) + gb . get_bits ( suffix_length , STR_ ) ) ; } else { level_code = ( int ) ( ( NUM_ << suffix_length ) + gb . get_bits ( prefix - NUM_ , STR_ ) ) ; if ( prefix >= NUM_ ) level_code += ( NUM_ << ( prefix - NUM_ ) ) - NUM_ ; } mask = - ( level_code & NUM_ ) ; level_code = ( ( ( NUM_ + level_code ) > > NUM_ ) ^ mask ) - mask ; } level [ i ] = level_code ; suffix_length += ( ( ( xffffffffL & ( suffix_limit [ suffix_length ] + level_code ) ) > ( NUM_ . suffix_limit [ suffix_length ] ) ) ? NUM_ : NUM_ ) ; } } if ( total_coeff == max_coeff ) zeros_left = NUM_ ; else { if ( n >= H264Context . CHROMA_DC_BLOCK_INDEX ) { zeros_left = gb . get_vlc2 ( chroma_dc_total_zeros_vlc [ total_coeff - NUM_ ] . table_base , chroma_dc_total_zeros_vlc [ total_coeff - NUM_ ] . table_offset , H264Context . CHROMA_DC_TOTAL_ZEROS_VLC_BITS , NUM_ , STR_ ) ; } else { zeros_left = gb . get_vlc2 ( total_zeros_vlc [ total_coeff - NUM_ ] . table_base , total_zeros_vlc [ total_coeff - NUM_ ] . table_offset , H264Context . TOTAL_ZEROS_VLC_BITS , NUM_ , STR_ ) ; } } scantable_offset += zeros_left + total_coeff - NUM_ ; if ( scantable_offset < NUM_ ) { int [ ] new_scantable_base = new int [ scantable_base . length + ( - scantable_offset ) ] ; System . arraycopy ( scantable_base , NUM_ , new_scantable_base , - scantable_offset , scantable_base . length ) ; scantable_base = new_scantable_base ; scantable_offset = NUM_ ; } if ( n >= H264Context . LUMA_DC_BLOCK_INDEX ) { block_base [ block_offset + scantable_base [ scantable_offset ] ] = ( short ) level [ NUM_ ] ; for ( i = NUM_ ; i < total_coeff && zeros_left > NUM_ ; i ++ ) { if ( zeros_left < NUM_ ) { run_before = gb . get_vlc2 ( run_vlc [ zeros_left - NUM_ ] . table_base , run_vlc [ zeros_left - NUM_ ] . table_offset , H264Context . RUN_VLC_BITS , NUM_ , STR_ ) ; } else { run_before = gb . get_vlc2 ( run7_vlc . table_base , run7_vlc . table_offset , H264Context . RUN7_VLC_BITS , NUM_ , STR_ ) ; } zeros_left -= run_before ; scantable_offset -= NUM_ + run_before ; block_base [ block_offset + scantable_base [ scantable_offset ] ] = ( short ) level [ i ] ; } for ( ; i < total_coeff ; i ++ ) { scantable_offset -- ; block_base [ block_offset + scantable_base [ scantable_offset ] ] = ( short ) level [ i ] ; } } else { block_base [ block_offset + scantable_base [ scantable_offset ] ] = ( short ) ( ( level [ NUM_ ] . qmul_base [ qmul_offset + scantable_base [ scantable_offset ] ] + NUM_ ) > > NUM_ ) ; for ( i = NUM_ ; i < total_coeff && zeros_left > NUM_ ; i ++ ) { if ( zeros_left < NUM_ ) { run_before = gb . get_vlc2 ( run_vlc [ zeros_left - NUM_ ] . table_base , run_vlc [ zeros_left - NUM_ ] . table_offset , H264Context . RUN_VLC_BITS , NUM_ , STR_ ) ; } else { run_before = gb . get_vlc2 ( run7_vlc . table_base , run7_vlc . table_offset , H264Context . RUN7_VLC_BITS , NUM_ , STR_ ) ; } zeros_left -= run_before ; scantable_offset -= ( NUM_ + run_before ) ; block_base [ block_offset + scantable_base [ scantable_offset ] ] = ( short ) ( ( level [ i ] . qmul_base [ qmul_offset + scantable_base [ scantable_offset ] ] + NUM_ ) > > NUM_ ) ; } for ( ; i < total_coeff ; i ++ ) { scantable_offset -- ; block_base [ block_offset + scantable_base [ scantable_offset ] ] = ( short ) ( ( level [ i ] . qmul_base [ qmul_offset + scantable_base [ scantable_offset ] ] + NUM_ ) > > NUM_ ) ; } } if ( zeros_left < NUM_ ) { return - NUM_ ; } return NUM_ ; }
public void checkReinitFile ( final boolean needReinit ) throws IOException { File bootModeFile = new File ( rootDir , Constants . STARTUPMODE ) ; if ( ! needReinit ) { log . info ( STR_ ) ; if ( bootModeFile . exists ( ) ) { bootModeFile . delete ( ) ; } return ; } if ( ! bootModeFile . exists ( ) ) { setDbStartupModeAsRestoreReinit ( rootDir ) ; } chown ( bootModeFile , BackupConstants . STORAGEOS_USER , BackupConstants . STORAGEOS_GROUP ) ; log . info ( STR_ , bootModeFile . getAbsolutePath ( ) ) ; }
private float clampMag ( float value , float absMin , float absMax ) { final float absValue = Math . abs ( value ) ; if ( absValue < absMin ) return NUM_ ; if ( absValue > absMax ) return value > NUM_ ? absMax : - absMax ; return value ; }
public void readDOT ( Reader input ) { DotParser dp = new DotParser ( input , m_nodes , m_edges ) ; graphID = dp . parse ( ) ; setAppropriateNodeSize ( ) ; if ( m_le != null ) { m_le . setNodeSize ( paddedNodeWidth , nodeHeight ) ; jBtLayout . setEnabled ( BOOL_ ) ; layoutGraph ( ) ; } }
private void notifyAllEntity ( ) { Log . printConcatLine ( super . getName ( ) , STR_ ) ; signalShutdown ( resList ) ; signalShutdown ( gisList ) ; resList . clear ( ) ; gisList . clear ( ) ; }
protected Response calcDefaultSMTPResponse ( HookResult result ) { if ( result != null ) { int rCode = result . getResult ( ) ; String smtpRetCode = result . getSmtpRetCode ( ) ; String smtpDesc = result . getSmtpDescription ( ) ; if ( ( rCode & HookReturnCode . DENY ) == HookReturnCode . DENY ) { if ( smtpRetCode == null ) smtpRetCode = SMTPRetCode . AUTH_FAILED ; if ( smtpDesc == null ) smtpDesc = STR_ ; SMTPResponse response = new SMTPResponse ( smtpRetCode , smtpDesc ) ; if ( ( rCode & HookReturnCode . DISCONNECT ) == HookReturnCode . DISCONNECT ) { response . setEndSession ( BOOL_ ) ; } return response ; } else if ( ( rCode & HookReturnCode . DENYSOFT ) == HookReturnCode . DENYSOFT ) { if ( smtpRetCode == null ) smtpRetCode = SMTPRetCode . LOCAL_ERROR ; if ( smtpDesc == null ) smtpDesc = STR_ ; SMTPResponse response = new SMTPResponse ( smtpRetCode , smtpDesc ) ; if ( ( rCode & HookReturnCode . DISCONNECT ) == HookReturnCode . DISCONNECT ) { response . setEndSession ( BOOL_ ) ; } return response ; } else if ( ( rCode & HookReturnCode . OK ) == HookReturnCode . OK ) { if ( smtpRetCode == null ) smtpRetCode = SMTPRetCode . AUTH_OK ; if ( smtpDesc == null ) smtpDesc = STR_ ; SMTPResponse response = new SMTPResponse ( smtpRetCode , smtpDesc ) ; if ( ( rCode & HookReturnCode . DISCONNECT ) == HookReturnCode . DISCONNECT ) { response . setEndSession ( BOOL_ ) ; } return response ; } else if ( ( rCode & HookReturnCode . DISCONNECT ) == HookReturnCode . DISCONNECT ) { SMTPResponse response = new SMTPResponse ( STR_ ) ; response . setEndSession ( BOOL_ ) ; return response ; } else { return null ; } } else { return null ; } }
public synchronized boolean hasAlerts ( ) { if ( alerts == null ) { return BOOL_ ; } return ! alerts . isEmpty ( ) ; }
public void testCompareToPosPos1 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int bSign = NUM_ ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; assertEquals ( NUM_ , aNumber . compareTo ( bNumber ) ) ; }
protected Collection < ? extends AnnotationMirror > replacePolyAll ( Collection < ? extends AnnotationMirror > annos ) { Set < AnnotationMirror > returnAnnos = AnnotationUtils . createAnnotationSet ( ) ; for ( AnnotationMirror top : getTopAnnotations ( ) ) { AnnotationMirror annotationInHierarchy = findAnnotationInHierarchy ( annos , top ) ; if ( annotationInHierarchy != null ) { returnAnnos . add ( annotationInHierarchy ) ; } } return returnAnnos ; }
public synchronized void resetInputs ( ) throws IOException { source . printStatistics ( STR_ ) ; setConfig ( config , source ) ; source . resetInputs ( ) ; numDocsCreated . set ( NUM_ ) ; resetLeftovers ( ) ; }
public void removeMatchingCoupling ( Coupling < ? > toRemove ) { for ( Coupling < ? > coupling : getCouplings ( ) ) { boolean consumersMatch = attributesMatch ( coupling . getConsumer ( ) , toRemove . getConsumer ( ) ) ; boolean producersMatch = attributesMatch ( coupling . getProducer ( ) , toRemove . getProducer ( ) ) ; if ( consumersMatch && producersMatch ) { removeCoupling ( coupling ) ; } } }
public String toShortString ( ) { StringBuilder sb = new StringBuilder ( ) ; if ( xRoadInstance != null ) { sb . append ( xRoadInstance ) ; } for ( String part : getFieldsForStringFormat ( ) ) { if ( part != null ) { if ( sb . length ( ) > NUM_ ) { sb . append ( STR_ ) ; } sb . append ( part ) ; } } return sb . toString ( ) ; }
private boolean checkPattern ( ) { if ( pattern == null ) { return BOOL_ ; } char leftSeparator = getLeftSeparator ( ) ; char rightSeparator = getRightSeparator ( ) ; Stack < Character > separatorStack = new Stack < Character > ( ) ; for ( int i = NUM_ ; i < pattern . length ( ) ; i ++ ) { char cur = pattern . charAt ( i ) ; if ( cur == leftSeparator ) { separatorStack . push ( cur ) ; } else if ( cur == rightSeparator ) { if ( ! separatorStack . isEmpty ( ) && ( separatorStack . pop ( ) == leftSeparator ) ) { continue ; } else { return BOOL_ ; } } } return separatorStack . isEmpty ( ) ; }
public static SQLiteDatabase openOrCreateDatabase ( File file , CursorFactory factory ) { return openOrCreateDatabase ( file . getPath ( ) , factory ) ; }
public String toString ( cp_info constant_pool [ ] ) { return Integer . toString ( ( int ) bytes ) ; }
private void clampStartingPosition ( ) { final float cX = mBounds . exactCenterX ( ) ; final float cY = mBounds . exactCenterY ( ) ; final float dX = mStartingX - cX ; final float dY = mStartingY - cY ; final float r = mTargetRadius ; if ( dX . dX + dY . dY > r . r ) { final double angle = Math . atan2 ( dY , dX ) ; mClampedStartingX = cX + ( float ) ( Math . cos ( angle ) . r ) ; mClampedStartingY = cY + ( float ) ( Math . sin ( angle ) . r ) ; } else { mClampedStartingX = mStartingX ; mClampedStartingY = mStartingY ; } }
public Wildcard ( String pattern , int regexpOptions ) { this . regexpOptions = regexpOptions ; regexp = Pattern . compile ( wildcardToRegex ( pattern ) , regexpOptions ) ; shortcut = extractShortcut ( pattern ) ; }
private boolean linkLast ( Node < E > node ) { if ( count >= capacity ) return BOOL_ ; Node < E > l = last ; node . prev = l ; last = node ; if ( first == null ) first = node ; else l . next = node ; ++ count ; notEmpty . signal ( ) ; return BOOL_ ; }
private String local_number ( ) throws ParseException { StringBuffer s = new StringBuffer ( ) ; if ( debug ) dbg_enter ( STR_ ) ; try { int lc = NUM_ ; while ( lexer . hasMoreChars ( ) ) { char la = lexer . lookAhead ( NUM_ ) ; if ( la == STR_ || la == STR_ || la == STR_ || la == STR_ || la == STR_ || la == STR_ || Lexer . isHexDigit ( la ) ) { lexer . consume ( NUM_ ) ; s . append ( la ) ; lc ++ ; } else if ( lc > NUM_ ) break ; else throw createParseException ( STR_ + la ) ; } return s . toString ( ) ; } finally { if ( debug ) dbg_leave ( STR_ ) ; } }
private static void appendDefaultValue ( StringBuilder sb , FieldType fieldType , Object defaultValue ) { if ( fieldType . isEscapedDefaultValue ( ) ) { appendEscapedWord ( sb , defaultValue . toString ( ) ) ; } else { sb . append ( defaultValue ) ; } }
public MetadataBlockDataPicture ( ByteBuffer rawdata ) throws IOException , InvalidFrameException { initFromByteBuffer ( rawdata ) ; }
public void previous ( ) { if ( current ( ) == null ) { return ; } m_currentSearchIndex -- ; m_isBeforeFirst = BOOL_ ; m_isAfterLast = BOOL_ ; if ( m_currentSearchIndex < NUM_ ) { m_currentSearchIndex = m_reducedResults . size ( ) - NUM_ ; m_isBeforeFirst = BOOL_ ; } }
public void testZeroOne ( ) { byte aBytes [ ] = { NUM_ } ; byte bBytes [ ] = { NUM_ } ; int aSign = NUM_ ; int bSign = NUM_ ; byte rBytes [ ] = { NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . or ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
@ Nullable public static Method findMethod ( Class c , String name , Object ... params ) { Class [ ] paramTypes = getParamTypes ( params ) ; Method method = null ; try { method = c . getDeclaredMethod ( name , paramTypes ) ; } catch ( NoSuchMethodException e ) { try { method = c . getMethod ( name , paramTypes ) ; } catch ( NoSuchMethodException e1 ) { } } if ( method != null ) method . setAccessible ( BOOL_ ) ; return method ; }
public void testPosZero ( ) { byte aBytes [ ] = { - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ } ; int aSign = NUM_ ; int bSign = NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . or ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public boolean closeAllSessions ( ) { while ( existsSession ( ) ) { SessionEditor sessionEditor = getFrontmostSessionEditor ( ) ; SessionEditorWorkbench workbench = sessionEditor . getSessionWorkbench ( ) ; SessionWrapper wrapper = workbench . getSessionWrapper ( ) ; if ( ! wrapper . isSessionChanged ( ) ) { closeFrontmostSession ( ) ; continue ; } String name = sessionEditor . getName ( ) ; int ret = JOptionPane . showConfirmDialog ( JOptionUtils . centeringComp ( ) , STR_ + name + STR_ , STR_ , JOptionPane . YES_NO_CANCEL_OPTION ) ; if ( ret == JOptionPane . NO_OPTION ) { closeFrontmostSession ( ) ; continue ; } else if ( ret == JOptionPane . CANCEL_OPTION ) { return BOOL_ ; } SaveSessionAsAction action = new SaveSessionAsAction ( ) ; action . actionPerformed ( new ActionEvent ( this , ActionEvent . ACTION_PERFORMED , STR_ ) ) ; if ( ! action . isSaved ( ) ) { int ret2 = JOptionPane . showConfirmDialog ( JOptionUtils . centeringComp ( ) , STR_ , STR_ , JOptionPane . OK_CANCEL_OPTION ) ; if ( ret2 == JOptionPane . CANCEL_OPTION ) { return BOOL_ ; } } closeFrontmostSession ( ) ; } return BOOL_ ; }
private void removeNonVisibleViews ( final int offset ) { int childCount = getChildCount ( ) ; if ( mLastItemPosition != mAdapter . getCount ( ) - NUM_ && childCount > NUM_ ) { View firstChild = getChildAt ( NUM_ ) ; while ( firstChild != null && getChildBottom ( firstChild ) + offset < NUM_ ) { removeViewInLayout ( firstChild ) ; childCount -- ; mCachedItemViews . addLast ( firstChild ) ; mFirstItemPosition ++ ; mListTopOffset += getChildHeight ( firstChild ) ; if ( childCount > NUM_ ) { firstChild = getChildAt ( NUM_ ) ; } else { firstChild = null ; } } } if ( mFirstItemPosition != NUM_ && childCount > NUM_ ) { View lastChild = getChildAt ( childCount - NUM_ ) ; while ( lastChild != null && getChildTop ( lastChild ) + offset > getHeight ( ) ) { removeViewInLayout ( lastChild ) ; childCount -- ; mCachedItemViews . addLast ( lastChild ) ; mLastItemPosition -- ; if ( childCount > NUM_ ) { lastChild = getChildAt ( childCount - NUM_ ) ; } else { lastChild = null ; } } } }
public RepeatedFieldBuilder < MType , BType , IType > addMessage ( int index , MType message ) { if ( message == null ) { throw new NullPointerException ( ) ; } ensureMutableMessageList ( ) ; messages . add ( index , message ) ; if ( builders != null ) { builders . add ( index , null ) ; } onChanged ( ) ; incrementModCounts ( ) ; return this ; }
void unlock ( Table t ) { locks . remove ( t ) ; }
public void onExceededDatabaseQuota ( String url , String databaseIdentifier , long currentQuota , long estimatedSize , long totalUsedQuota , WebStorage . QuotaUpdater quotaUpdater ) { if ( LOGV_ENABLED ) { Log . v ( LOGTAG , STR_ + url + STR_ + databaseIdentifier + STR_ + currentQuota + STR_ + totalUsedQuota + STR_ ) ; } long totalUnusedQuota = mGlobalLimit - totalUsedQuota - mAppCacheMaxSize ; if ( totalUnusedQuota <= NUM_ ) { if ( totalUsedQuota > NUM_ ) { scheduleOutOfSpaceNotification ( ) ; } quotaUpdater . updateQuota ( currentQuota ) ; if ( LOGV_ENABLED ) { Log . v ( LOGTAG , STR_ ) ; } return ; } long newOriginQuota = currentQuota ; if ( newOriginQuota == NUM_ ) { if ( totalUnusedQuota >= estimatedSize ) { newOriginQuota = estimatedSize ; } else { if ( LOGV_ENABLED ) { Log . v ( LOGTAG , STR_ + STR_ + STR_ + estimatedSize + STR_ + totalUnusedQuota ) ; } newOriginQuota = NUM_ ; } } else { long quotaIncrease = estimatedSize == NUM_ ? Math . min ( QUOTA_INCREASE_STEP , totalUnusedQuota ) : estimatedSize ; newOriginQuota += quotaIncrease ; if ( quotaIncrease > totalUnusedQuota ) { newOriginQuota = currentQuota ; } } quotaUpdater . updateQuota ( newOriginQuota ) ; if ( LOGV_ENABLED ) { Log . v ( LOGTAG , STR_ + newOriginQuota ) ; } }
protected String toValString ( Set vals ) { StringBuilder sb = new StringBuilder ( ) ; boolean first = BOOL_ ; for ( Iterator i = vals . iterator ( ) ; i . hasNext ( ) ; ) { String val = ( String ) i . next ( ) ; val = encodeVal ( val ) ; if ( first ) { first = BOOL_ ; } else { sb . append ( STR_ ) ; } sb . append ( val ) ; } return sb . toString ( ) ; }
private String printOFormat ( short x ) { String sx = null ; if ( x == Short . MIN_VALUE ) sx = STR_ ; else if ( x < NUM_ ) { String t = Integer . toString ( ( ~ ( - x - NUM_ ) ) ^ Short . MIN_VALUE , NUM_ ) ; switch ( t . length ( ) ) { case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; } } else sx = Integer . toString ( x , NUM_ ) ; return printOFormat ( sx ) ; }
public static JSONArray readJSONArray ( final JSONArray jsonArray , final int index , final boolean required , final boolean notNull ) throws JSONException { if ( required ) { return jsonArray . getJSONArray ( index ) ; } if ( notNull && jsonArray . isNull ( index ) ) { throw new JSONException ( String . format ( Locale . US , NULL_VALUE_FORMAT_ARRAY , index ) ) ; } JSONArray value = null ; if ( ! jsonArray . isNull ( index ) ) { value = jsonArray . getJSONArray ( index ) ; } return value ; }
private static Bitmap resizePhoto ( Bitmap realImage , float maxImageSize , boolean filter ) { float ratio = Math . min ( ( float ) maxImageSize / realImage . getWidth ( ) , ( float ) maxImageSize / realImage . getHeight ( ) ) ; int width = Math . round ( ( float ) ratio . realImage . getWidth ( ) ) ; int height = Math . round ( ( float ) ratio . realImage . getHeight ( ) ) ; Bitmap newBitmap = Bitmap . createScaledBitmap ( realImage , width , height , filter ) ; return newBitmap ; }
private Element createKeyValue ( ) throws Exception { Element keyValueEle = null ; PrivateKey key = idmClient . getTenantPrivateKey ( tenantName ) ; if ( key != null ) { RSAPrivateKey rsaKey = ( RSAPrivateKey ) key ; Element rsaKeyEle = createRSAKeyValue ( rsaKey ) ; if ( rsaKeyEle != null ) { keyValueEle = doc . createElement ( SAMLNames . DS_KEYVALUE ) ; keyValueEle . appendChild ( rsaKeyEle ) ; } } return keyValueEle ; }
static protected void expandElement ( Element el , List < Element > list ) { list . addAll ( el . getChildren ( STR_ ) ) ; List < Element > children = el . getChildren ( ) ; for ( int i = NUM_ ; i < children . size ( ) ; i ++ ) { expandElement ( children . get ( i ) , list ) ; } }
public static String dump ( Map < ? , ? > map ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Map . Entry < ? , ? > entry : map . entrySet ( ) ) { stringBuilder . append ( entry . getKey ( ) ) ; stringBuilder . append ( STR_ ) ; stringBuilder . append ( entry . getValue ( ) ) ; } return stringBuilder . toString ( ) ; }
public void changedUpdate ( DocumentEvent e ) { }
private void mergeCollapse ( ) { while ( stackSize > NUM_ ) { int n = stackSize - NUM_ ; if ( n > NUM_ && runLen [ n - NUM_ ] <= runLen [ n ] + runLen [ n + NUM_ ] ) { if ( runLen [ n - NUM_ ] < runLen [ n + NUM_ ] ) n -- ; mergeAt ( n ) ; } else if ( runLen [ n ] <= runLen [ n + NUM_ ] ) { mergeAt ( n ) ; } else { break ; } } }
private File findFile ( File directory , String name ) throws FileNotFoundException { File file = new File ( directory , name ) ; if ( file . exists ( ) ) { return file ; } for ( String child : directory . list ( ) ) { if ( child . equalsIgnoreCase ( name ) ) { return new File ( directory , child ) ; } } throw new FileNotFoundException ( STR_ + file ) ; }
public void forceRewriteExif ( String filename , Collection < ExifTag > tags ) throws FileNotFoundException , IOException { if ( ! rewriteExif ( filename , tags ) ) { ExifData tempData = mData ; mData = new ExifData ( DEFAULT_BYTE_ORDER ) ; FileInputStream is = null ; ByteArrayOutputStream bytes = null ; try { is = new FileInputStream ( filename ) ; bytes = new ByteArrayOutputStream ( ) ; doExifStreamIO ( is , bytes ) ; byte [ ] imageBytes = bytes . toByteArray ( ) ; readExif ( imageBytes ) ; setTags ( tags ) ; writeExif ( imageBytes , filename ) ; } catch ( IOException e ) { closeSilently ( is ) ; throw e ; } finally { is . close ( ) ; mData = tempData ; } } }
private boolean linkLast ( Node < E > node ) { if ( count >= capacity ) return BOOL_ ; Node < E > l = last ; node . prev = l ; last = node ; if ( first == null ) first = node ; else l . next = node ; ++ count ; notEmpty . signal ( ) ; return BOOL_ ; }
protected void removeFromMaps ( String clientType ) { Client client = ( Client ) clientTypeMap . get ( clientType ) ; externalClientData . remove ( clientType ) ; Map map = ( Map ) internalClientData . get ( clientType ) ; if ( map == null ) { removeFromClientMap ( clientType , client ) ; } else { handleParentChange ( clientType , map ) ; } unloadClient ( clientType ) ; }
public String serialize ( Object object ) throws ConverterException { deep = NUM_ ; StringBuilder sb = new StringBuilder ( ) ; _serialize ( object , sb , new HashSet < Object > ( ) ) ; return sb . toString ( ) ; }
private void endList ( boolean orderedList ) { if ( ! mParagraphStyles . isEmpty ( ) ) { AccumulatedParagraphStyle style = mParagraphStyles . peek ( ) ; ParagraphType type = style . getType ( ) ; if ( ( orderedList && ( type . isNumbering ( ) || type == ParagraphType . INDENTATION_OL ) ) || ( ! orderedList && ( type . isBullet ( ) || type == ParagraphType . INDENTATION_UL ) ) ) { int indent = style . getRelativeIndent ( ) ; if ( indent > NUM_ ) { style . setRelativeIndent ( indent - NUM_ ) ; style . setAbsoluteIndent ( style . getAbsoluteIndent ( ) - NUM_ ) ; } else { mParagraphStyles . pop ( ) ; } } else { mParagraphStyles . pop ( ) ; endList ( orderedList ) ; } } }
private void displayVerbose ( ConsoleApplication app , String categoryName , String typeName , Tag tag , Set < String > propertyNames ) { LocalizableMessage c1 = buildLine ( STR_ , MAX_LINE_WIDTH ) ; LocalizableMessage c2 = buildLine ( STR_ , MAX_LINE_WIDTH ) ; boolean isFirstManagedObject = BOOL_ ; for ( String category : categoryMap . keySet ( ) ) { if ( categoryName != null && ! categoryName . equals ( category ) ) { continue ; } Map < String , AbstractManagedObjectDefinition < ? , ? > > subTypes = categoryMap . get ( category ) ; for ( String type : subTypes . keySet ( ) ) { if ( typeName != null && ! typeName . equals ( type ) ) { continue ; } AbstractManagedObjectDefinition < ? , ? > mod = subTypes . get ( type ) ; if ( cannotDisplay ( app , mod , tag ) ) { continue ; } boolean isFirstProperty = BOOL_ ; Set < PropertyDefinition < ? > > pds = getPropertyDefinitions ( mod ) ; for ( PropertyDefinition < ? > pd : pds ) { if ( cannotDisplay ( app , pd , propertyNames ) ) { continue ; } if ( isFirstProperty ) { if ( ! isFirstManagedObject ) { app . println ( ) ; app . println ( c1 ) ; app . println ( ) ; } else { isFirstManagedObject = BOOL_ ; } app . println ( INFO_DSCFG_HELP_HEADING_COMPONENT . get ( mod . getUserFriendlyName ( ) ) ) ; app . println ( ) ; app . println ( mod . getSynopsis ( ) ) ; if ( mod . getDescription ( ) != null ) { app . println ( ) ; app . println ( mod . getDescription ( ) ) ; } } app . println ( ) ; app . println ( c2 ) ; app . println ( ) ; displayVerboseSingleProperty ( app , mod , pd . getName ( ) ) ; isFirstProperty = BOOL_ ; } } } }
private static < T > void findUniqueGoals ( Map < TestCase , Set < T > > testToGoals ) { Map < TestCase , Set < T > > goalMapCopy = new LinkedHashMap < > ( ) ; for ( Map . Entry < TestCase , Set < T > > entry : testToGoals . entrySet ( ) ) { Set < T > goalSet = new LinkedHashSet < T > ( entry . getValue ( ) ) ; for ( Map . Entry < TestCase , Set < T > > otherEntry : testToGoals . entrySet ( ) ) { if ( entry == otherEntry ) continue ; goalSet . removeAll ( otherEntry . getValue ( ) ) ; } goalMapCopy . put ( entry . getKey ( ) , goalSet ) ; } testToGoals . clear ( ) ; testToGoals . putAll ( goalMapCopy ) ; }
private static String formHead ( String hair , String face , String neck ) { return String . join ( STR_ , hair , face , neck ) ; }
public void terminate ( ) { listeners . clear ( ) ; lookupDisc . terminate ( ) ; locatorDisc . terminate ( ) ; if ( dynamicLocatorDisc != null ) dynamicLocatorDisc . terminate ( ) ; }
public void start ( ) { start = System . currentTimeMillis ( ) ; }
@ Nullable public static String extractProtocol ( @ NotNull String url ) { int index = url . indexOf ( URLUtil . SCHEME_SEPARATOR ) ; if ( index < NUM_ ) return null ; return url . substring ( NUM_ , index ) ; }
protected void loadBuffer ( ) { int resIdx = minuteSpacing / NUM_ ; if ( resIdx < NUM_ ) resIdx = NUM_ ; else if ( resIdx > NUM_ ) resIdx = NUM_ ; String fileName = path + etopoFileNames [ resIdx ] ; dataBuffer = null ; try { BinaryBufferedFile binFile = new BinaryBufferedFile ( fileName ) ; binFile . byteOrder ( BOOL_ ) ; bufferWidth = etopoWidths [ resIdx ] ; bufferHeight = etopoHeights [ resIdx ] ; int spacer = NUM_ ; switch ( minuteSpacing ) { case ( NUM_ ) : spacer = NUM_ + this . spacer ; break ; case ( NUM_ ) : spacer = NUM_ + this . spacer ; break ; default : spacer = NUM_ + this . spacer ; } dataBuffer = new short [ ( bufferWidth + spacer ) . bufferHeight ] ; for ( int i = NUM_ ; i < bufferWidth . bufferHeight ; i ++ ) dataBuffer [ i ] = binFile . readShort ( ) ; binFile . close ( ) ; bufferWidth += spacer ; } catch ( FileNotFoundException e ) { Debug . error ( STR_ + fileName + STR_ ) ; } catch ( IOException e ) { Debug . error ( STR_ + e . toString ( ) ) ; } catch ( FormatException e ) { Debug . error ( STR_ + e . toString ( ) ) ; } }
protected VersionTag fetchRemoteVersionTag ( Object key ) { VersionTag tag = null ; assert this . dataPolicy != DataPolicy . REPLICATE ; TransactionId txId = cache . getCacheTransactionManager ( ) . suspend ( ) ; try { boolean retry = BOOL_ ; InternalDistributedMember member = getRandomReplicate ( ) ; while ( retry ) { try { if ( member == null ) { break ; } FetchVersionResponse response = RemoteFetchVersionMessage . send ( member , this , key ) ; tag = response . waitForResponse ( ) ; retry = BOOL_ ; } catch ( RemoteOperationException e ) { member = getRandomReplicate ( ) ; if ( member != null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STR_ , member ) ; } } } } } finally { if ( txId != null ) { cache . getCacheTransactionManager ( ) . resume ( txId ) ; } } return tag ; }
public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { if ( oldChild == null || oldChild . getParentNode ( ) != this ) return null ; ElemTemplateElement newChildElem = ( ( ElemTemplateElement ) newChild ) ; ElemTemplateElement oldChildElem = ( ( ElemTemplateElement ) oldChild ) ; ElemTemplateElement prev = ( ElemTemplateElement ) oldChildElem . getPreviousSibling ( ) ; if ( null != prev ) prev . m_nextSibling = newChildElem ; if ( m_firstChild == oldChildElem ) m_firstChild = newChildElem ; newChildElem . m_parentNode = this ; oldChildElem . m_parentNode = null ; newChildElem . m_nextSibling = oldChildElem . m_nextSibling ; oldChildElem . m_nextSibling = null ; return newChildElem ; }
public void paintDirty ( ) { int size = NUM_ ; synchronized ( displayLock ) { size = paintQueueFill ; Animation [ ] array = paintQueue ; paintQueue = paintQueueTemp ; paintQueueTemp = array ; paintQueueFill = NUM_ ; } if ( size > NUM_ ) { Graphics wrapper = getCodenameOneGraphics ( ) ; int dwidth = getDisplayWidth ( ) ; int dheight = getDisplayHeight ( ) ; int topX = dwidth ; int topY = dheight ; int bottomX = NUM_ ; int bottomY = NUM_ ; for ( int iter = NUM_ ; iter < size ; iter ++ ) { Animation ani = paintQueueTemp [ iter ] ; if ( ani == null ) { continue ; } paintQueueTemp [ iter ] = null ; wrapper . translate ( - wrapper . getTranslateX ( ) , - wrapper . getTranslateY ( ) ) ; wrapper . setClip ( NUM_ , NUM_ , dwidth , dheight ) ; if ( ani instanceof Component ) { Component cmp = ( Component ) ani ; Rectangle dirty = cmp . getDirtyRegion ( ) ; if ( dirty != null ) { Dimension d = dirty . getSize ( ) ; wrapper . setClip ( dirty . getX ( ) , dirty . getY ( ) , d . getWidth ( ) , d . getHeight ( ) ) ; cmp . setDirtyRegion ( null ) ; } cmp . paintComponent ( wrapper ) ; getPaintableBounds ( cmp , paintDirtyTmpRect ) ; int cmpAbsX = paintDirtyTmpRect . getX ( ) ; topX = Math . min ( cmpAbsX , topX ) ; bottomX = Math . max ( cmpAbsX + paintDirtyTmpRect . getWidth ( ) , bottomX ) ; int cmpAbsY = paintDirtyTmpRect . getY ( ) ; topY = Math . min ( cmpAbsY , topY ) ; bottomY = Math . max ( cmpAbsY + paintDirtyTmpRect . getHeight ( ) , bottomY ) ; } else { bottomX = dwidth ; bottomY = dheight ; topX = NUM_ ; topY = NUM_ ; ani . paint ( wrapper ) ; } } paintOverlay ( wrapper ) ; flushGraphics ( topX , topY , bottomX - topX , bottomY - topY ) ; } }
public static FSize calcTextSize ( Paint paint , String demoText ) { Rect r = new Rect ( ) ; paint . getTextBounds ( demoText , NUM_ , demoText . length ( ) , r ) ; return new FSize ( r . width ( ) , r . height ( ) ) ; }
private boolean parseDelimiters ( DelimiterProcessor delimiterProcessor , char delimiterChar ) { DelimiterData res = scanDelimiters ( delimiterProcessor , delimiterChar ) ; if ( res == null ) { return BOOL_ ; } int numDelims = res . count ; int startIndex = index ; index += numDelims ; Text node = appendText ( input , startIndex , index ) ; lastDelimiter = new Delimiter ( node , delimiterChar , res . canOpen , res . canClose , lastDelimiter ) ; lastDelimiter . numDelims = numDelims ; if ( lastDelimiter . previous != null ) { lastDelimiter . previous . next = lastDelimiter ; } return BOOL_ ; }
private void clearMoney ( ) { money . clear ( ) ; updateMoney ( ) ; }
private void multiTouchController ( ) { if ( DEBUG ) Log . i ( STR_ , STR_ + mMode + STR_ + mCurrPt . getNumTouchPoints ( ) + STR_ + mCurrPt . isDown ( ) + mCurrPt . isMultiTouch ( ) ) ; switch ( mMode ) { case MODE_NOTHING : if ( DEBUG ) Log . i ( STR_ , STR_ ) ; if ( mCurrPt . isDown ( ) ) { selectedObject = objectCanvas . getDraggableObjectAtPoint ( mCurrPt ) ; if ( selectedObject != null ) { mMode = MODE_DRAG ; objectCanvas . selectObject ( selectedObject , mCurrPt ) ; anchorAtThisPositionAndScale ( ) ; mSettleStartTime = mSettleEndTime = mCurrPt . getEventTime ( ) ; } } break ; case MODE_DRAG : if ( DEBUG ) Log . i ( STR_ , STR_ ) ; if ( ! mCurrPt . isDown ( ) ) { mMode = MODE_NOTHING ; objectCanvas . selectObject ( ( selectedObject = null ) , mCurrPt ) ; } else if ( mCurrPt . isMultiTouch ( ) ) { mMode = MODE_PINCH ; anchorAtThisPositionAndScale ( ) ; mSettleStartTime = mCurrPt . getEventTime ( ) ; mSettleEndTime = mSettleStartTime + EVENT_SETTLE_TIME_INTERVAL ; } else { if ( mCurrPt . getEventTime ( ) < mSettleEndTime ) { anchorAtThisPositionAndScale ( ) ; } else { performDragOrPinch ( ) ; } } break ; case MODE_PINCH : if ( DEBUG ) Log . i ( STR_ , STR_ ) ; if ( ! mCurrPt . isMultiTouch ( ) || ! mCurrPt . isDown ( ) ) { if ( ! mCurrPt . isDown ( ) ) { mMode = MODE_NOTHING ; objectCanvas . selectObject ( ( selectedObject = null ) , mCurrPt ) ; } else { mMode = MODE_DRAG ; anchorAtThisPositionAndScale ( ) ; mSettleStartTime = mCurrPt . getEventTime ( ) ; mSettleEndTime = mSettleStartTime + EVENT_SETTLE_TIME_INTERVAL ; } } else { if ( Math . abs ( mCurrPt . getX ( ) - mPrevPt . getX ( ) ) > MAX_MULTITOUCH_POS_JUMP_SIZE || Math . abs ( mCurrPt . getY ( ) - mPrevPt . getY ( ) ) > MAX_MULTITOUCH_POS_JUMP_SIZE || Math . abs ( mCurrPt . getMultiTouchWidth ( ) - mPrevPt . getMultiTouchWidth ( ) ) . NUM_ > MAX_MULTITOUCH_DIM_JUMP_SIZE || Math . abs ( mCurrPt . getMultiTouchHeight ( ) - mPrevPt . getMultiTouchHeight ( ) ) . NUM_ > MAX_MULTITOUCH_DIM_JUMP_SIZE ) { anchorAtThisPositionAndScale ( ) ; mSettleStartTime = mCurrPt . getEventTime ( ) ; mSettleEndTime = mSettleStartTime + EVENT_SETTLE_TIME_INTERVAL ; } else if ( mCurrPt . eventTime < mSettleEndTime ) { anchorAtThisPositionAndScale ( ) ; } else { performDragOrPinch ( ) ; } } break ; } if ( DEBUG ) Log . i ( STR_ , STR_ + mMode + STR_ + mCurrPt . getNumTouchPoints ( ) + STR_ + mCurrPt . isDown ( ) + mCurrPt . isMultiTouch ( ) ) ; }
public void exec ( String [ ] args ) throws Throwable { URLClassLoader urlClassLoader = new URLClassLoader ( classPath . toArray ( new URL [ classPath . size ( ) ] ) ) ; Class < ? > cls = urlClassLoader . loadClass ( mainClass ) ; Method method = cls . getDeclaredMethod ( STR_ , String [ ] . class ) ; method . setAccessible ( BOOL_ ) ; try { method . invoke ( null , new Object [ ] { args } ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } }
public static String toString ( URI uri , Charset encoding ) throws IOException { return toString ( uri . toURL ( ) , Charsets . toCharset ( encoding ) ) ; }
void rollbackLocalTransaction ( ) throws RollbackFailedException { if ( _tx == null ) { return ; } try { if ( _logger . isLoggable ( Level . FINEST ) ) { _logger . log ( Level . FINEST , STR_ + _tx ) ; } _tx . abort ( ) ; } catch ( Exception e ) { if ( _logger . isLoggable ( Level . SEVERE ) ) { _logger . log ( Level . SEVERE , STR_ + _tx , e ) ; } throw new RollbackFailedException ( e ) ; } }
public void write ( char c [ ] , int off , int len ) { if ( ( off < NUM_ ) || ( off > c . length ) || ( len < NUM_ ) || ( ( off + len ) > c . length ) || ( ( off + len ) < NUM_ ) ) { throw new IndexOutOfBoundsException ( ) ; } else if ( len == NUM_ ) { return ; } synchronized ( lock ) { int newcount = count + len ; if ( newcount > buf . length ) { buf = Arrays . copyOf ( buf , Math . max ( buf . length << NUM_ , newcount ) ) ; } System . arraycopy ( c , off , buf , count , len ) ; count = newcount ; } }
private void writeJarPostResource ( StringBuilder sb , String path ) { sb . append ( STR_ + JAR_RESOURCE_SET + STR_ ) ; sb . append ( path . replace ( STR_ , STR_ ) ) ; }
public static String normalize ( String value ) { if ( value == null ) return value ; value = value . trim ( ) ; if ( value . indexOf ( STR_ ) == - NUM_ ) return value ; boolean space = BOOL_ ; int len = value . length ( ) ; StringBuffer b = new StringBuffer ( len ) ; for ( int i = NUM_ ; i < len ; i ++ ) { char v = value . charAt ( i ) ; if ( v == STR_ ) { if ( ! space ) b . append ( v ) ; space = BOOL_ ; } else { b . append ( v ) ; space = BOOL_ ; } } return b . toString ( ) ; }
protected static void appendDecorations ( int basePos , String sourceCode , CreateSimpleLexer langHandler , List < Object > out ) { if ( sourceCode == null ) { throw new NullPointerException ( STR_ ) ; } Job job = new Job ( ) ; job . setSourceCode ( sourceCode ) ; job . setBasePos ( basePos ) ; langHandler . decorate ( job ) ; out . addAll ( job . getDecorations ( ) ) ; }
protected CarbonDictionaryColumnMetaChunk readLastChunkFromDictionaryMetadataFile ( DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier ) throws IOException { DictionaryService dictService = CarbonCommonFactory . getDictionaryService ( ) ; CarbonDictionaryMetadataReader columnMetadataReaderImpl = dictService . getDictionaryMetadataReader ( dictionaryColumnUniqueIdentifier . getCarbonTableIdentifier ( ) , dictionaryColumnUniqueIdentifier . getColumnIdentifier ( ) , carbonStorePath ) ; CarbonDictionaryColumnMetaChunk carbonDictionaryColumnMetaChunk = null ; try { carbonDictionaryColumnMetaChunk = columnMetadataReaderImpl . readLastEntryOfDictionaryMetaChunk ( ) ; } finally { columnMetadataReaderImpl . close ( ) ; } return carbonDictionaryColumnMetaChunk ; }
public static ExternalAppId determineExternalIntentSource ( String packageName , Intent intent ) { String appId = IntentUtils . safeGetStringExtra ( intent , Browser . EXTRA_APPLICATION_ID ) ; ExternalAppId externalId = ExternalAppId . OTHER ; if ( appId == null ) { String url = getUrlFromIntent ( intent ) ; if ( url != null && url . startsWith ( TWITTER_LINK_PREFIX ) ) { externalId = ExternalAppId . TWITTER ; } else if ( url != null && url . startsWith ( FACEBOOK_LINK_PREFIX ) ) { externalId = ExternalAppId . FACEBOOK ; } else if ( url != null && url . startsWith ( NEWS_LINK_PREFIX ) ) { externalId = ExternalAppId . NEWS ; } } else { if ( appId . equals ( PACKAGE_PLUS ) ) { externalId = ExternalAppId . PLUS ; } else if ( appId . equals ( PACKAGE_GMAIL ) ) { externalId = ExternalAppId . GMAIL ; } else if ( appId . equals ( PACKAGE_HANGOUTS ) ) { externalId = ExternalAppId . HANGOUTS ; } else if ( appId . equals ( PACKAGE_MESSENGER ) ) { externalId = ExternalAppId . MESSENGER ; } else if ( appId . equals ( PACKAGE_LINE ) ) { externalId = ExternalAppId . LINE ; } else if ( appId . equals ( PACKAGE_WHATSAPP ) ) { externalId = ExternalAppId . WHATSAPP ; } else if ( appId . equals ( PACKAGE_GSA ) ) { externalId = ExternalAppId . GSA ; } else if ( appId . equals ( packageName ) ) { externalId = ExternalAppId . CHROME ; } } return externalId ; }
protected TableHDU ( Header hdr , T td ) { super ( hdr , td ) ; }
public void pushStylesheet ( Stylesheet s ) { if ( m_stylesheets . size ( ) == NUM_ ) m_stylesheetRoot = ( StylesheetRoot ) s ; m_stylesheets . push ( s ) ; }
public boolean isBlank ( final CharSequence cs ) { int strLen ; if ( cs == null || ( strLen = cs . length ( ) ) == NUM_ ) { return BOOL_ ; } for ( int i = NUM_ ; i < strLen ; i ++ ) { if ( ! Character . isWhitespace ( cs . charAt ( i ) ) ) { return BOOL_ ; } } return BOOL_ ; }
public void stop ( ) throws IOException , InterruptedException { thread . interrupt ( ) ; selector . wakeup ( ) ; }
private Document parse ( final String data , DocumentBuilder docBuilder ) { if ( docBuilder == null || data == null ) { return null ; } Document document = null ; try { StringBuilder buf = new StringBuilder ( NUM_ ) ; if ( ! data . startsWith ( STR_ ) ) { buf . append ( BEGIN_PART ) ; } buf . append ( data ) ; if ( ! data . endsWith ( END_PART ) ) { buf . append ( END_PART ) ; } InputSource inputSource = new InputSource ( new StringReader ( buf . toString ( ) ) ) ; document = docBuilder . parse ( inputSource ) ; } catch ( Exception e ) { LOGGER . warn ( STR_ + e . getMessage ( ) ) ; } return document ; }
private XNetReply loadChars ( java . io . BufferedReader istream ) throws java . io . IOException { String s = STR_ ; s = istream . readLine ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + s ) ; } if ( s == null ) { return null ; } else { return new XNetReply ( s ) ; } }
public synchronized void removeConnectionManager ( final HttpConnectionManager connectionManager ) { if ( shutdown ) { throw new IllegalStateException ( STR_ ) ; } connectionManagers . remove ( connectionManager ) ; }
private boolean addState ( long stateNumber ) { if ( firstState < NUM_ ) { firstState = stateNumber ; } else if ( stepSize < NUM_ ) { stepSize = ( int ) ( stateNumber - firstState ) ; } else { int step = ( int ) ( stateNumber - lastState ) ; if ( step != stepSize ) { return BOOL_ ; } } lastState = stateNumber ; return BOOL_ ; }
public void reset ( ) { adler = NUM_ ; }
public static boolean isLibraryResourceRoot ( @ Nullable VirtualFile res ) { if ( res != null ) { VirtualFile aar = res . getParent ( ) ; if ( aar != null ) { VirtualFile exploded = aar . getParent ( ) ; if ( exploded != null ) { String name = exploded . getName ( ) ; if ( name . equals ( EXPLODED_BUNDLES ) || name . equals ( EXPLODED_AAR ) ) { return BOOL_ ; } } } } return BOOL_ ; }
public void failEngine ( String reason , @ Nullable Throwable failure ) { if ( failEngineLock . tryLock ( ) ) { store . incRef ( ) ; try { try { closeNoLock ( STR_ + reason + STR_ ) ; } finally { if ( failedEngine != null ) { logger . debug ( STR_ , reason , failure ) ; return ; } logger . warn ( STR_ , failure , reason ) ; failedEngine = ( failure != null ) ? failure : new IllegalStateException ( reason ) ; if ( Lucene . isCorruptionException ( failure ) ) { try { store . markStoreCorrupted ( new IOException ( STR_ + reason + STR_ , ExceptionsHelper . unwrapCorruption ( failure ) ) ) ; } catch ( IOException e ) { logger . warn ( STR_ , e ) ; } } failedEngineListener . onFailedEngine ( shardId , reason , failure ) ; } } catch ( Throwable t ) { logger . warn ( STR_ , t ) ; } finally { store . decRef ( ) ; } } else { logger . debug ( STR_ , reason , failure ) ; } }
public void clear ( ) { values . clear ( ) ; }
@ Override default CompletableFuture < OptionalInt > maxInt ( final ToIntFunction < ? super T > fn ) { return CompletableFuture . supplyAsync ( null , getExec ( ) ) ; }
private void addVNXFileStorageSystemIntoCache ( String storageSystemURI , DistributedQueueItemProcessedCallback callBack ) { if ( StringUtils . isNotEmpty ( storageSystemURI ) ) { VNXFILE_CACHE . put ( storageSystemURI , callBack ) ; } }
void resetToPreferredSizes ( int availableSize ) { int [ ] testSizes = getPreferredSizes ( ) ; int totalSize = NUM_ ; for ( int counter = NUM_ ; counter < NUM_ ; counter ++ ) { if ( testSizes [ counter ] != - NUM_ ) { totalSize += testSizes [ counter ] ; } } if ( totalSize > availableSize ) { testSizes = getMinimumSizes ( ) ; totalSize = NUM_ ; for ( int counter = NUM_ ; counter < NUM_ ; counter ++ ) { if ( testSizes [ counter ] != - NUM_ ) { totalSize += testSizes [ counter ] ; } } } setSizes ( testSizes ) ; distributeSpace ( availableSize - totalSize , BOOL_ ) ; }
@ Override public byte [ ] decode ( byte [ ] data ) throws Exception { if ( data [ NUM_ ] == NUM_ && data [ NUM_ ] == NUM_ && data [ NUM_ ] == NUM_ ) { return data ; } int bufSize = NUM_ ; FastByteArrayOutputStream bos = null ; boolean failed = BOOL_ ; final int orgSize = data . length ; if ( data != null ) { while ( failed ) { final Inflater inf = new Inflater ( ) ; inf . setInput ( data ) ; final int size = data . length ; bos = new FastByteArrayOutputStream ( size ) ; if ( size < bufSize ) { bufSize = size ; } final byte [ ] buf = new byte [ bufSize ] ; int count ; try { while ( ! inf . finished ( ) ) { count = inf . inflate ( buf ) ; bos . write ( buf , NUM_ , count ) ; if ( inf . getRemaining ( ) == NUM_ ) { break ; } } failed = BOOL_ ; } catch ( final Exception ee ) { LogWriter . writeLog ( STR_ + ee ) ; failed = BOOL_ ; hasError = BOOL_ ; if ( data . length == orgSize && data . length > NUM_ ) { failed = BOOL_ ; } else if ( data . length > NUM_ ) { final byte [ ] newData = new byte [ data . length - NUM_ ] ; System . arraycopy ( data , NUM_ , newData , NUM_ , data . length - NUM_ ) ; data = newData ; } else { failed = BOOL_ ; } } } data = bos . toByteArray ( ) ; return applyPredictor ( predictor , data , colors , bitsPerComponent , columns ) ; } return data ; }
public boolean isProcessing ( ) { return mRunning . get ( ) ; }
public Criteria or ( ) { Criteria criteria = createCriteriaInternal ( ) ; oredCriteria . add ( criteria ) ; return criteria ; }
private static InputStreamReader decompressWith7Zip ( final String archivePath ) throws ConfigurationException { PATH_PROGRAM_7ZIP = ( String ) config . getConfigParameter ( ConfigurationKeys . PATH_PROGRAM_7ZIP ) ; if ( PATH_PROGRAM_7ZIP == null ) { throw ErrorFactory . createConfigurationException ( ErrorKeys . CONFIGURATION_PARAMETER_UNDEFINED ) ; } try { Runtime runtime = Runtime . getRuntime ( ) ; Process p = runtime . exec ( PATH_PROGRAM_7ZIP + STR_ + archivePath + STR_ ) ; return new InputStreamReader ( p . getInputStream ( ) , WIKIPEDIA_ENCODING ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
public void makeImmutable ( ) { if ( isMutable ) { isMutable = BOOL_ ; } }
private final Object arenaExchange ( Object item , boolean timed , long ns ) { Node [ ] a = arena ; Node p = participant . get ( ) ; for ( int i = p . index ; ; ) { int b , m , c ; long j ; Node q = ( Node ) U . getObjectVolatile ( a , j = ( i << ASHIFT ) + ABASE ) ; if ( q != null && U . compareAndSwapObject ( a , j , q , null ) ) { Object v = q . item ; q . match = item ; Thread w = q . parked ; if ( w != null ) U . unpark ( w ) ; return v ; } else if ( i <= ( m = ( b = bound ) & MMASK ) && q == null ) { p . item = item ; if ( U . compareAndSwapObject ( a , j , null , p ) ) { long end = ( timed && m == NUM_ ) ? System . nanoTime ( ) + ns : NUM_ ; Thread t = Thread . currentThread ( ) ; for ( int h = p . hash , spins = SPINS ; ; ) { Object v = p . match ; if ( v != null ) { U . putOrderedObject ( p , MATCH , null ) ; p . item = null ; p . hash = h ; return v ; } else if ( spins > NUM_ ) { h ^= h << NUM_ ; h ^= h > > > NUM_ ; h ^= h << NUM_ ; if ( h == NUM_ ) h = SPINS | ( int ) t . getId ( ) ; else if ( h < NUM_ && ( -- spins & ( ( SPINS > > > NUM_ ) - NUM_ ) ) == NUM_ ) Thread . yield ( ) ; } else if ( U . getObjectVolatile ( a , j ) != p ) spins = SPINS ; else if ( ! t . isInterrupted ( ) && m == NUM_ && ( ! timed || ( ns = end - System . nanoTime ( ) ) > NUM_ ) ) { U . putObject ( t , BLOCKER , this ) ; p . parked = t ; if ( U . getObjectVolatile ( a , j ) == p ) U . park ( BOOL_ , ns ) ; p . parked = null ; U . putObject ( t , BLOCKER , null ) ; } else if ( U . getObjectVolatile ( a , j ) == p && U . compareAndSwapObject ( a , j , p , null ) ) { if ( m != NUM_ ) U . compareAndSwapInt ( this , BOUND , b , b + SEQ - NUM_ ) ; p . item = null ; p . hash = h ; i = p . index >>>= NUM_ ; if ( Thread . interrupted ( ) ) return null ; if ( timed && m == NUM_ && ns <= NUM_ ) return TIMED_OUT ; break ; } } } else p . item = null ; } else { if ( p . bound != b ) { p . bound = b ; p . collides = NUM_ ; i = ( i != m || m == NUM_ ) ? m : m - NUM_ ; } else if ( ( c = p . collides ) < m || m == FULL || ! U . compareAndSwapInt ( this , BOUND , b , b + SEQ + NUM_ ) ) { p . collides = c + NUM_ ; i = ( i == NUM_ ) ? m : i - NUM_ ; } else i = m + NUM_ ; p . index = i ; } } }
public void send ( String data ) throws IOException { DatagramPacket dp = new DatagramPacket ( data . getBytes ( ) , data . length ( ) , multicastGroup ) ; datagramSocket . send ( dp ) ; }
private void removeStaleRangeReferences ( ) { removeStaleReferences ( rangeReferenceQueue , ranges ) ; }
private boolean isExported ( URI id , List < URI > exportedVolumes ) { return exportedVolumes . contains ( id ) ; }
private String fixMonitorLinks ( String fixString , String dumpName ) { if ( fixString . indexOf ( STR_ ) > NUM_ ) { fixString = fixString . replaceAll ( STR_ , STR_ + dumpName + STR_ ) ; } return ( fixString ) ; }
protected static TestDimensionConfig buildStandardDimensionConfig ( TestApiDimensionName dimensionName ) { return new TestDimensionConfig ( dimensionName , dimensionName . asName ( ) , getDefaultKeyValueStore ( dimensionName ) , getDefaultSearchProvider ( ) , getDefaultFields ( ) , getDefaultFields ( ) ) ; }
public String toString ( ) { StringBuffer sb = new StringBuffer ( STR_ ) ; if ( type != SET_CONSTRAINTS ) { sb . append ( type == AS_IS ? STR_ : STR_ ) ; } sb . append ( loader ) ; sb . append ( STR_ ) ; for ( int i = NUM_ ; i < contextElements . length ; i ++ ) { if ( i > NUM_ ) { sb . append ( STR_ ) ; } sb . append ( contextElements [ i ] ) ; } if ( principals == null ) { sb . append ( STR_ ) ; } else { sb . append ( STR_ ) ; for ( int i = NUM_ ; i < principals . length ; i ++ ) { if ( i > NUM_ ) { sb . append ( STR_ ) ; } sb . append ( principals [ i ] ) ; } sb . append ( STR_ ) ; } for ( int i = NUM_ ; i < permissions . length ; i ++ ) { if ( i > NUM_ ) { sb . append ( STR_ ) ; } sb . append ( permissions [ i ] ) ; } sb . append ( STR_ ) ; return sb . toString ( ) ; }
public synchronized void cacheReposts ( List < Long > newRepostIds ) { TreeSet < Long > reposts = new TreeSet < > ( ) ; reposts . addAll ( Longs . asList ( repostCache . get ( ) ) ) ; reposts . addAll ( newRepostIds ) ; repostCache . set ( Longs . toArray ( reposts ) ) ; }
public boolean isNavigationAtBottom ( ) { return ( mSmallestWidthDp >= NUM_ || mInPortrait ) ; }
protected final Class < ? > defineClass ( String className , byte [ ] classRep , int offset , int length ) throws ClassFormatError { return defineClass ( className , classRep , offset , length , null ) ; }
public boolean rewriteExif ( ByteBuffer buf , Collection < ExifTag > tags ) throws IOException { ExifModifier mod = null ; try { mod = new ExifModifier ( buf , this ) ; for ( ExifTag t : tags ) { mod . modifyTag ( t ) ; } return mod . commit ( ) ; } catch ( ExifInvalidFormatException e ) { throw new IOException ( STR_ + e ) ; } }
private void writeNewlineOnDebug ( XMLStreamWriter out ) throws XMLStreamException { if ( LOG . isDebugging ( ) ) { out . writeCharacters ( STR_ ) ; } }
public RequestHandle put ( String url , ResponseHandlerInterface responseHandler ) { return put ( null , url , null , responseHandler ) ; }
public Discretize ( Element discretize , FieldMetaInfo . Optype opType , ArrayList < Attribute > fieldDefs ) throws Exception { super ( opType , fieldDefs ) ; m_fieldName = discretize . getAttribute ( STR_ ) ; m_mapMissingTo = discretize . getAttribute ( STR_ ) ; if ( m_mapMissingTo != null && m_mapMissingTo . length ( ) > NUM_ ) { m_mapMissingDefined = BOOL_ ; } m_defaultValue = discretize . getAttribute ( STR_ ) ; if ( m_defaultValue != null && m_defaultValue . length ( ) > NUM_ ) { m_defaultValueDefined = BOOL_ ; } NodeList dbL = discretize . getElementsByTagName ( STR_ ) ; for ( int i = NUM_ ; i < dbL . getLength ( ) ; i ++ ) { Node dbN = dbL . item ( i ) ; if ( dbN . getNodeType ( ) == Node . ELEMENT_NODE ) { Element dbE = ( Element ) dbN ; DiscretizeBin db = new DiscretizeBin ( dbE , m_opType ) ; m_bins . add ( db ) ; } } if ( fieldDefs != null ) { setUpField ( ) ; } }
private static String quadTree ( final MapTile aTile ) { StringBuilder quadKey = new StringBuilder ( ) ; for ( int i = aTile . zoomLevel ; i > NUM_ ; i -- ) { int digit = NUM_ ; int mask = NUM_ << ( i - NUM_ ) ; if ( ( aTile . x & mask ) != NUM_ ) digit += NUM_ ; if ( ( aTile . y & mask ) != NUM_ ) digit += NUM_ ; quadKey . append ( digit ) ; } return quadKey . toString ( ) ; }
public static int [ ] concatAllInt ( int [ ] ... arrays ) { int totalLength = NUM_ ; final int subArrayCount = arrays . length ; for ( int i = NUM_ ; i < subArrayCount ; ++ i ) { totalLength += arrays [ i ] . length ; } int [ ] result = Arrays . copyOf ( arrays [ NUM_ ] , totalLength ) ; int offset = arrays [ NUM_ ] . length ; for ( int i = NUM_ ; i < subArrayCount ; ++ i ) { System . arraycopy ( arrays [ i ] , NUM_ , result , offset , arrays [ i ] . length ) ; offset += arrays [ i ] . length ; } return result ; }
public static long [ ] ones ( int bits ) { long [ ] v = new long [ ( ( bits - NUM_ ) > > > LONG_LOG2_SIZE ) + NUM_ ] ; final int fillWords = bits > > > LONG_LOG2_SIZE ; final int fillBits = bits & LONG_LOG2_MASK ; Arrays . fill ( v , NUM_ , fillWords , LONG_ALL_BITS ) ; if ( fillWords < v . length ) { v [ v . length - NUM_ ] = ( NUM_ << fillBits ) - NUM_ ; } return v ; }
private boolean checkCurrentKeyAge ( ) throws NumberFormatException { long currentTokenKeyTS = Long . parseLong ( _cachedTokenKeysBundle . getCurrentKeyEntry ( ) ) ; long now = System . currentTimeMillis ( ) ; long diff = now - currentTokenKeyTS ; if ( diff >= _keyRotationIntervalInMsecs ) { return BOOL_ ; } return BOOL_ ; }
public final void pushContextNodeList ( DTMIterator nl ) { m_contextNodeLists . push ( nl ) ; }
public void note ( Element e , String msg ) { messager . printMessage ( Diagnostic . Kind . NOTE , msg , e ) ; }
public static PublicKey generatePublicKey ( String encodedPublicKey ) { try { byte [ ] decodedKey = Base64 . decode ( encodedPublicKey , Base64 . DEFAULT ) ; KeyFactory keyFactory = KeyFactory . getInstance ( KEY_FACTORY_ALGORITHM ) ; return keyFactory . generatePublic ( new X509EncodedKeySpec ( decodedKey ) ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } catch ( InvalidKeySpecException e ) { Log . e ( TAG , STR_ ) ; throw new IllegalArgumentException ( e ) ; } }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . addAll ( Collections . list ( super . listOptions ( ) ) ) ; result . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
public TrustSource add ( File trustedCAPemFile ) { if ( trustedCAPemFile == null ) { throw new IllegalArgumentException ( STR_ ) ; } String pemFileContents ; try { pemFileContents = Files . toString ( trustedCAPemFile , Charset . forName ( STR_ ) ) ; } catch ( IOException e ) { throw new UncheckedIOException ( STR_ + trustedCAPemFile . getAbsolutePath ( ) , e ) ; } return add ( pemFileContents ) ; }
StringVector processSTRINGLIST ( StylesheetHandler handler , String uri , String name , String rawName , String value ) { StringTokenizer tokenizer = new StringTokenizer ( value , STR_ ) ; int nStrings = tokenizer . countTokens ( ) ; StringVector strings = new StringVector ( nStrings ) ; for ( int i = NUM_ ; i < nStrings ; i ++ ) { strings . addElement ( tokenizer . nextToken ( ) ) ; } return strings ; }
private String checkforRegex ( String aRegexFragment ) { final StringBuilder result = new StringBuilder ( ) ; final StringCharacterIterator iterator = new StringCharacterIterator ( aRegexFragment ) ; char character = iterator . current ( ) ; while ( character != CharacterIterator . DONE ) { if ( character == STR_ ) { result . append ( STR_ ) ; } else if ( character == STR_ ) { result . append ( STR_ ) ; } else if ( character == STR_ ) { result . append ( STR_ ) ; } else if ( character == STR_ ) { result . append ( STR_ ) ; } else if ( character == STR_ ) { result . append ( STR_ ) ; } else if ( character == STR_ ) { result . append ( STR_ ) ; } else if ( character == STR_ ) { result . append ( STR_ ) ; } else if ( character == STR_ ) { result . append ( STR_ ) ; } else if ( character == STR_ ) { result . append ( STR_ ) ; } else if ( character == STR_ ) { result . append ( STR_ ) ; } else if ( character == STR_ ) { result . append ( STR_ ) ; } else if ( character == STR_ ) { result . append ( STR_ ) ; } else if ( character == STR_ ) { result . append ( STR_ ) ; } else if ( character == STR_ ) { result . append ( STR_ ) ; } else if ( character == STR_ ) { result . append ( STR_ ) ; } else if ( character == STR_ ) { result . append ( STR_ ) ; } else { result . append ( character ) ; } character = iterator . next ( ) ; } return result . toString ( ) ; }
public static void downto ( Float self , Number to , @ ClosureParams ( FirstParam . class ) Closure closure ) { float to1 = to . floatValue ( ) ; if ( self >= to1 ) { for ( float i = self ; i >= to1 ; i -- ) { closure . call ( i ) ; } } else throw new GroovyRuntimeException ( STR_ + to + STR_ + self + STR_ ) ; }
public static AttributeDescription objectClass ( ) { return OBJECT_CLASS ; }
public void addKeyValueComment ( String keyName , String value ) { int keyIndex ; if ( ( keyIndex = findKeyCommentIndex ( keyName ) ) < NUM_ ) { keyValComments . add ( STR_ + keyName + STR_ + value + STR_ ) ; return ; } log . warn ( STR_ + keyName + STR_ ) ; keyValComments . set ( keyIndex , STR_ + keyName + STR_ + value + STR_ ) ; }
private String isInputChecked ( String dataSet , String value ) { if ( dataSet != null && dataSet . equals ( value ) ) { return STR_ ; } return STR_ ; }
public final void popSubContextList ( ) { m_axesIteratorStack . pop ( ) ; }
private DriverTask createDriverTask ( String taskType ) { String taskID = String . format ( STR_ , HP3PARConstants . DRIVER_NAME , taskType , UUID . randomUUID ( ) ) ; DriverTask task = new HP3PARDriverTask ( taskID ) ; return task ; }
public static void write ( File file , CharSequence data , Charset encoding , boolean append ) throws IOException { String str = data == null ? null : data . toString ( ) ; writeStringToFile ( file , str , encoding , append ) ; }
public void store ( Element cat , List < String > trees ) { CatalogTreeManager manager = InstanceManager . getDefault ( jmri . CatalogTreeManager . class ) ; cat . setAttribute ( STR_ , STR_ ) ; Iterator < String > iter = trees . iterator ( ) ; while ( iter . hasNext ( ) ) { String sname = iter . next ( ) ; if ( sname == null ) { log . error ( STR_ ) ; continue ; } if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + sname ) ; } if ( sname . charAt ( NUM_ ) != CatalogTree . XML ) { continue ; } CatalogTree ct = manager . getBySystemName ( sname ) ; Element elem = new Element ( STR_ ) ; elem . setAttribute ( STR_ , sname ) ; String uname = ct . getUserName ( ) ; if ( uname != null ) { elem . setAttribute ( STR_ , uname ) ; } storeNode ( elem , ct . getRoot ( ) ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + sname ) ; } cat . addContent ( elem ) ; } }
public boolean isEnabled ( ) { return enabled ; }
public Criteria createCriteria ( ) { Criteria criteria = createCriteriaInternal ( ) ; if ( oredCriteria . size ( ) == NUM_ ) { oredCriteria . add ( criteria ) ; } return criteria ; }
public static boolean loadTexture ( int glId , int file ) { InputStream is = Resource . getResInputStream ( file ) ; Bitmap bitmap = null ; try { BitmapFactory . Options opts = new BitmapFactory . Options ( ) ; opts . inScaled = BOOL_ ; bitmap = BitmapFactory . decodeStream ( is , null , opts ) ; } catch ( Exception e ) { Log . e ( TAG , STR_ + file , e ) ; return BOOL_ ; } finally { try { is . close ( ) ; } catch ( Exception e ) { Log . e ( TAG , STR_ , e ) ; } } return loadTexture ( glId , bitmap ) ; }
public static int roll1D100 ( ) { return rand . nextInt ( NUM_ ) + NUM_ ; }
public ZipfianGenerator ( long min , long max , double _zipfianconstant , double _zetan ) { items = max - min + NUM_ ; base = min ; zipfianconstant = _zipfianconstant ; theta = zipfianconstant ; zeta2theta = zeta ( NUM_ , theta ) ; alpha = NUM_ / ( NUM_ - theta ) ; zetan = _zetan ; countforzeta = items ; eta = ( NUM_ - Math . pow ( NUM_ / items , NUM_ - theta ) ) / ( NUM_ - zeta2theta / zetan ) ; nextInt ( ) ; }
public void removeRole ( RoleEntity role ) { roles . remove ( role ) ; }
final boolean transferAfterCancelledWait ( Node node ) { if ( compareAndSetWaitStatus ( node , Node . CONDITION , NUM_ ) ) { enq ( node ) ; return BOOL_ ; } while ( ! isOnSyncQueue ( node ) ) Thread . yield ( ) ; return BOOL_ ; }
private Map processEvent ( MatchResult result ) { Map map = new HashMap ( ) ; for ( int i = NUM_ ; i < result . groupCount ( ) + NUM_ ; i ++ ) { Object key = matchingKeywords . get ( i - NUM_ ) ; Object value = result . group ( i ) ; map . put ( key , value ) ; } return map ; }
public void addExtension ( String ext ) { exts . add ( ext . toLowerCase ( ) ) ; }
private void displaySimple ( PrintStream output ) { output . println ( STR_ ) ; for ( int j = NUM_ ; j < P ; j ++ ) { double [ ] a0 = new double [ N ] ; double [ ] a1 = new double [ N ] ; double [ ] a2 = new double [ N ] ; for ( int i = NUM_ ; i < N ; i ++ ) { a0 [ i ] = A [ i ] ; a1 [ i ] = C_A [ i ] [ j ] ; a2 [ i ] = B [ i ] ; } double value = computeFirstOrder ( a0 , a1 , a2 , N ) ; output . print ( value < NUM_ ? NUM_ : value ) ; if ( j < P - NUM_ ) { output . print ( STR_ ) ; } } output . println ( ) ; output . println ( STR_ ) ; for ( int j = NUM_ ; j < P ; j ++ ) { double [ ] a0 = new double [ N ] ; double [ ] a1 = new double [ N ] ; double [ ] a2 = new double [ N ] ; for ( int i = NUM_ ; i < N ; i ++ ) { a0 [ i ] = A [ i ] ; a1 [ i ] = C_A [ i ] [ j ] ; a2 [ i ] = B [ i ] ; } double value = computeTotalOrder ( a0 , a1 , a2 , N ) ; output . print ( value < NUM_ ? NUM_ : value ) ; if ( j < P - NUM_ ) { output . print ( STR_ ) ; } } output . println ( ) ; }
public boolean equals ( Object o ) { if ( o == this ) return BOOL_ ; if ( ! ( o instanceof MBeanAttributeInfo ) ) return BOOL_ ; MBeanAttributeInfo p = ( MBeanAttributeInfo ) o ; return ( Objects . equals ( p . getName ( ) , getName ( ) ) && Objects . equals ( p . getType ( ) , getType ( ) ) && Objects . equals ( p . getDescription ( ) , getDescription ( ) ) && Objects . equals ( p . getDescriptor ( ) , getDescriptor ( ) ) && p . isReadable ( ) == isReadable ( ) && p . isWritable ( ) == isWritable ( ) && p . isIs ( ) == isIs ( ) ) ; }
protected boolean handleDirectory ( File directory , String [ ] contentNames ) throws SecurityException { boolean continueWandering = BOOL_ ; for ( String child : contentNames ) { boolean keepGoing = handleEntry ( new File ( directory . getAbsolutePath ( ) + File . separator , child ) ) ; if ( ! keepGoing ) { continueWandering = exhaustiveSearch ; if ( ! continueWandering ) { break ; } } } return continueWandering ; }
int size ( ) { return Integer . bitCount ( set ) ; }
public boolean hasNext ( ) { return iterator . hasNext ( ) ; }
public static double vectorDistance ( double [ ] vec1 , double [ ] vec2 , double power , double oneOverPower ) { double result = NUM_ ; if ( power == NUM_ ) { for ( int i = NUM_ ; i < vec1 . length ; i ++ ) { result += vec1 [ i ] - vec2 [ i ] == NUM_ ? NUM_ : NUM_ ; } } else if ( power == NUM_ ) { for ( int i = NUM_ ; i < vec1 . length ; i ++ ) { result += Math . abs ( vec1 [ i ] - vec2 [ i ] ) ; } } else if ( power == NUM_ ) { result = Math . sqrt ( distSquaredCartesian ( vec1 , vec2 ) ) ; } else if ( power == Integer . MAX_VALUE || Double . isInfinite ( power ) ) { for ( int i = NUM_ ; i < vec1 . length ; i ++ ) { result = Math . max ( result , Math . max ( vec1 [ i ] , vec2 [ i ] ) ) ; } } else { for ( int i = NUM_ ; i < vec1 . length ; i ++ ) { result += Math . pow ( vec1 [ i ] - vec2 [ i ] , power ) ; } result = Math . pow ( result , oneOverPower ) ; } return result ; }
public static String formatNumber ( final long number ) { long divided = number ; final StringBuffer sb = new StringBuffer ( ) ; while ( divided > NUM_ ) { long rest = divided % NUM_ ; sb . insert ( NUM_ , STR_ + String . format ( STR_ , rest ) ) ; divided = divided / NUM_ ; } long rest = divided % NUM_ ; sb . insert ( NUM_ , rest ) ; return sb . toString ( ) ; }
private boolean isSubsumed ( String selector , Iterable < String > others ) { for ( String other : others ) { if ( subsumes ( other , selector ) ) { return BOOL_ ; } } return BOOL_ ; }
private void displayValues ( ) { log ( STR_ , Project . MSG_INFO ) ; log ( STR_ + this . spec ) ; log ( STR_ + getSpecAbsolutePath ( ) ) ; log ( STR_ + getSerializedSpecAbsolutePath ( ) ) ; log ( STR_ + this . specdir ) ; log ( STR_ + this . cup2srcdir ) ; log ( STR_ + this . classpath ) ; log ( STR_ + this . algorithm ) ; log ( STR_ + this . verbose ) ; log ( STR_ + this . parsetable ) ; log ( STR_ ) ; }
private List < View > addView ( View view , List < View > cache ) { if ( cache == null ) { cache = new LinkedList < View > ( ) ; } cache . add ( view ) ; return cache ; }
private boolean checkTouchingMinTarget ( int index , MotionEvent event ) { if ( isTouchingMinTarget ( index , event ) ) { lastTouchedMin = BOOL_ ; isTouchingMinTarget . add ( event . getPointerId ( index ) ) ; if ( ! minAnimator . isRunning ( ) ) { minAnimator = getMinTargetAnimator ( BOOL_ ) ; minAnimator . start ( ) ; } return BOOL_ ; } return BOOL_ ; }
public boolean isCanceled ( ) { if ( pane == null ) return BOOL_ ; Object v = pane . getValue ( ) ; return ( ( v != null ) && ( cancelOption . length == NUM_ ) && ( v . equals ( cancelOption [ NUM_ ] ) ) ) ; }
public int availableProcessors ( ) { return RVMThread . availableProcessors ; }
public void updateDebug ( Boolean debug , Boolean database , Boolean exception , Boolean tracing , Boolean dump , Boolean timer , Boolean implicitAccess , Boolean queryUsage ) throws SecurityException { checkWriteAccess ( ) ; boolean hasAccess = ConfigWebUtil . hasAccess ( config , SecurityManager . TYPE_DEBUGGING ) ; if ( ! hasAccess ) throw new SecurityException ( STR_ ) ; Element debugging = _getRootElement ( STR_ ) ; if ( debug != null ) debugging . setAttribute ( STR_ , Caster . toString ( debug . booleanValue ( ) ) ) ; else debugging . removeAttribute ( STR_ ) ; if ( database != null ) debugging . setAttribute ( STR_ , Caster . toString ( database . booleanValue ( ) ) ) ; else debugging . removeAttribute ( STR_ ) ; if ( exception != null ) debugging . setAttribute ( STR_ , Caster . toString ( exception . booleanValue ( ) ) ) ; else debugging . removeAttribute ( STR_ ) ; if ( tracing != null ) debugging . setAttribute ( STR_ , Caster . toString ( tracing . booleanValue ( ) ) ) ; else debugging . removeAttribute ( STR_ ) ; if ( dump != null ) debugging . setAttribute ( STR_ , Caster . toString ( dump . booleanValue ( ) ) ) ; else debugging . removeAttribute ( STR_ ) ; if ( timer != null ) debugging . setAttribute ( STR_ , Caster . toString ( timer . booleanValue ( ) ) ) ; else debugging . removeAttribute ( STR_ ) ; if ( implicitAccess != null ) debugging . setAttribute ( STR_ , Caster . toString ( implicitAccess . booleanValue ( ) ) ) ; else debugging . removeAttribute ( STR_ ) ; if ( queryUsage != null ) debugging . setAttribute ( STR_ , Caster . toString ( queryUsage . booleanValue ( ) ) ) ; else debugging . removeAttribute ( STR_ ) ; }
public final static void debug ( String s ) { if ( DEBUG ) debug . println ( STR_ + s ) ; }
public static final void writeLongArrayXml ( long [ ] val , String name , XmlSerializer out ) throws XmlPullParserException , IOException { if ( val == null ) { out . startTag ( null , STR_ ) ; out . endTag ( null , STR_ ) ; return ; } out . startTag ( null , STR_ ) ; if ( name != null ) { out . attribute ( null , STR_ , name ) ; } final int N = val . length ; out . attribute ( null , STR_ , Integer . toString ( N ) ) ; for ( int i = NUM_ ; i < N ; i ++ ) { out . startTag ( null , STR_ ) ; out . attribute ( null , STR_ , Long . toString ( val [ i ] ) ) ; out . endTag ( null , STR_ ) ; } out . endTag ( null , STR_ ) ; }
public static < T extends GenericEntity > List < T > filterByOr ( List < T > values , List < ? extends EntityCondition > exprs ) { if ( values == null ) return null ; if ( UtilValidate . isEmpty ( exprs ) ) { return values ; } List < T > result = new LinkedList < T > ( ) ; for ( T value : values ) { boolean include = BOOL_ ; for ( EntityCondition condition : exprs ) { include = condition . entityMatches ( value ) ; if ( include ) break ; } if ( include ) { result . add ( value ) ; } } return result ; }
private boolean checkTouchSlop ( View child , float dx , float dy ) { if ( child == null ) { return BOOL_ ; } final boolean checkHorizontal = mCallback . getViewHorizontalDragRange ( child ) > NUM_ ; final boolean checkVertical = mCallback . getViewVerticalDragRange ( child ) > NUM_ ; if ( checkHorizontal && checkVertical ) { return dx . dx + dy . dy > mTouchSlop . mTouchSlop ; } else if ( checkHorizontal ) { return Math . abs ( dx ) > mTouchSlop ; } else if ( checkVertical ) { return Math . abs ( dy ) > mTouchSlop ; } return BOOL_ ; }
@ Override public RES next ( REQ req ) { writeTraceLog ( req , middlewareName ) ; if ( predicate . test ( req ) ) { RES res = middleware . handle ( req , next ) ; writeTraceLog ( res , middlewareName ) ; return res ; } else if ( next != null ) { RES res = ( RES ) next . next ( req ) ; writeTraceLog ( res , middlewareName ) ; return res ; } else { return null ; } }
protected void read ( long offset , byte [ ] b ) throws IOException { rafile . seek ( offset ) ; if ( rafile . read ( b ) != b . length ) { throw new IOException ( STR_ + getPath ( ) ) ; } }
public void run ( ) { final FetcherInfo info = FetcherInfo . getFetcherInfo ( ) ; try { fetchloop ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { synchronized ( info . waitList ) { Thread me = Thread . currentThread ( ) ; for ( int i = NUM_ ; i < info . fetchers . length ; i ++ ) { if ( info . fetchers [ i ] == me ) { info . fetchers [ i ] = null ; info . numFetchers -- ; } } } } }
public CtClass makeAnnotation ( String name ) throws RuntimeException { try { CtClass cc = makeInterface ( name , get ( STR_ ) ) ; cc . setModifiers ( cc . getModifiers ( ) | Modifier . ANNOTATION ) ; return cc ; } catch ( NotFoundException e ) { throw new RuntimeException ( e . getMessage ( ) , e ) ; } }
public void testNegateMathContextNegative ( ) { String a = STR_ ; int aScale = NUM_ ; int precision = NUM_ ; RoundingMode rm = RoundingMode . CEILING ; MathContext mc = new MathContext ( precision , rm ) ; String c = STR_ ; int cScale = NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal res = aNumber . negate ( mc ) ; assertEquals ( STR_ , c , res . toString ( ) ) ; assertEquals ( STR_ , cScale , res . scale ( ) ) ; }
public void add ( Node node ) { availableNodes . add ( node ) ; }
public void write ( OutputStream out ) throws IOException { DataOutputStream dataOut = new DataOutputStream ( out ) ; dataOut . writeShort ( pool . size ( ) + NUM_ ) ; for ( Entry e : pool ) { e . write ( dataOut ) ; } }
protected ForeignKeyConstraint buildForeignKeyConstraint ( List < String > fkFieldNames , List < String > pkFieldNames , TableDefinition targetTable , DatabasePlatform platform ) { assert fkFieldNames . size ( ) > NUM_ && fkFieldNames . size ( ) == pkFieldNames . size ( ) ; ForeignKeyConstraint fkConstraint = new ForeignKeyConstraint ( ) ; for ( int i = NUM_ ; i < fkFieldNames . size ( ) ; i ++ ) { fkConstraint . getSourceFields ( ) . add ( fkFieldNames . get ( i ) ) ; fkConstraint . getTargetFields ( ) . add ( pkFieldNames . get ( i ) ) ; } fkConstraint . setTargetTable ( targetTable . getFullName ( ) ) ; String fkFieldName = fkFieldNames . get ( NUM_ ) ; String name = buildForeignKeyConstraintName ( this . getName ( ) , fkFieldName , platform . getMaxForeignKeyNameSize ( ) , platform ) ; fkConstraint . setName ( name ) ; return fkConstraint ; }
public static boolean isRewritableBatch ( String queryString , boolean noBackslashEscapes ) { LexState state = LexState . Normal ; char lastChar = STR_ ; boolean singleQuotes = BOOL_ ; boolean endingSemicolon = BOOL_ ; char [ ] query = queryString . toCharArray ( ) ; int queryLength = query . length ; for ( int i = NUM_ ; i < queryLength ; i ++ ) { if ( state == LexState . Escape ) state = LexState . String ; char car = query [ i ] ; switch ( car ) { case STR_ : if ( state == LexState . Normal && lastChar == STR_ ) state = LexState . SlashStarComment ; break ; case STR_ : if ( state == LexState . SlashStarComment && lastChar == STR_ ) { state = LexState . Normal ; } else if ( state == LexState . Normal && lastChar == STR_ ) { state = LexState . EOLComment ; } break ; case STR_ : if ( state == LexState . Normal ) state = LexState . EOLComment ; break ; case STR_ : if ( state == LexState . Normal && lastChar == STR_ ) { state = LexState . EOLComment ; } break ; case STR_ : if ( state == LexState . Normal ) { endingSemicolon = BOOL_ ; } break ; case STR_ : if ( state == LexState . EOLComment ) { state = LexState . Normal ; } break ; case STR_ : if ( state == LexState . Normal ) { state = LexState . String ; singleQuotes = BOOL_ ; } else if ( state == LexState . String && ! singleQuotes ) { state = LexState . Normal ; } break ; case STR_ : if ( state == LexState . Normal ) { state = LexState . String ; singleQuotes = BOOL_ ; } else if ( state == LexState . String && singleQuotes ) { state = LexState . Normal ; } break ; case STR_ : if ( noBackslashEscapes ) { break ; } if ( state == LexState . String ) state = LexState . Escape ; break ; case STR_ : if ( state == LexState . Backtick ) { state = LexState . Normal ; } else if ( state == LexState . Normal ) { state = LexState . Backtick ; } break ; default : if ( state == LexState . Normal && endingSemicolon && ( ( byte ) car >= NUM_ ) ) { endingSemicolon = BOOL_ ; } break ; } lastChar = car ; } return state != LexState . EOLComment && ! endingSemicolon ; }
private boolean zzRefill ( ) throws java . io . IOException { if ( zzStartRead > NUM_ ) { System . arraycopy ( zzBuffer , zzStartRead , zzBuffer , NUM_ , zzEndRead - zzStartRead ) ; zzEndRead -= zzStartRead ; zzCurrentPos -= zzStartRead ; zzMarkedPos -= zzStartRead ; zzPushbackPos -= zzStartRead ; zzStartRead = NUM_ ; } if ( zzCurrentPos >= zzBuffer . length ) { char newBuffer [ ] = new char [ zzCurrentPos . NUM_ ] ; System . arraycopy ( zzBuffer , NUM_ , newBuffer , NUM_ , zzBuffer . length ) ; zzBuffer = newBuffer ; } int numRead = zzReader . read ( zzBuffer , zzEndRead , zzBuffer . length - zzEndRead ) ; if ( numRead < NUM_ ) { return BOOL_ ; } else { zzEndRead += numRead ; return BOOL_ ; } }
public ServerBuilder ( Config config ) { Objects . requireNonNull ( config ) ; _config = config ; }
private static LDAPFilter createSubstringFilter ( SubstringFilter sf ) throws LDAPException , IOException { List < Object > anyo = sf . getAny ( ) ; ArrayList < ByteString > subAnyElements = new ArrayList < > ( anyo . size ( ) ) ; for ( Object o : anyo ) { subAnyElements . add ( ByteStringUtility . convertValue ( o ) ) ; } if ( sf . getInitial ( ) == null && subAnyElements . isEmpty ( ) && sf . getFinal ( ) == null ) { LocalizableMessage message = ERR_LDAP_FILTER_DECODE_NULL . get ( ) ; throw new LDAPException ( LDAPResultCode . PROTOCOL_ERROR , message ) ; } return LDAPFilter . createSubstringFilter ( sf . getName ( ) , sf . getInitial ( ) == null ? null : ByteStringUtility . convertValue ( sf . getInitial ( ) ) , subAnyElements , sf . getFinal ( ) == null ? null : ByteStringUtility . convertValue ( sf . getFinal ( ) ) ) ; }
public void testCompareNegNeg2 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = - NUM_ ; int bSign = - NUM_ ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; assertEquals ( NUM_ , aNumber . compareTo ( bNumber ) ) ; }
@ Override protected void onSizeChanged ( int w , int h , int oldw , int oldh ) { if ( readySent ) { setScaleAndCenter ( getScale ( ) , getCenter ( ) ) ; } }
protected void disown ( AbstractNode child ) throws IllegalStateException { ensureParentage ( child ) ; child . parent = null ; }
public String qName2String ( QName qName , boolean writeNS ) { String prefix = null ; String namespaceURI = qName . getNamespace ( ) ; String localPart = qName . getLocalPart ( ) ; if ( localPart != null && localPart . length ( ) > NUM_ ) { int index = localPart . indexOf ( STR_ ) ; if ( index != - NUM_ ) { prefix = localPart . substring ( NUM_ , index ) ; if ( prefix . length ( ) > NUM_ && ! prefix . equals ( STR_ ) ) { registerPrefixForURI ( prefix , namespaceURI ) ; localPart = localPart . substring ( index + NUM_ ) ; } else { prefix = null ; } } localPart = getLastLocalPart ( localPart ) ; } if ( namespaceURI . length ( ) == NUM_ ) { if ( writeNS ) { String defaultNS = nsStack . getNamespaceURI ( STR_ ) ; if ( defaultNS != null && defaultNS . length ( ) > NUM_ ) { registerPrefixForURI ( STR_ , STR_ ) ; } } } else { prefix = getPrefixForURI ( namespaceURI , qName . getPreferredPrefix ( ) ) ; } if ( ( prefix == null ) || ( prefix . length ( ) == NUM_ ) ) return localPart ; return prefix + STR_ + localPart ; }
public JSONException ( Throwable cause ) { super ( cause . getMessage ( ) ) ; this . cause = cause ; }
@ Override public void close ( ) throws XMLStreamException { log . log ( Level . FINE , STR_ ) ; stream . close ( ) ; }
public void testDivideRoundHalfUpNeg2 ( ) { String a = STR_ ; int aScale = NUM_ ; String b = STR_ ; int bScale = NUM_ ; String c = STR_ ; int resScale = - NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal bNumber = new BigDecimal ( new BigInteger ( b ) , bScale ) ; BigDecimal result = aNumber . divide ( bNumber , resScale , BigDecimal . ROUND_HALF_UP ) ; assertEquals ( STR_ , c , result . toString ( ) ) ; assertEquals ( STR_ , resScale , result . scale ( ) ) ; }
@ Override public String readLine ( ) throws IOException { if ( this . pointer >= this . data . length - NUM_ ) { return null ; } else { final StringBuilder buf = new StringBuilder ( ) ; int c ; while ( ( c = read ( ) ) >= NUM_ ) { if ( ( c == NUM_ ) || ( c == NUM_ ) ) { if ( ( ( peek ( ) == NUM_ ) || ( peek ( ) == NUM_ ) ) && ( peek ( ) != c ) ) { read ( ) ; } break ; } buf . append ( ( char ) c ) ; } return buf . toString ( ) ; } }
protected static Map attrSetToMap ( AttrSet attrSet , boolean fetchByteValues ) { Map attributesMap = new AMHashMap ( fetchByteValues ) ; if ( attrSet == null ) { return attributesMap ; } int attrSetSize = attrSet . size ( ) ; if ( ! fetchByteValues ) { for ( int i = NUM_ ; i < attrSetSize ; i ++ ) { Attr attr = attrSet . elementAt ( i ) ; String values [ ] = attr . getStringValues ( ) ; attributesMap . put ( attr . getName ( ) , stringArrayToSet ( values ) ) ; } } else { for ( int i = NUM_ ; i < attrSetSize ; i ++ ) { Attr attr = attrSet . elementAt ( i ) ; attributesMap . put ( attr . getName ( ) , attr . getByteValues ( ) ) ; } } return attributesMap ; }
public void testGetMinCRL ( ) { X509CRLSelector selector = new X509CRLSelector ( ) ; assertNull ( STR_ , selector . getMinCRL ( ) ) ; BigInteger minCRL = new BigInteger ( STR_ ) ; selector . setMinCRLNumber ( minCRL ) ; assertTrue ( STR_ , minCRL . equals ( selector . getMinCRL ( ) ) ) ; }
public < E > E parseResponseData ( GDataRequest req , Class < E > resultType ) throws IOException , ServiceException { InputProperties inputProperties = new ClientInputProperties ( req , resultType ) ; return parseResponseData ( req . getParseSource ( ) , inputProperties , resultType ) ; }
public void addRtpStreamListener ( RtpStreamListener rtpStreamListener ) { mRtpStreamListener = rtpStreamListener ; }
public synchronized byte [ ] toByteArray ( ) { int remaining = count ; if ( remaining == NUM_ ) { return EMPTY_BYTE_ARRAY ; } byte [ ] newbuf = new byte [ remaining ] ; int pos = NUM_ ; for ( byte [ ] buf : buffers ) { int c = Math . min ( buf . length , remaining ) ; System . arraycopy ( buf , NUM_ , newbuf , pos , c ) ; pos += c ; remaining -= c ; if ( remaining == NUM_ ) { break ; } } return newbuf ; }
public void addVolumesToConsistencyGroup ( String cgName , List < String > virtualVolumeNames ) throws VPlexApiException { s_logger . info ( STR_ , _baseURI ) ; _cgMgr . addVolumesToConsistencyGroup ( cgName , virtualVolumeNames ) ; }
public void testConstructorSignBytesPositive6 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , - NUM_ } ; int aSign = NUM_ ; byte rBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , - NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , aNumber . signum ( ) ) ; }
public static boolean looksLikeAFontStyle ( String val ) { return FONT_STYLES . indexOf ( val ) >= NUM_ ; }
public static void dumpCursor ( ICursor cursor , int maxColumnWidth ) { StringBuilder builder = new StringBuilder ( STR_ ) ; dumpCursor ( cursor , maxColumnWidth , builder ) ; Logger . d ( Logger . LOG_TAG , builder . toString ( ) ) ; }
static int computeValidLevels ( long bitPattern ) { return Long . bitCount ( bitPattern ) ; }
public static void runUnderLock ( ReentrantLock lock , Runnable runnable ) { lock . lock ( ) ; try { runnable . run ( ) ; } finally { lock . unlock ( ) ; } }
private static boolean dateByMonth ( DateTimeFormatterBuilder bld , Collection < DateTimeFieldType > fields , boolean extended , boolean strictISO ) { boolean reducedPrec = BOOL_ ; if ( fields . remove ( DateTimeFieldType . year ( ) ) ) { bld . append ( yearElement ( ) ) ; if ( fields . remove ( DateTimeFieldType . monthOfYear ( ) ) ) { if ( fields . remove ( DateTimeFieldType . dayOfMonth ( ) ) ) { appendSeparator ( bld , extended ) ; bld . appendMonthOfYear ( NUM_ ) ; appendSeparator ( bld , extended ) ; bld . appendDayOfMonth ( NUM_ ) ; } else { bld . appendLiteral ( STR_ ) ; bld . appendMonthOfYear ( NUM_ ) ; reducedPrec = BOOL_ ; } } else { if ( fields . remove ( DateTimeFieldType . dayOfMonth ( ) ) ) { checkNotStrictISO ( fields , strictISO ) ; bld . appendLiteral ( STR_ ) ; bld . appendLiteral ( STR_ ) ; bld . appendDayOfMonth ( NUM_ ) ; } else { reducedPrec = BOOL_ ; } } } else if ( fields . remove ( DateTimeFieldType . monthOfYear ( ) ) ) { bld . appendLiteral ( STR_ ) ; bld . appendLiteral ( STR_ ) ; bld . appendMonthOfYear ( NUM_ ) ; if ( fields . remove ( DateTimeFieldType . dayOfMonth ( ) ) ) { appendSeparator ( bld , extended ) ; bld . appendDayOfMonth ( NUM_ ) ; } else { reducedPrec = BOOL_ ; } } else if ( fields . remove ( DateTimeFieldType . dayOfMonth ( ) ) ) { bld . appendLiteral ( STR_ ) ; bld . appendLiteral ( STR_ ) ; bld . appendLiteral ( STR_ ) ; bld . appendDayOfMonth ( NUM_ ) ; } return reducedPrec ; }
@ Override public int insert ( String elem ) { int firstIndex = ( int ) ( elem . charAt ( NUM_ ) - STR_ ) ; int lastIndex = ( int ) ( elem . charAt ( elem . length ( ) - NUM_ ) - STR_ ) ; storage [ firstIndex . NUM_ + lastIndex ] = elem ; return NUM_ ; }
public void clearMovementData ( ) { pathSprites = new ArrayList < StepSprite > ( ) ; movementTarget = null ; checkFoVHexImageCacheClear ( ) ; repaint ( ) ; refreshMoveVectors ( ) ; }
public void threadRecordFailure ( Throwable t ) { threadFailure . compareAndSet ( null , t ) ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
protected Boolean replayCompletion ( Participant participant ) throws IllegalStateException { if ( ! replayStack_ . contains ( participant ) ) { replayStack_ . push ( participant ) ; } return committed_ ; }
public static < V > boolean addDistinctEntry ( List < V > sourceList , V entry ) { return ( sourceList != null && ! sourceList . contains ( entry ) ) ? sourceList . add ( entry ) : BOOL_ ; }
public void testDecoder7 ( ) { boolean res ; String originalAppIdName = mAppIdName ; int originalContentTypeValue = mContentTypeValue ; Random rd = new Random ( ) ; for ( int i = NUM_ ; i < OMA_CONTENT_TYPE_NAMES . length ; i ++ ) { mContentTypeName = OMA_CONTENT_TYPE_NAMES [ i ] ; byte [ ] pdu = createPDU ( NUM_ ) ; WspTypeDecoder pduDecoder = new WspTypeDecoder ( pdu ) ; res = pduDecoder . decodeContentType ( mWspContentTypeStart ) ; assertTrue ( res ) ; Log . d ( LOG_TAG , STR_ + mContentTypeName + STR_ + pduDecoder . getValueString ( ) + STR_ ) ; assertTrue ( mContentTypeName . equals ( pduDecoder . getValueString ( ) ) ) ; } mAppIdName = originalAppIdName ; mContentTypeValue = originalContentTypeValue ; }
public void shutdownNow ( ) { shutdown = BOOL_ ; final Future < ? > f = engineFuture . get ( ) ; if ( f != null ) { if ( log . isInfoEnabled ( ) ) log . info ( STR_ + this ) ; f . cancel ( BOOL_ ) ; } final ExecutorService s = engineService . get ( ) ; if ( s != null ) { if ( log . isInfoEnabled ( ) ) log . info ( STR_ + this ) ; s . shutdownNow ( ) ; } final HttpClient cm = clientConnectionManagerRef . get ( ) ; if ( cm != null ) { if ( log . isInfoEnabled ( ) ) log . info ( STR_ + this ) ; try { cm . stop ( ) ; } catch ( Exception e ) { log . error ( STR_ , e ) ; } } for ( AbstractRunningQuery q : runningQueries . values ( ) ) { q . cancel ( BOOL_ ) ; } priorityQueue . clear ( ) ; deadlineQueue . clear ( ) ; engineFuture . set ( null ) ; engineService . set ( null ) ; clientConnectionManagerRef . set ( null ) ; }
static public void addNotificationListener ( JMXConnector jmxConnector , Class < ? > mbeanClass , NotificationListener notificationListener ) throws InstanceNotFoundException , Exception { MBeanServerConnection mbsc = jmxConnector . getMBeanServerConnection ( ) ; ObjectName objectName = generateMBeanObjectName ( mbeanClass ) ; mbsc . addNotificationListener ( objectName , notificationListener , null , null ) ; }
protected String toHTML ( String s ) { String result ; result = s ; result = result . replaceAll ( STR_ , STR_ ) ; result = result . replaceAll ( STR_ , STR_ ) ; result = result . replaceAll ( STR_ , STR_ ) ; result = result . replaceAll ( STR_ , STR_ ) ; result = result . replaceAll ( STR_ , STR_ ) ; return result ; }
@ Override public synchronized void clear ( ) { File [ ] files = mRootDirectory . listFiles ( ) ; if ( files != null ) { for ( File file : files ) { file . delete ( ) ; } } mEntries . clear ( ) ; mTotalSize = NUM_ ; VolleyLog . d ( STR_ ) ; }
protected void normalizeScores ( ) { double hub_ssum = NUM_ ; double auth_ssum = NUM_ ; for ( V v : graph . getVertices ( ) ) { double hub_val = getOutputValue ( v ) . hub ; double auth_val = getOutputValue ( v ) . authority ; hub_ssum += ( hub_val . hub_val ) ; auth_ssum += ( auth_val . auth_val ) ; } hub_ssum = Math . sqrt ( hub_ssum ) ; auth_ssum = Math . sqrt ( auth_ssum ) ; for ( V v : graph . getVertices ( ) ) { HITS . Scores values = getOutputValue ( v ) ; setOutputValue ( v , new HITS . Scores ( values . hub / hub_ssum , values . authority / auth_ssum ) ) ; } }
public static int absoluteMax ( int [ ] intArray ) { int max = Integer . MIN_VALUE ; for ( int i = NUM_ ; i < intArray . length ; i ++ ) { if ( Math . abs ( intArray [ i ] ) > max && intArray [ i ] != NUM_ ) { max = intArray [ i ] ; } } return max == Integer . MIN_VALUE ? NUM_ : max ; }
private boolean doAcquireNanos ( long arg , long nanosTimeout ) throws InterruptedException { if ( nanosTimeout <= NUM_ ) return BOOL_ ; final long deadline = System . nanoTime ( ) + nanosTimeout ; final Node node = addWaiter ( Node . EXCLUSIVE ) ; boolean failed = BOOL_ ; try { for ( ; ; ) { final Node p = node . predecessor ( ) ; if ( p == head && tryAcquire ( arg ) ) { setHead ( node ) ; p . next = null ; failed = BOOL_ ; return BOOL_ ; } nanosTimeout = deadline - System . nanoTime ( ) ; if ( nanosTimeout <= NUM_ ) return BOOL_ ; if ( shouldParkAfterFailedAcquire ( p , node ) && nanosTimeout > spinForTimeoutThreshold ) LockSupport . parkNanos ( this , nanosTimeout ) ; if ( Thread . interrupted ( ) ) throw new InterruptedException ( ) ; } } finally { if ( failed ) cancelAcquire ( node ) ; } }
boolean hasMinFeatureCount ( String feature ) { if ( minFeatureCount == NUM_ ) return BOOL_ ; Set < Integer > ids = clippedFeatureIndex . get ( feature ) ; if ( ids == null ) return BOOL_ ; return ids . size ( ) >= minFeatureCount ; }
void mutate ( ) { do { int iBit ; do { iBit = m_random . nextInt ( m_nNodes . m_nNodes ) ; } while ( isSquare ( iBit ) ) ; m_bits [ iBit ] = ! m_bits [ iBit ] ; } while ( hasCycles ( ) ) ; calcScore ( ) ; }
public void put ( E e ) throws InterruptedException { checkNotNull ( e ) ; final ReentrantLock lock = this . lock ; lock . lockInterruptibly ( ) ; try { while ( count == items . length ) notFull . await ( ) ; enqueue ( e ) ; } finally { lock . unlock ( ) ; } }
private void deleteComments ( SpanManager sm ) { int start = NUM_ ; while ( ( start = sm . indexOf ( STR_ , start ) ) != - NUM_ ) { int end = sm . indexOf ( STR_ , start + NUM_ ) + NUM_ ; if ( end == - NUM_ + NUM_ ) { end = sm . length ( ) ; } try { if ( lineSeparator . equals ( sm . substring ( start - lineSeparator . length ( ) , start ) ) && lineSeparator . equals ( sm . substring ( end , end + lineSeparator . length ( ) ) ) ) { end += lineSeparator . length ( ) ; } } catch ( IndexOutOfBoundsException e ) { } sm . delete ( start , end ) ; } }
DateTimeParseContext ( DateTimeFormatter formatter ) { super ( ) ; this . formatter = formatter ; parsed . add ( new Parsed ( ) ) ; }
public static boolean isNetworkTypeCellular ( String networkType ) { return networkType . equals ( STR_ ) ; }
private void defineInternalFrameCloseButtons ( UIDefaults d ) { String p = STR_ ; String c = PAINTER_PREFIX + STR_ ; d . put ( p + STR_ , STR_ ) ; d . put ( p + STR_ , new TitlePaneCloseButtonWindowNotFocusedState ( ) ) ; d . put ( p + STR_ , new InsetsUIResource ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; d . put ( p + STR_ , new LazyPainter ( c , TitlePaneCloseButtonPainter . Which . BACKGROUND_DISABLED ) ) ; d . put ( p + STR_ , new LazyPainter ( c , TitlePaneCloseButtonPainter . Which . BACKGROUND_ENABLED ) ) ; d . put ( p + STR_ , new LazyPainter ( c , TitlePaneCloseButtonPainter . Which . BACKGROUND_MOUSEOVER ) ) ; d . put ( p + STR_ , new LazyPainter ( c , TitlePaneCloseButtonPainter . Which . BACKGROUND_PRESSED ) ) ; d . put ( p + STR_ , new LazyPainter ( c , TitlePaneCloseButtonPainter . Which . BACKGROUND_ENABLED_WINDOWNOTFOCUSED ) ) ; d . put ( p + STR_ , new LazyPainter ( c , TitlePaneCloseButtonPainter . Which . BACKGROUND_MOUSEOVER ) ) ; d . put ( p + STR_ , new LazyPainter ( c , TitlePaneCloseButtonPainter . Which . BACKGROUND_PRESSED_WINDOWNOTFOCUSED ) ) ; d . put ( p + STR_ , new SeaGlassIcon ( p , STR_ , NUM_ , NUM_ ) ) ; }
private void modify ( StoragePort port , String portNetworkId ) { port . setPortNetworkId ( portNetworkId ) ; dbClient . persistObject ( port ) ; modifiedStoragePortsList . add ( port ) ; }
public boolean is ( String word ) { return m_Words . contains ( word . toLowerCase ( ) ) ; }
public static final String removeMultipleSpacesAndReturns ( final String data ) { final StringBuilder all_data = new StringBuilder ( data ) ; int i = NUM_ ; while ( i < all_data . length ( ) ) { if ( ( ( all_data . charAt ( i ) == STR_ ) && ( all_data . charAt ( i - NUM_ ) == STR_ ) ) || ( ( all_data . charAt ( i ) == Character . LINE_SEPARATOR ) && ( all_data . charAt ( i - NUM_ ) == Character . LINE_SEPARATOR ) ) ) { all_data . deleteCharAt ( i ) ; } else { i ++ ; } } return all_data . toString ( ) ; }
public void removeListener ( ConnectableDeviceListener listener ) { listeners . remove ( listener ) ; }
protected boolean readAttributes ( DataInputStream d , int attributes_count , attribute_info [ ] ai ) throws IOException { attribute_info a = null ; int i ; int j ; long len ; String s ; for ( i = NUM_ ; i < attributes_count ; i ++ ) { j = d . readUnsignedShort ( ) ; len = d . readInt ( ) & xFFFFFFFFL ; s = ( ( CONSTANT_Utf8_info ) ( constant_pool [ j ] ) ) . convert ( ) ; if ( s . compareTo ( attribute_info . SourceFile ) == NUM_ ) { SourceFile_attribute sa = new SourceFile_attribute ( ) ; sa . sourcefile_index = d . readUnsignedShort ( ) ; a = ( attribute_info ) sa ; } else if ( s . compareTo ( attribute_info . ConstantValue ) == NUM_ ) { ConstantValue_attribute ca = new ConstantValue_attribute ( ) ; ca . constantvalue_index = d . readUnsignedShort ( ) ; a = ( attribute_info ) ca ; } else if ( s . compareTo ( attribute_info . Code ) == NUM_ ) { Code_attribute ca = new Code_attribute ( ) ; ca . max_stack = d . readUnsignedShort ( ) ; ca . max_locals = d . readUnsignedShort ( ) ; ca . code_length = d . readInt ( ) & xFFFFFFFFL ; ca . code = new byte [ ( int ) ca . code_length ] ; d . read ( ca . code ) ; ca . exception_table_length = d . readUnsignedShort ( ) ; ca . exception_table = new exception_table_entry [ ca . exception_table_length ] ; int k ; exception_table_entry e ; for ( k = NUM_ ; k < ca . exception_table_length ; k ++ ) { e = new exception_table_entry ( ) ; e . start_pc = d . readUnsignedShort ( ) ; e . end_pc = d . readUnsignedShort ( ) ; e . handler_pc = d . readUnsignedShort ( ) ; e . catch_type = d . readUnsignedShort ( ) ; ca . exception_table [ k ] = e ; } ca . attributes_count = d . readUnsignedShort ( ) ; ca . attributes = new attribute_info [ ca . attributes_count ] ; readAttributes ( d , ca . attributes_count , ca . attributes ) ; a = ( attribute_info ) ca ; } else if ( s . compareTo ( attribute_info . Exceptions ) == NUM_ ) { Exception_attribute ea = new Exception_attribute ( ) ; ea . number_of_exceptions = d . readUnsignedShort ( ) ; if ( ea . number_of_exceptions > NUM_ ) { int k ; ea . exception_index_table = new int [ ea . number_of_exceptions ] ; for ( k = NUM_ ; k < ea . number_of_exceptions ; k ++ ) ea . exception_index_table [ k ] = d . readUnsignedShort ( ) ; } a = ( attribute_info ) ea ; } else if ( s . compareTo ( attribute_info . LineNumberTable ) == NUM_ ) { LineNumberTable_attribute la = new LineNumberTable_attribute ( ) ; la . line_number_table_length = d . readUnsignedShort ( ) ; int k ; line_number_table_entry e ; la . line_number_table = new line_number_table_entry [ la . line_number_table_length ] ; for ( k = NUM_ ; k < la . line_number_table_length ; k ++ ) { e = new line_number_table_entry ( ) ; e . start_pc = d . readUnsignedShort ( ) ; e . line_number = d . readUnsignedShort ( ) ; la . line_number_table [ k ] = e ; } a = ( attribute_info ) la ; } else if ( s . compareTo ( attribute_info . LocalVariableTable ) == NUM_ ) { LocalVariableTable_attribute la = new LocalVariableTable_attribute ( ) ; la . local_variable_table_length = d . readUnsignedShort ( ) ; int k ; local_variable_table_entry e ; la . local_variable_table = new local_variable_table_entry [ la . local_variable_table_length ] ; for ( k = NUM_ ; k < la . local_variable_table_length ; k ++ ) { e = new local_variable_table_entry ( ) ; e . start_pc = d . readUnsignedShort ( ) ; e . length = d . readUnsignedShort ( ) ; e . name_index = d . readUnsignedShort ( ) ; e . descriptor_index = d . readUnsignedShort ( ) ; e . index = d . readUnsignedShort ( ) ; la . local_variable_table [ k ] = e ; } a = ( attribute_info ) la ; } else if ( s . compareTo ( attribute_info . LocalVariableTypeTable ) == NUM_ ) { LocalVariableTypeTable_attribute la = new LocalVariableTypeTable_attribute ( ) ; la . local_variable_type_table_length = d . readUnsignedShort ( ) ; int k ; local_variable_type_table_entry e ; la . local_variable_type_table = new local_variable_type_table_entry [ la . local_variable_type_table_length ] ; for ( k = NUM_ ; k < la . local_variable_type_table_length ; k ++ ) { e = new local_variable_type_table_entry ( ) ; e . start_pc = d . readUnsignedShort ( ) ; e . length = d . readUnsignedShort ( ) ; e . name_index = d . readUnsignedShort ( ) ; e . signature_index = d . readUnsignedShort ( ) ; e . index = d . readUnsignedShort ( ) ; la . local_variable_type_table [ k ] = e ; } a = ( attribute_info ) la ; } else if ( s . compareTo ( attribute_info . Synthetic ) == NUM_ ) { Synthetic_attribute ia = new Synthetic_attribute ( ) ; a = ( attribute_info ) ia ; } else if ( s . compareTo ( attribute_info . Signature ) == NUM_ ) { Signature_attribute ia = new Signature_attribute ( ) ; ia . signature_index = d . readUnsignedShort ( ) ; a = ( attribute_info ) ia ; } else if ( s . compareTo ( attribute_info . Deprecated ) == NUM_ ) { Deprecated_attribute da = new Deprecated_attribute ( ) ; a = ( attribute_info ) da ; } else if ( s . compareTo ( attribute_info . EnclosingMethod ) == NUM_ ) { EnclosingMethod_attribute ea = new EnclosingMethod_attribute ( ) ; ea . class_index = d . readUnsignedShort ( ) ; ea . method_index = d . readUnsignedShort ( ) ; a = ( attribute_info ) ea ; } else if ( s . compareTo ( attribute_info . InnerClasses ) == NUM_ ) { InnerClasses_attribute ia = new InnerClasses_attribute ( ) ; ia . inner_classes_length = d . readUnsignedShort ( ) ; ia . inner_classes = new inner_class_entry [ ia . inner_classes_length ] ; for ( int k = NUM_ ; k < ia . inner_classes_length ; k ++ ) { inner_class_entry e = new inner_class_entry ( ) ; e . inner_class_index = d . readUnsignedShort ( ) ; e . outer_class_index = d . readUnsignedShort ( ) ; e . name_index = d . readUnsignedShort ( ) ; e . access_flags = d . readUnsignedShort ( ) ; ia . inner_classes [ k ] = e ; } a = ( attribute_info ) ia ; } else if ( s . compareTo ( attribute_info . RuntimeVisibleAnnotations ) == NUM_ ) { RuntimeVisibleAnnotations_attribute ra = new RuntimeVisibleAnnotations_attribute ( ) ; ra . number_of_annotations = d . readUnsignedShort ( ) ; ra . annotations = new annotation [ ra . number_of_annotations ] ; for ( int k = NUM_ ; k < ra . number_of_annotations ; k ++ ) { annotation annot = new annotation ( ) ; annot . type_index = d . readUnsignedShort ( ) ; annot . num_element_value_pairs = d . readUnsignedShort ( ) ; annot . element_value_pairs = readElementValues ( annot . num_element_value_pairs , d , BOOL_ , NUM_ ) ; ra . annotations [ k ] = annot ; } a = ( attribute_info ) ra ; } else if ( s . compareTo ( attribute_info . RuntimeInvisibleAnnotations ) == NUM_ ) { RuntimeInvisibleAnnotations_attribute ra = new RuntimeInvisibleAnnotations_attribute ( ) ; ra . number_of_annotations = d . readUnsignedShort ( ) ; ra . annotations = new annotation [ ra . number_of_annotations ] ; for ( int k = NUM_ ; k < ra . number_of_annotations ; k ++ ) { annotation annot = new annotation ( ) ; annot . type_index = d . readUnsignedShort ( ) ; annot . num_element_value_pairs = d . readUnsignedShort ( ) ; annot . element_value_pairs = readElementValues ( annot . num_element_value_pairs , d , BOOL_ , NUM_ ) ; ra . annotations [ k ] = annot ; } a = ( attribute_info ) ra ; } else if ( s . compareTo ( attribute_info . RuntimeVisibleParameterAnnotations ) == NUM_ ) { RuntimeVisibleParameterAnnotations_attribute ra = new RuntimeVisibleParameterAnnotations_attribute ( ) ; ra . num_parameters = d . readUnsignedByte ( ) ; ra . parameter_annotations = new parameter_annotation [ ra . num_parameters ] ; for ( int x = NUM_ ; x < ra . num_parameters ; x ++ ) { parameter_annotation pAnnot = new parameter_annotation ( ) ; pAnnot . num_annotations = d . readUnsignedShort ( ) ; pAnnot . annotations = new annotation [ pAnnot . num_annotations ] ; for ( int k = NUM_ ; k < pAnnot . num_annotations ; k ++ ) { annotation annot = new annotation ( ) ; annot . type_index = d . readUnsignedShort ( ) ; annot . num_element_value_pairs = d . readUnsignedShort ( ) ; annot . element_value_pairs = readElementValues ( annot . num_element_value_pairs , d , BOOL_ , NUM_ ) ; pAnnot . annotations [ k ] = annot ; } ra . parameter_annotations [ x ] = pAnnot ; } a = ( attribute_info ) ra ; } else if ( s . compareTo ( attribute_info . RuntimeInvisibleParameterAnnotations ) == NUM_ ) { RuntimeInvisibleParameterAnnotations_attribute ra = new RuntimeInvisibleParameterAnnotations_attribute ( ) ; ra . num_parameters = d . readUnsignedByte ( ) ; ra . parameter_annotations = new parameter_annotation [ ra . num_parameters ] ; for ( int x = NUM_ ; x < ra . num_parameters ; x ++ ) { parameter_annotation pAnnot = new parameter_annotation ( ) ; pAnnot . num_annotations = d . readUnsignedShort ( ) ; pAnnot . annotations = new annotation [ pAnnot . num_annotations ] ; for ( int k = NUM_ ; k < pAnnot . num_annotations ; k ++ ) { annotation annot = new annotation ( ) ; annot . type_index = d . readUnsignedShort ( ) ; annot . num_element_value_pairs = d . readUnsignedShort ( ) ; annot . element_value_pairs = readElementValues ( annot . num_element_value_pairs , d , BOOL_ , NUM_ ) ; pAnnot . annotations [ k ] = annot ; } ra . parameter_annotations [ x ] = pAnnot ; } a = ( attribute_info ) ra ; } else if ( s . compareTo ( attribute_info . AnnotationDefault ) == NUM_ ) { AnnotationDefault_attribute da = new AnnotationDefault_attribute ( ) ; element_value [ ] result = readElementValues ( NUM_ , d , BOOL_ , NUM_ ) ; da . default_value = result [ NUM_ ] ; a = ( attribute_info ) da ; } else if ( s . equals ( attribute_info . BootstrapMethods ) ) { BootstrapMethods_attribute bsma = new BootstrapMethods_attribute ( ) ; int count = d . readUnsignedShort ( ) ; bsma . method_handles = new short [ count ] ; bsma . arg_indices = new short [ count ] [ ] ; for ( int num = NUM_ ; num < count ; num ++ ) { short index = ( short ) d . readUnsignedShort ( ) ; bsma . method_handles [ num ] = index ; int argCount = d . readUnsignedShort ( ) ; bsma . arg_indices [ num ] = new short [ argCount ] ; for ( int numArg = NUM_ ; numArg < argCount ; numArg ++ ) { short indexArg = ( short ) d . readUnsignedShort ( ) ; bsma . arg_indices [ num ] [ numArg ] = indexArg ; } } assert bootstrap_methods_attribute == null : STR_ ; a = bootstrap_methods_attribute = bsma ; } else { Generic_attribute ga = new Generic_attribute ( ) ; if ( len > NUM_ ) { ga . info = new byte [ ( int ) len ] ; d . read ( ga . info ) ; } a = ( attribute_info ) ga ; } a . attribute_name = j ; a . attribute_length = len ; ai [ i ] = a ; } return BOOL_ ; }
private void notifiyDownloadState ( ) { synchronized ( mDownloadMonitor ) { Log . v ( LOG_TAG , STR_ ) ; mDownloadMonitor . notify ( ) ; } }
private PKIXBuilderParameters CreatePKIXBuilderParameters ( X509Certificate endCert ) throws CertificatePathBuildingException { X509CertSelector targetConstraints = new X509CertSelector ( ) ; targetConstraints . setCertificate ( endCert ) ; PKIXBuilderParameters params ; try { params = new PKIXBuilderParameters ( trustStore , targetConstraints ) ; params . setRevocationEnabled ( BOOL_ ) ; } catch ( KeyStoreException e ) { throw new CertificatePathBuildingException ( STR_ + e . getMessage ( ) , e ) ; } catch ( InvalidAlgorithmParameterException e ) { throw new CertificatePathBuildingException ( STR_ + e . getMessage ( ) , e ) ; } catch ( Throwable e ) { throw new CertificatePathBuildingException ( STR_ + e . getMessage ( ) , e ) ; } Collection < Object > certCollection = new ArrayList < Object > ( ) ; addCertificateCandidates ( endCert , certCollection ) ; if ( ! certCollection . isEmpty ( ) ) { try { CertStore certStore = CertStore . getInstance ( STR_ , new CollectionCertStoreParameters ( certCollection ) ) ; params . addCertStore ( certStore ) ; } catch ( InvalidAlgorithmParameterException e ) { throw new CertificatePathBuildingException ( STR_ + e . getMessage ( ) , e ) ; } catch ( NoSuchAlgorithmException e ) { throw new CertificatePathBuildingException ( STR_ + e . getMessage ( ) , e ) ; } } else { logger . debug ( STR_ ) ; } return params ; }
public synchronized void addSeries ( XYSeries series ) { mSeries . add ( series ) ; }
public static String valueOf ( long value ) { return Long . toString ( value ) ; }
public void printStackTrace ( ) { Throwable t ; StringWriter writer ; writer = new StringWriter ( ) ; t = new Throwable ( ) ; t . fillInStackTrace ( ) ; t . printStackTrace ( new PrintWriter ( writer ) ) ; println ( writer . toString ( ) ) ; }
protected int effectiveBandSize ( final int dim1 , final int dim2 ) { if ( bandSize == Double . POSITIVE_INFINITY ) { return ( dim1 > dim2 ) ? dim1 : dim2 ; } if ( bandSize >= NUM_ ) { return ( int ) bandSize ; } return ( int ) Math . ceil ( ( dim1 >= dim2 ? dim1 : dim2 ) . bandSize ) ; }
private final Object arenaExchange ( Object item , boolean timed , long ns ) { Node [ ] a = arena ; Node p = participant . get ( ) ; for ( int i = p . index ; ; ) { int b , m , c ; long j ; Node q = ( Node ) U . getObjectVolatile ( a , j = ( i << ASHIFT ) + ABASE ) ; if ( q != null && U . compareAndSwapObject ( a , j , q , null ) ) { Object v = q . item ; q . match = item ; Thread w = q . parked ; if ( w != null ) U . unpark ( w ) ; return v ; } else if ( i <= ( m = ( b = bound ) & MMASK ) && q == null ) { p . item = item ; if ( U . compareAndSwapObject ( a , j , null , p ) ) { long end = ( timed && m == NUM_ ) ? System . nanoTime ( ) + ns : NUM_ ; Thread t = Thread . currentThread ( ) ; for ( int h = p . hash , spins = SPINS ; ; ) { Object v = p . match ; if ( v != null ) { U . putOrderedObject ( p , MATCH , null ) ; p . item = null ; p . hash = h ; return v ; } else if ( spins > NUM_ ) { h ^= h << NUM_ ; h ^= h > > > NUM_ ; h ^= h << NUM_ ; if ( h == NUM_ ) h = SPINS | ( int ) t . getId ( ) ; else if ( h < NUM_ && ( -- spins & ( ( SPINS > > > NUM_ ) - NUM_ ) ) == NUM_ ) Thread . yield ( ) ; } else if ( U . getObjectVolatile ( a , j ) != p ) spins = SPINS ; else if ( ! t . isInterrupted ( ) && m == NUM_ && ( ! timed || ( ns = end - System . nanoTime ( ) ) > NUM_ ) ) { U . putObject ( t , BLOCKER , this ) ; p . parked = t ; if ( U . getObjectVolatile ( a , j ) == p ) U . park ( BOOL_ , ns ) ; p . parked = null ; U . putObject ( t , BLOCKER , null ) ; } else if ( U . getObjectVolatile ( a , j ) == p && U . compareAndSwapObject ( a , j , p , null ) ) { if ( m != NUM_ ) U . compareAndSwapInt ( this , BOUND , b , b + SEQ - NUM_ ) ; p . item = null ; p . hash = h ; i = p . index >>>= NUM_ ; if ( Thread . interrupted ( ) ) return null ; if ( timed && m == NUM_ && ns <= NUM_ ) return TIMED_OUT ; break ; } } } else p . item = null ; } else { if ( p . bound != b ) { p . bound = b ; p . collides = NUM_ ; i = ( i != m || m == NUM_ ) ? m : m - NUM_ ; } else if ( ( c = p . collides ) < m || m == FULL || ! U . compareAndSwapInt ( this , BOUND , b , b + SEQ + NUM_ ) ) { p . collides = c + NUM_ ; i = ( i == NUM_ ) ? m : i - NUM_ ; } else i = m + NUM_ ; p . index = i ; } } }
public static int encodeLongitudeCeil ( double longitude ) { GeoUtils . checkLongitude ( longitude ) ; if ( longitude == NUM_ ) { longitude = Math . nextDown ( longitude ) ; } return ( int ) Math . ceil ( longitude / LON_DECODE ) ; }
private LinkedList < Diff > diff_lineMode ( String text1 , String text2 , long deadline ) { LinesToCharsResult b = diff_linesToChars ( text1 , text2 ) ; text1 = b . chars1 ; text2 = b . chars2 ; List < String > linearray = b . lineArray ; LinkedList < Diff > diffs = diff_main ( text1 , text2 , BOOL_ , deadline ) ; diff_charsToLines ( diffs , linearray ) ; diff_cleanupSemantic ( diffs ) ; diffs . add ( new Diff ( Operation . EQUAL , STR_ ) ) ; int count_delete = NUM_ ; int count_insert = NUM_ ; String text_delete = STR_ ; String text_insert = STR_ ; ListIterator < Diff > pointer = diffs . listIterator ( ) ; Diff thisDiff = pointer . next ( ) ; while ( thisDiff != null ) { switch ( thisDiff . operation ) { case INSERT : count_insert ++ ; text_insert += thisDiff . text ; break ; case DELETE : count_delete ++ ; text_delete += thisDiff . text ; break ; case EQUAL : if ( count_delete >= NUM_ && count_insert >= NUM_ ) { pointer . previous ( ) ; for ( int j = NUM_ ; j < count_delete + count_insert ; j ++ ) { pointer . previous ( ) ; pointer . remove ( ) ; } for ( Diff newDiff : diff_main ( text_delete , text_insert , BOOL_ , deadline ) ) { pointer . add ( newDiff ) ; } } count_insert = NUM_ ; count_delete = NUM_ ; text_delete = STR_ ; text_insert = STR_ ; break ; } thisDiff = pointer . hasNext ( ) ? pointer . next ( ) : null ; } diffs . removeLast ( ) ; return diffs ; }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case NUM_ : return ID ; case NUM_ : return CREATE_TIME ; case NUM_ : return UPDATE_TIME ; case NUM_ : return OPERATION ; case NUM_ : return STATUS ; case NUM_ : return SRC_PATH ; case NUM_ : return SRC_CLUSTER ; case NUM_ : return SRC_DB ; case NUM_ : return SRC_TABLE ; case NUM_ : return SRC_PARTITIONS ; case NUM_ : return SRC_MODIFIED_TIME ; case NUM_ : return RENAME_TO_DB ; case NUM_ : return RENAME_TO_TABLE ; case NUM_ : return RENAME_TO_PATH ; case NUM_ : return EXTRAS ; case NUM_ : return WAITING_ON_JOBS ; default : return null ; } }
public JSONBuffer appendKeyHash ( Object key ) { if ( stack . empty ( ) || stack . peek ( ) != Operand . HASH ) { throw new JSONException ( STR_ ) ; } addQuotedString ( key ) ; buffer . append ( STR_ ) ; buffer . append ( STR_ ) ; stack . push ( Operand . HASH ) ; return this ; }
static ReplayPromise < Void > anyReplay ( final Duration timeout , final Promise < ? > ... promises ) { return anyReplay ( timeout , System . currentTimeMillis ( ) , promises ) ; }
public static PolicyService sendPLLRequest ( URL policyServiceUrl , PolicyRequest preq ) throws SendRequestException , PolicyException { String lbcookie = null ; try { lbcookie = getLBCookie ( preq ) ; } catch ( Exception e ) { throw new SendRequestException ( e ) ; } PolicyService policyService = new PolicyService ( ) ; policyService . setMethodID ( PolicyService . POLICY_REQUEST_ID ) ; policyService . setPolicyRequest ( preq ) ; String xmlString = policyService . toXMLString ( ) ; Request request = new Request ( xmlString ) ; RequestSet requestSet = new RequestSet ( PolicyService . POLICY_SERVICE ) ; requestSet . addRequest ( request ) ; if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + STR_ + policyServiceUrl + STR_ + xmlString ) ; } Vector responses = PLLClient . send ( policyServiceUrl , lbcookie , requestSet ) ; Response response = ( Response ) responses . elementAt ( NUM_ ) ; PolicyService ps = PolicyService . parseXML ( response . getContent ( ) ) ; if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + STR_ + ps . toXMLString ( ) ) ; } return ps ; }
public static URI createId ( Class < ? extends DataObject > clazz ) { return newId ( clazz , getLocation ( clazz ) ) ; }
public static double log2 ( double x ) { return Math . log ( x ) . ONE_BY_LOG2 ; }
private void needNewBuffer ( int newcount ) { if ( currentBufferIndex < buffers . size ( ) - NUM_ ) { filledBufferSum += currentBuffer . length ; currentBufferIndex ++ ; currentBuffer = buffers . get ( currentBufferIndex ) ; } else { int newBufferSize ; if ( currentBuffer == null ) { newBufferSize = newcount ; filledBufferSum = NUM_ ; } else { newBufferSize = Math . max ( currentBuffer . length << NUM_ , newcount - filledBufferSum ) ; filledBufferSum += currentBuffer . length ; } currentBufferIndex ++ ; currentBuffer = new byte [ newBufferSize ] ; buffers . add ( currentBuffer ) ; } }
@ Override public void addFocusables ( ArrayList < View > views , int direction , int focusableMode ) { final int focusableCount = views . size ( ) ; final int descendantFocusability = getDescendantFocusability ( ) ; if ( descendantFocusability != FOCUS_BLOCK_DESCENDANTS ) { for ( int i = NUM_ ; i < getChildCount ( ) ; i ++ ) { final View child = getChildAt ( i ) ; if ( child . getVisibility ( ) == VISIBLE ) { ItemInfo ii = infoForChild ( child ) ; if ( ii != null && ii . position == mCurItem ) { child . addFocusables ( views , direction , focusableMode ) ; } } } } if ( descendantFocusability != FOCUS_AFTER_DESCENDANTS || ( focusableCount == views . size ( ) ) ) { if ( ! isFocusable ( ) ) { return ; } if ( ( focusableMode & FOCUSABLES_TOUCH_MODE ) == FOCUSABLES_TOUCH_MODE && isInTouchMode ( ) && ! isFocusableInTouchMode ( ) ) { return ; } if ( views != null ) { views . add ( this ) ; } } }
public void insertElementAt ( Node value , int at ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; if ( null == m_map ) { m_map = new Node [ m_blocksize ] ; m_mapSize = m_blocksize ; } else if ( ( m_firstFree + NUM_ ) >= m_mapSize ) { m_mapSize += m_blocksize ; Node newMap [ ] = new Node [ m_mapSize ] ; System . arraycopy ( m_map , NUM_ , newMap , NUM_ , m_firstFree + NUM_ ) ; m_map = newMap ; } if ( at <= ( m_firstFree - NUM_ ) ) { System . arraycopy ( m_map , at , m_map , at + NUM_ , m_firstFree - at ) ; } m_map [ at ] = value ; m_firstFree ++ ; }
public Result regress ( DiscreteVariable x , List < Node > regressors ) { if ( ! binary ( x ) ) { throw new IllegalArgumentException ( STR_ ) ; } for ( Node node : regressors ) { if ( ! ( node instanceof ContinuousVariable || binary ( node ) ) ) { throw new IllegalArgumentException ( STR_ ) ; } } double [ ] [ ] _regressors = new double [ regressors . size ( ) ] [ getRows ( ) . length ] ; for ( int j = NUM_ ; j < regressors . size ( ) ; j ++ ) { int col = dataSet . getColumn ( regressors . get ( j ) ) ; double [ ] dataCol = dataCols [ col ] ; for ( int i = NUM_ ; i < getRows ( ) . length ; i ++ ) { _regressors [ j ] [ i ] = dataCol [ getRows ( ) [ i ] ] ; } } int [ ] target = new int [ getRows ( ) . length ] ; int col = dataSet . getColumn ( dataSet . getVariable ( x . getName ( ) ) ) ; for ( int i = NUM_ ; i < getRows ( ) . length ; i ++ ) { target [ i ] = dataSet . getInt ( getRows ( ) [ i ] , col ) ; } List < String > regressorNames = new ArrayList < > ( ) ; for ( Node node : regressors ) { regressorNames . add ( node . getName ( ) ) ; } return regress ( target , x . getName ( ) , _regressors , regressorNames ) ; }
void copyFile ( String source , String target ) ;
static public List < Sequence < IString > > tokenizeFile ( String filename , boolean doNIST ) { List < Sequence < IString > > sequences = new ArrayList < > ( ) ; LineNumberReader reader = IOTools . getReaderFromFile ( filename ) ; try { for ( String line ; ( line = reader . readLine ( ) ) != null ; ) { if ( doNIST ) line = NISTTokenizer . tokenize ( line ) ; sequences . add ( IStrings . tokenize ( line ) ) ; } reader . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return sequences ; }
public Statement like ( String expr ) { statement . append ( STR_ ) ; appendEscapedSQLString ( statement , expr ) ; return this ; }
public static KdbxHeader readKdbxHeader ( KdbxHeader kdbxHeader , InputStream inputStream ) throws IOException { MessageDigest digest = Encryption . getMessageDigestInstance ( ) ; DigestInputStream digestInputStream = new DigestInputStream ( inputStream , digest ) ; LittleEndianDataInputStream ledis = new LittleEndianDataInputStream ( digestInputStream ) ; if ( ! verifyMagicNumber ( ledis ) ) { throw new IllegalStateException ( STR_ ) ; } if ( ! verifyFileVersion ( ledis ) ) { throw new IllegalStateException ( STR_ ) ; } byte headerType ; while ( ( headerType = ledis . readByte ( ) ) != HeaderType . END ) { switch ( headerType ) { case HeaderType . COMMENT : getByteArray ( ledis ) ; break ; case HeaderType . CIPHER_ID : kdbxHeader . setCipherUuid ( getByteArray ( ledis ) ) ; break ; case HeaderType . COMPRESSION_FLAGS : kdbxHeader . setCompressionFlags ( getInt ( ledis ) ) ; break ; case HeaderType . MASTER_SEED : kdbxHeader . setMasterSeed ( getByteArray ( ledis ) ) ; break ; case HeaderType . TRANSFORM_SEED : kdbxHeader . setTransformSeed ( getByteArray ( ledis ) ) ; break ; case HeaderType . TRANSFORM_ROUNDS : kdbxHeader . setTransformRounds ( getLong ( ledis ) ) ; break ; case HeaderType . ENCRYPTION_IV : kdbxHeader . setEncryptionIv ( getByteArray ( ledis ) ) ; break ; case HeaderType . PROTECTED_STREAM_KEY : kdbxHeader . setProtectedStreamKey ( getByteArray ( ledis ) ) ; break ; case HeaderType . STREAM_START_BYTES : kdbxHeader . setStreamStartBytes ( getByteArray ( ledis ) ) ; break ; case HeaderType . INNER_RANDOM_STREAM_ID : kdbxHeader . setInnerRandomStreamId ( getInt ( ledis ) ) ; break ; default : throw new IllegalStateException ( STR_ ) ; } } getByteArray ( ledis ) ; kdbxHeader . setHeaderHash ( digest . digest ( ) ) ; return kdbxHeader ; }
public static byte [ ] copyToByteArray ( InputStream in ) throws IOException { ByteArrayOutputStream out = new ByteArrayOutputStream ( BUFFER_SIZE ) ; copy ( in , out ) ; return out . toByteArray ( ) ; }
public boolean isEnumConstant ( ) { return ( getModifiers ( ) & Modifier . ENUM ) != NUM_ ; }
public boolean containsAny ( Collection < Taxon > taxa ) { for ( Taxon taxon : taxa ) { if ( taxa . contains ( taxon ) ) { return BOOL_ ; } } return BOOL_ ; }
@ SuppressWarnings ( STR_ ) public synchronized T dequeueTask ( ) throws InterruptedException { while ( _data . isEmpty ( ) ) { if ( ! _closedInput ) wait ( ) ; else return ( T ) NO_MORE_TASKS ; } T t = _data . removeFirst ( ) ; notify ( ) ; return t ; }
@ Override public void readExternal ( ObjectInput in ) throws IOException , ClassNotFoundException { super . readExternal ( in ) ; this . facetName = in . readUTF ( ) ; }
private boolean stringToBoolean ( String condition ) { boolean result = BOOL_ ; if ( condition != null && condition . length ( ) > NUM_ ) { String s = condition . substring ( NUM_ , NUM_ ) ; if ( s . equalsIgnoreCase ( STR_ ) || s . equals ( STR_ ) || s . equalsIgnoreCase ( STR_ ) ) result = BOOL_ ; } return result ; }
public static void writeUINT32 ( long number , OutputStream out ) throws IOException { if ( number < NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } byte [ ] toWrite = new byte [ NUM_ ] ; for ( int i = NUM_ ; i <= NUM_ ; i += NUM_ ) { toWrite [ i / NUM_ ] = ( byte ) ( ( number > > i ) & xFF ) ; } out . write ( toWrite ) ; }
public RemoteMetaDataImpl ( Schema schema ) throws RemoteException { this . schema = schema ; fields . addAll ( schema . fields ( ) ) ; }
private void checkServerResponseCode ( HttpURLConnection urlConnection ) throws RequestFailureException { try { if ( urlConnection . getResponseCode ( ) != NUM_ ) { throw new RequestFailureException ( STR_ + urlConnection . getResponseCode ( ) + STR_ ) ; } } catch ( IOException e ) { throw new RequestFailureException ( STR_ , e ) ; } }
public void addSwitchWithOptionalExtraPart ( String option , String optionExtraPartSynopsis , String description ) { optionList . add ( option ) ; optionExtraPartSynopsisMap . put ( option , optionExtraPartSynopsis ) ; optionDescriptionMap . put ( option , description ) ; int length = option . length ( ) + optionExtraPartSynopsis . length ( ) + NUM_ ; if ( length > maxWidth ) { maxWidth = length ; } }
public static Object detectLinuxDefaultFileBrowser ( Map < String , Object > fileBrowsers ) { ArrayList < String > command = new ArrayList < String > ( ) ; command . add ( STR_ ) ; command . add ( STR_ ) ; command . add ( STR_ ) ; command . add ( STR_ ) ; if ( fileBrowsers == null ) { fileBrowsers = new HashMap < String , Object > ( ) ; fileBrowsers . put ( STR_ , STR_ ) ; } return Utils . isExpectedCommandOutput ( command , fileBrowsers ) ; }
public void updated ( ) { currentColor = HtmlColors . decode ( getSettingValue ( ) ) ; secondaryColor = HtmlColors . decode ( baseColor ) ; Color foregroundColor ; Color backgroundColor ; if ( type == FOREGROUND ) { foregroundColor = currentColor ; backgroundColor = secondaryColor ; } else { foregroundColor = secondaryColor ; backgroundColor = currentColor ; } preview . setForeground ( foregroundColor ) ; preview . setBackground ( backgroundColor ) ; }
public Collection < ? extends ImmutableClassType > removeInstrumentationPoints ( final Collection < ? extends ImmutableType > types ) { return removeInstrumentationPoints ( types , Collections . < IInstrumentationApplier > singleton ( RemoveAllInstrumentationApplier . getInstance ( ) ) ) ; }
private Record createRecord ( RecordProperties recordProperties ) throws RecordException { String debugDirectory ; if ( isRecording ( ) ) { debugDirectory = previousDebugDirectory ; } else { debugDirectory = SystemPropertiesManager . get ( DebugConstants . CONFIG_DEBUG_DIRECTORY ) ; } String recordDirectory = debugDirectory + File . separator + RecordConstants . RECORD_FOLDER_NAME + File . separator + recordProperties . getIssueID ( ) + File . separator + recordProperties . getReferenceID ( ) ; Record record = new Record ( recordProperties , recordDirectory ) ; try { createFolder ( record . getFolderPath ( ) ) ; PrintWriter printWriterInfo = getPrintWriterForFile ( record , RecordConstants . INFO_FILE_NAME ) ; JsonValue info = recordReport . infoReport ( record ) ; try { JSONObject json = new JSONObject ( info . toString ( ) ) ; printWriterInfo . println ( json . toString ( NUM_ ) ) ; } catch ( JSONException e ) { debug . warning ( STR_ , info , e ) ; printWriterInfo . println ( info ) ; } printWriterInfo . flush ( ) ; return record ; } catch ( IOException e ) { debug . error ( STR_ , recordProperties , e ) ; throw new RecordException ( STR_ + recordProperties . getIssueID ( ) + STR_ , e ) ; } }
public static LaggedEdge serializableInstance ( ) { return new LaggedEdge ( STR_ , LaggedFactor . serializableInstance ( ) ) ; }
public final void dispatchCharactersEvents ( int nodeHandle , ContentHandler ch , boolean normalize ) throws SAXException { int identity = makeNodeIdentity ( nodeHandle ) ; if ( identity == DTM . NULL ) return ; int type = _type2 ( identity ) ; if ( type == DTM . ELEMENT_NODE || type == DTM . DOCUMENT_NODE ) { int startNode = identity ; identity = _firstch2 ( identity ) ; if ( DTM . NULL != identity ) { int offset = - NUM_ ; int length = NUM_ ; do { type = _exptype2 ( identity ) ; if ( type == DTM . TEXT_NODE || type == DTM . CDATA_SECTION_NODE ) { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex >= NUM_ ) { if ( - NUM_ == offset ) { offset = dataIndex > > > TEXT_LENGTH_BITS ; } length += dataIndex & TEXT_LENGTH_MAX ; } else { if ( - NUM_ == offset ) { offset = m_data . elementAt ( - dataIndex ) ; } length += m_data . elementAt ( - dataIndex + NUM_ ) ; } } identity ++ ; } while ( _parent2 ( identity ) >= startNode ) ; if ( length > NUM_ ) { if ( normalize ) m_chars . sendNormalizedSAXcharacters ( ch , offset , length ) ; else m_chars . sendSAXcharacters ( ch , offset , length ) ; } } } else if ( DTM . TEXT_NODE == type || DTM . CDATA_SECTION_NODE == type ) { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex >= NUM_ ) { if ( normalize ) m_chars . sendNormalizedSAXcharacters ( ch , dataIndex > > > TEXT_LENGTH_BITS , dataIndex & TEXT_LENGTH_MAX ) ; else m_chars . sendSAXcharacters ( ch , dataIndex > > > TEXT_LENGTH_BITS , dataIndex & TEXT_LENGTH_MAX ) ; } else { if ( normalize ) m_chars . sendNormalizedSAXcharacters ( ch , m_data . elementAt ( - dataIndex ) , m_data . elementAt ( - dataIndex + NUM_ ) ) ; else m_chars . sendSAXcharacters ( ch , m_data . elementAt ( - dataIndex ) , m_data . elementAt ( - dataIndex + NUM_ ) ) ; } } else { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex < NUM_ ) { dataIndex = - dataIndex ; dataIndex = m_data . elementAt ( dataIndex + NUM_ ) ; } String str = ( String ) m_values . elementAt ( dataIndex ) ; if ( normalize ) FastStringBuffer . sendNormalizedSAXcharacters ( str . toCharArray ( ) , NUM_ , str . length ( ) , ch ) ; else ch . characters ( str . toCharArray ( ) , NUM_ , str . length ( ) ) ; } }
private int clampMag ( int value , int absMin , int absMax ) { final int absValue = Math . abs ( value ) ; if ( absValue < absMin ) return NUM_ ; if ( absValue > absMax ) return value > NUM_ ? absMax : - absMax ; return value ; }
private static int lengthOfMimeNames ( String val ) { int len = val . indexOf ( STR_ ) ; if ( len < NUM_ ) len = val . length ( ) ; return len ; }
private char readEscapeCharacter ( ) throws JSONException { char escaped = in . charAt ( pos ++ ) ; switch ( escaped ) { case STR_ : if ( pos + NUM_ > in . length ( ) ) { throw syntaxError ( STR_ ) ; } String hex = in . substring ( pos , pos + NUM_ ) ; pos += NUM_ ; return ( char ) Integer . parseInt ( hex , NUM_ ) ; case STR_ : return STR_ ; case STR_ : return STR_ ; case STR_ : return STR_ ; case STR_ : return STR_ ; case STR_ : return STR_ ; case STR_ : case STR_ : case STR_ : default : return escaped ; } }
public static boolean isSha1String ( final String string ) { Preconditions . checkNotNull ( string , STR_ ) ; return ( string . length ( ) == NUM_ ) && isHexString ( string ) ; }
public boolean isWatched ( ) { return watched ; }
public void addDateChangeListener ( DateChangeListener listener ) { dateChangeListeners . add ( listener ) ; }
public static String stripFileProtocol ( String uriString ) { if ( uriString . startsWith ( STR_ ) ) { uriString = uriString . substring ( NUM_ ) ; } return uriString ; }
public void replaceTemplate ( ElemTemplate v , int i ) throws TransformerException { if ( null == m_templates ) throw new ArrayIndexOutOfBoundsException ( ) ; replaceChild ( v , ( ElemTemplateElement ) m_templates . elementAt ( i ) ) ; m_templates . setElementAt ( v , i ) ; v . setStylesheet ( this ) ; }
public static byte [ ] decode ( String data ) { int len = data . length ( ) / NUM_ . NUM_ ; ByteArrayOutputStream bOut = new ByteArrayOutputStream ( len ) ; try { encoder . decode ( data , bOut ) ; } catch ( Exception e ) { throw new DecoderException ( STR_ + e . getMessage ( ) , e ) ; } return bOut . toByteArray ( ) ; }
public void characters ( char ch [ ] , int start , int length ) throws SAXException { m_curValue . append ( ch , start , length ) ; }
public boolean regenerate ( Projection proj ) { boolean ret = super . regenerate ( proj ) ; if ( proj != null && ! ret ) { ret = generate ( proj ) ; } return ret ; }
@ Override public byte [ ] unwrap ( final byte [ ] incoming , final int offset , final int len ) throws LdapException { final byte [ ] copy = new byte [ len ] ; System . arraycopy ( incoming , offset , copy , NUM_ , len ) ; return copy ; }
private int sequentialForwardSelection ( String dataFile , String [ ] features , int indVarColNumber , int X [ ] , int Y [ ] , double J [ ] , int rowIni , int rowEnd ) { double sig [ ] = new double [ Y . length ] ; int sigIndex [ ] = new int [ Y . length ] ; double corXplusy [ ] = new double [ Y . length ] ; double corX ; if ( X . length > NUM_ ) { Regression reg = new Regression ( ) ; reg . multipleLinearRegression ( dataFile , indVarColNumber , X , features , interceptTerm , rowIni , rowEnd ) ; corX = reg . getCorrelation ( ) ; } else corX = NUM_ ; for ( int i = NUM_ ; i < Y . length ; i ++ ) { corXplusy [ i ] = correlationOfNewFeature ( dataFile , features , indVarColNumber , X , Y [ i ] , rowIni , rowEnd ) ; sig [ i ] = corXplusy [ i ] - corX ; sigIndex [ i ] = Y [ i ] ; } int minSig = MathUtils . getMinIndex ( sig ) ; J [ NUM_ ] = corXplusy [ minSig ] ; J [ NUM_ ] = corX ; int maxSig = MathUtils . getMaxIndex ( sig ) ; J [ NUM_ ] = corXplusy [ maxSig ] ; return sigIndex [ maxSig ] ; }
private static byte [ ] codesToBytes ( String codes , boolean required ) { if ( codes . length ( ) == NUM_ ) { if ( required ) { throw new IllegalStateException ( STR_ ) ; } return null ; } if ( ( codes . length ( ) % NUM_ ) != NUM_ ) { codes = STR_ + codes ; } byte [ ] bytes = new byte [ codes . length ( ) / NUM_ ] ; for ( int i = NUM_ ; i < bytes . length ; ++ i ) { int charIdx = i . NUM_ ; bytes [ i ] = ( byte ) ( Integer . parseInt ( codes . substring ( charIdx , charIdx + NUM_ ) , NUM_ ) ) ; } return bytes ; }
public DragEntry dragSelectedEntry ( ) { try { KeyStoreHistory history = getActiveKeyStoreHistory ( ) ; if ( history == null ) { return null ; } KeyStoreState currentState = history . getCurrentState ( ) ; KeyStore keyStore = currentState . getKeyStore ( ) ; String alias = getSelectedEntryAlias ( ) ; if ( alias == null ) { return null ; } if ( KeyStoreUtil . isKeyEntry ( alias , keyStore ) ) { JOptionPane . showMessageDialog ( frame , res . getString ( STR_ ) , KSE . getApplicationName ( ) , JOptionPane . WARNING_MESSAGE ) ; return null ; } if ( KeyStoreUtil . isKeyPairEntry ( alias , keyStore ) ) { Password password = currentState . getEntryPassword ( alias ) ; KeyStoreType type = KeyStoreType . resolveJce ( keyStore . getType ( ) ) ; if ( password == null && type . hasEntryPasswords ( ) ) { JOptionPane . showMessageDialog ( frame , res . getString ( STR_ ) , KSE . getApplicationName ( ) , JOptionPane . WARNING_MESSAGE ) ; return null ; } PrivateKey privateKey = ( PrivateKey ) keyStore . getKey ( alias , password . toCharArray ( ) ) ; Certificate [ ] certificateChain = keyStore . getCertificateChain ( alias ) ; return new DragKeyPairEntry ( alias , privateKey , password , certificateChain ) ; } else { Certificate trustedCertificate = keyStore . getCertificate ( alias ) ; return new DragTrustedCertificateEntry ( alias , trustedCertificate ) ; } } catch ( Exception ex ) { DError . displayError ( frame , ex ) ; return null ; } }
public void insert ( T object , int index ) { synchronized ( mLock ) { if ( mOriginalValues != null ) { mOriginalValues . add ( index , object ) ; } else { mObjects . add ( index , object ) ; } } if ( mNotifyOnChange ) notifyDataSetChanged ( ) ; }
public static Document createDocument ( boolean isSecureProcessing ) { try { DocumentBuilderFactory dfactory = DocumentBuilderFactory . newInstance ( ) ; dfactory . setNamespaceAware ( BOOL_ ) ; DocumentBuilder docBuilder = dfactory . newDocumentBuilder ( ) ; Document outNode = docBuilder . newDocument ( ) ; return outNode ; } catch ( ParserConfigurationException pce ) { throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_CREATEDOCUMENT_NOT_SUPPORTED , null ) ) ; } }
public double reduce ( String numericColumnName , NumericReduceFunction function ) { Column column = column ( numericColumnName ) ; return function . reduce ( column . toDoubleArray ( ) ) ; }
public void testSetBitNegativeOutside1 ( ) { byte aBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; int aSign = - NUM_ ; int number = NUM_ ; byte rBytes [ ] = { - NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , - NUM_ , - NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger result = aNumber . setBit ( number ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , - NUM_ , result . signum ( ) ) ; }
static public String formatUInt8Char ( byte b ) { String ch = new String ( new byte [ ] { b } ) ; ch = ch . replaceAll ( STR_ , STR_ ) ; return formatUInt8 ( b ) + STR_ + ch ; }
public static final ArrayList < Move > removeIllegal ( Position pos , ArrayList < Move > moveList ) { ArrayList < Move > ret = new ArrayList < Move > ( ) ; UndoInfo ui = new UndoInfo ( ) ; int mlSize = moveList . size ( ) ; for ( int mi = NUM_ ; mi < mlSize ; mi ++ ) { Move m = moveList . get ( mi ) ; pos . makeMove ( m , ui ) ; pos . setWhiteMove ( ! pos . whiteMove ) ; if ( ! inCheck ( pos ) ) ret . add ( m ) ; pos . setWhiteMove ( ! pos . whiteMove ) ; pos . unMakeMove ( m , ui ) ; } return ret ; }
public static int applyMaskPenaltyRule4 ( ByteMatrix matrix ) { int numDarkCells = NUM_ ; byte [ ] [ ] array = matrix . getArray ( ) ; int width = matrix . getWidth ( ) ; int height = matrix . getHeight ( ) ; for ( int y = NUM_ ; y < height ; ++ y ) { for ( int x = NUM_ ; x < width ; ++ x ) { if ( array [ y ] [ x ] == NUM_ ) { numDarkCells += NUM_ ; } } } int numTotalCells = matrix . getHeight ( ) . matrix . getWidth ( ) ; double darkRatio = ( double ) numDarkCells / numTotalCells ; return Math . abs ( ( int ) ( darkRatio . NUM_ - NUM_ ) ) / NUM_ . NUM_ ; }
private void checkState ( ) { if ( diagramRetrieved ) { throw new IllegalStateException ( STR_ ) ; } }
static Hashtable convertToHash ( Map m ) { Hashtable retHash = new Hashtable ( ) ; Set s = m . keySet ( ) ; Iterator iter = s . iterator ( ) ; while ( iter . hasNext ( ) ) { String key = ( String ) iter . next ( ) ; Set val = ( Set ) m . get ( key ) ; retHash . put ( key , setToString ( val ) ) ; } return retHash ; }
public void actionPerformed ( ActionEvent evt ) { }
public boolean equal_at_start ( PlaPointInt p_point ) { if ( p_point == null ) return BOOL_ ; PlaPoint first = corner_first ( ) ; return first . equals ( p_point ) ; }
public void forEachBlockDepthFirst ( boolean reverse , SsaBasicBlock . Visitor v ) { BitSet visited = new BitSet ( blocks . size ( ) ) ; Stack < SsaBasicBlock > stack = new Stack < SsaBasicBlock > ( ) ; SsaBasicBlock rootBlock = reverse ? getExitBlock ( ) : getEntryBlock ( ) ; if ( rootBlock == null ) { return ; } stack . add ( null ) ; stack . add ( rootBlock ) ; while ( stack . size ( ) > NUM_ ) { SsaBasicBlock cur = stack . pop ( ) ; SsaBasicBlock parent = stack . pop ( ) ; if ( ! visited . get ( cur . getIndex ( ) ) ) { BitSet children = reverse ? cur . getPredecessors ( ) : cur . getSuccessors ( ) ; for ( int i = children . nextSetBit ( NUM_ ) ; i >= NUM_ ; i = children . nextSetBit ( i + NUM_ ) ) { stack . add ( cur ) ; stack . add ( blocks . get ( i ) ) ; } visited . set ( cur . getIndex ( ) ) ; v . visitBlock ( cur , parent ) ; } } }
protected void fillPath ( ) { mPSStream . println ( mFillOpStr ) ; }
public static byte [ ] decode ( String encoded ) { if ( encoded == null ) { return null ; } char [ ] base64Data = encoded . toCharArray ( ) ; int len = removeWhiteSpace ( base64Data ) ; if ( len % FOURBYTE != NUM_ ) { return null ; } int numberQuadruple = ( len / FOURBYTE ) ; if ( numberQuadruple == NUM_ ) { return new byte [ NUM_ ] ; } byte decodedData [ ] = null ; byte b1 = NUM_ , b2 = NUM_ , b3 = NUM_ , b4 = NUM_ ; char d1 = NUM_ , d2 = NUM_ , d3 = NUM_ , d4 = NUM_ ; int i = NUM_ ; int encodedIndex = NUM_ ; int dataIndex = NUM_ ; decodedData = new byte [ ( numberQuadruple ) . NUM_ ] ; for ( ; i < numberQuadruple - NUM_ ; i ++ ) { if ( ! isData ( ( d1 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d2 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d3 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d4 = base64Data [ dataIndex ++ ] ) ) ) { return null ; } b1 = base64Alphabet [ d1 ] ; b2 = base64Alphabet [ d2 ] ; b3 = base64Alphabet [ d3 ] ; b4 = base64Alphabet [ d4 ] ; decodedData [ encodedIndex ++ ] = ( byte ) ( b1 << NUM_ | b2 > > NUM_ ) ; decodedData [ encodedIndex ++ ] = ( byte ) ( ( ( b2 & xf ) << NUM_ ) | ( ( b3 > > NUM_ ) & xf ) ) ; decodedData [ encodedIndex ++ ] = ( byte ) ( b3 << NUM_ | b4 ) ; } if ( ! isData ( ( d1 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d2 = base64Data [ dataIndex ++ ] ) ) ) { return null ; } b1 = base64Alphabet [ d1 ] ; b2 = base64Alphabet [ d2 ] ; d3 = base64Data [ dataIndex ++ ] ; d4 = base64Data [ dataIndex ++ ] ; if ( ! isData ( ( d3 ) ) || ! isData ( ( d4 ) ) ) { if ( isPad ( d3 ) && isPad ( d4 ) ) { if ( ( b2 & xf ) != NUM_ ) { return null ; } byte [ ] tmp = new byte [ i . NUM_ + NUM_ ] ; System . arraycopy ( decodedData , NUM_ , tmp , NUM_ , i . NUM_ ) ; tmp [ encodedIndex ] = ( byte ) ( b1 << NUM_ | b2 > > NUM_ ) ; return tmp ; } else if ( ! isPad ( d3 ) && isPad ( d4 ) ) { b3 = base64Alphabet [ d3 ] ; if ( ( b3 & x3 ) != NUM_ ) { return null ; } byte [ ] tmp = new byte [ i . NUM_ + NUM_ ] ; System . arraycopy ( decodedData , NUM_ , tmp , NUM_ , i . NUM_ ) ; tmp [ encodedIndex ++ ] = ( byte ) ( b1 << NUM_ | b2 > > NUM_ ) ; tmp [ encodedIndex ] = ( byte ) ( ( ( b2 & xf ) << NUM_ ) | ( ( b3 > > NUM_ ) & xf ) ) ; return tmp ; } else { return null ; } } else { b3 = base64Alphabet [ d3 ] ; b4 = base64Alphabet [ d4 ] ; decodedData [ encodedIndex ++ ] = ( byte ) ( b1 << NUM_ | b2 > > NUM_ ) ; decodedData [ encodedIndex ++ ] = ( byte ) ( ( ( b2 & xf ) << NUM_ ) | ( ( b3 > > NUM_ ) & xf ) ) ; decodedData [ encodedIndex ++ ] = ( byte ) ( b3 << NUM_ | b4 ) ; } return decodedData ; }
public boolean isLastWindow ( AccessibilityWindowInfo baseWindow , int windowType ) { int index = getWindowIndex ( baseWindow ) ; if ( index == WRONG_INDEX ) { return BOOL_ ; } int count = mWindows . size ( ) ; for ( int i = index + NUM_ ; i < count ; i ++ ) { AccessibilityWindowInfo window = mWindows . get ( i ) ; if ( window != null && window . getType ( ) == windowType ) { return BOOL_ ; } } return BOOL_ ; }
public void passPgSessionMapEx ( ViewBean other ) { Map attributes = getPageSessionAttributes ( ) ; for ( Iterator i = retainPageSessionsBtwTabs . iterator ( ) ; i . hasNext ( ) ; ) { String key = ( String ) i . next ( ) ; other . setPageSessionAttribute ( key , ( Serializable ) attributes . get ( key ) ) ; } other . setPageSessionAttribute ( getTrackingTabIDName ( ) , ( Serializable ) attributes . get ( getTrackingTabIDName ( ) ) ) ; }
public long time ( ) { return heartbeatTime ; }
public boolean hitClip ( int x , int y , int width , int height ) { return g . hitClip ( x , y , width , height ) ; }
public static CloseWatcher pollUnclosed ( ) { ReferenceQueue < Object > q = queue ; if ( q == null ) { return null ; } while ( BOOL_ ) { CloseWatcher cw = ( CloseWatcher ) q . poll ( ) ; if ( cw == null ) { return null ; } if ( refs != null ) { refs . remove ( cw ) ; } if ( cw . closeable != null ) { return cw ; } } }
private static boolean appendOdexesToClassPath ( Context cxt , File dexDir , String [ ] names ) { String strDexDir = dexDir . getAbsolutePath ( ) ; ArrayList < String > jarPaths = new ArrayList < String > ( ) ; for ( int i = NUM_ ; i < names . length ; i ++ ) { String jarPath = strDexDir + STR_ + names [ i ] ; File f = new File ( jarPath ) ; if ( f . isFile ( ) ) { jarPaths . add ( jarPath ) ; } } String [ ] jarsOfDex = new String [ jarPaths . size ( ) ] ; jarPaths . toArray ( jarsOfDex ) ; PathClassLoader pcl = ( PathClassLoader ) cxt . getClassLoader ( ) ; try { if ( Build . VERSION . SDK_INT < SDK_INT_ICS ) { FrameworkHack . appendDexListImplUnderICS ( jarsOfDex , pcl , dexDir ) ; } else { boolean kitkatPlus = Build . VERSION . SDK_INT >= SDK_INT_KITKAT ; boolean marshmallowPlus = Build . VERSION . SDK_INT >= SDK_INT_MARSHMALLOW ; ArrayList < File > jarFiles = DexDex . strings2Files ( jarsOfDex ) ; FrameworkHack . appendDexListImplICS ( jarFiles , pcl , dexDir , kitkatPlus , marshmallowPlus ) ; } for ( String jarName : names ) { theAppended . add ( jarName ) ; } if ( debug ) { Log . d ( TAG , STR_ + pcl ) ; Log . d ( TAG , STR_ + theAppended ) ; } } catch ( Exception ex ) { throw new RuntimeException ( ex ) ; } return BOOL_ ; }
@ Override public final int readInt ( ) throws IOException { dis . readFully ( work , NUM_ , NUM_ ) ; return ( work [ NUM_ ] ) << NUM_ | ( work [ NUM_ ] & xff ) << NUM_ | ( work [ NUM_ ] & xff ) << NUM_ | ( work [ NUM_ ] & xff ) ; }
private void assertSerializeAndDesDateTime ( String dateTimeString ) throws RyaTypeResolverException { assertSerializeAndDesDateTime ( dateTimeString , dateTimeString ) ; }
public boolean isHardMode ( ) { return isHardMode ; }
protected String doIt ( ) throws Exception { setup ( ) ; for ( MWarehouse warehouse : warehouses ) for ( MCostType costType : costTypes ) for ( MCostElement costElement : costElements ) for ( int productId : products ) generateInventoryValue ( productId , costType . getM_CostType_ID ( ) , costElement . getM_CostElement_ID ( ) , warehouse . getM_Warehouse_ID ( ) ) ; pstmt . executeBatch ( ) ; commitEx ( ) ; DB . close ( pstmt ) ; DB . executeUpdate ( STR_ + DB . TO_DATE ( p_DateValue ) + STR_ , getAD_PInstance_ID ( ) , get_TrxName ( ) ) ; return STR_ + count ; }
public void run ( ) { setup ( ) ; log . info ( STR_ ) ; for ( TaskStorageManager taskStorageManager : taskStorageManagers ) { taskStorageManager . init ( ) ; taskStorageManager . stopStores ( ) ; log . debug ( STR_ + taskStorageManager . toString ( ) ) ; } log . info ( STR_ + storeBaseDir . toString ( ) ) ; }
public Criteria createCriteria ( ) { Criteria criteria = createCriteriaInternal ( ) ; if ( oredCriteria . size ( ) == NUM_ ) { oredCriteria . add ( criteria ) ; } return criteria ; }
public static int [ ] shuffle ( int [ ] input ) { List < Integer > vals = new ArrayList < Integer > ( input . length ) ; for ( int i = NUM_ ; i < input . length ; i ++ ) vals . add ( input [ i ] ) ; Collections . shuffle ( vals , SEEDED_RANDOM ) ; int [ ] copy = new int [ input . length ] ; for ( int i = NUM_ ; i < input . length ; i ++ ) copy [ i ] = vals . get ( i ) ; return copy ; }
public void read ( int i ) { VariableValue v = rowVector . elementAt ( i ) ; v . readAll ( ) ; }
protected List < Expression > transformExpressions ( List < ? extends Expression > expressions , ExpressionTransformer transformer ) { List < Expression > list = new ArrayList < Expression > ( expressions . size ( ) ) ; for ( Expression expr : expressions ) { list . add ( transformer . transform ( expr ) ) ; } return list ; }
public String prefixForward ( int length ) { final String prefix = prefix ( length ) ; this . pointer += length ; this . index += length ; this . column += length ; return prefix ; }
private boolean canAddTask ( ) { return tCur == null ; }
public void flush ( ) throws IOException { if ( printWriter != null ) { printWriter . flush ( ) ; } if ( gzipOutputStream != null ) { gzipOutputStream . flush ( ) ; } }
public int start ( ) { started . compareAndSet ( BOOL_ , BOOL_ ) ; server . start ( ) ; return server . getServerPort ( ) ; }
public static double angle ( Tuple3d a , Tuple3d b ) { double dx = b . x - a . x ; double dy = b . y - a . y ; double angle = NUM_ ; if ( dx == NUM_ ) { if ( dy == NUM_ ) angle = NUM_ ; else if ( dy > NUM_ ) angle = Math . PI / NUM_ ; else angle = ( Math . PI . NUM_ ) / NUM_ ; } else if ( dy == NUM_ ) { if ( dx > NUM_ ) angle = NUM_ ; else angle = Math . PI ; } else { if ( dx < NUM_ ) angle = Math . atan ( dy / dx ) + Math . PI ; else if ( dy < NUM_ ) angle = Math . atan ( dy / dx ) + ( NUM_ . Math . PI ) ; else angle = Math . atan ( dy / dx ) ; } return angle ; }
public void addStringToTable ( byte [ ] oldString , byte newString ) { int length = oldString . length ; byte [ ] str = new byte [ length + NUM_ ] ; System . arraycopy ( oldString , NUM_ , str , NUM_ , length ) ; str [ length ] = newString ; stringTable [ tableIndex ++ ] = str ; if ( tableIndex == NUM_ ) { bitsToGet = NUM_ ; } else if ( tableIndex == NUM_ ) { bitsToGet = NUM_ ; } else if ( tableIndex == NUM_ ) { bitsToGet = NUM_ ; } }
public static boolean identical ( URI first , URI second ) { if ( ( first != null ) && ( second != null ) ) { return first . equals ( second ) ; } return BOOL_ ; }
default < ST > Xor < ST , T > toXor ( final ST secondary ) { final Optional < T > o = toOptional ( ) ; return o . isPresent ( ) ? Xor . primary ( o . get ( ) ) : Xor . secondary ( secondary ) ; }
public void processInvite ( RequestEvent requestEvent , ServerTransaction serverTransaction ) { SipProvider sipProvider = ( SipProvider ) requestEvent . getSource ( ) ; Request request = requestEvent . getRequest ( ) ; logger . info ( STR_ + request ) ; timer . schedule ( new DelayedInviteResponsesTask ( requestEvent , sipProvider ) , NUM_ ) ; }
ConfigurationError ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; }
protected Instances dataFromXML ( Instances header ) throws Exception { Instances result ; Element node ; Vector < Element > list ; list = getChildTags ( m_Document . getDocumentElement ( ) , TAG_BODY ) ; node = list . get ( NUM_ ) ; list = getChildTags ( node , TAG_INSTANCES ) ; node = list . get ( NUM_ ) ; result = createInstances ( header , node ) ; return result ; }
private static String prependIfMissing ( final String str , final CharSequence prefix , final boolean ignoreCase , final CharSequence ... prefixes ) { if ( str == null || isEmpty ( prefix ) || startsWith ( str , prefix , ignoreCase ) ) { return str ; } if ( prefixes != null && prefixes . length > NUM_ ) { for ( final CharSequence p : prefixes ) { if ( startsWith ( str , p , ignoreCase ) ) { return str ; } } } return prefix . toString ( ) + str ; }
protected CacheDistributionAdvisor createDistributionAdvisor ( InternalRegionArguments internalRegionArgs ) { return CacheDistributionAdvisor . createCacheDistributionAdvisor ( this ) ; }
public Object [ ] toArray ( ) { ArrayList < E > al = new ArrayList < E > ( ) ; for ( Node < E > p = first ( ) ; p != null ; p = succ ( p ) ) { E item = p . item ; if ( item != null ) al . add ( item ) ; } return al . toArray ( ) ; }
public void addMouseListener ( GlobalMouseListener listener ) { listeners . add ( listener ) ; }
private Vector1D finiteOrNullPoint ( final double x ) { return Double . isInfinite ( x ) ? null : new Vector1D ( x ) ; }
public void loadPDF ( final File input ) { if ( input == null ) { return ; } scale = NUM_ ; PDFfile = input . getAbsolutePath ( ) ; fileLoc . setText ( PDFfile ) ; openFile ( input , null , BOOL_ ) ; }
public CharBuffer append ( Object obj ) { return append ( String . valueOf ( obj ) ) ; }
public void testIntbyInt1 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int bSign = - NUM_ ; byte rBytes [ ] = { - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . multiply ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , - NUM_ , result . signum ( ) ) ; }
public abstract void initializeConstraints ( Step step , Settings settings ) ;
private static void checkFileValidation ( File file ) { if ( file == null ) throw new NullPointerException ( STR_ ) ; if ( ! file . exists ( ) ) { throw new IllegalArgumentException ( STR_ + file . getPath ( ) + STR_ ) ; } file . canRead ( ) ; }
public < ResultT > Set < ResultT > toSet ( Converter < ResultT > converter ) { try { if ( isEmpty ( cursor ) ) { return Collections . emptySet ( ) ; } return populate ( converter , new HashSet < ResultT > ( cursor . getCount ( ) ) ) ; } finally { close ( ) ; } }
public static Builder newBuilder ( ) { return new Builder ( ) ; }
public static void stashDisableAssertionArg ( String arg ) { if ( arg == null || arg . equals ( STR_ ) ) { assertionsEnabled = BOOL_ ; } else { disabledAssertionStrings = arg . split ( STR_ ) ; } }
private static void attemptRetryOnException ( String logPrefix , Request < ? > request , VolleyError exception ) throws VolleyError { RetryPolicy retryPolicy = request . getRetryPolicy ( ) ; int oldTimeout = request . getTimeoutMs ( ) ; try { retryPolicy . retry ( exception ) ; } catch ( VolleyError e ) { request . addMarker ( String . format ( STR_ , logPrefix , oldTimeout ) ) ; throw e ; } request . addMarker ( String . format ( STR_ , logPrefix , oldTimeout ) ) ; }
public Iterator < Stream > memberIterator ( ) { return memberSet . iterator ( ) ; }
private void cleanMapping ( ) { ArrayList < Integer > toRemove = new ArrayList < Integer > ( ) ; int size = mListMapping . size ( ) ; for ( int i = NUM_ ; i < size ; ++ i ) { if ( mListMapping . keyAt ( i ) == mListMapping . valueAt ( i ) ) { toRemove . add ( mListMapping . keyAt ( i ) ) ; } } size = toRemove . size ( ) ; for ( int i = NUM_ ; i < size ; ++ i ) { mListMapping . delete ( toRemove . get ( i ) ) ; } }
public static String timeUntil ( final int seconds , final boolean forceSeconds ) { final StringBuilder sbuf = new StringBuilder ( ) ; timeUntil ( sbuf , seconds , forceSeconds ) ; return sbuf . toString ( ) ; }
public void remove ( T item ) { if ( set . remove ( item ) ) { fireContentsChanged ( this , NUM_ , getSize ( ) - NUM_ ) ; } }
public static void append ( File file , Reader reader , String charset ) throws IOException { append ( file , reader , charset , BOOL_ ) ; }
void parseIgnoredSection ( ) throws IOException { int depth = NUM_ ; in . replace ++ ; while ( BOOL_ ) { switch ( ch ) { case STR_ : if ( ( ch = in . read ( ) ) == STR_ ) { if ( ( ch = in . read ( ) ) == STR_ ) { ch = in . read ( ) ; depth ++ ; } } break ; case STR_ : if ( ( ch = in . read ( ) ) == STR_ ) { if ( ( ch = in . read ( ) ) == STR_ ) { ch = in . read ( ) ; if ( -- depth == NUM_ ) { in . replace -- ; return ; } } } break ; case - NUM_ : error ( STR_ ) ; in . replace -- ; return ; default : ch = in . read ( ) ; break ; } } }
private synchronized int readRecordLength ( ) throws IOException { if ( in . getPos ( ) >= end ) { return - NUM_ ; } int length = in . readInt ( ) ; if ( sync != null && length == SYNC_ESCAPE ) { in . readFully ( syncCheck ) ; if ( ! Arrays . equals ( sync , syncCheck ) ) { throw new IOException ( STR_ ) ; } syncSeen = BOOL_ ; if ( in . getPos ( ) >= end ) { return - NUM_ ; } length = in . readInt ( ) ; } else { syncSeen = BOOL_ ; } return length ; }
public void addSlide ( @ NonNull Fragment fragment ) { fragments . add ( fragment ) ; if ( isWizardMode ) { setOffScreenPageLimit ( fragments . size ( ) ) ; } mPagerAdapter . notifyDataSetChanged ( ) ; }
public DefaultIntervalCategoryDataset ( Comparable [ ] seriesKeys , Comparable [ ] categoryKeys , Number [ ] [ ] starts , Number [ ] [ ] ends ) { this . startData = starts ; this . endData = ends ; if ( starts != null && ends != null ) { String baseName = STR_ ; ResourceBundle resources = ResourceBundleWrapper . getBundle ( baseName ) ; int seriesCount = starts . length ; if ( seriesCount != ends . length ) { String errMsg = STR_ + STR_ + STR_ + STR_ ; throw new IllegalArgumentException ( errMsg ) ; } if ( seriesCount > NUM_ ) { if ( seriesKeys != null ) { if ( seriesKeys . length != seriesCount ) { throw new IllegalArgumentException ( STR_ + STR_ ) ; } this . seriesKeys = seriesKeys ; } else { String prefix = resources . getString ( STR_ ) + STR_ ; this . seriesKeys = generateKeys ( seriesCount , prefix ) ; } int categoryCount = starts [ NUM_ ] . length ; if ( categoryCount != ends [ NUM_ ] . length ) { String errMsg = STR_ + STR_ + STR_ + STR_ ; throw new IllegalArgumentException ( errMsg ) ; } if ( categoryKeys != null ) { if ( categoryKeys . length != categoryCount ) { throw new IllegalArgumentException ( STR_ + STR_ ) ; } this . categoryKeys = categoryKeys ; } else { String prefix = resources . getString ( STR_ ) + STR_ ; this . categoryKeys = generateKeys ( categoryCount , prefix ) ; } } else { this . seriesKeys = new Comparable [ NUM_ ] ; this . categoryKeys = new Comparable [ NUM_ ] ; } } }
public void translate ( double dx , double dy ) { if ( ! isRelative ( ) ) { x += dx ; y += dy ; } if ( sourcePoint != null ) { sourcePoint . setX ( sourcePoint . getX ( ) + dx ) ; sourcePoint . setY ( sourcePoint . getY ( ) + dy ) ; } if ( targetPoint != null ) { targetPoint . setX ( targetPoint . getX ( ) + dx ) ; targetPoint . setY ( targetPoint . getY ( ) + dy ) ; } if ( TRANSLATE_CONTROL_POINTS && points != null ) { int count = points . size ( ) ; for ( int i = NUM_ ; i < count ; i ++ ) { mxPoint pt = ( mxPoint ) points . get ( i ) ; pt . setX ( pt . getX ( ) + dx ) ; pt . setY ( pt . getY ( ) + dy ) ; } } }
public abstract void fill ( ByteBuffer buffer , long id ) ;
private String anonymizePassword ( String password ) { if ( password == null ) { return STR_ ; } StringBuilder sb = new StringBuilder ( ) ; for ( int i = NUM_ ; i < password . length ( ) ; i ++ ) { sb . append ( STR_ ) ; } return sb . toString ( ) ; }
public final void write ( final byte [ ] data ) { byteBuffer . put ( data ) ; }
public RRDatabase ( File file ) throws IOException { name = file . getName ( ) ; rrdFile = new RRDFile ( file ) ; header = new Header ( rrdFile ) ; nameindex = new HashMap < String , Integer > ( header . dsCount ) ; dataSources = new ArrayList < DataSource > ( header . dsCount ) ; for ( int i = NUM_ ; i < header . dsCount ; i ++ ) { DataSource ds = new DataSource ( rrdFile ) ; nameindex . put ( ds . getName ( ) , i ) ; dataSources . add ( ds ) ; } archives = new ArrayList < Archive > ( header . rraCount ) ; for ( int i = NUM_ ; i < header . rraCount ; i ++ ) { Archive archive = new Archive ( this ) ; archives . add ( archive ) ; } long last_up = ( long ) rrdFile . readLong ( ) . NUM_ ; if ( header . getVersionAsInt ( ) >= Constants . VERSION_WITH_LAST_UPDATE_SEC ) { long last_up_usec = rrdFile . readLong ( ) ; last_up += last_up_usec / NUM_ ; } lastUpdate = new Date ( last_up ) ; for ( int i = NUM_ ; i < header . dsCount ; i ++ ) { DataSource ds = dataSources . get ( i ) ; ds . loadPDPStatusBlock ( rrdFile ) ; } for ( int i = NUM_ ; i < header . rraCount ; i ++ ) { Archive archive = archives . get ( i ) ; archive . loadCDPStatusBlocks ( rrdFile , header . dsCount ) ; } for ( int i = NUM_ ; i < header . rraCount ; i ++ ) { Archive archive = archives . get ( i ) ; archive . loadCurrentRow ( rrdFile ) ; } for ( int i = NUM_ ; i < header . rraCount ; i ++ ) { Archive archive = archives . get ( i ) ; archive . loadData ( rrdFile , header . dsCount ) ; } }
public void close ( ) throws IOException { inputStream . close ( ) ; }
public Address malloc ( int size , int howmany ) { int result = nextReservableAddress ; nextReservableAddress += size . howmany ; if ( nextReservableAddress > ( MEMSIZE + memAddressStart ) ) { addressOutOfRange = BOOL_ ; return null ; } return new Address ( Op . MEM , size , result ) ; }
public static String maskLeft ( String s , int len , char mask_ch ) { if ( len <= NUM_ ) { return s ; } len = Math . min ( len , s . length ( ) ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = NUM_ ; i < len ; i ++ ) { sb . append ( mask_ch ) ; } sb . append ( s . substring ( len ) ) ; return sb . toString ( ) ; }
public static double pdf ( double x , double mu , double sigma , double skew ) { x = ( x - mu ) / sigma ; if ( Math . abs ( skew ) > NUM_ ) { x = - Math . log ( NUM_ - skew . x ) / skew ; } return MathUtil . SQRTHALF . Math . exp ( - NUM_ . x . x ) / sigma / ( NUM_ - skew . x ) ; }
public Composer to ( long animDuration , float x , float y , int alpha , float scaleX , float scaleY , float rotation , Ease ease ) { mTweenParameterList . add ( new TweenParameter ( x , y , alpha , scaleX , scaleY , rotation , animDuration , ease ) ) ; return this ; }
@ Override public String toString ( ) { StringBuilder buffer = new StringBuilder ( NUM_ ) ; try { print ( buffer ) ; } catch ( IOException e ) { throw new RuntimeException ( STR_ , e ) ; } return buffer . toString ( ) ; }
@ Override public MemChunkHolder < BigDataMemAllocator > createChunk ( long size , boolean autoreclaim ) { MemChunkHolder < BigDataMemAllocator > ret = null ; Long addr = m_vmasvc . allocate ( m_nid , size , BOOL_ ) ; if ( NUM_ == addr && m_activegc ) { forceGC ( ) ; addr = m_vmasvc . allocate ( m_nid , size , BOOL_ ) ; } if ( NUM_ != addr ) { ret = new MemChunkHolder < BigDataMemAllocator > ( this , addr , size ) ; ret . setCollector ( m_chunkcollector ) ; if ( autoreclaim ) { m_chunkcollector . register ( ret ) ; } } return ret ; }
protected void drawLabel ( Canvas canvas , String labelText , DefaultRenderer renderer , List < RectF > prevLabelsBounds , int centerX , int centerY , float shortRadius , float longRadius , float currentAngle , float angle , int left , int right , int color , Paint paint , boolean line , boolean display ) { if ( renderer . isShowLabels ( ) || display ) { paint . setColor ( color ) ; double rAngle = Math . toRadians ( NUM_ - ( currentAngle + angle / NUM_ ) ) ; double sinValue = Math . sin ( rAngle ) ; double cosValue = Math . cos ( rAngle ) ; int x1 = Math . round ( centerX + ( float ) ( shortRadius . sinValue ) ) ; int y1 = Math . round ( centerY + ( float ) ( shortRadius . cosValue ) ) ; int x2 = Math . round ( centerX + ( float ) ( longRadius . sinValue ) ) ; int y2 = Math . round ( centerY + ( float ) ( longRadius . cosValue ) ) ; float size = renderer . getLabelsTextSize ( ) ; float extra = Math . max ( size / NUM_ , NUM_ ) ; paint . setTextAlign ( Align . LEFT ) ; if ( x1 > x2 ) { extra = - extra ; paint . setTextAlign ( Align . RIGHT ) ; } float xLabel = x2 + extra ; float yLabel = y2 ; float width = right - xLabel ; if ( x1 > x2 ) { width = xLabel - left ; } labelText = getFitText ( labelText , width , paint ) ; float widthLabel = paint . measureText ( labelText ) ; boolean okBounds = BOOL_ ; while ( ! okBounds && line ) { boolean intersects = BOOL_ ; int length = prevLabelsBounds . size ( ) ; for ( int j = NUM_ ; j < length && ! intersects ; j ++ ) { RectF prevLabelBounds = prevLabelsBounds . get ( j ) ; if ( prevLabelBounds . intersects ( xLabel , yLabel , xLabel + widthLabel , yLabel + size ) ) { intersects = BOOL_ ; yLabel = Math . max ( yLabel , prevLabelBounds . bottom ) ; } } okBounds = ! intersects ; } if ( line ) { y2 = ( int ) ( yLabel - size / NUM_ ) ; canvas . drawLine ( x1 , y1 , x2 , y2 , paint ) ; canvas . drawLine ( x2 , y2 , x2 + extra , y2 , paint ) ; } else { paint . setTextAlign ( Align . CENTER ) ; } canvas . drawText ( labelText , xLabel , yLabel , paint ) ; if ( line ) { prevLabelsBounds . add ( new RectF ( xLabel , yLabel , xLabel + widthLabel , yLabel + size ) ) ; } } }
protected void onPageScrolled ( int position , float offset , int offsetPixels ) { if ( mDecorChildCount > NUM_ ) { final int scrollX = getScrollX ( ) ; int paddingLeft = getPaddingLeft ( ) ; int paddingRight = getPaddingRight ( ) ; final int width = getWidth ( ) ; final int childCount = getChildCount ( ) ; for ( int i = NUM_ ; i < childCount ; i ++ ) { final View child = getChildAt ( i ) ; final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; if ( ! lp . isDecor ) continue ; final int hgrav = lp . gravity & Gravity . HORIZONTAL_GRAVITY_MASK ; int childLeft = NUM_ ; switch ( hgrav ) { default : childLeft = paddingLeft ; break ; case Gravity . LEFT : childLeft = paddingLeft ; paddingLeft += child . getWidth ( ) ; break ; case Gravity . CENTER_HORIZONTAL : childLeft = Math . max ( ( width - child . getMeasuredWidth ( ) ) / NUM_ , paddingLeft ) ; break ; case Gravity . RIGHT : childLeft = width - paddingRight - child . getMeasuredWidth ( ) ; paddingRight += child . getMeasuredWidth ( ) ; break ; } childLeft += scrollX ; final int childOffset = childLeft - child . getLeft ( ) ; if ( childOffset != NUM_ ) { child . offsetLeftAndRight ( childOffset ) ; } } } if ( mOnPageChangeListener != null ) { mOnPageChangeListener . onPageScrolled ( position , offset , offsetPixels ) ; } if ( mInternalPageChangeListener != null ) { mInternalPageChangeListener . onPageScrolled ( position , offset , offsetPixels ) ; } if ( mPageTransformer != null ) { final int scrollX = getScrollX ( ) ; final int childCount = getChildCount ( ) ; for ( int i = NUM_ ; i < childCount ; i ++ ) { final View child = getChildAt ( i ) ; final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; if ( lp . isDecor ) continue ; final float transformPos = ( float ) ( child . getLeft ( ) - scrollX ) / getClientWidth ( ) ; mPageTransformer . transformPage ( child , transformPos ) ; } } mCalledSuper = BOOL_ ; }
public Single < TAccessToken > grantNewAccessToken ( OAuth2Grant < TAccessToken > grant ) { return grantNewAccessToken ( grant , Calendar . getInstance ( ) ) ; }
public static Number floor ( Number a ) { if ( isFloatingPoint ( a ) ) { return Math . floor ( a . doubleValue ( ) ) ; } else { return a . longValue ( ) ; } }
private void readDefsElement ( IXMLElement elem ) throws IOException { for ( IXMLElement child : elem . getChildren ( ) ) { Figure childFigure = readElement ( child ) ; } }
@ Nullable private static ActivityWrapper findLauncherActivityForDevice ( @ NotNull List < ActivityWrapper > launchableActivities , @ NotNull IDevice device ) { if ( device . supportsFeature ( IDevice . HardwareFeature . TV ) ) { return findLeanbackLauncher ( launchableActivities ) ; } return null ; }
public boolean isQueryRunning ( final BoundEntity song ) { synchronized ( mRunningQueries ) { return mRunningQueries . contains ( song ) ; } }
public synchronized void flush ( ) throws IOException { checkNotClosed ( ) ; trimToSize ( ) ; trimToFileCount ( ) ; journalWriter . flush ( ) ; }
private Response < Bitmap > doParse ( NetworkResponse response ) { byte [ ] data = response . data ; BitmapFactory . Options decodeOptions = new BitmapFactory . Options ( ) ; Bitmap bitmap = null ; if ( mMaxWidth == NUM_ && mMaxHeight == NUM_ ) { decodeOptions . inPreferredConfig = mDecodeConfig ; bitmap = BitmapFactory . decodeByteArray ( data , NUM_ , data . length , decodeOptions ) ; } else { decodeOptions . inJustDecodeBounds = BOOL_ ; BitmapFactory . decodeByteArray ( data , NUM_ , data . length , decodeOptions ) ; int actualWidth = decodeOptions . outWidth ; int actualHeight = decodeOptions . outHeight ; int desiredWidth = getResizedDimension ( mMaxWidth , mMaxHeight , actualWidth , actualHeight ) ; int desiredHeight = getResizedDimension ( mMaxHeight , mMaxWidth , actualHeight , actualWidth ) ; decodeOptions . inJustDecodeBounds = BOOL_ ; decodeOptions . inSampleSize = findBestSampleSize ( actualWidth , actualHeight , desiredWidth , desiredHeight ) ; Bitmap tempBitmap = BitmapFactory . decodeByteArray ( data , NUM_ , data . length , decodeOptions ) ; if ( tempBitmap != null && ( tempBitmap . getWidth ( ) > desiredWidth || tempBitmap . getHeight ( ) > desiredHeight ) ) { bitmap = Bitmap . createScaledBitmap ( tempBitmap , desiredWidth , desiredHeight , BOOL_ ) ; tempBitmap . recycle ( ) ; } else { bitmap = tempBitmap ; } } if ( bitmap == null ) { return Response . error ( new ParseError ( response ) ) ; } else { return Response . success ( bitmap , HttpHeaderParser . parseCacheHeaders ( response ) ) ; } }
private Map < String , ExtensionFileFilter > addExtensions ( JFileChooser chooser ) { Map < String , ExtensionFileFilter > filters = new HashMap < String , ExtensionFileFilter > ( ) ; for ( Map . Entry < String , String > entry : exts . entrySet ( ) ) { ExtensionFileFilter filter = new ExtensionFileFilter ( entry . getKey ( ) , entry . getValue ( ) ) ; filters . put ( entry . getKey ( ) , filter ) ; chooser . addChoosableFileFilter ( filter ) ; } return filters ; }
public static String withNodeInfo ( AccessibilityNodeInfo nodeInfo ) { if ( nodeInfo == null ) { return null ; } return String . format ( STR_ , nodeInfo . getText ( ) , nodeInfo . getContentDescription ( ) ) ; }
static int allParametersAndArgumentsMatchWithDefaultParams ( Parameter [ ] params , ClassNode [ ] args ) { int dist = NUM_ ; ClassNode ptype = null ; for ( int i = NUM_ , j = NUM_ ; i < params . length ; i ++ ) { Parameter param = params [ i ] ; ClassNode paramType = param . getType ( ) ; ClassNode arg = j >= args . length ? null : args [ j ] ; if ( arg == null || ! isAssignableTo ( arg , paramType ) ) { if ( ! param . hasInitialExpression ( ) && ( ptype == null || ! ptype . equals ( paramType ) ) ) { return - NUM_ ; } ptype = null ; } else { j ++ ; if ( ! paramType . equals ( arg ) ) dist += getDistance ( arg , paramType ) ; if ( param . hasInitialExpression ( ) ) { ptype = arg ; } else { ptype = null ; } } } return dist ; }
private void expect ( char expectedSymbol ) throws ParseException { if ( ! accept ( expectedSymbol ) ) throw new ParseException ( STR_ + expectedSymbol + STR_ + ( char ) data [ index ] + STR_ , index ) ; }
public static byte [ ] stringToUtf8Bytes ( String string ) { int len = string . length ( ) ; byte [ ] bytes = new byte [ len . NUM_ ] ; int outAt = NUM_ ; for ( int i = NUM_ ; i < len ; i ++ ) { char c = string . charAt ( i ) ; if ( ( c != NUM_ ) && ( c < x80 ) ) { bytes [ outAt ] = ( byte ) c ; outAt ++ ; } else if ( c < x800 ) { bytes [ outAt ] = ( byte ) ( ( ( c > > NUM_ ) & x1f ) | xc0 ) ; bytes [ outAt + NUM_ ] = ( byte ) ( ( c & x3f ) | x80 ) ; outAt += NUM_ ; } else { bytes [ outAt ] = ( byte ) ( ( ( c > > NUM_ ) & x0f ) | xe0 ) ; bytes [ outAt + NUM_ ] = ( byte ) ( ( ( c > > NUM_ ) & x3f ) | x80 ) ; bytes [ outAt + NUM_ ] = ( byte ) ( ( c & x3f ) | x80 ) ; outAt += NUM_ ; } } byte [ ] result = new byte [ outAt ] ; System . arraycopy ( bytes , NUM_ , result , NUM_ , outAt ) ; return result ; }
public abstract void initParameters ( int [ ] aCircuitData , IRedstoneCircuitBlock aRedstoneCircuitBlock ) ;
public Contentlet executeSafeFirst ( ) { List < Contentlet > result = executeSafe ( ) ; if ( result . size ( ) > NUM_ ) { return result . get ( NUM_ ) ; } return null ; }
public void clear ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { for ( Node < E > f = first ; f != null ; ) { f . item = null ; Node < E > n = f . next ; f . prev = null ; f . next = null ; f = n ; } first = last = null ; count = NUM_ ; notFull . signalAll ( ) ; } finally { lock . unlock ( ) ; } }
public void clear ( ) { oredCriteria . clear ( ) ; orderByClause = null ; distinct = BOOL_ ; }
private static int determineConsecutiveDigitCount ( CharSequence msg , int startpos ) { int count = NUM_ ; int len = msg . length ( ) ; int idx = startpos ; if ( idx < len ) { char ch = msg . charAt ( idx ) ; while ( isDigit ( ch ) && idx < len ) { count ++ ; idx ++ ; if ( idx < len ) { ch = msg . charAt ( idx ) ; } } } return count ; }
public static boolean isFileExist ( String filePath , FileType fileType , boolean performFileCheck ) throws IOException { filePath = filePath . replace ( STR_ , STR_ ) ; switch ( fileType ) { case HDFS : case VIEWFS : Path path = new Path ( filePath ) ; FileSystem fs = path . getFileSystem ( configuration ) ; if ( performFileCheck ) { return fs . exists ( path ) && fs . isFile ( path ) ; } else { return fs . exists ( path ) ; } case LOCAL : default : File defaultFile = new File ( filePath ) ; if ( performFileCheck ) { return defaultFile . exists ( ) && defaultFile . isFile ( ) ; } else { return defaultFile . exists ( ) ; } } }
private DoubleFactor pointwiseProduct ( List < DoubleFactor > factors ) { if ( factors . isEmpty ( ) ) { DoubleFactor factor = new DoubleFactor ( ) ; factor . addEntry ( new Assignment ( ) , NUM_ , NUM_ ) ; return factor ; } else if ( factors . size ( ) == NUM_ ) { return factors . get ( NUM_ ) ; } DoubleFactor factor = factors . get ( NUM_ ) ; factors . remove ( NUM_ ) ; for ( DoubleFactor f : factors ) { DoubleFactor tempFactor = new DoubleFactor ( ) ; Set < String > sharedVars = new HashSet < String > ( f . getVariables ( ) ) ; sharedVars . retainAll ( factor . getVariables ( ) ) ; for ( Assignment a : f . getValues ( ) ) { double [ ] entry = f . getEntry ( a ) ; double prob = entry [ NUM_ ] ; double util = entry [ NUM_ ] ; for ( Assignment b : factor . getValues ( ) ) { if ( b . consistentWith ( a , sharedVars ) ) { double [ ] entry2 = factor . getEntry ( b ) ; double prob2 = entry2 [ NUM_ ] ; double util2 = entry2 [ NUM_ ] ; double product = prob . prob2 ; double sum = util + util2 ; tempFactor . addEntry ( new Assignment ( a , b ) , product , sum ) ; } } } factor = tempFactor ; } return factor ; }
public ClassPath ( ) { String syscp = System . getProperty ( STR_ ) ; String envcp = System . getProperty ( STR_ ) ; if ( envcp == null ) envcp = STR_ ; String cp = syscp + File . pathSeparator + envcp ; init ( cp ) ; }
protected static boolean uninstallAddOnExtension ( AddOn addOn , Extension extension , AddOnUninstallationProgressCallback callback ) { boolean uninstalledWithoutErrors = BOOL_ ; if ( extension . isEnabled ( ) ) { String extUiName = extension . getUIName ( ) ; if ( extension . canUnload ( ) ) { logger . debug ( STR_ + extension . getName ( ) ) ; try { extension . unload ( ) ; ExtensionFactory . unloadAddOnExtension ( extension ) ; } catch ( Exception e ) { logger . error ( STR_ + extension . getName ( ) + STR_ + addOn . getId ( ) + STR_ , e ) ; uninstalledWithoutErrors = BOOL_ ; } } else { logger . debug ( STR_ + extension . getName ( ) ) ; uninstalledWithoutErrors = BOOL_ ; } callback . extensionRemoved ( extUiName ) ; } addOn . removeLoadedExtension ( extension ) ; return uninstalledWithoutErrors ; }
private static String pickRandomStatsFields ( String [ ] fieldNames ) { String fieldName ; do { fieldName = fieldNames [ TestUtil . nextInt ( random ( ) , NUM_ , fieldNames . length - NUM_ ) ] ; } while ( fieldName . endsWith ( STR_ ) || fieldName . endsWith ( STR_ ) ) ; return fieldName ; }
@ Override public synchronized void doDeleteChild ( BaseSolrResource endpoint , String childId ) { String key = getIgnoreCase ( ) ? childId . toLowerCase ( Locale . ROOT ) : childId ; if ( ! managedWords . contains ( key ) ) throw new SolrException ( ErrorCode . NOT_FOUND , String . format ( Locale . ROOT , STR_ , childId , getResourceId ( ) ) ) ; managedWords . remove ( key ) ; storeManagedData ( managedWords ) ; log . info ( STR_ , key ) ; }
public static final String writeTime ( double seconds , final String timeformat , final char separator ) { if ( seconds < NUM_ ) { if ( seconds == UNDEFINED_TIME ) return STR_ ; return STR_ + writeTime ( Math . abs ( seconds ) , timeformat , separator ) ; } int day = ( int ) ( seconds / MIDNIGHT ) ; seconds %= MIDNIGHT ; if ( TIMEFORMAT_EEESSSS . equals ( timeformat ) ) return Week . getDayName ( day ) + STR_ + Long . toString ( ( long ) ( seconds ) ) ; double s = seconds ; long h = ( long ) ( s / NUM_ ) ; s = s % NUM_ ; int m = ( int ) ( s / NUM_ ) ; s = s % NUM_ ; StringBuilder str = new StringBuilder ( NUM_ ) ; if ( h < timeElements . length ) { str . append ( timeElements [ ( int ) h ] ) ; } else { str . append ( Long . toString ( h ) ) ; } str . append ( separator ) ; str . append ( timeElements [ m ] ) ; if ( TIMEFORMAT_EEEHHMM . equals ( timeformat ) ) { return Week . getDayName ( day ) + STR_ + str . toString ( ) ; } if ( TIMEFORMAT_EEEHHMMSS . equals ( timeformat ) ) { str . append ( separator ) ; str . append ( timeElements [ ( int ) s ] ) ; return Week . getDayName ( day ) + STR_ + str . toString ( ) ; } if ( TIMEFORMAT_HHMMSSDOTSS . equals ( timeformat ) ) { str . append ( separator ) ; if ( s < NUM_ ) { str . append ( STR_ ) ; } str . append ( s ) ; return Week . getDayName ( day ) + STR_ + str . toString ( ) ; } throw new IllegalArgumentException ( STR_ + timeformat + STR_ ) ; }
public DExportPrivateKeyType ( JFrame parent ) { super ( parent , Dialog . ModalityType . DOCUMENT_MODAL ) ; setTitle ( res . getString ( STR_ ) ) ; initComponents ( ) ; }
public static IPoint [ ] copyOf ( IPoint [ ] original , int newLength ) { IPoint [ ] copy = new IPoint [ newLength ] ; System . arraycopy ( original , NUM_ , copy , NUM_ , Math . min ( original . length , newLength ) ) ; return copy ; }
public void writeFooter ( ) { ps . println ( STR_ ) ; ps . println ( STR_ ) ; ps . println ( STR_ ) ; }
protected void saveObject ( Object object ) { if ( m_FileChooser == null ) { createFileChooser ( ) ; } int returnVal = m_FileChooser . showSaveDialog ( this ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { File sFile = m_FileChooser . getSelectedFile ( ) ; try { ObjectOutputStream oo = new ObjectOutputStream ( new BufferedOutputStream ( new FileOutputStream ( sFile ) ) ) ; oo . writeObject ( object ) ; oo . close ( ) ; } catch ( Exception ex ) { JOptionPane . showMessageDialog ( this , STR_ + sFile . getName ( ) + STR_ + ex . getMessage ( ) , STR_ , JOptionPane . ERROR_MESSAGE ) ; } } }
@ Override public void write ( DataOutput out ) throws IOException { if ( USE_HADOOP_TEXT ) Text . writeString ( out , term ) ; else out . writeUTF ( term ) ; WritableUtils . writeVInt ( out , splitno ) ; WritableUtils . writeVInt ( out , flushno ) ; }
public static String stripNonDigits ( String str ) { StringBuffer result = new StringBuffer ( str . length ( ) ) ; for ( char candidate : str . toCharArray ( ) ) { if ( Character . isDigit ( candidate ) ) { result . append ( candidate ) ; } } return result . toString ( ) ; }
protected Collection < CommunicationSummaryStatistics > doGetCommunicationSummaryStatistics ( String tenantId , Criteria criteria ) { String index = client . getIndex ( tenantId ) ; Map < String , CommunicationSummaryStatistics > stats = new HashMap < > ( ) ; if ( ! criteria . transactionWide ( ) ) { Criteria txnWideCriteria = criteria . deriveTransactionWide ( ) ; buildCommunicationSummaryStatistics ( stats , index , txnWideCriteria , BOOL_ ) ; } buildCommunicationSummaryStatistics ( stats , index , criteria , BOOL_ ) ; return stats . values ( ) ; }
public void removeContent ( String variableId ) { if ( ! paused ) { curState . removeFromState ( variableId ) ; update ( ) ; } else { log . info ( STR_ + variableId ) ; } }
public void addCommandListener ( ActionListener l ) { if ( globalCommandListeners == null ) { globalCommandListeners = new EventDispatcher ( ) ; } globalCommandListeners . addListener ( l ) ; }
public static void completeBackgroundTasks ( long timeoutMillis ) { boolean fifoEmpty = BOOL_ ; boolean asyncThreadsCompleted = BOOL_ ; long absTimeout = System . currentTimeMillis ( ) + timeoutMillis ; while ( System . currentTimeMillis ( ) < absTimeout ) { synchronized ( fifo ) { fifoEmpty = fifo . size ( ) == NUM_ ; } synchronized ( JGoogleAnalyticsTracker . class ) { asyncThreadsCompleted = asyncThreadsRunning == NUM_ ; } if ( fifoEmpty && asyncThreadsCompleted ) break ; try { Thread . sleep ( NUM_ ) ; } catch ( InterruptedException e ) { break ; } } }
private synchronized void writeObject ( java . io . ObjectOutputStream s ) throws IOException { if ( actions == null ) getActions ( ) ; s . defaultWriteObject ( ) ; }
public static final byte [ ] decode ( BufferedReader reader ) throws IOException , Base64DecodingException { byte [ ] retBytes = null ; UnsyncByteArrayOutputStream baos = null ; try { baos = new UnsyncByteArrayOutputStream ( ) ; String line ; while ( null != ( line = reader . readLine ( ) ) ) { byte [ ] bytes = decode ( line ) ; baos . write ( bytes ) ; } retBytes = baos . toByteArray ( ) ; } finally { baos . close ( ) ; } return retBytes ; }
public boolean isDefinedInEnv ( ) { if ( envVars == null || paramNames . length == NUM_ ) { return BOOL_ ; } for ( String var : envVars ) { if ( System . getenv ( var ) == null ) { return BOOL_ ; } } return BOOL_ ; }
public void apply ( Animator animator , float currValue , float endValue , float velocity ) { apply ( animator , currValue , endValue , velocity , Math . abs ( endValue - currValue ) ) ; }
public void addNotice ( ParserNotice notice ) { notices . add ( notice ) ; }
@ Override public String toString ( ) { int len = sessionId . length ; StringBuffer s = new StringBuffer ( NUM_ + NUM_ . len ) ; s . append ( STR_ ) ; for ( int i = NUM_ ; i < len ; i ++ ) { s . append ( x0ff & sessionId [ i ] ) ; if ( i != ( len - NUM_ ) ) s . append ( STR_ ) ; } s . append ( STR_ ) ; return s . toString ( ) ; }
public EventBinder < E > after ( String name ) { after . add ( name ) ; return this ; }
public Point2D forward ( Point2D llp , Point2D pt ) { return forward ( llp . getY ( ) , llp . getX ( ) , pt , BOOL_ ) ; }
public JobCreateRequest createJobCreateRequest ( String namespaceCd , String jobName ) { List < Parameter > parameters = new ArrayList < > ( ) ; Parameter parameter = new Parameter ( AbstractServiceTest . ATTRIBUTE_NAME_2_MIXED_CASE , AbstractServiceTest . ATTRIBUTE_VALUE_2 ) ; parameters . add ( parameter ) ; parameter = new Parameter ( STR_ , null ) ; parameters . add ( parameter ) ; return createJobCreateRequest ( namespaceCd , jobName , parameters ) ; }
private void load ( ) throws RepositoryException , RDFParseException , IOException { final RepositoryConnection conn = repository . getConnection ( ) ; String ttlString = MODEL_TTL ; InputStream stringInput = new ByteArrayInputStream ( ttlString . getBytes ( ) ) ; conn . add ( stringInput , STR_ , RDFFormat . TURTLE , new Resource [ ] { } ) ; ttlString = BUCKET_TTL ; stringInput = new ByteArrayInputStream ( ttlString . getBytes ( ) ) ; conn . add ( stringInput , STR_ , RDFFormat . TURTLE , new Resource [ ] { } ) ; conn . commit ( ) ; conn . close ( ) ; }
public boolean isTaxIncluded ( ) { if ( m_M_PriceList_ID == NUM_ ) { m_M_PriceList_ID = DB . getSQLValue ( get_TrxName ( ) , STR_ , getC_Order_ID ( ) ) ; } MPriceList pl = MPriceList . get ( getCtx ( ) , m_M_PriceList_ID , get_TrxName ( ) ) ; return pl . isTaxIncluded ( ) ; }
protected WebResource createRequest ( String uriPath ) { ensureInitialization ( ) ; return clientRequestHelper . createRequest ( client , serviceURI , URI . create ( uriPath ) ) ; }
public static void init ( Context context ) { if ( cameraManager == null ) { cameraManager = new CameraManager ( context ) ; } }
public void nextTable ( ) throws SQLException { if ( tables . hasNext ( ) ) { currentTable = tables . next ( ) ; openRows ( ) ; } }
public DDistinguishedNameChooser ( JFrame parent , String title , X500Name distinguishedName , boolean editable ) { super ( parent , title , Dialog . ModalityType . DOCUMENT_MODAL ) ; this . distinguishedName = distinguishedName ; this . editable = editable ; initComponents ( ) ; }
public static boolean deleteFile ( String filePathAndName ) { if ( ( filePathAndName == null ) || filePathAndName . isEmpty ( ) ) { return BOOL_ ; } boolean isSuccessfulDelete = BOOL_ ; try { File fileToDelete = new File ( filePathAndName ) ; isSuccessfulDelete = fileToDelete . delete ( ) ; } catch ( Exception e ) { logger . debug ( e . toString ( ) + System . lineSeparator ( ) + StackTrace . getStringFromStackTrace ( e ) ) ; isSuccessfulDelete = BOOL_ ; } return isSuccessfulDelete ; }
public TungstenPropertiesIO ( File path ) { this ( new JavaFileIO ( ) , new FilePath ( path . getAbsolutePath ( ) ) ) ; }
@ Override public int compareTo ( final TimeInstant rhs ) { return Integer . compare ( this . time , rhs . time ) ; }
private boolean writeToCharacteristic ( BluetoothGattCharacteristic charc , byte [ ] data ) { charc . setValue ( data ) ; boolean result = mGattClient . writeCharacteristic ( charc ) ; if ( result ) { Log . d ( TAG , STR_ + charc . getUuid ( ) + STR_ + Arrays . toString ( data ) ) ; } else { Log . e ( TAG , STR_ + charc . getUuid ( ) + STR_ + Arrays . toString ( data ) ) ; } return result ; }
public static void composeThroughMask ( Raster src , WritableRaster dst , Raster sel ) { int x = src . getMinX ( ) ; int y = src . getMinY ( ) ; int w = src . getWidth ( ) ; int h = src . getHeight ( ) ; int srcRGB [ ] = null ; int selRGB [ ] = null ; int dstRGB [ ] = null ; for ( int i = NUM_ ; i < h ; i ++ ) { srcRGB = src . getPixels ( x , y , w , NUM_ , srcRGB ) ; selRGB = sel . getPixels ( x , y , w , NUM_ , selRGB ) ; dstRGB = dst . getPixels ( x , y , w , NUM_ , dstRGB ) ; int k = x ; for ( int j = NUM_ ; j < w ; j ++ ) { int sr = srcRGB [ k ] ; int dir = dstRGB [ k ] ; int sg = srcRGB [ k + NUM_ ] ; int dig = dstRGB [ k + NUM_ ] ; int sb = srcRGB [ k + NUM_ ] ; int dib = dstRGB [ k + NUM_ ] ; int sa = srcRGB [ k + NUM_ ] ; int dia = dstRGB [ k + NUM_ ] ; float a = selRGB [ k + NUM_ ] / NUM_ ; float ac = NUM_ - a ; dstRGB [ k ] = ( int ) ( a . sr + ac . dir ) ; dstRGB [ k + NUM_ ] = ( int ) ( a . sg + ac . dig ) ; dstRGB [ k + NUM_ ] = ( int ) ( a . sb + ac . dib ) ; dstRGB [ k + NUM_ ] = ( int ) ( a . sa + ac . dia ) ; k += NUM_ ; } dst . setPixels ( x , y , w , NUM_ , dstRGB ) ; y ++ ; } }
public char skipTo ( char to ) { char c ; int index = this . myIndex ; do { c = next ( ) ; if ( c == NUM_ ) { this . myIndex = index ; return c ; } } while ( c != to ) ; back ( ) ; return c ; }
public int checkVersionSize ( final SoftwareVersion version ) { URL imageUrl = getImageURL ( version ) ; HttpURLConnection urlConnection = invokeRequest ( imageUrl ) ; return urlConnection . getContentLength ( ) ; }
private static DateTimeFormatter createFormatterForStyle ( String style ) { if ( style == null || style . length ( ) != NUM_ ) { throw new IllegalArgumentException ( STR_ + style ) ; } int dateStyle = selectStyle ( style . charAt ( NUM_ ) ) ; int timeStyle = selectStyle ( style . charAt ( NUM_ ) ) ; if ( dateStyle == NONE && timeStyle == NONE ) { throw new IllegalArgumentException ( STR_ ) ; } return createFormatterForStyleIndex ( dateStyle , timeStyle ) ; }
public boolean ackNextChunkId ( String id ) { if ( state . isTerminated ( ) ) return BOOL_ ; else if ( id . equals ( chunkid ) ) { return BOOL_ ; } else { if ( ! allowOtherChunksInBetween ( id ) ) { if ( state . isDone ( ) ) { if ( ! isTerminated ( ) ) terminate ( ) ; return BOOL_ ; } else { throw new PngjInputException ( STR_ + id + STR_ + chunkid + STR_ ) ; } } else return BOOL_ ; } }
void submit ( ProcessAndDisplayImageTask task ) { initExecutorsIfNeed ( ) ; taskExecutorForCachedImages . execute ( task ) ; }
public void testPosPosSameLength ( ) { byte aBytes [ ] = { - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ } ; byte bBytes [ ] = { - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int bSign = NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . or ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
private Response < Bitmap > doParse ( NetworkResponse response ) { byte [ ] data = response . data ; BitmapFactory . Options decodeOptions = new BitmapFactory . Options ( ) ; Bitmap bitmap = null ; if ( mMaxWidth == NUM_ && mMaxHeight == NUM_ ) { decodeOptions . inPreferredConfig = mDecodeConfig ; bitmap = BitmapFactory . decodeByteArray ( data , NUM_ , data . length , decodeOptions ) ; } else { decodeOptions . inJustDecodeBounds = BOOL_ ; BitmapFactory . decodeByteArray ( data , NUM_ , data . length , decodeOptions ) ; int actualWidth = decodeOptions . outWidth ; int actualHeight = decodeOptions . outHeight ; int desiredWidth = getResizedDimension ( mMaxWidth , mMaxHeight , actualWidth , actualHeight , mScaleType ) ; int desiredHeight = getResizedDimension ( mMaxHeight , mMaxWidth , actualHeight , actualWidth , mScaleType ) ; decodeOptions . inJustDecodeBounds = BOOL_ ; decodeOptions . inSampleSize = findBestSampleSize ( actualWidth , actualHeight , desiredWidth , desiredHeight ) ; Bitmap tempBitmap = BitmapFactory . decodeByteArray ( data , NUM_ , data . length , decodeOptions ) ; if ( tempBitmap != null && ( tempBitmap . getWidth ( ) > desiredWidth || tempBitmap . getHeight ( ) > desiredHeight ) ) { bitmap = Bitmap . createScaledBitmap ( tempBitmap , desiredWidth , desiredHeight , BOOL_ ) ; tempBitmap . recycle ( ) ; } else { bitmap = tempBitmap ; } } if ( bitmap == null ) { return Response . error ( new ParseError ( response ) ) ; } else { return Response . success ( bitmap , HttpHeaderParser . parseCacheHeaders ( response ) ) ; } }
@ Override public void pause ( boolean toPause ) { isPaused = toPause ; }
public static String replaceAll ( String original , String oldSubstring , String newSubstring ) { return replace ( original , oldSubstring , newSubstring , BOOL_ ) ; }
public long add ( final AddOp add ) throws Exception { return add ( add , UUID . randomUUID ( ) ) ; }
protected boolean isSmall ( ) { return this . scale . this . textSizeInMeters < this . pixelSizeInMeters ; }
public byte [ ] decompress ( DataInput is ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; try { while ( BOOL_ ) { byte b = is . readByte ( ) ; if ( b == - NUM_ ) break ; baos . write ( b ) ; } } catch ( EOFException ex ) { } catch ( IOException ex ) { throw new RuntimeException ( ex ) ; } return decompress ( baos . toByteArray ( ) ) ; }
public int borrowSpareRegister ( int category ) { int result = spareRegisterBase + borrowedSpareRegisters ; borrowedSpareRegisters += category ; registerCount = Math . max ( registerCount , result + category ) ; return result ; }
public void True ( boolean expression , Object errorMessage ) { if ( ! expression ) { throw new IllegalArgumentException ( String . valueOf ( errorMessage ) ) ; } }
private void processFields ( final Object component , final Context context , final ContextDestroyer contextDestroyer ) { Class < ? > componentClass = component . getClass ( ) ; while ( componentClass != null && ! componentClass . equals ( Object . class ) ) { final Field [ ] fields = ClassReflection . getDeclaredFields ( componentClass ) ; if ( fields != null && fields . length > NUM_ ) { processFields ( component , fields , context , contextDestroyer ) ; } componentClass = componentClass . getSuperclass ( ) ; } }
public static String replaceAll ( String input , String regularExpression , String replacement ) { return input . replaceAll ( regularExpression , replacement ) ; }
void requestNotificationUpdate ( ) { if ( mCurrentNotificationGroupIndex != NOTIFICATION_OFF ) { RhythmNotificationService . showNotification ( mContext , mNotificationId ) ; } }
public static int countLowerCase ( final String text ) { int count = NUM_ ; for ( final char chr : text . toCharArray ( ) ) { if ( Character . isLowerCase ( chr ) ) { count ++ ; } } return count ; }
public void assignService ( String serviceName , Map attributes ) throws IdRepoException , SSOException { IdServices idServices = IdServicesFactory . getDataStoreServices ( ) ; Set OCs = getServiceOCs ( token , serviceName ) ; SchemaType stype ; Map tMap = new HashMap ( ) ; tMap . put ( serviceName , OCs ) ; Set assignedServices = idServices . getAssignedServices ( token , type , name , tMap , orgName , univDN ) ; if ( assignedServices . contains ( serviceName ) ) { Object args [ ] = { serviceName , type . getName ( ) } ; throw new IdRepoException ( IdRepoBundle . BUNDLE_NAME , IdRepoErrorCode . SERVICE_ALREADY_ASSIGNED , args ) ; } try { ServiceSchemaManager ssm = new ServiceSchemaManager ( serviceName , token ) ; ServiceSchema ss = ssm . getSchema ( type . getName ( ) ) ; if ( ss != null ) { Set cosPriority = ( attributes != null ) ? ( Set ) attributes . remove ( COS_PRIORITY ) : null ; attributes = ss . validateAndInheritDefaults ( attributes , orgName , BOOL_ ) ; if ( cosPriority != null ) { attributes . put ( COS_PRIORITY , cosPriority ) ; } attributes = AMCommonUtils . removeEmptyValues ( attributes ) ; stype = ss . getServiceType ( ) ; } else { ss = ssm . getSchema ( SchemaType . DYNAMIC ) ; if ( ss == null ) { Object args [ ] = { serviceName } ; throw new IdRepoException ( IdRepoBundle . BUNDLE_NAME , IdRepoErrorCode . UNABLE_GET_SERVICE_SCHEMA , args ) ; } if ( attributes == null ) { try { attributes = getServiceConfig ( token , serviceName , SchemaType . DYNAMIC ) ; } catch ( SMSException smsex ) { Object args [ ] = { serviceName , type . getName ( ) } ; throw new IdRepoException ( IdRepoBundle . BUNDLE_NAME , STR_ , args ) ; } } else { attributes = ss . validateAndInheritDefaults ( attributes , orgName , BOOL_ ) ; } attributes = AMCommonUtils . removeEmptyValues ( attributes ) ; stype = SchemaType . DYNAMIC ; } attributes = AMCrypt . encryptPasswords ( attributes , ss ) ; } catch ( SMSException smse ) { Object [ ] args = { serviceName } ; throw new IdRepoException ( IdRepoBundle . BUNDLE_NAME , IdRepoErrorCode . SERVICE_NOT_ASSIGNED , args ) ; } attributes . put ( STR_ , OCs ) ; idServices . assignService ( token , type , name , serviceName , stype , attributes , orgName , univDN ) ; }
@ Override protected void createButtonsForButtonBar ( final Composite parent ) { for ( final Iterator it = buttonDescriptions . iterator ( ) ; it . hasNext ( ) ; ) { final ButtonDescription buttonDescription = ( ButtonDescription ) it . next ( ) ; createButton ( parent , buttonDescription . buttonId , buttonDescription . buttonLabel , buttonDescription . isDefault ) ; } if ( includeDefaultButtons ) { super . createButtonsForButtonBar ( parent ) ; } hookAfterButtonsCreated ( ) ; }
private boolean checkFileModifications ( ) throws Exception { long destFileTime = destFile . lastModified ( ) ; if ( sourceFile . lastModified ( ) > destFileTime ) { logger . debug ( STR_ ) ; return BOOL_ ; } Properties metadata = restoreFileModifications ( metaDataFile ) ; if ( metadata == null ) { return BOOL_ ; } SAXParserFactory parserFactory = SAXParserFactory . newInstance ( ) ; SAXParser parser = parserFactory . newSAXParser ( ) ; TimeCheckerHandler handler = new TimeCheckerHandler ( baseDir , metadata ) ; parser . parse ( sourceFile , handler ) ; return handler . isModified ( ) ; }
public static Number mul ( Number a , Number b ) { if ( isFloatingPoint ( a ) || isFloatingPoint ( b ) ) { return a . doubleValue ( ) . b . doubleValue ( ) ; } else { return a . longValue ( ) . b . longValue ( ) ; } }
private final int findWidestAxis ( ) { int widest = NUM_ ; double width = ( maxLimit [ NUM_ ] - minLimit [ NUM_ ] ) . getAxisWeightHint ( NUM_ ) ; if ( Double . isNaN ( width ) ) { width = NUM_ ; } for ( int i = NUM_ ; i < dimensions ; i ++ ) { double nwidth = ( maxLimit [ i ] - minLimit [ i ] ) . getAxisWeightHint ( i ) ; if ( Double . isNaN ( nwidth ) ) { nwidth = NUM_ ; } if ( nwidth > width ) { widest = i ; width = nwidth ; } } return widest ; }
public void addSortKey ( int column , Comparator < String > comparator ) { sortKeys . add ( column ) ; sortComparators . add ( comparator ) ; }
public static String tagSwap ( String content , Map < String , String > tagSwapMap ) { for ( Map . Entry < String , String > entry : tagSwapMap . entrySet ( ) ) { content = content . replace ( entry . getKey ( ) , entry . getValue ( ) ) ; } return content ; }
public static RunStats delegateGetBucketForIntegers ( int buckets ) throws Exception { Long startTime = System . currentTimeMillis ( ) ; PrimaryIndexBucketGeneratorImpl ibg = new PrimaryIndexBucketGeneratorImpl ( FieldDataType . INTEGER , buckets ) ; PrimaryIndexBucketLocatorImpl locator = new PrimaryIndexBucketLocatorImpl ( null , null , null , ibg . generateBuckets ( ) , null , null , null , null , null ) ; logger . debug ( STR_ ) ; HashMap < Long , List < Object > > hm = new HashMap < > ( ) ; SummaryStatistics stats = new SummaryStatistics ( ) ; for ( int inputInt = - NUM_ ; inputInt < NUM_ ; inputInt ++ ) { Long bucketId = locator . getBucket ( inputInt , FieldDataType . INTEGER ) ; calculate ( hm , stats , bucketId , inputInt ) ; } Long runTime = System . currentTimeMillis ( ) - startTime ; RunStats runStats = new RunStats ( STR_ , FieldDataType . INTEGER , runTime , stats , hm ) ; logger . debug ( runStats . toString ( ) ) ; return runStats ; }
public static long countSubstr ( final String value , final String subStr , final boolean caseSensitive , boolean allowOverlapping ) { validate ( value , NULL_STRING_PREDICATE , NULL_STRING_MSG_SUPPLIER ) ; return countSubstr ( caseSensitive ? value : value . toLowerCase ( ) , caseSensitive ? subStr : subStr . toLowerCase ( ) , allowOverlapping , NUM_ ) ; }
private void dropIndex ( String indexName ) throws OracleException { PreparedStatement stmt = null ; if ( indexName == null ) throw SODAUtils . makeException ( SODAMessage . EX_ARG_CANNOT_BE_NULL , STR_ ) ; indexName = CollectionDescriptor . stringToIdentifier ( indexName ) ; String sqltext = dropIndexDDL ( indexName ) ; try { metrics . startTiming ( ) ; stmt = conn . prepareStatement ( sqltext ) ; stmt . execute ( ) ; if ( OracleLog . isLoggingEnabled ( ) ) log . info ( STR_ + indexName ) ; stmt . close ( ) ; stmt = null ; metrics . recordDDL ( ) ; } catch ( SQLException e ) { int errcode = e . getErrorCode ( ) ; if ( ( errcode == ORA_SQL_OBJECT_NOT_EXISTS ) || ( errcode == ORA_SQL_INDEX_NOT_EXISTS ) ) { if ( OracleLog . isLoggingEnabled ( ) ) log . warning ( e . toString ( ) ) ; } else { if ( OracleLog . isLoggingEnabled ( ) ) log . warning ( e . toString ( ) ) ; throw SODAUtils . makeExceptionWithSQLText ( e , sqltext ) ; } } finally { for ( String message : SODAUtils . closeCursor ( stmt , null ) ) { if ( OracleLog . isLoggingEnabled ( ) ) log . severe ( message ) ; } } }
void unlaunch ( ) { if ( server != null ) { server . die ( ) ; server = null ; } frame . setVisible ( BOOL_ ) ; client = null ; System . gc ( ) ; System . runFinalization ( ) ; }
private boolean isOutsideDocElem ( ) { return ( null == m_docFrag ) && m_elemStack . size ( ) == NUM_ && ( null == m_currentNode || m_currentNode . getNodeType ( ) == Node . DOCUMENT_NODE ) ; }
public int postFiles ( File [ ] files , int startIndexInArgs , OutputStream out , String type ) { reset ( ) ; int filesPosted = NUM_ ; for ( File srcFile : files ) { if ( srcFile . isDirectory ( ) && srcFile . canRead ( ) ) { filesPosted += postDirectory ( srcFile , out , type ) ; } else if ( srcFile . isFile ( ) && srcFile . canRead ( ) ) { filesPosted += postFiles ( new File [ ] { srcFile } , out , type ) ; } else { File parent = srcFile . getParentFile ( ) ; if ( parent == null ) parent = new File ( STR_ ) ; String fileGlob = srcFile . getName ( ) ; GlobFileFilter ff = new GlobFileFilter ( fileGlob , BOOL_ ) ; File [ ] fileList = parent . listFiles ( ff ) ; if ( fileList == null || fileList . length == NUM_ ) { warn ( STR_ + srcFile ) ; continue ; } filesPosted += postFiles ( fileList , out , type ) ; } } return filesPosted ; }
private static String unicode2html ( final String text , final boolean amp , final boolean html ) { if ( text == null ) return null ; final StringBuilder sb = new StringBuilder ( text . length ( ) . NUM_ / NUM_ ) ; int textpos = NUM_ ; String r ; char c ; while ( textpos < text . length ( ) ) { c = text . charAt ( textpos ) ; if ( amp && c == AMP_UNICODE ) { sb . append ( AMP_HTML ) ; textpos ++ ; continue ; } if ( ( r = UNICODE2HTML4XML . get ( c ) ) != null ) { sb . append ( r ) ; textpos ++ ; continue ; } if ( html && ( r = UNICODE2HTML4HTML . get ( c ) ) != null ) { sb . append ( r ) ; textpos ++ ; continue ; } sb . append ( c ) ; textpos ++ ; } return sb . toString ( ) ; }
public String addPlaylist ( String playlistName ) { ContentValues mInserts = new ContentValues ( ) ; mInserts . put ( MediaStore . Audio . Playlists . NAME , playlistName ) ; mInserts . put ( MediaStore . Audio . Playlists . DATE_ADDED , System . currentTimeMillis ( ) ) ; mInserts . put ( MediaStore . Audio . Playlists . DATE_MODIFIED , System . currentTimeMillis ( ) ) ; Uri uri = mContentResolver . insert ( MediaStore . Audio . Playlists . EXTERNAL_CONTENT_URI , mInserts ) ; if ( uri == null ) { return null ; } else { String ref = PREFIX_PLAYLIST + getPlaylistUniqueName ( Long . toString ( ContentUris . parseId ( uri ) ) ) ; Playlist pl = new Playlist ( ref ) ; pl . setName ( playlistName ) ; pl . setIsLoaded ( BOOL_ ) ; mPlaylists . put ( ref , pl ) ; mCallback . playlistUpdated ( pl ) ; return ref ; } }
public static JSONArray readJSONArray ( final JSONObject jsonObject , final String key , final boolean required , final boolean notNull ) throws JSONException { if ( required ) { return jsonObject . getJSONArray ( key ) ; } if ( notNull && jsonObject . isNull ( key ) ) { throw new JSONException ( String . format ( Locale . US , NULL_VALUE_FORMAT_OBJECT , key ) ) ; } JSONArray value = null ; if ( ! jsonObject . isNull ( key ) ) { value = jsonObject . getJSONArray ( key ) ; } return value ; }
default int copyTo ( @ NotNull byte [ ] bytes ) throws BufferUnderflowException { int len = ( int ) Math . min ( bytes . length , readRemaining ( ) ) ; for ( int i = NUM_ ; i < len ; i ++ ) bytes [ i ] = readByte ( start ( ) + i ) ; return len ; }
private void addCharacters ( final Map < String , RPObject > characters ) { for ( Entry < String , RPObject > character : characters . entrySet ( ) ) { JButton button = createCharacterButton ( character . getKey ( ) , character . getValue ( ) ) ; characterPanel . add ( button ) ; } }
public void runTest ( ) throws Throwable { Document doc ; NodeList genderList ; Node genderNode ; CharacterData entText ; EntityReference entReference ; doc = ( Document ) load ( STR_ , BOOL_ ) ; genderList = doc . getElementsByTagName ( STR_ ) ; genderNode = genderList . item ( NUM_ ) ; entReference = doc . createEntityReference ( STR_ ) ; assertNotNull ( STR_ , entReference ) ; entText = ( CharacterData ) entReference . getFirstChild ( ) ; assertNotNull ( STR_ , entText ) ; { boolean success = BOOL_ ; try { entText . insertData ( NUM_ , STR_ ) ; } catch ( DOMException ex ) { success = ( ex . code == DOMException . NO_MODIFICATION_ALLOWED_ERR ) ; } assertTrue ( STR_ , success ) ; } }
@ Override public void unbindView ( VH holder ) { }
public static boolean isPresent ( Rule rule ) { if ( rule == null ) { return BOOL_ ; } return ( ! isNotSet ( rule . getMinScaleDenominator ( ) ) || ! isNotSet ( rule . getMaxScaleDenominator ( ) ) ) ; }
public long startcode ( ) { return Long . parseLong ( fields [ NUM_ ] ) ; }
public static void consumeProcessOutput ( Process self ) { consumeProcessOutput ( self , ( OutputStream ) null , ( OutputStream ) null ) ; }
public static void registerDefaultResolvers ( ) { List < KeyResolver > keyResolverList = new ArrayList < KeyResolver > ( ) ; keyResolverList . add ( new KeyResolver ( new RSAKeyValueResolver ( ) ) ) ; keyResolverList . add ( new KeyResolver ( new DSAKeyValueResolver ( ) ) ) ; keyResolverList . add ( new KeyResolver ( new X509CertificateResolver ( ) ) ) ; keyResolverList . add ( new KeyResolver ( new X509SKIResolver ( ) ) ) ; keyResolverList . add ( new KeyResolver ( new RetrievalMethodResolver ( ) ) ) ; keyResolverList . add ( new KeyResolver ( new X509SubjectNameResolver ( ) ) ) ; keyResolverList . add ( new KeyResolver ( new X509IssuerSerialResolver ( ) ) ) ; keyResolverList . add ( new KeyResolver ( new DEREncodedKeyValueResolver ( ) ) ) ; keyResolverList . add ( new KeyResolver ( new KeyInfoReferenceResolver ( ) ) ) ; keyResolverList . add ( new KeyResolver ( new X509DigestResolver ( ) ) ) ; resolverVector . addAll ( keyResolverList ) ; }
public static final void delete ( String fileName ) { File file = new File ( fileName ) ; if ( ! file . delete ( ) ) { log . error ( STR_ , file ) ; } File metadataFile = new File ( fileName + METADATA_SUFFIX ) ; if ( ! metadataFile . delete ( ) ) { log . error ( STR_ , metadataFile ) ; } File directory = file . getParentFile ( ) ; if ( directory . isDirectory ( ) ) { directory . delete ( ) ; } }
protected final void refreshLoadingViewsSize ( ) { final int maximumPullScroll = ( int ) ( getMaximumPullScroll ( ) . NUM_ ) ; int pLeft = getPaddingLeft ( ) ; int pTop = getPaddingTop ( ) ; int pRight = getPaddingRight ( ) ; int pBottom = getPaddingBottom ( ) ; switch ( getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setWidth ( maximumPullScroll ) ; pLeft = - maximumPullScroll ; } else { pLeft = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setWidth ( maximumPullScroll ) ; pRight = - maximumPullScroll ; } else { pRight = NUM_ ; } break ; case VERTICAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setHeight ( maximumPullScroll ) ; pTop = - maximumPullScroll ; } else { pTop = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setHeight ( maximumPullScroll ) ; pBottom = - maximumPullScroll ; } else { pBottom = NUM_ ; } break ; } if ( DEBUG ) { Log . d ( LOG_TAG , String . format ( STR_ , pLeft , pTop , pRight , pBottom ) ) ; } setPadding ( pLeft , pTop , pRight , pBottom ) ; }
public static boolean isExtension ( String filename , String extension ) { if ( filename == null ) { return BOOL_ ; } if ( extension == null || extension . length ( ) == NUM_ ) { return indexOfExtension ( filename ) == - NUM_ ; } String fileExt = getExtension ( filename ) ; return fileExt . equals ( extension ) ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return BOOL_ ; } if ( ! ( obj instanceof TimePeriodValuesCollection ) ) { return BOOL_ ; } TimePeriodValuesCollection that = ( TimePeriodValuesCollection ) obj ; if ( this . domainIsPointsInTime != that . domainIsPointsInTime ) { return BOOL_ ; } if ( this . xPosition != that . xPosition ) { return BOOL_ ; } if ( ! ObjectUtilities . equal ( this . data , that . data ) ) { return BOOL_ ; } return BOOL_ ; }
public void print ( JTextPane pane ) { setDocument ( pane ) ; printDialog ( ) ; }
private boolean ensureScrollWheelAdjusted ( ) { int deltaY = mInitialScrollOffset - mCurrentScrollOffset ; if ( deltaY != NUM_ ) { mPreviousScrollerY = NUM_ ; if ( Math . abs ( deltaY ) > mSelectorElementHeight / NUM_ ) { deltaY += ( deltaY > NUM_ ) ? - mSelectorElementHeight : mSelectorElementHeight ; } mAdjustScroller . startScroll ( NUM_ , NUM_ , NUM_ , deltaY , SELECTOR_ADJUSTMENT_DURATION_MILLIS ) ; invalidate ( ) ; return BOOL_ ; } return BOOL_ ; }
private String sortXml ( final String originalXml ) { String errorMsg = STR_ ; xmlProcessingInstructionParser . scanForIgnoredSections ( originalXml ) ; String xml = xmlProcessingInstructionParser . replaceIgnoredSections ( ) ; insertXmlInXmlProcessor ( xml , errorMsg ) ; xmlProcessor . sortXml ( ) ; try ( ByteArrayOutputStream sortedXmlOutputStream = xmlProcessor . getSortedXml ( ) ) { String sortedXml = sortedXmlOutputStream . toString ( encoding ) ; if ( xmlProcessingInstructionParser . existsIgnoredSections ( ) ) { sortedXml = xmlProcessingInstructionParser . revertIgnoredSections ( sortedXml ) ; } return sortedXml ; } catch ( IOException e ) { throw new FailureException ( errorMsg + xml , e ) ; } }
void waitForDictionaryLoading ( ) { while ( mUpdatingDictionary ) { try { Thread . sleep ( NUM_ ) ; } catch ( InterruptedException e ) { } } }
private void publishData ( String path , byte [ ] data ) { try { if ( data != null && data . length > NUM_ ) { ByteArrayInputStream bii = new ByteArrayInputStream ( data ) ; ObjectInputStream ois = new ObjectInputStream ( bii ) ; Object dataObj = ois . readObject ( ) ; ZooKeeperDataWrapper wrapper = ( ZooKeeperDataWrapper ) ( dataObj ) ; JetstreamMessage tm = ( JetstreamMessage ) wrapper . getOrginalData ( ) ; String trackerKey = createKey ( path , wrapper ) ; m_changeTracker . put ( trackerKey , wrapper . getTimestamp ( ) ) ; try { LOGGER . warn ( STR_ + path + STR_ + trackerKey + STR_ + wrapper . getTimestamp ( ) ) ; m_transportListener . postMessage ( tm , m_queueStats ) ; } catch ( Throwable mse ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( STR_ ) ; buf . append ( mse . getLocalizedMessage ( ) ) ; LOGGER . error ( STR_ + path + buf . toString ( ) , mse ) ; } m_totalMsgsRcvd . increment ( ) ; m_msgsRcvdPerSec . increment ( ) ; } } catch ( ClassNotFoundException e ) { LOGGER . error ( STR_ + path , e ) ; } catch ( IOException e ) { LOGGER . error ( STR_ + path , e ) ; } }
static public long nextAddr ( Random r , WormAddressManager am ) { if ( r . nextInt ( NUM_ ) < NUM_ ) return NUM_ ; return nextNonZeroAddr ( r , am ) ; }
public void undoableEditHappened ( mxUndoableEdit undoableEdit ) { if ( enabled ) { if ( undoableEdit . getTransparent ( ) ) { } else if ( ! undoableEdit . getUndoable ( ) ) { notUndoableEditHappened ( ) ; } else if ( collection ) { collected . add ( undoableEdit ) ; fireEvent ( new mxEventObject ( mxEvent . ADD , STR_ , undoableEdit ) ) ; } else { collected . add ( undoableEdit ) ; addEventList ( ) ; fireEvent ( new mxEventObject ( mxEvent . ADD , STR_ , undoableEdit ) ) ; } } }
public File ( File dir , String name ) { this ( dir == null ? null : dir . getPath ( ) , name ) ; }
public void removeDragListener ( DragListener l ) { mListeners . remove ( l ) ; }
private HighTideValues findHighTide ( JSONObject responseObject ) throws JSONException , ParseException { JSONArray predictions = ( JSONArray ) responseObject . get ( STR_ ) ; JSONObject lastPrediction = null , firstHighTide = null , secondHighTide = null , lowTide = null ; boolean firstTideDone = BOOL_ ; for ( int i = NUM_ ; i < predictions . length ( ) ; i ++ ) { JSONObject prediction = ( JSONObject ) predictions . get ( i ) ; if ( lastPrediction == null ) { lastPrediction = prediction ; continue ; } if ( isTideIncreasing ( lastPrediction , prediction ) ) { if ( ! firstTideDone ) { firstHighTide = prediction ; } else { secondHighTide = prediction ; } } else { if ( ! firstTideDone && firstHighTide != null ) { firstTideDone = BOOL_ ; } else if ( secondHighTide != null ) { break ; } if ( firstTideDone ) { lowTide = prediction ; } } lastPrediction = prediction ; } DateFormat dateFormat = new SimpleDateFormat ( STR_ ) ; return new HighTideValues ( AlexaDateUtil . getFormattedTime ( dateFormat . parse ( firstHighTide . getString ( STR_ ) ) ) , getFormattedHeight ( firstHighTide . getString ( STR_ ) ) , AlexaDateUtil . getFormattedTime ( dateFormat . parse ( lowTide . getString ( STR_ ) ) ) , getFormattedHeight ( lowTide . getString ( STR_ ) ) , AlexaDateUtil . getFormattedTime ( dateFormat . parse ( secondHighTide . getString ( STR_ ) ) ) , getFormattedHeight ( secondHighTide . getString ( STR_ ) ) ) ; }
public static boolean isIpAddress ( String ipAddress ) { Matcher m1 = validIPV4Pattern . matcher ( ipAddress ) ; if ( m1 . matches ( ) ) { return BOOL_ ; } Matcher m2 = validIPV6Pattern . matcher ( ipAddress ) ; return m2 . matches ( ) ; }
@ Override public synchronized void removeTrainingSetListener ( TrainingSetListener tsl ) { m_trainingListeners . removeElement ( tsl ) ; }
public void renameAttributeValue ( Attribute att , String val , String name ) { int v = att . indexOfValue ( val ) ; if ( v == - NUM_ ) { throw new IllegalArgumentException ( val + STR_ ) ; } renameAttributeValue ( att . index ( ) , v , name ) ; }
private static void s_uacmean ( SparseBlock a , double [ ] c , int m , int n , KahanObject kbuff , Mean kmean , int rl , int ru ) { Arrays . fill ( c , n , n . NUM_ , ru - rl ) ; if ( a . isContiguous ( ) ) { countDisAgg ( a . values ( rl ) , c , a . indexes ( rl ) , a . pos ( rl ) , n , ( int ) a . size ( rl , ru ) ) ; } else { for ( int i = rl ; i < ru ; i ++ ) { if ( ! a . isEmpty ( i ) ) countDisAgg ( a . values ( i ) , c , a . indexes ( i ) , a . pos ( i ) , n , a . size ( i ) ) ; } } if ( a . isContiguous ( ) ) { meanAgg ( a . values ( rl ) , c , a . indexes ( rl ) , a . pos ( rl ) , ( int ) a . size ( rl , ru ) , n , kbuff , kmean ) ; } else { for ( int i = rl ; i < ru ; i ++ ) { if ( ! a . isEmpty ( i ) ) meanAgg ( a . values ( i ) , c , a . indexes ( i ) , a . pos ( i ) , a . size ( i ) , n , kbuff , kmean ) ; } } }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
public boolean isPdfAttachment ( ) { if ( getPO ( ) == null ) return BOOL_ ; return m_po . isPdfAttachment ( ) ; }
private int nameToIndex ( String parameterName ) throws SQLException { parameterMetadata . readMetadataFromDbIfRequired ( ) ; for ( int i = NUM_ ; i <= parameterMetadata . getParameterCount ( ) ; i ++ ) { String name = parameterMetadata . getName ( i ) ; if ( name != null && name . equalsIgnoreCase ( parameterName ) ) { return i ; } } throw new SQLException ( STR_ + parameterName ) ; }
public void sort ( Comparator < ? super SubRange > comparator ) { Collections . sort ( data , comparator ) ; }
private void add ( TreeMap < String , Object > map , String key , Object value ) { Vector < Object > v = getList ( map , key ) ; if ( v == null ) { v = new Vector < > ( ) ; synchronized ( map ) { map . put ( key , v ) ; } } if ( ! v . contains ( value ) ) { v . add ( value ) ; } }
public void test_singleResourceLocking_serialized_waitsFor_highConcurrency_taskTimeout ( ) throws Exception { final Properties properties = new Properties ( ) ; final int nthreads = NUM_ ; final int ntasks = NUM_ ; properties . setProperty ( TestOptions . CORE_POOL_SIZE , STR_ + nthreads ) ; properties . setProperty ( TestOptions . NTASKS , STR_ + ntasks ) ; properties . setProperty ( TestOptions . NRESOURCES , STR_ ) ; properties . setProperty ( TestOptions . MIN_LOCKS , STR_ ) ; properties . setProperty ( TestOptions . MAX_LOCKS , STR_ ) ; properties . setProperty ( TestOptions . TASK_TIMEOUT , STR_ ) ; properties . setProperty ( TestOptions . PREDECLARE_LOCKS , STR_ ) ; properties . setProperty ( TestOptions . SORT_LOCK_REQUESTS , STR_ ) ; final Result result = doComparisonTest ( properties ) ; assertEquals ( STR_ , NUM_ , Integer . parseInt ( result . get ( STR_ ) ) ) ; assertEquals ( STR_ , NUM_ , Integer . parseInt ( result . get ( STR_ ) ) ) ; final int ncancel = Integer . parseInt ( result . get ( STR_ ) ) ; assertTrue ( STR_ , ncancel > NUM_ ) ; }
private WeekFields ( DayOfWeek firstDayOfWeek , int minimalDaysInFirstWeek ) { Objects . requireNonNull ( firstDayOfWeek , STR_ ) ; if ( minimalDaysInFirstWeek < NUM_ || minimalDaysInFirstWeek > NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } this . firstDayOfWeek = firstDayOfWeek ; this . minimalDays = minimalDaysInFirstWeek ; }
private ResultPointsAndTransitions transitionsBetween ( ResultPoint from , ResultPoint to ) { int fromX = ( int ) from . getX ( ) ; int fromY = ( int ) from . getY ( ) ; int toX = ( int ) to . getX ( ) ; int toY = ( int ) to . getY ( ) ; boolean steep = Math . abs ( toY - fromY ) > Math . abs ( toX - fromX ) ; if ( steep ) { int temp = fromX ; fromX = fromY ; fromY = temp ; temp = toX ; toX = toY ; toY = temp ; } int dx = Math . abs ( toX - fromX ) ; int dy = Math . abs ( toY - fromY ) ; int error = - dx > > NUM_ ; int ystep = fromY < toY ? NUM_ : - NUM_ ; int xstep = fromX < toX ? NUM_ : - NUM_ ; int transitions = NUM_ ; boolean inBlack = image . get ( steep ? fromY : fromX , steep ? fromX : fromY ) ; for ( int x = fromX , y = fromY ; x != toX ; x += xstep ) { boolean isBlack = image . get ( steep ? y : x , steep ? x : y ) ; if ( isBlack != inBlack ) { transitions ++ ; inBlack = isBlack ; } error += dy ; if ( error > NUM_ ) { if ( y == toY ) { break ; } y += ystep ; error -= dx ; } } return new ResultPointsAndTransitions ( from , to , transitions ) ; }
private void placeGroups ( ) { startRow ( ) ; placeChild ( mCloseButton , Gravity . END ) ; placeGroup ( mMainGroup ) ; int customGroupWidth = NUM_ ; if ( mCustomGroup != null ) { updateCustomGroupForRow ( ROW_MAIN ) ; customGroupWidth = getWidthWithMargins ( mCustomGroup ) ; } int buttonGroupWidth = NUM_ ; if ( mButtonGroup != null ) { updateButtonGroupForRow ( ROW_MAIN ) ; buttonGroupWidth = getWidthWithMargins ( mButtonGroup ) ; } boolean customGroupOnMainRow = customGroupWidth <= availableWidth ( ) ; boolean buttonGroupOnMainRow = customGroupWidth + buttonGroupWidth <= availableWidth ( ) ; if ( mCustomGroup != null ) { if ( customGroupOnMainRow ) { mCustomGroup . gravity = ( mButtonGroup != null && buttonGroupOnMainRow ) ? Gravity . START : Gravity . END ; } else { startRow ( ) ; updateCustomGroupForRow ( ROW_OTHER ) ; } placeGroup ( mCustomGroup ) ; } if ( mButtonGroup != null ) { if ( ! buttonGroupOnMainRow ) { startRow ( ) ; updateButtonGroupForRow ( ROW_OTHER ) ; if ( mCustomGroup == null && mMessageTextView != null ) { LayoutParams lp = ( LayoutParams ) mMessageTextView . getLayoutParams ( ) ; int messageBottom = lp . top + mMessageTextView . getMeasuredHeight ( ) ; mTop = Math . max ( mTop , messageBottom + NUM_ . mMargin ) ; } } placeGroup ( mButtonGroup ) ; if ( mCustomButton != null && ! buttonGroupOnMainRow ) { LayoutParams primaryButtonLP = ( LayoutParams ) mPrimaryButton . getLayoutParams ( ) ; LayoutParams customButtonLP = ( LayoutParams ) mCustomButton . getLayoutParams ( ) ; LayoutParams messageLP = ( LayoutParams ) mMessageView . getLayoutParams ( ) ; if ( customButtonLP . start >= messageLP . start ) { customButtonLP . start = messageLP . start ; } else { customButtonLP . start = mMargin ; } if ( ! mButtonGroup . isStacked ) { customButtonLP . top = primaryButtonLP . top + ( mPrimaryButton . getMeasuredHeight ( ) - mCustomButton . getMeasuredHeight ( ) ) / NUM_ ; } } } startRow ( ) ; if ( buttonGroupOnMainRow ) { int layoutHeight = mBottom ; for ( int i = NUM_ ; i < getChildCount ( ) ; i ++ ) { View child = getChildAt ( i ) ; int extraSpace = layoutHeight - child . getMeasuredHeight ( ) ; LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; lp . top = extraSpace / NUM_ ; } } }
static HeapDoublesSketch copy ( DoublesSketch sketch ) { HeapDoublesSketch qsCopy ; qsCopy = HeapDoublesSketch . newInstance ( sketch . getK ( ) ) ; qsCopy . n_ = sketch . getN ( ) ; qsCopy . minValue_ = sketch . getMinValue ( ) ; qsCopy . maxValue_ = sketch . getMaxValue ( ) ; qsCopy . combinedBufferItemCapacity_ = sketch . getCombinedBufferItemCapacity ( ) ; qsCopy . baseBufferCount_ = sketch . getBaseBufferCount ( ) ; qsCopy . bitPattern_ = sketch . getBitPattern ( ) ; double [ ] combBuf = sketch . getCombinedBuffer ( ) ; qsCopy . combinedBuffer_ = Arrays . copyOf ( combBuf , combBuf . length ) ; return qsCopy ; }
public List < VerificationOK > verify ( List < VerificationOK > result ) throws IOException , GeneralSecurityException { if ( result == null ) result = new ArrayList < > ( ) ; while ( pkcs7 != null ) { result . addAll ( verifySignature ( ) ) ; } return result ; }
public SchemaField ( String name , FieldType type ) { this ( name , type , type . properties , null ) ; }
private void createDaySlot ( ArrayList < MAssignmentSlot > list , MAssignmentSlot ma ) { Timestamp start = ma . getStartTime ( ) ; GregorianCalendar calStart = new GregorianCalendar ( ) ; calStart . setTime ( start ) ; calStart . set ( Calendar . HOUR_OF_DAY , NUM_ ) ; calStart . set ( Calendar . MINUTE , NUM_ ) ; calStart . set ( Calendar . SECOND , NUM_ ) ; calStart . set ( Calendar . MILLISECOND , NUM_ ) ; Timestamp end = ma . getEndTime ( ) ; GregorianCalendar calEnd = new GregorianCalendar ( ) ; calEnd . setTime ( end ) ; calEnd . set ( Calendar . HOUR_OF_DAY , NUM_ ) ; calEnd . set ( Calendar . MINUTE , NUM_ ) ; calEnd . set ( Calendar . SECOND , NUM_ ) ; calEnd . set ( Calendar . MILLISECOND , NUM_ ) ; while ( calStart . before ( calEnd ) ) { Timestamp xStart = new Timestamp ( calStart . getTimeInMillis ( ) ) ; calStart . add ( Calendar . DAY_OF_YEAR , NUM_ ) ; Timestamp xEnd = new Timestamp ( calStart . getTimeInMillis ( ) ) ; MAssignmentSlot myMa = new MAssignmentSlot ( xStart , xEnd , ma . getName ( ) , ma . getDescription ( ) , ma . getStatus ( ) ) ; list . add ( myMa ) ; } }
public boolean isAttachment ( String fileName ) { return fileName . startsWith ( ENTRY_ATTACHMENT ) ; }
void subtractFlakes ( int quantity ) { for ( int i = NUM_ ; i < quantity ; ++ i ) { int index = numFlakes - i - NUM_ ; flakes . remove ( index ) ; } setNumFlakes ( numFlakes - quantity ) ; }
public Optimized ( int n , int s , int t , Iterator < EdgeInfo > edges ) { super ( n , s , t ) ; queue = new int [ n ] ; QUEUE_SIZE = n ; capacity = new int [ n ] [ n ] ; flow = new int [ n ] [ n ] ; previous = new int [ n ] ; visited = new int [ n ] ; while ( edges . hasNext ( ) ) { EdgeInfo ei = edges . next ( ) ; capacity [ ei . start ] [ ei . end ] = ei . capacity ; } }
public void put ( Buffer buffer ) { if ( buffer . getLength ( ) <= NUM_ ) { return ; } byte [ ] currentRtpPacketData = ( ( byte [ ] ) buffer . getData ( ) ) ; H264RtpHeaders h264RtpHeaders = new H264RtpHeaders ( currentRtpPacketData ) ; if ( h264RtpHeaders . getFUI_F ( ) ) { return ; } if ( reassembledData == null ) { timeStamp = buffer . getTimeStamp ( ) ; format = buffer . getFormat ( ) ; seqNumber = buffer . getSequenceNumber ( ) ; reassembledDataNALHeader = h264RtpHeaders . getNALHeader ( ) ; reassembledData = new byte [ JavaPacketizer . H264_MAX_RTP_PKTS ] [ H264_FRAME_PACKET_SIZE ] ; reassembledDataSize = new int [ JavaPacketizer . H264_MAX_RTP_PKTS ] ; reassembledDataHasStart = BOOL_ ; reassembledDataHasEnd = BOOL_ ; } int posSeq = ( int ) ( buffer . getSequenceNumber ( ) & VIDEO_DECODER_MAX_PAYLOADS_CHUNKS_MASK ) ; int payloadStartPosition = h264RtpHeaders . getHeaderSize ( ) ; int payloadLength = buffer . getLength ( ) - h264RtpHeaders . getHeaderSize ( ) ; if ( h264RtpHeaders . getFUI_TYPE ( ) == H264RtpHeaders . AVC_NALTYPE_FUA ) { reassembledDataHasStart |= ( h264RtpHeaders . getFUH_S ( ) ) ; reassembledDataHasEnd |= ( h264RtpHeaders . getFUH_E ( ) ) ; reassembledDataPosSeqStart = ( ( h264RtpHeaders . getFUH_S ( ) ) ? posSeq : reassembledDataPosSeqStart ) ; reassembledDataPosSeqEnd = ( ( h264RtpHeaders . getFUH_E ( ) ) ? posSeq : reassembledDataPosSeqEnd ) ; } reassembledDataSize [ posSeq ] = payloadLength ; reassembledDataFullSize += payloadLength ; System . arraycopy ( currentRtpPacketData , payloadStartPosition , reassembledData [ posSeq ] , NUM_ , payloadLength ) ; videoOrientation = buffer . getVideoOrientation ( ) ; }
public static Map < String , Object > badExpireEvenProcessor ( DispatchContext dctx , Map < String , ? extends Object > context ) { GenericValue creditCard = ( GenericValue ) context . get ( STR_ ) ; String expireDate = creditCard . getString ( STR_ ) ; String lastNumberStr = expireDate . substring ( expireDate . length ( ) - NUM_ ) ; int lastNumber = Integer . parseInt ( lastNumberStr ) ; if ( lastNumber % NUM_ == NUM_ ) { return alwaysBadExpireProcessor ( dctx , context ) ; } else { return alwaysApproveProcessor ( dctx , context ) ; } }
public ExpressionType negate ( ) { if ( isNegated ( ) ) { return new ExpressionType ( typeString . replace ( SUFFIX_NEGATED , STR_ ) ) ; } else { return new ExpressionType ( typeString + SUFFIX_NEGATED ) ; } }
protected void updatePathGreyness ( TreePath ancestor ) { boolean value = isPathCheckBox ( ancestor ) ; Object ancestorNode = ancestor . getLastPathComponent ( ) ; if ( ! isPathCheckBox ( ancestor ) ) { addToCheckBoxPathsSet ( ancestor ) ; return ; } }
protected ArrayList < String > useTokenizer ( String s ) throws Exception { String [ ] tokens ; ArrayList < String > result ; int i ; tokens = Tokenizer . tokenize ( m_Tokenizer , new String [ ] { s } ) ; result = new ArrayList < String > ( ) ; for ( i = NUM_ ; i < tokens . length ; i ++ ) { result . add ( tokens [ i ] ) ; } return result ; }
public DOMStorableInputOutputFormat ( DOMFactory factory , String description , String fileExtension , String mimeType ) { this . factory = factory ; this . description = description ; this . fileExtension = fileExtension ; this . mimeType = mimeType ; try { this . dataFlavor = new DataFlavor ( mimeType ) ; } catch ( ClassNotFoundException ex ) { InternalError error = new InternalError ( STR_ + mimeType ) ; error . initCause ( ex ) ; throw error ; } }
default TypeParameterDeclaration asTypeParameter ( ) { throw new UnsupportedOperationException ( String . format ( STR_ , this ) ) ; }
public void addColumn ( String header ) { if ( getModel ( ) instanceof DefaultTableModel ) { DefaultTableModel model = ( DefaultTableModel ) getModel ( ) ; model . addColumn ( Util . cleanAmp ( header ) ) ; } else throw new IllegalArgumentException ( STR_ ) ; }
public void addMoveScript ( String pathname ) { _moveScripts . add ( pathname ) ; setDirtyAndFirePropertyChange ( STR_ , pathname , null ) ; }
private void checkAndAddResizeHandler ( ) { Component parent = getParent ( ) ; if ( parent != null && resizable && resizeHandler == null ) { resizeHandler = new ResizeHandler ( ) ; parent . addComponentListener ( resizeHandler ) ; } }
static public void useXalanXPathSupport ( ) throws Exception { Class . forName ( STR_ ) ; Class c = Class . forName ( STR_ ) ; synchronized ( STATIC_LOCK ) { xpathSupportClass = c ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( STR_ ) ; } }
public int numberOfOwningShards ( ) { int count = NUM_ ; for ( ShardRouting shardEntry : this ) { if ( shardEntry . state ( ) != ShardRoutingState . RELOCATING ) { count ++ ; } } return count ; }
public String convertBinaryToHexString ( byte [ ] bytes ) { StringBuilder builder = new StringBuilder ( bytes . length . NUM_ ) ; for ( byte b : bytes ) { int highBitsInt = ( b > > NUM_ ) & xF ; int lowBitsInt = b & xF ; builder . append ( HEX_CHARS [ highBitsInt ] ) ; builder . append ( HEX_CHARS [ lowBitsInt ] ) ; } return builder . toString ( ) ; }
protected static void writeHeader ( XMLWriter writer ) { XmlWriterUtil . writeCommentLineBreak ( writer ) ; XmlWriterUtil . writeComment ( writer , STR_ ) ; DateFormat dateFormat = new SimpleDateFormat ( STR_ ) ; XmlWriterUtil . writeComment ( writer , STR_ + dateFormat . format ( new Date ( System . currentTimeMillis ( ) ) ) ) ; XmlWriterUtil . writeComment ( writer , STR_ ) ; XmlWriterUtil . writeComment ( writer , STR_ ) ; XmlWriterUtil . writeCommentLineBreak ( writer ) ; XmlWriterUtil . writeLineBreak ( writer ) ; }
protected void close ( ) { try { if ( to != null ) to . close ( ) ; if ( from != null ) from . close ( ) ; } catch ( IOException e ) { } if ( process != null ) process . destroy ( ) ; process = null ; to = null ; from = null ; errorLogger = null ; }
public void clearParseIssues ( ) { parseIssues . clear ( ) ; }
public int validate ( GraphicsConfiguration gc ) { int returnCode = VolatileImage . IMAGE_OK ; boolean lostSurfaceTmp = lostSurface ; lostSurface = BOOL_ ; if ( isAccelerationEnabled ( ) ) { if ( ! isConfigValid ( gc ) ) { returnCode = VolatileImage . IMAGE_INCOMPATIBLE ; } else if ( sdAccel == null ) { sdAccel = initAcceleratedSurface ( ) ; if ( sdAccel != null ) { sdCurrent = sdAccel ; sdBackup = null ; returnCode = VolatileImage . IMAGE_RESTORED ; } else { sdCurrent = getBackupSurface ( ) ; } } else if ( sdAccel . isSurfaceLost ( ) ) { try { restoreAcceleratedSurface ( ) ; sdCurrent = sdAccel ; sdAccel . setSurfaceLost ( BOOL_ ) ; sdBackup = null ; returnCode = VolatileImage . IMAGE_RESTORED ; } catch ( sun . java2d . InvalidPipeException e ) { sdCurrent = getBackupSurface ( ) ; } } else if ( lostSurfaceTmp ) { returnCode = VolatileImage . IMAGE_RESTORED ; } } else if ( sdAccel != null ) { sdCurrent = getBackupSurface ( ) ; sdAccel = null ; returnCode = VolatileImage . IMAGE_RESTORED ; } if ( ( returnCode != VolatileImage . IMAGE_INCOMPATIBLE ) && ( sdCurrent != sdPrevious ) ) { sdPrevious = sdCurrent ; returnCode = VolatileImage . IMAGE_RESTORED ; } if ( returnCode == VolatileImage . IMAGE_RESTORED ) { initContents ( ) ; } return returnCode ; }
private static String unsignedToString ( final int value ) { if ( value >= NUM_ ) { return Integer . toString ( value ) ; } else { return Long . toString ( ( ( long ) value ) & x00000000FFFFFFFFL ) ; } }
public ConnectionManager ( ConnectionManagerConfiguration configuration ) throws Exception { _configuration = configuration ; if ( _configuration == null ) { throw new ConnectionManagerException ( STR_ ) ; } }
@ SuppressWarnings ( STR_ ) public Pids ( ) { Arrays . sort ( PIDs , pidComparator ) ; }
public void handleHeaderColumnReleased ( Point p ) { TABLE . setPressedColumnIndex ( - NUM_ ) ; JTableHeader th = TABLE . getTableHeader ( ) ; int col = th . columnAtPoint ( p ) ; if ( col != - NUM_ ) th . repaint ( th . getHeaderRect ( col ) ) ; }
public void createDevices ( @ NotNull List < Device > devices ) { if ( ! initIfNecessary ( ) ) { return ; } for ( Device device : devices ) { String deviceIdBase = device . getId ( ) ; String deviceNameBase = device . getDisplayName ( ) ; int i = NUM_ ; while ( isUserDevice ( device ) ) { String id = String . format ( Locale . getDefault ( ) , STR_ , deviceIdBase , i ) ; String name = String . format ( Locale . getDefault ( ) , STR_ , deviceNameBase , i ) ; device = cloneDeviceWithNewIdAndName ( device , id , name ) ; } ourDeviceManager . addUserDevice ( device ) ; } ourDeviceManager . saveUserDevices ( ) ; }
public WritableRaster createCompatibleWritableRaster ( int w , int h ) { if ( w <= NUM_ || h <= NUM_ ) { throw new RasterFormatException ( STR_ + ( ( w <= NUM_ ) ? STR_ : STR_ ) ) ; } SampleModel sm = sampleModel . createCompatibleSampleModel ( w , h ) ; return new ShortBandedRaster ( sm , new Point ( NUM_ , NUM_ ) ) ; }
public void write ( PrintWriter writer ) { for ( int i = NUM_ ; i < count ; i ++ ) { writer . println ( keys [ i ] + STR_ + values [ i ] ) ; } writer . flush ( ) ; }
@ WorkerThread public synchronized int stopRecord ( ) { if ( mRecorder == null ) { mState = STATE_IDLE ; return - NUM_ ; } int length = - NUM_ ; switch ( mState ) { case STATE_RECORDING : try { Thread . sleep ( STOP_AUDIO_RECORD_DELAY_MILLIS ) ; mRecorder . stop ( ) ; length = ( int ) ( ( System . currentTimeMillis ( ) - mSampleStart ) / NUM_ ) ; } catch ( RuntimeException e ) { Log . w ( TAG , STR_ + e . getMessage ( ) ) ; } catch ( InterruptedException e ) { Log . w ( TAG , STR_ + e . getMessage ( ) ) ; } case STATE_PREPARED : case STATE_IDLE : default : try { mRecorder . reset ( ) ; } catch ( RuntimeException e ) { Log . w ( TAG , STR_ + e . getMessage ( ) ) ; } mRecorder . release ( ) ; mRecorder = null ; mState = STATE_IDLE ; break ; } return length ; }
public XMLParser ( final Class classToBeBound , final String [ ] schemas ) throws XMLException { try { JAXBContext jc = JAXBContext . newInstance ( classToBeBound ) ; marshaller = jc . createMarshaller ( ) ; marshaller . setSchema ( XMLSchemaUtils . createSchema ( schemas ) ) ; unmarshaller = jc . createUnmarshaller ( ) ; unmarshaller . setSchema ( XMLSchemaUtils . createSchema ( schemas ) ) ; } catch ( JAXBException e ) { throw new XMLException ( STR_ + classToBeBound , e ) ; } }
private void abort ( Throwable t ) { throwable = t ; }
public static UserImpl signup ( Map < String , String [ ] > parameters , String ip , List < SignupError > errors ) { log . entering ( STR_ , STR_ ) ; String email = getFirst ( parameters , STR_ ) ; String displayName = getFirst ( parameters , STR_ ) ; String photoUrl = getFirst ( parameters , STR_ ) ; String password = getFirst ( parameters , STR_ ) ; String confirm = getFirst ( parameters , STR_ ) ; if ( Strings . isNullOrEmpty ( email ) || ! EmailValidator . isValid ( email ) ) { errors . add ( SignupError . INVALID_EMAIL ) ; } if ( Strings . isNullOrEmpty ( displayName ) ) { errors . add ( SignupError . EMPTY_DISPLAY_NAME ) ; } if ( Strings . isNullOrEmpty ( password ) ) { errors . add ( SignupError . INVALID_PASSWORD ) ; } else if ( ! password . equals ( confirm ) ) { errors . add ( SignupError . CONFIRM_MISMATCH ) ; } else if ( password . length ( ) < NUM_ ) { errors . add ( SignupError . INVALID_PASSWORD ) ; } PersistenceManager pm = pmf . getPersistenceManager ( ) ; try { UserRecord record = findUserByEmail ( pm , email ) ; if ( record != null ) { errors . add ( SignupError . EMAIL_REGISTERED ) ; } else if ( errors . isEmpty ( ) ) { log . fine ( STR_ + email ) ; record = new UserRecord ( ) ; record . setEmail ( email ) ; record . setDisplayName ( displayName ) ; record . setPhotoUrl ( photoUrl ) ; record . setPassword ( password ) ; record . setTosAccepted ( BOOL_ ) ; record . setLastBigChangeTime ( System . currentTimeMillis ( ) ) ; pm . makePersistent ( record ) ; UserImpl user = createUserByRecord ( record ) ; return user ; } } finally { pm . close ( ) ; } log . exiting ( STR_ , STR_ ) ; return null ; }
@ Override public final String readNullTerminatedAsciiString ( ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; byte b ; while ( BOOL_ ) { b = readByte ( ) ; if ( b == NUM_ ) { break ; } baos . write ( b ) ; } byte [ ] buf = baos . toByteArray ( ) ; char [ ] chrBuf = new char [ buf . length ] ; for ( int x = NUM_ ; x < buf . length ; x ++ ) { chrBuf [ x ] = ( char ) buf [ x ] ; } return String . valueOf ( chrBuf ) ; }
private void thresholdBlur ( Kernel kernel , int [ ] inPixels , int [ ] outPixels , int width , int height , boolean alpha ) { float [ ] matrix = kernel . getKernelData ( null ) ; int cols = kernel . getWidth ( ) ; int cols2 = cols / NUM_ ; for ( int y = NUM_ ; y < height ; y ++ ) { int ioffset = y . width ; int outIndex = y ; for ( int x = NUM_ ; x < width ; x ++ ) { float r = NUM_ , g = NUM_ , b = NUM_ , a = NUM_ ; int moffset = cols2 ; int rgb1 = inPixels [ ioffset + x ] ; int a1 = ( rgb1 > > NUM_ ) & xff ; int r1 = ( rgb1 > > NUM_ ) & xff ; int g1 = ( rgb1 > > NUM_ ) & xff ; int b1 = rgb1 & xff ; float af = NUM_ , rf = NUM_ , gf = NUM_ , bf = NUM_ ; for ( int col = - cols2 ; col <= cols2 ; col ++ ) { float f = matrix [ moffset + col ] ; if ( f != NUM_ ) { int ix = x + col ; if ( ! ( NUM_ <= ix && ix < width ) ) ix = x ; int rgb2 = inPixels [ ioffset + ix ] ; int a2 = ( rgb2 > > NUM_ ) & xff ; int r2 = ( rgb2 > > NUM_ ) & xff ; int g2 = ( rgb2 > > NUM_ ) & xff ; int b2 = rgb2 & xff ; int d ; d = a1 - a2 ; if ( d >= - threshold && d <= threshold ) { a += f . a2 ; af += f ; } d = r1 - r2 ; if ( d >= - threshold && d <= threshold ) { r += f . r2 ; rf += f ; } d = g1 - g2 ; if ( d >= - threshold && d <= threshold ) { g += f . g2 ; gf += f ; } d = b1 - b2 ; if ( d >= - threshold && d <= threshold ) { b += f . b2 ; bf += f ; } } } a = af == NUM_ ? a1 : a / af ; r = rf == NUM_ ? r1 : r / rf ; g = gf == NUM_ ? g1 : g / gf ; b = bf == NUM_ ? b1 : b / bf ; int ia = alpha ? PixelUtils . clamp ( ( int ) ( a + NUM_ ) ) : xff ; int ir = PixelUtils . clamp ( ( int ) ( r + NUM_ ) ) ; int ig = PixelUtils . clamp ( ( int ) ( g + NUM_ ) ) ; int ib = PixelUtils . clamp ( ( int ) ( b + NUM_ ) ) ; outPixels [ outIndex ] = ( ia << NUM_ ) | ( ir << NUM_ ) | ( ig << NUM_ ) | ib ; outIndex += height ; } } }
void closeSilently ( ServerSocket socket ) { try { socket . close ( ) ; } catch ( Exception e ) { } }
public ExpressionParserBuilder withProcess ( Process process ) { this . process = process ; return this ; }
void addAssociatedComponentAt ( int index , Component cmp ) { if ( comps == null ) { comps = new Vector ( ) ; } comps . insertElementAt ( cmp , index ) ; }
private static byte [ ] readClass ( final InputStream is ) throws IOException { if ( is == null ) { throw new IOException ( STR_ ) ; } byte [ ] b = new byte [ is . available ( ) ] ; int len = NUM_ ; while ( BOOL_ ) { int n = is . read ( b , len , b . length - len ) ; if ( n == - NUM_ ) { if ( len < b . length ) { byte [ ] c = new byte [ len ] ; System . arraycopy ( b , NUM_ , c , NUM_ , len ) ; b = c ; } return b ; } len += n ; if ( len == b . length ) { int last = is . read ( ) ; if ( last < NUM_ ) { return b ; } byte [ ] c = new byte [ b . length + NUM_ ] ; System . arraycopy ( b , NUM_ , c , NUM_ , len ) ; c [ len ++ ] = ( byte ) last ; b = c ; } } }
static String stringFromPacket ( DatagramPacket packet ) { return new String ( packet . getData ( ) , NUM_ , packet . getLength ( ) ) ; }
private String readAttributeName ( boolean returnLowerCase ) { skipWhitespace ( ) ; int c = find ( ATTRIBUTE_NAME_TERMINATORS ) ; String forSubstring = returnLowerCase ? inputLowerCase : input ; String result = pos < c ? forSubstring . substring ( pos , c ) : null ; pos = c ; return result ; }
public boolean contains ( final Entity entity ) { if ( entity == null ) { return BOOL_ ; } final IRPZone entityZone = entity . getZone ( ) ; return zone . equals ( entityZone ) && zone . has ( entity . getID ( ) ) && shape . contains ( entity . getX ( ) , entity . getY ( ) ) ; }
protected void checkOffscreenImage ( Dimension d ) { if ( doubleBuffered ) { if ( offscreen == null || offscreen . getWidth ( ) != d . width || offscreen . getHeight ( ) != d . height ) { offscreen = new BufferedImage ( d . width , d . height , BufferedImage . TYPE_INT_ARGB ) ; offscreenG2d = offscreen . createGraphics ( ) ; } } }
public void clear ( ) { synchronized ( mLock ) { mGraphics . clear ( ) ; } postInvalidate ( ) ; }
public void testSetObject_int_Object_int ( ) throws SQLException { PreparedStatement ps = null ; try { String query = STR_ ; ps = conn . prepareStatement ( query ) ; Statement st = null ; try { ps . setObject ( NUM_ , Integer . MAX_VALUE , Types . INTEGER ) ; ps . execute ( ) ; st = conn . createStatement ( ) ; st . execute ( STR_ + Integer . MAX_VALUE ) ; ResultSet rs = st . getResultSet ( ) ; assertEquals ( NUM_ , getCount ( rs ) ) ; } finally { try { st . close ( ) ; } catch ( Exception ee ) { } } query = STR_ ; ps = conn . prepareStatement ( query ) ; try { ps . setObject ( NUM_ , STR_ , Types . CHAR ) ; ps . execute ( ) ; st = conn . createStatement ( ) ; st . execute ( STR_ ) ; ResultSet rs = st . getResultSet ( ) ; assertEquals ( NUM_ , getCount ( rs ) ) ; } finally { try { st . close ( ) ; } catch ( Exception ee ) { } } query = STR_ ; ps = conn . prepareStatement ( query ) ; ps . setObject ( NUM_ , new Object ( ) , Types . DECIMAL ) ; ps . execute ( ) ; query = STR_ ; ps = conn . prepareStatement ( query ) ; Date d = new Date ( NUM_ ) ; try { ps . setObject ( NUM_ , d , Types . DATE ) ; ps . execute ( ) ; st = conn . createStatement ( ) ; st . execute ( STR_ + d . getTime ( ) + STR_ ) ; ResultSet rs = st . getResultSet ( ) ; assertEquals ( NUM_ , getCount ( rs ) ) ; } finally { try { st . close ( ) ; } catch ( Exception ee ) { } } query = STR_ ; ps = conn . prepareStatement ( query ) ; try { ps . setObject ( NUM_ , STR_ , Types . BLOB ) ; ps . execute ( ) ; } finally { try { st . close ( ) ; } catch ( Exception ee ) { } } } finally { try { ps . close ( ) ; } catch ( Exception ee ) { } } try { ps . setObject ( NUM_ , Integer . MAX_VALUE , Types . INTEGER ) ; fail ( STR_ ) ; } catch ( SQLException e ) { } }
public void warning ( org . xml . sax . SAXParseException e ) throws org . xml . sax . SAXException { String formattedMsg = e . getMessage ( ) ; SAXSourceLocator locator = getLocator ( ) ; ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; try { handler . warning ( new TransformerException ( formattedMsg , locator ) ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } }
public static boolean checkChrootPath ( String zkHost , boolean create ) throws KeeperException , InterruptedException { if ( ! containsChroot ( zkHost ) ) { return BOOL_ ; } log . info ( STR_ ) ; String chrootPath = zkHost . substring ( zkHost . indexOf ( STR_ ) , zkHost . length ( ) ) ; SolrZkClient tmpClient = new SolrZkClient ( zkHost . substring ( NUM_ , zkHost . indexOf ( STR_ ) ) , NUM_ . NUM_ ) ; boolean exists = tmpClient . exists ( chrootPath , BOOL_ ) ; if ( ! exists && create ) { tmpClient . makePath ( chrootPath , BOOL_ , BOOL_ ) ; exists = BOOL_ ; } tmpClient . close ( ) ; return exists ; }
public void addJob ( Runnable job ) { mJobs . add ( job ) ; }
public void addXValue ( String xVal ) { mXValAverageLength = ( mXValAverageLength + xVal . length ( ) ) / NUM_ ; mXVals . add ( xVal ) ; }
public boolean isNavigationAtBottom ( ) { return ( mSmallestWidthDp >= NUM_ || mInPortrait ) ; }
public long timeSinceStart ( ) { long currentTime = System . currentTimeMillis ( ) ; return currentTime - startTime ; }
public Formatter format ( Locale l , String format , Object ... args ) { ensureOpen ( ) ; int last = - NUM_ ; int lasto = - NUM_ ; FormatString [ ] fsa = parse ( format ) ; for ( int i = NUM_ ; i < fsa . length ; i ++ ) { FormatString fs = fsa [ i ] ; int index = fs . index ( ) ; try { switch ( index ) { case - NUM_ : fs . print ( null , l ) ; break ; case - NUM_ : if ( last < NUM_ || ( args != null && last > args . length - NUM_ ) ) throw new MissingFormatArgumentException ( fs . toString ( ) ) ; fs . print ( ( args == null ? null : args [ last ] ) , l ) ; break ; case NUM_ : lasto ++ ; last = lasto ; if ( args != null && lasto > args . length - NUM_ ) throw new MissingFormatArgumentException ( fs . toString ( ) ) ; fs . print ( ( args == null ? null : args [ lasto ] ) , l ) ; break ; default : last = index - NUM_ ; if ( args != null && last > args . length - NUM_ ) throw new MissingFormatArgumentException ( fs . toString ( ) ) ; fs . print ( ( args == null ? null : args [ last ] ) , l ) ; break ; } } catch ( IOException x ) { lastException = x ; } } return this ; }
public void testWriteReadEmpty ( ) throws Exception { ByteArrayOutputStream out = new ByteArrayOutputStream ( NUM_ ) ; ObjectOutputStream os = new ObjectOutputStream ( out ) ; os . writeObject ( empty ) ; ObjectInputStream is = new ObjectInputStream ( new ByteArrayInputStream ( out . toByteArray ( ) ) ) ; ClusterPolicy copy = ( ClusterPolicy ) is . readObject ( ) ; is . close ( ) ; os . close ( ) ; assertTrue ( helper . areEquals ( empty , copy ) ) ; }
DOMStringListImpl ( String [ ] params ) { fStrings = new Vector ( ) ; if ( params != null ) { for ( int i = NUM_ ; i < params . length ; i ++ ) { fStrings . add ( params [ i ] ) ; } } }
public Instant watermarkHold ( ) { long min = Long . MAX_VALUE ; for ( Instant hold : watermarkHolds . values ( ) ) { min = Math . min ( min , hold . getMillis ( ) ) ; } return new Instant ( min ) ; }
@ Override public final boolean isCapPresent ( int cap ) { return ( ( oglCaps . getCaps ( ) & cap ) != NUM_ ) ; }
public static < T > MenuResult < T > again ( ) { return new MenuResult < > ( Type . AGAIN , Collections . < T > emptyList ( ) ) ; }
@ SuppressWarnings ( STR_ ) public V put ( K key , V value ) { final int hash = key . hashCode ( ) ; int index = indexOf ( key , hash ) ; if ( index >= NUM_ ) { index = ( index << NUM_ ) + NUM_ ; final V old = ( V ) mArray [ index ] ; mArray [ index ] = value ; return old ; } index = ~ index ; if ( mSize >= mHashes . length ) { final int n = mSize >= ( BASE_SIZE . NUM_ ) ? ( mSize + ( mSize > > NUM_ ) ) : ( mSize >= BASE_SIZE ? ( BASE_SIZE . NUM_ ) : BASE_SIZE ) ; final int [ ] ohashes = mHashes ; final Object [ ] oarray = mArray ; allocArrays ( n ) ; if ( mHashes . length > NUM_ ) { System . arraycopy ( ohashes , NUM_ , mHashes , NUM_ , ohashes . length ) ; System . arraycopy ( oarray , NUM_ , mArray , NUM_ , oarray . length ) ; } freeArrays ( ohashes , oarray , mSize ) ; } if ( index < mSize ) { System . arraycopy ( mHashes , index , mHashes , index + NUM_ , mSize - index ) ; System . arraycopy ( mArray , index << NUM_ , mArray , ( index + NUM_ ) << NUM_ , ( mSize - index ) << NUM_ ) ; } mHashes [ index ] = hash ; mArray [ index << NUM_ ] = key ; mArray [ ( index << NUM_ ) + NUM_ ] = value ; mSize ++ ; return null ; }
public Long addNewUser ( String SID , String username , String userpass , String lastname , String firstname , String email , String additionalname , String street , String zip , String fax , long states_id , String town , long language_id , String baseURL ) throws AxisFault { try { Long users_id = sessionManagement . checkSession ( SID ) ; Long user_level = userManagement . getUserLevelByID ( users_id ) ; if ( authLevelManagement . checkWebServiceLevel ( user_level ) ) { Configuration conf = cfgManagement . getConfKey ( NUM_ , STR_ ) ; String jName_timeZone = STR_ ; if ( conf != null ) { jName_timeZone = conf . getConf_value ( ) ; } Long user_id = userManagement . registerUser ( username , userpass , lastname , firstname , email , new Date ( ) , street , additionalname , fax , zip , states_id , town , language_id , STR_ , baseURL , BOOL_ , jName_timeZone ) ; if ( user_id == null || user_id < NUM_ ) { return user_id ; } Users user = userManagement . getUserById ( user_id ) ; user . setStatus ( NUM_ ) ; user . setUpdatetime ( new Date ( ) ) ; userManagement . updateUser ( user ) ; return user_id ; } else { return new Long ( - NUM_ ) ; } } catch ( Exception err ) { log . error ( STR_ , err ) ; throw new AxisFault ( err . getMessage ( ) ) ; } }
public static void interpreterOnly ( Runnable runnable ) { runnable . run ( ) ; }
public DAddExtensionType ( JDialog parent , X509Extension extensions ) { super ( parent , Dialog . ModalityType . DOCUMENT_MODAL ) ; setTitle ( res . getString ( STR_ ) ) ; this . extensions = extensions ; initComponents ( ) ; }
private int hash ( GraphicsConfiguration config , int w , int h , Object ... args ) { int hash ; hash = ( config != null ? config . hashCode ( ) : NUM_ ) ; hash = NUM_ . hash + w ; hash = NUM_ . hash + h ; hash = NUM_ . hash + Arrays . deepHashCode ( args ) ; return hash ; }
public static byte [ ] decode ( byte [ ] input , int offset , int len , int flags ) { Decoder decoder = new Decoder ( flags , new byte [ len . NUM_ / NUM_ ] ) ; if ( ! decoder . process ( input , offset , len , BOOL_ ) ) { throw new IllegalArgumentException ( STR_ ) ; } if ( decoder . op == decoder . output . length ) { return decoder . output ; } byte [ ] temp = new byte [ decoder . op ] ; System . arraycopy ( decoder . output , NUM_ , temp , NUM_ , decoder . op ) ; return temp ; }
protected void paintText ( Graphics g , AbstractButton b , Rectangle textRect , String text ) { paintText ( g , ( JComponent ) b , textRect , text ) ; }
public static boolean usesSecondOperand ( final Integer mnemonic ) { return ! mnemonic . equals ( ReilHelpers . _OPCODE_NOP ) && ! mnemonic . equals ( ReilHelpers . _OPCODE_BISZ ) && ! mnemonic . equals ( ReilHelpers . _OPCODE_STR ) && ! mnemonic . equals ( ReilHelpers . _OPCODE_STM ) && ! mnemonic . equals ( ReilHelpers . _OPCODE_LDM ) && ! mnemonic . equals ( ReilHelpers . _OPCODE_JCC ) ; }
public RhythmGroup addOverlay ( RhythmOverlay overlay ) { mOverlays . add ( overlay ) ; if ( mCurrentOverlayIndex == NO_OVERLAY ) { selectOverlay ( NUM_ ) ; } return this ; }
public char [ ] toCharArray ( ) { char [ ] buffer = new char [ count ] ; System . arraycopy ( value , offset , buffer , NUM_ , count ) ; return buffer ; }
private File [ ] filterFiles ( final File [ ] toFilter , final String fileName ) { if ( fileName != null && toFilter != null ) { final File fileAsFilter = new File ( fileName ) ; for ( File file : toFilter ) { if ( file . compareTo ( fileAsFilter ) == NUM_ ) { return new File [ ] { fileAsFilter } ; } } return new File [ NUM_ ] ; } return toFilter ; }
public Fp ( ECCurve curve , ECFieldElement x , ECFieldElement y ) { this ( curve , x , y , BOOL_ ) ; }
private void pullEvent ( ) { final int newScrollValue ; final int itemDimension ; final float initialMotionValue , lastMotionValue ; switch ( getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : initialMotionValue = mInitialMotionX ; lastMotionValue = mLastMotionX ; break ; case VERTICAL : default : initialMotionValue = mInitialMotionY ; lastMotionValue = mLastMotionY ; break ; } switch ( mCurrentMode ) { case PULL_FROM_END : newScrollValue = Math . round ( Math . max ( initialMotionValue - lastMotionValue , NUM_ ) / FRICTION ) ; itemDimension = getFooterSize ( ) ; break ; case PULL_FROM_START : default : newScrollValue = Math . round ( Math . min ( initialMotionValue - lastMotionValue , NUM_ ) / FRICTION ) ; itemDimension = getHeaderSize ( ) ; break ; } setHeaderScroll ( newScrollValue ) ; if ( newScrollValue != NUM_ && ! isRefreshing ( ) ) { float scale = Math . abs ( newScrollValue ) / ( float ) itemDimension ; switch ( mCurrentMode ) { case PULL_FROM_END : mFooterLayout . onPull ( scale ) ; break ; case PULL_FROM_START : default : mHeaderLayout . onPull ( scale ) ; break ; } if ( mState != State . PULL_TO_REFRESH && itemDimension >= Math . abs ( newScrollValue ) ) { setState ( State . PULL_TO_REFRESH ) ; } else if ( ( mState == State . PULL_TO_REFRESH && itemDimension < Math . abs ( newScrollValue ) ) || ( mState == State . RESET && itemDimension < Math . abs ( newScrollValue ) ) ) { setState ( State . RELEASE_TO_REFRESH ) ; } } }
private File writePrivateKeyFile ( ) throws GitException { final File keyDirectory = new File ( rootFolder , host ) ; if ( ! keyDirectory . exists ( ) ) { keyDirectory . mkdirs ( ) ; } final File keyFile = new File ( keyDirectory , DEFAULT_KEY_NAME ) ; try ( FileOutputStream fos = new FileOutputStream ( keyFile ) ) { fos . write ( sshKey ) ; } catch ( IOException e ) { LOG . error ( STR_ , e ) ; throw new GitException ( STR_ ) ; } protectPrivateKeyFile ( keyFile ) ; return keyFile ; }
protected boolean drawLeftBorder ( Component c , Graphics g , int x , int y , int width , int height ) { if ( super . drawLeftBorder ( c , g , x , y , width , height ) && frame . isResizable ( ) ) { g . setColor ( getFrameHighlight ( ) ) ; int topY = y + CORNER_SIZE ; g . drawLine ( x , topY , x + NUM_ , topY ) ; int bottomY = height - CORNER_SIZE ; g . drawLine ( x + NUM_ , bottomY , x + NUM_ , bottomY ) ; g . setColor ( getFrameShadow ( ) ) ; g . drawLine ( x + NUM_ , topY - NUM_ , x + NUM_ , topY - NUM_ ) ; g . drawLine ( x + NUM_ , bottomY - NUM_ , x + NUM_ , bottomY - NUM_ ) ; return BOOL_ ; } return BOOL_ ; }
public static boolean isFileReadable ( String fileName ) { final File file = new File ( fileName ) ; return file . exists ( ) && file . canRead ( ) ; }
public static String hintingSize ( Font font ) { int instrSize = NUM_ ; LocaTable locaTable = FontUtils . getLocaTable ( font ) ; GlyphTable glyfTable = FontUtils . getGlyphTable ( font ) ; for ( int i = NUM_ ; i < locaTable . numGlyphs ( ) ; i ++ ) { Glyph glyph = glyfTable . glyph ( locaTable . glyphOffset ( i ) , locaTable . glyphLength ( i ) ) ; instrSize += glyph . instructionSize ( ) ; } double percentage = instrSize . NUM_ / glyfTable . headerLength ( ) ; return String . format ( STR_ , instrSize , twoDecimalPlaces . format ( percentage ) ) ; }
public static void premain ( String agentArgs , Instrumentation inst ) { instrumentation = inst ; LOGGER . info ( STR_ ) ; checkForCorrectSetup ( ) ; try { @ SuppressWarnings ( STR_ ) InspectItClassLoader classLoader = new InspectItClassLoader ( new URL [ NUM_ ] ) ; Class < ? > agentClazz = classLoader . loadClass ( INSPECTIT_AGENT ) ; Constructor < ? > constructor = agentClazz . getConstructor ( File . class ) ; Object realAgent = constructor . newInstance ( getInspectItAgentJarFileLocation ( ) ) ; Agent . agent = ( IAgent ) realAgent ; preloadClasses ( ) ; LOGGER . info ( STR_ ) ; analyzeAlreadyLoadedClasses ( ) ; inst . addTransformer ( new JavaAgent ( ) ) ; } catch ( Exception e ) { LOGGER . severe ( STR_ ) ; e . printStackTrace ( ) ; } }
private static float systemPropertyValue ( String name ) { String floatString = System . getProperty ( name ) ; if ( floatString == null ) return Float . NaN ; try { return Float . parseFloat ( floatString ) ; } catch ( NumberFormatException ex ) { throw new IllegalArgumentException ( String . format ( STR_ , name , floatString ) ) ; } }
@ ZapApiIgnore public boolean isConfirmRemoveProxyExcludedDomain ( ) { return this . confirmRemoveProxyExcludeDomain ; }
public FloatColumn ( int nrows , int capacity , float defaultValue ) { super ( float . class , new Float ( defaultValue ) ) ; if ( capacity < nrows ) { throw new IllegalArgumentException ( STR_ ) ; } m_values = new float [ capacity ] ; Arrays . fill ( m_values , defaultValue ) ; m_size = nrows ; }
private boolean addLocalKey ( KeyCacheObject key , AffinityTopologyVersion topVer , Collection < KeyCacheObject > distributedKeys ) throws IgniteCheckedException { GridDistributedCacheEntry entry = cctx . colocated ( ) . entryExx ( key , topVer , BOOL_ ) ; assert ! entry . detached ( ) ; if ( ! cctx . isAll ( entry , filter ) ) { if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + entry ) ; onComplete ( BOOL_ , BOOL_ ) ; return BOOL_ ; } GridCacheMvccCandidate cand = addEntry ( entry ) ; if ( cand != null && ! cand . reentry ( ) ) distributedKeys . add ( key ) ; return inTx ( ) && cand == null ; }
public static boolean isSupplemental ( int c ) { return ( c >= x10000 && c <= x10FFFF ) ; }
public void testRadix10Neg ( ) { String value = STR_ ; int radix = NUM_ ; BigInteger aNumber = new BigInteger ( value , radix ) ; String result = aNumber . toString ( radix ) ; assertTrue ( result . equals ( value ) ) ; }
public synchronized int readInTestFromSUT ( ) { if ( remoteBuffer . isEmpty ( ) ) { return - NUM_ ; } return remoteBuffer . poll ( ) & xFF ; }
public SpatialIndex ( String shpFilename ) throws IOException { this . shpFileName = shpFilename ; if ( logger . isLoggable ( Level . FINE ) ) { logger . fine ( STR_ + shpFilename + STR_ ) ; } }
public int invokeCompiler ( ) { List < String > args = getExecArguments ( ) ; for ( int i = NUM_ ; i < args . size ( ) ; i ++ ) { String arg = args . get ( i ) ; if ( arg . startsWith ( STR_ ) ) { String fileName = arg . substring ( NUM_ ) ; args . remove ( i ) ; outputArgumentsToFile ( fileName , args ) ; break ; } } return ExecUtil . execute ( args . toArray ( new String [ args . size ( ) ] ) , System . out , System . err ) ; }
static double fourNeighborsIDW ( SpatialGrid sg , double xCoord , double yCoord , double exp ) { double xDif = ( xCoord - sg . getXmin ( ) ) % sg . getResolution ( ) ; double yDif = ( yCoord - sg . getYmin ( ) ) % sg . getResolution ( ) ; if ( xDif == NUM_ && yDif == NUM_ ) { return sg . getValue ( xCoord , yCoord ) ; } double x1 = xCoord - xDif ; double x2 = x1 + sg . getResolution ( ) ; double y1 = yCoord - yDif ; double y2 = y1 + sg . getResolution ( ) ; double d11 = Math . pow ( distance ( x1 , y1 , xCoord , yCoord ) , exp ) ; double d12 = Math . pow ( distance ( x1 , y2 , xCoord , yCoord ) , exp ) ; double d21 = Math . pow ( distance ( x2 , y1 , xCoord , yCoord ) , exp ) ; double d22 = Math . pow ( distance ( x2 , y2 , xCoord , yCoord ) , exp ) ; if ( xCoord == sg . getXmax ( ) ) { return ( sg . getValue ( x1 , y1 ) / d11 + sg . getValue ( x1 , y2 ) / d12 ) / ( NUM_ / d11 + NUM_ / d12 ) ; } if ( yCoord == sg . getYmax ( ) ) { return ( sg . getValue ( x1 , y1 ) / d11 + sg . getValue ( x2 , y1 ) / d21 ) / ( NUM_ / d11 + NUM_ / d21 ) ; } return ( sg . getValue ( x1 , y1 ) / d11 + sg . getValue ( x1 , y2 ) / d12 + sg . getValue ( x2 , y1 ) / d21 + sg . getValue ( x2 , y2 ) / d22 ) / ( NUM_ / d11 + NUM_ / d12 + NUM_ / d21 + NUM_ / d22 ) ; }
public PojoValueField ( PropertyDescriptor desc ) { super ( desc ) ; }
public UrlFilterRule ( String ruleText ) { super ( ruleText ) ; String urlRuleText = ruleText ; if ( StringUtils . startsWith ( urlRuleText , MASK_WHITE_LIST ) ) { urlRuleText = urlRuleText . substring ( MASK_WHITE_LIST . length ( ) ) ; whiteListRule = BOOL_ ; } int optionsIndex = StringUtils . lastIndexOf ( urlRuleText , OPTIONS_DELIMITER ) ; if ( optionsIndex > - NUM_ ) { urlRuleText = urlRuleText . substring ( NUM_ , optionsIndex ) ; } urlRuleText = toPunycode ( urlRuleText ) ; boolean regexRule = urlRuleText . startsWith ( MASK_REGEX_RULE ) && urlRuleText . endsWith ( MASK_REGEX_RULE ) ; if ( ! regexRule ) { shortcut = findShortcut ( urlRuleText ) ; } }
protected static Pair < String , String > lsrRegister ( final long offset , final ITranslationEnvironment environment , final List < ReilInstruction > instructions , final String registerNodeValue1 , final String registerNodeValue2 ) { final String shifterOperand = environment . getNextVariableString ( ) ; final String shifterCarryOut = environment . getNextVariableString ( ) ; final String tmpVar1 = environment . getNextVariableString ( ) ; final String tmpVar11 = environment . getNextVariableString ( ) ; final String tmpVar2 = environment . getNextVariableString ( ) ; final String tmpVar3 = environment . getNextVariableString ( ) ; final String tmpVar4 = environment . getNextVariableString ( ) ; final String tmpVar5 = environment . getNextVariableString ( ) ; final String tmpVar6 = environment . getNextVariableString ( ) ; final String tmpVar7 = environment . getNextVariableString ( ) ; final String isZeroCondition = environment . getNextVariableString ( ) ; final String shifterCarryOutTmp1 = environment . getNextVariableString ( ) ; final String shifterCarryOutTmp2 = environment . getNextVariableString ( ) ; final String shifterCarryOutTmp3 = environment . getNextVariableString ( ) ; final String shifterCarryOutTmp4 = environment . getNextVariableString ( ) ; long baseOffset = offset ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , dWordSize , registerNodeValue2 , dWordSize , String . valueOf ( x000000FFL ) , dWordSize , tmpVar1 ) ) ; instructions . add ( ReilHelpers . createSub ( baseOffset ++ , dWordSize , String . valueOf ( NUM_ ) , dWordSize , tmpVar1 , dWordSize , tmpVar11 ) ) ; instructions . add ( ReilHelpers . createBsh ( baseOffset ++ , dWordSize , registerNodeValue1 , dWordSize , tmpVar11 , dWordSize , tmpVar2 ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , dWordSize , tmpVar2 , dWordSize , bitMaskAllBitsSet , dWordSize , shifterOperand ) ) ; instructions . add ( ReilHelpers . createBisz ( baseOffset ++ , dWordSize , tmpVar11 , byteSize , isZeroCondition ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , byteSize , isZeroCondition , byteSize , STR_ , byteSize , shifterCarryOutTmp1 ) ) ; instructions . add ( ReilHelpers . createXor ( baseOffset ++ , dWordSize , tmpVar11 , wordSize , String . valueOf ( x20L ) , dWordSize , tmpVar3 ) ) ; instructions . add ( ReilHelpers . createBisz ( baseOffset ++ , dWordSize , tmpVar3 , byteSize , isZeroCondition ) ) ; instructions . add ( ReilHelpers . createBsh ( baseOffset ++ , dWordSize , registerNodeValue1 , dWordSize , thirtyOneSet , byteSize , tmpVar4 ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , byteSize , isZeroCondition , byteSize , tmpVar4 , byteSize , shifterCarryOutTmp2 ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , dWordSize , tmpVar11 , dWordSize , notThirtyOneSet , dWordSize , tmpVar5 ) ) ; instructions . add ( ReilHelpers . createBisz ( baseOffset ++ , dWordSize , tmpVar5 , byteSize , isZeroCondition ) ) ; instructions . add ( ReilHelpers . createSub ( baseOffset ++ , dWordSize , tmpVar11 , dWordSize , oneSet , dWordSize , tmpVar6 ) ) ; instructions . add ( ReilHelpers . createSub ( baseOffset ++ , dWordSize , zeroSet , dWordSize , tmpVar6 , dWordSize , tmpVar6 ) ) ; instructions . add ( ReilHelpers . createBsh ( baseOffset ++ , dWordSize , registerNodeValue1 , dWordSize , tmpVar6 , byteSize , tmpVar7 ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , byteSize , isZeroCondition , byteSize , tmpVar7 , byteSize , shifterCarryOutTmp3 ) ) ; instructions . add ( ReilHelpers . createOr ( baseOffset ++ , byteSize , shifterCarryOutTmp1 , byteSize , shifterCarryOutTmp2 , byteSize , shifterCarryOutTmp4 ) ) ; instructions . add ( ReilHelpers . createOr ( baseOffset ++ , byteSize , shifterCarryOutTmp3 , byteSize , shifterCarryOutTmp4 , byteSize , shifterCarryOut ) ) ; return new Pair < String , String > ( shifterOperand , shifterCarryOut ) ; }
public static boolean isDrmConvertNeeded ( String mimetype ) { return MIMETYPE_DRM_MESSAGE . equals ( mimetype ) ; }
public static String pad ( String original , int length , char padChar ) { if ( original . length ( ) >= length ) return original ; StringBuilder sb = new StringBuilder ( original ) ; while ( sb . length ( ) < length ) { sb . append ( padChar ) ; } return sb . toString ( ) ; }
public void propertyChange ( PropertyChangeEvent evt ) { String propName = evt . getPropertyName ( ) ; if ( propName == MapBean . CursorProperty ) { fallbackMapBeanCursor = ( ( Cursor ) evt . getNewValue ( ) ) ; } else { if ( propName == MouseDelegator . ActiveModeProperty ) { MapMouseMode mmm = ( MapMouseMode ) evt . getNewValue ( ) ; setResetCursor ( mmm . getModeCursor ( ) ) ; } else if ( propName == MapBean . LayersProperty ) { resetForLayers ( ( Layer [ ] ) evt . getNewValue ( ) , ( Layer [ ] ) evt . getOldValue ( ) ) ; } else if ( propName != MapBean . ProjectionProperty ) { return ; } setAllLabels ( fudgeString ) ; } initToolTip ( ) ; }
private void checkForNight ( final ZonedDateTime TIME ) { int hour = TIME . getHour ( ) ; int minute = TIME . getMinute ( ) ; if ( NUM_ <= hour && minute >= NUM_ && hour <= NUM_ && minute <= NUM_ || NUM_ <= hour && minute <= NUM_ && hour <= NUM_ && minute <= NUM_ ) { if ( isNightMode ( ) ) return ; setNightMode ( BOOL_ ) ; } else { if ( ! isNightMode ( ) ) return ; setNightMode ( BOOL_ ) ; } }
@ Override public int calculateOffsetY ( ) { return - ( int ) ( Math . sin ( this . angle ) . this . distance ) - this . shadowSize ; }
private double [ ] concatenateSamples ( final double [ ] x , final double [ ] y ) { final double [ ] z = new double [ x . length + y . length ] ; System . arraycopy ( x , NUM_ , z , NUM_ , x . length ) ; System . arraycopy ( y , NUM_ , z , x . length , y . length ) ; return z ; }
@ Override public void drawSeries ( Canvas canvas , Paint paint , List < Float > points , XYSeriesRenderer renderer , float yAxisValue , int seriesIndex , int startIndex ) { paint . setColor ( renderer . getColor ( ) ) ; final float stroke = paint . getStrokeWidth ( ) ; if ( renderer . isFillPoints ( ) ) { paint . setStyle ( Style . FILL ) ; } else { paint . setStrokeWidth ( renderer . getPointStrokeWidth ( ) ) ; paint . setStyle ( Style . STROKE ) ; } int length = points . size ( ) ; PointStyle ps = renderer . getPointStyle ( ) ; if ( ps == PointStyle . X ) { paint . setStrokeWidth ( renderer . getPointStrokeWidth ( ) ) ; for ( int i = NUM_ ; i < length ; i += NUM_ ) { drawX ( canvas , paint , points . get ( i ) , points . get ( i + NUM_ ) ) ; } } else { if ( ps == PointStyle . CIRCLE ) { for ( int i = NUM_ ; i < length ; i += NUM_ ) { drawCircle ( canvas , paint , points . get ( i ) , points . get ( i + NUM_ ) ) ; } } else { if ( ps == PointStyle . TRIANGLE ) { float [ ] path = new float [ NUM_ ] ; for ( int i = NUM_ ; i < length ; i += NUM_ ) { drawTriangle ( canvas , paint , path , points . get ( i ) , points . get ( i + NUM_ ) ) ; } } else { if ( ps == PointStyle . SQUARE ) { for ( int i = NUM_ ; i < length ; i += NUM_ ) { drawSquare ( canvas , paint , points . get ( i ) , points . get ( i + NUM_ ) ) ; } } else { if ( ps == PointStyle . DIAMOND ) { float [ ] path = new float [ NUM_ ] ; for ( int i = NUM_ ; i < length ; i += NUM_ ) { drawDiamond ( canvas , paint , path , points . get ( i ) , points . get ( i + NUM_ ) ) ; } } else { if ( ps == PointStyle . POINT ) { for ( int i = NUM_ ; i < length ; i += NUM_ ) { canvas . drawPoint ( points . get ( i ) , points . get ( i + NUM_ ) , paint ) ; } } } } } } } paint . setStrokeWidth ( stroke ) ; }
public final void pushSubContextList ( SubContextList iter ) { m_axesIteratorStack . push ( iter ) ; }
public String handleWord ( String aWord ) { Matcher m = conditionPattern . matcher ( aWord ) ; if ( m != null && m . matches ( ) ) { if ( type . equals ( AffixType . PREFIX ) ) { return handlePrefix ( aWord ) ; } else if ( type . equals ( AffixType . SUFFIX ) ) { return handleSuffix ( aWord ) ; } } return null ; }
public static void round ( Calendar c , String unit ) { Integer uu = CALENDAR_UNITS . get ( unit ) ; if ( null == uu ) { throw new IllegalArgumentException ( STR_ + unit ) ; } int u = uu . intValue ( ) ; switch ( u ) { case Calendar . YEAR : c . clear ( Calendar . MONTH ) ; case Calendar . MONTH : c . clear ( Calendar . DAY_OF_MONTH ) ; c . clear ( Calendar . DAY_OF_WEEK ) ; c . clear ( Calendar . DAY_OF_WEEK_IN_MONTH ) ; c . clear ( Calendar . DAY_OF_YEAR ) ; c . clear ( Calendar . WEEK_OF_MONTH ) ; c . clear ( Calendar . WEEK_OF_YEAR ) ; case Calendar . DATE : c . clear ( Calendar . HOUR_OF_DAY ) ; c . clear ( Calendar . HOUR ) ; c . clear ( Calendar . AM_PM ) ; case Calendar . HOUR_OF_DAY : c . clear ( Calendar . MINUTE ) ; case Calendar . MINUTE : c . clear ( Calendar . SECOND ) ; case Calendar . SECOND : c . clear ( Calendar . MILLISECOND ) ; break ; default : throw new IllegalStateException ( STR_ + u + STR_ + unit ) ; } }
private static final char [ ] growBuffer ( char [ ] dest , int index , int size ) { char [ ] copy = new char [ size ] ; if ( index > NUM_ ) { System . arraycopy ( dest , NUM_ , copy , NUM_ , index ) ; } return copy ; }
public boolean sync ( ) { if ( ulog == null ) { return BOOL_ ; } log . info ( msg ( ) + STR_ + replicas + STR_ + nUpdates ) ; if ( ! ( ulog . getState ( ) == UpdateLog . State . ACTIVE || ulog . getState ( ) == UpdateLog . State . REPLAYING ) ) { log . error ( msg ( ) + STR_ + ulog ) ; } if ( debug ) { if ( startingVersions != null ) { log . debug ( msg ( ) + STR_ + startingVersions . size ( ) + STR_ + startingVersions ) ; } } for ( String replica : replicas ) { requestVersions ( replica ) ; } recentUpdates = ulog . getRecentUpdates ( ) ; try { ourUpdates = recentUpdates . getVersions ( nUpdates ) ; } finally { recentUpdates . close ( ) ; } Collections . sort ( ourUpdates , absComparator ) ; if ( startingVersions != null ) { if ( startingVersions . size ( ) == NUM_ ) { log . warn ( STR_ ) ; return BOOL_ ; } Collections . sort ( startingVersions , absComparator ) ; ourLowThreshold = percentile ( startingVersions , NUM_ ) ; ourHighThreshold = percentile ( startingVersions , NUM_ ) ; long smallestNewUpdate = Math . abs ( ourUpdates . get ( ourUpdates . size ( ) - NUM_ ) ) ; if ( Math . abs ( startingVersions . get ( NUM_ ) ) < smallestNewUpdate ) { log . warn ( msg ( ) + STR_ ) ; return BOOL_ ; } List < Long > newList = new ArrayList < > ( ourUpdates ) ; for ( Long ver : startingVersions ) { if ( Math . abs ( ver ) < smallestNewUpdate ) { newList . add ( ver ) ; } } ourUpdates = newList ; } else { if ( ourUpdates . size ( ) > NUM_ ) { ourLowThreshold = percentile ( ourUpdates , NUM_ ) ; ourHighThreshold = percentile ( ourUpdates , NUM_ ) ; } else { log . info ( msg ( ) + STR_ ) ; return BOOL_ ; } } ourUpdateSet = new HashSet < > ( ourUpdates ) ; requestedUpdateSet = new HashSet < > ( ourUpdates ) ; for ( ; ; ) { ShardResponse srsp = shardHandler . takeCompletedOrError ( ) ; if ( srsp == null ) break ; boolean success = handleResponse ( srsp ) ; if ( ! success ) { log . info ( msg ( ) + STR_ ) ; shardHandler . cancelAll ( ) ; return BOOL_ ; } } log . info ( msg ( ) + STR_ ) ; return BOOL_ ; }
public static String stripFileProtocol ( String uriString ) { if ( uriString . startsWith ( STR_ ) ) { uriString = uriString . substring ( NUM_ ) ; } return uriString ; }
private void contentSpecTree ( int contentSpecIndex , XMLContentSpec contentSpec , ChildrenList children ) { getContentSpec ( contentSpecIndex , contentSpec ) ; if ( contentSpec . type == XMLContentSpec . CONTENTSPECNODE_LEAF || ( contentSpec . type & x0f ) == XMLContentSpec . CONTENTSPECNODE_ANY || ( contentSpec . type & x0f ) == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL || ( contentSpec . type & x0f ) == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { if ( children . length == children . qname . length ) { QName [ ] newQName = new QName [ children . length . NUM_ ] ; System . arraycopy ( children . qname , NUM_ , newQName , NUM_ , children . length ) ; children . qname = newQName ; int [ ] newType = new int [ children . length . NUM_ ] ; System . arraycopy ( children . type , NUM_ , newType , NUM_ , children . length ) ; children . type = newType ; } children . qname [ children . length ] = new QName ( null , ( String ) contentSpec . value , ( String ) contentSpec . value , ( String ) contentSpec . otherValue ) ; children . type [ children . length ] = contentSpec . type ; children . length ++ ; return ; } final int leftNode = contentSpec . value != null ? ( ( int [ ] ) ( contentSpec . value ) ) [ NUM_ ] : - NUM_ ; int rightNode = - NUM_ ; if ( contentSpec . otherValue != null ) rightNode = ( ( int [ ] ) ( contentSpec . otherValue ) ) [ NUM_ ] ; else return ; if ( contentSpec . type == XMLContentSpec . CONTENTSPECNODE_CHOICE || contentSpec . type == XMLContentSpec . CONTENTSPECNODE_SEQ ) { contentSpecTree ( leftNode , contentSpec , children ) ; contentSpecTree ( rightNode , contentSpec , children ) ; return ; } if ( contentSpec . type == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE || contentSpec . type == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE || contentSpec . type == XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE ) { contentSpecTree ( leftNode , contentSpec , children ) ; return ; } throw new RuntimeException ( STR_ + contentSpec . type ) ; }
protected JTextField createEditorComponent ( ) { JTextField editor = new BorderlessTextField ( STR_ , NUM_ ) ; editor . setBorder ( null ) ; return editor ; }
private void addArg ( String key , Object value ) { if ( requestArguments == null ) { requestArguments = new Hashtable ( ) ; } if ( value == null || key == null ) { return ; } if ( post ) { setWriteRequest ( BOOL_ ) ; } requestArguments . put ( key , value ) ; }
public static double [ ] readFileColumn ( String filename , int columnIdx , int sizeLimit ) throws IOException , SAXException { Path path = Paths . get ( filename ) ; if ( ! ( Files . exists ( path ) ) ) { throw new SAXException ( STR_ ) ; } BufferedReader br = new BufferedReader ( new InputStreamReader ( new FileInputStream ( filename ) , STR_ ) ) ; return readTS ( br , columnIdx , sizeLimit ) ; }
private void startReader ( ConnectionTable connTable ) { Assert . assertTrue ( ! this . isRunning ) ; stopped = BOOL_ ; this . isRunning = BOOL_ ; connTable . executeCommand ( this ) ; }
public static boolean isCompactionRequiredForTable ( String metaFolderPath ) { String minorCompactionStatusFile = metaFolderPath + CarbonCommonConstants . FILE_SEPARATOR + CarbonCommonConstants . minorCompactionRequiredFile ; String majorCompactionStatusFile = metaFolderPath + CarbonCommonConstants . FILE_SEPARATOR + CarbonCommonConstants . majorCompactionRequiredFile ; try { if ( FileFactory . isFileExist ( minorCompactionStatusFile , FileFactory . getFileType ( minorCompactionStatusFile ) ) || FileFactory . isFileExist ( majorCompactionStatusFile , FileFactory . getFileType ( majorCompactionStatusFile ) ) ) { return BOOL_ ; } } catch ( IOException e ) { LOGGER . error ( STR_ + e . getMessage ( ) ) ; } return BOOL_ ; }
BigInteger copy ( ) { prepareJavaRepresentation ( ) ; int [ ] copyDigits = new int [ numberLength ] ; System . arraycopy ( digits , NUM_ , copyDigits , NUM_ , numberLength ) ; return new BigInteger ( sign , numberLength , copyDigits ) ; }
public void addExcludedClass ( String className ) { mExcludedClasses . add ( className ) ; }
public BundleMessageSource ( Locale locale ) { _messages = ResourceBundle . getBundle ( BASE_NAME , locale ) ; }
private void clipViewOnTheRight ( Rect curViewBound , float curViewWidth , int right ) { curViewBound . right = ( int ) ( right - mClipPadding ) ; curViewBound . left = ( int ) ( curViewBound . right - curViewWidth ) ; }
private void createEditPanel ( ) { editPanel = new JPanel ( ) ; add ( editPanel , BorderLayout . CENTER ) ; CardLayout cardlayout = new CardLayout ( ) ; editPanel . setLayout ( cardlayout ) ; if ( colourRampMap != null ) { for ( ColourRampPanelInterface data : colourRampMap . keySet ( ) ) { data . setParent ( this ) ; String key = data . getTitle ( ) ; editPanel . add ( data . getPanel ( ) , key ) ; } } }
public static long atol ( String s ) { int i = NUM_ ; while ( i < s . length ( ) && Character . isWhitespace ( s . charAt ( i ) ) ) i ++ ; if ( i < s . length ( ) && s . charAt ( i ) == STR_ ) { if ( i + NUM_ < s . length ( ) && ( s . charAt ( i + NUM_ ) == STR_ || s . charAt ( i + NUM_ ) == STR_ ) ) return parseLong ( s . substring ( i + NUM_ ) , NUM_ ) ; else return parseLong ( s , NUM_ ) ; } else return parseLong ( s , NUM_ ) ; }
public Object eval ( Reader reader , ScriptEngine engine ) throws ScriptException { return engine . eval ( reader ) ; }
public static InputStream toInputStream ( CharSequence input , Charset encoding ) { return toInputStream ( input . toString ( ) , encoding ) ; }
public void classForName ( SootMethod container , Stmt forNameInvokeStmt ) { Set < String > classNames = reflectionInfo . classForNameClassNames ( container ) ; if ( classNames == null || classNames . isEmpty ( ) ) { registerGuard ( container , forNameInvokeStmt , STR_ ) ; } else { for ( String clsName : classNames ) { constantForName ( clsName , container , forNameInvokeStmt ) ; } } }
private AbstractRenderer createRenderer ( JTabbedPane tabbedPane ) { return hasEmbeddedTabs ( ) ? AbstractRenderer . createEmbeddedRenderer ( tabbedPane ) : AbstractRenderer . createRenderer ( tabPane ) ; }
public void readMap ( InputStream inputStream , MapBuilder builder ) { try { parseMap ( inputStream , builder ) ; if ( builder . nodeRefsWithoutDefsAdded ( ) ) LOG . warning ( STR_ ) ; } catch ( SAXParseException e ) { throw new OsmRuntimeException ( STR_ + STR_ + e . getPublicId ( ) + STR_ + e . getSystemId ( ) + STR_ + e . getLineNumber ( ) + STR_ + e . getColumnNumber ( ) + STR_ , e ) ; } catch ( SAXException e ) { throw new OsmRuntimeException ( STR_ , e ) ; } catch ( IOException e ) { throw new OsmRuntimeException ( STR_ , e ) ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( IOException e ) { LOG . log ( Level . SEVERE , STR_ , e ) ; } } } }
private void processComment ( ) { templateReader . nextCharacter ( ) ; if ( templateReader . startsWith ( syntax . getDocumentTypeOpening ( ) ) ) { processSchemaComment ( ) ; return ; } else if ( nestedComments ) { processNestedComment ( ) ; return ; } while ( templateReader . hasNextCharacter ( ) ) { final char commentCharacter = templateReader . nextCharacter ( ) ; if ( isCommentClosingMarker ( commentCharacter ) && templateReader . hasNextCharacter ( ) && templateReader . peekCharacter ( ) == syntax . getTagClosing ( ) ) { templateReader . nextCharacter ( ) ; break ; } } }
private void emitPermutationsAppCache ( TreeLogger logger , LinkerContext context , ArtifactSet artifacts , String startScreenId , OfflineScreen offlineScreen ) throws UnableToCompleteException { for ( EmittedArtifact emitted : artifacts . find ( EmittedArtifact . class ) ) { if ( emitted . getVisibility ( ) == Visibility . Private ) { continue ; } String pathName = emitted . getPartialPath ( ) ; if ( acceptCachedResource ( pathName ) ) { if ( ! allArtifacts . contains ( pathName ) ) { cachedArtifacts . add ( pathName ) ; } } } Set < ArtifactsGroup > keySet = artifactsByGroup . keySet ( ) ; for ( ArtifactsGroup group : keySet ) { Set < String > set = artifactsByGroup . get ( group ) ; set . addAll ( cachedArtifacts ) ; artifacts . add ( createCacheManifest ( context , logger , set , group . getGroupId ( ) , startScreenId , offlineScreen ) ) ; artifacts . add ( createCacheManifestLoader ( context , logger , group . getGroupId ( ) , startScreenId ) ) ; } }
public final boolean isRegistered ( ) { return ! canonicalName . startsWith ( STR_ ) && ! canonicalName . startsWith ( STR_ ) ; }
public License ( final String filename , final String text ) { if ( filename == null ) { throw new NullPointerException ( STR_ ) ; } if ( filename . isEmpty ( ) ) { throw new IllegalArgumentException ( STR_ ) ; } this . filename = filename ; if ( text == null ) { throw new NullPointerException ( STR_ ) ; } if ( text . isEmpty ( ) ) { throw new IllegalArgumentException ( STR_ ) ; } this . text = text ; }
protected static void processExplorerProps ( File propsFile ) { try { Properties expProps = new Properties ( ) ; BufferedInputStream bi = new BufferedInputStream ( new FileInputStream ( propsFile ) ) ; expProps . load ( bi ) ; bi . close ( ) ; bi = null ; Set < Object > keys = expProps . keySet ( ) ; Iterator < Object > keysI = keys . iterator ( ) ; while ( keysI . hasNext ( ) ) { String key = ( String ) keysI . next ( ) ; if ( ! key . endsWith ( STR_ ) ) { String existingVal = ExplorerDefaults . get ( key , STR_ ) ; if ( existingVal . length ( ) > NUM_ ) { String replacePolicy = expProps . getProperty ( key + STR_ ) ; if ( replacePolicy != null && replacePolicy . length ( ) > NUM_ ) { if ( replacePolicy . equalsIgnoreCase ( STR_ ) ) { String newVal = expProps . getProperty ( key ) ; ExplorerDefaults . set ( key , newVal ) ; } else { String newVal = expProps . getProperty ( key ) ; if ( existingVal . indexOf ( newVal ) < NUM_ ) { newVal = existingVal + STR_ + newVal ; ExplorerDefaults . set ( key , newVal ) ; } } } else { String newVal = expProps . getProperty ( key ) ; if ( existingVal . indexOf ( newVal ) < NUM_ ) { newVal = existingVal + STR_ + newVal ; ExplorerDefaults . set ( key , newVal ) ; } } } else { String newVal = expProps . getProperty ( key ) ; ExplorerDefaults . set ( key , newVal ) ; } } } } catch ( Exception ex ) { } }
@ SuppressWarnings ( STR_ ) protected int hashFields ( int hash , Map < FieldDescriptor , Object > map ) { for ( Map . Entry < FieldDescriptor , Object > entry : map . entrySet ( ) ) { FieldDescriptor field = entry . getKey ( ) ; Object value = entry . getValue ( ) ; hash = ( NUM_ . hash ) + field . getNumber ( ) ; if ( field . getType ( ) != FieldDescriptor . Type . ENUM ) { hash = ( NUM_ . hash ) + value . hashCode ( ) ; } else if ( field . isRepeated ( ) ) { List < ? extends EnumLite > list = ( List < ? extends EnumLite > ) value ; hash = ( NUM_ . hash ) + hashEnumList ( list ) ; } else { hash = ( NUM_ . hash ) + hashEnum ( ( EnumLite ) value ) ; } } return hash ; }
public DashboardServiceHelper ( ) { attributesRequireUpdate . add ( DASHBOARD_CLASS_NAME ) ; attributesRequireUpdate . add ( DASHBOARD_NAME ) ; attributesRequireUpdate . add ( DASHBOARD_DISPLAY_NAME ) ; attributesRequireUpdate . add ( DASHBOARD_ICON ) ; attributesRequireUpdate . add ( DASHBOARD_LOGIN ) ; attributesRequireUpdate . add ( ICF_IDENTIFIER ) ; attributes . addAll ( attributesRequireUpdate ) ; }
public static String javaUtilRegexEscape ( String s ) { if ( s . indexOf ( STR_ ) == - NUM_ ) { return STR_ + s + STR_ ; } StringBuilder sb = new StringBuilder ( ) ; for ( int i = NUM_ ; i < s . length ( ) ; i ++ ) { sb . append ( STR_ ) ; sb . append ( s . charAt ( i ) ) ; } return sb . toString ( ) ; }
public void forgetFfmpegPath ( ) { settings . put ( SETTINGS_FFMPEG_PATH , FFMPEG_PATH_UNSET ) ; }
@ Override public void printWarning ( final String message ) { printWarning ( message , preferenceStore . getBoolean ( UIPreferenceConstants . CONSOLE_SHOW_ON_NEW_WARNING ) ) ; }
public static String revertNewLines ( String string ) { int index ; StringBuffer newStringBuffer = new StringBuffer ( ) ; while ( ( index = string . indexOf ( STR_ ) ) != - NUM_ ) { if ( index > NUM_ ) { newStringBuffer . append ( string . substring ( NUM_ , index ) ) ; } newStringBuffer . append ( STR_ ) ; if ( ( index + NUM_ ) < string . length ( ) ) { string = string . substring ( index + NUM_ ) ; } else { string = STR_ ; } } newStringBuffer . append ( string ) ; string = newStringBuffer . toString ( ) ; newStringBuffer = new StringBuffer ( ) ; while ( ( index = string . indexOf ( STR_ ) ) != - NUM_ ) { if ( index > NUM_ ) { newStringBuffer . append ( string . substring ( NUM_ , index ) ) ; } newStringBuffer . append ( STR_ ) ; if ( ( index + NUM_ ) < string . length ( ) ) { string = string . substring ( index + NUM_ ) ; } else { string = STR_ ; } } newStringBuffer . append ( string ) ; return newStringBuffer . toString ( ) ; }
public void pathValuesToPixel ( List < Path > paths ) { for ( int i = NUM_ ; i < paths . size ( ) ; i ++ ) { pathValueToPixel ( paths . get ( i ) ) ; } }
@ Override public void onInsertComplete ( int taskId , Object cookie , long insertRowId ) { if ( taskId == AppConstants . QueryTokens . INSERT_WALLPOST && insertRowId != - NUM_ ) { Logger . i ( TAG , STR_ + insertRowId ) ; } }
protected void parseList ( ArrayList < String > list , String text ) { list . clear ( ) ; StringTokenizer st = new StringTokenizer ( text , STR_ ) ; while ( st . hasMoreElements ( ) ) { String line = ( String ) st . nextElement ( ) ; list . add ( line . trim ( ) ) ; } }
protected List < Node > splitAssignments ( Node node ) { if ( node instanceof AssignmentNode ) { List < Node > result = new ArrayList < > ( ) ; AssignmentNode a = ( AssignmentNode ) node ; result . add ( a . getTarget ( ) ) ; result . addAll ( splitAssignments ( a . getExpression ( ) ) ) ; return result ; } else { return Collections . singletonList ( node ) ; } }
public Tree < String > extractBestMaxRuleParse ( int start , int end , List < String > sentence ) { return extractBestMaxRuleParse1 ( start , end , NUM_ , sentence ) ; }
public static double normalize ( double val , double min , double max ) { if ( max < min ) throw new IllegalArgumentException ( STR_ ) ; return ( val - min ) / ( max - min ) ; }
private static boolean containsOnlyTransientAndStaticFields ( List < Field > fields ) { boolean containsNormalField = BOOL_ ; for ( Field field : fields ) { if ( ! Modifier . isTransient ( field . getModifiers ( ) ) && ! Modifier . isStatic ( field . getModifiers ( ) ) ) { containsNormalField = BOOL_ ; } } return ! containsNormalField ; }
@ Override public void appendIndexMapTo ( Appendable out , String name , List < SourceMapSection > sections ) throws IOException { out . append ( STR_ ) ; appendFirstField ( out , STR_ , STR_ ) ; appendField ( out , STR_ , escapeString ( name ) ) ; appendFieldStart ( out , STR_ ) ; out . append ( STR_ ) ; boolean first = BOOL_ ; for ( SourceMapSection section : sections ) { if ( first ) { first = BOOL_ ; } else { out . append ( STR_ ) ; } out . append ( STR_ ) ; appendFirstField ( out , STR_ , offsetValue ( section . getLine ( ) , section . getColumn ( ) ) ) ; if ( section . getSectionType ( ) == SourceMapSection . SectionType . URL ) { appendField ( out , STR_ , escapeString ( section . getSectionValue ( ) ) ) ; } else if ( section . getSectionType ( ) == SourceMapSection . SectionType . MAP ) { appendField ( out , STR_ , section . getSectionValue ( ) ) ; } else { throw new IOException ( STR_ ) ; } out . append ( STR_ ) ; } out . append ( STR_ ) ; appendFieldEnd ( out ) ; out . append ( STR_ ) ; }
public Builder addPart ( Part part ) { if ( part == null ) throw new NullPointerException ( STR_ ) ; parts . add ( part ) ; return this ; }
protected void notifyGone ( L locator ) { synchronized ( this ) { if ( ! staleLocators . add ( locator . getPartitionId ( ) ) ) { fail ( STR_ + locator ) ; } } }
@ Override public void addVetoableChangeListener ( String name , VetoableChangeListener vcl ) { m_bcSupport . addVetoableChangeListener ( name , vcl ) ; }
public String buildUser ( ) { return properties . getProperty ( STR_ ) ; }
private void updateIdleExpireTime ( long now ) { _threadIdleExpireTime . set ( now + _idleTimeout ) ; }
protected CtClass createCtClass ( String classname , boolean useCache ) { if ( classname . charAt ( NUM_ ) == STR_ ) classname = Descriptor . toClassName ( classname ) ; if ( classname . endsWith ( STR_ ) ) { String base = classname . substring ( NUM_ , classname . indexOf ( STR_ ) ) ; if ( ( ! useCache || getCached ( base ) == null ) && find ( base ) == null ) return null ; else return new CtArray ( classname , this ) ; } else if ( find ( classname ) == null ) return null ; else return new CtClassType ( classname , this ) ; }
@ Transactional public long createVoucherFromBill ( final int billId ) throws ApplicationRuntimeException { try { String voucherStatus = null ; final List vStatusList = appConfigValuesService . getConfigValuesByModuleAndKey ( STR_ , STR_ ) ; if ( ! vStatusList . isEmpty ( ) && vStatusList . size ( ) == NUM_ ) { final AppConfigValues appVal = ( AppConfigValues ) vStatusList . get ( NUM_ ) ; voucherStatus = appVal . getValue ( ) ; } else throw new ApplicationRuntimeException ( STR_ + MISSINGMSG ) ; final long vh = createVoucher . createVoucherFromBill ( billId , voucherStatus , null , null ) ; return vh ; } catch ( final Exception e ) { LOGGER . error ( e . getMessage ( ) ) ; throw new ApplicationRuntimeException ( e . getMessage ( ) ) ; } }
public static float compareEquivalance ( Bitmap bitmap1 , Bitmap bitmap2 ) { if ( bitmap1 == null || bitmap2 == null || bitmap1 . getWidth ( ) != bitmap2 . getWidth ( ) || bitmap1 . getHeight ( ) != bitmap2 . getHeight ( ) ) { return NUM_ ; } ByteBuffer buffer1 = ByteBuffer . allocate ( bitmap1 . getHeight ( ) . bitmap1 . getRowBytes ( ) ) ; bitmap1 . copyPixelsToBuffer ( buffer1 ) ; ByteBuffer buffer2 = ByteBuffer . allocate ( bitmap2 . getHeight ( ) . bitmap2 . getRowBytes ( ) ) ; bitmap2 . copyPixelsToBuffer ( buffer2 ) ; byte [ ] array1 = buffer1 . array ( ) ; byte [ ] array2 = buffer2 . array ( ) ; int len = array1 . length ; int count = NUM_ ; for ( int i = NUM_ ; i < len ; i ++ ) { if ( array1 [ i ] == array2 [ i ] ) { count ++ ; } } return ( ( float ) ( count ) ) / len ; }
public void handleTblCharsetAliasHrefActionRequest ( RequestInvocationEvent event ) throws ModelControlException { try { Map values = getValues ( ) ; onBeforeSaveProfile ( values ) ; setPageSessionAttribute ( PROPERTY_ATTRIBUTE , ( HashMap ) values ) ; G11NCharsetAliasEditViewBean vb = ( G11NCharsetAliasEditViewBean ) getViewBean ( G11NCharsetAliasEditViewBean . class ) ; unlockPageTrail ( ) ; passPgSessionMap ( vb ) ; vb . populateValues ( ( String ) getDisplayFieldValue ( STR_ ) ) ; vb . forwardTo ( getRequestContext ( ) ) ; } catch ( AMConsoleException e ) { setInlineAlertMessage ( CCAlert . TYPE_ERROR , STR_ , e . getMessage ( ) ) ; } }
public BooleanGlassGeneIm ( BooleanGlassGenePm genePm , Parameters parameters ) { try { this . genePm = genePm ; this . glassFunction = new BooleanGlassFunction ( genePm . getLagGraph ( ) ) ; this . initializer = new BasalInitializer ( glassFunction , NUM_ , NUM_ ) ; this . history = new GeneHistory ( initializer , glassFunction ) ; this . simulator = new MeasurementSimulatorParams ( parameters ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
protected List < ITEM_TYPE > selectFoldTrainItems ( List < ITEM_TYPE > items , int nFolds , int fold ) { List < ITEM_TYPE > trainItems = new ArrayList < ITEM_TYPE > ( ) ; for ( int i = NUM_ ; i < items . size ( ) ; ++ i ) { if ( i % nFolds != fold ) { trainItems . add ( items . get ( i ) ) ; } } return trainItems ; }
private boolean journalRebuildRequired ( ) { final int redundantOpCompactThreshold = NUM_ ; return redundantOpCount >= redundantOpCompactThreshold && redundantOpCount >= lruEntries . size ( ) ; }
protected void rehash ( int newCapacity ) { int oldCapacity = _set . length ; K oldKeys [ ] = ( K [ ] ) _set ; short oldVals [ ] = _values ; _set = new Object [ newCapacity ] ; Arrays . fill ( _set , FREE ) ; _values = new short [ newCapacity ] ; for ( int i = oldCapacity ; i -- > NUM_ ; ) { if ( oldKeys [ i ] != FREE && oldKeys [ i ] != REMOVED ) { K o = oldKeys [ i ] ; int index = insertionIndex ( o ) ; if ( index < NUM_ ) { throwObjectContractViolation ( _set [ ( - index - NUM_ ) ] , o ) ; } _set [ index ] = o ; _values [ index ] = oldVals [ i ] ; } } }
protected void addAttributes ( Element element , Attributes attributes ) { boolean noNamespaceAttributes = BOOL_ ; if ( element instanceof AbstractElement ) { AbstractElement baseElement = ( AbstractElement ) element ; baseElement . setAttributes ( attributes , namespaceStack , noNamespaceAttributes ) ; } else { int size = attributes . getLength ( ) ; for ( int i = NUM_ ; i < size ; i ++ ) { String attributeQName = attributes . getQName ( i ) ; if ( noNamespaceAttributes || ! attributeQName . startsWith ( STR_ ) ) { String attributeURI = attributes . getURI ( i ) ; String attributeLocalName = attributes . getLocalName ( i ) ; String attributeValue = attributes . getValue ( i ) ; QName qName = namespaceStack . getAttributeQName ( attributeURI , attributeLocalName , attributeQName ) ; element . addAttribute ( qName , attributeValue ) ; } } } }
public static < T > boolean remove ( Collection < T > collection , T element ) { if ( element == null ) { return BOOL_ ; } if ( CollectionUtils . isEmpty ( collection ) ) { return BOOL_ ; } return collection . remove ( element ) ; }
private static void persistUpdatedVpoolList ( List < VirtualPool > updatedVpoolList , DbClient dbClient ) { if ( ! updatedVpoolList . isEmpty ( ) ) { dbClient . updateAndReindexObject ( updatedVpoolList ) ; } }
void composeTemplates ( ElemTemplateElement templ ) throws TransformerException { templ . compose ( this ) ; for ( ElemTemplateElement child = templ . getFirstChildElem ( ) ; child != null ; child = child . getNextSiblingElem ( ) ) { composeTemplates ( child ) ; } templ . endCompose ( this ) ; }
public static boolean classExists ( String className ) { try { return Class . forName ( className ) != null ; } catch ( ClassNotFoundException e ) { return BOOL_ ; } }
public static void createTopLevelClassesXML ( String outputDir , String templatesPath , boolean lenient ) throws CompilerException { try { AsDocHelper asDocHelp = new AsDocHelper ( outputDir + STR_ , outputDir + STR_ , outputDir , outputDir + STR_ + File . separator + STR_ ) ; asDocHelp . createTopLevelClasses ( lenient ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; CompilerMessage c = new CouldNotCreate ( STR_ , t . getMessage ( ) ) ; ThreadLocalToolkit . log ( c ) ; throw c ; } }
void drawShape ( Graphics g , CSS . Value type , int ax , int ay , int aw , int ah , float align ) { int gap = isLeftToRight ? - ( bulletgap + NUM_ ) : ( aw + bulletgap ) ; int x = ax + gap ; int y = Math . max ( ay , ay + ( int ) ( align . ah ) - NUM_ ) ; if ( type == CSS . Value . SQUARE ) { g . drawRect ( x , y , NUM_ , NUM_ ) ; } else if ( type == CSS . Value . CIRCLE ) { g . drawOval ( x , y , NUM_ , NUM_ ) ; } else { g . fillOval ( x , y , NUM_ , NUM_ ) ; } }
public static void restore ( final Context context ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( LongTermOrbits . isSupported ( ) && prefs . getBoolean ( KEY_LOCATION_TOGGLE , BOOL_ ) ) { saveDownloadDataWifiOnlyPref ( context ) ; AlarmManager am = ( AlarmManager ) context . getSystemService ( Context . ALARM_SERVICE ) ; Intent intent = new Intent ( context , LtoService . class ) ; PendingIntent pi = PendingIntent . getService ( context , NUM_ , intent , PendingIntent . FLAG_UPDATE_CURRENT | PendingIntent . FLAG_ONE_SHOT ) ; long nextLtoDownload = System . currentTimeMillis ( ) + ( NUM_ . NUM_ . NUM_ ) ; am . set ( AlarmManager . RTC , nextLtoDownload , pi ) ; } }
private void generateFile ( int wordCnt ) throws Exception { Random rnd = new Random ( System . currentTimeMillis ( ) ) ; try ( OutputStreamWriter writer = new OutputStreamWriter ( igfs . create ( FILE , BOOL_ ) ) ) { int cnt = NUM_ ; while ( cnt < wordCnt ) { String word = DICTIONARY [ rnd . nextInt ( DICTIONARY . length ) ] ; writer . write ( word + STR_ ) ; cnt ++ ; } } }
public void polygon ( double [ ] x , double [ ] y ) { int n = x . length ; GeneralPath path = new GeneralPath ( ) ; path . moveTo ( ( float ) scaleX ( x [ NUM_ ] ) , ( float ) scaleY ( y [ NUM_ ] ) ) ; for ( int i = NUM_ ; i < n ; i ++ ) path . lineTo ( ( float ) scaleX ( x [ i ] ) , ( float ) scaleY ( y [ i ] ) ) ; path . closePath ( ) ; offscreen . draw ( path ) ; draw ( ) ; }
public void forceRewriteExif ( String filename , Collection < ExifTag > tags ) throws FileNotFoundException , IOException { if ( ! rewriteExif ( filename , tags ) ) { ExifData tempData = mData ; mData = new ExifData ( DEFAULT_BYTE_ORDER ) ; FileInputStream is = null ; ByteArrayOutputStream bytes = null ; try { is = new FileInputStream ( filename ) ; bytes = new ByteArrayOutputStream ( ) ; doExifStreamIO ( is , bytes ) ; byte [ ] imageBytes = bytes . toByteArray ( ) ; readExif ( imageBytes ) ; setTags ( tags ) ; writeExif ( imageBytes , filename ) ; } catch ( IOException e ) { closeSilently ( is ) ; throw e ; } finally { is . close ( ) ; mData = tempData ; } } }
public void append ( int key , E value ) { if ( mSize != NUM_ && key <= mKeys [ mSize - NUM_ ] ) { put ( key , value ) ; return ; } if ( mGarbage && mSize >= mKeys . length ) { gc ( ) ; } int pos = mSize ; if ( pos >= mKeys . length ) { int n = ContainerHelpers . idealIntArraySize ( pos + NUM_ ) ; int [ ] nkeys = new int [ n ] ; Object [ ] nvalues = new Object [ n ] ; System . arraycopy ( mKeys , NUM_ , nkeys , NUM_ , mKeys . length ) ; System . arraycopy ( mValues , NUM_ , nvalues , NUM_ , mValues . length ) ; mKeys = nkeys ; mValues = nvalues ; } mKeys [ pos ] = key ; mValues [ pos ] = value ; mSize = pos + NUM_ ; }
public void testNegateNegative ( ) { String a = STR_ ; int aScale = NUM_ ; String c = STR_ ; int cScale = NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal cNumber = new BigDecimal ( new BigInteger ( c ) , cScale ) ; assertEquals ( STR_ , cNumber , aNumber . negate ( ) ) ; }
public List < SearchResult > searchByObjectName ( String name ) { List < SearchResult > all = new ArrayList < > ( ) ; for ( Layer layer : layers ) { if ( isLayerVisible ( layer ) ) { all . addAll ( layer . searchByObjectName ( name ) ) ; } } Log . d ( TAG , STR_ + all . size ( ) + STR_ + name ) ; return all ; }
private void clearMessages ( ) { messages . clear ( ) ; }
public Searcher ( ) throws IOException { searcher = new IndexSearcher ( DirectoryReader . open ( FSDirectory . open ( Paths . get ( INDEX_DIR ) ) ) ) ; parser = new QueryParser ( CONTENT_FIELD , new StandardAnalyzer ( ) ) ; }
public void clearTextEdits ( ) { fEdits . clear ( ) ; }
public static void main ( String [ ] args ) { Frame frame = new PacketTool ( ) ; frame . pack ( ) ; frame . setLocationRelativeTo ( null ) ; frame . setVisible ( BOOL_ ) ; }
private void createToolBar ( ) { toolBar = new JToolBar ( STR_ ) ; if ( listener . runningAsJConsolePlugin || listener . runningAsVisualVMPlugin ) { toolBar . add ( createToolBarButton ( STR_ , STR_ ) ) ; toolBar . setFloatable ( BOOL_ ) ; } else { toolBar . add ( createToolBarButton ( STR_ , STR_ ) ) ; closeToolBarButton = createToolBarButton ( STR_ , STR_ ) ; closeToolBarButton . setEnabled ( BOOL_ ) ; toolBar . add ( closeToolBarButton ) ; } toolBar . addSeparator ( ) ; toolBar . add ( createToolBarButton ( STR_ , STR_ ) ) ; toolBar . addSeparator ( ) ; expandButton = createToolBarButton ( STR_ , STR_ ) ; expandButton . setEnabled ( BOOL_ ) ; toolBar . add ( expandButton ) ; collapseButton = createToolBarButton ( STR_ , STR_ ) ; collapseButton . setEnabled ( BOOL_ ) ; toolBar . add ( collapseButton ) ; toolBar . addSeparator ( ) ; findLRThreadsButton = createToolBarButton ( STR_ , STR_ ) ; findLRThreadsButton . setEnabled ( BOOL_ ) ; toolBar . add ( findLRThreadsButton ) ; toolBar . add ( createToolBarButton ( STR_ , STR_ ) ) ; toolBar . add ( createToolBarButton ( STR_ , STR_ ) ) ; toolBar . addSeparator ( ) ; }
public static Map attrSetToMap ( AttrSet attrSet , boolean fetchByteValues ) { Map attributesMap = new AMHashMap ( fetchByteValues ) ; if ( attrSet == null ) { return attributesMap ; } int attrSetSize = attrSet . size ( ) ; if ( ! fetchByteValues ) { for ( int i = NUM_ ; i < attrSetSize ; i ++ ) { Attr attr = attrSet . elementAt ( i ) ; String values [ ] = attr . getStringValues ( ) ; attributesMap . put ( attr . getName ( ) , stringArrayToSet ( values ) ) ; } } else { for ( int i = NUM_ ; i < attrSetSize ; i ++ ) { Attr attr = attrSet . elementAt ( i ) ; attributesMap . put ( attr . getName ( ) , attr . getByteValues ( ) ) ; } } return attributesMap ; }
public final Iterator < String > schemesIterator ( ) { return mDataSchemes != null ? mDataSchemes . iterator ( ) : null ; }
@ Override public void close ( ) throws IOException { try { out . close ( ) ; } finally { lockFile . delete ( ) ; } }
public static void reinitRecompiler ( ) { _rewriter . set ( new ProgramRewriter ( BOOL_ , BOOL_ ) ) ; }
default Value remove ( Optional < ? extends CharSequence > name ) { return name . isPresent ( ) ? remove ( name . get ( ) ) : null ; }
private String nextToInternal ( String excluded ) { int start = pos ; for ( ; pos < in . length ( ) ; pos ++ ) { char c = in . charAt ( pos ) ; if ( c == STR_ || c == STR_ || excluded . indexOf ( c ) != - NUM_ ) { return in . substring ( start , pos ) ; } } return in . substring ( start ) ; }
AcceptTcp ( PortTcp port , ServerSocketBar serverSocket ) { Objects . requireNonNull ( port ) ; Objects . requireNonNull ( serverSocket ) ; _port = port ; _serverSocket = serverSocket ; }
private static void updateGrabbedCursor ( Cursor cur ) { XBaseWindow target = XAwtState . getGrabWindow ( ) ; if ( target instanceof XWindowPeer ) { XWindowPeer grabber = ( XWindowPeer ) target ; grabber . pSetCursor ( cur ) ; } }
protected void parseURI ( String uriString ) throws URISyntaxException { String s = uriString ; int index = s . indexOf ( FRAGMENT_SEPARATOR ) ; if ( index != - NUM_ ) { setFragment ( s . substring ( index + NUM_ ) , BOOL_ ) ; s = s . substring ( NUM_ , index ) ; } index = s . indexOf ( SCHEME_SEPARATOR ) ; if ( index != - NUM_ ) { String scheme = s . substring ( NUM_ , index ) ; if ( isValidScheme ( scheme ) ) { setScheme ( scheme ) ; s = s . substring ( index + NUM_ ) ; } } parseSchemeSpecificPart ( s , BOOL_ ) ; }
@ Override public boolean equals ( Object obj ) { if ( ( obj instanceof KeepAliveKey ) == BOOL_ ) return BOOL_ ; KeepAliveKey kae = ( KeepAliveKey ) obj ; return host . equals ( kae . host ) && ( port == kae . port ) && protocol . equals ( kae . protocol ) && this . obj == kae . obj ; }
protected static void appendLongStringType ( StringBuilder sb ) { sb . append ( STR_ ) ; }
public void testConnectHeadset ( ) { int iterations = BluetoothTestRunner . sConnectHeadsetIterations ; if ( iterations == NUM_ ) { return ; } BluetoothAdapter adapter = BluetoothAdapter . getDefaultAdapter ( ) ; BluetoothDevice device = adapter . getRemoteDevice ( BluetoothTestRunner . sDeviceAddress ) ; mTestUtils . disable ( adapter ) ; mTestUtils . enable ( adapter ) ; mTestUtils . unpair ( adapter , device ) ; mTestUtils . pair ( adapter , device , BluetoothTestRunner . sDevicePairPasskey , BluetoothTestRunner . sDevicePairPin ) ; mTestUtils . disconnectProfile ( adapter , device , BluetoothProfile . HEADSET , null ) ; for ( int i = NUM_ ; i < iterations ; i ++ ) { mTestUtils . writeOutput ( STR_ + ( i + NUM_ ) + STR_ + iterations ) ; mTestUtils . connectProfile ( adapter , device , BluetoothProfile . HEADSET , String . format ( STR_ , device ) ) ; mTestUtils . disconnectProfile ( adapter , device , BluetoothProfile . HEADSET , String . format ( STR_ , device ) ) ; } mTestUtils . unpair ( adapter , device ) ; mTestUtils . disable ( adapter ) ; }
public static boolean isNA ( String [ ] NAstrings , String w ) { if ( NAstrings == null ) return BOOL_ ; for ( String na : NAstrings ) { if ( w . equals ( na ) ) return BOOL_ ; } return BOOL_ ; }
private double [ ] evaluateProbability ( double [ ] data ) { double [ ] prob = new double [ m_NumClasses ] , v = new double [ m_NumClasses ] ; for ( int j = NUM_ ; j < m_NumClasses - NUM_ ; j ++ ) { for ( int k = NUM_ ; k <= m_NumPredictors ; k ++ ) { v [ j ] += m_Par [ k ] [ j ] . data [ k ] ; } } v [ m_NumClasses - NUM_ ] = NUM_ ; for ( int m = NUM_ ; m < m_NumClasses ; m ++ ) { double sum = NUM_ ; for ( int n = NUM_ ; n < m_NumClasses - NUM_ ; n ++ ) { sum += Math . exp ( v [ n ] - v [ m ] ) ; } prob [ m ] = NUM_ / ( sum + Math . exp ( - v [ m ] ) ) ; } return prob ; }
public static final HashMap readMapXml ( InputStream in ) throws XmlPullParserException , IOException { XmlPullParser parser = Xml . newPullParser ( ) ; parser . setInput ( in , null ) ; return ( HashMap ) readValueXml ( parser , new String [ NUM_ ] ) ; }
int nextNode ( String sStr , int i ) { int nBraces = NUM_ ; char c = sStr . charAt ( i ) ; do { i ++ ; if ( i < sStr . length ( ) ) { c = sStr . charAt ( i ) ; if ( c == STR_ ) { while ( i < sStr . length ( ) && sStr . charAt ( i ) != STR_ ) { i ++ ; } i ++ ; if ( i < sStr . length ( ) ) { c = sStr . charAt ( i ) ; } } switch ( c ) { case STR_ : nBraces ++ ; break ; case STR_ : nBraces -- ; break ; default : break ; } } } while ( i < sStr . length ( ) && ( nBraces > NUM_ || ( c != STR_ && c != STR_ && c != STR_ ) ) ) ; if ( i >= sStr . length ( ) || nBraces < NUM_ ) { return - NUM_ ; } else if ( sStr . charAt ( i ) == STR_ ) { i ++ ; if ( sStr . charAt ( i ) == STR_ ) { while ( i < sStr . length ( ) && sStr . charAt ( i ) != STR_ ) { i ++ ; } i ++ ; if ( i >= sStr . length ( ) ) { return - NUM_ ; } } if ( sStr . charAt ( i ) == STR_ ) { i ++ ; c = sStr . charAt ( i ) ; while ( i < sStr . length ( ) && ( c == STR_ || Character . isDigit ( c ) ) ) { i ++ ; if ( i < sStr . length ( ) ) { c = sStr . charAt ( i ) ; } } } } return i ; }
public boolean selectNode ( D nodeData , SignalEvent event ) { if ( selectedNodes . isEmpty ( ) ) { insertAndSelectNode ( nodeData , NUM_ , BOOL_ ) ; return BOOL_ ; } if ( ! hasSameParent ( selectedNodes . get ( NUM_ ) , nodeData ) ) { if ( ! this . multilevelSelection || event . getShiftKey ( ) ) { return selectSingleNode ( nodeData ) ; } } if ( event == null || event . getCommandKey ( ) ) { ctrlSelect ( nodeData ) ; return BOOL_ ; } else { if ( event . getShiftKey ( ) ) { return shiftSelect ( nodeData ) ; } } return selectSingleNode ( nodeData ) ; }
@ Override public int [ ] sequenceLengths ( final long start , final long end ) throws IOException { final int entrySize = mIndex . getVersion ( ) >= IndexFile . PER_SEQUENCE_CHECKSUM_VERSION ? ( mIndex . hasQuality ( ) ? NUM_ : NUM_ ) : NUM_ ; final long internalStart = start + mStart ; final long internalEnd = end + mStart ; final int [ ] ret = new int [ ( int ) ( internalEnd - internalStart ) ] ; if ( ret . length == NUM_ ) { return ret ; } if ( mIndex . getMaxLength ( ) == mIndex . getMinLength ( ) ) { Arrays . fill ( ret , ( int ) mIndex . getMaxLength ( ) ) ; return ret ; } final byte [ ] buffer = new byte [ entrySize . NUM_ ] ; final DataFileIndex dataIndex = mSequenceManager . sequenceIndex ( ) ; final long [ ] numSequences = new long [ dataIndex . numberEntries ( ) ] ; int startFileNo = - NUM_ ; int endFileNo = - NUM_ ; for ( int i = NUM_ ; i < numSequences . length ; i ++ ) { if ( i > NUM_ ) { numSequences [ i ] = numSequences [ i - NUM_ ] + dataIndex . numberSequences ( i ) ; } else { numSequences [ NUM_ ] = dataIndex . numberSequences ( NUM_ ) ; } if ( internalStart < numSequences [ i ] ) { if ( startFileNo == - NUM_ ) { startFileNo = i ; } if ( internalEnd < numSequences [ i ] ) { endFileNo = i ; break ; } } } final long startLower = startFileNo == NUM_ ? NUM_ : numSequences [ startFileNo - NUM_ ] ; final long endLower = endFileNo < NUM_ ? NUM_ : numSequences [ endFileNo - NUM_ ] ; int seqNo = NUM_ ; for ( int i = startFileNo ; ( endFileNo == - NUM_ || i <= endFileNo ) && i < numSequences . length ; i ++ ) { try ( RandomAccessFile raf = new RandomAccessFile ( SdfFileUtils . sequencePointerFile ( mDirectory , i ) , STR_ ) ) { final long pos ; if ( i == startFileNo ) { pos = ( internalStart - startLower ) . entrySize ; raf . seek ( pos ) ; } else { pos = NUM_ ; } final long endPos = endFileNo == i ? ( internalEnd - endLower ) . entrySize : raf . length ( ) ; seqNo = sequenceLengthsHelper ( raf , buffer , ret , seqNo , pos , endPos , entrySize ) ; if ( endFileNo != i && seqNo > NUM_ ) { final long fileLength = dataIndex . dataSize ( i ) ; ret [ seqNo - NUM_ ] = ret [ seqNo - NUM_ ] - ( int ) fileLength ; } else { if ( seqNo != ret . length ) { throw new CorruptSdfException ( STR_ + ret . length + STR_ + seqNo ) ; } raf . read ( ) ; ret [ seqNo - NUM_ ] -= raf . readInt ( ) ; } } } ret [ ret . length - NUM_ ] = NUM_ - ret [ ret . length - NUM_ ] ; return ret ; }
public Observable < DriveId > createFile ( DriveFolder folder , File file , String title ) { return createFile ( folder , file , title , MimeTypeMap . getFileExtensionFromUrl ( file . getPath ( ) ) ) ; }
public static String extractCollectionFromPath ( String path ) { String extractedCollectionName = null ; String pathModified = removeFromEndOfString ( path , SLASH ) ; String [ ] pathSegments = pathModified . split ( STR_ ) ; if ( pathSegments . length > NUM_ ) { extractedCollectionName = pathSegments [ pathSegments . length - NUM_ ] ; } return extractedCollectionName ; }
public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( NUM_ ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
public boolean isPrivate ( ) { return Modifier . isPrivate ( _field . getModifiers ( ) ) ; }
@ Override public void onSuccess ( T result ) { try { LOGGER . debug ( STR_ , result ) ; queue . put ( result ) ; } catch ( InterruptedException e ) { LOGGER . warn ( STR_ , e ) ; } }
public void handleTblProviderResourceIdMapperButtonAddRequest ( RequestInvocationEvent event ) throws ModelControlException { try { Map values = getValues ( ) ; onBeforeSaveProfile ( values ) ; setPageSessionAttribute ( PROPERTY_ATTRIBUTE , ( HashMap ) values ) ; SMDiscoveryProviderResourceIdMapperAddViewBean vb = ( SMDiscoveryProviderResourceIdMapperAddViewBean ) getViewBean ( SMDiscoveryProviderResourceIdMapperAddViewBean . class ) ; removePageSessionAttribute ( SMDiscoveryProviderResourceIdMapperAddViewBean . PROPERTY_ATTRIBUTE ) ; unlockPageTrail ( ) ; passPgSessionMap ( vb ) ; vb . forwardTo ( getRequestContext ( ) ) ; } catch ( AMConsoleException e ) { setInlineAlertMessage ( CCAlert . TYPE_ERROR , STR_ , e . getMessage ( ) ) ; } }
public COpenOriginalFunction ( final CGraphWindow parent , final IViewContainer container , final INaviFunction function ) { super ( String . format ( STR_ , function . getName ( ) ) ) ; m_parent = parent ; m_container = container ; m_function = function ; }
public int read ( char [ ] buffer , int offset , int length ) throws IOException { byte [ ] bytes = new byte [ length ] ; int count = _file . read ( bytes , NUM_ , length ) ; for ( int i = NUM_ ; i < count ; i ++ ) { buffer [ offset + i ] = ( char ) bytes [ i ] ; } return count ; }
public boolean equals ( Object o ) { if ( ! ( o instanceof Vector2f ) ) { return BOOL_ ; } if ( this == o ) { return BOOL_ ; } Vector2f comp = ( Vector2f ) o ; if ( Float . compare ( x , comp . x ) != NUM_ ) { return BOOL_ ; } if ( Float . compare ( y , comp . y ) != NUM_ ) { return BOOL_ ; } return BOOL_ ; }
@ Override protected EClass findInstantiableCompatible ( EClass eType ) { if ( ! isInstantiatableSubType ( eType , eType ) ) { throw new IllegalStateException ( String . valueOf ( eType ) ) ; } return eType ; }
private int measureWidth ( int measureSpec ) { int result = NUM_ ; int specMode = MeasureSpec . getMode ( measureSpec ) ; int specSize = MeasureSpec . getSize ( measureSpec ) ; if ( specMode == MeasureSpec . EXACTLY ) { result = specSize ; } else { result = IMAGE_WIDTH + MAX_TEXT_WIDTH + TOAST_HEIGHT ; if ( specMode == MeasureSpec . AT_MOST ) { result = Math . min ( result , specSize ) ; } } return result ; }
public void restoreTopology ( Iterable < TcpDiscoveryNode > nodes , long topVer ) { assert ! F . isEmpty ( nodes ) ; assert topVer > NUM_ ; rwLock . writeLock ( ) . lock ( ) ; try { locNode . internalOrder ( topVer ) ; clear ( ) ; boolean firstAdd = BOOL_ ; for ( TcpDiscoveryNode node : nodes ) { if ( nodesMap . containsKey ( node . id ( ) ) ) continue ; nodesMap . put ( node . id ( ) , node ) ; if ( firstAdd ) { this . nodes = new TreeSet < > ( this . nodes ) ; firstAdd = BOOL_ ; } node . lastUpdateTime ( U . currentTimeMillis ( ) ) ; this . nodes . add ( node ) ; } nodeOrder = topVer ; initializeMinimumVersion ( ) ; } finally { rwLock . writeLock ( ) . unlock ( ) ; } }
final protected void startOp ( final IStartOpMessage msg ) { if ( ! controller ) throw new UnsupportedOperationException ( ERR_NOT_CONTROLLER ) ; if ( msg == null ) throw new IllegalArgumentException ( ) ; if ( ! queryId . equals ( msg . getQueryId ( ) ) ) throw new IllegalArgumentException ( ) ; lock . lock ( ) ; try { if ( log . isTraceEnabled ( ) ) log . trace ( msg . toString ( ) ) ; if ( future . isDone ( ) ) throw new RuntimeException ( STR_ ) ; runState . startOp ( msg ) ; } catch ( TimeoutException ex ) { halt ( ex ) ; } finally { lock . unlock ( ) ; } }
public Flux < IN > drain ( ) { return Flux . empty ( ) ; }
int traverseConsistencyCheck ( TextEditProcessor processor , Document document , List < List < TextEdit > > sourceEdits ) { int result = NUM_ ; if ( fChildren != null ) { for ( int i = fChildren . size ( ) - NUM_ ; i >= NUM_ ; i -- ) { TextEdit child = ( TextEdit ) fChildren . get ( i ) ; result = Math . max ( result , child . traverseConsistencyCheck ( processor , document , sourceEdits ) ) ; } } if ( processor . considerEdit ( this ) ) { performConsistencyCheck ( processor , document ) ; } return result ; }
public Minute ( Date time , TimeZone zone ) { this ( time , zone , Locale . getDefault ( ) ) ; }
private Plan buildPlan1 ( ) { Plan plan = PopulationUtils . createPlan ( ) ; Activity a = PopulationUtils . createActivityFromCoord ( STR_ , CoordUtils . createCoord ( NUM_ , NUM_ ) ) ; a . setEndTime ( Time . parseTime ( STR_ ) ) ; plan . addActivity ( a ) ; plan . addLeg ( PopulationUtils . createLeg ( STR_ ) ) ; double travelTime = Time . parseTime ( STR_ ) ; double distance = Math . round ( ( travelTime . ChainChopper . AVERAGE_SPEED ) / ChainChopper . CROWFLY_FACTOR ) ; Activity b = PopulationUtils . createActivityFromCoord ( STR_ , CoordUtils . createCoord ( distance , NUM_ ) ) ; plan . addActivity ( b ) ; return plan ; }
protected void encodeAtom ( OutputStream outStream , byte data [ ] , int offset , int len ) throws IOException { byte a , b = NUM_ , c = NUM_ ; int c1 , c2 , c3 , c4 ; a = data [ offset ] ; if ( len > NUM_ ) { b = data [ offset + NUM_ ] ; } if ( len > NUM_ ) { c = data [ offset + NUM_ ] ; } c1 = ( a > > > NUM_ ) & x3f ; c2 = ( ( a << NUM_ ) & x30 ) | ( ( b > > > NUM_ ) & xf ) ; c3 = ( ( b << NUM_ ) & x3c ) | ( ( c > > > NUM_ ) & x3 ) ; c4 = c & x3f ; outStream . write ( c1 + STR_ ) ; outStream . write ( c2 + STR_ ) ; outStream . write ( c3 + STR_ ) ; outStream . write ( c4 + STR_ ) ; return ; }
public void test_unwrap_ByteBuffer_ByteBuffer_05 ( ) { String host = STR_ ; int port = NUM_ ; ByteBuffer bbs = ByteBuffer . allocate ( NUM_ ) ; ByteBuffer bbd = ByteBuffer . allocate ( NUM_ ) ; SSLEngine sse = getEngine ( host , port ) ; sse . setUseClientMode ( BOOL_ ) ; try { SSLEngineResult res = sse . unwrap ( bbs , bbd ) ; assertEquals ( NUM_ , res . bytesConsumed ( ) ) ; assertEquals ( NUM_ , res . bytesProduced ( ) ) ; } catch ( Exception e ) { fail ( STR_ + e ) ; } }
private int adjustAlpha ( int color , float factor ) { int alpha = Math . round ( Color . alpha ( color ) . factor ) ; int red = Color . red ( color ) ; int green = Color . green ( color ) ; int blue = Color . blue ( color ) ; return Color . argb ( alpha , red , green , blue ) ; }
private void initializeRatioSlider ( ) { ratioSlider . setMajorTickSpacing ( NUM_ ) ; ratioSlider . setMinorTickSpacing ( NUM_ ) ; ratioSlider . setPaintTicks ( BOOL_ ) ; Hashtable < Integer , JLabel > labelTable = new Hashtable < Integer , JLabel > ( ) ; labelTable . put ( new Integer ( NUM_ ) , new JLabel ( STR_ ) ) ; labelTable . put ( new Integer ( NUM_ ) , new JLabel ( STR_ ) ) ; labelTable . put ( new Integer ( NUM_ ) , new JLabel ( STR_ ) ) ; labelTable . put ( new Integer ( NUM_ ) , new JLabel ( STR_ ) ) ; labelTable . put ( new Integer ( NUM_ ) , new JLabel ( STR_ ) ) ; ratioSlider . setLabelTable ( labelTable ) ; ratioSlider . setPaintLabels ( BOOL_ ) ; }
private static void initializeSettings ( Settings . Builder output , Settings input , boolean loadDefaults ) { output . put ( input ) ; if ( useSystemProperties ( input ) ) { if ( loadDefaults ) { for ( String prefix : PROPERTY_DEFAULTS_PREFIXES ) { output . putProperties ( prefix , System . getProperties ( ) ) ; } } for ( String prefix : PROPERTY_PREFIXES ) { output . putProperties ( prefix , System . getProperties ( ) , PROPERTY_DEFAULTS_PREFIXES ) ; } } output . replacePropertyPlaceholders ( ) ; }
@ Override public void drawOval ( int x , int y , int width , int height ) { setStateToLocal ( ) ; m_printstream . println ( xTransform ( xScale ( x ) ) + STR_ + yTransform ( yScale ( y ) ) + STR_ + xScale ( width ) + STR_ + yScale ( height ) + STR_ ) ; }
public String toString ( int indentFactor ) throws JSONException { return toString ( indentFactor , NUM_ ) ; }
private void validateSQLFields ( ) { boolean flag = controller . isEnableSQLDatabaseOutput ( ) ; enableSQLDatabaseConnection . setSelected ( flag ) ; sqlHostLabel . setEnabled ( flag ) ; sqlHostField . setEnabled ( flag ) ; sqlDatabaseLabel . setEnabled ( flag ) ; sqlDatabaseField . setEnabled ( flag ) ; sqlUserLabel . setEnabled ( flag ) ; sqlUserField . setEnabled ( flag ) ; sqlPasswordLabel . setEnabled ( flag ) ; sqlPasswordField . setEnabled ( flag ) ; enableZipEncodingCheckBox . setEnabled ( flag ) ; }
public void readFromObject ( Object object ) { try { Method method = BeanUtils . getReadMethod ( object . getClass ( ) , getName ( ) ) ; if ( method != null ) { Object value = method . invoke ( object , null ) ; initializeValue ( value ) ; if ( value != null ) { for ( Iterator iter = subProperties . iterator ( ) ; iter . hasNext ( ) ; ) { Property subProperty = ( Property ) iter . next ( ) ; subProperty . readFromObject ( value ) ; } } } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
private boolean internalOfferTask ( AFrameTask task ) { synchronized ( mFrameTaskQueue ) { return mFrameTaskQueue . offer ( task ) ; } }
public void startDTD ( String name , String publicId , String systemId ) throws org . xml . sax . SAXException { }
public static String toString ( ByteBuffer bb ) { byte [ ] bytes = new byte [ bb . getInt ( ) ] ; String s = STR_ ; try { if ( ArrayUtils . isNotEmpty ( bytes ) ) { bb . get ( bytes ) ; s = new String ( bytes , UTF8 ) ; } } catch ( Exception e ) { throw new RuntimeException ( STR_ + STR_ , e ) ; } return s ; }
public static boolean validImage ( Image image ) { return ( image != null && image . getWidth ( null ) > NUM_ && image . getHeight ( null ) > NUM_ ) ; }
protected void ping ( InetAddress address ) throws Exception { Socket socket = null ; int ping = NUM_ ; for ( ; ; ) { if ( isDebug ( ) ) { log ( STR_ + ping + STR_ + getMaxPings ( ) + STR_ + address + STR_ + getPort ( ) ) ; } try { socket = new Socket ( address , getPort ( ) ) ; break ; } catch ( ConnectException ce ) { log ( STR_ + ping + STR_ + getMaxPings ( ) + STR_ + ce . toString ( ) + STR_ + address + STR_ + getPort ( ) ) ; ping ++ ; if ( ping <= getMaxPings ( ) ) { log ( STR_ + getPingIntervalMilli ( ) + STR_ ) ; Thread . sleep ( getPingIntervalMilli ( ) ) ; } else { break ; } } } if ( socket == null ) { throw new ConnectException ( STR_ + getMaxPings ( ) + STR_ ) ; } try { BufferedReader reader = new BufferedReader ( new InputStreamReader ( socket . getInputStream ( ) , STR_ ) ) ; PrintWriter writer = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( socket . getOutputStream ( ) ) ) , BOOL_ ) ; log ( STR_ + address + STR_ ) ; writer . println ( STR_ ) ; writer . flush ( ) ; boolean pongReceived = BOOL_ ; for ( ; ; ) { String answer = reader . readLine ( ) ; if ( answer != null ) { answer = answer . trim ( ) ; log ( STR_ + answer + STR_ ) ; answer = answer . trim ( ) ; if ( answer . equals ( STR_ ) ) { pongReceived = BOOL_ ; } } else { break ; } } reader . close ( ) ; writer . close ( ) ; if ( ! pongReceived ) { throw new ConnectException ( STR_ ) ; } } finally { socket . close ( ) ; } }
private ImageSize computeSizeToFit ( float maxSide ) { if ( NUM_ == maxSide ) { return new ImageSize ( NUM_ , NUM_ ) ; } ImageSize resized = new ImageSize ( this ) ; if ( ( this . mWidth > maxSide ) || ( this . mHeight > maxSide ) ) { double ratioX = maxSide / this . mWidth ; double ratioY = maxSide / this . mHeight ; double scale = Math . min ( ratioX , ratioY ) ; scale = NUM_ / Integer . highestOneBit ( ( int ) Math . floor ( NUM_ / scale ) ) ; resized . mWidth = ( int ) ( Math . floor ( resized . mWidth . scale / NUM_ ) . NUM_ ) ; resized . mHeight = ( int ) ( Math . floor ( resized . mHeight . scale / NUM_ ) . NUM_ ) ; } return resized ; }
public static List < BigInteger > embeddedSelectorToPartitions ( String selector , String type , DataPartitioner partitioner ) throws PIRException { List < BigInteger > parts ; int partitionBits = partitioner . getBits ( type ) ; if ( partitionBits > NUM_ ) { int hashedSelector = KeyedHash . hash ( STR_ , NUM_ , selector , STR_ ) ; parts = partitioner . toPartitions ( hashedSelector , PrimitiveTypePartitioner . INT ) ; } else { parts = partitioner . toPartitions ( selector , type ) ; } return parts ; }
public static double stddevp ( double [ ] a , int lo , int hi ) { return Math . sqrt ( varp ( a , lo , hi ) ) ; }
public Java2TypeScriptTranslator ( TranspilationHandler logHandler , JSweetContext context , JCCompilationUnit compilationUnit , boolean preserveSourceLineNumbers ) { super ( logHandler , context , compilationUnit , new Java2TypeScriptAdapter ( context ) , preserveSourceLineNumbers ) ; }
@ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { int count = getChildCount ( ) ; mLeftWidth = NUM_ ; mRightWidth = NUM_ ; int maxHeight = NUM_ ; int maxWidth = NUM_ ; int childState = NUM_ ; for ( int i = NUM_ ; i < count ; i ++ ) { final View child = getChildAt ( i ) ; if ( child . getVisibility ( ) != GONE ) { measureChildWithMargins ( child , widthMeasureSpec , NUM_ , heightMeasureSpec , NUM_ ) ; final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; if ( lp . position == LayoutParams . POSITION_LEFT ) { mLeftWidth += Math . max ( maxWidth , child . getMeasuredWidth ( ) + lp . leftMargin + lp . rightMargin ) ; } else if ( lp . position == LayoutParams . POSITION_RIGHT ) { mRightWidth += Math . max ( maxWidth , child . getMeasuredWidth ( ) + lp . leftMargin + lp . rightMargin ) ; } else { maxWidth = Math . max ( maxWidth , child . getMeasuredWidth ( ) + lp . leftMargin + lp . rightMargin ) ; } maxHeight = Math . max ( maxHeight , child . getMeasuredHeight ( ) + lp . topMargin + lp . bottomMargin ) ; childState = combineMeasuredStates ( childState , child . getMeasuredState ( ) ) ; } } maxWidth += mLeftWidth + mRightWidth ; maxHeight = Math . max ( maxHeight , getSuggestedMinimumHeight ( ) ) ; maxWidth = Math . max ( maxWidth , getSuggestedMinimumWidth ( ) ) ; setMeasuredDimension ( resolveSizeAndState ( maxWidth , widthMeasureSpec , childState ) , resolveSizeAndState ( maxHeight , heightMeasureSpec , childState << MEASURED_HEIGHT_STATE_SHIFT ) ) ; }
protected int exec ( String command , StringList args ) { try { print ( command ) ; StringList cmd = new StringList ( ) ; cmd = cmd . plus ( command ) ; if ( args != null ) { for ( String a : args ) { print ( STR_ + a ) ; } cmd . addAll ( args ) ; } println ( STR_ ) ; ProcessBuilder pb = new ProcessBuilder ( ) ; pb . command ( cmd . array ( ) ) ; pb . redirectErrorStream ( BOOL_ ) ; Process p = pb . start ( ) ; copyInThread ( p . getInputStream ( ) , quiet ? null : sysOut ) ; p . waitFor ( ) ; return p . exitValue ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
@ Ignore @ Test public void testGatewaySenderEventListenerInvocationWithoutLocator ( ) { int mPort = AvailablePortHelper . getRandomAvailablePortForDUnitSite ( ) ; vm4 . invoke ( null ) ; vm5 . invoke ( null ) ; vm6 . invoke ( null ) ; vm7 . invoke ( null ) ; vm4 . invoke ( null ) ; vm5 . invoke ( null ) ; startSenderInVMs ( STR_ , vm4 , vm5 ) ; vm4 . invoke ( null ) ; vm5 . invoke ( null ) ; vm6 . invoke ( null ) ; vm7 . invoke ( null ) ; final Map keyValues = new HashMap ( ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { keyValues . put ( i , i ) ; } vm4 . invoke ( null ) ; vm4 . invoke ( null ) ; vm5 . invoke ( null ) ; vm4 . invoke ( null ) ; vm5 . invoke ( null ) ; fail ( STR_ ) ; }
protected ApplicationUser buildUser ( Map < String , String > headerMap , boolean includeRoles ) { LOGGER . debug ( STR_ ) ; Map < String , String > headerNames = getHeaderNames ( ) ; ApplicationUser applicationUser = createNewApplicationUser ( ) ; buildUserId ( applicationUser , headerMap , headerNames . get ( HTTP_HEADER_USER_ID ) ) ; buildFirstName ( applicationUser , headerMap , headerNames . get ( HTTP_HEADER_FIRST_NAME ) ) ; buildLastName ( applicationUser , headerMap , headerNames . get ( HTTP_HEADER_LAST_NAME ) ) ; buildEmail ( applicationUser , headerMap , headerNames . get ( HTTP_HEADER_EMAIL ) ) ; buildSessionId ( applicationUser , headerMap , HTTP_HEADER_SESSION_ID ) ; buildSessionInitTime ( applicationUser , headerMap , headerNames . get ( HTTP_HEADER_SESSION_INIT_TIME ) ) ; userNamespaceAuthorizationHelper . buildNamespaceAuthorizations ( applicationUser ) ; if ( includeRoles ) { buildRoles ( applicationUser , headerMap , headerNames . get ( HTTP_HEADER_ROLES ) ) ; } LOGGER . debug ( STR_ + applicationUser ) ; return applicationUser ; }
@ Interruptible public static void harnessEnd ( ) { Stats . stopAll ( ) ; insideHarness = BOOL_ ; }
private Cluster < SubspaceModel > runFastDOC ( Database database , Relation < V > relation , ArrayModifiableDBIDs S , int d , int n , int m , int r ) { long [ ] D = null ; DBIDVar dV = DBIDUtil . newVar ( ) ; FiniteProgress iprogress = LOG . isVerbose ( ) ? new FiniteProgress ( STR_ , m . n , LOG ) : null ; Random random = rnd . getSingleThreadedRandom ( ) ; DBIDArrayIter iter = S . iter ( ) ; outer : for ( int i = NUM_ ; i < n ; ++ i ) { iter . seek ( random . nextInt ( S . size ( ) ) ) ; for ( int j = NUM_ ; j < m ; ++ j ) { DBIDs randomSet = DBIDUtil . randomSample ( S , r , random ) ; long [ ] nD = BitsUtil . zero ( d ) ; for ( int k = NUM_ ; k < d ; ++ k ) { if ( dimensionIsRelevant ( k , relation , randomSet ) ) { BitsUtil . setI ( nD , k ) ; } } if ( D == null || BitsUtil . cardinality ( nD ) > BitsUtil . cardinality ( D ) ) { D = nD ; dV . set ( iter ) ; if ( BitsUtil . cardinality ( D ) >= d_zero ) { if ( iprogress != null ) { iprogress . setProcessed ( iprogress . getTotal ( ) , LOG ) ; } break outer ; } } LOG . incrementProcessed ( iprogress ) ; } } LOG . ensureCompleted ( iprogress ) ; if ( D == null || BitsUtil . cardinality ( D ) == NUM_ ) { return null ; } SubspaceMaximumDistanceFunction df = new SubspaceMaximumDistanceFunction ( D ) ; DistanceQuery < V > dq = database . getDistanceQuery ( relation , df ) ; RangeQuery < V > rq = database . getRangeQuery ( dq , DatabaseQuery . HINT_SINGLE ) ; DBIDs C = DBIDUtil . intersection ( S , rq . getRangeForDBID ( dV , w ) ) ; return ( C . size ( ) > NUM_ ) ? makeCluster ( relation , C , D ) : null ; }
public RaceGUI ( String appName ) { UIManager . put ( STR_ , Boolean . FALSE ) ; JFrame f = new JFrame ( appName ) ; f . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; f . setLayout ( new BorderLayout ( ) ) ; track = new TrackView ( ) ; f . add ( track , BorderLayout . CENTER ) ; controlPanel = new RaceControlPanel ( ) ; f . add ( controlPanel , BorderLayout . SOUTH ) ; f . pack ( ) ; f . setVisible ( BOOL_ ) ; }
public static Iterable < String > toHexStrings ( Iterable < ByteArray > arrays ) { ArrayList < String > ret = new ArrayList < String > ( ) ; for ( ByteArray array : arrays ) ret . add ( HexString . toHexString ( array . get ( ) ) ) ; return ret ; }
public static List < GeoTimeSerie > partitionAndApply ( Object function , WarpScriptStack stack , Macro validator , Collection < String > bylabels , List < GeoTimeSerie > ... series ) throws WarpScriptException { Map < Map < String , String > , List < GeoTimeSerie > > unflattened = partitionAndApplyUnflattened ( function , stack , validator , bylabels , series ) ; List < GeoTimeSerie > results = new ArrayList < GeoTimeSerie > ( ) ; for ( List < GeoTimeSerie > l : unflattened . values ( ) ) { results . addAll ( l ) ; } return results ; }
final WorkQueue registerWorker ( ForkJoinWorkerThread wt ) { Thread . UncaughtExceptionHandler handler ; WorkQueue [ ] ws ; int s , ps ; wt . setDaemon ( BOOL_ ) ; if ( ( handler = ueh ) != null ) wt . setUncaughtExceptionHandler ( handler ) ; do { } while ( ! U . compareAndSwapInt ( this , INDEXSEED , s = indexSeed , s += SEED_INCREMENT ) || s == NUM_ ) ; WorkQueue w = new WorkQueue ( this , wt , config > > > NUM_ , s ) ; if ( ( ( ps = plock ) & PL_LOCK ) != NUM_ || ! U . compareAndSwapInt ( this , PLOCK , ps , ps += PL_LOCK ) ) ps = acquirePlock ( ) ; int nps = ( ps & SHUTDOWN ) | ( ( ps + PL_LOCK ) & ~ SHUTDOWN ) ; try { if ( ( ws = workQueues ) != null ) { int n = ws . length , m = n - NUM_ ; int r = ( s << NUM_ ) | NUM_ ; if ( ws [ r &= m ] != null ) { int probes = NUM_ ; int step = ( n <= NUM_ ) ? NUM_ : ( ( n > > > NUM_ ) & EVENMASK ) + NUM_ ; while ( ws [ r = ( r + step ) & m ] != null ) { if ( ++ probes >= n ) { workQueues = ws = Arrays . copyOf ( ws , n <<= NUM_ ) ; m = n - NUM_ ; probes = NUM_ ; } } } w . eventCount = w . poolIndex = r ; ws [ r ] = w ; } } finally { if ( ! U . compareAndSwapInt ( this , PLOCK , ps , nps ) ) releasePlock ( nps ) ; } wt . setName ( workerNamePrefix . concat ( Integer . toString ( w . poolIndex ) ) ) ; return w ; }
public void clear ( ) { documents . clear ( ) ; fireMRUListChanged ( ) ; }
public boolean isDirectlyControlDependentOn ( BasicBlock insBlock , Branch b ) { Set < ControlFlowEdge > incomming = incomingEdgesOf ( insBlock ) ; if ( incomming . size ( ) == NUM_ ) { for ( ControlFlowEdge e : incomming ) { if ( ! e . hasControlDependency ( ) && ! e . isExceptionEdge ( ) ) { return isDirectlyControlDependentOn ( getEdgeSource ( e ) , b ) ; } } } boolean isRootDependent = isRootDependent ( insBlock ) ; if ( b == null ) return isRootDependent ; if ( isRootDependent && b != null ) return BOOL_ ; for ( ControlFlowEdge e : incomming ) { Branch current = e . getBranchInstruction ( ) ; if ( e . isExceptionEdge ( ) ) { if ( current != null ) throw new IllegalStateException ( STR_ ) ; else continue ; } if ( current == null ) continue ; if ( current . equals ( b ) ) return BOOL_ ; } return BOOL_ ; }
final boolean tryReadLock ( ) { Thread current = Thread . currentThread ( ) ; for ( ; ; ) { int c = getState ( ) ; if ( exclusiveCount ( c ) != NUM_ && getExclusiveOwnerThread ( ) != current ) return BOOL_ ; int r = sharedCount ( c ) ; if ( r == MAX_COUNT ) throw new Error ( STR_ ) ; if ( compareAndSetState ( c , c + SHARED_UNIT ) ) { if ( r == NUM_ ) { firstReader = current ; firstReaderHoldCount = NUM_ ; } else if ( firstReader == current ) { firstReaderHoldCount ++ ; } else { HoldCounter rh = cachedHoldCounter ; if ( rh == null || rh . tid != current . getId ( ) ) cachedHoldCounter = rh = readHolds . get ( ) ; else if ( rh . count == NUM_ ) readHolds . set ( rh ) ; rh . count ++ ; } return BOOL_ ; } } }
public static String replace ( String text , String oldsub , String newsub , boolean caseInsensitive , boolean firstOnly ) { StringBuilder buf ; int tln ; int oln = oldsub . length ( ) ; if ( oln == NUM_ ) { int nln = newsub . length ( ) ; if ( nln == NUM_ ) { return text ; } else { if ( firstOnly ) { return newsub + text ; } else { tln = text . length ( ) ; buf = new StringBuilder ( tln + ( tln + NUM_ ) . nln ) ; buf . append ( newsub ) ; for ( int i = NUM_ ; i < tln ; i ++ ) { buf . append ( text . charAt ( i ) ) ; buf . append ( newsub ) ; } return buf . toString ( ) ; } } } else { oldsub = caseInsensitive ? oldsub . toLowerCase ( ) : oldsub ; String input = caseInsensitive ? text . toLowerCase ( ) : text ; int e = input . indexOf ( oldsub ) ; if ( e == - NUM_ ) { return text ; } int b = NUM_ ; tln = text . length ( ) ; buf = new StringBuilder ( tln + Math . max ( newsub . length ( ) - oln , NUM_ ) . NUM_ ) ; do { buf . append ( text . substring ( b , e ) ) ; buf . append ( newsub ) ; b = e + oln ; e = input . indexOf ( oldsub , b ) ; } while ( e != - NUM_ && ! firstOnly ) ; buf . append ( text . substring ( b ) ) ; return buf . toString ( ) ; } }
public void serializeFormDef ( FormDef fd , String filepath ) { String hash = FileUtils . getMd5Hash ( new File ( filepath ) ) ; File formDef = new File ( Collect . CACHE_PATH + File . separator + hash + STR_ ) ; if ( ! formDef . exists ( ) ) { FileOutputStream fos ; try { fos = new FileOutputStream ( formDef ) ; DataOutputStream dos = new DataOutputStream ( fos ) ; fd . writeExternal ( dos ) ; dos . flush ( ) ; dos . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
private void paintRoute ( Graphics2D graphics , JXMapViewer viewer , PlottableEntity entity ) { Set < Plottable > plottables = entity . getPlottables ( ) ; if ( plottables . size ( ) > NUM_ ) { graphics . setColor ( Color . BLACK ) ; graphics . setStroke ( new BasicStroke ( NUM_ ) ) ; drawRoute ( plottables , graphics , viewer ) ; graphics . setColor ( entity . getColor ( ) ) ; graphics . setStroke ( new BasicStroke ( NUM_ ) ) ; drawRoute ( plottables , graphics , viewer ) ; } }
private boolean installReply ( String alias , InputStream in ) throws Exception { if ( alias == null ) { alias = keyAlias ; } Pair < Key , char [ ] > objs = recoverKey ( alias , storePass , keyPass ) ; PrivateKey privKey = ( PrivateKey ) objs . fst ; if ( keyPass == null ) { keyPass = objs . snd ; } Certificate userCert = keyStore . getCertificate ( alias ) ; if ( userCert == null ) { MessageFormat form = new MessageFormat ( rb . getString ( STR_ ) ) ; Object [ ] source = { alias } ; throw new Exception ( form . format ( source ) ) ; } Collection < ? extends Certificate > c = cf . generateCertificates ( in ) ; if ( c . isEmpty ( ) ) { throw new Exception ( rb . getString ( STR_ ) ) ; } Certificate [ ] replyCerts = c . toArray ( new Certificate [ c . size ( ) ] ) ; Certificate [ ] newChain ; if ( replyCerts . length == NUM_ ) { newChain = establishCertChain ( userCert , replyCerts [ NUM_ ] ) ; } else { newChain = validateReply ( alias , userCert , replyCerts ) ; } if ( newChain != null ) { keyStore . setKeyEntry ( alias , privKey , ( keyPass != null ) ? keyPass : storePass , newChain ) ; return BOOL_ ; } else { return BOOL_ ; } }
@ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case EipPackage . AGGREGATOR__NAME : return NAME_EDEFAULT == null ? name != null : ! NAME_EDEFAULT . equals ( name ) ; case EipPackage . AGGREGATOR__TO_CHANNELS : return toChannels != null && ! toChannels . isEmpty ( ) ; case EipPackage . AGGREGATOR__FROM_CHANNELS : return fromChannels != null && ! fromChannels . isEmpty ( ) ; case EipPackage . AGGREGATOR__PART : return part != PART_EDEFAULT ; case EipPackage . AGGREGATOR__STRATEGY : return STRATEGY_EDEFAULT == null ? strategy != null : ! STRATEGY_EDEFAULT . equals ( strategy ) ; case EipPackage . AGGREGATOR__EXPRESSION : return EXPRESSION_EDEFAULT == null ? expression != null : ! EXPRESSION_EDEFAULT . equals ( expression ) ; } return super . eIsSet ( featureID ) ; }
public synchronized void mouseWheel ( int wheelAmt ) { peer . mouseWheel ( wheelAmt ) ; afterEvent ( ) ; }
@ Override public int length ( ) { return data . length / ( format . getFrameSize ( ) . NUM_ ) ; }
public void validate ( Set setData ) throws ValidationException { for ( Iterator iter = setData . iterator ( ) ; iter . hasNext ( ) ; ) { performValidation ( ( String ) iter . next ( ) ) ; } }
public static void deleteDirectory ( final File dir , boolean checkForLinks ) { if ( dir . isFile ( ) ) { throw new IllegalArgumentException ( STR_ + dir . getName ( ) + STR_ ) ; } else if ( checkForLinks && isLink ( dir ) ) { throw new IllegalArgumentException ( STR_ + dir . getName ( ) + STR_ ) ; } if ( dir . exists ( ) ) { IOUtils . deleteDir ( dir , checkForLinks ) ; } else { throw new IllegalArgumentException ( STR_ + dir . getName ( ) + STR_ ) ; } }
private static Marshaller createMarshaller ( JAXBContext jaxbContext , String schemaPath ) throws SAXException , JAXBException { Schema schema = XmlParser . getSchema ( new String [ ] { schemaPath } ) ; Marshaller jaxbMarshaller = jaxbContext . createMarshaller ( ) ; jaxbMarshaller . setSchema ( schema ) ; jaxbMarshaller . setProperty ( Marshaller . JAXB_FORMATTED_OUTPUT , BOOL_ ) ; jaxbMarshaller . setProperty ( Marshaller . JAXB_ENCODING , STR_ ) ; return jaxbMarshaller ; }
public static GeneralPath cardinalSpline ( float pts [ ] , float slack , boolean closed ) { GeneralPath path = new GeneralPath ( ) ; path . moveTo ( pts [ NUM_ ] , pts [ NUM_ ] ) ; return cardinalSpline ( path , pts , slack , closed , NUM_ , NUM_ ) ; }
public static String makeMethodSafe ( final String S ) { String name = makeHTMLNameSafe ( S ) ; name = name . replace ( STR_ , STR_ ) ; return name ; }
public Builder addListenUrl ( String url ) { if ( UrlUtil . isUrl ( url ) ) { if ( mListenUrls == null ) { mListenUrls = new HashSet < String > ( ) ; } mListenUrls . add ( url ) ; } return this ; }
private void expand ( int i ) { if ( count + i <= buf . length ) { return ; } byte [ ] newbuf = mPool . getBuf ( ( count + i ) . NUM_ ) ; System . arraycopy ( buf , NUM_ , newbuf , NUM_ , count ) ; mPool . returnBuf ( buf ) ; buf = newbuf ; }
public void remove ( Production production ) { productions . remove ( production ) ; }
private void writeDelay ( ) { try { Thread . sleep ( NUM_ ) ; } catch ( InterruptedException e ) { fail ( STR_ ) ; } }
public static void main ( String [ ] argv ) { ArgParser ap = new ArgParser ( STR_ ) ; ap . add ( STR_ , STR_ , NUM_ ) ; if ( argv . length < NUM_ ) { ap . bail ( STR_ , BOOL_ ) ; } ap . parse ( argv ) ; String [ ] files = ap . getArgValues ( STR_ ) ; if ( files != null && files [ NUM_ ] != null ) { String shp = files [ NUM_ ] ; String dbf = null ; try { dbf = shp . substring ( NUM_ , shp . lastIndexOf ( STR_ ) + NUM_ ) + PARAM_DBF ; DbfTableModel model = DbfTableModel . getDbfTableModel ( PropUtils . getResourceOrFileOrURL ( dbf ) ) ; EsriGraphicList list = EsriGraphicList . getEsriGraphicList ( PropUtils . getResourceOrFileOrURL ( shp ) , null , null ) ; logger . info ( list . getDescription ( ) ) ; EsriShapeExport ese = new EsriShapeExport ( list , model , null ) ; ese . export ( ) ; } catch ( MalformedURLException murle ) { logger . warning ( STR_ + murle . getMessage ( ) ) ; } catch ( NullPointerException npe ) { logger . warning ( STR_ ) ; } catch ( Exception exception ) { logger . warning ( STR_ + exception . getMessage ( ) ) ; exception . printStackTrace ( ) ; } } else { ap . bail ( STR_ , BOOL_ ) ; } System . exit ( NUM_ ) ; }
public PartialHull ( IPoint first , IPoint second ) { points . add ( first ) ; points . add ( second ) ; }
public void testMaxGreater ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int bSign = NUM_ ; byte rBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . max ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertTrue ( STR_ , result . signum ( ) == NUM_ ) ; }
public static SortedSet < Interval > findFullAvailabilityGaps ( Set < Interval > availableIntervals , Set < Interval > neededIntervals ) { Comparator < Interval > intervalStartComparator = new IntervalStartComparator ( ) ; SortedSet < Interval > sortedAvailableIntervals = new TreeSet < > ( intervalStartComparator ) ; sortedAvailableIntervals . addAll ( availableIntervals ) ; SortedSet < Interval > sortedNeededIntervals = new TreeSet < > ( intervalStartComparator ) ; sortedNeededIntervals . addAll ( neededIntervals ) ; Iterator < Interval > availableIntervalsIterator = sortedAvailableIntervals . iterator ( ) ; if ( ! availableIntervalsIterator . hasNext ( ) ) { return sortedNeededIntervals ; } Interval available = availableIntervalsIterator . next ( ) ; SortedSet < Interval > missingIntervals = new TreeSet < > ( intervalStartComparator ) ; for ( Interval needed : sortedNeededIntervals ) { while ( ! canDetermineAvailability ( available , needed ) && availableIntervalsIterator . hasNext ( ) ) { available = availableIntervalsIterator . next ( ) ; } if ( available . contains ( needed ) ) { continue ; } missingIntervals . add ( needed ) ; } return missingIntervals ; }
public static List < String > split ( String str , String delim ) { List < String > splitList = null ; StringTokenizer st = null ; if ( str == null ) return splitList ; if ( delim != null ) st = new StringTokenizer ( str , delim ) ; else st = new StringTokenizer ( str ) ; if ( st != null && st . hasMoreTokens ( ) ) { splitList = new LinkedList < String > ( ) ; while ( st . hasMoreTokens ( ) ) splitList . add ( st . nextToken ( ) ) ; } return splitList ; }
public void writeExif ( String jpegFileName , String exifOutFileName ) throws FileNotFoundException , IOException { if ( jpegFileName == null || exifOutFileName == null ) { throw new IllegalArgumentException ( NULL_ARGUMENT_STRING ) ; } InputStream is = null ; is = new FileInputStream ( jpegFileName ) ; writeExif ( is , exifOutFileName ) ; is . close ( ) ; }
public boolean isGenClass ( SootClass clz ) { return genClasses . contains ( clz . getName ( ) ) ; }
public boolean hasExtraStillImage ( ) { return isApng ( ) && ! firsIdatApngFrame ; }
private void readResponseHeaders ( State state , InnerState innerState , HttpResponse response ) throws StopRequest { Header header = response . getFirstHeader ( STR_ ) ; if ( header != null ) { innerState . mHeaderContentDisposition = header . getValue ( ) ; } header = response . getFirstHeader ( STR_ ) ; if ( header != null ) { innerState . mHeaderContentLocation = header . getValue ( ) ; } header = response . getFirstHeader ( STR_ ) ; if ( header != null ) { innerState . mHeaderETag = header . getValue ( ) ; } String headerTransferEncoding = null ; header = response . getFirstHeader ( STR_ ) ; if ( header != null ) { headerTransferEncoding = header . getValue ( ) ; } String headerContentType = null ; header = response . getFirstHeader ( STR_ ) ; if ( header != null ) { headerContentType = header . getValue ( ) ; if ( ! headerContentType . equals ( STR_ ) ) { throw new StopRequest ( DownloaderService . STATUS_FILE_DELIVERED_INCORRECTLY , STR_ ) ; } } if ( headerTransferEncoding == null ) { header = response . getFirstHeader ( STR_ ) ; if ( header != null ) { innerState . mHeaderContentLength = header . getValue ( ) ; long contentLength = Long . parseLong ( innerState . mHeaderContentLength ) ; if ( contentLength != - NUM_ && contentLength != mInfo . mTotalBytes ) { Log . e ( Constants . TAG , STR_ ) ; } } } else { if ( Constants . LOGVV ) { Log . v ( Constants . TAG , STR_ ) ; } } if ( Constants . LOGVV ) { Log . v ( Constants . TAG , STR_ + innerState . mHeaderContentDisposition ) ; Log . v ( Constants . TAG , STR_ + innerState . mHeaderContentLength ) ; Log . v ( Constants . TAG , STR_ + innerState . mHeaderContentLocation ) ; Log . v ( Constants . TAG , STR_ + innerState . mHeaderETag ) ; Log . v ( Constants . TAG , STR_ + headerTransferEncoding ) ; } boolean noSizeInfo = innerState . mHeaderContentLength == null && ( headerTransferEncoding == null || ! headerTransferEncoding . equalsIgnoreCase ( STR_ ) ) ; if ( noSizeInfo ) { throw new StopRequest ( DownloaderService . STATUS_HTTP_DATA_ERROR , STR_ ) ; } }
public void removeChangeListener ( final PTPropertyChangeListener listener ) { changeListeners . remove ( listener ) ; }
public static ResultSet optimizeInJoinSelect ( ) { SimpleResultSet rs = new SimpleResultSet ( ) ; rs . addColumn ( STR_ , Types . INTEGER , NUM_ , NUM_ ) ; rs . addRow ( NUM_ ) ; return rs ; }
public PartitionSubstitutionModel parsePAUPBlock ( BeautiOptions options , List < CharSet > charSets ) throws ImportException , IOException { PartitionSubstitutionModel model = new PartitionSubstitutionModel ( options , STR_ ) ; readTopLevelBlock ( options , model , charSets ) ; return model ; }
private void zEventToggleTimeMenuButtonMousePressed ( MouseEvent e ) { togglePopup ( ) ; }
private void addLine ( GridField field , VEditor editor , boolean mandatory ) { log . fine ( STR_ + field ) ; JLabel label = VEditorFactory . getLabel ( field ) ; label . setLabelFor ( ( Component ) editor ) ; editor . setReadWrite ( BOOL_ ) ; editor . setMandatory ( mandatory ) ; field . addPropertyChangeListener ( editor ) ; if ( m_newRow ) { m_gbc . gridy = m_line ++ ; m_gbc . gridx = NUM_ ; } else m_gbc . gridx = NUM_ ; m_gbc . insets = m_labelInsets ; m_gbc . fill = GridBagConstraints . HORIZONTAL ; m_gbc . weightx = NUM_ ; parameterPanel . add ( label , m_gbc ) ; if ( m_newRow ) m_gbc . gridx = NUM_ ; else m_gbc . gridx = NUM_ ; m_gbc . insets = m_fieldInsets ; m_gbc . fill = GridBagConstraints . HORIZONTAL ; m_gbc . weightx = NUM_ ; parameterPanel . add ( ( Component ) editor , m_gbc ) ; m_newRow = ! m_newRow ; }
protected Object lazilyLoadDesktopProperty ( String name ) { return null ; }
@ edu . umd . cs . findbugs . annotations . SuppressWarnings ( value = STR_ , justification = STR_ ) public void initRecoveredVersion ( T member , RegionVersionHolder < T > v , boolean latestOplog ) { RegionVersionHolder < T > recovered = v . clone ( ) ; if ( member == null || member . equals ( myId ) ) { synchronized ( localExceptions ) { if ( latestOplog || localVersion . get ( ) == NUM_ ) { localExceptions = recovered ; if ( logger . isTraceEnabled ( LogMarker . RVV ) ) { logger . trace ( LogMarker . RVV , STR_ , recovered . version ) ; } localVersion . set ( recovered . version ) ; } } } else { Long gcVersion = memberToGCVersion . get ( member ) ; synchronized ( memberToVersion ) { RegionVersionHolder < T > oldVersion = memberToVersion . get ( member ) ; if ( latestOplog || oldVersion == null || oldVersion . version == NUM_ ) { if ( gcVersion != null ) { recovered . removeExceptionsOlderThan ( gcVersion ) ; } memberToVersion . put ( member , recovered ) ; } } } }
protected void notifyClickListenersAboutClick ( int item ) { if ( clickingListeners . size ( ) > NUM_ ) { for ( OnWheelClickedListener listener : clickingListeners ) { listener . onItemClicked ( this , item ) ; } } else { setCurrentItem ( item , BOOL_ , NUM_ ) ; } }
@ Override public synchronized void disconnectionNotification ( String eventName , Object source ) { List < Object > listenees = m_listenees . get ( eventName ) ; if ( listenees != null ) { listenees . remove ( source ) ; if ( listenees . size ( ) == NUM_ ) { m_listenees . remove ( eventName ) ; } } if ( eventName . compareTo ( STR_ ) == NUM_ ) { stop ( ) ; } }
public void testConstructorSignBytesZeroNull1 ( ) { byte aBytes [ ] = { } ; int aSign = - NUM_ ; byte rBytes [ ] = { NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , aNumber . signum ( ) ) ; }
private String replaceIllegalChar ( String data , char ch , String replacement ) { int idx = NUM_ ; StringBuilder buffer = new StringBuilder ( data . length ( ) . NUM_ ) ; while ( ( data != null ) && ( idx = data . indexOf ( ch ) ) != - NUM_ ) { buffer . append ( data . substring ( NUM_ , idx ) ) ; buffer . append ( replacement ) ; data = data . substring ( idx + NUM_ ) ; } if ( ( data != null ) && ( data . length ( ) > NUM_ ) ) { buffer . append ( data ) ; } return buffer . toString ( ) ; }
protected static final void adjustModuleName ( DebugModule d ) { d . name = adjustModuleName ( d . name ) ; }
public org . dom4j . Attribute createAttribute ( Element elem , Attribute attr ) { return factory . createAttribute ( elem , createQName ( attr . getName ( ) ) , attr . getValue ( ) ) ; }
public LogEntry ( ) { index = ENTRY_INDEX . getAndIncrement ( ) ; time = System . currentTimeMillis ( ) ; }
public void testBitLengthPositive3 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; assertEquals ( NUM_ , aNumber . bitLength ( ) ) ; }
public boolean isSignatureValid ( ) { return ECKey . verify ( Utils . doubleDigest ( content ) , signature , params . getAlertSigningKey ( ) ) ; }
private void validateCreateInformation ( Date startTime , String taskName ) { Assert . notNull ( startTime , STR_ ) ; if ( taskName != null && taskName . length ( ) > this . maxTaskNameSize ) { throw new IllegalArgumentException ( STR_ + this . maxTaskNameSize + STR_ ) ; } }
private static Object increment ( final Object object , final Number amount , final JsonPointer field ) throws BadRequestException { if ( object instanceof Long ) { return ( ( Long ) object ) + amount . longValue ( ) ; } else if ( object instanceof Integer ) { return ( ( Integer ) object ) + amount . intValue ( ) ; } else if ( object instanceof Float ) { return ( ( Float ) object ) + amount . floatValue ( ) ; } else if ( object instanceof Double ) { return ( ( Double ) object ) + amount . doubleValue ( ) ; } else { throw new BadRequestException ( STR_ + field + STR_ ) ; } }
public static LinkedHashSet < Entity > findEntites ( LinkedHashSet < Entity > matches , HashSet < Entity > checked , Entity entity , Predicate predicate ) { if ( ! checked . add ( entity ) ) { return matches ; } if ( predicate . matches ( entity ) ) { matches . add ( entity ) ; } for ( RefNode refNode : entity . getChildren ( RefNode . class ) ) { Entity e = refNode . getReference ( ) ; if ( e != null ) { findEntites ( matches , checked , e , predicate ) ; } } for ( ToManyNode toManyNode : entity . getChildren ( ToManyNode . class ) ) { for ( Entity e : toManyNode . getList ( ) ) { if ( e != null ) { findEntites ( matches , checked , e , predicate ) ; } } } return matches ; }
protected OMGeometry createMGRSRectangle ( MGRSPoint mgrsBasePoint , double voffset , double hoffset , double interval , Ellipsoid ellipsoid ) { double [ ] llpoints = new double [ NUM_ ] ; double easting = mgrsBasePoint . easting + hoffset ; double northing = mgrsBasePoint . northing + voffset ; int zone_number = mgrsBasePoint . zone_number ; char zone_letter = mgrsBasePoint . zone_letter ; LatLonPoint llp1 = new LatLonPoint . Double ( ) ; llp1 = MGRSPoint . MGRStoLL ( ellipsoid , northing , easting , zone_number , zone_letter , llp1 ) ; llpoints [ NUM_ ] = llp1 . getY ( ) ; llpoints [ NUM_ ] = llp1 . getX ( ) ; llpoints [ NUM_ ] = llp1 . getY ( ) ; llpoints [ NUM_ ] = llp1 . getX ( ) ; MGRSPoint . MGRStoLL ( ellipsoid , northing , easting + interval , zone_number , zone_letter , llp1 ) ; llpoints [ NUM_ ] = llp1 . getY ( ) ; llpoints [ NUM_ ] = llp1 . getX ( ) ; MGRSPoint . MGRStoLL ( ellipsoid , northing + interval , easting + interval , zone_number , zone_letter , llp1 ) ; llpoints [ NUM_ ] = llp1 . getY ( ) ; llpoints [ NUM_ ] = llp1 . getX ( ) ; MGRSPoint . MGRStoLL ( ellipsoid , northing + interval , easting , zone_number , zone_letter , llp1 ) ; llpoints [ NUM_ ] = llp1 . getY ( ) ; llpoints [ NUM_ ] = llp1 . getX ( ) ; MGRSPoint mgrs = new MGRSPoint ( northing , easting , zone_number , zone_letter ) ; mgrs . resolve ( mgrsBasePoint . getAccuracy ( ) ) ; String mgrsString = mgrs . getMGRS ( ) ; if ( Debug . debugging ( STR_ ) ) Debug . output ( STR_ + mgrsString + STR_ + mgrs . getAccuracy ( ) ) ; PolygonGeometry poly = new PolygonGeometry . LL ( llpoints , OMGraphic . DECIMAL_DEGREES , ( interval <= NUM_ ? OMGraphic . LINETYPE_STRAIGHT : OMGraphic . LINETYPE_GREATCIRCLE ) ) ; poly . putAttribute ( OMGraphic . APP_OBJECT , mgrsString ) ; return poly ; }
public String toXMLString ( ) throws XACMLException { return toXMLString ( BOOL_ , BOOL_ ) ; }
public void addMemoryPressureListener ( MemoryPressureListener listener ) { mListeners . add ( listener ) ; }
private void resetForOT ( ) { if ( bottomOT && homeScore == awayScore ) { gameYardLine = NUM_ ; gameYardsNeed = NUM_ ; gameDown = NUM_ ; numOT ++ ; if ( ( numOT % NUM_ ) == NUM_ ) gamePoss = BOOL_ ; else gamePoss = BOOL_ ; gameTime = - NUM_ ; bottomOT = BOOL_ ; } else if ( ! bottomOT ) { gamePoss = ! gamePoss ; gameYardLine = NUM_ ; gameYardsNeed = NUM_ ; gameDown = NUM_ ; gameTime = - NUM_ ; bottomOT = BOOL_ ; } else { playingOT = BOOL_ ; } }
public synchronized void startPolling ( ) { m_scheduler . scheduleAtFixedRate ( m_notificationPoller , NUM_ , NUM_ , TimeUnit . MILLISECONDS ) ; }
private void dropProxy ( ProxyReg reg ) { synchronized ( caches ) { Iterator iter = caches . iterator ( ) ; while ( iter . hasNext ( ) ) { LookupCacheImpl cache = ( LookupCacheImpl ) iter . next ( ) ; cache . removeProxyReg ( reg ) ; } } }
public void testUpdate4 ( ) { int newValue1 = - NUM_ ; int newValue2 = - NUM_ ; String updateQuery = STR_ + DatabaseCreator . TEST_TABLE1 + STR_ + newValue1 + STR_ + newValue2 + STR_ ; try { int num = statement . executeUpdate ( updateQuery ) ; int expectedUpdated = NUM_ ; assertEquals ( STR_ , expectedUpdated , num ) ; String selectQuery = STR_ + DatabaseCreator . TEST_TABLE1 ; ResultSet result = statement . executeQuery ( selectQuery ) ; while ( result . next ( ) ) { int id = result . getInt ( STR_ ) ; } result . close ( ) ; } catch ( SQLException e ) { fail ( STR_ + e . getMessage ( ) ) ; } }
public long toLong ( ) { return m_value . longValue ( ) ; }
public static void moveToDirectory ( File src , File destDir , boolean createDestDir ) throws IOException { if ( src == null ) { throw new NullPointerException ( STR_ ) ; } if ( destDir == null ) { throw new NullPointerException ( STR_ ) ; } if ( ! src . exists ( ) ) { throw new FileNotFoundException ( STR_ + src + STR_ ) ; } if ( src . isDirectory ( ) ) { moveDirectoryToDirectory ( src , destDir , createDestDir ) ; } else { moveFileToDirectory ( src , destDir , createDestDir ) ; } }
public static int copyAndCloseBoth ( Reader input , Writer output ) throws IOException { try { return copyAndCloseOutput ( input , output ) ; } finally { input . close ( ) ; } }
protected void writeHeader ( ) throws IOException { header = new byte [ SHAPE_FILE_HEADER_LENGTH ] ; writeBEInt ( header , NUM_ , SHAPE_FILE_CODE ) ; writeBEInt ( header , NUM_ , NUM_ ) ; writeLEInt ( header , NUM_ , SHAPE_FILE_VERSION ) ; writeLEInt ( header , NUM_ , SHAPE_TYPE_NULL ) ; writeLEDouble ( header , NUM_ , NUM_ ) ; writeLEDouble ( header , NUM_ , NUM_ ) ; writeLEDouble ( header , NUM_ , NUM_ ) ; writeLEDouble ( header , NUM_ , NUM_ ) ; raf . seek ( NUM_ ) ; raf . write ( header , NUM_ , SHAPE_FILE_HEADER_LENGTH ) ; }
public String hashKeyForDisk ( String key ) { String cacheKey ; try { final MessageDigest mDigest = MessageDigest . getInstance ( STR_ ) ; mDigest . update ( key . getBytes ( ) ) ; cacheKey = bytesToHexString ( mDigest . digest ( ) ) ; } catch ( NoSuchAlgorithmException e ) { cacheKey = String . valueOf ( key . hashCode ( ) ) ; } return cacheKey ; }
private Favorite packFavorite ( Cursor c ) { Favorite favorite = new Favorite ( ) ; favorite . id = c . getLong ( ID_INDEX ) ; favorite . screen = c . getInt ( SCREEN_INDEX ) ; favorite . container = c . getInt ( CONTAINER_INDEX ) ; favorite . cellX = c . getInt ( CELLX_INDEX ) ; favorite . cellY = c . getInt ( CELLY_INDEX ) ; favorite . spanX = c . getInt ( SPANX_INDEX ) ; favorite . spanY = c . getInt ( SPANY_INDEX ) ; favorite . iconType = c . getInt ( ICON_TYPE_INDEX ) ; if ( favorite . iconType == Favorites . ICON_TYPE_RESOURCE ) { String iconPackage = c . getString ( ICON_PACKAGE_INDEX ) ; if ( ! TextUtils . isEmpty ( iconPackage ) ) { favorite . iconPackage = iconPackage ; } String iconResource = c . getString ( ICON_RESOURCE_INDEX ) ; if ( ! TextUtils . isEmpty ( iconResource ) ) { favorite . iconResource = iconResource ; } } if ( favorite . iconType == Favorites . ICON_TYPE_BITMAP ) { byte [ ] blob = c . getBlob ( ICON_INDEX ) ; if ( blob != null && blob . length > NUM_ ) { favorite . icon = blob ; } } String title = c . getString ( TITLE_INDEX ) ; if ( ! TextUtils . isEmpty ( title ) ) { favorite . title = title ; } String intentDescription = c . getString ( INTENT_INDEX ) ; if ( ! TextUtils . isEmpty ( intentDescription ) ) { try { Intent intent = Intent . parseUri ( intentDescription , NUM_ ) ; intent . removeExtra ( ItemInfo . EXTRA_PROFILE ) ; favorite . intent = intent . toUri ( NUM_ ) ; } catch ( URISyntaxException e ) { Log . e ( TAG , STR_ , e ) ; } } favorite . itemType = c . getInt ( ITEM_TYPE_INDEX ) ; if ( favorite . itemType == Favorites . ITEM_TYPE_APPWIDGET ) { favorite . appWidgetId = c . getInt ( APPWIDGET_ID_INDEX ) ; String appWidgetProvider = c . getString ( APPWIDGET_PROVIDER_INDEX ) ; if ( ! TextUtils . isEmpty ( appWidgetProvider ) ) { favorite . appWidgetProvider = appWidgetProvider ; } } return favorite ; }
public static void unregister ( SPINThreadFunctions old ) { if ( old != null ) { localFunctions . set ( old ) ; } else { localFunctions . remove ( ) ; } }
public static boolean loadProperties ( Properties properties , InputStream propsIn ) { try { properties . load ( propsIn ) ; return BOOL_ ; } catch ( java . io . IOException e ) { if ( logger . isLoggable ( Level . FINE ) ) { logger . warning ( STR_ ) ; } return BOOL_ ; } }
public Complex sin ( ) { return new Complex ( Math . sin ( re ) . Math . cosh ( im ) , Math . cos ( re ) . Math . sinh ( im ) ) ; }
@ OnClick ( R . id . dismiss_button ) public void onDismissClick ( View view ) { if ( SystemClock . elapsedRealtime ( ) - mLastClickTime < NUM_ ) { return ; } mLastClickTime = SystemClock . elapsedRealtime ( ) ; dismissOffer ( getAdapterPosition ( ) ) ; if ( snackbar != null ) { snackbar . dismiss ( ) ; } }
public Table findTable ( String name ) { return findTable ( name , BOOL_ ) ; }
public static void appendString ( final StringBuffer buf , final String s ) { buf . append ( STR_ ) ; for ( int i = NUM_ ; i < s . length ( ) ; ++ i ) { char c = s . charAt ( i ) ; if ( c == STR_ ) { buf . append ( STR_ ) ; } else if ( c == STR_ ) { buf . append ( STR_ ) ; } else if ( c == STR_ ) { buf . append ( STR_ ) ; } else if ( c == STR_ ) { buf . append ( STR_ ) ; } else if ( c < x20 || c > x7f ) { buf . append ( STR_ ) ; if ( c < x10 ) { buf . append ( STR_ ) ; } else if ( c < x100 ) { buf . append ( STR_ ) ; } else if ( c < x1000 ) { buf . append ( STR_ ) ; } buf . append ( Integer . toString ( c , NUM_ ) ) ; } else { buf . append ( c ) ; } } buf . append ( STR_ ) ; }
public void draw ( final Graphics g , final int height , final int width ) { int constantDim ; int changingDim ; if ( orientation == X_AXIS ) { changingDim = width ; constantDim = height ; } else { changingDim = height ; constantDim = width ; } int dimStep ; if ( fixedSteps ) { dimStep = changingDim / STEPS ; } else { dimStep = NUM_ ; STEPS = changingDim / dimStep ; } float red = _redT ; float green = _greenT ; float blue = _blueT ; int offset = NUM_ ; for ( int i = NUM_ ; i < STEPS ; i ++ ) { Color c = new Color ( round ( red ) , round ( green ) , round ( blue ) ) ; g . setColor ( c ) ; drawRect ( g , offset , constantDim , dimStep ) ; offset += dimStep ; float value = shader . getValue ( ( float ) i / ( float ) STEPS ) ; red = _redT + ( _redB - _redT ) . value ; green = _greenT + ( _greenB - _greenT ) . value ; blue = _blueT + ( _blueB - _blueT ) . value ; } Color c = new Color ( round ( red ) , round ( green ) , round ( blue ) ) ; g . setColor ( c ) ; drawRect ( g , offset , constantDim , changingDim - offset ) ; }
public static double [ ] convexHull ( double [ ] pts , int len , float [ ] angles , int [ ] idx , int [ ] stack ) { int plen = len / NUM_ - NUM_ ; if ( len < NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } if ( angles . length < plen || idx . length < plen || stack . length < len / NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } int i0 = NUM_ ; for ( int i = NUM_ ; i < len ; i += NUM_ ) { if ( pts [ i + NUM_ ] < pts [ i0 + NUM_ ] ) { i0 = i ; } else if ( pts [ i + NUM_ ] == pts [ i0 + NUM_ ] ) { i0 = ( pts [ i ] < pts [ i0 ] ? i : i0 ) ; } } for ( int i = NUM_ , j = NUM_ ; i < len ; i += NUM_ ) { if ( i == i0 ) continue ; angles [ j ] = ( float ) Math . atan2 ( pts [ i + NUM_ ] - pts [ i0 + NUM_ ] , pts [ i ] - pts [ i0 ] ) ; idx [ j ++ ] = i ; } ArrayLib . sort ( angles , idx , plen ) ; float angle = angles [ NUM_ ] ; int ti = NUM_ , tj = idx [ NUM_ ] ; for ( int i = NUM_ ; i < plen ; i ++ ) { int j = idx [ i ] ; if ( angle == angles [ i ] ) { double x1 = pts [ tj ] - pts [ i0 ] ; double y1 = pts [ tj + NUM_ ] - pts [ i0 + NUM_ ] ; double x2 = pts [ j ] - pts [ i0 ] ; double y2 = pts [ j + NUM_ ] - pts [ i0 + NUM_ ] ; double d1 = x1 . x1 + y1 . y1 ; double d2 = x2 . x2 + y2 . y2 ; if ( d1 >= d2 ) { idx [ i ] = - NUM_ ; } else { idx [ ti ] = - NUM_ ; angle = angles [ i ] ; ti = i ; tj = j ; } } else { angle = angles [ i ] ; ti = i ; tj = j ; } } int sp = NUM_ ; stack [ sp ++ ] = i0 ; int j = NUM_ ; for ( int k = NUM_ ; k < NUM_ ; j ++ ) { if ( idx [ j ] != - NUM_ ) { stack [ sp ++ ] = idx [ j ] ; k ++ ; } } for ( ; j < plen ; j ++ ) { if ( idx [ j ] == - NUM_ ) continue ; while ( isNonLeft ( i0 , stack [ sp - NUM_ ] , stack [ sp - NUM_ ] , idx [ j ] , pts ) ) { sp -- ; } stack [ sp ++ ] = idx [ j ] ; } double [ ] hull = new double [ NUM_ . sp ] ; for ( int i = NUM_ ; i < sp ; i ++ ) { hull [ NUM_ . i ] = pts [ stack [ i ] ] ; hull [ NUM_ . i + NUM_ ] = pts [ stack [ i ] + NUM_ ] ; } return hull ; }
private void sendMessages ( ) { List < MurmurMessage > messages = getMessages ( NUM_ ) ; MurmurMessage exchangeInfoMessage = new MurmurMessage ( STR_ , Integer . toString ( messages . size ( ) ) , NUM_ ) ; if ( lengthValueWrite ( out , exchangeInfoMessage . toJSON ( MurmurApplication . getContext ( ) , NUM_ , NUM_ ) ) ) { for ( MurmurMessage message : messages ) { List < MurmurMessage > packet = new ArrayList < > ( ) ; packet . add ( message ) ; CleartextMessages messagesMessage = new CleartextMessages ( ( ArrayList < MurmurMessage > ) packet ) ; lengthValueWrite ( out , messagesMessage . toJson ( MurmurApplication . getContext ( ) ) ) ; } } }
protected void init ( String str ) { int len = str . length ( ) ; text = new char [ len ] ; lcText = new char [ len ] ; for ( int i = NUM_ ; i < len ; i ++ ) { char c = str . charAt ( i ) ; text [ i ] = c ; if ( c == STR_ || c == STR_ || c == STR_ ) { lcText [ i ] = STR_ ; } else lcText [ i ] = ( ( c >= STR_ && c <= STR_ ) || ( c >= STR_ && c <= STR_ ) ) ? c : Character . toLowerCase ( c ) ; } }
private void updateAttrs ( SvcReg reg , EntryRep entry , Object [ ] values ) { EntryClass eclass = entry . eclass ; for ( int fldidx = values . length ; -- fldidx >= NUM_ ; ) { Object oval = entry . fields [ fldidx ] ; Object nval = values [ fldidx ] ; if ( nval != null && ! nval . equals ( oval ) ) { eclass = getDefiningClass ( eclass , fldidx ) ; HashMap map = addAttr ( reg , eclass , fldidx , nval ) ; entry . fields [ fldidx ] = nval ; if ( hasAttr ( reg , eclass , fldidx , oval ) ) continue ; ArrayList regs = ( ArrayList ) map . get ( oval ) ; regs . remove ( regs . indexOf ( reg ) ) ; if ( regs . isEmpty ( ) ) map . remove ( oval ) ; } } }
public void finalizeNetworkConstruction ( ) { Set < MotifLink > keySet = nodeSetsDepartingFromLink . keySet ( ) ; nodesWithLink = new HashMap < MotifLink , ArrayList < Node > > ( keySet . size ( ) ) ; for ( MotifLink motifLink : keySet ) { Set < Node > nodes = nodeSetsDepartingFromLink . get ( motifLink ) ; ArrayList < Node > n = new ArrayList < Node > ( nodes ) ; Collections . sort ( n ) ; nodesWithLink . put ( motifLink , n ) ; } nodeSetsDepartingFromLink = null ; }
public Collection < AISValidationFailure > failures ( ) { return Collections . unmodifiableCollection ( failureList ) ; }
public static GetInactiveImagesResponse checkGetInactiveImagesResponse ( GetInactiveImagesResponse response ) throws RpcException { logger . info ( STR_ , response ) ; switch ( response . getResult ( ) ) { case OK : break ; case SYSTEM_ERROR : throw new SystemErrorException ( response . getError ( ) ) ; case DATASTORE_NOT_FOUND : throw new DatastoreNotFoundException ( response . getError ( ) ) ; case OPERATION_IN_PROGRESS : throw new OperationInProgressException ( response . getError ( ) ) ; default : throw new RpcException ( String . format ( STR_ , response . getResult ( ) ) ) ; } return response ; }
public void runTest ( ) throws Throwable { Document doc ; Element root ; NodeList elementList ; Node firstChild ; NodeList textList ; CharacterData textNode ; String data ; doc = ( Document ) load ( STR_ , BOOL_ ) ; root = doc . getDocumentElement ( ) ; root . normalize ( ) ; elementList = root . getElementsByTagName ( STR_ ) ; firstChild = elementList . item ( NUM_ ) ; textList = firstChild . getChildNodes ( ) ; textNode = ( CharacterData ) textList . item ( NUM_ ) ; data = textNode . getData ( ) ; assertEquals ( STR_ , STR_ , data ) ; }
public double semiDeviation ( ) { return Math . sqrt ( semiVariance ( ) ) ; }
private void checkPostsDisplayOnRecyclerView ( List < Post > postsToCheck , int position ) { int columnCount = NUM_ ; int size = postsToCheck . size ( ) + position ; int pos = NUM_ ; for ( int i = position ; i < size ; i ++ ) { checkItemAtPosition ( i , postsToCheck . get ( pos ) ) ; if ( ( ( i + NUM_ ) % columnCount ) == NUM_ ) { int nextRowStart = i + columnCount ; int nextRowEnd = nextRowStart - columnCount + NUM_ ; for ( int n = nextRowStart ; n >= nextRowEnd ; n -- ) { checkItemAtPosition ( n , postsToCheck . get ( n - position ) ) ; } i = i + columnCount ; } pos ++ ; } }
private void addDependentClassesToWorklist ( GVCongruenceClass c ) { for ( ValueGraphVertex v : c ) { for ( Enumeration < GraphNode > e = v . inNodes ( ) ; e . hasMoreElements ( ) ; ) { ValueGraphVertex in = ( ValueGraphVertex ) e . nextElement ( ) ; int vn = in . getValueNumber ( ) ; GVCongruenceClass x = B . get ( vn ) ; workList . push ( x ) ; } } }
public synchronized JSONObject toJSONObject ( ) { JSONObject res = new JSONObject ( ) ; res . putAll ( this ) ; return res ; }
private Shape createEllipseInternal ( int x , int y , int w , int h ) { ellipse . setFrame ( x , y , w , h ) ; return ellipse ; }
public static String write ( StringBuilder sb , String ... strings ) { for ( String string : strings ) sb . append ( string ) ; return sb . toString ( ) ; }
public ImportFolderValidation validate ( final String path ) { Check . notNull ( path , STR_ ) ; if ( validationCache == null ) { validationCache = new HashMap ( ) ; } else { if ( validationCache . containsKey ( path ) ) { return ( ImportFolderValidation ) validationCache . get ( path ) ; } } final ImportFolderValidation validation = computeValidation ( path ) ; validationCache . put ( path , validation ) ; return validation ; }
private static byte [ ] hmac_sha ( String crypto , byte [ ] keyBytes , byte [ ] text ) { try { Mac hmac ; hmac = Mac . getInstance ( crypto ) ; SecretKeySpec macKey = new SecretKeySpec ( keyBytes , STR_ ) ; hmac . init ( macKey ) ; return hmac . doFinal ( text ) ; } catch ( GeneralSecurityException gse ) { throw new UndeclaredThrowableException ( gse ) ; } }
public static String fetchCgName ( String clusterCgName ) { String cgName = null ; if ( clusterCgName != null && ! clusterCgName . isEmpty ( ) ) { String [ ] tmp = clusterCgName . split ( SPLITTER ) ; cgName = tmp [ NUM_ ] ; } return cgName ; }
public void test_chooseServerAlias ( ) { init ( SERVER ) ; assertNull ( manager . chooseServerAlias ( null , null , new Socket ( ) ) ) ; assertNull ( manager . chooseServerAlias ( STR_ , null , new Socket ( ) ) ) ; String res = manager . chooseServerAlias ( TYPE_RSA , null , null ) ; assertNotNull ( res ) ; assertEquals ( STR_ , res . toLowerCase ( ) ) ; res = manager . chooseServerAlias ( TYPE_RSA , null , new Socket ( ) ) ; assertNotNull ( res ) ; assertEquals ( STR_ , res . toLowerCase ( ) ) ; }
public void add ( int index , Entity entity ) { if ( entities . contains ( entity ) ) { throw new IllegalStateException ( STR_ + entity + STR_ ) ; } if ( entity . getEntityType ( ) != entityType ) { throw new IllegalStateException ( STR_ + entity . getEntityType ( ) + STR_ + getParent ( ) + STR_ + getName ( ) ) ; } if ( entity . isClearlyNotInDatabase ( ) ) { newEntities . add ( entity ) ; } entities . add ( index , entity ) ; }
public static ControlTagCacheObject createTestEquipmentAlive ( ) { ControlTagCacheObject cacheObject = new ControlTagCacheObject ( new Long ( NUM_ ) , STR_ , STR_ , DataTagConstants . MODE_TEST ) ; cacheObject . setDescription ( STR_ ) ; cacheObject . setLogged ( BOOL_ ) ; cacheObject . setUnit ( STR_ ) ; cacheObject . setDipAddress ( STR_ ) ; cacheObject . setJapcAddress ( STR_ ) ; cacheObject . setValue ( new Long ( System . currentTimeMillis ( ) ) ) ; cacheObject . setValueDescription ( STR_ ) ; cacheObject . setSimulated ( BOOL_ ) ; cacheObject . setMinValue ( Long . MIN_VALUE ) ; cacheObject . setMaxValue ( Long . MAX_VALUE ) ; cacheObject . setValueDictionary ( new DataTagValueDictionary ( ) ) ; cacheObject . setAddress ( new DataTagAddress ( ) ) ; cacheObject . setDataTagQuality ( createValidQuality ( ) ) ; cacheObject . setCacheTimestamp ( new Timestamp ( System . currentTimeMillis ( ) ) ) ; cacheObject . setDaqTimestamp ( new Timestamp ( System . currentTimeMillis ( ) ) ) ; cacheObject . setSourceTimestamp ( new Timestamp ( System . currentTimeMillis ( ) ) ) ; return cacheObject ; }
public DistributedLogConfiguration ( ) { super ( ) ; addConfiguration ( new SystemConfiguration ( ) ) ; }
void normalize ( ) throws IOException { int end = chars . length ( ) ; if ( end == NUM_ ) { return ; } int pos = NUM_ ; int codepoint = Character . codePointAt ( chars , NUM_ ) ; boolean escaped = BOOL_ ; for ( int i = NUM_ ; i < end ; ) { int charCount = Character . charCount ( codepoint ) ; int i2 = i + charCount ; int nextCodepoint = i2 < end ? Character . codePointAt ( chars , i2 ) : - NUM_ ; if ( escaped ) { escaped = BOOL_ ; if ( escapeOneCodepoint ( pos , i - NUM_ , codepoint , nextCodepoint ) ) { pos = i2 ; } } else if ( codepoint == STR_ ) { escaped = BOOL_ ; } else if ( escapeOneCodepoint ( pos , i , codepoint , nextCodepoint ) ) { pos = i2 ; } i = i2 ; codepoint = nextCodepoint ; } out . append ( chars , pos , end ) ; }
protected void rebuildListModel ( ) { DefaultListModel dlm = ( DefaultListModel ) getListModel ( ) ; OMGraphicList list = getList ( ) ; int [ ] selectedIndicies = null ; if ( list != null ) { if ( selectedTiles != null && selectedTiles . length > NUM_ ) { selectedIndicies = new int [ selectedTiles . length ] ; } int tileCount = NUM_ ; int selectedIndex = NUM_ ; if ( selectedIndicies != null ) { for ( OMGraphic omg : list ) { ImageTile imageTile = ( ImageTile ) omg ; if ( imageTile . isSelected ( ) && selectedIndex < selectedIndicies . length ) { selectedIndicies [ selectedIndex ++ ] = tileCount ; } tileCount ++ ; } } dlm . clear ( ) ; for ( OMGraphic omg : list ) { tileCount ++ ; dlm . addElement ( omg ) ; } } if ( resultsList != null ) { if ( selectedIndicies != null ) { resultsList . setSelectedIndices ( selectedIndicies ) ; } resultsList . repaint ( ) ; } }
public void tick ( ) { tick ( NUM_ ) ; }
public Result send ( Email email , boolean ... sync ) { return service . send ( email , boolToInt ( BOOL_ , sync ) ) ; }
private boolean isPopulating ( ) { return isPopulating ; }
public void processAttributes ( java . io . Writer writer , int nAttrs ) throws IOException , SAXException { String encoding = getEncoding ( ) ; for ( int i = NUM_ ; i < nAttrs ; i ++ ) { final String name = m_attributes . getQName ( i ) ; final String value = m_attributes . getValue ( i ) ; writer . write ( STR_ ) ; writer . write ( name ) ; writer . write ( STR_ ) ; writeAttrString ( writer , value , encoding ) ; writer . write ( STR_ ) ; } }
public int processor ( ) { return Integer . parseInt ( fields [ NUM_ ] ) ; }
public void addNativeChildAt ( ReactShadowNode child , int nativeIndex ) { Assertions . assertCondition ( ! mIsLayoutOnly ) ; Assertions . assertCondition ( ! child . mIsLayoutOnly ) ; if ( mNativeChildren == null ) { mNativeChildren = new ArrayList < > ( NUM_ ) ; } mNativeChildren . add ( nativeIndex , child ) ; child . mNativeParent = this ; }
public boolean containsKey ( final Object eKey ) { return _elementOrder . contains ( eKey ) ; }
private void handleExitMessage ( final Component component , final long nativeCtxt ) { postDropTargetEvent ( component , NUM_ , NUM_ , DnDConstants . ACTION_NONE , DnDConstants . ACTION_NONE , null , nativeCtxt , SunDropTargetEvent . MOUSE_EXITED , SunDropTargetContextPeer . DISPATCH_SYNC ) ; }
public void addParameterAnnotations ( CstMethodRef method , AnnotationsList list ) { if ( parameterAnnotations == null ) { parameterAnnotations = new ArrayList < ParameterAnnotationStruct > ( ) ; } parameterAnnotations . add ( new ParameterAnnotationStruct ( method , list ) ) ; }
public static String unhtmlSingleQuotes ( final String str ) { return str . replaceAll ( STR_ , STR_ ) ; }
public void addInputMethodListener ( InputMethodListener l ) { m_textArea . addInputMethodListener ( l ) ; }
public void initRawSwap ( ArrayList < S2CellId > cellIds ) { this . cellIds = new ArrayList < S2CellId > ( cellIds ) ; cellIds . clear ( ) ; }
protected void encryptFinal ( ) throws IOException { inBuffer . flip ( ) ; outBuffer . clear ( ) ; try { cipher . doFinal ( inBuffer , outBuffer ) ; } catch ( ShortBufferException e ) { throw new IOException ( e ) ; } catch ( IllegalBlockSizeException e ) { throw new IOException ( e ) ; } catch ( BadPaddingException e ) { throw new IOException ( e ) ; } inBuffer . clear ( ) ; outBuffer . flip ( ) ; while ( outBuffer . hasRemaining ( ) ) { output . write ( outBuffer ) ; } }
private static boolean spanWillOverlap ( Spannable spanText , URLSpan [ ] spanList , int start , int end ) { if ( start == end ) { return BOOL_ ; } for ( URLSpan span : spanList ) { int existingStart = spanText . getSpanStart ( span ) ; int existingEnd = spanText . getSpanEnd ( span ) ; if ( ( start >= existingStart && start < existingEnd ) || end > existingStart && end <= existingEnd ) { if ( Log . isLoggable ( TAG , Log . VERBOSE ) ) { CharSequence seq = spanText . subSequence ( start , end ) ; Log . v ( TAG , STR_ + seq + STR_ ) ; } return BOOL_ ; } } return BOOL_ ; }
private HashMap < Integer , Trie > buildLookupTable ( final Map < Integer , List < Trie > > childTries ) { HashMap < Integer , Trie > lookup = new HashMap < > ( childTries . size ( ) ) ; for ( int id : childTries . keySet ( ) ) { final List < Trie > tries = childTries . get ( id ) ; if ( tries . size ( ) == NUM_ ) { lookup . put ( id , tries . get ( NUM_ ) ) ; } else { lookup . put ( id , new SliceAggregatingTrie ( tries ) ) ; } } return lookup ; }
public void addMarker ( int x , int z , Color color ) { MapMarker marker = new MapMarker ( ) ; marker . x = x ; marker . z = z ; marker . color = color ; markers . add ( marker ) ; }
private void commitDiscard ( long time , boolean allowDiscard ) { if ( mDiscardingTab == null ) return ; assert mStackTabs != null ; StackTab discarded = mDiscardingTab ; if ( Math . abs ( discarded . getDiscardAmount ( ) ) / getDiscardRange ( ) > DISCARD_COMMIT_THRESHOLD && allowDiscard ) { mLayout . uiRequestingCloseTab ( time , discarded . getId ( ) ) ; RecordUserAction . record ( STR_ ) ; RecordUserAction . record ( STR_ ) ; } else { startAnimation ( time , OverviewAnimationType . UNDISCARD ) ; } mDiscardingTab = null ; requestUpdate ( ) ; }
public List < Object > buildJavaMethodParameters ( AssetOptionsContext context , Map < String , String > availableAssets , AssetOptionsMethodInfo assetMethod ) { final List < Object > javaMethodParameters = Lists . newArrayList ( ) ; javaMethodParameters . add ( context ) ; for ( String parentAssetName : assetMethod . assetDependencies ) { String parentAssetValue = availableAssets . get ( parentAssetName ) ; int index = javaMethodParameters . size ( ) ; Object value = assetMethod . convertParameter ( index , parentAssetValue ) ; javaMethodParameters . add ( value ) ; } return javaMethodParameters ; }
private static ImageView pickGraphic ( RestartableService startStoppable ) { final boolean running = startStoppable . isRunning ( ) ; final ImageView icon = running ? new ImageView ( stopImage ) : new ImageView ( startImage ) ; if ( ! running ) { final FadeTransition ft = new FadeTransition ( Duration . millis ( NUM_ ) , icon ) ; ft . setToValue ( NUM_ ) ; ft . setCycleCount ( Transition . INDEFINITE ) ; ft . setAutoReverse ( BOOL_ ) ; ft . play ( ) ; } icon . setFitHeight ( DPIUtility . MINI_ICON_SIZE ) ; icon . setFitWidth ( DPIUtility . MINI_ICON_SIZE ) ; return icon ; }
public static boolean isExtension ( String filename , String extension ) { if ( filename == null ) { return BOOL_ ; } if ( extension == null || extension . length ( ) == NUM_ ) { return indexOfExtension ( filename ) == - NUM_ ; } String fileExt = getExtension ( filename ) ; return fileExt . equals ( extension ) ; }
public void createCashBasedJournalEntriesAndReversalsForSavingsCharges ( final Office office , final String currencyCode , final CASH_ACCOUNTS_FOR_SAVINGS accountTypeToBeDebited , final CASH_ACCOUNTS_FOR_SAVINGS accountTypeToBeCredited , final Long savingsProductId , final Long paymentTypeId , final Long loanId , final String transactionId , final Date transactionDate , final BigDecimal totalAmount , final Boolean isReversal , final List < ChargePaymentDTO > chargePaymentDTOs ) { if ( chargePaymentDTOs . size ( ) != NUM_ ) { throw new PlatformDataIntegrityException ( STR_ , STR_ ) ; } ChargePaymentDTO chargePaymentDTO = chargePaymentDTOs . get ( NUM_ ) ; final GLAccount chargeSpecificAccount = getLinkedGLAccountForSavingsCharges ( savingsProductId , accountTypeToBeCredited . getValue ( ) , chargePaymentDTO . getChargeId ( ) ) ; final GLAccount savingsControlAccount = getLinkedGLAccountForSavingsProduct ( savingsProductId , accountTypeToBeDebited . getValue ( ) , paymentTypeId ) ; if ( isReversal ) { createDebitJournalEntryForSavings ( office , currencyCode , chargeSpecificAccount , loanId , transactionId , transactionDate , totalAmount ) ; createCreditJournalEntryForSavings ( office , currencyCode , savingsControlAccount , loanId , transactionId , transactionDate , totalAmount ) ; } else { createDebitJournalEntryForSavings ( office , currencyCode , savingsControlAccount , loanId , transactionId , transactionDate , totalAmount ) ; createCreditJournalEntryForSavings ( office , currencyCode , chargeSpecificAccount , loanId , transactionId , transactionDate , totalAmount ) ; } }
public void addAll ( JsonArray array ) { elements . addAll ( array . elements ) ; }
public void testListOptions ( ) { if ( m_OptionTester . getOptionHandler ( ) != null ) { if ( ! m_OptionTester . checkListOptions ( ) ) { fail ( STR_ ) ; } } }
@ Override final public void mouseReleased ( MouseEvent e ) { if ( isComponentPressedDown ) { mouseLiberalClick ( e ) ; long now = System . currentTimeMillis ( ) ; long timeBetweenUnusedClicks = now - lastUnusedLiberalSingleClickTimeStamp ; if ( timeBetweenUnusedClicks <= slowestDoubleClickMilliseconds ) { mouseLiberalDoubleClick ( e ) ; lastUnusedLiberalSingleClickTimeStamp = NUM_ ; } else { lastUnusedLiberalSingleClickTimeStamp = System . currentTimeMillis ( ) ; } } isComponentPressedDown = BOOL_ ; mouseRelease ( e ) ; }
public static ModificationType valueOf ( final int intValue ) { ModificationType result = null ; if ( NUM_ <= intValue && intValue < ELEMENTS . length ) { result = ELEMENTS [ intValue ] ; } if ( result == null ) { result = new ModificationType ( intValue , STR_ + intValue + STR_ , Enum . UNKNOWN ) ; } return result ; }
@ Override public void fillHeader ( Header hdr ) { try { Standard . context ( AsciiTable . class ) ; hdr . setXtension ( STR_ ) ; hdr . setBitpix ( BasicHDU . BITPIX_BYTE ) ; hdr . setNaxes ( NUM_ ) ; hdr . setNaxis ( NUM_ , this . rowLen ) ; hdr . setNaxis ( NUM_ , this . nRows ) ; Cursor < String , HeaderCard > iter = hdr . iterator ( ) ; iter . setKey ( NAXIS2 . key ( ) ) ; iter . next ( ) ; iter . add ( new HeaderCard ( PCOUNT . key ( ) , NUM_ , PCOUNT . comment ( ) ) ) ; iter . add ( new HeaderCard ( GCOUNT . key ( ) , NUM_ , GCOUNT . comment ( ) ) ) ; iter . add ( new HeaderCard ( TFIELDS . key ( ) , this . nFields , TFIELDS . comment ( ) ) ) ; for ( int i = NUM_ ; i < this . nFields ; i += NUM_ ) { addColInfo ( i , iter ) ; } } catch ( HeaderCardException e ) { LOG . log ( Level . SEVERE , STR_ + e . getMessage ( ) , e ) ; } finally { Standard . context ( null ) ; } }
private boolean searchEndMatch ( final String itemName ) { for ( Map . Entry < String , Sentence > e : parsedNames . entrySet ( ) ) { Sentence parsed = e . getValue ( ) ; if ( itemName . endsWith ( parsed . getOriginalText ( ) ) || itemName . endsWith ( parsed . getNormalized ( ) ) ) { name = e . getKey ( ) ; return BOOL_ ; } } return BOOL_ ; }
private static byte expectedNorm ( final DefaultSimilarity sim , final int length , final float boost ) { return ( byte ) sim . encodeNormValue ( boost / ( ( float ) Math . sqrt ( length ) ) ) ; }
public void testCompareToEqualNeg ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = - NUM_ ; int bSign = - NUM_ ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; assertEquals ( NUM_ , aNumber . compareTo ( bNumber ) ) ; }
@ Override public ShapeTileSimplex enlarge ( double p_offset ) { if ( p_offset == NUM_ ) return this ; ShapeTileSimplex offset_simplex = offset ( p_offset ) ; ShapeTileOctagon bounding_oct = bounding_octagon ( ) ; if ( bounding_oct . is_NaN ( ) ) return ShapeTileSimplex . EMPTY ; ShapeTileOctagon offset_oct = bounding_oct . offset ( p_offset ) ; return offset_simplex . intersection ( offset_oct . to_Simplex ( ) ) ; }
V remove ( Object key , int hash , Object value ) { lock ( ) ; try { int c = cnt - NUM_ ; HE < K , V > [ ] tab = table ; int index = hash & ( tab . length - NUM_ ) ; HE < K , V > first = tab [ index ] ; HE < K , V > e = first ; while ( e != null && ( e . hash != hash || ! key . equals ( e . k ) ) ) e = e . next ; V oldValue = null ; if ( e != null ) { V v = e . v ; if ( value == null || value . equals ( v ) ) { oldValue = v ; ++ modCnt ; HE < K , V > newFirst = e . next ; for ( HE < K , V > p = first ; p != e ; p = p . next ) newFirst = new HE < K , V > ( p . k , p . hash , newFirst , p . v ) ; tab [ index ] = newFirst ; cnt = c ; } } return oldValue ; } finally { unlock ( ) ; } }
public static TreePath pathTillOfKind ( final TreePath path , final Tree . Kind kind ) { return pathTillOfKind ( path , EnumSet . of ( kind ) ) ; }
public BigDecimal readF2Dot14 ( int index ) { throw new UnsupportedOperationException ( ) ; }
public int size ( ) { return set . size ( ) ; }
private void writeAttribute ( java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( namespace . equals ( STR_ ) ) { xmlWriter . writeAttribute ( attName , attValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } }
public void addRenderingHints ( Map < ? , ? > hints ) { mGraphics . addRenderingHints ( hints ) ; }
private void createNewFieldsArray ( ) { for ( int i = NUM_ ; i < personFieldsOld . length ; i ++ ) { personFieldsNew [ i ] = personFieldsOld [ i ] + STR_ ; } }
public void removeAllRelations ( ) { for ( BNode inputNode : new LinkedList < BNode > ( inputNodes . values ( ) ) ) { removeInputNode ( inputNode . getId ( ) ) ; } for ( BNode outputNode : new LinkedList < BNode > ( outputNodes . values ( ) ) ) { removeOutputNode ( outputNode . getId ( ) ) ; } }
private void addExposedTypes ( Class < ? > clazz , Class < ? > cause ) { if ( pruned ( clazz ) ) { return ; } boolean alreadyDone = done ( clazz ) ; visit ( clazz ) ; recordExposure ( clazz , cause ) ; if ( alreadyDone || pruned ( clazz ) ) { return ; } TypeToken < ? > token = TypeToken . of ( clazz ) ; for ( TypeToken < ? > superType : token . getTypes ( ) ) { if ( ! superType . equals ( token ) ) { logger . debug ( STR_ , superType , clazz ) ; addExposedTypes ( superType , clazz ) ; } } for ( Class innerClass : clazz . getDeclaredClasses ( ) ) { if ( exposed ( innerClass . getModifiers ( ) ) ) { logger . debug ( STR_ , innerClass , clazz ) ; addExposedTypes ( innerClass , clazz ) ; } } for ( Field field : clazz . getDeclaredFields ( ) ) { if ( exposed ( field . getModifiers ( ) ) ) { logger . debug ( STR_ , field , clazz ) ; addExposedTypes ( field , clazz ) ; } } for ( Invokable invokable : getExposedInvokables ( token ) ) { logger . debug ( STR_ , invokable , clazz ) ; addExposedTypes ( invokable , clazz ) ; } }
public void storeLogs ( File folder ) { String path = folder . getAbsolutePath ( ) ; mLoggerFolder = new LogThis ( path ) ; }
@ Override public Object clone ( ) { return new LocationPath ( this ) ; }
private Assignment recursiveBackTrackingSearch ( CSP csp , Assignment assignment ) { Assignment result = null ; if ( assignment . isComplete ( csp . getVariables ( ) ) ) { result = assignment ; } else { Variable var = selectUnassignedVariable ( assignment , csp ) ; for ( Object value : orderDomainValues ( var , assignment , csp ) ) { assignment . setAssignment ( var , value ) ; fireStateChanged ( assignment , csp ) ; if ( assignment . isConsistent ( csp . getConstraints ( var ) ) ) { DomainRestoreInfo info = inference ( var , assignment , csp ) ; if ( ! info . isEmpty ( ) ) fireStateChanged ( csp ) ; if ( ! info . isEmptyDomainFound ( ) ) { result = recursiveBackTrackingSearch ( csp , assignment ) ; if ( result != null ) break ; } info . restoreDomains ( csp ) ; } assignment . removeAssignment ( var ) ; } } return result ; }
private static JSONObject createFileTransferError ( int errorCode , String source , String target , String body , Integer httpStatus ) { JSONObject error = null ; try { error = new JSONObject ( ) ; error . put ( STR_ , errorCode ) ; error . put ( STR_ , source ) ; error . put ( STR_ , target ) ; if ( body != null ) { error . put ( STR_ , body ) ; } if ( httpStatus != null ) { error . put ( STR_ , httpStatus ) ; } } catch ( JSONException e ) { Log . e ( LOG_TAG , e . getMessage ( ) , e ) ; } return error ; }
public ArrayList < Value > keys ( ) { ArrayList < Value > list = New . arrayList ( size ) ; for ( Value k : keys ) { if ( k != null && k != ValueNull . DELETED ) { list . add ( k ) ; } } return list ; }
private void close ( ) { if ( closed ) { return ; } closed = BOOL_ ; try { resultSet . close ( ) ; } catch ( final SQLException e ) { logger . error ( e , e ) ; } try { if ( statement != null ) { statement . close ( ) ; } } catch ( final SQLException e ) { logger . error ( e , e ) ; } }
public DeliveryThread ( TOMLayer tomLayer , ServiceReplica receiver , Recoverable recoverer , ServerViewController controller ) { super ( STR_ ) ; this . decided = new LinkedBlockingQueue < > ( ) ; this . tomLayer = tomLayer ; this . receiver = receiver ; this . recoverer = recoverer ; this . controller = controller ; }
protected void addButtonListener ( ) { ApplicationInsightsAddDialog dialog = new ApplicationInsightsAddDialog ( getShell ( ) ) ; dialog . open ( ) ; tableViewer . refresh ( ) ; }
public int [ ] toArray ( ) { int [ ] result = new int [ size ] ; System . arraycopy ( array , NUM_ , result , NUM_ , size ) ; return result ; }
public Block obtainBlock ( String prototypeName , @ Nullable String uuid ) { Block block ; if ( uuid != null ) { WeakReference < Block > ref = mBlockRefs . get ( uuid ) ; if ( ref != null ) { block = ref . get ( ) ; if ( block != null ) { throw new IllegalArgumentException ( STR_ + uuid + STR_ ) ; } } } if ( ! mBlockTemplates . containsKey ( prototypeName ) ) { Log . w ( TAG , STR_ + prototypeName + STR_ ) ; return null ; } Block . Builder builder = new Block . Builder ( mBlockTemplates . get ( prototypeName ) ) ; if ( uuid != null ) { builder . setUuid ( uuid ) ; } block = builder . build ( ) ; mBlockRefs . put ( block . getId ( ) , new WeakReference < Block > ( block ) ) ; return block ; }
public SmsConsoleServiceConfig ( ) { Document doc = parseDocument ( CONFIG_FILENAME ) ; configServices ( doc ) ; hiddenServices = Collections . unmodifiableSet ( services . get ( HIDDEN_SERVICES ) ) ; }
@ Override protected void onSizeChanged ( int w , int h , int oldw , int oldh ) { super . onSizeChanged ( w , h , oldw , oldh ) ; setupBounds ( w , h ) ; setupPaints ( ) ; invalidate ( ) ; }
private static String convertToQuotedString ( String s ) { if ( s == null || s . isEmpty ( ) ) { return null ; } if ( s . charAt ( NUM_ ) == STR_ && s . charAt ( s . length ( ) - NUM_ ) == STR_ ) { return s ; } return STR_ + s + STR_ ; }
public PatternObserverExpr ( String namespace , String name , Expression [ ] parameters ) { super ( namespace , name , Arrays . asList ( parameters ) ) ; }
public static String convertStringToHexString ( String data ) { return conventBytesToHexString ( data . getBytes ( ) ) ; }
public boolean isTransient ( ) { return Modifier . isTransient ( getAccessFlags ( ) ) ; }
public boolean isForHTTPBasic ( ) { return ( negoValue != null ) ? negoValue . equalsIgnoreCase ( HTTP_HTTPBASIC ) : BOOL_ ; }
private String indent ( int level ) { final String s = STR_ ; if ( level == NUM_ ) return STR_ ; StringBuilder sb = new StringBuilder ( level . s . length ( ) ) ; for ( int i = NUM_ ; i < level ; i ++ ) { sb . append ( s ) ; } return s . toString ( ) ; }
public static String cut ( String line , IntPredicate testFunction ) { String s = STR_ ; int pos = SubParser . locate ( line , testFunction ) ; if ( pos != - NUM_ ) { s = line . substring ( NUM_ , pos ) ; } return s ; }
public void addListener ( UpdateManagerListener listener ) { listeners . add ( listener ) ; }
@ Override public void run ( ) { List < Span > dequeuedSpans = new ArrayList < Span > ( maxSpanBatchSize ) ; long errorCount = NUM_ ; while ( running . get ( ) || queue . size ( ) > NUM_ ) { Span firstSpan = null ; try { firstSpan = queue . poll ( NUM_ , TimeUnit . SECONDS ) ; if ( firstSpan != null ) { dequeuedSpans . add ( firstSpan ) ; queue . drainTo ( dequeuedSpans , maxSpanBatchSize - NUM_ ) ; } } catch ( InterruptedException ie ) { } startClient ( ) ; if ( dequeuedSpans . isEmpty ( ) ) { continue ; } try { List < Event > events = new ArrayList < Event > ( dequeuedSpans . size ( ) ) ; for ( Span span : dequeuedSpans ) { Map < String , String > headers = new HashMap < String , String > ( ) ; headers . put ( STR_ , span . toString ( ) ) ; headers . put ( STR_ , span . getTracerId ( ) ) ; headers . put ( STR_ , span . getDescription ( ) ) ; String body = span . toJson ( ) ; Event evt = EventBuilder . withBody ( body , Charset . forName ( STR_ ) , headers ) ; events . add ( evt ) ; } flumeClient . appendBatch ( events ) ; dequeuedSpans . clear ( ) ; errorCount = NUM_ ; } catch ( Exception e ) { errorCount += NUM_ ; if ( errorCount < MAX_ERRORS ) { try { queue . addAll ( dequeuedSpans ) ; } catch ( IllegalStateException ex ) { LOG . error ( STR_ + dequeuedSpans . size ( ) + STR_ ) ; } } closeClient ( ) ; try { Thread . sleep ( NUM_ ) ; } catch ( InterruptedException e1 ) { } } } closeClient ( ) ; }
public void cancelAuthentication ( ) { synchronized ( syncLock ) { authenticating = BOOL_ ; timer . cancel ( ) ; timer . purge ( ) ; } }
private void checkValidInterval ( Duration pollingInterval , int retries , long timeSleptMillis ) { long highSum = NUM_ ; long lowSum = NUM_ ; for ( int i = NUM_ ; i < retries ; i ++ ) { double currentInterval = pollingInterval . getMillis ( ) . Math . pow ( DataflowPipelineJob . DEFAULT_BACKOFF_EXPONENT , i ) ; double randomOffset = NUM_ . currentInterval ; highSum += Math . round ( currentInterval + randomOffset ) ; lowSum += Math . round ( currentInterval - randomOffset ) ; } assertThat ( timeSleptMillis , allOf ( greaterThanOrEqualTo ( lowSum ) , lessThanOrEqualTo ( highSum ) ) ) ; }
public void write ( String str , int off , int len ) throws IOException { if ( _outputStream == null ) throw new IOException ( STR_ ) ; final int off_plus_len = off + len ; for ( int i = off ; i < off_plus_len ; ) { char c = str . charAt ( i ++ ) ; if ( c < x80 ) { _bytes [ _index ] = ( byte ) c ; if ( ++ _index >= _bytes . length ) { flushBuffer ( ) ; } } else { write ( c ) ; } } }
public CommitRecordIndex ( IRawStore store , Checkpoint checkpoint , IndexMetadata metadata , boolean readOnly ) { super ( store , checkpoint , metadata , readOnly ) ; this . ser = new Entry . EntrySerializer ( ) ; }
protected String encodeBody ( ) { return Long . toString ( this . sequenceNumber ) ; }
public void addContainer ( ImageContainer container ) { mContainers . add ( container ) ; }
private void checkSize ( final int i ) { if ( i >= max_size ) { final int old_size = max_size ; max_size += increment_size ; if ( max_size <= i ) { max_size = i + increment_size + NUM_ ; } final Rectangle [ ] temp = items ; items = new Rectangle [ max_size ] ; System . arraycopy ( temp , NUM_ , items , NUM_ , old_size ) ; increment_size = incrementSize ( increment_size ) ; } }
public static double [ ] genPulseFromFourierMag ( double [ ] mag , double f0 ) { int numHarm = mag . length ; int currentF0 = ( int ) Math . round ( f0 ) ; int T ; if ( currentF0 < NUM_ ) T = NUM_ ; else T = NUM_ ; int T2 = NUM_ . T ; double [ ] pulse = new double [ T ] ; double [ ] real = new double [ T2 ] ; double [ ] imag = new double [ T2 ] ; real [ NUM_ ] = real [ T ] = NUM_ ; for ( int i = NUM_ ; i <= numHarm ; i ++ ) { real [ i ] = real [ T - i ] = real [ T + i ] = real [ T2 - i ] = mag [ i - NUM_ ] ; imag [ i ] = imag [ T - i ] = imag [ T + i ] = imag [ T2 - i ] = NUM_ ; } for ( int i = ( numHarm + NUM_ ) ; i < ( T - numHarm ) ; i ++ ) { real [ i ] = real [ T - i ] = real [ T + i ] = real [ T2 - i ] = NUM_ ; imag [ i ] = imag [ T - i ] = imag [ T + i ] = imag [ T2 - i ] = NUM_ ; } FFT . transform ( real , imag , BOOL_ ) ; double sqrt_f0 = Math . sqrt ( currentF0 ) ; for ( int i = NUM_ ; i < T ; i ++ ) pulse [ i ] = real [ ( i - numHarm ) % T ] . sqrt_f0 ; return pulse ; }
static String _targetSoFile ( String libName , int version ) { Context context = mContext ; if ( null == context ) { return STR_ ; } String path = STR_ + context . getPackageName ( ) + STR_ ; File f = context . getFilesDir ( ) ; if ( f != null ) { path = f . getPath ( ) ; } return path + STR_ + libName + STR_ + version + STR_ ; }
@ Override public void stopMonitoring ( ) { stopMonitoring ( BOOL_ ) ; }
@ Override public Object compute ( ArrayList < Map < String , Object > > rows ) throws Exception { if ( column . equals ( STR_ ) ) { return rows . size ( ) ; } long count = NUM_ ; for ( Map < String , Object > row : rows ) { if ( row . containsKey ( column ) && ( row . get ( column ) != null ) ) { count ++ ; } } return count ; }
private Property [ ] parseProperties ( final String contents ) { final String [ ] parts = contents . split ( STR_ ) ; final List < Property > resultsAsList = new ArrayList < Property > ( ) ; for ( String part : parts ) { try { if ( ! StringUtils . isEmpty ( part . trim ( ) ) ) { resultsAsList . add ( new Property ( part ) ) ; } } catch ( final Exception e ) { LOG . warn ( e . getMessage ( ) , e ) ; } } return resultsAsList . toArray ( new Property [ resultsAsList . size ( ) ] ) ; }
public void requestSecondsUntilAccountExpiration ( ) { operations . add ( PasswordPolicyStateOperationType . GET_SECONDS_UNTIL_ACCOUNT_EXPIRATION ) ; }
public final boolean equalsIgnoreCase ( String a ) { int len = a . length ( ) ; if ( _length != len ) return BOOL_ ; int offset = _offset ; char [ ] buffer = _buffer ; for ( int i = NUM_ ; i < len ; i ++ ) { char ca = buffer [ offset + i ] ; char cb = a . charAt ( i ) ; if ( ca == cb ) { } else if ( Character . toLowerCase ( ca ) != Character . toLowerCase ( cb ) ) return BOOL_ ; } return BOOL_ ; }
public static int [ ] checkObjectStart ( PdfTokenizer lineTokenizer ) { try { lineTokenizer . seek ( NUM_ ) ; if ( ! lineTokenizer . nextToken ( ) || lineTokenizer . getTokenType ( ) != TokenType . Number ) return null ; int num = lineTokenizer . getIntValue ( ) ; if ( ! lineTokenizer . nextToken ( ) || lineTokenizer . getTokenType ( ) != TokenType . Number ) return null ; int gen = lineTokenizer . getIntValue ( ) ; if ( ! lineTokenizer . nextToken ( ) ) return null ; if ( ! Arrays . equals ( Obj , lineTokenizer . getByteContent ( ) ) ) return null ; return new int [ ] { num , gen } ; } catch ( Exception ioe ) { } return null ; }
private Object singleElement ( int row , int col ) { Object res = null ; if ( this . isNull == null || ! this . isNull [ row . this . nFields + col ] ) { res = ArrayFuncs . newInstance ( this . types [ col ] , NUM_ ) ; System . arraycopy ( this . data [ col ] , row , res , NUM_ , NUM_ ) ; } return res ; }
private char convertToChar ( String kurzname ) { char result = KEIN_SIEGEL ; if ( kurzname != null && ! kurzname . isEmpty ( ) ) { if ( kurzname . length ( ) > NUM_ ) { result = kurzname . toCharArray ( ) [ NUM_ ] ; } else { result = kurzname . toCharArray ( ) [ NUM_ ] ; } } return result ; }
public NodeSetDTM ( NodeIterator iterator , XPathContext xctxt ) { super ( ) ; Node node ; m_manager = xctxt . getDTMManager ( ) ; while ( null != ( node = iterator . nextNode ( ) ) ) { int handle = xctxt . getDTMHandleFromNode ( node ) ; addNodeInDocOrder ( handle , xctxt ) ; } }
public static Vec meanVector ( DataSet dataSet ) { DenseVector dv = new DenseVector ( dataSet . getNumNumericalVars ( ) ) ; meanVector ( dv , dataSet ) ; return dv ; }
private void makeCacheDirectory ( ) { File cacheDir = new File ( CACHE_DIRECTORY ) ; if ( ! cacheDir . exists ( ) ) { cacheDir . mkdir ( ) ; } }
public void inputKeyevent ( int value ) { executeCommandQuietly ( adbCommand ( STR_ , STR_ , STR_ , STR_ + value ) ) ; try { Thread . sleep ( NUM_ ) ; } catch ( InterruptedException e ) { log . warn ( STR_ , e ) ; } }
public static void passMockSleep ( ) { mockSleepQueue . offer ( BOOL_ ) ; }
private static File createReserveDiskCacheDir ( Context context ) { File cacheDir = StorageUtils . getCacheDirectory ( context , BOOL_ ) ; File individualDir = new File ( cacheDir , STR_ ) ; if ( individualDir . exists ( ) || individualDir . mkdir ( ) ) { cacheDir = individualDir ; } return cacheDir ; }
JSONStringer close ( Scope empty , Scope nonempty , String closeBracket ) throws JSONException { Scope context = peek ( ) ; if ( context != nonempty && context != empty ) { throw new JSONException ( STR_ ) ; } stack . remove ( stack . size ( ) - NUM_ ) ; if ( context == nonempty ) { newline ( ) ; } out . append ( closeBracket ) ; return this ; }
private QueryBuilder buildSort ( ) { QueryBuilder builder = new QueryBuilder ( ) ; Iterator < String > sortIterator = mSortingOrderList . iterator ( ) ; while ( sortIterator . hasNext ( ) ) { builder . append ( sortIterator . next ( ) ) ; if ( sortIterator . hasNext ( ) ) builder . append ( STR_ ) ; } return builder ; }
public void init ( int mode , byte [ ] key , byte [ ] iv ) { context = OpenSslNative . init ( context , mode , algorithm , padding , key , iv ) ; }
private String diff_wordsToCharsMunge ( String text , List < String > lineArray , Map < String , Integer > lineHash ) { int lineStart = NUM_ ; int lineEnd = - NUM_ ; String line ; StringBuilder chars = new StringBuilder ( ) ; while ( lineEnd < text . length ( ) - NUM_ ) { String patternStr = STR_ ; Pattern pattern = Pattern . compile ( patternStr ) ; Matcher matcher = pattern . matcher ( text ) ; matcher . region ( lineStart , text . length ( ) ) ; if ( matcher . find ( ) ) { lineEnd = matcher . start ( ) ; } else lineEnd = - NUM_ ; if ( lineEnd == - NUM_ ) { lineEnd = text . length ( ) - NUM_ ; } line = text . substring ( lineStart , lineEnd + NUM_ ) ; lineStart = lineEnd + NUM_ ; if ( lineHash . containsKey ( line ) ) { chars . append ( String . valueOf ( ( char ) ( int ) lineHash . get ( line ) ) ) ; } else { lineArray . add ( line ) ; lineHash . put ( line , lineArray . size ( ) - NUM_ ) ; chars . append ( String . valueOf ( ( char ) ( lineArray . size ( ) - NUM_ ) ) ) ; } } return chars . toString ( ) ; }
private void replaceTop ( Scope topOfStack ) { stack . set ( stack . size ( ) - NUM_ , topOfStack ) ; }
public boolean hasNext ( ) { return index < desc . length ( ) ; }
public void registerSessionThread ( SessionThread newSession ) { synchronized ( this ) { List < SessionThread > toBeRemoved = new ArrayList < SessionThread > ( ) ; for ( SessionThread sessionThread : sessionThreads ) { if ( ! sessionThread . isAlive ( ) ) { Log . d ( TAG , STR_ ) ; try { sessionThread . join ( ) ; Log . d ( TAG , STR_ ) ; toBeRemoved . add ( sessionThread ) ; sessionThread . closeSocket ( ) ; } catch ( InterruptedException e ) { Log . d ( TAG , STR_ ) ; } } } for ( SessionThread removeThread : toBeRemoved ) { sessionThreads . remove ( removeThread ) ; } sessionThreads . add ( newSession ) ; } Log . d ( TAG , STR_ ) ; }
protected IObjectInfo < T > store_impl ( Segment < T > segment , ObjectInfo < T > oi ) { if ( _invalid ) return null ; _size . incrementAndGet ( ) ; segment . incrementSize ( ) ; ObjectInfo < T > tail = segment . getTail ( ) ; tail . setForwardRef ( oi ) ; oi . setBackwardRef ( tail ) ; segment . setTail ( oi ) ; return oi ; }
public TeXFormula ( ) { parser = new TeXParser ( STR_ , this , BOOL_ ) ; }
public static void grayToBinary ( BinaryVariable variable ) { int n = variable . getNumberOfBits ( ) ; BitSet gray = variable . getBitSet ( ) ; variable . set ( n - NUM_ , gray . get ( n - NUM_ ) ) ; for ( int i = n - NUM_ ; i >= NUM_ ; i -- ) { variable . set ( i , variable . get ( i + NUM_ ) ^ gray . get ( i ) ) ; } }
private void updateTags ( Movie movie ) { List < String > availableTags = new ArrayList < > ( tagsObservable ) ; for ( String tagInMovie : new ArrayList < > ( movie . getTags ( ) ) ) { boolean tagFound = BOOL_ ; for ( String tag : availableTags ) { if ( tagInMovie . equals ( tag ) ) { tagFound = BOOL_ ; break ; } } if ( ! tagFound ) { addTag ( tagInMovie ) ; } } }
protected void removeNextProtocolMessages ( List < ProtocolMessage > protocolMessages , int fromIndex ) { for ( int i = protocolMessages . size ( ) - NUM_ ; i >= fromIndex ; i -- ) { protocolMessages . remove ( i ) ; } }
public static double sigmoid ( double x ) { return NUM_ / ( NUM_ + Math . pow ( Math . E , - x ) ) ; }
public void testRadix36Neg ( ) { String value = STR_ ; int radix = NUM_ ; BigInteger aNumber = new BigInteger ( value , radix ) ; String result = aNumber . toString ( radix ) ; assertTrue ( result . equals ( value ) ) ; }
public UCIBestMove stop ( ) { if ( ! isConnected ( ) ) { throw new IllegalStateException ( STR_ ) ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( STR_ ) ; } UCIBestMove result = null ; synchronized ( stopSynch ) { if ( ! isProcessingGo ( ) ) { result = lastBestMove ; lastBestMove = null ; } else { long totalSleepTime = NUM_ ; send ( STR_ ) ; while ( goRunnable != null && totalSleepTime < NUM_ ) { try { Thread . sleep ( NUM_ ) ; totalSleepTime += NUM_ ; } catch ( InterruptedException ie ) { } } result = lastBestMove ; lastBestMove = null ; } } return result ; }
@ Override public boolean supportsDataDefinitionAndDataManipulationTransactions ( ) { debugCodeCall ( STR_ ) ; return BOOL_ ; }
public static void removeJavaNoOpLogger ( Collection < Handler > rmvHnds ) { Logger log = Logger . getLogger ( STR_ ) ; for ( Handler h : log . getHandlers ( ) ) log . removeHandler ( h ) ; if ( ! F . isEmpty ( rmvHnds ) ) { for ( Handler h : rmvHnds ) log . addHandler ( h ) ; } }
public void onConfigurationChanged ( ) { int curFirst = pager . getCurrentScreen ( ) . PAGE_SIZE ; calPageSize ( ) ; int newPage = curFirst / PAGE_SIZE ; removeViewAt ( NUM_ ) ; afterPlatformListGot ( ) ; pager . setCurrentScreen ( newPage ) ; }
private int binarySearch ( final int start , final int end , final SizeTester sizeTester , final RectF availableSpace ) { int lastBest = start ; int low = start ; int high = end - NUM_ ; int middle ; while ( low <= high ) { middle = low + high > > > NUM_ ; final int midValCmp = sizeTester . onTestSize ( middle , availableSpace ) ; if ( midValCmp < NUM_ ) { lastBest = low ; low = middle + NUM_ ; } else if ( midValCmp > NUM_ ) { high = middle - NUM_ ; lastBest = high ; } else return middle ; } return lastBest ; }
protected boolean isValidDomain ( String domain ) { Matcher ipDomainMatcher = IP_DOMAIN_PATTERN . matcher ( domain ) ; if ( ipDomainMatcher . matches ( ) ) { InetAddressValidator inetAddressValidator = InetAddressValidator . getInstance ( ) ; return inetAddressValidator . isValid ( ipDomainMatcher . group ( NUM_ ) ) ; } DomainValidator domainValidator = DomainValidator . getInstance ( allowLocal ) ; return domainValidator . isValid ( domain ) || domainValidator . isValidTld ( domain ) ; }
public void tableSwitch ( final int [ ] keys , final TableSwitchGenerator generator , final boolean useTable ) { for ( int i = NUM_ ; i < keys . length ; ++ i ) { if ( keys [ i ] < keys [ i - NUM_ ] ) { throw new IllegalArgumentException ( STR_ ) ; } } Label def = newLabel ( ) ; Label end = newLabel ( ) ; if ( keys . length > NUM_ ) { int len = keys . length ; int min = keys [ NUM_ ] ; int max = keys [ len - NUM_ ] ; int range = max - min + NUM_ ; if ( useTable ) { Label [ ] labels = new Label [ range ] ; Arrays . fill ( labels , def ) ; for ( int i = NUM_ ; i < len ; ++ i ) { labels [ keys [ i ] - min ] = newLabel ( ) ; } mv . visitTableSwitchInsn ( min , max , def , labels ) ; for ( int i = NUM_ ; i < range ; ++ i ) { Label label = labels [ i ] ; if ( label != def ) { mark ( label ) ; generator . generateCase ( i + min , end ) ; } } } else { Label [ ] labels = new Label [ len ] ; for ( int i = NUM_ ; i < len ; ++ i ) { labels [ i ] = newLabel ( ) ; } mv . visitLookupSwitchInsn ( def , keys , labels ) ; for ( int i = NUM_ ; i < len ; ++ i ) { mark ( labels [ i ] ) ; generator . generateCase ( keys [ i ] , end ) ; } } } mark ( def ) ; generator . generateDefault ( ) ; mark ( end ) ; }
public void testRemainderKnuthMultiDigitsByOneDigit ( ) { byte aBytes [ ] = { NUM_ , - NUM_ , NUM_ , - NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ } ; byte bBytes [ ] = { NUM_ , - NUM_ , - NUM_ , - NUM_ } ; int aSign = NUM_ ; int bSign = - NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , - NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . remainder ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public void testTimedInvokeAny4 ( ) throws Throwable { ExecutorService e = new ForkJoinPool ( NUM_ ) ; PoolCleaner cleaner = null ; try { cleaner = cleaner ( e ) ; long startTime = System . nanoTime ( ) ; List < Callable < String > > l = new ArrayList < Callable < String > > ( ) ; l . add ( new NPETask ( ) ) ; try { e . invokeAny ( l , LONG_DELAY_MS , MILLISECONDS ) ; shouldThrow ( ) ; } catch ( ExecutionException success ) { assertTrue ( success . getCause ( ) instanceof NullPointerException ) ; } assertTrue ( millisElapsedSince ( startTime ) < LONG_DELAY_MS ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
private void parse ( File dir ) { File [ ] xmlFiles = dir . listFiles ( new XmlFilter ( ) ) ; for ( File xmlFile : xmlFiles ) { parseTestFromXml ( xmlFile ) ; } }
public boolean hasNext ( int index ) { for ( int p = NUM_ ; p < mask . length ; p ++ ) { if ( mask [ p ] ) { if ( index <= lastElementIndex [ p ] ) { return BOOL_ ; } } } return BOOL_ ; }
public static boolean isExternalStorageAvailable ( ) { String state = Environment . getExternalStorageState ( ) ; if ( state . equals ( Environment . MEDIA_MOUNTED ) ) { return BOOL_ ; } else { return BOOL_ ; } }
public TarEntry ( byte [ ] headerBuf ) { this ( ) ; parseTarHeader ( headerBuf ) ; }
public static void unregisterMbeans ( MBeanServer mBeanServer ) { try { mBeanServer . unregisterMBean ( Log4jMXBeanImp . getObjectName ( ) ) ; mBeanServer . unregisterMBean ( ExceptionMXBeanImp . getObjectName ( ) ) ; mBeanServer . unregisterMBean ( ExceptionDeltaMXBeanImp . getObjectName ( ) ) ; mBeanServer . unregisterMBean ( Log4jDeltaMXBeanImp . getObjectName ( ) ) ; mBeanServer . unregisterMBean ( JamonMXBeanImp . getObjectName ( ) ) ; mBeanServer . unregisterMBean ( HttpStatusMXBeanImp . getObjectName ( ) ) ; mBeanServer . unregisterMBean ( HttpStatusDeltaMXBeanImp . getObjectName ( ) ) ; unregisterGcMXBean ( mBeanServer ) ; unregisterMbeansFromPropsFile ( mBeanServer ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
public static DeterministicKey createMasterPrivateKey ( byte [ ] seed ) throws HDDerivationException { checkArgument ( seed . length > NUM_ , STR_ ) ; byte [ ] i = HDUtils . hmacSha512 ( MASTER_HMAC_SHA512 , seed ) ; checkState ( i . length == NUM_ , i . length ) ; byte [ ] il = Arrays . copyOfRange ( i , NUM_ , NUM_ ) ; byte [ ] ir = Arrays . copyOfRange ( i , NUM_ , NUM_ ) ; Arrays . fill ( i , ( byte ) NUM_ ) ; DeterministicKey masterPrivKey = createMasterPrivKeyFromBytes ( il , ir ) ; Arrays . fill ( il , ( byte ) NUM_ ) ; Arrays . fill ( ir , ( byte ) NUM_ ) ; return masterPrivKey ; }
public boolean isNANPACountry ( String regionCode ) { return nanpaRegions . contains ( regionCode ) ; }
public void parse ( InputStream in ) throws IOException , SAXException { try { _xmlReader . setInput ( in ) ; parseAll ( ) ; } catch ( XMLStreamException e ) { if ( e . getNestedException ( ) instanceof IOException ) throw ( IOException ) e . getNestedException ( ) ; throw new SAXException ( e . getMessage ( ) ) ; } finally { _xmlReader . reset ( ) ; } }
@ Override public void printStackTrace ( PrintStream ps ) { super . printStackTrace ( ps ) ; if ( nested != null ) nested . printStackTrace ( ps ) ; }
public AMPassword ( char [ ] pw ) { int i ; int length = pw . length ; cleared = BOOL_ ; password = new char [ length ] ; System . arraycopy ( pw , NUM_ , password , NUM_ , length ) ; }
public void reset ( ) { firstStep = BOOL_ ; N3 = NUM_ ; N4 = NUM_ ; System . arraycopy ( IV , NUM_ , ofbV , NUM_ , IV . length ) ; byteCount = NUM_ ; cipher . reset ( ) ; }
private static img createControlButtonImage ( String name , String js_command , boolean enabled ) { StringBuffer imgName = new StringBuffer ( STR_ + name ) ; if ( ! enabled ) imgName . append ( STR_ ) ; imgName . append ( STR_ ) ; img img = new img ( MobileEnv . getImageDirectory ( imgName . toString ( ) ) , name ) ; if ( enabled ) img . setAlt ( Msg . getMsg ( AD_Language , name ) ) ; img . setID ( STR_ ) ; if ( js_command != null && js_command . length ( ) > NUM_ && enabled ) { img . setOnClick ( STR_ + FORM_NAME + STR_ + M_Command + STR_ + name + STR_ + js_command ) ; } return img ; }
public String [ ] toArray ( ) throws Exception { return Utils . splitOptions ( toCommandLine ( ) ) ; }
public static Set < EvalFactoryNode > recursiveGetChildNodes ( EvalFactoryNode currentNode , EvalNodeUtilFactoryFilter filter ) { Set < EvalFactoryNode > result = new LinkedHashSet < EvalFactoryNode > ( ) ; if ( filter . consider ( currentNode ) ) { result . add ( currentNode ) ; } recursiveGetChildNodes ( result , currentNode , filter ) ; return result ; }
void dispose ( ) { if ( popup != null ) { popup . removeAll ( ) ; } popup = null ; }
void checkFrameValue ( final Object value ) { if ( value == Opcodes . TOP || value == Opcodes . INTEGER || value == Opcodes . FLOAT || value == Opcodes . LONG || value == Opcodes . DOUBLE || value == Opcodes . NULL || value == Opcodes . UNINITIALIZED_THIS ) { return ; } if ( value instanceof String ) { checkInternalName ( ( String ) value , STR_ ) ; return ; } if ( ! ( value instanceof Label ) ) { throw new IllegalArgumentException ( STR_ + value ) ; } else { usedLabels . add ( ( Label ) value ) ; } }
@ Override public void endPrefixMapping ( String str ) throws SAXException { }
@ Override public void parse ( final Cookie cookie , final String value ) throws MalformedCookieException { if ( cookie == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( value == null ) { throw new MalformedCookieException ( STR_ ) ; } int age = - NUM_ ; try { age = Integer . parseInt ( value ) ; } catch ( final NumberFormatException e ) { age = - NUM_ ; } if ( age < NUM_ ) { throw new MalformedCookieException ( STR_ ) ; } cookie . setExpiryDate ( new Date ( System . currentTimeMillis ( ) + age . NUM_ ) ) ; }
public VariableConfigResource ( String configuration , TextResource baseResource ) { this ( baseResource ) ; for ( String configurationLine : configuration . split ( STR_ ) ) { String [ ] configSplit = configurationLine . split ( STR_ ) ; addConfig ( configSplit [ NUM_ ] , configSplit [ NUM_ ] ) ; } }
private static String readFile ( String fileName ) { String classMethod = STR_ ; StringBuilder fileData = new StringBuilder ( ) ; String fileString = STR_ ; try { BufferedReader reader = new BufferedReader ( new FileReader ( fileName ) ) ; char [ ] buf = new char [ NUM_ ] ; int numRead = NUM_ ; while ( ( numRead = reader . read ( buf ) ) != - NUM_ ) { String readData = String . valueOf ( buf , NUM_ , numRead ) ; fileData . append ( readData ) ; buf = new char [ NUM_ ] ; } reader . close ( ) ; fileString = fileData . toString ( ) ; } catch ( Exception e ) { debug . error ( classMethod + STR_ + fileName ) ; } return fileString ; }
public ScaleIOSnapshotVolumeResponse snapshotMultiVolume ( Map < String , String > id2snapshot , String systemId ) throws Exception { String uri = ScaleIOConstants . getSnapshotVolumesURI ( systemId ) ; ScaleIOSnapshotVolumes spVol = new ScaleIOSnapshotVolumes ( ) ; for ( Map . Entry < String , String > entry : id2snapshot . entrySet ( ) ) { spVol . addSnapshot ( entry . getKey ( ) , entry . getValue ( ) ) ; } ClientResponse response = post ( URI . create ( uri ) , getJsonForEntity ( spVol ) ) ; return getResponseObject ( ScaleIOSnapshotVolumeResponse . class , response ) ; }
@ Override public String toString ( ) { return STR_ + m_Width + STR_ + m_SumOfWeights + STR_ + m_TM . toString ( ) ; }
public synchronized void returnBuf ( byte [ ] buf ) { if ( buf == null || buf . length > mSizeLimit ) { return ; } mBuffersByLastUse . add ( buf ) ; int pos = Collections . binarySearch ( mBuffersBySize , buf , BUF_COMPARATOR ) ; if ( pos < NUM_ ) { pos = - pos - NUM_ ; } mBuffersBySize . add ( pos , buf ) ; mCurrentSize += buf . length ; trim ( ) ; }
public boolean isDraft ( ) { return draft != null && draft . booleanValue ( ) ; }
private WeatherUpdater ( ) { onTurnReached ( NUM_ ) ; }
protected void writeDataToFile ( NodeHolder nodeHolder ) throws CarbonDataWriterException { long offset = writeDataToFile ( nodeHolder , fileChannel ) ; BlockletInfoColumnar blockletInfo = getBlockletInfo ( nodeHolder , offset ) ; blockletInfoList . add ( blockletInfo ) ; }
protected Container createSideNavigationComponent ( Vector commands ) { return createSideNavigationComponent ( commands , null ) ; }
public static double min ( double [ ] a ) { double min = Double . POSITIVE_INFINITY ; for ( int i = NUM_ ; i < a . length ; i ++ ) { if ( Double . isNaN ( a [ i ] ) ) return Double . NaN ; if ( a [ i ] < min ) min = a [ i ] ; } return min ; }
@ Override public void onUpdateSelection ( int oldSelStart , int oldSelEnd , int newSelStart , int newSelEnd , int candidatesStart , int candidatesEnd ) { super . onUpdateSelection ( oldSelStart , oldSelEnd , newSelStart , newSelEnd , candidatesStart , candidatesEnd ) ; if ( mComposing . length ( ) > NUM_ && ( newSelStart != candidatesEnd || newSelEnd != candidatesEnd ) ) { mComposing . setLength ( NUM_ ) ; updateCandidates ( ) ; InputConnection ic = getCurrentInputConnection ( ) ; if ( ic != null ) { ic . finishComposingText ( ) ; } } }
public < T > T mapTo ( final Class < T > mappingClass ) { return mapTo ( mappingClass , null ) ; }
private ArrayList < SpinnerLanguageElement > createSpinnerLanguages ( int avoidLanguage ) { ArrayList < SpinnerLanguageElement > result = new ArrayList < SpinnerLanguageElement > ( ) ; List < String > languages = mSessionOptions . allLanguages ( ) ; for ( int i = NUM_ ; i < languages . size ( ) ; ++ i ) { if ( i != avoidLanguage ) { result . add ( new SpinnerLanguageElement ( languages . get ( i ) , i ) ) ; } } return result ; }
private String userAgent ( ) { return mUserAgent ; }
protected void collectProperties ( Class < ? > type , Type < ? > referenceType , Map < String , Property > properties ) { try { BeanInfo beanInfo = Introspector . getBeanInfo ( type ) ; PropertyDescriptor [ ] descriptors = beanInfo . getPropertyDescriptors ( ) ; for ( final PropertyDescriptor pd : descriptors ) { try { Method readMethod = getReadMethod ( pd , type ) ; Method writeMethod = getWriteMethod ( pd , type , null ) ; Property property = processProperty ( pd . getName ( ) , pd . getPropertyType ( ) , readMethod , writeMethod , type , referenceType , properties ) ; postProcessProperty ( property , pd , readMethod , writeMethod , type , referenceType , properties ) ; } catch ( final Exception e ) { throw new RuntimeException ( STR_ + referenceType . getCanonicalName ( ) + STR_ + pd . getName ( ) + STR_ , e ) ; } } } catch ( IntrospectionException e ) { throw new RuntimeException ( e ) ; } }
private void beforeKey ( ) throws JSONException { Scope context = peek ( ) ; if ( context == Scope . NONEMPTY_OBJECT ) { out . append ( STR_ ) ; } else if ( context != Scope . EMPTY_OBJECT ) { throw new JSONException ( STR_ ) ; } newline ( ) ; replaceTop ( Scope . DANGLING_KEY ) ; }
public void addHeaderView ( View v , Object data , boolean isSelectable ) { if ( mAdapter != null && ! ( mAdapter instanceof HeaderViewListAdapter ) ) { throw new IllegalStateException ( STR_ ) ; } FixedViewInfo info = new FixedViewInfo ( ) ; info . view = v ; info . data = data ; info . isSelectable = isSelectable ; mHeaderViewInfos . add ( info ) ; if ( mAdapter != null && mObserver != null ) { mObserver . onChanged ( ) ; } }
private void renderOperatorBackground ( final Operator operator , final Graphics2D g2 ) { Rectangle2D frame = model . getOperatorRect ( operator ) ; if ( frame == null ) { return ; } RoundRectangle2D background = new RoundRectangle2D . Double ( frame . getX ( ) - NUM_ , frame . getY ( ) - NUM_ , frame . getWidth ( ) + NUM_ , frame . getHeight ( ) + NUM_ , OPERATOR_BG_CORNER , OPERATOR_BG_CORNER ) ; g2 . setColor ( Color . WHITE ) ; g2 . fill ( background ) ; Rectangle2D nameBounds = OPERATOR_FONT . getStringBounds ( operator . getName ( ) , g2 . getFontRenderContext ( ) ) ; if ( nameBounds . getWidth ( ) > frame . getWidth ( ) ) { double relevantWidth = Math . min ( nameBounds . getWidth ( ) , frame . getWidth ( ) . MAX_HEADER_RATIO ) ; double offset = ( frame . getWidth ( ) - relevantWidth ) / NUM_ ; int x = ( int ) ( frame . getX ( ) + offset ) ; int padding = NUM_ ; RoundRectangle2D nameBackground = new RoundRectangle2D . Double ( ( int ) Math . min ( frame . getX ( ) - padding , x - padding ) , frame . getY ( ) - NUM_ , relevantWidth + NUM_ . padding , ProcessRendererModel . HEADER_HEIGHT + NUM_ , OPERATOR_BG_CORNER , OPERATOR_BG_CORNER ) ; g2 . fill ( nameBackground ) ; } renderPortsBackground ( operator . getInputPorts ( ) , g2 ) ; renderPortsBackground ( operator . getOutputPorts ( ) , g2 ) ; }
protected void optionWindow ( ActionEvent e ) { if ( optionsFrame == null ) { optionsFrame = new JmriJFrame ( Bundle . getMessage ( STR_ ) , BOOL_ , BOOL_ ) ; optionsPane = optionsFrame . getContentPane ( ) ; optionsPane . setLayout ( new BoxLayout ( optionsFrame . getContentPane ( ) , BoxLayout . Y_AXIS ) ) ; clearEntry . setSelectedIndex ( nxPairs . getClearDownOption ( ) ) ; JPanel p1 = new JPanel ( ) ; clearEntry . setToolTipText ( STR_ ) ; p1 . add ( new JLabel ( Bundle . getMessage ( STR_ ) ) ) ; p1 . add ( clearEntry ) ; optionsPane . add ( p1 ) ; JPanel p2 = new JPanel ( ) ; initializeColorCombo ( settingTrackColorBox ) ; setColorCombo ( settingTrackColorBox , nxPairs . getSettingRouteColor ( ) ) ; ActionListener settingTrackColorListener = null ; settingTrackColorBox . addActionListener ( settingTrackColorListener ) ; p2 . add ( new JLabel ( Bundle . getMessage ( STR_ ) ) ) ; p2 . add ( settingTrackColorBox ) ; optionsPane . add ( p2 ) ; durationSetting . setText ( STR_ + nxPairs . getSettingTimer ( ) ) ; if ( nxPairs . useDifferentColorWhenSetting ( ) ) { durationSetting . setEnabled ( BOOL_ ) ; } else { durationSetting . setEnabled ( BOOL_ ) ; } JPanel p3 = new JPanel ( ) ; p3 . add ( new JLabel ( Bundle . getMessage ( STR_ ) ) ) ; p3 . add ( durationSetting ) ; optionsPane . add ( p3 ) ; JPanel p4 = new JPanel ( ) ; p4 . add ( dispatcherUse ) ; dispatcherUse . setSelected ( nxPairs . getDispatcherIntegration ( ) ) ; optionsPane . add ( p4 ) ; JButton ok = new JButton ( Bundle . getMessage ( STR_ ) ) ; optionsPane . add ( ok ) ; ok . addActionListener ( null ) ; } optionsFrame . pack ( ) ; optionsFrame . setVisible ( BOOL_ ) ; }
public void makeExistingDemandBillInactive ( String assessmentNo ) { DemandBillService demandBillService = ( DemandBillService ) beanProvider . getBean ( STR_ ) ; demandBillService . makeDemandBillInactive ( assessmentNo ) ; }
public void write ( DataOutput out ) throws IOException { WritableUtils . writeVInt ( out , length ) ; out . write ( bytes , NUM_ , length ) ; }
int characterClass ( ) throws RESyntaxException { if ( pattern . charAt ( idx ) != STR_ ) { internalError ( ) ; } if ( ( idx + NUM_ ) >= len || pattern . charAt ( ++ idx ) == STR_ ) { syntaxError ( STR_ ) ; } if ( idx < len && pattern . charAt ( idx ) == STR_ ) { idx ++ ; int idxStart = idx ; while ( idx < len && pattern . charAt ( idx ) >= STR_ && pattern . charAt ( idx ) <= STR_ ) { idx ++ ; } if ( ( idx + NUM_ ) < len && pattern . charAt ( idx ) == STR_ && pattern . charAt ( idx + NUM_ ) == STR_ ) { String charClass = pattern . substring ( idxStart , idx ) ; Character i = ( Character ) hashPOSIX . get ( charClass ) ; if ( i != null ) { idx += NUM_ ; return node ( RE . OP_POSIXCLASS , i . charValue ( ) ) ; } syntaxError ( STR_ + charClass + STR_ ) ; } syntaxError ( STR_ ) ; } int ret = node ( RE . OP_ANYOF , NUM_ ) ; char CHAR_INVALID = Character . MAX_VALUE ; char last = CHAR_INVALID ; char simpleChar ; boolean include = BOOL_ ; boolean definingRange = BOOL_ ; int idxFirst = idx ; char rangeStart = Character . MIN_VALUE ; char rangeEnd ; RERange range = new RERange ( ) ; while ( idx < len && pattern . charAt ( idx ) != STR_ ) { switchOnCharacter : switch ( pattern . charAt ( idx ) ) { case STR_ : include = ! include ; if ( idx == idxFirst ) { range . include ( Character . MIN_VALUE , Character . MAX_VALUE , BOOL_ ) ; } idx ++ ; continue ; case STR_ : { int c ; switch ( c = escape ( ) ) { case ESC_COMPLEX : case ESC_BACKREF : syntaxError ( STR_ ) ; case ESC_CLASS : if ( definingRange ) { syntaxError ( STR_ ) ; } switch ( pattern . charAt ( idx - NUM_ ) ) { case RE . E_NSPACE : range . include ( Character . MIN_VALUE , NUM_ , include ) ; range . include ( ( char ) NUM_ , include ) ; range . include ( NUM_ , NUM_ , include ) ; range . include ( NUM_ , Character . MAX_VALUE , include ) ; break ; case RE . E_NALNUM : range . include ( Character . MIN_VALUE , STR_ , include ) ; range . include ( STR_ , STR_ , include ) ; range . include ( STR_ , STR_ , include ) ; range . include ( STR_ , include ) ; range . include ( STR_ , Character . MAX_VALUE , include ) ; break ; case RE . E_NDIGIT : range . include ( Character . MIN_VALUE , STR_ , include ) ; range . include ( STR_ , Character . MAX_VALUE , include ) ; break ; case RE . E_SPACE : range . include ( STR_ , include ) ; range . include ( STR_ , include ) ; range . include ( STR_ , include ) ; range . include ( STR_ , include ) ; range . include ( STR_ , include ) ; range . include ( STR_ , include ) ; break ; case RE . E_ALNUM : range . include ( STR_ , STR_ , include ) ; range . include ( STR_ , STR_ , include ) ; range . include ( STR_ , include ) ; case RE . E_DIGIT : range . include ( STR_ , STR_ , include ) ; break ; } last = CHAR_INVALID ; break ; default : simpleChar = ( char ) c ; break switchOnCharacter ; } } continue ; case STR_ : if ( definingRange ) { syntaxError ( STR_ ) ; } definingRange = BOOL_ ; rangeStart = ( last == CHAR_INVALID ? NUM_ : last ) ; if ( ( idx + NUM_ ) < len && pattern . charAt ( ++ idx ) == STR_ ) { simpleChar = Character . MAX_VALUE ; break ; } continue ; default : simpleChar = pattern . charAt ( idx ++ ) ; break ; } if ( definingRange ) { rangeEnd = simpleChar ; if ( rangeStart >= rangeEnd ) { syntaxError ( STR_ ) ; } range . include ( rangeStart , rangeEnd , include ) ; last = CHAR_INVALID ; definingRange = BOOL_ ; } else { if ( idx >= len || pattern . charAt ( idx ) != STR_ ) { range . include ( simpleChar , include ) ; } last = simpleChar ; } } if ( idx == len ) { syntaxError ( STR_ ) ; } idx ++ ; instruction [ ret + RE . offsetOpdata ] = ( char ) range . num ; for ( int i = NUM_ ; i < range . num ; i ++ ) { emit ( ( char ) range . minRange [ i ] ) ; emit ( ( char ) range . maxRange [ i ] ) ; } return ret ; }
public static byte [ ] decode ( byte [ ] data ) { int len = data . length / NUM_ . NUM_ ; ByteArrayOutputStream bOut = new ByteArrayOutputStream ( len ) ; try { encoder . decode ( data , NUM_ , data . length , bOut ) ; } catch ( Exception e ) { throw new DecoderException ( STR_ + e . getMessage ( ) , e ) ; } return bOut . toByteArray ( ) ; }
@ Override public int doFinal ( final byte [ ] out , final int outOff ) throws BadCiphertextException { complete_ = BOOL_ ; int written = contentCryptoHandler_ . doFinal ( out , outOff ) ; updateTrailingSignature ( out , outOff , written ) ; if ( cryptoAlgo_ . getTrailingSignatureLength ( ) > NUM_ ) { try { CiphertextFooters footer = new CiphertextFooters ( trailingSig_ . sign ( ) ) ; byte [ ] fBytes = footer . toByteArray ( ) ; System . arraycopy ( fBytes , NUM_ , out , outOff + written , fBytes . length ) ; return written + fBytes . length ; } catch ( final SignatureException ex ) { throw new AwsCryptoException ( ex ) ; } } else { return written ; } }
public void hideAllBudges ( ) { for ( RelativeLayout badge : badgeList ) { if ( badge . getVisibility ( ) == VISIBLE ) BadgeHelper . hideBadge ( badge ) ; } badgeSaveInstanceHashMap . clear ( ) ; }
public Element render ( SVGPlot svgp ) { Element tag = svgp . svgElement ( SVGConstants . SVG_G_TAG ) ; Element button = svgp . svgRect ( x , y , w , h ) ; if ( ! Double . isNaN ( r ) ) { SVGUtil . setAtt ( button , SVGConstants . SVG_RX_ATTRIBUTE , r ) ; SVGUtil . setAtt ( button , SVGConstants . SVG_RY_ATTRIBUTE , r ) ; } SVGUtil . setAtt ( button , SVGConstants . SVG_STYLE_ATTRIBUTE , butcss . inlineCSS ( ) ) ; tag . appendChild ( button ) ; if ( svgp . getIdElement ( SVGEffects . LIGHT_GRADIENT_ID ) != null ) { Element light = svgp . svgRect ( x , y , w , h ) ; if ( ! Double . isNaN ( r ) ) { SVGUtil . setAtt ( light , SVGConstants . SVG_RX_ATTRIBUTE , r ) ; SVGUtil . setAtt ( light , SVGConstants . SVG_RY_ATTRIBUTE , r ) ; } SVGUtil . setAtt ( light , SVGConstants . SVG_STYLE_ATTRIBUTE , STR_ + SVGEffects . LIGHT_GRADIENT_ID + STR_ ) ; tag . appendChild ( light ) ; } if ( svgp . getIdElement ( SVGEffects . SHADOW_ID ) != null ) { button . setAttribute ( SVGConstants . SVG_FILTER_ATTRIBUTE , STR_ + SVGEffects . SHADOW_ID + STR_ ) ; } if ( title != null ) { Element label = svgp . svgText ( x + w . NUM_ , y + h . NUM_ , title ) ; label . setAttribute ( SVGConstants . SVG_STYLE_ATTRIBUTE , titlecss . inlineCSS ( ) ) ; tag . appendChild ( label ) ; } return tag ; }
public void add ( String gram ) { if ( name == null || gram == null ) return ; int len = gram . length ( ) ; if ( len < NUM_ || len > NGram . N_GRAM ) return ; ++ n_words [ len - NUM_ ] ; if ( freq . containsKey ( gram ) ) { freq . put ( gram , freq . get ( gram ) + NUM_ ) ; } else { freq . put ( gram , NUM_ ) ; } }
public void test_addressing ( ) { final Journal store = ( Journal ) getStore ( ) ; try { final RWStrategy bufferStrategy = ( RWStrategy ) store . getBufferStrategy ( ) ; final RWStore rw = bufferStrategy . getStore ( ) ; final ArrayList < Integer > sizes = new ArrayList < Integer > ( ) ; final TreeMap < Long , Integer > paddrs = new TreeMap < Long , Integer > ( ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { final int s = r . nextInt ( NUM_ ) + NUM_ ; sizes . add ( s ) ; final int a = rw . alloc ( s , null ) ; final long pa = rw . physicalAddress ( a ) ; assertTrue ( paddrs . get ( pa ) == null ) ; paddrs . put ( pa , a ) ; } for ( int i = NUM_ ; i < NUM_ ; i ++ ) { final int s = r . nextInt ( NUM_ ) + NUM_ ; sizes . add ( s ) ; final int a = rw . alloc ( s , null ) ; final long pa = rw . physicalAddress ( a ) ; paddrs . put ( pa , a ) ; } } finally { store . destroy ( ) ; } }
public void handleClientMembership ( String clientId , int eventType ) { String notifType = null ; List < ManagedResource > cleanedUp = null ; if ( eventType == ClientMembershipMessage . LEFT ) { notifType = NOTIF_CLIENT_LEFT ; cleanedUp = cleanupBridgeClientResources ( clientId ) ; } else if ( eventType == ClientMembershipMessage . CRASHED ) { notifType = NOTIF_CLIENT_CRASHED ; cleanedUp = cleanupBridgeClientResources ( clientId ) ; } else if ( eventType == ClientMembershipMessage . JOINED ) { notifType = NOTIF_CLIENT_JOINED ; } if ( cleanedUp != null ) { for ( ManagedResource resource : cleanedUp ) { MBeanUtil . unregisterMBean ( resource ) ; } } Helper . sendNotification ( this , new Notification ( notifType , this . modelMBean , Helper . getNextNotificationSequenceNumber ( ) , clientId ) ) ; }
public < V extends Comparable < ? super V > > OptionalDouble maxBy ( DoubleFunction < V > keyExtractor ) { ObjDoubleBox < V > result = collect ( null , null , null ) ; return result . a == null ? OptionalDouble . empty ( ) : OptionalDouble . of ( result . b ) ; }
private JLabel addKeybindLabel ( JPanel panel , String labelText ) { GridBagConstraints gbc = new GridBagConstraints ( ) ; gbc . anchor = GridBagConstraints . WEST ; gbc . insets = new Insets ( NUM_ , NUM_ , NUM_ , NUM_ ) ; gbc . gridx = NUM_ ; gbc . gridy = keybindLabelGridYCounter ++ ; gbc . weightx = NUM_ ; JLabel jlbl = new JLabel ( labelText ) ; panel . add ( jlbl , gbc ) ; return jlbl ; }
public static boolean isLetterOrNumber ( int c ) { return isLetter ( c ) || isNumber ( c ) ; }
public String seasonSummaryStr ( ) { setTeamRanks ( ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( ncgSummaryStr ( ) ) ; sb . append ( STR_ + userTeam . seasonSummaryStr ( ) ) ; sb . append ( STR_ + leagueRecords . brokenRecordsStr ( getYear ( ) , userTeam . abbr ) ) ; return sb . toString ( ) ; }
public void addEndBumper ( ) { numEndBumpers ++ ; String name = STR_ ; boolean duplicate = BOOL_ ; while ( duplicate ) { name = STR_ + numEndBumpers ; if ( finder . findPositionablePointByName ( name ) == null ) { duplicate = BOOL_ ; } if ( duplicate ) { numEndBumpers ++ ; } } PositionablePoint o = new PositionablePoint ( name , PositionablePoint . END_BUMPER , currentPoint , this ) ; pointList . add ( o ) ; setDirty ( BOOL_ ) ; }
public Map < String , Object > convertDataToObjects ( Map < String , String > data ) { Map < String , Object > results = new HashMap < > ( ) ; if ( data != null ) { for ( String key : data . keySet ( ) ) { results . put ( key , data . get ( key ) ) ; } } return results ; }
public int pixelFor ( Color c ) { return pixelFor ( c . getRGB ( ) ) ; }
void stripNonCompiledNodes ( Node n , Set < String > filesToCompile ) { for ( Node child : n . children ( ) ) { if ( ! filesToCompile . contains ( child . getSourceFileName ( ) ) ) { child . detachFromParent ( ) ; } } }
protected void restoreBaseURI ( ) { fBaseURI . pop ( ) ; fLiteralSystemID . pop ( ) ; fExpandedSystemID . pop ( ) ; fBaseURIScope . pop ( ) ; fCurrentBaseURI . setBaseSystemId ( ( String ) fBaseURI . peek ( ) ) ; fCurrentBaseURI . setLiteralSystemId ( ( String ) fLiteralSystemID . peek ( ) ) ; fCurrentBaseURI . setExpandedSystemId ( ( String ) fExpandedSystemID . peek ( ) ) ; }
private boolean checkTouchSlop ( View child , float dx , float dy ) { if ( child == null ) { return BOOL_ ; } final boolean checkHorizontal = mCallback . getViewHorizontalDragRange ( child ) > NUM_ ; final boolean checkVertical = mCallback . getViewVerticalDragRange ( child ) > NUM_ ; if ( checkHorizontal && checkVertical ) { return dx . dx + dy . dy > mTouchSlop . mTouchSlop ; } else if ( checkHorizontal ) { return Math . abs ( dx ) > mTouchSlop ; } else if ( checkVertical ) { return Math . abs ( dy ) > mTouchSlop ; } return BOOL_ ; }
public void testToBigIntegerPos1 ( ) { String a = STR_ ; BigInteger bNumber = new BigInteger ( STR_ ) ; BigDecimal aNumber = new BigDecimal ( a ) ; BigInteger result = aNumber . toBigInteger ( ) ; assertTrue ( STR_ , result . equals ( bNumber ) ) ; }
public static boolean asBoolean ( CharSequence string ) { return string . length ( ) > NUM_ ; }
public void initialize ( ) { TextureState ts = new TextureState ( ) ; ts . setEnabled ( BOOL_ ) ; setRenderState ( ts ) ; for ( int i = NUM_ ; i < landmarkList . size ( ) ; ++ i ) { LandmarkState state = landmarkList . get ( i ) ; addLandmark ( state , BOOL_ ) ; } zBufferState = new ZBufferState ( ) ; zBufferState . setFunction ( ZBufferState . TestFunction . LessThanOrEqualTo ) ; zBufferState . setEnabled ( BOOL_ ) ; setRenderState ( zBufferState ) ; }
public List < JCCompilationUnit > enterTrees ( List < JCCompilationUnit > roots ) { if ( ! taskListener . isEmpty ( ) ) { for ( JCCompilationUnit unit : roots ) { TaskEvent e = new TaskEvent ( TaskEvent . Kind . ENTER , unit ) ; taskListener . started ( e ) ; } } enter . main ( roots ) ; if ( ! taskListener . isEmpty ( ) ) { for ( JCCompilationUnit unit : roots ) { TaskEvent e = new TaskEvent ( TaskEvent . Kind . ENTER , unit ) ; taskListener . finished ( e ) ; } } if ( needRootClasses || sourceOutput || stubOutput ) { ListBuffer < JCClassDecl > cdefs = new ListBuffer < > ( ) ; for ( JCCompilationUnit unit : roots ) { for ( List < JCTree > defs = unit . defs ; defs . nonEmpty ( ) ; defs = defs . tail ) { if ( defs . head instanceof JCClassDecl ) cdefs . append ( ( JCClassDecl ) defs . head ) ; } } rootClasses = cdefs . toList ( ) ; } for ( JCCompilationUnit unit : roots ) { inputFiles . add ( unit . sourcefile ) ; } return roots ; }
final V replaceNode ( long key , V value , Object cv ) { int hash = spread ( key ) ; for ( Node < V > [ ] tab = table ; ; ) { Node < V > f ; int n , i , fh ; if ( tab == null || ( n = tab . length ) == NUM_ || ( f = tabAt ( tab , i = ( n - NUM_ ) & hash ) ) == null ) { break ; } else if ( ( fh = f . hash ) == MOVED ) { tab = helpTransfer ( tab , f ) ; } else { V oldVal = null ; boolean validated = BOOL_ ; synchronized ( f ) { if ( tabAt ( tab , i ) == f ) { if ( fh >= NUM_ ) { validated = BOOL_ ; for ( Node < V > e = f , pred = null ; ; ) { if ( ( e . key == key ) ) { V ev = e . val ; if ( cv == null || cv == ev || ( ev != null && cv . equals ( ev ) ) ) { oldVal = ev ; if ( value != null ) { e . val = value ; } else if ( pred != null ) { pred . next = e . next ; } else { setTabAt ( tab , i , e . next ) ; } } break ; } pred = e ; if ( ( e = e . next ) == null ) { break ; } } } else if ( f instanceof TreeBin ) { validated = BOOL_ ; TreeBin < V > t = ( TreeBin < V > ) f ; TreeNode < V > r , p ; if ( ( r = t . root ) != null && ( p = r . findTreeNode ( hash , key ) ) != null ) { V pv = p . val ; if ( cv == null || cv == pv || ( pv != null && cv . equals ( pv ) ) ) { oldVal = pv ; if ( value != null ) { p . val = value ; } else if ( t . removeTreeNode ( p ) ) { setTabAt ( tab , i , untreeify ( t . first ) ) ; } } } } } } if ( validated ) { if ( oldVal != null ) { if ( value == null ) { addCount ( - NUM_ , - NUM_ ) ; } return oldVal ; } break ; } } } return null ; }
public static LineByLineFileInputOperator checkpoint ( LineByLineFileInputOperator oper , ByteArrayOutputStream bos ) throws Exception { Kryo kryo = new Kryo ( ) ; Output loutput = new Output ( bos ) ; kryo . writeObject ( loutput , oper ) ; loutput . close ( ) ; Input lInput = new Input ( bos . toByteArray ( ) ) ; @ SuppressWarnings ( STR_ ) LineByLineFileInputOperator checkPointedOper = kryo . readObject ( lInput , oper . getClass ( ) ) ; lInput . close ( ) ; return checkPointedOper ; }
public static String explode ( Collection < String > collection , String delimiter ) { StringBuilder sb = new StringBuilder ( ) ; if ( ! collection . isEmpty ( ) ) { Iterator < String > i = collection . iterator ( ) ; sb . append ( i . next ( ) ) ; while ( i . hasNext ( ) ) { sb . append ( delimiter ) ; sb . append ( i . next ( ) ) ; } } return sb . toString ( ) ; }
@ Override public int hashCode ( ) { return fullyQualifiedName . hashCode ( ) ; }
@ Override public Enumeration < String > enumerateMeasures ( ) { Vector < String > newVector = new Vector < String > ( NUM_ ) ; newVector . addElement ( STR_ ) ; return newVector . elements ( ) ; }
public static void writeStatistics ( TDoubleObjectHashMap < DescriptiveStatistics > statsMap , String keyLabel , String file ) throws IOException { double [ ] keys = statsMap . keys ( ) ; Arrays . sort ( keys ) ; BufferedWriter writer = new BufferedWriter ( new FileWriter ( file ) ) ; writer . write ( keyLabel ) ; writer . write ( TAB ) ; writer . write ( STR_ ) ; writer . write ( TAB ) ; writer . write ( STR_ ) ; writer . write ( TAB ) ; writer . write ( STR_ ) ; writer . write ( TAB ) ; writer . write ( STR_ ) ; writer . write ( TAB ) ; writer . write ( STR_ ) ; writer . newLine ( ) ; for ( double key : keys ) { DescriptiveStatistics stats = statsMap . get ( key ) ; writer . write ( String . valueOf ( key ) ) ; writer . write ( TAB ) ; writer . write ( String . valueOf ( stats . getMean ( ) ) ) ; writer . write ( TAB ) ; writer . write ( String . valueOf ( stats . getPercentile ( NUM_ ) ) ) ; writer . write ( TAB ) ; writer . write ( String . valueOf ( stats . getMin ( ) ) ) ; writer . write ( TAB ) ; writer . write ( String . valueOf ( stats . getMax ( ) ) ) ; writer . write ( TAB ) ; writer . write ( String . valueOf ( stats . getN ( ) ) ) ; writer . newLine ( ) ; } writer . close ( ) ; }
public void actionPerformed ( ActionEvent e ) { if ( ! checkModified ( ) ) return ; if ( m_Script . getFilename ( ) == null ) return ; try { m_Script . start ( m_Args ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; JOptionPane . showMessageDialog ( FileScriptingPanel . this , STR_ + ex , STR_ , JOptionPane . ERROR_MESSAGE ) ; } }
static String encodeStub ( RMIServer rmiServer , Map < String , ? > env ) throws IOException { if ( IIOPHelper . isStub ( rmiServer ) ) return STR_ + encodeIIOPStub ( rmiServer , env ) ; else return STR_ + encodeJRMPStub ( rmiServer , env ) ; }
public int lineToY ( int line ) { FontMetrics fm = painter . getFontMetrics ( ) ; return ( line - firstLine ) . fm . getHeight ( ) - ( fm . getLeading ( ) + fm . getMaxDescent ( ) ) ; }
private void handleDoubleClick ( DoubleClickEvent e ) { ISelection selection = e . getSelection ( ) ; if ( selection instanceof IStructuredSelection ) { IStructuredSelection structured = ( IStructuredSelection ) selection ; if ( structured . size ( ) == NUM_ ) { Object first = structured . getFirstElement ( ) ; if ( first instanceof ISVNRemoteFile ) { openAction . selectionChanged ( null , selection ) ; openAction . run ( null ) ; } else { treeViewer . setExpandedState ( first , ! treeViewer . getExpandedState ( first ) ) ; } } } }
protected File chooseFile ( int type ) { Frame frame = getFrame ( ) ; File f = null ; if ( fileChooser == null ) fileChooser = new JFileChooser ( ) ; fileChooser . setCurrentDirectory ( E00File ) ; if ( type == NUM_ ) fileChooser . setDialogType ( JFileChooser . OPEN_DIALOG ) ; else fileChooser . setDialogType ( JFileChooser . SAVE_DIALOG ) ; int retval = fileChooser . showDialog ( frame , null ) ; if ( retval == JFileChooser . APPROVE_OPTION ) f = fileChooser . getSelectedFile ( ) ; return f ; }
public void pixellate ( FontRenderContext renderFRC , Point2D loc , Point pxResult ) { if ( renderFRC == null ) { renderFRC = frc ; } AffineTransform at = renderFRC . getTransform ( ) ; at . transform ( loc , loc ) ; pxResult . x = ( int ) loc . getX ( ) ; pxResult . y = ( int ) loc . getY ( ) ; loc . setLocation ( pxResult . x , pxResult . y ) ; try { at . inverseTransform ( loc , loc ) ; } catch ( NoninvertibleTransformException e ) { throw new IllegalArgumentException ( STR_ ) ; } }
public static long startTime ( ) { return System . nanoTime ( ) ; }
@ Transactional public int deleteAll ( ) { List < T > allEntities = retrieveAll ( ) ; for ( T entity : allEntities ) { delete ( entity ) ; } return allEntities . size ( ) ; }
private GSMessageImpl receiveFromQueue ( long timeout ) throws ReceiveFromQueueException { Transaction txn = m_session . getTransaction ( ) ; if ( _logger . isLoggable ( Level . FINE ) ) { _logger . log ( Level . FINE , STR_ + txn ) ; } try { return ( GSMessageImpl ) m_space . take ( m_jmsMessageTemplate , txn , timeout ) ; } catch ( Exception e ) { throw new ReceiveFromQueueException ( e ) ; } }
public static void writeByteArrayToFile ( File file , byte [ ] data , boolean append ) throws IOException { OutputStream out = null ; try { out = openOutputStream ( file , append ) ; out . write ( data ) ; out . close ( ) ; } finally { IOUtils . closeQuietly ( out ) ; } }
public String findNext ( boolean previousFlipped ) { boolean resetIsFlipped = BOOL_ ; if ( previousFlipped && count > NUM_ ) { if ( ! valueIterator . hasNext ( ) ) { valueIterator = values . iterator ( ) ; index = NUM_ ; isFlipped = BOOL_ ; resetIsFlipped = BOOL_ ; } else { index ++ ; } currentValue = valueIterator . next ( ) ; } count ++ ; if ( resetIsFlipped ) { isFlipped = BOOL_ ; } return currentValue ; }
public static boolean isNotEmpty ( List < Object > list ) { return ! list . isEmpty ( ) ; }
private RegistrationResult checkPassword ( String password , String confirmPassword ) { if ( ( password == null ) || password . length ( ) == NUM_ ) { if ( debug . messageEnabled ( ) ) { debug . message ( STR_ ) ; } return RegistrationResult . NO_PASSWORD_ERROR ; } else { if ( password . length ( ) < requiredPasswordLength ) { if ( debug . messageEnabled ( ) ) { debug . message ( STR_ ) ; } return RegistrationResult . PASSWORD_TOO_SHORT ; } if ( ( confirmPassword == null ) || confirmPassword . length ( ) == NUM_ ) { if ( debug . messageEnabled ( ) ) { debug . message ( STR_ ) ; } return RegistrationResult . NO_CONFIRMATION_ERROR ; } else { if ( ! password . equals ( confirmPassword ) ) { return RegistrationResult . PASSWORD_MISMATCH_ERROR ; } } } return RegistrationResult . NO_ERROR ; }
private static LDAPFilter createANDFilter ( FilterSet filterSet ) throws LDAPException , IOException { List < JAXBElement < ? > > list = filterSet . getFilterGroup ( ) ; ArrayList < RawFilter > filters = new ArrayList < > ( list . size ( ) ) ; for ( JAXBElement < ? > filter : list ) { filters . add ( createFilter ( filter ) ) ; } return LDAPFilter . createANDFilter ( filters ) ; }
public void put ( String key , double value ) { if ( value == Double . POSITIVE_INFINITY ) { put ( key , STR_ ) ; } else if ( value == Double . NEGATIVE_INFINITY ) { put ( key , STR_ ) ; } else { put ( key , Double . toString ( value ) ) ; } }
public void test_fill$FIIF ( ) { float val = Float . MAX_VALUE ; float d [ ] = new float [ NUM_ ] ; Arrays . fill ( d , NUM_ , d . length , val ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) assertTrue ( STR_ , ! ( d [ i ] == val ) ) ; for ( int i = NUM_ ; i < d . length ; i ++ ) assertTrue ( STR_ , d [ i ] == val ) ; try { Arrays . fill ( d , NUM_ , NUM_ , val ) ; fail ( STR_ ) ; } catch ( IllegalArgumentException e ) { } try { Arrays . fill ( d , - NUM_ , NUM_ , val ) ; fail ( STR_ ) ; } catch ( ArrayIndexOutOfBoundsException e ) { } try { Arrays . fill ( d , NUM_ , d . length + NUM_ , val ) ; fail ( STR_ ) ; } catch ( ArrayIndexOutOfBoundsException e ) { } }
@ Override public void mouseDragged ( MouseEvent evt ) { int xTrans = NUM_ ; int yTrans = NUM_ ; if ( slider . getSnapToTicks ( ) ) { int pos = getLocationForValue ( getSnappedValue ( evt ) ) ; if ( pos > - NUM_ ) { if ( slider . getOrientation ( ) == JSlider . HORIZONTAL ) { xTrans = pos - evt . getX ( ) + offset ; evt . translatePoint ( xTrans , NUM_ ) ; } else { yTrans = pos - evt . getY ( ) + offset ; evt . translatePoint ( NUM_ , yTrans ) ; } } } delegate . mouseDragged ( evt ) ; evt . translatePoint ( xTrans , yTrans ) ; }
@ Override final Node < K , V > find ( int h , Object k ) { if ( k != null ) { for ( Node < K , V > e = first ; e != null ; e = e . next ) { int s ; K ek ; if ( ( ( s = lockState ) & ( WAITER | WRITER ) ) != NUM_ ) { if ( e . hash == h && ( ( ek = e . key ) == k || ( ek != null && k . equals ( ek ) ) ) ) return e ; } else if ( U . compareAndSwapInt ( this , LOCKSTATE , s , s + READER ) ) { TreeNode < K , V > r , p ; try { p = ( ( r = root ) == null ? null : r . findTreeNode ( h , k , null ) ) ; } finally { Thread w ; int ls ; do { } while ( ! U . compareAndSwapInt ( this , LOCKSTATE , ls = lockState , ls - READER ) ) ; if ( ls == ( READER | WAITER ) && ( w = waiter ) != null ) LockSupport . unpark ( w ) ; } return p ; } } } return null ; }
public void stopEnumeration ( EnumerationDeletionContext aws ) { aws . computeEnumerationRequest . enumerationAction = EnumerationAction . STOP ; handleEnumerationRequestForDeletion ( aws ) ; }
public static void doRestart ( Context c ) { try { if ( c != null ) { PackageManager pm = c . getPackageManager ( ) ; if ( pm != null ) { Intent mStartActivity = pm . getLaunchIntentForPackage ( c . getPackageName ( ) ) ; if ( mStartActivity != null ) { mStartActivity . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_TOP ) ; int mPendingIntentId = NUM_ ; PendingIntent mPendingIntent = PendingIntent . getActivity ( c , mPendingIntentId , mStartActivity , PendingIntent . FLAG_CANCEL_CURRENT ) ; AlarmManager mgr = ( AlarmManager ) c . getSystemService ( Context . ALARM_SERVICE ) ; mgr . set ( AlarmManager . RTC , System . currentTimeMillis ( ) + NUM_ , mPendingIntent ) ; System . exit ( NUM_ ) ; } else { Log . e ( STR_ , STR_ ) ; } } else { Log . e ( STR_ , STR_ ) ; } } else { Log . e ( STR_ , STR_ ) ; } } catch ( Exception ex ) { Log . e ( STR_ , STR_ ) ; } }
public Collection < Object > values ( ) { ArrayList < Object > answer = new ArrayList < Object > ( readMethods . size ( ) ) ; for ( Iterator < Object > iter = valueIterator ( ) ; iter . hasNext ( ) ; ) { answer . add ( iter . next ( ) ) ; } return Collections . unmodifiableList ( answer ) ; }
protected DateTimeData parse ( String str ) throws SchemaDateTimeException { DateTimeData date = new DateTimeData ( str , this ) ; int len = str . length ( ) ; int end = getYearMonth ( str , NUM_ , len , date ) ; date . day = DAY ; parseTimeZone ( str , end , len , date ) ; validateDateTime ( date ) ; saveUnnormalized ( date ) ; if ( date . utc != NUM_ && date . utc != STR_ ) { normalize ( date ) ; } date . position = NUM_ ; return date ; }
public ArrayVal ( double [ ] values ) { this . array = new double [ values . length ] ; for ( int i = NUM_ ; i < array . length ; i ++ ) { array [ i ] = values [ i ] ; } hashcode = Arrays . hashCode ( array ) ; }
public void addChild ( String child ) { if ( child == null ) { return ; } String childPath = path . endsWith ( STR_ ) ? path + child : path + STR_ + child ; children . add ( new ZkNode ( childPath ) ) ; }
@ VisibleForTesting public static boolean sendToTMaster ( String command , String topologyName , SchedulerStateManagerAdaptor stateManager , NetworkUtils . TunnelConfig tunnelConfig ) { LOG . fine ( STR_ + topologyName ) ; TopologyMaster . TMasterLocation location = stateManager . getTMasterLocation ( topologyName ) ; if ( location == null ) { LOG . severe ( STR_ + topologyName ) ; return BOOL_ ; } LOG . fine ( STR_ + topologyName ) ; String url = String . format ( STR_ , location . getHost ( ) , location . getControllerPort ( ) , command , location . getTopologyId ( ) ) ; try { URL endpoint = new URL ( url ) ; LOG . fine ( STR_ + endpoint ) ; return sendGetRequest ( endpoint , command , tunnelConfig ) ; } catch ( MalformedURLException e ) { throw new RuntimeException ( STR_ + url , e ) ; } }
public int addPadding ( byte [ ] in , int inOff ) { byte code = ( byte ) ( in . length - inOff ) ; while ( inOff < ( in . length - NUM_ ) ) { in [ inOff ] = ( byte ) random . nextInt ( ) ; inOff ++ ; } in [ inOff ] = code ; return code ; }
public void update ( long duration , TimeUnit unit ) { update ( unit . toNanos ( duration ) ) ; }
public static String fromDoc2String ( Document doc ) throws Exception { KXmlSerializer serializer = new KXmlSerializer ( ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; DataOutputStream dos = new DataOutputStream ( bos ) ; try { serializer . setFeature ( STR_ , BOOL_ ) ; serializer . setOutput ( dos , XformConstants . DEFAULT_CHARACTER_ENCODING ) ; doc . write ( serializer ) ; serializer . flush ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } return new String ( bos . toByteArray ( ) , XformConstants . DEFAULT_CHARACTER_ENCODING ) ; }
public int addOrderTerm ( GenericValue orderTerm ) { orderTerms . add ( orderTerm ) ; return orderTerms . indexOf ( orderTerm ) ; }
public static int checkActions ( Map < String , Object > entry ) { boolean ip6 = BOOL_ ; boolean ip4 = BOOL_ ; String actions = null ; if ( entry . containsKey ( StaticFlowEntryPusher . COLUMN_ACTIONS ) || entry . containsKey ( StaticFlowEntryPusher . COLUMN_INSTR_APPLY_ACTIONS ) || entry . containsKey ( StaticFlowEntryPusher . COLUMN_INSTR_WRITE_ACTIONS ) ) { if ( entry . containsKey ( StaticFlowEntryPusher . COLUMN_ACTIONS ) ) { actions = ( String ) entry . get ( StaticFlowEntryPusher . COLUMN_ACTIONS ) ; } else if ( entry . containsKey ( StaticFlowEntryPusher . COLUMN_INSTR_APPLY_ACTIONS ) ) { actions = ( String ) entry . get ( StaticFlowEntryPusher . COLUMN_INSTR_APPLY_ACTIONS ) ; } else if ( entry . containsKey ( StaticFlowEntryPusher . COLUMN_INSTR_WRITE_ACTIONS ) ) { actions = ( String ) entry . get ( StaticFlowEntryPusher . COLUMN_INSTR_WRITE_ACTIONS ) ; } if ( actions . contains ( MatchUtils . STR_ICMPV6_CODE ) || actions . contains ( MatchUtils . STR_ICMPV6_TYPE ) || actions . contains ( MatchUtils . STR_IPV6_DST ) || actions . contains ( MatchUtils . STR_IPV6_SRC ) || actions . contains ( MatchUtils . STR_IPV6_FLOW_LABEL ) || actions . contains ( MatchUtils . STR_IPV6_ND_SSL ) || actions . contains ( MatchUtils . STR_IPV6_ND_TARGET ) || actions . contains ( MatchUtils . STR_IPV6_ND_TTL ) ) { ip6 = BOOL_ ; } if ( actions . contains ( MatchUtils . STR_NW_SRC ) || actions . contains ( MatchUtils . STR_NW_DST ) || actions . contains ( MatchUtils . STR_ARP_OPCODE ) || actions . contains ( MatchUtils . STR_ARP_SHA ) || actions . contains ( MatchUtils . STR_ARP_DHA ) || actions . contains ( MatchUtils . STR_ARP_SPA ) || actions . contains ( MatchUtils . STR_ARP_DPA ) || actions . contains ( MatchUtils . STR_ICMP_CODE ) || actions . contains ( MatchUtils . STR_ICMP_TYPE ) ) { ip4 = BOOL_ ; } } if ( ip6 == BOOL_ && ip4 == BOOL_ ) { return NUM_ ; } else if ( ip6 == BOOL_ && ip4 == BOOL_ ) { return NUM_ ; } else if ( ip6 == BOOL_ && ip4 == BOOL_ ) { return NUM_ ; } else { return - NUM_ ; } }
public String toString ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( ValidationErrorObject error : errors ) { stringBuilder . append ( error . toString ( ) ) ; } return stringBuilder . toString ( ) ; }
public static ObservableStringValue decision ( ObservableBooleanValue condition , ObservableStringValue ifTrue , ObservableStringValue ifFalse ) { StringProperty ret = new SimpleStringProperty ( ) ; condition . addListener ( null ) ; ifTrue . addListener ( null ) ; ifFalse . addListener ( null ) ; ret . set ( condition . get ( ) ? ifTrue . get ( ) : ifFalse . get ( ) ) ; return ret ; }
public static final boolean readFromStream ( InputStream in , byte [ ] buf , int offset , int len ) throws IOException { int totalBytesRead = NUM_ ; while ( totalBytesRead < len ) { int bytesRead = in . read ( buf , offset + totalBytesRead , len - totalBytesRead ) ; if ( bytesRead < NUM_ ) { return BOOL_ ; } totalBytesRead += bytesRead ; } return BOOL_ ; }
public static Field findStaticField ( Class < ? > type , String name ) throws NoSuchFieldException { Field field = findField ( type , name ) ; if ( ! Modifier . isStatic ( field . getModifiers ( ) ) ) { throw new NoSuchFieldException ( STR_ + name + STR_ ) ; } return field ; }
public void newBraces ( EditorState editorState , char ch ) { String casName = argumentHelper . readCharacters ( editorState ) ; if ( ch == FUNCTION_OPEN_KEY && metaModel . isGeneral ( casName ) ) { delCharacters ( editorState , casName . length ( ) ) ; newFunction ( editorState , casName ) ; } else if ( ch == FUNCTION_OPEN_KEY && metaModel . isFunction ( casName ) ) { delCharacters ( editorState , casName . length ( ) ) ; newFunction ( editorState , casName ) ; } else { newArray ( editorState , NUM_ , ch ) ; } }
@ Override public Xid [ ] recover ( int flag ) throws XAException { debugCodeCall ( STR_ , quoteFlags ( flag ) ) ; checkOpen ( ) ; try ( Statement stat = physicalConn . createStatement ( ) ) { ResultSet rs = stat . executeQuery ( STR_ + STR_ ) ; ArrayList < Xid > list = New . arrayList ( ) ; while ( rs . next ( ) ) { String tid = rs . getString ( STR_ ) ; int id = getNextId ( XID ) ; Xid xid = new JdbcXid ( factory , id , tid ) ; list . add ( xid ) ; } rs . close ( ) ; Xid [ ] result = new Xid [ list . size ( ) ] ; list . toArray ( result ) ; if ( list . size ( ) > NUM_ ) { prepared = BOOL_ ; } return result ; } catch ( SQLException e ) { XAException xa = new XAException ( XAException . XAER_RMERR ) ; xa . initCause ( e ) ; throw xa ; } }
public void bind ( Texture texture ) { faces . forEach ( null ) ; }
public final void clearPassword ( ) { Arrays . fill ( password , STR_ ) ; password = null ; }
private static int NewCharArray ( JNIEnvironment env , int length ) { if ( traceJNI ) VM . sysWrite ( STR_ ) ; RuntimeEntrypoints . checkJNICountDownToGC ( ) ; try { char [ ] newArray = new char [ length ] ; return env . pushJNIRef ( newArray ) ; } catch ( Throwable unexpected ) { if ( traceJNI ) unexpected . printStackTrace ( System . err ) ; env . recordException ( unexpected ) ; return NUM_ ; } }
private void initQuadProgram ( ) { glUseProgram ( quadProgram ) ; int texUniform = glGetUniformLocation ( quadProgram , STR_ ) ; glUniform1i ( texUniform , NUM_ ) ; glUseProgram ( NUM_ ) ; }
public void put ( E e ) throws InterruptedException { if ( e == null ) throw new NullPointerException ( ) ; int c = - NUM_ ; Node < E > node = new Node < E > ( e ) ; final ReentrantLock putLock = this . putLock ; final AtomicInteger count = this . count ; putLock . lockInterruptibly ( ) ; try { while ( count . get ( ) == capacity ) { notFull . await ( ) ; } enqueue ( node ) ; c = count . getAndIncrement ( ) ; if ( c + NUM_ < capacity ) notFull . signal ( ) ; } finally { putLock . unlock ( ) ; } if ( c == NUM_ ) signalNotEmpty ( ) ; }
public static boolean logFileZipped ( String file ) { return file . endsWith ( STR_ ) || file . endsWith ( STR_ ) || file . endsWith ( STR_ ) ; }
private void validateHasChecksumFile ( File archiveFile ) throws InvalidArchiveUpdateException { try { resolveChecksumFile ( extractFileToDirectory ( archiveFile , CHECKSUMS_FILE_IN_OPENIDM ) ) ; } catch ( Exception e ) { throw new InvalidArchiveUpdateException ( archiveFile . getName ( ) , STR_ + archiveFile . getName ( ) + STR_ , e ) ; } }
protected String ratsProblem ( ) { final String text = STR_ + STR_ ; return ( text ) ; }
public Class < ? > lookupEntityClass ( Class < ? > objClass ) { for ( Class < ? > cls = objClass ; cls != null ; cls = cls . getSuperclass ( ) ) { if ( entityBindings . containsKey ( cls ) || cls . isAnnotationPresent ( Entity . class ) ) { return cls ; } } throw new IllegalArgumentException ( STR_ + objClass ) ; }
private boolean isWhitespace ( int position ) { if ( _len >= NUM_ && position >= _len ) { return BOOL_ ; } return Character . isWhitespace ( _working [ position ] ) ; }
private void collectWrapperClasses ( ClassLoader cl , String pkg , File file ) throws Exception { for ( File f : file . listFiles ( ) ) { if ( f . isDirectory ( ) ) { collectWrapperClasses ( cl , pkg + f . getName ( ) + STR_ , f ) ; } else { addWrapperClassToWrapperClassesList ( cl , pkg , f ) ; } } }
public void clearImages ( ) { chunks . clear ( ) ; markers . clear ( ) ; redraw ( BOOL_ ) ; shift_x = NUM_ ; shift_y = NUM_ ; zoom_level_pos = NUM_ ; zoom_level = NUM_ ; }
public void test_fill$JIIJ ( ) { long d [ ] = new long [ NUM_ ] ; Arrays . fill ( d , NUM_ , d . length , Long . MAX_VALUE ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) assertTrue ( STR_ , ! ( d [ i ] == Long . MAX_VALUE ) ) ; for ( int i = NUM_ ; i < d . length ; i ++ ) assertTrue ( STR_ , d [ i ] == Long . MAX_VALUE ) ; try { Arrays . fill ( d , NUM_ , NUM_ , Long . MIN_VALUE ) ; fail ( STR_ ) ; } catch ( IllegalArgumentException e ) { } try { Arrays . fill ( d , - NUM_ , NUM_ , Long . MAX_VALUE ) ; fail ( STR_ ) ; } catch ( ArrayIndexOutOfBoundsException e ) { } try { Arrays . fill ( d , NUM_ , d . length + NUM_ , Long . MAX_VALUE ) ; fail ( STR_ ) ; } catch ( ArrayIndexOutOfBoundsException e ) { } }
public Object extFunction ( String ns , String funcName , Vector argVec , Object methodKey , ExpressionContext exprContext ) throws javax . xml . transform . TransformerException { Object result = null ; if ( null != ns ) { ExtensionHandler extNS = ( ExtensionHandler ) m_extensionFunctionNamespaces . get ( ns ) ; if ( null != extNS ) { try { result = extNS . callFunction ( funcName , argVec , methodKey , exprContext ) ; } catch ( javax . xml . transform . TransformerException e ) { throw e ; } catch ( Exception e ) { throw new javax . xml . transform . TransformerException ( e ) ; } } else { throw new XPathProcessorException ( XSLMessages . createMessage ( XSLTErrorResources . ER_EXTENSION_FUNC_UNKNOWN , new Object [ ] { ns , funcName } ) ) ; } } return result ; }
private static void addComponent ( final JPanel panel , final Component component , final String description , final String hint ) { final JPanel settingPanel = new JPanel ( new BorderLayout ( ) ) ; settingPanel . setBorder ( STANDARD_EMPTY_BORDER ) ; settingPanel . add ( new JLabel ( description ) , BorderLayout . CENTER ) ; final JPanel innerPanel = new JPanel ( new BorderLayout ( ) ) ; innerPanel . add ( component , BorderLayout . CENTER ) ; final JHintIcon hintPopup = new JHintIcon ( hint ) ; hintPopup . setBorder ( new EmptyBorder ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; innerPanel . add ( hintPopup , BorderLayout . EAST ) ; settingPanel . add ( innerPanel , BorderLayout . EAST ) ; panel . add ( settingPanel ) ; }
private void writeAttribute ( java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( namespace . equals ( STR_ ) ) { xmlWriter . writeAttribute ( attName , attValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } }
public ReversedLinesFileReader ( final File file , final int blockSize , final String encoding ) throws IOException { this ( file , blockSize , Charsets . toCharset ( encoding ) ) ; }
private void onConnect ( ) { connectionState = ConnectionState . Connected ; checkForUpdatedFlight = BOOL_ ; subscribe ( String . format ( trafficAlertChannel , flightId ) ) ; subscribe ( String . format ( situationalAwarenessChannel , flightId ) ) ; }
public static double cdf ( double x , double sigma ) { if ( x <= NUM_ ) { return NUM_ ; } final double xs = x / sigma ; return NUM_ - Math . exp ( - NUM_ . xs . xs ) ; }
public double gaussianShortfall ( double target ) { final CumulativeNormalDistribution gIntegral = new CumulativeNormalDistribution ( mean ( ) , standardDeviation ( ) ) ; return gIntegral . op ( target ) ; }
@ Override public int read ( char ch [ ] , int offset , int length ) throws IOException { int byteLength = length << NUM_ ; if ( byteLength > fBuffer . length ) { byteLength = fBuffer . length ; } int byteCount = fInputStream . read ( fBuffer , NUM_ , byteLength ) ; if ( byteCount == - NUM_ ) { return - NUM_ ; } if ( ( byteCount & NUM_ ) != NUM_ ) { int b = fInputStream . read ( ) ; if ( b == - NUM_ ) { expectedTwoBytes ( ) ; } fBuffer [ byteCount ++ ] = ( byte ) b ; } final int charCount = byteCount > > NUM_ ; if ( fIsBigEndian ) { processBE ( ch , offset , charCount ) ; } else { processLE ( ch , offset , charCount ) ; } return charCount ; }
public static void endWrapper ( Writer writer ) throws IOException { writer . write ( STR_ ) ; writer . write ( STR_ ) ; writer . write ( STR_ ) ; writer . write ( STR_ ) ; writer . write ( STR_ ) ; }
protected Document createConfigurationDocument ( AVList params ) { Document doc = super . createConfigurationDocument ( params ) ; if ( doc == null || doc . getDocumentElement ( ) == null ) return doc ; DataConfigurationUtils . createWMSLayerConfigElements ( params , doc . getDocumentElement ( ) ) ; return doc ; }
public void registerCallback ( String challenge , ChallengeCallbackPlugin plugin , HttpMessage attack ) { cleanExpiredCallbacks ( ) ; regCallbacks . put ( challenge , new RegisteredCallback ( plugin , attack ) ) ; }
public static double min ( Array array ) throws PageException { if ( array . getDimension ( ) > NUM_ ) throw new ExpressionException ( STR_ ) ; if ( array . size ( ) == NUM_ ) return NUM_ ; double rtn = _toDoubleValue ( array , NUM_ ) ; int len = array . size ( ) ; try { for ( int i = NUM_ ; i <= len ; i ++ ) { double v = _toDoubleValue ( array , i ) ; if ( rtn > v ) rtn = v ; } } catch ( PageException e ) { throw new ExpressionException ( STR_ + e . getMessage ( ) ) ; } return rtn ; }
public static byte [ ] writeToArray ( NSObject root ) throws IOException { ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; write ( bout , root ) ; return bout . toByteArray ( ) ; }
private static void loadLibraryResource ( String resourceSubdirectoryName , String libraryName , String tempSubdirectoryName , String ... dependentLibraryNames ) throws Throwable { for ( String dependentLibraryName : dependentLibraryNames ) { logger . log ( level , STR_ + libraryName + STR_ + dependentLibraryName ) ; String dependentResourceSubdirectoryName = resourceSubdirectoryName + STR_ + osString ( ) + STR_ + archString ( ) ; String dependentLibraryTempSubDirectoryName = libraryName + STR_ + File . separator + osString ( ) + File . separator + archString ( ) + File . separator ; loadLibraryResource ( dependentResourceSubdirectoryName , dependentLibraryName , dependentLibraryTempSubDirectoryName ) ; } String libraryFileName = createLibraryFileName ( libraryName ) ; File libraryTempFile = createTempFile ( tempSubdirectoryName , libraryFileName ) ; if ( ! libraryTempFile . exists ( ) ) { String libraryResourceName = resourceSubdirectoryName + STR_ + libraryFileName ; logger . log ( level , STR_ + libraryResourceName ) ; logger . log ( level , STR_ + libraryTempFile ) ; writeResourceToFile ( libraryResourceName , libraryTempFile ) ; } logger . log ( level , STR_ + libraryTempFile ) ; System . load ( libraryTempFile . toString ( ) ) ; logger . log ( level , STR_ + libraryTempFile + STR_ ) ; }
private JobDefinition createJobDefinition ( ) throws Exception { namespaceDaoTestHelper . createNamespaceEntity ( TEST_ACTIVITI_NAMESPACE_CD ) ; JobDefinitionCreateRequest request = jobDefinitionServiceTestHelper . createJobDefinitionCreateRequest ( ) ; JobDefinition jobDefinition = jobDefinitionService . createJobDefinition ( request , BOOL_ ) ; validateJobDefinition ( jobDefinition ) ; return jobDefinition ; }
private WebSocketInputStream openInputStream ( Socket socket ) throws WebSocketException { try { return new WebSocketInputStream ( new BufferedInputStream ( socket . getInputStream ( ) ) ) ; } catch ( IOException e ) { throw new WebSocketException ( WebSocketError . SOCKET_INPUT_STREAM_FAILURE , STR_ + e . getMessage ( ) , e ) ; } }
@ Override protected void drawFirstPassShape ( Graphics2D g2 , int pass , int series , int item , Shape shape ) { if ( isShadowPass ( pass ) ) { if ( getWallPaint ( ) != null ) { g2 . setStroke ( getItemStroke ( series , item ) ) ; g2 . setPaint ( getWallPaint ( ) ) ; g2 . translate ( getXOffset ( ) , getYOffset ( ) ) ; g2 . draw ( shape ) ; g2 . translate ( - getXOffset ( ) , - getYOffset ( ) ) ; } } else { super . drawFirstPassShape ( g2 , pass , series , item , shape ) ; } }
public static double asDouble ( String str , double def ) { try { return Double . parseDouble ( str ) ; } catch ( NumberFormatException e ) { return def ; } }
public JMenu createHelpMenu ( ) { ShowHelpAction helpAction = new ShowHelpAction ( STR_ ) ; JMenu helpMenu = new JMenu ( STR_ ) ; helpMenu . add ( helpAction ) ; return helpMenu ; }
@ Override public void addFocusables ( ArrayList < View > views , int direction , int focusableMode ) { final int focusableCount = views . size ( ) ; final int descendantFocusability = getDescendantFocusability ( ) ; if ( descendantFocusability != FOCUS_BLOCK_DESCENDANTS ) { for ( int i = NUM_ ; i < getChildCount ( ) ; i ++ ) { final View child = getChildAt ( i ) ; if ( child . getVisibility ( ) == VISIBLE ) { ItemInfo ii = infoForChild ( child ) ; if ( ii != null && ii . position == mCurItem ) { child . addFocusables ( views , direction , focusableMode ) ; } } } } if ( descendantFocusability != FOCUS_AFTER_DESCENDANTS || ( focusableCount == views . size ( ) ) ) { if ( ! isFocusable ( ) ) { return ; } if ( ( focusableMode & FOCUSABLES_TOUCH_MODE ) == FOCUSABLES_TOUCH_MODE && isInTouchMode ( ) && ! isFocusableInTouchMode ( ) ) { return ; } if ( views != null ) { views . add ( this ) ; } } }
public static void expandDigits ( String numberString , WordRelation wordRelation , Item tokenItem ) { int numberDigits = numberString . length ( ) ; for ( int i = NUM_ ; i < numberDigits ; i ++ ) { char digit = numberString . charAt ( i ) ; if ( isDigit ( digit ) ) { wordRelation . addWord ( tokenItem , digit2num [ numberString . charAt ( i ) - STR_ ] ) ; } else { wordRelation . addWord ( tokenItem , STR_ ) ; } } }
public String longestMatch ( String input ) { TrieNode node = root ; String result = null ; for ( int i = input . length ( ) - NUM_ ; i >= NUM_ ; i -- ) { node = node . getChild ( input . charAt ( i ) ) ; if ( node == null ) break ; if ( node . isTerminal ( ) ) result = input . substring ( i ) ; } return result ; }
public void testMapSubClass ( ) throws Exception { ObjectMapper mapper = new ObjectMapper ( ) ; MapSubClass result = mapper . readValue ( STR_ , MapSubClass . class ) ; assertEquals ( NUM_ , result . size ( ) ) ; Object value = result . get ( STR_ ) ; assertEquals ( BooleanWrapper . class , value . getClass ( ) ) ; BooleanWrapper bw = ( BooleanWrapper ) value ; assertEquals ( Boolean . TRUE , bw . b ) ; }
@ Override public void removePropertyChangeListener ( PropertyChangeListener pcl ) { m_pcs . removePropertyChangeListener ( pcl ) ; }
public void addOnTagClickListener ( TagsClickListener listener ) { if ( clickListeners == null ) { clickListeners = new ArrayList < > ( ) ; } clickListeners . add ( listener ) ; }
public void removeAllTrackingIcons ( ) { if ( trackingIcons != null && trackingIcons . size ( ) > NUM_ ) { trackingIcons . clear ( ) ; repaint ( ) ; } }
private void readReference ( ) { ArrayList < String > v_value = new ArrayList < String > ( ) ; ArrayList < String > v_name = new ArrayList < String > ( ) ; ArrayList < String > v_description = new ArrayList < String > ( ) ; DocumentEngine . readReferenceList ( v_value , v_name , v_description ) ; int size = v_value . size ( ) ; s_value = new String [ size ] ; s_name = new String [ size ] ; s_description = new String [ size ] ; for ( int i = NUM_ ; i < size ; i ++ ) { s_value [ i ] = ( String ) v_value . get ( i ) ; s_name [ i ] = ( String ) v_name . get ( i ) ; s_description [ i ] = ( String ) v_description . get ( i ) ; } }
protected void assertRoundTrip ( TPS expected ) throws IOException , ClassNotFoundException { final byte [ ] serialized ; { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; ObjectOutputStream oos = new ObjectOutputStream ( baos ) ; expected . writeExternal ( oos ) ; oos . flush ( ) ; serialized = baos . toByteArray ( ) ; } final TPS actual ; { actual = new TPS ( ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( serialized ) ; ObjectInputStream ois = new ObjectInputStream ( bais ) ; actual . readExternal ( ois ) ; } assertEquals ( expected , actual ) ; }
public static double calculateContrastRatio ( double lum1 , double lum2 ) { if ( ( lum1 < NUM_ ) || ( lum2 < NUM_ ) ) { throw new IllegalArgumentException ( STR_ ) ; } return ( Math . max ( lum1 , lum2 ) + NUM_ ) / ( Math . min ( lum1 , lum2 ) + NUM_ ) ; }
protected void reset ( ) throws XNIException { int count = fComponents . size ( ) ; for ( int i = NUM_ ; i < count ; i ++ ) { XMLComponent c = ( XMLComponent ) fComponents . get ( i ) ; c . reset ( this ) ; } }
public synchronized void unregister ( String name ) { StreamScope < ? > streamScope = byNameMap . remove ( name ) ; if ( streamScope == null ) return ; List < String > names = byStreamScopeMap . get ( streamScope ) ; names . remove ( name ) ; if ( names . isEmpty ( ) ) byStreamScopeMap . remove ( streamScope ) ; }
private String expandAffix ( String pattern , StringBuffer buffer ) { buffer . setLength ( NUM_ ) ; for ( int i = NUM_ ; i < pattern . length ( ) ; ) { char c = pattern . charAt ( i ++ ) ; if ( c == QUOTE ) { c = pattern . charAt ( i ++ ) ; switch ( c ) { case CURRENCY_SIGN : if ( i < pattern . length ( ) && pattern . charAt ( i ) == CURRENCY_SIGN ) { ++ i ; buffer . append ( symbols . getInternationalCurrencySymbol ( ) ) ; } else { buffer . append ( symbols . getCurrencySymbol ( ) ) ; } continue ; case PATTERN_PERCENT : c = symbols . getPercent ( ) ; break ; case PATTERN_PER_MILLE : c = symbols . getPerMill ( ) ; break ; case PATTERN_MINUS : c = symbols . getMinusSign ( ) ; break ; } } buffer . append ( c ) ; } return buffer . toString ( ) ; }
public static QueryFunctions extractFunctions ( String [ ] filterQueries ) { final QueryFunctions result = new QueryFunctions ( ) ; if ( isEmpty ( filterQueries ) ) { return result ; } String [ ] arguments = new String [ NUM_ ] ; for ( String unmodifiedAnalysis : filterQueries ) { String function = extractFunction ( unmodifiedAnalysis ) ; String [ ] functions ; if ( function . contains ( FUNCTION_ARGUMENT_SPLITTER ) ) { functions = function . split ( FUNCTION_ARGUMENT_SPLITTER ) ; } else { functions = new String [ ] { function } ; } for ( String subFunction : functions ) { if ( subFunction . contains ( AGGREGATION_ARGUMENT_DELIMITER ) ) { arguments = extractAggregationParameter ( subFunction ) ; subFunction = subFunction . substring ( NUM_ , subFunction . indexOf ( AGGREGATION_ARGUMENT_DELIMITER ) ) ; } FunctionType type = FunctionType . valueOf ( subFunction . toUpperCase ( ) ) ; addFunction ( result , type , arguments ) ; } } return result ; }
protected final void fireVetoableChange ( String propertyName , int oldValue , int newValue ) throws PropertyVetoException { VetoableChangeSupport aVetoSupport = this . vetoSupport ; if ( aVetoSupport == null ) { return ; } aVetoSupport . fireVetoableChange ( propertyName , Integer . valueOf ( oldValue ) , Integer . valueOf ( newValue ) ) ; }
protected boolean isValidClassname ( String classname ) { return ( classname . indexOf ( STR_ ) == - NUM_ ) ; }
public static int number ( ) { return _all . size ( ) ; }
public String generateInvertedString ( ) { return String . format ( STR_ , xFFFFFF & generateInverted ( ) ) ; }
@ NotNull public String extractPresentableUrl ( @ NotNull String path ) { return path . replace ( STR_ , File . separatorChar ) ; }
public String convertSWFToHTML ( URL in ) throws Exception { HttpURLConnection conn = ( HttpURLConnection ) in . openConnection ( ) ; conn . setAllowUserInteraction ( BOOL_ ) ; conn . setRequestProperty ( STR_ , STR_ ) ; conn . setInstanceFollowRedirects ( BOOL_ ) ; conn . connect ( ) ; return convertSWFToHTML ( conn . getInputStream ( ) ) ; }
private void initProgram ( ) { glUseProgram ( this . program ) ; viewProjMatrixUniform = glGetUniformLocation ( this . program , STR_ ) ; glUseProgram ( NUM_ ) ; }
private boolean isNegative ( final String input ) { requireNonNull ( input ) ; for ( final String negativeString : negativeStrings ) { if ( input . equalsIgnoreCase ( negativeString ) ) { return BOOL_ ; } } return BOOL_ ; }
@ Override protected void sendDispositionHeader ( final OutputStream out ) throws IOException { LOG . trace ( STR_ ) ; super . sendDispositionHeader ( out ) ; final String filename = source . getFileName ( ) ; if ( filename != null ) { out . write ( FILE_NAME_BYTES ) ; out . write ( QUOTE_BYTES ) ; out . write ( EncodingUtil . getAsciiBytes ( filename ) ) ; out . write ( QUOTE_BYTES ) ; } }
private List < Map < String , Object > > prepareResultsforDisplay ( Collection < ScoredResult > scoredResults ) { ArrayList < Map < String , Object > > output = new ArrayList < Map < String , Object > > ( scoredResults . size ( ) ) ; for ( ScoredResult result : scoredResults ) { Map < String , Object > resultMap = new HashMap < String , Object > ( ) ; if ( result . track != null ) { prepareTrackForDisplay ( result . track , resultMap ) ; } else { prepareMarkerForDisplay ( result . waypoint , resultMap ) ; } output . add ( resultMap ) ; } return output ; }
public long copy ( final InputStream from , final OutputStream to ) throws IOException { long count = NUM_ ; byte [ ] tmp = mByteArrayPool . get ( mTempBufSize ) ; try { while ( BOOL_ ) { int read = from . read ( tmp , NUM_ , mTempBufSize ) ; if ( read == - NUM_ ) { return count ; } to . write ( tmp , NUM_ , read ) ; count += read ; } } finally { mByteArrayPool . release ( tmp ) ; } }
private static Element infoAsElement ( Document doc , LibraryInfo info ) { Element libraryElement = doc . createElement ( STR_ ) ; libraryElement . setAttribute ( STR_ , info . getVersion ( ) ) ; appendPathElements ( doc , STR_ , libraryElement , info . getBootpath ( ) ) ; appendPathElements ( doc , STR_ , libraryElement , info . getExtensionDirs ( ) ) ; appendPathElements ( doc , STR_ , libraryElement , info . getEndorsedDirs ( ) ) ; return libraryElement ; }
public void addChoiceValue ( String value , String i18nKey ) throws SMSException , SSOException { Map choiceValues = as . getChoiceValuesMap ( ) ; choiceValues . put ( value , i18nKey ) ; updateChoiceValues ( choiceValues ) ; }
private void notifyChange ( int previous , int current ) { if ( mOnValueChangeListener != null ) { mOnValueChangeListener . onValueChange ( this , previous , mValue ) ; } }
public void loadLibrary ( String libName ) { loadLibrary0 ( libName , RVMClass . getClassLoaderFromStackFrame ( NUM_ ) , BOOL_ ) ; }
public void handleTblDataActionHrefRequest ( RequestInvocationEvent event ) { String idRepoName = hexToString ( ( String ) getDisplayFieldValue ( TBL_DATA_ACTION_HREF ) ) ; String curRealm = ( String ) getPageSessionAttribute ( AMAdminConstants . CURRENT_REALM ) ; try { IDRepoModel model = ( IDRepoModel ) getModel ( ) ; setPageSessionAttribute ( IDRepoOpViewBeanBase . IDREPO_NAME , idRepoName ) ; setPageSessionAttribute ( IDRepoOpViewBeanBase . IDREPO_TYPE , model . getIDRepoType ( curRealm , idRepoName ) ) ; IDRepoEditViewBean vb = ( IDRepoEditViewBean ) getViewBean ( IDRepoEditViewBean . class ) ; unlockPageTrail ( ) ; passPgSessionMap ( vb ) ; vb . forwardTo ( getRequestContext ( ) ) ; } catch ( AMConsoleException e ) { setInlineAlertMessage ( CCAlert . TYPE_ERROR , STR_ , e . getMessage ( ) ) ; forwardTo ( ) ; } }
public Charset charset ( ) { return charset != null ? Charset . forName ( charset ) : null ; }
public boolean initialize ( DDFModule poModuleIn , String pszTagIn , byte [ ] pachFieldArea ) { int iFDOffset = poModuleIn . _fieldControlLength ; poModule = poModuleIn ; pszTag = pszTagIn ; _data_struct_code = DataStructCode . get ( ( char ) pachFieldArea [ NUM_ ] ) ; _data_type_code = DataTypeCode . get ( ( char ) pachFieldArea [ NUM_ ] ) ; if ( Debug . debugging ( STR_ ) ) { Debug . output ( STR_ + pszTagIn + STR_ + _data_struct_code + STR_ + _data_type_code + STR_ + iFDOffset ) ; } byte [ ] tempData = new byte [ pachFieldArea . length - iFDOffset ] ; System . arraycopy ( pachFieldArea , iFDOffset , tempData , NUM_ , pachFieldArea . length - iFDOffset ) ; MutableInt nCharsConsumed = new MutableInt ( ) ; _fieldName = DDFUtils . fetchVariable ( tempData , tempData . length , DDF_UNIT_TERMINATOR , DDF_FIELD_TERMINATOR , nCharsConsumed ) ; if ( Debug . debugging ( STR_ ) ) { Debug . output ( STR_ + pszTagIn + STR_ + _fieldName ) ; } iFDOffset += nCharsConsumed . value ; tempData = new byte [ pachFieldArea . length - iFDOffset ] ; System . arraycopy ( pachFieldArea , iFDOffset , tempData , NUM_ , pachFieldArea . length - iFDOffset ) ; _arrayDescr = DDFUtils . fetchVariable ( tempData , tempData . length , DDF_UNIT_TERMINATOR , DDF_FIELD_TERMINATOR , nCharsConsumed ) ; iFDOffset += nCharsConsumed . value ; tempData = new byte [ pachFieldArea . length - iFDOffset ] ; System . arraycopy ( pachFieldArea , iFDOffset , tempData , NUM_ , pachFieldArea . length - iFDOffset ) ; _formatControls = DDFUtils . fetchVariable ( tempData , tempData . length , DDF_UNIT_TERMINATOR , DDF_FIELD_TERMINATOR , nCharsConsumed ) ; if ( _data_struct_code != DataStructCode . ELEMENTARY ) { if ( ! buildSubfieldDefns ( _arrayDescr ) ) { return BOOL_ ; } if ( ! applyFormats ( _formatControls ) ) { return BOOL_ ; } } return BOOL_ ; }
@ Override public void loadHeightMap ( Raster raster ) throws IOException { int stripHeight = Math . min ( STRIP_ROWS , rasterLength ) ; int stripWidth = rasterWidth . samplesPerPixel ; int stripSize = stripWidth . stripHeight . bytesPerSample ; int numStrips = ( int ) Math . ceil ( ( double ) rasterLength / stripHeight ) ; if ( stripSize > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( STR_ + Integer . MAX_VALUE + STR_ ) ; } if ( ( minimum == null ) || ( maximum == null ) ) { computeMinMaxFromStrip ( dataType , numStrips , stripSize , stripWidth , stripHeight ) ; } loadFromStrip ( dataType , numStrips , stripSize , stripWidth , stripHeight , raster , BOOL_ ) ; }
public void addFooter ( @ NonNull View view ) { if ( view == null ) { throw new IllegalArgumentException ( STR_ ) ; } mFooters . add ( view ) ; }
public static Pair < int [ ] , double [ ] > convert ( Set < Feature > features , Lexicon lexicon , boolean trainingMode ) { TIntDoubleHashMap fMap = new TIntDoubleHashMap ( features . size ( ) ) ; for ( Feature feature : features ) { final int featureId = FeatureUtilities . getFeatureId ( lexicon , trainingMode , feature ) ; if ( featureId < NUM_ ) continue ; double value = feature . getValue ( ) + fMap . get ( featureId ) ; fMap . put ( featureId , value ) ; } int [ ] idsOriginal = fMap . keys ( ) ; int [ ] ids = new int [ idsOriginal . length ] ; System . arraycopy ( idsOriginal , NUM_ , ids , NUM_ , ids . length ) ; Arrays . sort ( ids ) ; double [ ] vals = new double [ fMap . size ( ) ] ; int count = NUM_ ; for ( int key : ids ) { vals [ count ++ ] = fMap . get ( key ) ; } return new Pair < > ( ids , vals ) ; }
private static String creteXMLTotalCount ( int firstRow , int numPFIS , int numPJUR , int rDefault , int maxResults ) { String result = null ; Document document = DocumentHelper . createDocument ( ) ; Element root = document . addElement ( PersonKeys . XML_PERSONAS_TEXT ) ; root . addAttribute ( PersonKeys . XML_INICIO_TEXT , Integer . toString ( firstRow ) ) ; if ( ( firstRow + rDefault ) > ( numPFIS + numPJUR ) ) { root . addAttribute ( PersonKeys . XML_FIN_TEXT , Integer . toString ( numPFIS + numPJUR ) ) ; } else { root . addAttribute ( PersonKeys . XML_FIN_TEXT , Integer . toString ( firstRow + rDefault ) ) ; } root . addAttribute ( PersonKeys . XML_TOTAL_TEXT , Integer . toString ( numPFIS + numPJUR ) ) ; root . addAttribute ( PersonKeys . XML_RANGO_TEXT , Integer . toString ( rDefault ) ) ; root . addAttribute ( PersonKeys . XML_RESULT_MAX_TEXT , Integer . toString ( maxResults ) ) ; result = document . asXML ( ) ; return result ; }
public String toFeatureString ( FeatureVector fv ) { if ( numByteFeatures != fv . getNumberOfByteFeatures ( ) || numShortFeatures != fv . getNumberOfShortFeatures ( ) || numContinuousFeatures != fv . getNumberOfContinuousFeatures ( ) ) throw new IllegalArgumentException ( STR_ + fv + STR_ ) ; StringBuilder buf = new StringBuilder ( ) ; for ( int i = NUM_ ; i < numByteFeatures ; i ++ ) { if ( buf . length ( ) > NUM_ ) buf . append ( STR_ ) ; buf . append ( getFeatureValueAsString ( i , fv . getByteFeature ( i ) ) ) ; } for ( int i = numByteFeatures ; i < numByteFeatures + numShortFeatures ; i ++ ) { if ( buf . length ( ) > NUM_ ) buf . append ( STR_ ) ; buf . append ( getFeatureValueAsString ( i , fv . getShortFeature ( i ) ) ) ; } for ( int i = numByteFeatures + numShortFeatures ; i < numByteFeatures + numShortFeatures + numContinuousFeatures ; i ++ ) { if ( buf . length ( ) > NUM_ ) buf . append ( STR_ ) ; buf . append ( fv . getContinuousFeature ( i ) ) ; } return buf . toString ( ) ; }
protected void sortPopulation ( ) { if ( Properties . SHUFFLE_GOALS ) Randomness . shuffle ( population ) ; if ( isMaximizationFunction ( ) ) { Collections . sort ( population , Collections . reverseOrder ( ) ) ; } else { Collections . sort ( population ) ; } }
public void clean ( ) { ChronoFullRevision cfr = firstCFR ; totalSize = size ; while ( cfr != null ) { totalSize += cfr . size ( ) ; cfr = cfr . getNext ( ) ; } if ( totalSize < MAX_STORAGE_SIZE ) { return ; } cfr = firstCFR ; while ( cfr != null ) { totalSize += cfr . clean ( revisionIndex , NUM_ ) ; cfr = cfr . getNext ( ) ; } ChronoStorageBlock block ; while ( last != null && totalSize >= MAX_STORAGE_SIZE ) { block = last . getIndexPrev ( ) ; if ( storage . remove ( last . getRevisionIndex ( ) ) == null ) { throw new RuntimeException ( STR_ ) ; } totalSize -= last . length ( ) ; size += last . length ( ) ; if ( block != null ) { block . setIndexNext ( null ) ; } last . setIndexPrev ( null ) ; cfr = last . getChronoFullRevision ( ) ; totalSize += cfr . size ( ) - cfr . clean ( revisionIndex , last . getRevisionIndex ( ) ) ; if ( last == first ) { first = null ; } last = block ; } System . gc ( ) ; }
public static Number plus ( Character left , Character right ) { return plus ( Integer . valueOf ( left ) , right ) ; }
boolean containRelayState ( String relayState ) { return relayStateMap . containsKey ( relayState ) ; }
public void localSearchStarted ( ) { startTime = System . currentTimeMillis ( ) ; endTime = startTime + Properties . LOCAL_SEARCH_BUDGET . NUM_ ; tests = NUM_ ; suites = NUM_ ; fitnessEvaluations = NUM_ ; executedStart = MaxStatementsStoppingCondition . getNumExecutedStatements ( ) ; }
public synchronized int write ( InputStream in ) throws IOException { int readCount = NUM_ ; int inBufferPos = count - filledBufferSum ; int n = in . read ( currentBuffer , inBufferPos , currentBuffer . length - inBufferPos ) ; while ( n != - NUM_ ) { readCount += n ; inBufferPos += n ; count += n ; if ( inBufferPos == currentBuffer . length ) { needNewBuffer ( currentBuffer . length ) ; inBufferPos = NUM_ ; } n = in . read ( currentBuffer , inBufferPos , currentBuffer . length - inBufferPos ) ; } return readCount ; }
public static double normalizeRadians ( double r ) { if ( r < NUM_ && r >= - TWO_PI ) return r + TWO_PI ; if ( r >= TWO_PI && r < FOUR_PI ) return r - TWO_PI ; if ( r >= NUM_ && r < TWO_PI ) return r ; r -= TWO_PI . Math . floor ( r . TWO_PI_INVERSE ) ; if ( r < NUM_ ) r += TWO_PI ; return r ; }
public static TetradMatrix convertCovToCorr ( TetradMatrix m ) { for ( int i = NUM_ ; i < m . rows ( ) ; i ++ ) { for ( int j = NUM_ ; j < m . columns ( ) ; j ++ ) { if ( Double . isNaN ( m . get ( i , j ) ) ) { throw new IllegalArgumentException ( STR_ ) ; } } } return correlation ( m ) ; }
private byte [ ] ungzip ( byte [ ] body ) { ByteArrayInputStream bytein = new ByteArrayInputStream ( body ) ; try ( GZIPInputStream gzin = new GZIPInputStream ( bytein ) ; ByteArrayOutputStream byteout = new ByteArrayOutputStream ( ) ) { int res = NUM_ ; byte buf [ ] = new byte [ NUM_ ] ; while ( res >= NUM_ ) { res = gzin . read ( buf , NUM_ , buf . length ) ; if ( res > NUM_ ) { byteout . write ( buf , NUM_ , res ) ; } } byte uncompressed [ ] = byteout . toByteArray ( ) ; return uncompressed ; } catch ( IOException e ) { } return null ; }
private boolean selectID ( int nodeID , boolean show ) { if ( m_root == null ) return BOOL_ ; log . config ( STR_ + nodeID + STR_ + show + STR_ + m_root ) ; MTreeNode node = m_root . findNode ( nodeID ) ; if ( node != null ) { TreePath treePath = new TreePath ( node . getPath ( ) ) ; log . config ( STR_ + node + STR_ + treePath . toString ( ) ) ; tree . setSelectionPath ( treePath ) ; if ( show ) { tree . makeVisible ( treePath ) ; tree . scrollPathToVisible ( treePath ) ; } return BOOL_ ; } log . info ( STR_ + nodeID ) ; return BOOL_ ; }
@ Override public void loadRGBA ( Raster raster ) throws IOException { if ( bandStorageType == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( samplesPerPixel < NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } if ( iStream != null ) { iStream . close ( ) ; } iStream = new FileImageInputStream ( new File ( dataFilePath ) ) ; iStream . seek ( imageStart ) ; int stripHeight = Math . min ( STRIP_ROWS , rasterLength ) ; int stripWidth = rasterWidth . samplesPerPixel ; int numStrips = ( int ) Math . ceil ( ( double ) rasterLength / stripHeight ) ; if ( bandStorageType . equals ( STR_ ) ) { int stripSize = stripWidth . stripHeight . bytesPerSample ; if ( stripSize > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( STR_ + Integer . MAX_VALUE + STR_ ) ; } byte [ ] bbArray = new byte [ stripSize ] ; ByteBuffer bbuf = ByteBuffer . allocate ( NUM_ . rasterWidth . stripHeight ) ; iStream . seek ( imageStart ) ; int r = NUM_ ; for ( int i = NUM_ ; i < numStrips ; ++ i ) { int h = Math . min ( rasterLength - stripHeight . i , stripHeight ) ; int len = h . stripWidth ; len = iStream . read ( bbArray , NUM_ , len ) ; for ( int j = NUM_ ; j < h ; ++ j ) { for ( int k = NUM_ ; k < stripWidth ; k += samplesPerPixel ) { for ( int l = NUM_ ; l < samplesPerPixel ; ++ l ) { bbuf . put ( bbArray [ k + l ] ) ; } if ( samplesPerPixel == NUM_ ) { bbuf . put ( ( byte ) NUM_ ) ; } } r ++ ; } bbuf . rewind ( ) ; raster . set ( r , h , bbArray ) ; } } else if ( bandStorageType . equals ( STR_ ) ) { int stripSize = rasterWidth . stripHeight ; if ( stripSize > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( STR_ + Integer . MAX_VALUE + STR_ ) ; } raster . set ( NUM_ ) ; byte [ ] bArray = new byte [ NUM_ . rasterWidth . stripHeight ] ; byte [ ] bbArray = new byte [ stripSize ] ; iStream . seek ( imageStart ) ; for ( int k = NUM_ ; k < samplesPerPixel ; ++ k ) { int r = NUM_ ; for ( int i = NUM_ ; i < numStrips ; ++ i ) { int h = Math . min ( rasterLength - stripHeight . i , stripHeight ) ; int len = h . rasterWidth ; len = iStream . read ( bbArray , NUM_ , len ) ; for ( int j = NUM_ ; j < h ; ++ j ) { raster . get ( r , bArray ) ; for ( int c = NUM_ ; c < rasterWidth ; ++ c ) { bArray [ c . NUM_ + k ] = bbArray [ c ] ; } raster . set ( r , NUM_ , bArray ) ; r ++ ; } } } } if ( minimum == null ) { minimum = new double [ ] { NUM_ , NUM_ , NUM_ , NUM_ } ; } if ( maximum == null ) { maximum = new double [ ] { NUM_ , NUM_ , NUM_ , NUM_ } ; } }
protected final boolean isListState ( ) { return stateTextTypes . charAt ( state ) == STR_ ; }
private static Class < ? extends Activity > guessErrorActivityClass ( Context context ) { Class < ? extends Activity > resolvedActivityClass ; resolvedActivityClass = CustomActivityOnCrash . getErrorActivityClassWithIntentFilter ( context ) ; if ( resolvedActivityClass == null ) { resolvedActivityClass = DefaultErrorActivity . class ; } return resolvedActivityClass ; }
public void loadGlyphs ( String chars ) throws NoGlyphException { char [ ] chs = chars . toCharArray ( ) ; for ( int i = NUM_ ; i < chs . length ; i ++ ) { getGlyph ( chs [ i ] , null ) ; } }
private void initQuestAndAddToWorld ( final IQuest quest ) { logger . info ( STR_ + quest . getName ( ) ) ; quest . addToWorld ( ) ; quests . add ( quest ) ; }
public static MoveCommand [ ] values ( int f , GameOptions opts , boolean forwardIni ) { boolean manualShutdown = BOOL_ , selfDestruct = BOOL_ ; if ( opts != null ) { manualShutdown = opts . booleanOption ( STR_ ) ; selfDestruct = opts . booleanOption ( STR_ ) ; } ArrayList < MoveCommand > flaggedCmds = new ArrayList < MoveCommand > ( ) ; for ( MoveCommand cmd : MoveCommand . values ( ) ) { if ( ( cmd == MOVE_SHUTDOWN || cmd == MOVE_STARTUP ) && ! manualShutdown ) { continue ; } if ( cmd == MOVE_SELF_DESTRUCT && ! selfDestruct ) { continue ; } if ( cmd == MOVE_FORWARD_INI && ! forwardIni ) { continue ; } if ( ( cmd . flag & f ) == f ) { flaggedCmds . add ( cmd ) ; } } return flaggedCmds . toArray ( new MoveCommand [ NUM_ ] ) ; }
public boolean isLDAP ( ) { String host = getLDAPHost ( ) ; if ( host == null || host . length ( ) == NUM_ ) return BOOL_ ; String domain = getLDAPDomain ( ) ; return domain != null && domain . length ( ) > NUM_ ; }
public void shedCache ( ) { Connection [ ] conn ; synchronized ( freeList ) { conn = freeList . toArray ( new Connection [ freeList . size ( ) ] ) ; freeList . clear ( ) ; } for ( int i = conn . length ; -- i >= NUM_ ; ) { Connection c = conn [ i ] ; conn [ i ] = null ; try { c . close ( ) ; } catch ( java . io . IOException e ) { } } }
public static byte [ ] hash ( InputStream in ) throws IOException { if ( HASH_DIGEST == null ) { throw new EvernoteUtilException ( EDAM_HASH_ALGORITHM + STR_ , new NoSuchAlgorithmException ( EDAM_HASH_ALGORITHM ) ) ; } byte [ ] buf = new byte [ NUM_ ] ; int n ; while ( ( n = in . read ( buf ) ) != - NUM_ ) { HASH_DIGEST . update ( buf , NUM_ , n ) ; } return HASH_DIGEST . digest ( ) ; }
public byte [ ] readRawBytes ( final int size ) throws IOException { if ( size < NUM_ ) { throw InvalidProtocolBufferNanoException . negativeSize ( ) ; } if ( bufferPos + size > currentLimit ) { skipRawBytes ( currentLimit - bufferPos ) ; throw InvalidProtocolBufferNanoException . truncatedMessage ( ) ; } if ( size <= bufferSize - bufferPos ) { final byte [ ] bytes = new byte [ size ] ; System . arraycopy ( buffer , bufferPos , bytes , NUM_ , size ) ; bufferPos += size ; return bytes ; } else { throw InvalidProtocolBufferNanoException . truncatedMessage ( ) ; } }
public abstract TreeNode createNode ( final int x , final int y ) ;
@ SuppressWarnings ( STR_ ) public static < T extends FeatureStructure > List < T > toList ( FSArray array ) { if ( array == null ) { return new ArrayList < T > ( ) ; } else { return ( List < T > ) Arrays . asList ( array . toArray ( ) ) ; } }
private void resetNotes2 ( ) { if ( errorInStatus2 ) { if ( editMode ) { statusText1 . setText ( editStatus2 ) ; } else { statusText2 . setText ( stdStatus2 ) ; } errorInStatus2 = BOOL_ ; } }
protected static int toDigit ( final char ch , final int index ) throws IllegalArgumentException { final int digit = Character . digit ( ch , NUM_ ) ; if ( digit == - NUM_ ) { throw new IllegalArgumentException ( STR_ + ch + STR_ + index ) ; } return digit ; }
public static ServerSideSortRequestControl newControl ( final boolean isCritical , final Collection < SortKey > keys ) { Reject . ifNull ( keys ) ; Reject . ifFalse ( ! keys . isEmpty ( ) , STR_ ) ; return new ServerSideSortRequestControl ( isCritical , Collections . unmodifiableList ( new ArrayList < SortKey > ( keys ) ) ) ; }
@ SuppressWarnings ( { STR_ , STR_ } ) static < E extends Comparable < E > > AutoSortedCollection < E > createAutoSortedCollection ( Supplier < List < SortedListElement < E > > > listSup , Collection < ? extends E > values ) { List list = listSup . get ( ) ; if ( ! list . isEmpty ( ) ) { throw new IllegalStateException ( STR_ ) ; } AutoSortedCollection < E > sortedCollection = new AutoListSortedCollection < > ( list , null ) ; sortedCollection . addAll ( values ) ; return sortedCollection ; }
private void intStream ( ) { int [ ] ints = new int [ ] { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; IntStream intStream = IntStream . of ( ints ) ; intStream . forEach ( null ) ; IntStream intStream2 = IntStream . of ( NUM_ , NUM_ , NUM_ , NUM_ , NUM_ ) ; intStream2 . forEach ( null ) ; }
@ SuppressWarnings ( STR_ ) public boolean isCustomized ( ) { if ( m_customizationLevel == null ) { getElementID ( ) ; m_customizationLevel = new Integer ( s_parameters . CUSTOMNONE ) ; if ( m_parent . isCustomPrefix ( m_name ) ) { m_customizationLevel = new Integer ( s_parameters . CUSTOMPREFIXED ) ; } else { if ( m_parent . isObjectExists ( STR_ , m_parent . getTables ( ) ) && m_parent . isObjectExists ( STR_ , m_parent . getTables ( ) ) ) { String sql = s_dbEngine . sqlAD_getTableColumnEntityType ( m_parent . getVendor ( ) , m_parent . getCatalog ( ) , m_parent . getSchema ( ) , m_table , m_name ) ; Statement stmt = m_parent . setStatement ( ) ; ResultSet rs = m_parent . executeQuery ( stmt , sql ) ; if ( m_parent . getResultSetNext ( rs ) ) { String s = m_parent . getResultSetString ( rs , STR_ ) ; if ( m_parent . isCustomEntityType ( s ) ) m_customizationLevel = new Integer ( s_parameters . CUSTOMMARKED ) ; } m_parent . releaseResultSet ( rs ) ; m_parent . releaseStatement ( stmt ) ; } } } if ( m_customizationLevel . intValue ( ) > s_parameters . CUSTOMNONE ) return BOOL_ ; else return BOOL_ ; }
private void reloadQueue ( ) { String q = null ; int id = mCardId ; if ( mPreferences . contains ( STR_ ) ) { id = mPreferences . getInt ( STR_ , ~ mCardId ) ; } if ( id == mCardId ) { q = mPreferences . getString ( STR_ , STR_ ) ; } int qlen = q != null ? q . length ( ) : NUM_ ; if ( qlen > NUM_ ) { int plen = NUM_ ; int n = NUM_ ; int shift = NUM_ ; for ( int i = NUM_ ; i < qlen ; i ++ ) { final char c = q . charAt ( i ) ; if ( c == STR_ ) { ensurePlayListCapacity ( plen + NUM_ ) ; mPlayList [ plen ] = n ; plen ++ ; n = NUM_ ; shift = NUM_ ; } else { if ( c >= STR_ && c <= STR_ ) { n += c - STR_ << shift ; } else if ( c >= STR_ && c <= STR_ ) { n += NUM_ + c - STR_ << shift ; } else { plen = NUM_ ; break ; } shift += NUM_ ; } } mPlayListLen = plen ; final int pos = mPreferences . getInt ( STR_ , NUM_ ) ; if ( pos < NUM_ || pos >= mPlayListLen ) { mPlayListLen = NUM_ ; return ; } mPlayPos = pos ; updateCursor ( mPlayList [ mPlayPos ] ) ; if ( mCursor == null ) { SystemClock . sleep ( NUM_ ) ; updateCursor ( mPlayList [ mPlayPos ] ) ; } synchronized ( this ) { closeCursor ( ) ; mOpenFailedCounter = NUM_ ; openCurrentAndNext ( ) ; } if ( mPlayer == null || ! mPlayer . isInitialized ( ) ) { mPlayListLen = NUM_ ; return ; } final long seekpos = mPreferences . getLong ( STR_ , NUM_ ) ; seek ( seekpos >= NUM_ && seekpos < duration ( ) ? seekpos : NUM_ ) ; if ( D ) { LOG . info ( STR_ + position ( ) + STR_ + duration ( ) + STR_ + seekpos + STR_ ) ; } int repmode = mPreferences . getInt ( STR_ , REPEAT_NONE ) ; if ( repmode != REPEAT_ALL && repmode != REPEAT_CURRENT ) { repmode = REPEAT_NONE ; } mRepeatMode = repmode ; int shufmode = mPreferences . getInt ( STR_ , SHUFFLE_NONE ) ; if ( shufmode != SHUFFLE_AUTO && shufmode != SHUFFLE_NORMAL ) { shufmode = SHUFFLE_NONE ; } if ( shufmode != SHUFFLE_NONE ) { q = mPreferences . getString ( STR_ , STR_ ) ; qlen = q != null ? q . length ( ) : NUM_ ; if ( qlen > NUM_ ) { n = NUM_ ; shift = NUM_ ; mHistory . clear ( ) ; for ( int i = NUM_ ; i < qlen ; i ++ ) { final char c = q . charAt ( i ) ; if ( c == STR_ ) { if ( n >= mPlayListLen ) { mHistory . clear ( ) ; break ; } mHistory . add ( n ) ; n = NUM_ ; shift = NUM_ ; } else { if ( c >= STR_ && c <= STR_ ) { n += c - STR_ << shift ; } else if ( c >= STR_ && c <= STR_ ) { n += NUM_ + c - STR_ << shift ; } else { mHistory . clear ( ) ; break ; } shift += NUM_ ; } } } } if ( shufmode == SHUFFLE_AUTO ) { if ( ! makeAutoShuffleList ( ) ) { shufmode = SHUFFLE_NONE ; } } mShuffleMode = shufmode ; } }
public final void scheduledForFlush ( ) { scheduledForFlush . set ( BOOL_ ) ; }
public ImageInfo inspectImage ( String image ) throws IOException { return inspectImage ( InspectImageParams . create ( image ) ) ; }
@ Override public double prevCumulativeQuantity ( final Long woActivityId , Long mbHeaderId ) { if ( mbHeaderId == null ) mbHeaderId = - NUM_ ; final Object [ ] params = new Object [ ] { mbHeaderId , mbHeaderId , WorksConstants . CANCELLED_STATUS , woActivityId } ; final Double pQuant = ( Double ) genericService . findByNamedQuery ( STR_ , params ) ; if ( pQuant == null ) return NUM_ ; else return pQuant . doubleValue ( ) ; }
void receive ( int length , DataInputStream in ) throws IOException { synchronized ( lock ) { if ( ( pos > NUM_ ) && ( ( buffer . length - present ) < length ) ) { System . arraycopy ( buffer , pos , buffer , NUM_ , present - pos ) ; present -= pos ; pos = NUM_ ; } if ( ( buffer . length - present ) < length ) throw new IOException ( STR_ ) ; in . readFully ( buffer , present , length ) ; present += length ; requested -= length ; lock . notifyAll ( ) ; } }
public JDABuilder removeListener ( Object listener ) { listeners . remove ( listener ) ; return this ; }
private void updateBaseMatrix ( Drawable d ) { ImageView imageView = getImageView ( ) ; if ( null == imageView || null == d ) { return ; } final float viewWidth = getImageViewWidth ( imageView ) ; final float viewHeight = getImageViewHeight ( imageView ) ; final int drawableWidth = d . getIntrinsicWidth ( ) ; final int drawableHeight = d . getIntrinsicHeight ( ) ; mBaseMatrix . reset ( ) ; final float widthScale = viewWidth / drawableWidth ; final float heightScale = viewHeight / drawableHeight ; if ( mScaleType == ScaleType . CENTER ) { mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth ) / NUM_ , ( viewHeight - drawableHeight ) / NUM_ ) ; } else if ( mScaleType == ScaleType . CENTER_CROP ) { float scale = Math . max ( widthScale , heightScale ) ; mBaseMatrix . postScale ( scale , scale ) ; mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth . scale ) / NUM_ , ( viewHeight - drawableHeight . scale ) / NUM_ ) ; } else if ( mScaleType == ScaleType . CENTER_INSIDE ) { float scale = Math . min ( NUM_ , Math . min ( widthScale , heightScale ) ) ; mBaseMatrix . postScale ( scale , scale ) ; mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth . scale ) / NUM_ , ( viewHeight - drawableHeight . scale ) / NUM_ ) ; } else { RectF mTempSrc = new RectF ( NUM_ , NUM_ , drawableWidth , drawableHeight ) ; RectF mTempDst = new RectF ( NUM_ , NUM_ , viewWidth , viewHeight ) ; switch ( mScaleType ) { case FIT_CENTER : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . CENTER ) ; break ; case FIT_START : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . START ) ; break ; case FIT_END : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . END ) ; break ; case FIT_XY : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . FILL ) ; break ; default : break ; } } resetMatrix ( ) ; }
private static List < String > readFile ( File file ) throws IOException { FileReader fr = new FileReader ( file ) ; BufferedReader br = new BufferedReader ( fr ) ; List < String > lines = new ArrayList < String > ( ) ; String line ; while ( ( line = br . readLine ( ) ) != null ) lines . add ( line ) ; fr . close ( ) ; br . close ( ) ; return lines ; }
FlexibleNode readExternalNode ( HashMap < String , Taxon > translationList ) throws ImportException , IOException { FlexibleNode node = new FlexibleNode ( ) ; String label = readToken ( STR_ ) ; Taxon taxon ; if ( translationList . size ( ) > NUM_ ) { taxon = translationList . get ( label ) ; if ( taxon == null ) { throw new UnknownTaxonException ( STR_ + label + STR_ ) ; } } else { taxon = new Taxon ( label ) ; } if ( getLastMetaComment ( ) != null ) { parseMigrationString ( getLastMetaComment ( ) , node ) ; clearLastMetaComment ( ) ; } node . setTaxon ( taxon ) ; int pop = Integer . parseInt ( label . split ( STR_ ) [ NUM_ ] ) ; node . setAttribute ( POP , ( pop - NUM_ ) ) ; return node ; }
static void plugTogetherPair ( InputStream in , OutputStream out , InputStream in1 , OutputStream out1 ) { Thread inThread = null ; Thread outThread = null ; int nExecs = getNumExec ( ) ; inThread = AccessController . doPrivileged ( new NewThreadAction ( new PipeWriter ( in , out , STR_ , nExecs ) , STR_ , BOOL_ ) ) ; outThread = AccessController . doPrivileged ( new NewThreadAction ( new PipeWriter ( in1 , out1 , STR_ , nExecs ) , STR_ , BOOL_ ) ) ; inThread . start ( ) ; outThread . start ( ) ; }
@ NonNull public static StorableFence and ( @ NonNull StorableFence ... fences ) { return StorableFence . and ( Arrays . asList ( fences ) ) ; }
public MXFUID ( byte [ ] uid ) { this . uid = Arrays . copyOf ( uid , uid . length ) ; }
private int shrinkFlexItems ( FlexLine flexLine , @ FlexDirection int flexDirection , int maxMainSize , int paddingAlongMainAxis , int startIndex ) { int childIndex = startIndex ; int sizeBeforeShrink = flexLine . mMainSize ; if ( flexLine . mTotalFlexShrink <= NUM_ || maxMainSize > flexLine . mMainSize ) { childIndex += flexLine . mItemCount ; return childIndex ; } boolean needsReshrink = BOOL_ ; float unitShrink = ( flexLine . mMainSize - maxMainSize ) / flexLine . mTotalFlexShrink ; float accumulatedRoundError = NUM_ ; flexLine . mMainSize = paddingAlongMainAxis + flexLine . mDividerLengthInMainSize ; for ( int i = NUM_ ; i < flexLine . mItemCount ; i ++ ) { View child = getReorderedChildAt ( childIndex ) ; if ( child == null ) { continue ; } else if ( child . getVisibility ( ) == View . GONE ) { childIndex ++ ; continue ; } LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; if ( isMainAxisDirectionHorizontal ( flexDirection ) ) { if ( ! mChildrenFrozen [ childIndex ] ) { float rawCalculatedWidth = child . getMeasuredWidth ( ) - unitShrink . lp . flexShrink ; if ( i == flexLine . mItemCount - NUM_ ) { rawCalculatedWidth += accumulatedRoundError ; accumulatedRoundError = NUM_ ; } int newWidth = Math . round ( rawCalculatedWidth ) ; if ( newWidth < lp . minWidth ) { needsReshrink = BOOL_ ; newWidth = lp . minWidth ; mChildrenFrozen [ childIndex ] = BOOL_ ; flexLine . mTotalFlexShrink -= lp . flexShrink ; } else { accumulatedRoundError += ( rawCalculatedWidth - newWidth ) ; if ( accumulatedRoundError > NUM_ ) { newWidth += NUM_ ; accumulatedRoundError -= NUM_ ; } else if ( accumulatedRoundError < - NUM_ ) { newWidth -= NUM_ ; accumulatedRoundError += NUM_ ; } } child . measure ( MeasureSpec . makeMeasureSpec ( newWidth , MeasureSpec . EXACTLY ) , MeasureSpec . makeMeasureSpec ( child . getMeasuredHeight ( ) , MeasureSpec . EXACTLY ) ) ; } flexLine . mMainSize += child . getMeasuredWidth ( ) + lp . leftMargin + lp . rightMargin ; } else { if ( ! mChildrenFrozen [ childIndex ] ) { float rawCalculatedHeight = child . getMeasuredHeight ( ) - unitShrink . lp . flexShrink ; if ( i == flexLine . mItemCount - NUM_ ) { rawCalculatedHeight += accumulatedRoundError ; accumulatedRoundError = NUM_ ; } int newHeight = Math . round ( rawCalculatedHeight ) ; if ( newHeight < lp . minHeight ) { needsReshrink = BOOL_ ; newHeight = lp . minHeight ; mChildrenFrozen [ childIndex ] = BOOL_ ; flexLine . mTotalFlexShrink -= lp . flexShrink ; } else { accumulatedRoundError += ( rawCalculatedHeight - newHeight ) ; if ( accumulatedRoundError > NUM_ ) { newHeight += NUM_ ; accumulatedRoundError -= NUM_ ; } else if ( accumulatedRoundError < - NUM_ ) { newHeight -= NUM_ ; accumulatedRoundError += NUM_ ; } } child . measure ( MeasureSpec . makeMeasureSpec ( child . getMeasuredWidth ( ) , MeasureSpec . EXACTLY ) , MeasureSpec . makeMeasureSpec ( newHeight , MeasureSpec . EXACTLY ) ) ; } flexLine . mMainSize += child . getMeasuredHeight ( ) + lp . topMargin + lp . bottomMargin ; } childIndex ++ ; } if ( needsReshrink && sizeBeforeShrink != flexLine . mMainSize ) { shrinkFlexItems ( flexLine , flexDirection , maxMainSize , paddingAlongMainAxis , startIndex ) ; } return childIndex ; }
public static DataModelList serializableInstance ( ) { return new DataModelList ( ) ; }
@ Override public MBHeader findLastMBPageNoForLineItem ( final WorkOrderActivity workOrderActivity , final Long mbHeaderId ) { logger . info ( STR_ ) ; String query = STR_ ; Object [ ] params ; final List < Object > paramList = new ArrayList < Object > ( ) ; query = query + STR_ + STR_ + STR_ + STR_ ; paramList . add ( workOrderActivity . getId ( ) ) ; paramList . add ( mbHeaderId ) ; paramList . add ( WorksConstants . APPROVED ) ; paramList . add ( mbHeaderId ) ; params = new Object [ paramList . size ( ) ] ; params = paramList . toArray ( params ) ; final List < MBHeader > mbHeaderList = genericService . findAllBy ( query , params ) ; MBHeader result = null ; if ( mbHeaderList != null && ! mbHeaderList . isEmpty ( ) ) result = mbHeaderList . get ( NUM_ ) ; return result ; }
synchronized private void outputBufferedChunk ( ) { if ( smallChunks == null || chunkSize == NUM_ ) { return ; } if ( smallChunks . size ( ) == NUM_ ) { outputChunk ( smallChunks . get ( NUM_ ) ) ; chunkSize = NUM_ ; smallChunks = null ; return ; } final IBindingSet [ ] chunk = new IBindingSet [ chunkSize ] ; int destPos = NUM_ ; for ( IBindingSet [ ] e : smallChunks ) { System . arraycopy ( e , NUM_ , chunk , destPos , e . length ) ; destPos += e . length ; } outputChunk ( chunk ) ; chunkSize = NUM_ ; smallChunks = null ; }
public ByteVector putByteArray ( final byte [ ] b , final int off , final int len ) { if ( length + len > data . length ) { enlarge ( len ) ; } if ( b != null ) { System . arraycopy ( b , off , data , length , len ) ; } length += len ; return this ; }
private void waitLoadCompete ( ) { if ( m_loadComplete ) return ; m_loader . setPriority ( Thread . NORM_PRIORITY ) ; log . config ( STR_ ) ; while ( m_loader . isAlive ( ) ) { try { Thread . sleep ( NUM_ ) ; } catch ( Exception e ) { log . log ( Level . SEVERE , STR_ , e ) ; } } log . config ( STR_ ) ; }
@ SuppressWarnings ( STR_ ) private void dtdatt ( Pair elm ) throws Exception { char attqn [ ] = null ; Pair att = null ; char ch ; for ( short st = NUM_ ; st >= NUM_ ; ) { ch = getch ( ) ; switch ( st ) { case NUM_ : switch ( chtyp ( ch ) ) { case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : bkch ( ) ; attqn = qname ( mIsNSAware ) ; att = find ( elm . list , attqn ) ; if ( att == null ) { att = pair ( elm . list ) ; att . chars = attqn ; elm . list = att ; } else { att = pair ( null ) ; att . chars = attqn ; att . id = STR_ ; } wsskip ( ) ; st = NUM_ ; break ; case STR_ : pent ( STR_ ) ; break ; case STR_ : break ; default : panic ( FAULT ) ; break ; } break ; case NUM_ : switch ( chtyp ( ch ) ) { case STR_ : att . id = STR_ ; st = NUM_ ; break ; case STR_ : pent ( STR_ ) ; break ; case STR_ : break ; default : bkch ( ) ; bntok ( ) ; att . id = bkeyword ( ) ; switch ( att . id ) { case STR_ : if ( wsskip ( ) != STR_ ) { panic ( FAULT ) ; } ch = getch ( ) ; st = NUM_ ; break ; case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : wsskip ( ) ; st = NUM_ ; break ; default : panic ( FAULT ) ; break ; } break ; } break ; case NUM_ : switch ( chtyp ( ch ) ) { case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : bkch ( ) ; switch ( att . id ) { case STR_ : bntok ( ) ; break ; case STR_ : mBuffIdx = - NUM_ ; bname ( BOOL_ ) ; break ; default : panic ( FAULT ) ; break ; } wsskip ( ) ; st = NUM_ ; break ; case STR_ : pent ( STR_ ) ; break ; case STR_ : break ; default : panic ( FAULT ) ; break ; } break ; case NUM_ : switch ( ch ) { case STR_ : wsskip ( ) ; st = NUM_ ; break ; case STR_ : wsskip ( ) ; switch ( att . id ) { case STR_ : bntok ( ) ; break ; case STR_ : mBuffIdx = - NUM_ ; bname ( BOOL_ ) ; break ; default : panic ( FAULT ) ; break ; } wsskip ( ) ; break ; case STR_ : pent ( STR_ ) ; break ; default : panic ( FAULT ) ; break ; } break ; case NUM_ : switch ( ch ) { case STR_ : bntok ( ) ; switch ( bkeyword ( ) ) { case STR_ : switch ( wsskip ( ) ) { case STR_ : case STR_ : st = NUM_ ; break ; case EOS : panic ( FAULT ) ; default : st = - NUM_ ; break ; } break ; case STR_ : case STR_ : st = - NUM_ ; break ; default : panic ( FAULT ) ; break ; } break ; case STR_ : case STR_ : bkch ( ) ; st = NUM_ ; break ; case STR_ : case STR_ : case STR_ : case STR_ : break ; case STR_ : pent ( STR_ ) ; break ; default : bkch ( ) ; st = - NUM_ ; break ; } break ; case NUM_ : switch ( ch ) { case STR_ : case STR_ : bkch ( ) ; bqstr ( STR_ ) ; att . list = pair ( null ) ; att . list . chars = new char [ att . chars . length + mBuffIdx + NUM_ ] ; System . arraycopy ( att . chars , NUM_ , att . list . chars , NUM_ , att . chars . length - NUM_ ) ; att . list . chars [ att . chars . length - NUM_ ] = STR_ ; att . list . chars [ att . chars . length ] = ch ; System . arraycopy ( mBuff , NUM_ , att . list . chars , att . chars . length + NUM_ , mBuffIdx ) ; att . list . chars [ att . chars . length + mBuffIdx + NUM_ ] = ch ; att . list . chars [ att . chars . length + mBuffIdx + NUM_ ] = STR_ ; st = - NUM_ ; break ; default : panic ( FAULT ) ; break ; } break ; default : panic ( FAULT ) ; break ; } } }
public void addClasses ( List < String > classNames ) { if ( handlerFactories == null ) { handlerFactories = new ArrayList < String > ( ) ; } handlerFactories . addAll ( classNames ) ; }
public static boolean isConstantName ( String name ) { return Pattern . matches ( STR_ , name ) ; }
private void notifyDead ( final RPEntity dead ) { if ( ! rats . remove ( dead ) ) { logger . warn ( STR_ + dead . toString ( ) + STR_ ) ; } if ( rats . size ( ) == NUM_ ) { phaseToDefaultPhase ( new LinkedList < String > ( Arrays . asList ( STR_ ) ) ) ; } }
public static OMGrid read ( DataInputStream dis ) throws IOException { return read ( dis , null ) ; }
public VarcharConstant ( String s ) { type = new VarcharType ( s . length ( ) ) ; val = s ; }
public boolean addChildPlanet ( DimensionProperties child ) { if ( child == this ) return BOOL_ ; childPlanets . add ( child . getId ( ) ) ; child . setParentPlanet ( this ) ; return BOOL_ ; }
@ Override public Enumeration < String > enumerateMeasures ( ) { Vector < String > newVector = new Vector < String > ( NUM_ ) ; newVector . add ( STR_ ) ; return newVector . elements ( ) ; }
int [ ] calculateRelative ( int [ ] absolute ) { int [ ] res = new int [ absolute . length ] ; res [ NUM_ ] = absolute [ NUM_ ] ; for ( int i = NUM_ ; i < res . length ; i ++ ) { res [ i ] = absolute [ i ] - absolute [ i - NUM_ ] ; } return res ; }
@ AfterClass public static void deleteLogDir ( ) { if ( logDir != null ) { FileUtils . deleteQuietly ( logDir ) ; } }
public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; char [ ] separator = { STR_ , STR_ } ; int n = rows ( ) ; int m = columns ( ) ; for ( int i = NUM_ ; i < n ; i ++ ) { separator [ NUM_ ] = STR_ ; for ( int j = NUM_ ; j < m ; j ++ ) { sb . append ( separator ) ; sb . append ( components [ i ] [ j ] ) ; separator [ NUM_ ] = STR_ ; } sb . append ( STR_ ) ; sb . append ( STR_ ) ; } return sb . toString ( ) ; }
public static String [ ] splitStringIntoArray ( String value ) { String [ ] values = new String [ NUM_ ] ; if ( value != null && value . length ( ) > NUM_ ) { if ( value . indexOf ( CIMConstants . COMMA_SEPERATOR ) != - NUM_ ) { values = value . split ( STR_ ) ; } else { values = new String [ NUM_ ] ; values [ NUM_ ] = value ; } } return values ; }
public static String fromAttrModelingModelClass ( String vaModelClass ) { return vaModelClass . split ( ValueAnalysis . MODEL_PACKAGE_PREFIX ) [ NUM_ ] ; }
private void pullEvent ( ) { final int newScrollValue ; final int itemDimension ; final float initialMotionValue , lastMotionValue ; switch ( getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : initialMotionValue = mInitialMotionX ; lastMotionValue = mLastMotionX ; break ; case VERTICAL : default : initialMotionValue = mInitialMotionY ; lastMotionValue = mLastMotionY ; break ; } switch ( mCurrentMode ) { case PULL_FROM_END : newScrollValue = Math . round ( Math . max ( initialMotionValue - lastMotionValue , NUM_ ) / FRICTION ) ; itemDimension = getFooterSize ( ) ; break ; case PULL_FROM_START : default : newScrollValue = Math . round ( Math . min ( initialMotionValue - lastMotionValue , NUM_ ) / FRICTION ) ; itemDimension = getHeaderSize ( ) ; break ; } setHeaderScroll ( newScrollValue ) ; if ( newScrollValue != NUM_ && ! isRefreshing ( ) ) { float scale = Math . abs ( newScrollValue ) / ( float ) itemDimension ; switch ( mCurrentMode ) { case PULL_FROM_END : mFooterLayout . onPull ( scale ) ; break ; case PULL_FROM_START : default : mHeaderLayout . onPull ( scale ) ; break ; } if ( mState != State . PULL_TO_REFRESH && itemDimension >= Math . abs ( newScrollValue ) ) { setState ( State . PULL_TO_REFRESH ) ; } else if ( mState == State . PULL_TO_REFRESH && itemDimension < Math . abs ( newScrollValue ) ) { setState ( State . RELEASE_TO_REFRESH ) ; } } }
public synchronized void add ( DccLocoAddress locoAddress , boolean directionNormal ) { if ( ! contains ( locoAddress ) ) { if ( ConsistList . size ( ) == NUM_ ) { byte command = NceBinaryCommand . LOCO_CMD_FWD_CONSIST_LEAD ; if ( ! directionNormal ) { command = NceBinaryCommand . LOCO_CMD_REV_CONSIST_LEAD ; } addLocoToConsist ( locoAddress . getNumber ( ) , locoAddress . isLongAddress ( ) , command ) ; ConsistPosition . put ( locoAddress , DccConsist . POSITION_LEAD ) ; } else if ( ConsistList . size ( ) == NUM_ ) { byte command = NceBinaryCommand . LOCO_CMD_FWD_CONSIST_REAR ; if ( ! directionNormal ) { command = NceBinaryCommand . LOCO_CMD_REV_CONSIST_REAR ; } addLocoToConsist ( locoAddress . getNumber ( ) , locoAddress . isLongAddress ( ) , command ) ; ConsistPosition . put ( locoAddress , DccConsist . POSITION_TRAIL ) ; } else { byte command = NceBinaryCommand . LOCO_CMD_FWD_CONSIST_MID ; if ( ! directionNormal ) { command = NceBinaryCommand . LOCO_CMD_REV_CONSIST_MID ; } addLocoToConsist ( locoAddress . getNumber ( ) , locoAddress . isLongAddress ( ) , command ) ; ConsistPosition . put ( locoAddress , ConsistPosition . size ( ) ) ; } ConsistList . add ( locoAddress ) ; ConsistDir . put ( locoAddress , Boolean . valueOf ( directionNormal ) ) ; } else { log . error ( STR_ + locoAddress + STR_ + getConsistAddress ( ) ) ; } }
private GridClientConfiguration clientConfiguration ( ) { GridClientConfiguration cfg = new GridClientConfiguration ( ) ; cfg . setTopologyRefreshFrequency ( topologyRefreshFrequency ( ) ) ; cfg . setMaxConnectionIdleTime ( maxConnectionIdleTime ( ) ) ; cfg . setProtocol ( protocol ( ) ) ; cfg . setServers ( Arrays . asList ( serverAddress ( ) ) ) ; cfg . setBalancer ( new GridClientRoundRobinBalancer ( ) ) ; if ( useSsl ( ) ) cfg . setSslContextFactory ( sslContextFactory ( ) ) ; GridClientDataConfiguration loc = new GridClientDataConfiguration ( ) ; GridClientDataConfiguration partitioned = new GridClientDataConfiguration ( ) ; partitioned . setName ( PARTITIONED_CACHE_NAME ) ; partitioned . setAffinity ( new GridClientPartitionAffinity ( ) ) ; GridClientDataConfiguration partitionedAsyncBackup = new GridClientDataConfiguration ( ) ; partitionedAsyncBackup . setName ( PARTITIONED_ASYNC_BACKUP_CACHE_NAME ) ; partitionedAsyncBackup . setAffinity ( new GridClientPartitionAffinity ( ) ) ; GridClientDataConfiguration replicated = new GridClientDataConfiguration ( ) ; replicated . setName ( REPLICATED_CACHE_NAME ) ; GridClientDataConfiguration replicatedAsync = new GridClientDataConfiguration ( ) ; replicatedAsync . setName ( REPLICATED_ASYNC_CACHE_NAME ) ; cfg . setDataConfigurations ( Arrays . asList ( loc , partitioned , replicated , replicatedAsync , partitionedAsyncBackup ) ) ; return cfg ; }
public final TestSubscriber assertNotSubscribed ( ) { String prefix = STR_ ; if ( done . getCount ( ) != NUM_ ) { prefix = STR_ ; } if ( subscription . get ( ) != null ) { fail ( prefix , STR_ , errors ) ; } else if ( ! errors . isEmpty ( ) ) { fail ( prefix , STR_ , errors ) ; } return this ; }
public Builder ( ) { setVersionCode ( Math . min ( FreshAir . getCurrentApplicationVersion ( ) , NUM_ ) ) ; setFeatures ( new LinkedList < FeatureInfo > ( ) ) ; }
protected String convertDateFormat ( String pattern ) { boolean inside = BOOL_ ; boolean mark = BOOL_ ; boolean modifiedCommand = BOOL_ ; StringBuilder buf = new StringBuilder ( ) ; for ( int i = NUM_ ; i < pattern . length ( ) ; i ++ ) { char c = pattern . charAt ( i ) ; if ( c == STR_ && ! mark ) { mark = BOOL_ ; } else { if ( mark ) { if ( modifiedCommand ) { modifiedCommand = BOOL_ ; mark = BOOL_ ; } else { inside = translateCommand ( buf , pattern , i , inside ) ; if ( c == STR_ || c == STR_ ) { modifiedCommand = BOOL_ ; } else { mark = BOOL_ ; } } } else { if ( ! inside && c != STR_ ) { buf . append ( STR_ ) ; inside = BOOL_ ; } buf . append ( c ) ; } } } if ( buf . length ( ) > NUM_ ) { char lastChar = buf . charAt ( buf . length ( ) - NUM_ ) ; if ( lastChar != STR_ && inside ) { buf . append ( STR_ ) ; } } return buf . toString ( ) ; }
public void addChildNode ( EvalFactoryNode childNode ) { childNodes . add ( childNode ) ; }
public final void headTo ( Tuple3d p ) { double angle = Geometric . angle ( this . location , p ) ; turnTo ( Math . toDegrees ( angle ) ) ; }
public void compactBuffer ( ) { if ( offset != buffer . length ) { byte [ ] newBuffer = new byte [ offset ] ; System . arraycopy ( buffer , NUM_ , newBuffer , NUM_ , offset ) ; buffer = newBuffer ; } }
public static byte [ ] decode ( String s ) { return decode ( s . toCharArray ( ) ) ; }
public static int putByteBuffer ( byte [ ] bytes , int offset , ByteBuffer buf ) { int len = buf . remaining ( ) ; buf . get ( bytes , offset , len ) ; return offset + len ; }
private void clearIndexToFirst ( ) { for ( ; ; ) { Index < K , V > q = head ; for ( ; ; ) { Index < K , V > r = q . right ; if ( r != null && r . indexesDeletedNode ( ) && ! q . unlink ( r ) ) break ; if ( ( q = q . down ) == null ) { if ( head . right == null ) tryReduceLevel ( ) ; return ; } } } }
final void tryTerminate ( ) { for ( ; ; ) { int c = ctl . get ( ) ; if ( isRunning ( c ) || runStateAtLeast ( c , TIDYING ) || ( runStateOf ( c ) == SHUTDOWN && ! workQueue . isEmpty ( ) ) ) return ; if ( workerCountOf ( c ) != NUM_ ) { interruptIdleWorkers ( ONLY_ONE ) ; return ; } final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { if ( ctl . compareAndSet ( c , ctlOf ( TIDYING , NUM_ ) ) ) { try { terminated ( ) ; } finally { ctl . set ( ctlOf ( TERMINATED , NUM_ ) ) ; termination . signalAll ( ) ; } return ; } } finally { mainLock . unlock ( ) ; } } }
public void joinResource ( ) throws InterruptedException { if ( runObj != null ) { synchronized ( complete ) { if ( runObj != null ) complete . wait ( ) ; } } }
public static String toJSONString ( List list ) { if ( list == null ) return STR_ ; boolean first = BOOL_ ; StringBuffer sb = new StringBuffer ( ) ; Iterator iter = list . iterator ( ) ; sb . append ( STR_ ) ; while ( iter . hasNext ( ) ) { if ( first ) first = BOOL_ ; else sb . append ( STR_ ) ; Object value = iter . next ( ) ; if ( value == null ) { sb . append ( STR_ ) ; continue ; } sb . append ( JSONValue . toJSONString ( value ) ) ; } sb . append ( STR_ ) ; return sb . toString ( ) ; }
@ Override public int hashCode ( ) { final int prime = NUM_ ; int result = super . hashCode ( ) ; result = prime . result + ( tenant == null ? NUM_ : tenant . hashCode ( ) ) ; return result ; }
public void loadAccessors ( MappedField configuredField , MappedField targetField ) { loadAccessors ( targetClass , configuredField , targetField ) ; }
public static MatrixBlock reshape ( MatrixBlock in , MatrixBlock out , int rows , int cols , boolean rowwise ) throws DMLRuntimeException { int rlen = in . rlen ; int clen = in . clen ; if ( ( ( long ) rlen ) . clen != ( ( long ) rows ) . cols ) throw new DMLRuntimeException ( STR_ + rlen + STR_ + clen + STR_ + rows + STR_ + cols + STR_ ) ; if ( rlen == rows && clen == cols ) { out . copy ( in ) ; return out ; } out . sparse = MatrixBlock . evalSparseFormatInMemory ( rows , cols , in . nonZeros ) ; out . rlen = rows ; out . clen = cols ; out . nonZeros = in . nonZeros ; if ( ! in . sparse && ! out . sparse ) reshapeDense ( in , out , rows , cols , rowwise ) ; else if ( in . sparse && out . sparse ) reshapeSparse ( in , out , rows , cols , rowwise ) ; else if ( in . sparse ) reshapeSparseToDense ( in , out , rows , cols , rowwise ) ; else reshapeDenseToSparse ( in , out , rows , cols , rowwise ) ; return out ; }
public static Class < ? > [ ] toClassesFromObjects ( final Object [ ] params ) { final Class < ? > [ ] classes = new Class < ? > [ params . length ] ; int i = NUM_ ; for ( final Object object : params ) { if ( object != null ) { classes [ i ++ ] = object . getClass ( ) ; } else { classes [ i ++ ] = Object . class ; } } return classes ; }
public AdminRegion ( String localName , RemoteGemFireVM vm , String userAttributeDesc ) { String gn = localName ; int idx = localName . lastIndexOf ( nameSep ) ; if ( idx != - NUM_ ) { localName = localName . substring ( idx + NUM_ ) ; } else { gn = nameSep + gn ; } this . globalName = gn ; this . localName = localName ; this . userAttributeDesc = userAttributeDesc ; this . vm = vm ; }
public Element signWithWSSX509TokenProfile ( Document doc , java . security . cert . Certificate cert , String algorithm , List ids ) throws XMLSignatureException { return signWithWSSX509TokenProfile ( doc , cert , algorithm , ids , SOAPBindingConstants . WSF_10_VERSION ) ; }
public void addUserMessageListener ( UserMessageListener userMessageListener ) { userMessageListeners . add ( userMessageListener ) ; }
public IteratorBuilder addTemplate ( ISpaceQuery query ) { templates . add ( query ) ; return this ; }
public String addToClassPath ( final String path ) { this . classPath += ( System . getProperty ( STR_ ) + path ) ; return this . classPath ; }
private static int NewLongArray ( JNIEnvironment env , int length ) { if ( traceJNI ) VM . sysWrite ( STR_ ) ; RuntimeEntrypoints . checkJNICountDownToGC ( ) ; try { long [ ] newArray = new long [ length ] ; return env . pushJNIRef ( newArray ) ; } catch ( Throwable unexpected ) { if ( traceJNI ) unexpected . printStackTrace ( System . err ) ; env . recordException ( unexpected ) ; return NUM_ ; } }
protected abstract void finalizeOutput ( final int [ ] sourceImagePixels , final int imageWidth , final int imageHeight ) ;
public static boolean ignoringBatteryOptimizations ( ) { return NgnApplication . ignoringBatteryOptimizations ( null ) ; }
private boolean retryDelayHasPassedBy ( Long lastFailTime ) { return lastFailTime == null || lastFailTime + this . retryAfterMs < System . currentTimeMillis ( ) ; }
public static java . lang . String valueOf ( long l ) { return Long . toString ( l ) ; }
private boolean useMetric ( MetricRule rule , Metric metric ) { if ( rule . awsDimensionSelect == null && rule . awsDimensionSelectRegex == null ) { return BOOL_ ; } if ( rule . awsDimensionSelect != null && metricsIsInAwsDimensionSelect ( rule , metric ) ) { return BOOL_ ; } if ( rule . awsDimensionSelectRegex != null && metricIsInAwsDimensionSelectRegex ( rule , metric ) ) { return BOOL_ ; } return BOOL_ ; }
final void addIconManager ( AbstractStatusIconManager manager ) { iconManagers . add ( manager ) ; }
public IndexMetaData upgradeIndexMetaData ( IndexMetaData indexMetaData ) { if ( isUpgraded ( indexMetaData ) ) { return indexMetaData ; } checkSupportedVersion ( indexMetaData ) ; IndexMetaData newMetaData = upgradeLegacyRoutingSettings ( indexMetaData ) ; newMetaData = addDefaultUnitsIfNeeded ( newMetaData ) ; checkMappingsCompatibility ( newMetaData ) ; newMetaData = upgradeSettings ( newMetaData ) ; newMetaData = markAsUpgraded ( newMetaData ) ; return newMetaData ; }
static final void encode ( byte [ ] src , int srcOff , int len , byte [ ] dst , int dstOff ) { dst [ dstOff ] = ( byte ) ENCODE_TABLE . charAt ( ( src [ srcOff ] > > NUM_ ) & x3F ) ; if ( len == NUM_ ) { dst [ dstOff + NUM_ ] = ( byte ) ENCODE_TABLE . charAt ( ( ( src [ srcOff ] << NUM_ ) & x30 ) | ( ( src [ srcOff + NUM_ ] > > NUM_ ) & x0F ) ) ; dst [ dstOff + NUM_ ] = ( byte ) ENCODE_TABLE . charAt ( ( ( src [ srcOff + NUM_ ] << NUM_ ) & x3C ) | ( ( src [ srcOff + NUM_ ] > > NUM_ ) & x03 ) ) ; dst [ dstOff + NUM_ ] = ( byte ) ENCODE_TABLE . charAt ( src [ srcOff + NUM_ ] & x3F ) ; } else if ( len == NUM_ ) { dst [ dstOff + NUM_ ] = ( byte ) ENCODE_TABLE . charAt ( ( ( src [ srcOff ] << NUM_ ) & x30 ) | ( ( src [ srcOff + NUM_ ] > > NUM_ ) & x0F ) ) ; dst [ dstOff + NUM_ ] = ( byte ) ENCODE_TABLE . charAt ( ( src [ srcOff + NUM_ ] << NUM_ ) & x3C ) ; } else { dst [ dstOff + NUM_ ] = ( byte ) ENCODE_TABLE . charAt ( ( src [ srcOff ] << NUM_ ) & x30 ) ; } }
@ SuppressWarnings ( STR_ ) public final void storeData ( final List data ) throws IDBPersistenceException { SqlSession session = null ; int size = data . size ( ) ; int commited = NUM_ ; T dtShortTermLog ; try { session = sqlSessionFactory . openSession ( ExecutorType . BATCH , BOOL_ ) ; if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( STR_ + session . toString ( ) + STR_ ) ; } LoggerMapper < T > persistenceMapper = session . getMapper ( mapperInterface ) ; for ( int i = NUM_ ; i != size ; i ++ ) { if ( ( NUM_ == i % RECORDS_PER_BATCH ) && i > NUM_ ) { if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( STR_ + i ) ; } session . commit ( ) ; commited = i ; } if ( data . get ( i ) != null ) { dtShortTermLog = ( T ) data . get ( i ) ; if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( STR_ + dtShortTermLog . getId ( ) ) ; } persistenceMapper . insertLog ( dtShortTermLog ) ; } } session . commit ( ) ; commited = size ; } catch ( PersistenceException e ) { LOGGER . error ( STR_ + data . size ( ) + STR_ , e ) ; try { if ( session != null ) { session . rollback ( ) ; } } catch ( Exception sql ) { LOGGER . error ( STR_ , sql ) ; } throw new IDBPersistenceException ( e . getMessage ( ) , commited ) ; } finally { try { if ( session != null ) { session . close ( ) ; } } catch ( Exception e ) { LOGGER . error ( STR_ , e ) ; } } }
@ SuppressWarnings ( STR_ ) public static Map < String , ConfigurationKey < ? > > registeredKeys ( ) { synchronized ( registeredKeys ) { if ( copy == null ) copy = Collections . unmodifiableMap ( ( Map < String , ConfigurationKey < ? > > ) registeredKeys . clone ( ) ) ; return copy ; } }
public static String md5 ( String stringToHash ) { if ( stringToHash != null ) { try { MessageDigest md = MessageDigest . getInstance ( STR_ ) ; byte [ ] bytes = md . digest ( stringToHash . getBytes ( ) ) ; StringBuilder sb = new StringBuilder ( NUM_ . bytes . length ) ; for ( int i = NUM_ ; i < bytes . length ; i ++ ) { int low = ( bytes [ i ] & x0f ) ; int high = ( ( bytes [ i ] & xf0 ) > > NUM_ ) ; sb . append ( Constants . HEXADECIMAL [ high ] ) ; sb . append ( Constants . HEXADECIMAL [ low ] ) ; } return sb . toString ( ) ; } catch ( NoSuchAlgorithmException e ) { return STR_ ; } } else { return STR_ ; } }
public String mostOfString ( ) { String typeName = STR_ ; switch ( type ) { case BUILTIN : typeName = STR_ ; break ; case NUMBER : typeName = STR_ ; break ; case STRING : typeName = STR_ ; break ; case PF_STEP : typeName = STR_ ; break ; case IDENT : typeName = STR_ ; break ; case COMMENT : typeName = STR_ ; break ; case DASHES : typeName = STR_ ; break ; case END_MODULE : typeName = STR_ ; break ; case PROLOG : typeName = STR_ ; break ; case EPILOG : typeName = STR_ ; break ; case PCAL_LABEL : typeName = STR_ ; break ; } ; String str = STR_ + string + STR_ ; if ( string == null ) { str = STR_ ; } ; String result = STR_ + str + STR_ + typeName + STR_ + column + STR_ + getWidth ( ) ; if ( aboveAlign . line != - NUM_ ) { result = result + STR_ + aboveAlign . toString ( ) ; } ; if ( belowAlign . line != - NUM_ ) { result = result + STR_ + belowAlign . toString ( ) ; } ; if ( preSpace != NUM_ ) { result = result + STR_ + preSpace ; } ; if ( isAlignmentPoint ) { result = result + STR_ ; } ; if ( distFromMargin != NUM_ ) { result = result + STR_ + distFromMargin ; } ; if ( subscript ) { result = result + STR_ ; } ; return result ; }
public CreateIndexRequest mapping ( String type , XContentBuilder source ) { if ( mappings . containsKey ( type ) ) { throw new IllegalStateException ( STR_ + type + STR_ ) ; } try { mappings . put ( type , source . string ( ) ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( STR_ , e ) ; } return this ; }
public static PrettyPrint indentWithSpaces ( int number ) { if ( number < NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } char [ ] chars = new char [ number ] ; Arrays . fill ( chars , STR_ ) ; return new PrettyPrint ( chars ) ; }
private static void copyFile ( File src , File dst , Integer port , boolean internalCompression ) throws IOException { BufferedReader in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( src ) , StandardCharsets . UTF_8 ) ) ; Writer out = new OutputStreamWriter ( new FileOutputStream ( dst ) , StandardCharsets . UTF_8 ) ; for ( String line = in . readLine ( ) ; null != line ; line = in . readLine ( ) ) { if ( null != port ) line = line . replace ( STR_ , port . toString ( ) ) ; line = line . replace ( STR_ , internalCompression ? STR_ : STR_ ) ; out . write ( line ) ; } in . close ( ) ; out . close ( ) ; }
public void assertEventLogContains ( Object event ) { if ( ! mEventLog . contains ( event ) ) { fail ( STR_ + mEventLog ) ; } }
private static boolean isAllUnderscores ( ) { int i = NUM_ ; boolean result = BOOL_ ; while ( result && ( i < token . length ( ) ) ) { if ( token . charAt ( i ) != STR_ ) { result = BOOL_ ; } ; i = i + NUM_ ; } ; return result ; }
public ImageWarp ( BufferedImage bi , GeoCoordTransformation transform , DataBounds imageBounds ) { if ( bi != null ) { iwidth = bi . getWidth ( ) ; iheight = bi . getHeight ( ) ; setGeoTrans ( transform ) ; setImageBounds ( imageBounds ) ; pixels = getPixels ( bi , NUM_ , NUM_ , iwidth , iheight ) ; bi = null ; } }
public static EquipmentLoggerFactory createFactory ( final EquipmentConfiguration econf , final ProcessConfiguration pconf , boolean useEquipmentLoggers , boolean useEquipmentAppendersOnly ) { return new EquipmentLoggerFactory ( econf . getHandlerClassName ( ) , Long . valueOf ( econf . getId ( ) ) , econf . getName ( ) , pconf . getProcessName ( ) , useEquipmentLoggers , useEquipmentAppendersOnly ) ; }
protected void assertEquals ( Integer expected , Integer actual ) { if ( expected == null || actual == null ) { if ( expected != actual ) { assertEquals ( STR_ + expected , STR_ + actual ) ; } } else { assertEquals ( expected . intValue ( ) , actual . intValue ( ) ) ; } }
public static boolean vPoolSpecifiesSnapshots ( final VirtualPool virtualPool ) { if ( virtualPool . getMaxNativeSnapshots ( ) == null ) { return BOOL_ ; } return virtualPool . getMaxNativeSnapshots ( ) != MAX_DISABLED ; }
public void mapDatasetToAxis ( int index , int axisIndex ) { List axisIndices = new java . util . ArrayList ( NUM_ ) ; axisIndices . add ( new Integer ( axisIndex ) ) ; mapDatasetToAxes ( index , axisIndices ) ; }
public AuthenticatorAppRegistrationURIBuilder ( AMIdentity id , String secretHex , int codeLength , String issuer ) { Reject . ifNull ( id , STR_ ) ; Reject . ifNull ( secretHex , STR_ ) ; Reject . ifTrue ( StringUtils . isBlank ( issuer ) , STR_ ) ; Reject . ifTrue ( ( codeLength < MIN_CODE_LENGTH ) , STR_ + MIN_CODE_LENGTH + STR_ ) ; if ( secretHex . length ( ) == NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } this . issuer = issuer ; this . id = id ; this . secretHex = secretHex ; this . codeLength = codeLength ; }
protected void updateApplicationEnabled ( ) { firePropertyChange ( STR_ , Boolean . valueOf ( ! isEnabled ( ) ) , Boolean . valueOf ( isEnabled ( ) ) ) ; }
public PersonalityInsights ( final String versionDate , String username , String password ) { this ( versionDate ) ; setUsernameAndPassword ( username , password ) ; }
public String signMessage ( String message ) throws IllegalStateException { Validate . notNull ( getSignAlgorithm ( ) , STR_ ) ; Validate . notNull ( getPrivateKey ( ) , STR_ ) ; Validate . notEmpty ( message , STR_ ) ; log . debug ( STR_ + message + STR_ + getSignAlgorithm ( ) ) ; try { SignatureAlgorithm algo = SignatureAlgorithm . getSignatureAlgorithmForURI ( getSignAlgorithm ( ) ) ; Signature sig = Signature . getInstance ( algo . getAlgorithmName ( ) ) ; sig . initSign ( this . privateKey ) ; byte [ ] messageBytes = message . getBytes ( STR_ ) ; sig . update ( messageBytes ) ; byte [ ] sigBytes = sig . sign ( ) ; String signature = SharedUtils . encodeBytes ( sigBytes ) ; log . debug ( STR_ + signature ) ; return signature ; } catch ( Exception e ) { log . error ( STR_ , e ) ; throw new IllegalStateException ( e ) ; } }
private void outputPriceLists ( Properties ctx , PrintWriter out , boolean includeAny ) { out . println ( STR_ ) ; if ( includeAny ) out . println ( STR_ ) ; out . println ( STR_ ) ; out . println ( STR_ ) ; out . println ( STR_ ) ; }
public void clearBindings ( ) { if ( mBindArgs != null ) { Arrays . fill ( mBindArgs , null ) ; } }
public boolean assignIfBestMatch ( MethodDeclaration declaration ) { assert ! finalized : STR_ ; if ( ! isMatch ( declaration . getParameters ( ) ) ) { return BOOL_ ; } if ( this . bestMatchMethod . isPresent ( ) ) { if ( this . bestMatchMethod . get ( ) . getParameters ( ) . size ( ) > declaration . getParameters ( ) . size ( ) ) { return BOOL_ ; } } this . bestMatchMethod = Optional . of ( declaration ) ; return BOOL_ ; }
public static List < User > from ( Cursor c ) { List < User > users = null ; int count = c . getCount ( ) ; if ( count > NUM_ ) { users = new ArrayList < > ( count ) ; while ( c . moveToNext ( ) ) { User user = new User ( ) ; Syncing . from ( c , user ) ; int col = c . getColumnIndex ( EMAIL_HASH ) ; if ( col >= NUM_ ) { user . emailHash = c . getString ( col ) ; } col = c . getColumnIndex ( FOLLOWING ) ; if ( col >= NUM_ ) { user . isFollowing = c . getInt ( col ) == NUM_ ; } users . add ( user ) ; } } c . close ( ) ; return users ; }
@ Override public void flush ( ) throws IOException { out . flush ( ) ; }
private void startCheckingStatus ( ) { future = executor . submit ( null ) ; }
private static Object newInstanceNoServiceLoader ( Class < ? > providerClass ) { if ( System . getSecurityManager ( ) == null ) { return null ; } try { Method creationMethod = providerClass . getDeclaredMethod ( STR_ ) ; return creationMethod . invoke ( null , ( Object [ ] ) null ) ; } catch ( NoSuchMethodException exc ) { return null ; } catch ( Exception exc ) { return null ; } }
private void addSignatureProfile ( SignatureWrapper signature , XmlSignature xmlSignature ) { SignatureType signatureType = SignatureType . NA ; String certificateId = signature . getSigningCertificateId ( ) ; if ( certificateId != null ) { signatureType = getSignatureType ( certificateId ) ; } xmlSignature . setSignatureLevel ( signatureType . name ( ) ) ; }
public synchronized void removeImageListener ( ImageListener cl ) { m_imageListeners . remove ( cl ) ; }
public ArrayList < ConstraintWidget > buildList ( ScoutWidget [ ] list ) { ArrayList < ConstraintWidget > ret = new ArrayList < > ( ) ; for ( int i = mContainSet . nextSetBit ( NUM_ ) ; i >= NUM_ ; i = mContainSet . nextSetBit ( i + NUM_ ) ) { ret . add ( list [ i ] . mConstraintWidget ) ; } return ret ; }
private boolean nodeExists ( StringTokenizer path ) throws BackingStoreException { String token = path . nextToken ( ) ; if ( token . equals ( STR_ ) ) throw new IllegalArgumentException ( STR_ ) ; synchronized ( lock ) { AbstractPreferences child = kidCache . get ( token ) ; if ( child == null ) child = getChild ( token ) ; if ( child == null ) return BOOL_ ; if ( ! path . hasMoreTokens ( ) ) return BOOL_ ; path . nextToken ( ) ; if ( ! path . hasMoreTokens ( ) ) throw new IllegalArgumentException ( STR_ ) ; return child . nodeExists ( path ) ; } }
public int size ( ) { return delegate . size ( ) ; }
public NetworkAddressFactoryImpl ( ) throws InitializationException { this ( DEFAULT_TCP_HTTP_LISTEN_PORT ) ; }
public TransparentGlassPanePanel ( ImageIcon icon , String text , Color backgroundColor , float transparency ) { setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints gbc = new GridBagConstraints ( ) ; gbc . gridy = NUM_ ; gbc . gridx = NUM_ ; JLabel iconLabel = new JLabel ( icon ) ; add ( iconLabel , gbc ) ; gbc . gridy += NUM_ ; label = new JLabel ( text ) ; add ( label , gbc ) ; if ( transparency > NUM_ ) { transparency = NUM_ ; } else if ( transparency < NUM_ ) { transparency = NUM_ ; } Color transparentColor = new Color ( backgroundColor . getRed ( ) , backgroundColor . getGreen ( ) , backgroundColor . getBlue ( ) , ( int ) ( transparency . NUM_ ) ) ; setBackground ( transparentColor ) ; setOpaque ( BOOL_ ) ; }
@ Override protected void fillHeader ( Header head ) { try { Standard . context ( UndefinedData . class ) ; head . setXtension ( STR_ ) ; head . setBitpix ( BasicHDU . BITPIX_BYTE ) ; head . setNaxes ( NUM_ ) ; head . addValue ( NAXISn . n ( NUM_ ) , this . data . length ) ; head . addValue ( PCOUNT , NUM_ ) ; head . addValue ( GCOUNT , NUM_ ) ; head . addValue ( EXTEND , BOOL_ ) ; } catch ( HeaderCardException e ) { LOG . log ( Level . SEVERE , STR_ , e ) ; } finally { Standard . context ( null ) ; } }
protected void cleanStationsAndNetwork ( ) { log . info ( STR_ ) ; cleanSchedule ( ) ; removeNonUsedStopFacilities ( ) ; cleanModes ( ) ; removeNonUsedLinks ( ) ; log . info ( STR_ ) ; }
private static String stripAppleSpanFromMarkup ( String markup ) { StringBuilder stripped = new StringBuilder ( markup ) ; int prefixBegIdx = stripped . indexOf ( APPLE_SPAN_PREFIX ) ; while ( prefixBegIdx >= NUM_ ) { int prefixEndIdx = stripped . indexOf ( STR_ , prefixBegIdx ) + NUM_ ; stripped . replace ( prefixBegIdx , prefixEndIdx , STR_ ) ; int suffixBegIdx = stripped . lastIndexOf ( APPLE_SPAN_SUFFIX ) ; int suffixEndIdx = suffixBegIdx + APPLE_SPAN_SUFFIX . length ( ) ; stripped . replace ( suffixBegIdx , suffixEndIdx , STR_ ) ; prefixBegIdx = stripped . indexOf ( APPLE_SPAN_PREFIX ) ; } return stripped . toString ( ) ; }
private InvocationConstraints createInvocationConstraints ( ) { if ( MIN_RETRY >= sleepTime [ tryIndx ] ) { return new InvocationConstraints ( new ConnectionAbsoluteTime ( System . currentTimeMillis ( ) + sleepTime [ tryIndx ] ) , null ) ; } else { return InvocationConstraints . EMPTY ; } }
public void create ( SSOToken token , String dn , Map attrs ) throws SMSException , SSOException { create ( token . getPrincipal ( ) , dn , attrs ) ; objectChanged ( dn , ADD ) ; }
@ Override public void close ( ) throws IOException { if ( ! closed ) { try { if ( ! eof ) { exhaustInputStream ( this ) ; } } finally { eof = BOOL_ ; closed = BOOL_ ; } } }
private void discardDownstreamMediaChunk ( ) { MediaChunk removed = mediaChunks . removeFirst ( ) ; long totalBytes = removed . bytesLoaded ( ) ; removed . release ( ) ; notifyDownstreamDiscarded ( removed . startTimeUs , removed . endTimeUs , totalBytes ) ; }
public Object executeScript ( final Script script , final ScriptContext context ) { final ScriptEngine engine = scriptEngineProvider . getScriptEngine ( script . getType ( ) ) ; return executeScript ( script , engine , context ) ; }
public static PlaceholderFragment newInstance ( ) { PlaceholderFragment fragment = new PlaceholderFragment ( ) ; Bundle args = new Bundle ( ) ; fragment . setArguments ( args ) ; return fragment ; }
void removeEQ ( Object o ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { Object [ ] array = queue ; for ( int i = NUM_ , n = size ; i < n ; i ++ ) { if ( o == array [ i ] ) { removeAt ( i ) ; break ; } } } finally { lock . unlock ( ) ; } }
public T eval ( ) { return eval ( bindings ( ) ) ; }
public void add ( XMPPathSegment segment ) { segments . add ( segment ) ; }
private void nextSync ( ) { if ( syncItemIterator . hasNext ( ) ) { partialStartTime = System . currentTimeMillis ( ) ; currentSyncItem = syncItemIterator . next ( ) ; currentSyncItem . sync ( this , hostConnection , callbackHandler , contentResolver ) ; } else { LogUtils . LOGD ( TAG , STR_ + ( System . currentTimeMillis ( ) - startTime ) ) ; if ( listener != null ) { listener . onSyncFinished ( this ) ; } syncService . stopSelf ( serviceStartId ) ; } }
public String decode ( String encoded ) { JsonObject object = new JsonObject ( encoded ) ; JsonArray headers = object . getJsonArray ( STR_ ) ; for ( Object headerObj : headers ) { JsonArray header = ( JsonArray ) headerObj ; String key = header . getString ( NUM_ ) ; String value = header . getString ( NUM_ ) ; if ( key . equalsIgnoreCase ( CONTENT_TYPE ) && ( value . contains ( STR_ ) || value . contains ( APPLICATION_JSON ) ) ) { try { object . put ( STR_ , new JsonObject ( new String ( object . getBinary ( PAYLOAD ) , Charset . forName ( UTF_8 ) ) ) ) ; } catch ( DecodeException e ) { object . put ( STR_ , new String ( object . getBinary ( PAYLOAD ) , Charset . forName ( UTF_8 ) ) ) ; } object . remove ( PAYLOAD ) ; break ; } } return object . toString ( ) ; }
public boolean matchesWord ( ) { return ! isEmpty ( ) && Character . isLetterOrDigit ( queue . charAt ( pos ) ) ; }
public void test_doAs_01 ( ) { Subject subj = new Subject ( ) ; PrivilegedAction < Object > pa = new myPrivilegedAction ( ) ; PrivilegedAction < Object > paNull = null ; try { Object obj = Subject . doAs ( null , pa ) ; } catch ( Exception e ) { fail ( STR_ + e ) ; } try { Object obj = Subject . doAs ( subj , pa ) ; } catch ( Exception e ) { fail ( STR_ + e ) ; } try { Object obj = Subject . doAs ( subj , paNull ) ; fail ( STR_ ) ; } catch ( NullPointerException npe ) { } }
public void testDivideExpLessZero ( ) { String a = STR_ ; int aScale = NUM_ ; String b = STR_ ; int bScale = NUM_ ; String c = STR_ ; int resScale = - NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal bNumber = new BigDecimal ( new BigInteger ( b ) , bScale ) ; BigDecimal result = aNumber . divide ( bNumber , resScale , BigDecimal . ROUND_CEILING ) ; assertEquals ( STR_ , c , result . toString ( ) ) ; assertEquals ( STR_ , resScale , result . scale ( ) ) ; }
public static boolean containsWhitespace ( final CharSequence seq ) { if ( isEmpty ( seq ) ) { return BOOL_ ; } final int strLen = seq . length ( ) ; for ( int i = NUM_ ; i < strLen ; i ++ ) { if ( Character . isWhitespace ( seq . charAt ( i ) ) ) { return BOOL_ ; } } return BOOL_ ; }
public boolean isWheelEvent ( ) { return isWheelEvent ; }
public Connection ( String clientHandle , String clientId , String host , int port , Context context , MqttAndroidClient client , boolean sslConnection ) { this . clientHandle = clientHandle ; this . clientId = clientId ; this . host = host ; this . port = port ; this . context = context ; this . client = client ; this . sslConnection = sslConnection ; history = new ArrayList < String > ( ) ; StringBuffer sb = new StringBuffer ( ) ; sb . append ( STR_ ) ; sb . append ( clientId ) ; sb . append ( STR_ ) ; addAction ( sb . toString ( ) ) ; }
public void recordState ( DialogueState state , String name ) { if ( frame != null ) { stateMonitorTab . recordState ( state , name ) ; } }
public void characters ( org . w3c . dom . Node node ) throws org . xml . sax . SAXException { flushPending ( ) ; String data = node . getNodeValue ( ) ; if ( data != null ) { final int length = data . length ( ) ; if ( length > m_charsBuff . length ) { m_charsBuff = new char [ length . NUM_ + NUM_ ] ; } data . getChars ( NUM_ , length , m_charsBuff , NUM_ ) ; characters ( m_charsBuff , NUM_ , length ) ; } }
private void computeFiltersFromDefault ( IndicatorViewState oldState ) { filters = new ArrayList < Filter > ( ) ; Set < String > defaultFilterNames = new HashSet < String > ( ) ; for ( Filter defaultFilter : defaultFilters ) { filters . add ( defaultFilter ) ; if ( defaultFilter . name != null ) defaultFilterNames . add ( defaultFilter . name ) ; } if ( oldState != null ) { for ( Filter oldFilter : oldState . filters ) { if ( oldFilter . name == null || ! defaultFilterNames . contains ( oldFilter . name ) ) filters . add ( oldFilter ) ; } } }
private static Data parseName ( Set me , Set peer ) { if ( me == null ) { throw new NullPointerException ( STR_ ) ; } else if ( me . isEmpty ( ) ) { throw new IllegalArgumentException ( STR_ ) ; } Data data = new Data ( ) ; StringBuffer b = new StringBuffer ( ) ; data . me = cons ( me , b ) ; if ( peer != null && ! peer . isEmpty ( ) ) { b . append ( STR_ ) ; data . peer = cons ( peer , b ) ; } data . name = b . toString ( ) ; return data ; }
public static boolean streamContentEquals ( InputStream s1 , InputStream s2 ) throws IOException { try { int b1 , b2 ; do { b1 = s1 . read ( ) ; b2 = s2 . read ( ) ; } while ( ( b1 == b2 ) && ( b1 != - NUM_ ) ) ; return b1 == b2 ; } finally { try { s1 . close ( ) ; s2 . close ( ) ; } catch ( Exception e ) { } } }
public ContentNode parse ( JSDocCharScanner scanner , TagDictionary < AbstractInlineTagDefinition > inlineTagsDictinary ) { ComposedContent description = DomFactory . eINSTANCE . createComposedContent ( ) ; if ( ! scanner . hasNext ( ) ) { return null ; } if ( nextIsTagTitle ( scanner ) ) { return null ; } int start = scanner . nextOffset ( ) ; int end = start ; StringBuilder strb = new StringBuilder ( ) ; while ( scanner . hasNext ( ) ) { char c = scanner . peek ( ) ; if ( regionStart ( c ) ) { ScannerState st = scanner . saveState ( ) ; InlineTag tag = ( InlineTag ) parseRegion ( scanner , inlineTagsDictinary ) ; if ( tag != null ) { saveTextTokens ( description , start , end , strb ) ; strb = new StringBuilder ( ) ; start = end ; description . getContents ( ) . add ( tag ) ; continue ; } else { scanner . restoreState ( st ) ; if ( start == end ) { assert BOOL_ ; } } } scanner . next ( ) ; if ( JSDocCharScanner . isNL ( c ) ) { if ( scanner . hasNext ( ) && ! nextIsTagTitle ( scanner ) ) { end = scanner . offset ( ) ; } else { break ; } } strb . append ( c ) ; end = scanner . offset ( ) ; } String pendingData = strb . toString ( ) ; if ( pendingData . isEmpty ( ) == BOOL_ ) { saveTextTokens ( description , start , end , strb ) ; } switch ( description . getContents ( ) . size ( ) ) { case NUM_ : return null ; case NUM_ : return description . getContents ( ) . get ( NUM_ ) ; default : return description ; } }
static public void add ( Errors errors , String text ) { if ( errors == null ) { return ; } errors . add ( text ) ; }
public synchronized void removeIconsForPkg ( String packageName , UserHandleCompat user ) { removeFromMemCacheLocked ( packageName , user ) ; long userSerial = mUserManager . getSerialNumberForUser ( user ) ; mIconDb . delete ( IconDB . COLUMN_COMPONENT + STR_ + IconDB . COLUMN_USER + STR_ , new String [ ] { packageName + STR_ , Long . toString ( userSerial ) } ) ; }
public boolean contains ( String sCategory ) { return CategoryEstimations . containsKey ( sCategory ) ; }
private void createRecursivly ( String path ) throws KeeperException , InterruptedException { try { if ( zk . exists ( path , BOOL_ ) == null && path . length ( ) > NUM_ ) { String temp = path . substring ( NUM_ , path . lastIndexOf ( File . separator ) ) ; createRecursivly ( temp ) ; zk . create ( path , null , Ids . OPEN_ACL_UNSAFE , CreateMode . PERSISTENT ) ; } else { return ; } } catch ( KeeperException e ) { throw e ; } catch ( InterruptedException e ) { throw e ; } }
public static final void frontEndStatistics ( SpecObj spec ) { }
public String toString ( ) { if ( notBefore == null || notAfter == null ) return STR_ ; return ( STR_ + notBefore . toString ( ) + STR_ + notAfter . toString ( ) + STR_ ) ; }
public void zoom ( double x , double y , double factor ) { double rangeX = Math . abs ( currentExtent . getMaxX ( ) - currentExtent . getMinX ( ) ) ; double rangeY = Math . abs ( currentExtent . getMaxY ( ) - currentExtent . getMinY ( ) ) ; currentExtent . setMinX ( x - ( rangeX . factor ) / NUM_ ) ; currentExtent . setMinY ( y - ( rangeY . factor ) / NUM_ ) ; currentExtent . setMaxX ( x + ( rangeX . factor ) / NUM_ ) ; currentExtent . setMaxY ( y + ( rangeY . factor ) / NUM_ ) ; addToExtentHistory ( currentExtent ) ; }
protected boolean isOutputLineExpected ( final String line , final String [ ] expectedPrefixes , final boolean filePathsAreExpected ) { final String trimmed = line != null ? line . trim ( ) : null ; if ( StringUtils . isNotEmpty ( trimmed ) ) { if ( filePathsAreExpected && isFilePath ( line ) ) { return BOOL_ ; } if ( expectedPrefixes != null ) { for ( final String prefix : expectedPrefixes ) { if ( StringUtils . startsWithIgnoreCase ( line , prefix ) ) { return BOOL_ ; } } } return BOOL_ ; } return BOOL_ ; }
public static String meterToString ( OFInstructionMeter inst , Logger log ) { return STR_SUB_GOTO_METER_METER_ID + STR_ + Long . toString ( inst . getMeterId ( ) ) ; }
public boolean isImageCachable ( int w , int h ) { return ( w . h ) < maxSingleImagePixelSize ; }
public static BigInteger sizeOfDirectoryAsBigInteger ( File directory ) { checkDirectory ( directory ) ; final File [ ] files = directory . listFiles ( ) ; if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { try { if ( ! isSymlink ( file ) ) { size = size . add ( BigInteger . valueOf ( sizeOf ( file ) ) ) ; } } catch ( IOException ioe ) { } } return size ; }
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; }
public void freeEntry ( BasicPoolEntry entry ) { if ( numEntries < NUM_ ) { throw new IllegalStateException ( STR_ + route ) ; } if ( numEntries <= freeEntries . size ( ) ) { throw new IllegalStateException ( STR_ + route ) ; } freeEntries . add ( entry ) ; }
public boolean isIn ( Coords coords ) { return coordinates . contains ( coords ) ; }
private DialogBaseUnits computeDialogBaseUnits ( FontMetrics metrics ) { double averageCharWidth = computeAverageCharWidth ( metrics , averageCharWidthTestString ) ; int ascent = metrics . getAscent ( ) ; double height = ascent > NUM_ ? ascent : ascent + ( NUM_ - ascent ) / NUM_ ; DialogBaseUnits dialogBaseUnits = new DialogBaseUnits ( averageCharWidth , height ) ; if ( LOGGER . isLoggable ( Level . CONFIG ) ) { LOGGER . config ( STR_ + dialogBaseUnits + STR_ + metrics . getFont ( ) ) ; } return dialogBaseUnits ; }
public synchronized void close ( ) { try { writer . close ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } }
public static boolean isProxyUri ( final String url ) { notNull ( url ) ; return url . contains ( getRequestHandlerPath ( ) ) ; }
public void addAction ( Action act ) { if ( act . entry != null && act . entry != this ) { Log . e ( TAG , STR_ + act . entry . ID + STR_ + ID ) ; return ; } if ( mActions == null ) { mActions = new ArrayList < Action > ( ) ; } if ( mActions . size ( ) == NUM_ ) { Log . w ( TAG , STR_ ) ; return ; } act . entry = this ; mActions . add ( act ) ; }
public abstract Iterable < ? extends CompilationUnitTree > parse ( ) throws IOException ;
private void name ( StringBuilder builder ) { String name = type . getName ( ) ; if ( name != null ) { builder . append ( STR_ ) ; builder . append ( name ) ; builder . append ( STR_ ) ; } }
public void handleTblHandlersButtonAddRequest ( RequestInvocationEvent event ) throws ModelControlException { try { Map values = getValues ( ) ; onBeforeSaveProfile ( values ) ; setPageSessionAttribute ( PROPERTY_ATTRIBUTE , ( HashMap ) values ) ; WSAuthNServicesHandlersAddViewBean vb = ( WSAuthNServicesHandlersAddViewBean ) getViewBean ( WSAuthNServicesHandlersAddViewBean . class ) ; unlockPageTrail ( ) ; passPgSessionMap ( vb ) ; vb . forwardTo ( getRequestContext ( ) ) ; } catch ( AMConsoleException e ) { setInlineAlertMessage ( CCAlert . TYPE_ERROR , STR_ , e . getMessage ( ) ) ; } }
public void reduceDL ( double expFPRate , boolean checkErr ) { boolean needUpdate = BOOL_ ; double [ ] rulesetStat = new double [ NUM_ ] ; for ( int j = NUM_ ; j < m_SimpleStats . size ( ) ; j ++ ) { rulesetStat [ NUM_ ] += m_SimpleStats . get ( j ) [ NUM_ ] ; rulesetStat [ NUM_ ] += m_SimpleStats . get ( j ) [ NUM_ ] ; rulesetStat [ NUM_ ] += m_SimpleStats . get ( j ) [ NUM_ ] ; if ( j == m_SimpleStats . size ( ) - NUM_ ) { rulesetStat [ NUM_ ] = m_SimpleStats . get ( j ) [ NUM_ ] ; rulesetStat [ NUM_ ] = m_SimpleStats . get ( j ) [ NUM_ ] ; rulesetStat [ NUM_ ] = m_SimpleStats . get ( j ) [ NUM_ ] ; } } for ( int k = m_SimpleStats . size ( ) - NUM_ ; k >= NUM_ ; k -- ) { double [ ] ruleStat = m_SimpleStats . get ( k ) ; double ifDeleted = potential ( k , expFPRate , rulesetStat , ruleStat , checkErr ) ; if ( ! Double . isNaN ( ifDeleted ) ) { if ( k == ( m_SimpleStats . size ( ) - NUM_ ) ) { removeLast ( ) ; } else { m_Ruleset . remove ( k ) ; needUpdate = BOOL_ ; } } } if ( needUpdate ) { m_Filtered = null ; m_SimpleStats = null ; countData ( ) ; } }
@ Override public void onDrawFrame ( GL10 gl10 ) { GLES20 . glClearColor ( NUM_ , NUM_ , NUM_ , NUM_ ) ; GLES20 . glClear ( GLES20 . GL_COLOR_BUFFER_BIT | GLES20 . GL_DEPTH_BUFFER_BIT ) ; GLES20 . glEnable ( GLES20 . GL_DEPTH_TEST ) ; GLES20 . glEnable ( GLES20 . GL_CULL_FACE ) ; GLES20 . glEnable ( GLES20 . GL_BLEND ) ; GLES20 . glBlendFunc ( GLES20 . GL_SRC_ALPHA , GLES20 . GL_ONE_MINUS_SRC_ALPHA ) ; long currentTimeMillis = System . currentTimeMillis ( ) ; updateWithDelta ( currentTimeMillis - lastTimeMillis ) ; lastTimeMillis = currentTimeMillis ; }
public void removeLineHighlight ( Object tag ) { if ( tag instanceof LineHighlightInfo ) { lineHighlights . remove ( tag ) ; repaintLine ( ( LineHighlightInfo ) tag ) ; } }
private Element createSingleLogOutForCastleAsIDP ( String binding ) throws Exception { String entityID = idmClient . getEntityID ( tenantName ) ; String ssoLoc = convertToIPV6ShortForm ( entityID ) ; if ( ssoLoc == null ) { ssoLoc = tenantName ; } String sloLoc = ssoLoc . replaceAll ( STR_ , STR_ ) ; Element slosEle = createEndPoint ( SAMLNames . SLOS , binding , sloLoc , null ) ; return slosEle ; }
public static void unregisterTransportMBean ( String containerName ) throws Exception { MBeanServer mBeanServer = getMBeanServer ( containerName ) ; if ( mBeanServer == null ) return ; ObjectName transportMBeanObjectName = TransportConstants . createTransportMBeanObjectName ( containerName ) ; if ( mBeanServer . isRegistered ( transportMBeanObjectName ) ) { mBeanServer . unregisterMBean ( transportMBeanObjectName ) ; if ( _logger . isLoggable ( Level . FINE ) ) { _logger . fine ( STR_ ) ; } } }
public void addNodesInDocOrder ( NodeIterator iterator , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; Node node ; while ( null != ( node = iterator . nextNode ( ) ) ) { addNodeInDocOrder ( node , support ) ; } }
protected void uninstallDefaults ( ) { SeaGlassContext context = getContext ( splitPane , ENABLED ) ; style . uninstallDefaults ( context ) ; context . dispose ( ) ; style = null ; context = getContext ( splitPane , Region . SPLIT_PANE_DIVIDER , ENABLED ) ; dividerStyle . uninstallDefaults ( context ) ; context . dispose ( ) ; dividerStyle = null ; super . uninstallDefaults ( ) ; }
public void subtractAmount ( final String amount ) { subtractAmount ( Integer . parseInt ( amount ) ) ; }
private synchronized void makeCompositeBuilder ( ) throws InvalidObjectException { if ( compositeBuilder != null ) return ; Class < ? > targetClass = ( Class < ? > ) getJavaType ( ) ; CompositeBuilder [ ] [ ] builders = { { new CompositeBuilderViaFrom ( targetClass , itemNames ) } , { new CompositeBuilderViaConstructor ( targetClass , itemNames ) } , { new CompositeBuilderCheckGetters ( targetClass , itemNames , getterMappings ) , new CompositeBuilderViaSetters ( targetClass , itemNames ) , new CompositeBuilderViaProxy ( targetClass , itemNames ) } } ; CompositeBuilder foundBuilder = null ; final StringBuilder whyNots = new StringBuilder ( ) ; Throwable possibleCause = null ; find : for ( CompositeBuilder [ ] relatedBuilders : builders ) { for ( int i = NUM_ ; i < relatedBuilders . length ; i ++ ) { CompositeBuilder builder = relatedBuilders [ i ] ; String whyNot = builder . applicable ( getters ) ; if ( whyNot == null ) { foundBuilder = builder ; break find ; } Throwable cause = builder . possibleCause ( ) ; if ( cause != null ) possibleCause = cause ; if ( whyNot . length ( ) > NUM_ ) { if ( whyNots . length ( ) > NUM_ ) whyNots . append ( STR_ ) ; whyNots . append ( whyNot ) ; if ( i == NUM_ ) break ; } } } if ( foundBuilder == null ) { String msg = STR_ + targetClass . getName ( ) + STR_ + whyNots ; if ( possibleCause != null ) msg += STR_ ; throw invalidObjectException ( msg , possibleCause ) ; } compositeBuilder = foundBuilder ; }
public void append ( CharSequence s ) { text . append ( s ) ; }
public void invalidateAll ( ) { if ( m_tuples == null ) return ; for ( int i = NUM_ ; i < m_tuples . length ; ++ i ) invalidate ( i ) ; }
public void add ( final long addr ) { addrs . add ( addr ) ; }
@ AndroidOnly ( STR_ ) public void test_wrap_ByteBuffer_ByteBuffer_04 ( ) { String host = STR_ ; int port = NUM_ ; ByteBuffer bbs = ByteBuffer . allocate ( NUM_ ) ; ByteBuffer bbd = ByteBuffer . allocate ( NUM_ ) ; SSLEngine sse = getEngine ( host , port ) ; try { sse . wrap ( bbs , bbd ) ; fail ( STR_ ) ; } catch ( IllegalStateException iobe ) { } catch ( Exception e ) { fail ( e + STR_ ) ; } }
public static boolean isBlackListed ( @ Nonnull Size size , @ Nonnull String blacklistString ) { String [ ] blacklistStringArray = blacklistString . split ( STR_ ) ; if ( blacklistStringArray . length == NUM_ ) { return BOOL_ ; } Set < String > blacklistedSizes = new HashSet ( Lists . newArrayList ( blacklistStringArray ) ) ; return isBlackListed ( size , blacklistedSizes ) ; }
static private void _writeDecRef ( Writer out , char ch ) throws IOException { if ( ch == STR_ ) { out . write ( STR_ ) ; return ; } out . write ( STR_ ) ; int i = ( int ) ch ; if ( i > NUM_ ) { out . write ( STR_ + ( i / NUM_ ) ) ; i = i % NUM_ ; out . write ( STR_ + ( i / NUM_ ) ) ; i = i % NUM_ ; out . write ( STR_ + ( i / NUM_ ) ) ; i = i % NUM_ ; out . write ( STR_ + ( i / NUM_ ) ) ; i = i % NUM_ ; out . write ( STR_ + i ) ; } else if ( i > NUM_ ) { out . write ( STR_ + ( i / NUM_ ) ) ; i = i % NUM_ ; out . write ( STR_ + ( i / NUM_ ) ) ; i = i % NUM_ ; out . write ( STR_ + ( i / NUM_ ) ) ; i = i % NUM_ ; out . write ( STR_ + i ) ; } else { out . write ( STR_ + ( i / NUM_ ) ) ; i = i % NUM_ ; out . write ( STR_ + ( i / NUM_ ) ) ; i = i % NUM_ ; out . write ( STR_ + i ) ; } out . write ( STR_ ) ; }
protected byte [ ] inputStreamToByteArray ( InputStream is ) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; int next = is . read ( ) ; while ( next > - NUM_ ) { bos . write ( next ) ; next = is . read ( ) ; } bos . flush ( ) ; is . close ( ) ; return bos . toByteArray ( ) ; }
@ Override public String toString ( ) { Object value = get ( ) ; return value == null ? STR_ : value . toString ( ) ; }
private boolean isAReferenceTag ( String str ) { if ( str == null ) { return BOOL_ ; } return str . indexOf ( STR_ ) == NUM_ && str . lastIndexOf ( STR_ ) == ( str . length ( ) - NUM_ ) ; }
protected static String encode ( String url ) { StringBuilder encoder = new StringBuilder ( ) ; for ( char chr : url . toCharArray ( ) ) { byte chrByte = ( byte ) chr ; if ( ( chrByte <= NUM_ || chrByte >= NUM_ || chr == STR_ || chr == STR_ ) ) { encoder . append ( String . format ( STR_ , chrByte ) ) ; } else { encoder . append ( chr ) ; } } return encoder . toString ( ) ; }
public void testX509CRLEntry ( ) { TBTCRLEntry tbt_crlentry = new TBTCRLEntry ( ) ; assertNull ( tbt_crlentry . getCertificateIssuer ( ) ) ; assertNull ( tbt_crlentry . getCriticalExtensionOIDs ( ) ) ; try { assertNull ( tbt_crlentry . getEncoded ( ) ) ; } catch ( CRLException e ) { fail ( STR_ + e . getMessage ( ) ) ; } assertNull ( tbt_crlentry . getNonCriticalExtensionOIDs ( ) ) ; assertNull ( tbt_crlentry . getRevocationDate ( ) ) ; }
public static long now ( ) { return System . currentTimeMillis ( ) ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
private BinlogPosition findHeartbeat ( MaxwellReplicator r ) throws Exception { r . startReplicator ( ) ; for ( RowMap row = r . getRow ( ) ; row != null ; row = r . getRow ( ) ) { if ( Objects . equals ( r . getLastHeartbeatRead ( ) , recoveryInfo . heartbeat ) ) return row . getPosition ( ) ; } return null ; }
private Configure ( ) { Properties p = new Properties ( ) ; Map args = new HashMap ( ) ; args . putAll ( System . getenv ( ) ) ; args . putAll ( System . getProperties ( ) ) ; p . putAll ( args ) ; this . property = p ; reload ( BOOL_ ) ; }
private void handleTruncatedInfo ( final StatementInfo info ) throws SQLException { final byte [ ] originalInfo = statement . getStatementInfoRequestItems ( ) ; final byte [ ] newInfoItems = new byte [ originalInfo . length + NUM_ . NUM_ ] ; int newIndex = NUM_ ; for ( final byte infoItem : originalInfo ) { assert newIndex < newInfoItems . length : STR_ ; switch ( infoItem ) { case ISCConstants . isc_info_sql_select : case ISCConstants . isc_info_sql_bind : final RowDescriptorBuilder currentBuilder = infoItem == ISCConstants . isc_info_sql_select ? info . fieldBuilder : info . parameterBuilder ; final int descriptorIndex = currentBuilder != null ? currentBuilder . getFirstUnprocessedIndex ( ) + NUM_ : NUM_ ; newInfoItems [ newIndex ++ ] = ISCConstants . isc_info_sql_sqlda_start ; newInfoItems [ newIndex ++ ] = NUM_ ; newInfoItems [ newIndex ++ ] = ( byte ) ( descriptorIndex & xFF ) ; newInfoItems [ newIndex ++ ] = ( byte ) ( descriptorIndex > > NUM_ ) ; newInfoItems [ newIndex ++ ] = infoItem ; break ; default : newInfoItems [ newIndex ++ ] = infoItem ; break ; } } assert newIndex == newInfoItems . length : STR_ ; info . requestBufferSize = Math . min ( NUM_ . info . requestBufferSize , statement . getMaxSqlInfoSize ( ) ) ; info . buffer = statement . getSqlInfo ( newInfoItems , info . requestBufferSize ) ; info . currentIndex = NUM_ ; }
public static String stripFileExtension ( String name ) { int pos = name . lastIndexOf ( STR_ ) ; if ( pos > NUM_ & pos < name . length ( ) - NUM_ ) return name . substring ( NUM_ , pos ) ; return name ; }
private static void pushTransactionStartStamp ( Transaction t ) { Map < Transaction , Timestamp > map = suspendedTxStartStamps . get ( ) ; Timestamp stamp = transactionStartStamp . get ( ) ; if ( stamp != null ) { map . put ( t , stamp ) ; } else { Debug . logError ( STR_ , module ) ; } }
private int indexedBinarySearch ( List < S2CellId > l , S2CellId key , int low ) { int high = l . size ( ) - NUM_ ; while ( low <= high ) { int mid = ( low + high ) > > NUM_ ; S2CellId midVal = l . get ( mid ) ; int cmp = midVal . compareTo ( key ) ; if ( cmp < NUM_ ) { low = mid + NUM_ ; } else if ( cmp > NUM_ ) { high = mid - NUM_ ; } else { return mid ; } } return low ; }
public Variable [ ] findLocalArrays ( ) { List < Variable > arrays = new ArrayList < Variable > ( ) ; for ( ListIterator < Variable > iterator = fLocalVariables . listIterator ( fLocalVariables . size ( ) ) ; iterator . hasPrevious ( ) ; ) { Variable localVariable = iterator . previous ( ) ; if ( localVariable . isArray ( ) ) arrays . add ( localVariable ) ; } return arrays . toArray ( new Variable [ arrays . size ( ) ] ) ; }
public static int indexOfJavaLikeExtension ( String fileName ) { int fileNameLength = fileName . length ( ) ; char [ ] [ ] javaLikeExtensions = getJavaLikeExtensions ( ) ; extensions : for ( int i = NUM_ , length = javaLikeExtensions . length ; i < length ; i ++ ) { char [ ] extension = javaLikeExtensions [ i ] ; int extensionLength = extension . length ; int extensionStart = fileNameLength - extensionLength ; int dotIndex = extensionStart - NUM_ ; if ( dotIndex < NUM_ ) continue ; if ( fileName . charAt ( dotIndex ) != STR_ ) continue ; for ( int j = NUM_ ; j < extensionLength ; j ++ ) { if ( fileName . charAt ( extensionStart + j ) != extension [ j ] ) continue extensions ; } return dotIndex ; } return - NUM_ ; }
public ShapeTileSimplex remove_border_line ( int p_no ) { if ( p_no < NUM_ || p_no >= lines_size ( ) ) { return this ; } ArrayList < PlaLineInt > new_arr = new ArrayList < PlaLineInt > ( lines_size ( ) ) ; new_arr . addAll ( lines_list ) ; new_arr . remove ( p_no ) ; return new ShapeTileSimplex ( new_arr ) ; }
protected boolean waitBeforeExecution ( ) throws InterruptedException { return BOOL_ ; }
static boolean isValidStreamingUrl ( String url ) { return url != null && url . matches ( STR_ ) ; }
public WebServiceProxy ( URL serverURL , ExecutorService executorService ) { this ( serverURL , executorService , NUM_ , NUM_ ) ; }
private static byte [ ] exposeByteArrayInputStreamBytes ( ByteArrayInputStream bais ) { byte [ ] buffer ; synchronized ( bais ) { byte [ ] buf ; int pos ; try { buf = ( byte [ ] ) BAIS_BUF . get ( bais ) ; pos = BAIS_POS . getInt ( bais ) ; } catch ( IllegalAccessException iae ) { throw new AssertionError ( iae ) ; } int available = bais . available ( ) ; if ( pos == NUM_ && buf . length == available ) { buffer = buf ; } else { buffer = new byte [ available ] ; System . arraycopy ( buf , pos , buffer , NUM_ , available ) ; } bais . skip ( available ) ; } return buffer ; }
private void restoreData ( ) { Map < String , ? > map = preferenceUtils . getAll ( ) ; Set < String > strings = map . keySet ( ) ; for ( String string : strings ) { if ( string . startsWith ( SharedPreferenceUtils . keyTestMode ) ) { preferenceUtils . restoreKey ( string ) ; } } refreshKeyValues ( ) ; }
public String putImage ( String theFolder , String theImageName , Bitmap theBitmap ) { if ( theFolder == null || theImageName == null || theBitmap == null ) return null ; this . DEFAULT_APP_IMAGEDATA_DIRECTORY = theFolder ; String mFullPath = setupFullPath ( theImageName ) ; if ( ! mFullPath . equals ( STR_ ) ) { lastImagePath = mFullPath ; saveBitmap ( mFullPath , theBitmap ) ; } return mFullPath ; }
public Class < ? > type ( ) { if ( isClass ) { return ( Class < ? > ) object ; } else { return object . getClass ( ) ; } }
void addToExternalCSS ( CSSElement cssElement ) { if ( externalCSS == null ) { externalCSS = new Vector ( ) ; } externalCSS . addElement ( cssElement ) ; }
@ Override public String toString ( ) { return buf . toString ( ) ; }
private void remove ( String world , PermissionHolder holder , String permission ) { try { if ( world != null && ! world . equals ( STR_ ) ) { holder . unsetPermission ( permission , server , world ) ; } else { holder . unsetPermission ( permission , server ) ; } } catch ( ObjectLacksException ignored ) { } save ( holder ) ; }
private void action_treeAddAll ( ) { log . info ( STR_ ) ; ListModel model = centerList . getModel ( ) ; int size = model . getSize ( ) ; int index = - NUM_ ; for ( index = NUM_ ; index < size ; index ++ ) { ListItem item = ( ListItem ) model . getElementAt ( index ) ; action_treeAdd ( item ) ; } }
private ConcurrentSkipListMap . Node < K , V > hiNode ( ) { if ( hi == null ) return m . findLast ( ) ; else if ( hiInclusive ) return m . findNear ( hi , LT | EQ ) ; else return m . findNear ( hi , LT ) ; }
public static final ImagePoint convertPoint ( MapPoint mapPoint , MapEnvelope mapEnv , int imgHeight , int imgWidth ) { long imageY = Math . round ( convertY ( mapPoint , mapEnv , imgHeight ) ) ; long imageX = Math . round ( convertX ( mapPoint , mapEnv , imgWidth ) ) ; return new ImagePoint ( imageX , imageY ) ; }
private void checkUsingAdaptation ( ) { if ( tsUseAdaptation . isSelected ( ) ) { tfAdaptationTime . setEnabled ( BOOL_ ) ; tfAdaptationParam . setEnabled ( BOOL_ ) ; } else { tfAdaptationTime . setEnabled ( BOOL_ ) ; tfAdaptationParam . setEnabled ( BOOL_ ) ; } }
public String combineMix ( List < String > files , String outFile ) { ArrayList < String > cmd = new ArrayList < String > ( ) ; cmd . add ( soxBin ) ; cmd . add ( STR_ ) ; for ( String file : files ) { cmd . add ( STR_ ) ; cmd . add ( STR_ ) ; cmd . add ( file ) ; } cmd . add ( outFile ) ; try { int rc = execSox ( cmd , callback ) ; if ( rc != NUM_ ) { outFile = null ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } return outFile ; }
public Quarter ( int quarter , Year year ) { if ( ( quarter < FIRST_QUARTER ) || ( quarter > LAST_QUARTER ) ) { throw new IllegalArgumentException ( STR_ ) ; } this . year = ( short ) year . getYear ( ) ; this . quarter = ( byte ) quarter ; peg ( Calendar . getInstance ( ) ) ; }
public void sendRequestVoteRequest ( boolean isPrevote ) throws GondolaException { if ( ! enabled || masterId >= NUM_ ) { return ; } if ( ! isPrevote ) { currentTerm ++ ; votedFor = - NUM_ ; save ( currentTerm , memberId ) ; votedFor = memberId ; } prevotesOnly = isPrevote ; Message message = pool . checkout ( ) ; try { saveQueue . getLatest ( savedRid ) ; message . requestVoteRequest ( memberId , currentTerm , isPrevote , savedRid ) ; peers . forEach ( null ) ; } finally { message . release ( ) ; } prevoteTs = clock . now ( ) + ( long ) ( ( Math . random ( ) . prevotePeriod ) ) ; if ( ! isPrevote ) { prevoteTs += electionTimeout ; } }
private List < String > filterTargetsFromResponse ( Set < String > varrayTaggedPortWWNs , Map < String , List < String > > initiatorTargetMap , String initiatorKey ) { log . debug ( STR_ ) ; List < String > filteredTargetList = new ArrayList < String > ( ) ; List < String > targetPortListFromResponse = initiatorTargetMap . get ( initiatorKey ) ; for ( String portWWN : targetPortListFromResponse ) { if ( varrayTaggedPortWWNs . contains ( portWWN ) || varrayTaggedPortWWNs . contains ( portWWN . toUpperCase ( ) ) ) { filteredTargetList . add ( portWWN . toUpperCase ( ) ) ; } } log . debug ( STR_ ) ; return filteredTargetList ; }
public PilotingRollData checkManeuver ( MoveStep step , EntityMovementType overallMoveType ) { PilotingRollData roll = getBasePilotingRoll ( overallMoveType ) ; if ( ( step == null ) || ( step . getType ( ) != MoveStepType . MANEUVER ) ) { roll . addModifier ( TargetRoll . CHECK_FALSE , STR_ ) ; return roll ; } boolean sideSlipMod = ( this instanceof ConvFighter ) && isVSTOL ( ) ; roll . append ( new PilotingRollData ( getId ( ) , ManeuverType . getMod ( step . getManeuverType ( ) , sideSlipMod ) , ManeuverType . getTypeName ( step . getManeuverType ( ) ) + STR_ ) ) ; return roll ; }
public static List < String > parseProgramArgs ( ILaunchConfiguration launchConfig ) throws CoreException { return parseArgs ( launchConfig . getAttribute ( IJavaLaunchConfigurationConstants . ATTR_PROGRAM_ARGUMENTS , STR_ ) ) ; }
public abstract T decodeValue ( String value ) ;
private void fitImageToView ( ) { Drawable drawable = getDrawable ( ) ; if ( drawable == null || drawable . getIntrinsicWidth ( ) == NUM_ || drawable . getIntrinsicHeight ( ) == NUM_ ) { return ; } if ( matrix == null || prevMatrix == null ) { return ; } int drawableWidth = drawable . getIntrinsicWidth ( ) ; int drawableHeight = drawable . getIntrinsicHeight ( ) ; float scaleX = ( float ) viewWidth / drawableWidth ; float scaleY = ( float ) viewHeight / drawableHeight ; switch ( mScaleType ) { case CENTER : scaleX = scaleY = NUM_ ; break ; case CENTER_CROP : scaleX = scaleY = Math . max ( scaleX , scaleY ) ; break ; case CENTER_INSIDE : scaleX = scaleY = Math . min ( NUM_ , Math . min ( scaleX , scaleY ) ) ; case FIT_CENTER : scaleX = scaleY = Math . min ( scaleX , scaleY ) ; break ; case FIT_XY : break ; default : throw new UnsupportedOperationException ( STR_ ) ; } float redundantXSpace = viewWidth - ( scaleX . drawableWidth ) ; float redundantYSpace = viewHeight - ( scaleY . drawableHeight ) ; matchViewWidth = viewWidth - redundantXSpace ; matchViewHeight = viewHeight - redundantYSpace ; if ( ! isZoomed ( ) && ! imageRenderedAtLeastOnce ) { matrix . setScale ( scaleX , scaleY ) ; matrix . postTranslate ( redundantXSpace / NUM_ , redundantYSpace / NUM_ ) ; normalizedScale = NUM_ ; } else { if ( prevMatchViewWidth == NUM_ || prevMatchViewHeight == NUM_ ) { savePreviousImageValues ( ) ; } prevMatrix . getValues ( m ) ; m [ Matrix . MSCALE_X ] = matchViewWidth / drawableWidth . normalizedScale ; m [ Matrix . MSCALE_Y ] = matchViewHeight / drawableHeight . normalizedScale ; float transX = m [ Matrix . MTRANS_X ] ; float transY = m [ Matrix . MTRANS_Y ] ; float prevActualWidth = prevMatchViewWidth . normalizedScale ; float actualWidth = getImageWidth ( ) ; translateMatrixAfterRotate ( Matrix . MTRANS_X , transX , prevActualWidth , actualWidth , prevViewWidth , viewWidth , drawableWidth ) ; float prevActualHeight = prevMatchViewHeight . normalizedScale ; float actualHeight = getImageHeight ( ) ; translateMatrixAfterRotate ( Matrix . MTRANS_Y , transY , prevActualHeight , actualHeight , prevViewHeight , viewHeight , drawableHeight ) ; matrix . setValues ( m ) ; } fixTrans ( ) ; setImageMatrix ( matrix ) ; }
@ Override public synchronized MXBeanMapping mappingForType ( Type objType , MXBeanMappingFactory factory ) throws OpenDataException { if ( inProgress . containsKey ( objType ) ) { throw new OpenDataException ( STR_ + typeName ( objType ) ) ; } MXBeanMapping mapping ; mapping = getMapping ( objType ) ; if ( mapping != null ) return mapping ; inProgress . put ( objType , objType ) ; try { mapping = makeMapping ( objType , factory ) ; } catch ( OpenDataException e ) { throw openDataException ( STR_ + typeName ( objType ) , e ) ; } finally { inProgress . remove ( objType ) ; } putMapping ( objType , mapping ) ; return mapping ; }
public void testCase18 ( ) { byte aBytes [ ] = { NUM_ } ; byte bBytes [ ] = { NUM_ } ; byte rBytes [ ] = { NUM_ } ; int aSign = NUM_ ; int bSign = NUM_ ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . add ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public static Element createElementInSignature11Space ( Document doc , String elementName ) { if ( doc == null ) { throw new RuntimeException ( STR_ ) ; } if ( ( ds11Prefix == null ) || ( ds11Prefix . length ( ) == NUM_ ) ) { return doc . createElementNS ( Constants . SignatureSpec11NS , elementName ) ; } return doc . createElementNS ( Constants . SignatureSpec11NS , ds11Prefix + STR_ + elementName ) ; }
public void removeElementAt ( final int index ) { entries . remove ( index ) ; }
public static void c2ir ( double c [ ] , int nc , double hh [ ] , int leng ) { hh [ NUM_ ] = Math . exp ( c [ NUM_ ] ) ; for ( int n = NUM_ ; n < leng ; n ++ ) { double d = NUM_ ; int upl = ( n >= nc ) ? nc - NUM_ : n ; for ( int k = NUM_ ; k <= upl ; k ++ ) d += k . c [ k ] . hh [ n - k ] ; hh [ n ] = d / n ; } }
public void close ( ) { _ncGuards = null ; }
public void processIndication ( Hashtable < String , String > cimNotification ) { String cimIndicationType = getCimIndicationType ( cimNotification ) ; if ( _monitoringPropertiesLoader . isToLogIndications ( ) ) { _logger . debug ( STR_ + getIndicationData ( cimNotification ) ) ; } if ( cimIndicationType != null && cimIndicationType . equals ( CimConstants . CIM_ALERT_INDICATION_TYPE ) ) { if ( _monitoringPropertiesLoader . isToLogIndications ( ) ) { _logger . debug ( STR_ ) ; } _alertProcessor . processIndication ( cimNotification ) ; } else if ( cimIndicationType != null && cimIndicationType . equals ( CimConstants . CIM_INST_INDICATION_TYPE ) ) { if ( _monitoringPropertiesLoader . isToLogIndications ( ) ) { _logger . debug ( STR_ ) ; } _eventProcessor . processIndication ( cimNotification ) ; } else { if ( _monitoringPropertiesLoader . isToLogIndications ( ) ) { _logger . debug ( STR_ , cimIndicationType ) ; } } }
public ReplicationJob createJobForCopyTable ( long auditLogId , long auditLogEntryCreateTime , Table table ) throws StateUpdateException { ReplicationOperation replicationOperation = HiveUtils . isPartitioned ( table ) ? ReplicationOperation . COPY_PARTITIONED_TABLE : ReplicationOperation . COPY_UNPARTITIONED_TABLE ; Map < String , String > extras = new HashMap < > ( ) ; extras . put ( PersistedJobInfo . AUDIT_LOG_ID_EXTRAS_KEY , Long . toString ( auditLogId ) ) ; extras . put ( PersistedJobInfo . AUDIT_LOG_ENTRY_CREATE_TIME_KEY , Long . toString ( auditLogEntryCreateTime ) ) ; PersistedJobInfo persistedJobInfo = jobInfoStore . resilientCreate ( replicationOperation , ReplicationStatus . PENDING , ReplicationUtils . getLocation ( table ) , srcCluster . getName ( ) , new HiveObjectSpec ( table ) , Collections . emptyList ( ) , ReplicationUtils . getTldt ( table ) , Optional . empty ( ) , Optional . empty ( ) , extras ) ; HiveObjectSpec spec = new HiveObjectSpec ( table ) ; Optional < Path > tableLocation = ReplicationUtils . getLocation ( table ) ; switch ( replicationOperation ) { case COPY_UNPARTITIONED_TABLE : return new ReplicationJob ( conf , new CopyUnpartitionedTableTask ( conf , destinationObjectFactory , objectConflictHandler , srcCluster , destCluster , spec , tableLocation , directoryCopier , BOOL_ ) , onStateChangeHandler , persistedJobInfo ) ; case COPY_PARTITIONED_TABLE : return new ReplicationJob ( conf , new CopyPartitionedTableTask ( conf , destinationObjectFactory , objectConflictHandler , srcCluster , destCluster , spec , tableLocation ) , onStateChangeHandler , persistedJobInfo ) ; default : throw new RuntimeException ( STR_ + replicationOperation ) ; } }
public static String readFully ( Reader reader ) throws IOException { try { StringWriter writer = new StringWriter ( ) ; char [ ] buffer = new char [ NUM_ ] ; int count ; while ( ( count = reader . read ( buffer ) ) != - NUM_ ) { writer . write ( buffer , NUM_ , count ) ; } return writer . toString ( ) ; } finally { reader . close ( ) ; } }
synchronized public void releaseXMLReader ( XMLReader reader ) { if ( m_readerManager != null ) { m_readerManager . releaseXMLReader ( reader ) ; } }
public int unFinishSize ( ) { return mUnFinishQueue . size ( ) ; }
public void addSample ( int weight , float value ) { ensureSortedByIndex ( ) ; Sample newSample = recycledSampleCount > NUM_ ? recycledSamples [ -- recycledSampleCount ] : new Sample ( ) ; newSample . index = nextSampleIndex ++ ; newSample . weight = weight ; newSample . value = value ; samples . add ( newSample ) ; totalWeight += weight ; while ( totalWeight > maxWeight ) { int excessWeight = totalWeight - maxWeight ; Sample oldestSample = samples . get ( NUM_ ) ; if ( oldestSample . weight <= excessWeight ) { totalWeight -= oldestSample . weight ; samples . remove ( NUM_ ) ; if ( recycledSampleCount < MAX_RECYCLED_SAMPLES ) { recycledSamples [ recycledSampleCount ++ ] = oldestSample ; } } else { oldestSample . weight -= excessWeight ; totalWeight -= excessWeight ; } } }
private void specialisedPredicates ( ) { DoublePredicate doublePredicate = null ; LongPredicate longPredicate = null ; }
private static final synchronized int nextPoolId ( ) { return ++ poolNumberSequence ; }
public static boolean secKeyVerify ( byte [ ] seckey ) { Preconditions . checkArgument ( seckey . length == NUM_ ) ; ByteBuffer byteBuff = nativeECDSABuffer . get ( ) ; if ( byteBuff == null || byteBuff . capacity ( ) < seckey . length ) { byteBuff = ByteBuffer . allocateDirect ( seckey . length ) ; byteBuff . order ( ByteOrder . nativeOrder ( ) ) ; nativeECDSABuffer . set ( byteBuff ) ; } byteBuff . rewind ( ) ; byteBuff . put ( seckey ) ; r . lock ( ) ; try { return secp256k1_ec_seckey_verify ( byteBuff , Secp256k1Context . getContext ( ) ) == NUM_ ; } finally { r . unlock ( ) ; } }
public TreeNodeIterator ( Node root , boolean preorder ) { m_preorder = preorder ; m_root = root ; m_stack = new ArrayList ( ) ; m_stack . add ( root ) ; if ( ! preorder ) { for ( Node n = root . getChild ( NUM_ ) ; n != null ; n = n . getChild ( NUM_ ) ) m_stack . add ( n ) ; } }
public static WritableNativeArray makeNativeArray ( List objects ) { WritableNativeArray nativeArray = new WritableNativeArray ( ) ; if ( objects == null ) { return nativeArray ; } for ( Object elem : objects ) { elem = makeNativeObject ( elem ) ; if ( elem == null ) { nativeArray . pushNull ( ) ; } else if ( elem instanceof Boolean ) { nativeArray . pushBoolean ( ( Boolean ) elem ) ; } else if ( elem instanceof Integer ) { nativeArray . pushInt ( ( Integer ) elem ) ; } else if ( elem instanceof Double ) { nativeArray . pushDouble ( ( Double ) elem ) ; } else if ( elem instanceof String ) { nativeArray . pushString ( ( String ) elem ) ; } else if ( elem instanceof WritableNativeArray ) { nativeArray . pushArray ( ( WritableNativeArray ) elem ) ; } else if ( elem instanceof WritableNativeMap ) { nativeArray . pushMap ( ( WritableNativeMap ) elem ) ; } else { throw new IllegalArgumentException ( STR_ + elem . getClass ( ) ) ; } } return nativeArray ; }
public static BigInteger sizeOfDirectoryAsBigInteger ( File directory ) { checkDirectory ( directory ) ; final File [ ] files = directory . listFiles ( ) ; if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { try { if ( ! isSymlink ( file ) ) { size = size . add ( BigInteger . valueOf ( sizeOf ( file ) ) ) ; } } catch ( IOException ioe ) { } } return size ; }
@ Override public void nodeChanged ( ) { log . info ( STR_ ) ; wakeup ( ) ; }
private static NodePair splitBlock ( final View view , final Function function , final CodeNode node , final Instruction instruction ) { boolean before = BOOL_ ; final List < Instruction > beforeInstructions = new ArrayList < Instruction > ( ) ; final List < Instruction > afterInstructions = new ArrayList < Instruction > ( ) ; for ( final Instruction nodeInstruction : node . getInstructions ( ) ) { if ( before ) { beforeInstructions . add ( nodeInstruction ) ; } else { afterInstructions . add ( nodeInstruction ) ; } if ( nodeInstruction == instruction ) { before = BOOL_ ; } } if ( afterInstructions . isEmpty ( ) ) { return new NodePair ( node , null ) ; } else { final CodeNode firstNode = view . createCodeNode ( function , beforeInstructions ) ; final CodeNode secondNode = view . createCodeNode ( function , afterInstructions ) ; firstNode . setColor ( node . getColor ( ) ) ; secondNode . setColor ( DEFAULT_BLOCK_COLOR ) ; for ( final ViewEdge edge : node . getIncomingEdges ( ) ) { final ViewEdge newEdge = view . createEdge ( edge . getSource ( ) , firstNode , edge . getType ( ) ) ; newEdge . setColor ( edge . getColor ( ) ) ; } for ( final ViewEdge edge : node . getOutgoingEdges ( ) ) { final ViewEdge newEdge = view . createEdge ( secondNode , edge . getTarget ( ) , edge . getType ( ) ) ; newEdge . setColor ( edge . getColor ( ) ) ; } view . deleteNode ( node ) ; return new NodePair ( firstNode , secondNode ) ; } }
public Pair < String , String > objectToString ( final long shopId , final String currency , final BigDecimal regularPrice ) { return new Pair < String , String > ( STR_ + shopId + STR_ + currency , moneyBridge . objectToString ( regularPrice ) ) ; }
public String readLine ( ) throws IOException { StringBuilder line = new StringBuilder ( ) ; int i ; char c ; i = read ( ) ; if ( i == - NUM_ ) return null ; while ( i > - NUM_ && i != STR_ && i != STR_ ) { c = ( char ) ( i & xFF ) ; line = line . append ( c ) ; i = read ( ) ; } if ( i == STR_ ) { if ( ( i = read ( ) ) != STR_ ) throw new IOException ( STR_ + Integer . toHexString ( i ) + STR_ + line ) ; } return line . toString ( ) ; }
static public void forceCreationOfNewIndex ( ) { forceCreationOfNewIndex ( BOOL_ ) ; }
public FrameBlock zeroOutOperations ( FrameBlock result , IndexRange range , boolean complementary , int iRowStartSrc , int iRowStartDest , int brlen , int iMaxRowsToCopy ) throws DMLRuntimeException { int clen = getNumColumns ( ) ; if ( result == null ) result = new FrameBlock ( getSchema ( ) ) ; else { result . reset ( NUM_ , BOOL_ ) ; result . setSchema ( getSchema ( ) ) ; } result . ensureAllocatedColumns ( brlen ) ; if ( complementary ) { for ( int r = ( int ) range . rowStart ; r <= range . rowEnd && r + iRowStartDest < brlen ; r ++ ) { for ( int c = ( int ) range . colStart ; c <= range . colEnd ; c ++ ) result . set ( r + iRowStartDest , c , get ( r + iRowStartSrc , c ) ) ; } } else { int r = iRowStartDest ; for ( ; r < ( int ) range . rowStart && r - iRowStartDest < iMaxRowsToCopy ; r ++ ) for ( int c = NUM_ ; c < clen ; c ++ ) result . set ( r , c , get ( r + iRowStartSrc - iRowStartDest , c ) ) ; for ( ; r <= ( int ) range . rowEnd && r - iRowStartDest < iMaxRowsToCopy ; r ++ ) { for ( int c = NUM_ ; c < ( int ) range . colStart ; c ++ ) result . set ( r , c , get ( r + iRowStartSrc - iRowStartDest , c ) ) ; for ( int c = ( int ) range . colEnd + NUM_ ; c < clen ; c ++ ) result . set ( r , c , get ( r + iRowStartSrc - iRowStartDest , c ) ) ; } for ( ; r - iRowStartDest < iMaxRowsToCopy ; r ++ ) for ( int c = NUM_ ; c < clen ; c ++ ) result . set ( r , c , get ( r + iRowStartSrc - iRowStartDest , c ) ) ; } return result ; }
public SignalBarrier ( ) { _owner = null ; }
public void testToBigIntegerPos1 ( ) { String a = STR_ ; BigInteger bNumber = new BigInteger ( STR_ ) ; BigDecimal aNumber = new BigDecimal ( a ) ; BigInteger result = aNumber . toBigInteger ( ) ; assertTrue ( STR_ , result . equals ( bNumber ) ) ; }
private static float [ ] normalize ( float [ ] coefficients ) { float accumulator = NUM_ ; for ( int x = NUM_ ; x < coefficients . length ; x ++ ) { accumulator += Math . abs ( coefficients [ x ] ) ; } for ( int x = NUM_ ; x < coefficients . length ; x ++ ) { coefficients [ x ] = coefficients [ x ] / accumulator ; } return coefficients ; }
protected void printTrack ( Track track ) { DefaultEntityViewInfo vInfo = ( DefaultEntityViewInfo ) track . getViewInfo ( ) ; tmpNodeBuffer . clear ( ) ; tmpNodeBuffer . addAll ( track . getNodes ( ) ) ; if ( ! tmpNodeBuffer . isEmpty ( ) ) { printLine ( imageBdr , tmpNodeBuffer , vInfo , BOOL_ , BOOL_ , null ) ; printPoint ( imageBdr , tmpNodeBuffer . get ( tmpNodeBuffer . size ( ) - NUM_ ) , vInfo , null ) ; } }
private PeriodFormatterBuilder appendSuffix ( PeriodFieldAffix suffix ) { final Object originalPrinter ; final Object originalParser ; if ( iElementPairs . size ( ) > NUM_ ) { originalPrinter = iElementPairs . get ( iElementPairs . size ( ) - NUM_ ) ; originalParser = iElementPairs . get ( iElementPairs . size ( ) - NUM_ ) ; } else { originalPrinter = null ; originalParser = null ; } if ( originalPrinter == null || originalParser == null || originalPrinter != originalParser || ! ( originalPrinter instanceof FieldFormatter ) ) { throw new IllegalStateException ( STR_ ) ; } clearPrefix ( ) ; FieldFormatter newField = new FieldFormatter ( ( FieldFormatter ) originalPrinter , suffix ) ; iElementPairs . set ( iElementPairs . size ( ) - NUM_ , newField ) ; iElementPairs . set ( iElementPairs . size ( ) - NUM_ , newField ) ; iFieldFormatters [ newField . getFieldType ( ) ] = newField ; return this ; }
public Collection < Cube > all ( ) { return Collections . unmodifiableCollection ( cubes ) ; }
public static short readUByte ( ByteBuffer buffer ) { byte b = buffer . get ( ) ; return ( short ) ( b & xff ) ; }
public static double mostToxicRow ( Gate g ) { return Collections . min ( g . get_toxicity ( ) ) ; }
public MultiServer ( ) { this ( NetworkConfig . DEFAULT_TCP_PORT , NetworkConfig . DEFAULT_UDP_PORT ) ; }
protected String urlString ( ) throws ParseException { StringBuffer retval = new StringBuffer ( ) ; lexer . selectLexer ( STR_ ) ; while ( lexer . hasMoreChars ( ) ) { char la = lexer . lookAhead ( NUM_ ) ; if ( la == STR_ || la == STR_ || la == STR_ || la == STR_ || la == STR_ ) break ; lexer . consume ( NUM_ ) ; retval . append ( la ) ; } return retval . toString ( ) ; }
public XmlElement ( byte [ ] encodedDocument ) { if ( encodedDocument == null ) throw new IllegalArgumentException ( STR_ ) ; this . encoded = encodedDocument . clone ( ) ; }
public void add ( int position , int height ) { int currHeight = mMap . get ( position , - NUM_ ) ; if ( currHeight != height ) { if ( currHeight == - NUM_ ) { if ( mMap . size ( ) == mMaxSize ) { mMap . delete ( mOrder . remove ( NUM_ ) ) ; } } else { mOrder . remove ( ( Integer ) position ) ; } mMap . put ( position , height ) ; mOrder . add ( position ) ; } }
public void testmodInversePos2 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , - NUM_ } ; byte mBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int mSign = NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger modulus = new BigInteger ( mSign , mBytes ) ; BigInteger result = aNumber . modInverse ( modulus ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
@ GET @ Path ( STR_ ) @ Produces ( { MediaType . APPLICATION_XML , MediaType . APPLICATION_JSON } ) @ CheckPermission ( roles = { Role . SECURITY_ADMIN } ) public OSTenantListRestRep listCoprhdOsTenants ( ) { _log . debug ( STR_ ) ; List < OSTenant > tenants = getOsTenantsFromCoprhdDb ( ) ; return map ( tenants ) ; }
public int read ( final byte [ ] data ) { init ( ) ; if ( data != null ) { rawData = ByteBuffer . wrap ( data ) ; rawData . rewind ( ) ; rawData . order ( ByteOrder . LITTLE_ENDIAN ) ; readHeader ( ) ; if ( ! err ( ) ) { readContents ( ) ; if ( frameCount < NUM_ ) { status = STATUS_FORMAT_ERROR ; } } } else { status = STATUS_OPEN_ERROR ; } return status ; }
private void calculateUniqueValue ( Object [ ] minValue , Object [ ] uniqueValue ) { for ( int i = NUM_ ; i < measureCount ; i ++ ) { if ( type [ i ] == CarbonCommonConstants . BIG_INT_MEASURE ) { uniqueValue [ i ] = ( long ) minValue [ i ] - NUM_ ; } else if ( type [ i ] == CarbonCommonConstants . BIG_DECIMAL_MEASURE ) { BigDecimal val = ( BigDecimal ) minValue [ i ] ; uniqueValue [ i ] = ( val . subtract ( new BigDecimal ( NUM_ ) ) ) ; } else { uniqueValue [ i ] = ( double ) minValue [ i ] - NUM_ ; } } }
@ RequestMapping ( value = STR_ ) public void ssoBindingError ( Locale locale , @ PathVariable ( value = STR_ ) String tenant , HttpServletResponse response ) throws IOException { logger . info ( STR_ + locale . toString ( ) + STR_ + tenant ) ; ssoDefaultTenantBindingError ( locale , response ) ; }
public long env_end ( ) { return Long . parseLong ( fields [ NUM_ ] ) ; }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case NUM_ : return STRINGS ; case NUM_ : return HELLO ; default : return null ; } }
public X509TrustChainKeySelector ( X509Certificate ... trustedRoots ) { _log = LoggerFactory . getLogger ( X509TrustChainKeySelector . class ) ; checkCtorArgsNotNull ( trustedRoots ) ; _trustAnchors = new HashSet < TrustAnchor > ( ) ; for ( X509Certificate cert : trustedRoots ) { _trustAnchors . add ( new TrustAnchor ( cert , null ) ) ; } }
@ Override public void removeAttributeNS ( String namespaceURI , String localName ) { if ( ownerDocument . errorChecking && isReadOnly ( ) ) { String msg = DOMMessageFormatter . formatMessage ( DOMMessageFormatter . DOM_DOMAIN , STR_ , null ) ; throw new DOMException ( DOMException . NO_MODIFICATION_ALLOWED_ERR , msg ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return ; } attributes . safeRemoveNamedItemNS ( namespaceURI , localName ) ; }
public boolean drawImage ( Image img , AffineTransform xform , ImageObserver obs ) { if ( img == null ) { return BOOL_ ; } boolean result ; int srcWidth = img . getWidth ( null ) ; int srcHeight = img . getHeight ( null ) ; if ( srcWidth < NUM_ || srcHeight < NUM_ ) { result = BOOL_ ; } else { result = drawImageToPlatform ( img , xform , null , NUM_ , NUM_ , srcWidth , srcHeight , BOOL_ ) ; } return result ; }
public void handleButton1Request ( RequestInvocationEvent event ) throws ModelControlException { ServerSiteModel model = ( ServerSiteModel ) getModel ( ) ; AMPropertySheet ps = ( AMPropertySheet ) getChild ( PROPERTY_ATTRIBUTE ) ; String serverName = ( String ) getPageSessionAttribute ( PG_ATTR_SERVER_NAME ) ; String name = ( String ) getDisplayFieldValue ( TF_NAME ) ; name = name . trim ( ) ; if ( name . length ( ) > NUM_ ) { try { model . cloneServer ( serverName , name ) ; backTrail ( ) ; ServerSiteViewBean vb = ( ServerSiteViewBean ) getViewBean ( ServerSiteViewBean . class ) ; passPgSessionMap ( vb ) ; vb . forwardTo ( getRequestContext ( ) ) ; } catch ( AMConsoleException e ) { setInlineAlertMessage ( CCAlert . TYPE_ERROR , STR_ , e . getMessage ( ) ) ; forwardTo ( ) ; } } else { setInlineAlertMessage ( CCAlert . TYPE_ERROR , STR_ , STR_ ) ; forwardTo ( ) ; } }
public static < TK , FV > FeatureValueCollection < FV > combine ( Derivation < TK , FV > hyp ) { Counter < FV > counter = new ClassicCounter < FV > ( ) ; for ( ; hyp != null ; hyp = hyp . parent ) { if ( hyp . features != null ) { for ( FeatureValue < FV > feature : hyp . features ) { counter . incrementCount ( feature . name , feature . value ) ; } } } Set < FV > featureNames = new TreeSet < FV > ( counter . keySet ( ) ) ; FeatureValueCollection < FV > combinedList = new FeatureValueList < FV > ( featureNames . size ( ) ) ; for ( FV feature : featureNames ) { combinedList . add ( new FeatureValue < FV > ( feature , counter . getCount ( feature ) ) ) ; } return combinedList ; }
public void sendTitles ( ) { if ( listeners == null ) { return ; } StringBuilder labels = new StringBuilder ( STR_ ) ; labels . append ( STR_ + Bundle . getMessage ( STR_ ) + STR_ ) ; labels . append ( STR_ + manager . getClosedText ( ) + STR_ ) ; labels . append ( STR_ + manager . getThrownText ( ) + STR_ ) ; String message = labels . toString ( ) ; for ( ControllerInterface listener : listeners ) { listener . sendPacketToDevice ( message ) ; } }
public FilenameUtils ( ) { super ( ) ; }
public static void closeSession ( ) throws HibernateException { Session session = ( Session ) threadLocal . get ( ) ; threadLocal . set ( null ) ; if ( session != null ) { session . close ( ) ; } }
protected Calendar ( ) { zone = TimeZone . getDefault ( ) ; fields = new int [ FIELD_COUNT ] ; isSet = new boolean [ FIELD_COUNT ] ; areFieldsSet = isTimeSet = BOOL_ ; setTimeInMillis ( System . currentTimeMillis ( ) ) ; }
private PointPair calculateEdge ( Component comp1 , Component comp2 ) { Rectangle r1 = comp1 . getBounds ( ) ; Rectangle r2 = comp2 . getBounds ( ) ; Point c1 = new Point ( ( int ) ( r1 . x + r1 . width / NUM_ ) , ( int ) ( r1 . y + r1 . height / NUM_ ) ) ; Point c2 = new Point ( ( int ) ( r2 . x + r2 . width / NUM_ ) , ( int ) ( r2 . y + r2 . height / NUM_ ) ) ; double angle = Math . atan2 ( c1 . y - c2 . y , c1 . x - c2 . x ) ; angle += Math . PI / NUM_ ; Point d = new Point ( ( int ) ( offset . Math . cos ( angle ) ) , ( int ) ( offset . Math . sin ( angle ) ) ) ; c1 . translate ( d . x , d . y ) ; c2 . translate ( d . x , d . y ) ; Point p1 = getBoundaryIntersection ( comp1 , c1 , c2 ) ; Point p2 = getBoundaryIntersection ( comp2 , c2 , c1 ) ; if ( ( p1 == null ) || ( p2 == null ) ) { c1 = new Point ( ( int ) ( r1 . x + r1 . width / NUM_ ) , ( int ) ( r1 . y + r1 . height / NUM_ ) ) ; c2 = new Point ( ( int ) ( r2 . x + r2 . width / NUM_ ) , ( int ) ( r2 . y + r2 . height / NUM_ ) ) ; p1 = getBoundaryIntersection ( comp1 , c1 , c2 ) ; p2 = getBoundaryIntersection ( comp2 , c2 , c1 ) ; } if ( ( p1 == null ) || ( p2 == null ) ) { return null ; } return new PointPair ( p1 , p2 ) ; }
public static boolean isXML11Space ( int c ) { return ( c < x10000 && ( XML11CHARS [ c ] & MASK_XML11_SPACE ) != NUM_ ) ; }
public void unregisterPlayerListener ( CheerleaderPlayerListener listener ) { checkState ( ) ; mCheerleaderPlayerListeners . remove ( listener ) ; }
public OutputStream openOutputStream ( Uri uri , boolean append ) throws IOException { assertBackgroundThread ( ) ; switch ( getUriType ( uri ) ) { case URI_TYPE_FILE : { File localFile = new File ( uri . getPath ( ) ) ; File parent = localFile . getParentFile ( ) ; if ( parent != null ) { parent . mkdirs ( ) ; } return new FileOutputStream ( localFile , append ) ; } case URI_TYPE_CONTENT : case URI_TYPE_RESOURCE : { AssetFileDescriptor assetFd = contentResolver . openAssetFileDescriptor ( uri , append ? STR_ : STR_ ) ; return assetFd . createOutputStream ( ) ; } } throw new FileNotFoundException ( STR_ + uri ) ; }
protected Integer adjustIntegerValue ( Integer origValue , Integer minValue , Integer maxValue ) { Integer resultValue = origValue ; if ( resultValue . compareTo ( minValue ) < NUM_ ) { resultValue = minValue ; } if ( resultValue . compareTo ( maxValue ) > NUM_ ) { resultValue = maxValue ; } return resultValue ; }
private void initPaints ( Resources res ) { final String monthTypeface = res . getString ( R . string . date_picker_month_typeface ) ; final String dayOfWeekTypeface = res . getString ( R . string . date_picker_day_of_week_typeface ) ; final String dayTypeface = res . getString ( R . string . date_picker_day_typeface ) ; final int monthTextSize = res . getDimensionPixelSize ( R . dimen . date_picker_month_text_size ) ; final int dayOfWeekTextSize = res . getDimensionPixelSize ( R . dimen . date_picker_day_of_week_text_size ) ; final int dayTextSize = res . getDimensionPixelSize ( R . dimen . date_picker_day_text_size ) ; mMonthPaint . setAntiAlias ( BOOL_ ) ; mMonthPaint . setTextSize ( monthTextSize ) ; mMonthPaint . setTypeface ( Typeface . create ( monthTypeface , NUM_ ) ) ; mMonthPaint . setTextAlign ( Align . CENTER ) ; mMonthPaint . setStyle ( Style . FILL ) ; mDayOfWeekPaint . setAntiAlias ( BOOL_ ) ; mDayOfWeekPaint . setTextSize ( dayOfWeekTextSize ) ; mDayOfWeekPaint . setTypeface ( Typeface . create ( dayOfWeekTypeface , NUM_ ) ) ; mDayOfWeekPaint . setTextAlign ( Align . CENTER ) ; mDayOfWeekPaint . setStyle ( Style . FILL ) ; mDaySelectorPaint . setAntiAlias ( BOOL_ ) ; mDaySelectorPaint . setStyle ( Style . FILL ) ; mDayHighlightPaint . setAntiAlias ( BOOL_ ) ; mDayHighlightPaint . setStyle ( Style . FILL ) ; mDayPaint . setAntiAlias ( BOOL_ ) ; mDayPaint . setTextSize ( dayTextSize ) ; mDayPaint . setTypeface ( Typeface . create ( dayTypeface , NUM_ ) ) ; mDayPaint . setTextAlign ( Align . CENTER ) ; mDayPaint . setStyle ( Style . FILL ) ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; String childData ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; nameNode = elementList . item ( NUM_ ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; child . deleteData ( NUM_ , NUM_ ) ; childData = child . getData ( ) ; assertEquals ( STR_ , STR_ , childData ) ; }
public int size ( ) { return rules . size ( ) ; }
private void copyArrays ( ) { String [ ] oldSyms = _symbols ; int size = oldSyms . length ; _symbols = new String [ size ] ; System . arraycopy ( oldSyms , NUM_ , _symbols , NUM_ , size ) ; Bucket [ ] oldBuckets = _buckets ; size = oldBuckets . length ; _buckets = new Bucket [ size ] ; System . arraycopy ( oldBuckets , NUM_ , _buckets , NUM_ , size ) ; }
static LabelNode [ ] clone ( final List < LabelNode > labels , final Map < LabelNode , LabelNode > map ) { LabelNode [ ] clones = new LabelNode [ labels . size ( ) ] ; for ( int i = NUM_ ; i < clones . length ; ++ i ) { clones [ i ] = map . get ( labels . get ( i ) ) ; } return clones ; }
@ Procedure @ PerformsWrites @ Description ( STR_ ) public Stream < RelationshipRefactorResult > from ( @ Name ( STR_ ) Relationship rel , @ Name ( STR_ ) Node newNode ) { RelationshipRefactorResult result = new RelationshipRefactorResult ( rel . getId ( ) ) ; try { Relationship newRel = newNode . createRelationshipTo ( rel . getEndNode ( ) , rel . getType ( ) ) ; copyProperties ( rel , newRel ) ; rel . delete ( ) ; return Stream . of ( result . withOther ( newRel ) ) ; } catch ( Exception e ) { return Stream . of ( result . withError ( e ) ) ; } }
public static long maxFill ( final long n , final float f ) { return Math . min ( ( long ) Math . ceil ( n . f ) , n - NUM_ ) ; }
public static void print ( char x ) { out . print ( x ) ; out . flush ( ) ; }
public void clearSourceElements ( ) { for ( PNode node : sourceElements ) { SourceHandle . removeSourceHandleFrom ( node ) ; } sourceElements . clear ( ) ; selectionModel . fireSelectionChanged ( ) ; }
public static double [ ] [ ] readMatrix ( int numberOfRows , int numberOfColumns , boolean ignoreFirstLine , String fileName ) { double [ ] [ ] matrix = new double [ numberOfRows ] [ numberOfColumns ] ; try { FileReader fr = new FileReader ( fileName ) ; BufferedReader br = new BufferedReader ( fr ) ; String line ; StringTokenizer tokenizer ; String token ; if ( ignoreFirstLine ) { br . readLine ( ) ; } line = br . readLine ( ) ; int rowId = NUM_ ; while ( line != null ) { tokenizer = new StringTokenizer ( line ) ; for ( int i = NUM_ ; i < numberOfColumns ; i ++ ) { token = tokenizer . nextToken ( ) ; double parsedNumber = Double . parseDouble ( token ) ; matrix [ rowId ] [ i ] = parsedNumber ; } if ( tokenizer . hasMoreTokens ( ) ) { throw new RuntimeException ( STR_ ) ; } line = br . readLine ( ) ; rowId ++ ; } if ( rowId != numberOfRows ) { throw new RuntimeException ( STR_ ) ; } } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new RuntimeException ( STR_ ) ; } return matrix ; }
@ Override protected boolean readIntoBuffer ( int minLength ) { if ( bufferSpaceLeft ( ) < minLength ) { increaseBufferSize ( minLength + currentlyInBuffer ( ) ) ; } else if ( buf . length - writePos < minLength ) { compact ( ) ; } int readSum = NUM_ ; while ( readSum < minLength && ! datagrams . isEmpty ( ) ) { Datagram next = datagrams . removeFirst ( ) ; int length = ( int ) next . getDuration ( ) ; if ( buf . length < writePos + length ) { increaseBufferSize ( writePos + length ) ; } int read = readDatagram ( next , buf , writePos ) ; writePos += read ; readSum += read ; } if ( dataProcessor != null ) { dataProcessor . applyInline ( buf , writePos - readSum , readSum ) ; } return readSum >= minLength ; }
@ NotNull public ClarifaiClient buildSync ( ) { return new ClarifaiClientImpl ( this ) ; }
public void mouseReleased ( MouseEvent e ) { VisualizationViewer < ? , ? > vv = ( VisualizationViewer < ? , ? > ) e . getSource ( ) ; down = null ; vv . setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; }
@ Nullable public static Class < ? > classForName ( @ Nullable String cls , @ Nullable Class < ? > dflt , boolean includePrimitiveTypes ) { Class < ? > clazz ; if ( cls == null ) clazz = dflt ; else if ( ! includePrimitiveTypes || cls . length ( ) > NUM_ || ( clazz = primitiveMap . get ( cls ) ) == null ) { try { clazz = Class . forName ( cls ) ; } catch ( ClassNotFoundException ignore ) { clazz = dflt ; } } return clazz ; }
public String checkWriteProtected ( int resIdAction , final File ... filesToBeModified ) { if ( filesToBeModified != null ) { for ( File file : filesToBeModified ) { if ( ( file != null ) && ( file . exists ( ) ) && ( ! file . canWrite ( ) ) ) { String action = ( resIdAction == NUM_ ) ? STR_ : mContext . getString ( resIdAction ) ; return mContext . getString ( R . string . file_err_writeprotected , file . getAbsolutePath ( ) , action ) ; } } } return null ; }
private int clampMag ( int value , int absMin , int absMax ) { final int absValue = Math . abs ( value ) ; if ( absValue < absMin ) return NUM_ ; if ( absValue > absMax ) return value > NUM_ ? absMax : - absMax ; return value ; }
@ NotNull @ Contract ( pure = BOOL_ ) public static String strip ( @ NotNull final String s , @ NotNull final CharFilter filter ) { final StringBuilder result = new StringBuilder ( s . length ( ) ) ; for ( int i = NUM_ ; i < s . length ( ) ; i ++ ) { char ch = s . charAt ( i ) ; if ( filter . accept ( ch ) ) { result . append ( ch ) ; } } return result . toString ( ) ; }
protected void addComponent ( XMLComponent component ) { if ( fComponents . contains ( component ) ) { return ; } fComponents . add ( component ) ; addRecognizedParamsAndSetDefaults ( component ) ; }
public void testLocalInstances_distribution ( ) { MatsimRandom . reset ( NUM_ ) ; Random local1a = MatsimRandom . getLocalInstance ( ) ; double value1 = local1a . nextDouble ( ) ; MatsimRandom . reset ( NUM_ ) ; Random local2a = MatsimRandom . getLocalInstance ( ) ; double value2a = local2a . nextDouble ( ) ; Random local2b = MatsimRandom . getLocalInstance ( ) ; double value2b = local2b . nextDouble ( ) ; assertTrue ( Math . abs ( value1 - value2a ) > EPSILON ) ; assertTrue ( Math . abs ( value2a - value2b ) > EPSILON ) ; assertTrue ( Math . abs ( value1 - value2b ) > EPSILON ) ; }
public final void test_ROUNDTRIP_GetKeySpecKey02 ( ) { boolean performed = BOOL_ ; for ( int i = NUM_ ; i < algName . length ; i ++ ) { try { TestDataGenerator g = new TestDataGenerator ( algName [ i ] [ NUM_ ] , algName [ i ] [ NUM_ ] , privateKeyInfoDamaged , null ) ; EncryptedPrivateKeyInfo epki ; if ( g . ap ( ) == null ) { epki = new EncryptedPrivateKeyInfo ( algName [ i ] [ NUM_ ] , g . ct ( ) ) ; } else { epki = new EncryptedPrivateKeyInfo ( g . ap ( ) , g . ct ( ) ) ; } try { epki . getKeySpec ( g . pubK ( ) == null ? g . k ( ) : g . pubK ( ) ) ; fail ( algName [ i ] [ NUM_ ] + STR_ + algName [ i ] [ NUM_ ] ) ; } catch ( InvalidKeyException e ) { } performed = BOOL_ ; } catch ( TestDataGenerator . AllowedFailure allowedFailure ) { } catch ( NoSuchAlgorithmException allowedFailure ) { } } assertTrue ( STR_ , performed ) ; }
public void clear ( IValidatable bean ) { for ( Binding b : _optComponents . values ( ) ) { b . clear ( bean ) ; } for ( Binding b : _bindings . values ( ) ) { b . clear ( bean ) ; } _modified = BOOL_ ; }
public boolean hasCredentials ( ) { return _hasCredentials ; }
public boolean isRecursiveAttrSet ( ElemAttributeSet attrSet ) { if ( null == m_attrSetStack ) { m_attrSetStack = new Stack ( ) ; } if ( ! m_attrSetStack . empty ( ) ) { int loc = m_attrSetStack . search ( attrSet ) ; if ( loc > - NUM_ ) { return BOOL_ ; } } return BOOL_ ; }
public void clear ( AbsoluteTableIdentifier absoluteTableIdentifier ) { tableLockMap . remove ( absoluteTableIdentifier ) ; tableSegmentMap . remove ( absoluteTableIdentifier ) ; }
public int enumerate ( Thread [ ] threads ) { return enumerate ( threads , BOOL_ ) ; }
public static InputStream toInputStream ( CharSequence input ) { return toInputStream ( input . toString ( ) ) ; }
@ Override public void process ( Number tuple ) { values . add ( tuple . doubleValue ( ) ) ; }
public void grantWritePermission ( Collection attributeNames ) { Iterator it = attributeNames . iterator ( ) ; if ( it != null ) { while ( it . hasNext ( ) ) { String temp = ( String ) it . next ( ) ; writables . add ( temp . toLowerCase ( ) ) ; } } }
public void saveData ( File file ) throws IOException { synchronized ( accumulators ) { ObjectOutputStream oos = null ; try { oos = new ObjectOutputStream ( new FileOutputStream ( file ) ) ; oos . writeObject ( accumulators ) ; } finally { if ( oos != null ) { oos . close ( ) ; } } } }
public static Ingredient fromCursor ( Cursor cursor ) { Ingredient ingredient = new Ingredient ( ) ; for ( int c = NUM_ ; c < cursor . getColumnCount ( ) ; c ++ ) { String columnName = cursor . getColumnName ( c ) ; if ( columnName . equals ( RecipeIngredientTable . AMOUNT_COLUMN ) ) { ingredient . setAmount ( cursor . getString ( c ) ) ; } else if ( columnName . equals ( RecipeIngredientTable . DESCRIPTION_COLUMN ) ) { ingredient . setDescription ( cursor . getString ( c ) ) ; } } return ingredient ; }
public void append ( char c [ ] , int off , int len ) { int restLength = buffer . length - pos ; if ( len < restLength ) { System . arraycopy ( c , off , buffer , pos , len ) ; pos += len ; } else { System . arraycopy ( c , off , buffer , pos , restLength ) ; curr . next = new Entity ( buffer ) ; curr = curr . next ; length += buffer . length ; buffer = new char [ ( buffer . length > len - restLength ) ? buffer . length : len - restLength ] ; System . arraycopy ( c , off + restLength , buffer , NUM_ , len - restLength ) ; pos = len - restLength ; } }
public boolean contains ( String voiceName ) { return ( getVoice ( voiceName ) != null ) ; }
public static boolean isEnterpriseEdition ( String serverVersion ) { return serverVersion . contains ( STR_ ) || serverVersion . contains ( STR_ ) || serverVersion . contains ( STR_ ) ; }
public static boolean createFolder ( @ SuppressWarnings ( STR_ ) Context mContext , String path , String folderName ) { File SDCardRoot = new File ( path , folderName ) ; if ( ! SDCardRoot . exists ( ) ) { return SDCardRoot . mkdir ( ) ; } return BOOL_ ; }
private static NSObject parseObject ( Node n ) throws ParseException , IOException { String type = n . getNodeName ( ) ; if ( type . equals ( STR_ ) ) { NSDictionary dict = new NSDictionary ( ) ; List < Node > children = filterElementNodes ( n . getChildNodes ( ) ) ; for ( int i = NUM_ ; i < children . size ( ) ; i += NUM_ ) { Node key = children . get ( i ) ; Node val = children . get ( i + NUM_ ) ; String keyString = getNodeTextContents ( key ) ; dict . put ( keyString , parseObject ( val ) ) ; } return dict ; } else if ( type . equals ( STR_ ) ) { List < Node > children = filterElementNodes ( n . getChildNodes ( ) ) ; NSArray array = new NSArray ( children . size ( ) ) ; for ( int i = NUM_ ; i < children . size ( ) ; i ++ ) { array . setValue ( i , parseObject ( children . get ( i ) ) ) ; } return array ; } else if ( type . equals ( STR_ ) ) { return new NSNumber ( BOOL_ ) ; } else if ( type . equals ( STR_ ) ) { return new NSNumber ( BOOL_ ) ; } else if ( type . equals ( STR_ ) ) { return new NSNumber ( getNodeTextContents ( n ) ) ; } else if ( type . equals ( STR_ ) ) { return new NSNumber ( getNodeTextContents ( n ) ) ; } else if ( type . equals ( STR_ ) ) { return new NSString ( getNodeTextContents ( n ) ) ; } else if ( type . equals ( STR_ ) ) { return new NSData ( getNodeTextContents ( n ) ) ; } else if ( type . equals ( STR_ ) ) { return new NSDate ( getNodeTextContents ( n ) ) ; } return null ; }
LuaString loadString ( ) throws IOException { int size = this . luacSizeofSizeT == NUM_ ? ( int ) loadInt64 ( ) : loadInt ( ) ; if ( size == NUM_ ) return null ; byte [ ] bytes = new byte [ size ] ; is . readFully ( bytes , NUM_ , size ) ; return LuaString . valueOf ( bytes , NUM_ , bytes . length - NUM_ ) ; }
protected AbstractPreferences ( AbstractPreferences parent , String name ) { if ( parent == null ) { if ( ! name . equals ( STR_ ) ) throw new IllegalArgumentException ( STR_ + name + STR_ ) ; this . absolutePath = STR_ ; root = this ; } else { if ( name . indexOf ( STR_ ) != - NUM_ ) throw new IllegalArgumentException ( STR_ + name + STR_ ) ; if ( name . equals ( STR_ ) ) throw new IllegalArgumentException ( STR_ ) ; root = parent . root ; absolutePath = ( parent == root ? STR_ + name : parent . absolutePath ( ) + STR_ + name ) ; } this . name = name ; this . parent = parent ; }
static Class < ? > canonicalize ( Class < ? > t , int how ) { Class < ? > ct ; if ( t == Object . class ) { } else if ( ! t . isPrimitive ( ) ) { switch ( how ) { case UNWRAP : ct = Wrapper . asPrimitiveType ( t ) ; if ( ct != t ) return ct ; break ; case RAW_RETURN : case ERASE : return Object . class ; } } else if ( t == void . class ) { switch ( how ) { case RAW_RETURN : return int . class ; case WRAP : return Void . class ; } } else { switch ( how ) { case WRAP : return Wrapper . asWrapperType ( t ) ; case INTS : if ( t == int . class || t == long . class ) return null ; if ( t == double . class ) return long . class ; return int . class ; case LONGS : if ( t == long . class ) return null ; return long . class ; case RAW_RETURN : if ( t == int . class || t == long . class || t == float . class || t == double . class ) return null ; return int . class ; } } return null ; }
protected String extractSubstring ( String pszSrc ) { int nBracket = NUM_ ; int i ; String pszReturn ; for ( i = NUM_ ; i < pszSrc . length ( ) && ( nBracket > NUM_ || pszSrc . charAt ( i ) != STR_ ) ; i ++ ) { if ( pszSrc . charAt ( i ) == STR_ ) { nBracket ++ ; } else if ( pszSrc . charAt ( i ) == STR_ ) { nBracket -- ; } } if ( pszSrc . charAt ( NUM_ ) == STR_ ) { pszReturn = pszSrc . substring ( NUM_ , i - NUM_ ) ; } else { pszReturn = pszSrc . substring ( NUM_ , i ) ; } return pszReturn ; }
public void read ( Appendable dest ) throws IOException { if ( _inputStream == null ) throw new IOException ( STR_ ) ; while ( BOOL_ ) { if ( _start >= _end ) { _start = NUM_ ; _end = _inputStream . read ( _bytes , NUM_ , _bytes . length ) ; if ( _end <= NUM_ ) { break ; } } byte b = _bytes [ _start ] ; if ( b >= NUM_ ) { dest . append ( ( char ) b ) ; _start ++ ; } else { int code = read2 ( ) ; if ( code < x10000 ) { dest . append ( ( char ) code ) ; } else if ( code <= x10ffff ) { dest . append ( ( char ) ( ( ( code - x10000 ) > > NUM_ ) + xd800 ) ) ; dest . append ( ( char ) ( ( ( code - x10000 ) & x3ff ) + xdc00 ) ) ; } else { throw new CharConversionException ( STR_ + Integer . toHexString ( code ) + STR_ ) ; } } } }
public boolean isMonitoring ( ) { return m_Monitor . isMonitoring ( ) ; }
static final Color hexToColor ( String value ) { String digits ; int n = value . length ( ) ; if ( value . startsWith ( STR_ ) ) { digits = value . substring ( NUM_ , Math . min ( value . length ( ) , NUM_ ) ) ; } else { digits = value ; } String hstr = STR_ + digits ; Color c ; try { c = Color . decode ( hstr ) ; } catch ( NumberFormatException nfe ) { c = null ; } return c ; }
public final boolean contentEquals ( java . lang . CharSequence csq ) { if ( csq . length ( ) != _length ) return BOOL_ ; for ( int i = NUM_ ; i < _length ; ) { char c = _high [ i > > B1 ] [ i & M1 ] ; if ( csq . charAt ( i ++ ) != c ) return BOOL_ ; } return BOOL_ ; }
private void populateAvailableDataStores ( ) { DataAccessFactory fac ; logger . debug ( STR_ ) ; Iterator < DataStoreFactorySpi > iterator = DataStoreFinder . getAvailableDataStores ( ) ; while ( iterator . hasNext ( ) ) { fac = ( DataAccessFactory ) iterator . next ( ) ; logger . debug ( STR_ + fac . getDisplayName ( ) ) ; availableDataStoreList . add ( fac . getDisplayName ( ) ) ; } }
protected void add ( double value , int group ) { if ( ( group < NUM_ ) || ( group >= numberOfGroups ) ) { throw new IllegalArgumentException ( STR_ ) ; } data . add ( new Observation ( value , group ) ) ; }
protected static String makeOptionString ( Script script ) { StringBuffer result ; Enumeration < Option > enm ; Option option ; result = new StringBuffer ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; enm = script . listOptions ( ) ; while ( enm . hasMoreElements ( ) ) { option = enm . nextElement ( ) ; result . append ( option . synopsis ( ) + STR_ ) ; result . append ( option . description ( ) + STR_ ) ; } result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; return result . toString ( ) ; }
public RegistrationBuilder addContact ( URI contact ) { contacts . add ( contact ) ; return this ; }
public static void closeQuietly ( AutoCloseable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( RuntimeException rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } }
String formatTime ( int hour , int minute ) { String s = STR_ ; String t = Integer . toString ( hour ) ; if ( t . length ( ) == NUM_ ) { s = t + STR_ ; } else if ( t . length ( ) == NUM_ ) { s = STR_ + t + STR_ ; } t = Integer . toString ( minute ) ; if ( t . length ( ) == NUM_ ) { s = s + t ; } else if ( t . length ( ) == NUM_ ) { s = s + STR_ + t ; } if ( s . length ( ) != NUM_ ) { s = STR_ ; } return s ; }
public boolean isEmpty ( ) { return ( sentenceType == SentenceType . UNDEFINED ) && expressions . isEmpty ( ) ; }
@ Override public void init ( AbstractAddressbookManager aBooMgr ) { setAddressBookManager ( aBooMgr ) ; reloadSettings ( ) ; try { connection = DriverManager . getConnection ( IDENTITYDB_CONNECT_STRING ) ; } catch ( SQLException e ) { logger . error ( STR_ + IDENTITYDB_CONNECT_STRING , e ) ; } Statement statement ; try { statement = connection . createStatement ( ) ; statement . setQueryTimeout ( NUM_ ) ; statement . executeUpdate ( STR_ + TABLE_IDENTITY + STR_ ) ; statement . executeUpdate ( STR_ + TABLE_CLOUDPROVIDER + STR_ ) ; statement . executeUpdate ( STR_ + TABLE_CLOUDPROVIDER_MAP + STR_ ) ; aBooMgr . init ( ) ; } catch ( SQLException e ) { logger . error ( STR_ , e ) ; } finally { if ( connection != null ) { try { connection . close ( ) ; } catch ( SQLException e ) { logger . error ( STR_ , e ) ; } } } }
private Buffer checkErrorPacket ( int command ) throws SQLException { Buffer resultPacket = null ; this . serverStatus = NUM_ ; try { resultPacket = reuseAndReadPacket ( this . reusablePacket ) ; } catch ( SQLException sqlEx ) { throw sqlEx ; } catch ( Exception fallThru ) { throw SQLError . createCommunicationsException ( this . connection , this . lastPacketSentTimeMs , this . lastPacketReceivedTimeMs , fallThru , getExceptionInterceptor ( ) ) ; } checkErrorPacket ( resultPacket ) ; return resultPacket ; }
public void applySettings ( boolean loadCoreComponents ) throws ApplySettingsException { List < String > errors = new ArrayList < String > ( NUM_ ) ; applyTorrentDataSaveFolderSettings ( errors ) ; applyTorrentSeedingSettings ( errors ) ; if ( ! errors . isEmpty ( ) ) { throw new ApplySettingsException ( StringUtils . explode ( errors , STR_ ) ) ; } }
public boolean shouldSelectCell ( EventObject e ) { return BOOL_ ; }
private int measureShort ( int measureSpec ) { int result ; int specMode = MeasureSpec . getMode ( measureSpec ) ; int specSize = MeasureSpec . getSize ( measureSpec ) ; if ( specMode == MeasureSpec . EXACTLY ) { result = specSize ; } else { result = ( int ) ( NUM_ . mRadius + getPaddingTop ( ) + getPaddingBottom ( ) + NUM_ ) ; if ( specMode == MeasureSpec . AT_MOST ) { result = Math . min ( result , specSize ) ; } } return result ; }
private void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject ( ) ; if ( resourceBundleName != null ) { try { rb = ResourceBundle . getBundle ( resourceBundleName ) ; } catch ( MissingResourceException e ) { rb = null ; } } }
method_info findMethod ( String s ) { method_info m ; int i ; for ( i = NUM_ ; i < methods_count ; i ++ ) { m = methods [ i ] ; if ( s . equals ( m . toName ( constant_pool ) ) ) { return m ; } } return null ; }
private boolean matches ( @ Nullable Object obj , String operator , String operandStr ) { ObsValue value ; if ( obj == null ) { switch ( operator ) { case STR_ : case STR_ : case STR_ : return operandStr . isEmpty ( ) ; default : return BOOL_ ; } } else if ( obj instanceof ObsPoint ) { value = ( ( ObsPoint ) obj ) . value ; } else if ( obj instanceof ObsValue ) { value = ( ObsValue ) obj ; } else return BOOL_ ; ObsValue operand = null ; if ( value . uuid != null ) { operand = ObsValue . newCoded ( Utils . expandUuid ( operandStr ) ) ; } else if ( value . number != null ) { try { operand = ObsValue . newNumber ( Double . valueOf ( operandStr ) ) ; } catch ( NumberFormatException e ) { operand = ObsValue . ZERO ; } } else if ( value . text != null ) { operand = ObsValue . newText ( operandStr ) ; } else if ( value . date != null ) { try { operand = ObsValue . newDate ( LocalDate . parse ( operandStr ) ) ; } catch ( IllegalArgumentException e ) { operand = ObsValue . MIN_DATE ; } } else if ( value . instant != null ) { try { operand = ObsValue . newTime ( Long . valueOf ( operandStr ) ) ; } catch ( IllegalArgumentException e ) { operand = ObsValue . MIN_TIME ; } } switch ( operator ) { case STR_ : case STR_ : case STR_ : return Objects . equal ( value . uuid , operand . uuid ) ; case STR_ : return value . compareTo ( operand ) < NUM_ ; case STR_ : return value . compareTo ( operand ) <= NUM_ ; case STR_ : return value . compareTo ( operand ) > NUM_ ; case STR_ : return value . compareTo ( operand ) >= NUM_ ; } return BOOL_ ; }
private void waitUntilReadable ( ) throws IOException { readTimeout . enter ( ) ; try { while ( readBuffer . size ( ) == NUM_ && ! finished && ! closed && errorCode == null ) { waitForIo ( ) ; } } finally { readTimeout . exitAndThrowIfTimedOut ( ) ; } }
public static < X extends Exception > String toString ( Iteration < ? , X > iter , String separator ) throws X { StringBuilder sb = new StringBuilder ( ) ; toString ( iter , separator , sb ) ; return sb . toString ( ) ; }
@ SuppressWarnings ( STR_ ) @ Override public boolean contains ( final Object obj ) { if ( null != obj ) { Iterator < E > it = new ArrayDequeIterator < E > ( ) ; while ( it . hasNext ( ) ) { if ( obj . equals ( ( E ) it . next ( ) ) ) { return BOOL_ ; } } } return BOOL_ ; }
public static synchronized GridTestPrintStream acquireErr ( ) { if ( testErr == null ) testErr = new GridTestPrintStream ( sysErr ) ; if ( errCnt == NUM_ ) System . setErr ( testErr ) ; errCnt ++ ; return testErr ; }
private void writeObject ( ObjectOutputStream out ) throws IOException { out . defaultWriteObject ( ) ; doWriteObject ( out ) ; }
private static boolean isPropertyName ( String name ) { return ( ( name . length ( ) > NUM_ ) && Character . isUpperCase ( name . charAt ( NUM_ ) ) ) || ( ( name . length ( ) > NUM_ ) && Character . isUpperCase ( name . charAt ( NUM_ ) ) ) ; }
public Collection < ExpressionObject < ? > > analyzeExpression ( GenericPK id , Expression formula , ExpressionAST expression ) throws ScopeException { ExtractReferences visitor = new ExtractReferences ( ) ; List < ExpressionRef > references = visitor . apply ( expression ) ; String internal = rewriteExpressionValue ( formula . getValue ( ) , expression , references ) ; if ( ! internal . equals ( formula . getValue ( ) ) ) { formula . setInternal ( internal ) ; } else { formula . setInternal ( null ) ; } int level = computeReferenceTree ( expression , references ) ; formula . setLevel ( level ) ; Collection < ExpressionObject < ? > > objects = new HashSet < > ( ) ; for ( ExpressionRef expr : references ) { Object ref = expr . getReference ( ) ; if ( ref != null && ref instanceof Property ) { Property property = ( Property ) ref ; ExpressionObject < ? > object = property . getExpressionObject ( ) ; if ( object != null ) { objects . add ( object ) ; } } } if ( ! objects . isEmpty ( ) ) { Collection < ExpressionObject < ? > > closure = null ; Collection < ExpressionObject < ? > > transitiveClosure = objects ; do { closure = transitiveClosure ; transitiveClosure = transitiveClosure ( id , closure ) ; } while ( closure . size ( ) < transitiveClosure . size ( ) ) ; Collection < ReferencePK < ? > > IDs = new HashSet < > ( ) ; for ( ExpressionObject < ? > object : transitiveClosure ) { ReferencePK < ? > refPk = reference ( object ) ; if ( refPk != null ) { IDs . add ( refPk ) ; } } formula . setReferences ( IDs ) ; return transitiveClosure ; } else { return objects ; } }
public void removeRtcpListener ( RtcpEventListener listener ) { if ( sLogger . isActivated ( ) ) { sLogger . debug ( STR_ ) ; } mListeners . removeElement ( listener ) ; }
private static void collectAllTimes ( Tree tree , NodeRef node , NodeRef [ ] excludeBelow , ArrayList times , ArrayList < Integer > childs ) { times . add ( new ComparableDouble ( tree . getNodeHeight ( node ) ) ) ; childs . add ( tree . getChildCount ( node ) ) ; for ( int i = NUM_ ; i < tree . getChildCount ( node ) ; i ++ ) { NodeRef child = tree . getChild ( node , i ) ; if ( excludeBelow == null ) { collectAllTimes ( tree , child , excludeBelow , times , childs ) ; } else { boolean include = BOOL_ ; for ( NodeRef anExcludeBelow : excludeBelow ) { if ( anExcludeBelow . getNumber ( ) == child . getNumber ( ) ) { include = BOOL_ ; break ; } } if ( include ) collectAllTimes ( tree , child , excludeBelow , times , childs ) ; } } }
protected void paintText ( final Graphics g , final JComponent c , final Rectangle localTextRect , final String text ) { final Graphics2D g2d = g instanceof Graphics2D ? ( Graphics2D ) g : null ; final AbstractButton b = ( AbstractButton ) c ; final ButtonModel model = b . getModel ( ) ; final FontMetrics fm = g . getFontMetrics ( ) ; final int mnemonicIndex = AquaMnemonicHandler . isMnemonicHidden ( ) ? - NUM_ : b . getDisplayedMnemonicIndex ( ) ; if ( model . isEnabled ( ) ) { g . setColor ( b . getForeground ( ) ) ; } else { g . setColor ( defaultDisabledTextColor ) ; } SwingUtilities2 . drawStringUnderlineCharAt ( c , g , text , mnemonicIndex , localTextRect . x , localTextRect . y + fm . getAscent ( ) ) ; }
public static ConstraintWidget [ ] inferTableList ( WidgetsScene list ) { for ( ConstraintWidget widget : list . getWidgets ( ) ) { widget . resetAnchors ( ) ; } return inferTableList ( list . getRoot ( ) ) ; }
public String toXMLString ( boolean includeNS , boolean declareNS ) throws FSMsgException { return toXMLString ( includeNS , declareNS , BOOL_ ) ; }
public void ifPresent ( LongConsumer consumer ) { if ( isPresent ) consumer . accept ( value ) ; }
public void update ( String [ ] columns , Object [ ] columnValues , String [ ] conditions , Object [ ] conditionValues ) throws DataAccessException { if ( columns . length != columnValues . length || conditions . length != conditionValues . length ) { logger . error ( STR_ ) ; return ; } Object [ ] values = Arrays . copyOf ( columnValues , columnValues . length + conditionValues . length ) ; System . arraycopy ( conditionValues , NUM_ , values , columnValues . length , conditionValues . length ) ; final String sql = PreparedStatementUtil . prepareUpdateTemplateWithColumn ( tableName , columns , conditions ) ; execute ( sql , values ) ; }
public static String replicaSetUsedIn ( String addresses ) { if ( addresses . startsWith ( STR_ ) ) { return null ; } int index = addresses . indexOf ( STR_ ) ; if ( index < NUM_ ) return null ; return addresses . substring ( NUM_ , index ) ; }
public void onProgress ( long bytesWritten , long totalSize ) { Log . v ( LOG_TAG , String . format ( STR_ , bytesWritten , totalSize , ( totalSize > NUM_ ) ? ( bytesWritten . NUM_ / totalSize ) . NUM_ : - NUM_ ) ) ; }
public String self ( TypeDeclaration decl ) { if ( decl instanceof Constructor ) { decl = ( TypeDeclaration ) decl . getContainer ( ) ; } String name = JsUtils . escapeStringLiteral ( decl . getName ( ) ) ; if ( decl . isShared ( ) || decl . isToplevel ( ) ) { name += nestingSuffix ( decl , BOOL_ ) ; } else { name = STR_ + Long . toString ( getUID ( decl ) , NUM_ ) ; } return String . format ( STR_ , Character . toLowerCase ( name . charAt ( NUM_ ) ) , name . substring ( NUM_ ) ) ; }
public double elapsedTime ( ) { long now = threadTimer . getCurrentThreadCpuTime ( ) ; return ( now - start ) / NANOSECONDS_PER_SECOND ; }
public static void sortList ( List list ) { if ( SystemUtils . IS_JAVA_1_7 && list instanceof CopyOnWriteArrayList ) { List tempList = new ArrayList ( list ) ; Collections . sort ( tempList ) ; list . clear ( ) ; list . addAll ( tempList ) ; } else { Collections . sort ( list ) ; } }
public void fireIndexedPropertyChange ( String propertyName , int index , boolean oldValue , boolean newValue ) { if ( oldValue != newValue ) { fireIndexedPropertyChange ( propertyName , index , Boolean . valueOf ( oldValue ) , Boolean . valueOf ( newValue ) ) ; } }
public static < T > T [ ] concat ( T [ ] first , T [ ] second , Class < T > type ) { T [ ] result = newArray ( type , first . length + second . length ) ; System . arraycopy ( first , NUM_ , result , NUM_ , first . length ) ; System . arraycopy ( second , NUM_ , result , first . length , second . length ) ; return result ; }
public synchronized void writeToRemote ( byte b ) { remoteBuffer . add ( b ) ; }
@ Override public void drawSeries ( Canvas canvas , Paint paint , List < Float > points , List < Double > values , XYSeriesRenderer seriesRenderer , SupportSeriesRender supportSeriesRender , float yAxisValue , int seriesIndex , int startIndex ) { int seriesNr = mDataset . getSeriesCount ( ) ; int length = points . size ( ) ; paint . setColor ( seriesRenderer . getColor ( ) ) ; paint . setStyle ( Style . FILL ) ; float halfDiffX = getHalfDiffX ( points , length , seriesNr ) ; int start = NUM_ ; if ( startIndex > NUM_ ) { start = NUM_ ; } for ( int i = start ; i < length ; i += NUM_ ) { if ( points . size ( ) > i + NUM_ ) { float xMin = points . get ( i ) ; float yMin = points . get ( i + NUM_ ) ; float xMax = points . get ( i + NUM_ ) ; float yMax = points . get ( i + NUM_ ) ; drawBar ( canvas , xMin , yMin , xMax , yMax , halfDiffX , seriesNr , seriesIndex , paint ) ; } } paint . setColor ( seriesRenderer . getColor ( ) ) ; }
private void beginGesture ( int scrollOffsetY , int scrollExtentY ) { mInitialTranslationY = getTranslationY ( ) ; boolean isInitiallyVisible = mInitialTranslationY < mTotalHeight ; int startingY = isInitiallyVisible ? scrollOffsetY : Math . min ( scrollOffsetY , mTotalHeight ) ; mInitialOffsetY = startingY + scrollExtentY ; }
@ Override public void add ( String ... identifiers ) { whitelist . addAll ( Arrays . asList ( identifiers ) ) ; }
public static void clear ( ) { shopId . set ( NUM_ ) ; shopCode . set ( STR_ ) ; }
@ Override public boolean communicationInitiated ( ) { return bugsPopulated . getCount ( ) == NUM_ && communicationInitiated && networkClient . ready ( ) ; }
public static Charset toCharset ( Charset charset ) { return charset == null ? Charset . defaultCharset ( ) : charset ; }
@ Override public void dump ( String prefix , FileDescriptor fd , PrintWriter writer , String [ ] args ) { super . dump ( prefix , fd , writer , args ) ; writer . print ( prefix ) ; writer . print ( STR_ ) ; writer . println ( rawQuery ) ; writer . print ( prefix ) ; writer . print ( STR_ ) ; writer . println ( Arrays . toString ( args ) ) ; }
public void addContigField ( ContigField field ) { addIdField ( mContigLines , field ) ; }
boolean removeIndexEntry ( String resourceName , String policyName ) { Iterator iter = topLevelEntries . iterator ( ) ; boolean processed = BOOL_ ; while ( ! processed && ( iter . hasNext ( ) ) ) { ResourceIndexEntry resourceIndexEntry = ( ResourceIndexEntry ) iter . next ( ) ; if ( resourceIndexEntry . removeIndexEntry ( resourceType , resourceName , policyName ) ) { processed = BOOL_ ; } } return processed ; }
public static double pdf ( double x , double mu , double shape ) { if ( ! ( x > NUM_ ) || x == Double . POSITIVE_INFINITY ) { return NUM_ ; } final double v = ( x - mu ) / mu ; double t1 = Math . sqrt ( shape / ( MathUtil . TWOPI . x . x . x ) ) ; return t1 > NUM_ ? t1 . Math . exp ( - shape . v . v . NUM_ / x ) : NUM_ ; }
@ Override public void onStopTrackingTouch ( SeekBar seekBar ) { final int pos = mItemList . indexOf ( mSelectedTracker ) ; final int delta = NUM_ / mItemList . size ( ) ; cp_mover . setProgress ( pos . delta + delta / NUM_ ) ; }
public static int maxProfit ( int [ ] prices ) { if ( prices == null || prices . length < NUM_ ) { return NUM_ ; } int max = NUM_ ; int min = prices [ NUM_ ] ; for ( int i = NUM_ ; i < prices . length ; i ++ ) { min = Math . min ( min , prices [ i ] ) ; if ( prices [ i ] > prices [ i - NUM_ ] ) { max = Math . max ( max , prices [ i ] - min ) ; } } return max ; }
public void add ( String string ) { elements . add ( string == null ? JsonNull . INSTANCE : new JsonPrimitive ( string ) ) ; }
public void componentAdded ( ContainerEvent e ) { Layer childLayer = ( Layer ) e . getChild ( ) ; addProjectionListener ( childLayer ) ; if ( ! removedLayers . removeElement ( childLayer ) ) { addedLayers . addElement ( childLayer ) ; } changeLayers ( e ) ; }
public void processingInstruction ( String target , String data ) throws SAXException { charactersFlush ( ) ; int dataIndex = m_data . size ( ) ; m_previous = addNode ( DTM . PROCESSING_INSTRUCTION_NODE , DTM . PROCESSING_INSTRUCTION_NODE , m_parents . peek ( ) , m_previous , - dataIndex , BOOL_ ) ; m_data . addElement ( m_valuesOrPrefixes . stringToIndex ( target ) ) ; m_values . addElement ( data ) ; m_data . addElement ( m_valueIndex ++ ) ; }
protected void panic ( String msg ) throws SAXException { SAXParseException spe = new SAXParseException ( msg , this ) ; mHandErr . fatalError ( spe ) ; throw spe ; }
private void updateNamespacePermissions ( UserNamespaceAuthorizationEntity userNamespaceAuthorizationEntity , List < NamespacePermissionEnum > namespacePermissions ) { userNamespaceAuthorizationEntity . setReadPermission ( namespacePermissions . contains ( NamespacePermissionEnum . READ ) ) ; userNamespaceAuthorizationEntity . setWritePermission ( namespacePermissions . contains ( NamespacePermissionEnum . WRITE ) ) ; userNamespaceAuthorizationEntity . setExecutePermission ( namespacePermissions . contains ( NamespacePermissionEnum . EXECUTE ) ) ; userNamespaceAuthorizationEntity . setGrantPermission ( namespacePermissions . contains ( NamespacePermissionEnum . GRANT ) ) ; }
public static void report ( ) { if ( ! booted ) return ; ControllerThread . report ( ) ; RuntimeMeasurements . report ( ) ; for ( Enumeration < Organizer > e = organizers . elements ( ) ; e . hasMoreElements ( ) ; ) { Organizer organizer = e . nextElement ( ) ; organizer . report ( ) ; } if ( options . FINAL_REPORT_LEVEL >= NUM_ ) { EdgeCounts . dumpCounts ( ) ; dcg . dumpGraph ( ) ; } if ( options . REPORT_INTERRUPT_STATS ) { VM . sysWriteln ( STR_ ) ; VM . sysWriteln ( STR_ , RVMThread . timerTicks ) ; VM . sysWriteln ( STR_ , controllerClock ) ; VM . sysWriteln ( STR_ , ( int ) methodSamples . getTotalNumberOfSamples ( ) ) ; } }
public static Set < ? > convertArrayToSet ( Object [ ] source ) { Set < Object > set = new HashSet < Object > ( ) ; for ( Object element : source ) { set . add ( element ) ; } return set ; }
public static int intersectLineRectangle ( Line2D l , Rectangle2D r , Point2D [ ] pts ) { double a1x = l . getX1 ( ) , a1y = l . getY1 ( ) ; double a2x = l . getX2 ( ) , a2y = l . getY2 ( ) ; double mxx = r . getMaxX ( ) , mxy = r . getMaxY ( ) ; double mnx = r . getMinX ( ) , mny = r . getMinY ( ) ; if ( pts [ NUM_ ] == null ) pts [ NUM_ ] = new Point2D . Double ( ) ; if ( pts [ NUM_ ] == null ) pts [ NUM_ ] = new Point2D . Double ( ) ; int i = NUM_ ; if ( intersectLineLine ( mnx , mny , mxx , mny , a1x , a1y , a2x , a2y , pts [ i ] ) > NUM_ ) i ++ ; if ( intersectLineLine ( mxx , mny , mxx , mxy , a1x , a1y , a2x , a2y , pts [ i ] ) > NUM_ ) i ++ ; if ( i == NUM_ ) return i ; if ( intersectLineLine ( mxx , mxy , mnx , mxy , a1x , a1y , a2x , a2y , pts [ i ] ) > NUM_ ) i ++ ; if ( i == NUM_ ) return i ; if ( intersectLineLine ( mnx , mxy , mnx , mny , a1x , a1y , a2x , a2y , pts [ i ] ) > NUM_ ) i ++ ; return i ; }
public static String cidrMaskToNetMask ( String cidrMask ) { if ( cidrMask == null ) { return null ; } int cidrMaskValue = NUM_ ; try { cidrMaskValue = Integer . parseInt ( cidrMask ) ; } catch ( NumberFormatException e ) { return null ; } int cidrMaskFull = xffffffff << ( NUM_ - cidrMaskValue ) ; int cidrMaskBits1 = cidrMaskFull > > NUM_ & xff ; int cidrMaskBits2 = cidrMaskFull > > NUM_ & xff ; int cidrMaskBits3 = cidrMaskFull > > NUM_ & xff ; int cidrMaskBits4 = cidrMaskFull > > NUM_ & xff ; StringBuffer netMaskBuf = new StringBuffer ( ) ; netMaskBuf . append ( cidrMaskBits1 ) ; netMaskBuf . append ( STR_ ) ; netMaskBuf . append ( cidrMaskBits2 ) ; netMaskBuf . append ( STR_ ) ; netMaskBuf . append ( cidrMaskBits3 ) ; netMaskBuf . append ( STR_ ) ; netMaskBuf . append ( cidrMaskBits4 ) ; return netMaskBuf . toString ( ) ; }
public boolean inBounds ( MouseEvent e ) { return e . getX ( ) > x && e . getX ( ) < x + width && e . getY ( ) > y && e . getY ( ) < y + height ; }
public ClassPath ( @ Nonnull Iterable < DexFile > classPath , boolean checkPackagePrivateAccess ) { Iterable < DexFile > dexFiles = Iterables . concat ( classPath , Lists . newArrayList ( getBasicClasses ( ) ) ) ; unknownClass = new UnknownClassProto ( this ) ; loadedClasses . put ( unknownClass . getType ( ) , unknownClass ) ; this . checkPackagePrivateAccess = checkPackagePrivateAccess ; loadPrimitiveType ( STR_ ) ; loadPrimitiveType ( STR_ ) ; loadPrimitiveType ( STR_ ) ; loadPrimitiveType ( STR_ ) ; loadPrimitiveType ( STR_ ) ; loadPrimitiveType ( STR_ ) ; loadPrimitiveType ( STR_ ) ; loadPrimitiveType ( STR_ ) ; loadPrimitiveType ( STR_ ) ; for ( DexFile dexFile : dexFiles ) { for ( ClassDef classDef : dexFile . getClasses ( ) ) { ClassDef prev = availableClasses . get ( classDef . getType ( ) ) ; if ( prev == null ) { availableClasses . put ( classDef . getType ( ) , classDef ) ; } } } }
private boolean askToSave ( ) { if ( mainFrame . isProjectChanged ( ) ) { int response = JOptionPane . showConfirmDialog ( mainFrame , L10N . getLocalString ( STR_ , STR_ ) , L10N . getLocalString ( STR_ , STR_ ) , JOptionPane . YES_NO_CANCEL_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( response == JOptionPane . YES_OPTION ) { if ( mainFrame . getSaveFile ( ) != null ) { save ( ) ; } else { saveAs ( ) ; } } else if ( response == JOptionPane . CANCEL_OPTION ) { return BOOL_ ; } } return BOOL_ ; }
public MapCursor addCursor ( MapCursor cursor ) { cursors . add ( cursor ) ; return cursor ; }
private boolean discardUpstreamMediaChunks ( int queueLength ) { if ( mediaChunks . size ( ) <= queueLength ) { return BOOL_ ; } long startTimeUs = NUM_ ; long endTimeUs = mediaChunks . getLast ( ) . endTimeUs ; BaseMediaChunk removed = null ; while ( mediaChunks . size ( ) > queueLength ) { removed = mediaChunks . removeLast ( ) ; startTimeUs = removed . startTimeUs ; } sampleQueue . discardUpstreamSamples ( removed . getFirstSampleIndex ( ) ) ; notifyUpstreamDiscarded ( startTimeUs , endTimeUs ) ; return BOOL_ ; }
public MetalinkFileBuilder addFile ( String name ) { MetalinkFileBuilder newFile = new MetalinkFileBuilder ( name ) ; files . add ( newFile ) ; return newFile ; }
private void sendAfterConnect ( Channel ch , NettyChannelContext contextFinal , Operation request , NettyChannelGroup group ) { if ( request . getStatusCode ( ) < Operation . STATUS_CODE_FAILURE_THRESHOLD ) { request . complete ( ) ; } else { request . fail ( request . getStatusCode ( ) ) ; } }
protected String checkProduction ( final Territory to , final Collection < Unit > units , final PlayerID player ) { final List < Territory > producers = getAllProducers ( to , player , units ) ; if ( producers . isEmpty ( ) ) { return STR_ + to . getName ( ) ; } Collections . sort ( producers , getBestProducerComparator ( to , units , player ) ) ; if ( ! getCanAllUnitsWithRequiresUnitsBePlacedCorrectly ( units , to ) ) { return STR_ ; } final int maxUnitsToBePlaced = getMaxUnitsToBePlaced ( units , to , player , BOOL_ ) ; if ( ( maxUnitsToBePlaced != - NUM_ ) && ( maxUnitsToBePlaced < units . size ( ) ) ) { return STR_ + units . size ( ) + STR_ + to . getName ( ) ; } return null ; }
@ Override public void closeWrite ( ) throws IOException { if ( _isWriteClosed ) { return ; } _isWriteClosed = BOOL_ ; SocketStream stream = _streamImpl ; if ( stream != null ) { stream . closeWrite ( ) ; } else if ( _s != null ) { try { _s . shutdownOutput ( ) ; } catch ( UnsupportedOperationException e ) { log . log ( Level . FINEST , e . toString ( ) , e ) ; } catch ( Exception e ) { log . finer ( e . toString ( ) ) ; log . log ( Level . FINEST , e . toString ( ) , e ) ; } } }
public boolean equals ( Object that ) { return ( that instanceof CharSet ) && Arrays . equals ( chars , ( ( CharSet ) that ) . chars ) ; }
public static Void processRecords ( List < KinesisEventRecord > inputRecords , KinesisUserRecordProcessor processor ) { List < Record > rawRecords = new LinkedList < > ( ) ; for ( KinesisEventRecord rec : inputRecords ) { rawRecords . add ( rec . getKinesis ( ) ) ; } return processor . process ( UserRecord . deaggregate ( rawRecords ) ) ; }
protected Font resolveFont ( SharedContext ctx , String font , float size , IdentValue weight , IdentValue style , IdentValue variant ) { if ( font . startsWith ( STR_ ) ) { font = font . substring ( NUM_ ) ; } if ( font . endsWith ( STR_ ) ) { font = font . substring ( NUM_ , font . length ( ) - NUM_ ) ; } if ( font . equalsIgnoreCase ( STR_ ) ) { font = STR_ ; } if ( font . equalsIgnoreCase ( STR_ ) ) { font = STR_ ; } if ( font . equalsIgnoreCase ( STR_ ) ) { font = STR_ ; } if ( font . equals ( STR_ ) && style == IdentValue . OBLIQUE ) { font = STR_ ; } if ( font . equals ( STR_ ) && style == IdentValue . ITALIC ) { font = STR_ ; } String fontInstanceName = getFontInstanceHashName ( ctx , font , size , weight , style , variant ) ; if ( instanceHash . containsKey ( fontInstanceName ) ) { return instanceHash . get ( fontInstanceName ) ; } if ( availableFontsHash . containsKey ( font ) ) { Font possiblyNullFont = availableFontsHash . get ( font ) ; Font rootFont = null ; if ( possiblyNullFont != null ) { rootFont = possiblyNullFont ; } else { rootFont = new Font ( font , Font . PLAIN , NUM_ ) ; availableFontsHash . put ( font , rootFont ) ; } Font fnt = createFont ( ctx , rootFont , size , weight , style , variant ) ; instanceHash . put ( fontInstanceName , fnt ) ; return fnt ; } return null ; }
public ArrayRealVector ( double [ ] d , int pos , int size ) throws MathIllegalArgumentException , NullArgumentException { if ( d == null ) { throw new NullArgumentException ( ) ; } if ( d . length < pos + size ) { throw new MathIllegalArgumentException ( LocalizedCoreFormats . NUMBER_TOO_LARGE , pos + size , d . length ) ; } data = new double [ size ] ; System . arraycopy ( d , pos , data , NUM_ , size ) ; }
public void clearPaymentMethodsById ( List < String > paymentMethodIdsToRemove ) { if ( UtilValidate . isEmpty ( paymentMethodIdsToRemove ) ) return ; for ( Iterator < CartPaymentInfo > iter = paymentInfo . iterator ( ) ; iter . hasNext ( ) ; ) { CartPaymentInfo info = iter . next ( ) ; if ( paymentMethodIdsToRemove . contains ( info . paymentMethodId ) ) { iter . remove ( ) ; } } }
@ Override public void clean ( ) { setCurrentPoints ( NUM_ ) ; checkState ( ) ; }
public void handleButton2Request ( RequestInvocationEvent event ) { setPageSessionAttribute ( getTrackingTabIDName ( ) , AMAdminConstants . FED_TAB_ID ) ; setPageSessionAttribute ( AMAdminConstants . PREVIOUS_TAB_ID , getTrackingTabIDName ( ) ) ; FederationViewBean vb = ( FederationViewBean ) getViewBean ( FederationViewBean . class ) ; backTrail ( ) ; passPgSessionMap ( vb ) ; vb . forwardTo ( getRequestContext ( ) ) ; }
@ Override public void performRequest ( String request ) { if ( request . compareTo ( STR_ ) == NUM_ ) { stop ( ) ; } else { throw new IllegalArgumentException ( request + STR_ ) ; } }
public byte [ ] toBytes ( ) { byte [ ] returnBytes = new byte [ bytesLength ] ; System . arraycopy ( bytes , NUM_ , returnBytes , NUM_ , bytesLength ) ; return returnBytes ; }
public void startCheck ( ) { checker = new Thread ( new CheckForUpdate ( ) ) ; checker . setPriority ( Thread . MIN_PRIORITY ) ; checker . start ( ) ; }
@ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case SGraphPackage . TRANSITION__TRIGGER : return trigger != null ; case SGraphPackage . TRANSITION__EFFECT : return effect != null ; case SGraphPackage . TRANSITION__PROPERTIES : return properties != null && ! properties . isEmpty ( ) ; case SGraphPackage . TRANSITION__DOCUMENTATION : return DOCUMENTATION_EDEFAULT == null ? documentation != null : ! DOCUMENTATION_EDEFAULT . equals ( documentation ) ; case SGraphPackage . TRANSITION__TARGET : return target != null ; case SGraphPackage . TRANSITION__SOURCE : return basicGetSource ( ) != null ; } return super . eIsSet ( featureID ) ; }
public boolean isAckSeen ( ) { return this . ackSeen ; }
protected void uninstallListeners ( ) { super . uninstallListeners ( ) ; splitPane . removePropertyChangeListener ( this ) ; }
private static Collector < SegmentInfo , ? , Map < String , SegmentInfo > > partitionsToMapCollector ( ) { return Collector . of ( null , null , null ) ; }
public boolean isCrc ( ) { return isFlags ( FLAG_CACHED_VALUES_CHECKED & FLAG_CRC_CALCED ) ; }
public int size ( ) { return queue . size ( ) ; }
@ Override public StringBuffer format ( double number , StringBuffer result , FieldPosition fieldPosition ) { boolean tryFastPath = BOOL_ ; if ( fieldPosition == DontCareFieldPosition . INSTANCE ) tryFastPath = BOOL_ ; else { fieldPosition . setBeginIndex ( NUM_ ) ; fieldPosition . setEndIndex ( NUM_ ) ; } if ( tryFastPath ) { String tempResult = fastFormat ( number ) ; if ( tempResult != null ) { result . append ( tempResult ) ; return result ; } } return format ( number , result , fieldPosition . getFieldDelegate ( ) ) ; }
private void buildCursorConditionally ( MatrixCursor cursor , CharacterRecord cr , String selection , String [ ] selectionArgs ) { if ( selectionArgs == null ) cursor . addRow ( new Object [ ] { cr . getId ( ) , cr . getName ( ) , cr . getRace ( ) } ) ; else for ( String item : selectionArgs ) if ( ( selection . equals ( CharacterContract . CharacterEntry . COLUMN_NAME ) && item . equals ( cr . getName ( ) ) ) || ( selection . equals ( CharacterContract . CharacterEntry . COLUMN_RACE ) && item . equals ( cr . getRace ( ) ) ) ) { cursor . addRow ( new Object [ ] { cr . getId ( ) , cr . getName ( ) , cr . getRace ( ) } ) ; } }
public ModpackFileSelectionPanel ( WizardController controller , Map wizardData , File gameDir , BiFunction < String , Boolean , Integer > blackList ) { initComponents ( ) ; this . controller = controller ; this . wizardData = wizardData ; this . blackList = blackList ; CheckBoxTreeNode root = create ( gameDir , STR_ ) ; jTree1 . setModel ( new DefaultTreeModel ( root ) ) ; jTree1 . setCellRenderer ( new CheckBoxTreeCellRenderer ( ) ) ; jTree1 . addMouseListener ( new CheckBoxTreeNodeSelectionListener ( ) ) ; wizardData . put ( STR_ , root ) ; }
public Shape paintLayer ( Graphics g , int offs0 , int offs1 , Shape bounds , JTextComponent c , View view ) { Graphics2D g2d = ( Graphics2D ) g ; Composite originalComposite = null ; if ( getAlpha ( ) < NUM_ ) { originalComposite = g2d . getComposite ( ) ; g2d . setComposite ( getAlphaComposite ( ) ) ; } Paint paint = getPaint ( ) ; if ( paint == null ) g2d . setColor ( c . getSelectionColor ( ) ) ; else g2d . setPaint ( paint ) ; if ( offs0 == view . getStartOffset ( ) && offs1 == view . getEndOffset ( ) ) { Rectangle alloc ; if ( bounds instanceof Rectangle ) alloc = ( Rectangle ) bounds ; else alloc = bounds . getBounds ( ) ; g2d . fillRect ( alloc . x , alloc . y , alloc . width , alloc . height ) ; if ( getAlpha ( ) < NUM_ ) g2d . setComposite ( originalComposite ) ; return alloc ; } else { try { Shape shape = view . modelToView ( offs0 , Position . Bias . Forward , offs1 , Position . Bias . Backward , bounds ) ; Rectangle r = ( shape instanceof Rectangle ) ? ( Rectangle ) shape : shape . getBounds ( ) ; if ( roundedEdges ) { g2d . fillRoundRect ( r . x , r . y , r . width , r . height , ARCWIDTH , ARCHEIGHT ) ; } else { g2d . fillRect ( r . x , r . y , r . width , r . height ) ; } if ( getAlpha ( ) < NUM_ ) g2d . setComposite ( originalComposite ) ; return r ; } catch ( BadLocationException ble ) { ble . printStackTrace ( ) ; } finally { if ( getAlpha ( ) < NUM_ ) g2d . setComposite ( originalComposite ) ; } } return null ; }
private void createContainerIfNecessary ( ) { if ( container . isFull ( ) ) { container = new TimerRawContainer ( ) ; data . add ( container ) ; } }
private void processUpdateCounts ( int [ ] updateCounts , int commandsInBatch ) { if ( updateCounts . length < commandsInBatch ) { error . emit ( tuples . get ( updateCounts . length + batchStartIdx ) ) ; errorTuples ++ ; tuplesWrittenSuccessfully += updateCounts . length ; batchStartIdx += updateCounts . length + NUM_ ; if ( ( tuples . size ( ) - batchStartIdx ) > NUM_ ) { processBatch ( ) ; } } else { tuplesWrittenSuccessfully = commandsInBatch ; for ( int i = NUM_ ; i < commandsInBatch ; i ++ ) { if ( updateCounts [ i ] == Statement . EXECUTE_FAILED ) { error . emit ( tuples . get ( i + batchStartIdx ) ) ; errorTuples ++ ; tuplesWrittenSuccessfully -- ; } } } }
public int chooseProtocolVersion ( ) { return preferredProtocolVersion ; }
public Sensor createNewSensor ( String systemName , String userName ) { Sensor s ; String sName = AcelaAddress . normalizeSystemName ( systemName ) ; if ( sName . equals ( STR_ ) ) { log . error ( STR_ + systemName ) ; return null ; } s = getBySystemName ( sName ) ; if ( s != null ) { log . error ( STR_ + systemName ) ; return null ; } String altName = AcelaAddress . convertSystemNameToAlternate ( sName ) ; s = getBySystemName ( altName ) ; if ( s != null ) { log . error ( STR_ + systemName + STR_ + altName + STR_ ) ; return null ; } int bit = AcelaAddress . getBitFromSystemName ( sName ) ; if ( ( bit < NUM_ ) || ( bit >= NUM_ ) ) { log . error ( STR_ + Integer . toString ( bit ) + STR_ ) ; return null ; } if ( userName == null ) { s = new AcelaSensor ( sName ) ; } else { s = new AcelaSensor ( sName , userName ) ; } AcelaNode node = AcelaAddress . getNodeFromSystemName ( sName , _memo ) ; if ( node == null ) { log . warn ( STR_ + sName + STR_ ) ; return s ; } if ( ! node . hasActiveSensors ) { int newnodeaddress ; newnodeaddress = node . getNodeAddress ( ) ; log . warn ( STR_ + newnodeaddress ) ; return s ; } node . registerSensor ( s , bit ) ; return s ; }
public static InputStream needStream ( String propertyName ) throws NoSuchPropertyException , FileNotFoundException , MaryConfigurationException { MaryProperties . needProperty ( propertyName ) ; return getStream ( propertyName ) ; }
public static boolean equal ( Object a , Object b ) { return a == b || ( a != null && a . equals ( b ) ) ; }
public static String networkNameToString ( byte [ ] data , int offset , int length ) { String ret ; if ( ( data [ offset ] & x80 ) != x80 || length < NUM_ ) { return STR_ ; } switch ( ( data [ offset ] > > > NUM_ ) & x7 ) { case NUM_ : int countSeptets ; int unusedBits = data [ offset ] & NUM_ ; countSeptets = ( ( ( length - NUM_ ) . NUM_ ) - unusedBits ) / NUM_ ; ret = GsmAlphabet . gsm7BitPackedToString ( data , offset + NUM_ , countSeptets ) ; break ; case NUM_ : try { ret = new String ( data , offset + NUM_ , length - NUM_ , STR_ ) ; } catch ( UnsupportedEncodingException ex ) { ret = STR_ ; Log . e ( LOG_TAG , STR_ , ex ) ; } break ; default : ret = STR_ ; break ; } if ( ( data [ offset ] & x40 ) != NUM_ ) { } return ret ; }
public void add ( Marker marker ) { mItems . add ( marker ) ; }
public static String readAsciiLine ( InputStream in ) throws IOException { StringBuilder result = new StringBuilder ( NUM_ ) ; while ( BOOL_ ) { int c = in . read ( ) ; if ( c == - NUM_ ) { throw new EOFException ( ) ; } else if ( c == STR_ ) { break ; } result . append ( ( char ) c ) ; } int length = result . length ( ) ; if ( length > NUM_ && result . charAt ( length - NUM_ ) == STR_ ) { result . setLength ( length - NUM_ ) ; } return result . toString ( ) ; }
private static Map . Entry < DateTime , TimeSeriesValue > findName ( List < TimeSeriesCollection > c , GroupName name ) { ListIterator < TimeSeriesCollection > iter = c . listIterator ( ) ; while ( iter . hasNext ( ) ) { final int idx = iter . nextIndex ( ) ; final TimeSeriesCollection tsdata = iter . next ( ) ; final Optional < TimeSeriesValue > found = tsdata . get ( name ) ; if ( found . isPresent ( ) ) return SimpleMapEntry . create ( tsdata . getTimestamp ( ) , found . get ( ) ) ; } throw new IllegalStateException ( STR_ ) ; }
public Map < String , Object > finalizeOrderEntryPayment ( String checkOutPaymentId , BigDecimal amount , boolean singleUse , boolean append ) { Map < String , Object > result = ServiceUtil . returnSuccess ( ) ; if ( UtilValidate . isNotEmpty ( checkOutPaymentId ) ) { if ( ! append ) { cart . clearPayments ( ) ; } cart . addPaymentAmount ( checkOutPaymentId , amount , singleUse ) ; } return result ; }
public void deploy ( String routeId , String routeName , JsonValue routeConfig ) throws RouterHandlerException { Reject . ifNull ( routeName ) ; write . lock ( ) ; try { load ( routeId , routeName , routeConfig . copy ( ) ) ; directoryMonitor . store ( routeId , routeConfig ) ; logger . info ( STR_ , routeId , routeName ) ; } catch ( IOException e ) { throw new RouterHandlerException ( format ( STR_ , routeId ) , e ) ; } finally { write . unlock ( ) ; } }
private static char [ ] subscriptForDigit ( int digit ) { return Character . toChars ( x2080 + digit ) ; }
private FsPermission permission ( IgfsFile file ) { String perm = file . property ( IgfsUtils . PROP_PERMISSION , null ) ; if ( perm == null ) return FsPermission . getDefault ( ) ; try { return new FsPermission ( ( short ) Integer . parseInt ( perm , NUM_ ) ) ; } catch ( NumberFormatException ignore ) { return FsPermission . getDefault ( ) ; } }
public SimpleMailboxACL ( ) { this . entries = Collections . emptyMap ( ) ; }
private void readStreamResult ( InH3 hIn , HeadersAmp headers ) throws IOException { ServiceRefAmp serviceRef = readToAddress ( hIn ) ; long id = hIn . readLong ( ) ; QueryRefAmp queryRef = serviceRef . getQueryRef ( id ) ; if ( queryRef != null ) { ClassLoader loader = queryRef . getClassLoader ( ) ; Thread thread = Thread . currentThread ( ) ; thread . setContextClassLoader ( loader ) ; } int sequence = hIn . readInt ( ) ; List < Object > values = ( List ) hIn . readObject ( ) ; Throwable exn = ( Throwable ) hIn . readObject ( Throwable . class ) ; boolean isComplete = hIn . readBoolean ( ) ; if ( log . isLoggable ( _logLevel ) ) { log . log ( _logLevel , STR_ + values + STR_ + isComplete + STR_ + this + STR_ + STR_ + id + STR_ + serviceRef + STR_ + headers + STR_ ) ; } if ( queryRef != null ) { if ( queryRef . accept ( headers , values , sequence , isComplete ) ) { serviceRef . removeQueryRef ( id ) ; } if ( exn != null ) { serviceRef . removeQueryRef ( id ) ; queryRef . fail ( headers , exn ) ; } } else if ( log . isLoggable ( Level . WARNING ) ) { log . warning ( STR_ + id + STR_ + serviceRef + STR_ + headers ) ; } }
public static int rectCrossingsForPath ( PathIterator pi , double rxmin , double rymin , double rxmax , double rymax ) { if ( rxmax <= rxmin || rymax <= rymin ) { return NUM_ ; } if ( pi . isDone ( ) ) { return NUM_ ; } double coords [ ] = new double [ NUM_ ] ; if ( pi . currentSegment ( coords ) != PathIterator . SEG_MOVETO ) { throw new IllegalPathStateException ( STR_ + STR_ ) ; } pi . next ( ) ; double curx , cury , movx , movy , endx , endy ; curx = movx = coords [ NUM_ ] ; cury = movy = coords [ NUM_ ] ; int crossings = NUM_ ; while ( crossings != RECT_INTERSECTS && ! pi . isDone ( ) ) { switch ( pi . currentSegment ( coords ) ) { case PathIterator . SEG_MOVETO : if ( curx != movx || cury != movy ) { crossings = rectCrossingsForLine ( crossings , rxmin , rymin , rxmax , rymax , curx , cury , movx , movy ) ; } movx = curx = coords [ NUM_ ] ; movy = cury = coords [ NUM_ ] ; break ; case PathIterator . SEG_LINETO : endx = coords [ NUM_ ] ; endy = coords [ NUM_ ] ; crossings = rectCrossingsForLine ( crossings , rxmin , rymin , rxmax , rymax , curx , cury , endx , endy ) ; curx = endx ; cury = endy ; break ; case PathIterator . SEG_QUADTO : endx = coords [ NUM_ ] ; endy = coords [ NUM_ ] ; crossings = rectCrossingsForQuad ( crossings , rxmin , rymin , rxmax , rymax , curx , cury , coords [ NUM_ ] , coords [ NUM_ ] , endx , endy , NUM_ ) ; curx = endx ; cury = endy ; break ; case PathIterator . SEG_CUBICTO : endx = coords [ NUM_ ] ; endy = coords [ NUM_ ] ; crossings = rectCrossingsForCubic ( crossings , rxmin , rymin , rxmax , rymax , curx , cury , coords [ NUM_ ] , coords [ NUM_ ] , coords [ NUM_ ] , coords [ NUM_ ] , endx , endy , NUM_ ) ; curx = endx ; cury = endy ; break ; case PathIterator . SEG_CLOSE : if ( curx != movx || cury != movy ) { crossings = rectCrossingsForLine ( crossings , rxmin , rymin , rxmax , rymax , curx , cury , movx , movy ) ; } curx = movx ; cury = movy ; break ; } pi . next ( ) ; } if ( crossings != RECT_INTERSECTS && ( curx != movx || cury != movy ) ) { crossings = rectCrossingsForLine ( crossings , rxmin , rymin , rxmax , rymax , curx , cury , movx , movy ) ; } return crossings ; }
public void updateFieldVisibility ( NeuronUpdateRule rule ) { boolean bounded = rule instanceof BoundedUpdateRule ; boolean clip = BOOL_ ; setBoundsPanelVisible ( bounded ) ; if ( bounded ) { clip = rule instanceof ClippableUpdateRule ; clippingDropDown . setSelected ( clip ) ; } setClippingPanelVisible ( clip ) ; setBoundsEnabled ( bounded ) ; }
@ Override public int hashCode ( ) { int hash = NUM_ ; if ( altFormat != null ) { hash += altFormat . hashCode ( ) ; } if ( projection != null ) { hash = hash . NUM_ ; hash += projection . hashCode ( ) ; } if ( version != null ) { hash = hash . NUM_ ; hash += version . hashCode ( ) ; } return hash ; }
public void removeOkListener ( ActionListener a ) { m_okBut . removeActionListener ( a ) ; }
void change_item_shape ( BrdItem p_item , int p_shape_no , ShapeTile p_new_shape ) { AwtreeNodeLeaf [ ] old_entries = p_item . get_search_tree_entries ( this ) ; AwtreeNodeLeaf [ ] new_leaf_arr = new AwtreeNodeLeaf [ old_entries . length ] ; ShapeTile [ ] new_precalculated_tree_shapes = new ShapeTile [ old_entries . length ] ; remove_leaf ( old_entries [ p_shape_no ] ) ; for ( int i = NUM_ ; i < new_precalculated_tree_shapes . length ; ++ i ) { if ( i == p_shape_no ) { new_precalculated_tree_shapes [ i ] = p_new_shape ; } else { new_precalculated_tree_shapes [ i ] = p_item . get_tree_shape ( this , i ) ; new_leaf_arr [ i ] = old_entries [ i ] ; } } p_item . set_precalculated_tree_shapes ( new_precalculated_tree_shapes , this ) ; new_leaf_arr [ p_shape_no ] = insert ( p_item , p_shape_no ) ; p_item . set_search_tree_entries ( this , new_leaf_arr ) ; }
public JQuickStartPane ( KseFrame kseFrame ) { super ( GRADIENT_COLOR_1 , GRADIENT_COLOR_2 ) ; this . kseFrame = kseFrame ; new DropTarget ( this , this ) ; initComponents ( ) ; }
protected String decode ( String urlString ) { try { Class clazz = URLDecoder . class ; Method method = clazz . getDeclaredMethod ( STR_ , new Class [ ] { String . class , String . class } ) ; if ( urlString . indexOf ( STR_ ) >= NUM_ ) { int len = urlString . length ( ) ; StringBuffer buf = new StringBuffer ( len ) ; for ( int i = NUM_ ; i < len ; i ++ ) { char c = urlString . charAt ( i ) ; if ( c == STR_ ) buf . append ( STR_ ) ; else buf . append ( c ) ; } urlString = buf . toString ( ) ; } Object result = method . invoke ( null , new Object [ ] { urlString , STR_ } ) ; if ( result != null ) return ( String ) result ; } catch ( Exception e ) { } boolean replaced = BOOL_ ; byte [ ] encodedBytes = urlString . getBytes ( ) ; int encodedLength = encodedBytes . length ; byte [ ] decodedBytes = new byte [ encodedLength ] ; int decodedLength = NUM_ ; for ( int i = NUM_ ; i < encodedLength ; i ++ ) { byte b = encodedBytes [ i ] ; if ( b == STR_ ) { if ( i + NUM_ >= encodedLength ) throw new IllegalArgumentException ( STR_ + urlString + STR_ ) ; byte enc1 = encodedBytes [ ++ i ] ; byte enc2 = encodedBytes [ ++ i ] ; b = ( byte ) ( ( hexToByte ( enc1 ) << NUM_ ) + hexToByte ( enc2 ) ) ; replaced = BOOL_ ; } decodedBytes [ decodedLength ++ ] = b ; } if ( ! replaced ) return urlString ; try { return new String ( decodedBytes , NUM_ , decodedLength , STR_ ) ; } catch ( UnsupportedEncodingException e ) { return new String ( decodedBytes , NUM_ , decodedLength ) ; } }
public static String indent ( final int depth ) { if ( depth < NUM_ ) { return STR_ ; } return ws . substring ( NUM_ , Math . min ( ws . length ( ) , depth . NUM_ ) ) ; }
public ExceptionlessOutputStream ( OutputStream out ) { super ( new DataOutputStream ( out ) ) ; dos = ( DataOutputStream ) this . out ; }
public T advanceToElement ( Predicate < T > predicate ) { Node < T > start = head ; if ( head == null ) return null ; do { T currElement = advance ( ) ; if ( predicate . test ( currElement ) ) { return currElement ; } } while ( head != start ) ; return null ; }
public void addTrace ( final Trace trace ) { traceList . add ( trace ) ; add ( trace ) ; revalidate ( ) ; }
public static void pingAllDevices ( String message ) throws IOException { Sender sender = new Sender ( Ids . API_KEY ) ; for ( DeviceInfo deviceInfo : endpoint . listDeviceInfo ( ) ) { doSendViaGcm ( message , sender , deviceInfo ) ; } }
public static void w ( String tag , String msg , Object ... args ) { if ( sLevel > LEVEL_WARNING ) { return ; } if ( args . length > NUM_ ) { msg = String . format ( msg , args ) ; } Log . w ( tag , msg ) ; }
private void findMatchesInContexts ( List < NumberContext > contexts , boolean isValid , boolean isPossible , String region , String number ) { if ( isValid ) { doTestInContext ( number , region , contexts , Leniency . VALID ) ; } else { for ( NumberContext context : contexts ) { String text = context . leadingText + number + context . trailingText ; assertTrue ( STR_ + text , hasNoMatches ( phoneUtil . findNumbers ( text , region ) ) ) ; } } if ( isPossible ) { doTestInContext ( number , region , contexts , Leniency . POSSIBLE ) ; } else { for ( NumberContext context : contexts ) { String text = context . leadingText + number + context . trailingText ; assertTrue ( STR_ + text , hasNoMatches ( phoneUtil . findNumbers ( text , region , Leniency . POSSIBLE , Long . MAX_VALUE ) ) ) ; } } }
public void testGeneralPunctuationCategory ( ) { String [ ] s = { STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ } ; String regexp = STR_ ; for ( int i = NUM_ ; i < s . length ; i ++ ) { Pattern pattern = Pattern . compile ( regexp ) ; Matcher matcher = pattern . matcher ( s [ i ] ) ; assertTrue ( matcher . find ( ) ) ; } }
@ Override public int hashCode ( ) { int code = NUM_ ; if ( eSubjects != null ) { for ( EntitlementSubject eSubject : eSubjects ) { code += eSubject . hashCode ( ) ; } } if ( pSubjectName != null ) { code += pSubjectName . hashCode ( ) ; } return code ; }
private void assignRandomLowerTriangularMatrix ( int n , SecureRandom sr ) { numRows = n ; numColumns = n ; length = ( n + NUM_ ) > > > NUM_ ; matrix = new int [ numRows ] [ length ] ; for ( int i = NUM_ ; i < numRows ; i ++ ) { int q = i > > > NUM_ ; int r = i & x1f ; int s = NUM_ - r ; r = NUM_ << r ; for ( int j = NUM_ ; j < q ; j ++ ) { matrix [ i ] [ j ] = sr . nextInt ( ) ; } matrix [ i ] [ q ] = ( sr . nextInt ( ) > > > s ) | r ; for ( int j = q + NUM_ ; j < length ; j ++ ) { matrix [ i ] [ j ] = NUM_ ; } } }
private boolean loadWithInspectItClassLoader ( String className ) { return className . startsWith ( CLASS_NAME_PREFIX ) ; }
public static void addCustomCommands ( String commands , ContextMenu m ) { Matcher matcher = CUSTOM_COMMANDS_PATTERN . matcher ( commands ) ; boolean sep = BOOL_ ; while ( matcher . find ( ) ) { String match = matcher . group ( ) ; if ( match . equals ( STR_ ) ) { sep = BOOL_ ; } else { String command = matcher . group ( NUM_ ) ; String submenu = null ; if ( match . startsWith ( STR_ ) ) { submenu = CUSTOM_COMMANDS_SUBMENU ; } if ( sep ) { m . addSeparator ( submenu ) ; } m . addSubItem ( STR_ + command , Helper . replaceUnderscoreWithSpace ( command ) , submenu ) ; sep = BOOL_ ; } } }
public void paintBorder ( Component c , Graphics g , int x , int y , int width , int height ) { Border border = getBorder ( ) ; String title = getTitle ( ) ; if ( ( title != null ) && ! title . isEmpty ( ) ) { int edge = ( border instanceof TitledBorder ) ? NUM_ : EDGE_SPACING ; JLabel label = getLabel ( c ) ; Dimension size = label . getPreferredSize ( ) ; Insets insets = getBorderInsets ( border , c , new Insets ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; int borderX = x + edge ; int borderY = y + edge ; int borderW = width - edge - edge ; int borderH = height - edge - edge ; int labelY = y ; int labelH = size . height ; int position = getPosition ( ) ; switch ( position ) { case ABOVE_TOP : insets . left = NUM_ ; insets . right = NUM_ ; borderY += labelH - edge ; borderH -= labelH - edge ; break ; case TOP : insets . top = edge + insets . top / NUM_ - labelH / NUM_ ; if ( insets . top < edge ) { borderY -= insets . top ; borderH += insets . top ; } else { labelY += insets . top ; } break ; case BELOW_TOP : labelY += insets . top + edge ; break ; case ABOVE_BOTTOM : labelY += height - labelH - insets . bottom - edge ; break ; case BOTTOM : labelY += height - labelH ; insets . bottom = edge + ( insets . bottom - labelH ) / NUM_ ; if ( insets . bottom < edge ) { borderH += insets . bottom ; } else { labelY -= insets . bottom ; } break ; case BELOW_BOTTOM : insets . left = NUM_ ; insets . right = NUM_ ; labelY += height - labelH ; borderH -= labelH - edge ; break ; } insets . left += edge + TEXT_INSET_H ; insets . right += edge + TEXT_INSET_H ; int labelX = x ; int labelW = width - insets . left - insets . right ; if ( labelW > size . width ) { labelW = size . width ; } switch ( getJustification ( c ) ) { case LEFT : labelX += insets . left ; break ; case RIGHT : labelX += width - insets . right - labelW ; break ; case CENTER : labelX += ( width - labelW ) / NUM_ ; break ; } if ( border != null ) { if ( ( position != TOP ) && ( position != BOTTOM ) ) { border . paintBorder ( c , g , borderX , borderY , borderW , borderH ) ; } else { Graphics g2 = g . create ( ) ; if ( g2 instanceof Graphics2D ) { Graphics2D g2d = ( Graphics2D ) g2 ; Path2D path = new Path2D . Float ( ) ; path . append ( new Rectangle ( borderX , borderY , borderW , labelY - borderY ) , BOOL_ ) ; path . append ( new Rectangle ( borderX , labelY , labelX - borderX - TEXT_SPACING , labelH ) , BOOL_ ) ; path . append ( new Rectangle ( labelX + labelW + TEXT_SPACING , labelY , borderX - labelX + borderW - labelW - TEXT_SPACING , labelH ) , BOOL_ ) ; path . append ( new Rectangle ( borderX , labelY + labelH , borderW , borderY - labelY + borderH - labelH ) , BOOL_ ) ; g2d . clip ( path ) ; } border . paintBorder ( c , g2 , borderX , borderY , borderW , borderH ) ; g2 . dispose ( ) ; } } g . translate ( labelX , labelY ) ; label . setSize ( labelW , labelH ) ; label . paint ( g ) ; g . translate ( - labelX , - labelY ) ; } else if ( border != null ) { border . paintBorder ( c , g , x , y , width , height ) ; } }
public int nextClearBit ( int fromIndex ) { int i = fromIndex > > ADDRESS_BITS ; int max = data . length ; for ( ; i < max ; i ++ ) { if ( data [ i ] == - NUM_ ) { continue ; } int j = Math . max ( fromIndex , i << ADDRESS_BITS ) ; for ( int end = j + NUM_ ; j < end ; j ++ ) { if ( ! get ( j ) ) { return j ; } } } return max << ADDRESS_BITS ; }
private final void nextRequest ( ) { pacingTimer . stop ( ) ; pacingTimer . restart ( ) ; replyTryCount = NUM_ ; }
@ Override public boolean equals ( Object o ) { if ( this == o ) { return BOOL_ ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return BOOL_ ; } Account account = ( Account ) o ; if ( username != null ? ! username . equals ( account . username ) : account . username != null ) { return BOOL_ ; } return BOOL_ ; }
public static int identifyPid ( final String name ) throws PidUnavailableException { try { final int index = name . indexOf ( STR_ ) ; if ( index < NUM_ ) { throw new PidUnavailableException ( STR_ + name ) ; } return Integer . valueOf ( name . substring ( NUM_ , index ) ) ; } catch ( NumberFormatException e ) { throw new PidUnavailableException ( STR_ + name , e ) ; } }
abstract protected void processCommand ( String line ) throws Exception ;
private void writeAttribute ( java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( namespace . equals ( STR_ ) ) { xmlWriter . writeAttribute ( attName , attValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } }
protected Object next ( ) { int i = NUM_ ; char [ ] c ; try { i = st . nextToken ( ) ; } catch ( IOException e ) { Debug . error ( STR_ + e . toString ( ) + STR_ ) ; } if ( ( i == StreamTokenizer . TT_EOF ) || ( i == NUM_ ) ) return EOF ; if ( i == StreamTokenizer . TT_WORD ) return new Symbol ( st . sval , NUM_ ) ; if ( ( i == STR_ ) || ( i == STR_ ) ) return st . sval ; if ( i == StreamTokenizer . TT_NUMBER ) return new Double ( st . nval ) ; if ( ( i == STR_ ) || ( i == STR_ ) || ( i == STR_ ) ) return LP ; if ( ( i == STR_ ) || ( i == STR_ ) || ( i == STR_ ) ) return RP ; c = new char [ NUM_ ] ; c [ NUM_ ] = ( char ) i ; return new Symbol ( new String ( c ) , NUM_ ) ; }
public static void copy ( File source , File dest ) throws IOException { if ( source . isDirectory ( ) ) { dest . mkdir ( ) ; for ( File child : listFiles ( source ) ) { copy ( child , new File ( dest , child . getName ( ) ) ) ; } } else { if ( source . exists ( ) ) { long lm = source . lastModified ( ) ; if ( dest . isDirectory ( ) ) { dest = new File ( dest , source . getName ( ) ) ; } FileOutputStream fos = new FileOutputStream ( dest ) ; try { FileInputStream fis = new FileInputStream ( source ) ; try { if ( USE_NIO ) { nioCopy ( fos , fis ) ; } else { oioCopy ( source , fos , fis ) ; } } finally { fis . close ( ) ; } } finally { fos . close ( ) ; } dest . setExecutable ( source . canExecute ( ) , BOOL_ ) ; dest . setLastModified ( lm ) ; } } }
public static int classIndex ( int luaState , Class clazz , String searchName ) throws LuaException { synchronized ( LuaStateFactory . getExistingState ( luaState ) ) { int res ; res = checkField ( luaState , clazz , searchName ) ; if ( res != NUM_ ) { return NUM_ ; } res = checkMethod ( luaState , clazz , searchName ) ; if ( res != NUM_ ) { return NUM_ ; } return NUM_ ; } }
private void notifyResourceEventListeners ( ResourceEvent event , Object resource ) { for ( Iterator < ResourceEventsListener > iter = resourceListeners . iterator ( ) ; iter . hasNext ( ) ; ) { try { ResourceEventsListener listener = ( ResourceEventsListener ) iter . next ( ) ; listener . handleEvent ( event , resource ) ; } catch ( CancelException e ) { } catch ( GemFireSecurityException | ManagementException ex ) { if ( event == ResourceEvent . CACHE_CREATE ) { throw ex ; } else { logger . warn ( ex . getMessage ( ) , ex ) ; } } catch ( Exception err ) { logger . warn ( err . getMessage ( ) , err ) ; } catch ( VirtualMachineError e ) { SystemFailure . initiateFailure ( e ) ; throw e ; } catch ( Throwable t ) { SystemFailure . checkFailure ( ) ; logger . warn ( t . getMessage ( ) , t ) ; } } }
public boolean isEnumConstant ( ) { return ( getModifiers ( ) & Modifier . ENUM ) != NUM_ ; }
private void inferCaller ( ) { needToInferCaller = BOOL_ ; Throwable throwable = new Throwable ( ) ; boolean lookingForLogger = BOOL_ ; for ( final StackTraceElement frame : throwable . getStackTrace ( ) ) { String cname = frame . getClassName ( ) ; boolean isLoggerImpl = isLoggerImplFrame ( cname ) ; if ( lookingForLogger ) { if ( isLoggerImpl ) { lookingForLogger = BOOL_ ; } } else { if ( ! isLoggerImpl ) { if ( ! cname . startsWith ( STR_ ) && ! cname . startsWith ( STR_ ) ) { setSourceClassName ( cname ) ; setSourceMethodName ( frame . getMethodName ( ) ) ; return ; } } } } }
final int recordExceptionalCompletion ( Throwable ex ) { int s ; if ( ( s = status ) >= NUM_ ) { int h = System . identityHashCode ( this ) ; final ReentrantLock lock = exceptionTableLock ; lock . lock ( ) ; try { expungeStaleExceptions ( ) ; ExceptionNode [ ] t = exceptionTable ; int i = h & ( t . length - NUM_ ) ; for ( ExceptionNode e = t [ i ] ; ; e = e . next ) { if ( e == null ) { t [ i ] = new ExceptionNode ( this , ex , t [ i ] , exceptionTableRefQueue ) ; break ; } if ( e . get ( ) == this ) break ; } } finally { lock . unlock ( ) ; } s = setCompletion ( EXCEPTIONAL ) ; } return s ; }
private void analyzeResultingTlsContextAndWriteFile ( TlsContext tlsContext , String folder , String fieldName , String workflowName , long phase ) throws JAXBException , IOException { if ( TlsContextAnalyzer . containsFullWorkflowWithMissingMessage ( tlsContext ) || TlsContextAnalyzer . containsServerFinishedWithModifiedHandshake ( tlsContext ) || TlsContextAnalyzer . containsFullWorkflowWithModifiedMessage ( tlsContext ) ) { String fileNameBasic = createFileName ( folder , phase , tlsContext , fieldName ) ; FileOutputStream fos = new FileOutputStream ( fileNameBasic + workflowName + STR_ ) ; WorkflowTraceSerializer . write ( fos , tlsContext . getWorkflowTrace ( ) ) ; } }
public Year ( int year ) { if ( ( year < Year . MINIMUM_YEAR ) || ( year > Year . MAXIMUM_YEAR ) ) { throw new IllegalArgumentException ( STR_ + year + STR_ ) ; } this . year = ( short ) year ; peg ( Calendar . getInstance ( ) ) ; }
@ SuppressWarnings ( STR_ ) public List < String > hostVcenterChangeDetails ( URI hostId , URI clusterId , URI datacenterId , boolean isVcenter ) { List < String > result = Lists . newArrayList ( ) ; Host host = _dbClient . queryObject ( Host . class , hostId ) ; VcenterDataCenter datacenter = _dbClient . queryObject ( VcenterDataCenter . class , datacenterId ) ; if ( host != null && datacenter != null ) { result . add ( ComputeSystemDialogProperties . getMessage ( STR_ , host . getLabel ( ) , datacenter . getLabel ( ) ) ) ; result . addAll ( hostClusterChangeDetails ( hostId , clusterId , datacenterId , isVcenter ) ) ; } return result ; }
public boolean deleteStatement ( TestCase test , int position ) throws ConstructionFailedException { if ( ! ConstraintVerifier . canDelete ( test , position ) ) { return BOOL_ ; } logger . debug ( STR_ , position ) ; Set < Integer > toDelete = new LinkedHashSet < > ( ) ; recursiveDeleteInclusion ( test , toDelete , position ) ; List < Integer > pos = new ArrayList < > ( toDelete ) ; Collections . sort ( pos , Collections . reverseOrder ( ) ) ; for ( Integer i : pos ) { logger . debug ( STR_ , i ) ; test . remove ( i ) ; } return BOOL_ ; }
public boolean isCompound ( ) { return splits . size ( ) != NUM_ ; }
@ Override public Set < Statement > sum ( final IGASState < Set < Statement > , Set < Statement > , Set < Statement > > state , final Set < Statement > left , final Set < Statement > right ) { final Set < Statement > tmp = new LinkedHashSet < Statement > ( left ) ; tmp . addAll ( right ) ; return tmp ; }
public void testSignumPositive ( ) { String a = STR_ ; int aScale = NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; assertEquals ( STR_ , NUM_ , aNumber . signum ( ) ) ; }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case NUM_ : return HOST ; case NUM_ : return PORT ; case NUM_ : return ID ; case NUM_ : return V_NODES ; case NUM_ : return PING_FREQUENCY ; case NUM_ : return SERVICE_NAME ; case NUM_ : return STATE ; case NUM_ : return TIMESTAMP ; default : return null ; } }
private static int categorizeByYear2014Method ( Context c ) { ArrayList < Integer > componentYears = new ArrayList < Integer > ( ) ; conditionallyAdd ( componentYears , getNumCoresYear ( ) ) ; conditionallyAdd ( componentYears , getClockSpeedYear ( ) ) ; conditionallyAdd ( componentYears , getRamYear ( c ) ) ; if ( componentYears . isEmpty ( ) ) return CLASS_UNKNOWN ; Collections . sort ( componentYears ) ; if ( ( componentYears . size ( ) & x01 ) == NUM_ ) { return componentYears . get ( componentYears . size ( ) / NUM_ ) ; } else { int baseIndex = componentYears . size ( ) / NUM_ - NUM_ ; return componentYears . get ( baseIndex ) + ( componentYears . get ( baseIndex + NUM_ ) - componentYears . get ( baseIndex ) ) / NUM_ ; } }
public Time ( Date time ) { SimpleTimeZone tz = new SimpleTimeZone ( NUM_ , STR_ ) ; SimpleDateFormat dateF = new SimpleDateFormat ( STR_ ) ; dateF . setTimeZone ( tz ) ; String d = dateF . format ( time ) + STR_ ; int year = Integer . parseInt ( d . substring ( NUM_ , NUM_ ) ) ; if ( year < NUM_ || year > NUM_ ) { this . time = new DERGeneralizedTime ( d ) ; } else { this . time = new DERUTCTime ( d . substring ( NUM_ ) ) ; } }
public ActionRequestHelper then ( ActionRequestHelper nextAction ) { mNext . add ( nextAction ) ; return this ; }
protected int [ ] readColorTable ( final int ncolors ) { final int nbytes = NUM_ . ncolors ; int [ ] tab = null ; final byte [ ] c = new byte [ nbytes ] ; try { rawData . get ( c ) ; tab = new int [ NUM_ ] ; int i = NUM_ ; int j = NUM_ ; while ( i < ncolors ) { final int r = ( c [ j ++ ] ) & xff ; final int g = ( c [ j ++ ] ) & xff ; final int b = ( c [ j ++ ] ) & xff ; tab [ i ++ ] = xff000000 | ( r << NUM_ ) | ( g << NUM_ ) | b ; } } catch ( final BufferUnderflowException e ) { Log . w ( TAG , STR_ , e ) ; status = STATUS_FORMAT_ERROR ; } return tab ; }
public boolean isCurrent ( String str ) { if ( pos + str . length ( ) > lcText . length ) return BOOL_ ; for ( int i = str . length ( ) - NUM_ ; i >= NUM_ ; i -- ) { if ( str . charAt ( i ) != lcText [ pos + i ] ) return BOOL_ ; } return BOOL_ ; }
private static String matchablePath ( String path ) { if ( path == null ) { return STR_ ; } else if ( path . endsWith ( STR_ ) ) { return path ; } else { return path + STR_ ; } }
public void assertUsable ( ) throws IOException { if ( throwable . get ( ) == null ) { if ( connection == null ) { throw new IOException ( STR_ ) ; } return ; } Throwable t = throwable . get ( ) ; if ( t instanceof IOException ) { throw ( IOException ) t ; } else { throw Throwables . propagate ( t ) ; } }
private Collection < Insanity > checkSubreaders ( MapOfSets < Integer , CacheEntry > valIdToItems , MapOfSets < ReaderField , Integer > readerFieldToValIds ) { final List < Insanity > insanity = new ArrayList < > ( NUM_ ) ; Map < ReaderField , Set < ReaderField > > badChildren = new HashMap < > ( NUM_ ) ; MapOfSets < ReaderField , ReaderField > badKids = new MapOfSets < > ( badChildren ) ; Map < Integer , Set < CacheEntry > > viToItemSets = valIdToItems . getMap ( ) ; Map < ReaderField , Set < Integer > > rfToValIdSets = readerFieldToValIds . getMap ( ) ; Set < ReaderField > seen = new HashSet < > ( NUM_ ) ; Set < ReaderField > readerFields = rfToValIdSets . keySet ( ) ; for ( final ReaderField rf : readerFields ) { if ( seen . contains ( rf ) ) continue ; List < Object > kids = getAllDescendantReaderKeys ( rf . readerKey ) ; for ( Object kidKey : kids ) { ReaderField kid = new ReaderField ( kidKey , rf . fieldName ) ; if ( badChildren . containsKey ( kid ) ) { badKids . put ( rf , kid ) ; badKids . putAll ( rf , badChildren . get ( kid ) ) ; badChildren . remove ( kid ) ; } else if ( rfToValIdSets . containsKey ( kid ) ) { badKids . put ( rf , kid ) ; } seen . add ( kid ) ; } seen . add ( rf ) ; } for ( final ReaderField parent : badChildren . keySet ( ) ) { Set < ReaderField > kids = badChildren . get ( parent ) ; List < CacheEntry > badEntries = new ArrayList < > ( kids . size ( ) . NUM_ ) ; { for ( final Integer value : rfToValIdSets . get ( parent ) ) { badEntries . addAll ( viToItemSets . get ( value ) ) ; } } for ( final ReaderField kid : kids ) { for ( final Integer value : rfToValIdSets . get ( kid ) ) { badEntries . addAll ( viToItemSets . get ( value ) ) ; } } CacheEntry [ ] badness = new CacheEntry [ badEntries . size ( ) ] ; badness = badEntries . toArray ( badness ) ; insanity . add ( new Insanity ( InsanityType . SUBREADER , STR_ + parent . toString ( ) , badness ) ) ; } return insanity ; }
public static String addProtocolToUrl ( String url ) { if ( ! url . startsWith ( HTTP_PROTOCOL_PREFIX ) && ! url . startsWith ( HTTPS_PROTOCOL_PREFIX ) && ! url . startsWith ( FILE_PROTOCOL_PREFIX ) ) { if ( url . startsWith ( FILE_PREFIX ) ) { url = FILE_PROTOCOL_PREFIX + url ; } else { url = HTTP_PROTOCOL_PREFIX + url ; } } return url ; }
public XPath ( String exprString , SourceLocator locator , PrefixResolver prefixResolver , int type ) throws javax . xml . transform . TransformerException { this ( exprString , locator , prefixResolver , type , null ) ; }
public static String methodNameToPropertyName ( String methodName ) { if ( methodName . startsWith ( STR_ ) ) methodName = methodName . substring ( NUM_ ) ; else if ( methodName . startsWith ( STR_ ) ) methodName = methodName . substring ( NUM_ ) ; else if ( methodName . startsWith ( STR_ ) ) methodName = methodName . substring ( NUM_ ) ; if ( methodName . length ( ) == NUM_ ) return null ; char ch = methodName . charAt ( NUM_ ) ; if ( Character . isUpperCase ( ch ) && ( methodName . length ( ) == NUM_ || ! Character . isUpperCase ( methodName . charAt ( NUM_ ) ) ) ) { methodName = Character . toLowerCase ( ch ) + methodName . substring ( NUM_ ) ; } return methodName ; }
private StringBuilder createIndent ( int indent ) { StringBuilder oneIndent = createIndent ( ) ; StringBuilder ret = new StringBuilder ( ) ; while ( indent -- > NUM_ ) { ret . append ( oneIndent ) ; } return ret ; }
protected ClassLoader ( ) { this ( getSystemClassLoader ( ) ) ; }
public static void matchvPoolWithStoragePools ( VirtualPool vpool , List < StoragePool > pools , DbClient dbClient , CoordinatorClient coordinator , String matcherGroupName , StringBuffer errorMessage ) { List < StoragePool > filterPools = getMatchedPoolWithStoragePools ( vpool , pools , VirtualPool . getProtectionSettings ( vpool , dbClient ) , VirtualPool . getRemoteProtectionSettings ( vpool , dbClient ) , VirtualPool . getFileRemoteProtectionSettings ( vpool , dbClient ) , dbClient , coordinator , matcherGroupName , errorMessage ) ; updateInvalidAndMatchedPoolsForVpool ( vpool , filterPools , pools , dbClient ) ; }
private static int [ ] trimArray ( int [ ] array , int size ) { if ( size < NUM_ ) { throw new IllegalArgumentException ( ) ; } if ( size == NUM_ ) { return NO_ERRORS ; } int [ ] a = new int [ size ] ; System . arraycopy ( array , NUM_ , a , NUM_ , size ) ; return a ; }
static < T > boolean removeIf ( Iterable < T > removeFrom , Predicate < ? super T > predicate ) { if ( removeFrom instanceof RandomAccess && removeFrom instanceof List ) { return removeIfFromRandomAccessList ( ( List < T > ) removeFrom , checkNotNull ( predicate ) ) ; } return Iterators . removeIf ( removeFrom . iterator ( ) , predicate ) ; }
@ BeforeClass public static void createEcomConnection ( ) { boolean wasException = BOOL_ ; try { _connection = new EcomConnection ( createConnectionInfo ( ) , createListener ( ) , new CimFilterMap ( ) ) ; } catch ( Exception e ) { wasException = BOOL_ ; } Assert . assertFalse ( wasException ) ; }
protected void _init ( final IDatatypeURIResolver resolver , final ILexiconConfiguration < BigdataValue > config , final Collection < IExtension < ? extends BigdataValue > > extensions ) { }
public mxRectangle graphModelChanged ( mxIGraphModel sender , List < mxUndoableChange > changes , Boolean rv ) { int thresh = getChangesRepaintThreshold ( ) ; boolean ignoreDirty = thresh > NUM_ && changes . size ( ) > thresh ; if ( ! ignoreDirty ) { Iterator < mxUndoableChange > it = changes . iterator ( ) ; while ( it . hasNext ( ) ) { if ( it . next ( ) instanceof mxRootChange ) { ignoreDirty = BOOL_ ; break ; } } } ArrayList < Object > changedCells = new ArrayList < Object > ( ) ; mxRectangle dirty = processChanges ( changes , BOOL_ , ignoreDirty , changedCells ) ; if ( ! rv ) { if ( changedCells != null ) { for ( Object changedCell : changedCells ) { mxCellState parentState = view . getState ( model . getParent ( changedCell ) , BOOL_ ) ; view . validate ( parentState , changedCell , BOOL_ ) ; } } } else view . validate ( ) ; if ( ! ignoreDirty ) { mxRectangle tmp = processChanges ( changes , BOOL_ , ignoreDirty ) ; if ( tmp != null ) { if ( dirty == null ) { dirty = tmp ; } else { dirty . add ( tmp ) ; } } } removeSelectionCells ( getRemovedCellsForChanges ( changes ) ) ; return dirty ; }
public void testSetBitException ( ) { byte aBytes [ ] = { - NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int number = - NUM_ ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; try { aNumber . setBit ( number ) ; fail ( STR_ ) ; } catch ( ArithmeticException e ) { } }
public void guard ( final Guard r ) throws InterruptedException { incThread ( ) ; try { r . run ( ) ; } catch ( InterruptedException e ) { throw e ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } finally { decThread ( ) ; } }
public void log ( Date time , String message ) { try { PrintWriter w = new PrintWriter ( new FileWriter ( filename , BOOL_ ) ) ; w . println ( STR_ + format . format ( time ) + STR_ + message ) ; w . close ( ) ; } catch ( IOException e ) { } }
protected ResourceInfo newElement ( int type ) { ResourceInfo result = null ; switch ( type ) { case IResource . FILE : case IResource . FOLDER : result = new ResourceInfo ( type ) ; break ; case IResource . PROJECT : result = new ResourceInfo ( type ) ; break ; case IResource . ROOT : result = new ResourceInfo ( type ) ; break ; } return result ; }
private boolean isModelUseful ( ContingencyMatrix cm ) { return BOOL_ ; }
public void registerPlayerObserver ( PlayerEventsObserver observer , boolean replyImmediately ) { if ( this . connection == null ) return ; playerEventsObservers . add ( observer ) ; if ( replyImmediately ) replyWithLastResult ( observer ) ; if ( playerEventsObservers . size ( ) == NUM_ ) { if ( connection . getProtocol ( ) == HostConnection . PROTOCOL_TCP ) { connection . registerPlayerNotificationsObserver ( this , checkerHandler ) ; connection . registerSystemNotificationsObserver ( this , checkerHandler ) ; connection . registerInputNotificationsObserver ( this , checkerHandler ) ; checkerHandler . post ( tcpCheckerRunnable ) ; } else { checkerHandler . post ( httpCheckerRunnable ) ; } } }
@ Override public int numElements ( ) throws Exception { if ( m_zeroR != null ) { return NUM_ ; } return m_Tree . numNodes ( ) ; }
public boolean isHighlightable ( OMGraphic omg ) { return BOOL_ ; }
public void testVirtualDestinationsDinamicallyIncludedBehavior3 ( ) throws Exception { final String topic = STR_ ; final String vq = STR_ + topic ; startAllBrokers ( ) ; final int msgs1 = NUM_ ; final int msgs2 = NUM_ ; Destination tDest = createDestination ( topic , BOOL_ ) ; Destination vqDest = createDestination ( vq , BOOL_ ) ; MessageConsumer clientB1t = createConsumer ( STR_ , tDest ) ; MessageConsumer clientB2t = createConsumer ( STR_ , tDest ) ; MessageConsumer clientB1vq = createConsumer ( STR_ , vqDest ) ; Thread . sleep ( NUM_ . NUM_ ) ; sendMessages ( STR_ , tDest , msgs1 ) ; sendMessages ( STR_ , tDest , msgs2 ) ; Thread . sleep ( NUM_ ) ; MessageIdList msgsB1t = getConsumerMessages ( STR_ , clientB1t ) ; msgsB1t . waitForMessagesToArrive ( msgs1 + msgs2 ) ; assertEquals ( msgs1 + msgs2 , msgsB1t . getMessageCount ( ) ) ; MessageIdList msgsB2t = getConsumerMessages ( STR_ , clientB2t ) ; msgsB2t . waitForMessagesToArrive ( msgs1 + msgs2 ) ; assertEquals ( msgs1 + msgs2 , msgsB2t . getMessageCount ( ) ) ; MessageIdList msgsB1vq = getConsumerMessages ( STR_ , clientB1vq ) ; msgsB1vq . waitForMessagesToArrive ( msgs1 + msgs2 ) ; assertEquals ( msgs1 + msgs2 , msgsB1vq . getMessageCount ( ) ) ; assertEquals ( NUM_ , getQueueSize ( STR_ , ( ActiveMQDestination ) vqDest ) ) ; assertEquals ( NUM_ , getQueueSize ( STR_ , ( ActiveMQDestination ) vqDest ) ) ; destroyAllBrokers ( ) ; }
public RpcClient peerWith ( PeerInfo serverInfo , Bootstrap bootstrap , Map < String , Object > attributes ) throws IOException { InetSocketAddress remoteAddress = new InetSocketAddress ( serverInfo . getHostName ( ) , serverInfo . getPort ( ) ) ; return peerWith ( remoteAddress , bootstrap , attributes ) ; }
public GridReversedLinesFileReader ( final File file , final int blockSize , final String encoding ) throws IOException { this ( file , blockSize , Charset . forName ( encoding ) ) ; }
private void beforeName ( ) throws IOException { int context = peek ( ) ; if ( context == NONEMPTY_OBJECT ) { out . write ( STR_ ) ; } else if ( context != EMPTY_OBJECT ) { throw new IllegalStateException ( STR_ ) ; } newline ( ) ; replaceTop ( DANGLING_NAME ) ; }
protected String constName ( ) { return STR_ + name . toUpperCase ( ) ; }
public boolean isTimestampWithinInterval ( DateTime timestamp , String intervalString ) throws IllegalArgumentException { Interval interval = Interval . parse ( intervalString ) ; return interval . contains ( timestamp ) ; }
private void processAnsiOsCommand ( ) { if ( ansiOsCommand . charAt ( NUM_ ) != STR_ || ansiOsCommand . charAt ( NUM_ ) != STR_ ) { Logger . log ( STR_ + ansiOsCommand + STR_ ) ; return ; } }
private void addToRenaming ( Renaming renaming , HashSet < String > prevDeclared , ExprNode expr ) { if ( ! ( expr instanceof OpApplNode ) ) { return ; } HashSet < String > newDeclared = ( HashSet < String > ) prevDeclared . clone ( ) ; OpApplNode node = ( OpApplNode ) expr ; if ( node . getUnbdedQuantSymbols ( ) != null ) { for ( int i = NUM_ ; i < node . getUnbdedQuantSymbols ( ) . length ; i ++ ) { FormalParamNode id = node . getUnbdedQuantSymbols ( ) [ i ] ; if ( newDeclared . contains ( getCurrentName ( id , renaming ) ) ) { String newname = getNewName ( id , newDeclared , renaming ) ; newDeclared . add ( newname ) ; addCurrentName ( id , newname , renaming ) ; } } } if ( node . getBdedQuantSymbolLists ( ) != null ) { for ( int i = NUM_ ; i < node . getBdedQuantSymbolLists ( ) . length ; i ++ ) { addToRenaming ( renaming , prevDeclared , node . getBdedQuantBounds ( ) [ i ] ) ; FormalParamNode [ ] nodeList = node . getBdedQuantSymbolLists ( ) [ i ] ; for ( int j = NUM_ ; j < nodeList . length ; j ++ ) { FormalParamNode id = nodeList [ j ] ; if ( newDeclared . contains ( getCurrentName ( id , renaming ) ) ) { String newname = getNewName ( id , newDeclared , renaming ) ; newDeclared . add ( newname ) ; addCurrentName ( id , newname , renaming ) ; } } } } for ( int i = NUM_ ; i < node . getArgs ( ) . length ; i ++ ) { if ( node . getArgs ( ) [ i ] instanceof ExprNode ) { addToRenaming ( renaming , newDeclared , ( ExprNode ) node . getArgs ( ) [ i ] ) ; } } }
private LinkedList < Diff > diff_lineMode ( String text1 , String text2 , long deadline ) { LinesToCharsResult b = diff_linesToChars ( text1 , text2 ) ; text1 = b . chars1 ; text2 = b . chars2 ; List < String > linearray = b . lineArray ; LinkedList < Diff > diffs = diff_main ( text1 , text2 , BOOL_ , deadline ) ; diff_charsToLines ( diffs , linearray ) ; diff_cleanupSemantic ( diffs ) ; diffs . add ( new Diff ( Operation . EQUAL , STR_ ) ) ; int count_delete = NUM_ ; int count_insert = NUM_ ; String text_delete = STR_ ; String text_insert = STR_ ; ListIterator < Diff > pointer = diffs . listIterator ( ) ; Diff thisDiff = pointer . next ( ) ; while ( thisDiff != null ) { switch ( thisDiff . operation ) { case INSERT : count_insert ++ ; text_insert += thisDiff . text ; break ; case DELETE : count_delete ++ ; text_delete += thisDiff . text ; break ; case EQUAL : if ( count_delete >= NUM_ && count_insert >= NUM_ ) { pointer . previous ( ) ; for ( int j = NUM_ ; j < count_delete + count_insert ; j ++ ) { pointer . previous ( ) ; pointer . remove ( ) ; } for ( Diff newDiff : diff_main ( text_delete , text_insert , BOOL_ , deadline ) ) { pointer . add ( newDiff ) ; } } count_insert = NUM_ ; count_delete = NUM_ ; text_delete = STR_ ; text_insert = STR_ ; break ; } thisDiff = pointer . hasNext ( ) ? pointer . next ( ) : null ; } diffs . removeLast ( ) ; return diffs ; }
public boolean removeTriggerGroupToNeverDelete ( String group ) { if ( group != null ) return triggerGroupsToNeverDelete . remove ( group ) ; return BOOL_ ; }
public void remove ( Rule rule ) { rules . remove ( rule ) ; }
private boolean uploadAllTrackPoints ( Fusiontables fusiontables , String tableId , Track track ) throws IOException { int numberOfPoints = track . getNumberOfPoints ( ) ; List < Location > locations = new ArrayList < Location > ( MAX_POINTS_PER_UPLOAD ) ; Location lastValidLocation = null ; boolean sentStartMarker = BOOL_ ; int readCount = NUM_ ; LocationIterator locationIterator = null ; try { locationIterator = myTracksProviderUtils . getTrackPointLocationIterator ( trackId , - NUM_ , BOOL_ , MyTracksProviderUtils . DEFAULT_LOCATION_FACTORY ) ; while ( locationIterator . hasNext ( ) ) { Location location = locationIterator . next ( ) ; locations . add ( location ) ; if ( LocationUtils . isValidLocation ( location ) ) { lastValidLocation = location ; } if ( ! sentStartMarker && lastValidLocation != null ) { String name = context . getString ( R . string . marker_label_start , track . getName ( ) ) ; createNewPoint ( fusiontables , tableId , name , STR_ , lastValidLocation , MARKER_TYPE_START ) ; sentStartMarker = BOOL_ ; } readCount ++ ; if ( readCount % MAX_POINTS_PER_UPLOAD == NUM_ ) { if ( ! prepareAndUploadPoints ( fusiontables , tableId , track , locations , BOOL_ ) ) { Log . d ( TAG , STR_ ) ; return BOOL_ ; } updateProgress ( readCount , numberOfPoints ) ; locations . clear ( ) ; } } if ( ! prepareAndUploadPoints ( fusiontables , tableId , track , locations , BOOL_ ) ) { Log . d ( TAG , STR_ ) ; return BOOL_ ; } if ( lastValidLocation != null ) { String name = context . getString ( R . string . marker_label_end , track . getName ( ) ) ; DescriptionGenerator descriptionGenerator = new DescriptionGeneratorImpl ( context ) ; String description = descriptionGenerator . generateTrackDescription ( track , null , null , BOOL_ ) ; createNewPoint ( fusiontables , tableId , name , description , lastValidLocation , MARKER_TYPE_END ) ; } return BOOL_ ; } finally { if ( locationIterator != null ) { locationIterator . close ( ) ; } } }
@ CheckReturnValue @ Deprecated @ Nonnull public static String join ( @ Nonnull String [ ] s , @ Nonnull String delimiter ) { StringBuilder buffer = new StringBuilder ( ) ; for ( int i = NUM_ ; i < s . length ; i ++ ) { buffer . append ( s [ i ] ) ; if ( i < s . length - NUM_ ) { buffer . append ( delimiter ) ; } } return buffer . toString ( ) ; }
private void initSelectPosition ( int position ) { if ( mSelectMode == ISelectable . SELECT_MODE_SINGLE ) { if ( mSelectedPosition == ISelectable . INVALID_POSITION ) { mSelectedPosition = position ; } } else if ( mSelectMode == ISelectable . SELECT_MODE_MULTI ) { if ( ! mSelectedPositions . contains ( position ) ) mSelectedPositions . add ( position ) ; } else { throw new RuntimeException ( ) ; } }
@ Override public PathImpl schemeWalk ( String userPath , Map < String , Object > attributes , String filePath , int offset ) { if ( ! isWindows ( ) ) { return super . schemeWalk ( userPath , attributes , filePath , offset ) ; } String canonicalPath ; if ( filePath . length ( ) < offset + NUM_ ) { return super . schemeWalk ( userPath , attributes , filePath , offset ) ; } char ch1 = filePath . charAt ( offset + NUM_ ) ; char ch2 = filePath . charAt ( offset ) ; if ( ( ch2 == STR_ || ch2 == _separatorChar ) && ( ch1 == STR_ || ch1 == _separatorChar ) ) return super . schemeWalk ( userPath , attributes , convertFromWindowsPath ( filePath . substring ( offset ) ) , NUM_ ) ; else return super . schemeWalk ( userPath , attributes , filePath , offset ) ; }
void initProperties ( String defaultLevel , String defaultFilter , String defaultFormatter , String defaultEncoding ) { LogManager manager = LogManager . getLogManager ( ) ; final String filterName = manager . getProperty ( prefix + STR_ ) ; if ( filterName != null ) { try { filter = ( Filter ) getCustomizeInstance ( filterName ) ; } catch ( Exception e1 ) { printInvalidPropMessage ( STR_ , filterName , e1 ) ; filter = ( Filter ) getDefaultInstance ( defaultFilter ) ; } } else { filter = ( Filter ) getDefaultInstance ( defaultFilter ) ; } String levelName = manager . getProperty ( prefix + STR_ ) ; if ( levelName != null ) { try { level = Level . parse ( levelName ) ; } catch ( Exception e ) { printInvalidPropMessage ( STR_ , levelName , e ) ; level = Level . parse ( defaultLevel ) ; } } else { level = Level . parse ( defaultLevel ) ; } final String formatterName = manager . getProperty ( prefix + STR_ ) ; if ( formatterName != null ) { try { formatter = ( Formatter ) getCustomizeInstance ( formatterName ) ; } catch ( Exception e ) { printInvalidPropMessage ( STR_ , formatterName , e ) ; formatter = ( Formatter ) getDefaultInstance ( defaultFormatter ) ; } } else { formatter = ( Formatter ) getDefaultInstance ( defaultFormatter ) ; } final String encodingName = manager . getProperty ( prefix + STR_ ) ; try { internalSetEncoding ( encodingName ) ; } catch ( UnsupportedEncodingException e ) { printInvalidPropMessage ( STR_ , encodingName , e ) ; } }
public static void writeUnsignedVL ( long data , DataOutput out ) throws IOException { while ( BOOL_ ) { if ( ( data & ~ x7FL ) == NUM_ ) { out . writeByte ( ( int ) data ) ; return ; } else { out . writeByte ( ( ( int ) data & x7F ) | x80 ) ; data >>>= NUM_ ; } } }
public JSONArray names ( ) { JSONArray ja = new JSONArray ( ) ; Iterator keys = keys ( ) ; while ( keys . hasNext ( ) ) { ja . put ( keys . next ( ) ) ; } return ja . length ( ) == NUM_ ? null : ja ; }
public void addTableWithAlias ( String table , String alias ) { QueryTableData tableData = new QueryTableData ( ) ; tableData . setTableName ( table ) ; tableData . setTableAlias ( alias ) ; tableData . setTableIndex ( _tablesData . size ( ) ) ; _tablesData . add ( tableData ) ; if ( alias == null ) tables . put ( table , tableData ) ; else { tables . put ( alias , tableData ) ; tables . put ( table , tableData ) ; } }
private int encryptBlock ( byte [ ] in , int inOff , byte [ ] out , int outOff ) throws DataLengthException , IllegalStateException { if ( ( inOff + blockSize ) > in . length ) { throw new DataLengthException ( STR_ ) ; } for ( int i = NUM_ ; i < blockSize ; i ++ ) { cbcV [ i ] ^= in [ inOff + i ] ; } int length = cipher . processBlock ( cbcV , NUM_ , out , outOff ) ; System . arraycopy ( out , outOff , cbcV , NUM_ , cbcV . length ) ; return length ; }
private void renderAxes ( Camera camera ) { glPushMatrix ( ) ; glLoadIdentity ( ) ; float rotX = camera . getRotation ( ) . x ; float rotY = camera . getRotation ( ) . y ; float rotZ = NUM_ ; glRotatef ( rotX , NUM_ , NUM_ , NUM_ ) ; glRotatef ( rotY , NUM_ , NUM_ , NUM_ ) ; glRotatef ( rotZ , NUM_ , NUM_ , NUM_ ) ; glLineWidth ( NUM_ ) ; glBegin ( GL_LINES ) ; glColor3f ( NUM_ , NUM_ , NUM_ ) ; glVertex3f ( NUM_ , NUM_ , NUM_ ) ; glVertex3f ( NUM_ , NUM_ , NUM_ ) ; glColor3f ( NUM_ , NUM_ , NUM_ ) ; glVertex3f ( NUM_ , NUM_ , NUM_ ) ; glVertex3f ( NUM_ , NUM_ , NUM_ ) ; glColor3f ( NUM_ , NUM_ , NUM_ ) ; glVertex3f ( NUM_ , NUM_ , NUM_ ) ; glVertex3f ( NUM_ , NUM_ , NUM_ ) ; glEnd ( ) ; glPopMatrix ( ) ; }
@ Override public Object clone ( ) throws CloneNotSupportedException { PeriodAxisLabelInfo clone = ( PeriodAxisLabelInfo ) super . clone ( ) ; return clone ; }
public long skip ( long n ) throws IOException { if ( n < NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } ensureOpen ( ) ; int max = ( int ) Math . min ( n , Integer . MAX_VALUE ) ; int total = NUM_ ; while ( total < max ) { int len = max - total ; if ( len > tmpbuf . length ) { len = tmpbuf . length ; } len = read ( tmpbuf , NUM_ , len ) ; if ( len == - NUM_ ) { entryEOF = BOOL_ ; break ; } total += len ; } return total ; }
private Path convertPath ( Path path ) throws Exception { if ( mode != PROXY ) return path ; else { URI secondaryUri = new URI ( SECONDARY_URI ) ; URI pathUri = path . toUri ( ) ; return new Path ( new URI ( pathUri . getScheme ( ) != null ? secondaryUri . getScheme ( ) : null , pathUri . getAuthority ( ) != null ? secondaryUri . getAuthority ( ) : null , pathUri . getPath ( ) , null , null ) ) ; } }
private static String joinArray ( String [ ] array , String delimiter ) { StringBuffer buffer = new StringBuffer ( ) ; for ( int index = NUM_ ; index < array . length ; index ++ ) { buffer . append ( array [ index ] ) ; if ( index < array . length - NUM_ ) { buffer . append ( delimiter ) ; } } return buffer . toString ( ) ; }
private void outputPartners ( Properties ctx , PrintWriter out , int partnerID , boolean includeAny ) { out . println ( STR_ ) ; if ( includeAny ) { out . println ( STR_ ) ; if ( partnerID == NUM_ ) out . println ( STR_ ) ; out . println ( STR_ ) ; } for ( MBPartner partner : getAllPartners ( ctx ) ) { out . print ( STR_ + partner . get_ID ( ) + STR_ ) ; if ( partnerID == partner . get_ID ( ) ) out . print ( STR_ ) ; out . println ( STR_ + Util . maskHTML ( partner . getName ( ) ) + STR_ ) ; } out . println ( STR_ ) ; }
public void stop ( ) { mCancel = BOOL_ ; if ( mRunning . compareAndSet ( BOOL_ , BOOL_ ) ) { if ( mSampleDispatcherTask != null ) { mSampleDispatcherTask . cancel ( BOOL_ ) ; mFilledBuffers . clear ( ) ; } } }
public ChessSquare ( Composite parent , ChessBoard chessBoard , int id , boolean isLight ) { super ( parent , SWT . DOUBLE_BUFFERED | SWT . NO_BACKGROUND ) ; board = chessBoard ; this . id = id ; this . isLight = isLight ; addPaintListener ( paintListener ) ; addControlListener ( controlListener ) ; addMouseListener ( mouseListener ) ; addListener ( SWT . MouseWheel , mouseWheelListener ) ; addListener ( SWT . MouseDown , dndListener ) ; addListener ( SWT . MouseUp , dndListener ) ; }
@ Override protected void stopService ( ) { Thread t = keepAliveThread ; keepAliveThread = null ; if ( t != null ) { t . interrupt ( ) ; } }
public static int truncatedCompareTo ( final Calendar cal1 , final Calendar cal2 , final int field ) { final Calendar truncatedCal1 = truncate ( cal1 , field ) ; final Calendar truncatedCal2 = truncate ( cal2 , field ) ; return truncatedCal1 . compareTo ( truncatedCal2 ) ; }
public boolean isPortUsable ( StoragePort storagePort ) { return isPortUsable ( storagePort , BOOL_ ) ; }
public boolean isExpired ( ) { return this . ttl < System . currentTimeMillis ( ) ; }
@ Override public void actionPerformed ( ActionEvent event ) { String command = event . getActionCommand ( ) ; if ( command . equals ( STR_ ) ) { attemptFontSelection ( ) ; } else if ( command . equals ( STR_ ) ) { attemptPaintSelection ( ) ; } else if ( command . equals ( STR_ ) ) { attemptModifyShowTitle ( ) ; } }
void removeAttributeValues ( String attrName , Set values ) throws SMSException { if ( attrName != null ) { Map attrs = getAttributes ( ) ; Set origValues = ( Set ) attrs . get ( attrName ) ; if ( origValues != null && ! origValues . isEmpty ( ) ) { Set newValues = new HashSet ( origValues ) ; newValues . removeAll ( values ) ; if ( newValues . isEmpty ( ) ) { removeAttribute ( attrName ) ; } else { Map newAttrs = new HashMap ( ) ; newAttrs . put ( attrName , newValues ) ; setAttributes ( newAttrs ) ; } } } }
private static boolean checkContentCharacters ( String chars ) throws CharConversionException { boolean escape = BOOL_ ; for ( int i = NUM_ ; i < chars . length ( ) ; i ++ ) { char ch = chars . charAt ( i ) ; if ( ch <= NUM_ ) { switch ( ch ) { case x9 : case xA : case xD : continue ; case STR_ : if ( escape ) { continue ; } escape = ( i > NUM_ ) && ( chars . charAt ( i - NUM_ ) == STR_ ) ; continue ; case STR_ : case STR_ : escape = BOOL_ ; continue ; default : if ( ch < x20 ) { throw new CharConversionException ( STR_ + ( ( int ) ch ) + STR_ ) ; } } } } return escape == BOOL_ ; }
public void testFindAppDeployments ( ) throws Exception { WAR war = createWar ( ) ; testConfigWar ( ) ; List < Element > l = deployer . selectAppDeployments ( war , domain ) ; assertEquals ( NUM_ , l . size ( ) ) ; deployer . removeDeployableFromDomain ( war , domain ) ; l = deployer . selectAppDeployments ( war , domain ) ; assertEquals ( NUM_ , l . size ( ) ) ; }
@ Override public void drawTop ( final Graphics2D g2d ) { final Rectangle r = getArea ( ) ; if ( isContained ( ) ) { r . setLocation ( NUM_ , NUM_ ) ; } else { if ( ! isOnScreen ( g2d , r ) ) { return ; } } final Composite oldComposite = g2d . getComposite ( ) ; try { g2d . setComposite ( entityComposite ) ; drawTop ( g2d , r . x , r . y , r . width , r . height ) ; } finally { g2d . setComposite ( oldComposite ) ; } }
protected void initDebug ( ) { setDebug ( ( getInitParameter ( STR_ ) == null ) ? BOOL_ : Boolean . valueOf ( getInitParameter ( STR_ ) ) ) ; }
protected void indexNulls ( InputStream is , long ptr , List < Entry > entries ) { boolean moreRecords = BOOL_ ; byte rHdr [ ] = new byte [ SHAPE_RECORD_HEADER_LENGTH ] ; int result ; int nRecords = NUM_ ; int recLengthWords , recLengthBytes ; long recOffset ; int recBufSize = NUM_ ; byte recBuf [ ] = new byte [ recBufSize ] ; double x ; double y ; try { while ( moreRecords ) { result = is . read ( rHdr , NUM_ , SHAPE_RECORD_HEADER_LENGTH ) ; if ( result < NUM_ ) { moreRecords = BOOL_ ; if ( logger . isLoggable ( Level . FINE ) ) { logger . fine ( STR_ + nRecords + STR_ ) ; logger . fine ( STR_ + recBufSize ) ; } } else { nRecords ++ ; recOffset = ptr ; readBEInt ( rHdr , NUM_ ) ; recLengthWords = readBEInt ( rHdr , NUM_ ) ; recLengthBytes = recLengthWords . NUM_ ; if ( recLengthBytes > recBufSize ) { if ( logger . isLoggable ( Level . FINE ) ) { logger . fine ( STR_ + recLengthBytes ) ; } recBufSize = recLengthBytes ; recBuf = new byte [ recBufSize ] ; } result = is . read ( recBuf , NUM_ , recLengthBytes ) ; x = NUM_ ; y = NUM_ ; ptr += recLengthBytes + NUM_ ; Entry entry = new Entry ( x , y , x , y , ( int ) recOffset ) ; entries . add ( entry ) ; } } } catch ( java . io . IOException e ) { e . printStackTrace ( ) ; } finally { try { is . close ( ) ; } catch ( java . io . IOException e ) { } } }
protected static RpcPair resolveRpcPair ( ASTNode node , PeerTypeResolver peerResolver ) { MethodDeclaration methodDecl = ASTResolving . findParentMethodDeclaration ( node ) ; TypeDeclaration typeDecl = ( TypeDeclaration ) ASTResolving . findAncestor ( node , ASTNode . TYPE_DECLARATION ) ; assert ( typeDecl != null ) ; IType dstType = peerResolver . getPeerType ( typeDecl ) ; if ( dstType == null ) { return null ; } CompilationUnit astRoot = ASTResolving . createQuickFixAST ( dstType . getCompilationUnit ( ) , null ) ; TypeDeclaration dstTypeDecl = JavaASTUtils . findTypeDeclaration ( astRoot , dstType . getFullyQualifiedName ( STR_ ) ) ; if ( dstTypeDecl == null ) { return null ; } return new RpcPair ( typeDecl , methodDecl , dstTypeDecl ) ; }
public static void assertEquals ( FieldMatrix < ? extends FieldElement < ? > > expected , FieldMatrix < ? extends FieldElement < ? > > observed ) { Assert . assertNotNull ( STR_ , observed ) ; if ( expected . getColumnDimension ( ) != observed . getColumnDimension ( ) || expected . getRowDimension ( ) != observed . getRowDimension ( ) ) { StringBuilder messageBuffer = new StringBuilder ( ) ; messageBuffer . append ( STR_ ) ; messageBuffer . append ( STR_ + observed . getRowDimension ( ) + STR_ + observed . getColumnDimension ( ) ) ; messageBuffer . append ( STR_ + expected . getRowDimension ( ) + STR_ + expected . getColumnDimension ( ) ) ; Assert . fail ( messageBuffer . toString ( ) ) ; } for ( int i = NUM_ ; i < expected . getRowDimension ( ) ; ++ i ) { for ( int j = NUM_ ; j < expected . getColumnDimension ( ) ; ++ j ) { FieldElement < ? > eij = expected . getEntry ( i , j ) ; FieldElement < ? > oij = observed . getEntry ( i , j ) ; Assert . assertEquals ( eij , oij ) ; } } }
public void addAddition ( String addition ) { additions . add ( addition ) ; }
private void startNewTransition ( ) { if ( ! hasBounds ( ) ) { throw new UnsupportedOperationException ( STR_ + STR_ ) ; } mCurrentTrans = mTransGen . generateNextTransition ( mDrawableRect , mViewportRect ) ; mElapsedTime = NUM_ ; mLastFrameTime = System . currentTimeMillis ( ) ; fireTransitionStart ( mCurrentTrans ) ; }
protected void rotateOrthogonal ( ) { active . setRotation ( active . getRotation ( ) + NUM_ , this ) ; error . setRotation ( error . getRotation ( ) + NUM_ , this ) ; displayState ( ) ; repaint ( ) ; }
private String convertToElementName ( String attributeName ) { return attributeName . replace ( STR_ , STR_ ) ; }
private boolean hasOtherMapAndReduceParentNode ( Lop tmpNode , ArrayList < Lop > nodeList , Lop node ) { if ( tmpNode . getExecLocation ( ) == ExecLocation . MapAndReduce ) return BOOL_ ; for ( Lop n : tmpNode . getOutputs ( ) ) { if ( nodeList . contains ( n ) && isChild ( n , node , IDMap ) ) { if ( ! n . equals ( node ) && n . getExecLocation ( ) == ExecLocation . MapAndReduce ) return BOOL_ ; else return hasOtherMapAndReduceParentNode ( n , nodeList , node ) ; } } return BOOL_ ; }
public synchronized void add ( double value ) { add ( mCategories . size ( ) + STR_ , value ) ; }
@ Nullable String findLongestNamePrefix ( Node name , Set < String > namespaces ) { if ( namespaces . contains ( name . getQualifiedName ( ) ) ) { return name . getQualifiedName ( ) ; } else if ( name . isGetProp ( ) ) { return findLongestNamePrefix ( name . getFirstChild ( ) , namespaces ) ; } return null ; }
public static LogWriter createLogWriter ( final Properties properties ) { Properties nonDefault = properties ; if ( nonDefault == null ) { nonDefault = new Properties ( ) ; } DistributedTestUtils . addHydraProperties ( nonDefault ) ; DistributionConfig dc = new DistributionConfigImpl ( nonDefault ) ; LogWriter logger = LogWriterFactory . createLogWriterLogger ( BOOL_ , BOOL_ , dc , BOOL_ ) ; nonDefault . put ( DistributionConfig . LOG_WRITER_NAME , logger ) ; return logger ; }
public int session ( ) { return Integer . parseInt ( fields [ NUM_ ] ) ; }
public ReflectiveProperty ( Class < T > propertyHolder , Class < V > valueType , String name ) { super ( valueType , name ) ; char firstLetter = Character . toUpperCase ( name . charAt ( NUM_ ) ) ; String theRest = name . substring ( NUM_ ) ; String capitalizedName = firstLetter + theRest ; String getterName = PREFIX_GET + capitalizedName ; try { mGetter = propertyHolder . getMethod ( getterName , ( Class < ? > [ ] ) null ) ; } catch ( NoSuchMethodException e ) { try { mGetter = propertyHolder . getDeclaredMethod ( getterName , ( Class < ? > [ ] ) null ) ; mGetter . setAccessible ( BOOL_ ) ; } catch ( NoSuchMethodException e2 ) { getterName = PREFIX_IS + capitalizedName ; try { mGetter = propertyHolder . getMethod ( getterName , ( Class < ? > [ ] ) null ) ; } catch ( NoSuchMethodException e3 ) { try { mGetter = propertyHolder . getDeclaredMethod ( getterName , ( Class < ? > [ ] ) null ) ; mGetter . setAccessible ( BOOL_ ) ; } catch ( NoSuchMethodException e4 ) { try { mField = propertyHolder . getField ( name ) ; Class fieldType = mField . getType ( ) ; if ( ! typesMatch ( valueType , fieldType ) ) { throw new NoSuchPropertyException ( STR_ + fieldType + STR_ + STR_ + valueType + STR_ ) ; } return ; } catch ( NoSuchFieldException e5 ) { throw new NoSuchPropertyException ( STR_ + STR_ + name ) ; } } } } } Class getterType = mGetter . getReturnType ( ) ; if ( ! typesMatch ( valueType , getterType ) ) { throw new NoSuchPropertyException ( STR_ + getterType + STR_ + STR_ + valueType + STR_ ) ; } String setterName = PREFIX_SET + capitalizedName ; try { mSetter = propertyHolder . getDeclaredMethod ( setterName , getterType ) ; mSetter . setAccessible ( BOOL_ ) ; } catch ( NoSuchMethodException ignored ) { } }
private void writePhotoOverlay ( String name , String category , String description , String styleName , Location location , String photoUrl , float heading ) { if ( location != null ) { printWriter . println ( STR_ ) ; printWriter . println ( STR_ + StringUtils . formatCData ( name ) + STR_ ) ; printWriter . println ( STR_ + StringUtils . formatCData ( description ) + STR_ ) ; printWriter . print ( STR_ ) ; printWriter . print ( STR_ + location . getLongitude ( ) + STR_ ) ; printWriter . print ( STR_ + location . getLatitude ( ) + STR_ ) ; printWriter . print ( STR_ ) ; printWriter . print ( STR_ + heading + STR_ ) ; printWriter . print ( STR_ ) ; printWriter . println ( STR_ ) ; printWriter . println ( STR_ + StringUtils . formatDateTimeIso8601 ( location . getTime ( ) ) + STR_ ) ; printWriter . println ( STR_ + styleName + STR_ ) ; writeCategory ( category ) ; if ( playTrack ) { printWriter . println ( STR_ + Uri . decode ( photoUrl ) + STR_ ) ; } else { Uri uri = Uri . parse ( photoUrl ) ; printWriter . println ( STR_ + KmzTrackExporter . KMZ_IMAGES_DIR + File . separatorChar + uri . getLastPathSegment ( ) + STR_ ) ; } printWriter . print ( STR_ ) ; printWriter . print ( STR_ ) ; printWriter . print ( STR_ ) ; printWriter . print ( STR_ ) ; printWriter . print ( STR_ ) ; printWriter . print ( STR_ ) ; printWriter . println ( STR_ ) ; printWriter . println ( STR_ ) ; printWriter . println ( STR_ + getCoordinates ( location , STR_ ) + STR_ ) ; printWriter . println ( STR_ ) ; printWriter . println ( STR_ ) ; } }
public boolean onBackPressed ( ) { if ( doesDrawerExist ( ) ) { if ( mDrawer . isDrawerVisible ( Gravity . START ) ) { mDrawer . closeDrawer ( Gravity . START ) ; return BOOL_ ; } } if ( mContentView . onBackPressed ( ) ) return BOOL_ ; if ( ! mStateStack . empty ( ) ) { mStateStack . pop ( ) ; if ( ! mStateStack . empty ( ) ) { setState ( mStateStack . pop ( ) ) ; return BOOL_ ; } } return BOOL_ ; }
public void simulateMethod ( SootMethod method , ReferenceVariable thisVar , ReferenceVariable returnVar , ReferenceVariable params [ ] ) { String subSignature = method . getSubSignature ( ) ; if ( subSignature . equals ( STR_ ) ) { java_io_ObjectInputStream_latestUserDefinedLoader ( method , thisVar , returnVar , params ) ; return ; } else if ( subSignature . equals ( STR_ ) ) { java_io_ObjectInputStream_allocateNewObject ( method , thisVar , returnVar , params ) ; return ; } else if ( subSignature . equals ( STR_ ) ) { java_io_ObjectInputStream_allocateNewArray ( method , thisVar , returnVar , params ) ; return ; } else { defaultMethod ( method , thisVar , returnVar , params ) ; return ; } }
public NodeSetDTM ( NodeIterator iterator , XPathContext xctxt ) { super ( ) ; Node node ; m_manager = xctxt . getDTMManager ( ) ; while ( null != ( node = iterator . nextNode ( ) ) ) { int handle = xctxt . getDTMHandleFromNode ( node ) ; addNodeInDocOrder ( handle , xctxt ) ; } }
public ShardIterator onlyNodeSelectorActiveInitializingShardsIt ( String nodeAttribute , DiscoveryNodes discoveryNodes ) { ArrayList < ShardRouting > ordered = new ArrayList < > ( activeShards . size ( ) + allInitializingShards . size ( ) ) ; Set < String > selectedNodes = Sets . newHashSet ( discoveryNodes . resolveNodesIds ( nodeAttribute ) ) ; for ( ShardRouting shardRouting : activeShards ) { if ( selectedNodes . contains ( shardRouting . currentNodeId ( ) ) ) { ordered . add ( shardRouting ) ; } } for ( ShardRouting shardRouting : allInitializingShards ) { if ( selectedNodes . contains ( shardRouting . currentNodeId ( ) ) ) { ordered . add ( shardRouting ) ; } } if ( ordered . isEmpty ( ) ) { throw new IllegalArgumentException ( STR_ + nodeAttribute + STR_ ) ; } return new PlainShardIterator ( shardId , ordered ) ; }
private void checkChanges ( ) { settings . clearMovieNfoFilenames ( ) ; if ( cbMovieNfoFilename1 . isSelected ( ) ) { settings . addMovieNfoFilename ( MovieNfoNaming . FILENAME_NFO ) ; } if ( cbMovieNfoFilename2 . isSelected ( ) ) { settings . addMovieNfoFilename ( MovieNfoNaming . MOVIE_NFO ) ; } if ( cbMovieNfoFilename3 . isSelected ( ) ) { settings . addMovieNfoFilename ( MovieNfoNaming . DISC_NFO ) ; } CertificationStyleWrapper wrapper = ( CertificationStyleWrapper ) cbCertificationStyle . getSelectedItem ( ) ; if ( wrapper != null && settings . getMovieCertificationStyle ( ) != wrapper . style ) { settings . setMovieCertificationStyle ( wrapper . style ) ; } }
XMenuItemPeer [ ] copyItems ( ) { synchronized ( getMenuTreeLock ( ) ) { return ( XMenuItemPeer [ ] ) items . toArray ( new XMenuItemPeer [ ] { } ) ; } }
public byte receiveOneByte ( ) { Log . d ( TAG , STR_ ) ; try { acquireLock ( ) ; mServerSocket . receive ( mReceivePacket ) ; Log . d ( TAG , STR_ + ( NUM_ + mReceivePacket . getData ( ) [ NUM_ ] ) ) ; return mReceivePacket . getData ( ) [ NUM_ ] ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return Byte . MIN_VALUE ; }
public static void connectionClosed ( ) { numConnections . getAndDecrement ( ) ; }
public static String buildChatSDP ( String ipAddress , int localPort , String protocol , String acceptTypes , String wrapperTypes , String setup , String path , String direction ) { return buildSDP ( ipAddress , localPort , protocol , acceptTypes , wrapperTypes , null , null , null , setup , path , direction , null , NUM_ ) ; }
int [ ] determineDimensions ( int sourceCodeWords , int errorCorrectionCodeWords ) throws WriterException { float ratio = NUM_ ; int [ ] dimension = null ; for ( int cols = minCols ; cols <= maxCols ; cols ++ ) { int rows = calculateNumberOfRows ( sourceCodeWords , errorCorrectionCodeWords , cols ) ; if ( rows < minRows ) { break ; } if ( rows > maxRows ) { continue ; } float newRatio = ( ( NUM_ . cols + NUM_ ) . DEFAULT_MODULE_WIDTH ) / ( rows . HEIGHT ) ; if ( dimension != null && Math . abs ( newRatio - PREFERRED_RATIO ) > Math . abs ( ratio - PREFERRED_RATIO ) ) { continue ; } ratio = newRatio ; dimension = new int [ ] { cols , rows } ; } if ( dimension == null ) { int rows = calculateNumberOfRows ( sourceCodeWords , errorCorrectionCodeWords , minCols ) ; if ( rows < minRows ) { dimension = new int [ ] { minCols , minRows } ; } } if ( dimension == null ) { throw new WriterException ( STR_ ) ; } return dimension ; }
public static DataDisplayTable listFontMetrics ( Font font ) { String [ ] header = { STR_ , STR_ } ; Align [ ] displayAlignment = { Align . Left , Align . Left } ; DataDisplayTable table = new DataDisplayTable ( Arrays . asList ( header ) ) ; table . setAlignment ( Arrays . asList ( displayAlignment ) ) ; FontHeaderTable headTable = ( FontHeaderTable ) FontUtils . getTable ( font , Tag . head ) ; HorizontalHeaderTable hheaTable = ( HorizontalHeaderTable ) FontUtils . getTable ( font , Tag . hhea ) ; OS2Table os2Table = ( OS2Table ) FontUtils . getTable ( font , Tag . OS_2 ) ; table . add ( Arrays . asList ( new String [ ] { STR_ , String . format ( STR_ , headTable . unitsPerEm ( ) ) } ) ) ; table . add ( Arrays . asList ( new String [ ] { STR_ , String . format ( STR_ , headTable . xMin ( ) , headTable . xMax ( ) ) } ) ) ; table . add ( Arrays . asList ( new String [ ] { STR_ , String . format ( STR_ , headTable . yMin ( ) , headTable . yMax ( ) ) } ) ) ; table . add ( Arrays . asList ( new String [ ] { STR_ , String . format ( STR_ , headTable . lowestRecPPEM ( ) ) } ) ) ; table . add ( Arrays . asList ( new String [ ] { STR_ , String . format ( STR_ , hheaTable . ascender ( ) ) } ) ) ; table . add ( Arrays . asList ( new String [ ] { STR_ , String . format ( STR_ , hheaTable . descender ( ) ) } ) ) ; table . add ( Arrays . asList ( new String [ ] { STR_ , String . format ( STR_ , hheaTable . lineGap ( ) ) } ) ) ; table . add ( Arrays . asList ( new String [ ] { STR_ , String . format ( STR_ , os2Table . usWinAscent ( ) ) } ) ) ; table . add ( Arrays . asList ( new String [ ] { STR_ , String . format ( STR_ , os2Table . usWinDescent ( ) ) } ) ) ; table . add ( Arrays . asList ( new String [ ] { STR_ , String . format ( STR_ , os2Table . sTypoAscender ( ) ) } ) ) ; table . add ( Arrays . asList ( new String [ ] { STR_ , String . format ( STR_ , os2Table . sTypoDescender ( ) ) } ) ) ; table . add ( Arrays . asList ( new String [ ] { STR_ , String . format ( STR_ , os2Table . sTypoLineGap ( ) ) } ) ) ; return table ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( NUM_ ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . add ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
public static ShoppingCartItem makeItem ( Integer cartLocation , String itemType , String itemDescription , String productCategoryId , BigDecimal basePrice , BigDecimal selectedAmount , BigDecimal quantity , Map < String , Object > attributes , String prodCatalogId , ShoppingCart . ShoppingCartItemGroup itemGroup , LocalDispatcher dispatcher , ShoppingCart cart , Boolean triggerExternalOpsBool ) throws CartItemModifyException { Delegator delegator = cart . getDelegator ( ) ; ShoppingCartItem newItem = new ShoppingCartItem ( delegator , itemType , itemDescription , productCategoryId , basePrice , attributes , prodCatalogId , cart . getLocale ( ) , itemGroup ) ; if ( cartLocation == null ) { cart . addItemToEnd ( newItem ) ; } else { cart . addItem ( cartLocation . intValue ( ) , newItem ) ; } boolean triggerExternalOps = triggerExternalOpsBool == null ? BOOL_ : triggerExternalOpsBool . booleanValue ( ) ; try { newItem . setQuantity ( quantity , dispatcher , cart , triggerExternalOps ) ; } catch ( CartItemModifyException e ) { cart . removeEmptyCartItems ( ) ; throw e ; } if ( selectedAmount != null ) { newItem . setSelectedAmount ( selectedAmount ) ; } return newItem ; }
private native synchronized static void hookMethodNative ( Member method , Class < ? > declaringClass , int slot , Object additionalInfo ) ;
final void runWorker ( Worker w ) { Runnable task = w . firstTask ; w . firstTask = null ; boolean completedAbruptly = BOOL_ ; try { while ( task != null || ( task = getTask ( ) ) != null ) { w . lock ( ) ; clearInterruptsForTaskRun ( ) ; try { beforeExecute ( w . thread , task ) ; Throwable thrown = null ; try { task . run ( ) ; } catch ( RuntimeException x ) { thrown = x ; throw x ; } catch ( Error x ) { thrown = x ; throw x ; } catch ( Throwable x ) { thrown = x ; throw new Error ( x ) ; } finally { afterExecute ( task , thrown ) ; } } finally { task = null ; w . completedTasks ++ ; w . unlock ( ) ; } } completedAbruptly = BOOL_ ; } finally { processWorkerExit ( w , completedAbruptly ) ; } }
private static ClusterProperties fromProperties ( Properties props ) { ClusterProperties prop = new ClusterProperties ( ) ; prop . clusterName = getStringProperty ( IGNITE_CLUSTER_NAME , props , DEFAULT_CLUSTER_NAME ) ; prop . cpuPerNode = getDoubleProperty ( IGNITE_RUN_CPU_PER_NODE , props , DEFAULT_CPU_PER_NODE ) ; prop . memPerNode = getDoubleProperty ( IGNITE_MEMORY_PER_NODE , props , DEFAULT_MEM_PER_NODE ) ; prop . memOverHeadPerNode = getDoubleProperty ( IGNITE_MEMORY_OVERHEAD_PER_NODE , props , Math . max ( NUM_ . prop . memPerNode , DEFAULT_MINIMUM_MEM_OVERHEAD_PER_NODE ) ) ; prop . nodeCnt = getDoubleProperty ( IGNITE_NODE_COUNT , props , DEFAULT_IGNITE_NODE_COUNT ) ; prop . igniteUrl = getStringProperty ( IGNITE_URL , props , null ) ; prop . ignitePath = getStringProperty ( IGNITE_PATH , props , null ) ; prop . licencePath = getStringProperty ( LICENCE_PATH , props , null ) ; prop . jvmOpts = getStringProperty ( IGNITE_JVM_OPTS , props , null ) ; prop . igniteWorkDir = getStringProperty ( IGNITE_WORKING_DIR , props , DEFAULT_IGNITE_WORK_DIR ) ; prop . igniteLocalWorkDir = getStringProperty ( IGNITE_LOCAL_WORK_DIR , props , DEFAULT_IGNITE_LOCAL_WORK_DIR ) ; prop . igniteReleasesDir = getStringProperty ( IGNITE_RELEASES_DIR , props , DEFAULT_IGNITE_RELEASES_DIR ) ; prop . igniteCfg = getStringProperty ( IGNITE_CONFIG_XML , props , null ) ; prop . userLibs = getStringProperty ( IGNITE_USERS_LIBS , props , null ) ; String pattern = getStringProperty ( IGNITE_HOSTNAME_CONSTRAINT , props , null ) ; if ( pattern != null ) { try { prop . hostnameConstraint = Pattern . compile ( pattern ) ; } catch ( PatternSyntaxException e ) { log . log ( Level . WARNING , STR_ , e ) ; } } return prop ; }
public static String generateNativeGuid ( StorageSystem device ) { return String . format ( STR_ , _deviceTypeMap . get ( device . getSystemType ( ) ) , device . getSerialNumber ( ) ) ; }
public CacheMetricsSnapshot ( CacheMetrics loc , Collection < CacheMetrics > metrics ) { cacheName = loc . name ( ) ; isEmpty = loc . isEmpty ( ) ; isWriteBehindEnabled = loc . isWriteBehindEnabled ( ) ; writeBehindFlushSize = loc . getWriteBehindFlushSize ( ) ; writeBehindFlushThreadCnt = loc . getWriteBehindFlushThreadCount ( ) ; writeBehindFlushFreq = loc . getWriteBehindFlushFrequency ( ) ; writeBehindStoreBatchSize = loc . getWriteBehindStoreBatchSize ( ) ; writeBehindBufSize = loc . getWriteBehindBufferSize ( ) ; size = loc . getSize ( ) ; keySize = loc . getKeySize ( ) ; keyType = loc . getKeyType ( ) ; valType = loc . getValueType ( ) ; isStoreByVal = loc . isStoreByValue ( ) ; isStatisticsEnabled = loc . isStatisticsEnabled ( ) ; isManagementEnabled = loc . isManagementEnabled ( ) ; isReadThrough = loc . isReadThrough ( ) ; isWriteThrough = loc . isWriteThrough ( ) ; offHeapMaxSize = loc . getOffHeapMaxSize ( ) ; for ( CacheMetrics e : metrics ) { reads += e . getCacheGets ( ) ; puts += e . getCachePuts ( ) ; hits += e . getCacheHits ( ) ; misses += e . getCacheMisses ( ) ; txCommits += e . getCacheTxCommits ( ) ; txRollbacks += e . getCacheTxRollbacks ( ) ; evicts += e . getCacheEvictions ( ) ; removes += e . getCacheRemovals ( ) ; putAvgTimeNanos += e . getAveragePutTime ( ) ; getAvgTimeNanos += e . getAverageGetTime ( ) ; rmvAvgTimeNanos += e . getAverageRemoveTime ( ) ; commitAvgTimeNanos += e . getAverageTxCommitTime ( ) ; rollbackAvgTimeNanos += e . getAverageTxRollbackTime ( ) ; if ( e . getOverflowSize ( ) > - NUM_ ) overflowSize += e . getOverflowSize ( ) ; else overflowSize = - NUM_ ; offHeapGets += e . getOffHeapGets ( ) ; offHeapPuts += e . getOffHeapPuts ( ) ; offHeapRemoves += e . getOffHeapRemovals ( ) ; offHeapEvicts += e . getOffHeapEvictions ( ) ; offHeapHits += e . getOffHeapHits ( ) ; offHeapMisses += e . getOffHeapMisses ( ) ; offHeapEntriesCnt += e . getOffHeapEntriesCount ( ) ; offHeapPrimaryEntriesCnt += e . getOffHeapPrimaryEntriesCount ( ) ; offHeapBackupEntriesCnt += e . getOffHeapBackupEntriesCount ( ) ; offHeapAllocatedSize += e . getOffHeapAllocatedSize ( ) ; swapGets += e . getSwapGets ( ) ; swapPuts += e . getSwapPuts ( ) ; swapRemoves += e . getSwapRemovals ( ) ; swapHits += e . getSwapHits ( ) ; swapMisses += e . getSwapMisses ( ) ; swapEntriesCnt += e . getSwapEntriesCount ( ) ; swapSize += e . getSwapSize ( ) ; if ( e . getDhtEvictQueueCurrentSize ( ) > - NUM_ ) dhtEvictQueueCurrSize += e . getDhtEvictQueueCurrentSize ( ) ; else dhtEvictQueueCurrSize = - NUM_ ; txThreadMapSize += e . getTxThreadMapSize ( ) ; txXidMapSize += e . getTxXidMapSize ( ) ; txCommitQueueSize += e . getTxCommitQueueSize ( ) ; txPrepareQueueSize += e . getTxPrepareQueueSize ( ) ; txStartVerCountsSize += e . getTxStartVersionCountsSize ( ) ; txCommittedVersionsSize += e . getTxCommittedVersionsSize ( ) ; txRolledbackVersionsSize += e . getTxRolledbackVersionsSize ( ) ; if ( e . getTxDhtThreadMapSize ( ) > - NUM_ ) txDhtThreadMapSize += e . getTxDhtThreadMapSize ( ) ; else txDhtThreadMapSize = - NUM_ ; if ( e . getTxDhtXidMapSize ( ) > - NUM_ ) txDhtXidMapSize += e . getTxDhtXidMapSize ( ) ; else txDhtXidMapSize = - NUM_ ; if ( e . getTxDhtCommitQueueSize ( ) > - NUM_ ) txDhtCommitQueueSize += e . getTxDhtCommitQueueSize ( ) ; else txDhtCommitQueueSize = - NUM_ ; if ( e . getTxDhtPrepareQueueSize ( ) > - NUM_ ) txDhtPrepareQueueSize += e . getTxDhtPrepareQueueSize ( ) ; else txDhtPrepareQueueSize = - NUM_ ; if ( e . getTxDhtStartVersionCountsSize ( ) > - NUM_ ) txDhtStartVerCountsSize += e . getTxDhtStartVersionCountsSize ( ) ; else txDhtStartVerCountsSize = - NUM_ ; if ( e . getTxDhtCommittedVersionsSize ( ) > - NUM_ ) txDhtCommittedVersionsSize += e . getTxDhtCommittedVersionsSize ( ) ; else txDhtCommittedVersionsSize = - NUM_ ; if ( e . getTxDhtRolledbackVersionsSize ( ) > - NUM_ ) txDhtRolledbackVersionsSize += e . getTxDhtRolledbackVersionsSize ( ) ; else txDhtRolledbackVersionsSize = - NUM_ ; if ( e . getWriteBehindTotalCriticalOverflowCount ( ) > - NUM_ ) writeBehindTotalCriticalOverflowCnt += e . getWriteBehindTotalCriticalOverflowCount ( ) ; else writeBehindTotalCriticalOverflowCnt = - NUM_ ; if ( e . getWriteBehindCriticalOverflowCount ( ) > - NUM_ ) writeBehindCriticalOverflowCnt += e . getWriteBehindCriticalOverflowCount ( ) ; else writeBehindCriticalOverflowCnt = - NUM_ ; if ( e . getWriteBehindErrorRetryCount ( ) > - NUM_ ) writeBehindErrorRetryCnt += e . getWriteBehindErrorRetryCount ( ) ; else writeBehindErrorRetryCnt = - NUM_ ; } int size = metrics . size ( ) ; if ( size > NUM_ ) { putAvgTimeNanos /= size ; getAvgTimeNanos /= size ; rmvAvgTimeNanos /= size ; commitAvgTimeNanos /= size ; rollbackAvgTimeNanos /= size ; } }
private void addReference ( final int sourcePosition , final int referencePosition ) { if ( srcAndRefPositions == null ) { srcAndRefPositions = new int [ NUM_ ] ; } if ( referenceCount >= srcAndRefPositions . length ) { int [ ] a = new int [ srcAndRefPositions . length + NUM_ ] ; System . arraycopy ( srcAndRefPositions , NUM_ , a , NUM_ , srcAndRefPositions . length ) ; srcAndRefPositions = a ; } srcAndRefPositions [ referenceCount ++ ] = sourcePosition ; srcAndRefPositions [ referenceCount ++ ] = referencePosition ; }
public void step3 ( Map < String , String > fileNameToPackageName , Map < String , List < FunDef > > fileNameToFunctions ) throws SyntaxException { for ( STypeDef sTypeDef : typeDefSet ) { if ( sTypeDef instanceof SClassDef ) { List < STypeDef > circularRecorder = new ArrayList < > ( ) ; SClassDef parent = ( ( SClassDef ) sTypeDef ) . parent ( ) ; while ( parent != null ) { circularRecorder . add ( parent ) ; if ( parent . equals ( sTypeDef ) ) { err . SyntaxException ( STR_ + circularRecorder , LineCol . SYNTHETIC ) ; return ; } parent = parent . parent ( ) ; } circularRecorder . clear ( ) ; } else if ( sTypeDef instanceof SInterfaceDef ) { SInterfaceDef i = ( SInterfaceDef ) sTypeDef ; checkInterfaceCircularInheritance ( i , i . superInterfaces ( ) , new ArrayList < > ( ) ) ; } else { throw new LtBug ( STR_ + sTypeDef . getClass ( ) ) ; } } for ( STypeDef sTypeDef : typeDefSet ) { checkOverrideAllMethods ( sTypeDef ) ; } for ( String fileName : mapOfStatements . keySet ( ) ) { List < Import > imports = fileNameToImport . get ( fileName ) ; String pkg = fileNameToPackageName . get ( fileName ) ; List < FunDef > functionDefs = fileNameToFunctions . get ( fileName ) ; for ( FunDef fun : functionDefs ) { STypeDef type = getTypeWithAccess ( fun . superType , imports ) ; if ( ! ( type instanceof SClassDef || type instanceof SInterfaceDef ) ) { err . SyntaxException ( STR_ , fun . superType . line_col ( ) ) ; return ; } SConstructorDef [ ] zeroParamConstructor = new SConstructorDef [ NUM_ ] ; SMethodDef [ ] methodToOverride = new SMethodDef [ NUM_ ] ; if ( ! getMethodForLambda ( type , zeroParamConstructor , methodToOverride ) ) { err . SyntaxException ( STR_ , fun . superType . line_col ( ) ) ; return ; } SClassDef sClassDef = ( SClassDef ) types . get ( pkg + fun . name ) ; parseAnnos ( fun . annos , sClassDef , imports , ElementType . TYPE , Arrays . asList ( ElementType . METHOD , ElementType . CONSTRUCTOR ) ) ; if ( zeroParamConstructor [ NUM_ ] == null ) { sClassDef . setParent ( getObject_Class ( ) ) ; assert type instanceof SInterfaceDef ; sClassDef . superInterfaces ( ) . add ( ( SInterfaceDef ) type ) ; } else { sClassDef . setParent ( ( SClassDef ) zeroParamConstructor [ NUM_ ] . declaringType ( ) ) ; } SConstructorDef cons = new SConstructorDef ( LineCol . SYNTHETIC ) ; parseAnnos ( fun . annos , cons , imports , ElementType . CONSTRUCTOR , Arrays . asList ( ElementType . TYPE , ElementType . METHOD ) ) ; cons . setDeclaringType ( sClassDef ) ; sClassDef . constructors ( ) . add ( cons ) ; if ( zeroParamConstructor [ NUM_ ] == null ) { zeroParamConstructor [ NUM_ ] = getObject_Class ( ) . constructors ( ) . get ( NUM_ ) ; } cons . statements ( ) . add ( new Ins . InvokeSpecial ( new Ins . This ( sClassDef ) , zeroParamConstructor [ NUM_ ] , LineCol . SYNTHETIC ) ) ; cons . modifiers ( ) . add ( SModifier . PUBLIC ) ; SMethodDef method = new SMethodDef ( LineCol . SYNTHETIC ) ; method . setDeclaringType ( sClassDef ) ; method . setReturnType ( getRealReturnType ( methodToOverride [ NUM_ ] . getReturnType ( ) , BOOL_ ) ) ; method . setName ( methodToOverride [ NUM_ ] . name ( ) ) ; sClassDef . methods ( ) . add ( method ) ; parseAnnos ( fun . annos , method , imports , ElementType . METHOD , Arrays . asList ( ElementType . TYPE , ElementType . CONSTRUCTOR ) ) ; method . modifiers ( ) . add ( SModifier . PUBLIC ) ; parseParameters ( fun . params , fun . params . size ( ) , method , imports , BOOL_ ) ; methodToStatements . put ( method , fun . statements ) ; checkOverrideAllMethods ( sClassDef ) ; } } for ( STypeDef typeDef : typeDefSet ) { for ( SAnno anno : typeDef . annos ( ) ) { if ( anno . type ( ) . fullName ( ) . equals ( STR_ ) ) { final String msg = typeDef + STR_ ; if ( typeDef instanceof SInterfaceDef ) { if ( ! getMethodForLambda ( typeDef , new SConstructorDef [ NUM_ ] , new SMethodDef [ NUM_ ] ) ) { err . SyntaxException ( msg , typeDef . line_col ( ) ) ; return ; } } else { err . SyntaxException ( msg , typeDef . line_col ( ) ) ; return ; } } else if ( anno . type ( ) . fullName ( ) . equals ( STR_ ) ) { final String msg = typeDef + STR_ ; if ( typeDef instanceof SClassDef ) { if ( ! getMethodForLambda ( typeDef , new SConstructorDef [ NUM_ ] , new SMethodDef [ NUM_ ] ) ) { err . SyntaxException ( msg , typeDef . line_col ( ) ) ; return ; } } else { err . SyntaxException ( msg , typeDef . line_col ( ) ) ; return ; } } } List < SMethodDef > methods ; if ( typeDef instanceof SClassDef ) methods = ( ( SClassDef ) typeDef ) . methods ( ) ; else methods = ( ( SInterfaceDef ) typeDef ) . methods ( ) ; for ( SMethodDef method : methods ) { for ( SAnno anno : method . annos ( ) ) { if ( anno . type ( ) . fullName ( ) . equals ( STR_ ) ) { if ( method . overRide ( ) . isEmpty ( ) ) { err . SyntaxException ( method + STR_ , method . line_col ( ) ) ; return ; } } } } } for ( STypeDef typeDef : typeDefSet ) { if ( typeDef instanceof SClassDef ) { SClassDef cls = ( SClassDef ) typeDef ; if ( cls . isDataClass ( ) ) { fillMethodsIntoDataClass ( cls ) ; } } } }
public void removeAllUpdateListeners ( ) { if ( mUpdateListeners == null ) { return ; } mUpdateListeners . clear ( ) ; mUpdateListeners = null ; }
public Vector2 floor ( ) { x = ( float ) Math . floor ( x ) ; z = ( float ) Math . floor ( z ) ; return this ; }
public static Location createLocation ( final String rawJSON ) throws TwitterException { try { final JSONObject json = new JSONObject ( rawJSON ) ; return locationConstructor . newInstance ( json ) ; } catch ( final InstantiationException e ) { throw new TwitterException ( e ) ; } catch ( final IllegalAccessException e ) { throw new AssertionError ( e ) ; } catch ( final InvocationTargetException e ) { throw new TwitterException ( e ) ; } catch ( final JSONException e ) { throw new TwitterException ( e ) ; } }
@ Override protected int calcAttackValue ( ) { int av = NUM_ ; if ( bDirect ) { av = Math . min ( av + ( toHit . getMoS ( ) / NUM_ ) , av . NUM_ ) ; } if ( bGlancing ) { av = ( int ) Math . floor ( av / NUM_ ) ; } av = ( int ) Math . floor ( getBracketingMultiplier ( ) . av ) ; return av ; }
public void test_writeImmutable ( ) { final IRawStore store = getStore ( ) ; try { final int len = NUM_ ; final byte [ ] expected1 = new byte [ len ] ; r . nextBytes ( expected1 ) ; final ByteBuffer tmp = ByteBuffer . wrap ( expected1 ) ; final long addr1 = store . write ( tmp ) ; assertEquals ( len , tmp . position ( ) ) ; assertEquals ( tmp . position ( ) , tmp . limit ( ) ) ; assertEquals ( expected1 , store . read ( addr1 ) ) ; final byte [ ] expected2 = expected1 . clone ( ) ; r . nextBytes ( expected1 ) ; assertEquals ( expected2 , store . read ( addr1 ) ) ; } finally { store . destroy ( ) ; } }
@ Override public String queryToRetrieveData ( ) { String parameterizedQuery ; if ( query . contains ( STR_ ) ) { parameterizedQuery = query . replace ( STR_ , startRow + STR_ ) ; } else { parameterizedQuery = query ; } return parameterizedQuery ; }
public String toString ( ) { String classname = Util . getUnqualifiedName ( getClass ( ) ) ; return ( ref == null ) ? classname : classname + STR_ + ref . remoteToString ( ) + STR_ ; }
private static void initialise ( ) { Hints hints = new Hints ( Hints . CRS , DefaultGeographicCRS . WGS84 ) ; PositionFactory positionFactory = GeometryFactoryFinder . getPositionFactory ( hints ) ; GeometryFactory geometryFactory = GeometryFactoryFinder . getGeometryFactory ( hints ) ; PrimitiveFactory primitiveFactory = GeometryFactoryFinder . getPrimitiveFactory ( hints ) ; AggregateFactory aggregateFactory = GeometryFactoryFinder . getAggregateFactory ( hints ) ; wktParser = new WKTParser ( geometryFactory , primitiveFactory , positionFactory , aggregateFactory ) ; wktTypeList . add ( new WKTType ( WKT_POINT , BOOL_ , NUM_ , STR_ , BOOL_ ) ) ; wktTypeList . add ( new WKTType ( WKT_MULTIPOINT , BOOL_ , NUM_ , STR_ , BOOL_ ) ) ; wktTypeList . add ( new WKTType ( WKT_LINESTRING , BOOL_ , NUM_ , STR_ , BOOL_ ) ) ; wktTypeList . add ( new WKTType ( STR_ , BOOL_ , NUM_ , STR_ , BOOL_ ) ) ; wktTypeList . add ( new WKTType ( WKT_MULTILINESTRING , BOOL_ , NUM_ , STR_ , BOOL_ ) ) ; wktTypeList . add ( new WKTType ( WKT_POLYGON , BOOL_ , - NUM_ , STR_ , BOOL_ ) ) ; wktTypeList . add ( new WKTType ( WKT_MULTIPOLYGON , BOOL_ , - NUM_ , STR_ , BOOL_ , BOOL_ ) ) ; for ( WKTType wkyType : wktTypeList ) { wktTypeMap . put ( wkyType . getName ( ) , wkyType ) ; } }
public Instances pruneToK ( Instances neighbours , double [ ] distances , int k ) { if ( neighbours == null || distances == null || neighbours . numInstances ( ) == NUM_ ) { return null ; } if ( k < NUM_ ) { k = NUM_ ; } int currentK = NUM_ ; double currentDist ; for ( int i = NUM_ ; i < neighbours . numInstances ( ) ; i ++ ) { currentK ++ ; currentDist = distances [ i ] ; if ( currentK > k && currentDist != distances [ i - NUM_ ] ) { currentK -- ; neighbours = new Instances ( neighbours , NUM_ , currentK ) ; break ; } } return neighbours ; }
@ Override protected String doInBackground ( String ... f_url ) { int count ; InputStream input = null ; OutputStream output = null ; try { URL url = new URL ( f_url [ NUM_ ] ) ; URLConnection connection = url . openConnection ( ) ; connection . connect ( ) ; int lengthOfFile = connection . getContentLength ( ) ; input = new BufferedInputStream ( url . openStream ( ) , NUM_ ) ; output = new FileOutputStream ( f_url [ NUM_ ] ) ; byte data [ ] = new byte [ NUM_ ] ; long total = NUM_ ; while ( ( count = input . read ( data ) ) != - NUM_ ) { total += count ; publishProgress ( Integer . toString ( ( int ) ( ( total . NUM_ ) / lengthOfFile ) ) ) ; output . write ( data , NUM_ , count ) ; } output . flush ( ) ; } catch ( Exception e ) { Log . e ( STR_ , e . getMessage ( ) ) ; } finally { try { if ( output != null ) output . close ( ) ; } catch ( Exception e ) { Log . e ( STR_ , e . getMessage ( ) ) ; } try { if ( input != null ) input . close ( ) ; } catch ( Exception e ) { Log . e ( STR_ , e . getMessage ( ) ) ; } } return null ; }
public void error ( String msg ) { print ( STR_ + msg , out . err ) ; }
public static void loadArmV7aLibrary ( ApplicationLike applicationLike , String libName ) { if ( libName == null || libName . isEmpty ( ) || applicationLike == null ) { throw new TinkerRuntimeException ( STR_ ) ; } if ( TinkerApplicationHelper . isTinkerEnableForNativeLib ( applicationLike ) ) { if ( TinkerApplicationHelper . loadLibraryFromTinker ( applicationLike , STR_ , libName ) ) { return ; } } System . loadLibrary ( libName ) ; }
AtomicSequence ( final long initialValue ) { UPDATER . lazySet ( this , initialValue ) ; }
public void keyReleased ( KeyEvent e ) { if ( e . isShiftDown ( ) && e . getKeyCode ( ) == NEXT_THROTTLE_KEY ) { requestFocusForNextFrame ( ) ; } else if ( e . isShiftDown ( ) && e . getKeyCode ( ) == PREV_THROTTLE_KEY ) { requestFocusForPreviousFrame ( ) ; } }
protected static Long convertStringToBuckectingLong ( String stringToBeConverted ) { if ( stringToBeConverted == null || stringToBeConverted . equals ( STR_ ) ) { return null ; } byte [ ] byteString = stringToBeConverted . getBytes ( ) ; if ( byteString . length < NUM_ ) { byte [ ] newByteString = new byte [ NUM_ ] ; for ( int i = NUM_ ; i < newByteString . length ; i ++ ) { if ( i < byteString . length ) { newByteString [ i ] = byteString [ i ] ; } else { newByteString [ i ] = NUM_ ; } } byteString = newByteString ; } ByteBuffer bb = ByteBuffer . wrap ( byteString ) ; long byteMethod = bb . getLong ( ) ; byteMethod = Math . abs ( byteMethod ) ; return byteMethod ; }
@ Override public void closeInvoked ( ) { }
private void pendingEvent ( EventReg reg , ServiceID sid , Item item , int transition , boolean copyItem ) { if ( item != null && copyItem ) item = copyItem ( item ) ; newNotifies . add ( new EventTask ( reg , sid , item , transition ) ) ; }
public static void writeln ( String fileName , Object [ ] objects ) { if ( writer == null ) { createWriter ( fileName ) ; for ( Object obj : objects ) { writeln ( obj . toString ( ) ) ; } closeWriter ( ) ; } }
protected double regressionPrediction ( Instance transformedInstance , boolean [ ] selectedAttributes , double [ ] coefficients ) throws Exception { double result = NUM_ ; int column = NUM_ ; for ( int j = NUM_ ; j < transformedInstance . numAttributes ( ) ; j ++ ) { if ( ( m_ClassIndex != j ) && ( selectedAttributes [ j ] ) ) { result += coefficients [ column ] . transformedInstance . value ( j ) ; column ++ ; } } result += coefficients [ column ] ; return result ; }
public QLFDocument ( List < F > list , String docno , Map < String , String > extraProps ) { featureList = new MemoryLocalFeatureList < F > ( list ) ; iterator = list . iterator ( ) ; if ( extraProps != null ) props . putAll ( extraProps ) ; props . put ( STR_ , docno ) ; }
@ Override protected TemplateModel invokeGenericGet ( Map keyMap , Class clazz , String key ) throws TemplateModelException { Map map = ( Map ) object ; Object val = map . get ( key ) ; if ( val == null ) { if ( key . length ( ) == NUM_ ) { Character charKey = Character . valueOf ( key . charAt ( NUM_ ) ) ; val = map . get ( charKey ) ; if ( val == null && ! ( map . containsKey ( key ) || map . containsKey ( charKey ) ) ) { return UNKNOWN ; } } else if ( ! map . containsKey ( key ) ) { return UNKNOWN ; } } return wrap ( val ) ; }
public byte [ ] toZOrderByteArray ( final BigInteger bigInt ) { final int numDimensions = datatypeConfig . getNumDimensions ( ) ; final byte [ ] bigIntAsByteArr = bigInt . toByteArray ( ) ; final int paddedArraySize = numDimensions . BASE_SIZE + NUM_ ; final byte [ ] bigIntAsByteArrPad = new byte [ paddedArraySize ] ; int idx = NUM_ ; for ( int i = NUM_ ; i < paddedArraySize - bigIntAsByteArr . length ; i ++ ) { bigIntAsByteArrPad [ idx ++ ] = NUM_ ; } for ( int i = NUM_ ; i < bigIntAsByteArr . length ; i ++ ) { bigIntAsByteArrPad [ idx ++ ] = bigIntAsByteArr [ i ] ; } final byte [ ] bigIntAsByteArrUnsigned = unpadLeadingZero ( bigIntAsByteArrPad ) ; return bigIntAsByteArrUnsigned ; }
public void clearLogcat ( @ NotNull IDevice device , @ NotNull Project project ) { synchronized ( myLock ) { ExecutorService executor = myExecutors . get ( device ) ; if ( executor != null ) { stopReceiving ( device ) ; executor . submit ( null ) ; startReceiving ( device ) ; } } }
public void expand ( int level ) { ArrayList < S2CellId > output = new ArrayList < S2CellId > ( ) ; long levelLsb = S2CellId . lowestOnBitForLevel ( level ) ; int i = size ( ) - NUM_ ; do { S2CellId id = cellId ( i ) ; if ( id . lowestOnBit ( ) < levelLsb ) { id = id . parent ( level ) ; while ( i > NUM_ && id . contains ( cellId ( i - NUM_ ) ) ) { -- i ; } } output . add ( id ) ; id . getAllNeighbors ( level , output ) ; } while ( -- i >= NUM_ ) ; initSwap ( output ) ; }
private StringSet discoverVolumeSnaps ( StorageSystem system , List < Snap > snaps , String parentGUID , StringSet parentMatchedVPools , VNXeApiClient apiClient , DbClient dbClient , Map < String , List < UnManagedVolume > > hostVolumesMap , VNXeLun lun , boolean isSnapInCG , String cgName ) throws Exception { StringSet snapsets = new StringSet ( ) ; for ( Snap snapDetail : snaps ) { UnManagedVolume unManagedVolume = null ; String managedSnapNativeGuid = NativeGUIDGenerator . generateNativeGuidForVolumeOrBlockSnapShot ( system . getNativeGuid ( ) , snapDetail . getId ( ) ) ; BlockSnapshot viprSnap = DiscoveryUtils . checkBlockSnapshotExistsInDB ( dbClient , managedSnapNativeGuid ) ; if ( null != viprSnap ) { log . info ( STR_ , managedSnapNativeGuid ) ; snapsets . add ( managedSnapNativeGuid ) ; continue ; } String unManagedVolumeNatvieGuid = NativeGUIDGenerator . generateNativeGuidForPreExistingVolume ( system . getNativeGuid ( ) , snapDetail . getId ( ) ) ; unManagedVolume = DiscoveryUtils . checkUnManagedVolumeExistsInDB ( dbClient , unManagedVolumeNatvieGuid ) ; unManagedVolume = createUnManagedVolumeForSnap ( unManagedVolume , unManagedVolumeNatvieGuid , lun , system , dbClient , hostVolumesMap , snapDetail ) ; populateSnapInfo ( unManagedVolume , snapDetail , parentGUID , parentMatchedVPools ) ; snapsets . add ( unManagedVolumeNatvieGuid ) ; unManagedVolumesReturnedFromProvider . add ( unManagedVolume . getId ( ) ) ; if ( isSnapInCG ) { addObjectToUnManagedConsistencyGroup ( apiClient , unManagedVolume , cgName , system , dbClient ) ; } } return snapsets ; }
public void receive ( final CallEvent event ) { if ( event . isValid ( ) ) { if ( ! mEvents . contains ( event ) ) { mEvents . add ( NUM_ , event ) ; fireTableRowsInserted ( NUM_ , NUM_ ) ; prune ( ) ; } else { int row = mEvents . indexOf ( event ) ; fireTableRowsUpdated ( row , row ) ; } } else { if ( mEvents . contains ( event ) ) { int row = mEvents . indexOf ( event ) ; mEvents . remove ( event ) ; fireTableRowsDeleted ( row , row ) ; } } }
public Pet findOne ( String id ) { log . debug ( STR_ , id ) ; Pet pet = petRepository . findOne ( UUID . fromString ( id ) ) ; return pet ; }
public final void clear ( ) { mActiveIssues . clear ( ) ; }
public static void awaitDataReady ( ) { synchronized ( mDbHelperLock ) { if ( mDbHelper == null ) { try { mDbHelperLock . wait ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } }
protected AbstractIoSession ( IoService service ) { this . service = service ; this . handler = service . getHandler ( ) ; long currentTime = System . currentTimeMillis ( ) ; creationTime = currentTime ; lastThroughputCalculationTime = currentTime ; lastReadTime = currentTime ; lastWriteTime = currentTime ; lastIdleTimeForBoth = currentTime ; lastIdleTimeForRead = currentTime ; lastIdleTimeForWrite = currentTime ; closeFuture . addListener ( SCHEDULED_COUNTER_RESETTER ) ; sessionId = idGenerator . incrementAndGet ( ) ; }
private String processFloatToken ( String token ) { String result = token . replaceAll ( groupSeparator , STR_ ) ; if ( ! decimalSeparator . equals ( STR_ ) ) result = result . replaceAll ( decimalSeparator , STR_ ) ; boolean isNegative = BOOL_ ; int preLen = negativePrefix . length ( ) ; if ( ( preLen > NUM_ ) && result . startsWith ( negativePrefix ) ) { isNegative = BOOL_ ; result = result . substring ( preLen ) ; } int sufLen = negativeSuffix . length ( ) ; if ( ( sufLen > NUM_ ) && result . endsWith ( negativeSuffix ) ) { isNegative = BOOL_ ; result = result . substring ( result . length ( ) - sufLen , result . length ( ) ) ; } if ( result . equals ( nanString ) ) result = STR_ ; if ( result . equals ( infinityString ) ) result = STR_ ; if ( isNegative ) result = STR_ + result ; Matcher m = NON_ASCII_DIGIT . matcher ( result ) ; if ( m . find ( ) ) { StringBuilder inASCII = new StringBuilder ( ) ; for ( int i = NUM_ ; i < result . length ( ) ; i ++ ) { char nextChar = result . charAt ( i ) ; if ( Character . isDigit ( nextChar ) ) { int d = Character . digit ( nextChar , NUM_ ) ; if ( d != - NUM_ ) inASCII . append ( d ) ; else inASCII . append ( nextChar ) ; } else { inASCII . append ( nextChar ) ; } } result = inASCII . toString ( ) ; } return result ; }
InternalWindow ( String title ) { setLayout ( new BorderLayout ( ) ) ; titleBar = new TitleBar ( ) ; add ( titleBar , BorderLayout . NORTH ) ; titleBar . setLayout ( new SBoxLayout ( SBoxLayout . HORIZONTAL , TITLEBAR_PADDING ) ) ; titleLabel = new JLabel ( ) ; setTitle ( title ) ; titleLabel . setMinimumSize ( new Dimension ( NUM_ , NUM_ ) ) ; titleBar . add ( titleLabel ) ; SBoxLayout . addSpring ( titleBar ) ; minimizeButton = new JButton ( minimizeIcon ) ; minimizeButton . setMargin ( new Insets ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; minimizeButton . setBorder ( BorderFactory . createEmptyBorder ( ) ) ; minimizeButton . setFocusable ( BOOL_ ) ; minimizeButton . addActionListener ( new MinimizeListener ( ) ) ; titleBar . add ( minimizeButton ) ; closeButton = new JButton ( closeIcon ) ; closeButton . setMargin ( new Insets ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; closeButton . setBorder ( BorderFactory . createEmptyBorder ( ) ) ; closeButton . setFocusable ( BOOL_ ) ; closeButton . addActionListener ( new CloseActionListener ( ) ) ; titleBar . add ( closeButton ) ; cache = new ComponentPaintCache ( this ) ; }
@ SuppressWarnings ( STR_ ) public static Map < String , Object > loadStream ( InputStream inputStream ) { LOG . fine ( STR_ ) ; Yaml yaml = new Yaml ( ) ; Map < Object , Object > propsYaml = ( Map < Object , Object > ) yaml . load ( inputStream ) ; LOG . fine ( STR_ ) ; Map < String , Object > typedMap = new HashMap < > ( ) ; for ( Object key : propsYaml . keySet ( ) ) { typedMap . put ( key . toString ( ) , propsYaml . get ( key ) ) ; } return typedMap ; }
String [ ] split ( final String stringToSplit ) { if ( StringUtils . isNotBlank ( stringToSplit ) ) { int strLenght = stringToSplit . length ( ) ; int splitNum = strLenght / chunkSize ; if ( strLenght % chunkSize > NUM_ ) { splitNum += NUM_ ; } String [ ] result = new String [ splitNum ] ; for ( int i = NUM_ ; i < splitNum ; i ++ ) { int startPos = i . chunkSize ; int endPos = startPos + chunkSize ; if ( endPos > strLenght ) { endPos = strLenght ; } result [ i ] = stringToSplit . substring ( startPos , endPos ) ; } return result ; } return null ; }
public void logVelocityMessage ( int level , String message ) { synchronized ( this ) { Object [ ] data = new Object [ NUM_ ] ; data [ NUM_ ] = new Integer ( level ) ; data [ NUM_ ] = message ; pendingMessages . addElement ( data ) ; } }
public void testShiftRightNegNonZeroes ( ) { byte aBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = - NUM_ ; int number = NUM_ ; byte rBytes [ ] = { - NUM_ , - NUM_ , NUM_ , - NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger result = aNumber . shiftRight ( number ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , - NUM_ , result . signum ( ) ) ; }
public void removeAllAddresses ( ) { addresses . clear ( ) ; }
public static boolean isShowTooltips ( ) { return showTooltips ; }
private void addReference ( final int sourcePosition , final int referencePosition ) { if ( srcAndRefPositions == null ) { srcAndRefPositions = new int [ NUM_ ] ; } if ( referenceCount >= srcAndRefPositions . length ) { int [ ] a = new int [ srcAndRefPositions . length + NUM_ ] ; System . arraycopy ( srcAndRefPositions , NUM_ , a , NUM_ , srcAndRefPositions . length ) ; srcAndRefPositions = a ; } srcAndRefPositions [ referenceCount ++ ] = sourcePosition ; srcAndRefPositions [ referenceCount ++ ] = referencePosition ; }
public void dispose ( ) { logDebug ( STR_ ) ; mSetupDone = BOOL_ ; if ( mServiceConn != null ) { logDebug ( STR_ ) ; if ( mContext != null ) mContext . unbindService ( mServiceConn ) ; } mDisposed = BOOL_ ; mContext = null ; mServiceConn = null ; mService = null ; mPurchaseListener = null ; }
public static java . lang . String toBinaryString ( int i ) { return intToBinaryString ( i ) ; }
public static boolean isPropertyField ( String fieldName ) { return ! ID_FIELD_NAME . equals ( fieldName ) && ! URI_FIELD_NAME . equals ( fieldName ) && ! TEXT_FIELD_NAME . equals ( fieldName ) && ! CONTEXT_FIELD_NAME . equals ( fieldName ) && fieldName . charAt ( NUM_ ) != STR_ ; }
public static void checkAccess ( int modifiers ) { if ( System . getSecurityManager ( ) != null && ! Modifier . isPublic ( modifiers ) ) { throw new SecurityException ( STR_ ) ; } }
protected void printIndent ( StringBuilder ddl ) { ddl . append ( getIndent ( ) ) ; }
public NType merge ( NType a , NType b ) throws MergeFailed { if ( a != null && b == null ) return a ; if ( a == null && b != null ) return b ; if ( a == null && b == null ) return null ; if ( a . equals ( b ) ) return a ; try { return Dispatcher . dispatch ( getClass ( ) , this , STR_ , a , b ) ; } catch ( NoSuchMethodException e ) { throw new MergeFailed ( STR_ , a , b ) ; } }
public static String format ( String s , String col ) { String s1 = ( s + padd ) ; return s1 . substring ( NUM_ , Math . min ( col . length ( ) , s1 . length ( ) ) ) ; }
protected static void loadEnd ( MLookupInfo info , HashMap lookup ) { if ( info . IsValidated && lookup . size ( ) > NUM_ ) s_loadedLookups . put ( getKey ( info ) , lookup ) ; }
public static void info ( final String message ) { infoLogger . accept ( message ) ; }
private void rotateRight ( Node < K , V > root ) { Node < K , V > pivot = root . left ; Node < K , V > right = root . right ; Node < K , V > pivotLeft = pivot . left ; Node < K , V > pivotRight = pivot . right ; root . left = pivotRight ; if ( pivotRight != null ) { pivotRight . parent = root ; } replaceInParent ( root , pivot ) ; pivot . right = root ; root . parent = pivot ; root . height = Math . max ( right != null ? right . height : NUM_ , pivotRight != null ? pivotRight . height : NUM_ ) + NUM_ ; pivot . height = Math . max ( root . height , pivotLeft != null ? pivotLeft . height : NUM_ ) + NUM_ ; }
private void checkNoCharactersMissing ( int totalLength , List < Token > tokens ) { if ( ! tokens . isEmpty ( ) && tokens . get ( tokens . size ( ) - NUM_ ) . right != totalLength ) { String error = String . format ( STR_ , tokens . get ( tokens . size ( ) - NUM_ ) . right , totalLength ) ; throw new RuntimeException ( error ) ; } int start = NUM_ ; for ( int i = NUM_ ; i < tokens . size ( ) ; i ++ ) { Token token = tokens . get ( i ) ; if ( token . left != start ) { throw new RuntimeException ( STR_ + start ) ; } start = token . right ; } }
public boolean validateServiceAttributes ( String token , String validatorClass , Set values ) throws SMSException , SSOException , RemoteException { initialize ( ) ; if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + validatorClass + STR_ + values ) ; } try { Class clazz = Class . forName ( validatorClass ) ; ServiceAttributeValidator v = ( ServiceAttributeValidator ) clazz . newInstance ( ) ; return v . validate ( values ) ; } catch ( InstantiationException ex ) { throw new SMSException ( STR_ ) ; } catch ( IllegalAccessException ex ) { throw new SMSException ( STR_ ) ; } catch ( ClassNotFoundException ex ) { throw new SMSException ( STR_ ) ; } }
public synchronized void animatePanTo ( Point2D p , long duration ) { Point2D pp = new Point2D . Double ( ) ; m_itransform . transform ( p , pp ) ; animatePanToAbs ( pp , duration ) ; }
public static void assertEqualsWithRelativeErrorOrBothNaN ( String message , double expected , double actual ) { if ( expected == actual ) { return ; } if ( Double . isNaN ( expected ) && ! Double . isNaN ( actual ) ) { throw new AssertionFailedError ( message + STR_ + expected + STR_ + actual + STR_ ) ; } if ( ! Double . isNaN ( expected ) && Double . isNaN ( actual ) ) { throw new AssertionFailedError ( message + STR_ + expected + STR_ + actual + STR_ ) ; } double relativeError ; if ( Math . abs ( actual ) > Math . abs ( expected ) ) { relativeError = Math . abs ( ( expected - actual ) / actual ) ; } else { relativeError = Math . abs ( ( expected - actual ) / expected ) ; } if ( relativeError > MAX_RELATIVE_ERROR ) { throw new AssertionFailedError ( message + STR_ + expected + STR_ + actual + STR_ ) ; } }
protected void assertException ( final AbstractExceptionCase exceptionCase ) throws Throwable { assertException ( exceptionCase , null ) ; }
@ Override public ServiceHost start ( ) throws Throwable { super . start ( ) ; startDefaultCoreServicesSynchronously ( ) ; super . startService ( new RootNamespaceService ( ) ) ; super . startService ( new SampleServiceWithSharedCustomUi ( ) ) ; super . startService ( new SampleFactoryServiceWithCustomUi ( ) ) ; super . startFactory ( new SampleSimpleEchoService ( ) ) ; super . startFactory ( new SamplePreviousEchoService ( ) ) ; super . startFactory ( new ExampleService ( ) ) ; super . startFactory ( new ExampleTaskService ( ) ) ; super . startService ( new UiService ( ) ) ; startSwaggerDescriptorService ( ) ; return this ; }
@ Override public void endOfStream ( ) throws AdeException { for ( MsgData data : m_msgData . values ( ) ) { if ( data . m_totalLogCounts > NUM_ ) { data . m_lambda = data . m_totalLogCounts / data . m_intervalCount ; m_minLambda = Math . min ( data . m_lambda , m_minLambda ) ; if ( locateMismatchingDistributions ( data ) ) { data . m_badFit = BOOL_ ; } } } m_trained = BOOL_ ; }
static BinaryTree < Integer > buildComplete ( int n ) { BinaryTree < Integer > bt = new BinaryTree < Integer > ( ) ; int b = ( int ) Math . pow ( NUM_ , n - NUM_ ) ; for ( int i = NUM_ ; i < n ; i ++ ) { bt . insert ( b ) ; for ( int j = NUM_ ; j <= Math . pow ( NUM_ , i ) - NUM_ ; j ++ ) { bt . insert ( b + NUM_ . b . j ) ; } b = b / NUM_ ; } return bt ; }
public void erase ( ) { byte [ ] bytes = null ; for ( ByteBuffer buffer : buffers ) { if ( bytes == null || bytes . length < buffer . limit ( ) ) bytes = new byte [ buffer . limit ( ) ] ; buffer . position ( NUM_ ) ; buffer . put ( bytes , NUM_ , buffer . limit ( ) ) ; buffer . position ( NUM_ ) ; } }
@ Override boolean resurrectSelection ( ) { final int childCount = getChildCount ( ) ; if ( childCount <= NUM_ ) { return BOOL_ ; } int selectedTop = NUM_ ; int selectedPos ; int childrenTop = mListPadding . top ; int childrenBottom = getBottom ( ) - getTop ( ) - mListPadding . bottom ; final int firstPosition = mFirstPosition ; final int toPosition = mResurrectToPosition ; boolean down = BOOL_ ; if ( toPosition >= firstPosition && toPosition < firstPosition + childCount ) { selectedPos = toPosition ; final View selected = getChildAt ( selectedPos - mFirstPosition ) ; selectedTop = selected . getTop ( ) ; int selectedBottom = selected . getBottom ( ) ; if ( selectedTop < childrenTop ) { selectedTop = childrenTop + getVerticalFadingEdgeLength ( ) ; } else if ( selectedBottom > childrenBottom ) { selectedTop = childrenBottom - selected . getMeasuredHeight ( ) - getVerticalFadingEdgeLength ( ) ; } } else { if ( toPosition < firstPosition ) { selectedPos = firstPosition ; for ( int i = NUM_ ; i < childCount ; i ++ ) { final View v = getChildAt ( i ) ; final int top = v . getTop ( ) ; if ( i == NUM_ ) { selectedTop = top ; if ( firstPosition > NUM_ || top < childrenTop ) { childrenTop += getVerticalFadingEdgeLength ( ) ; } } if ( top >= childrenTop ) { selectedPos = firstPosition + i ; selectedTop = top ; break ; } } } else { final int itemCount = mItemCount ; down = BOOL_ ; selectedPos = firstPosition + childCount - NUM_ ; for ( int i = childCount - NUM_ ; i >= NUM_ ; i -- ) { final View v = getChildAt ( i ) ; final int top = v . getTop ( ) ; final int bottom = v . getBottom ( ) ; if ( i == childCount - NUM_ ) { selectedTop = top ; if ( firstPosition + childCount < itemCount || bottom > childrenBottom ) { childrenBottom -= getVerticalFadingEdgeLength ( ) ; } } if ( bottom <= childrenBottom ) { selectedPos = firstPosition + i ; selectedTop = top ; break ; } } } } mResurrectToPosition = INVALID_POSITION ; removeCallbacks ( mFlingRunnable ) ; mTouchMode = TOUCH_MODE_REST ; clearScrollingCache ( ) ; mSpecificTop = selectedTop ; selectedPos = lookForSelectablePosition ( selectedPos , down ) ; if ( selectedPos >= firstPosition && selectedPos <= getLastVisiblePosition ( ) ) { mLayoutMode = LAYOUT_SPECIFIC ; setSelectionInt ( selectedPos ) ; invokeOnItemScrollListener ( ) ; } else { selectedPos = INVALID_POSITION ; } reportScrollStateChange ( OnScrollListener . SCROLL_STATE_IDLE ) ; return selectedPos >= NUM_ ; }
public void logPurchase ( BigDecimal purchaseAmount , Currency currency , Bundle parameters ) { if ( purchaseAmount == null ) { notifyDeveloperError ( STR_ ) ; return ; } else if ( currency == null ) { notifyDeveloperError ( STR_ ) ; return ; } if ( parameters == null ) { parameters = new Bundle ( ) ; } parameters . putString ( AppEventsConstants . EVENT_PARAM_CURRENCY , currency . getCurrencyCode ( ) ) ; logEvent ( AppEventsConstants . EVENT_NAME_PURCHASED , purchaseAmount . doubleValue ( ) , parameters ) ; eagerFlush ( ) ; }
public static String padBetween ( final String first , final int length , final String last ) { final int padlen = length - ( first . length ( ) + last . length ( ) ) ; return first + ( padlen > NUM_ ? getSpaceString ( padlen ) : STR_ ) + last ; }
public void applyFromResolveInfo ( PackageManager pm , ResolveInfo info , WidgetPreviewLoader loader ) { mInfo = info ; CharSequence label = info . loadLabel ( pm ) ; mWidgetName . setText ( label ) ; mWidgetDims . setText ( String . format ( mDimensionsFormatString , NUM_ , NUM_ ) ) ; mWidgetPreviewLoader = loader ; }
private QueueConnectionImpl createNewPrimary ( Set excludedServers ) { QueueConnectionImpl primary = null ; while ( primary == null && pool . getPoolOrCacheCancelInProgress ( ) == null ) { List servers = findQueueServers ( excludedServers , NUM_ , BOOL_ , printPrimaryNotFoundError , LocalizedStrings . QueueManagerImpl_COULD_NOT_FIND_SERVER_TO_CREATE_PRIMARY_CLIENT_QUEUE ) ; printPrimaryNotFoundError = BOOL_ ; if ( servers == null || servers . isEmpty ( ) ) { break ; } Connection connection = null ; try { connection = factory . createClientToServerConnection ( ( ServerLocation ) servers . get ( NUM_ ) , BOOL_ ) ; } catch ( GemFireSecurityException e ) { throw e ; } catch ( Exception e ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STR_ , servers . get ( NUM_ ) ) ; } } if ( connection != null ) { primary = initializeQueueConnection ( connection , BOOL_ , queueConnections . getFailedUpdater ( ) ) ; } excludedServers . addAll ( servers ) ; } if ( primary != null && sentClientReady && primary . sendClientReady ( ) ) { readyForEventsAfterFailover ( primary ) ; } return primary ; }
public static int readInt ( ) { return scanner . nextInt ( ) ; }
public CSVConfig guess ( ) { try { BufferedReader bIn = new BufferedReader ( new InputStreamReader ( getInputStream ( ) , StandardCharsets . UTF_8 ) ) ; String [ ] lines = new String [ NUM_ ] ; String line = null ; int counter = NUM_ ; while ( ( line = bIn . readLine ( ) ) != null && counter <= NUM_ ) { lines [ counter ] = line ; counter ++ ; } if ( counter < NUM_ ) { String [ ] newLines = new String [ counter ] ; System . arraycopy ( lines , NUM_ , newLines , NUM_ , counter ) ; lines = newLines ; } analyseLines ( lines ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( Exception e ) { } } } CSVConfig conf = config ; config = null ; return conf ; }
private void updateDesign ( DataSetDesign dataSetDesign , IConnection conn , String queryText ) throws OdaException { IQuery query = conn . newQuery ( null ) ; query . prepare ( queryText ) ; query . setProperty ( Query . PROP_SETUP_QUERY_TEXT , getSetupQueryText ( ) ) ; try { IResultSetMetaData md = query . getMetaData ( ) ; updateResultSetDesign ( md , dataSetDesign ) ; } catch ( OdaException e ) { dataSetDesign . setResultSets ( null ) ; e . printStackTrace ( ) ; } try { IParameterMetaData paramMd = query . getParameterMetaData ( ) ; updateParameterDesign ( paramMd , dataSetDesign ) ; } catch ( OdaException ex ) { dataSetDesign . setParameters ( null ) ; ex . printStackTrace ( ) ; } }
@ Override public OutlierResult run ( Database db , Relation < V > relation ) { DBIDs ids = relation . getDBIDs ( ) ; SimilarityQuery < V > sq = db . getSimilarityQuery ( relation , kernelFunction ) ; KernelMatrix kernelMatrix = new KernelMatrix ( sq , relation , ids ) ; WritableDoubleDataStore abodvalues = DataStoreUtil . makeDoubleStorage ( ids , DataStoreFactory . HINT_STATIC ) ; DoubleMinMax minmaxabod = new DoubleMinMax ( ) ; MeanVariance s = new MeanVariance ( ) ; KNNHeap nn = DBIDUtil . newHeap ( k ) ; for ( DBIDIter pA = ids . iter ( ) ; pA . valid ( ) ; pA . advance ( ) ) { final double simAA = kernelMatrix . getSimilarity ( pA , pA ) ; nn . clear ( ) ; for ( DBIDIter nB = relation . iterDBIDs ( ) ; nB . valid ( ) ; nB . advance ( ) ) { if ( DBIDUtil . equal ( nB , pA ) ) { continue ; } double simBB = kernelMatrix . getSimilarity ( nB , nB ) ; double simAB = kernelMatrix . getSimilarity ( pA , nB ) ; double sqdAB = simAA + simBB - simAB - simAB ; if ( ! ( sqdAB > NUM_ ) ) { continue ; } nn . insert ( sqdAB , nB ) ; } KNNList nl = nn . toKNNList ( ) ; s . reset ( ) ; DoubleDBIDListIter iB = nl . iter ( ) , iC = nl . iter ( ) ; for ( ; iB . valid ( ) ; iB . advance ( ) ) { double sqdAB = iB . doubleValue ( ) ; double simAB = kernelMatrix . getSimilarity ( pA , iB ) ; if ( ! ( sqdAB > NUM_ ) ) { continue ; } for ( iC . seek ( iB . getOffset ( ) + NUM_ ) ; iC . valid ( ) ; iC . advance ( ) ) { double sqdAC = iC . doubleValue ( ) ; double simAC = kernelMatrix . getSimilarity ( pA , iC ) ; if ( ! ( sqdAC > NUM_ ) ) { continue ; } double simBC = kernelMatrix . getSimilarity ( iB , iC ) ; double numerator = simBC - simAB - simAC + simAA ; double div = NUM_ / ( sqdAB . sqdAC ) ; s . put ( numerator . div , Math . sqrt ( div ) ) ; } } final double abof = s . getNaiveVariance ( ) ; minmaxabod . put ( abof ) ; abodvalues . putDouble ( pA , abof ) ; } DoubleRelation scoreResult = new MaterializedDoubleRelation ( STR_ , STR_ , abodvalues , relation . getDBIDs ( ) ) ; OutlierScoreMeta scoreMeta = new InvertedOutlierScoreMeta ( minmaxabod . getMin ( ) , minmaxabod . getMax ( ) , NUM_ , Double . POSITIVE_INFINITY ) ; return new OutlierResult ( scoreMeta , scoreResult ) ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; String badSubstring ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; nameNode = elementList . item ( NUM_ ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; { boolean success = BOOL_ ; try { badSubstring = child . substringData ( NUM_ , - NUM_ ) ; } catch ( DOMException ex ) { success = ( ex . code == DOMException . INDEX_SIZE_ERR ) ; } assertTrue ( STR_ , success ) ; } }
public static String toString ( JSONObject jo ) throws JSONException { StringBuffer sb = new StringBuffer ( ) ; sb . append ( escape ( jo . getString ( STR_ ) ) ) ; sb . append ( STR_ ) ; sb . append ( escape ( jo . getString ( STR_ ) ) ) ; if ( jo . has ( STR_ ) ) { sb . append ( STR_ ) ; sb . append ( jo . getString ( STR_ ) ) ; } if ( jo . has ( STR_ ) ) { sb . append ( STR_ ) ; sb . append ( escape ( jo . getString ( STR_ ) ) ) ; } if ( jo . has ( STR_ ) ) { sb . append ( STR_ ) ; sb . append ( escape ( jo . getString ( STR_ ) ) ) ; } if ( jo . optBoolean ( STR_ ) ) { sb . append ( STR_ ) ; } return sb . toString ( ) ; }
@ Override public boolean equals ( Object otherRule ) { if ( otherRule == this ) { return BOOL_ ; } if ( otherRule instanceof ZoneOffsetTransitionRule ) { ZoneOffsetTransitionRule other = ( ZoneOffsetTransitionRule ) otherRule ; return month == other . month && dom == other . dom && dow == other . dow && timeDefinition == other . timeDefinition && time . equals ( other . time ) && timeEndOfDay == other . timeEndOfDay && standardOffset . equals ( other . standardOffset ) && offsetBefore . equals ( other . offsetBefore ) && offsetAfter . equals ( other . offsetAfter ) ; } return BOOL_ ; }
private void initializeMembershipMatrix ( ) { for ( int i = NUM_ ; i < points . size ( ) ; i ++ ) { for ( int j = NUM_ ; j < k ; j ++ ) { membershipMatrix [ i ] [ j ] = random . nextDouble ( ) ; } membershipMatrix [ i ] = MathArrays . normalizeArray ( membershipMatrix [ i ] , NUM_ ) ; } }
public static void writeAll ( OutputStream stream , Object [ ] o ) throws Exception { ObjectOutputStream oos ; int i ; if ( ! ( stream instanceof BufferedOutputStream ) ) { stream = new BufferedOutputStream ( stream ) ; } oos = new ObjectOutputStream ( stream ) ; for ( i = NUM_ ; i < o . length ; i ++ ) { oos . writeObject ( o [ i ] ) ; } oos . flush ( ) ; oos . close ( ) ; }
public boolean deleteAttachmentPoint ( DatapathId sw , OFPort port ) { AttachmentPoint ap = new AttachmentPoint ( sw , port , new Date ( NUM_ ) ) ; if ( this . oldAPs != null ) { ArrayList < AttachmentPoint > apList = new ArrayList < AttachmentPoint > ( ) ; apList . addAll ( this . oldAPs ) ; int index = apList . indexOf ( ap ) ; if ( index > NUM_ ) { apList . remove ( index ) ; this . oldAPs = apList ; } } if ( this . attachmentPoints != null ) { ArrayList < AttachmentPoint > apList = new ArrayList < AttachmentPoint > ( ) ; apList . addAll ( this . attachmentPoints ) ; int index = apList . indexOf ( ap ) ; if ( index > NUM_ ) { apList . remove ( index ) ; this . attachmentPoints = apList ; return BOOL_ ; } } return BOOL_ ; }
public B css ( @ NonNls String classes ) { return css ( classes , null ) ; }
public static ArgumentException adaptPropertyException ( PropertyException e , AbstractManagedObjectDefinition < ? , ? > d ) { return new ArgumentException ( e . getMessageObject ( ) ) ; }
private Consumer < Operation > createNotificationTarget ( ) { return null ; }
public void write ( byte [ ] bytes ) throws IOException { dataOutput . write ( bytes ) ; offset += bytes . length ; }
static synchronized boolean isShapingSupported ( ) { if ( isShapingSupported == null ) { XToolkit . awtLock ( ) ; try { isShapingSupported = XlibWrapper . XShapeQueryExtension ( XToolkit . getDisplay ( ) , XlibWrapper . larg1 , XlibWrapper . larg2 ) ; } finally { XToolkit . awtUnlock ( ) ; } } return isShapingSupported . booleanValue ( ) ; }
private boolean isIdChar ( int ch ) { return isAlpha ( ch ) || isDigit ( ch ) || ch == STR_ || ch == STR_ || ch == STR_ || ch == STR_ || Character . isLetter ( ch ) ; }
protected String handleTimeseal ( String text ) throws IOException { String result = text ; if ( LOG . isDebugEnabled ( ) ) LOG . debug ( STR_ + result ) ; while ( result . contains ( STR_ ) ) { sendAck ( ) ; result = result . replaceFirst ( STR_ , STR_ ) ; if ( LOG . isDebugEnabled ( ) ) LOG . debug ( STR_ + result ) ; } if ( LOG . isDebugEnabled ( ) ) LOG . debug ( STR_ + result ) ; return result ; }
public BerInputStream ( InputStream in , int initialSize ) throws IOException { this . in = in ; buffer = new byte [ initialSize ] ; next ( ) ; if ( length != INDEFINIT_LENGTH ) { if ( buffer . length < ( length + offset ) ) { byte [ ] newBuffer = new byte [ length + offset ] ; System . arraycopy ( buffer , NUM_ , newBuffer , NUM_ , offset ) ; buffer = newBuffer ; } } else { isIndefinedLength = BOOL_ ; throw new ASN1Exception ( STR_ ) ; } }
protected LocationHandler ( Location location , Option ... options ) { this . location = location ; this . options = options . length == NUM_ ? EnumSet . noneOf ( Option . class ) : EnumSet . copyOf ( Arrays . asList ( options ) ) ; }
private void init ( ) { _logger . debug ( STR_ ) ; list = new ConcurrentLinkedQueue < ArrivedIndication > ( ) ; IntermediateProcessor intermediateProcessor = new IntermediateProcessor ( list , _processor ) ; indicationProcessTimer = Executors . newSingleThreadScheduledExecutor ( ) ; indicationProcessTimer . scheduleWithFixedDelay ( intermediateProcessor , CIMConstants . INDICATION_PROCESS_INTERVAL , PERIODIC_DELAY , TimeUnit . SECONDS ) ; }
public static final String longToHexString ( long a ) { StringBuffer sb = new StringBuffer ( NUM_ ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) sb . append ( NIBBLE [ ( int ) ( a > > > ( NUM_ - NUM_ . i ) ) & xf ] ) ; return sb . toString ( ) ; }
private Date watchCoreStartAt ( SolrServer client , final long timeout , final Date min ) throws InterruptedException , IOException , SolrServerException { final long sleepInterval = NUM_ ; long timeSlept = NUM_ ; SolrParams p = params ( STR_ , STR_ , STR_ , STR_ ) ; while ( timeSlept < timeout ) { QueryRequest req = new QueryRequest ( p ) ; req . setPath ( STR_ ) ; try { NamedList data = client . request ( req ) ; for ( String k : new String [ ] { STR_ , STR_ } ) { Object o = data . get ( k ) ; assertNotNull ( STR_ + k , o ) ; data = ( NamedList ) o ; } Date startTime = ( Date ) data . get ( STR_ ) ; assertNotNull ( STR_ , startTime ) ; if ( null == min || startTime . after ( min ) ) { return startTime ; } } catch ( SolrException e ) { if ( NUM_ != e . code ( ) ) { throw e ; } } timeSlept += sleepInterval ; Thread . sleep ( sleepInterval ) ; } fail ( STR_ + min ) ; return min ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; String childData ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; nameNode = elementList . item ( NUM_ ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; child . deleteData ( NUM_ , NUM_ ) ; childData = child . getData ( ) ; assertEquals ( STR_ , STR_ , childData ) ; }
@ Override public ParamsRequestCondition combine ( ParamsRequestCondition other ) { Set < ParamExpression > set = new LinkedHashSet < > ( this . expressions ) ; set . addAll ( other . expressions ) ; return new ParamsRequestCondition ( set ) ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return BOOL_ ; } if ( ! ( obj instanceof TimeSeriesCollection ) ) { return BOOL_ ; } TimeSeriesCollection that = ( TimeSeriesCollection ) obj ; if ( this . xPosition != that . xPosition ) { return BOOL_ ; } if ( this . domainIsPointsInTime != that . domainIsPointsInTime ) { return BOOL_ ; } if ( ! ObjectUtilities . equal ( this . data , that . data ) ) { return BOOL_ ; } return BOOL_ ; }
private void parseRules ( Attributes attributes ) { startMode = getModeAttribute ( attributes , STR_ ) ; if ( startMode == null ) { startMode = lookupCreateMode ( IMPLICIT_MODE_NAME ) ; md . currentMode = startMode ; startMode . noteDefined ( null ) ; } startMode . noteUsed ( locator ) ; if ( attributesSchema ) { Mode wrapper = lookupCreateMode ( WRAPPER_MODE_NAME ) ; ActionSet actions = new ActionSet ( ) ; actions . addNoResultAction ( new AllowAction ( new ModeUsage ( startMode , startMode ) ) ) ; wrapper . bindElement ( NamespaceSpecification . ANY_NAMESPACE , NamespaceSpecification . DEFAULT_WILDCARD , actions ) ; wrapper . noteDefined ( null ) ; startMode = wrapper ; } defaultSchemaType = getSchemaType ( attributes ) ; }
public void fill ( byte value ) { value &= xf ; Arrays . fill ( data , ( byte ) ( value << NUM_ | value ) ) ; }
public void makeImmutable ( ) { if ( isMutable ) { isMutable = BOOL_ ; } }
private static void parse ( InputStream in , Encoding encoding , ContentHandler contentHandler ) throws IOException , SAXException { try { XMLReader reader = new ExpatReader ( ) ; reader . setContentHandler ( contentHandler ) ; InputSource source = new InputSource ( in ) ; source . setEncoding ( encoding . expatName ) ; reader . parse ( source ) ; } catch ( IOException e ) { throw new AssertionError ( e ) ; } }
@ Override public List < Foo > findByField2 ( boolean field2 ) { return findByField2 ( field2 , QueryUtil . ALL_POS , QueryUtil . ALL_POS , null ) ; }
public void addToAssociated ( Message asMessage ) { associatedMessages . add ( asMessage ) ; }
private static void parsePropertyAssignments ( Properties p , String [ ] assignments ) { for ( String assignment : assignments ) { int split = assignment . indexOf ( STR_ ) ; String key = assignment . substring ( NUM_ , split ) ; String value = assignment . substring ( split + NUM_ ) ; p . put ( key , value ) ; } }
protected boolean switchProfiles ( IProfile newSelection ) { if ( newSelection == null ) { return BOOL_ ; } if ( mCurrentProfile == newSelection ) { return BOOL_ ; } if ( mAlternativeProfileHeaderSwitching ) { int prevSelection = - NUM_ ; if ( mProfileFirst == newSelection ) { prevSelection = NUM_ ; } else if ( mProfileSecond == newSelection ) { prevSelection = NUM_ ; } else if ( mProfileThird == newSelection ) { prevSelection = NUM_ ; } IProfile tmp = mCurrentProfile ; mCurrentProfile = newSelection ; if ( prevSelection == NUM_ ) { mProfileFirst = tmp ; } else if ( prevSelection == NUM_ ) { mProfileSecond = tmp ; } else if ( prevSelection == NUM_ ) { mProfileThird = tmp ; } } else { if ( mProfiles != null ) { ArrayList < IProfile > previousActiveProfiles = new ArrayList < > ( Arrays . asList ( mCurrentProfile , mProfileFirst , mProfileSecond , mProfileThird ) ) ; if ( previousActiveProfiles . contains ( newSelection ) ) { int position = - NUM_ ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { if ( previousActiveProfiles . get ( i ) == newSelection ) { position = i ; break ; } } if ( position != - NUM_ ) { previousActiveProfiles . remove ( position ) ; previousActiveProfiles . add ( NUM_ , newSelection ) ; mCurrentProfile = previousActiveProfiles . get ( NUM_ ) ; mProfileFirst = previousActiveProfiles . get ( NUM_ ) ; mProfileSecond = previousActiveProfiles . get ( NUM_ ) ; mProfileThird = previousActiveProfiles . get ( NUM_ ) ; } } else { mProfileThird = mProfileSecond ; mProfileSecond = mProfileFirst ; mProfileFirst = mCurrentProfile ; mCurrentProfile = newSelection ; } } } if ( mOnlySmallProfileImagesVisible ) { mProfileThird = mProfileSecond ; mProfileSecond = mProfileFirst ; mProfileFirst = mCurrentProfile ; } buildProfiles ( ) ; return BOOL_ ; }
public static SearchScope valueOf ( final int intValue ) { SearchScope result = null ; if ( NUM_ <= intValue && intValue < ELEMENTS . length ) { result = ELEMENTS [ intValue ] ; } if ( result == null ) { result = new SearchScope ( intValue , STR_ + intValue + STR_ , Enum . UNKNOWN ) ; } return result ; }
public static IPackageFragmentRoot addClassFolder ( IJavaProject jproject , String containerName , IPath sourceAttachPath , IPath sourceAttachRoot ) throws CoreException { IProject project = jproject . getProject ( ) ; IContainer container = null ; if ( containerName == null || containerName . length ( ) == NUM_ ) { container = project ; } else { IFolder folder = project . getFolder ( containerName ) ; if ( ! folder . exists ( ) ) { CoreUtility . createFolder ( folder , BOOL_ , BOOL_ , null ) ; } container = folder ; } IClasspathEntry cpe = JavaCore . newLibraryEntry ( container . getFullPath ( ) , sourceAttachPath , sourceAttachRoot ) ; addToClasspath ( jproject , cpe ) ; return jproject . getPackageFragmentRoot ( container ) ; }
private void previousWindow ( Calendar startTime ) { if ( isDaily ( ) ) { startTime . add ( Calendar . DAY_OF_MONTH , - NUM_ ) ; } else if ( isWeekly ( ) ) { startTime . add ( Calendar . WEEK_OF_MONTH , - NUM_ ) ; } else if ( isMonthly ( ) ) { int month = startTime . get ( Calendar . MONTH ) ; adjustDayOfMonth ( startTime , month + - NUM_ ) ; } }
private < T > T [ ] copyElements ( T [ ] a ) { if ( head < tail ) { System . arraycopy ( elements , head , a , NUM_ , size ( ) ) ; } else if ( head > tail ) { int headPortionLen = elements . length - head ; System . arraycopy ( elements , head , a , NUM_ , headPortionLen ) ; System . arraycopy ( elements , NUM_ , a , headPortionLen , tail ) ; } return a ; }
abstract void executeOnHandlerTask ( Runnable task ) ;
public static LatLng translatePoint ( LatLng point , double distance , double bearing ) { distance = distance / NUM_ ; double lat = Math . toRadians ( point . latitude ) ; double lng = Math . toRadians ( point . longitude ) ; bearing = Math . toRadians ( bearing ) ; double Lat2 = Math . asin ( ( Math . sin ( lat ) . Math . cos ( distance / EARTH ) ) + ( Math . cos ( lat ) . Math . sin ( distance / EARTH ) . Math . cos ( bearing ) ) ) ; double Long2 = lng + Math . atan2 ( Math . sin ( bearing ) . Math . sin ( distance / EARTH ) . Math . cos ( lat ) , Math . cos ( distance / EARTH ) - ( Math . sin ( lat ) . Math . sin ( Lat2 ) ) ) ; Lat2 = Math . toDegrees ( Lat2 ) ; Long2 = Math . toDegrees ( Long2 ) ; return new LatLng ( Lat2 , Long2 ) ; }
public Instance calcPivot ( MyIdxList list1 , MyIdxList list2 , Instances insts ) { int classIdx = m_Instances . classIndex ( ) ; double [ ] attrVals = new double [ insts . numAttributes ( ) ] ; Instance temp ; for ( int i = NUM_ ; i < list1 . length ( ) ; i ++ ) { temp = insts . instance ( list1 . get ( i ) . idx ) ; for ( int k = NUM_ ; k < temp . numValues ( ) ; k ++ ) { if ( temp . index ( k ) == classIdx ) { continue ; } attrVals [ k ] += temp . valueSparse ( k ) ; } } for ( int j = NUM_ ; j < list2 . length ( ) ; j ++ ) { temp = insts . instance ( list2 . get ( j ) . idx ) ; for ( int k = NUM_ ; k < temp . numValues ( ) ; k ++ ) { if ( temp . index ( k ) == classIdx ) { continue ; } attrVals [ k ] += temp . valueSparse ( k ) ; } } for ( int j = NUM_ , numInsts = list1 . length ( ) + list2 . length ( ) ; j < attrVals . length ; j ++ ) { attrVals [ j ] /= numInsts ; } temp = new DenseInstance ( NUM_ , attrVals ) ; return temp ; }
default Optional < List < T > > parseOptional ( byte [ ] parseMessage ) { return Optional . ofNullable ( parse ( parseMessage ) ) ; }
public static void initializeForClientUse ( ) { EmbeddedUtils . initializeForClientUse ( ) ; }
private void createUser ( SSOToken token , PersistentObject parentObj , Map attributes , String profileName ) throws UMSException , AMEntryExistsException , AMException { String orgDN = getOrganizationDN ( internalToken , parentObj . getDN ( ) ) ; String entryDN = getNamingAttribute ( AMObject . USER ) + STR_ + profileName + STR_ + parentObj . getDN ( ) ; attributes = callBackHelper . preProcess ( token , entryDN , orgDN , null , attributes , CallBackHelper . CREATE , AMObject . USER , BOOL_ ) ; AttrSet attrSet = CommonUtils . mapToAttrSet ( attributes ) ; makeNamingFirst ( attrSet , getNamingAttribute ( AMObject . USER ) , profileName ) ; UserPasswordValidationHelper pluginImpl = new UserPasswordValidationHelper ( token , orgDN ) ; try { pluginImpl . validate ( CommonUtils . attrSetToMap ( attrSet ) ) ; } catch ( AMException ame ) { debug . error ( STR_ + STR_ , ame ) ; throw ame ; } TemplateManager tempMgr = TemplateManager . getTemplateManager ( ) ; CreationTemplate creationTemp = tempMgr . getCreationTemplate ( STR_ , new Guid ( orgDN ) , TemplateManager . SCOPE_ANCESTORS ) ; attrSet = combineOCs ( creationTemp , attrSet ) ; PersistentObject user = new PersistentObject ( creationTemp , attrSet ) ; try { parentObj . addChild ( user ) ; } catch ( AccessRightsException e ) { if ( debug . warningEnabled ( ) ) { debug . warning ( STR_ + STR_ , e ) ; } throw new AMException ( token , STR_ ) ; } catch ( EntryAlreadyExistsException ee ) { if ( ComplianceServicesImpl . isComplianceUserDeletionEnabled ( ) ) { complianceImpl . checkIfDeletedUser ( token , user . getDN ( ) ) ; } if ( debug . warningEnabled ( ) ) { debug . warning ( STR_ + STR_ , ee ) ; } throw new AMEntryExistsException ( token , STR_ , ee ) ; } catch ( UMSException ue ) { if ( debug . warningEnabled ( ) ) { debug . warning ( STR_ + STR_ , ue ) ; } processInternalException ( token , ue , STR_ ) ; } callBackHelper . postProcess ( token , user . getDN ( ) , orgDN , null , attributes , CallBackHelper . CREATE , AMObject . USER , BOOL_ ) ; AMUserEntryProcessed postPlugin = getUserPostPlugin ( ) ; if ( postPlugin != null ) { Map attrMap = CommonUtils . attrSetToMap ( attrSet ) ; postPlugin . processUserAdd ( token , user . getDN ( ) , attrMap ) ; } EmailNotificationHelper mailerObj = new EmailNotificationHelper ( user . getDN ( ) ) ; mailerObj . setUserCreateNotificationList ( ) ; mailerObj . sendUserCreateNotification ( attributes ) ; }
public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( NUM_ ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
private static int byteCompaction ( int mode , int [ ] codewords , int codeIndex , StringBuilder result ) { if ( mode == BYTE_COMPACTION_MODE_LATCH ) { int count = NUM_ ; long value = NUM_ ; char [ ] decodedData = new char [ NUM_ ] ; int [ ] byteCompactedCodewords = new int [ NUM_ ] ; boolean end = BOOL_ ; int nextCode = codewords [ codeIndex ++ ] ; while ( ( codeIndex < codewords [ NUM_ ] ) && ! end ) { byteCompactedCodewords [ count ++ ] = nextCode ; value = NUM_ . value + nextCode ; nextCode = codewords [ codeIndex ++ ] ; if ( nextCode == TEXT_COMPACTION_MODE_LATCH || nextCode == BYTE_COMPACTION_MODE_LATCH || nextCode == NUMERIC_COMPACTION_MODE_LATCH || nextCode == BYTE_COMPACTION_MODE_LATCH_6 || nextCode == BEGIN_MACRO_PDF417_CONTROL_BLOCK || nextCode == BEGIN_MACRO_PDF417_OPTIONAL_FIELD || nextCode == MACRO_PDF417_TERMINATOR ) { codeIndex -- ; end = BOOL_ ; } else { if ( ( count % NUM_ == NUM_ ) && ( count > NUM_ ) ) { for ( int j = NUM_ ; j < NUM_ ; ++ j ) { decodedData [ NUM_ - j ] = ( char ) ( value % NUM_ ) ; value >>= NUM_ ; } result . append ( decodedData ) ; count = NUM_ ; } } } if ( codeIndex == codewords [ NUM_ ] && nextCode < TEXT_COMPACTION_MODE_LATCH ) { byteCompactedCodewords [ count ++ ] = nextCode ; } for ( int i = NUM_ ; i < count ; i ++ ) { result . append ( ( char ) byteCompactedCodewords [ i ] ) ; } } else if ( mode == BYTE_COMPACTION_MODE_LATCH_6 ) { int count = NUM_ ; long value = NUM_ ; boolean end = BOOL_ ; while ( codeIndex < codewords [ NUM_ ] && ! end ) { int code = codewords [ codeIndex ++ ] ; if ( code < TEXT_COMPACTION_MODE_LATCH ) { count ++ ; value = NUM_ . value + code ; } else { if ( code == TEXT_COMPACTION_MODE_LATCH || code == BYTE_COMPACTION_MODE_LATCH || code == NUMERIC_COMPACTION_MODE_LATCH || code == BYTE_COMPACTION_MODE_LATCH_6 || code == BEGIN_MACRO_PDF417_CONTROL_BLOCK || code == BEGIN_MACRO_PDF417_OPTIONAL_FIELD || code == MACRO_PDF417_TERMINATOR ) { codeIndex -- ; end = BOOL_ ; } } if ( ( count % NUM_ == NUM_ ) && ( count > NUM_ ) ) { char [ ] decodedData = new char [ NUM_ ] ; for ( int j = NUM_ ; j < NUM_ ; ++ j ) { decodedData [ NUM_ - j ] = ( char ) ( value & xFF ) ; value >>= NUM_ ; } result . append ( decodedData ) ; count = NUM_ ; } } } return codeIndex ; }
public void addAll ( @ NonNull List < T > itemList ) { synchronized ( lock ) { if ( items == null ) { items = new ArrayList < > ( ) ; } items . addAll ( itemList ) ; } if ( notifyOnChange ) { if ( items . size ( ) - itemList . size ( ) != NUM_ ) { notifyItemRangeChanged ( items . size ( ) - itemList . size ( ) , itemList . size ( ) ) ; } else { notifyDataSetChanged ( ) ; } } }
public void write ( int a ) throws IOException { outs . write ( a ) ; position ++ ; }
public void testInsert1 ( ) throws SQLException { DatabaseCreator . fillParentTable ( conn ) ; DatabaseCreator . fillFKStrictTable ( conn ) ; DatabaseCreator . fillFKCascadeTable ( conn ) ; statement . execute ( STR_ + DatabaseCreator . FKSTRICT_TABLE + STR_ ) ; statement . execute ( STR_ + DatabaseCreator . FKCASCADE_TABLE + STR_ ) ; }
public boolean isStartsWithMode ( ) { return startsWithMode ; }
public Builder withThreads ( int threads ) { properties . setProperty ( NettyOptions . THREADS , String . valueOf ( Assert . argNot ( threads , threads <= NUM_ , STR_ ) ) ) ; return this ; }
public void paintTabbedPaneTabAreaBackground ( SynthContext context , Graphics g , int x , int y , int w , int h , int orientation ) { if ( orientation == JTabbedPane . LEFT ) { AffineTransform transform = new AffineTransform ( ) ; transform . scale ( - NUM_ , NUM_ ) ; transform . rotate ( Math . toRadians ( NUM_ ) ) ; paintBackground ( context , g , y , x , h , w , transform ) ; } else if ( orientation == JTabbedPane . RIGHT ) { AffineTransform transform = new AffineTransform ( ) ; transform . rotate ( Math . toRadians ( NUM_ ) ) ; transform . translate ( NUM_ , - ( x + w ) ) ; paintBackground ( context , g , y , NUM_ , h , w , transform ) ; } else if ( orientation == JTabbedPane . BOTTOM ) { AffineTransform transform = new AffineTransform ( ) ; transform . translate ( x , y ) ; paintBackground ( context , g , NUM_ , NUM_ , w , h , transform ) ; } else { paintBackground ( context , g , x , y , w , h , null ) ; } }
@ Override public void endCDATA ( Augmentations augs ) throws XNIException { try { if ( fLexicalHandler != null ) { fLexicalHandler . endCDATA ( ) ; } } catch ( SAXException e ) { throw new XNIException ( e ) ; } }
public static MediaLocator createMediaLocator ( String url ) { MediaLocator ml ; if ( url . indexOf ( STR_ ) > NUM_ && ( ml = new MediaLocator ( url ) ) != null ) return ml ; if ( url . startsWith ( File . separator ) ) { if ( ( ml = new MediaLocator ( STR_ + url ) ) != null ) return ml ; } else { String file = STR_ + System . getProperty ( STR_ ) + File . separator + url ; if ( ( ml = new MediaLocator ( file ) ) != null ) return ml ; } return null ; }
private static void invokeRemoteClearAndWait ( VM remoteVM , VM thisVM ) { remoteVM . invoke ( null ) ; try { clearLatch . await ( ) ; } catch ( InterruptedException e ) { fail ( STR_ ) ; } }
private int measureShort ( int measureSpec ) { int result ; int specMode = MeasureSpec . getMode ( measureSpec ) ; int specSize = MeasureSpec . getSize ( measureSpec ) ; if ( specMode == MeasureSpec . EXACTLY ) { result = specSize ; } else { result = ( int ) ( NUM_ . mRadius + getPaddingTop ( ) + getPaddingBottom ( ) + NUM_ ) ; if ( specMode == MeasureSpec . AT_MOST ) { result = Math . min ( result , specSize ) ; } } return result ; }
public void key ( String skey ) throws SQLite . Exception { synchronized ( this ) { byte ekey [ ] = null ; if ( skey != null && skey . length ( ) > NUM_ ) { ekey = new byte [ skey . length ( ) ] ; for ( int i = NUM_ ; i < skey . length ( ) ; i ++ ) { char c = skey . charAt ( i ) ; ekey [ i ] = ( byte ) ( ( c & xff ) ^ ( c > > NUM_ ) ) ; } } _key ( ekey ) ; } }
public void testSharedTestData ( ) throws Exception { assertEquals ( testSqlDate , Date . valueOf ( testLocalDate ) ) ; assertEquals ( testSqlTime , Time . valueOf ( testLocalTime ) ) ; assertEquals ( testSqlTimeStamp , Timestamp . valueOf ( testLocalDateTime ) ) ; assertEquals ( testLocalDate , testSqlDate . toLocalDate ( ) ) ; assertEquals ( testLocalTime , testSqlTime . toLocalTime ( ) ) ; assertEquals ( testLocalDateTime , testSqlTimeStamp . toLocalDateTime ( ) ) ; }
public static Cache . Entry makeRandomCacheEntry ( byte [ ] data , boolean isExpired , boolean needsRefresh ) { Random random = new Random ( ) ; Cache . Entry entry = new Cache . Entry ( ) ; if ( data != null ) { entry . data = data ; } else { entry . data = new byte [ random . nextInt ( NUM_ ) ] ; } entry . etag = String . valueOf ( random . nextLong ( ) ) ; entry . serverDate = random . nextLong ( ) ; entry . ttl = isExpired ? NUM_ : Long . MAX_VALUE ; entry . softTtl = needsRefresh ? NUM_ : Long . MAX_VALUE ; return entry ; }
public static final void isCDataWF ( DOMErrorHandler errorHandler , DOMErrorImpl error , DOMLocatorImpl locator , String datavalue , boolean isXML11Version ) { if ( datavalue == null || ( datavalue . length ( ) == NUM_ ) ) { return ; } char [ ] dataarray = datavalue . toCharArray ( ) ; int datalength = dataarray . length ; if ( isXML11Version ) { int i = NUM_ ; while ( i < datalength ) { char c = dataarray [ i ++ ] ; if ( XML11Char . isXML11Invalid ( c ) ) { if ( XMLChar . isHighSurrogate ( c ) && i < datalength ) { char c2 = dataarray [ i ++ ] ; if ( XMLChar . isLowSurrogate ( c2 ) && XMLChar . isSupplemental ( XMLChar . supplemental ( c , c2 ) ) ) { continue ; } } String msg = DOMMessageFormatter . formatMessage ( DOMMessageFormatter . XML_DOMAIN , STR_ , new Object [ ] { Integer . toString ( c , NUM_ ) } ) ; reportDOMError ( errorHandler , error , locator , msg , DOMError . SEVERITY_ERROR , STR_ ) ; } else if ( c == STR_ ) { int count = i ; if ( count < datalength && dataarray [ count ] == STR_ ) { while ( ++ count < datalength && dataarray [ count ] == STR_ ) { } if ( count < datalength && dataarray [ count ] == STR_ ) { String msg = DOMMessageFormatter . formatMessage ( DOMMessageFormatter . XML_DOMAIN , STR_ , null ) ; reportDOMError ( errorHandler , error , locator , msg , DOMError . SEVERITY_ERROR , STR_ ) ; } } } } } else { int i = NUM_ ; while ( i < datalength ) { char c = dataarray [ i ++ ] ; if ( XMLChar . isInvalid ( c ) ) { if ( XMLChar . isHighSurrogate ( c ) && i < datalength ) { char c2 = dataarray [ i ++ ] ; if ( XMLChar . isLowSurrogate ( c2 ) && XMLChar . isSupplemental ( XMLChar . supplemental ( c , c2 ) ) ) { continue ; } } String msg = DOMMessageFormatter . formatMessage ( DOMMessageFormatter . XML_DOMAIN , STR_ , new Object [ ] { Integer . toString ( c , NUM_ ) } ) ; reportDOMError ( errorHandler , error , locator , msg , DOMError . SEVERITY_ERROR , STR_ ) ; } else if ( c == STR_ ) { int count = i ; if ( count < datalength && dataarray [ count ] == STR_ ) { while ( ++ count < datalength && dataarray [ count ] == STR_ ) { } if ( count < datalength && dataarray [ count ] == STR_ ) { String msg = DOMMessageFormatter . formatMessage ( DOMMessageFormatter . XML_DOMAIN , STR_ , null ) ; reportDOMError ( errorHandler , error , locator , msg , DOMError . SEVERITY_ERROR , STR_ ) ; } } } } } }
public void characters ( char ch [ ] , int start , int length ) { if ( titlePending ) { title . append ( ch , start , length ) ; } else if ( descPending ) { desc . append ( ch , start , length ) ; } }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( NUM_ ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return newVector . elements ( ) ; }
private void closeInjectorResource ( ShardId shardId , Injector shardInjector , Class < ? extends Closeable > ... toClose ) { for ( Class < ? extends Closeable > closeable : toClose ) { if ( closeInjectorOptionalResource ( shardId , shardInjector , closeable ) == BOOL_ ) { logger . warn ( STR_ , shardId , closeable . getSimpleName ( ) ) ; } } }
public final void incrementIdCounterTo ( int id ) { int diff = id - mIdCounter . get ( ) ; if ( diff < NUM_ ) return ; mIdCounter . addAndGet ( diff ) ; updateSharedPreference ( ) ; }
private static int clearBrandingResourceMapCache ( ContentResolver cr , long providerId ) { StringBuilder where = new StringBuilder ( ) ; where . append ( Imps . BrandingResourceMapCache . PROVIDER_ID ) ; where . append ( STR_ ) ; where . append ( providerId ) ; return cr . delete ( Imps . BrandingResourceMapCache . CONTENT_URI , where . toString ( ) , null ) ; }
public byte [ ] toByteArray ( ) { final int outLen = nonce_ . length + ( Long . SIZE / Byte . SIZE ) ; final ByteBuffer out = ByteBuffer . allocate ( outLen ) ; out . put ( nonce_ ) ; out . putLong ( contentLength_ ) ; return out . array ( ) ; }
public void addInterface ( CP ifc ) { addCPItem ( ifc ) ; interfaces . addElement ( ifc ) ; }
public Builder addConstraint ( @ JobConstraint int constraint ) { int [ ] newConstraints = new int [ mConstraints == null ? NUM_ : mConstraints . length + NUM_ ] ; if ( mConstraints != null && mConstraints . length != NUM_ ) { System . arraycopy ( mConstraints , NUM_ , newConstraints , NUM_ , mConstraints . length ) ; } newConstraints [ newConstraints . length - NUM_ ] = constraint ; mConstraints = newConstraints ; return this ; }
void cleanupParameters ( String relayState ) { if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + STR_ + relayState ) ; } relayStateMap . remove ( relayState ) ; userSessionMap . remove ( relayState ) ; userIDMap . remove ( relayState ) ; isSOAPInitiatedMap . remove ( relayState ) ; isSOAPInitiatedMap . remove ( relayState ) ; isIDPInitiatedMap . remove ( relayState ) ; origProtocolMap . remove ( relayState ) ; protocolListMap . remove ( relayState ) ; realmMap . remove ( relayState ) ; idpEntityIDMap . remove ( relayState ) ; spEntityIDMap . remove ( relayState ) ; sloRequestXMLMap . remove ( relayState ) ; sloResponseXMLMap . remove ( relayState ) ; currentStatusMap . remove ( relayState ) ; }
private boolean extraEntity ( String outputString , int charToMap ) { boolean extra = BOOL_ ; if ( charToMap < ASCII_MAX ) { switch ( charToMap ) { case STR_ : if ( ! outputString . equals ( STR_ ) ) extra = BOOL_ ; break ; case STR_ : if ( ! outputString . equals ( STR_ ) ) extra = BOOL_ ; break ; case STR_ : if ( ! outputString . equals ( STR_ ) ) extra = BOOL_ ; break ; case STR_ : if ( ! outputString . equals ( STR_ ) ) extra = BOOL_ ; break ; default : extra = BOOL_ ; } } return extra ; }
protected void drawPoint ( Graphics2D g , PointStyle pointStyle , double x , double y , Color color , Color borderColor ) { Shape pointShape = pointStyle . createShape ( x , y ) ; g . setColor ( color ) ; g . fill ( pointShape ) ; g . setColor ( borderColor ) ; g . draw ( pointShape ) ; }
public void testAndNotNegNegFirstLonger ( ) { byte aBytes [ ] = { - NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ } ; byte bBytes [ ] = { - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = - NUM_ ; int bSign = - NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . andNot ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
int retryTime ( ) { return retryTime . decrementAndGet ( ) ; }
public DatepickerCombo ( final Composite parent , final int style ) { this ( parent , style , DateFormat . getDateTimeInstance ( ) ) ; }
public void testPowPositiveNum ( ) { byte aBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ } ; int aSign = NUM_ ; int exp = NUM_ ; byte rBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , - NUM_ , NUM_ , - NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , - NUM_ , NUM_ , - NUM_ , NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , - NUM_ , NUM_ , - NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , - NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger result = aNumber . pow ( exp ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
protected void drawMarkHilighted ( Graphics2D g2 , float x , float y ) { Rectangle2D bounds = mark . getBounds2D ( ) ; float w = ( float ) bounds . getWidth ( ) ; float h = ( float ) bounds . getHeight ( ) ; x = x - ( w / NUM_ ) ; y = y - ( h / NUM_ ) ; g2 . translate ( x , y ) ; if ( hilightedMarkFillPaint != null ) { g2 . setPaint ( hilightedMarkFillPaint ) ; g2 . fill ( mark ) ; } g2 . setPaint ( hilightedMarkPaint ) ; g2 . setStroke ( hilightedMarkStroke ) ; g2 . draw ( mark ) ; g2 . translate ( - x , - y ) ; Rectangle2D rect = new Rectangle2D . Float ( x , y , w , h ) ; markBounds . add ( rect ) ; }
public static String trimTrailingWhitespace ( String str ) { if ( ! hasLength ( str ) ) { return str ; } StringBuilder sb = new StringBuilder ( str ) ; while ( sb . length ( ) > NUM_ && Character . isWhitespace ( sb . charAt ( sb . length ( ) - NUM_ ) ) ) { sb . deleteCharAt ( sb . length ( ) - NUM_ ) ; } return sb . toString ( ) ; }
private static MksTicketResponse checkGetMksTicketResponse ( MksTicketResponse mksTicketResponse ) throws RpcException { logger . info ( STR_ , mksTicketResponse ) ; switch ( mksTicketResponse . getResult ( ) ) { case OK : break ; case SYSTEM_ERROR : throw new SystemErrorException ( mksTicketResponse . getError ( ) ) ; case VM_NOT_FOUND : throw new VmNotFoundException ( mksTicketResponse . getError ( ) ) ; case INVALID_VM_POWER_STATE : throw new InvalidVmPowerStateException ( mksTicketResponse . getError ( ) ) ; default : throw new RpcException ( String . format ( STR_ , mksTicketResponse . getResult ( ) ) ) ; } return mksTicketResponse ; }
@ NotNull default B append ( double d , int decimalPlaces ) throws BufferOverflowException { if ( decimalPlaces < NUM_ ) { double d2 = d . Maths . tens ( decimalPlaces ) ; if ( d2 <= Long . MAX_VALUE && d2 >= Long . MIN_VALUE ) { return appendDecimal ( Math . round ( d2 ) , decimalPlaces ) ; } } return append ( d ) ; }
public CompletableFuture < T > completeAsync ( Supplier < ? extends T > supplier , Executor executor ) { if ( supplier == null || executor == null ) throw new NullPointerException ( ) ; executor . execute ( new AsyncSupply < T > ( this , supplier ) ) ; return this ; }
private MovieSubtitleChooserModel ( ) { name = BUNDLE . getString ( STR_ ) ; }
protected SuballocatedIntVector findNamespaceContext ( int elementNodeIndex ) { if ( null != m_namespaceDeclSetElements ) { int wouldBeAt = findInSortedSuballocatedIntVector ( m_namespaceDeclSetElements , elementNodeIndex ) ; if ( wouldBeAt >= NUM_ ) return ( SuballocatedIntVector ) m_namespaceDeclSets . elementAt ( wouldBeAt ) ; if ( wouldBeAt == - NUM_ ) return null ; wouldBeAt = - NUM_ - wouldBeAt ; int candidate = m_namespaceDeclSetElements . elementAt ( -- wouldBeAt ) ; int ancestor = _parent ( elementNodeIndex ) ; if ( wouldBeAt == NUM_ && candidate < ancestor ) { int rootHandle = getDocumentRoot ( makeNodeHandle ( elementNodeIndex ) ) ; int rootID = makeNodeIdentity ( rootHandle ) ; int uppermostNSCandidateID ; if ( getNodeType ( rootHandle ) == DTM . DOCUMENT_NODE ) { int ch = _firstch ( rootID ) ; uppermostNSCandidateID = ( ch != DTM . NULL ) ? ch : rootID ; } else { uppermostNSCandidateID = rootID ; } if ( candidate == uppermostNSCandidateID ) { return ( SuballocatedIntVector ) m_namespaceDeclSets . elementAt ( wouldBeAt ) ; } } while ( wouldBeAt >= NUM_ && ancestor > NUM_ ) { if ( candidate == ancestor ) { return ( SuballocatedIntVector ) m_namespaceDeclSets . elementAt ( wouldBeAt ) ; } else if ( candidate < ancestor ) { do { ancestor = _parent ( ancestor ) ; } while ( candidate < ancestor ) ; } else if ( wouldBeAt > NUM_ ) { candidate = m_namespaceDeclSetElements . elementAt ( -- wouldBeAt ) ; } else break ; } } return null ; }
public static java . sql . Timestamp nowTimestamp ( ) { return getTimestamp ( System . currentTimeMillis ( ) ) ; }
public int diff_commonSuffix ( String text1 , String text2 ) { int text1_length = text1 . length ( ) ; int text2_length = text2 . length ( ) ; int n = Math . min ( text1_length , text2_length ) ; for ( int i = NUM_ ; i <= n ; i ++ ) { if ( text1 . charAt ( text1_length - i ) != text2 . charAt ( text2_length - i ) ) { return i - NUM_ ; } } return n ; }
private void translateMatrixAfterRotate ( int axis , float trans , float prevImageSize , float imageSize , int prevViewSize , int viewSize , int drawableSize ) { if ( imageSize < viewSize ) { m [ axis ] = ( viewSize - ( drawableSize . m [ Matrix . MSCALE_X ] ) ) . NUM_ ; } else if ( trans > NUM_ ) { m [ axis ] = - ( ( imageSize - viewSize ) . NUM_ ) ; } else { float percentage = ( Math . abs ( trans ) + ( NUM_ . prevViewSize ) ) / prevImageSize ; m [ axis ] = - ( ( percentage . imageSize ) - ( viewSize . NUM_ ) ) ; } }
private void revokeEncryptPolicy ( org . wso2 . emm . agent . beans . Operation operation ) { boolean encryptStatus = ( devicePolicyManager . getStorageEncryptionStatus ( ) != devicePolicyManager . ENCRYPTION_STATUS_UNSUPPORTED && ( devicePolicyManager . getStorageEncryptionStatus ( ) == devicePolicyManager . ENCRYPTION_STATUS_ACTIVE || devicePolicyManager . getStorageEncryptionStatus ( ) == devicePolicyManager . ENCRYPTION_STATUS_ACTIVATING ) ) ; if ( operation . isEnabled ( ) && encryptStatus ) { devicePolicyManager . setStorageEncryption ( deviceAdmin , BOOL_ ) ; } }
public JSONBuffer closeHash ( ) { if ( stack . empty ( ) || stack . peek ( ) != Operand . HASH ) { throw new JSONException ( STR_ ) ; } removeSeparator ( ) ; buffer . append ( STR_ ) ; stack . pop ( ) ; addSeparator ( ) ; return this ; }
private static byte [ ] generateSeed ( ) { try { ByteArrayOutputStream seedBuffer = new ByteArrayOutputStream ( ) ; DataOutputStream seedBufferOut = new DataOutputStream ( seedBuffer ) ; seedBufferOut . writeLong ( System . currentTimeMillis ( ) ) ; seedBufferOut . writeLong ( System . nanoTime ( ) ) ; seedBufferOut . write ( BUILD_FINGERPRINT_AND_DEVICE_SERIAL ) ; seedBufferOut . close ( ) ; return seedBuffer . toByteArray ( ) ; } catch ( IOException e ) { throw new SecurityException ( STR_ , e ) ; } }
private void init ( SnmpMib myMib ) { if ( debug == null ) { final Key < Debug > key = Key . get ( Debug . class , Names . named ( CoreTokenConstants . CTS_MONITOR_DEBUG ) ) ; debug = InjectorHolder . getInstance ( key ) ; } final List < OperationEntry > operationEntries = new ArrayList < OperationEntry > ( ) ; final List < TokenEntry > tokenEntries = new ArrayList < TokenEntry > ( ) ; for ( Enum e : crudItems ) { final OperationEntry entry = new OperationEntry ( myMib ) ; entry . OperationType = e . name ( ) ; entry . OperationTableIndex = ( long ) e . ordinal ( ) + NUM_ ; operationEntries . add ( entry ) ; } for ( Enum e : tokenItems ) { final TokenEntry entry = new TokenEntry ( myMib ) ; entry . TokenType = e . name ( ) ; entry . TokenTableIndex = ( long ) e . ordinal ( ) + NUM_ ; tokenEntries . add ( entry ) ; } try { for ( OperationEntry ce : operationEntries ) { OperationTable . addEntry ( ce ) ; } for ( TokenEntry te : tokenEntries ) { TokenTable . addEntry ( te ) ; } createCRUDOperationsPerTokenTypeTable ( myMib , CtsCRUDOperationsPerTokenTypeTable , operationEntries , tokenEntries ) ; createCRUDOperationsTable ( myMib , CtsCRUDOperationsTable , operationEntries ) ; createTokenOperationsTable ( myMib , CtsTokenOperationsTable , tokenEntries ) ; } catch ( SnmpStatusException e ) { if ( debug . messageEnabled ( ) ) { debug . error ( STR_ , e ) ; } } }
@ Override public void disconnectionNotification ( String eventName , Object source ) { m_listenees . remove ( source ) ; if ( m_listenees . size ( ) == NUM_ ) { m_listeneeTypes . clear ( ) ; } }
public X509Name ( Vector oids , Vector values ) { this ( oids , values , new X509DefaultEntryConverter ( ) ) ; }
@ Override public ToDoubleFunction < Stream < Tuple2 < F , Double > > > dist ( Stream < Tuple2 < F , Double > > features1 ) { Object2DoubleMap < F > auxMap = new Object2DoubleOpenHashMap < > ( ) ; auxMap . defaultReturnValue ( NUM_ ) ; DoubleAdder norm1 = new DoubleAdder ( ) ; features1 . forEach ( null ) ; if ( norm1 . doubleValue ( ) == NUM_ ) { return null ; } return null ; }
public LoadMetadataDetails [ ] readLoadMetadata ( String tableFolderPath ) { Gson gsonObjectToRead = new Gson ( ) ; DataInputStream dataInputStream = null ; BufferedReader buffReader = null ; InputStreamReader inStream = null ; String metadataFileName = tableFolderPath + CarbonCommonConstants . FILE_SEPARATOR + CarbonCommonConstants . LOADMETADATA_FILENAME ; LoadMetadataDetails [ ] listOfLoadFolderDetailsArray ; AtomicFileOperations fileOperation = new AtomicFileOperationsImpl ( metadataFileName , FileFactory . getFileType ( metadataFileName ) ) ; try { if ( ! FileFactory . isFileExist ( metadataFileName , FileFactory . getFileType ( metadataFileName ) ) ) { return new LoadMetadataDetails [ NUM_ ] ; } dataInputStream = fileOperation . openForRead ( ) ; inStream = new InputStreamReader ( dataInputStream , Charset . forName ( CarbonCommonConstants . DEFAULT_CHARSET ) ) ; buffReader = new BufferedReader ( inStream ) ; listOfLoadFolderDetailsArray = gsonObjectToRead . fromJson ( buffReader , LoadMetadataDetails [ ] . class ) ; } catch ( IOException e ) { return new LoadMetadataDetails [ NUM_ ] ; } finally { closeStreams ( buffReader , inStream , dataInputStream ) ; } return listOfLoadFolderDetailsArray ; }
public String toInnerHtml ( Node node , Appendable appendable ) { NodeVisitor renderer = createRenderer ( appendable ) ; node . visitChildren ( renderer ) ; return appendable . toString ( ) ; }
private void updateStorageViewInfo ( VPlexStorageViewInfo storageViewInfo ) { VPlexApiDiscoveryManager discoveryMgr = _vplexApiClient . getDiscoveryManager ( ) ; discoveryMgr . updateStorageViewInfo ( storageViewInfo ) ; }
static List < String > decodeAll ( Collection < String > eventKeys ) { List < String > eventIds = Lists . newArrayList ( ) ; for ( String eventKey : eventKeys ) { decodeTo ( eventKey , eventIds ) ; } return eventIds ; }
public Object [ ] toArray ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = NUM_ ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }
private void replaceTop ( Scope topOfStack ) { stack . set ( stack . size ( ) - NUM_ , topOfStack ) ; }
public void testZeroOne ( ) { BigInteger aNumber = BigInteger . ZERO ; BigInteger bNumber = BigInteger . ONE ; BigInteger result = aNumber . and ( bNumber ) ; assertTrue ( result . equals ( BigInteger . ZERO ) ) ; assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public byte [ ] toByteArray ( String ascii ) { if ( ascii == null ) { return EMPTY_BYTE_ARRAY ; } return fromAscii ( ascii . toCharArray ( ) ) ; }
public static boolean [ ] copyOfRange ( boolean [ ] original , int start , int end ) { if ( start <= end ) { if ( original . length >= start && NUM_ <= start ) { int length = end - start ; int copyLength = Math . min ( length , original . length - start ) ; boolean [ ] copy = new boolean [ length ] ; System . arraycopy ( original , start , copy , NUM_ , copyLength ) ; return copy ; } throw new ArrayIndexOutOfBoundsException ( ) ; } throw new IllegalArgumentException ( ) ; }
private void onColumnSync ( ) { int syncPosition = Math . min ( mSyncPosition , getCount ( ) - NUM_ ) ; SparseArray < Double > positionHeightRatios = new SparseArray < Double > ( syncPosition ) ; for ( int pos = NUM_ ; pos < syncPosition ; pos ++ ) { final GridItemRecord rec = mPositionData . get ( pos ) ; if ( rec == null ) break ; Log . d ( TAG , STR_ + pos + STR_ + rec . heightRatio ) ; positionHeightRatios . append ( pos , rec . heightRatio ) ; } mPositionData . clear ( ) ; if ( DBG ) Log . d ( TAG , STR_ + mColumnWidth ) ; for ( int pos = NUM_ ; pos < syncPosition ; pos ++ ) { final GridItemRecord rec = getOrCreateRecord ( pos ) ; final double heightRatio = positionHeightRatios . get ( pos ) ; final int height = ( int ) ( mColumnWidth . heightRatio ) ; rec . heightRatio = heightRatio ; int top ; int bottom ; if ( isHeaderOrFooter ( pos ) ) { top = getLowestPositionedBottom ( ) ; bottom = top + height ; for ( int i = NUM_ ; i < mColumnCount ; i ++ ) { mColumnTops [ i ] = top ; mColumnBottoms [ i ] = bottom ; } } else { final int column = getHighestPositionedBottomColumn ( ) ; top = mColumnBottoms [ column ] ; bottom = top + height + getChildTopMargin ( pos ) + getChildBottomMargin ( ) ; mColumnTops [ column ] = top ; mColumnBottoms [ column ] = bottom ; rec . column = column ; } if ( DBG ) Log . d ( TAG , STR_ + pos + STR_ + top + STR_ + bottom + STR_ + height + STR_ + heightRatio ) ; } final int syncColumn = getHighestPositionedBottomColumn ( ) ; setPositionColumn ( syncPosition , syncColumn ) ; int syncToBottom = mColumnBottoms [ syncColumn ] ; int offset = - syncToBottom + mSpecificTop ; offsetAllColumnsTopAndBottom ( offset ) ; mDistanceToTop = - syncToBottom ; System . arraycopy ( mColumnBottoms , NUM_ , mColumnTops , NUM_ , mColumnCount ) ; }
private static Map < Direction , Sprite [ ] > splitTiles ( SpriteStore st , Sprite orig ) { int twidth = NUM_ATTACK_FRAMES . TILE_SIZE ; int theight = NUM_ . TILE_SIZE ; Map < Direction , Sprite [ ] > map = new EnumMap < Direction , Sprite [ ] > ( Direction . class ) ; int y = NUM_ ; map . put ( Direction . UP , st . getTiles ( orig , NUM_ , y , NUM_ATTACK_FRAMES , twidth , theight ) ) ; y += theight ; map . put ( Direction . RIGHT , st . getTiles ( orig , NUM_ , y , NUM_ATTACK_FRAMES , twidth , theight ) ) ; y += theight ; map . put ( Direction . DOWN , st . getTiles ( orig , NUM_ , y , NUM_ATTACK_FRAMES , twidth , theight ) ) ; y += theight ; map . put ( Direction . LEFT , st . getTiles ( orig , NUM_ , y , NUM_ATTACK_FRAMES , twidth , theight ) ) ; return map ; }
void incrementSchema ( String schemaName ) { if ( schemaName != null ) { Integer count = dbMap . get ( schemaName ) ; if ( count == null ) dbMap . put ( schemaName , NUM_ ) ; else dbMap . put ( schemaName , count . intValue ( ) + NUM_ ) ; } lastDb = schemaName ; }
private String buildEventData ( ) throws JAXBException { if ( _eventParameters != null ) { try { JAXBContext jaxbContext = JAXBContext . newInstance ( EventParameters . class ) ; Marshaller marshaller = jaxbContext . createMarshaller ( ) ; marshaller . setProperty ( Marshaller . JAXB_FORMATTED_OUTPUT , BOOL_ ) ; Writer outWriter = new StringWriter ( ) ; StreamResult result = new StreamResult ( outWriter ) ; marshaller . marshal ( _eventParameters , result ) ; return outWriter . toString ( ) ; } catch ( JAXBException e ) { _log . error ( STR_ + e . getMessage ( ) ) ; throw e ; } } else { return null ; } }
public boolean isProjected ( ) { return projected ; }
private boolean normalizeAttrValue ( XMLAttributes attributes , int index ) { boolean leadingSpace = BOOL_ ; boolean spaceStart = BOOL_ ; boolean readingNonSpace = BOOL_ ; int count = NUM_ ; int eaten = NUM_ ; String attrValue = attributes . getValue ( index ) ; char [ ] attValue = new char [ attrValue . length ( ) ] ; fBuffer . setLength ( NUM_ ) ; attrValue . getChars ( NUM_ , attrValue . length ( ) , attValue , NUM_ ) ; for ( int i = NUM_ ; i < attValue . length ; i ++ ) { if ( attValue [ i ] == STR_ ) { if ( readingNonSpace ) { spaceStart = BOOL_ ; readingNonSpace = BOOL_ ; } if ( spaceStart && ! leadingSpace ) { spaceStart = BOOL_ ; fBuffer . append ( attValue [ i ] ) ; count ++ ; } else { if ( leadingSpace || ! spaceStart ) { eaten ++ ; } } } else { readingNonSpace = BOOL_ ; spaceStart = BOOL_ ; leadingSpace = BOOL_ ; fBuffer . append ( attValue [ i ] ) ; count ++ ; } } if ( count > NUM_ && fBuffer . charAt ( count - NUM_ ) == STR_ ) { fBuffer . setLength ( count - NUM_ ) ; } String newValue = fBuffer . toString ( ) ; attributes . setValue ( index , newValue ) ; return ! attrValue . equals ( newValue ) ; }
private Shape decodeMarkInterior ( int width , int height ) { double left = width / NUM_ - NUM_ ; double top = height / NUM_ - NUM_ ; path . reset ( ) ; path . moveTo ( left + NUM_ , top + NUM_ ) ; path . lineTo ( left + NUM_ , top + NUM_ ) ; path . lineTo ( left + NUM_ , top + NUM_ ) ; path . closePath ( ) ; return path ; }
public MonotoneSolver ( final ILatticeGraph < GraphNode > graph , final Lattice lattice , final IStateVector < GraphNode , LatticeElement > startVector , final ITransformationProvider < GraphNode , LatticeElement > transformationProvider , final IGraphWalker < GraphNode , ObjectType > walker ) { if ( graph == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( lattice == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( startVector == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( transformationProvider == null ) { throw new IllegalArgumentException ( STR_ ) ; } final List < GraphNode > nodes = graph . getNodes ( ) ; if ( nodes . size ( ) != startVector . size ( ) ) { throw new IllegalArgumentException ( String . format ( STR_ , startVector . size ( ) , nodes . size ( ) ) ) ; } for ( final GraphNode node : nodes ) { if ( ! startVector . hasState ( node ) ) { throw new IllegalArgumentException ( STR_ + node + STR_ ) ; } } this . graph = graph ; this . lattice = lattice ; this . state = startVector ; this . transformationList = transformationProvider ; this . walker = walker ; }
private Stat preparePortStatInfo ( String nativeId , URI resourceId , long iops , long timeSample ) { Stat ipPortStat = new Stat ( ) ; ipPortStat . setServiceType ( Constants . _File ) ; ipPortStat . setTimeCollected ( timeSample ) ; ipPortStat . setResourceId ( resourceId ) ; ipPortStat . setNativeGuid ( nativeId ) ; ipPortStat . setTotalIOs ( iops ) ; return ipPortStat ; }
public void testInsert3 ( ) throws SQLException { DatabaseCreator . fillParentTable ( conn ) ; DatabaseCreator . fillFKStrictTable ( conn ) ; statement . execute ( STR_ + DatabaseCreator . TEST_TABLE5 + STR_ + STR_ + DatabaseCreator . FKSTRICT_TABLE + STR_ ) ; ResultSet r = statement . executeQuery ( STR_ + DatabaseCreator . TEST_TABLE5 ) ; r . next ( ) ; assertEquals ( STR_ , NUM_ , r . getInt ( NUM_ ) ) ; r . close ( ) ; }
public int compareTo ( AppVersion other ) { int result = major - other . major ; if ( result == NUM_ ) { result = minor - other . minor ; } if ( result == NUM_ ) { result = patch - other . patch ; } if ( result == NUM_ && ( milestone > - NUM_ || other . milestone > - NUM_ ) ) { if ( milestone > - NUM_ ) { if ( other . milestone == - NUM_ ) { result = - NUM_ ; } else { result = milestone - other . milestone ; } } else { if ( other . milestone > - NUM_ ) { result = NUM_ ; } } } if ( result == NUM_ && ! ObjectUtil . nullEquals ( modifier , other . modifier ) ) { if ( modifier == null ) { result = NUM_ ; } else if ( other . modifier == null ) { result = - NUM_ ; } else { result = modifier . compareToIgnoreCase ( other . modifier ) ; } } return result ; }
public StreamConsumer ( InputStream stream , String charset ) { in = new BufferedInputStream ( stream ) ; this . charset = charset ; thread . start ( ) ; }
public MediaSize ( int x , int y , int units ) { super ( x , y , units ) ; if ( x > y ) { throw new IllegalArgumentException ( STR_ ) ; } sizeVector . add ( this ) ; }
private Peer constructPeerPojo ( final PeerData peerData ) throws PeerException { Preconditions . checkNotNull ( peerData , STR_ ) ; try { PeerInfo peerInfo = fromJson ( peerData . getInfo ( ) , PeerInfo . class ) ; if ( localPeerId . equals ( peerData . getId ( ) ) ) { localPeer . setPeerInfo ( peerInfo ) ; return localPeer ; } RemotePeerImpl remotePeer = new RemotePeerImpl ( localPeerId , securityManager , peerInfo , messenger , commandResponseListener , messageResponseListener , provider , this ) ; RelationInfoMeta relationInfoMeta = new RelationInfoMeta ( ) ; Map < String , String > traits = relationInfoMeta . getRelationTraits ( ) ; traits . put ( STR_ , STR_ ) ; traits . put ( STR_ , STR_ ) ; traits . put ( STR_ , STR_ ) ; User peerOwner = identityManager . getUserByKeyId ( identityManager . getPeerOwnerId ( ) ) ; RelationMeta relationMeta = new RelationMeta ( peerOwner , localPeer , remotePeer , localPeer . getKeyId ( ) ) ; Relation relation = relationManager . buildRelation ( relationInfoMeta , relationMeta ) ; relation . setRelationStatus ( RelationStatus . VERIFIED ) ; relationManager . saveRelation ( relation ) ; return remotePeer ; } catch ( Exception e ) { throw new PeerException ( STR_ , e ) ; } }
public void loadWorkspaceContents ( String xml ) throws BlocklyParserException { loadWorkspaceContents ( new ByteArrayInputStream ( xml . getBytes ( ) ) ) ; }
private boolean compareAndDecrementWorkerCount ( int expect ) { return ctl . compareAndSet ( expect , expect - NUM_ ) ; }
public boolean load ( String fileLocation , int type ) { if ( mHasLoaded ) { return BOOL_ ; } String shaderCode ; try { shaderCode = ShaderUtils . getStringFromFileInAssets ( mContext , fileLocation , BOOL_ ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; mIsCompiled = BOOL_ ; return BOOL_ ; } mHasLoaded = BOOL_ ; mShaderId = GLES20 . glCreateShader ( type ) ; if ( mShaderId == NUM_ ) { String msg = ( type == GLES20 . GL_VERTEX_SHADER ? STR_ : STR_ ) ; Log . e ( TAG , STR_ + msg ) ; return BOOL_ ; } GLES20 . glShaderSource ( mShaderId , shaderCode ) ; GLES20 . glCompileShader ( mShaderId ) ; int [ ] compileStatus = new int [ NUM_ ] ; GLES20 . glGetShaderiv ( mShaderId , GLES20 . GL_COMPILE_STATUS , compileStatus , NUM_ ) ; mIsCompiled = ( compileStatus [ NUM_ ] == GLES20 . GL_TRUE ) ; if ( ! mIsCompiled ) { String compileError = GLES20 . glGetShaderInfoLog ( mShaderId ) ; Log . e ( TAG , compileError ) ; GLES20 . glDeleteShader ( mShaderId ) ; } return mIsCompiled && mHasLoaded ; }
public void addChild ( PdfLayer childLayer ) { if ( childLayer . parent != null ) throw new IllegalArgumentException ( STR_ ) ; childLayer . parent = this ; if ( children == null ) children = new ArrayList < > ( ) ; children . add ( childLayer ) ; }
protected void moveRandomly ( OMPoint point , double factor , Projection proj ) { double hor = Math . random ( ) - NUM_ ; double vert = Math . random ( ) - NUM_ ; Point2D mapPoint = proj . forward ( point . getLat ( ) , point . getLon ( ) ) ; mapPoint . setLocation ( mapPoint . getX ( ) + ( hor . factor ) , mapPoint . getY ( ) + ( vert . factor ) ) ; Point2D llp = proj . inverse ( mapPoint ) ; point . setLat ( llp . getY ( ) ) ; point . setLon ( llp . getX ( ) ) ; }
private void initializeContext ( ) throws IOException { String workingDir = System . getProperty ( STR_ ) ; File dataset = FileUtils . getFile ( workingDir + STR_ ) ; File log4jFile = FileUtils . getFile ( workingDir + STR_ ) ; File datasetFolder = new File ( destinationFolder + STR_ ) ; File log4jFolder = new File ( destinationFolder + STR_ ) ; dataset . mkdirs ( ) ; log4jFile . mkdirs ( ) ; FileUtils . copyFileToDirectory ( dataset , datasetFolder ) ; FileUtils . copyFileToDirectory ( log4jFile , log4jFolder ) ; }
protected boolean isTokenChar ( char ch ) { if ( Character . isLetterOrDigit ( ch ) ) return BOOL_ ; if ( Character . isISOControl ( ch ) ) return BOOL_ ; if ( isHttpSeparator ( ch ) ) return BOOL_ ; return BOOL_ ; }
public static int parseInt ( FXGNode node , String value , String name ) { try { return Integer . parseInt ( value ) ; } catch ( NumberFormatException e ) { throw new FXGException ( node . getStartLine ( ) , node . getStartColumn ( ) , STR_ , name , value ) ; } }
public static double invSqrtQuick ( final double value ) { if ( USE_JDK_MATH ) { return NUM_ / Math . sqrt ( value ) ; } return Double . longBitsToDouble ( x5FE6EB50C7B537A9L - ( Double . doubleToRawLongBits ( value ) > > NUM_ ) ) ; }
public void close ( ) throws IOException { articleIdxWriter . close ( ) ; chronoIdxWriter . close ( ) ; revisionIdxWriter . close ( ) ; }
private final byte [ ] zeroExtend ( byte [ ] dataToPad ) { assert null != dataToPad ; final int targetLength = NUM_ ; if ( targetLength <= dataToPad . length ) return dataToPad ; byte padded [ ] = new byte [ targetLength ] ; for ( int i = NUM_ ; i < dataToPad . length ; i ++ ) padded [ i ] = dataToPad [ i ] ; for ( int i = dataToPad . length ; i < padded . length ; i ++ ) padded [ i ] = ( byte ) NUM_ ; return padded ; }
public void applyFromResolveInfo ( PackageManager pm , ResolveInfo info , WidgetPreviewLoader loader ) { mInfo = info ; CharSequence label = info . loadLabel ( pm ) ; mWidgetName . setText ( label ) ; mWidgetDims . setText ( String . format ( mDimensionsFormatString , NUM_ , NUM_ ) ) ; mWidgetPreviewLoader = loader ; }
private static boolean isCertificateEntry ( String alias ) throws KeyStoreException { return sKeyStore . isCertificateEntry ( alias ) ; }
public void test_unwrap_06 ( ) { String host = STR_ ; int port = NUM_ ; ByteBuffer [ ] bbA = { ByteBuffer . allocate ( NUM_ ) , ByteBuffer . allocate ( NUM_ ) , ByteBuffer . allocate ( NUM_ ) } ; ByteBuffer bb = ByteBuffer . allocate ( NUM_ ) ; SSLEngine sse = getEngine ( host , port ) ; sse . setUseClientMode ( BOOL_ ) ; try { SSLEngineResult res = sse . unwrap ( bb , bbA , NUM_ , bbA . length ) ; assertEquals ( NUM_ , res . bytesConsumed ( ) ) ; assertEquals ( NUM_ , res . bytesProduced ( ) ) ; } catch ( Exception ex ) { fail ( STR_ + ex ) ; } }
public static Window windowForWordInPosition ( int windowSize , int wordPos , List < String > sentence ) { List < String > window = new ArrayList < > ( ) ; List < String > onlyTokens = new ArrayList < > ( ) ; int contextSize = ( int ) Math . floor ( ( windowSize - NUM_ ) / NUM_ ) ; for ( int i = wordPos - contextSize ; i <= wordPos + contextSize ; i ++ ) { if ( i < NUM_ ) window . add ( STR_ ) ; else if ( i >= sentence . size ( ) ) window . add ( STR_ ) ; else { onlyTokens . add ( sentence . get ( i ) ) ; window . add ( sentence . get ( i ) ) ; } } String wholeSentence = StringUtils . join ( sentence ) ; String window2 = StringUtils . join ( onlyTokens ) ; int begin = wholeSentence . indexOf ( window2 ) ; int end = begin + window2 . length ( ) ; return new Window ( window , begin , end ) ; }
private void fillIn ( ClassSymbol c ) { if ( completionFailureName == c . fullname ) { throw new CompletionFailure ( c , STR_ ) ; } currentOwner = c ; warnedAttrs . clear ( ) ; JavaFileObject classfile = c . classfile ; if ( classfile != null ) { JavaFileObject previousClassFile = currentClassFile ; try { if ( filling ) { Assert . error ( STR_ + classfile . toUri ( ) + STR_ + previousClassFile ) ; } currentClassFile = classfile ; if ( verbose ) { log . printVerbose ( STR_ , currentClassFile . toString ( ) ) ; } if ( classfile . getKind ( ) == JavaFileObject . Kind . CLASS ) { filling = BOOL_ ; try { bp = NUM_ ; buf = readInputStream ( buf , classfile . openInputStream ( ) ) ; readClassFile ( c ) ; if ( ! missingTypeVariables . isEmpty ( ) && ! foundTypeVariables . isEmpty ( ) ) { List < Type > missing = missingTypeVariables ; List < Type > found = foundTypeVariables ; missingTypeVariables = List . nil ( ) ; foundTypeVariables = List . nil ( ) ; filling = BOOL_ ; ClassType ct = ( ClassType ) currentOwner . type ; ct . supertype_field = types . subst ( ct . supertype_field , missing , found ) ; ct . interfaces_field = types . subst ( ct . interfaces_field , missing , found ) ; } else if ( missingTypeVariables . isEmpty ( ) != foundTypeVariables . isEmpty ( ) ) { Name name = missingTypeVariables . head . tsym . name ; throw badClassFile ( STR_ , name ) ; } } finally { missingTypeVariables = List . nil ( ) ; foundTypeVariables = List . nil ( ) ; filling = BOOL_ ; } } else { if ( sourceCompleter != null ) { sourceCompleter . complete ( c ) ; } else { throw new IllegalStateException ( STR_ + classfile . toUri ( ) ) ; } } return ; } catch ( IOException ex ) { throw badClassFile ( STR_ , ex . getMessage ( ) ) ; } finally { currentClassFile = previousClassFile ; } } else { JCDiagnostic diag = diagFactory . fragment ( STR_ , c . flatname ) ; throw newCompletionFailure ( c , diag ) ; } }
public void enable ( ) { List < Entry > entries = removeIntersectedEntries ( tree . getSelectedEntries ( ) ) ; boolean enable = BOOL_ ; for ( Entry entry : entries ) { if ( entry == null ) { enable = BOOL_ ; break ; } if ( ! requiredSelectionType . isInstance ( entry ) ) { enable = BOOL_ ; break ; } if ( needsWriteAccess && entry . isReadOnly ( ) ) { enable = BOOL_ ; break ; } } if ( entries . isEmpty ( ) ) { enable = BOOL_ ; } setEnabled ( enable ) ; }
public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; if ( getName ( ) != null ) { buffer . append ( getName ( ) ) ; } buffer . append ( STR_ ) ; if ( getEnclosingTypeName ( ) != null ) { buffer . append ( getEnclosingTypeName ( ) ) ; } buffer . append ( STR_ ) ; if ( getSourceName ( ) != null ) { buffer . append ( getSourceName ( ) ) ; } return buffer . toString ( ) ; }
protected void mark ( ) throws CompilationFailedException { applyToSourceUnits ( mark ) ; }
private boolean labelToKeepRec ( Node v , Set < Integer > ids , NodeSet keep ) { boolean hasBelow = BOOL_ ; int id = ( Integer ) v . getInfo ( ) ; if ( ids . size ( ) == NUM_ || ids . contains ( id ) ) hasBelow = BOOL_ ; for ( Edge e = v . getFirstOutEdge ( ) ; e != null ; e = v . getNextOutEdge ( e ) ) { Node w = e . getTarget ( ) ; if ( labelToKeepRec ( w , ids , keep ) ) hasBelow = BOOL_ ; } if ( hasBelow ) keep . add ( v ) ; return hasBelow ; }
public void putExternalProperty ( SSOToken clientToken , String key , String value ) throws SessionException { try { sessionUtilsWrapper . checkPermissionToSetProperty ( clientToken , key , value ) ; } catch ( SessionException se ) { fireSessionEvent ( SessionEventType . PROTECTED_PROPERTY ) ; sessionLogging . logEvent ( toSessionInfo ( ) , SessionEventType . PROTECTED_PROPERTY ) ; throw se ; } internalPutProperty ( key , value ) ; debug . message ( STR_ ) ; }
void addEdge ( MethodParameter in , MethodParameter out ) { Set < MethodParameter > outs = graph . get ( in ) ; if ( outs == null ) { outs = new HashSet < > ( ) ; graph . put ( in , outs ) ; } outs . add ( out ) ; }
public static int [ ] randomNumber ( int n ) { int [ ] num = new int [ n ] ; for ( int i = NUM_ ; i < num . length ; i ++ ) { num [ i ] = ( int ) ( rGen . nextDouble ( ) . NUM_ ) ; } return num ; }
public boolean isDeviceTV ( Context context ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . LOLLIPOP ) { UiModeManager uiManager = ( UiModeManager ) context . getSystemService ( Context . UI_MODE_SERVICE ) ; return uiManager != null && uiManager . getCurrentModeType ( ) == Configuration . UI_MODE_TYPE_TELEVISION ; } return BOOL_ ; }
protected void rcptToAuthors ( final RecipientType rt ) { for ( final Account . Id id : authors ) { add ( rt , id ) ; } }
public Object createShapeData ( Shape shape ) { return null ; }
private ProtectionSet createProtectionSet ( RecoverPointVolumeIngestionContext volumeContext ) { UnManagedProtectionSet umpset = volumeContext . getUnManagedProtectionSet ( ) ; ProtectionSet pset = VolumeIngestionUtil . findOrCreateProtectionSet ( volumeContext , volumeContext . getUnmanagedVolume ( ) , umpset , _dbClient ) ; volumeContext . setManagedProtectionSet ( pset ) ; return pset ; }
public synchronized void dispose ( ) { if ( isDisposed ) { return ; } isDisposed = BOOL_ ; ArrayList < PooledConnection > list = recycledConnections ; for ( int i = NUM_ , size = list . size ( ) ; i < size ; i ++ ) { closeConnection ( list . get ( i ) ) ; } }
public static String appendParameter ( CtClass type , String descriptor ) { int i = descriptor . indexOf ( STR_ ) ; if ( i < NUM_ ) return descriptor ; else { StringBuffer newdesc = new StringBuffer ( ) ; newdesc . append ( descriptor . substring ( NUM_ , i ) ) ; toDescriptor ( newdesc , type ) ; newdesc . append ( descriptor . substring ( i ) ) ; return newdesc . toString ( ) ; } }
public void writeTo ( byte [ ] bytes , int offset ) throws IOException { flush ( ) ; final long end = file . length ; long pos = NUM_ ; int buffer = NUM_ ; int bytesUpto = offset ; while ( pos < end ) { int length = BUFFER_SIZE ; long nextPos = pos + length ; if ( nextPos > end ) { length = ( int ) ( end - pos ) ; } System . arraycopy ( file . getBuffer ( buffer ++ ) , NUM_ , bytes , bytesUpto , length ) ; bytesUpto += length ; pos = nextPos ; } }
protected int calcnCluster ( ) { return NUM_ ; }
public static void validateServiceName ( String serviceCode , String serviceName ) { if ( ! serviceName . startsWith ( serviceCode ) ) { throw new CodedException ( X_INCONSISTENT_HEADERS , STR_ + STR_ ) ; } }
protected static void initCMYKColorspace ( ) { if ( ICCProfileForRGB == null ) { rgbModel = new ComponentColorModel ( rgbCS , new int [ ] { NUM_ , NUM_ , NUM_ } , BOOL_ , BOOL_ , ColorModel . OPAQUE , DataBuffer . TYPE_BYTE ) ; } else { final int compCount = rgbCS . getNumComponents ( ) ; final int [ ] values = new int [ compCount ] ; for ( int i = NUM_ ; i < compCount ; i ++ ) { values [ i ] = NUM_ ; } rgbModel = new ComponentColorModel ( rgbCS , values , BOOL_ , BOOL_ , ColorModel . OPAQUE , DataBuffer . TYPE_BYTE ) ; } final FastColorSpaceCMYK cmykCS = new FastColorSpaceCMYK ( ) ; CSToRGB = new ColorConvertOp ( cmykCS , rgbCS , ColorSpaces . hints ) ; }
private void addNotificationCategorySeparator ( JPanel panel ) { JSeparator jsep = new JSeparator ( SwingConstants . HORIZONTAL ) ; jsep . setMaximumSize ( new Dimension ( Short . MAX_VALUE , NUM_ ) ) ; panel . add ( jsep ) ; }
public void clearDraggedOperators ( ) { this . draggedOperators = Collections . unmodifiableList ( Collections . < Operator > emptyList ( ) ) ; }
public FakeClock resetTime ( ) { fakeNowMs . set ( baseTimeMs ) ; return this ; }
public void removeUpdateListener ( AnimatorUpdateListener listener ) { if ( mUpdateListeners == null ) { return ; } mUpdateListeners . remove ( listener ) ; if ( mUpdateListeners . size ( ) == NUM_ ) { mUpdateListeners = null ; } }
public GSERParser ( CharSequence value ) { Reject . checkNotNull ( value ) ; this . gserValue = value . toString ( ) ; this . pos = NUM_ ; this . length = value . length ( ) ; }
public Slice ( double start , double end , boolean visible ) { this . start = start ; this . end = end ; this . visible = visible ; }
public static void injectToTarget ( Object target , Bundle data ) { if ( target == null || data == null ) return ; ParcelInjector injector ; try { injector = getInjectorByClass ( target . getClass ( ) ) ; injector . injectDataToTarget ( target , data ) ; } catch ( Exception e ) { throw new RuntimeException ( String . format ( STR_ , e . getMessage ( ) ) , e ) ; } }
public static boolean areBackendInitiators ( List < Initiator > initiators ) { boolean backend = BOOL_ ; for ( Initiator initiator : initiators ) { if ( ! NullColumnValueGetter . isNullURI ( initiator . getHost ( ) ) && URIUtil . isType ( initiator . getHost ( ) , Host . class ) ) { backend = BOOL_ ; break ; } } return backend ; }
public boolean containsValue ( Object value ) { return map . containsValue ( value ) ; }
private void writeAttribute ( java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( namespace . equals ( STR_ ) ) { xmlWriter . writeAttribute ( attName , attValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } }
public boolean hasSkins ( ) { return System . getProperty ( STR_ ) != null || System . getProperty ( STR_ ) != null ; }
public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; if ( type != null ) { name ( builder ) ; attributes ( builder ) ; } return builder . toString ( ) ; }
public void makeImmutable ( ) { if ( ! isImmutable ) { overflowEntries = overflowEntries . isEmpty ( ) ? Collections . < K , V > emptyMap ( ) : Collections . unmodifiableMap ( overflowEntries ) ; isImmutable = BOOL_ ; } }
protected void parseNames ( ) { while ( reader . hasNextCharacter ( ) ) { final char character = next ( ) ; if ( Strings . isWhitespace ( character ) ) { addName ( ) ; continue ; } else if ( character == blockOpening ) { addName ( ) ; break ; } else { builder . append ( character ) ; } } if ( GdxArrays . isEmpty ( tags ) ) { throwException ( STR_ ) ; } }
protected void writeZip64CentralDirectory ( ) throws IOException { if ( zip64Mode == Zip64Mode . Never ) { return ; } if ( ! hasUsedZip64 && ( cdOffset >= ZIP64_MAGIC || cdLength >= ZIP64_MAGIC || entries . size ( ) >= ZIP64_MAGIC_SHORT ) ) { hasUsedZip64 = BOOL_ ; } if ( ! hasUsedZip64 ) { return ; } long offset = written ; writeOut ( ZIP64_EOCD_SIG ) ; writeOut ( ZipEightByteInteger . getBytes ( SHORT + SHORT + WORD + WORD + DWORD + DWORD + DWORD + DWORD ) ) ; writeOut ( ZipShort . getBytes ( ZIP64_MIN_VERSION ) ) ; writeOut ( ZipShort . getBytes ( ZIP64_MIN_VERSION ) ) ; writeOut ( LZERO ) ; writeOut ( LZERO ) ; byte [ ] num = ZipEightByteInteger . getBytes ( entries . size ( ) ) ; writeOut ( num ) ; writeOut ( num ) ; writeOut ( ZipEightByteInteger . getBytes ( cdLength ) ) ; writeOut ( ZipEightByteInteger . getBytes ( cdOffset ) ) ; writeOut ( ZIP64_EOCD_LOC_SIG ) ; writeOut ( LZERO ) ; writeOut ( ZipEightByteInteger . getBytes ( offset ) ) ; writeOut ( ONE ) ; }
public boolean isCacheValid ( int row ) { return m_valid . get ( row ) ; }
public void finish ( ) throws IOException { checkClosed ( ) ; write ( ) ; }
public final void readFully ( byte [ ] b , int off , int len ) throws java . io . IOException { if ( len < NUM_ ) { throw new IndexOutOfBoundsException ( ) ; } int n = NUM_ ; while ( n < len ) { int count = read ( b , off + n , len - n ) ; if ( count < NUM_ ) { throw new EOFException ( ) ; } n += count ; } }
public SVGRasterizer ( InputStream istream ) { this . input = new TranscoderInput ( istream ) ; }
private static Future < ? > directExecute ( Runnable runnable , int delay ) { Future < ? > future = null ; if ( delay > NUM_ ) { if ( ! ( executor instanceof ScheduledExecutorService ) ) { throw new IllegalArgumentException ( STR_ ) ; } ScheduledExecutorService scheduledExecutorService = ( ScheduledExecutorService ) executor ; future = scheduledExecutorService . schedule ( runnable , delay , TimeUnit . MILLISECONDS ) ; } else { if ( executor instanceof ExecutorService ) { ExecutorService executorService = ( ExecutorService ) executor ; future = executorService . submit ( runnable ) ; } else { executor . execute ( runnable ) ; } } return future ; }
@ Override public void onPatchVersionCheckFail ( File patchFile , SharePatchInfo oldPatchInfo , String patchFileVersion , boolean isUpgradePatch ) { TinkerLog . i ( TAG , STR_ , patchFile . getAbsolutePath ( ) , patchFileVersion , isUpgradePatch ) ; }
public void init ( boolean forEncryption , CipherParameters params ) throws IllegalArgumentException { if ( ! ( params instanceof ParametersWithIV ) ) { throw new IllegalArgumentException ( STR_ ) ; } ParametersWithIV ivParams = ( ParametersWithIV ) params ; byte [ ] iv = ivParams . getIV ( ) ; if ( iv == null || iv . length != NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } if ( ! ( ivParams . getParameters ( ) instanceof KeyParameter ) ) { throw new IllegalArgumentException ( STR_ ) ; } KeyParameter key = ( KeyParameter ) ivParams . getParameters ( ) ; workingIV = new byte [ key . getKey ( ) . length ] ; workingKey = new byte [ key . getKey ( ) . length ] ; lfsr = new int [ STATE_SIZE ] ; nfsr = new int [ STATE_SIZE ] ; out = new byte [ NUM_ ] ; System . arraycopy ( iv , NUM_ , workingIV , NUM_ , iv . length ) ; System . arraycopy ( key . getKey ( ) , NUM_ , workingKey , NUM_ , key . getKey ( ) . length ) ; reset ( ) ; }
public ExtensionForcedUser ( ) { super ( ) ; initialize ( ) ; }
private String replacePlaceholders ( String query , Map < String , String > replacements ) { String resultQuery = query ; for ( Map . Entry < String , String > entry : replacements . entrySet ( ) ) { resultQuery = resultQuery . replace ( entry . getKey ( ) , entry . getValue ( ) ) ; } return resultQuery ; }
protected int readFully ( InputStream in , byte buffer [ ] ) throws java . io . IOException { for ( int i = NUM_ ; i < buffer . length ; i ++ ) { int q = in . read ( ) ; if ( q == - NUM_ ) return i ; buffer [ i ] = ( byte ) q ; } return buffer . length ; }
public void destroyBucket ( AutoMixBucket bucket ) { SharedPreferences prefs = getPrefs ( ) ; SharedPreferences . Editor editor = prefs . edit ( ) ; Set < String > set = new TreeSet < > ( prefs . getStringSet ( PREF_BUCKETS_IDS , new TreeSet < String > ( ) ) ) ; set . remove ( bucket . getSessionId ( ) ) ; editor . putStringSet ( PREF_BUCKETS_IDS , set ) ; editor . apply ( ) ; mBuckets . remove ( bucket ) ; }
public void clearChanged ( ) { changed . set ( BOOL_ ) ; }
public static Object [ ] convertParams ( Object [ ] source , Class < ? > [ ] target ) { Object [ ] converted = new Object [ target . length ] ; for ( int i = NUM_ ; i < target . length ; i ++ ) { converted [ i ] = convert ( source [ i ] , target [ i ] ) ; } return converted ; }
private void rProbeAndAddHopsToCandidateSet ( Hop hop , HashSet < Hop > probeSet , HashSet < Pair < Hop , Hop > > candSet ) { if ( hop . getVisited ( ) == VisitStatus . DONE ) return ; if ( hop . getInput ( ) != null ) for ( Hop c : hop . getInput ( ) ) { if ( ! probeSet . contains ( c ) ) rProbeAndAddHopsToCandidateSet ( c , probeSet , candSet ) ; else { candSet . add ( new Pair < Hop , Hop > ( hop , c ) ) ; } } hop . setVisited ( VisitStatus . DONE ) ; }
protected void parse ( DataInputStream stream ) throws Exception { value = stream . readInt ( ) ; }
List < String > asList ( ) { if ( more ) { list . set ( list . size ( ) - NUM_ , STR_ ) ; } return Collections . unmodifiableList ( list ) ; }
public void testNotNeg ( ) { byte aBytes [ ] = { - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ } ; int aSign = - NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger result = aNumber . not ( ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public CacheStatResource ( String resourceIdentifier , CacheResource cacheResource ) { super ( resourceIdentifier ) ; this . cacheResource = cacheResource ; relativeCacheStats = cacheResource . getCacheStats ( ) ; }
public Map < URI , List < URI > > addTargetVolumeFullCopies ( ) { List < URI > fullCopies = Lists . newArrayList ( ) ; Map < URI , List < URI > > fullCopiesMap = new HashMap < > ( ) ; URI targetCG = null ; for ( URI volumeId : uris ( volumeIds ) ) { List < URI > targets = getTargets ( volumeId ) ; for ( URI target : targets ) { if ( targetCG == null ) { targetCG = getConsistencyGroup ( target ) ; } List < URI > volumeFullCopies = getFullCopies ( target ) ; fullCopies . addAll ( volumeFullCopies ) ; fullCopiesMap . put ( target , volumeFullCopies ) ; } } if ( ! fullCopies . isEmpty ( ) && targetCG != null ) { BlockStorageUtils . addVolumesToConsistencyGroup ( targetCG , fullCopies ) ; } return fullCopiesMap ; }
WeatherAttribute ( int max , String ... desc ) { maxValue = max ; value = Rand . rand ( max + NUM_ ) ; this . desc = desc ; }
protected ClassLoader ( ClassLoader parentLoader ) { SecurityManager sc = System . getSecurityManager ( ) ; if ( sc != null ) { sc . checkCreateClassLoader ( ) ; } parentClassLoader = parentLoader ; definedPackages = new HashMap < String , Package > ( ) ; loadedClasses = new HashMap < String , Class < ? > > ( ) ; packageCertificates = new Hashtable < String , Certificate [ ] > ( ) ; }
static public double log10 ( double inValue ) { return Math . log ( inValue ) / Math . log ( NUM_ ) ; }
void updateFeatureCounts ( int [ ] translationIds , List < List < RichTranslation < IString , String > > > nbestLists ) { for ( int i = NUM_ ; i < translationIds . length ; i ++ ) { Set < String > features = new HashSet < String > ( ) ; for ( RichTranslation < IString , String > trans : nbestLists . get ( i ) ) { for ( FeatureValue < String > f : trans . features ) { features . add ( f . name ) ; } } synchronized ( clippedFeatureIndex ) { for ( String fName : features ) { Set < Integer > ids = clippedFeatureIndex . get ( fName ) ; if ( ids == null ) { ids = new TreeSet < Integer > ( ) ; clippedFeatureIndex . put ( fName , ids ) ; } if ( ids . size ( ) < minFeatureCount ) { ids . add ( translationIds [ i ] ) ; } } } } }
public static void d ( String tag , String msg , Object ... args ) { if ( sLevel > LEVEL_DEBUG ) { return ; } if ( args . length > NUM_ ) { msg = String . format ( msg , args ) ; } Log . d ( tag , msg ) ; }
private void addNativeExpressAds ( ) { for ( int i = NUM_ ; i <= mRecyclerViewItems . size ( ) ; i += ITEMS_PER_AD ) { final NativeExpressAdView adView = new NativeExpressAdView ( MainActivity . this ) ; mRecyclerViewItems . add ( i , adView ) ; } }
protected boolean accept ( final IChangeRecord record ) { return BOOL_ ; }
public final T allocate ( ) { AtomicInteger topRef = _top ; while ( BOOL_ ) { final int top = topRef . get ( ) ; if ( top <= NUM_ ) { return null ; } else if ( topRef . compareAndSet ( top , top - NUM_ ) ) { T value = _freeStack . getAndSet ( top - NUM_ , null ) ; if ( value != null ) { return value ; } } } }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
public void putResponseGetAllResources ( List < String > resources ) { logger . debug ( STR_ ) ; ResourceSet resourceSet = new ResourceSet ( ) ; for ( String res : resources ) { RemoteResource resource = gson . fromJson ( res , RemoteResource . class ) ; resource . setResourcePoolConnector ( this ) ; resourceSet . add ( resource ) ; } synchronized ( getAllResourceResponse ) { getAllResourceResponse . add ( resourceSet ) ; getAllResourceResponse . notify ( ) ; } }
public static Map < String , Set < String > > toAvPairMap ( final Set < String > names , final String value ) { if ( value == null ) { return Collections . EMPTY_MAP ; } if ( names == null || names . isEmpty ( ) ) { return new HashMap ( ) ; } final Map < String , Set < String > > map = new HashMap < String , Set < String > > ( names . size ( ) ) ; final Set < String > set = new HashSet < String > ( NUM_ ) ; set . add ( value ) ; for ( final String name : names ) { map . put ( name , set ) ; } return map ; }
public PrefixTagger ( MaxentTagger maxentTagger ) { super ( maxentTagger ) ; this . leftWindow = leftWindow ( ) ; this . rightWindow = rightWindow ( ) ; this . offset = leftWindow ( ) ; }
@ Override public void performRequest ( String request ) { if ( request . compareTo ( STR_ ) == NUM_ ) { stop ( ) ; } else { throw new IllegalArgumentException ( request + STR_ ) ; } }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( NUM_ ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
public synchronized void kill ( ) { running = BOOL_ ; closed = BOOL_ ; try { STDIN . close ( ) ; } catch ( IOException e ) { } try { process . destroy ( ) ; } catch ( Exception e ) { } }
private Iterable < int [ ] > splitArray ( int [ ] arr ) { int len1 = arr . length / NUM_ ; int len2 = len1 + arr . length % NUM_ ; int [ ] a1 = new int [ len1 ] ; int [ ] a2 = new int [ len2 ] ; System . arraycopy ( arr , NUM_ , a1 , NUM_ , len1 ) ; System . arraycopy ( arr , len1 , a2 , NUM_ , len2 ) ; return Arrays . asList ( a1 , a2 ) ; }
public void put ( E e ) throws InterruptedException { checkNotNull ( e ) ; final ReentrantLock lock = this . lock ; lock . lockInterruptibly ( ) ; try { while ( count == items . length ) notFull . await ( ) ; enqueue ( e ) ; } finally { lock . unlock ( ) ; } }
@ Ignore @ Test public void shouldCaptureQueryEventData ( ) throws Exception { startClient ( null ) ; counters . consumeAll ( NUM_ , TimeUnit . SECONDS ) ; List < QueryEventData > allQueryEvents = recordedEventData ( QueryEventData . class , - NUM_ ) ; allQueryEvents . forEach ( null ) ; }
private List < ValidationError > checkForNoRatesPresent ( ) { if ( overheadRates != null && overheadRates . isEmpty ( ) ) return Arrays . asList ( new ValidationError ( STR_ , STR_ ) ) ; else return null ; }
public void modifyExport ( String id , String zoneName , IsilonExport exp ) throws IsilonException { String uriWithZoneName = getURIWithZoneName ( id , zoneName ) ; modify ( _baseUrl . resolve ( URI_NFS_EXPORTS ) , uriWithZoneName , STR_ , exp ) ; }
public double measureNumIterations ( ) { return m_Classifiers . size ( ) ; }
public void markPotentiallyUnknownBit ( LocalVariableBinding local ) { if ( this != DEAD_END ) { this . tagBits |= NULL_FLAG_MASK ; int position ; long mask ; if ( ( position = local . id + this . maxFieldCount ) < BitCacheSize ) { mask = NUM_ << position ; isTrue ( ( this . nullBit1 & mask ) == NUM_ , STR_ ) ; this . nullBit4 |= mask ; if ( COVERAGE_TEST_FLAG ) { if ( CoverageTestId == NUM_ ) { this . nullBit4 = ~ NUM_ ; } } } else { int vectorIndex = ( position / BitCacheSize ) - NUM_ ; if ( this . extra == null ) { int length = vectorIndex + NUM_ ; this . extra = new long [ extraLength ] [ ] ; for ( int j = NUM_ ; j < extraLength ; j ++ ) { this . extra [ j ] = new long [ length ] ; } } else { int oldLength ; if ( vectorIndex >= ( oldLength = this . extra [ NUM_ ] . length ) ) { for ( int j = NUM_ ; j < extraLength ; j ++ ) { System . arraycopy ( this . extra [ j ] , NUM_ , ( this . extra [ j ] = new long [ vectorIndex + NUM_ ] ) , NUM_ , oldLength ) ; } } } mask = NUM_ << ( position % BitCacheSize ) ; isTrue ( ( this . extra [ NUM_ ] [ vectorIndex ] & mask ) == NUM_ , STR_ ) ; this . extra [ NUM_ ] [ vectorIndex ] |= mask ; if ( COVERAGE_TEST_FLAG ) { if ( CoverageTestId == NUM_ ) { this . extra [ NUM_ ] [ vectorIndex ] = ~ NUM_ ; } } } } }
public int count ( ) { return dict . size ( ) ; }
public static boolean aboveOrEqual ( int a , int b ) { return Integer . compareUnsigned ( a , b ) >= NUM_ ; }
protected void awaitCompletionComputeValuesAndShutdown ( ) { { runExecutorAndAwaitCompletion ( ) ; } if ( logger . isDebugEnabled ( ) ) printStats ( ) ; executor . shutdown ( ) ; while ( ! executor . isTerminated ( ) ) { try { Thread . sleep ( NUM_ ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } }
public Flags flagList ( ) throws DecodingException { Flags flags = new Flags ( ) ; nextWordChar ( ) ; consumeChar ( STR_ ) ; CharacterValidator validator = new NoopCharValidator ( ) ; String nextWord = consumeWord ( validator ) ; while ( ! nextWord . endsWith ( STR_ ) ) { DecoderUtils . setFlag ( nextWord , flags ) ; nextWord = consumeWord ( validator ) ; } if ( nextWord . length ( ) > NUM_ ) { int parenIndex = nextWord . indexOf ( STR_ ) ; if ( parenIndex > NUM_ ) { final String nextFlag = nextWord . substring ( NUM_ , parenIndex ) ; DecoderUtils . setFlag ( nextFlag , flags ) ; } } return flags ; }
protected RestClientItf createNewRestClient ( URI endpoint , String username , String password , String version , Client client ) { XtremIOClient xioClient = null ; if ( version != null && ! version . isEmpty ( ) && Integer . valueOf ( version . split ( DOT_OPERATOR ) [ NUM_ ] ) >= XIO_MIN_4X_VERSION ) { xioClient = new XtremIOV2Client ( endpoint , username , password , client ) ; } else { xioClient = new XtremIOV1Client ( endpoint , username , password , client ) ; } return xioClient ; }
public String diff_text2 ( LinkedList < Diff > diffs ) { StringBuilder text = new StringBuilder ( ) ; for ( Diff aDiff : diffs ) { if ( aDiff . operation != Operation . DELETE ) { text . append ( aDiff . text ) ; } } return text . toString ( ) ; }
static private < E > List < E > toJavaList ( List < E > values , int rows , int columns ) { List < E > result = new ArrayList < > ( values . size ( ) ) ; for ( int i = NUM_ ; i < values . size ( ) ; i ++ ) { int row = i / columns ; int column = i % columns ; E value = values . get ( ( column . rows ) + row ) ; result . add ( value ) ; } return result ; }
public void lineArrow ( final int x0 , final int y0 , final int x1 , final int y1 , final int sidelength , final int padding , final long lineColor , final long arrowColor ) { final double dx = x1 - x0 ; final double dy = y1 - y0 ; final double angle = Math . atan2 ( dy , dx ) ; final double d = Math . sqrt ( ( dx . dx + dy . dy ) ) ; final double arrowtip = d - padding ; final double arrowlength = TL . sidelength ; final double arrowbase = arrowtip - arrowlength ; final double xn = Math . cos ( angle ) ; final double yn = Math . sin ( angle ) ; final int xt = x0 + ( ( int ) ( arrowtip . xn ) ) ; final int yt = y0 + ( ( int ) ( arrowtip . yn ) ) ; final double xb = x0 + arrowbase . xn ; final double yb = y0 + arrowbase . yn ; final double sl2 = sidelength / NUM_ ; final double xk = sl2 . Math . cos ( angle + PI2 ) ; final double yk = sl2 . Math . sin ( angle + PI2 ) ; final int x2 = ( int ) ( xb + xk ) ; final int y2 = ( int ) ( yb + yk ) ; final int x3 = ( int ) ( xb - xk ) ; final int y3 = ( int ) ( yb - yk ) ; setColor ( lineColor ) ; line ( x0 , y0 , ( int ) xb , ( int ) yb , NUM_ ) ; setColor ( arrowColor ) ; line ( x2 , y2 , x3 , y3 , NUM_ ) ; line ( x2 , y2 , xt , yt , NUM_ ) ; line ( x3 , y3 , xt , yt , NUM_ ) ; }
public String toHtml ( Node node , Appendable appendable ) { NodeVisitor renderer = createRenderer ( appendable ) ; node . visit ( renderer ) ; return appendable . toString ( ) ; }
public static String [ ] toCommaSeparatedArray ( String str ) throws IOException { return str . split ( STR_ ) ; }
@ Override public final Object put ( String key , Object value ) { return set ( key , value ) ; }
private void appendFloatType ( StringBuilder sb , FieldType fieldType , int fieldWidth ) { sb . append ( STR_ ) ; }
private HttpEntity paramsToEntity ( RequestParams params , ResponseHandlerInterface responseHandler ) { HttpEntity entity = null ; try { if ( params != null ) { entity = params . getEntity ( responseHandler ) ; } } catch ( Throwable t ) { if ( responseHandler != null ) responseHandler . sendFailureMessage ( NUM_ , null , null , t ) ; else t . printStackTrace ( ) ; } return entity ; }
public static boolean isInstallableEditing ( EnumSet < EmbeddingFlags > flagSet ) { return flagSet . isEmpty ( ) ; }
public void testMultiplyScalePosPos ( ) { String a = STR_ ; int aScale = NUM_ ; String b = STR_ ; int bScale = NUM_ ; String c = STR_ ; int cScale = NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal bNumber = new BigDecimal ( new BigInteger ( b ) , bScale ) ; BigDecimal result = aNumber . multiply ( bNumber ) ; assertEquals ( STR_ , c , result . toString ( ) ) ; assertEquals ( STR_ , cScale , result . scale ( ) ) ; }
public Iterator < Resource > resourceIterator ( ) { return resourceList . iterator ( ) ; }
public double nextUniform ( double lower , double upper ) { if ( upper <= lower ) { throw new MathIllegalArgumentException ( LocalizedCoreFormats . LOWER_BOUND_NOT_BELOW_UPPER_BOUND , lower , upper ) ; } if ( Double . isInfinite ( lower ) || Double . isInfinite ( upper ) ) { throw new MathIllegalArgumentException ( LocalizedCoreFormats . INFINITE_BOUND ) ; } if ( Double . isNaN ( lower ) || Double . isNaN ( upper ) ) { throw new MathIllegalArgumentException ( LocalizedCoreFormats . NAN_NOT_ALLOWED ) ; } final double u = randomGenerator . nextDouble ( ) ; return u . upper + ( NUM_ - u ) . lower ; }
public ShapeTileBox bounding_box ( ) { PlaPointInt lower_left = new PlaPointInt ( Math . floor ( v_x ) , Math . floor ( v_y ) ) ; PlaPointInt upper_right = new PlaPointInt ( Math . ceil ( v_x ) , Math . ceil ( v_y ) ) ; return new ShapeTileBox ( lower_left , upper_right ) ; }
public void addInterface ( String name ) { cachedInterfaces = null ; int info = constPool . addClassInfo ( name ) ; if ( interfaces == null ) { interfaces = new int [ NUM_ ] ; interfaces [ NUM_ ] = info ; } else { int n = interfaces . length ; int [ ] newarray = new int [ n + NUM_ ] ; System . arraycopy ( interfaces , NUM_ , newarray , NUM_ , n ) ; newarray [ n ] = info ; interfaces = newarray ; } }
@ SuppressWarnings ( STR_ ) public static MIssue create ( Properties ctx , String hexInput ) { HashMap hmIn = null ; try { byte [ ] byteArray = Secure . convertHexString ( hexInput ) ; ByteArrayInputStream bIn = new ByteArrayInputStream ( byteArray ) ; ObjectInputStream oIn = new ObjectInputStream ( bIn ) ; hmIn = ( HashMap ) oIn . readObject ( ) ; } catch ( Exception e ) { s_log . log ( Level . SEVERE , STR_ , e ) ; return null ; } MIssue issue = new MIssue ( ctx , ( HashMap < String , String > ) hmIn ) ; return issue ; }
void flushBuffer ( ) throws IOException { se . flushBuffer ( ) ; }
public static void showUnknownError ( Context context , Throwable t , DialogInterface . OnCancelListener listener ) { showError ( context , String . format ( context . getString ( R . string . afc_pmsg_unknown_error ) , t ) , listener ) ; }
private static boolean makeConcavePolygon ( final PlanetModel planetModel , final GeoCompositePolygon rval , final MutableBoolean seenConcave , final EdgeBuffer edgeBuffer , final List < GeoPolygon > holes , final GeoPoint testPoint ) { if ( edgeBuffer . size ( ) == NUM_ ) { return BOOL_ ; } if ( seenConcave . value ) { throw new IllegalArgumentException ( STR_ ) ; } seenConcave . value = BOOL_ ; if ( edgeBuffer . size ( ) < NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } final List < GeoPoint > points = new ArrayList < GeoPoint > ( edgeBuffer . size ( ) ) ; final BitSet internalEdges = new BitSet ( edgeBuffer . size ( ) - NUM_ ) ; Edge edge = edgeBuffer . pickOne ( ) ; boolean isInternal = BOOL_ ; for ( int i = NUM_ ; i < edgeBuffer . size ( ) ; i ++ ) { points . add ( edge . startPoint ) ; if ( i < edgeBuffer . size ( ) - NUM_ ) { internalEdges . set ( i , edge . isInternal ) ; } else { isInternal = edge . isInternal ; } edge = edgeBuffer . getNext ( edge ) ; } if ( testPoint != null && holes != null && holes . size ( ) > NUM_ ) { final GeoPolygon testPolygon = new GeoConcavePolygon ( planetModel , points , null , internalEdges , isInternal ) ; if ( testPolygon . isWithin ( testPoint ) ) { return BOOL_ ; } } final GeoPolygon realPolygon = new GeoConcavePolygon ( planetModel , points , holes , internalEdges , isInternal ) ; if ( testPoint != null && ( holes == null || holes . size ( ) == NUM_ ) ) { if ( realPolygon . isWithin ( testPoint ) ) { return BOOL_ ; } } rval . addShape ( realPolygon ) ; return BOOL_ ; }
public void addButton ( final JButton theButton ) { customButtonPanel . add ( theButton ) ; }
void swapCursor ( long monthMillis , @ Nullable EventCursor cursor , ContentObserver contentObserver ) { for ( int i = NUM_ ; i < mMonths . size ( ) ; i ++ ) { if ( CalendarUtils . sameMonth ( monthMillis , mMonths . get ( i ) ) ) { swapCursor ( i , cursor , contentObserver ) ; break ; } } }
final boolean close ( ) { return ! closed . getAndSet ( BOOL_ ) ; }
public byte [ ] encryptRaw ( byte [ ] baseKey , int usage , byte [ ] ivec , byte [ ] plaintext , int start , int len ) throws GeneralSecurityException , KrbCryptoException { if ( ! KeyUsage . isValid ( usage ) ) { throw new GeneralSecurityException ( STR_ + usage ) ; } byte [ ] output = encryptCTS ( baseKey , usage , ivec , null , plaintext , start , len , BOOL_ ) ; return output ; }
private void fixbug ( Document doc ) { Element element = doc . getDocumentElement ( ) ; if ( element != null ) { fixbug ( element ) ; } }
private String toHexString ( byte [ ] block ) { StringBuffer buf = new StringBuffer ( ) ; int len = block . length ; for ( int i = NUM_ ; i < len ; i ++ ) { byte2hex ( block [ i ] , buf ) ; if ( i < len - NUM_ ) { buf . append ( STR_ ) ; } } return buf . toString ( ) ; }
public static String removeDeployUri ( String uri ) { if ( ( uri == null ) || ( uri . length ( ) == NUM_ ) ) { return uri ; } int loc = uri . indexOf ( STR_ , NUM_ ) ; if ( loc == - NUM_ ) { return null ; } else { return uri . substring ( loc ) ; } }
public static double loss ( double pred , double y ) { return Math . abs ( y - pred ) ; }
public boolean needSignatureFileBytes ( ) { return sfBytes == null ; }
public void insert ( T object , int index ) { synchronized ( mLock ) { mObjects . add ( index , object ) ; } if ( mNotifyOnChange ) notifyItemInserted ( index ) ; }
private void loadTargetModules ( ) { for ( final Module module : target . getModules ( ) ) { module . addListener ( moduleKeeperListener ) ; modules . add ( module ) ; if ( ! module . isLoaded ( ) ) { try { module . load ( ) ; } catch ( final CouldntLoadDataException e ) { errorLoadingModule ( module , e ) ; return ; } } } step ++ ; }
public BloomFilter ( double falsePositiveProbability , int expectedNumberOfElements ) { this ( Math . ceil ( - ( Math . log ( falsePositiveProbability ) / Math . log ( NUM_ ) ) ) / Math . log ( NUM_ ) , expectedNumberOfElements , ( int ) Math . ceil ( - ( Math . log ( falsePositiveProbability ) / Math . log ( NUM_ ) ) ) ) ; }
public synchronized void notifyBand ( final int times , final int onTime , final int offTime , final int flashColour ) { final List < BLEAction > list = new ArrayList < > ( ) ; byte [ ] colors = convertRgb ( flashColour ) ; list . add ( new WaitAction ( NUM_ ) ) ; list . add ( new WriteAction ( Profile . UUID_CHAR_CONTROL_POINT , Protocol . VIBRATION_WITHOUT_LED ) ) ; list . add ( new WaitAction ( NUM_ ) ) ; list . add ( new WriteAction ( Profile . UUID_CHAR_CONTROL_POINT , colors ) ) ; queue ( list ) ; }
public void test_ConstructorLjava_security_cert_CertPathParameters ( ) { try { CertPathParameters parameters = new MyCertPathParameters ( ) ; CertPathTrustManagerParameters p = new CertPathTrustManagerParameters ( parameters ) ; assertNotSame ( STR_ , parameters , p . getParameters ( ) ) ; } catch ( Exception e ) { fail ( STR_ + e . toString ( ) ) ; } try { new CertPathTrustManagerParameters ( null ) ; fail ( STR_ ) ; } catch ( NullPointerException npe ) { } }
private static int buildRequestCode ( long threadId , int action ) { action ++ ; return ( int ) ( action . NUM_ + threadId ) ; }
public OuterJoinQualifier add ( String propertyLeft , String propertyRight ) { additionalProperties . add ( new PropertyValueExpressionPair ( new PropertyValueExpression ( propertyLeft ) , new PropertyValueExpression ( propertyRight ) ) ) ; return this ; }
public void insertElementAt ( int value , int at ) { if ( null == m_map ) { m_map = new int [ m_blocksize ] ; m_mapSize = m_blocksize ; } else if ( ( m_firstFree + NUM_ ) >= m_mapSize ) { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , NUM_ , newMap , NUM_ , m_firstFree + NUM_ ) ; m_map = newMap ; } if ( at <= ( m_firstFree - NUM_ ) ) { System . arraycopy ( m_map , at , m_map , at + NUM_ , m_firstFree - at ) ; } m_map [ at ] = value ; m_firstFree ++ ; }
protected static Dfp atanInternal ( final Dfp a ) { Dfp y = new Dfp ( a ) ; Dfp x = new Dfp ( y ) ; Dfp py = new Dfp ( y ) ; for ( int i = NUM_ ; i < NUM_ ; i += NUM_ ) { x = x . multiply ( a ) ; x = x . multiply ( a ) ; x = x . negate ( ) ; y = y . add ( x . divide ( i ) ) ; if ( y . equals ( py ) ) { break ; } py = new Dfp ( y ) ; } return y ; }
public static String parseSegmentName ( String filename ) { int idx = indexOfSegmentName ( filename ) ; if ( idx != - NUM_ ) { filename = filename . substring ( NUM_ , idx ) ; } return filename ; }
private static Tree generateSubTree ( HashMap < Integer , Pair < IndexedWord , List < Integer > > > dependencies , int root ) { List < Integer > children = dependencies . get ( root ) . second ; IndexedWord tw = dependencies . get ( root ) . first ; Tree tree = new LabeledScoredTreeNode ( tw ) ; boolean addedHead = children . isEmpty ( ) ; List < Integer > sortedChildren = CollectionUtils . sorted ( children ) ; for ( Integer c : sortedChildren ) { if ( c > root && ! addedHead ) { Tree child = new LabeledScoredTreeNode ( tw ) ; tree . addChild ( child ) ; addedHead = BOOL_ ; } Tree child = generateSubTree ( dependencies , c ) ; tree . addChild ( child ) ; } if ( ! addedHead ) { Tree child = new LabeledScoredTreeNode ( tw ) ; tree . addChild ( child ) ; } return tree ; }
@ HLEFunction ( nid = x267A6DD2 , version = NUM_ , checkInsideInterrupt = BOOL_ ) public int __sceSasRevParam ( int sasCore , int delay , int feedback ) { checkSasHandleGood ( sasCore ) ; waveformEffectDelay = delay ; waveformEffectFeedback = feedback ; return NUM_ ; }
static boolean isPossibleFP ( String val ) { final int length = val . length ( ) ; for ( int i = NUM_ ; i < length ; ++ i ) { char c = val . charAt ( i ) ; if ( ! ( c >= STR_ && c <= STR_ || c == STR_ || c == STR_ || c == STR_ || c == STR_ || c == STR_ ) ) { return BOOL_ ; } } return BOOL_ ; }
public boolean deleteTrack ( Track track ) { synchronized ( tracks ) { return tracks . removeElement ( track ) ; } }
protected static ArrayList < GeoPoint > parseKmlCoordinates ( String input ) { LinkedList < GeoPoint > tmpCoords = new LinkedList < GeoPoint > ( ) ; int i = NUM_ ; int tupleStart = NUM_ ; int length = input . length ( ) ; boolean startReadingTuple = BOOL_ ; while ( i < length ) { char c = input . charAt ( i ) ; if ( c == STR_ || c == STR_ || c == STR_ ) { if ( startReadingTuple ) { String tuple = input . substring ( tupleStart , i ) ; GeoPoint p = parseKmlCoord ( tuple ) ; if ( p != null ) tmpCoords . add ( p ) ; startReadingTuple = BOOL_ ; } } else { if ( ! startReadingTuple ) { startReadingTuple = BOOL_ ; tupleStart = i ; } if ( i == length - NUM_ ) { String tuple = input . substring ( tupleStart , i + NUM_ ) ; GeoPoint p = parseKmlCoord ( tuple ) ; if ( p != null ) tmpCoords . add ( p ) ; } } i ++ ; } ArrayList < GeoPoint > coordinates = new ArrayList < GeoPoint > ( tmpCoords . size ( ) ) ; coordinates . addAll ( tmpCoords ) ; return coordinates ; }
public void paint ( Graphics2D g ) { for ( int i = NUM_ ; i < m_nodes . size ( ) ; i ++ ) { WFNode node = m_nodes . get ( i ) ; Rectangle rect = node . getBounds ( ) ; g . setColor ( Color . BLACK ) ; g . drawRect ( rect . x , rect . y , rect . width , rect . height ) ; Graphics2D t = ( Graphics2D ) g . create ( rect . x , rect . y , rect . width , rect . height ) ; node . paint ( t ) ; t . dispose ( ) ; } createLines ( ) ; for ( int i = NUM_ ; i < m_lines . size ( ) ; i ++ ) { WFLine line = ( WFLine ) m_lines . get ( i ) ; line . paint ( g ) ; } }
ServerSessionContext registerRequest ( long sequence , Runnable runnable ) { commands . put ( sequence , runnable ) ; return this ; }
public void testConstructorSignBytesZeroNull2 ( ) { byte aBytes [ ] = { } ; int aSign = NUM_ ; byte rBytes [ ] = { NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , aNumber . signum ( ) ) ; }
public void addPreferencesButton ( ) { JButton prefsButton = new JButton ( STR_ ) ; prefsButton . setHideActionText ( BOOL_ ) ; prefsButton . setAction ( TimeSeriesPlotActions . getPropertiesDialogAction ( this ) ) ; buttonPanel . add ( prefsButton ) ; }
public static void findIndexMatches ( SearchPattern pattern , Index index , IndexQueryRequestor requestor , SearchParticipant participant , IJavaSearchScope scope , IProgressMonitor monitor ) throws IOException { pattern . findIndexMatches ( index , requestor , participant , scope , monitor ) ; }
public static void logInfo ( String message , Object ... args ) { message = MessageFormat . format ( message , args ) ; log ( IStatus . INFO , IStatus . OK , message , null ) ; }
public static boolean occupy ( int waitMs ) { if ( occupiedUntil != null && occupiedUntil . after ( new Date ( ) ) ) { return BOOL_ ; } occupiedUntil = DateUtils . addMilliseconds ( new Date ( ) , waitMs ) ; return BOOL_ ; }
public boolean [ ] [ ] moralize ( BayesNet bayesNet ) { int nNodes = bayesNet . getNrOfNodes ( ) ; boolean [ ] [ ] bAdjacencyMatrix = new boolean [ nNodes ] [ nNodes ] ; for ( int iNode = NUM_ ; iNode < nNodes ; iNode ++ ) { ParentSet parents = bayesNet . getParentSets ( ) [ iNode ] ; moralizeNode ( parents , iNode , bAdjacencyMatrix ) ; } return bAdjacencyMatrix ; }
public void addDivider ( ImageView v ) { RelativeLayout . LayoutParams dividerParams = new RelativeLayout . LayoutParams ( LayoutParams . FILL_PARENT , LayoutParams . WRAP_CONTENT ) ; if ( mImageView != null ) { dividerParams . addRule ( RelativeLayout . BELOW , mImageView . getId ( ) ) ; } else if ( mMissingImage != null ) { dividerParams . addRule ( RelativeLayout . BELOW , mMissingImage . getId ( ) ) ; } else if ( mVideoButton != null ) { dividerParams . addRule ( RelativeLayout . BELOW , mVideoButton . getId ( ) ) ; } else if ( mAudioButton != null ) { dividerParams . addRule ( RelativeLayout . BELOW , mAudioButton . getId ( ) ) ; } else if ( mView_Text != null ) { dividerParams . addRule ( RelativeLayout . BELOW , mView_Text . getId ( ) ) ; } else { Log . e ( t , STR_ ) ; return ; } addView ( v , dividerParams ) ; }
private double findLength ( Point originPoint , Point targetPoint ) { int x1 = originPoint . x ; int y1 = originPoint . y ; int x2 = targetPoint . x ; int y2 = targetPoint . y ; double sideA = x2 - x1 ; double sideB = ( y1 > y2 ? ( y1 - y2 ) : ( y2 - y1 ) ) ; if ( sideB == NUM_ ) { return sideA ; } return Math . sqrt ( Math . pow ( sideA , NUM_ ) + Math . pow ( sideB , NUM_ ) ) ; }
public void testCase4 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int bSign = - NUM_ ; byte rBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . subtract ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( NUM_ , result . signum ( ) ) ; }
public static Automaton determinizeSimple ( Automaton a , Set < Integer > initialset ) { if ( a . getNumStates ( ) == NUM_ ) { return a ; } int [ ] points = a . getStartPoints ( ) ; Map < Set < Integer > , Set < Integer > > sets = new HashMap < > ( ) ; LinkedList < Set < Integer > > worklist = new LinkedList < > ( ) ; Map < Set < Integer > , Integer > newstate = new HashMap < > ( ) ; sets . put ( initialset , initialset ) ; worklist . add ( initialset ) ; Automaton . Builder result = new Automaton . Builder ( ) ; result . createState ( ) ; newstate . put ( initialset , NUM_ ) ; Transition t = new Transition ( ) ; while ( worklist . size ( ) > NUM_ ) { Set < Integer > s = worklist . removeFirst ( ) ; int r = newstate . get ( s ) ; for ( int q : s ) { if ( a . isAccept ( q ) ) { result . setAccept ( r , BOOL_ ) ; break ; } } for ( int n = NUM_ ; n < points . length ; n ++ ) { Set < Integer > p = new HashSet < > ( ) ; for ( int q : s ) { int count = a . initTransition ( q , t ) ; for ( int i = NUM_ ; i < count ; i ++ ) { a . getNextTransition ( t ) ; if ( t . min <= points [ n ] && points [ n ] <= t . max ) { p . add ( t . dest ) ; } } } if ( ! sets . containsKey ( p ) ) { sets . put ( p , p ) ; worklist . add ( p ) ; newstate . put ( p , result . createState ( ) ) ; } int q = newstate . get ( p ) ; int min = points [ n ] ; int max ; if ( n + NUM_ < points . length ) { max = points [ n + NUM_ ] - NUM_ ; } else { max = Character . MAX_CODE_POINT ; } result . addTransition ( r , q , min , max ) ; } } return Operations . removeDeadStates ( result . finish ( ) ) ; }
public static void write ( InputStream in , OutputStream out , boolean closeBoth ) throws IOException { byte [ ] buff = new byte [ NUM_ ] ; int read = NUM_ ; while ( ( read = in . read ( buff ) ) > NUM_ ) { out . write ( buff , NUM_ , read ) ; } out . flush ( ) ; if ( closeBoth ) { safeCloseStreams ( in , out ) ; } }
public static double distance ( CoordinateDD p1 , CoordinateDD p2 , UNITS units ) { final double latP1 = p1 . northSouth ; final double latP2 = p2 . northSouth ; final double lonP1 = p1 . eastWest ; final double lonP2 = p2 . eastWest ; if ( latP1 == latP2 && lonP1 == lonP2 ) return NUM_ ; double distRad = Math . acos ( Math . sin ( toRadians ( latP1 ) ) . Math . sin ( toRadians ( latP2 ) ) + Math . cos ( toRadians ( latP1 ) ) . Math . cos ( toRadians ( latP2 ) ) . Math . cos ( toRadians ( lonP1 - lonP2 ) ) ) ; final double distAsDegree = toDegrees ( distRad ) ; return metersToUnits ( distAsDegree . NUM_ . NUM_ . NUM_ , units ) ; }
public static LiquidNetwork initNetwork ( ) { Random random = new Random ( System . currentTimeMillis ( ) ) ; int id = random . nextInt ( ) ; while ( usedIds . contains ( id ) ) { id = random . nextInt ( ) ; } ; LiquidNetwork net = new LiquidNetwork ( ) ; usedIds . add ( id ) ; net . networkID = id ; return net ; }
public String exportXml ( ) throws IOException { ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; exportXml ( outputStream ) ; return outputStream . toString ( ) ; }
public PatternReplaceFilter ( TokenStream in , Pattern p , String replacement , boolean all ) { super ( in ) ; this . replacement = ( null == replacement ) ? STR_ : replacement ; this . all = all ; this . m = p . matcher ( termAtt ) ; }
public boolean isMutable ( ) { return mutable ; }
public static int [ ] stableSort ( double [ ] array ) { int [ ] index = new int [ array . length ] ; int [ ] newIndex = new int [ array . length ] ; int [ ] helpIndex ; int numEqual ; array = ( double [ ] ) array . clone ( ) ; for ( int i = NUM_ ; i < index . length ; i ++ ) { index [ i ] = i ; if ( Double . isNaN ( array [ i ] ) ) { array [ i ] = Double . MAX_VALUE ; } } quickSort ( array , index , NUM_ , array . length - NUM_ ) ; int i = NUM_ ; while ( i < index . length ) { numEqual = NUM_ ; for ( int j = i + NUM_ ; ( ( j < index . length ) && Utils . eq ( array [ index [ i ] ] , array [ index [ j ] ] ) ) ; j ++ ) numEqual ++ ; if ( numEqual > NUM_ ) { helpIndex = new int [ numEqual ] ; for ( int j = NUM_ ; j < numEqual ; j ++ ) helpIndex [ j ] = i + j ; quickSort ( index , helpIndex , NUM_ , numEqual - NUM_ ) ; for ( int j = NUM_ ; j < numEqual ; j ++ ) newIndex [ i + j ] = index [ helpIndex [ j ] ] ; i += numEqual ; } else { newIndex [ i ] = index [ i ] ; i ++ ; } } return newIndex ; }
public void reopenReadWrite ( ) { synchronized ( mLock ) { throwIfNotOpenLocked ( ) ; if ( ! isReadOnlyLocked ( ) ) { return ; } final int oldOpenFlags = mConfigurationLocked . openFlags ; mConfigurationLocked . openFlags = ( mConfigurationLocked . openFlags & ~ OPEN_READ_MASK ) | OPEN_READWRITE ; try { mConnectionPoolLocked . reconfigure ( mConfigurationLocked ) ; } catch ( RuntimeException ex ) { mConfigurationLocked . openFlags = oldOpenFlags ; throw ex ; } } }
public static int readChars ( Reader r , char [ ] charArray ) throws IOException { int totalCharsRead = NUM_ ; int charsRead = r . read ( charArray ) ; while ( charsRead >= NUM_ ) { totalCharsRead += charsRead ; if ( totalCharsRead == charArray . length ) { break ; } charsRead = r . read ( charArray , totalCharsRead , charArray . length - totalCharsRead ) ; } return totalCharsRead ; }
public void removeDirection ( final Direction dir , final boolean face ) { RPAction action ; int size ; action = new RPAction ( ) ; action . put ( STR_ , STR_ ) ; action . put ( STR_ , - dir . get ( ) ) ; send ( action ) ; directions . remove ( dir ) ; size = directions . size ( ) ; if ( size == NUM_ ) { action = new RPAction ( ) ; action . put ( STR_ , STR_ ) ; } else { if ( face ) { action = new FaceRPAction ( directions . get ( size - NUM_ ) ) ; } else { action = new MoveRPAction ( directions . get ( size - NUM_ ) ) ; } } send ( action ) ; }
public static double [ ] ndary ( int n ) { double d [ ] = new double [ n ] ; for ( int i = NUM_ ; i < n ; i ++ ) { d [ i ] = R . nextGaussian ( ) ; } return d ; }
private double dot ( final int k0 , final int k1 , final int [ ] assignment0 , final int [ ] assignment1 ) { double dot = NUM_ ; final int N = X . size ( ) ; int a = NUM_ , b = NUM_ ; for ( int i = NUM_ ; i < N ; i ++ ) { if ( assignment0 [ i ] != k0 ) continue ; a ++ ; for ( int j = NUM_ ; j < N ; j ++ ) { if ( assignment1 [ j ] != k1 ) continue ; dot += kernel . eval ( i , j , X , accel ) ; } } for ( int j = NUM_ ; j < N ; j ++ ) if ( assignment1 [ j ] == k1 ) b ++ ; return dot / ( a . b ) ; }
public void removeAllTextures ( ) { for ( WeakReference < CCTexture2D > texSR : textures . values ( ) ) { CCTexture2D tex = texSR . get ( ) ; if ( tex != null ) tex . releaseTexture ( CCDirector . gl ) ; } textures . clear ( ) ; }
public synchronized void addToQueue ( final ImageResourceLoader imageResourceLoader , final String uri , final MutableFSImage mfsi , final int width , final int height ) { XRLog . general ( Level . FINE , STR_ + uri ) ; _loadQueue . addLast ( new ImageLoadItem ( imageResourceLoader , uri , mfsi , width , height ) ) ; notifyAll ( ) ; }
private JNIWriter ( Context context ) { context . put ( jniWriterKey , this ) ; fileManager = context . get ( JavaFileManager . class ) ; log = Log . instance ( context ) ; Options options = Options . instance ( context ) ; verbose = options . isSet ( VERBOSE ) ; checkAll = options . isSet ( STR_ ) ; this . context = context ; syms = Symtab . instance ( context ) ; lineSep = System . getProperty ( STR_ ) ; }
public JOSMTolerantFastXMLParser ( Sink sink , XMLStreamReader reader , boolean enableDateParsing ) { this . sink = sink ; this . enableDateParsing = enableDateParsing ; this . reader = reader ; if ( enableDateParsing ) { timestampFormat = new XmlTimestampFormat ( ) ; } else { Calendar calendar ; calendar = Calendar . getInstance ( ) ; calendar . set ( Calendar . MILLISECOND , NUM_ ) ; dummyTimestampContainer = new SimpleTimestampContainer ( calendar . getTime ( ) ) ; } memberTypeParser = new MemberTypeParser ( ) ; }
public Hashtable ( int initialCapacity , float loadFactor ) { if ( initialCapacity < NUM_ ) { throw new IllegalArgumentException ( STR_ + initialCapacity ) ; } if ( loadFactor <= NUM_ || Float . isNaN ( loadFactor ) ) { throw new IllegalArgumentException ( STR_ + loadFactor ) ; } if ( initialCapacity == NUM_ ) initialCapacity = NUM_ ; this . loadFactor = loadFactor ; table = new Entry [ initialCapacity ] ; threshold = ( int ) ( initialCapacity . loadFactor ) ; }
public static String extractReminder ( String publicURL , String accessURL ) { return publicURL . substring ( accessURL . length ( ) ) ; }
public void createUnderlying ( ) { if ( options != null ) { options . createUnderlying ( ) ; if ( Platform . isFxApplicationThread ( ) ) { line = new com . lynden . gmapsfx . shapes . Polyline ( options . convert ( ) ) ; } } }
private void initRasterProgram ( ) { IntBuffer props = BufferUtils . createIntBuffer ( NUM_ ) ; IntBuffer params = BufferUtils . createIntBuffer ( NUM_ ) ; int uniformsResourceIndex = glGetProgramResourceIndex ( rasterProgram , GL_UNIFORM_BLOCK , STR_ ) ; computeUboBinding = params . get ( NUM_ ) ; props . put ( NUM_ , GL_BUFFER_BINDING ) ; glGetProgramResourceiv ( rasterProgram , GL_UNIFORM_BLOCK , uniformsResourceIndex , props , null , params ) ; rasterUboBinding = params . get ( NUM_ ) ; }
private void installVoiceData ( ) { if ( TextUtils . isEmpty ( getEngineName ( ) ) ) return ; Intent intent = new Intent ( TextToSpeech . Engine . ACTION_INSTALL_TTS_DATA ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; intent . setPackage ( getEngineName ( ) ) ; try { Log . v ( TAG , STR_ + intent . toUri ( NUM_ ) ) ; startActivity ( intent ) ; } catch ( ActivityNotFoundException ex ) { Log . e ( TAG , STR_ + intent + STR_ ) ; } }
@ SuppressWarnings ( STR_ ) Symbol selectBest ( Env < AttrContext > env , Type site , List < Type > argtypes , List < Type > typeargtypes , Symbol sym , Symbol bestSoFar , boolean allowBoxing , boolean useVarargs , boolean operator ) { if ( sym . kind == ERR || ! sym . isInheritedIn ( site . tsym , types ) ) { return bestSoFar ; } else if ( useVarargs && ( sym . flags ( ) & VARARGS ) == NUM_ ) { return bestSoFar . kind >= ERRONEOUS ? new BadVarargsMethod ( ( ResolveError ) bestSoFar . baseSymbol ( ) ) : bestSoFar ; } Assert . check ( sym . kind < AMBIGUOUS ) ; try { Type mt = rawInstantiate ( env , site , sym , null , argtypes , typeargtypes , allowBoxing , useVarargs , types . noWarnings ) ; if ( ! operator || verboseResolutionMode . contains ( VerboseResolutionMode . PREDEF ) ) currentResolutionContext . addApplicableCandidate ( sym , mt ) ; } catch ( InapplicableMethodException ex ) { if ( ! operator ) currentResolutionContext . addInapplicableCandidate ( sym , ex . getDiagnostic ( ) ) ; switch ( bestSoFar . kind ) { case ABSENT_MTH : return new InapplicableSymbolError ( currentResolutionContext ) ; case WRONG_MTH : if ( operator ) return bestSoFar ; bestSoFar = new InapplicableSymbolsError ( currentResolutionContext ) ; default : return bestSoFar ; } } if ( ! isAccessible ( env , site , sym ) ) { return ( bestSoFar . kind == ABSENT_MTH ) ? new AccessError ( env , site , sym ) : bestSoFar ; } return ( bestSoFar . kind > AMBIGUOUS ) ? sym : mostSpecific ( argtypes , sym , bestSoFar , env , site , allowBoxing && operator , useVarargs ) ; }
public Bitmap loadBitmap ( String uri , int reqWidth , int reqHeight ) { Bitmap bitmap = loadBitmapFromMemCache ( uri ) ; if ( bitmap != null ) { Log . d ( TAG , STR_ + uri ) ; return bitmap ; } try { bitmap = loadBitmapFromDiskCache ( uri , reqWidth , reqHeight ) ; if ( bitmap != null ) { Log . d ( TAG , STR_ + uri ) ; return bitmap ; } bitmap = loadBitmapFromHttp ( uri , reqWidth , reqHeight ) ; Log . d ( TAG , STR_ + uri ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } if ( bitmap == null && ! mIsDiskLruCacheCreated ) { Log . w ( TAG , STR_ ) ; bitmap = downloadBitmapFromUrl ( uri ) ; } return bitmap ; }
public boolean isSafeToExecuteSUTCode ( ) { Thread current = Thread . currentThread ( ) ; if ( ! privilegedThreads . contains ( current ) ) { return BOOL_ ; } else { return privilegedThreadToIgnore == current ; } }
public void testCase17 ( ) { byte aBytes [ ] = { NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte rBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int bSign = NUM_ ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . add ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public String [ ] readDirectory ( String dir ) { if ( dir == null ) { throw new NullPointerException ( STR_ ) ; } StringArrayOut listOut = new StringArrayOut ( ) ; try { checkResult ( LibIMobileDevice . afc_read_directory ( getRef ( ) , dir , listOut ) ) ; StringArray list = listOut . getValue ( ) ; ArrayList < String > result = new ArrayList < String > ( ) ; if ( list != null ) { for ( int i = NUM_ ; ; i ++ ) { String s = list . get ( i ) ; if ( s == null ) { break ; } result . add ( s ) ; } } return result . toArray ( new String [ result . size ( ) ] ) ; } finally { LibIMobileDevice . delete_StringArray_values_z ( listOut . getValue ( ) ) ; listOut . delete ( ) ; } }
public static String createArgsString ( List < String > args ) { if ( args == null ) { return STR_ ; } StringBuilder argsSb = new StringBuilder ( ) ; for ( String arg : args ) { if ( ( arg . contains ( STR_ ) || arg . contains ( STR_ ) ) && ! StringUtilities . isQuoted ( arg ) ) { argsSb . append ( StringUtilities . quote ( arg ) ) ; } else { argsSb . append ( arg ) ; } argsSb . append ( STR_ ) ; } if ( argsSb . length ( ) > NUM_ ) { argsSb . setLength ( argsSb . length ( ) - NUM_ ) ; } return argsSb . toString ( ) ; }
public void addElement ( int value ) { int indexRelativeToCache = m_firstFree - m_buildCacheStartIndex ; if ( indexRelativeToCache >= NUM_ && indexRelativeToCache < m_blocksize ) { m_buildCache [ indexRelativeToCache ] = value ; ++ m_firstFree ; } else { int index = m_firstFree > > > m_SHIFT ; int offset = m_firstFree & m_MASK ; if ( index >= m_map . length ) { int newsize = index + m_numblocks ; int [ ] [ ] newMap = new int [ newsize ] [ ] ; System . arraycopy ( m_map , NUM_ , newMap , NUM_ , m_map . length ) ; m_map = newMap ; } int [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new int [ m_blocksize ] ; block [ offset ] = value ; m_buildCache = block ; m_buildCacheStartIndex = m_firstFree - offset ; ++ m_firstFree ; } }
public static < T > List < List < T > > overlap ( List < List < T > > lists , int before , int after ) { if ( before < NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } if ( after < NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } ListIterator < List < T > > iter = lists . listIterator ( ) ; List < List < T > > result = new ArrayList < List < T > > ( ) ; for ( ; iter . hasNext ( ) ; ) { List < T > current = new ArrayList < T > ( iter . next ( ) ) ; List < T > prev = before > NUM_ ? findPrevious ( iter ) : null ; List < T > next = after > NUM_ ? findNext ( iter ) : null ; if ( prev != null ) { List < T > overlap = prev . subList ( prev . size ( ) - before , prev . size ( ) ) ; current . addAll ( NUM_ , overlap ) ; } if ( next != null ) { List < T > overlap = next . subList ( NUM_ , after ) ; current . addAll ( overlap ) ; } result . add ( current ) ; } return result ; }
public double [ ] [ ] extractMainSetJacobian ( final ODEState state ) { final double [ ] p = state . getSecondaryState ( index ) ; final double [ ] [ ] dYdY0 = new double [ stateDim ] [ stateDim ] ; int j = NUM_ ; for ( int i = NUM_ ; i < stateDim ; i ++ ) { System . arraycopy ( p , j , dYdY0 [ i ] , NUM_ , stateDim ) ; j += stateDim ; } return dYdY0 ; }
public static void init ( final AsyncContext context ) { final SecurityContext security = ( SecurityContext ) context . getAttribute ( AsyncContext . SECURITY_CTX ) ; final boolean forceSetSecurity = forceSetSecurityContext ( context ) ; if ( forceSetSecurity ) { SecurityContextHolder . setContext ( security ) ; } ctx . set ( context ) ; }
private void handleGetCandidateResult ( PlacementTask currentState , Operation postOperation , Map < String , ServerAddress > candidates , Stopwatch placementWatch ) { ServiceUtils . logInfo ( this , STR_ , placementWatch . elapsed ( TimeUnit . MILLISECONDS ) ) ; if ( candidates . isEmpty ( ) ) { String msg = String . format ( STR_ , currentState . resource ) ; PlacementTask patchState = buildPatch ( TaskState . TaskStage . FAILED , currentState . taskState . isDirect , null ) ; patchState . resultCode = PlaceResultCode . NO_SUCH_RESOURCE ; patchState . error = msg ; failTask ( patchState , new Throwable ( msg ) , postOperation ) ; return ; } ServiceUtils . logInfo ( this , STR_ , candidates , currentState . timeoutMs ) ; Stopwatch scoreCandidatesStopwatch = Stopwatch . createStarted ( ) ; queryHostsForScores ( currentState . resource , candidates , null ) ; }
public boolean contains ( JsonElement element ) { return elements . contains ( element ) ; }
private void appendPath ( Path cp , final Path p ) { if ( p != null && p . size ( ) > NUM_ ) { cp . append ( p ) ; } }
public static void doDefaultLayout ( Composite parent , DialogField [ ] editors , boolean labelOnTop ) { doDefaultLayout ( parent , editors , labelOnTop , NUM_ , NUM_ ) ; }
protected static final List < CView > processQueryResults ( final ResultSet resultSet , final INaviProject project , final Map < Integer , Set < CTag > > tags , final ITagManager nodeTagManager , final SQLProvider provider , final List < CView > views , final ViewType viewType , final GraphType graphType ) throws SQLException { final Map < Integer , Set < CTag > > nodeTagMap = getNodeTags ( provider . getConnection ( ) , project , nodeTagManager ) ; try { while ( resultSet . next ( ) ) { final int viewId = resultSet . getInt ( STR_ ) ; final String name = PostgreSQLHelpers . readString ( resultSet , STR_ ) ; final String description = PostgreSQLHelpers . readString ( resultSet , STR_ ) ; final Timestamp creationDate = resultSet . getTimestamp ( STR_ ) ; final Timestamp modificationDate = resultSet . getTimestamp ( STR_ ) ; final boolean starState = resultSet . getBoolean ( STR_ ) ; final int nodeCount = resultSet . getInt ( STR_ ) ; final int edgeCount = resultSet . getInt ( STR_ ) ; final Set < CTag > viewTags = tags . containsKey ( viewId ) ? tags . get ( viewId ) : new HashSet < CTag > ( ) ; final Set < CTag > nodeTags = nodeTagMap . containsKey ( viewId ) ? nodeTagMap . get ( viewId ) : new HashSet < CTag > ( ) ; final CProjectViewGenerator generator = new CProjectViewGenerator ( provider , project ) ; views . add ( generator . generate ( viewId , name , description , viewType , graphType , creationDate , modificationDate , nodeCount , edgeCount , viewTags , nodeTags , starState ) ) ; } return views ; } finally { resultSet . close ( ) ; } }
private void drawString ( Object nativeFont , String str , int x , int y , int textDecoration , int fontHeight ) { if ( str . length ( ) == NUM_ ) { return ; } if ( textDecoration != NUM_ ) { boolean raised = ( textDecoration & Style . TEXT_DECORATION_3D ) != NUM_ ; boolean lowerd = ( textDecoration & Style . TEXT_DECORATION_3D_LOWERED ) != NUM_ ; boolean north = ( textDecoration & Style . TEXT_DECORATION_3D_SHADOW_NORTH ) != NUM_ ; if ( raised || lowerd || north ) { textDecoration = textDecoration & ( ~ Style . TEXT_DECORATION_3D ) & ( ~ Style . TEXT_DECORATION_3D_LOWERED ) & ( ~ Style . TEXT_DECORATION_3D_SHADOW_NORTH ) ; int c = getColor ( ) ; int a = getAlpha ( ) ; int newColor = NUM_ ; int offset = - NUM_ ; if ( lowerd ) { offset = NUM_ ; newColor = xffffff ; } else if ( north ) { offset = NUM_ ; } setColor ( newColor ) ; if ( a == xff ) { setAlpha ( NUM_ ) ; } drawString ( nativeFont , str , x , y + offset , textDecoration , fontHeight ) ; setAlpha ( a ) ; setColor ( c ) ; drawString ( nativeFont , str , x , y , textDecoration , fontHeight ) ; return ; } canvas . drawText ( str , x , y - font . getFontAscent ( ) , font ) ; if ( ( textDecoration & Style . TEXT_DECORATION_UNDERLINE ) != NUM_ ) { paint . setStyle ( Paint . Style . FILL ) ; canvas . drawLine ( x , y + fontHeight - NUM_ , x + impl . stringWidth ( nativeFont , str ) , y + fontHeight - NUM_ , paint ) ; } if ( ( textDecoration & Style . TEXT_DECORATION_STRIKETHRU ) != NUM_ ) { paint . setStyle ( Paint . Style . FILL ) ; canvas . drawLine ( x , y + fontHeight / NUM_ , x + impl . stringWidth ( nativeFont , str ) , y + fontHeight / NUM_ , paint ) ; } if ( ( textDecoration & Style . TEXT_DECORATION_OVERLINE ) != NUM_ ) { paint . setStyle ( Paint . Style . FILL ) ; canvas . drawLine ( x , y , x + impl . stringWidth ( nativeFont , str ) , y , paint ) ; } } else { canvas . drawText ( str , x , y - font . getFontAscent ( ) , font ) ; } }
protected void parse ( DataInputStream stream ) throws Exception { value = stream . readUTF ( ) ; }
public void removeDragEventHandlers ( ) { node . removeEventHandler ( TouchEvent . ANY , touchHandler ) ; node . removeEventHandler ( MouseEvent . ANY , mouseHandler ) ; }
protected void installListeners ( ) { super . installListeners ( ) ; table . addPropertyChangeListener ( this ) ; }
public void testCompareToZeroPos ( ) { byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int bSign = NUM_ ; BigInteger aNumber = BigInteger . ZERO ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; assertEquals ( - NUM_ , aNumber . compareTo ( bNumber ) ) ; }
public void shutdown ( ) throws ConnectionManagerException { s_logger . info ( STR_ ) ; connectionLock . lock ( ) ; try { closeAllConnections ( ) ; if ( _listener != null ) { _listener . stop ( ) ; _listener = null ; } executorService . shutdown ( ) ; } catch ( Exception e ) { throw new ConnectionManagerException ( STR_ , e ) ; } finally { connectionLock . unlock ( ) ; } }
private void closeWriterExecutionService ( ExecutorService service ) throws CarbonDataWriterException { try { service . shutdown ( ) ; service . awaitTermination ( NUM_ , TimeUnit . DAYS ) ; } catch ( InterruptedException e ) { LOGGER . error ( e , e . getMessage ( ) ) ; throw new CarbonDataWriterException ( e . getMessage ( ) ) ; } }
public void removeJob ( String jobId ) { if ( jobs . contains ( jobId ) ) { jobs . remove ( jobId ) ; } }
public String formatTimeMillis ( long ts ) { synchronized ( timeFormatter ) { return timeFormatter . format ( new Date ( ts ) ) ; } }
protected static final int positionCoordinate2D ( float value ) { return ( int ) ( value + NUM_ ) ; }
@ Override public Object clone ( ) { try { IdentityHashMap < K , V > cloneHashMap = ( IdentityHashMap < K , V > ) super . clone ( ) ; cloneHashMap . elementData = newElementArray ( elementData . length ) ; System . arraycopy ( elementData , NUM_ , cloneHashMap . elementData , NUM_ , elementData . length ) ; return cloneHashMap ; } catch ( CloneNotSupportedException e ) { throw new AssertionError ( e ) ; } }
public void search ( ) { performSearch ( ) ; }
public RemoteSession ( HttpSession session ) { super ( ) ; debug = Debug . getInstance ( STR_ ) ; this . session = ( HttpSession ) session ; creationTime = session . getCreationTime ( ) ; id = session . getId ( ) ; lastAccessedTime = session . getLastAccessedTime ( ) ; maxInactiveInterval = session . getMaxInactiveInterval ( ) ; isNew = session . isNew ( ) ; internalAttributes = new HashMap ( ) ; Enumeration aNames = getAttributeNames ( ) ; while ( aNames . hasMoreElements ( ) ) { String attributeName = ( String ) aNames . nextElement ( ) ; if ( isSerializable ( getAttribute ( attributeName ) ) && ! attributeName . equals ( STR_ ) && ! attributeName . equals ( STR_ ) ) { internalAttributes . put ( attributeName , getAttribute ( attributeName ) ) ; internalAttributeNames . add ( attributeName ) ; debug . message ( STR_ + attributeName + STR_ + getAttribute ( attributeName ) ) ; } } }
@ Override public SnmpMibHandler addMib ( SnmpMibAgent mib ) throws IllegalArgumentException { if ( mib == null ) { throw new IllegalArgumentException ( ) ; } if ( ! mibs . contains ( mib ) ) mibs . addElement ( mib ) ; root . register ( mib ) ; return this ; }
public boolean exist ( ) { return productionRun != null ; }
public static String numberToString ( Number number ) throws JSONException { if ( number == null ) { throw new JSONException ( STR_ ) ; } double doubleValue = number . doubleValue ( ) ; JSON . checkDouble ( doubleValue ) ; if ( number . equals ( NEGATIVE_ZERO ) ) { return STR_ ; } long longValue = number . longValue ( ) ; if ( doubleValue == ( double ) longValue ) { return Long . toString ( longValue ) ; } return number . toString ( ) ; }
public static SortClause create ( String item , String order ) { return new SortClause ( item , ORDER . valueOf ( order ) ) ; }
public long endTime ( ) { return getTimestamp ( ) + calculateDuration ( ) ; }
protected void buildLeavesMiddleOut ( BallNode node ) throws Exception { if ( node . m_Left != null && node . m_Right != null ) { buildLeavesMiddleOut ( node . m_Left ) ; buildLeavesMiddleOut ( node . m_Right ) ; } else if ( node . m_Left != null || node . m_Right != null ) { throw new Exception ( STR_ ) ; } else { BallNode n2 = buildTreeMiddleOut ( node . m_Start , node . m_End ) ; if ( n2 . m_Left != null && n2 . m_Right != null ) { node . m_Left = n2 . m_Left ; node . m_Right = n2 . m_Right ; buildLeavesMiddleOut ( node ) ; } else if ( n2 . m_Left != null || n2 . m_Right != null ) { throw new Exception ( STR_ ) ; } } }
@ Deprecated public static int [ ] decodeValue ( String a ) { return toIntArray ( a . split ( STR_ ) ) ; }
public WeightVector ( WeightVector wv ) { float in [ ] = wv . getInternalArray ( ) ; u = new float [ in . length ] ; System . arraycopy ( in , NUM_ , u , NUM_ , in . length ) ; size = in . length ; }
public void waitUntilDone ( ) { countLock . lock ( ) ; try { equalCountCv . await ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( STR_ ) ; } finally { countLock . unlock ( ) ; } }
public java . lang . StringBuilder insert ( int offset , long l ) { return insert ( offset , Long . toString ( l ) ) ; }
public ProjectionPreferencesDialog ( Projector projector ) { this . projector = projector ; String toleranceToolTip = STR_ + STR_ ; JLabel toleranceLabel = new JLabel ( STR_ ) ; tolerance . setToolTipText ( toleranceToolTip ) ; toleranceLabel . setToolTipText ( toleranceToolTip ) ; mainPanel . addItemLabel ( toleranceLabel , tolerance ) ; if ( projector . getProjectionMethod ( ) instanceof ProjectCoordinate ) { mainPanel . addItem ( STR_ , autoFind ) ; } fillFieldValues ( ) ; setContentPane ( mainPanel ) ; }
public void addTableValueChangeListener ( TableValueChangeListener listener ) { if ( listener == null ) { return ; } m_listeners . add ( listener ) ; }
@ Override public int print ( Graphics g , PageFormat pageFormat , int pageIndex ) { if ( pageIndex > NUM_ ) { return ( NO_SUCH_PAGE ) ; } else { Graphics2D g2d = ( Graphics2D ) g ; g2d . translate ( pageFormat . getImageableX ( ) , pageFormat . getImageableY ( ) ) ; double fHeight = pageFormat . getImageableHeight ( ) ; double fWidth = pageFormat . getImageableWidth ( ) ; int xMax = NUM_ ; int yMax = NUM_ ; for ( int iNode = NUM_ ; iNode < m_BayesNet . getNrOfNodes ( ) ; iNode ++ ) { if ( xMax < m_BayesNet . getPositionX ( iNode ) ) { xMax = m_BayesNet . getPositionX ( iNode ) ; } if ( yMax < m_BayesNet . getPositionY ( iNode ) ) { yMax = m_BayesNet . getPositionY ( iNode ) ; } } double fCurrentScale = m_fScale ; xMax += m_nPaddedNodeWidth + NUM_ ; if ( fWidth / xMax < fHeight / yMax ) { m_fScale = fWidth / xMax ; } else { m_fScale = fHeight / yMax ; } paint ( g2d ) ; m_fScale = fCurrentScale ; return ( PAGE_EXISTS ) ; } }
public LinkedHashMap < Pokemon , NicknamePokemonResponse . Result > bulkRenameWithPattern ( final String pattern , final BiConsumer < NicknamePokemonResponse . Result , Pokemon > perPokeCallback ) { final LinkedHashMap < Pokemon , NicknamePokemonResponse . Result > results = new LinkedHashMap < > ( ) ; mons . forEach ( null ) ; return results ; }
protected static byte [ ] [ ] parseDirectives ( byte [ ] buf , String [ ] keyTable , List < byte [ ] > realmChoices , int realmIndex ) throws SaslException { byte [ ] [ ] valueTable = new byte [ keyTable . length ] [ ] ; ByteArrayOutputStream key = new ByteArrayOutputStream ( NUM_ ) ; ByteArrayOutputStream value = new ByteArrayOutputStream ( NUM_ ) ; boolean gettingKey = BOOL_ ; boolean gettingQuotedValue = BOOL_ ; boolean expectSeparator = BOOL_ ; byte bch ; int i = skipLws ( buf , NUM_ ) ; while ( i < buf . length ) { bch = buf [ i ] ; if ( gettingKey ) { if ( bch == STR_ ) { if ( key . size ( ) != NUM_ ) { throw new SaslException ( STR_ + key ) ; } i = skipLws ( buf , i + NUM_ ) ; } else if ( bch == STR_ ) { if ( key . size ( ) == NUM_ ) { throw new SaslException ( STR_ ) ; } gettingKey = BOOL_ ; i = skipLws ( buf , i + NUM_ ) ; if ( i < buf . length ) { if ( buf [ i ] == STR_ ) { gettingQuotedValue = BOOL_ ; ++ i ; } } else { throw new SaslException ( STR_ + key . toString ( ) ) ; } } else if ( isLws ( bch ) ) { i = skipLws ( buf , i + NUM_ ) ; if ( i < buf . length ) { if ( buf [ i ] != STR_ ) { throw new SaslException ( STR_ + key . toString ( ) ) ; } } else { throw new SaslException ( STR_ + key . toString ( ) ) ; } } else { key . write ( bch ) ; ++ i ; } } else if ( gettingQuotedValue ) { if ( bch == STR_ ) { ++ i ; if ( i < buf . length ) { value . write ( buf [ i ] ) ; ++ i ; } else { throw new SaslException ( STR_ + key . toString ( ) + STR_ + value . toString ( ) ) ; } } else if ( bch == STR_ ) { ++ i ; gettingQuotedValue = BOOL_ ; expectSeparator = BOOL_ ; } else { value . write ( bch ) ; ++ i ; } } else if ( isLws ( bch ) || bch == STR_ ) { extractDirective ( key . toString ( ) , value . toByteArray ( ) , keyTable , valueTable , realmChoices , realmIndex ) ; key . reset ( ) ; value . reset ( ) ; gettingKey = BOOL_ ; gettingQuotedValue = expectSeparator = BOOL_ ; i = skipLws ( buf , i + NUM_ ) ; } else if ( expectSeparator ) { throw new SaslException ( STR_ + value . toString ( ) + STR_ ) ; } else { value . write ( bch ) ; ++ i ; } } if ( gettingQuotedValue ) { throw new SaslException ( STR_ + key . toString ( ) + STR_ + value . toString ( ) ) ; } if ( key . size ( ) > NUM_ ) { extractDirective ( key . toString ( ) , value . toByteArray ( ) , keyTable , valueTable , realmChoices , realmIndex ) ; } return valueTable ; }
public static Assignment createDefault ( String ... variables ) { return createDefault ( Arrays . asList ( variables ) ) ; }
private void onStopAttack ( ) { attacking = null ; }
public JSONTokener ( Reader reader ) { this . reader = reader . markSupported ( ) ? reader : new BufferedReader ( reader ) ; this . eof = BOOL_ ; this . usePrevious = BOOL_ ; this . previous = NUM_ ; this . index = NUM_ ; this . character = NUM_ ; this . line = NUM_ ; }
void calculatePressed ( ActionEvent e ) { if ( checkEditConditional ( ) ) { return ; } if ( numConditionals > NUM_ ) { String cName = STR_ ; Conditional c = null ; for ( int i = NUM_ ; i < numConditionals ; i ++ ) { cName = _curLogix . getConditionalByNumberOrder ( i ) ; if ( cName != null ) { c = _conditionalManager . getBySystemName ( cName ) ; if ( c == null ) { log . error ( STR_ + cName ) ; } else { c . calculate ( BOOL_ , null ) ; } } else { log . error ( STR_ ) ; } } conditionalTableModel . fireTableDataChanged ( ) ; } }
public static FunctionAlias newInstance ( Schema schema , int id , String name , String javaClassMethod , boolean force , boolean bufferResultSetToLocalTemp ) { FunctionAlias alias = new FunctionAlias ( schema , id , name ) ; int paren = javaClassMethod . indexOf ( STR_ ) ; int lastDot = javaClassMethod . lastIndexOf ( STR_ , paren < NUM_ ? javaClassMethod . length ( ) : paren ) ; if ( lastDot < NUM_ ) { throw DbException . get ( ErrorCode . SYNTAX_ERROR_1 , javaClassMethod ) ; } alias . className = javaClassMethod . substring ( NUM_ , lastDot ) ; alias . methodName = javaClassMethod . substring ( lastDot + NUM_ ) ; alias . bufferResultSetToLocalTemp = bufferResultSetToLocalTemp ; alias . init ( force ) ; return alias ; }
protected void updateMenu ( ) { boolean present ; boolean initializing ; boolean running ; boolean stopping ; boolean active ; if ( m_MenuBar == null ) return ; present = ( m_Experiment != null ) ; initializing = present && m_Experiment . isInitializing ( ) ; running = present && m_Experiment . isRunning ( ) ; stopping = present && m_Experiment . isStopping ( ) ; active = initializing || running || stopping ; m_MenuItemFileNew . setEnabled ( ! active ) ; m_MenuItemFileOpen . setEnabled ( ! active ) ; m_MenuItemFileSave . setEnabled ( present && ( getCurrentFile ( ) != null ) ) ; m_MenuItemFileSaveAs . setEnabled ( present ) ; m_MenuItemFileClose . setEnabled ( ! active ) ; m_MenuItemExecutionStart . setEnabled ( present && ! active ) ; m_MenuItemExecutionStop . setEnabled ( present && running ) ; for ( AbstractExperimenterMenuItem item : m_AdditionalMenuItems . keySet ( ) ) item . update ( this , m_AdditionalMenuItems . get ( item ) ) ; }
@ NotNull @ ObjectiveCName ( STR_ ) public ConfigurationBuilder addAutoJoinGroup ( String groupTokenOrShortName ) { autoJoinGroups . add ( groupTokenOrShortName ) ; return this ; }
public boolean hasValueInfo ( ) { return ! receiverValue . equals ( STR_ ) || methodArgumentValues != null ; }
public boolean nextIsSep ( ) { if ( Character . isLetterOrDigit ( str . charAt ( currentPosition ) ) ) return BOOL_ ; else return BOOL_ ; }
protected static final String addEscapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = NUM_ ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case NUM_ : continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < x20 || ch > x7e ) { String s = STR_ + Integer . toString ( ch , NUM_ ) ; retval . append ( STR_ + s . substring ( s . length ( ) - NUM_ , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; }
protected void dropCar ( PrintWriter file , Car car , boolean isManifest ) { if ( isManifest ) { StringBuffer buf = new StringBuffer ( padAndTruncateString ( Setup . getDropCarPrefix ( ) , Setup . getManifestPrefixLength ( ) ) ) ; String [ ] format = Setup . getDropManifestMessageFormat ( ) ; boolean isLocal = isLocalMove ( car ) ; if ( isLocal ) { buf = new StringBuffer ( padAndTruncateString ( Setup . getLocalPrefix ( ) , Setup . getManifestPrefixLength ( ) ) ) ; format = Setup . getLocalManifestMessageFormat ( ) ; } dropCar ( file , car , buf , format , isLocal , isManifest ) ; } else { StringBuffer buf = new StringBuffer ( padAndTruncateString ( Setup . getSwitchListDropCarPrefix ( ) , Setup . getSwitchListPrefixLength ( ) ) ) ; String [ ] format = Setup . getDropSwitchListMessageFormat ( ) ; boolean isLocal = isLocalMove ( car ) ; if ( isLocal ) { buf = new StringBuffer ( padAndTruncateString ( Setup . getSwitchListLocalPrefix ( ) , Setup . getSwitchListPrefixLength ( ) ) ) ; format = Setup . getLocalSwitchListMessageFormat ( ) ; } dropCar ( file , car , buf , format , isLocal , isManifest ) ; } }
@ AfterMethod public void deleteStorage ( ) throws BusinessException , IOException , SerializationException { if ( null != storageData ) { if ( storageManager . getRecordingState ( ) == RecordingState . ON ) { storageManager . stopRecording ( ) ; } if ( ! storageManager . isStorageClosed ( storageData ) ) { storageManager . closeStorage ( storageData ) ; } storageManager . deleteStorage ( storageData ) ; storageData = null ; } assertThat ( storageManager . getExistingStorages ( ) , is ( empty ( ) ) ) ; }
public final void removeElementAt ( int i ) { if ( i > m_firstFree ) System . arraycopy ( m_map , i + NUM_ , m_map , i , m_firstFree ) ; else m_map [ i ] = java . lang . Integer . MIN_VALUE ; m_firstFree -- ; }
protected int keyOnList ( String key , List < String > list ) { int ret = - NUM_ ; int index = NUM_ ; if ( list != null ) { for ( String listKey : list ) { if ( listKey . equalsIgnoreCase ( key ) ) { ret = index ; break ; } index ++ ; } } return ret ; }
private boolean incrementSentence ( ) throws IOException { if ( length == NUM_ ) return BOOL_ ; while ( BOOL_ ) { int start = iterator . current ( ) ; if ( start == BreakIterator . DONE ) return BOOL_ ; int end = iterator . next ( ) ; if ( end == BreakIterator . DONE ) return BOOL_ ; setNextSentence ( start , end ) ; if ( incrementWord ( ) ) { return BOOL_ ; } } }
Enumeration < CryptoPermissionEntry > permissionElements ( ) { return permissionEntries . elements ( ) ; }
private static char [ ] zzUnpackCMap ( String packed ) { char [ ] map = new char [ x10000 ] ; int i = NUM_ ; int j = NUM_ ; while ( i < NUM_ ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM_ ) ; } return map ; }
private static void populateAccessRequest ( AccessRequest accessRequest ) { accessRequest . setAccessLicenseNumber ( props . getProperty ( LICENSE_NUMBER ) ) ; accessRequest . setUserId ( props . getProperty ( USER_NAME ) ) ; accessRequest . setPassword ( props . getProperty ( PASSWORD ) ) ; }
public BinaryTable ( Header myHeader ) throws FitsException { long heapSizeL = myHeader . getLongValue ( PCOUNT ) ; long heapOffsetL = myHeader . getLongValue ( THEAP ) ; if ( heapOffsetL > MAX_INTEGER_VALUE ) { throw new FitsException ( STR_ ) ; } if ( heapSizeL > MAX_INTEGER_VALUE ) { throw new FitsException ( STR_ ) ; } if ( heapSizeL - heapOffsetL > MAX_INTEGER_VALUE ) { throw new FitsException ( STR_ ) ; } this . heapOffset = ( int ) heapOffsetL ; int heapSize = ( int ) heapSizeL ; int rwsz = myHeader . getIntValue ( NAXIS1 ) ; this . nRow = myHeader . getIntValue ( NAXIS2 ) ; if ( this . heapOffset > NUM_ ) { this . heapOffset -= this . nRow . rwsz ; } if ( this . heapOffset < NUM_ || this . heapOffset > heapSize ) { throw new FitsException ( STR_ ) ; } this . heap = new FitsHeap ( heapSize - this . heapOffset ) ; int nCol = myHeader . getIntValue ( TFIELDS ) ; this . rowLen = NUM_ ; for ( int col = NUM_ ; col < nCol ; col ++ ) { this . rowLen += processCol ( myHeader , col ) ; } HeaderCard card = myHeader . findCard ( NAXIS1 ) ; card . setValue ( String . valueOf ( this . rowLen ) ) ; myHeader . updateLine ( NAXIS1 , card ) ; }
public static TaskContext current ( ) { final Deque < TaskContext > stack = contextStacks . get ( ) ; if ( stack == null ) { return null ; } return stack . peekLast ( ) ; }
public static byte [ ] concat ( final byte [ ] ... arrays ) { int totalSize = NUM_ ; for ( final byte [ ] array : arrays ) { totalSize += array . length ; } int startIndex = NUM_ ; final byte [ ] result = new byte [ totalSize ] ; for ( final byte [ ] array : arrays ) { System . arraycopy ( array , NUM_ , result , startIndex , array . length ) ; startIndex += array . length ; } return result ; }
public JKNamespace ( final String url , final String prefix ) { logger . info ( String . format ( STR_ , url , prefix ) ) ; this . url = url ; this . prefix = prefix ; }
public boolean isLifo ( ) { String cm = getCostingMethod ( ) ; return cm != null && cm . equals ( COSTINGMETHOD_Lifo ) && COSTELEMENTTYPE_Material . equals ( getCostElementType ( ) ) ; }
public static void main ( String [ ] args ) throws Exception { final String cfg = STR_ ; final Class < ? extends BenchmarkDriver > benchmark = IgniteSqlQueryBenchmark . class ; final int threads = NUM_ ; final boolean clientDriverNode = BOOL_ ; final int extraNodes = NUM_ ; final int warmUp = NUM_ ; final int duration = NUM_ ; final int range = NUM_ ; final boolean throughputLatencyProbe = BOOL_ ; for ( int i = NUM_ ; i < extraNodes ; i ++ ) { IgniteConfiguration nodeCfg = Ignition . loadSpringBean ( cfg , STR_ ) ; nodeCfg . setGridName ( STR_ + i ) ; nodeCfg . setMetricsLogFrequency ( NUM_ ) ; Ignition . start ( nodeCfg ) ; } ArrayList < String > args0 = new ArrayList < > ( ) ; addArg ( args0 , STR_ , threads ) ; addArg ( args0 , STR_ , warmUp ) ; addArg ( args0 , STR_ , duration ) ; addArg ( args0 , STR_ , range ) ; addArg ( args0 , STR_ , benchmark . getSimpleName ( ) ) ; addArg ( args0 , STR_ , STR_ ) ; addArg ( args0 , STR_ , cfg ) ; if ( throughputLatencyProbe ) addArg ( args0 , STR_ , STR_ ) ; if ( clientDriverNode ) args0 . add ( STR_ ) ; BenchmarkDriverStartUp . main ( args0 . toArray ( new String [ args0 . size ( ) ] ) ) ; }
public static boolean safeNavigationOperatorDefined ( String nestedFieldName ) { if ( nestedFieldName . contains ( SAFE_NAVIGATION_OPERATOR ) ) if ( ! nestedFieldName . startsWith ( SAFE_NAVIGATION_OPERATOR ) ) throw new MappingException ( STR_ ) ; else return BOOL_ ; return BOOL_ ; }
public static boolean isEnabled ( ) { if ( sEnabled == null ) { sEnabled = detectEnabled ( ) ; } return sEnabled . booleanValue ( ) ; }
public boolean intersects ( GeoBounds other ) { boolean rv = BOOL_ ; for ( Rectangle2D r1 : rects ) { for ( Rectangle2D r2 : other . rects ) { rv = r1 . intersects ( r2 ) ; if ( rv ) { break ; } } if ( rv ) { break ; } } return rv ; }
public void dispose ( ) { mListeners . clear ( ) ; }
public void openImageGallery ( final ActionListener response ) { openGallery ( response , Display . GALLERY_IMAGE ) ; }
private void readObject ( final java . io . ObjectInputStream in ) throws IOException , ClassNotFoundException { inequalitySymbol = ( String ) in . readObject ( ) ; timeStamp = in . readLong ( ) ; }
String popBaseIndentifier ( ) { return ( String ) m_baseIdentifiers . pop ( ) ; }
@ Nullable public static File resolveDrawable ( @ NotNull RenderResources resources , @ Nullable ResourceValue drawable , @ NotNull Project project ) { if ( drawable != null ) { drawable = resources . resolveResValue ( drawable ) ; } if ( drawable == null ) { return null ; } String result = drawable . getValue ( ) ; StateList stateList = resolveStateList ( resources , drawable , project ) ; if ( stateList != null ) { List < StateListState > states = stateList . getStates ( ) ; if ( ! states . isEmpty ( ) ) { StateListState state = states . get ( states . size ( ) - NUM_ ) ; result = state . getValue ( ) ; } } if ( result == null ) { return null ; } final File file = new File ( result ) ; return file . isFile ( ) ? file : null ; }
public static void delete ( String code , JDA jda ) { Invite invite = resolve ( code ) ; if ( invite == null ) throw new IllegalArgumentException ( STR_ + STR_ + code ) ; delete ( invite , jda ) ; }
private void updateHeaderSeparator ( ) { final String bestDateTimePattern = DateFormatUtils . getBestDateTimePattern ( mCurrentLocale , ( mIs24HourView ) ? STR_ : STR_ ) ; final String separatorText ; final char [ ] hourFormats = { STR_ , STR_ , STR_ , STR_ } ; int hIndex = lastIndexOfAny ( bestDateTimePattern , hourFormats ) ; if ( hIndex == - NUM_ ) { separatorText = STR_ ; } else { separatorText = Character . toString ( bestDateTimePattern . charAt ( hIndex + NUM_ ) ) ; } mSeparatorView . setText ( separatorText ) ; }
protected void connectionFailed ( Channel failedChannel , IOException cause ) { failureCause = IOExceptionSupport . create ( cause ) ; channel = failedChannel ; connected . set ( BOOL_ ) ; connectLatch . countDown ( ) ; }
public void testMissingApplication ( ) throws Exception { mEnabled . add ( LauncherActivityDetector . ISSUE_MORE_THAN_ONE_LAUNCHER ) ; mEnabled . add ( LauncherActivityDetector . ISSUE_MISSING_LAUNCHER ) ; mEnabled . add ( LauncherActivityDetector . ISSUE_LAUNCHER_ACTIVITY_IN_LIBRARY ) ; String expected = STR_ ; String result = lintProject ( xml ( FN_ANDROID_MANIFEST_XML , STR_ + STR_ + STR_ + STR_ + STR_ ) ) ; assertEquals ( expected , result ) ; }
public String toString ( ) { ArrayList fields = new ArrayList ( NUM_ ) ; fields . add ( codebase ) ; fields . add ( policy ) ; fields . add ( classpath ) ; fields . add ( implClassName ) ; fields . add ( ( ( serverConfigArgs == null ) ? null : Arrays . asList ( serverConfigArgs ) ) ) ; fields . add ( lifeCycle ) ; fields . add ( servicePreparer ) ; return fields . toString ( ) ; }
public Drawable createFromPath ( String pathName ) { return Drawable . createFromPath ( pathName ) ; }
@ Override public void parse ( Reader reader , String baseURI ) throws IOException , RDFParseException , RDFHandlerException { if ( reader == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( baseURI == null ) { throw new IllegalArgumentException ( STR_ ) ; } InputSource inputSource = new InputSource ( reader ) ; inputSource . setSystemId ( baseURI ) ; parse ( inputSource ) ; }
final public void print ( double v ) { try { _out . print ( v ) ; } catch ( IOException e ) { log . log ( Level . FINE , e . toString ( ) , e ) ; } }
public static boolean isEmpty ( String string ) { return string == null || string . length ( ) == NUM_ ; }
public static boolean isXML11ValidName ( String name ) { int length = name . length ( ) ; if ( length == NUM_ ) return BOOL_ ; int i = NUM_ ; char ch = name . charAt ( NUM_ ) ; if ( ! isXML11NameStart ( ch ) ) { if ( length > NUM_ && isXML11NameHighSurrogate ( ch ) ) { char ch2 = name . charAt ( NUM_ ) ; if ( ! XMLChar . isLowSurrogate ( ch2 ) || ! isXML11NameStart ( XMLChar . supplemental ( ch , ch2 ) ) ) { return BOOL_ ; } i = NUM_ ; } else { return BOOL_ ; } } while ( i < length ) { ch = name . charAt ( i ) ; if ( ! isXML11Name ( ch ) ) { if ( ++ i < length && isXML11NameHighSurrogate ( ch ) ) { char ch2 = name . charAt ( i ) ; if ( ! XMLChar . isLowSurrogate ( ch2 ) || ! isXML11Name ( XMLChar . supplemental ( ch , ch2 ) ) ) { return BOOL_ ; } } else { return BOOL_ ; } } ++ i ; } return BOOL_ ; }
public void reset ( ) { mExpectedEvents . clear ( ) ; mExpectedInterrupt = BOOL_ ; mReplaying = BOOL_ ; }
String generateDigest ( File fileDir , String fileName ) { final String algorithm = STR_ ; InputStream fileStream = null ; DigestInputStream d = null ; try { fileStream = getFileStream ( fileDir , fileName ) ; MessageDigest md = MessageDigest . getInstance ( algorithm ) ; d = new DigestInputStream ( fileStream , md ) ; byte [ ] buffer = new byte [ NUM_ ] ; while ( d . read ( buffer ) != - NUM_ ) { } return toHexString ( md . digest ( ) ) ; } catch ( NoSuchAlgorithmException e ) { return algorithm + STR_ ; } catch ( IOException e ) { CLog . e ( e ) ; } finally { StreamUtil . closeStream ( d ) ; StreamUtil . closeStream ( fileStream ) ; } return STR_ ; }
public AgentConfig environmentToConfiguration ( Environment environment , long platformId ) { AgentConfig agentConfiguration = new AgentConfig ( ) ; agentConfiguration . setPlatformId ( platformId ) ; if ( CollectionUtils . isNotEmpty ( environment . getPlatformSensorConfigs ( ) ) ) { Collection < PlatformSensorTypeConfig > platformSensorTypeConfigs = new ArrayList < > ( ) ; for ( IPlatformSensorConfig platformSensorConfig : environment . getPlatformSensorConfigs ( ) ) { if ( platformSensorConfig . isActive ( ) ) { platformSensorTypeConfigs . add ( getPlatformSensorTypeConfig ( platformId , platformSensorConfig ) ) ; } } agentConfiguration . setPlatformSensorTypeConfigs ( platformSensorTypeConfigs ) ; } else { agentConfiguration . setPlatformSensorTypeConfigs ( Collections . < PlatformSensorTypeConfig > emptyList ( ) ) ; } if ( CollectionUtils . isNotEmpty ( environment . getMethodSensorConfigs ( ) ) ) { Collection < MethodSensorTypeConfig > methodSensorTypeConfigs = new ArrayList < > ( ) ; for ( IMethodSensorConfig methodSensorConfig : environment . getMethodSensorConfigs ( ) ) { methodSensorTypeConfigs . add ( getMethodSensorTypeConfig ( platformId , methodSensorConfig ) ) ; } agentConfiguration . setMethodSensorTypeConfigs ( methodSensorTypeConfigs ) ; } else { agentConfiguration . setMethodSensorTypeConfigs ( Collections . < MethodSensorTypeConfig > emptyList ( ) ) ; } IExceptionSensorConfig exceptionSensorConfig = environment . getExceptionSensorConfig ( ) ; if ( null != exceptionSensorConfig ) { agentConfiguration . setExceptionSensorTypeConfig ( getExceptionSensorTypeConfig ( platformId , exceptionSensorConfig ) ) ; } JmxSensorConfig jmxSensorConfig = environment . getJmxSensorConfig ( ) ; if ( null != jmxSensorConfig ) { agentConfiguration . setJmxSensorTypeConfig ( getJmxSensorTypeConfig ( platformId , jmxSensorConfig ) ) ; } IStrategyConfig bufferStrategyConfig = environment . getBufferStrategyConfig ( ) ; agentConfiguration . setBufferStrategyConfig ( new StrategyConfig ( bufferStrategyConfig . getClassName ( ) , bufferStrategyConfig . getSettings ( ) ) ) ; IStrategyConfig sendingStrategyConfig = environment . getSendingStrategyConfig ( ) ; agentConfiguration . setSendingStrategyConfig ( new StrategyConfig ( sendingStrategyConfig . getClassName ( ) , sendingStrategyConfig . getSettings ( ) ) ) ; Collection < ExcludeRule > excludeRules = configurationResolver . getAllExcludeRules ( environment ) ; if ( CollectionUtils . isNotEmpty ( excludeRules ) ) { Collection < IMatchPattern > excludeClassesPatterns = new ArrayList < > ( ) ; for ( ExcludeRule excludeRule : excludeRules ) { excludeClassesPatterns . add ( PatternFactory . getPattern ( excludeRule . getClassName ( ) ) ) ; } agentConfiguration . setExcludeClassesPatterns ( excludeClassesPatterns ) ; } else { agentConfiguration . setExcludeClassesPatterns ( Collections . < IMatchPattern > emptyList ( ) ) ; } agentConfiguration . setConfigurationInfo ( configurationResolver . getConfigurationInfo ( environment ) ) ; return agentConfiguration ; }
private void initializeNameGoals ( Map < TestCase , Set < TestFitnessFunction > > testToGoals ) { for ( Map . Entry < TestCase , Set < TestFitnessFunction > > entry : testToGoals . entrySet ( ) ) { Set < TestFitnessFunction > goals = new LinkedHashSet < > ( ) ; List < TestFitnessFunction > topGoals = getTopGoals ( entry . getValue ( ) ) ; if ( topGoals . isEmpty ( ) ) { } else if ( topGoals . size ( ) <= MAX_SIMILAR_GOALS ) { for ( TestFitnessFunction goal : topGoals ) { goals . add ( goal ) ; String goalName = getTestName ( entry . getKey ( ) , goals ) ; if ( goalName . length ( ) > MAX_CHARS ) { goals . remove ( goal ) ; break ; } } } else { goals . add ( chooseRepresentativeGoal ( entry . getKey ( ) , topGoals ) ) ; } testToGoals . put ( entry . getKey ( ) , goals ) ; } }
public static java . lang . Double valueOf ( java . lang . String s ) throws java . lang . NumberFormatException { return new Double ( parseDouble ( s ) ) ; }
private void writeObject ( java . io . ObjectOutputStream s ) throws java . io . IOException { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { s . defaultWriteObject ( ) ; for ( Node < E > p = first ; p != null ; p = p . next ) s . writeObject ( p . item ) ; s . writeObject ( null ) ; } finally { lock . unlock ( ) ; } }
public boolean isParseRobotsTxt ( ) { return parseRobotsTxt ; }
public String byteArrayToBase64 ( byte [ ] bytes ) { return Base64 . encodeBase64String ( bytes ) ; }
private void validateIndexStorage ( ) { CloseableIterator < IndexStoreEntry > iterator = null ; try { ArrayList structureList = new ArrayList ( ) ; iterator = indexDataStructure . iterator ( null ) ; while ( iterator . hasNext ( ) ) { IndexStoreEntry ie = iterator . next ( ) ; if ( entriesContains ( ie ) ) { structureList . add ( ie ) ; } else { fail ( STR_ + ie ) ; } } assertEquals ( STR_ , entries . size ( ) , structureList . size ( ) ) ; } finally { if ( iterator != null ) { iterator . close ( ) ; } } }
protected void onException ( final WroRuntimeException e ) { throw e ; }
private int quantize ( long x ) { return NUM_ + ( int ) Math . floor ( Math . log ( x ) / Math . log ( quantizationBase ) ) ; }
public static boolean validateOutputDirectory ( File directory ) { if ( directory . exists ( ) ) { Diagnostic . error ( ErrorType . DIRECTORY_EXISTS , directory . getPath ( ) ) ; return BOOL_ ; } return BOOL_ ; }
@ Override public void onWebSocketClose ( int statusCode , String reason ) { super . onWebSocketClose ( statusCode , reason ) ; log . info ( STR_ , peerID , Integer . toString ( statusCode ) + STR_ + reason ) ; store . unsubscribe ( handle ) ; }
public void drawPoint ( Graphics sc , IPoint p ) { double x1 = p . getX ( ) ; double y1 = p . getY ( ) ; sc . drawOval ( ( int ) x1 - NUM_ , ( int ) y1 - NUM_ , NUM_ , NUM_ ) ; }
private static int computeCapacity ( final int expectedSize ) { if ( expectedSize == NUM_ ) { return NUM_ ; } final int capacity = ( int ) FastMath . ceil ( expectedSize / LOAD_FACTOR ) ; final int powerOfTwo = Integer . highestOneBit ( capacity ) ; if ( powerOfTwo == capacity ) { return capacity ; } return nextPowerOfTwo ( capacity ) ; }
public static void appendString ( final StringBuffer buf , final String s ) { buf . append ( STR_ ) ; for ( int i = NUM_ ; i < s . length ( ) ; ++ i ) { char c = s . charAt ( i ) ; if ( c == STR_ ) { buf . append ( STR_ ) ; } else if ( c == STR_ ) { buf . append ( STR_ ) ; } else if ( c == STR_ ) { buf . append ( STR_ ) ; } else if ( c == STR_ ) { buf . append ( STR_ ) ; } else if ( c < x20 || c > x7f ) { buf . append ( STR_ ) ; if ( c < x10 ) { buf . append ( STR_ ) ; } else if ( c < x100 ) { buf . append ( STR_ ) ; } else if ( c < x1000 ) { buf . append ( STR_ ) ; } buf . append ( Integer . toString ( c , NUM_ ) ) ; } else { buf . append ( c ) ; } } buf . append ( STR_ ) ; }
protected void a_processJunction_nns ( String name , Continuation cont ) throws NamingException { if ( name . equals ( STR_ ) ) { NameNotFoundException e = new NameNotFoundException ( ) ; cont . setErrorNNS ( this , name ) ; throw cont . fillInException ( e ) ; } try { Object target = a_lookup ( name , cont ) ; if ( cont . isContinue ( ) ) cont . appendRemainingComponent ( STR_ ) ; else { cont . setContinueNNS ( target , name , this ) ; } } catch ( NamingException e ) { e . appendRemainingComponent ( STR_ ) ; throw e ; } }
public void addCallback ( Callback callback ) { if ( ! mCallbacks . contains ( callback ) ) { mCallbacks . add ( callback ) ; } }
public JTidyDocumentBuilderFactory ( DocumentBuilderSetting [ ] settings ) throws DOMTestIncompatibleException { super ( settings ) ; try { ClassLoader classLoader = ClassLoader . getSystemClassLoader ( ) ; Class tidyClass = classLoader . loadClass ( STR_ ) ; tidyConstructor = tidyClass . getConstructor ( NO_CLASSES ) ; parseDOMMethod = tidyClass . getMethod ( STR_ , new Class [ ] { java . io . InputStream . class , java . io . OutputStream . class } ) ; domImpl = new JTidyDOMImplementation ( ) ; } catch ( Exception ex ) { throw new DOMTestIncompatibleException ( ex , null ) ; } if ( settings != null ) { for ( int i = NUM_ ; i < settings . length ; i ++ ) { } } }
public void dispose ( ) { logDebug ( STR_ ) ; mSetupDone = BOOL_ ; if ( mServiceConn != null ) { logDebug ( STR_ ) ; if ( mContext != null ) mContext . unbindService ( mServiceConn ) ; } mDisposed = BOOL_ ; mContext = null ; mServiceConn = null ; mService = null ; mPurchaseListener = null ; }
public void enqueue ( TerminatingRunnable r ) { synchronized ( queue ) { queue . add ( r ) ; queue . notifyAll ( ) ; } }
protected void doProcessMessage ( DTLSMessage message ) throws HandshakeException , GeneralSecurityException { }
public void addCertificatesAndCRLs ( CertStore certStore ) throws CertStoreException , CMSException { certs . addAll ( CMSUtils . getCertificatesFromStore ( certStore ) ) ; crls . addAll ( CMSUtils . getCRLsFromStore ( certStore ) ) ; }
void disconnect ( ) { synchronized ( lock ) { disconnected = BOOL_ ; lock . notifyAll ( ) ; } }
public SimpleRateLimiter ( double mbPerSec ) { setMBPerSec ( mbPerSec ) ; lastNS = System . nanoTime ( ) ; }
private long wc ( String text ) { long wc = NUM_ ; String [ ] lines = text . split ( STR_ ) ; for ( String line : lines ) { wc += line . split ( STR_ ) . length ; } return wc ; }
public boolean unbind ( ) { boolean worked = BOOL_ ; if ( m_rxThread == null ) worked = BOOL_ ; else m_stopRx = BOOL_ ; return worked ; }
public void register ( Schedule schedule ) { Integer oldSize = Integer . valueOf ( _scheduleHashTable . size ( ) ) ; _scheduleHashTable . put ( schedule . getId ( ) , schedule ) ; int id = Integer . parseInt ( schedule . getId ( ) ) ; if ( id > _id ) { _id = id ; } setDirtyAndFirePropertyChange ( LISTLENGTH_CHANGED_PROPERTY , oldSize , Integer . valueOf ( _scheduleHashTable . size ( ) ) ) ; }
public final void writeMapleAsciiString ( final String s ) { writeShort ( ( short ) s . length ( ) ) ; writeAsciiString ( s ) ; }
public static boolean hasUID ( String classname ) { boolean result ; try { result = hasUID ( Class . forName ( classname ) ) ; } catch ( Exception e ) { result = BOOL_ ; } return result ; }
public static boolean removeDirectory ( String pathToDir ) { return deleteRecursive ( new File ( pathToDir ) ) ; }
public static final boolean validateGroupName ( String sGroupName ) { if ( sGroupName . length ( ) == NUM_ ) { return BOOL_ ; } return sGroupName . matches ( STR_ ) ; }
private void _init ( Configuration conf ) { try { if ( this . id > NUM_ ) { DefaultListener d = new DefaultListener ( ) ; d . upgrade ( conf , this ) ; } if ( ! X . isEmpty ( listener ) ) { String name = listener ; if ( name != null ) { try { Class < ? > c = Class . forName ( name , BOOL_ , classLoader ) ; Object o = c . newInstance ( ) ; if ( o instanceof IListener ) { log . info ( STR_ + name ) ; IListener l = ( IListener ) o ; l . upgrade ( conf , this ) ; l . onStart ( conf , this ) ; } } catch ( Throwable e ) { log . error ( this . name + STR_ + name , e ) ; } } } } catch ( Throwable e ) { log . error ( e . getMessage ( ) , e ) ; } }
private boolean isScanRootAvailable ( URL url ) { for ( ScanRoot scanRoot : _pendingScanRoots ) { if ( url . equals ( scanRoot . getUrl ( ) ) ) return BOOL_ ; } return BOOL_ ; }
public SequentialListenerManager addListenerExecutor ( int index , Listener listener , ListenerExecutor executor ) { if ( listeners . contains ( listener ) ) throw new IllegalArgumentException ( STR_ + listener ) ; listeners . add ( index , listener ) ; listenerExecutors . add ( index , executor ) ; return this ; }
private boolean hasAsParent ( INode child , ICompositeNode directParent ) { INode parent = child ; while ( parent != null ) { if ( parent == directParent ) return BOOL_ ; parent = parent . getParent ( ) ; } return BOOL_ ; }
public void clearMarkers ( ) { mGoogleMap . clear ( ) ; markers . clear ( ) ; }
@ Override public double cloudletSubmit ( Cloudlet cl ) { return cloudletSubmit ( cl , NUM_ ) ; }
public void verifyingToken ( ) { setTokenInfo ( STR_ ) ; verifyToken . setEnabled ( BOOL_ ) ; }
public Certificate buildCertificate ( String certString ) throws InvalidCertificate { try { String base64Cert = formatCertificate ( certString ) ; InputStream inBytes = new ByteArrayInputStream ( base64Cert . getBytes ( ) ) ; CertificateFactory cf = CertificateFactory . getInstance ( STR_ ) ; assert inBytes . available ( ) > NUM_ ; Certificate certificate = cf . generateCertificate ( inBytes ) ; inBytes . close ( ) ; return certificate ; } catch ( Exception e ) { log . debug ( STR_ + e + STR_ ) ; throw FaultUtil . InvalidCertificate ( STR_ ) ; } }
private PageLeafImpl compact ( TableKelp table ) { long now = CurrentTime . currentTime ( ) / NUM_ ; Set < PageLeafEntry > entries = fillEntries ( table ) ; ArrayList < BlockLeaf > blocks = new ArrayList < > ( ) ; BlockLeaf block = new BlockLeaf ( getId ( ) ) ; blocks . add ( block ) ; Row row = table . row ( ) ; for ( PageLeafEntry entry : entries ) { if ( entry . getCode ( ) != INSERT && entry . getExpires ( ) <= now ) { continue ; } while ( ! block . addEntry ( row , entry ) ) { block = new BlockLeaf ( getId ( ) ) ; blocks . add ( block ) ; } } PageLeafImpl newPage = new PageLeafImpl ( getId ( ) , getNextId ( ) , getSequence ( ) , _table , getMinKey ( ) , getMaxKey ( ) , blocks ) ; newPage . validate ( table ) ; newPage . toSorted ( table ) ; if ( isDirty ( ) ) { newPage . setDirty ( ) ; } if ( _stub != null ) { _stub . copyToCompact ( newPage ) ; } return newPage ; }
public SabresQuery ( Class < T > clazz ) { this . clazz = clazz ; name = clazz . getSimpleName ( ) ; innerQueries = null ; }
SNode awaitFulfill ( SNode s , boolean timed , long nanos ) { final long deadline = timed ? System . nanoTime ( ) + nanos : NUM_ ; Thread w = Thread . currentThread ( ) ; int spins = ( shouldSpin ( s ) ? ( timed ? maxTimedSpins : maxUntimedSpins ) : NUM_ ) ; for ( ; ; ) { if ( w . isInterrupted ( ) ) s . tryCancel ( ) ; SNode m = s . match ; if ( m != null ) return m ; if ( timed ) { nanos = deadline - System . nanoTime ( ) ; if ( nanos <= NUM_ ) { s . tryCancel ( ) ; continue ; } } if ( spins > NUM_ ) spins = shouldSpin ( s ) ? ( spins - NUM_ ) : NUM_ ; else if ( s . waiter == null ) s . waiter = w ; else if ( ! timed ) LockSupport . park ( this ) ; else if ( nanos > spinForTimeoutThreshold ) LockSupport . parkNanos ( this , nanos ) ; } }
public String backupNow ( String backupFilePrefix ) throws McException , IOException { _logger . debug ( STR_ ) ; return Backup . backup ( backupFilePrefix ) ; }
void fullyUnlock ( ) { takeLock . unlock ( ) ; putLock . unlock ( ) ; }
public boolean isClusteredHost ( StorageSystem storage , List < Initiator > initiators ) { return isClusteredHost ( storage , initiators , null ) ; }
public static List < SubstringReplacerMatchRule > matchRulesFromInternal ( String matchReplaceDetails , Instances inputStructure , String statusMessagePrefix , Logger log , Environment env ) { List < SubstringReplacerMatchRule > matchRules = new ArrayList < SubstringReplacerMatchRule > ( ) ; String [ ] mrParts = matchReplaceDetails . split ( STR_ ) ; for ( String p : mrParts ) { SubstringReplacerMatchRule mr = new SubstringReplacerMatchRule ( p . trim ( ) ) ; mr . m_statusMessagePrefix = statusMessagePrefix ; mr . m_logger = log ; mr . init ( env , inputStructure ) ; matchRules . add ( mr ) ; } return matchRules ; }
private static void time ( DateTimeFormatterBuilder bld , Collection < DateTimeFieldType > fields , boolean extended , boolean strictISO , boolean reducedPrec , boolean datePresent ) { boolean hour = fields . remove ( DateTimeFieldType . hourOfDay ( ) ) ; boolean minute = fields . remove ( DateTimeFieldType . minuteOfHour ( ) ) ; boolean second = fields . remove ( DateTimeFieldType . secondOfMinute ( ) ) ; boolean milli = fields . remove ( DateTimeFieldType . millisOfSecond ( ) ) ; if ( ! hour && ! minute && ! second && ! milli ) { return ; } if ( hour || minute || second || milli ) { if ( strictISO && reducedPrec ) { throw new IllegalArgumentException ( STR_ + fields ) ; } if ( datePresent ) { bld . appendLiteral ( STR_ ) ; } } if ( hour && minute && second || ( hour && ! second && ! milli ) ) { } else { if ( strictISO && datePresent ) { throw new IllegalArgumentException ( STR_ + fields ) ; } if ( ! hour && ( minute && second || ( minute && ! milli ) || second ) ) { } else { if ( strictISO ) { throw new IllegalArgumentException ( STR_ + fields ) ; } } } if ( hour ) { bld . appendHourOfDay ( NUM_ ) ; } else if ( minute || second || milli ) { bld . appendLiteral ( STR_ ) ; } if ( extended && hour && minute ) { bld . appendLiteral ( STR_ ) ; } if ( minute ) { bld . appendMinuteOfHour ( NUM_ ) ; } else if ( second || milli ) { bld . appendLiteral ( STR_ ) ; } if ( extended && minute && second ) { bld . appendLiteral ( STR_ ) ; } if ( second ) { bld . appendSecondOfMinute ( NUM_ ) ; } else if ( milli ) { bld . appendLiteral ( STR_ ) ; } if ( milli ) { bld . appendLiteral ( STR_ ) ; bld . appendMillisOfSecond ( NUM_ ) ; } }
public static Object [ ] mergeAndExtractParams ( Map < String , ? extends Object > globalConfig , Map < String , ? extends Object > localParams , Collection < String > ignoreParams , Map < String , ExternalResourceDescription > resources ) { Set < String > uniqueParams = new HashSet < > ( ) ; uniqueParams . addAll ( localParams . keySet ( ) ) ; uniqueParams . addAll ( globalConfig . keySet ( ) ) ; if ( ignoreParams != null ) { uniqueParams . removeAll ( ignoreParams ) ; } Object [ ] params = new Object [ resources . size ( ) . NUM_ + uniqueParams . size ( ) . NUM_ ] ; int i = NUM_ ; for ( Entry < String , ExternalResourceDescription > entry : resources . entrySet ( ) ) { params [ i ++ ] = entry . getKey ( ) ; params [ i ++ ] = entry . getValue ( ) ; } for ( String key : uniqueParams ) { params [ i ++ ] = key ; if ( localParams . containsKey ( key ) ) { params [ i ++ ] = CpeBuilderUtils . convertToParameterValue ( localParams . get ( key ) ) ; } else { params [ i ++ ] = CpeBuilderUtils . convertToParameterValue ( globalConfig . get ( key ) ) ; } } return params ; }
public void storeProperties ( String artifact , String version , Properties props ) throws IOException { Path propertiesFile = getPropertiesFile ( artifact , version ) ; Path dir = propertiesFile . getParent ( ) ; if ( ! Files . exists ( dir ) ) { Files . createDirectories ( dir ) ; } try ( OutputStream out = new BufferedOutputStream ( newOutputStream ( propertiesFile ) ) ) { props . store ( out , null ) ; } }
public static String makeDescriptor ( Class [ ] params , Class retType ) { StringBuffer sbuf = new StringBuffer ( ) ; sbuf . append ( STR_ ) ; for ( int i = NUM_ ; i < params . length ; i ++ ) makeDesc ( sbuf , params [ i ] ) ; sbuf . append ( STR_ ) ; if ( retType != null ) makeDesc ( sbuf , retType ) ; return sbuf . toString ( ) ; }
public boolean isLoggable ( Level lev ) { return logger . isLoggable ( lev ) ; }
int parseHour ( String source , char patternChar , int offset ) throws ParseException { int min = ( patternChar == HOUR_1_LETTER || patternChar == HOUR12_1_LETTER ) ? NUM_ : NUM_ ; int max = ( ( patternChar == HOUR_LETTER || patternChar == HOUR_1_LETTER ) ? NUM_ : NUM_ ) + min ; return parseNumber ( source , offset , STR_ , min , max ) - min ; }
@ Override public boolean supportsKnowledge ( ) { return BOOL_ ; }
public void or ( Criteria criteria ) { oredCriteria . add ( criteria ) ; }
@ DataProvider public Object [ ] [ ] invalidIdProvider ( ) { return new Object [ ] [ ] { new Object [ ] { STR_ , STR_ , HttpStatus . SC_NOT_FOUND } , new Object [ ] { STR_ , STR_ , HttpStatus . SC_NOT_FOUND } , new Object [ ] { STR_ , STR_ , HttpStatus . SC_INTERNAL_SERVER_ERROR } , new Object [ ] { STR_ , STR_ , HttpStatus . SC_INTERNAL_SERVER_ERROR } , new Object [ ] { STR_ , STR_ , HttpStatus . SC_INTERNAL_SERVER_ERROR } } ; }
public final static HeaderElement parseHeaderElement ( final String value , HeaderValueParser parser ) throws ParseException { if ( value == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( parser == null ) parser = BasicHeaderValueParser . DEFAULT ; CharArrayBuffer buffer = new CharArrayBuffer ( value . length ( ) ) ; buffer . append ( value ) ; ParserCursor cursor = new ParserCursor ( NUM_ , value . length ( ) ) ; return parser . parseHeaderElement ( buffer , cursor ) ; }
private static void attemptRetryOnException ( String logPrefix , Request < ? > request , VolleyError exception ) throws VolleyError { RetryPolicy retryPolicy = request . getRetryPolicy ( ) ; int oldTimeout = request . getTimeoutMs ( ) ; try { retryPolicy . retry ( exception ) ; } catch ( VolleyError e ) { request . addMarker ( String . format ( STR_ , logPrefix , oldTimeout ) ) ; throw e ; } request . addMarker ( String . format ( STR_ , logPrefix , oldTimeout ) ) ; }
public static String encodeString ( String s ) { return new String ( encode ( s . getBytes ( ) ) ) ; }
private void clearState ( ) { allocatedResources . clear ( ) ; requestsToCountMap . clear ( ) ; requestsQueue . clear ( ) ; }
public static double [ ] vectorBoxCorner ( double [ ] center , double [ ] result , double distance , boolean upperRight ) { if ( result == null || result . length != center . length ) { result = new double [ center . length ] ; } if ( upperRight == BOOL_ ) { distance = - distance ; } distance = SIN_PI_DIV_4 . distance ; for ( int i = NUM_ ; i < center . length ; i ++ ) { result [ i ] = center [ i ] + distance ; } return result ; }
public void toArray ( int [ ] array ) { System . arraycopy ( data , NUM_ , array , NUM_ , size ) ; }
public FixedSecureRandom ( boolean intPad , byte [ ] [ ] values ) { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; for ( int i = NUM_ ; i != values . length ; i ++ ) { try { bOut . write ( values [ i ] ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( STR_ ) ; } } _data = bOut . toByteArray ( ) ; if ( intPad ) { _intPad = _data . length % NUM_ ; } }
@ Override protected void ensureNumberOfColumns ( int numberOfColumns ) { if ( data . length >= numberOfColumns ) { return ; } long [ ] newData = new long [ numberOfColumns ] ; System . arraycopy ( data , NUM_ , newData , NUM_ , data . length ) ; data = newData ; }
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; }
public void invokeHookSpoutAck ( Object messageId , long completeLatencyNs ) { if ( taskHooks . size ( ) != NUM_ ) { SpoutAckInfo ackInfo = new SpoutAckInfo ( messageId , getThisTaskId ( ) , completeLatencyNs / Constants . MILLISECONDS_TO_NANOSECONDS ) ; for ( ITaskHook taskHook : taskHooks ) { taskHook . spoutAck ( ackInfo ) ; } } }
public static float wrap ( float value ) { if ( value >= NUM_ ) { return value - ( int ) value ; } float wrappedValue = value - ( float ) Math . floor ( value ) ; if ( wrappedValue >= NUM_ ) { wrappedValue -= NUM_ ; } return wrappedValue ; }
StubSkeletonWriter ( BatchEnvironment env , RemoteClass remoteClass , StubVersion version ) { this . env = env ; this . remoteClass = remoteClass ; this . version = version ; stubClassName = Util . binaryNameOf ( remoteClass . classDoc ( ) ) + STR_ ; skeletonClassName = Util . binaryNameOf ( remoteClass . classDoc ( ) ) + STR_ ; int i = stubClassName . lastIndexOf ( STR_ ) ; packageName = ( i != - NUM_ ? stubClassName . substring ( NUM_ , i ) : STR_ ) ; stubClassSimpleName = stubClassName . substring ( i + NUM_ ) ; skeletonClassSimpleName = skeletonClassName . substring ( i + NUM_ ) ; remoteMethods = remoteClass . remoteMethods ( ) ; methodFieldNames = nameMethodFields ( remoteMethods ) ; }
private void writeObject ( java . io . ObjectOutputStream s ) throws java . io . IOException { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { s . defaultWriteObject ( ) ; for ( Node < E > p = first ; p != null ; p = p . next ) s . writeObject ( p . item ) ; s . writeObject ( null ) ; } finally { lock . unlock ( ) ; } }
public void removeUpdateListener ( AnimatorUpdateListener listener ) { if ( mUpdateListeners == null ) { return ; } mUpdateListeners . remove ( listener ) ; if ( mUpdateListeners . size ( ) == NUM_ ) { mUpdateListeners = null ; } }
public void put ( String key , Object value , boolean errorOnFail ) { if ( value == null ) { putNull ( key ) ; } else if ( value instanceof Boolean ) { put ( key , ( Boolean ) value ) ; } else if ( value instanceof Byte ) { put ( key , ( Byte ) value ) ; } else if ( value instanceof Double ) { put ( key , ( Double ) value ) ; } else if ( value instanceof Float ) { put ( key , ( Float ) value ) ; } else if ( value instanceof Integer ) { put ( key , ( Integer ) value ) ; } else if ( value instanceof Long ) { put ( key , ( Long ) value ) ; } else if ( value instanceof Short ) { put ( key , ( Short ) value ) ; } else if ( value instanceof String ) { put ( key , ( String ) value ) ; } else if ( value instanceof byte [ ] ) { put ( key , ( byte [ ] ) value ) ; } else if ( errorOnFail ) { throw new UnsupportedOperationException ( STR_ + value . getClass ( ) ) ; } }
private void step ( ) { casings . forEach ( null ) ; casings . forEach ( null ) ; casings . forEach ( null ) ; stepPipes ( ) ; stepForwarders ( ) ; }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case NUM_ : return HOST ; case NUM_ : return PORT ; case NUM_ : return ID ; case NUM_ : return STATE ; case NUM_ : return TIMESTAMP ; case NUM_ : return VERSION ; default : return null ; } }
public static Number abs ( Number a ) { if ( isFloatingPoint ( a ) ) { return Math . abs ( a . doubleValue ( ) ) ; } else { return Math . abs ( a . longValue ( ) ) ; } }
private static DoubleMatrix2D xdistanceOld ( DoubleMatrix2D matrix , int norm ) { return null ; }
public Map < String , String > map ( ) { return hashMap ( ) ; }
private String discoverTagName ( RSyntaxDocument doc , int dot ) { Stack stack = new Stack ( ) ; Element root = doc . getDefaultRootElement ( ) ; int curLine = root . getElementIndex ( dot ) ; for ( int i = NUM_ ; i <= curLine ; i ++ ) { Token t = doc . getTokenListForLine ( i ) ; while ( t != null && t . isPaintable ( ) ) { if ( t . type == Token . MARKUP_TAG_DELIMITER ) { if ( t . isSingleChar ( STR_ ) || t . isSingleChar ( STR_ ) ) { t = t . getNextToken ( ) ; while ( t != null && t . isPaintable ( ) ) { if ( t . type == Token . MARKUP_TAG_NAME || t . type == Token . MARKUP_TAG_ATTRIBUTE ) { stack . push ( t . getLexeme ( ) ) ; break ; } t = t . getNextToken ( ) ; } } else if ( t . textCount == NUM_ && t . text [ t . textOffset ] == STR_ && ( t . text [ t . textOffset + NUM_ ] == STR_ || t . text [ t . textOffset + NUM_ ] == STR_ ) ) { if ( ! stack . isEmpty ( ) ) { stack . pop ( ) ; } } else if ( t . textCount == NUM_ && ( t . text [ t . textOffset ] == STR_ || t . text [ t . textOffset ] == STR_ ) && t . text [ t . textOffset + NUM_ ] == STR_ ) { String tagName = null ; if ( ! stack . isEmpty ( ) ) { tagName = ( String ) stack . pop ( ) ; } if ( t . offset + t . textCount >= dot ) { return tagName ; } } } t = t . getNextToken ( ) ; } } return null ; }
private static void addQueryFields ( Document doc , Node parent , Collection < PojoField > fields ) { if ( ! fields . isEmpty ( ) ) { Element prop = addProperty ( doc , parent , STR_ , null ) ; Element map = addElement ( doc , prop , STR_ , STR_ , STR_ ) ; for ( PojoField field : fields ) addElement ( doc , map , STR_ , STR_ , field . javaName ( ) , STR_ , GeneratorUtils . boxPrimitiveType ( field . javaTypeName ( ) ) ) ; } }
public void testSimpleValidString ( ) throws Exception { JsonFactory jsonF = new JsonFactory ( ) ; DataFormatDetector detector = new DataFormatDetector ( jsonF ) ; final String JSON = STR_ ; DataFormatMatcher matcher = detector . findFormat ( new ByteArrayInputStream ( JSON . getBytes ( STR_ ) ) ) ; assertTrue ( matcher . hasMatch ( ) ) ; assertEquals ( STR_ , matcher . getMatchedFormatName ( ) ) ; assertSame ( jsonF , matcher . getMatch ( ) ) ; assertEquals ( MatchStrength . WEAK_MATCH , matcher . getMatchStrength ( ) ) ; JsonParser jp = matcher . createParserWithMatch ( ) ; assertToken ( JsonToken . VALUE_STRING , jp . nextToken ( ) ) ; assertEquals ( STR_ , jp . getText ( ) ) ; assertNull ( jp . nextToken ( ) ) ; jp . close ( ) ; }
protected boolean doStart ( ) { if ( ! _lifecycle . isActive ( ) ) { return BOOL_ ; } if ( ! isEnable ( ) ) { return BOOL_ ; } int startingCount = _startingCount . getAndIncrement ( ) ; int threadCount = _threadCount . get ( ) + startingCount ; if ( _threadMax < threadCount ) { _startingCount . decrementAndGet ( ) ; onThreadMax ( ) ; return BOOL_ ; } else if ( isIdleTooLow ( startingCount ) ) { return BOOL_ ; } else { _startingCount . decrementAndGet ( ) ; return BOOL_ ; } }
@ Override public String globalInfo ( ) { return STR_ + STR_ ; }
public static long streamSkip ( InputStream stream , long count ) throws IOException { long skipped = stream . skip ( count ) ; if ( skipped < NUM_ ) { final byte [ ] temp = new byte [ NUM_ ] ; skipped = stream . read ( temp , NUM_ , Math . min ( ( int ) count , NUM_ ) ) ; } return skipped ; }
public boolean managedObjectExists ( ManagedObjectPath < ? , ? > path ) { DN targetDN = DNBuilder . create ( path ) ; try { return configRepository . getEntry ( targetDN ) != null ; } catch ( ConfigException e ) { return BOOL_ ; } }
public Vector2 rotate ( double theta ) { double cos = Math . cos ( theta ) ; double sin = Math . sin ( theta ) ; double x = this . x ; double y = this . y ; this . x = x . cos - y . sin ; this . y = x . sin + y . cos ; return this ; }
private static int [ ] [ ] regroupHistogram ( int [ ] [ ] matrix , int [ ] groups ) { long oldEntries = NUM_ ; for ( int i = NUM_ ; i < matrix . length ; i ++ ) { oldEntries += matrix [ i ] . length - NUM_ ; } long newEntries = NUM_ ; for ( int ni = NUM_ ; ni < groups . length ; ni ++ ) { newEntries += groups [ ni ] ; } if ( newEntries > oldEntries ) { int newlen = groups . length ; long ok = oldEntries ; for ( int ni = NUM_ ; ni < groups . length ; ni ++ ) { if ( ok < groups [ ni ] ) { int [ ] newGroups = new int [ ni + NUM_ ] ; System . arraycopy ( groups , NUM_ , newGroups , NUM_ , ni + NUM_ ) ; groups = newGroups ; groups [ ni ] = ( int ) ok ; ok = NUM_ ; break ; } ok -= groups [ ni ] ; } } else { long excess = oldEntries - newEntries ; int [ ] newGroups = new int [ groups . length + NUM_ ] ; System . arraycopy ( groups , NUM_ , newGroups , NUM_ , groups . length ) ; newGroups [ groups . length ] = ( int ) excess ; groups = newGroups ; } int [ ] [ ] newMatrix = new int [ groups . length ] [ ] ; int i = NUM_ ; int jMin = NUM_ ; int jMax = matrix [ i ] . length ; for ( int ni = NUM_ ; ni < groups . length ; ni ++ ) { int groupLength = groups [ ni ] ; int [ ] group = new int [ NUM_ + groupLength ] ; long groupWeight = NUM_ ; newMatrix [ ni ] = group ; int njFill = NUM_ ; while ( njFill < group . length ) { int len = group . length - njFill ; while ( jMin == jMax ) { jMin = NUM_ ; jMax = matrix [ ++ i ] . length ; } if ( len > jMax - jMin ) len = jMax - jMin ; groupWeight += ( long ) matrix [ i ] [ NUM_ ] . len ; System . arraycopy ( matrix [ i ] , jMax - len , group , njFill , len ) ; jMax -= len ; njFill += len ; } Arrays . sort ( group , NUM_ , group . length ) ; group [ NUM_ ] = ( int ) ( ( groupWeight + groupLength / NUM_ ) / groupLength ) ; } assert ( jMin == jMax ) ; assert ( i == matrix . length - NUM_ ) ; return newMatrix ; }
public void removePermission ( PermissionType permission ) { removedPermissions . add ( permission ) ; }
static void exportPrefs ( Preferences prefs , OutputStream stream , boolean withSubTree ) throws IOException , BackingStoreException { indent = - NUM_ ; BufferedWriter out = new BufferedWriter ( new OutputStreamWriter ( stream , STR_ ) ) ; out . write ( HEADER ) ; out . newLine ( ) ; out . newLine ( ) ; out . write ( DOCTYPE ) ; out . write ( STR_ ) ; out . write ( PREFS_DTD_NAME ) ; out . write ( STR_ ) ; out . newLine ( ) ; out . newLine ( ) ; flushStartTag ( STR_ , new String [ ] { STR_ } , new String [ ] { String . valueOf ( XML_VERSION ) } , out ) ; flushStartTag ( STR_ , new String [ ] { STR_ } , new String [ ] { prefs . isUserNode ( ) ? STR_ : STR_ } , out ) ; flushEmptyElement ( STR_ , out ) ; StringTokenizer ancestors = new StringTokenizer ( prefs . absolutePath ( ) , STR_ ) ; exportNode ( ancestors , prefs , withSubTree , out ) ; flushEndTag ( STR_ , out ) ; flushEndTag ( STR_ , out ) ; out . flush ( ) ; out = null ; }
protected void storeInProfilesMap ( Client client ) { Set parentSet = client . getProperties ( PARENT_ID ) ; String clientType = client . getClientType ( ) ; Map m = getStylesProfileMap ( clientType , parentSet ) ; if ( m != null ) { m . put ( clientType , client ) ; } return ; }
public int size ( ) { return data . size ( ) ; }
public void testBug4808 ( ) throws Exception { MysqlConnectionPoolDataSource ds = new MysqlConnectionPoolDataSource ( ) ; ds . setURL ( BaseTestCase . dbUrl ) ; PooledConnection closeMeTwice = ds . getPooledConnection ( ) ; closeMeTwice . close ( ) ; closeMeTwice . close ( ) ; }
public void testComputeZNaN ( ) { Geometry linearGeom = read ( STR_ ) ; LengthIndexedLine indexedLine = new LengthIndexedLine ( linearGeom ) ; double projIndex = indexedLine . project ( new Coordinate ( NUM_ , NUM_ ) ) ; Coordinate projPt = indexedLine . extractPoint ( projIndex ) ; assertTrue ( Double . isNaN ( projPt . z ) ) ; }
public static int optionLength ( String option ) { if ( option . equals ( STR_ ) ) return NUM_ ; if ( option . equals ( STR_ ) ) return NUM_ ; if ( option . equals ( STR_ ) ) return NUM_ ; return NUM_ ; }
public final double cos ( ) { return Math . cos ( this . radians ) ; }
public static FloatBuffer createFloatBuffer ( float [ ] coords ) { ByteBuffer bb = ByteBuffer . allocateDirect ( coords . length . SIZEOF_FLOAT ) ; bb . order ( ByteOrder . nativeOrder ( ) ) ; FloatBuffer fb = bb . asFloatBuffer ( ) ; fb . put ( coords ) ; fb . position ( NUM_ ) ; return fb ; }
public IntStreamEx remove ( IntPredicate predicate ) { return filter ( predicate . negate ( ) ) ; }
static void sendRawLine ( PircBot bot , BufferedWriter bwriter , String line ) { if ( line . length ( ) > bot . getMaxLineLength ( ) - NUM_ ) { line = line . substring ( NUM_ , bot . getMaxLineLength ( ) - NUM_ ) ; } synchronized ( bwriter ) { try { bwriter . write ( line + STR_ ) ; bwriter . flush ( ) ; } catch ( Exception e ) { } } }
Entry kill ( ) { Entry entry ; for ( int i = entries . size ( ) - NUM_ ; i >= NUM_ ; i -- ) { entry = entries . get ( i ) ; if ( ! entry . dead ) { entry . dead = BOOL_ ; return entry ; } } throw new IllegalStateException ( STR_ ) ; }
public void slotFromLocoAddress ( int i , SlotListener l ) { mLocoAddrHash . put ( Integer . valueOf ( i ) , l ) ; LocoNetMessage m = new LocoNetMessage ( NUM_ ) ; m . setOpCode ( LnConstants . OPC_LOCO_ADR ) ; m . setElement ( NUM_ , ( i / NUM_ ) & x7F ) ; m . setElement ( NUM_ , i & x7F ) ; tc . sendLocoNetMessage ( m ) ; }
protected void uninstallComponents ( ) { if ( scrollableTabLayoutEnabled ( ) ) { tabPane . remove ( tabScroller . viewport ) ; tabPane . remove ( tabScroller . scrollForwardButton ) ; tabPane . remove ( tabScroller . scrollBackwardButton ) ; tabScroller = null ; } }
public void reset ( ) { forms = null ; }
public static Map < String , String > populateRequestProperties ( Map < String , String > requestProperties , int bodyLength , MediaType contentType , MediaType acceptType ) { Map < String , String > properties ; if ( requestProperties == null || requestProperties . isEmpty ( ) ) { properties = new HashMap < > ( ) ; } else { properties = new HashMap < > ( requestProperties ) ; } if ( acceptType != null ) { properties . put ( HeaderNames . ACCEPT , acceptType . toString ( ) ) ; } if ( contentType != null ) { properties . put ( HeaderNames . CONTENT_TYPE , contentType . toString ( ) ) ; } if ( bodyLength > - NUM_ ) { properties . put ( HeaderNames . CONTENT_LENGTH , String . valueOf ( bodyLength ) ) ; } return properties ; }
public static BlockSnapshotDeleteCompleter createCompleter ( DbClient dbClient , BlockSnapshot snapshot , String task ) { BlockSnapshotDeleteCompleter completer = new BlockSnapshotDeleteCompleter ( snapshot , task ) ; if ( snapshot . getConsistencyGroup ( ) != null ) { List < URI > snapIds = new ArrayList < URI > ( ) ; List < BlockSnapshot > snaps = ControllerUtils . getSnapshotsPartOfReplicationGroup ( snapshot , dbClient ) ; for ( BlockSnapshot snap : snaps ) { snapIds . add ( snap . getId ( ) ) ; } completer . addIds ( snapIds ) ; } return completer ; }
private void checkProtocolAlreadyExists ( Set < String > protocols , String protocolType ) { if ( ! protocols . contains ( protocolType ) ) { protocols . add ( protocolType ) ; } }
private static char CallCharMethodV ( JNIEnvironment env , int objJREF , int methodID , Address argAddress ) throws Exception { if ( traceJNI ) VM . sysWrite ( STR_ ) ; RuntimeEntrypoints . checkJNICountDownToGC ( ) ; try { Object obj = env . getJNIRef ( objJREF ) ; Object returnObj = JNIHelpers . invokeWithVarArg ( obj , methodID , argAddress , TypeReference . Char , BOOL_ ) ; return Reflection . unwrapChar ( returnObj ) ; } catch ( Throwable unexpected ) { if ( traceJNI ) unexpected . printStackTrace ( System . err ) ; env . recordException ( unexpected ) ; return NUM_ ; } }
public void testConstrStringWithExponentWithPoint3 ( ) { String a = STR_ ; int aScale = NUM_ ; BigInteger bA = new BigInteger ( STR_ ) ; BigDecimal aNumber = new BigDecimal ( a ) ; assertEquals ( STR_ , bA , aNumber . unscaledValue ( ) ) ; assertEquals ( STR_ , aScale , aNumber . scale ( ) ) ; }
public static boolean isCompositionPlaylist ( ResourceByteRangeProvider resourceByteRangeProvider ) throws IOException { return IMFCompositionPlaylistType . isCompositionPlaylist ( resourceByteRangeProvider ) ; }
public static MasterPrivateKey decrypt ( String passphrase , byte [ ] encrypted ) throws HyperLedgerException { try { byte [ ] key = SCrypt . generate ( passphrase . getBytes ( STR_ ) , BITCOIN_SEED , NUM_ , NUM_ , NUM_ , NUM_ ) ; SecretKeySpec keyspec = new SecretKeySpec ( key , STR_ ) ; Cipher cipher = Cipher . getInstance ( STR_ , STR_ ) ; byte [ ] iv = Arrays . copyOfRange ( encrypted , NUM_ , NUM_ ) ; byte [ ] data = Arrays . copyOfRange ( encrypted , NUM_ , encrypted . length ) ; cipher . init ( Cipher . DECRYPT_MODE , keyspec , new IvParameterSpec ( iv ) ) ; return MasterPrivateKey . parse ( new String ( cipher . doFinal ( data ) ) ) ; } catch ( UnsupportedEncodingException | InvalidAlgorithmParameterException | NoSuchPaddingException | NoSuchProviderException | NoSuchAlgorithmException | InvalidKeyException | BadPaddingException | IllegalBlockSizeException e ) { throw new HyperLedgerException ( e ) ; } }
protected boolean beforeRelease ( ) { return deque . size ( ) < maxSize ; }
final boolean transferAfterCancelledWait ( Node node ) { if ( compareAndSetWaitStatus ( node , Node . CONDITION , NUM_ ) ) { enq ( node ) ; return BOOL_ ; } while ( ! isOnSyncQueue ( node ) ) Thread . yield ( ) ; return BOOL_ ; }
public void reset ( ) { System . arraycopy ( initialState , NUM_ , chain , NUM_ , chain . length ) ; ubiInit ( PARAM_TYPE_MESSAGE ) ; }
public int updateWithOnConflict ( String table , ContentValues values , String whereClause , String [ ] whereArgs , @ ConflictAlgorithm int conflictAlgorithm ) { if ( values == null || values . size ( ) == NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } acquireReference ( ) ; try { StringBuilder sql = new StringBuilder ( NUM_ ) ; sql . append ( STR_ ) ; sql . append ( CONFLICT_VALUES [ conflictAlgorithm ] ) ; sql . append ( table ) ; sql . append ( STR_ ) ; int setValuesSize = values . size ( ) ; int bindArgsSize = ( whereArgs == null ) ? setValuesSize : ( setValuesSize + whereArgs . length ) ; Object [ ] bindArgs = new Object [ bindArgsSize ] ; int i = NUM_ ; for ( Map . Entry < String , Object > entry : values . valueSet ( ) ) { sql . append ( ( i > NUM_ ) ? STR_ : STR_ ) ; sql . append ( entry . getKey ( ) ) ; bindArgs [ i ++ ] = entry . getValue ( ) ; sql . append ( STR_ ) ; } if ( whereArgs != null ) { for ( i = setValuesSize ; i < bindArgsSize ; i ++ ) { bindArgs [ i ] = whereArgs [ i - setValuesSize ] ; } } if ( ! TextUtils . isEmpty ( whereClause ) ) { sql . append ( STR_ ) ; sql . append ( whereClause ) ; } SQLiteStatement statement = new SQLiteStatement ( this , sql . toString ( ) , bindArgs ) ; try { return statement . executeUpdateDelete ( ) ; } finally { statement . close ( ) ; } } finally { releaseReference ( ) ; } }
public synchronized void addURLs ( List < URL > urls ) { for ( URL url : urls ) super . addURL ( url ) ; ArrayList searchList = new ArrayList ( ) ; searchList . addAll ( searchPath ) ; searchList . addAll ( urls ) ; searchPath = Collections . unmodifiableList ( searchPath ) ; }
protected byte [ ] httpGet ( final String url ) { HttpGet httpRequest = null ; HttpResponse httpResponse = null ; CloseableHttpClient client = null ; try { final URI uri = new URI ( url . trim ( ) ) ; httpRequest = new HttpGet ( uri ) ; if ( contentType != null ) { httpRequest . setHeader ( CONTENT_TYPE , contentType ) ; } client = getHttpClient ( url ) ; httpResponse = getHttpResponse ( client , httpRequest , url ) ; final byte [ ] returnedBytes = readHttpResponse ( url , httpResponse ) ; return returnedBytes ; } catch ( URISyntaxException e ) { throw new DSSException ( e ) ; } finally { try { if ( httpRequest != null ) { httpRequest . releaseConnection ( ) ; } if ( httpResponse != null ) { EntityUtils . consumeQuietly ( httpResponse . getEntity ( ) ) ; } } finally { closeClient ( client ) ; } } }
@ Override public String toString ( ) { return asString ; }
public final int readChar ( ) throws IOException { if ( _readEncoding != null ) { int ch = _readEncoding . read ( ) ; return ch ; } if ( _readLength <= _readOffset ) { if ( ! readBuffer ( ) ) return - NUM_ ; } return _readBuffer [ _readOffset ++ ] & xff ; }
public void writeExif ( String jpegFileName , String exifOutFileName ) throws FileNotFoundException , IOException { if ( jpegFileName == null || exifOutFileName == null ) { throw new IllegalArgumentException ( NULL_ARGUMENT_STRING ) ; } InputStream is = null ; try { is = new FileInputStream ( jpegFileName ) ; writeExif ( is , exifOutFileName ) ; } catch ( IOException e ) { closeSilently ( is ) ; throw e ; } is . close ( ) ; }
public void execNonQuery ( String sql , String [ ] selectionArgs ) { for ( int i = NUM_ , count = selectionArgs . length ; i < count ; i ++ ) sql = sql . replaceFirst ( STR_ , selectionArgs [ i ] ) ; LogUtils . d ( sql ) ; database . execSQL ( sql ) ; }
public DGeneralSubtreeChooser ( JFrame parent , String title , GeneralSubtree generalSubtree ) { super ( parent , title , ModalityType . DOCUMENT_MODAL ) ; initComponents ( generalSubtree ) ; }
public void insert ( UndoObjectStorable p_object ) { if ( p_object == null ) throw new IllegalArgumentException ( classname + STR_ ) ; disable_redo ( ) ; UndoObjectNode undoable_object = new UndoObjectNode ( p_object , stack_level ) ; objects_map . put ( p_object , undoable_object ) ; }
protected abstract SimpleEntry entryDataMatched ( EntryHierarchyData ehd ) ;
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = enumToVector ( super . listOptions ( ) ) ; result . add ( new Option ( STR_ + defaultNoisePercent ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
private void writeAttribute ( java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( namespace . equals ( STR_ ) ) { xmlWriter . writeAttribute ( attName , attValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } }
@ SuppressWarnings ( STR_ ) protected void notifyPropertyChangeListener ( String property , Object oldValue , Object newValue ) { if ( ( oldValue != null && oldValue . equals ( newValue ) ) || oldValue == newValue ) { log . error ( STR_ ) ; } Vector < PropertyChangeListener > v ; synchronized ( this ) { v = ( Vector < PropertyChangeListener > ) listeners . clone ( ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + v . size ( ) + STR_ + property ) ; } int cnt = v . size ( ) ; for ( int i = NUM_ ; i < cnt ; i ++ ) { PropertyChangeListener client = v . elementAt ( i ) ; client . propertyChange ( new PropertyChangeEvent ( this , property , oldValue , newValue ) ) ; } }
protected final void refreshLoadingViewsSize ( ) { final int maximumPullScroll = ( int ) ( getMaximumPullScroll ( ) . NUM_ ) ; int pLeft = getPaddingLeft ( ) ; int pTop = getPaddingTop ( ) ; int pRight = getPaddingRight ( ) ; int pBottom = getPaddingBottom ( ) ; switch ( getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setWidth ( maximumPullScroll ) ; pLeft = - maximumPullScroll ; } else { pLeft = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setWidth ( maximumPullScroll ) ; pRight = - maximumPullScroll ; } else { pRight = NUM_ ; } break ; case VERTICAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setHeight ( maximumPullScroll ) ; pTop = - maximumPullScroll ; } else { pTop = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setHeight ( maximumPullScroll ) ; pBottom = - maximumPullScroll ; } else { pBottom = NUM_ ; } break ; } if ( DEBUG ) { Log . d ( LOG_TAG , String . format ( STR_ , pLeft , pTop , pRight , pBottom ) ) ; } setPadding ( pLeft , pTop , pRight , pBottom ) ; }
public Element writeBeanVisual ( Element parent , Object o , String name ) throws Exception { Element node ; BeanVisual visual ; if ( DEBUG ) { trace ( new Throwable ( ) , name ) ; } m_CurrentNode = parent ; visual = ( BeanVisual ) o ; node = writeToXML ( parent , o , name ) ; invokeWriteToXML ( node , visual . getIconPath ( ) , VAL_ICONPATH ) ; invokeWriteToXML ( node , visual . getAnimatedIconPath ( ) , VAL_ANIMATEDICONPATH ) ; return node ; }
private String displayNametoBackCompatName ( String queryName ) { final int lastBackSlash = queryName . lastIndexOf ( STR_ ) ; if ( lastBackSlash > NUM_ && lastBackSlash < queryName . length ( ) - NUM_ ) { queryName = ( char ) x00ab + queryName ; queryName = queryName . substring ( NUM_ , lastBackSlash + NUM_ ) + ( char ) x00bb + STR_ + queryName . substring ( lastBackSlash + NUM_ ) ; queryName = queryName . replace ( STR_ , ( char ) x2044 ) ; } return queryName ; }
public SQLiteDatabaseConfiguration ( String path , int openFlags ) { if ( path == null ) { throw new IllegalArgumentException ( STR_ ) ; } this . path = path ; label = stripPathForLogs ( path ) ; this . openFlags = openFlags ; maxSqlCacheSize = NUM_ ; locale = Locale . getDefault ( ) ; }
@ Override public void drawRangeGridline ( Graphics2D g2 , CategoryPlot plot , ValueAxis axis , Rectangle2D dataArea , double value ) { Range range = axis . getRange ( ) ; if ( ! range . contains ( value ) ) { return ; } Rectangle2D adjusted = new Rectangle2D . Double ( dataArea . getX ( ) , dataArea . getY ( ) + getYOffset ( ) , dataArea . getWidth ( ) - getXOffset ( ) , dataArea . getHeight ( ) - getYOffset ( ) ) ; Line2D line1 = null ; Line2D line2 = null ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation == PlotOrientation . HORIZONTAL ) { double x0 = axis . valueToJava2D ( value , adjusted , plot . getRangeAxisEdge ( ) ) ; double x1 = x0 + getXOffset ( ) ; double y0 = dataArea . getMaxY ( ) ; double y1 = y0 - getYOffset ( ) ; double y2 = dataArea . getMinY ( ) ; line1 = new Line2D . Double ( x0 , y0 , x1 , y1 ) ; line2 = new Line2D . Double ( x1 , y1 , x1 , y2 ) ; } else if ( orientation == PlotOrientation . VERTICAL ) { double y0 = axis . valueToJava2D ( value , adjusted , plot . getRangeAxisEdge ( ) ) ; double y1 = y0 - getYOffset ( ) ; double x0 = dataArea . getMinX ( ) ; double x1 = x0 + getXOffset ( ) ; double x2 = dataArea . getMaxX ( ) ; line1 = new Line2D . Double ( x0 , y0 , x1 , y1 ) ; line2 = new Line2D . Double ( x1 , y1 , x2 , y1 ) ; } Paint paint = plot . getRangeGridlinePaint ( ) ; Stroke stroke = plot . getRangeGridlineStroke ( ) ; g2 . setPaint ( paint != null ? paint : Plot . DEFAULT_OUTLINE_PAINT ) ; g2 . setStroke ( stroke != null ? stroke : Plot . DEFAULT_OUTLINE_STROKE ) ; g2 . draw ( line1 ) ; g2 . draw ( line2 ) ; }
public static String dump ( final EndpointDescriptor descriptor ) { return String . format ( STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ , descriptor . bLength ( ) , descriptor . bDescriptorType ( ) , String . format ( STR_ , descriptor . bEndpointAddress ( ) & xff ) , descriptor . bEndpointAddress ( ) & x0f , getDirectionName ( descriptor . bEndpointAddress ( ) ) , descriptor . bmAttributes ( ) & xff , getTransferTypeName ( descriptor . bmAttributes ( ) ) , getSynchTypeName ( descriptor . bmAttributes ( ) ) , getUsageTypeName ( descriptor . bmAttributes ( ) ) , descriptor . wMaxPacketSize ( ) & xffff , descriptor . bInterval ( ) & xff ) ; }
public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( NUM_ ) ; newVector . addElement ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
public static void printPadding ( PrintWriter out , int padding ) { for ( int i = NUM_ ; i < padding ; ++ i ) { out . print ( STR_ ) ; } }
protected void sneakyClear ( ) { List < EObject > collection = new UnmodifiableEList < > ( size , data ) ; sneakyDoClear ( ) ; for ( Iterator < EObject > i = collection . iterator ( ) ; i . hasNext ( ) ; ) { inverseRemove ( i . next ( ) , null ) ; } }
@ CalledByNative public static Bitmap createHomeScreenIconFromWebIcon ( Context context , Bitmap webIcon ) { ActivityManager am = ( ActivityManager ) context . getSystemService ( Context . ACTIVITY_SERVICE ) ; int maxInnerSize = Math . round ( am . getLauncherLargeIconSize ( ) . MAX_INNER_SIZE_RATIO ) ; int innerSize = Math . min ( maxInnerSize , Math . max ( webIcon . getWidth ( ) , webIcon . getHeight ( ) ) ) ; int padding = Math . round ( ICON_PADDING_RATIO . innerSize ) ; int outerSize = innerSize + NUM_ . padding ; Bitmap bitmap = null ; try { bitmap = Bitmap . createBitmap ( outerSize , outerSize , Bitmap . Config . ARGB_8888 ) ; } catch ( OutOfMemoryError e ) { Log . w ( TAG , STR_ ) ; return webIcon ; } Canvas canvas = new Canvas ( bitmap ) ; Rect innerBounds = new Rect ( padding , padding , outerSize - padding , outerSize - padding ) ; Paint paint = new Paint ( Paint . ANTI_ALIAS_FLAG ) ; paint . setFilterBitmap ( BOOL_ ) ; canvas . drawBitmap ( webIcon , null , innerBounds , paint ) ; int cornerRadius = Math . round ( ICON_CORNER_RADIUS_RATIO . outerSize ) ; Path path = new Path ( ) ; path . setFillType ( Path . FillType . INVERSE_WINDING ) ; RectF innerBoundsF = new RectF ( innerBounds ) ; path . addRoundRect ( innerBoundsF , cornerRadius , cornerRadius , Path . Direction . CW ) ; paint . setXfermode ( new PorterDuffXfermode ( PorterDuff . Mode . CLEAR ) ) ; canvas . drawPath ( path , paint ) ; return bitmap ; }
private static boolean isInOverflow ( MenuItem item ) { return ! isActionButton ( item ) ; }
private static int determineConsecutiveBinaryCount ( CharSequence msg , byte [ ] bytes , int startpos ) throws WriterException { int len = msg . length ( ) ; int idx = startpos ; while ( idx < len ) { char ch = msg . charAt ( idx ) ; int numericCount = NUM_ ; while ( numericCount < NUM_ && isDigit ( ch ) ) { numericCount ++ ; int i = idx + numericCount ; if ( i >= len ) { break ; } ch = msg . charAt ( i ) ; } if ( numericCount >= NUM_ ) { return idx - startpos ; } int textCount = NUM_ ; while ( textCount < NUM_ && isText ( ch ) ) { textCount ++ ; int i = idx + textCount ; if ( i >= len ) { break ; } ch = msg . charAt ( i ) ; } if ( textCount >= NUM_ ) { return idx - startpos ; } ch = msg . charAt ( idx ) ; if ( bytes [ idx ] == NUM_ && ch != STR_ ) { throw new WriterException ( STR_ + ch + STR_ + ( int ) ch + STR_ ) ; } idx ++ ; } return idx - startpos ; }
void pluginMessage ( Throwable ex ) { log . printLines ( PrefixKind . JAVAC , STR_ ) ; ex . printStackTrace ( log . getWriter ( WriterKind . NOTICE ) ) ; }
public Builder map ( String fullyQualifiedColumnNames , ColumnMapper mapper ) { Predicate < ColumnId > columnMatcher = Predicates . includes ( fullyQualifiedColumnNames , null ) ; rules . add ( new MapperRule ( columnMatcher , mapper ) ) ; return this ; }
public double theta ( ) { return Math . atan2 ( y , x ) ; }
public static int hash32 ( final String text , int from , int length ) { return hash32 ( text . substring ( from , from + length ) ) ; }
protected void sendClosingMessage ( ) { try { send ( ConnectionMessage . CLOSING , NetworkProtocol . TCP ) ; } catch ( Exception e ) { log . warning ( STR_ + e . getMessage ( ) ) ; } try { send ( ConnectionMessage . CLOSING , NetworkProtocol . UDP ) ; } catch ( Exception e ) { log . warning ( STR_ + e . getMessage ( ) ) ; } }
public void remove ( T graphic ) { synchronized ( mLock ) { mGraphics . remove ( graphic ) ; if ( mFirstGraphic != null && mFirstGraphic . equals ( graphic ) ) { mFirstGraphic = null ; } } postInvalidate ( ) ; }
public boolean validSystemNameConfig ( String systemName ) { return ( BOOL_ ) ; }
public int read ( ) throws IOException { ensureOpen ( ) ; if ( next >= length ) { return - NUM_ ; } return str . charAt ( next ++ ) ; }
void addHiddenChannelListener ( HiddenChannelListener listener ) { listeners . add ( listener ) ; }
public boolean nextTo ( final Entity entity , final double step ) { final Rectangle2D thisArea = new Rectangle2D . Double ( x - step , y - step , area . getWidth ( ) + NUM_ . step , area . getHeight ( ) + NUM_ . step ) ; return thisArea . intersects ( entity . getArea ( ) ) ; }
private long rebalance_nl ( final long nParent , final long n , LongArray unlinked ) { final long nL = unsharedLeft ( n , unlinked ) ; final long nR = unsharedRight ( n , unlinked ) ; if ( ( nL == NUM_ || nR == NUM_ ) && vOptIsNull ( n ) ) { if ( attemptUnlink_nl ( nParent , n , unlinked ) ) { return fixHeight_nl ( nParent ) ; } else { return n ; } } final int hN = height ( n ) ; final int hL0 = height ( nL ) ; final int hR0 = height ( nR ) ; final int hNRepl = NUM_ + Math . max ( hL0 , hR0 ) ; final int bal = hL0 - hR0 ; if ( bal > NUM_ ) { return rebalanceToRight_nl ( nParent , n , nL , hR0 , unlinked ) ; } else if ( bal < - NUM_ ) { return rebalanceToLeft_nl ( nParent , n , nR , hL0 , unlinked ) ; } else if ( hNRepl != hN ) { height ( n , hNRepl ) ; return fixHeight_nl ( nParent ) ; } else { return NUM_ ; } }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
private void addConversations ( ) { TPP_Phase myphase = AWAITING ; mainNPC . add ( ConversationStates . ATTENDING , Arrays . asList ( STR_ , STR_ ) , new TPPQuestInPhaseCondition ( myphase ) , ConversationStates . ATTENDING , STR_ + STR_ + STR_ , null ) ; mainNPC . add ( ConversationStates . ATTENDING , STR_ , new TPPQuestInPhaseCondition ( myphase ) , ConversationStates . ATTENDING , null , new DetailsKillingsAction ( ) ) ; mainNPC . add ( ConversationStates . ATTENDING , STR_ , new TPPQuestInPhaseCondition ( myphase ) , ConversationStates . ATTENDING , null , new RewardPlayerAction ( ) ) ; }
public static void w ( String tag , String s , Object ... args ) { if ( LOG . WARN >= LOGLEVEL ) Log . w ( tag , String . format ( s , args ) ) ; }
@ edu . umd . cs . findbugs . annotations . SuppressWarnings ( value = STR_ , justification = STR_ ) public void handleNotification ( Notification notification , Object handback ) { if ( handback instanceof AgentImpl ) { AgentImpl agent = ( AgentImpl ) handback ; JMXConnectionNotification jmxNotifn = ( JMXConnectionNotification ) notification ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( STR_ , jmxNotifn . getConnectionId ( ) ) ; } agent . updateRmiClientsCount ( ) ; } }
public static boolean isBlank ( String s ) { if ( s == null ) { return BOOL_ ; } int sLen = s . length ( ) ; for ( int i = NUM_ ; i < sLen ; i ++ ) { if ( ! Character . isWhitespace ( s . charAt ( i ) ) ) { return BOOL_ ; } } return BOOL_ ; }
public PlainTextDictionary ( Path path ) throws IOException { in = Files . newBufferedReader ( path , StandardCharsets . UTF_8 ) ; }
public boolean addAliasByNumber ( String aliasName , String number ) { if ( aliasName . contains ( STR_ ) ) return BOOL_ ; String contactName = ContactsManager . getContactNameOrNull ( ctx , number ) ; addOrUpdate ( aliasName , number , contactName ) ; return BOOL_ ; }
void splitData ( Node node , Node newNode , int offset ) { if ( ranges != null ) { notifyRangesSplitData ( node , newNode , offset ) ; } }
@ NotNull @ ObjectiveCName ( STR_ ) public ConfigurationBuilder addTrustedKey ( String trustedKey ) { trustedKeys . add ( new TrustedKey ( trustedKey ) ) ; return this ; }
private void checkIsCorrectClass ( ) { if ( checkIsSubClass ( ACT_NAME ) ) { type = ElementType . ACTTIVITY ; } else if ( checkIsSubClass ( FRAG_NAME ) || checkIsSubClass ( V4_FRAG_NAME ) ) { type = ElementType . FRAGMENT ; } else { throw new IllegalArgumentException ( String . format ( STR_ , element . getQualifiedName ( ) , ACT_NAME , FRAG_NAME , V4_FRAG_NAME ) ) ; } }
String transformResourceIdToFileName ( final String resourceName ) { return resourceName . replace ( STR_ , STR_ ) ; }
public void disable ( RichFormatterFeature feature ) { features . remove ( feature ) ; }
public boolean isCritical ( ) { return BOOL_ ; }
public final boolean isSecure ( Socket sock ) throws IllegalArgumentException { if ( sock == null ) { throw new IllegalArgumentException ( STR_ ) ; } if ( sock . getClass ( ) != Socket . class ) { throw new IllegalArgumentException ( STR_ ) ; } if ( sock . isClosed ( ) ) { throw new IllegalArgumentException ( STR_ ) ; } return BOOL_ ; }
public synchronized void add ( String name , long threadId ) { if ( mFinished ) { throw new IllegalStateException ( STR_ ) ; } mMarkers . add ( new Marker ( name , threadId , SystemClock . elapsedRealtime ( ) ) ) ; }
private void skipWhitespace ( ) { matcher . usePattern ( WHITESPACE ) ; if ( matcher . lookingAt ( ) ) { matcher . region ( matcher . end ( ) , matcher . regionEnd ( ) ) ; } }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case NUM_ : return SUCCESS ; case NUM_ : return MSG ; default : return null ; } }
public void pushStylesheet ( Stylesheet s ) { if ( m_stylesheets . size ( ) == NUM_ ) m_stylesheetRoot = ( StylesheetRoot ) s ; m_stylesheets . push ( s ) ; }
private void fillNodesInContext ( SiteNode rootNode , List < SiteNode > nodesList ) { @ SuppressWarnings ( STR_ ) Enumeration < SiteNode > en = rootNode . children ( ) ; while ( en . hasMoreElements ( ) ) { SiteNode sn = en . nextElement ( ) ; if ( isInContext ( sn ) ) { nodesList . add ( sn ) ; } fillNodesInContext ( sn , nodesList ) ; } }
@ SuppressWarnings ( { STR_ , STR_ } ) public boolean matches ( InventoryCrafting p_77569_1_ , World p_77569_2_ ) { ArrayList arraylist = new ArrayList ( this . recipeItems ) ; for ( int i = NUM_ ; i < NUM_ ; ++ i ) { for ( int j = NUM_ ; j < NUM_ ; ++ j ) { ItemStack itemstack = p_77569_1_ . getStackInRowAndColumn ( j , i ) ; if ( itemstack != null ) { boolean flag = BOOL_ ; Iterator iterator = arraylist . iterator ( ) ; while ( iterator . hasNext ( ) ) { ItemStack itemstack1 = ( ItemStack ) iterator . next ( ) ; if ( itemstack . getItem ( ) == itemstack1 . getItem ( ) && ( itemstack1 . getItemDamage ( ) == NUM_ || itemstack . getItemDamage ( ) == itemstack1 . getItemDamage ( ) ) ) { flag = BOOL_ ; arraylist . remove ( itemstack1 ) ; break ; } } if ( ! flag ) { return BOOL_ ; } } } } return arraylist . isEmpty ( ) ; }
public StringBuilder dumpStatements ( final IAccessPath < ISPO > accessPath ) { final StringBuilder sb = new StringBuilder ( ) ; final BigdataStatementIterator itr = asStatementIterator ( accessPath . iterator ( ) ) ; try { while ( itr . hasNext ( ) ) { sb . append ( STR_ + itr . next ( ) ) ; } return sb ; } finally { itr . close ( ) ; } }
public static Element svgWaitIcon ( Document document , double x , double y , double w , double h ) { Element g = SVGUtil . svgElement ( document , SVGConstants . SVG_G_TAG ) ; setAtt ( g , SVGConstants . SVG_TRANSFORM_ATTRIBUTE , STR_ + x + STR_ + y + STR_ + w + STR_ + h + STR_ ) ; Element thro = SVGUtil . svgElement ( document , SVGConstants . SVG_PATH_TAG ) ; setAtt ( thro , SVGConstants . SVG_D_ATTRIBUTE , THROBBER_PATH ) ; setStyle ( thro , THROBBER_STYLE ) ; Element anim = SVGUtil . svgElement ( document , SVGConstants . SVG_ANIMATE_TRANSFORM_TAG ) ; setAtt ( anim , SVGConstants . SVG_ATTRIBUTE_NAME_ATTRIBUTE , SVGConstants . SVG_TRANSFORM_ATTRIBUTE ) ; setAtt ( anim , SVGConstants . SVG_ATTRIBUTE_TYPE_ATTRIBUTE , STR_ ) ; setAtt ( anim , SVGConstants . SVG_TYPE_ATTRIBUTE , SVGConstants . SVG_ROTATE_ATTRIBUTE ) ; setAtt ( anim , SVGConstants . SVG_FROM_ATTRIBUTE , STR_ ) ; setAtt ( anim , SVGConstants . SVG_TO_ATTRIBUTE , STR_ ) ; setAtt ( anim , SVGConstants . SVG_BEGIN_ATTRIBUTE , fmt ( Math . random ( ) . NUM_ ) + STR_ ) ; setAtt ( anim , SVGConstants . SVG_DUR_ATTRIBUTE , STR_ ) ; setAtt ( anim , SVGConstants . SVG_REPEAT_COUNT_ATTRIBUTE , STR_ ) ; setAtt ( anim , SVGConstants . SVG_FILL_ATTRIBUTE , STR_ ) ; thro . appendChild ( anim ) ; g . appendChild ( thro ) ; return g ; }
protected void onEnd ( Pcap pcap ) { this . end = BOOL_ ; }
public void cd ( String dir ) { StringBuilder buf = new StringBuilder ( ) ; String command = String . format ( ImageServerDialogProperties . getString ( STR_ ) , dir ) ; sendWaitFor ( command , defaultTimeout , prompts , buf ) ; log . debug ( buf . toString ( ) ) ; }
public void addRequestProperty ( String key , String value ) { jarFileURLConnection . addRequestProperty ( key , value ) ; }
public static String numberToString ( Number number ) throws JSONException { if ( number == null ) { throw new JSONException ( STR_ ) ; } testValidity ( number ) ; String string = number . toString ( ) ; if ( string . indexOf ( STR_ ) > NUM_ && string . indexOf ( STR_ ) < NUM_ && string . indexOf ( STR_ ) < NUM_ ) { while ( string . endsWith ( STR_ ) ) { string = string . substring ( NUM_ , string . length ( ) - NUM_ ) ; } if ( string . endsWith ( STR_ ) ) { string = string . substring ( NUM_ , string . length ( ) - NUM_ ) ; } } return string ; }
public static void writeSpecInfoToFiles ( SecuritySpecModel securitySpecModel , String app_ROOT_DIR ) { writeInfoFlowSummaryToFile ( securitySpecModel , Config . v ( ) . APP_ROOT_DIR ) ; writeInfoFlowDetailsToFile ( securitySpecModel , Config . v ( ) . APP_ROOT_DIR ) ; writeValueInfoToFile ( securitySpecModel , Config . v ( ) . APP_ROOT_DIR ) ; writePointsToInfoToFile ( securitySpecModel , Config . v ( ) . APP_ROOT_DIR ) ; }
private int measureShort ( int measureSpec ) { int result ; int specMode = MeasureSpec . getMode ( measureSpec ) ; int specSize = MeasureSpec . getSize ( measureSpec ) ; if ( specMode == MeasureSpec . EXACTLY ) { result = specSize ; } else { result = ( int ) ( NUM_ . mRadius + getPaddingTop ( ) + getPaddingBottom ( ) + NUM_ ) ; if ( specMode == MeasureSpec . AT_MOST ) { result = Math . min ( result , specSize ) ; } } return result ; }
private void handleCommand ( int id , String command , String params ) { String originCommand = commandId . get ( id ) ; if ( originCommand == null ) { originCommand = STR_ ; } handler . handleCommand ( id , command , params , originCommand ) ; if ( command . equals ( STR_ ) ) { LOGGER . warning ( STR_ + params ) ; } }
private void closeAllDumps ( ) { Object [ ] options = { STR_ , STR_ } ; int selectValue = JOptionPane . showOptionDialog ( null , STR_ , STR_ , JOptionPane . DEFAULT_OPTION , JOptionPane . QUESTION_MESSAGE , null , options , options [ NUM_ ] ) ; if ( selectValue == NUM_ ) { topNodes = new Vector ( ) ; resetMainPanel ( ) ; } }
private void closeCounterDataInputStream ( ) throws DataFallbackException { if ( LOG . isDebugEnabled ( ) ) LOG . debug ( STR_ + counterFile . getName ( ) ) ; if ( dInput != null ) { try { dInput . close ( ) ; } catch ( IOException e ) { throw new DataFallbackException ( e . getMessage ( ) ) ; } finally { dInput = null ; } } }
private static String removeFileNameExtension ( String fileName ) { if ( fileName . lastIndexOf ( STR_ ) == - NUM_ ) return fileName ; return fileName . substring ( NUM_ , fileName . lastIndexOf ( STR_ ) ) ; }
public void clear ( ) { read = write = count = NUM_ ; Arrays . fill ( buffer , null ) ; }
private Response < Bitmap > doParse ( NetworkResponse response ) { byte [ ] data = response . data ; BitmapFactory . Options decodeOptions = new BitmapFactory . Options ( ) ; Bitmap bitmap = null ; if ( mMaxWidth == NUM_ && mMaxHeight == NUM_ ) { decodeOptions . inPreferredConfig = mDecodeConfig ; bitmap = BitmapFactory . decodeByteArray ( data , NUM_ , data . length , decodeOptions ) ; } else { decodeOptions . inJustDecodeBounds = BOOL_ ; BitmapFactory . decodeByteArray ( data , NUM_ , data . length , decodeOptions ) ; int actualWidth = decodeOptions . outWidth ; int actualHeight = decodeOptions . outHeight ; int desiredWidth = getResizedDimension ( mMaxWidth , mMaxHeight , actualWidth , actualHeight , mScaleType ) ; int desiredHeight = getResizedDimension ( mMaxHeight , mMaxWidth , actualHeight , actualWidth , mScaleType ) ; decodeOptions . inJustDecodeBounds = BOOL_ ; decodeOptions . inSampleSize = findBestSampleSize ( actualWidth , actualHeight , desiredWidth , desiredHeight ) ; Bitmap tempBitmap = BitmapFactory . decodeByteArray ( data , NUM_ , data . length , decodeOptions ) ; if ( tempBitmap != null && ( tempBitmap . getWidth ( ) > desiredWidth || tempBitmap . getHeight ( ) > desiredHeight ) ) { bitmap = Bitmap . createScaledBitmap ( tempBitmap , desiredWidth , desiredHeight , BOOL_ ) ; tempBitmap . recycle ( ) ; } else { bitmap = tempBitmap ; } } if ( bitmap == null ) { return Response . error ( new ParseError ( response ) ) ; } else { return Response . success ( bitmap , HttpHeaderParser . parseCacheHeaders ( response ) ) ; } }
private List < Entry > reduceWithDouglasPeuker ( List < Entry > entries , double epsilon ) { if ( epsilon <= NUM_ || entries . size ( ) < NUM_ ) { return entries ; } keep [ NUM_ ] = BOOL_ ; keep [ entries . size ( ) - NUM_ ] = BOOL_ ; algorithmDouglasPeucker ( entries , epsilon , NUM_ , entries . size ( ) - NUM_ ) ; List < Entry > reducedEntries = new ArrayList < > ( ) ; for ( int i = NUM_ ; i < entries . size ( ) ; i ++ ) { if ( keep [ i ] ) { Entry curEntry = entries . get ( i ) ; reducedEntries . add ( new Entry ( curEntry . getVal ( ) , curEntry . getXIndex ( ) ) ) ; } } return reducedEntries ; }
static int hiBitPos ( long num ) { return NUM_ - Long . numberOfLeadingZeros ( num ) ; }
public AdaptiveGridArchive ( int capacity , Problem problem , int numberOfDivisions ) { this . capacity = capacity ; this . problem = problem ; this . numberOfDivisions = numberOfDivisions ; minimum = new double [ problem . getNumberOfObjectives ( ) ] ; maximum = new double [ problem . getNumberOfObjectives ( ) ] ; density = new int [ ( int ) Math . pow ( numberOfDivisions , problem . getNumberOfObjectives ( ) ) ] ; adaptGrid ( ) ; }
BeginLineAction ( String nm , boolean select ) { super ( nm ) ; this . select = select ; }
public static boolean occupy ( int waitMs ) { if ( occupiedUntil != null && occupiedUntil . after ( new Date ( ) ) ) { return BOOL_ ; } occupiedUntil = DateUtils . addMilliseconds ( new Date ( ) , waitMs ) ; return BOOL_ ; }
@ Override public void write ( List < byte [ ] > valueList ) throws IOException { if ( isFirstTime ) { init ( ) ; isFirstTime = BOOL_ ; } for ( byte [ ] value : valueList ) { oneDictionaryChunkList . add ( ByteBuffer . wrap ( value ) ) ; totalRecordCount ++ ; } }
public void proceed ( ) { idle . set ( BOOL_ ) ; subject . onNext ( null ) ; }
private static boolean nsEquals ( String nsURI_1 , String nsURI_2 ) { if ( nsURI_1 == null ) { return ( nsURI_2 == null ) ; } else { return nsURI_1 . equals ( nsURI_2 ) ; } }
private boolean linkFirst ( Node < E > node ) { if ( count >= capacity ) return BOOL_ ; Node < E > f = first ; node . next = f ; first = node ; if ( last == null ) last = node ; else f . prev = node ; ++ count ; notEmpty . signal ( ) ; return BOOL_ ; }
public static void sleep ( long millis ) { if ( mockSleepQueue == null ) { sleepUninterruptibly ( millis , TimeUnit . MILLISECONDS ) ; } else { try { boolean isMultiPass = mockSleepQueue . take ( ) ; rollMockClockMillis ( millis ) ; if ( isMultiPass ) mockSleepQueue . offer ( BOOL_ ) ; } catch ( InterruptedException e ) { } } }
public boolean isHandle ( String handle ) { return clientHandle . equals ( handle ) ; }
public static void isGTE ( String argName , long i , long min ) { if ( i < min ) { throw new IllegalArgumentException ( String . format ( STR_ , argName , min , i ) ) ; } }
int adjustTextOffset ( int offset ) { maxTextOffset = Math . max ( maxTextOffset , offset ) ; return maxTextOffset ; }
public static Object valueFromClassConstant ( String key , Object defaultValue ) { Configuration conf = instance ( ) ; String val = valueFor ( key ) ; if ( val == null ) { return defaultValue ; } int idx = val . lastIndexOf ( STR_ ) ; String klassname ; String cnst ; try { klassname = val . substring ( NUM_ , idx ) ; cnst = val . substring ( idx + NUM_ ) ; } catch ( IndexOutOfBoundsException e ) { conf . warning ( STR_ + key + STR_ + STR_ + val ) ; return defaultValue ; } Class klass ; try { klass = Class . forName ( klassname ) ; } catch ( ClassNotFoundException e ) { conf . warning ( STR_ + key + STR_ + klassname ) ; return defaultValue ; } Object cnstVal ; try { Field fld = klass . getDeclaredField ( cnst ) ; try { cnstVal = fld . get ( klass ) ; } catch ( IllegalAccessException e ) { conf . warning ( STR_ + key + STR_ + klassname + STR_ + cnst ) ; return defaultValue ; } } catch ( NoSuchFieldException e ) { conf . warning ( STR_ + key + STR_ + klassname ) ; return defaultValue ; } return cnstVal ; }
public static boolean isWifiConnected ( Context context ) { ConnectivityManager connectivityManager = ( ConnectivityManager ) context . getSystemService ( Context . CONNECTIVITY_SERVICE ) ; NetworkInfo networkInfo = connectivityManager . getActiveNetworkInfo ( ) ; return networkInfo != null && networkInfo . getType ( ) == ConnectivityManager . TYPE_WIFI ; }
public StrBuilder insert ( final int index , final char value ) { validateIndex ( index ) ; ensureCapacity ( size + NUM_ ) ; System . arraycopy ( buffer , index , buffer , index + NUM_ , size - index ) ; buffer [ index ] = value ; size ++ ; return this ; }
public List < byte [ ] > tryDecode ( final String targetToken ) { final ByteBuffer payloadBuf = extractValidPayloadFields ( targetToken ) ; if ( payloadBuf == null ) { return null ; } final List < byte [ ] > fields = new ArrayList < > ( ) ; try { byte [ ] field = null ; while ( ( field = tryReadPayloadNextField ( payloadBuf ) ) . length > NUM_ ) { fields . add ( field ) ; if ( fields . size ( ) > MAX_FIELD_SIZE ) { return null ; } } return fields ; } catch ( final BufferUnderflowException e ) { return null ; } }
@ NamespacePermission ( fields = STR_ , permissions = NamespacePermissionEnum . WRITE ) @ Override public BusinessObjectDefinition createBusinessObjectDefinition ( BusinessObjectDefinitionCreateRequest request ) { validateBusinessObjectDefinitionCreateRequest ( request ) ; NamespaceEntity namespaceEntity = namespaceDaoHelper . getNamespaceEntity ( request . getNamespace ( ) ) ; DataProviderEntity dataProviderEntity = dataProviderDaoHelper . getDataProviderEntity ( request . getDataProviderName ( ) ) ; BusinessObjectDefinitionKey businessObjectDefinitionKey = new BusinessObjectDefinitionKey ( request . getNamespace ( ) , request . getBusinessObjectDefinitionName ( ) ) ; BusinessObjectDefinitionEntity businessObjectDefinitionEntity = businessObjectDefinitionDao . getBusinessObjectDefinitionByKey ( businessObjectDefinitionKey ) ; if ( businessObjectDefinitionEntity != null ) { throw new AlreadyExistsException ( String . format ( STR_ , businessObjectDefinitionKey . getBusinessObjectDefinitionName ( ) , businessObjectDefinitionKey . getNamespace ( ) ) ) ; } businessObjectDefinitionEntity = createBusinessObjectDefinitionEntity ( request , namespaceEntity , dataProviderEntity ) ; return createBusinessObjectDefinitionFromEntity ( businessObjectDefinitionEntity ) ; }
public void endBlock ( ) throws IOException { if ( indent . length ( ) <= NUM_ ) { indent = STR_ ; } else if ( indent . length ( ) >= NUM_ ) { indent = indent . substring ( NUM_ ) ; } print ( STR_ , null ) ; printer . println ( ) ; }
private void migrateBlockVolumes ( ) { log . info ( STR_ ) ; DbClient dbClient = getDbClient ( ) ; List < URI > volumeURIs = dbClient . queryByType ( Volume . class , BOOL_ ) ; Iterator < Volume > volumes = dbClient . queryIterativeObjects ( Volume . class , volumeURIs , BOOL_ ) ; List < BlockObject > blockObjects = new ArrayList < BlockObject > ( ) ; while ( volumes . hasNext ( ) ) { blockObjects . add ( volumes . next ( ) ) ; } migrateBlockObjects ( blockObjects ) ; }
public static String decode ( String s , String enc , boolean plusToSpace ) { boolean modified = BOOL_ ; if ( enc == null || enc . length ( ) == NUM_ ) { enc = STR_ ; } int numChars = s . length ( ) ; StringBuilder sb = new StringBuilder ( numChars > NUM_ ? numChars / NUM_ : numChars ) ; int i = NUM_ ; char c ; byte [ ] bytes = null ; while ( i < numChars ) { c = s . charAt ( i ) ; switch ( c ) { case STR_ : if ( plusToSpace ) { sb . append ( STR_ ) ; } else { sb . append ( STR_ ) ; } i ++ ; modified = BOOL_ ; break ; case STR_ : try { if ( bytes == null ) { bytes = new byte [ ( numChars - i ) / NUM_ ] ; } int pos = NUM_ ; while ( ( ( i + NUM_ ) < numChars ) && ( c == STR_ ) ) { bytes [ pos ++ ] = ( byte ) Integer . parseInt ( s . substring ( i + NUM_ , i + NUM_ ) , NUM_ ) ; i += NUM_ ; if ( i < numChars ) { c = s . charAt ( i ) ; } } if ( ( i < numChars ) && ( c == STR_ ) ) { throw new IllegalArgumentException ( STR_ + s ) ; } try { sb . append ( new String ( bytes , NUM_ , pos , enc ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e . toString ( ) ) ; } } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( STR_ + s ) ; } modified = BOOL_ ; break ; default : sb . append ( c ) ; i ++ ; break ; } } if ( modified ) { return sb . toString ( ) ; } return s ; }
public ServerControllerTest ( String name ) { super ( name ) ; this . baseDir = System . getProperty ( STR_ ) ; }
@ Override public String encode ( ) { return value == intValue ( ) ? Integer . toString ( intValue ( ) ) + unit . encode ( ) : Double . toString ( value ) + unit . encode ( ) ; }
public HostNameParser ( LexerCore lexer ) { this . lexer = lexer ; lexer . selectLexer ( STR_ ) ; stripAddressScopeZones = Boolean . getBoolean ( STR_ ) ; }
private void loadText ( InputStream is ) { BufferedReader reader ; String line ; if ( is == null ) { throw new Error ( STR_ ) ; } reader = new BufferedReader ( new InputStreamReader ( is ) ) ; try { line = reader . readLine ( ) ; lineCount ++ ; while ( line != null ) { if ( ! line . startsWith ( STR_ ) ) { parseAndAdd ( line , reader ) ; } line = reader . readLine ( ) ; } reader . close ( ) ; } catch ( IOException e ) { throw new Error ( e . getMessage ( ) + STR_ + lineCount ) ; } finally { } }
public void addEmailAdress ( String anEmailAddress ) { if ( mEmails . indexOf ( anEmailAddress ) < NUM_ ) { mEmails . add ( anEmailAddress ) ; } }
public static Instances loadDataset ( String options [ ] , char T ) throws Exception { Instances D = null ; String filename = Utils . getOption ( T , options ) ; if ( filename == null || filename . isEmpty ( ) ) throw new Exception ( STR_ ) ; File file = new File ( filename ) ; if ( ! file . exists ( ) ) throw new Exception ( STR_ + filename ) ; if ( file . isDirectory ( ) ) throw new Exception ( STR_ + filename + STR_ ) ; try { DataSource source = new DataSource ( filename ) ; D = source . getDataSet ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new Exception ( STR_ + filename + STR_ ) ; } return D ; }
private boolean isTypedTimeFullyLegal ( ) { if ( mIs24HourMode ) { int [ ] values = getEnteredTime ( null ) ; return ( values [ NUM_ ] >= NUM_ && values [ NUM_ ] >= NUM_ && values [ NUM_ ] < NUM_ ) ; } else { return ( mTypedTimes . contains ( getAmOrPmKeyCode ( AM ) ) || mTypedTimes . contains ( getAmOrPmKeyCode ( PM ) ) ) ; } }
public void test_groupCommit ( ) throws Exception { final int writeServiceCorePoolSize = NUM_ ; final Properties properties = getProperties ( ) ; properties . setProperty ( TestOptions . TIMEOUT , STR_ ) ; properties . setProperty ( TestOptions . NTASKS , STR_ ) ; properties . setProperty ( Options . WRITE_SERVICE_CORE_POOL_SIZE , STR_ + writeServiceCorePoolSize ) ; properties . setProperty ( Options . WRITE_SERVICE_MAXIMUM_POOL_SIZE , STR_ ) ; properties . setProperty ( Options . WRITE_SERVICE_PRESTART_ALL_CORE_THREADS , STR_ ) ; properties . setProperty ( Options . WRITE_SERVICE_QUEUE_CAPACITY , STR_ ) ; doComparisonTest ( properties ) ; }
@ Override public void operate ( Population pop ) throws Exception { List < Individual > newIndividuals = new LinkedList < Individual > ( ) ; for ( int i = NUM_ ; i < pop . getNumberOfIndividuals ( ) ; i ++ ) { List < Individual > individuals = operate ( pop . get ( i ) ) ; newIndividuals . addAll ( individuals ) ; } pop . clear ( ) ; pop . addAllIndividuals ( newIndividuals ) ; }
public int size ( ) { return encodedNames . size ( ) ; }
public static byte [ ] toSeed ( List < String > words , String passphrase ) { return toSeed ( words , passphrase , Version . V0_6 ) ; }
private ArrayList < Interval > findOrCreateIntervalSet ( Register r ) { ArrayList < Interval > v = map . get ( r ) ; if ( v == null ) { v = new ArrayList < Interval > ( ) ; map . put ( r , v ) ; } return v ; }
protected void removeColumns ( Collection < String > removeColumnNames , String tableName ) { if ( removeColumnNames != null && ! removeColumnNames . isEmpty ( ) ) { execute ( getRemoveColumnSQLs ( removeColumnNames , tableName ) , mDb ) ; } }
public void registerAtmosphere ( IAtmosphere atmosphere ) { atmosphereRegistration . put ( atmosphere . getUnlocalizedName ( ) , atmosphere ) ; atmosphereList . add ( atmosphere ) ; }
public JXSearchField ( ) { this ( STR_ ) ; }
private static void reply_Login2_Role ( body body , MobileSessionCtx wsc , String roleId ) { String form = null ; Login login = new Login ( wsc . ctx ) ; KeyNamePair [ ] clients = login . getClients ( new KeyNamePair ( Integer . parseInt ( roleId ) , roleId ) ) ; StringBuffer script = new StringBuffer ( STR_ ) ; for ( int i = NUM_ ; i < clients . length ; i ++ ) { if ( i > NUM_ ) script . append ( STR_ ) ; KeyNamePair p = clients [ i ] ; script . append ( STR_ ) ; script . append ( p . getName ( ) ) ; script . append ( STR_ ) ; script . append ( p . getKey ( ) ) ; script . append ( STR_ ) ; } script . append ( STR_ ) ; }
public void testCreateDocumentType1 ( ) throws Throwable { Document doc ; DOMImplementation domImpl ; DocumentType newDocType ; Document ownerDocument ; String qualifiedName = STR_ ; String publicId ; String systemId ; List < String > publicIds = new ArrayList < String > ( ) ; publicIds . add ( STR_ ) ; publicIds . add ( STR_ ) ; List < String > systemIds = new ArrayList < String > ( ) ; systemIds . add ( STR_ ) ; systemIds . add ( STR_ ) ; doc = ( Document ) load ( STR_ , builder ) ; domImpl = doc . getImplementation ( ) ; for ( int indexN1005D = NUM_ ; indexN1005D < publicIds . size ( ) ; indexN1005D ++ ) { publicId = ( String ) publicIds . get ( indexN1005D ) ; for ( int indexN10061 = NUM_ ; indexN10061 < systemIds . size ( ) ; indexN10061 ++ ) { systemId = ( String ) systemIds . get ( indexN10061 ) ; newDocType = domImpl . createDocumentType ( qualifiedName , publicId , systemId ) ; assertNotNull ( STR_ , newDocType ) ; ownerDocument = newDocType . getOwnerDocument ( ) ; assertNull ( STR_ , ownerDocument ) ; } } }
public final void run ( ) { if ( m_start == NUM_ ) m_start = System . currentTimeMillis ( ) ; m_canContinue = BOOL_ ; while ( m_canContinue ) { if ( isInterrupted ( ) ) return ; m_lastStart = System . currentTimeMillis ( ) ; m_working = BOOL_ ; try { m_pollCount ++ ; if ( canDoWork ( ) ) { m_canContinue = doWork ( ) ; m_count ++ ; } } catch ( Exception e ) { log . log ( Level . SEVERE , STR_ , e ) ; } m_working = BOOL_ ; long end = System . currentTimeMillis ( ) ; m_time += ( end - m_lastStart ) ; if ( isInterrupted ( ) ) return ; try { log . fine ( STR_ + m_sleepSeconds ) ; sleep ( m_sleepSeconds . NUM_ ) ; } catch ( InterruptedException e1 ) { log . warning ( STR_ + e1 . getLocalizedMessage ( ) ) ; return ; } } }
public static SolrDocument assertSearchOneDoc ( SolrParams p ) throws Exception { SolrDocumentList docs = assertSearch ( p ) ; assertEquals ( STR_ + p . toString ( ) + STR_ + docs . toString ( ) , NUM_ , docs . getNumFound ( ) ) ; assertEquals ( STR_ + p . toString ( ) + STR_ + docs . toString ( ) , NUM_ , docs . size ( ) ) ; return docs . get ( NUM_ ) ; }
private static ValueSource buildSourceTree ( IndexSchema schema , String expression , int sourceType ) { int expressionType = getSourceType ( expression ) ; if ( sourceType != FIELD_TYPE && expressionType != FIELD_TYPE && expressionType != FILTER_TYPE && expressionType != sourceType ) { return null ; } switch ( expressionType ) { case NUMBER_TYPE : return buildNumericSource ( schema , expression ) ; case DATE_TYPE : return buildDateSource ( schema , expression ) ; case STRING_TYPE : return buildStringSource ( schema , expression ) ; case FIELD_TYPE : return buildFieldSource ( schema , expression , sourceType ) ; case FILTER_TYPE : return buildFilterSource ( schema , expression . substring ( expression . indexOf ( STR_ ) + NUM_ , expression . lastIndexOf ( STR_ ) ) , sourceType ) ; default : throw new SolrException ( ErrorCode . BAD_REQUEST , expression + STR_ ) ; } }
public Value predecessor ( ) { return predecessor . get ( ) ; }
public int valueSparseInt ( int indexOfIndex ) throws Exception { return Integer . parseInt ( actualValue ( indexOfIndex ) ) ; }
public void testToEngineeringStringZeroPosExponent ( ) { String a = STR_ ; BigDecimal aNumber = new BigDecimal ( a ) ; String result = STR_ ; assertEquals ( STR_ , result , aNumber . toEngineeringString ( ) ) ; }
public static int scan ( long v ) { return NUM_ - Long . numberOfLeadingZeros ( v ) ; }
public static boolean isAllUpperCase ( String str ) { if ( str == null ) return BOOL_ ; boolean hasLetters = BOOL_ ; char c ; for ( int i = str . length ( ) - NUM_ ; i >= NUM_ ; i -- ) { c = str . charAt ( i ) ; if ( Character . isLetter ( c ) ) { if ( ! Character . isUpperCase ( c ) ) return BOOL_ ; hasLetters = BOOL_ ; } } return hasLetters ; }
public static ClassPath createClassPath ( String classPathString , String sysClassPathString , String extDirsString ) { Path path = new Path ( ) ; if ( sysClassPathString == null ) { sysClassPathString = System . getProperty ( STR_ ) ; } if ( sysClassPathString != null ) { path . addFiles ( sysClassPathString ) ; } path . expandJarClassPaths ( BOOL_ ) ; if ( extDirsString == null ) { extDirsString = System . getProperty ( STR_ ) ; } if ( extDirsString != null ) { path . addDirectories ( extDirsString ) ; } path . emptyPathDefault ( STR_ ) ; if ( classPathString == null ) { classPathString = System . getProperty ( STR_ ) ; if ( classPathString == null ) { classPathString = STR_ ; } } path . addFiles ( classPathString ) ; return new ClassPath ( path . toArray ( new String [ path . size ( ) ] ) ) ; }
protected AbstractSpinedBuffer ( int initialCapacity ) { if ( initialCapacity < NUM_ ) throw new IllegalArgumentException ( STR_ + initialCapacity ) ; this . initialChunkPower = Math . max ( MIN_CHUNK_POWER , Integer . SIZE - Integer . numberOfLeadingZeros ( initialCapacity - NUM_ ) ) ; }
private void cleaningText ( ) { int latinCount = NUM_ , nonLatinCount = NUM_ ; for ( int i = NUM_ ; i < text . length ( ) ; ++ i ) { char c = text . charAt ( i ) ; if ( c <= STR_ && c >= STR_ ) { ++ latinCount ; } else if ( c >= STR_ && UnicodeBlock . of ( c ) != UnicodeBlock . LATIN_EXTENDED_ADDITIONAL ) { ++ nonLatinCount ; } } if ( latinCount . NUM_ < nonLatinCount ) { StringBuffer textWithoutLatin = new StringBuffer ( ) ; for ( int i = NUM_ ; i < text . length ( ) ; ++ i ) { char c = text . charAt ( i ) ; if ( c > STR_ || c < STR_ ) textWithoutLatin . append ( c ) ; } text = textWithoutLatin ; } }
public void beginApplyInterval ( ) { intervalStartMillis = System . currentTimeMillis ( ) ; endMillis = intervalStartMillis ; state = TaskState . apply ; }
void handshake ( ) throws IgniteCheckedException , SSLException { if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + handshakeStatus + STR_ + ses + STR_ ) ; lock ( ) ; try { boolean loop = BOOL_ ; while ( loop ) { switch ( handshakeStatus ) { case NOT_HANDSHAKING : case FINISHED : { SSLSession sslSes = sslEngine . getSession ( ) ; if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + sslSes . getProtocol ( ) + STR_ + sslSes . getCipherSuite ( ) + STR_ + ses + STR_ ) ; handshakeFinished = BOOL_ ; if ( ! initHandshakeComplete ) { initHandshakeComplete = BOOL_ ; GridNioFutureImpl < ? > fut = ses . removeMeta ( HANDSHAKE_FUT_META_KEY ) ; if ( fut != null ) fut . onDone ( ) ; parent . proceedSessionOpened ( ses ) ; } loop = BOOL_ ; break ; } case NEED_TASK : { if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + ses ) ; handshakeStatus = runTasks ( ) ; break ; } case NEED_UNWRAP : { if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + ses ) ; Status status = unwrapHandshake ( ) ; if ( status == BUFFER_UNDERFLOW && handshakeStatus != FINISHED || sslEngine . isInboundDone ( ) ) loop = BOOL_ ; break ; } case NEED_WRAP : { if ( outNetBuf . hasRemaining ( ) ) U . warn ( log , STR_ + ses ) ; outNetBuf . clear ( ) ; SSLEngineResult res = sslEngine . wrap ( handshakeBuf , outNetBuf ) ; outNetBuf . flip ( ) ; handshakeStatus = res . getHandshakeStatus ( ) ; if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + res . getStatus ( ) + STR_ + handshakeStatus + STR_ + ses + STR_ ) ; writeNetBuffer ( ) ; break ; } default : { throw new IllegalStateException ( STR_ + handshakeStatus + STR_ + ses + STR_ ) ; } } } } finally { unlock ( ) ; } if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + handshakeStatus + STR_ + ses + STR_ ) ; }
public void sendMessages ( List < ProducerRecord < String , String > > records ) { Producer < String , String > producer = new KafkaProducer < > ( getProducerConfig ( ) ) ; for ( ProducerRecord < String , String > rec : records ) producer . send ( rec ) ; producer . flush ( ) ; producer . close ( ) ; }
private static JFreeChart createChart ( ) { XYSeries series1 = new XYSeries ( STR_ ) ; series1 . add ( NUM_ , NUM_ ) ; series1 . add ( NUM_ , NUM_ ) ; series1 . add ( NUM_ , NUM_ ) ; XYDataset dataset = new XYSeriesCollection ( series1 ) ; return ChartFactory . createXYStepChart ( STR_ , STR_ , STR_ , dataset , PlotOrientation . VERTICAL , BOOL_ , BOOL_ , BOOL_ ) ; }
public void appendToNalUnit ( byte [ ] data , int offset , int limit ) { if ( ! isFilling ) { return ; } int readLength = limit - offset ; if ( nalData . length < nalLength + readLength ) { nalData = Arrays . copyOf ( nalData , ( nalLength + readLength ) . NUM_ ) ; } System . arraycopy ( data , offset , nalData , nalLength , readLength ) ; nalLength += readLength ; }
public boolean isNumberGeographical ( PhoneNumber phoneNumber ) { return isNumberGeographical ( getNumberType ( phoneNumber ) , phoneNumber . getCountryCode ( ) ) ; }
protected final void refreshLoadingViewsSize ( ) { final int maximumPullScroll = ( int ) ( getMaximumPullScroll ( ) . NUM_ ) ; int pLeft = getPaddingLeft ( ) ; int pTop = getPaddingTop ( ) ; int pRight = getPaddingRight ( ) ; int pBottom = getPaddingBottom ( ) ; switch ( getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setWidth ( maximumPullScroll ) ; pLeft = - maximumPullScroll ; } else { pLeft = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setWidth ( maximumPullScroll ) ; pRight = - maximumPullScroll ; } else { pRight = NUM_ ; } break ; case VERTICAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setHeight ( maximumPullScroll ) ; pTop = - maximumPullScroll ; } else { pTop = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setHeight ( maximumPullScroll ) ; pBottom = - maximumPullScroll ; } else { pBottom = NUM_ ; } break ; } if ( DEBUG ) { Log . d ( LOG_TAG , String . format ( STR_ , pLeft , pTop , pRight , pBottom ) ) ; } setPadding ( pLeft , pTop , pRight , pBottom ) ; }
protected int weightedDistribution ( int [ ] weights ) { int sum = NUM_ ; for ( int weight : weights ) { sum += weight ; } int val = ( int ) Math . floor ( m_random . nextDouble ( ) . sum ) ; for ( int i = NUM_ ; i < weights . length ; i ++ ) { val -= weights [ i ] ; if ( val < NUM_ ) { return i ; } } return - NUM_ ; }
protected String cleanUp ( String classname ) { String result ; result = classname ; if ( result . indexOf ( STR_ ) > - NUM_ ) { result = result . replace ( STR_ , STR_ ) ; } if ( result . indexOf ( STR_ ) > - NUM_ ) { result = result . replace ( STR_ , STR_ ) ; } if ( result . endsWith ( STR_ ) ) { result = result . substring ( NUM_ , result . length ( ) - NUM_ ) ; } return result ; }
public static boolean isAssignable ( Class targetType , Class valueType ) { Assert . notNull ( targetType , STR_ ) ; Assert . notNull ( valueType , STR_ ) ; return ( targetType . isAssignableFrom ( valueType ) || targetType . equals ( primitiveWrapperTypeMap . get ( valueType ) ) ) ; }
public DialogCheckBox addDialogCheckBox ( String description , String labelText , boolean initialState ) { String [ ] args = new String [ NUM_ ] ; args [ NUM_ ] = STR_ ; args [ NUM_ ] = description ; args [ NUM_ ] = labelText ; args [ NUM_ ] = Boolean . toString ( initialState ) ; DialogCheckBox dcb = new DialogCheckBox ( ) ; dcb . setArgs ( args ) ; components . add ( dcb ) ; mainPanel . add ( dcb ) ; return dcb ; }
private void performRestore ( File memberDir , File backupDir ) throws Exception { List < File > ifFiles = FileUtil . findAll ( memberDir , STR_ ) ; for ( File file : ifFiles ) { file . delete ( ) ; } List < File > oplogs = FileUtil . findAll ( memberDir , OPLOG_REGEX ) ; for ( File file : oplogs ) { file . delete ( ) ; } File restoreScript = new File ( backupDir , STR_ ) ; if ( ! restoreScript . exists ( ) ) { restoreScript = new File ( backupDir , STR_ ) ; } assertTrue ( restoreScript . exists ( ) ) ; assertEquals ( NUM_ , execute ( restoreScript . getAbsolutePath ( ) ) ) ; }
public static boolean downloadUrlToStream ( String urlString , OutputStream outputStream ) { disableConnectionReuseIfNecessary ( ) ; HttpURLConnection urlConnection = null ; BufferedOutputStream out = null ; BufferedInputStream in = null ; try { final URL url = new URL ( urlString ) ; urlConnection = ( HttpURLConnection ) url . openConnection ( ) ; in = new BufferedInputStream ( urlConnection . getInputStream ( ) , IO_BUFFER_SIZE ) ; out = new BufferedOutputStream ( outputStream , IO_BUFFER_SIZE ) ; int b ; while ( ( b = in . read ( ) ) != - NUM_ ) { out . write ( b ) ; } return BOOL_ ; } catch ( final IOException e ) { Log . e ( TAG , STR_ + e ) ; } finally { if ( urlConnection != null ) { urlConnection . disconnect ( ) ; } try { if ( out != null ) { out . close ( ) ; } if ( in != null ) { in . close ( ) ; } } catch ( final IOException e ) { } } return BOOL_ ; }
public boolean isPaymentsAdequate ( ) { return isPaymentsAdequate ( this . cart ) ; }
@ Override public void transactionCommited ( final long commitTime ) { if ( listeners . isEmpty ( ) ) { records . reset ( ) ; } else { records . flush ( ) ; listeners . forEach ( null ) ; } }
public static MWarehousePrice [ ] find ( MBPartner bPartner , boolean IsSOTrx , Timestamp valid , int M_Warehouse_ID , String Value , String Name , String UPC , String SKU , String trxName ) { int M_PriceList_ID = IsSOTrx ? bPartner . getM_PriceList_ID ( ) : bPartner . getPO_PriceList_ID ( ) ; MPriceList pl = null ; if ( M_PriceList_ID == NUM_ ) pl = MPriceList . getDefault ( bPartner . getCtx ( ) , IsSOTrx ) ; else pl = MPriceList . get ( bPartner . getCtx ( ) , M_PriceList_ID , trxName ) ; if ( pl == null ) { s_log . severe ( STR_ ) ; return null ; } MPriceListVersion plv = pl . getPriceListVersion ( valid ) ; if ( plv == null ) { s_log . severe ( STR_ + pl . getM_PriceList_ID ( ) ) ; return null ; } return find ( bPartner . getCtx ( ) , plv . getM_PriceList_Version_ID ( ) , M_Warehouse_ID , Value , Name , UPC , SKU , trxName ) ; }
private void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { COUNTER = new AtomicInteger ( ) ; serializers = new HashMap < Class , SerializerWrapper > ( ) ; serializersArray = new Serializer [ NUM_ ] ; deserialize ( in , this ) ; }
public static Date translateTime ( Date date , TimeZone src , TimeZone dest ) { Date newDate = new Date ( ) ; int offset = ( dest . getOffset ( date . getTime ( ) ) - src . getOffset ( date . getTime ( ) ) ) ; newDate . setTime ( date . getTime ( ) - offset ) ; return newDate ; }
private void showPopupMenu ( final MouseEvent event ) { final CTracesTableFilterMenu menu = new CTracesTableFilterMenu ( getFilterField ( ) ) ; menu . show ( event . getComponent ( ) , event . getX ( ) , event . getY ( ) ) ; }
private TaskResourceRep finishDeactivateTask ( BlockConsistencyGroup consistencyGroup , String task ) { URI id = consistencyGroup . getId ( ) ; Operation op = new Operation ( ) ; op . ready ( ) ; op . setProgress ( NUM_ ) ; op . setResourceType ( ResourceOperationTypeEnum . DELETE_CONSISTENCY_GROUP ) ; Operation status = _dbClient . createTaskOpStatus ( BlockConsistencyGroup . class , id , task , op ) ; return toTask ( consistencyGroup , task , status ) ; }
public static Severity parseSeverity ( String str ) throws IllegalSeverityException { if ( str . equalsIgnoreCase ( Messages . ERROR ) ) { return ERROR ; } else if ( str . equalsIgnoreCase ( Messages . WARNING ) ) { return WARNING ; } else { throw new IllegalSeverityException ( ) ; } }
private void restoreFromKeypress ( final KeyEvent keyEvent , final int keyNumber ) { if ( keyEvent . isAltDown ( ) ) { final int arrayIndex = ( keyNumber > NUM_ ? keyNumber : MAX_RECENT_MESSAGES ) - NUM_ ; if ( arrayIndex < recentMessages . size ( ) ) { displayMessage ( recentMessages . get ( arrayIndex ) ) ; } keyEvent . consume ( ) ; } }
public void removeScrollingListener ( OnWheelScrollListener listener ) { scrollingListeners . remove ( listener ) ; }
public void fire ( Session session , int type , boolean beforeAction ) { if ( rowBased || before != beforeAction || ( typeMask & type ) == NUM_ ) { return ; } load ( ) ; Connection c2 = session . createConnection ( BOOL_ ) ; boolean old = BOOL_ ; if ( type != Trigger . SELECT ) { old = session . setCommitOrRollbackDisabled ( BOOL_ ) ; } Value identity = session . getLastScopeIdentity ( ) ; try { triggerCallback . fire ( c2 , null , null ) ; } catch ( Throwable e ) { throw DbException . get ( ErrorCode . ERROR_EXECUTING_TRIGGER_3 , e , getName ( ) , triggerClassName != null ? triggerClassName : STR_ , e . toString ( ) ) ; } finally { if ( session . getLastTriggerIdentity ( ) != null ) { session . setLastScopeIdentity ( session . getLastTriggerIdentity ( ) ) ; session . setLastTriggerIdentity ( null ) ; } else { session . setLastScopeIdentity ( identity ) ; } if ( type != Trigger . SELECT ) { session . setCommitOrRollbackDisabled ( old ) ; } } }
public static void closeQuietly ( Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( RuntimeException rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } }
public MqttDevice mqttDevice ( ) { return mqttDevice ; }
public boolean skipsLocation ( String locationId ) { return _skipLocationsList . contains ( locationId ) ; }
private List < Race > parseRaces ( String json ) { List < Race > result = new ArrayList < > ( ) ; if ( json == null ) { return null ; } JSONParser parser = new JSONParser ( ) ; try { JSONObject root = ( JSONObject ) parser . parse ( json . trim ( ) ) ; JSONArray races = ( JSONArray ) root . get ( STR_ ) ; for ( Object o : races ) { if ( o instanceof JSONObject ) { Race race = parseRace ( ( JSONObject ) o ) ; if ( race != null ) { result . add ( race ) ; } } } } catch ( ParseException | ClassCastException | NullPointerException ex ) { LOGGER . warning ( STR_ + ex ) ; return null ; } return result ; }
public boolean isConnected ( short nodeId ) { NodeConnection nc = connections . get ( nodeId ) ; return ( nc != null && nc . state == NodeConnectionState . CONNECTED ) ; }
public ObjectName manageSystemMember ( DistributedMember distributedMember ) throws AdminException , MalformedObjectNameException { try { SystemMember member = lookupSystemMember ( distributedMember ) ; if ( member == null ) return null ; SystemMemberJmxImpl jmx = ( SystemMemberJmxImpl ) member ; ObjectName oname = new ObjectName ( jmx . getMBeanName ( ) ) ; return oname ; } catch ( AdminException e ) { logger . warn ( e . getMessage ( ) , e ) ; throw e ; } catch ( RuntimeException e ) { logger . warn ( e . getMessage ( ) , e ) ; throw e ; } catch ( VirtualMachineError err ) { SystemFailure . initiateFailure ( err ) ; throw err ; } catch ( Error e ) { SystemFailure . checkFailure ( ) ; logger . error ( e . getMessage ( ) , e ) ; throw e ; } }
private void connect ( ) throws IOException { JMXServiceURL jmxUrl = new JMXServiceURL ( String . format ( fmtUrl , host , port ) ) ; jmxc = JMXConnectorFactory . connect ( jmxUrl , null ) ; MBeanServerConnection mbeanServerConn = jmxc . getMBeanServerConnection ( ) ; try { ObjectName name = new ObjectName ( DOMAINLIST_OBJECT_NAME ) ; domainListProxy = MBeanServerInvocationHandler . newProxyInstance ( mbeanServerConn , name , DomainListManagementMBean . class , BOOL_ ) ; name = new ObjectName ( VIRTUALUSERTABLE_OBJECT_NAME ) ; virtualUserTableProxy = MBeanServerInvocationHandler . newProxyInstance ( mbeanServerConn , name , RecipientRewriteTableManagementMBean . class , BOOL_ ) ; name = new ObjectName ( USERSREPOSITORY_OBJECT_NAME ) ; usersRepositoryProxy = MBeanServerInvocationHandler . newProxyInstance ( mbeanServerConn , name , UsersRepositoryManagementMBean . class , BOOL_ ) ; name = new ObjectName ( MAILBOXCOPIER_OBJECT_NAME ) ; mailboxCopierManagement = MBeanServerInvocationHandler . newProxyInstance ( mbeanServerConn , name , MailboxCopierManagementMBean . class , BOOL_ ) ; name = new ObjectName ( MAILBOXMANAGER_OBJECT_NAME ) ; mailboxManagerManagement = MBeanServerInvocationHandler . newProxyInstance ( mbeanServerConn , name , MailboxManagerManagementMBean . class , BOOL_ ) ; name = new ObjectName ( QUOTAMANAGER_OBJECT_NAME ) ; quotaManagement = MBeanServerInvocationHandler . newProxyInstance ( mbeanServerConn , name , QuotaManagementMBean . class , BOOL_ ) ; name = new ObjectName ( REINDEXER_OBJECT_NAME ) ; reIndexerManagement = MBeanServerInvocationHandler . newProxyInstance ( mbeanServerConn , name , ReIndexerManagementMBean . class , BOOL_ ) ; name = new ObjectName ( SIEVEMANAGER_OBJECT_NAME ) ; sieveRepositoryManagement = MBeanServerInvocationHandler . newProxyInstance ( mbeanServerConn , name , SieveRepositoryManagementMBean . class , BOOL_ ) ; } catch ( MalformedObjectNameException e ) { throw new RuntimeException ( STR_ , e ) ; } }
public static void show ( @ NotNull final JComponent dataComponent , @ Nullable final JComponent actionListenerComponent , @ NotNull final String title , @ NotNull final Project project , @ Nullable final Collection < Runnable > closeListeners , @ NotNull final AnAction ... customActions ) { final ToolWindowApi api = new ToolWindowApi ( project , title ) ; final Collection < Runnable > closeListenersToAdd = new ArrayList < Runnable > ( Collections . singleton ( new MyToolWindowCloser ( api ) ) ) ; if ( closeListeners != null ) { closeListenersToAdd . addAll ( closeListeners ) ; } api . add ( PanelWithActions . wrap ( dataComponent , closeListenersToAdd , actionListenerComponent , customActions ) ) ; }
public IntentBuilder addEmailCc ( String address ) { if ( mCcAddresses == null ) { mCcAddresses = new ArrayList < String > ( ) ; } mCcAddresses . add ( address ) ; return this ; }
private ArrayList < String > extractNGrams ( ) { ArrayList < String > list = new ArrayList < String > ( ) ; NGram ngram = new NGram ( ) ; for ( int i = NUM_ ; i < text . length ( ) ; ++ i ) { ngram . addChar ( text . charAt ( i ) ) ; for ( int n = NUM_ ; n <= NGram . N_GRAM ; ++ n ) { String w = ngram . get ( n ) ; if ( w != null && wordLangProbMap . containsKey ( w ) ) list . add ( w ) ; } } return list ; }
protected void updateKeys ( ) { ButtonInfo [ ] buttons = NavigationButtons . loadButtonMap ( mContext ) ; int visibleCount = NUM_ ; for ( int i = NUM_ ; i < buttons . length ; i ++ ) { int id = BUTTON_IDS [ i ] ; ButtonInfo info = buttons [ mVertical ? buttons . length - i - NUM_ : i ] ; KeyButtonView button = ( KeyButtonView ) mParent . findViewById ( id ) ; boolean isSmallButton = NavigationButtons . IS_SLOT_SMALL [ i ] ; button . setInfo ( info , mVertical , isSmallButton ) ; if ( ! info . equals ( NavigationButtons . EMPTY ) && ! isSmallButton ) { visibleCount ++ ; } button . setTranslationX ( NUM_ ) ; mButtonViews . set ( i , button ) ; } if ( isDevicePhone ( mContext ) ) { adjustPadding ( visibleCount ) ; } updateLowLights ( visibleCount ) ; }
public static final String readString ( byte [ ] bytes , String charset ) throws IOException { return readString ( bytes , NUM_ , bytes . length , Charset . forName ( charset ) ) ; }
private void updateCommandCache ( String group , String command , boolean needNotify ) { String oldCommand = commandCache . get ( group ) ; if ( ! command . equals ( oldCommand ) ) { commandCache . put ( group , command ) ; if ( needNotify ) { notifyExecutor . execute ( new NotifyCommand ( group , command ) ) ; LoggerUtil . info ( String . format ( STR_ , group , command ) ) ; } } else { LoggerUtil . info ( String . format ( STR_ , group , command ) ) ; } }
public void updateLanguage ( ) { createLegendPanel ( legendPanel ) ; directoryTreeModel . changeRootText ( I18n . tr ( STR_ ) ) ; }
private synchronized void rebuildJournal ( ) throws IOException { if ( journalWriter != null ) { journalWriter . close ( ) ; } Writer writer = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( journalFileTmp ) , Util . US_ASCII ) ) ; try { writer . write ( MAGIC ) ; writer . write ( STR_ ) ; writer . write ( VERSION_1 ) ; writer . write ( STR_ ) ; writer . write ( Integer . toString ( appVersion ) ) ; writer . write ( STR_ ) ; writer . write ( Integer . toString ( valueCount ) ) ; writer . write ( STR_ ) ; writer . write ( STR_ ) ; for ( Entry entry : lruEntries . values ( ) ) { if ( entry . currentEditor != null ) { writer . write ( DIRTY + STR_ + entry . key + STR_ ) ; } else { writer . write ( CLEAN + STR_ + entry . key + entry . getLengths ( ) + STR_ ) ; } } } finally { writer . close ( ) ; } if ( journalFile . exists ( ) ) { renameTo ( journalFile , journalFileBackup , BOOL_ ) ; } renameTo ( journalFileTmp , journalFile , BOOL_ ) ; journalFileBackup . delete ( ) ; journalWriter = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( journalFile , BOOL_ ) , Util . US_ASCII ) ) ; }
public static byte [ ] decompressForZlib ( byte [ ] bytesToDecompress ) { byte [ ] returnValues = null ; Inflater inflater = new Inflater ( ) ; int numberOfBytesToDecompress = bytesToDecompress . length ; inflater . setInput ( bytesToDecompress , NUM_ , numberOfBytesToDecompress ) ; int bufferSizeInBytes = numberOfBytesToDecompress ; int numberOfBytesDecompressedSoFar = NUM_ ; List < Byte > bytesDecompressedSoFar = new ArrayList < Byte > ( ) ; try { while ( inflater . needsInput ( ) == BOOL_ ) { byte [ ] bytesDecompressedBuffer = new byte [ bufferSizeInBytes ] ; int numberOfBytesDecompressedThisTime = inflater . inflate ( bytesDecompressedBuffer ) ; numberOfBytesDecompressedSoFar += numberOfBytesDecompressedThisTime ; for ( int b = NUM_ ; b < numberOfBytesDecompressedThisTime ; b ++ ) { bytesDecompressedSoFar . add ( bytesDecompressedBuffer [ b ] ) ; } } returnValues = new byte [ bytesDecompressedSoFar . size ( ) ] ; for ( int b = NUM_ ; b < returnValues . length ; b ++ ) { returnValues [ b ] = ( byte ) ( bytesDecompressedSoFar . get ( b ) ) ; } } catch ( DataFormatException dfe ) { dfe . printStackTrace ( ) ; } inflater . end ( ) ; return returnValues ; }
protected boolean acceptChunk ( final IChunkMessage < IBindingSet > msg ) { if ( msg == null ) throw new IllegalArgumentException ( ) ; if ( ! msg . isMaterialized ( ) ) throw new IllegalStateException ( ) ; final AbstractRunningQuery q = getRunningQuery ( msg . getQueryId ( ) ) ; if ( q == null ) { throw new IllegalStateException ( ) ; } if ( ! q . acceptChunk ( msg ) ) { msg . release ( ) ; return BOOL_ ; } if ( ! isRunning ( ) ) { msg . release ( ) ; return BOOL_ ; } priorityQueue . add ( q ) ; return BOOL_ ; }
public String format ( Object obj , StringBuffer toAppendTo ) throws IllegalArgumentException { return format ( ( Date ) obj , toAppendTo ) ; }
void addMember ( final TypeMember member ) { Preconditions . checkNotNull ( member , STR_ ) ; Preconditions . checkArgument ( member . getParentType ( ) == this , STR_ ) ; members . add ( member ) ; }
public synchronized void removeIncrementalClassifierListener ( IncrementalClassifierListener cl ) { m_incrementalClassifierListeners . remove ( cl ) ; }
public static boolean cancelPotentialWork ( Object data , ImageView imageView ) { final BitmapWorkerTask bitmapWorkerTask = getBitmapWorkerTask ( imageView ) ; if ( bitmapWorkerTask != null ) { final Object bitmapData = bitmapWorkerTask . mData ; if ( bitmapData == null || ! bitmapData . equals ( data ) ) { bitmapWorkerTask . cancel ( BOOL_ ) ; if ( BuildConfig . DEBUG ) { Log . d ( TAG , STR_ + data ) ; } } else { return BOOL_ ; } } return BOOL_ ; }
public static Number asinh ( Number a ) { return FastMath . asinh ( a . doubleValue ( ) ) ; }
private String formatNames ( String [ ] names , int startIndex ) { StringBuilder sb = new StringBuilder ( ) ; if ( names != null ) { for ( String name : names ) { sb . append ( name . substring ( startIndex ) ) ; sb . append ( STR_ ) ; } } return sb . toString ( ) ; }
public String lookupPrefix ( String uri ) { String foundPrefix = null ; Enumeration prefixes = m_namespaces . keys ( ) ; while ( prefixes . hasMoreElements ( ) ) { String prefix = ( String ) prefixes . nextElement ( ) ; String uri2 = lookupNamespace ( prefix ) ; if ( uri2 != null && uri2 . equals ( uri ) ) { foundPrefix = prefix ; break ; } } return foundPrefix ; }
public void removeAllTrailers ( ) { trailer . clear ( ) ; firePropertyChange ( TRAILER , null , trailer ) ; }
public Builder clear ( ) { localeBuilder . clear ( ) ; return this ; }
private static boolean versionMatches ( Integer v1 , Integer v2 ) { if ( v1 == null || v1 == NUM_ || v2 == null || v2 == NUM_ ) { return BOOL_ ; } return v1 . equals ( v2 ) ; }
public static Optional < String > packageName ( String longName ) { if ( longName . contains ( DOT ) ) { return Optional . of ( longName . substring ( NUM_ , longName . lastIndexOf ( DOT ) ) ) ; } else { return Optional . empty ( ) ; } }
public int [ ] [ ] e2f ( ) { int eDim = tgtEndExclusive - tgtStartInclusive ; int [ ] [ ] e2f = new int [ eDim ] [ ] ; for ( int i = tgtStartInclusive ; i < tgtEndExclusive ; ++ i ) { int localIdx = i - tgtStartInclusive ; int [ ] e2fI = sentencePair . e2f ( i ) ; int srcAlignDim = e2fI . length ; e2f [ localIdx ] = new int [ srcAlignDim ] ; if ( srcAlignDim > NUM_ ) { System . arraycopy ( e2fI , NUM_ , e2f [ localIdx ] , NUM_ , srcAlignDim ) ; for ( int j = NUM_ ; j < srcAlignDim ; ++ j ) { e2f [ localIdx ] [ j ] -= srcStartInclusive ; } } } return e2f ; }
public void readExif ( String inFileName ) throws FileNotFoundException , IOException { if ( inFileName == null ) { throw new IllegalArgumentException ( NULL_ARGUMENT_STRING ) ; } InputStream is = null ; try { is = ( InputStream ) new BufferedInputStream ( new FileInputStream ( inFileName ) ) ; readExif ( is ) ; } catch ( IOException e ) { closeSilently ( is ) ; throw e ; } is . close ( ) ; }
private void assertWriteResult ( int size ) throws IOException { ByteBuffer buf = ByteBuffer . allocate ( size + NUM_ ) ; int count = NUM_ ; int total = NUM_ ; long beginTime = System . currentTimeMillis ( ) ; while ( ( count = clientChannel . read ( buf ) ) != - NUM_ ) { total = total + count ; if ( System . currentTimeMillis ( ) - beginTime > NUM_ ) { break ; } } assertEquals ( total , size ) ; buf . flip ( ) ; for ( int i = NUM_ ; i < count ; i ++ ) { assertEquals ( ( byte ) i , buf . get ( i ) ) ; } }
public static boolean isFileUploadAvailable ( final boolean needsCorrectMimeType ) { if ( Build . VERSION . SDK_INT == NUM_ ) { final String platformVersion = ( Build . VERSION . RELEASE == null ) ? STR_ : Build . VERSION . RELEASE ; return ! needsCorrectMimeType && ( platformVersion . startsWith ( STR_ ) || platformVersion . startsWith ( STR_ ) ) ; } else { return BOOL_ ; } }
@ Override public String toString ( ) { if ( m_bGenerateNet ) { return toXMLBIF03 ( ) ; } return m_Instances . toString ( ) ; }
private boolean menuItemAction ( int screenX , int screenY , int action ) { ListView listView = mAppMenu . getPopup ( ) . getListView ( ) ; ArrayList < View > itemViews = new ArrayList < View > ( ) ; for ( int i = NUM_ ; i < listView . getChildCount ( ) ; ++ i ) { boolean hasImageButtons = BOOL_ ; if ( listView . getChildAt ( i ) instanceof LinearLayout ) { LinearLayout layout = ( LinearLayout ) listView . getChildAt ( i ) ; for ( int j = NUM_ ; j < layout . getChildCount ( ) ; ++ j ) { itemViews . add ( layout . getChildAt ( j ) ) ; if ( layout . getChildAt ( j ) instanceof ImageButton ) hasImageButtons = BOOL_ ; } } if ( ! hasImageButtons ) itemViews . add ( listView . getChildAt ( i ) ) ; } boolean didPerformClick = BOOL_ ; for ( int i = NUM_ ; i < itemViews . size ( ) ; ++ i ) { View itemView = itemViews . get ( i ) ; boolean shouldPerform = itemView . isEnabled ( ) && itemView . isShown ( ) && getScreenVisibleRect ( itemView ) . contains ( screenX , screenY ) ; switch ( action ) { case ITEM_ACTION_HIGHLIGHT : itemView . setPressed ( shouldPerform ) ; break ; case ITEM_ACTION_PERFORM : if ( shouldPerform ) { itemView . performClick ( ) ; didPerformClick = BOOL_ ; } break ; case ITEM_ACTION_CLEAR_HIGHLIGHT_ALL : itemView . setPressed ( BOOL_ ) ; break ; default : assert BOOL_ ; break ; } } return didPerformClick ; }
public void toggle ( JFXDrawer drawer ) { if ( ! drawers . contains ( drawer ) ) addDrawer ( drawer ) ; if ( drawer . isShown ( ) || drawer . isShowing ( ) ) drawer . close ( ) ; else { updateDrawerPosition ( drawer ) ; drawer . open ( ) ; } }
public static boolean isVMwareVapp ( ) { if ( isVMwareVapp != null ) { log . info ( STR_ , isVMwareVapp . booleanValue ( ) ) ; return isVMwareVapp . booleanValue ( ) ; } final String [ ] cmd = { GET_OVF_PROPERTY_CMD , IS_VAPP } ; Exec . Result result = Exec . sudo ( CMD_TIMEOUT , cmd ) ; if ( ! result . exitedNormally ( ) ) { log . error ( STR_ , result . getStdError ( ) ) ; throw new IllegalStateException ( STR_ ) ; } if ( result . getExitValue ( ) == NUM_ ) { log . info ( STR_ ) ; isVMwareVapp = Boolean . TRUE ; return isVMwareVapp . booleanValue ( ) ; } log . info ( STR_ , result . getExitValue ( ) ) ; isVMwareVapp = Boolean . FALSE ; return isVMwareVapp . booleanValue ( ) ; }
protected String toBase64 ( byte [ ] data ) { return Base64 . encodeToString ( data , Base64 . DEFAULT ) ; }
@ Override public String toVerboseString ( ) { final StringBuilder sb = new StringBuilder ( ) ; print ( sb , NUM_ , Verbosity . LOG_WITH_STACKTRACE ) ; return sb . toString ( ) ; }
public static long quantile ( long [ ] values , double quantile ) { if ( values == null ) throw new IllegalArgumentException ( STR_ ) ; if ( quantile < NUM_ || quantile > NUM_ ) throw new IllegalArgumentException ( STR_ ) ; long [ ] copy = new long [ values . length ] ; System . arraycopy ( values , NUM_ , copy , NUM_ , copy . length ) ; Arrays . sort ( copy ) ; int index = ( int ) ( copy . length . quantile ) ; return copy [ index ] ; }
public void addTreeUpdate ( SLDTreeUpdatedInterface sldTree ) { treeUpdateList . add ( sldTree ) ; }
public static double distance ( VisualItem vi1 , VisualItem vi2 ) { double dx = vi1 . getX ( ) - vi2 . getX ( ) ; double dy = vi1 . getY ( ) - vi2 . getY ( ) ; return Math . sqrt ( dx . dx + dy . dy ) ; }
@ Override public void validateRequest ( GenericAttributeResolveRequest request ) throws BadAttributeResolveRequestException { if ( LOG . isDebugEnabled ( ) ) LOG . debug ( STR_ ) ; String siteId = request . getSite ( ) ; if ( null == siteId ) throw new BadAttributeResolveRequestException ( HDFSResourceConstants . HDFS_RESOURCE_RESOLVE_FORMAT_HINT ) ; String filePath = request . getQuery ( ) ; if ( null == filePath || ! filePath . startsWith ( STR_ ) ) throw new BadAttributeResolveRequestException ( HDFSResourceConstants . HDFS_RESOURCE_RESOLVE_FORMAT_HINT ) ; if ( LOG . isDebugEnabled ( ) ) LOG . debug ( STR_ ) ; }
public void clear ( ) { oredCriteria . clear ( ) ; orderByClause = null ; distinct = BOOL_ ; }
public Trigger when ( Criterion criterion ) { if ( criterion != null ) { criterions . add ( criterion ) ; } return this ; }
private static Pair < String , String > offsetROR ( final long offset , final ITranslationEnvironment environment , final List < ReilInstruction > instructions , final String registerNodeValue1 , final String registerNodeValue2 , final String immediateNodeValue ) { final String address = environment . getNextVariableString ( ) ; final String index = environment . getNextVariableString ( ) ; final String tmpVar = environment . getNextVariableString ( ) ; final String tmpVar1 = environment . getNextVariableString ( ) ; final String tmpVar2 = environment . getNextVariableString ( ) ; final String tmpVar3 = environment . getNextVariableString ( ) ; long baseOffset = offset ; instructions . add ( ReilHelpers . createBsh ( baseOffset ++ , dw , registerNodeValue2 , dw , STR_ + Integer . decode ( immediateNodeValue ) , dw , tmpVar1 ) ) ; instructions . add ( ReilHelpers . createBsh ( baseOffset ++ , dw , registerNodeValue2 , dw , String . valueOf ( NUM_ - Integer . decode ( immediateNodeValue ) ) , dw , tmpVar2 ) ) ; instructions . add ( ReilHelpers . createOr ( baseOffset ++ , dw , tmpVar1 , dw , tmpVar2 , dw , tmpVar3 ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , dw , tmpVar3 , dw , dWordBitMask , dw , index ) ) ; instructions . add ( ReilHelpers . createAdd ( baseOffset ++ , dw , registerNodeValue1 , dw , index , dw , tmpVar ) ) ; instructions . add ( ReilHelpers . createAnd ( baseOffset ++ , dw , tmpVar , dw , dWordBitMask , dw , address ) ) ; return new Pair < String , String > ( address , registerNodeValue1 ) ; }
public void clear ( ) { m_ReadMethods . clear ( ) ; m_WriteMethods . clear ( ) ; try { addMethods ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
public static String join ( CharSequence delimiter , Object [ ] tokens ) { StringBuilder sb = new StringBuilder ( ) ; boolean firstTime = BOOL_ ; for ( Object token : tokens ) { if ( firstTime ) { firstTime = BOOL_ ; } else { sb . append ( delimiter ) ; } sb . append ( token ) ; } return sb . toString ( ) ; }
private void fillIn ( ClassSymbol c ) { if ( completionFailureName == c . fullname ) { throw new CompletionFailure ( c , STR_ ) ; } currentOwner = c ; warnedAttrs . clear ( ) ; JavaFileObject classfile = c . classfile ; if ( classfile != null ) { JavaFileObject previousClassFile = currentClassFile ; try { if ( filling ) { Assert . error ( STR_ + classfile . toUri ( ) + STR_ + previousClassFile ) ; } currentClassFile = classfile ; if ( verbose ) { log . printVerbose ( STR_ , currentClassFile . toString ( ) ) ; } if ( classfile . getKind ( ) == JavaFileObject . Kind . CLASS ) { filling = BOOL_ ; try { bp = NUM_ ; buf = readInputStream ( buf , classfile . openInputStream ( ) ) ; readClassFile ( c ) ; if ( ! missingTypeVariables . isEmpty ( ) && ! foundTypeVariables . isEmpty ( ) ) { List < Type > missing = missingTypeVariables ; List < Type > found = foundTypeVariables ; missingTypeVariables = List . nil ( ) ; foundTypeVariables = List . nil ( ) ; filling = BOOL_ ; ClassType ct = ( ClassType ) currentOwner . type ; ct . supertype_field = types . subst ( ct . supertype_field , missing , found ) ; ct . interfaces_field = types . subst ( ct . interfaces_field , missing , found ) ; } else if ( missingTypeVariables . isEmpty ( ) != foundTypeVariables . isEmpty ( ) ) { Name name = missingTypeVariables . head . tsym . name ; throw badClassFile ( STR_ , name ) ; } } finally { missingTypeVariables = List . nil ( ) ; foundTypeVariables = List . nil ( ) ; filling = BOOL_ ; } } else { if ( sourceCompleter != null ) { sourceCompleter . complete ( c ) ; } else { throw new IllegalStateException ( STR_ + classfile . toUri ( ) ) ; } } return ; } catch ( IOException ex ) { throw badClassFile ( STR_ , ex . getMessage ( ) ) ; } finally { currentClassFile = previousClassFile ; } } else { JCDiagnostic diag = diagFactory . fragment ( STR_ , c . flatname ) ; throw newCompletionFailure ( c , diag ) ; } }
public static Packet toPacket ( ByteBuffer data ) { final byte code = data . get ( ) ; final short id = ( short ) ( ( data . get ( ) ) & xFF ) ; final short datalen = data . getShort ( ) ; final byte [ ] authData = new byte [ NUM_ ] ; data . get ( authData ) ; final PacketType type = PacketType . getPacketType ( code ) ; Packet pkt = null ; switch ( type ) { case ACCESS_ACCEPT : pkt = new AccessAccept ( ) ; pkt . setAuthenticator ( new ResponseAuthenticator ( authData ) ) ; break ; case ACCESS_CHALLENGE : pkt = new AccessChallenge ( ) ; pkt . setAuthenticator ( new ResponseAuthenticator ( authData ) ) ; break ; case ACCESS_REJECT : pkt = new AccessReject ( ) ; pkt . setAuthenticator ( new ResponseAuthenticator ( authData ) ) ; break ; case ACCESS_REQUEST : pkt = new AccessRequest ( ) ; pkt . setAuthenticator ( new RequestAuthenticator ( authData ) ) ; break ; case UNKNOWN : default : LOG . log ( Level . WARNING , STR_ + code + STR_ ) ; return null ; } pkt . setIdentifier ( id ) ; Attribute a = null ; while ( ( a = PacketFactory . nextAttribute ( data ) ) != null ) { pkt . addAttribute ( a ) ; } return pkt ; }
public void unlockReadLocks ( ) { if ( database . isMultiVersion ( ) ) { return ; } for ( int i = NUM_ ; i < locks . size ( ) ; i ++ ) { Table t = locks . get ( i ) ; if ( ! t . isLockedExclusively ( ) ) { synchronized ( database ) { t . unlock ( this ) ; locks . remove ( i ) ; } i -- ; } } }
protected void processAttributes ( ) { for ( final String tag : tags ) { for ( final String inherit : inherits ) { styleSheet . addStyles ( tag , styleSheet . getStyles ( inherit ) ) ; } styleSheet . addStyles ( tag , attributes ) ; } }
private boolean isImage ( String url ) { return url . matches ( Regex . IMAGE_PATTERN ) ; }
public void addAttribute ( AttributedCharacterIterator . Attribute attribute , Object value , int start , int end ) { if ( attribute == null ) { throw new NullPointerException ( STR_ ) ; } if ( start < NUM_ || end > text . length ( ) || start >= end ) { throw new IllegalArgumentException ( ) ; } if ( value == null ) { return ; } List < Range > ranges = attributeMap . get ( attribute ) ; if ( ranges == null ) { ranges = new ArrayList < Range > ( NUM_ ) ; ranges . add ( new Range ( start , end , value ) ) ; attributeMap . put ( attribute , ranges ) ; return ; } ListIterator < Range > it = ranges . listIterator ( ) ; while ( it . hasNext ( ) ) { Range range = it . next ( ) ; if ( end <= range . start ) { it . previous ( ) ; break ; } else if ( start < range . end || ( start == range . end && value . equals ( range . value ) ) ) { Range r1 = null , r3 ; it . remove ( ) ; r1 = new Range ( range . start , start , range . value ) ; r3 = new Range ( end , range . end , range . value ) ; while ( end > range . end && it . hasNext ( ) ) { range = it . next ( ) ; if ( end <= range . end ) { if ( end > range . start || ( end == range . start && value . equals ( range . value ) ) ) { it . remove ( ) ; r3 = new Range ( end , range . end , range . value ) ; break ; } } else { it . remove ( ) ; } } if ( value . equals ( r1 . value ) ) { if ( value . equals ( r3 . value ) ) { it . add ( new Range ( r1 . start < start ? r1 . start : start , r3 . end > end ? r3 . end : end , r1 . value ) ) ; } else { it . add ( new Range ( r1 . start < start ? r1 . start : start , end , r1 . value ) ) ; if ( r3 . start < r3 . end ) { it . add ( r3 ) ; } } } else { if ( value . equals ( r3 . value ) ) { if ( r1 . start < r1 . end ) { it . add ( r1 ) ; } it . add ( new Range ( start , r3 . end > end ? r3 . end : end , r3 . value ) ) ; } else { if ( r1 . start < r1 . end ) { it . add ( r1 ) ; } it . add ( new Range ( start , end , value ) ) ; if ( r3 . start < r3 . end ) { it . add ( r3 ) ; } } } return ; } } it . add ( new Range ( start , end , value ) ) ; }
public static boolean pointInRotatedRect ( float [ ] point , RectF bound , float rot ) { Matrix m = new Matrix ( ) ; float [ ] p = Arrays . copyOf ( point , NUM_ ) ; m . setRotate ( rot , bound . centerX ( ) , bound . centerY ( ) ) ; Matrix m0 = new Matrix ( ) ; if ( ! m . invert ( m0 ) ) return BOOL_ ; m0 . mapPoints ( p ) ; return inclusiveContains ( bound , p [ NUM_ ] , p [ NUM_ ] ) ; }
@ Override public void warning ( String domain , String key , XMLParseException exception ) throws XNIException { if ( fErrorHandler != null ) { SAXParseException saxException = createSAXParseException ( exception ) ; try { fErrorHandler . warning ( saxException ) ; } catch ( SAXParseException e ) { throw createXMLParseException ( e ) ; } catch ( SAXException e ) { throw createXNIException ( e ) ; } } }
public void modifyAll ( Map < String , Collection < DynamicModification > > modifications , Collection < Throwable > problems ) throws CannotCompileException { for ( String className : modifications . keySet ( ) ) { try { modify ( className , modifications . get ( className ) ) ; } catch ( NotFoundException e ) { log . warn ( STR_ + className , e ) ; problems . add ( e ) ; } catch ( ClassNotFoundException e ) { log . warn ( STR_ + className , e ) ; problems . add ( e ) ; } catch ( IOException e ) { log . warn ( STR_ + className , e ) ; problems . add ( e ) ; } } }
public MutableLocation toMutableLocation ( World w ) { return new MutableLocation ( x , y , z , w ) ; }
public boolean verify ( GeneralNameInterface name ) throws IOException { if ( name == null ) { throw new IOException ( STR_ ) ; } if ( excluded != null && excluded . size ( ) > NUM_ ) { for ( int i = NUM_ ; i < excluded . size ( ) ; i ++ ) { GeneralSubtree gs = excluded . get ( i ) ; if ( gs == null ) continue ; GeneralName gn = gs . getName ( ) ; if ( gn == null ) continue ; GeneralNameInterface exName = gn . getName ( ) ; if ( exName == null ) continue ; switch ( exName . constrains ( name ) ) { case GeneralNameInterface . NAME_DIFF_TYPE : case GeneralNameInterface . NAME_WIDENS : case GeneralNameInterface . NAME_SAME_TYPE : break ; case GeneralNameInterface . NAME_MATCH : case GeneralNameInterface . NAME_NARROWS : return BOOL_ ; } } } if ( permitted != null && permitted . size ( ) > NUM_ ) { boolean sameType = BOOL_ ; for ( int i = NUM_ ; i < permitted . size ( ) ; i ++ ) { GeneralSubtree gs = permitted . get ( i ) ; if ( gs == null ) continue ; GeneralName gn = gs . getName ( ) ; if ( gn == null ) continue ; GeneralNameInterface perName = gn . getName ( ) ; if ( perName == null ) continue ; switch ( perName . constrains ( name ) ) { case GeneralNameInterface . NAME_DIFF_TYPE : continue ; case GeneralNameInterface . NAME_WIDENS : case GeneralNameInterface . NAME_SAME_TYPE : sameType = BOOL_ ; continue ; case GeneralNameInterface . NAME_MATCH : case GeneralNameInterface . NAME_NARROWS : return BOOL_ ; } } if ( sameType ) { return BOOL_ ; } } return BOOL_ ; }
public void readGraphics ( ObjectInputStream objstream ) throws IOException { Debug . message ( STR_ , STR_ ) ; try { while ( BOOL_ ) { try { OMGraphic omg = ( OMGraphic ) objstream . readObject ( ) ; graphics . add ( omg ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } catch ( OptionalDataException ode ) { ode . printStackTrace ( ) ; } } } catch ( EOFException e ) { } }
public void createTopics ( int numPartitions , int replicationFactor , Set < String > topics ) { createTopics ( numPartitions , replicationFactor , topics . toArray ( new String [ topics . size ( ) ] ) ) ; }
public synchronized void removeListener ( Listener l ) { listeners . remove ( l ) ; }
public CommandLine add ( String ... args ) { if ( args != null && args . length > NUM_ ) { Collections . addAll ( arguments , args ) ; } return this ; }
private void restoreIcon ( BackupProtos . Key key , byte [ ] buffer , int dataSize ) throws IOException { if ( VERBOSE ) Log . v ( TAG , STR_ + key . id ) ; if ( DEBUG ) Log . d ( TAG , STR_ + buffer . length + STR_ + Base64 . encodeToString ( buffer , NUM_ , dataSize , Base64 . NO_WRAP ) ) ; BackupProtos . Resource res = unpackProto ( new BackupProtos . Resource ( ) , buffer , dataSize ) ; if ( DEBUG ) { Log . d ( TAG , STR_ + res . dpi + STR_ ) ; } Bitmap icon = BitmapFactory . decodeByteArray ( res . data , NUM_ , res . data . length ) ; if ( icon == null ) { Log . w ( TAG , STR_ + key . name ) ; } else { if ( VERBOSE ) Log . v ( TAG , STR_ + key . name ) ; mIconCache . preloadIcon ( ComponentName . unflattenFromString ( key . name ) , icon , res . dpi , STR_ , mUserSerial , mIdp ) ; } }
public static int determineConsecutiveDigitCount ( CharSequence msg , int startpos ) { int count = NUM_ ; int len = msg . length ( ) ; int idx = startpos ; if ( idx < len ) { char ch = msg . charAt ( idx ) ; while ( isDigit ( ch ) && idx < len ) { count ++ ; idx ++ ; if ( idx < len ) { ch = msg . charAt ( idx ) ; } } } return count ; }
public EventStoreBuilder useSslConnection ( String certificateCommonName ) { settingsBuilder . sslSettings ( SslSettings . trustCertificateCN ( certificateCommonName ) ) ; return this ; }
ActionMap createActionMap ( ) { ActionMap map = new ActionMapUIResource ( ) ; map . put ( STR_ , new ShowSystemMenuAction ( BOOL_ ) ) ; map . put ( STR_ , new ShowSystemMenuAction ( BOOL_ ) ) ; return map ; }
protected void paintContentBorderLeftEdge ( Graphics g , int x , int y , int w , int h , boolean drawBroken , Rectangle selRect , boolean isContentBorderPainted ) { if ( isContentBorderPainted ) { g . setColor ( selectHighlight ) ; g . fillRect ( x , y , NUM_ , h - NUM_ ) ; } }
private String fieldParamComment ( Field field , String paramComment ) { String commentType = fieldTypeCardinalityComment ( field ) ; String comment = String . format ( STR_ , wrapIfKeywordOrBuiltIn ( field . getSimpleName ( ) ) , commentType ) ; if ( paramComment == null ) { paramComment = DocumentationUtil . getScopedDescription ( field ) ; } if ( ! Strings . isNullOrEmpty ( paramComment ) ) { paramComment = RDocCommentFixer . rdocify ( paramComment ) ; comment += STR_ + paramComment . replaceAll ( STR_ , STR_ ) ; } return comment + STR_ ; }
public static long periodEnd ( long now , long period ) { LocalDateTime time = LocalDateTime . ofEpochSecond ( now / NUM_ , NUM_ , ZoneOffset . UTC ) ; long endTime = periodEnd ( now , period , time ) ; return endTime ; }
public void testThenCombine_sourceCancelled ( ) throws Throwable { for ( ExecutionMode m : ExecutionMode . values ( ) ) for ( boolean mayInterruptIfRunning : new boolean [ ] { BOOL_ , BOOL_ } ) for ( boolean fFirst : new boolean [ ] { BOOL_ , BOOL_ } ) for ( boolean failFirst : new boolean [ ] { BOOL_ , BOOL_ } ) for ( Integer v1 : new Integer [ ] { NUM_ , null } ) { final CompletableFuture < Integer > f = new CompletableFuture < > ( ) ; final CompletableFuture < Integer > g = new CompletableFuture < > ( ) ; final SubtractFunction r1 = new SubtractFunction ( m ) ; final SubtractFunction r2 = new SubtractFunction ( m ) ; final SubtractFunction r3 = new SubtractFunction ( m ) ; final CompletableFuture < Integer > fst = fFirst ? f : g ; final CompletableFuture < Integer > snd = ! fFirst ? f : g ; final Callable < Boolean > complete1 = failFirst ? null : null ; final Callable < Boolean > complete2 = failFirst ? null : null ; final CompletableFuture < Integer > h1 = m . thenCombine ( f , g , r1 ) ; assertTrue ( complete1 . call ( ) ) ; final CompletableFuture < Integer > h2 = m . thenCombine ( f , g , r2 ) ; checkIncomplete ( h1 ) ; checkIncomplete ( h2 ) ; assertTrue ( complete2 . call ( ) ) ; final CompletableFuture < Integer > h3 = m . thenCombine ( f , g , r3 ) ; checkCompletedWithWrappedCancellationException ( h1 ) ; checkCompletedWithWrappedCancellationException ( h2 ) ; checkCompletedWithWrappedCancellationException ( h3 ) ; r1 . assertNotInvoked ( ) ; r2 . assertNotInvoked ( ) ; r3 . assertNotInvoked ( ) ; checkCompletedNormally ( failFirst ? snd : fst , v1 ) ; checkCancelled ( failFirst ? fst : snd ) ; } }
public static String generateChatId ( final String receiverId , final String senderId ) { String combined = null ; if ( receiverId . compareTo ( senderId ) < NUM_ ) { combined = String . format ( Locale . US , AppConstants . CHAT_ID_FORMAT , receiverId , senderId ) ; } else { combined = String . format ( Locale . US , AppConstants . CHAT_ID_FORMAT , senderId , receiverId ) ; } String hashed = null ; try { hashed = Utils . sha1 ( combined ) ; } catch ( final NoSuchAlgorithmException e ) { hashed = combined ; } return hashed ; }
void extract ( String fname , String files [ ] ) throws IOException { ZipFile zf = new ZipFile ( fname ) ; Set < ZipEntry > dirs = newDirSet ( ) ; Enumeration < ? extends ZipEntry > zes = zf . entries ( ) ; while ( zes . hasMoreElements ( ) ) { ZipEntry e = zes . nextElement ( ) ; if ( files == null ) { dirs . add ( extractFile ( zf . getInputStream ( e ) , e ) ) ; } else { String name = e . getName ( ) ; for ( String file : files ) { if ( name . startsWith ( file ) ) { dirs . add ( extractFile ( zf . getInputStream ( e ) , e ) ) ; break ; } } } } zf . close ( ) ; updateLastModifiedTime ( dirs ) ; }
public void remove ( MenuComponent m ) { synchronized ( getTreeLock ( ) ) { int index = menus . indexOf ( m ) ; if ( index >= NUM_ ) { remove ( index ) ; } } }
public void testIdentity ( ) { assertNotNull ( new IdentityStub ( ) ) ; }
public void keyReleased ( final KeyEvent k ) { }
public XMLImporter ( ProgressListener listener ) { progressListener = listener ; }
private static TreeMap < Integer , Long > loadWorkspaceScreensDb ( Context context ) { final ContentResolver contentResolver = context . getContentResolver ( ) ; final Uri screensUri = LauncherSettings . WorkspaceScreens . CONTENT_URI ; final Cursor sc = contentResolver . query ( screensUri , null , null , null , null ) ; TreeMap < Integer , Long > orderedScreens = new TreeMap < Integer , Long > ( ) ; try { final int idIndex = sc . getColumnIndexOrThrow ( LauncherSettings . WorkspaceScreens . _ID ) ; final int rankIndex = sc . getColumnIndexOrThrow ( LauncherSettings . WorkspaceScreens . SCREEN_RANK ) ; while ( sc . moveToNext ( ) ) { try { long screenId = sc . getLong ( idIndex ) ; int rank = sc . getInt ( rankIndex ) ; orderedScreens . put ( rank , screenId ) ; } catch ( Exception e ) { Launcher . addDumpLog ( TAG , STR_ + e , BOOL_ ) ; } } } finally { sc . close ( ) ; } Launcher . addDumpLog ( TAG , STR_ , BOOL_ ) ; ArrayList < String > orderedScreensPairs = new ArrayList < String > ( ) ; for ( Integer i : orderedScreens . keySet ( ) ) { orderedScreensPairs . add ( STR_ + i + STR_ + orderedScreens . get ( i ) + STR_ ) ; } Launcher . addDumpLog ( TAG , STR_ + TextUtils . join ( STR_ , orderedScreensPairs ) , BOOL_ ) ; return orderedScreens ; }
public Observable < DriveId > createFile ( DriveFolder folder , final File file ) { return createFile ( folder , file , file . getName ( ) ) ; }
public static void validateContext ( AccelSurface srcData , AccelSurface dstData , Region clip , Composite comp , AffineTransform xform , Paint paint , SunGraphics2D sg2d , int flags ) { BufferedContext context = dstData . getContext ( ) ; context . validate ( srcData , dstData , clip , comp , xform , paint , sg2d , flags ) ; }
public void addCertificatesAndCRLs ( CertStore certStore ) throws CertStoreException , CMSException { certs . addAll ( CMSUtils . getCertificatesFromStore ( certStore ) ) ; crls . addAll ( CMSUtils . getCRLsFromStore ( certStore ) ) ; }
public void changeDefaultNames ( String type ) { String [ ] convert = CONVERT_TYPES . split ( STR_ ) ; String [ ] types = TYPES . split ( STR_ ) ; if ( convert . length != types . length ) { log . error ( STR_ , types . length , convert . length ) ; return ; } if ( type . equals ( Setup . DESCRIPTIVE ) ) { for ( int i = NUM_ ; i < convert . length ; i ++ ) { replaceName ( convert [ i ] , types [ i ] ) ; } String [ ] aarTypes = ARR_TYPES . split ( STR_ ) ; for ( int i = NUM_ ; i < aarTypes . length ; i ++ ) { list . remove ( aarTypes [ i ] ) ; } for ( int i = NUM_ ; i < types . length ; i ++ ) { if ( ! list . contains ( types [ i ] ) ) { list . add ( types [ i ] ) ; } } } else { for ( int i = NUM_ ; i < convert . length ; i ++ ) { replaceName ( types [ i ] , convert [ i ] ) ; } for ( int i = NUM_ ; i < types . length ; i ++ ) { list . remove ( types [ i ] ) ; } types = ARR_TYPES . split ( STR_ ) ; for ( int i = NUM_ ; i < types . length ; i ++ ) { if ( ! list . contains ( types [ i ] ) ) { list . add ( types [ i ] ) ; } } } }
public LabelValueComparator ( final Locale locale ) { c = Collator . getInstance ( locale ) ; }
public Refresher ( GLScene scene ) { Preconditions . checkNotNull ( scene ) ; this . scene = scene ; }
public Rect updateFastScrollerBounds ( int lastTouchY ) { mInvalidateRect . set ( mBgBounds ) ; if ( isVisible ( ) ) { int edgePadding = mRv . getMaxScrollbarWidth ( ) ; int bgPadding = ( mBgOriginalSize - mTextBounds . height ( ) ) / NUM_ ; int bgHeight = mBgOriginalSize ; int bgWidth = Math . max ( mBgOriginalSize , mTextBounds . width ( ) + ( NUM_ . bgPadding ) ) ; if ( Utilities . isRtl ( mRes ) ) { mBgBounds . left = mRv . getBackgroundPadding ( ) . left + ( NUM_ . mRv . getMaxScrollbarWidth ( ) ) ; mBgBounds . right = mBgBounds . left + bgWidth ; } else { mBgBounds . right = mRv . getWidth ( ) - mRv . getBackgroundPadding ( ) . right - ( NUM_ . mRv . getMaxScrollbarWidth ( ) ) ; mBgBounds . left = mBgBounds . right - bgWidth ; } mBgBounds . top = lastTouchY - ( int ) ( FAST_SCROLL_OVERLAY_Y_OFFSET_FACTOR . bgHeight ) ; mBgBounds . top = Math . max ( edgePadding , Math . min ( mBgBounds . top , mRv . getHeight ( ) - edgePadding - bgHeight ) ) ; mBgBounds . bottom = mBgBounds . top + bgHeight ; } else { mBgBounds . setEmpty ( ) ; } mInvalidateRect . union ( mBgBounds ) ; return mInvalidateRect ; }
public void buildUniqueId ( ) throws VPlexApiException { String name = getName ( ) ; if ( ! name . contains ( VPLEX_NAME_DELIM ) ) { s_logger . warn ( STR_ + name ) ; uniqueId = name ; return ; } int lastDelimIndex = name . lastIndexOf ( VPLEX_NAME_DELIM ) ; String suffix = name . substring ( lastDelimIndex + NUM_ ) ; s_logger . info ( STR_ , name , suffix ) ; uniqueId = suffix ; }
public static String createBase64 ( Bitmap mBitmap ) { ByteArrayOutputStream baos1 = new ByteArrayOutputStream ( ) ; mBitmap . compress ( Bitmap . CompressFormat . JPEG , NUM_ , baos1 ) ; byte [ ] b1 = baos1 . toByteArray ( ) ; return Base64 . encodeToString ( b1 , Base64 . DEFAULT ) ; }
public DiceServerEditor ( final IRemoteDiceServer diceServer ) { m_bean = diceServer ; final int bottomSpace = NUM_ ; final int labelSpace = NUM_ ; int row = NUM_ ; if ( m_bean . sendsEmail ( ) ) { add ( m_toLabel , new GridBagConstraints ( NUM_ , row , NUM_ , NUM_ , NUM_ , NUM_ , GridBagConstraints . WEST , GridBagConstraints . NONE , new Insets ( NUM_ , NUM_ , bottomSpace , labelSpace ) , NUM_ , NUM_ ) ) ; add ( m_toAddress , new GridBagConstraints ( NUM_ , row , NUM_ , NUM_ , NUM_ , NUM_ , GridBagConstraints . EAST , GridBagConstraints . HORIZONTAL , new Insets ( NUM_ , NUM_ , bottomSpace , NUM_ ) , NUM_ , NUM_ ) ) ; m_toAddress . setText ( m_bean . getToAddress ( ) ) ; row ++ ; add ( m_ccLabel , new GridBagConstraints ( NUM_ , row , NUM_ , NUM_ , NUM_ , NUM_ , GridBagConstraints . WEST , GridBagConstraints . NONE , new Insets ( NUM_ , NUM_ , bottomSpace , labelSpace ) , NUM_ , NUM_ ) ) ; add ( m_ccAddress , new GridBagConstraints ( NUM_ , row , NUM_ , NUM_ , NUM_ , NUM_ , GridBagConstraints . EAST , GridBagConstraints . HORIZONTAL , new Insets ( NUM_ , NUM_ , bottomSpace , NUM_ ) , NUM_ , NUM_ ) ) ; m_ccAddress . setText ( m_bean . getCcAddress ( ) ) ; row ++ ; } if ( m_bean . supportsGameId ( ) ) { final JLabel m_gameIdLabel = new JLabel ( STR_ ) ; add ( m_gameIdLabel , new GridBagConstraints ( NUM_ , row , NUM_ , NUM_ , NUM_ , NUM_ , GridBagConstraints . WEST , GridBagConstraints . NONE , new Insets ( NUM_ , NUM_ , bottomSpace , labelSpace ) , NUM_ , NUM_ ) ) ; add ( m_gameId , new GridBagConstraints ( NUM_ , row , NUM_ , NUM_ , NUM_ , NUM_ , GridBagConstraints . EAST , GridBagConstraints . HORIZONTAL , new Insets ( NUM_ , NUM_ , bottomSpace , NUM_ ) , NUM_ , NUM_ ) ) ; m_gameId . setText ( m_bean . getGameId ( ) ) ; row ++ ; } add ( m_testDiceyButton , new GridBagConstraints ( NUM_ , row , NUM_ , NUM_ , NUM_ , NUM_ , GridBagConstraints . EAST , GridBagConstraints . NONE , new Insets ( NUM_ , NUM_ , bottomSpace , NUM_ ) , NUM_ , NUM_ ) ) ; setupListeners ( ) ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return BOOL_ ; } if ( ! ( obj instanceof CandlestickRenderer ) ) { return BOOL_ ; } CandlestickRenderer that = ( CandlestickRenderer ) obj ; if ( this . candleWidth != that . candleWidth ) { return BOOL_ ; } if ( ! PaintUtilities . equal ( this . upPaint , that . upPaint ) ) { return BOOL_ ; } if ( ! PaintUtilities . equal ( this . downPaint , that . downPaint ) ) { return BOOL_ ; } if ( this . drawVolume != that . drawVolume ) { return BOOL_ ; } if ( this . maxCandleWidthInMilliseconds != that . maxCandleWidthInMilliseconds ) { return BOOL_ ; } if ( this . autoWidthMethod != that . autoWidthMethod ) { return BOOL_ ; } if ( this . autoWidthFactor != that . autoWidthFactor ) { return BOOL_ ; } if ( this . autoWidthGap != that . autoWidthGap ) { return BOOL_ ; } if ( this . useOutlinePaint != that . useOutlinePaint ) { return BOOL_ ; } if ( ! PaintUtilities . equal ( this . volumePaint , that . volumePaint ) ) { return BOOL_ ; } return super . equals ( obj ) ; }
public HeaderIterator iterator ( ) { return new BasicListHeaderIterator ( this . headers , null ) ; }
public static void w ( String tag , String msg , Object ... args ) { if ( sLevel > LEVEL_WARNING ) { return ; } if ( args . length > NUM_ ) { msg = String . format ( msg , args ) ; } Log . w ( tag , msg ) ; }
public static < T1 , T2 > void transform ( Collection < T1 > from , Collection < T2 > to , Transformer < T1 , T2 > transformer ) { for ( T1 instance : from ) { to . add ( transformer . transform ( instance ) ) ; } }
public static String generateCode ( ) { return generateCode ( CODESIZE ) ; }
public static boolean isBookSearchUrl ( String url ) { return url . startsWith ( STR_ ) || url . startsWith ( STR_ ) ; }
public void flush ( ) throws java . io . IOException { m_os . flush ( ) ; }
private void combineEntries ( ArrayList < long [ ] > list , int total ) { Collections . sort ( list , this ) ; for ( int minGap = NUM_ ; minGap < total ; minGap += minGap / NUM_ ) { for ( int i = NUM_ ; i < list . size ( ) - NUM_ ; i ++ ) { long [ ] current = list . get ( i ) ; long [ ] next = list . get ( i + NUM_ ) ; if ( current [ NUM_ ] + minGap >= next [ NUM_ ] ) { current [ NUM_ ] = next [ NUM_ ] ; list . remove ( i + NUM_ ) ; i -- ; } } int searched = NUM_ ; for ( long [ ] range : list ) { searched += range [ NUM_ ] - range [ NUM_ ] + NUM_ ; } if ( searched > NUM_ . total || list . size ( ) < NUM_ ) { break ; } } }
@ Override public void writeString ( byte [ ] str , int offset , int length ) throws IOException { if ( str == null ) writeInt ( NUM_ ) ; else { if ( useCompression && length >= Compressor . MIN_SIZE_FOR_DEFLATION ) { if ( byteBuffer . length < length ) byteBuffer = new byte [ NUM_ . length ] ; int numberOfBytes = compressor . deflateString2ByteArray ( str , offset , length , byteBuffer ) ; writeInt ( numberOfBytes ) ; io . write ( byteBuffer , NUM_ , Math . abs ( numberOfBytes ) ) ; } else { writeInt ( length ) ; io . write ( str , offset , length ) ; } } }
public void testGenerateDomainLimit ( ) throws Exception { ArrayList < URLCrawlDatum > list = new ArrayList < URLCrawlDatum > ( ) ; list . add ( createURLCrawlDatum ( STR_ , NUM_ , NUM_ ) ) ; list . add ( createURLCrawlDatum ( STR_ , NUM_ , NUM_ ) ) ; list . add ( createURLCrawlDatum ( STR_ , NUM_ , NUM_ ) ) ; createCrawlDB ( list ) ; Configuration myConfiguration = new Configuration ( conf ) ; myConfiguration . setInt ( Generator . GENERATOR_MAX_COUNT , NUM_ ) ; myConfiguration . set ( Generator . GENERATOR_COUNT_MODE , Generator . GENERATOR_COUNT_VALUE_DOMAIN ) ; Path generatedSegment = generateFetchlist ( Integer . MAX_VALUE , myConfiguration , BOOL_ ) ; Path fetchlistPath = new Path ( new Path ( generatedSegment , CrawlDatum . GENERATE_DIR_NAME ) , STR_ ) ; ArrayList < URLCrawlDatum > fetchList = readContents ( fetchlistPath ) ; assertEquals ( NUM_ , fetchList . size ( ) ) ; myConfiguration = new Configuration ( myConfiguration ) ; myConfiguration . setInt ( Generator . GENERATOR_MAX_COUNT , NUM_ ) ; generatedSegment = generateFetchlist ( Integer . MAX_VALUE , myConfiguration , BOOL_ ) ; fetchlistPath = new Path ( new Path ( generatedSegment , CrawlDatum . GENERATE_DIR_NAME ) , STR_ ) ; fetchList = readContents ( fetchlistPath ) ; assertEquals ( NUM_ , fetchList . size ( ) ) ; myConfiguration = new Configuration ( myConfiguration ) ; myConfiguration . setInt ( Generator . GENERATOR_MAX_COUNT , NUM_ ) ; generatedSegment = generateFetchlist ( Integer . MAX_VALUE , myConfiguration , BOOL_ ) ; fetchlistPath = new Path ( new Path ( generatedSegment , CrawlDatum . GENERATE_DIR_NAME ) , STR_ ) ; fetchList = readContents ( fetchlistPath ) ; assertEquals ( NUM_ , fetchList . size ( ) ) ; }
protected void writeColumnNotNullableStmt ( StringBuilder ddl ) { ddl . append ( STR_ ) ; }
private static OutputStream wrapOutputStream ( final OutputStream stream ) { String os = System . getProperty ( STR_ ) ; if ( os . startsWith ( STR_ ) ) { try { return new WindowsAnsiOutputStream ( stream ) ; } catch ( Throwable ignore ) { } return new AnsiOutputStream ( stream ) ; } return stream ; }
@ Override public Set < Location > unmarshal ( LocationsType locationsType ) { Set < Location > locations = new LinkedHashSet < Location > ( ) ; locations . addAll ( locationsType . getRpsBlastLocations ( ) ) ; locations . addAll ( locationsType . getHmmer2Locations ( ) ) ; locations . addAll ( locationsType . getHmmer3Locations ( ) ) ; locations . addAll ( locationsType . getSuperFamilyHmmer3Locations ( ) ) ; locations . addAll ( locationsType . getFingerPrintsLocations ( ) ) ; locations . addAll ( locationsType . getBlastProDomLocations ( ) ) ; locations . addAll ( locationsType . getPatternScanLocations ( ) ) ; locations . addAll ( locationsType . getProfileScanLocations ( ) ) ; locations . addAll ( locationsType . getPhobiusLocations ( ) ) ; locations . addAll ( locationsType . getCoilsLocations ( ) ) ; locations . addAll ( locationsType . getPantherLocations ( ) ) ; locations . addAll ( locationsType . getSignalPLocations ( ) ) ; locations . addAll ( locationsType . getTMHMMLocations ( ) ) ; return locations ; }
public int writeKey ( OutputStream out ) throws IOException { out . write ( blockBuffer , keyOffset , klen ) ; return klen ; }
boolean descendsFrom ( ClassFile cf ) { return descendsFrom ( cf . toString ( ) ) ; }
protected Object writePreProcess ( Object o ) throws Exception { return o ; }
public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( NUM_ ) ; newVector . addElement ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
public ExpressionParserBuilder withDynamics ( Resolver resolver ) { dynamicsResolvers . add ( resolver ) ; return this ; }
void warnMissingNames ( File file ) { String result = checkMissingNames ( file ) ; if ( result . equals ( STR_ ) ) { JOptionPane . showMessageDialog ( _who , STR_ ) ; } else { JOptionPane . showMessageDialog ( _who , result ) ; } }
public void add ( int position , WishlistItem wishlistItem ) { notifyItemInserted ( position ) ; wishlistItems . add ( position , wishlistItem ) ; }
protected void printBand ( byte [ ] bgrData , int x , int y , int width , int height ) throws PrinterException { mPSStream . println ( IMAGE_SAVE ) ; int psBytesPerRow = NUM_ . width ; while ( psBytesPerRow > MAX_PSSTR ) { psBytesPerRow /= NUM_ ; } mPSStream . println ( psBytesPerRow + IMAGE_STR ) ; mPSStream . println ( STR_ + width + STR_ + STR_ + height + STR_ + x + STR_ + y + STR_ ) ; mPSStream . println ( width + STR_ + height + STR_ + NUM_ + STR_ + width + STR_ + STR_ + - height + STR_ + height + STR_ + STR_ ) ; int index = NUM_ ; byte [ ] rgbData = new byte [ width . NUM_ ] ; try { for ( int i = NUM_ ; i < height ; i ++ ) { index = swapBGRtoRGB ( bgrData , index , rgbData ) ; byte [ ] encodedData = rlEncode ( rgbData ) ; byte [ ] asciiData = ascii85Encode ( encodedData ) ; mPSStream . write ( asciiData ) ; mPSStream . println ( STR_ ) ; } } catch ( IOException e ) { throw new PrinterIOException ( e ) ; } mPSStream . println ( IMAGE_RESTORE ) ; }
private void initPanel ( final ITreeNode < CTag > rootTag ) { final JPanel mainPanel = new JPanel ( new BorderLayout ( ) ) ; mainPanel . setBorder ( new TitledBorder ( STR_ ) ) ; createTree ( rootTag ) ; final JScrollPane pane = new JScrollPane ( m_tagTree ) ; pane . setVerticalScrollBarPolicy ( ScrollPaneConstants . VERTICAL_SCROLLBAR_AS_NEEDED ) ; pane . setHorizontalScrollBarPolicy ( ScrollPaneConstants . HORIZONTAL_SCROLLBAR_AS_NEEDED ) ; final JPanel anyTagPanel = new JPanel ( ) ; anyTagPanel . add ( m_anyTagBox ) ; mainPanel . add ( pane , BorderLayout . CENTER ) ; mainPanel . add ( m_anyTagBox , BorderLayout . SOUTH ) ; add ( mainPanel , BorderLayout . CENTER ) ; }
public final void append ( String value ) { if ( value == null ) return ; int strlen = value . length ( ) ; if ( NUM_ == strlen ) return ; int copyfrom = NUM_ ; char [ ] chunk = m_array [ m_lastChunk ] ; int available = m_chunkSize - m_firstFree ; while ( strlen > NUM_ ) { if ( available > strlen ) available = strlen ; value . getChars ( copyfrom , copyfrom + available , m_array [ m_lastChunk ] , m_firstFree ) ; strlen -= available ; copyfrom += available ; if ( strlen > NUM_ ) { int i = m_array . length ; if ( m_lastChunk + NUM_ == i ) { char [ ] [ ] newarray = new char [ i + NUM_ ] [ ] ; System . arraycopy ( m_array , NUM_ , newarray , NUM_ , i ) ; m_array = newarray ; } chunk = m_array [ ++ m_lastChunk ] ; if ( chunk == null ) { if ( m_lastChunk == NUM_ << m_rebundleBits && m_chunkBits < m_maxChunkBits ) { m_innerFSB = new FastStringBuffer ( this ) ; } chunk = m_array [ m_lastChunk ] = new char [ m_chunkSize ] ; } available = m_chunkSize ; m_firstFree = NUM_ ; } } m_firstFree += available ; }
protected void addPrefixMatch ( StringBuilder sb , String surface , String analyzed , String prefixToken ) { if ( prefixToken . length ( ) >= surface . length ( ) ) { addWholeMatch ( sb , surface , analyzed ) ; return ; } sb . append ( STR_ ) ; sb . append ( surface . substring ( NUM_ , prefixToken . length ( ) ) ) ; sb . append ( STR_ ) ; sb . append ( surface . substring ( prefixToken . length ( ) ) ) ; }
public WalletData addWallet ( final BitcoinController bitcoinController , Wallet wallet , String walletFilename ) { if ( walletFilename == null ) { return null ; } for ( WalletData loopModelData : perWalletModelDataList ) { if ( walletFilename . equals ( loopModelData . getWalletFilename ( ) ) ) { return loopModelData ; } } WalletData newPerWalletModelData = new WalletData ( ) ; newPerWalletModelData . setWallet ( wallet ) ; newPerWalletModelData . setWalletFilename ( walletFilename ) ; newPerWalletModelData . setWalletTableDataList ( new ArrayList < WalletTableData > ( ) ) ; if ( thereIsNoActiveWallet ( ) ) { perWalletModelDataList . remove ( activeWalletModelData ) ; activeWalletModelData = newPerWalletModelData ; } perWalletModelDataList . add ( newPerWalletModelData ) ; if ( wallet != null ) { wallet . addEventListener ( bitcoinController ) ; } createWalletTableData ( bitcoinController , walletFilename ) ; createAddressBookReceivingAddresses ( walletFilename ) ; return newPerWalletModelData ; }
public E push ( E object ) { addElement ( object ) ; return object ; }
public void add ( T object ) { synchronized ( mLock ) { if ( mOriginalValues != null ) { mOriginalValues . add ( object ) ; } else { mObjects . add ( object ) ; } } if ( mNotifyOnChange ) notifyDataSetChanged ( ) ; }
public static String toHumanSize ( long bytesValue ) { if ( NUM_ == bytesValue ) { return STR_ ; } boolean powerOfTwo = BOOL_ ; if ( ( bytesValue & ( bytesValue - NUM_ ) ) == NUM_ ) { powerOfTwo = BOOL_ ; } long multiple = ( long ) ( bytesValue / NUM_ ) ; if ( ( multiple & ( multiple - NUM_ ) ) == NUM_ ) { powerOfTwo = BOOL_ ; } Unit unit = Unit . B ; if ( powerOfTwo ) { if ( bytesValue >= Unit . EiB . value ) { unit = Unit . EiB ; } else if ( bytesValue >= Unit . PiB . value ) { unit = Unit . PiB ; } else if ( bytesValue >= Unit . TiB . value ) { unit = Unit . TiB ; } else if ( bytesValue >= Unit . GiB . value ) { unit = Unit . GiB ; } else if ( bytesValue >= Unit . MiB . value ) { unit = Unit . MiB ; } else if ( bytesValue >= Unit . KiB . value ) { unit = Unit . KiB ; } } else { if ( bytesValue >= Unit . EB . value ) { unit = Unit . EB ; } else if ( bytesValue >= Unit . PB . value ) { unit = Unit . PB ; } else if ( bytesValue >= Unit . TB . value ) { unit = Unit . TB ; } else if ( bytesValue >= Unit . GB . value ) { unit = Unit . GB ; } else if ( bytesValue >= Unit . MB . value ) { unit = Unit . MB ; } else if ( bytesValue >= Unit . KB . value ) { unit = Unit . KB ; } } double val = ( bytesValue / unit . getValue ( ) ) ; double roundedValue = Math . round ( val . NUM_ ) / NUM_ ; BigDecimal myDecimal = BigDecimal . valueOf ( roundedValue ) ; BigDecimal updated = myDecimal . stripTrailingZeros ( ) ; return updated . toPlainString ( ) + unit . name ( ) ; }
public boolean equals ( Object another ) { if ( another instanceof Permission ) { Permission p = ( Permission ) another ; return permission . equals ( p . toString ( ) ) ; } else { return BOOL_ ; } }
public static Intent buildStartInTerminalIntent ( File script ) { final ComponentName componentName = Constants . SL4A_SERVICE_LAUNCHER_COMPONENT_NAME ; Intent intent = new Intent ( ) ; intent . setComponent ( componentName ) ; intent . setAction ( Constants . ACTION_LAUNCH_FOREGROUND_SCRIPT ) ; intent . putExtra ( Constants . EXTRA_SCRIPT_PATH , script . getAbsolutePath ( ) ) ; return intent ; }
public Document loadDocument ( Resource file ) throws SAXException , IOException { DOMParser parser = new DOMParser ( ) ; InputStream in = null ; try { in = file . getInputStream ( ) ; InputSource source = new InputSource ( in ) ; parser . parse ( source ) ; } finally { IOUtil . closeEL ( in ) ; } return parser . getDocument ( ) ; }
public void resetFilters ( Boolean enabled ) { if ( logger . isLoggable ( Level . FINE ) ) { logger . fine ( STR_ + enabled ) ; } Set keys = filters . keySet ( ) ; for ( Iterator it = keys . iterator ( ) ; it . hasNext ( ) ; ) { String title = ( String ) it . next ( ) ; setFilterValue ( title , enabled ) ; } updateInterface ( ) ; }
private String [ ] diff_halfMatchI ( String longtext , String shorttext , int i ) { String seed = longtext . substring ( i , i + longtext . length ( ) / NUM_ ) ; int j = - NUM_ ; String best_common = STR_ ; String best_longtext_a = STR_ , best_longtext_b = STR_ ; String best_shorttext_a = STR_ , best_shorttext_b = STR_ ; while ( ( j = shorttext . indexOf ( seed , j + NUM_ ) ) != - NUM_ ) { int prefixLength = diff_commonPrefix ( longtext . substring ( i ) , shorttext . substring ( j ) ) ; int suffixLength = diff_commonSuffix ( longtext . substring ( NUM_ , i ) , shorttext . substring ( NUM_ , j ) ) ; if ( best_common . length ( ) < suffixLength + prefixLength ) { best_common = shorttext . substring ( j - suffixLength , j ) + shorttext . substring ( j , j + prefixLength ) ; best_longtext_a = longtext . substring ( NUM_ , i - suffixLength ) ; best_longtext_b = longtext . substring ( i + prefixLength ) ; best_shorttext_a = shorttext . substring ( NUM_ , j - suffixLength ) ; best_shorttext_b = shorttext . substring ( j + prefixLength ) ; } } if ( best_common . length ( ) . NUM_ >= longtext . length ( ) ) { return new String [ ] { best_longtext_a , best_longtext_b , best_shorttext_a , best_shorttext_b , best_common } ; } else { return null ; } }
@ Override public boolean generateEventID ( ) { return BOOL_ ; }
private void writeKeysWithPrefix ( String prefix ) { for ( String key : keys ) { if ( key . startsWith ( prefix ) ) { ps . println ( key + STR_ + prop . getProperty ( key ) ) ; } } ps . println ( ) ; }
public List < Operation > sendAndWait ( List < Operation > ops ) { return sendAndWait ( ops , BOOL_ ) ; }
public static void copy ( byte [ ] in , OutputStream out ) throws IOException { Assert . notNull ( in , STR_ ) ; Assert . notNull ( out , STR_ ) ; try { out . write ( in ) ; } finally { try { out . close ( ) ; } catch ( IOException ex ) { } } }
public Action mapToXACMLAction ( String nativeActionName , String serviceName ) throws XACMLException { return null ; }
private int nextInt ( StringTokenizer tok , String errorMsg ) throws SAXException { if ( ! tok . hasMoreTokens ( ) ) { throw new SAXException ( errorMsg ) ; } try { return Integer . parseInt ( tok . nextToken ( ) ) ; } catch ( NumberFormatException nfe ) { throw new SAXException ( errorMsg ) ; } }
public Calculable ( String id , double value ) { setId ( id ) ; setValue ( value ) ; setWhen ( System . currentTimeMillis ( ) ) ; }
public static boolean bookmarkNodeExists ( Context context , long nodeId ) { Boolean result = chromeBrowserProviderCall ( Boolean . class , ChromeBrowserProvider . CLIENT_API_BOOKMARK_NODE_EXISTS , context , argsToBundle ( nodeId ) ) ; return result != null ? result . booleanValue ( ) : BOOL_ ; }
private void executeTasksSimultaneouslyWithBarrier ( Runnable ... tasks ) throws InterruptedException { CountDownLatch latch = new CountDownLatch ( tasks . length ) ; for ( Runnable task : tasks ) { executor . execute ( null ) ; } latch . await ( ) ; }
private boolean isOperator ( char tok ) { if ( OPERATORS . indexOf ( tok ) == - NUM_ ) { return BOOL_ ; } return BOOL_ ; }
protected String formatIterable ( JCDiagnostic d , Iterable < ? > it , Locale l ) { StringBuilder sbuf = new StringBuilder ( ) ; String sep = STR_ ; for ( Object o : it ) { sbuf . append ( sep ) ; sbuf . append ( formatArgument ( d , o , l ) ) ; sep = STR_ ; } return sbuf . toString ( ) ; }
public void endRepresentation ( ) { if ( ! representationProtectionsSet ) { if ( currentRepresentationProtections != null ) { Collections . sort ( currentRepresentationProtections , this ) ; } representationProtections = currentRepresentationProtections ; representationProtectionsSet = BOOL_ ; } else { if ( currentRepresentationProtections == null ) { Assertions . checkState ( representationProtections == null ) ; } else { Collections . sort ( currentRepresentationProtections , this ) ; Assertions . checkState ( currentRepresentationProtections . equals ( representationProtections ) ) ; } } currentRepresentationProtections = null ; }
private static char [ ] zzUnpackCMap ( String packed ) { char [ ] map = new char [ x110000 ] ; int i = NUM_ ; int j = NUM_ ; while ( i < NUM_ ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM_ ) ; } return map ; }
public static ModuleVersion valueOf ( String string ) { return parseVersion ( string ) ; }
static void checkTypeRefAndPath ( int typeRef , TypePath typePath ) { int mask = NUM_ ; switch ( typeRef > > > NUM_ ) { case TypeReference . CLASS_TYPE_PARAMETER : case TypeReference . METHOD_TYPE_PARAMETER : case TypeReference . METHOD_FORMAL_PARAMETER : mask = xFFFF0000 ; break ; case TypeReference . FIELD : case TypeReference . METHOD_RETURN : case TypeReference . METHOD_RECEIVER : case TypeReference . LOCAL_VARIABLE : case TypeReference . RESOURCE_VARIABLE : case TypeReference . INSTANCEOF : case TypeReference . NEW : case TypeReference . CONSTRUCTOR_REFERENCE : case TypeReference . METHOD_REFERENCE : mask = xFF000000 ; break ; case TypeReference . CLASS_EXTENDS : case TypeReference . CLASS_TYPE_PARAMETER_BOUND : case TypeReference . METHOD_TYPE_PARAMETER_BOUND : case TypeReference . THROWS : case TypeReference . EXCEPTION_PARAMETER : mask = xFFFFFF00 ; break ; case TypeReference . CAST : case TypeReference . CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT : case TypeReference . METHOD_INVOCATION_TYPE_ARGUMENT : case TypeReference . CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT : case TypeReference . METHOD_REFERENCE_TYPE_ARGUMENT : mask = xFF0000FF ; break ; default : throw new IllegalArgumentException ( STR_ + Integer . toHexString ( typeRef > > > NUM_ ) ) ; } if ( ( typeRef & ~ mask ) != NUM_ ) { throw new IllegalArgumentException ( STR_ + Integer . toHexString ( typeRef ) ) ; } if ( typePath != null ) { for ( int i = NUM_ ; i < typePath . getLength ( ) ; ++ i ) { int step = typePath . getStep ( i ) ; if ( step != TypePath . ARRAY_ELEMENT && step != TypePath . INNER_TYPE && step != TypePath . TYPE_ARGUMENT && step != TypePath . WILDCARD_BOUND ) { throw new IllegalArgumentException ( STR_ + i + STR_ + typePath ) ; } if ( step != TypePath . TYPE_ARGUMENT && typePath . getStepArgument ( i ) != NUM_ ) { throw new IllegalArgumentException ( STR_ + i + STR_ + typePath ) ; } } } }
@ Override public boolean equals ( Object otherObj ) { if ( otherObj instanceof P2Model ) { return content . equals ( ( ( P2Model ) otherObj ) . content ) ; } else { return BOOL_ ; } }
public boolean showIcons ( ) { return preferences . getBoolean ( resources . getString ( R . string . key_show_icons ) , Boolean . parseBoolean ( resources . getString ( R . string . default_show_icons ) ) ) ; }
public static < V > boolean addListNotNullValue ( List < V > sourceList , V value ) { return ( sourceList != null && value != null ) ? sourceList . add ( value ) : BOOL_ ; }
private boolean checkForKey ( ) throws Exception { String query = m_query ; query = query . replaceAll ( STR_ , STR_ ) ; if ( ! query . startsWith ( STR_ ) ) { return BOOL_ ; } m_orderBy . clear ( ) ; if ( ! m_DataBaseConnection . isConnected ( ) ) { m_DataBaseConnection . connectToDatabase ( ) ; } DatabaseMetaData dmd = m_DataBaseConnection . getMetaData ( ) ; String table = endOfQuery ( BOOL_ ) ; ResultSet rs = dmd . getPrimaryKeys ( null , null , table ) ; while ( rs . next ( ) ) { m_orderBy . add ( rs . getString ( NUM_ ) ) ; } rs . close ( ) ; if ( m_orderBy . size ( ) != NUM_ ) { return BOOL_ ; } rs = dmd . getBestRowIdentifier ( null , null , table , DatabaseMetaData . bestRowSession , BOOL_ ) ; ResultSetMetaData rmd = rs . getMetaData ( ) ; int help = NUM_ ; while ( rs . next ( ) ) { m_orderBy . add ( rs . getString ( NUM_ ) ) ; help ++ ; } rs . close ( ) ; if ( help == rmd . getColumnCount ( ) ) { m_orderBy . clear ( ) ; } if ( m_orderBy . size ( ) != NUM_ ) { return BOOL_ ; } return BOOL_ ; }
public IgniteStripedThreadPoolExecutor ( int concurrentLvl , String gridName , String threadNamePrefix ) { execs = new ExecutorService [ concurrentLvl ] ; ThreadFactory factory = new IgniteThreadFactory ( gridName , threadNamePrefix ) ; for ( int i = NUM_ ; i < concurrentLvl ; i ++ ) execs [ i ] = Executors . newSingleThreadExecutor ( factory ) ; }
public static boolean isZip ( BufferedInputStream in ) { in . mark ( NUM_ ) ; byte [ ] b = new byte [ NUM_ ] ; byte [ ] zipSig = new byte [ NUM_ ] ; zipSig [ NUM_ ] = x50 ; zipSig [ NUM_ ] = x4b ; zipSig [ NUM_ ] = x03 ; zipSig [ NUM_ ] = x04 ; try { in . read ( b , NUM_ , NUM_ ) ; } catch ( Exception ex ) { throw new RuntimeException ( STR_ , ex ) ; } try { in . reset ( ) ; } catch ( Exception ex ) { throw new RuntimeException ( STR_ , ex ) ; } return Arrays . equals ( b , zipSig ) ; }
public List < String > extract ( Configuration config ) { List < String > features = new ArrayList < String > ( ) ; for ( Extractor fe : extractors ) { features . add ( fe . extract ( config ) ) ; } return features ; }
public String toString ( ) { StringBuffer path = new StringBuffer ( ) ; if ( absolute ) path . append ( STR_ ) ; for ( int i = NUM_ ; i < elements . size ( ) ; i ++ ) { if ( i > NUM_ ) path . append ( STR_ ) ; path . append ( elements . get ( i ) ) ; } return path . toString ( ) ; }
public void handleTblDataActionHrefRequest ( RequestInvocationEvent event ) { AgentsModel model = ( AgentsModel ) getModel ( ) ; String agentType = getDisplayIDType ( ) ; String universalId = hexToString ( ( String ) getDisplayFieldValue ( TBL_DATA_ACTION_HREF ) ) ; setPageSessionAttribute ( AgentProfileViewBean . UNIVERSAL_ID , universalId ) ; SSOToken ssoToken = model . getUserSSOToken ( ) ; String realm = ( String ) getPageSessionAttribute ( AMAdminConstants . CURRENT_REALM ) ; StringTokenizer st = new StringTokenizer ( universalId , STR_ ) ; st . nextToken ( ) ; String agentName = st . nextToken ( ) ; try { AMIdentity amid = new AMIdentity ( ssoToken , agentName , IdType . AGENTONLY , realm , null ) ; if ( agentType . equals ( AgentsViewBean . AGENT_WEB ) || ( agentType . equals ( AgentsViewBean . DEFAULT_ID_TYPE ) ) ) { if ( isPropertiesLocallyStored ( amid ) ) { setPageSessionAttribute ( LOCAL_OR_NOT , PROP_LOCAL ) ; } else { setPageSessionAttribute ( LOCAL_OR_NOT , PROP_CENTRAL ) ; } } Class clazz = getAgentCustomizedViewBean ( model . getAgentType ( amid ) ) ; AMViewBeanBase vb = ( AMViewBeanBase ) getViewBean ( clazz ) ; setPageSessionAttribute ( PG_SESSION_SUPERCEDE_AGENT_TYPE , model . getAgentType ( amid ) ) ; removePageSessionAttribute ( GenericAgentProfileViewBean . PS_TABNAME ) ; passPgSessionMap ( vb ) ; vb . forwardTo ( getRequestContext ( ) ) ; } catch ( IdRepoException e ) { setInlineAlertMessage ( CCAlert . TYPE_ERROR , STR_ , model . getErrorString ( e ) ) ; forwardTo ( ) ; } catch ( SSOException e ) { setInlineAlertMessage ( CCAlert . TYPE_ERROR , STR_ , model . getErrorString ( e ) ) ; forwardTo ( ) ; } catch ( AMConsoleException e ) { setInlineAlertMessage ( CCAlert . TYPE_ERROR , STR_ , model . getErrorString ( e ) ) ; forwardTo ( ) ; } catch ( ClassNotFoundException e ) { setInlineAlertMessage ( CCAlert . TYPE_ERROR , STR_ , model . getErrorString ( e ) ) ; forwardTo ( ) ; } }
@ Override protected boolean check ( File item ) { return item . exists ( ) ; }
public PropertyValueEditor ( ConsoleApplication app , ManagementContext context ) { this . app = app ; this . context = context ; }
@ Override public void toData ( DataOutput out ) throws IOException { out . writeInt ( maxInactiveInterval ) ; out . writeLong ( lastAccessedTime ) ; synchronized ( attributes ) { out . writeInt ( attributes . size ( ) ) ; for ( Map . Entry < String , Object > entry : attributes . entrySet ( ) ) { DeltaEvent delta = new DeltaEvent ( BOOL_ , entry . getKey ( ) , entry . getValue ( ) ) ; DataSerializer . writeObject ( delta , out ) ; } } out . writeUTF ( jvmOwnerId ) ; }
public void createVictoryConditions ( ) { victory = vf . createVictory ( STR_ ) ; }
public static IStatus validateQualifiedModuleName ( String qualifiedName ) { String pckg = Signature . getQualifier ( qualifiedName ) ; if ( ! Util . isValidPackageName ( pckg ) ) { return Util . newErrorStatus ( STR_ ) ; } return validateSimpleModuleName ( Signature . getSimpleName ( qualifiedName ) ) ; }
public static < T1 , T2 > Map < T1 , T2 > synchronizedMap ( ) { return Collections . synchronizedMap ( new HashMap < T1 , T2 > ( ) ) ; }
public boolean contains ( String key ) { return mSharedPreferences . contains ( key ) ; }
int registerMiss ( ) { return misses . incrementAndGet ( ) ; }
private void updateBaseMatrix ( Drawable d ) { ImageView imageView = getImageView ( ) ; if ( null == imageView || null == d ) { return ; } final float viewWidth = imageView . getWidth ( ) ; final float viewHeight = imageView . getHeight ( ) ; final int drawableWidth = d . getIntrinsicWidth ( ) ; final int drawableHeight = d . getIntrinsicHeight ( ) ; mBaseMatrix . reset ( ) ; final float widthScale = viewWidth / drawableWidth ; final float heightScale = viewHeight / drawableHeight ; if ( mScaleType == ScaleType . CENTER ) { mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth ) / NUM_ , ( viewHeight - drawableHeight ) / NUM_ ) ; } else if ( mScaleType == ScaleType . CENTER_CROP ) { float scale = Math . max ( widthScale , heightScale ) ; mBaseMatrix . postScale ( scale , scale ) ; mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth . scale ) / NUM_ , ( viewHeight - drawableHeight . scale ) / NUM_ ) ; } else if ( mScaleType == ScaleType . CENTER_INSIDE ) { float scale = Math . min ( NUM_ , Math . min ( widthScale , heightScale ) ) ; mBaseMatrix . postScale ( scale , scale ) ; mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth . scale ) / NUM_ , ( viewHeight - drawableHeight . scale ) / NUM_ ) ; } else { RectF mTempSrc = new RectF ( NUM_ , NUM_ , drawableWidth , drawableHeight ) ; RectF mTempDst = new RectF ( NUM_ , NUM_ , viewWidth , viewHeight ) ; switch ( mScaleType ) { case FIT_CENTER : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . CENTER ) ; break ; case FIT_START : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . START ) ; break ; case FIT_END : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . END ) ; break ; case FIT_XY : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . FILL ) ; break ; default : break ; } } resetMatrix ( ) ; }
public static CharSequence partialEscape ( CharSequence s ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = NUM_ ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == STR_ || c == STR_ || c == STR_ || c == STR_ || c == STR_ || c == STR_ || c == STR_ || c == STR_ || c == STR_ || c == STR_ || c == STR_ || c == STR_ || c == STR_ || c == STR_ ) { sb . append ( STR_ ) ; } sb . append ( c ) ; } return sb ; }
public void finished ( long work , long latency ) { finishedUpdater . getAndIncrement ( this ) ; totalWorkUpdater . getAndAdd ( this , work ) ; totalWorkSquaredUpdater . getAndAdd ( this , work . work ) ; totalLatencyUpdater . getAndAdd ( this , latency ) ; totalLatencySquaredUpdater . getAndAdd ( this , latency . latency ) ; }
public void close ( ) throws IOException { if ( mInputStream != null ) { mInputStream . close ( ) ; } else { throw new IOException ( STR_ ) ; } mInputStream = null ; }
private WindowsSecurityDescriptor ( ) { this . sidList = null ; this . aclBuffer = null ; this . sdBuffer = null ; }
public void printUsage ( OutputStream os ) { int count = NUM_ ; PrintStream out = UTF8 . printStream ( os ) ; for ( String option : optionList ) { if ( optionGroups . containsKey ( count ) ) { out . println ( STR_ + optionGroups . get ( count ) ) ; } count ++ ; if ( unlistedOptions . contains ( option ) ) { continue ; } out . print ( STR_ ) ; StringBuilder buf = new StringBuilder ( ) ; buf . append ( option ) ; if ( optionExtraPartSynopsisMap . get ( option ) != null ) { String optionExtraPartSynopsis = optionExtraPartSynopsisMap . get ( option ) ; buf . append ( STR_ ) ; buf . append ( optionExtraPartSynopsis ) ; buf . append ( STR_ ) ; } if ( requiresArgumentSet . contains ( option ) ) { buf . append ( STR_ ) ; buf . append ( argumentDescriptionMap . get ( option ) ) ; buf . append ( STR_ ) ; } printField ( out , buf . toString ( ) , maxWidth + NUM_ ) ; out . println ( optionDescriptionMap . get ( option ) ) ; } out . flush ( ) ; }
public void clearSharedVariables ( ) { sharedVariables . clear ( ) ; loadBuiltInSharedVariables ( ) ; }
public void remove ( Video video ) { videoList . remove ( video ) ; notifyDataSetChanged ( ) ; }
public final void sendPacket ( LsServerPacket bp ) { synchronized ( guard ) { if ( isWriteDisabled ( ) ) { return ; } log . debug ( STR_ + bp ) ; sendMsgQueue . addLast ( bp ) ; enableWriteInterest ( ) ; } }
private static Map < String , Object > processSection ( String section , Collection < Map < String , Object > > hosts , Map < String , Object > dflts , Map < String , Object > props ) throws IgniteCheckedException { if ( section == null || props == null ) return null ; if ( DFLT_SECTION . equalsIgnoreCase ( section ) ) { if ( dflts != null ) throw new IgniteCheckedException ( STR_ + DFLT_SECTION + STR_ ) ; return props ; } else { hosts . add ( props ) ; return null ; } }
public boolean isSet ( final OPTION option ) { return options == null ? BOOL_ : options . contains ( option ) ; }
public void handleButton1Request ( RequestInvocationEvent event ) throws ModelControlException { List optionData = restoreOptionsData ( ) ; CCCheckBox cbForceResetPwd = ( CCCheckBox ) getChild ( CB_FORCE_RESET_PWD ) ; boolean forceResetPwd = cbForceResetPwd . isChecked ( ) ; UMUserPasswordResetOptionsModel model = ( UMUserPasswordResetOptionsModel ) getModel ( ) ; String userId = ( String ) getPageSessionAttribute ( EntityEditViewBean . UNIVERSAL_ID ) ; try { model . modifyUserOption ( optionData , userId , forceResetPwd ) ; setInlineAlertMessage ( CCAlert . TYPE_INFO , STR_ , model . getLocalizedString ( STR_ ) ) ; } catch ( AMConsoleException e ) { setInlineAlertMessage ( CCAlert . TYPE_ERROR , STR_ , e . getMessage ( ) ) ; } forwardTo ( ) ; }
NumberStrategy ( final int field ) { this . field = field ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( NUM_ ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
@ Override public boolean queueRequest ( Operation op ) { AuthorizationContext ctx = op . getAuthorizationContext ( ) ; if ( ctx == null ) { op . fail ( new IllegalArgumentException ( STR_ ) ) ; return BOOL_ ; } Claims claims = ctx . getClaims ( ) ; if ( claims == null ) { op . fail ( new IllegalArgumentException ( STR_ ) ) ; return BOOL_ ; } String subject = claims . getSubject ( ) ; if ( subject == null ) { op . fail ( new IllegalArgumentException ( STR_ ) ) ; return BOOL_ ; } if ( op . hasPragmaDirective ( Operation . PRAGMA_DIRECTIVE_CLEAR_AUTH_CACHE ) ) { return handleCacheClearRequest ( op , subject ) ; } if ( subject . equals ( SystemUserService . SELF_LINK ) ) { op . complete ( ) ; return BOOL_ ; } if ( ctx . getResourceQueryFilter ( op . getAction ( ) ) != null ) { op . complete ( ) ; return BOOL_ ; } return BOOL_ ; }
public SpannableStringBuilder ( CharSequence text ) { this ( text , NUM_ , text . length ( ) ) ; }
public boolean hasExtraFields ( PdxType other ) { for ( PdxField ft : this . fields ) { if ( ! ft . isDeleted ( ) && other . getPdxField ( ft . getFieldName ( ) ) == null ) { return BOOL_ ; } } return BOOL_ ; }
public void put ( String id , String str ) { tab . put ( id , str ) ; if ( str . endsWith ( STR_ ) ) { int i = str . lastIndexOf ( File . separator ) ; if ( i >= NUM_ ) { tab . put ( str . substring ( i + NUM_ , str . length ( ) - NUM_ ) , str ) ; } } }
public void reportOccurences ( List < Map < Id < Vehicle > , Integer > > maps ) { for ( int m = NUM_ ; m < maps . size ( ) ; m ++ ) { Map < Id < Vehicle > , Integer > theMap = maps . get ( m ) ; log . info ( STR_ + ( m + NUM_ ) + STR_ + theMap . size ( ) + STR_ ) ; Integer min = Integer . MAX_VALUE ; Integer max = Integer . MIN_VALUE ; for ( Id < Vehicle > id : theMap . keySet ( ) ) { min = Math . min ( min , theMap . get ( id ) ) ; max = Math . max ( max , theMap . get ( id ) ) ; } log . info ( STR_ + min + STR_ + max ) ; List < Id < Link > > histList = new ArrayList < > ( ) ; Map < Id < Link > , Integer > histMap = new HashMap < Id < Link > , Integer > ( ) ; for ( long h = min ; h <= max ; h ++ ) { Id < Link > id = Id . create ( h , Link . class ) ; histList . add ( id ) ; histMap . put ( id , new Integer ( NUM_ ) ) ; } for ( Id < Vehicle > id : theMap . keySet ( ) ) { int value = theMap . get ( id ) ; histMap . put ( Id . create ( value , Link . class ) , new Integer ( histMap . get ( Id . create ( value , Link . class ) ) + NUM_ ) ) ; } String s = STR_ ; for ( Id < Link > id : histList ) { s += id . toString ( ) + STR_ + histMap . get ( id ) + STR_ ; } log . info ( STR_ ) ; log . info ( STR_ + s ) ; } }
public static List < URI > refIds ( Collection < ? extends RelatedResourceRep > refs ) { List < URI > ids = new ArrayList < URI > ( ) ; if ( refs != null ) { for ( RelatedResourceRep ref : refs ) { ids . add ( ref . getId ( ) ) ; } } return ids ; }
public static boolean hasTopCategory ( HttpServletRequest request , String categoryId , List < String > pathElements ) { if ( CategoryWorker . isCategoryTop ( request , categoryId ) ) { return BOOL_ ; } String topCategoryId = CategoryWorker . getTopCategoryFromTrail ( request , pathElements ) ; if ( topCategoryId != null ) { return BOOL_ ; } List < String > trail = CategoryWorker . getTrail ( request ) ; topCategoryId = CategoryWorker . getTopCategoryFromTrail ( request , trail ) ; if ( topCategoryId == null ) { return BOOL_ ; } return BOOL_ ; }
@ Override public String append ( String path , InputStream is ) throws MalformedURLException , IOException , AuthenticationException { String resp = null ; ensureValidToken ( ) ; String redirectUrl = null ; HttpURLConnection conn = authenticatedURL . openConnection ( new URL ( new URL ( httpfsUrl ) , MessageFormat . format ( STR_ , path ) ) , token ) ; conn . setRequestMethod ( STR_ ) ; conn . setInstanceFollowRedirects ( BOOL_ ) ; conn . connect ( ) ; logger . info ( STR_ + conn . getHeaderField ( STR_ ) ) ; resp = result ( conn , BOOL_ ) ; if ( conn . getResponseCode ( ) == NUM_ ) redirectUrl = conn . getHeaderField ( STR_ ) ; conn . disconnect ( ) ; if ( redirectUrl != null ) { conn = authenticatedURL . openConnection ( new URL ( redirectUrl ) , token ) ; conn . setRequestMethod ( STR_ ) ; conn . setDoOutput ( BOOL_ ) ; conn . setDoInput ( BOOL_ ) ; conn . setUseCaches ( BOOL_ ) ; conn . setRequestProperty ( STR_ , STR_ ) ; final int _SIZE = is . available ( ) ; conn . setRequestProperty ( STR_ , STR_ + _SIZE ) ; conn . setFixedLengthStreamingMode ( _SIZE ) ; conn . connect ( ) ; OutputStream os = conn . getOutputStream ( ) ; copy ( is , os ) ; is . close ( ) ; os . close ( ) ; resp = result ( conn , BOOL_ ) ; conn . disconnect ( ) ; } return resp ; }
public static void cacheImgs ( String skinImgDir , Iterable < String > baseImageURLs ) { String skinDir = getSkinDir ( ) ; for ( String img : baseImageURLs ) { img = img . replace ( STR_ , skinDir + STR_ ) ; img = img . replace ( STR_ , skinDir + skinImgDir ) ; Image . prefetch ( img ) ; } }
public static String separatorsToUnix ( String path ) { if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == - NUM_ ) { return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; }
public void clearBuffer ( ) { buffer . clear ( ) ; }
@ Override public final void perform ( IR ir ) { java . util . HashMap < Register , Register > newMap = new java . util . HashMap < Register , Register > ( NUM_ ) ; for ( Enumeration < BasicBlock > be = ir . getBasicBlocks ( ) ; be . hasMoreElements ( ) ; ) { BasicBlock bb = be . nextElement ( ) ; for ( Enumeration < Instruction > ie = bb . forwardInstrEnumerator ( ) ; ie . hasMoreElements ( ) ; ) { Instruction s = ie . nextElement ( ) ; ; newMap . clear ( ) ; if ( s . isPEI ( ) && s . operator ( ) != IR_PROLOGUE ) { if ( bb . hasApplicableExceptionalOut ( s ) || ! RegisterRestrictions . SCRATCH_IN_PEI ) { splitAllLiveRanges ( s , newMap , ir , BOOL_ ) ; } } switch ( s . getOpcode ( ) ) { case MIR_LOWTABLESWITCH_opcode : { RegisterOperand rOp = MIR_LowTableSwitch . getIndex ( s ) ; RegisterOperand temp = findOrCreateTemp ( rOp , newMap , ir ) ; insertMoveBefore ( temp , rOp . copyRO ( ) , s ) ; rOp . setRegister ( temp . getRegister ( ) ) ; } break ; } } } }
protected void appendString ( final String text ) { final HTMLDocument doc = ( HTMLDocument ) textPane . getDocument ( ) ; try { final Element root = doc . getParagraphElement ( NUM_ ) ; doc . insertBeforeEnd ( root , text ) ; } catch ( final BadLocationException e ) { logger . error ( e , e ) ; } catch ( final IOException e ) { logger . error ( e , e ) ; } }
public void scaleToSamples ( int usrSamples ) { double ratio ; ratio = ( double ) usrSamples / count ; count = NUM_ ; for ( int i = NUM_ ; i <= limits . length ; ++ i ) { results [ i ] = ( int ) Math . round ( results [ i ] . ratio ) ; count += results [ i ] ; } }
private void refreshSelected ( int offsetX ) { int offset = ( int ) ( offsetX + mMaxOverScrollDistance ) ; int tempIndex = Math . round ( offset / mIntervalDis ) ; tempIndex = clampSelectedIndex ( tempIndex ) ; if ( mSelectedIndex == tempIndex ) { return ; } mSelectedIndex = tempIndex ; if ( null != onValueChangeListener ) { onValueChangeListener . onChange ( this , mSelectedIndex , Float . parseFloat ( format ( mSelectedIndex . mIntervalValue + mMinValue ) ) ) ; } }
@ Override @ SuppressWarnings ( STR_ ) public void resetFrame ( ) { synchronized ( lock ) { sysName . setText ( STR_ + counter ++ ) ; } userName . setText ( null ) ; url . setText ( null ) ; stream . setSelected ( BOOL_ ) ; stream . setEnabled ( BOOL_ ) ; loopStart . setValue ( Long . valueOf ( NUM_ ) ) ; loopEnd . setValue ( Long . valueOf ( NUM_ ) ) ; this . newBuffer = BOOL_ ; }
public ExpectedRecords < T > repeatAll ( int times ) { List < T > toAppend = new ArrayList < > ( ) ; for ( int i = NUM_ ; i < times ; i ++ ) { toAppend . addAll ( expectedRecords ) ; } expectedRecords . addAll ( toAppend ) ; return this ; }
public void addAttributes ( Attributes atts ) throws SAXException { int nAtts = atts . getLength ( ) ; for ( int i = NUM_ ; i < nAtts ; i ++ ) { String uri = atts . getURI ( i ) ; if ( null == uri ) uri = STR_ ; addAttributeAlways ( uri , atts . getLocalName ( i ) , atts . getQName ( i ) , atts . getType ( i ) , atts . getValue ( i ) , BOOL_ ) ; } }
protected static GeoPoint parseKmlCoord ( String input ) { int end1 = input . indexOf ( STR_ ) ; int end2 = input . indexOf ( STR_ , end1 + NUM_ ) ; try { if ( end2 == - NUM_ ) { double lon = Double . parseDouble ( input . substring ( NUM_ , end1 ) ) ; double lat = Double . parseDouble ( input . substring ( end1 + NUM_ , input . length ( ) ) ) ; return new GeoPoint ( lat , lon ) ; } else { double lon = Double . parseDouble ( input . substring ( NUM_ , end1 ) ) ; double lat = Double . parseDouble ( input . substring ( end1 + NUM_ , end2 ) ) ; double alt = Double . parseDouble ( input . substring ( end2 + NUM_ , input . length ( ) ) ) ; return new GeoPoint ( lat , lon , alt ) ; } } catch ( NumberFormatException e ) { return null ; } catch ( IndexOutOfBoundsException e ) { return null ; } }
@ Nullable public Calendar detectDate ( String input ) { checkNotNull ( input ) ; Time . setTimeZone ( getTimeZone ( ) ) ; Options opt = new com . sk89q . jchronic . Options ( ) ; opt . setNow ( Calendar . getInstance ( getTimeZone ( ) ) ) ; Span date = Chronic . parse ( input , opt ) ; if ( date == null ) { return null ; } else { return date . getBeginCalendar ( ) ; } }
public synchronized void saveCommitPoint ( Long indexCommitGen ) { AtomicInteger reserveCount = savedCommits . get ( indexCommitGen ) ; if ( reserveCount == null ) reserveCount = new AtomicInteger ( ) ; reserveCount . incrementAndGet ( ) ; savedCommits . put ( indexCommitGen , reserveCount ) ; }
public void removeSearchable ( SearchResult searchable ) { if ( searchables . contains ( searchable ) ) searchables . remove ( search ) ; }
public static boolean is64bit ( ) { boolean is64bit = BOOL_ ; if ( isWindows ( ) ) { is64bit = ( System . getenv ( STR_ ) != null ) ; } else { is64bit = ( OS_ARCH . contains ( STR_ ) ) ; } return is64bit ; }
private int resolveSizeAndStateRespectingMinSize ( int minSize , int measuredSize , int measureSpec ) { if ( minSize != SIZE_UNSPECIFIED ) { final int desiredWidth = Math . max ( minSize , measuredSize ) ; return resolveSizeAndState ( desiredWidth , measureSpec , NUM_ ) ; } else { return measuredSize ; } }
@ Override public void onSongUpdate ( ProviderIdentifier provider , final Song s ) throws RemoteException { if ( s == null ) { Log . w ( TAG , STR_ + provider . mName + STR_ ) ; return ; } try { Song cached = mCache . getSong ( s . getRef ( ) ) ; boolean wasLoaded = BOOL_ ; boolean changed = BOOL_ ; if ( cached == null ) { mCache . putSong ( provider , s ) ; changed = BOOL_ ; cached = s ; } else { wasLoaded = cached . isLoaded ( ) ; if ( s . isLoaded ( ) && ! cached . isIdentical ( s ) ) { cached . setAlbum ( s . getAlbum ( ) ) ; cached . setArtist ( s . getArtist ( ) ) ; cached . setSourceLogo ( s . getLogo ( ) ) ; cached . setDuration ( s . getDuration ( ) ) ; cached . setTitle ( s . getTitle ( ) ) ; cached . setYear ( s . getYear ( ) ) ; cached . setOfflineStatus ( s . getOfflineStatus ( ) ) ; cached . setAvailable ( s . isAvailable ( ) ) ; cached . setIsLoaded ( s . isLoaded ( ) ) ; changed = BOOL_ ; } } if ( ! wasLoaded && cached . isLoaded ( ) ) { Artist artist = mCache . getArtist ( s . getArtist ( ) ) ; if ( artist == null && s . getArtist ( ) != null ) { artist = retrieveArtist ( s . getArtist ( ) , provider ) ; } if ( artist != null ) { Album album = mCache . getAlbum ( s . getAlbum ( ) ) ; if ( album == null && s . getAlbum ( ) != null ) { album = retrieveAlbum ( s . getAlbum ( ) , provider ) ; } if ( album != null ) { artist . addAlbum ( album . getRef ( ) ) ; } } } if ( changed ) { postSongForUpdate ( cached ) ; } } catch ( Exception e ) { Log . e ( TAG , STR_ , e ) ; } }
public static boolean deleteDirectoryAndContents ( File rootDirectory ) { if ( ( rootDirectory == null ) || ! rootDirectory . isDirectory ( ) ) { return BOOL_ ; } try { String [ ] directoryContents = rootDirectory . list ( ) ; for ( int i = NUM_ ; i < directoryContents . length ; i ++ ) { boolean success = deleteDirectoryAndContents ( new File ( rootDirectory , directoryContents [ i ] ) ) ; if ( ! success ) { return BOOL_ ; } } return rootDirectory . delete ( ) ; } catch ( Exception e ) { logger . debug ( e . toString ( ) + System . lineSeparator ( ) + StackTrace . getStringFromStackTrace ( e ) ) ; return BOOL_ ; } }
public static void nanosleep ( long nanos ) throws InterruptedException { if ( Thread . interrupted ( ) ) throw new InterruptedException ( ) ; if ( nanos <= NUM_ ) { return ; } if ( nanos >= NUM_ ) { Thread . sleep ( nanos / NUM_ , ( int ) ( nanos % NUM_ ) ) ; } else { if ( pureMode ) { Thread . yield ( ) ; } else { _nanosleep ( ( int ) nanos ) ; } } }
@ Override public boolean connectionAllowed ( EventSetDescriptor esd ) { return connectionAllowed ( esd . getName ( ) ) ; }
int pureLength ( ) { return length - delimiter . length ( ) ; }
private void addElements ( int value , int numberOfElements ) { if ( m_firstFree + numberOfElements < m_blocksize ) for ( int i = NUM_ ; i < numberOfElements ; i ++ ) { m_map0 [ m_firstFree ++ ] = value ; } else { int index = m_firstFree > > > m_SHIFT ; int offset = m_firstFree & m_MASK ; m_firstFree += numberOfElements ; while ( numberOfElements > NUM_ ) { if ( index >= m_map . length ) { int newsize = index + m_numblocks ; int [ ] [ ] newMap = new int [ newsize ] [ ] ; System . arraycopy ( m_map , NUM_ , newMap , NUM_ , m_map . length ) ; m_map = newMap ; } int [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new int [ m_blocksize ] ; int copied = ( m_blocksize - offset < numberOfElements ) ? m_blocksize - offset : numberOfElements ; numberOfElements -= copied ; while ( copied -- > NUM_ ) block [ offset ++ ] = value ; ++ index ; offset = NUM_ ; } } }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
public static StringBuilder formatTo ( StringBuilder buf , double [ ] d , String sep ) { if ( d == null ) { return buf . append ( STR_ ) ; } if ( d . length == NUM_ ) { return buf ; } buf . append ( d [ NUM_ ] ) ; for ( int i = NUM_ ; i < d . length ; i ++ ) { buf . append ( sep ) ; buf . append ( d [ i ] ) ; } return buf ; }
@ SuppressWarnings ( STR_ ) private static void mergeSort ( Object [ ] in , Object [ ] out , int start , int end , Comparator c ) { int len = end - start ; if ( len <= SIMPLE_LENGTH ) { for ( int i = start + NUM_ ; i < end ; i ++ ) { Object current = out [ i ] ; Object prev = out [ i - NUM_ ] ; if ( c . compare ( prev , current ) > NUM_ ) { int j = i ; do { out [ j -- ] = prev ; } while ( j > start && ( c . compare ( prev = out [ j - NUM_ ] , current ) > NUM_ ) ) ; out [ j ] = current ; } } return ; } int med = ( end + start ) > > > NUM_ ; mergeSort ( out , in , start , med , c ) ; mergeSort ( out , in , med , end , c ) ; if ( c . compare ( in [ med - NUM_ ] , in [ med ] ) <= NUM_ ) { System . arraycopy ( in , start , out , start , len ) ; return ; } int r = med , i = start ; do { Object fromVal = in [ start ] ; Object rVal = in [ r ] ; if ( c . compare ( fromVal , rVal ) <= NUM_ ) { int l_1 = find ( in , rVal , - NUM_ , start + NUM_ , med - NUM_ , c ) ; int toCopy = l_1 - start + NUM_ ; System . arraycopy ( in , start , out , i , toCopy ) ; i += toCopy ; out [ i ++ ] = rVal ; r ++ ; start = l_1 + NUM_ ; } else { int r_1 = find ( in , fromVal , NUM_ , r + NUM_ , end - NUM_ , c ) ; int toCopy = r_1 - r + NUM_ ; System . arraycopy ( in , r , out , i , toCopy ) ; i += toCopy ; out [ i ++ ] = fromVal ; start ++ ; r = r_1 + NUM_ ; } } while ( ( end - r ) > NUM_ && ( med - start ) > NUM_ ) ; if ( ( end - r ) <= NUM_ ) { System . arraycopy ( in , start , out , i , med - start ) ; } else { System . arraycopy ( in , r , out , i , end - r ) ; } }
private View fillFromLeft ( int nextLeft ) { mFirstPosition = Math . min ( mFirstPosition , mSelectedPosition ) ; mFirstPosition = Math . min ( mFirstPosition , mItemCount - NUM_ ) ; if ( mFirstPosition < NUM_ ) { mFirstPosition = NUM_ ; } return fillRight ( mFirstPosition , nextLeft ) ; }
public TomcatSlf4jLogbackFactoryAccessor ( ClassLoader cl ) throws ClassNotFoundException , IllegalAccessException , IllegalArgumentException , InvocationTargetException { Class clazz = cl . loadClass ( STR_ ) ; Method getSingleton = MethodUtils . getAccessibleMethod ( clazz , STR_ , new Class [ NUM_ ] ) ; Object singleton = getSingleton . invoke ( null ) ; Method getLoggerFactory = MethodUtils . getAccessibleMethod ( clazz , STR_ , new Class [ NUM_ ] ) ; Object loggerFactory = getLoggerFactory . invoke ( singleton ) ; Class loggerFactoryClass = cl . loadClass ( STR_ ) ; if ( ! loggerFactoryClass . isInstance ( loggerFactory ) ) { throw new RuntimeException ( STR_ ) ; } setTarget ( loggerFactory ) ; }
public QuarterDateFormat ( TimeZone zone , String [ ] quarterSymbols , boolean quarterFirst ) { ParamChecks . nullNotPermitted ( zone , STR_ ) ; this . calendar = new GregorianCalendar ( zone ) ; this . quarters = quarterSymbols ; this . quarterFirst = quarterFirst ; this . numberFormat = NumberFormat . getNumberInstance ( ) ; }
public long restart ( ) { long start = _startTimeNanos ; _startTimeNanos = System . nanoTime ( ) ; return _startTimeNanos - start ; }
private static byte [ ] stringToByteArray ( String str ) { byte [ ] result = new byte [ str . length ( ) + NUM_ ] ; for ( int i = NUM_ ; i < str . length ( ) ; i ++ ) { result [ i ] = ( byte ) str . charAt ( i ) ; } result [ str . length ( ) ] = NUM_ ; return result ; }
@ Override public void actionPerformed ( ActionEvent e ) { Object o ; o = e . getSource ( ) ; if ( o == menuFileOpen ) { loadFile ( ) ; } else if ( o == menuFileSave ) { saveFile ( ) ; } else if ( o == menuFileSaveAs ) { saveFileAs ( ) ; } else if ( o == menuFileClose ) { closeFile ( ) ; } else if ( o == menuFileCloseAll ) { closeAllFiles ( ) ; } else if ( o == menuFileProperties ) { showProperties ( ) ; } else if ( o == menuFileExit ) { close ( ) ; } else if ( o == menuEditUndo ) { undo ( ) ; } else if ( o == menuEditCopy ) { copyContent ( ) ; } else if ( o == menuEditSearch ) { search ( ) ; } else if ( o == menuEditClearSearch ) { clearSearch ( ) ; } else if ( o == menuEditDeleteAttribute ) { deleteAttribute ( BOOL_ ) ; } else if ( o == menuEditDeleteAttributes ) { deleteAttribute ( BOOL_ ) ; } else if ( o == menuEditRenameAttribute ) { renameAttribute ( ) ; } else if ( o == menuEditAttributeAsClass ) { attributeAsClass ( ) ; } else if ( o == menuEditDeleteInstance ) { deleteInstance ( BOOL_ ) ; } else if ( o == menuEditDeleteInstances ) { deleteInstance ( BOOL_ ) ; } else if ( o == menuEditSortInstances ) { sortInstances ( ) ; } else if ( o == menuViewAttributes ) { showAttributes ( ) ; } else if ( o == menuViewValues ) { showValues ( ) ; } else if ( o == menuViewOptimalColWidths ) { setOptimalColWidths ( ) ; } updateMenu ( ) ; }
public static boolean hasJoda ( ) { try { Class . forName ( STR_ ) ; return BOOL_ ; } catch ( ClassNotFoundException e ) { return BOOL_ ; } }
public RemoteServiceDescriptor ( String baseUrl , HttpJsonRequestFactory requestFactory ) throws IllegalArgumentException { this . baseUrl = baseUrl ; try { baseUrlURL = new URL ( baseUrl ) ; final String protocol = baseUrlURL . getProtocol ( ) ; if ( ! ( protocol . equals ( STR_ ) || protocol . equals ( STR_ ) ) ) { throw new IllegalArgumentException ( String . format ( STR_ , baseUrl ) ) ; } } catch ( MalformedURLException e ) { throw new IllegalArgumentException ( String . format ( STR_ , baseUrl ) ) ; } this . requestFactory = requestFactory ; }
private int findActivityElement ( int activityIndex ) { for ( int elementIndex = NUM_ ; elementIndex < mActivityList . size ( ) ; elementIndex ++ ) { if ( mActivityList . get ( elementIndex ) . mActivityIndex == activityIndex ) { return elementIndex ; } } return - NUM_ ; }
void addFillComponents ( Container panel , int [ ] cols , int [ ] rows ) { Dimension filler = new Dimension ( NUM_ , NUM_ ) ; boolean filled_cell_11 = BOOL_ ; CellConstraints cc = new CellConstraints ( ) ; if ( cols . length > NUM_ && rows . length > NUM_ ) { if ( cols [ NUM_ ] == NUM_ && rows [ NUM_ ] == NUM_ ) { panel . add ( Box . createRigidArea ( filler ) , cc . xy ( NUM_ , NUM_ ) ) ; filled_cell_11 = BOOL_ ; } } for ( int index = NUM_ ; index < cols . length ; index ++ ) { if ( cols [ index ] == NUM_ && filled_cell_11 ) { continue ; } panel . add ( Box . createRigidArea ( filler ) , cc . xy ( cols [ index ] , NUM_ ) ) ; } for ( int index = NUM_ ; index < rows . length ; index ++ ) { if ( rows [ index ] == NUM_ && filled_cell_11 ) { continue ; } panel . add ( Box . createRigidArea ( filler ) , cc . xy ( NUM_ , rows [ index ] ) ) ; } }
public void mapVolumeToSDC ( String volumeId , String sdcId ) throws Exception { log . info ( STR_ ) ; String uri = ScaleIOConstants . getMapVolumeToSDCURI ( volumeId ) ; ScaleIOMapVolumeToSDC mapParm = new ScaleIOMapVolumeToSDC ( ) ; mapParm . setSdcId ( sdcId ) ; mapParm . setAllowMultipleMappings ( STR_ ) ; post ( URI . create ( uri ) , getJsonForEntity ( mapParm ) ) ; }
public void addObscuredRecipient ( String playerName ) { obscuredRecipients . addElement ( playerName ) ; }
private static void replaceCollapsedByEclipseSourceRoots ( Element libElement , Library . ModifiableModel modifiableModel ) { String [ ] srcUrlsFromClasspath = modifiableModel . getUrls ( OrderRootType . SOURCES ) ; LOG . assertTrue ( srcUrlsFromClasspath . length <= NUM_ ) ; final String eclipseUrl = srcUrlsFromClasspath . length > NUM_ ? srcUrlsFromClasspath [ NUM_ ] : null ; for ( Element r : libElement . getChildren ( SRCROOT_ATTR ) ) { final String url = r . getAttributeValue ( STR_ ) ; final String bindAttr = r . getAttributeValue ( SRCROOT_BIND_ATTR ) ; boolean notBind = bindAttr != null && ! Boolean . parseBoolean ( bindAttr ) ; if ( notBind ) { modifiableModel . addRoot ( url , OrderRootType . SOURCES ) ; } else if ( eclipseUrl != null && areUrlsPointTheSame ( url , eclipseUrl ) && ! Comparing . strEqual ( url , eclipseUrl ) ) { modifiableModel . addRoot ( url , OrderRootType . SOURCES ) ; if ( srcUrlsFromClasspath != null && srcUrlsFromClasspath . length == NUM_ ) { modifiableModel . removeRoot ( eclipseUrl , OrderRootType . SOURCES ) ; srcUrlsFromClasspath = null ; } } } }
public static byte [ ] hexToBytes ( String hexString ) { byte [ ] result = new byte [ hexString . length ( ) / NUM_ ] ; for ( int i = NUM_ ; i < result . length ; ++ i ) { int offset = i . NUM_ ; result [ i ] = ( byte ) Integer . parseInt ( hexString . substring ( offset , offset + NUM_ ) , NUM_ ) ; } return result ; }
public void testSetBitNegativeOutside1 ( ) { byte aBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; int aSign = - NUM_ ; int number = NUM_ ; byte rBytes [ ] = { - NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , - NUM_ , - NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger result = aNumber . setBit ( number ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , - NUM_ , result . signum ( ) ) ; }
private static String replaceLast ( String str , char from , char to ) { int index = str . lastIndexOf ( from ) ; if ( index == - NUM_ ) return str ; return str . substring ( NUM_ , index ) + to + str . substring ( index + NUM_ ) ; }
public static String valueOf ( long value ) { return Long . toString ( value ) ; }
private static void cleanStaleInitiatorReferences ( ExportGroup exportGroup , DbClient dbClient ) { StringSet exportGroupInitiators = exportGroup . getInitiators ( ) ; if ( ! CollectionUtils . isEmpty ( exportGroupInitiators ) && ! CollectionUtils . isEmpty ( exportGroup . getExportMasks ( ) ) ) { Set < String > allMaskInitiators = new HashSet < > ( ) ; for ( String mask : exportGroup . getExportMasks ( ) ) { ExportMask maskObj = dbClient . queryObject ( ExportMask . class , URI . create ( mask ) ) ; if ( maskObj != null && ! CollectionUtils . isEmpty ( maskObj . getInitiators ( ) ) ) { allMaskInitiators . addAll ( maskObj . getInitiators ( ) ) ; } } Set < String > staleInitiators = Sets . difference ( exportGroupInitiators , allMaskInitiators ) ; if ( ! CollectionUtils . isEmpty ( staleInitiators ) ) { Collection < URI > staleInitiatorURIS = Collections2 . transform ( staleInitiators , CommonTransformerFunctions . FCTN_STRING_TO_URI ) ; exportGroup . removeInitiators ( new ArrayList < > ( staleInitiatorURIS ) ) ; _log . info ( STR_ , staleInitiatorURIS , exportGroup . getId ( ) ) ; } } }
public static < T > T findResourceByName ( Iterable < HasMetadata > entities , Class < T > clazz , String name ) { if ( entities != null ) { for ( HasMetadata entity : entities ) { if ( clazz . isInstance ( entity ) && Objects . equals ( name , getName ( entity ) ) ) { return clazz . cast ( entity ) ; } } } return null ; }
public static Map ordinalMap ( Iterator tuples , String field , Comparator cmp ) { Object [ ] o = ordinalArray ( tuples , field , cmp ) ; HashMap map = new HashMap ( ) ; for ( int i = NUM_ ; i < o . length ; ++ i ) map . put ( o [ i ] , new Integer ( i ) ) ; return map ; }
void addLineMonitor ( LineMonitor lm ) { if ( Printer . trace ) Printer . trace ( STR_ + lm + STR_ ) ; synchronized ( lineMonitors ) { if ( lineMonitors . indexOf ( lm ) >= NUM_ ) { if ( Printer . trace ) Printer . trace ( STR_ ) ; return ; } if ( Printer . debug ) Printer . debug ( STR_ + lm ) ; lineMonitors . add ( lm ) ; } synchronized ( this ) { notifyAll ( ) ; } if ( Printer . debug ) Printer . debug ( STR_ + lineMonitors . size ( ) + STR_ ) ; }
public static String toChar ( byte b ) { if ( b >= x20 ) { return Character . toString ( ( char ) b ) ; } else { return String . format ( STR_ , b ) ; } }
public void addNodes ( NodeIterator iterator ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; if ( null != iterator ) { Node obj ; while ( null != ( obj = iterator . nextNode ( ) ) ) { addElement ( obj ) ; } } }
public static double ptSegDist ( double x1 , double y1 , double x2 , double y2 , double px , double py ) { return Math . sqrt ( ptSegDistSq ( x1 , y1 , x2 , y2 , px , py ) ) ; }
MethodType asSpreaderType ( Class < ? > arrayType , int arrayLength ) { assert ( parameterCount ( ) >= arrayLength ) ; int spreadPos = ptypes . length - arrayLength ; if ( arrayLength == NUM_ ) return this ; if ( arrayType == Object [ ] . class ) { if ( isGeneric ( ) ) return this ; if ( spreadPos == NUM_ ) { MethodType res = genericMethodType ( arrayLength ) ; if ( rtype != Object . class ) { res = res . changeReturnType ( rtype ) ; } return res ; } } Class < ? > elemType = arrayType . getComponentType ( ) ; assert ( elemType != null ) ; for ( int i = spreadPos ; i < ptypes . length ; i ++ ) { if ( ptypes [ i ] != elemType ) { Class < ? > [ ] fixedPtypes = ptypes . clone ( ) ; Arrays . fill ( fixedPtypes , i , ptypes . length , elemType ) ; return methodType ( rtype , fixedPtypes ) ; } } return this ; }
public void put ( E e ) throws InterruptedException { if ( e == null ) throw new NullPointerException ( ) ; int c = - NUM_ ; Node < E > node = new Node < E > ( e ) ; final ReentrantLock putLock = this . putLock ; final AtomicInteger count = this . count ; putLock . lockInterruptibly ( ) ; try { while ( count . get ( ) == capacity ) { notFull . await ( ) ; } enqueue ( node ) ; c = count . getAndIncrement ( ) ; if ( c + NUM_ < capacity ) notFull . signal ( ) ; } finally { putLock . unlock ( ) ; } if ( c == NUM_ ) signalNotEmpty ( ) ; }
public static mxICell resolve ( mxICell root , String path ) { mxICell parent = root ; String [ ] tokens = path . split ( Pattern . quote ( PATH_SEPARATOR ) ) ; for ( int i = NUM_ ; i < tokens . length ; i ++ ) { parent = parent . getChildAt ( Integer . parseInt ( tokens [ i ] ) ) ; } return parent ; }
private static int nextNonQuoteIndex ( String trimmed , int i , boolean forward ) { while ( trimmed . charAt ( i ) == STR_ || trimmed . charAt ( i ) == STR_ || trimmed . charAt ( i ) == STR_ || trimmed . charAt ( i ) == STR_ || trimmed . charAt ( i ) == STR_ || trimmed . charAt ( i ) == STR_ || trimmed . charAt ( i ) == STR_ || trimmed . charAt ( i ) == STR_ ) { if ( forward ) i ++ ; else i -- ; } return i ; }
public static void reset ( ) { traceState . remove ( ) ; suspendedState . clear ( ) ; }
private String inclusiveSlice ( ) { if ( mark >= pos ) { return STR_ ; } return sign . substring ( mark , pos + NUM_ ) ; }
public byte [ ] toBytecode ( ) throws IOException , CannotCompileException { ByteArrayOutputStream barray = new ByteArrayOutputStream ( ) ; DataOutputStream out = new DataOutputStream ( barray ) ; try { toBytecode ( out ) ; } finally { out . close ( ) ; } return barray . toByteArray ( ) ; }
public static void serializePath ( final ObjectOutput os , final PathIterator pi ) throws IOException { os . writeObject ( pi . getWindingRule ( ) ) ; final List < java . io . Serializable > list = new ArrayList < java . io . Serializable > ( ) ; while ( ! pi . isDone ( ) ) { final float [ ] array = new float [ NUM_ ] ; final int type = pi . currentSegment ( array ) ; list . add ( type ) ; list . add ( array ) ; pi . next ( ) ; } os . writeObject ( list ) ; }
boolean findMarker ( ) throws IOException { if ( markerIndex == marker . length ) { return BOOL_ ; } if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + BytesUtil . toHexString ( marker ) + STR_ + nreads ) ; while ( markerIndex < marker . length ) { final int remtok = marker . length - markerIndex ; markerBB . limit ( remtok ) ; markerBB . position ( NUM_ ) ; final int rdLen = client . read ( markerBB ) ; if ( rdLen == - NUM_ ) { throw new IOException ( STR_ + nreads + STR_ + bytesRead ) ; } nreads ++ ; bytesRead += rdLen ; for ( int i = NUM_ ; i < rdLen ; i ++ ) { if ( markerBuffer [ i ] != marker [ markerIndex ] ) { if ( foundMarkerInInitialPosition ) { foundMarkerInInitialPosition = BOOL_ ; log . error ( STR_ ) ; } markerIndex = NUM_ ; if ( markerBuffer [ i ] == marker [ markerIndex ] ) { markerIndex ++ ; } } else { markerIndex ++ ; nmarkerbytematches ++ ; } } if ( nreads % NUM_ == NUM_ ) { if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + nreads + STR_ + bytesRead ) ; } } if ( markerIndex != marker . length ) { if ( log . isDebugEnabled ( ) ) log . debug ( STR_ ) ; return BOOL_ ; } else { if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + nreads + STR_ + nmarkerbytematches + STR_ ) ; return BOOL_ ; } }
public void parseLoggcFile ( InputStream loggcFileStream , DefaultMutableTreeNode root ) { BufferedReader bis = new BufferedReader ( new InputStreamReader ( loggcFileStream ) ) ; Vector histograms = new Vector ( ) ; try { while ( bis . ready ( ) ) { bis . mark ( getMarkSize ( ) ) ; String nextLine = bis . readLine ( ) ; if ( nextLine . startsWith ( STR_ ) ) { bis . reset ( ) ; histograms . add ( parseNextClassHistogram ( bis ) ) ; } } for ( int i = histograms . size ( ) - NUM_ ; i >= NUM_ ; i -- ) { DefaultMutableTreeNode dump = getNextDumpForHistogram ( root ) ; if ( dump != null ) { addHistogramToDump ( dump , ( HistogramTableModel ) histograms . get ( i ) ) ; } } } catch ( IOException ex ) { ex . printStackTrace ( ) ; } }
private void resolveTimeMacro ( StringBuffer result ) { Calendar calendar = new GregorianCalendar ( ) ; result . append ( calendar . get ( Calendar . YEAR ) + STR_ ) ; String month = calendar . get ( Calendar . MONTH ) + NUM_ + STR_ ; if ( month . length ( ) < NUM_ ) { month = STR_ + month ; } result . append ( month + STR_ ) ; String day = calendar . get ( Calendar . DAY_OF_MONTH ) + STR_ ; if ( day . length ( ) < NUM_ ) { day = STR_ + day ; } result . append ( day + STR_ ) ; int amPm = calendar . get ( Calendar . AM_PM ) ; String amPmString = amPm == Calendar . AM ? STR_ : STR_ ; result . append ( amPmString + STR_ ) ; String hour = calendar . get ( Calendar . HOUR ) + STR_ ; if ( hour . length ( ) < NUM_ ) { hour = STR_ + hour ; } result . append ( hour + STR_ ) ; String minute = calendar . get ( Calendar . MINUTE ) + STR_ ; if ( minute . length ( ) < NUM_ ) { minute = STR_ + minute ; } result . append ( minute + STR_ ) ; String second = calendar . get ( Calendar . SECOND ) + STR_ ; if ( second . length ( ) < NUM_ ) { second = STR_ + second ; } result . append ( second ) ; }
public boolean isEmpty ( ) { synchronized ( lock ) { return annotationsDrawOrder . isEmpty ( ) ; } }
default B append8bit ( @ NotNull CharSequence cs , int start , int end ) throws IllegalArgumentException , BufferOverflowException , BufferUnderflowException , IndexOutOfBoundsException { if ( cs instanceof BytesStore ) { return write ( ( BytesStore ) cs , ( long ) start , end ) ; } for ( int i = start ; i < end ; i ++ ) { char c = cs . charAt ( i ) ; if ( c > NUM_ ) c = STR_ ; writeByte ( ( byte ) c ) ; } return ( B ) this ; }
static void zero ( float [ ] [ ] array ) { for ( float [ ] aFloat : array ) { Arrays . fill ( aFloat , - NUM_ ) ; } }
@ Override public boolean contains ( Point2D . Double p ) { RoundRectangle2D . Double r = ( RoundRectangle2D . Double ) roundrect . clone ( ) ; double grow = AttributeKeys . getPerpendicularHitGrowth ( this ) ; r . x -= grow ; r . y -= grow ; r . width += grow . NUM_ ; r . height += grow . NUM_ ; r . arcwidth += grow . NUM_ ; r . archeight += grow . NUM_ ; return r . contains ( p ) ; }
private void downloadUpdateProp ( final boolean initialDownload ) { if ( bootProp != null ) { serverFolder = bootProp . getProperty ( STR_ , ClientGameConfiguration . get ( STR_ ) ) + STR_ ; String updatePropertiesFile = bootProp . getProperty ( STR_ , serverFolder + STR_ ) ; final HttpClient httpClient = new HttpClient ( updatePropertiesFile , initialDownload ) ; updateProp = httpClient . fetchProperties ( ) ; if ( updateProp != null && updateProp . containsKey ( STR_ ) ) { return ; } } String updatePropertiesFile = ClientGameConfiguration . get ( STR_ ) + STR_ ; HttpClient httpClient = new HttpClient ( updatePropertiesFile , initialDownload ) ; updateProp = httpClient . fetchProperties ( ) ; if ( updateProp != null && updateProp . containsKey ( STR_ ) ) { return ; } updatePropertiesFile = ClientGameConfiguration . get ( STR_ ) + STR_ ; httpClient = new HttpClient ( updatePropertiesFile , initialDownload ) ; updateProp = httpClient . fetchProperties ( ) ; }
private void mergeMethodHandleStore ( final int index , final MethodHandle methodHandle ) { localVariables . merge ( index , new MethodHandle ( methodHandle ) , null ) ; }
public final int read ( byte ba [ ] , int off , int len ) throws IOException { return is . read ( ba , off , len ) ; }
public ContextSuggestField ( String name , String value , int weight , CharSequence ... contexts ) { super ( name , value , weight ) ; validate ( value ) ; this . contexts = new HashSet < > ( ( contexts != null ) ? contexts . length : NUM_ ) ; if ( contexts != null ) { Collections . addAll ( this . contexts , contexts ) ; } }
@ Override protected byte [ ] decrypt ( byte type , byte [ ] fragment , int offset , int len ) { byte [ ] data = decCipher . update ( fragment , offset , len ) ; byte [ ] content ; if ( block_size != NUM_ ) { int padding_length = data [ data . length - NUM_ ] & xFF ; for ( int i = NUM_ ; i < padding_length ; i ++ ) { if ( ( data [ data . length - NUM_ - i ] & xFF ) != padding_length ) { throw new AlertException ( AlertProtocol . DECRYPTION_FAILED , new SSLProtocolException ( STR_ ) ) ; } } content = new byte [ data . length - hash_size - padding_length - NUM_ ] ; } else { content = new byte [ data . length - hash_size ] ; } byte [ ] mac_value ; mac_material_part [ NUM_ ] = type ; mac_material_part [ NUM_ ] = ( byte ) ( ( x00FF00 & content . length ) > > NUM_ ) ; mac_material_part [ NUM_ ] = ( byte ) ( x0000FF & content . length ) ; messageDigest . update ( mac_read_secret ) ; messageDigest . update ( pad_1 ) ; messageDigest . update ( read_seq_num ) ; messageDigest . update ( mac_material_part ) ; messageDigest . update ( data , NUM_ , content . length ) ; mac_value = messageDigest . digest ( ) ; messageDigest . update ( mac_read_secret ) ; messageDigest . update ( pad_2 ) ; messageDigest . update ( mac_value ) ; mac_value = messageDigest . digest ( ) ; if ( logger != null ) { logger . println ( STR_ ) ; logger . print ( data ) ; logger . println ( STR_ ) ; logger . print ( mac_value ) ; } for ( int i = NUM_ ; i < hash_size ; i ++ ) { if ( mac_value [ i ] != data [ i + content . length ] ) { throw new AlertException ( AlertProtocol . BAD_RECORD_MAC , new SSLProtocolException ( STR_ ) ) ; } } System . arraycopy ( data , NUM_ , content , NUM_ , content . length ) ; incSequenceNumber ( read_seq_num ) ; return content ; }
public Activity put ( String key , Activity activity ) { return ( Activity ) m_map . put ( key , activity ) ; }
public boolean isAbstract ( ) { return Modifier . isAbstract ( getAccessFlags ( ) ) ; }
private boolean journalRebuildRequired ( ) { final int redundantOpCompactThreshold = NUM_ ; return redundantOpCount >= redundantOpCompactThreshold && redundantOpCount >= lruEntries . size ( ) ; }
public void clearCurrentRequestTimedOut ( ) { if ( currentRequestTimedOut != null ) currentRequestTimedOut . clear ( ) ; currentRequestTimedOut = null ; }
protected void showPage ( int page ) { boolean isEmpty = page == PAGE_EMPTY ; Control control = isEmpty ? ( Control ) fEmptyPageLabel : getControl ( ) ; if ( isEmpty ) { setContentDescription ( STR_ ) ; clearViewer ( ) ; } fPagebook . showPage ( control ) ; }
@ Override public boolean equals ( Object o ) { if ( this == o ) return BOOL_ ; if ( o == null || getClass ( ) != o . getClass ( ) ) return BOOL_ ; Insets insets = ( Insets ) o ; if ( bottom != insets . bottom ) return BOOL_ ; if ( left != insets . left ) return BOOL_ ; if ( right != insets . right ) return BOOL_ ; if ( top != insets . top ) return BOOL_ ; return BOOL_ ; }
public void removeDocuments ( List < Query > queries ) { IndexWriter writer = getWriter ( ) ; for ( Query query : queries ) { try { writer . deleteDocuments ( query ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; closeWriter ( writer ) ; throw new RuntimeException ( e ) ; } } closeWriter ( writer ) ; }
protected String toString ( Object parameter ) { if ( parameter == null ) { return NULL_STR ; } try { String result = Misc . getAsString ( parameter ) ; if ( result . length ( ) > DEFAULT_ARG_STRING_MAX_LENGTH ) { result = result . substring ( NUM_ , DEFAULT_ARG_STRING_MAX_LENGTH ) + DEFAULT_MAX_STRING_ENDING ; } return result ; } catch ( Throwable e ) { return UNKNOWN ; } }
public static SecretKey generateSecretKey ( SecretKeyType secretKeyType , int keySize ) throws CryptoException { try { KeyGenerator keyGenerator = KeyGenerator . getInstance ( secretKeyType . jce ( ) , BOUNCY_CASTLE . jce ( ) ) ; keyGenerator . init ( keySize , SecureRandom . getInstance ( STR_ ) ) ; return keyGenerator . generateKey ( ) ; } catch ( GeneralSecurityException ex ) { throw new CryptoException ( MessageFormat . format ( res . getString ( STR_ ) , secretKeyType ) , ex ) ; } }
public CML deleteCML ( ISicresAbstractDocumentVO document ) { String id = document . getId ( ) ; Reference reference = new Reference ( STORE , id , null ) ; Predicate predicate = new Predicate ( new Reference [ ] { reference } , null , null ) ; CMLDelete delete = new CMLDelete ( predicate ) ; CML cml = new CML ( ) ; cml . setDelete ( new CMLDelete [ ] { delete } ) ; return cml ; }
private synchronized void eval ( ) throws MetadataEvaluationException { if ( cacheStrategy == CacheStrategy . NEVER_CACHE || internalValue . get ( ) == null ) { try { Object value = lazyValue . call ( ) ; if ( value == null ) { value = ACTUALLY_NULL ; } internalValue = new SoftReference < Object > ( value ) ; } catch ( Exception e ) { throw new MetadataEvaluationException ( e ) ; } } }
public void addEdgeToBounds ( S2Point from , S2Point to ) { if ( ! boundSet ) { boundSet = BOOL_ ; xmin = xmax = from . x ; ymin = ymax = from . y ; zmin = zmax = from . z ; } xmin = Math . min ( xmin , Math . min ( to . x , from . x ) ) ; ymin = Math . min ( ymin , Math . min ( to . y , from . y ) ) ; zmin = Math . min ( zmin , Math . min ( to . z , from . z ) ) ; xmax = Math . max ( xmax , Math . max ( to . x , from . x ) ) ; ymax = Math . max ( ymax , Math . max ( to . y , from . y ) ) ; zmax = Math . max ( zmax , Math . max ( to . z , from . z ) ) ; double approxArcLen = Math . abs ( from . x - to . x ) + Math . abs ( from . y - to . y ) + Math . abs ( from . z - to . z ) ; if ( approxArcLen < NUM_ ) { maxDeformation = Math . max ( maxDeformation , approxArcLen . NUM_ ) ; } else if ( approxArcLen < NUM_ ) { maxDeformation = Math . max ( maxDeformation , approxArcLen . NUM_ ) ; } else { maxDeformation = approxArcLen . NUM_ ; } }
@ Override public void write ( byte [ ] buffer , int offset , int length ) throws IOException { while ( ( mByteToSkip > NUM_ || mByteToCopy > NUM_ || mState != STATE_JPEG_DATA ) && length > NUM_ ) { if ( mByteToSkip > NUM_ ) { int byteToProcess = length > mByteToSkip ? mByteToSkip : length ; length -= byteToProcess ; mByteToSkip -= byteToProcess ; offset += byteToProcess ; } if ( mByteToCopy > NUM_ ) { int byteToProcess = length > mByteToCopy ? mByteToCopy : length ; out . write ( buffer , offset , byteToProcess ) ; length -= byteToProcess ; mByteToCopy -= byteToProcess ; offset += byteToProcess ; } if ( length == NUM_ ) { return ; } switch ( mState ) { case STATE_SOI : int byteRead = requestByteToBuffer ( NUM_ , buffer , offset , length ) ; offset += byteRead ; length -= byteRead ; if ( mBuffer . position ( ) < NUM_ ) { return ; } mBuffer . rewind ( ) ; if ( mBuffer . getShort ( ) != JpegHeader . SOI ) { throw new IOException ( STR_ ) ; } out . write ( mBuffer . array ( ) , NUM_ , NUM_ ) ; mState = STATE_FRAME_HEADER ; mBuffer . rewind ( ) ; writeExifData ( ) ; break ; case STATE_FRAME_HEADER : byteRead = requestByteToBuffer ( NUM_ , buffer , offset , length ) ; offset += byteRead ; length -= byteRead ; if ( mBuffer . position ( ) == NUM_ ) { short tag = mBuffer . getShort ( ) ; if ( tag == JpegHeader . EOI ) { out . write ( mBuffer . array ( ) , NUM_ , NUM_ ) ; mBuffer . rewind ( ) ; } } if ( mBuffer . position ( ) < NUM_ ) { return ; } mBuffer . rewind ( ) ; short marker = mBuffer . getShort ( ) ; if ( marker == JpegHeader . APP1 ) { mByteToSkip = ( mBuffer . getShort ( ) & x0000ffff ) - NUM_ ; mState = STATE_JPEG_DATA ; } else if ( ! JpegHeader . isSofMarker ( marker ) ) { out . write ( mBuffer . array ( ) , NUM_ , NUM_ ) ; mByteToCopy = ( mBuffer . getShort ( ) & x0000ffff ) - NUM_ ; } else { out . write ( mBuffer . array ( ) , NUM_ , NUM_ ) ; mState = STATE_JPEG_DATA ; } mBuffer . rewind ( ) ; } } if ( length > NUM_ ) { out . write ( buffer , offset , length ) ; } }
public static String hash ( String string ) { try { MessageDigest sha1 = MessageDigest . getInstance ( STR_ ) ; sha1 . update ( string . getBytes ( STR_ ) ) ; return Base64 . encode ( sha1 . digest ( ) ) ; } catch ( Exception ex ) { Debug debug = Debug . getInstance ( STR_ ) ; if ( debug . warningEnabled ( ) ) { debug . warning ( STR_ , ex ) ; } return null ; } }
static List < String > readExtensions ( final SubstringReader reader ) throws DecodeException { int length = NUM_ ; List < String > values ; reader . skipWhitespaces ( ) ; reader . mark ( ) ; try { char c = reader . read ( ) ; if ( c == STR_ ) { reader . mark ( ) ; while ( reader . read ( ) != STR_ ) { length ++ ; } reader . reset ( ) ; values = Collections . singletonList ( reader . read ( length ) ) ; reader . read ( ) ; } else if ( c == STR_ ) { reader . skipWhitespaces ( ) ; reader . mark ( ) ; c = reader . read ( ) ; if ( c == STR_ ) { values = Collections . emptyList ( ) ; } else { values = new ArrayList < > ( ) ; do { reader . reset ( ) ; values . add ( readQuotedString ( reader ) ) ; reader . skipWhitespaces ( ) ; reader . mark ( ) ; } while ( reader . read ( ) != STR_ ) ; values = Collections . unmodifiableList ( values ) ; } } else { do { length ++ ; } while ( reader . read ( ) != STR_ ) ; reader . reset ( ) ; values = Collections . singletonList ( reader . read ( length ) ) ; } return values ; } catch ( final StringIndexOutOfBoundsException e ) { throw DecodeException . error ( ERR_ATTR_SYNTAX_TRUNCATED_VALUE1 . get ( ) ) ; } }
private void NV21toI420SemiPlanar ( byte [ ] nv21bytes , byte [ ] i420bytes , int width , int height ) { System . arraycopy ( nv21bytes , NUM_ , i420bytes , NUM_ , width . height ) ; for ( int i = width . height ; i < nv21bytes . length ; i += NUM_ ) { i420bytes [ i ] = nv21bytes [ i + NUM_ ] ; i420bytes [ i + NUM_ ] = nv21bytes [ i ] ; } }
public int read ( ByteBuffer dst ) throws IOException { if ( ! dst . hasRemaining ( ) ) return NUM_ ; if ( ! isHandShakeComplete ( ) ) { if ( isBlocking ( ) ) { while ( ! isHandShakeComplete ( ) ) { processHandshake ( ) ; } } else { processHandshake ( ) ; if ( ! isHandShakeComplete ( ) ) { return NUM_ ; } } } int purged = readRemaining ( dst ) ; if ( purged != NUM_ ) return purged ; assert ( inData . position ( ) == NUM_ ) ; inData . clear ( ) ; if ( ! inCrypt . hasRemaining ( ) ) inCrypt . clear ( ) ; else inCrypt . compact ( ) ; if ( isBlocking ( ) || readEngineResult . getStatus ( ) == Status . BUFFER_UNDERFLOW ) if ( socketChannel . read ( inCrypt ) == - NUM_ ) { return - NUM_ ; } inCrypt . flip ( ) ; unwrap ( ) ; int transfered = transfereTo ( inData , dst ) ; if ( transfered == NUM_ && isBlocking ( ) ) { return read ( dst ) ; } return transfered ; }
private List < FacetResult > search ( ) throws IOException { DirectoryReader indexReader = DirectoryReader . open ( indexDir ) ; IndexSearcher searcher = new IndexSearcher ( indexReader ) ; SortedSetDocValuesReaderState state = new DefaultSortedSetDocValuesReaderState ( indexReader ) ; FacetsCollector fc = new FacetsCollector ( ) ; FacetsCollector . search ( searcher , new MatchAllDocsQuery ( ) , NUM_ , fc ) ; Facets facets = new SortedSetDocValuesFacetCounts ( state , fc ) ; List < FacetResult > results = new ArrayList < > ( ) ; results . add ( facets . getTopChildren ( NUM_ , STR_ ) ) ; results . add ( facets . getTopChildren ( NUM_ , STR_ ) ) ; indexReader . close ( ) ; return results ; }
public Resource mapRelations ( Resource object , JSONObject jsonObject , List < Resource > included ) throws Exception { HashMap < String , String > relationshipNames = getRelationshipNames ( object . getClass ( ) ) ; for ( String relationship : relationshipNames . keySet ( ) ) { JSONObject relationJsonObject = null ; try { relationJsonObject = jsonObject . getJSONObject ( relationship ) ; } catch ( JSONException e ) { Logger . debug ( STR_ + relationship + STR_ ) ; continue ; } JSONObject relationDataObject = null ; try { relationDataObject = relationJsonObject . getJSONObject ( STR_ ) ; Resource relationObject = Factory . newObjectFromJSONObject ( relationDataObject , null ) ; relationObject = matchIncludedToRelation ( relationObject , included ) ; mDeserializer . setField ( object , relationshipNames . get ( relationship ) , relationObject ) ; } catch ( JSONException e ) { Logger . debug ( STR_ ) ; } JSONArray relationDataArray = null ; try { relationDataArray = relationJsonObject . getJSONArray ( STR_ ) ; List < Resource > relationArray = Factory . newObjectFromJSONArray ( relationDataArray , null ) ; relationArray = matchIncludedToRelation ( relationArray , included ) ; mDeserializer . setField ( object , relationshipNames . get ( relationship ) , relationArray ) ; } catch ( JSONException e ) { Logger . debug ( STR_ ) ; } } return object ; }
public int size ( ) { return rdns . size ( ) ; }
@ Override public void doInitialize ( UimaContext aContext ) throws ResourceInitializationException { DB db = mongoResource . getDB ( ) ; collection = db . getCollection ( collectionName ) ; collection . createIndex ( new BasicDBObject ( FIELD_UNIQUE_ID , NUM_ ) ) ; collection . createIndex ( new BasicDBObject ( FIELD_PUBLISHEDIDS , NUM_ ) ) ; stopFeatures = new HashSet < String > ( ) ; stopFeatures . add ( STR_ ) ; stopFeatures . add ( STR_ ) ; maxContentLength = ConfigUtils . stringToInteger ( maxContentLengthString , NUM_ ) ; }
protected void drawHighFarOut ( double aRadius , Graphics2D g2 , double xx , double m ) { double side = aRadius . NUM_ ; g2 . draw ( new Line2D . Double ( xx - side , m + side , xx + side , m + side ) ) ; g2 . draw ( new Line2D . Double ( xx - side , m + side , xx , m ) ) ; g2 . draw ( new Line2D . Double ( xx + side , m + side , xx , m ) ) ; }
private void findLargeItemSets ( ) throws Exception { ArrayList < Object > kMinusOneSets , kSets ; Hashtable < ItemSet , Integer > hashtable ; int necSupport , i = NUM_ ; necSupport = ( int ) ( m_minSupport . m_instances . numInstances ( ) + NUM_ ) ; kSets = AprioriItemSet . singletons ( m_instances , m_treatZeroAsMissing ) ; if ( m_treatZeroAsMissing ) { AprioriItemSet . upDateCountersTreatZeroAsMissing ( kSets , m_instances ) ; } else { AprioriItemSet . upDateCounters ( kSets , m_instances ) ; } kSets = AprioriItemSet . deleteItemSets ( kSets , necSupport , m_instances . numInstances ( ) ) ; if ( kSets . size ( ) == NUM_ ) { return ; } do { m_Ls . add ( kSets ) ; kMinusOneSets = kSets ; kSets = AprioriItemSet . mergeAllItemSets ( kMinusOneSets , i , m_instances . numInstances ( ) ) ; hashtable = AprioriItemSet . getHashtable ( kMinusOneSets , kMinusOneSets . size ( ) ) ; m_hashtables . add ( hashtable ) ; kSets = AprioriItemSet . pruneItemSets ( kSets , hashtable ) ; if ( m_treatZeroAsMissing ) { AprioriItemSet . upDateCountersTreatZeroAsMissing ( kSets , m_instances ) ; } else { AprioriItemSet . upDateCounters ( kSets , m_instances ) ; } kSets = AprioriItemSet . deleteItemSets ( kSets , necSupport , m_instances . numInstances ( ) ) ; i ++ ; } while ( kSets . size ( ) > NUM_ ) ; }
public boolean isInAllowed ( int x , int y ) { for ( Shape r : arrivingBarriers ) { if ( r . contains ( x , y ) ) { return BOOL_ ; } } return BOOL_ ; }
public void removePluginInterface ( String interfacename ) throws SMSException , SSOException { SMSEntry . validateToken ( token ) ; validateServiceSchemaManagerImpl ( ) ; Document schemaDoc = ssm . getDocumentCopy ( ) ; Node schemaNode = XMLUtils . getRootNode ( schemaDoc , SMSUtils . SCHEMA ) ; Node pluginNode = XMLUtils . getNamedChildNode ( schemaNode , SMSUtils . PLUGIN_INTERFACE , SMSUtils . NAME , interfacename ) ; if ( pluginNode != null ) { schemaNode . removeChild ( pluginNode ) ; replaceSchema ( schemaDoc ) ; } }
public IPAddressName ( String name ) throws IOException { if ( name == null || name . length ( ) == NUM_ ) { throw new IOException ( STR_ ) ; } if ( name . charAt ( name . length ( ) - NUM_ ) == STR_ ) { throw new IOException ( STR_ + name ) ; } if ( name . indexOf ( STR_ ) >= NUM_ ) { parseIPv6 ( name ) ; isIPv4 = BOOL_ ; } else if ( name . indexOf ( STR_ ) >= NUM_ ) { parseIPv4 ( name ) ; isIPv4 = BOOL_ ; } else { throw new IOException ( STR_ + name ) ; } }
private boolean isSameFile ( Path first , Path second ) throws IOException { boolean sameFileSize = Files . size ( first ) == Files . size ( second ) ; if ( ! sameFileSize ) { return BOOL_ ; } byte [ ] firstBytes = Files . readAllBytes ( first ) ; byte [ ] secondBytes = Files . readAllBytes ( second ) ; return Arrays . equals ( firstBytes , secondBytes ) ; }
public static org . opcfoundation . ua . transport . security . KeyPair loadKeyPairFromProtectedStore ( String storeLocation , String alias , String storePW , String privatePW ) throws KeyStoreException , IOException , NoSuchAlgorithmException , CertificateException , UnrecoverableKeyException { KeyStore store = null ; store = KeyStore . getInstance ( STR_ ) ; File keystoreFile = new File ( storeLocation ) ; FileInputStream in = new FileInputStream ( keystoreFile ) ; store . load ( in , storePW . toCharArray ( ) ) ; in . close ( ) ; X509Certificate cert = ( X509Certificate ) store . getCertificate ( alias ) ; RSAPrivateKey key = ( RSAPrivateKey ) store . getKey ( alias , privatePW . toCharArray ( ) ) ; return new org . opcfoundation . ua . transport . security . KeyPair ( new Cert ( cert ) , new PrivKey ( key ) ) ; }
@ Override public GraphQuery hasNot ( final String key , final Object value ) { criteria . add ( new HasNot ( key , value ) ) ; return this ; }
private void initComputeProgram ( ) { IntBuffer workGroupSize = BufferUtils . createIntBuffer ( NUM_ ) ; glGetProgramiv ( computeProgram , GL_COMPUTE_WORK_GROUP_SIZE , workGroupSize ) ; workGroupSizeX = workGroupSize . get ( NUM_ ) ; workGroupSizeY = workGroupSize . get ( NUM_ ) ; int boxesResourceIndex = glGetProgramResourceIndex ( computeProgram , GL_SHADER_STORAGE_BLOCK , STR_ ) ; IntBuffer props = BufferUtils . createIntBuffer ( NUM_ ) ; IntBuffer params = BufferUtils . createIntBuffer ( NUM_ ) ; props . put ( NUM_ , GL_BUFFER_BINDING ) ; glGetProgramResourceiv ( computeProgram , GL_SHADER_STORAGE_BLOCK , boxesResourceIndex , props , null , params ) ; boxesSsboBinding = params . get ( NUM_ ) ; int uniformsResourceIndex = glGetProgramResourceIndex ( computeProgram , GL_UNIFORM_BLOCK , STR_ ) ; glGetProgramResourceiv ( computeProgram , GL_UNIFORM_BLOCK , uniformsResourceIndex , props , null , params ) ; computeUboBinding = params . get ( NUM_ ) ; int loc = glGetUniformLocation ( computeProgram , STR_ ) ; glGetUniformiv ( computeProgram , loc , params ) ; framebufferImageBinding = params . get ( NUM_ ) ; loc = glGetUniformLocation ( computeProgram , STR_ ) ; glGetUniformiv ( computeProgram , loc , params ) ; worldPositionImageBinding = params . get ( NUM_ ) ; loc = glGetUniformLocation ( computeProgram , STR_ ) ; glGetUniformiv ( computeProgram , loc , params ) ; worldNormalImageBinding = params . get ( NUM_ ) ; }
TSResponse ( byte [ ] tsReply ) throws IOException { parse ( tsReply ) ; }
public static void executeCommand ( ProcessBuilder p ) throws IOException { Process proc = p . start ( ) ; try ( BufferedReader stdInput = new BufferedReader ( new InputStreamReader ( proc . getInputStream ( ) ) ) ; BufferedReader stdError = new BufferedReader ( new InputStreamReader ( proc . getErrorStream ( ) ) ) ) { logger . info ( STR_ ) ; String s ; while ( ( s = stdInput . readLine ( ) ) != null ) { logger . info ( s ) ; } logger . info ( STR_ ) ; while ( ( s = stdError . readLine ( ) ) != null ) { logger . info ( s ) ; } } }
public boolean pageSetupDialog ( PrinterJob job ) { PrintRequestAttributeSet prats = getPrintRequestAttributeSet ( ) ; PageFormat pf = job . pageDialog ( prats ) ; setPrintRequestAttributeSet ( prats ) ; return BOOL_ ; }
public static void assertNotEquals ( BufferedImage image1 , BufferedImage image2 ) { assertNotEquals ( STR_ , image1 , image2 ) ; }
public Depend ( PathImpl source , long digest , boolean requireSource ) { this ( source ) ; long newDigest = source . getCrc64 ( ) ; _requireSource = requireSource ; if ( newDigest == digest ) { } else if ( ! requireSource && newDigest == NUM_ ) { } else if ( newDigest == NUM_ ) { if ( log . isLoggable ( Level . FINE ) ) log . fine ( _source . getNativePath ( ) + STR_ ) ; _isDigestModified = BOOL_ ; } else { _isDigestModified = BOOL_ ; } }
public static boolean stringToFile ( final String data , final File targetFile , final boolean doAppend ) { if ( targetFile == null || ! isWritable ( targetFile , BOOL_ ) ) { Log . e ( FileUtils . class , STR_ ) ; return BOOL_ ; } boolean isSucceed = BOOL_ ; try { final FileWriter out = new FileWriter ( targetFile , doAppend ) ; out . write ( data ) ; out . flush ( ) ; out . close ( ) ; } catch ( IOException e ) { isSucceed = BOOL_ ; } return isSucceed ; }
@ Override public void cascadeRegisterNewIfRequired ( Object object , UnitOfWorkImpl uow , Map visitedObjects ) { cascadeRegisterNewIfRequired ( object , uow , visitedObjects , BOOL_ ) ; }
public void initialize ( Map configParams ) throws PolicyException { if ( configParams == null ) { throw ( new PolicyException ( ResBundleUtils . rbName , STR_ , null , null ) ) ; } String configuredLdapServer = ( String ) configParams . get ( PolicyConfig . LDAP_SERVER ) ; if ( configuredLdapServer == null ) { debug . error ( STR_ + STR_ + STR_ + STR_ + STR_ ) ; throw ( new PolicyException ( ResBundleUtils . rbName , STR_ , null , null ) ) ; } ldapServer = configuredLdapServer . toLowerCase ( ) ; localDS = PolicyUtils . isLocalDS ( ldapServer ) ; aliasEnabled = Boolean . valueOf ( ( String ) configParams . get ( PolicyConfig . USER_ALIAS_ENABLED ) ) ; String authid = ( String ) configParams . get ( PolicyConfig . LDAP_BIND_DN ) ; String authpw = ( String ) configParams . get ( PolicyConfig . LDAP_BIND_PASSWORD ) ; if ( authpw != null ) { authpw = PolicyUtils . decrypt ( authpw ) ; } baseDN = ( String ) configParams . get ( PolicyConfig . LDAP_USERS_BASE_DN ) ; userSearchFilter = ( String ) configParams . get ( PolicyConfig . LDAP_USERS_SEARCH_FILTER ) ; String scope = ( String ) configParams . get ( PolicyConfig . LDAP_USERS_SEARCH_SCOPE ) ; if ( scope . equalsIgnoreCase ( LDAP_SCOPE_BASE ) ) { userSearchScope = SearchScope . BASE_OBJECT ; } else if ( scope . equalsIgnoreCase ( LDAP_SCOPE_ONE ) ) { userSearchScope = SearchScope . SINGLE_LEVEL ; } else { userSearchScope = SearchScope . WHOLE_SUBTREE ; } userRDNAttrName = ( String ) configParams . get ( PolicyConfig . LDAP_USER_SEARCH_ATTRIBUTE ) ; int minPoolSize ; int maxPoolSize ; try { timeLimit = Integer . parseInt ( ( String ) configParams . get ( PolicyConfig . LDAP_SEARCH_TIME_OUT ) ) ; maxResults = Integer . parseInt ( ( String ) configParams . get ( PolicyConfig . LDAP_SEARCH_LIMIT ) ) ; minPoolSize = Integer . parseInt ( ( String ) configParams . get ( PolicyConfig . LDAP_CONNECTION_POOL_MIN_SIZE ) ) ; maxPoolSize = Integer . parseInt ( ( String ) configParams . get ( PolicyConfig . LDAP_CONNECTION_POOL_MAX_SIZE ) ) ; } catch ( NumberFormatException nfe ) { throw ( new PolicyException ( nfe ) ) ; } boolean sslEnabled = Boolean . valueOf ( ( String ) configParams . get ( PolicyConfig . LDAP_SSL_ENABLED ) ) ; Set orgNameSet = ( Set ) configParams . get ( PolicyManager . ORGANIZATION_NAME ) ; if ( ( orgNameSet != null ) && ( ! orgNameSet . isEmpty ( ) ) ) { Iterator items = orgNameSet . iterator ( ) ; orgName = ( String ) items . next ( ) ; } if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + STR_ + ldapServer + STR_ + authid + STR_ + baseDN + STR_ + userSearchFilter + STR_ + userRDNAttrName + STR_ + timeLimit + STR_ + maxResults + STR_ + minPoolSize + STR_ + maxPoolSize + STR_ + sslEnabled + STR_ + orgName ) ; } LDAPConnectionPools . initConnectionPool ( ldapServer , authid , authpw , sslEnabled , minPoolSize , maxPoolSize ) ; connPool = LDAPConnectionPools . getConnectionPool ( ldapServer ) ; initialized = BOOL_ ; }
public static boolean parseBool ( String s ) { if ( s != null ) { if ( s . startsWith ( STR_ ) || s . startsWith ( STR_ ) || s . startsWith ( STR_ ) ) { return BOOL_ ; } if ( s . startsWith ( STR_ ) || s . startsWith ( STR_ ) || s . equals ( STR_ ) ) { return BOOL_ ; } } throw new SolrException ( SolrException . ErrorCode . BAD_REQUEST , STR_ + s ) ; }
private static void readDNA ( String filename ) { try { LineNumberReader in = new LineNumberReader ( new FileReader ( filename ) ) ; processOneLine ( in , STR_ , compilationRates ) ; processOneLine ( in , STR_ , speedupRates ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; VM . sysFail ( STR_ ) ; } }
public void test_Of_EEEE ( ) { EnumSet < EnumWithInnerClass > enumSet = EnumSet . of ( EnumWithInnerClass . a , EnumWithInnerClass . b , EnumWithInnerClass . c , EnumWithInnerClass . d ) ; assertEquals ( STR_ , NUM_ , enumSet . size ( ) ) ; assertTrue ( STR_ , enumSet . contains ( EnumWithInnerClass . a ) ) ; assertTrue ( STR_ , enumSet . contains ( EnumWithInnerClass . d ) ) ; try { EnumSet . of ( ( EnumWithInnerClass ) null , null , null , null ) ; fail ( STR_ ) ; } catch ( NullPointerException npe ) { } EnumSet < HugeEnumWithInnerClass > hugeEnumSet = EnumSet . of ( HugeEnumWithInnerClass . a , HugeEnumWithInnerClass . b , HugeEnumWithInnerClass . c , HugeEnumWithInnerClass . d ) ; assertEquals ( NUM_ , hugeEnumSet . size ( ) ) ; assertTrue ( hugeEnumSet . contains ( HugeEnumWithInnerClass . a ) ) ; assertTrue ( hugeEnumSet . contains ( HugeEnumWithInnerClass . d ) ) ; try { EnumSet . of ( ( HugeEnumWithInnerClass ) null , null , null , null ) ; fail ( STR_ ) ; } catch ( NullPointerException npe ) { } }
Builder ( URL swaggerUrl ) { try { this . swaggerLocation = swaggerUrl . toURI ( ) ; } catch ( URISyntaxException e ) { throw new IllegalArgumentException ( STR_ , e ) ; } this . swagger = readSwagger ( swaggerUrl . toString ( ) ) ; }
@ Override public void onSaveInstanceState ( @ NonNull Bundle savedInstanceState ) { savedInstanceState . putParcelable ( LOCATION_KEY , currentLocation ) ; if ( lastLocationUpdateTime != null ) { savedInstanceState . putLong ( LAST_LOCATION_UPDATE_TIME_STRING_KEY , lastLocationUpdateTime . getTime ( ) ) ; } if ( lastWifiScanTime != null ) { savedInstanceState . putLong ( LAST_WIFI_SCAN_TIME_STRING_KEY , lastWifiScanTime . getTime ( ) ) ; } savedInstanceState . putBoolean ( LOGGING_ENABLED_KEY , loggingEnabled ) ; super . onSaveInstanceState ( savedInstanceState ) ; }
public static String removeEmptyLines ( String text ) { text = text . replaceAll ( STR_ + ChineseLanguageConstants . SPACE [ NUM_ ] + STR_ , STR_ ) ; text = text . replaceAll ( STR_ + ChineseLanguageConstants . SPACE [ NUM_ ] + STR_ , STR_ ) ; return text ; }
public void keepOnly ( Set < IVarAbstraction > usefulPointers ) { Set < IVarAbstraction > reps = new HashSet < IVarAbstraction > ( ) ; for ( IVarAbstraction pn : usefulPointers ) { reps . add ( pn . getRepresentative ( ) ) ; } usefulPointers . addAll ( reps ) ; reps = null ; for ( IVarAbstraction pn : pointers ) { if ( ! usefulPointers . contains ( pn ) ) pn . deleteAll ( ) ; } System . gc ( ) ; }
public static String encryptCFB ( final byte [ ] concatenatedHashValue , final Long turnoverCounter , final SecretKey symmetricKey , int turnOverCounterLengthInBytes ) throws NoSuchAlgorithmException , NoSuchProviderException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException , IllegalBlockSizeException , BadPaddingException { final ByteBuffer byteBufferIV = ByteBuffer . allocate ( NUM_ ) ; byteBufferIV . put ( concatenatedHashValue ) ; final byte [ ] IV = byteBufferIV . array ( ) ; final ByteBuffer byteBufferData = ByteBuffer . allocate ( NUM_ ) ; byteBufferData . putLong ( turnoverCounter ) ; final byte [ ] data = byteBufferData . array ( ) ; byte [ ] turnOverCounterByteRep = get2ComplementRepForLong ( turnoverCounter , turnOverCounterLengthInBytes ) ; System . arraycopy ( turnOverCounterByteRep , NUM_ , data , NUM_ , turnOverCounterByteRep . length ) ; final IvParameterSpec ivSpec = new IvParameterSpec ( IV ) ; final Cipher cipher = Cipher . getInstance ( STR_ , STR_ ) ; cipher . init ( Cipher . ENCRYPT_MODE , symmetricKey , ivSpec ) ; final byte [ ] encryptedTurnOverValueComplete = cipher . doFinal ( data ) ; final byte [ ] encryptedTurnOverValue = new byte [ turnOverCounterLengthInBytes ] ; System . arraycopy ( encryptedTurnOverValueComplete , NUM_ , encryptedTurnOverValue , NUM_ , turnOverCounterLengthInBytes ) ; final String base64EncryptedTurnOverValue = CashBoxUtils . base64Encode ( encryptedTurnOverValue , BOOL_ ) ; return base64EncryptedTurnOverValue ; }
String publicNameFromDiskName ( String diskName ) { if ( ! shouldDiskNameBeVisible ( diskName ) ) { throw new IllegalArgumentException ( STR_ + diskName ) ; } return diskName . substring ( mFilePrefix . length ( ) , diskName . length ( ) ) ; }
public double [ ] predict ( FVec feat ) { return predict ( feat , BOOL_ ) ; }
public static < A > A [ ] append ( final A [ ] a , final A [ ] b ) { final int alen = a . length ; final int blen = b . length ; final A [ ] res = Arrays . copyOf ( a , alen + blen ) ; System . arraycopy ( b , NUM_ , res , alen , blen ) ; return res ; }
public boolean addListener ( @ NotNull SoftWrapAwareDocumentParsingListener listener ) { return myListeners . add ( listener ) ; }
private void assertArrayEquals ( double [ ] expected , double [ ] actual , double delta , boolean checkNaN ) { Assert . assertEquals ( expected . length , actual . length ) ; for ( int index = NUM_ ; index < actual . length ; index ++ ) { double d1 = expected [ index ] ; double d2 = actual [ index ] ; if ( Double . isNaN ( d1 ) || Double . isNaN ( d2 ) ) { if ( checkNaN ) { Assert . assertTrue ( Double . isNaN ( d1 ) == Double . isNaN ( d2 ) ) ; } Assert . assertTrue ( BOOL_ ) ; } else { Assert . assertEquals ( d1 , d2 , delta ) ; } } }
protected void addToPopulation ( Solution newSolution ) { List < Integer > dominates = new ArrayList < Integer > ( ) ; boolean dominated = BOOL_ ; for ( int i = NUM_ ; i < population . size ( ) ; i ++ ) { int flag = dominanceComparator . compare ( newSolution , population . get ( i ) ) ; if ( flag < NUM_ ) { dominates . add ( i ) ; } else if ( flag > NUM_ ) { dominated = BOOL_ ; } } if ( ! dominates . isEmpty ( ) ) { population . remove ( dominates . get ( PRNG . nextInt ( dominates . size ( ) ) ) ) ; population . add ( newSolution ) ; } else if ( ! dominated ) { population . remove ( PRNG . nextInt ( population . size ( ) ) ) ; population . add ( newSolution ) ; } }
public void updateMaxTextWidths ( float requiredWidth , float matchContentsWidth ) { mMaxRequiredWidth = Math . max ( mMaxRequiredWidth , requiredWidth ) ; mMaxMatchContentsWidth = Math . max ( mMaxMatchContentsWidth , matchContentsWidth ) ; }
private String generateBlendModeImport ( BlendMode blendMode ) { if ( blendMode == BlendMode . COLOR ) return STR_ ; else if ( blendMode == BlendMode . COLORBURN ) return STR_ ; else if ( blendMode == BlendMode . COLORDODGE ) return STR_ ; else if ( blendMode == BlendMode . EXCLUSION ) return STR_ ; else if ( blendMode == BlendMode . HUE ) return STR_ ; else if ( blendMode == BlendMode . LUMINOSITY ) return STR_ ; else if ( blendMode == BlendMode . SATURATION ) return STR_ ; else if ( blendMode == BlendMode . SOFTLIGHT ) return STR_ ; else return null ; }
public static String parseIntToMetricSuffix ( int x ) { String xint = String . valueOf ( x ) ; if ( xint . endsWith ( STR_ ) ) { xint = xint . replaceAll ( STR_ , STR_ ) ; } else if ( xint . endsWith ( STR_ ) ) { xint = xint . replaceAll ( STR_ , STR_ ) ; } return xint ; }
public SmAuthStatus query ( String parameter , String secret , SmAuthQueryCode request , SmAuthQueryResponse response ) { if ( null == response ) { return SmAuthStatus . SMAUTH_FAILURE ; } if ( SmAuthQueryCode . SMAUTH_QUERY_DESCRIPTION == request ) { response . setResponseBuffer ( SCHEME_DESCRIPTION ) ; response . setResponseCode ( SCHEME_VERSION ) ; } else if ( SmAuthQueryCode . SMAUTH_QUERY_CREDENTIALS_REQ == request ) { response . setResponseCode ( SmAuthQueryResponse . SMAUTH_CRED_BASIC ) ; } else { return SmAuthStatus . SMAUTH_FAILURE ; } return SmAuthStatus . SMAUTH_SUCCESS ; }
protected void addAllTransitiveJars ( WarArchiveMerger wam ) throws MojoExecutionException { DependencyCalculator dc = new DependencyCalculator ( artifactFactory , resolver , localRepository , remoteRepositories , mavenProject , mavenProjectBuilder , installer , container ) ; try { for ( File f : dc . execute ( ) ) { wam . addMergeItem ( f ) ; } } catch ( Exception ex ) { throw new MojoExecutionException ( STR_ , ex ) ; } }
private void add ( int col , GraphicalNode graphicalNode ) { myGraphicalNodes . remove ( graphicalNode ) ; if ( nbCols - NUM_ < col ) { nbCols = col + NUM_ ; } int row = NUM_ ; while ( isOccupied ( row , col ) ) { row ++ ; } graphicalNode . row = row ; graphicalNode . col = col ; myGraphicalNodes . add ( graphicalNode ) ; }
private int addTonalComponents ( float [ ] spectrum , int numComponents , TonalComponent [ ] components ) { int lastPos = - NUM_ ; for ( int i = NUM_ ; i < numComponents ; i ++ ) { lastPos = Math . max ( components [ i ] . pos + components [ i ] . numCoefs , lastPos ) ; for ( int j = NUM_ ; j < components [ i ] . numCoefs ; j ++ ) { spectrum [ components [ i ] . pos + j ] += components [ i ] . coef [ j ] ; } } return lastPos ; }
public static List < UserLayer > extractUserLayers ( StyledLayerDescriptor sld ) { List < UserLayer > userLayerList = new ArrayList < UserLayer > ( ) ; if ( sld != null ) { for ( StyledLayer layer : sld . layers ( ) ) { if ( layer instanceof UserLayer ) { UserLayer userLayer = ( UserLayer ) layer ; userLayerList . add ( userLayer ) ; } } } return userLayerList ; }
public static void closeQuiet ( @ Nullable Selector rsrc ) { if ( rsrc != null ) try { if ( rsrc . isOpen ( ) ) rsrc . close ( ) ; } catch ( IOException ignored ) { } }
private LinkedList < Diff > diff_main ( String text1 , String text2 , boolean checklines , long deadline ) { if ( text1 == null || text2 == null ) { throw new IllegalArgumentException ( STR_ ) ; } LinkedList < Diff > diffs ; if ( text1 . equals ( text2 ) ) { diffs = new LinkedList < Diff > ( ) ; if ( text1 . length ( ) != NUM_ ) { diffs . add ( new Diff ( Operation . EQUAL , text1 ) ) ; } return diffs ; } int commonlength = diff_commonPrefix ( text1 , text2 ) ; String commonprefix = text1 . substring ( NUM_ , commonlength ) ; text1 = text1 . substring ( commonlength ) ; text2 = text2 . substring ( commonlength ) ; commonlength = diff_commonSuffix ( text1 , text2 ) ; String commonsuffix = text1 . substring ( text1 . length ( ) - commonlength ) ; text1 = text1 . substring ( NUM_ , text1 . length ( ) - commonlength ) ; text2 = text2 . substring ( NUM_ , text2 . length ( ) - commonlength ) ; diffs = diff_compute ( text1 , text2 , checklines , deadline ) ; if ( commonprefix . length ( ) != NUM_ ) { diffs . addFirst ( new Diff ( Operation . EQUAL , commonprefix ) ) ; } if ( commonsuffix . length ( ) != NUM_ ) { diffs . addLast ( new Diff ( Operation . EQUAL , commonsuffix ) ) ; } diff_cleanupMerge ( diffs ) ; return diffs ; }
public static boolean createCompactionRequiredFile ( String metaFolderPath , CompactionType compactionType ) { String statusFile ; if ( compactionType . equals ( CompactionType . MINOR_COMPACTION ) ) { statusFile = metaFolderPath + CarbonCommonConstants . FILE_SEPARATOR + CarbonCommonConstants . minorCompactionRequiredFile ; } else { statusFile = metaFolderPath + CarbonCommonConstants . FILE_SEPARATOR + CarbonCommonConstants . majorCompactionRequiredFile ; } try { if ( ! FileFactory . isFileExist ( statusFile , FileFactory . getFileType ( statusFile ) ) ) { if ( FileFactory . createNewFile ( statusFile , FileFactory . getFileType ( statusFile ) ) ) { LOGGER . info ( STR_ + statusFile ) ; return BOOL_ ; } else { LOGGER . error ( STR_ + statusFile ) ; return BOOL_ ; } } else { LOGGER . info ( STR_ + statusFile + STR_ ) ; } } catch ( IOException e ) { LOGGER . error ( STR_ + e . getMessage ( ) ) ; } return BOOL_ ; }
private boolean allowNotificationEmission ( ObjectName name , TargetedNotification tn ) { try { if ( checkNotificationEmission ) { checkMBeanPermission ( name , STR_ ) ; } if ( notificationAccessController != null ) { notificationAccessController . fetchNotification ( connectionId , name , tn . getNotification ( ) , getSubject ( ) ) ; } return BOOL_ ; } catch ( SecurityException e ) { if ( logger . debugOn ( ) ) { logger . debug ( STR_ , STR_ + tn . getNotification ( ) + STR_ + STR_ ) ; } return BOOL_ ; } catch ( Exception e ) { if ( logger . debugOn ( ) ) { logger . debug ( STR_ , STR_ + tn . getNotification ( ) + STR_ + STR_ + e ) ; } return BOOL_ ; } }
public void updateThroughput ( long currentTime ) { throughputCalculationLock . lock ( ) ; try { int interval = ( int ) ( currentTime - lastThroughputCalculationTime ) ; long minInterval = getThroughputCalculationIntervalInMillis ( ) ; if ( ( minInterval == NUM_ ) || ( interval < minInterval ) ) { return ; } long readBytes = this . readBytes ; long writtenBytes = this . writtenBytes ; long readMessages = this . readMessages ; long writtenMessages = this . writtenMessages ; readBytesThroughput = ( readBytes - lastReadBytes ) . NUM_ / interval ; writtenBytesThroughput = ( writtenBytes - lastWrittenBytes ) . NUM_ / interval ; readMessagesThroughput = ( readMessages - lastReadMessages ) . NUM_ / interval ; writtenMessagesThroughput = ( writtenMessages - lastWrittenMessages ) . NUM_ / interval ; if ( readBytesThroughput > largestReadBytesThroughput ) { largestReadBytesThroughput = readBytesThroughput ; } if ( writtenBytesThroughput > largestWrittenBytesThroughput ) { largestWrittenBytesThroughput = writtenBytesThroughput ; } if ( readMessagesThroughput > largestReadMessagesThroughput ) { largestReadMessagesThroughput = readMessagesThroughput ; } if ( writtenMessagesThroughput > largestWrittenMessagesThroughput ) { largestWrittenMessagesThroughput = writtenMessagesThroughput ; } lastReadBytes = readBytes ; lastWrittenBytes = writtenBytes ; lastReadMessages = readMessages ; lastWrittenMessages = writtenMessages ; lastThroughputCalculationTime = currentTime ; } finally { throughputCalculationLock . unlock ( ) ; } }
public List < VerificationOK > verify ( X509Certificate signCert , X509Certificate issuerCert , Date signDate ) throws GeneralSecurityException , IOException { RootStoreVerifier rootStoreVerifier = new RootStoreVerifier ( verifier ) ; rootStoreVerifier . setRootStore ( rootStore ) ; CRLVerifier crlVerifier = new CRLVerifier ( rootStoreVerifier , getCRLsFromDSS ( ) ) ; crlVerifier . setRootStore ( rootStore ) ; crlVerifier . setOnlineCheckingAllowed ( latestRevision || onlineCheckingAllowed ) ; OCSPVerifier ocspVerifier = new OCSPVerifier ( crlVerifier , getOCSPResponsesFromDSS ( ) ) ; ocspVerifier . setRootStore ( rootStore ) ; ocspVerifier . setOnlineCheckingAllowed ( latestRevision || onlineCheckingAllowed ) ; return ocspVerifier . verify ( signCert , issuerCert , signDate ) ; }
protected boolean [ ] testWRTZeroR ( Classifier classifier , Evaluation evaluation , Instances train , Instances test ) throws Exception { boolean [ ] result = new boolean [ NUM_ ] ; evaluation . evaluateModel ( classifier , test ) ; try { Classifier zeroR = new weka . classifiers . rules . ZeroR ( ) ; zeroR . buildClassifier ( train ) ; Evaluation zeroREval = new Evaluation ( train ) ; zeroREval . evaluateModel ( zeroR , test ) ; result [ NUM_ ] = Utils . grOrEq ( zeroREval . errorRate ( ) , evaluation . errorRate ( ) ) ; } catch ( Exception ex ) { throw new Error ( STR_ + ex . getMessage ( ) ) ; } return result ; }
public void println ( ) { if ( addNewlines ) { try { out . write ( STR_ ) ; } catch ( IOException ioe ) { throw new GroovyRuntimeException ( ioe ) ; } } }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; String childData ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; nameNode = elementList . item ( NUM_ ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; child . deleteData ( NUM_ , NUM_ ) ; childData = child . getData ( ) ; assertEquals ( STR_ , STR_ , childData ) ; }
public void deliveryComplete ( final IMqttDeliveryToken token ) { logger . trace ( STR_ , token . getMessageId ( ) ) ; }
public DExportPublicKeyOpenSsl ( JFrame parent , String entryAlias ) { super ( parent , Dialog . ModalityType . DOCUMENT_MODAL ) ; this . entryAlias = entryAlias ; initComponents ( ) ; }
public static String escapeUnicode ( String s ) { int len = s . length ( ) ; int i = NUM_ ; while ( i < len ) { char ch = s . charAt ( i ) ; if ( ch > NUM_ ) { StringBuilder buf = new StringBuilder ( ) ; buf . append ( s . substring ( NUM_ , i ) ) ; while ( i < len ) { ch = s . charAt ( i ) ; if ( ch > NUM_ ) { buf . append ( STR_ ) ; buf . append ( Character . forDigit ( ( ch > > NUM_ ) % NUM_ , NUM_ ) ) ; buf . append ( Character . forDigit ( ( ch > > NUM_ ) % NUM_ , NUM_ ) ) ; buf . append ( Character . forDigit ( ( ch > > NUM_ ) % NUM_ , NUM_ ) ) ; buf . append ( Character . forDigit ( ( ch ) % NUM_ , NUM_ ) ) ; } else { buf . append ( ch ) ; } i ++ ; } s = buf . toString ( ) ; } else { i ++ ; } } return s ; }
public void keyPressed ( final int keyCode ) { if ( impl . getCurrentForm ( ) == null ) { return ; } addSingleArgumentEvent ( KEY_PRESSED , keyCode ) ; lastInteractionWasKeypad = lastInteractionWasKeypad || ( keyCode != MenuBar . leftSK && keyCode != MenuBar . clearSK && keyCode != MenuBar . backSK ) ; keyRepeatCharged = ( keyCode >= NUM_ || getGameAction ( keyCode ) > NUM_ ) || keyCode == impl . getClearKeyCode ( ) ; longPressCharged = keyRepeatCharged ; longKeyPressTime = System . currentTimeMillis ( ) ; keyRepeatValue = keyCode ; nextKeyRepeatEvent = System . currentTimeMillis ( ) + keyRepeatInitialIntervalTime ; previousKeyPressed = lastKeyPressed ; lastKeyPressed = keyCode ; }
public boolean isEmpty ( ) { return filter . isEmpty ( ) && query . isEmpty ( ) && sort . isEmpty ( ) ; }
public String [ ] readDirectory ( String dir ) { if ( dir == null ) { throw new NullPointerException ( STR_ ) ; } StringArrayOut listOut = new StringArrayOut ( ) ; try { checkResult ( LibIMobileDevice . afc_read_directory ( getRef ( ) , dir , listOut ) ) ; StringArray list = listOut . getValue ( ) ; ArrayList < String > result = new ArrayList < String > ( ) ; if ( list != null ) { for ( int i = NUM_ ; ; i ++ ) { String s = list . get ( i ) ; if ( s == null ) { break ; } result . add ( s ) ; } } return result . toArray ( new String [ result . size ( ) ] ) ; } finally { LibIMobileDevice . delete_StringArray_values_z ( listOut . getValue ( ) ) ; listOut . delete ( ) ; } }
public void registerInput ( String varName , JavaRDD < String > rddIn , String format , long rlen , long clen , FileFormatProperties props , List < ValueType > schema ) throws DMLRuntimeException { if ( ! ( DMLScript . rtplatform == RUNTIME_PLATFORM . SPARK || DMLScript . rtplatform == RUNTIME_PLATFORM . HYBRID_SPARK ) ) { throw new DMLRuntimeException ( STR_ ) ; } long nnz = - NUM_ ; if ( _variables == null ) _variables = new LocalVariableMap ( ) ; if ( _inVarnames == null ) _inVarnames = new ArrayList < String > ( ) ; JavaPairRDD < LongWritable , Text > rddText = rddIn . mapToPair ( new ConvertStringToLongTextPair ( ) ) ; int blksz = ConfigurationManager . getBlocksize ( ) ; MatrixCharacteristics mc = new MatrixCharacteristics ( rlen , clen , blksz , blksz , nnz ) ; FrameObject fo = null ; if ( format . equals ( STR_ ) ) { CSVFileFormatProperties csvprops = ( props != null ) ? ( CSVFileFormatProperties ) props : new CSVFileFormatProperties ( ) ; fo = new FrameObject ( OptimizerUtils . getUniqueTempFileName ( ) , new MatrixFormatMetaData ( mc , OutputInfo . CSVOutputInfo , InputInfo . CSVInputInfo ) ) ; fo . setFileFormatProperties ( csvprops ) ; } else if ( format . equals ( STR_ ) ) { if ( rlen == - NUM_ || clen == - NUM_ ) { throw new DMLRuntimeException ( STR_ + format ) ; } fo = new FrameObject ( null , new MatrixFormatMetaData ( mc , OutputInfo . TextCellOutputInfo , InputInfo . TextCellInputInfo ) ) ; } else { throw new DMLRuntimeException ( STR_ + format ) ; } if ( props != null ) fo . setFileFormatProperties ( props ) ; fo . setRDDHandle ( new RDDObject ( rddText , varName ) ) ; fo . setSchema ( STR_ ) ; _variables . put ( varName , fo ) ; _inVarnames . add ( varName ) ; checkIfRegisteringInputAllowed ( ) ; }
public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( argNum < NUM_ ) reportWrongNumberArgs ( ) ; }
public static String fixLineFeeds ( String sql ) { if ( sql . indexOf ( STR_ ) == - NUM_ ) { return sql ; } boolean hasFixes = BOOL_ ; char [ ] fixed = sql . toCharArray ( ) ; for ( int i = NUM_ ; i < fixed . length ; i ++ ) { if ( fixed [ i ] == STR_ && ( i == fixed . length - NUM_ || fixed [ i + NUM_ ] != STR_ ) ) { fixed [ i ] = STR_ ; hasFixes = BOOL_ ; } } return hasFixes ? String . valueOf ( fixed ) : sql ; }
public int compareTo ( Object obj ) { int diff = - NUM_ ; if ( obj instanceof ParserNotice ) { ParserNotice p2 = ( ParserNotice ) obj ; diff = level - p2 . getLevel ( ) ; if ( diff == NUM_ ) { diff = line - p2 . getLine ( ) ; if ( diff == NUM_ ) { diff = message . compareTo ( p2 . getMessage ( ) ) ; } } } return diff ; }
public static String mergePath ( String current , String realPath ) throws MalformedURLException { String currDir ; if ( current == null || current . indexOf ( STR_ ) == - NUM_ ) currDir = STR_ ; else if ( current . endsWith ( STR_ ) ) currDir = current ; else currDir = current . substring ( NUM_ , current . lastIndexOf ( STR_ ) + NUM_ ) ; String path ; if ( realPath . startsWith ( STR_ ) ) path = currDir + realPath . substring ( NUM_ ) ; else if ( realPath . startsWith ( STR_ ) ) path = realPath ; else if ( ! realPath . startsWith ( STR_ ) ) path = currDir + realPath ; else { while ( realPath . startsWith ( STR_ ) || currDir . length ( ) == NUM_ ) { realPath = realPath . substring ( NUM_ ) ; currDir = currDir . substring ( NUM_ , currDir . length ( ) - NUM_ ) ; int index = currDir . lastIndexOf ( STR_ ) ; if ( index == - NUM_ ) throw new MalformedURLException ( STR_ ) ; currDir = currDir . substring ( NUM_ , index + NUM_ ) ; } path = currDir + realPath ; } return path ; }
public void rollback ( ) throws SQLException { if ( useConnection == null ) { LOG . info ( STR_ ) ; return ; } try { useConnection . rollback ( ) ; } catch ( SQLException e ) { LOG . warning ( STR_ + e . getMessage ( ) ) ; throw e ; } }
public byte [ ] toByteArray ( ) { if ( headerNonce_ == null || headerTag_ == null ) { throw new AwsCryptoException ( STR_ ) ; } final byte [ ] serializedFields = serializeAuthenticatedFields ( ) ; final int outLen = serializedFields . length + headerNonce_ . length + headerTag_ . length ; final ByteBuffer serializedBytes = ByteBuffer . allocate ( outLen ) ; serializedBytes . put ( serializedFields ) ; serializedBytes . put ( headerNonce_ ) ; serializedBytes . put ( headerTag_ ) ; return serializedBytes . array ( ) ; }
public boolean containsKey ( Object key ) { return context . getAttribute ( ( String ) key ) != null ; }
private void updateLimit ( int limit ) { currentCycle . setLimit ( limit ) ; updatePlanCycles ( ) ; confirmUpdate . setTextColor ( resources . getColor ( R . color . light_gray ) ) ; }
@ SuppressWarnings ( STR_ ) public Set < S > descendants ( ) { Set < S > perms = new HashSet < > ( ) ; for ( S child : children ) { perms . add ( child ) ; perms . addAll ( child . descendants ( ) ) ; } return perms ; }
private String extractUrl ( String sharedUrl ) { String finalUrl ; finalUrl = sharedUrl . trim ( ) ; String [ ] possible_urls = finalUrl . split ( STR_ ) ; for ( String url : possible_urls ) { if ( NetworkManager . isUrl ( url ) ) { finalUrl = url ; break ; } } finalUrl = finalUrl . substring ( finalUrl . lastIndexOf ( STR_ ) + NUM_ ) ; finalUrl = finalUrl . substring ( finalUrl . lastIndexOf ( STR_ ) + NUM_ ) ; if ( NetworkManager . isUrl ( STR_ + finalUrl ) && ! NetworkManager . isUrl ( finalUrl ) ) { finalUrl = STR_ + finalUrl ; } if ( finalUrl . contains ( STR_ ) ) { finalUrl = finalUrl . substring ( NUM_ , finalUrl . indexOf ( STR_ ) ) ; } if ( finalUrl . contains ( STR_ ) ) { finalUrl = finalUrl . substring ( NUM_ , finalUrl . indexOf ( STR_ ) ) ; } if ( finalUrl . contains ( STR_ ) ) { finalUrl = finalUrl . substring ( NUM_ , finalUrl . indexOf ( STR_ ) ) ; } return finalUrl ; }
public Set entrySet ( ) { return map . entrySet ( ) ; }
public static String encode ( String input ) { return Base64 . encodeBase64String ( input . getBytes ( StandardCharsets . UTF_8 ) ) ; }
protected static final String addEscapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = NUM_ ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case NUM_ : continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < x20 || ch > x7e ) { String s = STR_ + Integer . toString ( ch , NUM_ ) ; retval . append ( STR_ + s . substring ( s . length ( ) - NUM_ , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; }
public void addSplit ( String splitLabel ) { if ( mDisabled ) return ; long now = SystemClock . elapsedRealtime ( ) ; mSplits . add ( now ) ; mSplitLabels . add ( splitLabel ) ; }
protected String encode ( final String value ) { try { return URLEncoder . encode ( value , STR_ ) ; } catch ( Exception exp ) { return value ; } }
private void checkConnectPermission ( ) throws SecurityException { SecurityManager security = System . getSecurityManager ( ) ; if ( security == null ) return ; if ( security != cacheSecurityManager ) { okContext = null ; authcache = new WeakHashMap < AccessControlContext , Reference < AccessControlContext > > ( ) ; cacheSecurityManager = security ; } AccessControlContext ctx = AccessController . getContext ( ) ; if ( okContext == null || ! ( okContext . equals ( ctx ) || authcache . containsKey ( ctx ) ) ) { security . checkConnect ( ep . getHost ( ) , ep . getPort ( ) ) ; authcache . put ( ctx , new SoftReference < AccessControlContext > ( ctx ) ) ; } okContext = ctx ; }
private boolean conditionL0 ( String value , int index ) { if ( index == value . length ( ) - NUM_ && contains ( value , index - NUM_ , NUM_ , STR_ , STR_ , STR_ ) ) { return BOOL_ ; } else if ( ( contains ( value , index - NUM_ , NUM_ , STR_ , STR_ ) || contains ( value , value . length ( ) - NUM_ , NUM_ , STR_ , STR_ ) ) && contains ( value , index - NUM_ , NUM_ , STR_ ) ) { return BOOL_ ; } else { return BOOL_ ; } }
public static PaginationContext fromContext ( RoutingContext context ) { HttpServerRequest request = context . request ( ) ; String pageStr = request . getParam ( PaginationContext . CURRENT_PAGE_QUERY_PARAM ) ; String perPageStr = request . getParam ( PaginationContext . PER_PAGE_QUERY_PARAM ) ; Integer page = null ; Integer perPage = null ; try { if ( pageStr != null ) { page = Integer . parseInt ( pageStr ) ; } if ( perPageStr != null ) { perPage = Integer . parseInt ( perPageStr ) ; } } catch ( NumberFormatException e ) { DefaultErrorHandler . badRequest ( context , STR_ ) ; } if ( perPage != null && perPage > PaginationContext . MAX_PER_PAGE ) { DefaultErrorHandler . badRequest ( context , STR_ + PaginationContext . PER_PAGE_QUERY_PARAM + STR_ + PaginationContext . MAX_PER_PAGE ) ; } return new PaginationContext ( page , perPage ) ; }
private void updateDataTypeState ( ) { boolean isSyncEnabled = mSyncSwitchPreference . isChecked ( ) ; boolean syncEverything = mSyncEverything . isChecked ( ) ; boolean passwordSyncConfigurable = mProfileSyncService . isBackendInitialized ( ) && mProfileSyncService . isCryptographerReady ( ) ; for ( CheckBoxPreference pref : mAllTypes ) { boolean canSyncType = pref != mSyncPasswords || passwordSyncConfigurable ; if ( ! isSyncEnabled ) { pref . setChecked ( BOOL_ ) ; } else if ( syncEverything ) { pref . setChecked ( canSyncType ) ; } pref . setEnabled ( isSyncEnabled && ! syncEverything && canSyncType ) ; } if ( isSyncEnabled && ! syncEverything ) { Set < Integer > syncTypes = mProfileSyncService . getPreferredDataTypes ( ) ; mSyncAutofill . setChecked ( syncTypes . contains ( ModelType . AUTOFILL ) ) ; mSyncBookmarks . setChecked ( syncTypes . contains ( ModelType . BOOKMARKS ) ) ; mSyncOmnibox . setChecked ( syncTypes . contains ( ModelType . TYPED_URLS ) ) ; mSyncPasswords . setChecked ( passwordSyncConfigurable && syncTypes . contains ( ModelType . PASSWORDS ) ) ; mSyncRecentTabs . setChecked ( syncTypes . contains ( ModelType . PROXY_TABS ) ) ; mSyncSettings . setChecked ( syncTypes . contains ( ModelType . PRIORITY_PREFERENCES ) ) ; } }
public static void writeProteinBestMatchesToFile ( String filePath , Map < String , PIRSFHmmer2RawMatch > proteinIdBestMatchMap ) throws IOException { BufferedWriter writer = null ; try { File file = createTmpFile ( filePath ) ; if ( ! file . exists ( ) ) { throw new IllegalStateException ( STR_ + filePath ) ; } writer = new BufferedWriter ( new FileWriter ( file ) ) ; for ( String proteinId : proteinIdBestMatchMap . keySet ( ) ) { PIRSFHmmer2RawMatch bestMatch = proteinIdBestMatchMap . get ( proteinId ) ; if ( bestMatch != null ) { writer . write ( proteinId ) ; writer . write ( STR_ ) ; writer . write ( bestMatch . getModelId ( ) ) ; writer . write ( STR_ ) ; writer . write ( bestMatch . getSignatureLibraryRelease ( ) ) ; writer . write ( STR_ ) ; writer . write ( String . valueOf ( bestMatch . getLocationStart ( ) ) ) ; writer . write ( STR_ ) ; writer . write ( String . valueOf ( bestMatch . getLocationEnd ( ) ) ) ; writer . write ( STR_ ) ; writer . write ( String . valueOf ( bestMatch . getEvalue ( ) ) ) ; writer . write ( STR_ ) ; writer . write ( String . valueOf ( bestMatch . getScore ( ) ) ) ; writer . write ( STR_ ) ; writer . write ( String . valueOf ( bestMatch . getHmmStart ( ) ) ) ; writer . write ( STR_ ) ; writer . write ( String . valueOf ( bestMatch . getHmmEnd ( ) ) ) ; writer . write ( STR_ ) ; writer . write ( bestMatch . getHmmBounds ( ) ) ; writer . write ( STR_ ) ; writer . write ( String . valueOf ( bestMatch . getLocationEvalue ( ) ) ) ; writer . write ( STR_ ) ; writer . write ( String . valueOf ( bestMatch . getLocationScore ( ) ) ) ; writer . write ( STR_ ) ; } } } finally { if ( writer != null ) { writer . close ( ) ; } } }
public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( NUM_ ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
void refreshUI ( String xml , DOMTree m_tree ) { if ( ( xml == null ) || xml . equals ( STR_ ) ) { setErrorMessage ( STR_ , STR_ ) ; return ; } final Document newRoot = getRoot ( xml ) ; if ( newRoot == null ) { setErrorMessage ( STR_ , STR_ ) ; return ; } m_tree . setDocument ( newRoot ) ; }
private void cleanupProtectionSetVolumes ( ProtectionSet protectionSet , List < String > volumeIDs , boolean markProtectionSetForDeletion ) { if ( protectionSet != null ) { _log . info ( STR_ , protectionSet . getLabel ( ) , volumeIDs . toString ( ) ) ; StringSet psetVolumes = protectionSet . getVolumes ( ) ; psetVolumes . removeAll ( volumeIDs ) ; protectionSet . setVolumes ( psetVolumes ) ; if ( markProtectionSetForDeletion ) { protectionSet . setInactive ( BOOL_ ) ; } _dbClient . updateObject ( protectionSet ) ; } }
private static Normalization determineNormalization ( Element model ) { Normalization normMethod = Normalization . NONE ; String normName = model . getAttribute ( STR_ ) ; if ( normName . equals ( STR_ ) ) { normMethod = Normalization . SIMPLEMAX ; } else if ( normName . equals ( STR_ ) ) { normMethod = Normalization . SOFTMAX ; } else if ( normName . equals ( STR_ ) ) { normMethod = Normalization . LOGIT ; } else if ( normName . equals ( STR_ ) ) { normMethod = Normalization . PROBIT ; } else if ( normName . equals ( STR_ ) ) { normMethod = Normalization . CLOGLOG ; } else if ( normName . equals ( STR_ ) ) { normMethod = Normalization . EXP ; } else if ( normName . equals ( STR_ ) ) { normMethod = Normalization . LOGLOG ; } else if ( normName . equals ( STR_ ) ) { normMethod = Normalization . CAUCHIT ; } return normMethod ; }
Operand pop ( Register s ) { Stack < Operand > stack = get ( s ) ; if ( stack == null ) { throw new OptimizingCompilerException ( STR_ ) ; } else { return stack . pop ( ) ; } }
@ Override public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { elementValue = new StringBuilder ( STR_ ) ; elementOn = BOOL_ ; if ( localName . equals ( ITEM_TITLE ) ) { episode = new Episode ( ) ; isItem = BOOL_ ; } if ( localName . equalsIgnoreCase ( MP3_1 ) && isItem ) { episode . setLength ( attributes . getValue ( LENGTH ) ) ; episode . setAudeoUrl ( attributes . getValue ( MP3_3 ) ) ; } }
public static void backAndForth ( HGSearchResult < ? > rs , int windowSize , int iteration ) { boolean advance = BOOL_ ; for ( int i = NUM_ ; i < iteration ; i ++ ) { Object x = rs . current ( ) ; int steps = random ( windowSize ) ; steps = forward ( rs , steps ) ; if ( back ( rs , steps ) != steps ) throw new RuntimeException ( STR_ + steps + STR_ ) ; if ( ! x . equals ( rs . current ( ) ) ) throw new RuntimeException ( STR_ + steps + STR_ + x ) ; if ( advance ) { forward ( rs , random ( windowSize ) ) ; if ( ! rs . hasNext ( ) ) { back ( rs , random ( windowSize ) ) ; advance = BOOL_ ; } } else { back ( rs , random ( windowSize ) ) ; if ( ! rs . hasPrev ( ) ) { forward ( rs , random ( windowSize ) ) ; advance = BOOL_ ; } } } }
@ Override public void close ( ) throws IOException { synchronized ( lock ) { if ( decoder != null ) { decoder . reset ( ) ; } decoder = null ; if ( in != null ) { in . close ( ) ; in = null ; } } }
public List < String > provideWhiteList ( ) { LinkedList < String > whiteList = new LinkedList < > ( ) ; whiteList . add ( STR_ ) ; return whiteList ; }
public boolean hasName ( final String name ) { for ( final String n : names ) { if ( n . equalsIgnoreCase ( name ) ) { return BOOL_ ; } } return BOOL_ ; }
@ Override public Double zincrby ( final String key , final double score , final String member ) { checkIsInMultiOrPipeline ( ) ; client . zincrby ( key , score , member ) ; String newscore = client . getBulkReply ( ) ; return Double . valueOf ( newscore ) ; }
private StringBuffer _toPattern ( StringBuffer result , boolean escapeUnprintable ) { if ( pat != null ) { int i ; int backslashCount = NUM_ ; for ( i = NUM_ ; i < pat . length ( ) ; ) { int c = UTF16 . charAt ( pat , i ) ; i += UTF16 . getCharCount ( c ) ; if ( escapeUnprintable && Utility . isUnprintable ( c ) ) { if ( ( backslashCount % NUM_ ) == NUM_ ) { result . setLength ( result . length ( ) - NUM_ ) ; } Utility . escapeUnprintable ( result , c ) ; backslashCount = NUM_ ; } else { UTF16 . append ( result , c ) ; if ( c == STR_ ) { ++ backslashCount ; } else { backslashCount = NUM_ ; } } } return result ; } return _generatePattern ( result , escapeUnprintable , BOOL_ ) ; }
private static Version readWorkspaceVersion ( final URL workspace ) { final File versionFile = getVersionFile ( workspace , BOOL_ ) ; if ( versionFile == null || ! versionFile . exists ( ) ) { return null ; } try { final Properties props = new Properties ( ) ; final FileInputStream is = new FileInputStream ( versionFile ) ; try { props . load ( is ) ; } finally { is . close ( ) ; } String versionString = props . getProperty ( WORKSPACE_CHECK_REFERENCE_BUNDLE_NAME ) ; if ( versionString != null ) { return Version . parseVersion ( versionString ) ; } versionString = props . getProperty ( WORKSPACE_CHECK_REFERENCE_BUNDLE_NAME_LEGACY ) ; if ( versionString != null ) { return Version . parseVersion ( versionString ) ; } return null ; } catch ( final IOException e ) { IDEWorkbenchPlugin . log ( STR_ + versionFile , new Status ( IStatus . ERROR , IDEWorkbenchPlugin . IDE_WORKBENCH , IStatus . ERROR , e . getMessage ( ) == null ? STR_ : e . getMessage ( ) , e ) ) ; return null ; } catch ( final IllegalArgumentException e ) { IDEWorkbenchPlugin . log ( STR_ + versionFile , new Status ( IStatus . ERROR , IDEWorkbenchPlugin . IDE_WORKBENCH , IStatus . ERROR , e . getMessage ( ) == null ? STR_ : e . getMessage ( ) , e ) ) ; return null ; } }
public VectorApproximation calculateApproximation ( DBID id , V dv ) { int [ ] approximation = new int [ dv . getDimensionality ( ) ] ; for ( int d = NUM_ ; d < splitPositions . length ; d ++ ) { final double val = dv . doubleValue ( d ) ; final int lastBorderIndex = splitPositions [ d ] . length - NUM_ ; if ( val < splitPositions [ d ] [ NUM_ ] ) { approximation [ d ] = NUM_ ; if ( id != null ) { LOG . warning ( STR_ ) ; } } else if ( val > splitPositions [ d ] [ lastBorderIndex ] ) { approximation [ d ] = lastBorderIndex - NUM_ ; if ( id != null ) { LOG . warning ( STR_ ) ; } } else { int pos = Arrays . binarySearch ( splitPositions [ d ] , val ) ; pos = ( pos >= NUM_ ) ? pos : ( ( - pos ) - NUM_ ) ; approximation [ d ] = pos ; } } return new VectorApproximation ( id , approximation ) ; }
private boolean checkIfVolumeSizeExceedingPoolSize ( CIMArgument [ ] inArgs , CIMArgument [ ] outArgs ) { if ( getVolumeSize ( inArgs ) > getVolumeSize ( outArgs ) ) { return BOOL_ ; } return BOOL_ ; }
@ SuppressWarnings ( STR_ ) private void log ( String label , ByteBuffer buffer ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( label ) ; sb . append ( STR_ ) ; sb . append ( buffer . get ( NUM_ ) ) ; sb . append ( STR_ ) ; for ( int x = NUM_ ; x < NUM_ ; x ++ ) { sb . append ( String . format ( STR_ , ( int ) ( buffer . get ( x ) & xFF ) ) ) ; sb . append ( STR_ ) ; } mLog . debug ( sb . toString ( ) ) ; }
private void readObject ( ObjectInputStream ois ) throws ClassNotFoundException , IOException { ois . defaultReadObject ( ) ; boolean hasFont = ois . readBoolean ( ) ; if ( hasFont ) { String name = ( String ) ois . readObject ( ) ; int size = ois . readInt ( ) ; int style = ois . readInt ( ) ; font = new Font ( name , style , size ) ; } else { font = OMText . DEFAULT_FONT ; } }
public void addFile ( String filename ) { if ( filename != null ) addFile ( new File ( filename ) ) ; }
public String format ( TemporalAccessor temporal ) { StringBuilder buf = new StringBuilder ( NUM_ ) ; formatTo ( temporal , buf ) ; return buf . toString ( ) ; }
public void paintToggleButtonBackground ( SynthContext context , Graphics g , int x , int y , int w , int h ) { paintBackground ( context , g , x , y , w , h , null ) ; }
void saveDeviceProfile ( @ Nonnull String user , @ Nonnull String realm , @ Nonnull OathDeviceSettings deviceSettings ) throws AuthLoginException { Reject . ifNull ( user , realm , deviceSettings ) ; try { devicesDao . saveDeviceProfiles ( user , realm , jsonUtils . toJsonValues ( Collections . singletonList ( deviceSettings ) ) ) ; } catch ( IOException e ) { debug . error ( STR_ , user , realm , e ) ; throw new AuthLoginException ( e ) ; } }
protected List < String > parametersToStringList ( List < Parameter > parameters ) { List < String > list = new ArrayList < > ( ) ; for ( Parameter parameter : parameters ) { list . add ( String . format ( STR_ , parameter . getName ( ) , parameter . getValue ( ) ) ) ; } return list ; }
public static boolean isMatchingName ( String nameA , String nameB ) { int a = nameA . length ( ) ; int b = nameB . length ( ) ; if ( a == b ) { return nameA . equals ( nameB ) ; } else if ( a < b - NUM_ ) { return nameB . endsWith ( nameA ) && nameB . charAt ( b - a - NUM_ ) == STR_ ; } else if ( b < a - NUM_ ) { return nameA . endsWith ( nameB ) && nameA . charAt ( a - b - NUM_ ) == STR_ ; } else { return BOOL_ ; } }
private void validateWill ( String dest , Object payload ) { if ( ( dest == null ) || ( payload == null ) ) { throw new IllegalArgumentException ( ) ; } MqttAsyncClient . validateTopic ( dest ) ; }
public static float ccpCalcRotate ( final CGPoint from , final CGPoint to ) { float o = to . x - from . x ; float a = to . y - from . y ; float at = ccMacros . CC_RADIANS_TO_DEGREES ( ( float ) Math . atan ( o / a ) ) ; if ( a < NUM_ ) { if ( o < NUM_ ) at = NUM_ + Math . abs ( at ) ; else at = NUM_ - Math . abs ( at ) ; } return at ; }
public static String cleanTabs ( String yaml ) { if ( yaml . contains ( STR_ ) ) { LOGGER . warn ( STR_ + STR_ + STR_ , TAB_AS_SPACES . length ( ) ) ; List < String > lines = NEWLINE_SPLITTER . splitToList ( yaml ) ; StringBuilder sb = new StringBuilder ( ) ; for ( String line : lines ) { String cleanLine = replaceStartingTabsWithSpaces ( line ) ; sb . append ( cleanLine ) ; sb . append ( STR_ ) ; } return sb . toString ( ) ; } else { return yaml ; } }
private static Paint darkerRadialGradientPaint ( RadialGradientPaint paint ) { final Color [ ] paintColors = paint . getColors ( ) ; for ( int i = NUM_ ; i < paintColors . length ; i ++ ) { paintColors [ i ] = darker ( paintColors [ i ] ) ; } return new RadialGradientPaint ( paint . getCenterPoint ( ) , paint . getRadius ( ) , paint . getFocusPoint ( ) , paint . getFractions ( ) , paintColors , paint . getCycleMethod ( ) , paint . getColorSpace ( ) , paint . getTransform ( ) ) ; }
private void checkAndSetFastPathStatus ( ) { boolean fastPathWasOn = isFastPath ; if ( ( roundingMode == RoundingMode . HALF_EVEN ) && ( isGroupingUsed ( ) ) && ( groupingSize == NUM_ ) && ( multiplier == NUM_ ) && ( ! decimalSeparatorAlwaysShown ) && ( ! useExponentialNotation ) ) { isFastPath = ( ( minimumIntegerDigits == NUM_ ) && ( maximumIntegerDigits >= NUM_ ) ) ; if ( isFastPath ) { if ( isCurrencyFormat ) { if ( ( minimumFractionDigits != NUM_ ) || ( maximumFractionDigits != NUM_ ) ) isFastPath = BOOL_ ; } else if ( ( minimumFractionDigits != NUM_ ) || ( maximumFractionDigits != NUM_ ) ) isFastPath = BOOL_ ; } } else isFastPath = BOOL_ ; if ( isFastPath ) { if ( fastPathData == null ) fastPathData = new FastPathData ( ) ; fastPathData . zeroDelta = symbols . getZeroDigit ( ) - STR_ ; fastPathData . groupingChar = symbols . getGroupingSeparator ( ) ; fastPathData . fractionalMaxIntBound = ( isCurrencyFormat ) ? NUM_ : NUM_ ; fastPathData . fractionalScaleFactor = ( isCurrencyFormat ) ? NUM_ : NUM_ ; fastPathData . positiveAffixesRequired = ( positivePrefix . length ( ) != NUM_ ) || ( positiveSuffix . length ( ) != NUM_ ) ; fastPathData . negativeAffixesRequired = ( negativePrefix . length ( ) != NUM_ ) || ( negativeSuffix . length ( ) != NUM_ ) ; int maxNbIntegralDigits = NUM_ ; int maxNbGroups = NUM_ ; int containerSize = Math . max ( positivePrefix . length ( ) , negativePrefix . length ( ) ) + maxNbIntegralDigits + maxNbGroups + NUM_ + maximumFractionDigits + Math . max ( positiveSuffix . length ( ) , negativeSuffix . length ( ) ) ; fastPathData . fastPathContainer = new char [ containerSize ] ; fastPathData . charsPositiveSuffix = positiveSuffix . toCharArray ( ) ; fastPathData . charsNegativeSuffix = negativeSuffix . toCharArray ( ) ; fastPathData . charsPositivePrefix = positivePrefix . toCharArray ( ) ; fastPathData . charsNegativePrefix = negativePrefix . toCharArray ( ) ; int longestPrefixLength = Math . max ( positivePrefix . length ( ) , negativePrefix . length ( ) ) ; int decimalPointIndex = maxNbIntegralDigits + maxNbGroups + longestPrefixLength ; fastPathData . integralLastIndex = decimalPointIndex - NUM_ ; fastPathData . fractionalFirstIndex = decimalPointIndex + NUM_ ; fastPathData . fastPathContainer [ decimalPointIndex ] = isCurrencyFormat ? symbols . getMonetaryDecimalSeparator ( ) : symbols . getDecimalSeparator ( ) ; } else if ( fastPathWasOn ) { fastPathData . fastPathContainer = null ; fastPathData . charsPositiveSuffix = null ; fastPathData . charsNegativeSuffix = null ; fastPathData . charsPositivePrefix = null ; fastPathData . charsNegativePrefix = null ; } fastPathCheckNeeded = BOOL_ ; }
public void test_keyBuilder_ascii_order ( ) { KeyBuilder keyBuilder = ( KeyBuilder ) KeyBuilder . newInstance ( ) ; KVO < String > [ ] a = new KVO [ ] { new KVO < String > ( TestKeyBuilder . asSortKey ( STR_ ) , null , STR_ ) , new KVO < String > ( TestKeyBuilder . asSortKey ( STR_ ) , null , STR_ ) , new KVO < String > ( TestKeyBuilder . asSortKey ( STR_ ) , null , STR_ ) , new KVO < String > ( TestKeyBuilder . asSortKey ( STR_ ) , null , STR_ ) } ; Arrays . sort ( a ) ; assertEquals ( STR_ , a [ NUM_ ] . obj ) ; assertEquals ( STR_ , a [ NUM_ ] . obj ) ; assertEquals ( STR_ , a [ NUM_ ] . obj ) ; assertEquals ( STR_ , a [ NUM_ ] . obj ) ; }
public boolean isClickTouchScreen ( ) { String s = DeviceInfo . getSoftwareVersion ( ) ; if ( s . length ( ) > NUM_ ) { int v = Integer . parseInt ( s . substring ( NUM_ , NUM_ ) ) ; return v <= NUM_ ; } return BOOL_ ; }
public DOMTestDocumentBuilderFactory newInstance ( DocumentBuilderSetting [ ] newSettings ) throws DOMTestIncompatibleException { if ( newSettings == null ) { return this ; } DocumentBuilderSetting [ ] mergedSettings = mergeSettings ( newSettings ) ; return new LSDocumentBuilderFactory ( mergedSettings ) ; }
public void reset ( ) { index = NUM_ ; if ( file != null ) { listIndex = NUM_ ; if ( ! written ) { writeAllRows ( ) ; written = BOOL_ ; } list . clear ( ) ; file . seek ( FileStore . HEADER_LENGTH ) ; } }
public void add ( GeometryFunction func ) { functions . add ( func ) ; sortedFunctions . put ( func . getName ( ) , func ) ; categorizedFunctions . put ( func . getCategory ( ) , func . getName ( ) , func ) ; if ( hasGeometryResult ( func ) ) categorizedGeometryFunctions . put ( func . getCategory ( ) , func . getName ( ) , func ) ; }
public void fireStateChanged ( ) { ChangeEvent e = new ChangeEvent ( this ) ; for ( ChangeListener listener : listeners ) { listener . stateChanged ( e ) ; } }
public static Clusters convertToClusters ( Graph clusterGraph , List < Node > measuredVariables ) { List < String > latents = new ArrayList < > ( ) ; Clusters clusters = new Clusters ( ) ; clusterGraph = GraphUtils . replaceNodes ( clusterGraph , measuredVariables ) ; for ( Node node : clusterGraph . getNodes ( ) ) { if ( ! measuredVariables . contains ( node ) ) { latents . add ( node . getName ( ) ) ; } } Collections . sort ( latents ) ; for ( int i = NUM_ ; i < latents . size ( ) ; i ++ ) { String name = latents . get ( i ) ; clusters . setClusterName ( i , name ) ; Node latent = clusterGraph . getNode ( name ) ; List < Node > measured = clusterGraph . getNodesOutTo ( latent , Endpoint . ARROW ) ; for ( Node _node : measured ) { if ( measuredVariables . contains ( _node ) ) { clusters . addToCluster ( i , _node . getName ( ) ) ; } } } return clusters ; }
final short rlshort ( DataInputStream dis ) throws IOException { short s = NUM_ ; short high , low ; s = dis . readShort ( ) ; high = ( short ) ( ( s & xFF ) << NUM_ ) ; low = ( short ) ( ( s & xFF00 ) > > > NUM_ ) ; s = ( short ) ( high | low ) ; return s ; }
public void encodeCell ( mxICell cell , Node node , boolean includeChildren ) { node . appendChild ( encode ( cell ) ) ; if ( includeChildren ) { int childCount = cell . getChildCount ( ) ; for ( int i = NUM_ ; i < childCount ; i ++ ) { encodeCell ( cell . getChildAt ( i ) , node , includeChildren ) ; } } }
public DateTimeFormatter withLocale ( Locale locale ) { if ( locale == getLocale ( ) || ( locale != null && locale . equals ( getLocale ( ) ) ) ) { return this ; } return new DateTimeFormatter ( iPrinter , iParser , locale , iOffsetParsed , iChrono , iZone , iPivotYear , iDefaultYear ) ; }
public void testIterate ( ) { final Range range = createRange ( NUM_ , NUM_ ) ; int next = NUM_ ; final Iterator iter = range . iterator ( ) ; while ( iter . hasNext ( ) ) { final Object value = iter . next ( ) ; assertEquals ( STR_ , createValue ( next ++ ) , value ) ; } assertEquals ( STR_ , NUM_ , next ) ; try { iter . next ( ) ; fail ( STR_ ) ; } catch ( NoSuchElementException ignore ) { } }
public String nextString ( char quote ) throws JSONException { char c ; StringBuilder sb = new StringBuilder ( ) ; for ( ; ; ) { c = next ( ) ; switch ( c ) { case NUM_ : case STR_ : case STR_ : throw syntaxError ( STR_ ) ; case STR_ : c = next ( ) ; switch ( c ) { case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( ( char ) Integer . parseInt ( next ( NUM_ ) , NUM_ ) ) ; break ; case STR_ : case STR_ : case STR_ : case STR_ : sb . append ( c ) ; break ; default : throw syntaxError ( STR_ ) ; } break ; default : if ( c == quote ) { return sb . toString ( ) ; } sb . append ( c ) ; } } }
public static Response parseXML ( String xml ) throws SAMLException { Document doc = XMLUtils . toDOMDocument ( xml , SAMLUtils . debug ) ; Element root = doc . getDocumentElement ( ) ; return new Response ( root ) ; }
public static void d ( String tag , String msg , Object ... args ) { if ( sLevel > LEVEL_DEBUG ) { return ; } if ( args . length > NUM_ ) { msg = String . format ( msg , args ) ; } Log . d ( tag , msg ) ; }
public CompiledSQL registerParamType ( String paramName , String dataType ) { if ( paramTypes == null ) { paramTypes = new HashMap ( ) ; } paramTypes . put ( paramName , dataType ) ; return this ; }
public void beginStep ( int step , String stepTitle , Logging logger ) { setProcessed ( step - NUM_ ) ; this . stepTitle = stepTitle ; logger . progress ( this ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) { return BOOL_ ; } else if ( ! ( obj instanceof MethodDesc ) ) { return BOOL_ ; } MethodDesc od = ( MethodDesc ) obj ; return ( ( name == null ? od . name == null : name . equals ( od . name ) ) && Arrays . equals ( types , od . types ) && ( constraints == null ? od . constraints == null : constraints . equals ( od . constraints ) ) ) ; }
public Set < String > addContent ( DialogueState newState ) { if ( ! paused ) { curState . addToState ( newState ) ; return update ( ) ; } else { log . info ( STR_ + newState ) ; return Collections . emptySet ( ) ; } }
public long removeIndex ( int index ) { if ( index >= size ) throw new IndexOutOfBoundsException ( String . valueOf ( index ) ) ; long [ ] items = this . items ; long value = items [ index ] ; size -- ; if ( ordered ) System . arraycopy ( items , index + NUM_ , items , index , size - index ) ; else items [ index ] = items [ size ] ; return value ; }
public FDModel loadModel ( String filename , String cwd ) { String fn = filename ; if ( fn == null ) return null ; if ( ! fn . endsWith ( STR_ + fileExtension ) ) { fn += STR_ + fileExtension ; } ModelPersistenceHandler persistenceHandler = createModelPersistenceHandler ( resourceSetProvider . get ( ) ) ; return ( FDModel ) persistenceHandler . loadModel ( fn , cwd ) ; }
public boolean saveCurrentConfiguration ( ) { if ( currentConfig . toString ( ) == null ) { return ( BOOL_ ) ; } int answer = JOptionPane . showConfirmDialog ( null , STR_ , STR_ , JOptionPane . YES_NO_CANCEL_OPTION , JOptionPane . QUESTION_MESSAGE , Icons . getImageIcon ( STR_ ) ) ; if ( answer == JOptionPane . CANCEL_OPTION ) { return ( BOOL_ ) ; } else if ( answer == JOptionPane . NO_OPTION ) { return ( BOOL_ ) ; } return ( saveCurrentConfigurationAs ( BOOL_ ) ) ; }
public static double [ ] normalise ( double [ ] initProbs ) { for ( int i = NUM_ ; i < initProbs . length ; i ++ ) { if ( initProbs [ i ] < NUM_ ) { initProbs [ i ] = NUM_ ; } } double sum = NUM_ ; for ( double prob : initProbs ) { sum += prob ; } double [ ] result = new double [ initProbs . length ] ; if ( sum > NUM_ ) { for ( int i = NUM_ ; i < initProbs . length ; i ++ ) { result [ i ] = initProbs [ i ] / sum ; } } else { for ( int i = NUM_ ; i < initProbs . length ; i ++ ) { result [ i ] = NUM_ / initProbs . length ; } } return result ; }
public void track ( File file , Object marker , FileDeleteStrategy deleteStrategy ) { if ( file == null ) { throw new NullPointerException ( STR_ ) ; } addTracker ( file . getPath ( ) , marker , deleteStrategy ) ; }
protected StringBuilder appendSearchStringParamIfNecessary ( StringBuilder sb ) { String searchStringParam = getEncodedSearchStringParam ( ) ; if ( searchStringParam != null ) { if ( sb . indexOf ( STR_ ) == - NUM_ ) { sb . append ( STR_ ) ; } else { sb . append ( STR_ ) ; } sb . append ( searchStringParam ) ; } return sb ; }
public static ClassInfo findOrCreateClass ( String fullName ) { ClassInfo u = findClass ( fullName ) ; if ( u == null ) { u = new ClassInfo ( fullName ) ; if ( u . isArray ( ) ) { findOrCreateClass ( fullName . substring ( NUM_ ) ) ; } } return u ; }
PlaPointRational ( BigInteger p_x , BigInteger p_y , BigInteger p_z ) { rp_x = p_x ; rp_y = p_y ; rp_z = p_z ; is_nan = p_z . signum ( ) <= NUM_ ; }
public boolean isNullValue ( ) { return StringUtils . trimToNull ( value ) == null && StringUtils . trimToNull ( comment ) == null ; }
private Map < Long , Pair < String , Long > > recoverPendingLargeMessages ( ) throws Exception { Map < Long , Pair < String , Long > > largeMessages = new HashMap < > ( ) ; List < String > filenames = largeMessagesFactory . listFiles ( STR_ ) ; List < Long > idList = new ArrayList < > ( ) ; for ( String filename : filenames ) { Long id = getLargeMessageIdFromFilename ( filename ) ; if ( ! largeMessagesToDelete . contains ( id ) ) { idList . add ( id ) ; SequentialFile seqFile = largeMessagesFactory . createSequentialFile ( filename ) ; long size = seqFile . size ( ) ; largeMessages . put ( id , new Pair < > ( filename , size ) ) ; } } return largeMessages ; }
private void checkForFragmentID ( Attributes attributes ) { if ( ! m_shouldProcess ) { if ( ( null != attributes ) && ( null != m_fragmentIDString ) ) { int n = attributes . getLength ( ) ; for ( int i = NUM_ ; i < n ; i ++ ) { String name = attributes . getQName ( i ) ; if ( name . equals ( Constants . ATTRNAME_ID ) ) { String val = attributes . getValue ( i ) ; if ( val . equalsIgnoreCase ( m_fragmentIDString ) ) { m_shouldProcess = BOOL_ ; m_fragmentID = m_elementID ; } } } } } }
public void unparsedEntityDecl ( String name , XMLResourceIdentifier identifier , String notation , Augmentations augs ) throws XNIException { try { if ( fDTDHandler != null ) { String publicId = identifier . getPublicId ( ) ; String systemId = fResolveDTDURIs ? identifier . getExpandedSystemId ( ) : identifier . getLiteralSystemId ( ) ; fDTDHandler . unparsedEntityDecl ( name , publicId , systemId , notation ) ; } } catch ( SAXException e ) { throw new XNIException ( e ) ; } }
public void waitForPaxosToFinish ( ) { proposeLock . lock ( ) ; canPropose . awaitUninterruptibly ( ) ; proposeLock . unlock ( ) ; }
public static ResponseData parse ( String responseData ) { int index = responseData . indexOf ( STR_ ) ; String mainData , extraData ; if ( - NUM_ == index ) { mainData = responseData ; extraData = STR_ ; } else { mainData = responseData . substring ( NUM_ , index ) ; extraData = index >= responseData . length ( ) ? STR_ : responseData . substring ( index + NUM_ ) ; } String [ ] fields = TextUtils . split ( mainData , Pattern . quote ( STR_ ) ) ; if ( fields . length < NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } ResponseData data = new ResponseData ( ) ; data . extra = extraData ; data . responseCode = Integer . parseInt ( fields [ NUM_ ] ) ; data . nonce = Integer . parseInt ( fields [ NUM_ ] ) ; data . packageName = fields [ NUM_ ] ; data . versionCode = fields [ NUM_ ] ; data . userId = fields [ NUM_ ] ; data . timestamp = Long . parseLong ( fields [ NUM_ ] ) ; return data ; }
public static double [ ] vectorBoxCorner ( double [ ] center , double [ ] result , double distance , boolean upperRight ) { if ( result == null || result . length != center . length ) { result = new double [ center . length ] ; } if ( upperRight == BOOL_ ) { distance = - distance ; } distance = SIN_PI_DIV_4 . distance ; for ( int i = NUM_ ; i < center . length ; i ++ ) { result [ i ] = center [ i ] + distance ; } return result ; }
public void testSetLoginConfigAdding ( ) throws Exception { String xml = WEBAPP_TEST_HEADER + STR_ ; WebXml webXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( xml . getBytes ( STR_ ) ) , getEntityResolver ( ) ) ; WebXmlUtils . setLoginConfig ( webXml , STR_ , STR_ ) ; assertTrue ( WebXmlUtils . hasLoginConfig ( webXml ) ) ; assertEquals ( STR_ , WebXmlUtils . getLoginConfigAuthMethod ( webXml ) ) ; }
public void validate ( ) throws AMConsoleException { if ( isSelected ( ) ) { if ( isPersonalQuestion ( ) ) { if ( ( question . length ( ) == NUM_ ) || ( answer . length ( ) == NUM_ ) ) { throw new AMConsoleException ( STR_ ) ; } } else { if ( answer . length ( ) == NUM_ ) { throw new AMConsoleException ( STR_ ) ; } } } }
public static void assertTrue ( boolean b , Object message ) { if ( ! b ) { throwError ( message ) ; } }
private String [ ] spliterator ( String phrase ) { String [ ] split = phrase . split ( STR_ ) ; String [ ] out = new String [ split . length ] ; for ( int ix = NUM_ ; ix < split . length ; ix ++ ) { String temp = split [ ix - NUM_ ] ; temp += STR_ + split [ ix ] ; out [ ix - NUM_ ] = temp ; } return out ; }
protected Signature ( String algorithm ) { this . algorithm = algorithm ; }
private final void augmentTokenList ( ) { Token [ ] temp = new Token [ size + increment ] ; System . arraycopy ( tokenList , NUM_ , temp , NUM_ , size ) ; size += increment ; tokenList = temp ; for ( int i = NUM_ ; i < increment ; i ++ ) { tokenList [ size - i - NUM_ ] = createInternalUseOnlyToken ( ) ; } }
public String calculateFromString ( String data ) throws Exception { log . trace ( STR_ , algoURI , data ) ; return calculateFromBytes ( data . getBytes ( StandardCharsets . UTF_8 ) ) ; }
public void addChannels ( List < Channel > channels ) { for ( Channel channel : channels ) { addChannel ( channel ) ; } }
public static String [ ] mergeStringArrays ( String [ ] array1 , String [ ] array2 ) { if ( ObjectUtils . isEmpty ( array1 ) ) { return array2 ; } if ( ObjectUtils . isEmpty ( array2 ) ) { return array1 ; } List < String > result = new ArrayList < String > ( ) ; result . addAll ( Arrays . asList ( array1 ) ) ; for ( String str : array2 ) { if ( ! result . contains ( str ) ) { result . add ( str ) ; } } return toStringArray ( result ) ; }
public void testRunAfterBoth_exceptionalCompletion ( ) throws Throwable { for ( ExecutionMode m : ExecutionMode . values ( ) ) for ( boolean fFirst : new boolean [ ] { BOOL_ , BOOL_ } ) for ( boolean failFirst : new boolean [ ] { BOOL_ , BOOL_ } ) for ( Integer v1 : new Integer [ ] { NUM_ , null } ) { final CompletableFuture < Integer > f = new CompletableFuture < > ( ) ; final CompletableFuture < Integer > g = new CompletableFuture < > ( ) ; final CFException ex = new CFException ( ) ; final Noop r1 = new Noop ( m ) ; final Noop r2 = new Noop ( m ) ; final Noop r3 = new Noop ( m ) ; final CompletableFuture < Integer > fst = fFirst ? f : g ; final CompletableFuture < Integer > snd = ! fFirst ? f : g ; final Callable < Boolean > complete1 = failFirst ? null : null ; final Callable < Boolean > complete2 = failFirst ? null : null ; final CompletableFuture < Void > h1 = m . runAfterBoth ( f , g , r1 ) ; assertTrue ( complete1 . call ( ) ) ; final CompletableFuture < Void > h2 = m . runAfterBoth ( f , g , r2 ) ; checkIncomplete ( h1 ) ; checkIncomplete ( h2 ) ; assertTrue ( complete2 . call ( ) ) ; final CompletableFuture < Void > h3 = m . runAfterBoth ( f , g , r3 ) ; checkCompletedWithWrappedException ( h1 , ex ) ; checkCompletedWithWrappedException ( h2 , ex ) ; checkCompletedWithWrappedException ( h3 , ex ) ; r1 . assertNotInvoked ( ) ; r2 . assertNotInvoked ( ) ; r3 . assertNotInvoked ( ) ; checkCompletedNormally ( failFirst ? snd : fst , v1 ) ; checkCompletedExceptionally ( failFirst ? fst : snd , ex ) ; } }
private double damp ( double value ) { return Math . sqrt ( value ) ; }
public void addMeasurement ( double measurement ) { double keepConstant = NUM_ - mDecayConstant ; if ( mCount > mCutover ) { mValue = Math . exp ( keepConstant . Math . log ( mValue ) + mDecayConstant . Math . log ( measurement ) ) ; } else if ( mCount > NUM_ ) { double retained = keepConstant . mCount / ( mCount + NUM_ ) ; double newcomer = NUM_ - retained ; mValue = Math . exp ( retained . Math . log ( mValue ) + newcomer . Math . log ( measurement ) ) ; } else { mValue = measurement ; } mCount ++ ; }
@ SuppressWarnings ( STR_ ) private String nextUnquotedValue ( ) throws IOException { StringBuilder builder = null ; int i = NUM_ ; findNonLiteralCharacter : while ( BOOL_ ) { for ( ; pos + i < limit ; i ++ ) { switch ( buffer [ pos + i ] ) { case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : checkLenient ( ) ; case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : break findNonLiteralCharacter ; } } if ( i < buffer . length ) { if ( fillBuffer ( i + NUM_ ) ) { continue ; } else { break ; } } if ( builder == null ) { builder = new StringBuilder ( ) ; } builder . append ( buffer , pos , i ) ; pos += i ; i = NUM_ ; if ( ! fillBuffer ( NUM_ ) ) { break ; } } String result ; if ( builder == null ) { result = new String ( buffer , pos , i ) ; } else { builder . append ( buffer , pos , i ) ; result = builder . toString ( ) ; } pos += i ; return result ; }
public long arg_end ( ) { return Long . parseLong ( fields [ NUM_ ] ) ; }
static List < IRuntimeClasspathEntry > computeClasspath ( IJavaProject javaProject ) throws CoreException { IRuntimeClasspathEntry [ ] unresolvedRuntimeClasspath = JavaRuntime . computeUnresolvedRuntimeClasspath ( javaProject ) ; List < IRuntimeClasspathEntry > resolvedRuntimeClasspath = new ArrayList < IRuntimeClasspathEntry > ( ) ; for ( IRuntimeClasspathEntry unresolvedClasspathEntry : unresolvedRuntimeClasspath ) { if ( JavaRuntime . isVMInstallReference ( unresolvedClasspathEntry ) ) { continue ; } resolvedRuntimeClasspath . addAll ( Arrays . asList ( JavaRuntime . resolveRuntimeClasspathEntry ( unresolvedClasspathEntry , javaProject ) ) ) ; } try { resolvedRuntimeClasspath . addAll ( NUM_ , GWTProjectUtilities . getGWTSourceFolderPathsFromProjectAndDependencies ( javaProject , BOOL_ ) ) ; } catch ( SdkException e ) { throw new CoreException ( new Status ( IStatus . ERROR , GWTPlugin . PLUGIN_ID , e . getLocalizedMessage ( ) , e ) ) ; } GwtSdk gwtRuntime = GwtSdk . findSdkFor ( javaProject ) ; if ( gwtRuntime == null ) { GWTPluginLog . logWarning ( STR_ + javaProject . getElementName ( ) + STR_ ) ; return resolvedRuntimeClasspath ; } IStatus validationStatus = gwtRuntime . validate ( ) ; if ( ! validationStatus . isOK ( ) ) { GWTPluginLog . logWarning ( STR_ + javaProject . getElementName ( ) + STR_ + validationStatus . getMessage ( ) + STR_ ) ; return resolvedRuntimeClasspath ; } try { File gwtDevJar = gwtRuntime . getDevJar ( ) ; resolvedRuntimeClasspath . add ( JavaRuntime . newArchiveRuntimeClasspathEntry ( Path . fromOSString ( gwtDevJar . getAbsolutePath ( ) ) ) ) ; } catch ( SdkException e ) { GWTPluginLog . logWarning ( e , STR_ ) ; } return resolvedRuntimeClasspath ; }
@ SuppressWarnings ( STR_ ) public ThrowingMockTokenFilterFactory ( Map < String , String > args ) { super ( args ) ; String exceptionClassName = args . get ( STR_ ) ; if ( exceptionClassName == null ) { throw new RuntimeException ( STR_ ) ; } try { exceptionClass = ( Class < ? extends RuntimeException > ) Class . forName ( exceptionClassName ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( e ) ; } }
public boolean isNavigationAtBottom ( ) { return ( mSmallestWidthDp >= NUM_ || mInPortrait ) ; }
public PatternGuardExpr ( String namespace , String name , List < Expression > parameters , PatternExpr guardedPattern ) { super ( namespace , name , parameters ) ; this . guarded = new ArrayList < PatternExpr > ( ) ; guarded . add ( guardedPattern ) ; }
private long startNewTrack ( ) { if ( isRecording ( ) ) { Log . d ( TAG , STR_ ) ; return - NUM_ ; } long now = System . currentTimeMillis ( ) ; trackTripStatisticsUpdater = new TripStatisticsUpdater ( now ) ; markerTripStatisticsUpdater = new TripStatisticsUpdater ( now ) ; Track track = new Track ( ) ; Uri uri = myTracksProviderUtils . insertTrack ( track ) ; long trackId = Long . parseLong ( uri . getLastPathSegment ( ) ) ; updateRecordingState ( trackId , BOOL_ ) ; PreferencesUtils . setInt ( this , R . string . auto_resume_track_current_retry_key , NUM_ ) ; PreferencesUtils . setInt ( this , R . string . activity_recognition_type_key , PreferencesUtils . ACTIVITY_RECOGNITION_TYPE_DEFAULT ) ; track . setId ( trackId ) ; track . setName ( TrackNameUtils . getTrackName ( this , trackId , now , null ) ) ; String category = PreferencesUtils . getString ( this , R . string . default_activity_key , PreferencesUtils . DEFAULT_ACTIVITY_DEFAULT ) ; track . setCategory ( category ) ; track . setIcon ( TrackIconUtils . getIconValue ( this , category ) ) ; track . setTripStatistics ( trackTripStatisticsUpdater . getTripStatistics ( ) ) ; myTracksProviderUtils . updateTrack ( track ) ; insertWaypoint ( WaypointCreationRequest . DEFAULT_START_TRACK ) ; startRecording ( BOOL_ ) ; return trackId ; }
protected AbstractMRMessage pollMessage ( ) { if ( disablePoll ) { return null ; } if ( ! pollQueue . isEmpty ( ) ) { PollMessage pm = pollQueue . peek ( ) ; if ( pm != null ) { return pm . getMessage ( ) ; } } return null ; }
public static byte [ ] readFully ( InputStream in ) throws IOException { try { return readFullyNoClose ( in ) ; } finally { in . close ( ) ; } }
private boolean isSuppressWarningsTest ( String baseName ) { return baseName . equals ( STR_ ) ; }
protected static String applyLimitClause ( final String query , int limit , final int queryResultSetLimit ) { Matcher matcher = SELECT_EXPR_PATTERN . matcher ( query ) ; if ( matcher . matches ( ) ) { Matcher limit_matcher = SELECT_WITH_LIMIT_EXPR_PATTERN . matcher ( query ) ; boolean queryAlreadyHasLimitClause = limit_matcher . matches ( ) ; if ( ! queryAlreadyHasLimitClause ) { if ( limit == NUM_ ) { limit = queryResultSetLimit ; } String result = query ; result += STR_ + limit ; return result ; } } return query ; }
public void unmaximiseComponent ( ) { if ( maximisedComponent == null ) { return ; } container . remove ( maximisedComponent ) ; container . add ( containerChild ) ; parentMaximisedComponent . add ( maximisedComponent ) ; container . validate ( ) ; containerChild = null ; parentMaximisedComponent = null ; maximisedComponent = null ; }
default CharSeq join ( CharSequence delimiter , CharSequence prefix , CharSequence suffix ) { StringBuilder stringBuilder = new StringBuilder ( prefix ) ; forEach ( null ) ; stringBuilder . append ( suffix ) ; return CharSeq . of ( stringBuilder . toString ( ) ) ; }
public void removeListener ( T listener ) { if ( listeners != null ) { List < T > newlisteners = new ArrayList < T > ( ) ; newlisteners . addAll ( listeners ) ; newlisteners . remove ( listener ) ; listeners = newlisteners ; } }
public static void saveAsASCII ( NSArray root , File out ) throws IOException { OutputStreamWriter w = new OutputStreamWriter ( new FileOutputStream ( out ) , STR_ ) ; w . write ( root . toASCIIPropertyList ( ) ) ; w . close ( ) ; }
public XSWildcardDecl performIntersectionWith ( XSWildcardDecl wildcard , short processContents ) { if ( wildcard == null ) return null ; XSWildcardDecl intersectWildcard = new XSWildcardDecl ( ) ; intersectWildcard . fProcessContents = processContents ; if ( areSame ( wildcard ) ) { intersectWildcard . fType = fType ; intersectWildcard . fNamespaceList = fNamespaceList ; } else if ( ( fType == NSCONSTRAINT_ANY ) || ( wildcard . fType == NSCONSTRAINT_ANY ) ) { XSWildcardDecl other = this ; if ( fType == NSCONSTRAINT_ANY ) other = wildcard ; intersectWildcard . fType = other . fType ; intersectWildcard . fNamespaceList = other . fNamespaceList ; } else if ( ( ( fType == NSCONSTRAINT_NOT ) && ( wildcard . fType == NSCONSTRAINT_LIST ) ) || ( ( fType == NSCONSTRAINT_LIST ) && ( wildcard . fType == NSCONSTRAINT_NOT ) ) ) { String [ ] list = null ; String [ ] other = null ; if ( fType == NSCONSTRAINT_NOT ) { other = fNamespaceList ; list = wildcard . fNamespaceList ; } else { other = wildcard . fNamespaceList ; list = fNamespaceList ; } int listSize = list . length ; String [ ] intersect = new String [ listSize ] ; int newSize = NUM_ ; for ( int i = NUM_ ; i < listSize ; i ++ ) { if ( list [ i ] != other [ NUM_ ] && list [ i ] != ABSENT ) intersect [ newSize ++ ] = list [ i ] ; } intersectWildcard . fType = NSCONSTRAINT_LIST ; intersectWildcard . fNamespaceList = new String [ newSize ] ; System . arraycopy ( intersect , NUM_ , intersectWildcard . fNamespaceList , NUM_ , newSize ) ; } else if ( ( fType == NSCONSTRAINT_LIST ) && ( wildcard . fType == NSCONSTRAINT_LIST ) ) { intersectWildcard . fType = NSCONSTRAINT_LIST ; intersectWildcard . fNamespaceList = intersect2sets ( fNamespaceList , wildcard . fNamespaceList ) ; } else if ( fType == NSCONSTRAINT_NOT && wildcard . fType == NSCONSTRAINT_NOT ) { if ( fNamespaceList [ NUM_ ] != ABSENT && wildcard . fNamespaceList [ NUM_ ] != ABSENT ) return null ; XSWildcardDecl other = this ; if ( fNamespaceList [ NUM_ ] == ABSENT ) other = wildcard ; intersectWildcard . fType = other . fType ; intersectWildcard . fNamespaceList = other . fNamespaceList ; } return intersectWildcard ; }
public static void filterOutbound ( StringBuilder message ) { for ( int i = NUM_ ; i < message . length ( ) ; i ++ ) { char currentChar = message . charAt ( i ) ; if ( LEGAL_CHARACTERS . indexOf ( currentChar ) == - NUM_ ) { if ( currentChar > NUM_ ) { int charAsInt = currentChar ; String stringVersion = Integer . toString ( charAsInt , NUM_ ) ; String replacement = STR_ + stringVersion + STR_ ; message . replace ( i , i + NUM_ , replacement ) ; i += replacement . length ( ) - NUM_ ; } else { message . deleteCharAt ( i ) ; i -- ; } } } }
private void drawDays ( Canvas canvas ) { final TextPaint p = mDayPaint ; final int headerHeight = mMonthHeight + mDayOfWeekHeight ; final int rowHeight = mDayHeight ; final int colWidth = mCellWidth ; final float halfLineHeight = ( p . ascent ( ) + p . descent ( ) ) / NUM_ ; int rowCenter = headerHeight + rowHeight / NUM_ ; for ( int day = NUM_ , col = findDayOffset ( ) ; day <= mDaysInMonth ; day ++ ) { final int colCenter = colWidth . col + colWidth / NUM_ ; final int colCenterRtl ; if ( ViewCompatUtils . isLayoutRtl ( this ) ) { colCenterRtl = mPaddedWidth - colCenter ; } else { colCenterRtl = colCenter ; } int state = NUM_ ; final boolean isDayEnabled = isDayEnabled ( day ) ; final boolean isDayActivated = mActivatedDay == day ; if ( isDayActivated ) { state = VIEW_STATE_SELECTED ; canvas . drawCircle ( colCenterRtl , rowCenter , mDaySelectorRadius , mDaySelectorPaint ) ; } else if ( mTouchedItem == day ) { state = VIEW_STATE_PRESSED ; if ( isDayEnabled ) { canvas . drawCircle ( colCenterRtl , rowCenter , mDaySelectorRadius , mDayHighlightPaint ) ; } } final boolean isDayToday = mToday == day ; final int dayTextColor ; if ( isDayToday && ! isDayActivated ) { dayTextColor = mDaySelectorPaint . getColor ( ) ; } else { final int [ ] stateSet = buildState ( isDayEnabled , state ) ; dayTextColor = mDayTextColor . getColorForState ( stateSet , NUM_ ) ; } p . setColor ( dayTextColor ) ; canvas . drawText ( mDayFormatter . format ( day ) , colCenterRtl , rowCenter - halfLineHeight , p ) ; col ++ ; if ( col == DAYS_IN_WEEK ) { col = NUM_ ; rowCenter += rowHeight ; } } }
public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( ch == null || start < NUM_ || length >= ( ch . length - start ) || length < NUM_ ) return ; append ( m_doc . createComment ( new String ( ch , start , length ) ) ) ; }
public boolean isEmpty ( ) { return arrayList . isEmpty ( ) ; }
public ArbitraryLengthPathNode ( final TermNode left , final TermNode right , final VarNode tVarLeft , final VarNode tVarRight , final PathMod mod ) { this ( new BOp [ ] { new JoinGroupNode ( ) } , NV . asMap ( new NV ( Annotations . LEFT_TERM , left ) , new NV ( Annotations . RIGHT_TERM , right ) , new NV ( Annotations . TRANSITIVITY_VAR_LEFT , tVarLeft ) , new NV ( Annotations . TRANSITIVITY_VAR_RIGHT , tVarRight ) , new NV ( Annotations . LOWER_BOUND , mod == PathMod . ONE_OR_MORE ? NUM_ : NUM_ ) , new NV ( Annotations . UPPER_BOUND , mod == PathMod . ZERO_OR_ONE ? NUM_ : Long . MAX_VALUE ) ) ) ; final Set < VarNode > dropVars = new LinkedHashSet < > ( ) ; dropVars . add ( tVarLeft ) ; dropVars . add ( tVarRight ) ; setProperty ( Annotations . DROP_VARS , dropVars ) ; }
static void checkFlags ( int flags ) { int allowedFlags = READ_ONLY_FLAG_MASK | EMPTY_FLAG_MASK | COMPACT_FLAG_MASK | ORDERED_FLAG_MASK ; int flagsMask = ~ allowedFlags ; if ( ( flags & flagsMask ) > NUM_ ) { throw new SketchesArgumentException ( STR_ + Integer . toBinaryString ( flags ) ) ; } }
public boolean canGetInt ( ) { return canGet ( int . class ) ; }
public static ArrayList < Object > deleteItemSets ( ArrayList < Object > itemSets , int minSupport , int maxSupport ) { ArrayList < Object > newVector = new ArrayList < Object > ( itemSets . size ( ) ) ; for ( int i = NUM_ ; i < itemSets . size ( ) ; i ++ ) { LabeledItemSet current = ( LabeledItemSet ) itemSets . get ( i ) ; if ( ( current . m_ruleSupCounter >= minSupport ) && ( current . m_ruleSupCounter <= maxSupport ) ) { newVector . add ( current ) ; } } return newVector ; }
private static synchronized String makeDateString ( Date date ) { return sdfDefault . format ( date ) ; }
public static String generateNativeGuid ( DbClient dbClient , FileShare fileShare ) throws IOException { StorageSystem device = dbClient . queryObject ( StorageSystem . class , fileShare . getStorageDevice ( ) ) ; return String . format ( STR_ + FILESYSTEM + STR_ , _deviceTypeMap . get ( device . getSystemType ( ) ) , device . getSerialNumber ( ) , fileShare . getNativeId ( ) ) ; }
public String toString ( ) { StringBuffer result = new StringBuffer ( ) ; int temp ; temp = ipAddress & x000000FF ; result . append ( temp ) ; result . append ( STR_ ) ; temp = ( ipAddress > > NUM_ ) & x000000FF ; result . append ( temp ) ; result . append ( STR_ ) ; temp = ( ipAddress > > NUM_ ) & x000000FF ; result . append ( temp ) ; result . append ( STR_ ) ; temp = ( ipAddress > > NUM_ ) & x000000FF ; result . append ( temp ) ; return result . toString ( ) ; }
public void logPurchase ( BigDecimal purchaseAmount , Currency currency , Bundle parameters ) { if ( purchaseAmount == null ) { notifyDeveloperError ( STR_ ) ; return ; } else if ( currency == null ) { notifyDeveloperError ( STR_ ) ; return ; } if ( parameters == null ) { parameters = new Bundle ( ) ; } parameters . putString ( AppEventsConstants . EVENT_PARAM_CURRENCY , currency . getCurrencyCode ( ) ) ; logEvent ( AppEventsConstants . EVENT_NAME_PURCHASED , purchaseAmount . doubleValue ( ) , parameters ) ; eagerFlush ( ) ; }
private static double distance ( Point p1 , Point p2 ) { double x = p1 . x - p2 . x ; double y = p1 . y - p2 . y ; return Math . sqrt ( x . x + y . y ) ; }
public void addHyperedgeInNode ( HyperEdge hyperEdge ) { if ( hyperEdge != null ) { if ( null == hyperedges ) hyperedges = new ArrayList < > ( ) ; hyperedges . add ( hyperEdge ) ; semiringPlus ( hyperEdge ) ; } }
public RotatedProblems ( ) { super ( ) ; }
public DockerPortMapping withHostPort ( int hostPort ) { DockerPortMapping newMapping = new DockerPortMapping ( ) ; newMapping . protocol = protocol ; newMapping . containerPort = containerPort ; newMapping . hostIp = hostIp ; newMapping . hostPort = String . valueOf ( hostPort ) ; return newMapping ; }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case NUM_ : return ID1 ; case NUM_ : return ID2 ; default : return null ; } }
@ Override public int length ( ) { return str . length ( ) ; }
public void clearAllHaptics ( ) { mHaptics . clear ( ) ; }
public void encode ( final ActiveMQBuffer buffer ) { buffer . writeString ( name ) ; buffer . writeString ( factoryClassName ) ; buffer . writeInt ( params == null ? NUM_ : params . size ( ) ) ; if ( params != null ) { encodeMap ( buffer , params ) ; } if ( extraProps != null ) { encodeMap ( buffer , extraProps ) ; } }
@ Override public void write ( byte [ ] b , int off , int len ) throws IOException { flushBits ( ) ; out . write ( b , off , len ) ; }
public static double log2 ( double x ) { return Math . log ( x ) / LOG2 ; }
boolean isNameUsed ( String name ) { List < Integer > columnsWithName = columnNames . get ( name ) ; return columnsWithName != null && ! columnsWithName . isEmpty ( ) ; }
public StateInteractive complete ( ) { if ( return_state != this && actlog != null ) { actlog . start_scope ( LogfileScope . COMPLETE_SCOPE ) ; } return return_state ; }
private WorkQueue findNonEmptyStealQueue ( ) { WorkQueue [ ] ws ; int wl ; int r = TLRandom . nextSecondarySeed ( ) ; if ( ( ws = workQueues ) != null && ( wl = ws . length ) > NUM_ ) { int m = wl - NUM_ , origin = r & m ; for ( int k = origin , oldSum = NUM_ , checkSum = NUM_ ; ; ) { WorkQueue q ; int b ; if ( ( q = ws [ k ] ) != null ) { if ( ( b = q . base ) - q . top < NUM_ ) return q ; checkSum += b ; } if ( ( k = ( k + NUM_ ) & m ) == origin ) { if ( oldSum == ( oldSum = checkSum ) ) break ; checkSum = NUM_ ; } } } return null ; }
public void testPseudoLegalMoves ( ) throws ChessParseError { String fen = STR_ ; Position pos = TextIO . readFEN ( fen ) ; assertEquals ( fen , TextIO . toFEN ( pos ) ) ; List < String > strMoves = getMoveList ( pos , BOOL_ ) ; assertTrue ( strMoves . contains ( STR_ ) ) ; assertTrue ( ! strMoves . contains ( STR_ ) ) ; assertTrue ( ! strMoves . contains ( STR_ ) ) ; assertTrue ( strMoves . contains ( STR_ ) ) ; assertTrue ( strMoves . contains ( STR_ ) ) ; assertTrue ( ! strMoves . contains ( STR_ ) ) ; assertTrue ( strMoves . contains ( STR_ ) ) ; assertTrue ( ! strMoves . contains ( STR_ ) ) ; assertTrue ( strMoves . contains ( STR_ ) ) ; assertTrue ( strMoves . contains ( STR_ ) ) ; assertEquals ( NUM_ , strMoves . size ( ) ) ; pos . setPiece ( Position . getSquare ( NUM_ , NUM_ ) , Piece . BROOK ) ; strMoves = getMoveList ( pos , BOOL_ ) ; assertTrue ( ! strMoves . contains ( STR_ ) ) ; assertTrue ( ! strMoves . contains ( STR_ ) ) ; pos . setPiece ( Position . getSquare ( NUM_ , NUM_ ) , Piece . EMPTY ) ; pos . setPiece ( Position . getSquare ( NUM_ , NUM_ ) , Piece . BROOK ) ; strMoves = getMoveList ( pos , BOOL_ ) ; assertTrue ( ! strMoves . contains ( STR_ ) ) ; assertTrue ( strMoves . contains ( STR_ ) ) ; pos . setPiece ( Position . getSquare ( NUM_ , NUM_ ) , Piece . EMPTY ) ; pos . setPiece ( Position . getSquare ( NUM_ , NUM_ ) , Piece . BBISHOP ) ; strMoves = getMoveList ( pos , BOOL_ ) ; assertTrue ( strMoves . contains ( STR_ ) ) ; assertTrue ( ! strMoves . contains ( STR_ ) ) ; pos . setPiece ( Position . getSquare ( NUM_ , NUM_ ) , Piece . EMPTY ) ; pos . setCastleMask ( NUM_ << Position . A1_CASTLE ) ; strMoves = getMoveList ( pos , BOOL_ ) ; assertTrue ( ! strMoves . contains ( STR_ ) ) ; assertTrue ( strMoves . contains ( STR_ ) ) ; }
private void doDdpOrientation ( Node d , Node a , Node b , Node c , Graph graph ) { List < Node > sepset = getSepset ( d , c ) ; if ( sepset == null ) { return ; } if ( sepset . contains ( b ) ) { graph . setEndpoint ( c , b , Endpoint . TAIL ) ; if ( verbose ) { logger . log ( STR_ , SearchLogUtils . edgeOrientedMsg ( STR_ + d , graph . getEdge ( b , c ) ) ) ; out . println ( SearchLogUtils . edgeOrientedMsg ( STR_ + d , graph . getEdge ( b , c ) ) ) ; } changeFlag = BOOL_ ; } else { if ( ! isArrowpointAllowed ( a , b , graph ) ) { return ; } if ( ! isArrowpointAllowed ( c , b , graph ) ) { return ; } graph . setEndpoint ( a , b , Endpoint . ARROW ) ; graph . setEndpoint ( c , b , Endpoint . ARROW ) ; logger . log ( STR_ , SearchLogUtils . colliderOrientedMsg ( STR_ + d , a , b , c ) ) ; changeFlag = BOOL_ ; } }
public void handleTblBootstrapResOffHrefActionRequest ( RequestInvocationEvent event ) throws ModelControlException { try { Map values = getValues ( ) ; onBeforeSaveProfile ( values ) ; setPageSessionAttribute ( PROPERTY_ATTRIBUTE , ( HashMap ) values ) ; SMDiscoveryBootstrapRefOffEditViewBean vb = ( SMDiscoveryBootstrapRefOffEditViewBean ) getViewBean ( SMDiscoveryBootstrapRefOffEditViewBean . class ) ; unlockPageTrail ( ) ; passPgSessionMap ( vb ) ; vb . populateValues ( ( String ) getDisplayFieldValue ( TBL_BOOTSTRAP_RES_OFF_HREF_ACTION ) ) ; vb . forwardTo ( getRequestContext ( ) ) ; } catch ( AMConsoleException e ) { setInlineAlertMessage ( CCAlert . TYPE_ERROR , STR_ , e . getMessage ( ) ) ; } }
@ VisibleForTesting String postRequest ( long timestamp , String xml ) throws RequestFailureException { String response = null ; HttpURLConnection urlConnection = null ; try { urlConnection = createConnection ( ) ; setUpPostRequest ( timestamp , urlConnection , xml ) ; sendRequestToServer ( urlConnection , xml ) ; response = readResponseFromServer ( urlConnection ) ; } finally { if ( urlConnection != null ) { urlConnection . disconnect ( ) ; } } return response ; }
private void generateKey ( ) throws Exception { KeyGenerator keygen = KeyGenerator . getInstance ( ALGO ) ; SecretKey key = keygen . generateKey ( ) ; persistKey ( key ) ; }
public HttpRequestEvent fireHttpRequestEvent ( String request , OutputStream output ) throws IOException { HttpRequestEvent event = new HttpRequestEvent ( this , request , output ) ; HttpRequestListener listener ; Vector list = ( Vector ) listeners . clone ( ) ; Enumeration e = list . elements ( ) ; while ( e . hasMoreElements ( ) ) { listener = ( HttpRequestListener ) e . nextElement ( ) ; listener . httpRequest ( event ) ; } return event ; }
private void parseRecord ( Element unitNode ) { NodeList nl = unitNode . getChildNodes ( ) ; for ( int i = NUM_ ; i < nl . getLength ( ) ; i ++ ) { Node currNode = nl . item ( i ) ; if ( currNode . getParentNode ( ) != unitNode ) { continue ; } int nodeType = currNode . getNodeType ( ) ; if ( nodeType == Node . ELEMENT_NODE ) { String nodeName = currNode . getNodeName ( ) ; if ( nodeName . equalsIgnoreCase ( UNIT ) ) { parseUnit ( ( Element ) currNode , entities ) ; } else if ( nodeName . equalsIgnoreCase ( SURVIVORS ) ) { parseUnit ( ( Element ) currNode , survivors ) ; } else if ( nodeName . equalsIgnoreCase ( ALLIES ) ) { parseUnit ( ( Element ) currNode , allies ) ; } else if ( nodeName . equalsIgnoreCase ( SALVAGE ) ) { parseUnit ( ( Element ) currNode , salvage ) ; } else if ( nodeName . equalsIgnoreCase ( DEVASTATED ) ) { parseUnit ( ( Element ) currNode , devastated ) ; } else if ( nodeName . equalsIgnoreCase ( KILLS ) ) { parseKills ( ( Element ) currNode ) ; } else if ( nodeName . equalsIgnoreCase ( ENTITY ) ) { parseUnit ( ( Element ) currNode , entities ) ; } else if ( nodeName . equalsIgnoreCase ( PILOT ) ) { parsePilot ( ( Element ) currNode ) ; } } else { continue ; } } }
public void cancel ( ) { synchronized ( lock ) { if ( this . latency == NO_TARGET ) { throw new IllegalStateException ( STR_ + STR_ ) ; } if ( ! requests . remove ( this ) ) { throw new InternalError ( STR_ + this + STR_ ) ; } if ( requests . isEmpty ( ) ) requests = null ; this . latency = NO_TARGET ; adjustLatencyIfNeeded ( ) ; } }
void mergeSuccess ( MergePolicy . OneMerge merge ) { }
void startEventTracker ( ) { List < EventTrackingService > services = getEnabledServicesForType ( EventTrackingService . class ) ; if ( services != null && ! services . isEmpty ( ) ) { if ( eventTracker == null ) { eventTracker = new EventTracker ( context , services , foamApiKeys . wifiOnly ( ) ) ; } if ( ! eventTracker . isRunning ( ) ) { eventTracker . start ( ) ; } } }
@ Override public int preceding ( int offset ) { CharacterIterator text = getText ( ) ; checkOffset ( offset , text ) ; if ( cachedBreakPositions == null || offset <= cachedBreakPositions [ NUM_ ] || offset > cachedBreakPositions [ cachedBreakPositions . length - NUM_ ] ) { cachedBreakPositions = null ; return super . preceding ( offset ) ; } else { positionInCache = NUM_ ; while ( positionInCache < cachedBreakPositions . length && offset > cachedBreakPositions [ positionInCache ] ) { ++ positionInCache ; } -- positionInCache ; text . setIndex ( cachedBreakPositions [ positionInCache ] ) ; return text . getIndex ( ) ; } }
protected static boolean signedFitsInNibble ( int value ) { return ( value >= - NUM_ ) && ( value <= NUM_ ) ; }
@ Override public void mousePressed ( MouseEvent e ) { events . clear ( ) ; if ( mapDragOperationFromModifiers ( e ) != DnDConstants . ACTION_NONE ) { try { motionThreshold = DragSource . getDragThreshold ( ) ; } catch ( Exception exc ) { motionThreshold = NUM_ ; } appendEvent ( e ) ; } }
public void simpleElement ( String name , String value ) throws IOException { simpleElement ( null , name , null , value ) ; }
public static boolean isValidIPv4 ( String address ) { if ( address . length ( ) == NUM_ ) { return BOOL_ ; } int octet ; int octets = NUM_ ; String temp = address + STR_ ; int pos ; int start = NUM_ ; while ( start < temp . length ( ) && ( pos = temp . indexOf ( STR_ , start ) ) > start ) { if ( octets == NUM_ ) { return BOOL_ ; } try { octet = Integer . parseInt ( temp . substring ( start , pos ) ) ; } catch ( NumberFormatException ex ) { return BOOL_ ; } if ( octet < NUM_ || octet > NUM_ ) { return BOOL_ ; } start = pos + NUM_ ; octets ++ ; } return octets == NUM_ ; }
private void validateDimensionCSV ( SchemaInfo schemaInfo , String factTableName , String dimTableName , CarbonFile dimFile , String partitionId , CarbonDataLoadSchema schema , String delimiter ) throws DataLoadingException { String [ ] columnNames = getDimColumnNames ( schemaInfo , factTableName , dimTableName , partitionId , schema ) ; if ( null == columnNames || columnNames . length < NUM_ ) { return ; } if ( ! checkAllColumnsPresent ( columnNames , dimFile . getAbsolutePath ( ) , delimiter ) ) { LOGGER . error ( STR_ + STR_ + dimFile . getName ( ) ) ; throw new DataLoadingException ( DataProcessorConstants . CSV_VALIDATION_ERRROR_CODE , STR_ + STR_ + dimFile . getName ( ) ) ; } }
private DataPoint isUnique ( Node from , DataPoint point , double tolerance ) { if ( logger . isDebugEnabled ( ) ) logger . debug ( STR_ + tolerance + STR_ + point ) ; while ( from . type == Type . branch ) { Branch branch = ( Branch ) from ; double d = point . get ( branch . splitDimension ) ; if ( Math . abs ( d - branch . midPoint ) < tolerance ) { if ( logger . isDebugEnabled ( ) ) logger . debug ( STR_ + branch + STR_ ) ; DataPoint leftCheck = isUnique ( branch . left , point , tolerance ) ; DataPoint rightCheck = isUnique ( branch . right , point , tolerance ) ; if ( ( leftCheck == null ) && ( rightCheck == null ) ) { return null ; } else { if ( leftCheck != null ) { return leftCheck ; } else { return rightCheck ; } } } else if ( point . getVector ( ) [ branch . splitDimension ] < branch . midPoint ) { if ( logger . isDebugEnabled ( ) ) logger . debug ( STR_ + branch + STR_ ) ; from = branch . left ; } else { if ( logger . isDebugEnabled ( ) ) logger . debug ( STR_ + branch + STR_ ) ; from = branch . right ; } } Leaf leaf = ( Leaf ) from ; for ( DataPoint p : leaf . points ) { for ( int i = NUM_ ; i < p . getDimension ( ) ; i ++ ) { if ( Math . abs ( p . get ( i ) - point . get ( i ) ) >= tolerance ) { break ; } } if ( getDistance ( p , point ) < tolerance ) { return p ; } } return null ; }
public boolean removeTuple ( Tuple t ) { Table table = t . getTable ( ) ; if ( m_sets . contains ( table ) ) { return table . removeTuple ( t ) ; } else { return BOOL_ ; } }
private boolean isDarkThemeSet ( ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( getActivity ( ) ) ; String key = getString ( R . string . theme_preference_key ) ; String defaultValue = getString ( R . string . theme_preference_default_value ) ; return Integer . valueOf ( sharedPreferences . getString ( key , defaultValue ) ) != NUM_ ; }
public String visit ( Type t , Locale locale ) { return t . accept ( this , locale ) ; }
public synchronized void add ( String name , long threadId ) { if ( mFinished ) { throw new IllegalStateException ( STR_ ) ; } mMarkers . add ( new Marker ( name , threadId , SystemClock . elapsedRealtime ( ) ) ) ; }
@ Deprecated public void addPrefixNSMapping ( String prefix , String nsURI ) { if ( nsURI . length ( ) == NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } if ( prefix . length ( ) == NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } if ( prefix . equals ( NO_NS_PREFIX ) ) { throw new IllegalArgumentException ( STR_ + prefix + STR_ ) ; } if ( prefixToNamespaceURILookup . containsKey ( prefix ) ) { throw new IllegalArgumentException ( STR_ + prefix + STR_ ) ; } if ( namespaceURIToPrefixLookup . containsKey ( nsURI ) ) { throw new IllegalArgumentException ( STR_ + nsURI + STR_ ) ; } if ( prefix . equals ( DEFAULT_NAMESPACE_PREFIX ) ) { this . defaultNS = nsURI ; } else { prefixToNamespaceURILookup . put ( prefix , nsURI ) ; namespaceURIToPrefixLookup . put ( nsURI , prefix ) ; } }
protected Message createResponseMessage ( ) { return new Message ( NUM_ , Version . CURRENT ) ; }
public static void o ( double a ) { o ( a , Parameters . OutputFieldWidth , Parameters . OutputFracPlaces ) ; }
public void writeField ( String name , String value ) throws IOException { if ( name == null ) { throw new IllegalArgumentException ( STR_ ) ; } out . writeBytes ( PREFIX ) ; out . writeBytes ( boundary ) ; out . writeBytes ( NEWLINE ) ; out . writeBytes ( STR_ + name + STR_ ) ; out . writeBytes ( NEWLINE ) ; out . writeBytes ( NEWLINE ) ; if ( value != null ) { out . writeBytes ( value ) ; } out . writeBytes ( NEWLINE ) ; out . flush ( ) ; }
public int drainTo ( Collection < ? super E > c ) { int result = buffer . drainTo ( c ) ; if ( producer != null ) { producer . wakeUp ( ) ; } return result ; }
protected void grow ( ) { if ( dists == EMPTY_DISTS ) { dists = new double [ INITIAL_SIZE ] ; ids = new int [ INITIAL_SIZE ] ; return ; } final int len = dists . length ; final int newlength = len + ( len > > NUM_ ) ; double [ ] odists = dists ; dists = new double [ newlength ] ; System . arraycopy ( odists , NUM_ , dists , NUM_ , odists . length ) ; int [ ] oids = ids ; ids = new int [ newlength ] ; System . arraycopy ( oids , NUM_ , ids , NUM_ , oids . length ) ; }
IgfsInputStreamImpl ( IgfsContext igfsCtx , IgfsPath path , @ Nullable IgfsEntryInfo fileInfo , int prefetchBlocks , int seqReadsBeforePrefetch , @ Nullable IgfsSecondaryFileSystemPositionedReadable secReader , long len , int blockSize , long blocksCnt , boolean proxy ) { assert igfsCtx != null ; assert path != null ; this . igfsCtx = igfsCtx ; this . path = path ; this . fileInfo = fileInfo ; this . prefetchBlocks = prefetchBlocks ; this . seqReadsBeforePrefetch = seqReadsBeforePrefetch ; this . secReader = secReader ; this . len = len ; this . blockSize = blockSize ; this . blocksCnt = blocksCnt ; this . proxy = proxy ; log = igfsCtx . kernalContext ( ) . log ( IgfsInputStream . class ) ; maxLocCacheSize = ( prefetchBlocks > NUM_ ? prefetchBlocks : NUM_ ) . NUM_ / NUM_ ; locCache = new LinkedHashMap < > ( maxLocCacheSize , NUM_ ) ; pendingFuts = new GridConcurrentHashSet < > ( prefetchBlocks > NUM_ ? prefetchBlocks : NUM_ ) ; igfsCtx . metrics ( ) . incrementFilesOpenedForRead ( ) ; }
public AbstractScaleOutClientIndexView ( final AbstractScaleOutFederation fed , final String name , final long timestamp , final IMetadataIndex metadataIndex ) { if ( fed == null ) throw new IllegalArgumentException ( ) ; if ( name == null ) throw new IllegalArgumentException ( ) ; if ( metadataIndex == null ) throw new IllegalArgumentException ( ) ; this . fed = fed ; this . name = name ; this . timestamp = timestamp ; this . metadataIndex = metadataIndex ; this . metadataIndexMetadata = metadataIndex . getIndexMetadata ( ) ; final AbstractClient < ? > client = fed . getClient ( ) ; this . capacity = client . getDefaultRangeQueryCapacity ( ) ; this . batchOnly = client . getBatchApiOnly ( ) ; this . taskTimeout = client . getTaskTimeout ( ) ; this . readConsistent = client . isReadConsistent ( ) ; }
public boolean canSendEvent ( ) { try { validateSendEvent ( ) ; return BOOL_ ; } catch ( Exception e ) { return BOOL_ ; } }
public static final String capitalize ( String str , char ... delimiters ) { final int delimLen = delimiters == null ? - NUM_ : delimiters . length ; if ( TextUtils . isEmpty ( str ) || delimLen == NUM_ ) { return str ; } final char [ ] buffer = str . toCharArray ( ) ; boolean capitalizeNext = BOOL_ ; for ( int i = NUM_ ; i < buffer . length ; i ++ ) { char ch = buffer [ i ] ; if ( isDelimiter ( ch , delimiters ) ) { capitalizeNext = BOOL_ ; } else if ( capitalizeNext ) { buffer [ i ] = Character . toTitleCase ( ch ) ; capitalizeNext = BOOL_ ; } } return new String ( buffer ) ; }
public void testCompareToNegZero ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = - NUM_ ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = BigInteger . ZERO ; assertEquals ( - NUM_ , aNumber . compareTo ( bNumber ) ) ; }
public void write ( OutputStream out ) throws SocksException , IOException { if ( data == null ) { Socks5Message msg ; if ( addrType == SOCKS_ATYP_DOMAINNAME ) msg = new Socks5Message ( command , host , port ) ; else { if ( ip == null ) { try { ip = InetAddress . getByName ( host ) ; } catch ( UnknownHostException uh_ex ) { throw new SocksException ( SocksConstants . SOCKS_JUST_ERROR ) ; } } msg = new Socks5Message ( command , ip , port ) ; } data = msg . data ; } out . write ( data ) ; }
public boolean isConnected ( short nodeId ) { NodeConnection nc = connections . get ( nodeId ) ; return ( nc != null && nc . state == NodeConnectionState . CONNECTED ) ; }
TemplateSubPatternAssociation ( ElemTemplate template , StepPattern pattern , String pat ) { m_pattern = pat ; m_template = template ; m_stepPattern = pattern ; m_targetString = m_stepPattern . getTargetString ( ) ; m_wild = m_targetString . equals ( STR_ ) ; }
public static byte [ ] compressForZlib ( byte [ ] bytesToCompress ) { Deflater deflater = new Deflater ( ) ; deflater . setInput ( bytesToCompress ) ; deflater . finish ( ) ; byte [ ] bytesCompressed = new byte [ Short . MAX_VALUE ] ; int numberOfBytesAfterCompression = deflater . deflate ( bytesCompressed ) ; byte [ ] returnValues = new byte [ numberOfBytesAfterCompression ] ; System . arraycopy ( bytesCompressed , NUM_ , returnValues , NUM_ , numberOfBytesAfterCompression ) ; return returnValues ; }
private static ByteBuffer generateWavData ( int sampleCount , int freqHz ) { final int numDataBytes = sampleCount . NUM_CHANNELS . BITS_PER_SAMPLE / NUM_ ; final double freq = freqHz ; ByteBuffer buf = ByteBuffer . allocate ( numDataBytes ) ; buf . order ( ByteOrder . LITTLE_ENDIAN ) ; if ( BITS_PER_SAMPLE == NUM_ ) { final double peak = NUM_ ; for ( int i = NUM_ ; i < sampleCount ; i ++ ) { double timeSec = i / ( double ) SAMPLE_RATE ; double sinValue = Math . sin ( NUM_ . Math . PI . freq . timeSec ) ; if ( GameSurfaceRenderer . EXTRA_CHECK ) { int output = ( int ) ( peak . sinValue + NUM_ ) ; if ( output < NUM_ || output >= NUM_ ) { throw new RuntimeException ( STR_ ) ; } } buf . put ( ( byte ) ( peak . sinValue + NUM_ ) ) ; } } else if ( BITS_PER_SAMPLE == NUM_ ) { final double peak = NUM_ ; ShortBuffer sbuf = buf . asShortBuffer ( ) ; for ( int i = NUM_ ; i < sampleCount ; i ++ ) { double timeSec = i / ( double ) SAMPLE_RATE ; double sinValue = Math . sin ( NUM_ . Math . PI . freq . timeSec ) ; sbuf . put ( ( short ) ( peak . sinValue ) ) ; } } buf . position ( NUM_ ) ; return buf ; }
protected static String h2c ( String hyphenated , boolean studly ) { StringBuilder b = new StringBuilder ( hyphenated . length ( ) ) ; boolean capNext = studly ; for ( int i = NUM_ ; i < hyphenated . length ( ) ; ++ i ) { char c = hyphenated . charAt ( i ) ; if ( c == STR_ ) capNext = BOOL_ ; else { b . append ( capNext ? Character . toUpperCase ( c ) : c ) ; capNext = BOOL_ ; } } return b . toString ( ) ; }
public synchronized void onWriteEvent ( ) throws IOException { LRMIInvocationTrace trace = null ; try { while ( ! _contexts . isEmpty ( ) ) { Context current = _contexts . peek ( ) ; trace = current . getTrace ( ) ; if ( trace != null ) LRMIInvocationContext . updateContext ( trace , null , null , null , null , BOOL_ , null , null ) ; noneBlockingWrite ( current ) ; if ( current . getPhase ( ) != Context . Phase . FINISH ) { setWriteInterest ( ) ; break ; } else { traceContextTotalWriteTime ( current ) ; _contexts . poll ( ) ; pendingWrites . decrement ( ) ; } } if ( _contexts . isEmpty ( ) ) { removeWriteInterest ( BOOL_ ) ; } } finally { if ( trace != null ) LRMIInvocationContext . resetContext ( ) ; } }
public static void add ( Object spy ) { SPIES . add ( spy ) ; }
void initLeafCalc ( byte [ ] seed0 ) { this . i = NUM_ ; this . j = NUM_ ; byte [ ] dummy = new byte [ mdsize ] ; System . arraycopy ( seed0 , NUM_ , dummy , NUM_ , seed . length ) ; this . seed = gmssRandom . nextSeed ( dummy ) ; }
@ Override public boolean downloadFile ( String path , String dest ) { try { FileOutputStream fos = new FileOutputStream ( new File ( dest ) ) ; mDBApi . getFile ( path , null , fos , null ) ; fos . close ( ) ; return BOOL_ ; } catch ( DropboxException e ) { e . printStackTrace ( ) ; return BOOL_ ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; return BOOL_ ; } catch ( IOException e ) { e . printStackTrace ( ) ; return BOOL_ ; } }
boolean doesOccur ( QName refName ) { return m_refs . contains ( refName ) ; }
public static DateFormat toDateFormat ( String dateFormat , TimeZone tz , Locale locale ) { DateFormat df = null ; if ( UtilValidate . isEmpty ( dateFormat ) ) { df = DateFormat . getDateInstance ( DateFormat . SHORT , locale ) ; } else { df = new SimpleDateFormat ( dateFormat , locale == null ? Locale . getDefault ( ) : locale ) ; } df . setTimeZone ( tz ) ; return df ; }
public Integer loadIdNameValues ( DbOutputStatement statement , Integer idx ) throws Exception { int index = idx . intValue ( ) ; if ( _logger . isDebugEnabled ( ) ) _logger . debug ( STR_ ) ; _id = statement . getLongInteger ( index ++ ) ; _name = statement . getShortText ( index ++ ) ; return new Integer ( index ) ; }
private byte [ ] padPassword ( byte [ ] password ) { if ( password == null ) { password = new byte [ NUM_ ] ; } byte [ ] padded = new byte [ NUM_ ] ; final int numContributingPasswordBytes = password . length > padded . length ? padded . length : password . length ; System . arraycopy ( password , NUM_ , padded , NUM_ , numContributingPasswordBytes ) ; if ( password . length < padded . length ) { System . arraycopy ( PW_PADDING , NUM_ , padded , password . length , padded . length - password . length ) ; } return padded ; }
private double maxDistLevel ( DBID id , int level ) { final NumberVector obj = relation . get ( id ) ; final double r = NUM_ / ( NUM_ << ( level - NUM_ ) ) ; double dist ; if ( t == NUM_ ) { dist = NUM_ ; for ( int dim = NUM_ ; dim < d ; dim ++ ) { final double p_m_r = getDimForObject ( obj , dim ) % r ; dist += Math . max ( p_m_r , r - p_m_r ) ; } } else if ( t == NUM_ ) { dist = NUM_ ; for ( int dim = NUM_ ; dim < d ; dim ++ ) { final double p_m_r = getDimForObject ( obj , dim ) % r ; double a = Math . max ( p_m_r , r - p_m_r ) ; dist += a . a ; } dist = Math . sqrt ( dist ) ; } else if ( ! Double . isInfinite ( t ) ) { dist = NUM_ ; for ( int dim = NUM_ ; dim < d ; dim ++ ) { final double p_m_r = getDimForObject ( obj , dim ) % r ; dist += Math . pow ( Math . max ( p_m_r , r - p_m_r ) , t ) ; } dist = Math . pow ( dist , NUM_ / t ) ; } else { dist = Double . NEGATIVE_INFINITY ; for ( int dim = NUM_ ; dim < d ; dim ++ ) { final double p_m_r = getDimForObject ( obj , dim ) % r ; dist = Math . max ( dist , Math . max ( p_m_r , r - p_m_r ) ) ; } } return dist . diameter ; }
public final int moveMade ( long now , boolean useIncrement ) { stopTimer ( now ) ; ArrayList < TimeControlField > tc = tcData . getTC ( whiteToMove ) ; Pair < Integer , Integer > tcInfo = getCurrentTC ( whiteToMove ) ; int tcIdx = tcInfo . first ; int movesToTc = tcInfo . second ; int remaining = getRemainingTime ( whiteToMove , now ) ; if ( useIncrement ) { remaining += tc . get ( tcIdx ) . increment ; if ( movesToTc == NUM_ ) { if ( tcIdx + NUM_ < tc . size ( ) ) tcIdx ++ ; remaining += tc . get ( tcIdx ) . timeControl ; } } elapsed = NUM_ ; return remaining ; }
public static Properties prefixProperties ( Properties props , String prefix ) { Properties prefixProps = new Properties ( ) ; for ( String key : props . stringPropertyNames ( ) ) { if ( key . startsWith ( prefix ) ) { String keyWithoutPrefix = key . substring ( prefix . length ( ) ) ; prefixProps . setProperty ( keyWithoutPrefix , props . getProperty ( key ) ) ; } } return prefixProps ; }
public final void testSetRegex ( ) { RegexConstraint regexConstraint = new RegexConstraint ( Pattern . compile ( STR_ ) ) ; regexConstraint . setRegex ( REGEX ) ; assertEquals ( REGEX , regexConstraint . getRegex ( ) ) ; }
public synchronized void start ( ) { if ( isStarted ) { return ; } if ( isStopped ) { throw new IllegalStateException ( STR_ ) ; } logger . info ( STR_ + Tor . getFullVersion ( ) + STR_ ) ; verifyUnlimitedStrengthPolicyInstalled ( ) ; directoryDownloader . start ( directory ) ; circuitManager . startBuildingCircuits ( ) ; if ( dashboard . isEnabledByProperty ( ) ) { dashboard . startListening ( ) ; } isStarted = BOOL_ ; }
public static CipherParameters makePBEParameters ( PBEKeySpec keySpec , int type , int hash , int keySize , int ivSize ) { PBEParametersGenerator generator = makePBEGenerator ( type , hash ) ; byte [ ] key ; CipherParameters param ; key = convertPassword ( type , keySpec ) ; generator . init ( key , keySpec . getSalt ( ) , keySpec . getIterationCount ( ) ) ; if ( ivSize != NUM_ ) { param = generator . generateDerivedParameters ( keySize , ivSize ) ; } else { param = generator . generateDerivedParameters ( keySize ) ; } for ( int i = NUM_ ; i != key . length ; i ++ ) { key [ i ] = NUM_ ; } return param ; }
@ Override public double value ( int attIndex ) { int index = locateIndex ( attIndex ) ; if ( ( index >= NUM_ ) && ( m_Indices [ index ] == attIndex ) ) { return NUM_ ; } else { return NUM_ ; } }
private void fetchFilterSeeds ( ) { if ( seedList == null || seedList . isEmpty ( ) ) { return ; } for ( Iterator < URI > it = seedList . iterator ( ) ; it . hasNext ( ) ; ) { URI seed = it . next ( ) ; for ( FetchFilter filter : controller . getFetchFilters ( ) ) { FetchStatus filterReason = filter . checkFilter ( seed ) ; if ( filterReason != FetchStatus . VALID ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + seed + STR_ + filterReason ) ; } it . remove ( ) ; break ; } } } }
public XYAreaRenderer2 ( XYToolTipGenerator labelGenerator , XYURLGenerator urlGenerator ) { super ( ) ; this . showOutline = BOOL_ ; setBaseToolTipGenerator ( labelGenerator ) ; setURLGenerator ( urlGenerator ) ; GeneralPath area = new GeneralPath ( ) ; area . moveTo ( NUM_ , - NUM_ ) ; area . lineTo ( NUM_ , - NUM_ ) ; area . lineTo ( NUM_ , NUM_ ) ; area . lineTo ( - NUM_ , NUM_ ) ; area . lineTo ( - NUM_ , - NUM_ ) ; area . closePath ( ) ; this . legendArea = area ; }
public static boolean isPrimitiveOrWrapper ( Class < ? > clazz ) { Assert . notNull ( clazz , STR_ ) ; return ( clazz . isPrimitive ( ) || isPrimitiveWrapper ( clazz ) ) ; }
private void assertFileContains ( List < String > expected , String filename ) throws Exception { try ( BufferedReader reader = new BufferedReader ( new FileReader ( filename ) ) ) { List < String > actual = new ArrayList < > ( ) ; for ( ; ; ) { String line = reader . readLine ( ) ; if ( line == null ) { break ; } actual . add ( line ) ; } assertEquals ( expected , actual ) ; } }
private void reportException ( Kind kind , Element element , Throwable t ) { StringWriter buf = new StringWriter ( ) ; t . printStackTrace ( new PrintWriter ( buf ) ) ; buf . toString ( ) ; message ( kind , element , STR_ , buf . toString ( ) ) ; }
public void add ( String [ ] titles , double [ ] values ) { add ( mCategories . size ( ) + STR_ , titles , values ) ; }
static String parseAuthority ( String uriString , int ssi ) { int length = uriString . length ( ) ; if ( length > ssi + NUM_ && uriString . charAt ( ssi + NUM_ ) == STR_ && uriString . charAt ( ssi + NUM_ ) == STR_ ) { int end = ssi + NUM_ ; LOOP : while ( end < length ) { switch ( uriString . charAt ( end ) ) { case STR_ : case STR_ : case STR_ : break LOOP ; } end ++ ; } return uriString . substring ( ssi + NUM_ , end ) ; } else { return null ; } }
public static void sort ( List < ? > list ) { if ( list . size ( ) > NUM_ ) { Collections . sort ( list , INSTANCE ) ; } }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( NUM_ ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return newVector . elements ( ) ; }
public void addDatatransferProgressListener ( OnDatatransferProgressListener listener , OCUpload ocUpload ) { if ( ocUpload == null || listener == null ) return ; String targetKey = buildRemoteName ( ocUpload . getAccountName ( ) , ocUpload . getRemotePath ( ) ) ; mBoundListeners . put ( targetKey , listener ) ; }
private static char [ ] zzUnpackCMap ( String packed ) { char [ ] map = new char [ x10000 ] ; int i = NUM_ ; int j = NUM_ ; while ( i < NUM_ ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM_ ) ; } return map ; }
protected String [ ] readNext ( LineNumberReader reader ) throws IOException { String [ ] rowDef = null ; do { String nextLine = reader . readLine ( ) ; if ( nextLine == null ) { hasNext = BOOL_ ; return rowDef ; } String [ ] r = parser . parseLineMulti ( nextLine ) ; if ( r . length > NUM_ ) { if ( rowDef == null ) { rowDef = r ; } else { String [ ] t = new String [ rowDef . length + r . length ] ; System . arraycopy ( rowDef , NUM_ , t , NUM_ , rowDef . length ) ; System . arraycopy ( r , NUM_ , t , rowDef . length , r . length ) ; rowDef = t ; } } } while ( parser . isPending ( ) ) ; return rowDef ; }
public Class < ? > type ( ) { if ( isClass ) { return ( Class < ? > ) object ; } else { return object . getClass ( ) ; } }
private void verifyPropertySourceValue ( ReloadablePropertySource reloadablePropertySource , String expectedValue ) { logger . debug ( STR_ + TEST_KEY + STR_ + expectedValue ) ; logger . debug ( STR_ + properties . get ( TEST_KEY ) + STR_ + reloadablePropertySource . getProperty ( TEST_KEY ) ) ; String value = ( String ) reloadablePropertySource . getProperty ( TEST_KEY ) ; assertEquals ( expectedValue , value ) ; }
private void updateCenterPanel ( ) { long now = System . currentTimeMillis ( ) ; if ( _nextUpdateTime > now ) return ; _nextUpdateTime = now + NUM_ . NUM_ ; _centerPanel . removeAll ( ) ; _centerComponent = new JLabel ( ) ; GridBagConstraints gbc = new GridBagConstraints ( ) ; gbc . gridx = NUM_ ; gbc . gridy = NUM_ ; gbc . weightx = NUM_ ; gbc . fill = GridBagConstraints . NONE ; gbc . anchor = GridBagConstraints . CENTER ; _centerPanel . add ( _centerComponent , gbc ) ; refresh ( ) ; }
public void serviceRequestQueue ( ) throws CLIException { if ( isVerbose ( ) ) { outputWriter . printlnMessage ( rbMessages . getString ( STR_ ) ) ; } try { while ( ! requestQueue . isEmpty ( ) ) { CLIRequest req = ( CLIRequest ) requestQueue . remove ( NUM_ ) ; try { req . process ( this ) ; if ( statusOS != null ) { String status = formatStatus ( req . getOptions ( ) , NUM_ ) ; statusOS . write ( status . getBytes ( ) ) ; } } catch ( CLIException e ) { if ( isVerbose ( ) ) { e . printStackTrace ( System . out ) ; } if ( statusOS != null ) { String status = formatStatus ( req . getOptions ( ) , e . getExitCode ( ) ) ; statusOS . write ( status . getBytes ( ) ) ; } if ( bContinue ) { outputWriter . printlnError ( e . getMessage ( ) ) ; } else { throw e ; } } } } catch ( IOException e ) { throw new CLIException ( e , ExitCodes . REQUEST_CANNOT_BE_PROCESSED ) ; } finally { if ( statusOS != null ) { try { statusOS . close ( ) ; } catch ( IOException ex ) { } statusOS = null ; } } }
AlwaysIdenticalKeyStoreState ( ) { super ( ) ; }
public static byte [ ] packByteBufferIntoSingleByteArray ( ByteBuffer [ ] byteBufferArr ) { if ( null == byteBufferArr || byteBufferArr . length == NUM_ ) { return null ; } int noOfCol = byteBufferArr . length ; short offsetLen = ( short ) ( noOfCol . NUM_ ) ; int totalBytes = calculateTotalBytes ( byteBufferArr ) + offsetLen ; ByteBuffer buffer = ByteBuffer . allocate ( totalBytes ) ; buffer . putShort ( offsetLen ) ; for ( int index = NUM_ ; index < byteBufferArr . length - NUM_ ; index ++ ) { ByteBuffer individualCol = byteBufferArr [ index ] ; int noOfBytes = individualCol . capacity ( ) ; buffer . putShort ( ( short ) ( offsetLen + noOfBytes ) ) ; offsetLen += noOfBytes ; individualCol . rewind ( ) ; } for ( int index = NUM_ ; index < byteBufferArr . length ; index ++ ) { ByteBuffer individualCol = byteBufferArr [ index ] ; buffer . put ( individualCol . array ( ) ) ; } buffer . rewind ( ) ; return buffer . array ( ) ; }
public void stop ( ) { mCancel = BOOL_ ; if ( mRunning . compareAndSet ( BOOL_ , BOOL_ ) ) { if ( mSampleDispatcherTask != null ) { mThreadPoolManager . cancel ( mSampleDispatcherTask ) ; mSampleDispatcherTask = null ; mFilledBuffers . clear ( ) ; } } }
public void add ( SimpleName ref ) { String typeName = ref . getIdentifier ( ) ; if ( fImportsAdded . contains ( typeName ) ) { return ; } IBinding binding = ref . resolveBinding ( ) ; if ( binding != null ) { if ( binding . getKind ( ) != IBinding . TYPE ) { return ; } ITypeBinding typeBinding = ( ITypeBinding ) binding ; if ( typeBinding . isArray ( ) ) { typeBinding = typeBinding . getElementType ( ) ; } typeBinding = typeBinding . getTypeDeclaration ( ) ; if ( ! typeBinding . isRecovered ( ) ) { if ( needsImport ( typeBinding , ref ) ) { fImpStructure . addImport ( typeBinding ) ; fImportsAdded . add ( typeName ) ; } return ; } } else { if ( fDoIgnoreLowerCaseNames && typeName . length ( ) > NUM_ ) { char ch = typeName . charAt ( NUM_ ) ; if ( Strings . isLowerCase ( ch ) && Character . isLetter ( ch ) ) { return ; } } } fImportsAdded . add ( typeName ) ; fUnresolvedTypes . put ( typeName , new UnresolvedTypeData ( ref ) ) ; }
private static boolean checkFont ( String fontName , String newName , String testString , boolean force ) { boolean displayable = BOOL_ ; Font f = UIManager . getFont ( fontName ) ; if ( f != null && ! newName . equalsIgnoreCase ( f . getName ( ) ) ) { if ( ! GUIUtils . canDisplay ( f , testString ) || force ) { f = new Font ( newName , f . getStyle ( ) , f . getSize ( ) ) ; if ( GUIUtils . canDisplay ( f , testString ) ) UIManager . put ( fontName , f ) ; else displayable = BOOL_ ; } } else if ( f != null ) { displayable = GUIUtils . canDisplay ( f , testString ) ; } else { displayable = BOOL_ ; } return displayable ; }
public void addAllSearchables ( ArrayList < ? extends SearchResult > searchable ) { mSearchableList . addAll ( searchable ) ; }
public List < ValueBox > addArgumentHotspots ( String signature , int arg ) { List < ValueBox > sigSpots = StringAnalysis . getArgumentExpressions ( signature , arg ) ; return addArgumentHotspots ( signature , arg , sigSpots ) ; }
public boolean isFull ( ) { return counter . get ( ) == qSize ; }
public static String JQ ( String request ) throws Exception { int queryStartPos = request . indexOf ( STR_ ) ; String query ; String path ; if ( - NUM_ == queryStartPos ) { query = STR_ ; path = request ; } else { query = request . substring ( queryStartPos + NUM_ ) ; path = request . substring ( NUM_ , queryStartPos ) ; } query = setParam ( query , STR_ , STR_ ) ; request = path + STR_ + setParam ( query , STR_ , STR_ ) ; String response ; boolean failed = BOOL_ ; try { response = restTestHarness . query ( request ) ; failed = BOOL_ ; } finally { if ( failed ) { log . error ( STR_ + request ) ; } } return response ; }
static void sort ( int [ ] a , int left , int right , int [ ] work , int workBase , int workLen ) { if ( right - left < QUICKSORT_THRESHOLD ) { sort ( a , left , right , BOOL_ ) ; return ; } int [ ] run = new int [ MAX_RUN_COUNT + NUM_ ] ; int count = NUM_ ; run [ NUM_ ] = left ; for ( int k = left ; k < right ; run [ count ] = k ) { while ( k < right && a [ k ] == a [ k + NUM_ ] ) k ++ ; if ( k == right ) break ; if ( a [ k ] < a [ k + NUM_ ] ) { while ( ++ k <= right && a [ k - NUM_ ] <= a [ k ] ) ; } else if ( a [ k ] > a [ k + NUM_ ] ) { while ( ++ k <= right && a [ k - NUM_ ] >= a [ k ] ) ; for ( int lo = run [ count ] - NUM_ , hi = k ; ++ lo < -- hi ; ) { int t = a [ lo ] ; a [ lo ] = a [ hi ] ; a [ hi ] = t ; } } if ( run [ count ] > left && a [ run [ count ] ] >= a [ run [ count ] - NUM_ ] ) { count -- ; } if ( ++ count == MAX_RUN_COUNT ) { sort ( a , left , right , BOOL_ ) ; return ; } } if ( count == NUM_ ) { return ; } else if ( count == NUM_ && run [ count ] > right ) { return ; } right ++ ; if ( run [ count ] < right ) { run [ ++ count ] = right ; } byte odd = NUM_ ; for ( int n = NUM_ ; ( n <<= NUM_ ) < count ; odd ^= NUM_ ) ; int [ ] b ; int ao , bo ; int blen = right - left ; if ( work == null || workLen < blen || workBase + blen > work . length ) { work = new int [ blen ] ; workBase = NUM_ ; } if ( odd == NUM_ ) { System . arraycopy ( a , left , work , workBase , blen ) ; b = a ; bo = NUM_ ; a = work ; ao = workBase - left ; } else { b = work ; ao = NUM_ ; bo = workBase - left ; } for ( int last ; count > NUM_ ; count = last ) { for ( int k = ( last = NUM_ ) + NUM_ ; k <= count ; k += NUM_ ) { int hi = run [ k ] , mi = run [ k - NUM_ ] ; for ( int i = run [ k - NUM_ ] , p = i , q = mi ; i < hi ; ++ i ) { if ( q >= hi || p < mi && a [ p + ao ] <= a [ q + ao ] ) { b [ i + bo ] = a [ p ++ + ao ] ; } else { b [ i + bo ] = a [ q ++ + ao ] ; } } run [ ++ last ] = hi ; } if ( ( count & NUM_ ) != NUM_ ) { for ( int i = right , lo = run [ count - NUM_ ] ; -- i >= lo ; b [ i + bo ] = a [ i + ao ] ) ; run [ ++ last ] = right ; } int [ ] t = a ; a = b ; b = t ; int o = ao ; ao = bo ; bo = o ; } }
protected void shiftEnd ( int newSize ) { int oldSize = getArrayLength ( ) ; int oldGapEnd = g1 ; int upperSize = oldSize - oldGapEnd ; int arrayLength = getNewArraySize ( newSize ) ; int newGapEnd = arrayLength - upperSize ; resize ( arrayLength ) ; g1 = newGapEnd ; if ( upperSize != NUM_ ) { System . arraycopy ( array , oldGapEnd , array , newGapEnd , upperSize ) ; } }
protected void processStyle12ExamineAndSetupAdjustment ( Game game , Style12Message message , GameService service , String entireMessage ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( STR_ ) ; } if ( game . isInState ( Game . OBSERVING_EXAMINED_STATE ) && message . relation == Style12Message . EXAMINING_GAME_RELATION ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( STR_ ) ; } examineGamesWaitingOnMoves . put ( game . getId ( ) , message ) ; connector . sendMessage ( STR_ + message . gameId , BOOL_ , ChatType . MOVES ) ; } else if ( entireMessage . contains ( STR_ ) || entireMessage . contains ( STR_ ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( STR_ ) ; } Game examineGame = IcsUtils . createGame ( message , entireMessage ) ; if ( message . relation == Style12Message . EXAMINING_GAME_RELATION && ! examineGame . isInState ( Game . SETUP_STATE ) ) { examineGamesWaitingOnMoves . put ( game . getId ( ) , message ) ; connector . sendMessage ( STR_ + message . gameId , BOOL_ , ChatType . MOVES ) ; } } else if ( game . isInState ( Game . EXAMINING_STATE ) && ( entireMessage . contains ( STR_ ) || entireMessage . contains ( STR_ ) ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( STR_ ) ; } processExaminedGameBecameSetup ( ) ; } else if ( entireMessage . contains ( STR_ ) || entireMessage . contains ( STR_ ) ) { examineGamesWaitingOnMoves . put ( game . getId ( ) , message ) ; connector . sendMessage ( STR_ + message . gameId , BOOL_ , ChatType . MOVES ) ; } else { IcsUtils . resetGame ( game , message ) ; service . fireGameStateChanged ( message . gameId , BOOL_ ) ; connector . sendMessage ( STR_ + message . gameId , BOOL_ , ChatType . MOVES ) ; } }
public SamFilterChain ( Collection < SamFilter > filters ) { mFilters = filters . toArray ( new SamFilter [ filters . size ( ) ] ) ; }
PreviousWordAction ( String nm , boolean select ) { super ( nm ) ; this . select = select ; }
static UnixStream < String > cat ( final String filePath ) throws IOException { Objects . requireNonNull ( filePath , STR_ ) ; return new UnixStreamImpl < > ( lines ( Paths . get ( filePath ) ) ) ; }
private static String encode_base64 ( byte d [ ] , int len ) throws IllegalArgumentException { int off = NUM_ ; StringBuffer rs = new StringBuffer ( ) ; int c1 , c2 ; if ( len <= NUM_ || len > d . length ) { throw new IllegalArgumentException ( STR_ ) ; } while ( off < len ) { c1 = d [ off ++ ] & xff ; rs . append ( base64_code [ ( c1 > > NUM_ ) & x3f ] ) ; c1 = ( c1 & x03 ) << NUM_ ; if ( off >= len ) { rs . append ( base64_code [ c1 & x3f ] ) ; break ; } c2 = d [ off ++ ] & xff ; c1 |= ( c2 > > NUM_ ) & x0f ; rs . append ( base64_code [ c1 & x3f ] ) ; c1 = ( c2 & x0f ) << NUM_ ; if ( off >= len ) { rs . append ( base64_code [ c1 & x3f ] ) ; break ; } c2 = d [ off ++ ] & xff ; c1 |= ( c2 > > NUM_ ) & x03 ; rs . append ( base64_code [ c1 & x3f ] ) ; rs . append ( base64_code [ c2 & x3f ] ) ; } return rs . toString ( ) ; }
protected void eleminateRedundent ( ElemTemplateElement psuedoVarRecipient , Vector paths ) { int n = paths . size ( ) ; int numPathsEliminated = NUM_ ; int numUniquePathsEliminated = NUM_ ; for ( int i = NUM_ ; i < n ; i ++ ) { ExpressionOwner owner = ( ExpressionOwner ) paths . elementAt ( i ) ; if ( null != owner ) { int found = findAndEliminateRedundant ( i + NUM_ , i , owner , psuedoVarRecipient , paths ) ; if ( found > NUM_ ) numUniquePathsEliminated ++ ; numPathsEliminated += found ; } } eleminateSharedPartialPaths ( psuedoVarRecipient , paths ) ; if ( DIAGNOSE_NUM_PATHS_REDUCED ) diagnoseNumPaths ( paths , numPathsEliminated , numUniquePathsEliminated ) ; }
public void commercialResult ( String stream , String resultText , RequestResult result ) { setCommercialResult ( DateTime . currentTime ( ) + STR_ + resultText ) ; lastCommercialRunAttempt = System . currentTimeMillis ( ) ; setLoadingCommercial ( BOOL_ ) ; if ( result == TwitchApi . RequestResult . RUNNING_COMMERCIAL ) { lastCommercial . put ( stream , System . currentTimeMillis ( ) ) ; if ( stream != null && stream . equals ( currentChannel ) ) { lastCommercialRun = System . currentTimeMillis ( ) ; } } }
void addFillComponents ( Container panel , int [ ] cols , int [ ] rows ) { Dimension filler = new Dimension ( NUM_ , NUM_ ) ; boolean filled_cell_11 = BOOL_ ; CellConstraints cc = new CellConstraints ( ) ; if ( cols . length > NUM_ && rows . length > NUM_ ) { if ( cols [ NUM_ ] == NUM_ && rows [ NUM_ ] == NUM_ ) { panel . add ( Box . createRigidArea ( filler ) , cc . xy ( NUM_ , NUM_ ) ) ; filled_cell_11 = BOOL_ ; } } for ( int index = NUM_ ; index < cols . length ; index ++ ) { if ( cols [ index ] == NUM_ && filled_cell_11 ) { continue ; } panel . add ( Box . createRigidArea ( filler ) , cc . xy ( cols [ index ] , NUM_ ) ) ; } for ( int index = NUM_ ; index < rows . length ; index ++ ) { if ( rows [ index ] == NUM_ && filled_cell_11 ) { continue ; } panel . add ( Box . createRigidArea ( filler ) , cc . xy ( NUM_ , rows [ index ] ) ) ; } }
public void done ( ) throws IOException { if ( ! initialStyles ) { writeInitialStyles ( ) ; initialStyles = BOOL_ ; } out . writeUBits ( NUM_ , NUM_ ) ; out . flushBits ( ) ; if ( bout != null && glyphCount > NUM_ ) { byte [ ] glyphBytes = bout . toByteArray ( ) ; glyphByteArrays . add ( glyphBytes ) ; } if ( glyphCount > NUM_ ) { bout = new ByteArrayOutputStream ( ) ; out = new OutStream ( bout ) ; glyphCount -- ; fill1Index = NUM_ ; lineIndex = NUM_ ; outstandingChanges = BOOL_ ; initialStyles = BOOL_ ; } else { if ( bout != null ) { finishFont ( ) ; } writer . completeTag ( ) ; } }
private static DetachISOResponse checkDetachISOResponse ( DetachISOResponse detachISOResponse ) throws RpcException { logger . info ( STR_ , detachISOResponse ) ; switch ( detachISOResponse . getResult ( ) ) { case OK : break ; case ISO_NOT_ATTACHED : logger . warn ( STR_ , detachISOResponse ) ; throw new IsoNotAttachedException ( detachISOResponse . getError ( ) ) ; case SYSTEM_ERROR : logger . warn ( STR_ , detachISOResponse ) ; throw new SystemErrorException ( detachISOResponse . getError ( ) ) ; case VM_NOT_FOUND : logger . warn ( STR_ , detachISOResponse ) ; throw new VmNotFoundException ( detachISOResponse . getError ( ) ) ; default : throw new RpcException ( String . format ( STR_ , detachISOResponse . getResult ( ) ) ) ; } return detachISOResponse ; }
public boolean is_terminal ( MethodOrMethodContext mc ) { Stack < SootMethod > sys_stack = new Stack < SootMethod > ( ) ; boolean result ; if ( ! is_system ( mc . method ( ) ) ) result = BOOL_ ; else { if ( ! process_callbacks ) result = BOOL_ ; else { if ( ( stack . size ( ) > NUM_ ) && is_system ( stack . peek ( ) ) ) result = ! calls_app_method ( mc , sys_stack ) ; else { if ( can_have_callbacks ( mc . method ( ) ) ) result = ! calls_app_method ( mc , sys_stack ) ; else result = BOOL_ ; } } } logger . info ( STR_ , mc . method ( ) , result ) ; return result ; }
boolean tryMatch ( SNode s ) { if ( match == null && UNSAFE . compareAndSwapObject ( this , matchOffset , null , s ) ) { Thread w = waiter ; if ( w != null ) { waiter = null ; LockSupport . unpark ( w ) ; } return BOOL_ ; } return match == s ; }
public void addItem ( int position , M model ) { mDatas . add ( position , model ) ; notifyItemInserted ( position ) ; }
public final Set < String > aliases ( ) { return Collections . unmodifiableSet ( this . aliasesSet ) ; }
public void encode ( OutputStream out ) throws IOException { DerOutputStream tmp = new DerOutputStream ( ) ; if ( this . extensionValue == null ) { this . extensionId = PKIXExtensions . IssuingDistributionPoint_Id ; this . critical = BOOL_ ; encodeThis ( ) ; } super . encode ( tmp ) ; out . write ( tmp . toByteArray ( ) ) ; }
public final void readChildren ( ObjectInputStream ois ) throws IOException , ClassNotFoundException { int count = serializable ; while ( count -- > NUM_ ) { Object child = null ; BeanContextSupport . BCSChild bscc = null ; try { child = ois . readObject ( ) ; bscc = ( BeanContextSupport . BCSChild ) ois . readObject ( ) ; } catch ( IOException ioe ) { continue ; } catch ( ClassNotFoundException cnfe ) { continue ; } synchronized ( child ) { BeanContextChild bcc = null ; try { bcc = ( BeanContextChild ) child ; } catch ( ClassCastException cce ) { } if ( bcc != null ) { try { bcc . setBeanContext ( getBeanContextPeer ( ) ) ; bcc . addPropertyChangeListener ( STR_ , childPCL ) ; bcc . addVetoableChangeListener ( STR_ , childVCL ) ; } catch ( PropertyVetoException pve ) { continue ; } } childDeserializedHook ( child , bscc ) ; } } }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case NUM_ : return SUCCESS ; default : return null ; } }
static boolean isChristmasTime ( Calendar cal ) { int month = cal . get ( Calendar . MONTH ) ; int day = cal . get ( Calendar . DAY_OF_MONTH ) ; if ( month >= NUM_ && month < NUM_ ) { return BOOL_ ; } if ( month == NUM_ ) { return day <= NUM_ ; } if ( month == NUM_ ) { return day >= NUM_ ; } return BOOL_ ; }
@ Override public void zoomRangeAxes ( double factor , PlotRenderingInfo info , Point2D source ) { zoomRangeAxes ( factor , info , source , BOOL_ ) ; }
@ Override public boolean connectionAllowed ( EventSetDescriptor esd ) { return connectionAllowed ( esd . getName ( ) ) ; }
private void boardSaveImage ( ) { if ( curfileImage == null ) { boardSaveAsImage ( ) ; return ; } JDialog waitD = new JDialog ( frame , Messages . getString ( STR_ ) ) ; waitD . add ( new JLabel ( Messages . getString ( STR_ ) ) ) ; waitD . setSize ( NUM_ , NUM_ ) ; waitD . setLocation ( ( frame . getSize ( ) . width / NUM_ ) - ( waitD . getSize ( ) . width / NUM_ ) , ( frame . getSize ( ) . height / NUM_ ) - ( waitD . getSize ( ) . height / NUM_ ) ) ; waitD . setVisible ( BOOL_ ) ; frame . setCursor ( Cursor . getPredefinedCursor ( Cursor . WAIT_CURSOR ) ) ; waitD . setCursor ( Cursor . getPredefinedCursor ( Cursor . WAIT_CURSOR ) ) ; try { ImageIO . write ( bv . getEntireBoardImage ( ) , STR_ , curfileImage ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } waitD . setVisible ( BOOL_ ) ; frame . setCursor ( Cursor . getDefaultCursor ( ) ) ; }
public boolean containsName ( String type , String name ) { List < String > names = getNames ( type ) ; return names . contains ( name ) ; }
@ SuppressWarnings ( STR_ ) public static < C extends Result > ArrayList < C > filterResults ( ResultHierarchy hier , Result r , Class < ? super C > restrictionClass ) { ArrayList < C > res = new ArrayList < > ( ) ; if ( restrictionClass . isInstance ( r ) ) { res . add ( ( C ) restrictionClass . cast ( r ) ) ; } for ( Hierarchy . Iter < Result > iter = hier . iterDescendants ( r ) ; iter . valid ( ) ; iter . advance ( ) ) { Result result = iter . get ( ) ; if ( restrictionClass . isInstance ( result ) ) { res . add ( ( C ) restrictionClass . cast ( result ) ) ; } } return res ; }
private boolean hasNextProxy ( ) { return nextProxyIndex < proxies . size ( ) ; }
@ Pure @ CausesError ( { IncorrectPure4JImmutableCallException . class , PureMethodParameterNotImmutableException . class } ) public String testParam1Bad ( Object in1 , Object in2 ) { Object in3 = in2 ; Pure4J . immutable ( in1 , in2 ) ; return in3 . toString ( ) ; }
protected boolean [ ] canHandleMissing ( boolean nominalPredictor , boolean numericPredictor , boolean stringPredictor , boolean datePredictor , boolean relationalPredictor , boolean multiInstance , int classType , boolean predictorMissing , boolean classMissing , int missingLevel ) { if ( missingLevel == NUM_ ) { print ( STR_ ) ; } print ( STR_ ) ; if ( predictorMissing ) { print ( STR_ ) ; if ( classMissing ) { print ( STR_ ) ; } } if ( classMissing ) { print ( STR_ ) ; } print ( STR_ ) ; printAttributeSummary ( nominalPredictor , numericPredictor , stringPredictor , datePredictor , relationalPredictor , multiInstance , classType ) ; print ( STR_ ) ; ArrayList < String > accepts = new ArrayList < String > ( ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; int numTrain = getNumInstances ( ) , numClasses = NUM_ ; return runBasicTest ( nominalPredictor , numericPredictor , stringPredictor , datePredictor , relationalPredictor , multiInstance , classType , missingLevel , predictorMissing , classMissing , numTrain , numClasses , accepts ) ; }
public Set < BrdItem > pick_items ( PlaPoint p_location , int p_layer , ItemSelectionFilter p_filter ) { Set < BrdItem > result = new TreeSet < BrdItem > ( ) ; ShapeTileBox point_shape = p_location . to_box ( ) ; Collection < AwtreeObject > overlaps = overlapping_objects ( point_shape , p_layer ) ; for ( AwtreeObject curr_object : overlaps ) { if ( ! ( curr_object instanceof BrdItem ) ) continue ; BrdItem curr_item = ( BrdItem ) curr_object ; if ( ! curr_item . is_selected_by_filter ( p_filter ) ) continue ; result . add ( curr_item ) ; } return result ; }
public boolean isCollinearWith ( Vector other ) { if ( x == NUM_ && y == NUM_ && z == NUM_ ) { return BOOL_ ; } final double otherX = other . x ; final double otherY = other . y ; final double otherZ = other . z ; if ( otherX == NUM_ && otherY == NUM_ && otherZ == NUM_ ) { return BOOL_ ; } if ( ( x == NUM_ ) != ( otherX == NUM_ ) ) return BOOL_ ; if ( ( y == NUM_ ) != ( otherY == NUM_ ) ) return BOOL_ ; if ( ( z == NUM_ ) != ( otherZ == NUM_ ) ) return BOOL_ ; final double quotientX = otherX / x ; if ( ! Double . isNaN ( quotientX ) ) { return other . equals ( multiply ( quotientX ) ) ; } final double quotientY = otherY / y ; if ( ! Double . isNaN ( quotientY ) ) { return other . equals ( multiply ( quotientY ) ) ; } final double quotientZ = otherZ / z ; if ( ! Double . isNaN ( quotientZ ) ) { return other . equals ( multiply ( quotientZ ) ) ; } throw new RuntimeException ( STR_ ) ; }
public void receive ( float [ ] currentFFTBins ) { if ( Float . isInfinite ( currentFFTBins [ NUM_ ] ) || Float . isNaN ( currentFFTBins [ NUM_ ] ) ) { currentFFTBins = new float [ currentFFTBins . length ] ; } if ( mDisplayFFTBins == null || mDisplayFFTBins . length != currentFFTBins . length ) { mDisplayFFTBins = currentFFTBins ; } float [ ] smoothedBins = mSmoothingFilter . filter ( currentFFTBins ) ; if ( mAveraging > NUM_ ) { float gain = NUM_ / ( float ) mAveraging ; for ( int x = NUM_ ; x < mDisplayFFTBins . length ; x ++ ) { mDisplayFFTBins [ x ] += ( smoothedBins [ x ] - mDisplayFFTBins [ x ] ) . gain ; } } else { mDisplayFFTBins = smoothedBins ; } repaint ( ) ; }
@ Override public void executionUnitImported ( final ExecutionUnit process , final Element element ) { NodeList children = element . getChildNodes ( ) ; children = element . getChildNodes ( ) ; for ( int i = NUM_ ; i < children . getLength ( ) ; i ++ ) { Node child = children . item ( i ) ; if ( child instanceof Element ) { Element backgroundElement = ( Element ) child ; if ( XML_TAG_BACKGROUND . equals ( backgroundElement . getTagName ( ) ) ) { String xStr = backgroundElement . getAttribute ( XML_ATTRIBUTE_X_POSITION ) ; String yStr = backgroundElement . getAttribute ( XML_ATTRIBUTE_Y_POSITION ) ; String wStr = backgroundElement . getAttribute ( XML_ATTRIBUTE_WIDTH ) ; String hStr = backgroundElement . getAttribute ( XML_ATTRIBUTE_HEIGHT ) ; String imgLocStr = backgroundElement . getAttribute ( XML_ATTRIBUTE_LOCATION ) ; try { int xLoc = Integer . parseInt ( xStr ) ; int yLoc = Integer . parseInt ( yStr ) ; int wLoc = Integer . parseInt ( wStr ) ; int hLoc = Integer . parseInt ( hStr ) ; ProcessBackgroundImage bgImg = new ProcessBackgroundImage ( xLoc , yLoc , wLoc , hLoc , imgLocStr , process ) ; setBackgroundImage ( bgImg ) ; } catch ( NullPointerException | IllegalArgumentException e ) { } } } } }
private void sendMailToQueue ( String to , String subject , String content , boolean isMultipart , boolean isHtml ) { EmailParams emailParams = new EmailParams ( to , subject , content , isMultipart , isHtml ) ; rabbitTemplate . convertAndSend ( RabbitmqConfiguration . QUEUE_SEND_EMAIL , emailParams ) ; }
private Set < ObjectInstance > filterListOfObjectInstances ( Set < ObjectInstance > list , QueryExp query ) { if ( query == null ) { return list ; } else { Set < ObjectInstance > result = new HashSet < ObjectInstance > ( ) ; for ( ObjectInstance oi : list ) { boolean res = BOOL_ ; MBeanServer oldServer = QueryEval . getMBeanServer ( ) ; query . setMBeanServer ( server ) ; try { res = query . apply ( oi . getObjectName ( ) ) ; } catch ( Exception e ) { res = BOOL_ ; } finally { query . setMBeanServer ( oldServer ) ; } if ( res ) { result . add ( oi ) ; } } return result ; } }
private void translateMatrixAfterRotate ( int axis , float trans , float prevImageSize , float imageSize , int prevViewSize , int viewSize , int drawableSize ) { if ( imageSize < viewSize ) { m [ axis ] = ( viewSize - ( drawableSize . m [ Matrix . MSCALE_X ] ) ) . NUM_ ; } else if ( trans > NUM_ ) { m [ axis ] = - ( ( imageSize - viewSize ) . NUM_ ) ; } else { float percentage = ( Math . abs ( trans ) + ( NUM_ . prevViewSize ) ) / prevImageSize ; m [ axis ] = - ( ( percentage . imageSize ) - ( viewSize . NUM_ ) ) ; } }
@ Path ( STR_ ) @ Timed @ ExceptionMetered @ GET public AutomationSecretResponse readSecretById ( @ Auth AutomationClient automationClient , @ PathParam ( STR_ ) LongParam secretId ) { Optional < Secret > secret = secretController . getSecretById ( secretId . get ( ) ) ; if ( ! secret . isPresent ( ) ) { throw new NotFoundException ( STR_ ) ; } ImmutableList < Group > groups = ImmutableList . copyOf ( aclDAO . getGroupsFor ( secret . get ( ) ) ) ; return AutomationSecretResponse . fromSecret ( secret . get ( ) , groups ) ; }
protected void addActionExceptionWarning ( Exception e ) { String msg = e . getMessage ( ) ; if ( msg != null ) { warnings . add ( msg ) ; } }
private void generateFieldInfos ( IType type , IBinaryType typeInfo , HashMap newElements , ArrayList childrenHandles ) { IBinaryField [ ] fields = typeInfo . getFields ( ) ; if ( fields == null ) { return ; } JavaModelManager manager = ( ( JavaElement ) type ) . manager ; for ( int i = NUM_ , fieldCount = fields . length ; i < fieldCount ; i ++ ) { IBinaryField fieldInfo = fields [ i ] ; BinaryField field = new BinaryField ( ( JavaElement ) type , manager , manager . intern ( new String ( fieldInfo . getName ( ) ) ) ) ; newElements . put ( field , fieldInfo ) ; childrenHandles . add ( field ) ; generateAnnotationsInfos ( field , fieldInfo . getAnnotations ( ) , fieldInfo . getTagBits ( ) , newElements ) ; } }
public void testFormattingYear ( ) { FormatTester test = new FormatTester ( ) ; Calendar cal = new GregorianCalendar ( NUM_ , Calendar . JUNE , NUM_ , NUM_ , NUM_ , NUM_ ) ; test . test ( STR_ , cal , STR_ , DateFormat . YEAR_FIELD ) ; test . test ( STR_ , cal , STR_ , DateFormat . YEAR_FIELD ) ; test . test ( STR_ , new GregorianCalendar ( NUM_ , Calendar . JUNE , NUM_ ) , STR_ , DateFormat . YEAR_FIELD ) ; test . test ( STR_ , new GregorianCalendar ( NUM_ , Calendar . JUNE , NUM_ ) , STR_ , DateFormat . YEAR_FIELD ) ; test . test ( STR_ , new GregorianCalendar ( NUM_ , Calendar . JUNE , NUM_ ) , STR_ , DateFormat . YEAR_FIELD ) ; test . test ( STR_ , cal , STR_ , DateFormat . YEAR_FIELD ) ; test . test ( STR_ , cal , STR_ , DateFormat . YEAR_FIELD ) ; test . test ( STR_ , cal , STR_ , DateFormat . YEAR_FIELD ) ; assertFalse ( test . testsFailed ) ; }
public List < String > generateModel ( String schema , String table , String packageName , boolean annotateSchema , boolean trimStrings ) { try { List < String > models = New . arrayList ( ) ; List < TableInspector > tables = getTables ( schema , table ) ; for ( TableInspector t : tables ) { t . read ( metaData ) ; String model = t . generateModel ( packageName , annotateSchema , trimStrings ) ; models . add ( model ) ; } return models ; } catch ( SQLException s ) { throw new RuntimeException ( s ) ; } }
public static Ed25519EncodedFieldElement toEncodedFieldElement ( final BigInteger b ) { return new Ed25519EncodedFieldElement ( toByteArray ( b ) ) ; }
private void mergeCollapse ( ) { while ( stackSize > NUM_ ) { int n = stackSize - NUM_ ; if ( n > NUM_ && runLen [ n - NUM_ ] <= runLen [ n ] + runLen [ n + NUM_ ] ) { if ( runLen [ n - NUM_ ] < runLen [ n + NUM_ ] ) n -- ; mergeAt ( n ) ; } else if ( runLen [ n ] <= runLen [ n + NUM_ ] ) { mergeAt ( n ) ; } else { break ; } } }
protected ArrayList < KeyNamePair > loadRMAData ( int C_BPartner_ID ) { ArrayList < KeyNamePair > list = new ArrayList < KeyNamePair > ( ) ; String sqlStmt = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; PreparedStatement pstmt = null ; try { pstmt = DB . prepareStatement ( sqlStmt , null ) ; pstmt . setInt ( NUM_ , C_BPartner_ID ) ; ResultSet rs = pstmt . executeQuery ( ) ; while ( rs . next ( ) ) { list . add ( new KeyNamePair ( rs . getInt ( NUM_ ) , rs . getString ( NUM_ ) ) ) ; } rs . close ( ) ; } catch ( SQLException e ) { log . log ( Level . SEVERE , sqlStmt . toString ( ) , e ) ; } finally { if ( pstmt != null ) { try { pstmt . close ( ) ; } catch ( Exception ex ) { log . severe ( STR_ ) ; } } } return list ; }
private void checkSendTrackToGoogle ( ) { if ( ! sendToGoogle ( activityMyTracks . getString ( R . string . export_google_maps ) ) || ! sendToGoogle ( activityMyTracks . getString ( R . string . export_google_fusion_tables ) ) || ! sendToGoogle ( activityMyTracks . getString ( R . string . export_google_spreadsheets ) ) ) { return ; } assertTrue ( GoogleUtils . deleteMaps ( activityMyTracks . getApplicationContext ( ) , GoogleUtils . ACCOUNT_1 , EndToEndTestUtils . trackName ) ) ; assertTrue ( GoogleUtils . deleteFusionTables ( activityMyTracks . getApplicationContext ( ) , GoogleUtils . ACCOUNT_1 , EndToEndTestUtils . trackName ) ) ; assertTrue ( GoogleUtils . deleteSpreadsheetsRow ( activityMyTracks . getApplicationContext ( ) , GoogleUtils . ACCOUNT_1 , EndToEndTestUtils . trackName ) ) ; }
private void checkBoundedTypeParameter ( Method method ) { TypeVariable < Method > typeParameter = getTypeParameter ( method ) ; assertEquals ( STR_ , typeParameter . getName ( ) ) ; assertEquals ( method , typeParameter . getGenericDeclaration ( ) ) ; Type [ ] bounds = typeParameter . getBounds ( ) ; assertLenghtOne ( bounds ) ; Type bound = bounds [ NUM_ ] ; assertEquals ( BoundedWildcardsGenericMethods . class , bound ) ; }
private byte [ ] entityToBytes ( HttpEntity entity ) throws IOException , ServerError { PoolingByteArrayOutputStream bytes = new PoolingByteArrayOutputStream ( mPool , ( int ) entity . getContentLength ( ) ) ; byte [ ] buffer = null ; try { InputStream in = entity . getContent ( ) ; if ( in == null ) { throw new ServerError ( ) ; } buffer = mPool . getBuf ( NUM_ ) ; int count ; while ( ( count = in . read ( buffer ) ) != - NUM_ ) { bytes . write ( buffer , NUM_ , count ) ; } return bytes . toByteArray ( ) ; } finally { try { entity . consumeContent ( ) ; } catch ( IOException e ) { VolleyLog . v ( STR_ ) ; } mPool . returnBuf ( buffer ) ; bytes . close ( ) ; } }
public void onDependencyChanged ( Preference dependency , boolean disableDependent ) { if ( mDependencyMet == disableDependent ) { mDependencyMet = ! disableDependent ; notifyDependencyChange ( shouldDisableDependents ( ) ) ; notifyChanged ( ) ; } }
@ Override public Double analyse ( double [ ] frame ) { if ( frame . length != getFrameLengthSamples ( ) ) throw new IllegalArgumentException ( STR_ + getFrameLengthSamples ( ) + STR_ + frame . length ) ; double totalEnergy = NUM_ ; for ( int i = NUM_ ; i < frame . length ; i ++ ) { totalEnergy += frame [ i ] . frame [ i ] ; } rememberFrameEnergy ( totalEnergy ) ; return new Double ( totalEnergy ) ; }
public static Element firstChildElement ( Element element ) { if ( element == null ) return null ; Node node = element . getFirstChild ( ) ; if ( node != null ) { do { if ( node . getNodeType ( ) == Node . ELEMENT_NODE ) { Element childElement = ( Element ) node ; return childElement ; } } while ( ( node = node . getNextSibling ( ) ) != null ) ; } return null ; }
private static void partialMatch ( DimensionalNode node , boolean [ ] relevant , double [ ] keys , ArrayList < IMultiPoint > results ) { IMultiPoint pt = node . point ; boolean match = BOOL_ ; for ( int i = NUM_ ; i < relevant . length ; i ++ ) { if ( ! relevant [ i ] ) continue ; if ( ! FloatingPoint . same ( pt . getCoordinate ( i + NUM_ ) , keys [ i ] ) ) { match = BOOL_ ; break ; } } if ( match ) { results . add ( pt ) ; } int d = node . dimension ; if ( relevant [ d - NUM_ ] ) { if ( FloatingPoint . lesserEquals ( keys [ d - NUM_ ] , pt . getCoordinate ( d ) ) ) { DimensionalNode below = node . getBelow ( ) ; if ( below != null ) { partialMatch ( below , relevant , keys , results ) ; } } if ( FloatingPoint . greaterEquals ( keys [ d - NUM_ ] , pt . getCoordinate ( d ) ) ) { DimensionalNode above = node . getAbove ( ) ; if ( above != null ) { partialMatch ( above , relevant , keys , results ) ; } } } else { DimensionalNode below = node . getBelow ( ) ; if ( below != null ) { partialMatch ( below , relevant , keys , results ) ; } DimensionalNode above = node . getAbove ( ) ; if ( above != null ) { partialMatch ( above , relevant , keys , results ) ; } } }
public int decryptBlock ( byte [ ] in , int inOff , byte [ ] out , int outOff ) throws DataLengthException , IllegalStateException { if ( ( inOff + blockSize ) > in . length ) { throw new DataLengthException ( STR_ ) ; } if ( ( outOff + blockSize ) > out . length ) { throw new DataLengthException ( STR_ ) ; } cipher . processBlock ( cfbV , NUM_ , cfbOutV , NUM_ ) ; System . arraycopy ( cfbV , blockSize , cfbV , NUM_ , cfbV . length - blockSize ) ; System . arraycopy ( in , inOff , cfbV , cfbV . length - blockSize , blockSize ) ; for ( int i = NUM_ ; i < blockSize ; i ++ ) { out [ outOff + i ] = ( byte ) ( cfbOutV [ i ] ^ in [ inOff + i ] ) ; } return blockSize ; }
public static String encodeForRedirect ( final String str ) { String classMethod = STR_ ; byte [ ] input ; try { input = str . getBytes ( STR_ ) ; } catch ( UnsupportedEncodingException uee ) { debug . error ( classMethod + STR_ , uee ) ; return null ; } Deflater deflater = new Deflater ( Deflater . DEFAULT_COMPRESSION , BOOL_ ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream ( out , deflater ) ; try { deflaterOutputStream . write ( input ) ; } catch ( IOException e ) { debug . error ( classMethod + STR_ , e ) ; return null ; } finally { IOUtils . closeIfNotNull ( deflaterOutputStream ) ; } String encoded = URLEncDec . encode ( Base64 . encode ( out . toByteArray ( ) ) ) ; if ( debug . messageEnabled ( ) ) { debug . message ( classMethod + STR_ + encoded . length ( ) ) ; debug . message ( classMethod + STR_ + encoded + STR_ ) ; } return encoded ; }
private void saveTouchStart ( MotionEvent event ) { mSavedMatrix . set ( mMatrix ) ; mTouchStartPoint . set ( event . getX ( ) , event . getY ( ) ) ; mClosestDataSetToTouch = mChart . getDataSetByTouchPoint ( event . getX ( ) , event . getY ( ) ) ; }
public static boolean isNestedMapping ( String regex ) { return regex . startsWith ( NESTED_MAPPING_STARTS_SYMBOL ) && regex . endsWith ( NESTED_MAPPING_ENDS_SYMBOL ) ; }
@ Override public Writer append ( CharSequence value ) { builder . append ( value ) ; return this ; }
public static boolean nullEquals ( String s1 , String s2 ) { return ( s1 == null ? s2 == null : s1 . equals ( s2 ) ) ; }
public String toString ( ) { return super . toString ( ) + STR_ + String . valueOf ( date ) ; }
private boolean hasImages ( IAction actionToCheck ) { return actionToCheck . getImageDescriptor ( ) != null || actionToCheck . getHoverImageDescriptor ( ) != null || actionToCheck . getDisabledImageDescriptor ( ) != null ; }
public double calcAngleBetweenLines ( Entry start1 , Entry end1 , Entry start2 , Entry end2 ) { double angle1 = calcAngleWithRatios ( start1 , end1 ) ; double angle2 = calcAngleWithRatios ( start2 , end2 ) ; return Math . abs ( angle1 - angle2 ) ; }
public ByteVector putByteArray ( final byte [ ] b , final int off , final int len ) { if ( length + len > data . length ) { enlarge ( len ) ; } if ( b != null ) { System . arraycopy ( b , off , data , length , len ) ; } length += len ; return this ; }
public void completeExecutorTask ( ) { ExecutorQueueItem item = null ; synchronized ( _executorLock ) { _executorTaskCount -- ; assert ( _executorTaskCount >= NUM_ ) ; if ( _executorQueueHead != null ) { item = _executorQueueHead ; _executorQueueHead = item . _next ; if ( _executorQueueHead == null ) _executorQueueTail = null ; } } if ( item != null ) { Runnable task = item . getRunnable ( ) ; ClassLoader loader = item . getLoader ( ) ; boolean isPriority = BOOL_ ; boolean isQueue = BOOL_ ; boolean isWake = BOOL_ ; scheduleImpl ( task , loader , MAX_EXPIRE , isPriority , isQueue , isWake ) ; } }
public static void forceMkdir ( File directory ) throws IOException { if ( directory . exists ( ) ) { if ( ! directory . isDirectory ( ) ) { String message = STR_ + directory + STR_ + STR_ ; throw new IOException ( message ) ; } } else { if ( ! directory . mkdirs ( ) ) { if ( ! directory . isDirectory ( ) ) { String message = STR_ + directory ; throw new IOException ( message ) ; } } } }
private < T > int countClearedRefs ( List < WeakReference < T > > refs ) { final Iterator < WeakReference < T > > itr = refs . iterator ( ) ; int n = NUM_ ; while ( itr . hasNext ( ) ) { final WeakReference < T > ref = itr . next ( ) ; if ( ref . get ( ) == null ) n ++ ; } return n ; }
protected void readImage ( ) { ix = readShort ( ) ; iy = readShort ( ) ; iw = readShort ( ) ; ih = readShort ( ) ; int packed = read ( ) ; lctFlag = ( packed & x80 ) != NUM_ ; interlace = ( packed & x40 ) != NUM_ ; lctSize = NUM_ << ( packed & NUM_ ) ; if ( lctFlag ) { lct = readColorTable ( lctSize ) ; act = lct ; } else { act = gct ; if ( bgIndex == transIndex ) bgColor = NUM_ ; } int save = NUM_ ; if ( transparency ) { save = act [ transIndex ] ; act [ transIndex ] = NUM_ ; } if ( act == null ) { status = STATUS_FORMAT_ERROR ; } if ( err ( ) ) return ; decodeImageData ( ) ; skip ( ) ; if ( err ( ) ) return ; frameCount ++ ; image = new BufferedImage ( width , height , BufferedImage . TYPE_INT_ARGB_PRE ) ; setPixels ( ) ; frames . add ( new GifFrame ( image , delay ) ) ; if ( transparency ) { act [ transIndex ] = save ; } resetFrame ( ) ; }
protected void addProjectedField ( String s ) { try { Field f = inClazz . getDeclaredField ( s ) ; TypeInfo t = new TypeInfo ( f . getName ( ) , ClassUtils . primitiveToWrapper ( f . getType ( ) ) ) ; t . getter = PojoUtils . createGetter ( inClazz , t . name , t . type ) ; t . setter = PojoUtils . createSetter ( projectedClazz , t . name , t . type ) ; projectedFields . add ( t ) ; } catch ( NoSuchFieldException e ) { throw new RuntimeException ( STR_ + s + STR_ + inClazz , e ) ; } }
protected Object evaluateLeftGreaterRight ( List elements , String lvalue , String rvalue ) { List array ; if ( elements instanceof java . util . Vector ) { array = new java . util . Vector ( ) ; } else { array = new ArrayList ( ) ; } for ( Iterator e = elements . iterator ( ) ; e . hasNext ( ) ; ) { Object o = e . next ( ) ; if ( o instanceof StructuredContent ) { if ( ( o = evaluateLeftGreaterRight ( ( StructuredContent ) o , lvalue , rvalue ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == NUM_ ) { return ( StructuredContent ) array . get ( NUM_ ) ; } return array ; }
public Optional < Double > avg ( ) { if ( isEmpty ( ) ) return Optional . empty ( ) ; return Optional . of ( sum ( ) / getEventCount ( ) ) ; }
public static boolean isSU ( String shell ) { int pos = shell . indexOf ( STR_ ) ; if ( pos >= NUM_ ) { shell = shell . substring ( NUM_ , pos ) ; } pos = shell . lastIndexOf ( STR_ ) ; if ( pos >= NUM_ ) { shell = shell . substring ( pos + NUM_ ) ; } return shell . equals ( STR_ ) ; }
private boolean isValid ( int type , String value ) { if ( value == null ) { return BOOL_ ; } if ( ALLOWED_STRINGS [ type ] != null ) { return verifyStringGroup ( value , ALLOWED_STRINGS [ type ] ) ; } switch ( type ) { case TYPE_NUMBER : return verify ( value , DIGITS , null ) ; case TYPE_PIXELS_OR_PERCENTAGE : if ( value . endsWith ( STR_ ) ) { value = value . substring ( NUM_ , value . length ( ) - NUM_ ) ; } else if ( value . endsWith ( STR_ ) ) { value = value . substring ( NUM_ , value . length ( ) - NUM_ ) ; } return verify ( value , DIGITS , null ) ; case TYPE_CHAR : return verify ( value , DIGITS | ABC , null , NUM_ , NUM_ ) ; case TYPE_COLOR : if ( value . length ( ) == NUM_ ) { return BOOL_ ; } if ( value . charAt ( NUM_ ) != STR_ ) { return verifyStringGroup ( value , COLOR_STRINGS ) ; } else { return verify ( value . substring ( NUM_ ) , HEX , null , NUM_ , NUM_ ) ; } default : return BOOL_ ; } }
protected synchronized Class loadClass ( String name , boolean resolve ) throws ClassNotFoundException { Class c = findLoadedClass ( name ) ; if ( c == null ) c = findClass ( name ) ; if ( c == null ) throw new ClassNotFoundException ( name ) ; if ( resolve ) resolveClass ( c ) ; return c ; }
private int parseStreams ( String json , Set < StreamInfo > streamInfos ) { try { JSONParser parser = new JSONParser ( ) ; JSONArray streamsArray ; try { JSONObject root = ( JSONObject ) parser . parse ( json ) ; streamsArray = ( JSONArray ) root . get ( STR_ ) ; } catch ( ClassCastException ex ) { LOGGER . warning ( STR_ ) ; streamsRequestError ( streamInfos ) ; return - NUM_ ; } if ( streamsArray == null ) { LOGGER . warning ( STR_ ) ; streamsRequestError ( streamInfos ) ; return - NUM_ ; } for ( Object obj : streamsArray ) { if ( obj instanceof JSONObject ) { StreamInfo parsedInfo = parseStream ( ( JSONObject ) obj , streamInfos == null ) ; if ( parsedInfo == null ) { LOGGER . warning ( STR_ + ( JSONObject ) obj ) ; } if ( streamInfos != null ) { streamInfos . remove ( parsedInfo ) ; } } else { LOGGER . warning ( STR_ + obj ) ; } } if ( streamInfos != null ) { for ( StreamInfo info : streamInfos ) { info . setOffline ( ) ; } } return streamsArray . size ( ) ; } catch ( ParseException ex ) { LOGGER . warning ( STR_ + ex . getLocalizedMessage ( ) ) ; streamsRequestError ( streamInfos ) ; return - NUM_ ; } }
public StrTokenizer reset ( String input ) { reset ( ) ; if ( input != null ) { this . chars = input . toCharArray ( ) ; } else { this . chars = null ; } return this ; }
public void runTest ( ) throws Throwable { Document doc ; EntityReference entRef ; CharacterData entText ; doc = ( Document ) load ( STR_ , BOOL_ ) ; entRef = doc . createEntityReference ( STR_ ) ; assertNotNull ( STR_ , entRef ) ; entText = ( CharacterData ) entRef . getFirstChild ( ) ; assertNotNull ( STR_ , entText ) ; { boolean success = BOOL_ ; try { entText . setNodeValue ( STR_ ) ; } catch ( DOMException ex ) { success = ( ex . code == DOMException . NO_MODIFICATION_ALLOWED_ERR ) ; } assertTrue ( STR_ , success ) ; } }
public void removeListener ( final IVisualCoverageListener listener ) { listeners . remove ( listener ) ; }
@ ObjectiveCName ( STR_ ) public boolean isLargeDialogMessage ( ContentType contentType ) { switch ( contentType ) { case SERVICE : case SERVICE_AVATAR : case SERVICE_AVATAR_REMOVED : case SERVICE_CREATED : case SERVICE_TITLE : case SERVICE_LEAVE : case SERVICE_REGISTERED : case SERVICE_KICK : case SERVICE_ADD : case SERVICE_JOINED : case SERVICE_CALL_ENDED : case SERVICE_CALL_MISSED : case SERVICE_ABOUT : case SERVICE_TOPIC : return BOOL_ ; default : return BOOL_ ; } }
public static boolean isLoggingBehaviorEnabled ( LoggingBehavior behavior ) { synchronized ( loggingBehaviors ) { return FacebookSdk . isDebugEnabled ( ) && loggingBehaviors . contains ( behavior ) ; } }
private void onAttacked ( final Entity attacker ) { attackers . remove ( attacker ) ; attackers . add ( attacker ) ; }
private void handleDisallow ( ParseState state , RobotToken token ) { if ( state . isSkipAgents ( ) ) { return ; } state . setFinishedAgentFields ( BOOL_ ) ; if ( ! state . isAddingRules ( ) ) { return ; } String path = token . getData ( ) ; try { path = URLDecoder . decode ( path , STR_ ) ; if ( path . length ( ) == NUM_ ) { state . clearRules ( ) ; } else { state . addRule ( path , BOOL_ ) ; } } catch ( Exception e ) { reportWarning ( STR_ + path , state . getUrl ( ) ) ; } }
public void hideColumn ( Object columnName ) { if ( columnName == null ) { return ; } for ( int i = NUM_ ; i < columnModel . getColumnCount ( ) ; i ++ ) { TableColumn column = columnModel . getColumn ( i ) ; if ( columnName . equals ( column . getHeaderValue ( ) ) ) { hideColumn ( column ) ; break ; } } }
public static < T > Set < T > toSet ( T obj1 , T obj2 , T obj3 , T obj4 , T obj5 , T obj6 ) { Set < T > theSet = new LinkedHashSet < T > ( ) ; theSet . add ( obj1 ) ; theSet . add ( obj2 ) ; theSet . add ( obj3 ) ; theSet . add ( obj4 ) ; theSet . add ( obj5 ) ; theSet . add ( obj6 ) ; return theSet ; }
private boolean isASCIIDigit ( char c ) { return ( c >= STR_ && c <= STR_ ) ; }
public static String separatorsToWindows ( String path ) { if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == - NUM_ ) { return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; }
public void accumulateAll ( List < TaggedLogAPIEntity > entities ) throws Exception { for ( TaggedLogAPIEntity entity : entities ) { accumulate ( entity ) ; } }
protected void printIdentifier ( String identifier , StringBuilder ddl ) { ddl . append ( getDelimitedIdentifier ( identifier ) ) ; }
public static int darker ( int c ) { return rgba ( Math . max ( NUM_ , ( int ) ( scale . red ( c ) ) ) , Math . max ( NUM_ , ( int ) ( scale . green ( c ) ) ) , Math . max ( NUM_ , ( int ) ( scale . blue ( c ) ) ) , alpha ( c ) ) ; }
private String toString ( final int size ) { if ( size < NUM_ ) { return String . format ( STR_ , size ) ; } else if ( size < NUM_ . NUM_ ) { return String . format ( Locale . ENGLISH , STR_ , NUM_ . size / NUM_ ) ; } else { return String . format ( Locale . ENGLISH , STR_ , NUM_ . size / NUM_ / NUM_ ) ; } }
@ KnownFailure ( STR_ ) public void test_getColumnsArbitrary ( ) throws SQLException { ResultSet setAllNull = null ; ResultSet setMixed = null ; ResultSet allArbitrary = null ; String [ ] tablesName = { DatabaseCreator . TEST_TABLE1 , DatabaseCreator . TEST_TABLE3 } ; Arrays . sort ( tablesName ) ; int setSize = NUM_ ; try { allArbitrary = meta . getColumns ( STR_ , STR_ , STR_ , STR_ ) ; assertNotNull ( allArbitrary ) ; checkColumnsShape ( allArbitrary ) ; setSize = crossCheckGetColumnsAndResultSetMetaData ( allArbitrary , BOOL_ ) ; assertEquals ( NUM_ , setSize ) ; setMixed = meta . getColumns ( null , null , STR_ , STR_ ) ; assertNotNull ( setMixed ) ; checkColumnsShape ( setMixed ) ; setSize = crossCheckGetColumnsAndResultSetMetaData ( setMixed , BOOL_ ) ; assertEquals ( NUM_ , setSize ) ; } catch ( SQLException e ) { fail ( STR_ + e . getMessage ( ) ) ; } conn . close ( ) ; try { meta . getColumns ( null , null , DatabaseCreator . TEST_TABLE1 , STR_ ) ; fail ( STR_ ) ; } catch ( SQLException e ) { } }
static public SdfMacro decodeInstruction ( SdfBuffer buff ) { SdfMacro m ; if ( ( m = ChannelStart . match ( buff ) ) != null ) { return m ; } else if ( ( m = SdlVersion . match ( buff ) ) != null ) { return m ; } else if ( ( m = SkemeStart . match ( buff ) ) != null ) { return m ; } else if ( ( m = GenerateTrigger . match ( buff ) ) != null ) { return m ; } else if ( ( m = EndSound . match ( buff ) ) != null ) { return m ; } else if ( ( m = DelaySound . match ( buff ) ) != null ) { return m ; } else if ( ( m = SkipOnTrigger . match ( buff ) ) != null ) { return m ; } else if ( ( m = InitiateSound . match ( buff ) ) != null ) { return m ; } else if ( ( m = MaskCompare . match ( buff ) ) != null ) { return m ; } else if ( ( m = LoadModifier . match ( buff ) ) != null ) { return m ; } else if ( ( m = BranchTo . match ( buff ) ) != null ) { return m ; } else if ( ( m = Play . match ( buff ) ) != null ) { return m ; } else if ( ( m = FourByteMacro . match ( buff ) ) != null ) { return m ; } else if ( ( m = TwoByteMacro . match ( buff ) ) != null ) { return m ; } log . warn ( STR_ ) ; return null ; }
public SIPDate ( long timeMillis ) { javaCal = new GregorianCalendar ( TimeZone . getTimeZone ( STR_ ) , Locale . getDefault ( ) ) ; java . util . Date date = new java . util . Date ( timeMillis ) ; javaCal . setTime ( date ) ; wkday = javaCal . get ( Calendar . DAY_OF_WEEK ) ; switch ( wkday ) { case Calendar . MONDAY : sipWkDay = MON ; break ; case Calendar . TUESDAY : sipWkDay = TUE ; break ; case Calendar . WEDNESDAY : sipWkDay = WED ; break ; case Calendar . THURSDAY : sipWkDay = THU ; break ; case Calendar . FRIDAY : sipWkDay = FRI ; break ; case Calendar . SATURDAY : sipWkDay = SAT ; break ; case Calendar . SUNDAY : sipWkDay = SUN ; break ; default : InternalErrorHandler . handleException ( STR_ + wkday ) ; } day = javaCal . get ( Calendar . DAY_OF_MONTH ) ; month = javaCal . get ( Calendar . MONTH ) ; switch ( month ) { case Calendar . JANUARY : sipMonth = JAN ; break ; case Calendar . FEBRUARY : sipMonth = FEB ; break ; case Calendar . MARCH : sipMonth = MAR ; break ; case Calendar . APRIL : sipMonth = APR ; break ; case Calendar . MAY : sipMonth = MAY ; break ; case Calendar . JUNE : sipMonth = JUN ; break ; case Calendar . JULY : sipMonth = JUL ; break ; case Calendar . AUGUST : sipMonth = AUG ; break ; case Calendar . SEPTEMBER : sipMonth = SEP ; break ; case Calendar . OCTOBER : sipMonth = OCT ; break ; case Calendar . NOVEMBER : sipMonth = NOV ; break ; case Calendar . DECEMBER : sipMonth = DEC ; break ; default : InternalErrorHandler . handleException ( STR_ + month ) ; } year = javaCal . get ( Calendar . YEAR ) ; hour = javaCal . get ( Calendar . HOUR_OF_DAY ) ; minute = javaCal . get ( Calendar . MINUTE ) ; second = javaCal . get ( Calendar . SECOND ) ; }
public static TypeMirror upperBound ( TypeMirror type ) { do { if ( type instanceof TypeVariable ) { TypeVariable tvar = ( TypeVariable ) type ; if ( tvar . getUpperBound ( ) != null ) { type = tvar . getUpperBound ( ) ; } else { break ; } } else if ( type instanceof WildcardType ) { WildcardType wc = ( WildcardType ) type ; if ( wc . getExtendsBound ( ) != null ) { type = wc . getExtendsBound ( ) ; } else { break ; } } else { break ; } } while ( BOOL_ ) ; return type ; }
public synchronized Object remove ( Object key ) { removeBlanks ( ) ; WeakKeyReference keyRef = new WeakKeyReference ( key ) ; WeakReference ref = ( WeakReference ) table . remove ( keyRef ) ; if ( ref == null ) return null ; return ref . get ( ) ; }
public boolean removeElement ( Node s ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; if ( null == m_map ) return BOOL_ ; for ( int i = NUM_ ; i < m_firstFree ; i ++ ) { Node node = m_map [ i ] ; if ( ( null != node ) && node . equals ( s ) ) { if ( i < m_firstFree - NUM_ ) System . arraycopy ( m_map , i + NUM_ , m_map , i , m_firstFree - i - NUM_ ) ; m_firstFree -- ; m_map [ m_firstFree ] = null ; return BOOL_ ; } } return BOOL_ ; }
@ Override public InetAddress addressLocal ( ) { Socket s = getSocket ( ) ; if ( s != null ) { return s . getLocalAddress ( ) ; } else { return null ; } }
public boolean startConnection ( ) { State state = _state . get ( ) ; if ( state . isActive ( ) ) { _connectionCount . incrementAndGet ( ) ; return BOOL_ ; } long now = CurrentTime . currentTime ( ) ; long lastFailTime = _lastFailTime ; long recoverTimeout = _dynamicRecoverTimeout . get ( ) ; if ( now < lastFailTime + recoverTimeout ) { return BOOL_ ; } int count ; do { count = _connectionCount . get ( ) ; if ( count > NUM_ ) { return BOOL_ ; } } while ( ! _connectionCount . compareAndSet ( count , count + NUM_ ) ) ; return BOOL_ ; }
public AbstractNaryOperator ( final Expr ... args ) { this ( Arrays . asList ( args ) ) ; }
static boolean isRegistered ( ObjectName objectName ) { return mbeanServer != null && mbeanServer . isRegistered ( objectName ) ; }
public SocketReader ( final Socket socket ) throws IOException { Preconditions . checkNotNull ( socket , STR_ ) ; m_InputStream = new BufferedInputStream ( socket . getInputStream ( ) ) ; }
private boolean moveToFinalScrollerPosition ( Scroller scroller ) { scroller . forceFinished ( BOOL_ ) ; if ( isHorizontalMode ( ) ) { int amountToScroll = scroller . getFinalX ( ) - scroller . getCurrX ( ) ; int futureScrollOffset = ( mCurrentScrollOffset + amountToScroll ) % mSelectorElementSize ; int overshootAdjustment = mInitialScrollOffset - futureScrollOffset ; if ( overshootAdjustment != NUM_ ) { if ( Math . abs ( overshootAdjustment ) > mSelectorElementSize / NUM_ ) { if ( overshootAdjustment > NUM_ ) { overshootAdjustment -= mSelectorElementSize ; } else { overshootAdjustment += mSelectorElementSize ; } } amountToScroll += overshootAdjustment ; scrollBy ( amountToScroll , NUM_ ) ; return BOOL_ ; } } else { int amountToScroll = scroller . getFinalY ( ) - scroller . getCurrY ( ) ; int futureScrollOffset = ( mCurrentScrollOffset + amountToScroll ) % mSelectorElementSize ; int overshootAdjustment = mInitialScrollOffset - futureScrollOffset ; if ( overshootAdjustment != NUM_ ) { if ( Math . abs ( overshootAdjustment ) > mSelectorElementSize / NUM_ ) { if ( overshootAdjustment > NUM_ ) { overshootAdjustment -= mSelectorElementSize ; } else { overshootAdjustment += mSelectorElementSize ; } } amountToScroll += overshootAdjustment ; scrollBy ( NUM_ , amountToScroll ) ; return BOOL_ ; } } return BOOL_ ; }
public void addLonLine ( double minLat , double maxLat , double lon ) { String name = STR_ + nextShape ; nextShape ++ ; b . append ( STR_ + name + STR_ ) ; double lat ; int steps = getStepCount ( minLat , lon , maxLat , lon ) ; for ( lat = minLat ; lat <= maxLat ; lat += ( maxLat - minLat ) / steps ) { b . append ( STR_ + lat + STR_ + lon + STR_ ) ; } b . append ( STR_ + maxLat + STR_ + lon + STR_ ) ; lat -= ( maxLat - minLat ) / NUM_ ; for ( ; lat >= minLat ; lat -= ( maxLat - minLat ) / steps ) { b . append ( STR_ + lat + STR_ + lon + STR_ ) ; } b . append ( STR_ ) ; b . append ( STR_ + name + STR_ ) ; }
@ Override public double calculate_K ( int [ ] x_index , double [ ] x_att , int [ ] y_index , double [ ] y_att ) { double result = NUM_ ; double tmp ; int xpos = x_index . length - NUM_ ; int ypos = y_index . length - NUM_ ; int zeros = dim ; while ( ( xpos >= NUM_ ) && ( ypos >= NUM_ ) ) { if ( x_index [ xpos ] == y_index [ ypos ] ) { tmp = x_att [ xpos ] - y_att [ ypos ] ; result += Math . exp ( - sigma . tmp . tmp ) ; xpos -- ; ypos -- ; } else if ( x_index [ xpos ] > y_index [ ypos ] ) { tmp = x_att [ xpos ] ; result += Math . exp ( - sigma . tmp . tmp ) ; xpos -- ; } else { tmp = y_att [ ypos ] ; result += Math . exp ( - sigma . tmp . tmp ) ; ypos -- ; } zeros -- ; } while ( xpos >= NUM_ ) { tmp = x_att [ xpos ] ; result += Math . exp ( - sigma . tmp . tmp ) ; xpos -- ; zeros -- ; } while ( ypos >= NUM_ ) { tmp = y_att [ ypos ] ; result += Math . exp ( - sigma . tmp . tmp ) ; ypos -- ; zeros -- ; } result += zeros ; return Math . pow ( result , degree ) ; }
SunCertPathBuilderResult ( CertPath certPath , TrustAnchor trustAnchor , PolicyNode policyTree , PublicKey subjectPublicKey , AdjacencyList adjList ) { super ( certPath , trustAnchor , policyTree , subjectPublicKey ) ; this . adjList = adjList ; }
public static void attach ( final JFrame parent , final IDebugger debugger , final CDebugEventNotifier notifier ) { try { notifier . start ( ) ; debugger . connect ( ) ; } catch ( final DebugExceptionWrapper exception ) { notifier . stop ( ) ; CUtilityFunctions . logException ( exception ) ; final String innerMessage = STR_ + STR_ ; final String innerDescription = CUtilityFunctions . createDescription ( STR_ , new String [ ] { STR_ } , new String [ ] { STR_ + STR_ } ) ; NaviErrorDialog . show ( parent , innerMessage , innerDescription , exception ) ; } }
public boolean checkAddrPattern ( final String theAddrPattern ) { return theAddrPattern . equals ( addrPattern ( ) ) ; }
@ MediumTest public void testStabilityInSpace ( ) { long t = System . currentTimeMillis ( ) ; VelocityTracker vt = VelocityTracker . obtain ( ) ; drag ( vt , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , t , NUM_ ) ; vt . computeCurrentVelocity ( NUM_ ) ; float firstX = vt . getXVelocity ( ) ; float firstY = vt . getYVelocity ( ) ; vt . clear ( ) ; drag ( vt , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , t , NUM_ ) ; vt . computeCurrentVelocity ( NUM_ ) ; float secondX = vt . getXVelocity ( ) ; float secondY = vt . getYVelocity ( ) ; assertEqualFuzzy ( firstX , secondX , NUM_ ) ; assertEqualFuzzy ( firstY , secondY , NUM_ ) ; vt . recycle ( ) ; }
private View fillFromTop ( int nextTop ) { if ( DEBUG ) Log . i ( TAG , STR_ + nextTop + M_FIRST_POSITION + mFirstPosition ) ; mFirstPosition = Math . min ( mFirstPosition , mSelectedPosition ) ; mFirstPosition = Math . min ( mFirstPosition , mItemCount - NUM_ ) ; if ( mFirstPosition < NUM_ ) { mFirstPosition = NUM_ ; } mFirstPosition -= mFirstPosition % mNumColumns ; return fillDown ( mFirstPosition , nextTop ) ; }
public static String SITInfo ( EnumMap < SIT , EnumMap < CIT , Boolean > > shp ) { StringBuilder result = new StringBuilder ( ) ; for ( SIT key : shp . keySet ( ) ) { result . append ( STR_ + key . toString ( ) + STR_ + CITInfo ( shp . get ( key ) ) + STR_ ) ; } return result . toString ( ) ; }
public static Map < String , Object > updateBinaryFile ( DispatchContext dctx , Map < String , ? extends Object > context ) { Map < String , Object > result = null ; try { result = updateBinaryFileMethod ( dctx , context ) ; } catch ( GenericServiceException e ) { return ServiceUtil . returnError ( e . getMessage ( ) ) ; } return result ; }
public List < byte [ ] > write ( List < InternalLog > logs ) throws IOException { final List < Put > puts = new ArrayList < Put > ( logs . size ( ) ) ; final List < byte [ ] > result = new ArrayList < byte [ ] > ( logs . size ( ) ) ; for ( InternalLog log : logs ) { final byte [ ] rowkey = RowkeyBuilder . buildRowkey ( log ) ; final Put p = new Put ( rowkey ) ; populateColumnValues ( p , log ) ; puts . add ( p ) ; final List < byte [ ] > indexRowkeys = log . getIndexRowkeys ( ) ; if ( indexRowkeys != null ) { writeIndexes ( rowkey , indexRowkeys , puts ) ; } result . add ( rowkey ) ; } tbl . put ( puts ) ; return result ; }
public int read ( long fileOffset , byte [ ] buffer , int offset , int length ) throws IOException { log . info ( STR_ + Long . toHexString ( fileOffset ) + STR_ + length + STR_ ) ; return _file . read ( fileOffset , buffer , offset , length ) ; }
public boolean validateCurrentStep ( int currentStep , int newStep ) { return BOOL_ ; }
@ NonNull protected static List < RaveError > mustBeTrue ( boolean input , @ NonNull ValidationContext validationContext ) { return input ? Collections . < RaveError > emptyList ( ) : createNewList ( new RaveError ( validationContext , RaveErrorStrings . MUST_BE_TRUE_ERROR ) ) ; }
private void signalNotFull ( ) { final ReentrantLock putLock = this . putLock ; putLock . lock ( ) ; try { notFull . signal ( ) ; } finally { putLock . unlock ( ) ; } }
@ LogMessageDoc ( level = STR_ , message = STR_ , explanation = STR_ + STR_ , recommendation = LogMessageDoc . REPORT_CONTROLLER_BUG ) public void queueHint ( String storeName , ByteArray key , Versioned < byte [ ] > value ) { try { HintKey hk = new HintKey ( storeName , key ) ; hintLock . lock ( ) ; try { boolean needed = ! hints . containsKey ( hk ) ; needed &= hints . doput ( hk , value ) ; if ( needed ) { hintQueue . add ( hk ) ; hintsAvailable . signal ( ) ; } } finally { hintLock . unlock ( ) ; } } catch ( SyncException e ) { logger . error ( STR_ + storeName , e ) ; } }
public static DBIDVar randomSample ( DBIDs ids , RandomFactory random ) { return randomSample ( ids , random . getSingleThreadedRandom ( ) ) ; }
public void testAddListener ( ) { SimpleListener listener1 = createMockSimpleListener ( NUM_ ) ; SimpleListener listener2 = createMockSimpleListener ( NUM_ ) ; assertEquals ( NUM_ , adaptor . getNumListeners ( ) ) ; adaptor . addListener ( listener1 ) ; assertEquals ( NUM_ , adaptor . getNumListeners ( ) ) ; adaptor . addListener ( listener2 ) ; assertEquals ( NUM_ , adaptor . getNumListeners ( ) ) ; adaptor . addListener ( listener1 ) ; assertEquals ( NUM_ , adaptor . getNumListeners ( ) ) ; List < SimpleListener > listeners = Lists . asList ( adaptor . getListeners ( ) ) ; assertEquals ( NUM_ , listeners . size ( ) ) ; assertTrue ( listeners . contains ( listener1 ) ) ; assertTrue ( listeners . contains ( listener2 ) ) ; EasyMock . verify ( listener1 , listener2 ) ; }
public void onResponse ( DiscoveryNode node ) { boolean found = pendingNodes . remove ( node ) ; assert found : STR_ + node + STR_ ; latch . countDown ( ) ; }
@ Override public synchronized boolean add ( E object ) { if ( elementCount == elementData . length ) { growByOne ( ) ; } elementData [ elementCount ++ ] = object ; modCount ++ ; return BOOL_ ; }
private static long copy ( InputStream from , OutputStream to ) throws IOException { byte [ ] buf = new byte [ Settings . BUFFER_SIZE ] ; long total = NUM_ ; while ( BOOL_ ) { int r = from . read ( buf ) ; if ( r == - NUM_ ) { break ; } to . write ( buf , NUM_ , r ) ; total += r ; } return total ; }
public ByteVector putByteArray ( final byte [ ] b , final int off , final int len ) { if ( length + len > data . length ) { enlarge ( len ) ; } if ( b != null ) { System . arraycopy ( b , off , data , length , len ) ; } length += len ; return this ; }
public void addValue ( String value ) { if ( _stringValues == null ) { setupStringValues ( ) ; } if ( ! _stringValues . contains ( value ) ) { _stringValues . add ( value ) ; } }
public void writeRawLittleEndian32 ( final int value ) throws IOException { if ( buffer . remaining ( ) < NUM_ ) { throw new OutOfSpaceException ( buffer . position ( ) , buffer . limit ( ) ) ; } buffer . putInt ( value ) ; }
private static URL [ ] pathToURLs ( String path ) throws MalformedURLException { if ( path == null ) { return null ; } synchronized ( pathToURLsCache ) { Object [ ] v = ( Object [ ] ) pathToURLsCache . get ( path ) ; if ( v != null ) { return ( ( URL [ ] ) v [ NUM_ ] ) ; } } StringTokenizer st = new StringTokenizer ( path ) ; URL [ ] urls = new URL [ st . countTokens ( ) ] ; for ( int i = NUM_ ; st . hasMoreTokens ( ) ; i ++ ) { urls [ i ] = new URL ( st . nextToken ( ) ) ; } synchronized ( pathToURLsCache ) { pathToURLsCache . put ( path , new Object [ ] { urls , new SoftReference ( path ) } ) ; } return urls ; }
public static int hash4 ( int hash , Object x , Object y , Object z , Object w ) { return x40000000 | ( hash + NUM_ . System . identityHashCode ( x ) + NUM_ . System . identityHashCode ( y ) + NUM_ . System . identityHashCode ( z ) + NUM_ . System . identityHashCode ( w ) ) ; }
public long skip ( long n ) throws IOException { if ( n < NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } ensureOpen ( ) ; int max = ( int ) Math . min ( n , Integer . MAX_VALUE ) ; int total = NUM_ ; while ( total < max ) { int len = max - total ; if ( len > b . length ) { len = b . length ; } len = read ( b , NUM_ , len ) ; if ( len == - NUM_ ) { reachEOF = BOOL_ ; break ; } total += len ; } return total ; }
private V doPut ( K kkey , V value , boolean onlyIfAbsent ) { Comparable < ? super K > key = comparable ( kkey ) ; for ( ; ; ) { Node < K , V > b = findPredecessor ( key ) ; Node < K , V > n = b . next ; for ( ; ; ) { if ( n != null ) { Node < K , V > f = n . next ; if ( n != b . next ) break ; Object v = n . value ; if ( v == null ) { n . helpDelete ( b , f ) ; break ; } if ( v == n || b . value == null ) break ; int c = key . compareTo ( n . key ) ; if ( c > NUM_ ) { b = n ; n = f ; continue ; } if ( c == NUM_ ) { if ( onlyIfAbsent || n . casValue ( v , value ) ) return ( V ) v ; else break ; } } Node < K , V > z = new Node < K , V > ( kkey , value , n ) ; if ( ! b . casNext ( n , z ) ) break ; int level = randomLevel ( ) ; if ( level > NUM_ ) insertIndex ( z , level ) ; return null ; } } }
public void addFillOutsideLine ( FillOutsideLine fill ) { mFillBelowLine . add ( fill ) ; }
public void add ( final PositionChangeListener listener ) { listeners . add ( listener ) ; }
public void choose ( boolean enable , String what ) ;
public void testDuplicateEntries ( ) throws Exception { String name1 = STR_ ; String name2 = STR_ ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; ZipOutputStream out = new ZipOutputStream ( baos ) ; out . putNextEntry ( new ZipEntry ( name2 ) ) ; out . closeEntry ( ) ; out . putNextEntry ( new ZipEntry ( name1 ) ) ; out . closeEntry ( ) ; out . close ( ) ; byte [ ] buffer = baos . toByteArray ( ) ; replaceBytes ( buffer , name2 . getBytes ( ) , name1 . getBytes ( ) ) ; File badZip = createTemporaryZipFile ( ) ; writeBytes ( badZip , buffer ) ; try { ZipFile bad = new ZipFile ( badZip ) ; fail ( ) ; } catch ( ZipException expected ) { } }
private void rehash ( ) { int size = _symbols . length ; int newSize = size + size ; if ( newSize > MAX_TABLE_SIZE ) { _size = NUM_ ; Arrays . fill ( _symbols , null ) ; Arrays . fill ( _buckets , null ) ; _dirty = BOOL_ ; return ; } String [ ] oldSyms = _symbols ; Bucket [ ] oldBuckets = _buckets ; _symbols = new String [ newSize ] ; _buckets = new Bucket [ newSize > > NUM_ ] ; _indexMask = newSize - NUM_ ; _sizeThreshold = _thresholdSize ( newSize ) ; int count = NUM_ ; int maxColl = NUM_ ; for ( int i = NUM_ ; i < size ; ++ i ) { String symbol = oldSyms [ i ] ; if ( symbol != null ) { ++ count ; int index = _hashToIndex ( calcHash ( symbol ) ) ; if ( _symbols [ index ] == null ) { _symbols [ index ] = symbol ; } else { int bix = ( index > > NUM_ ) ; Bucket newB = new Bucket ( symbol , _buckets [ bix ] ) ; _buckets [ bix ] = newB ; maxColl = Math . max ( maxColl , newB . length ( ) ) ; } } } size >>= NUM_ ; for ( int i = NUM_ ; i < size ; ++ i ) { Bucket b = oldBuckets [ i ] ; while ( b != null ) { ++ count ; String symbol = b . getSymbol ( ) ; int index = _hashToIndex ( calcHash ( symbol ) ) ; if ( _symbols [ index ] == null ) { _symbols [ index ] = symbol ; } else { int bix = ( index > > NUM_ ) ; Bucket newB = new Bucket ( symbol , _buckets [ bix ] ) ; _buckets [ bix ] = newB ; maxColl = Math . max ( maxColl , newB . length ( ) ) ; } b = b . getNext ( ) ; } } _longestCollisionList = maxColl ; if ( count != _size ) { throw new Error ( STR_ + _size + STR_ + count + STR_ ) ; } }
private void checkSize ( final int i ) { if ( i >= max_size ) { final int old_size = max_size ; max_size += increment_size ; if ( max_size <= i ) { max_size = i + increment_size + NUM_ ; } final int [ ] temp = items ; items = new int [ max_size ] ; System . arraycopy ( temp , NUM_ , items , NUM_ , old_size ) ; increment_size = incrementSize ( increment_size ) ; } }
public ComponentPrintService ( Component c , PageFormat format ) { setPageFormat ( format ) ; setPrintable ( this ) ; setComponent ( c ) ; Rectangle componentBounds = c . getBounds ( null ) ; setSize ( componentBounds . width , componentBounds . height ) ; setScale ( NUM_ , NUM_ ) ; }
@ Override public void reconcileFlow ( OFMatchReconcile ofmRcIn , EventPriority priority ) { if ( ofmRcIn == null ) return ; OFMatchReconcile myOfmRc = new OFMatchReconcile ( ofmRcIn ) ; flowQueue . offer ( myOfmRc , priority ) ; ctrFlowReconcileRequest . increment ( ) ; Date currTime = new Date ( ) ; long delay = NUM_ ; if ( currTime . after ( new Date ( lastReconcileTime . getTime ( ) + NUM_ ) ) ) { delay = NUM_ ; } else { delay = FLOW_RECONCILE_DELAY_MILLISEC ; } flowReconcileTask . reschedule ( delay , TimeUnit . MILLISECONDS ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( STR_ , myOfmRc . toString ( ) , flowQueue . size ( ) ) ; } }
public static Optional < String > createInputDialog ( final Window owner , final String title , final String label ) { final TextInputDialog dialog = new TextInputDialog ( ) ; dialog . setTitle ( title ) ; dialog . setHeaderText ( null ) ; dialog . setContentText ( label ) ; dialog . initOwner ( owner ) ; return dialog . showAndWait ( ) ; }
public void flush ( ) throws IOException { if ( writer != null ) { writer . flush ( ) ; } outstr . flush ( ) ; }
@ SuppressWarnings ( STR_ ) protected synchronized V removeInternal ( Object key , boolean countRemove ) { if ( key == null ) { if ( Debug . verboseOn ( ) ) Debug . logVerbose ( STR_ + this . name , module ) ; } Object nulledKey = fromKey ( key ) ; CacheLine < V > oldCacheLine ; V oldValue ; if ( fileTable != null ) { try { synchronized ( this ) { try { oldValue = fileTable . get ( nulledKey ) ; } catch ( IOException e ) { oldValue = null ; throw e ; } fileTable . remove ( nulledKey ) ; jdbmMgr . commit ( ) ; } } catch ( IOException e ) { oldValue = null ; Debug . logError ( e , module ) ; } oldCacheLine = memoryTable . remove ( nulledKey ) ; } else { oldCacheLine = memoryTable . remove ( nulledKey ) ; oldValue = oldCacheLine != null ? oldCacheLine . getValue ( ) : null ; } if ( oldCacheLine != null ) { cancel ( oldCacheLine ) ; } if ( oldValue != null ) { noteRemoval ( ( K ) key , oldValue ) ; if ( countRemove ) removeHitCount . incrementAndGet ( ) ; return oldValue ; } else { if ( countRemove ) removeMissCount . incrementAndGet ( ) ; return null ; } }
public void remove ( double value ) { if ( Double . isNaN ( value ) ) { return ; } int index = findInsertIndex ( value ) ; if ( index == - NUM_ ) { throw new IllegalStateException ( STR_ ) ; } Double valueAtIndex = values . get ( index ) ; if ( ( valueAtIndex != null ) && ( ! valueAtIndex . equals ( value ) ) ) { throw new IllegalStateException ( STR_ ) ; } values . remove ( index ) ; }
public void childrenRemoved ( BeanContextMembershipEvent bcme ) { Iterator < ? > it = bcme . iterator ( ) ; while ( it . hasNext ( ) ) { findAndUndo ( it . next ( ) ) ; } }
void lightweightPaint ( Graphics g ) { super . lightweightPaint ( g ) ; paintHeavyweightComponents ( g ) ; }
public JSONArray names ( ) { JSONArray ja = new JSONArray ( ) ; Iterator keys = keys ( ) ; while ( keys . hasNext ( ) ) { ja . put ( keys . next ( ) ) ; } return ja . length ( ) == NUM_ ? null : ja ; }
private final void removeChannel ( String channel ) { channel = channel . toLowerCase ( ) ; synchronized ( _channels ) { _channels . remove ( channel ) ; } }
public void addChangeListener ( ChangeListener cl ) { if ( ! listeners . contains ( cl ) ) listeners . add ( cl ) ; }
public static void expandNumber ( String numberString , WordRelation wordRelation , Item tokenItem ) { int numDigits = numberString . length ( ) ; if ( numDigits == NUM_ ) { } else if ( numDigits == NUM_ ) { expandDigits ( numberString , wordRelation , tokenItem ) ; } else if ( numDigits == NUM_ ) { expand2DigitNumber ( numberString , wordRelation , tokenItem ) ; } else if ( numDigits == NUM_ ) { expand3DigitNumber ( numberString , wordRelation , tokenItem ) ; } else if ( numDigits < NUM_ ) { expandBelow7DigitNumber ( numberString , wordRelation , tokenItem ) ; } else if ( numDigits < NUM_ ) { expandBelow10DigitNumber ( numberString , wordRelation , tokenItem ) ; } else if ( numDigits < NUM_ ) { expandBelow13DigitNumber ( numberString , wordRelation , tokenItem ) ; } else { expandDigits ( numberString , wordRelation , tokenItem ) ; } }
private void translateMatrixAfterRotate ( int axis , float trans , float prevImageSize , float imageSize , int prevViewSize , int viewSize , int drawableSize ) { if ( imageSize < viewSize ) { m [ axis ] = ( viewSize - ( drawableSize . m [ Matrix . MSCALE_X ] ) ) . NUM_ ; } else if ( trans > NUM_ ) { m [ axis ] = - ( ( imageSize - viewSize ) . NUM_ ) ; } else { float percentage = ( Math . abs ( trans ) + ( NUM_ . prevViewSize ) ) / prevImageSize ; m [ axis ] = - ( ( percentage . imageSize ) - ( viewSize . NUM_ ) ) ; } }
private int measureShort ( int measureSpec ) { int result = NUM_ ; int specMode = MeasureSpec . getMode ( measureSpec ) ; int specSize = MeasureSpec . getSize ( measureSpec ) ; if ( specMode == MeasureSpec . EXACTLY ) { result = specSize ; } else { result = ( int ) ( NUM_ . mRadius + getPaddingTop ( ) + getPaddingBottom ( ) + NUM_ ) ; if ( specMode == MeasureSpec . AT_MOST ) { result = Math . min ( result , specSize ) ; } } return result ; }
protected boolean canTriggerWalking ( ) { return BOOL_ ; }
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; }
public static String encryptECB ( final byte [ ] concatenatedHashValue , final Long turnoverCounter , final SecretKey symmetricKey , int turnOverCounterLengthInBytes ) throws NoSuchAlgorithmException , NoSuchProviderException , NoSuchPaddingException , InvalidKeyException , IllegalBlockSizeException , BadPaddingException { final ByteBuffer byteBufferIV = ByteBuffer . allocate ( NUM_ ) ; byteBufferIV . put ( concatenatedHashValue ) ; final byte [ ] IV = byteBufferIV . array ( ) ; final ByteBuffer byteBufferData = ByteBuffer . allocate ( NUM_ ) ; byteBufferData . putLong ( turnoverCounter ) ; final byte [ ] data = byteBufferData . array ( ) ; byte [ ] turnOverCounterByteRep = get2ComplementRepForLong ( turnoverCounter , turnOverCounterLengthInBytes ) ; System . arraycopy ( turnOverCounterByteRep , NUM_ , data , NUM_ , turnOverCounterByteRep . length ) ; final Cipher cipher = Cipher . getInstance ( STR_ , STR_ ) ; cipher . init ( Cipher . ENCRYPT_MODE , symmetricKey ) ; final byte [ ] intermediateResult = cipher . doFinal ( IV ) ; final byte [ ] result = new byte [ data . length ] ; for ( int i = NUM_ ; i < data . length ; i ++ ) { result [ i ] = ( byte ) ( ( data [ i ] ) ^ ( intermediateResult [ i ] ) ) ; } final byte [ ] encryptedTurnOverValue = new byte [ turnOverCounterLengthInBytes ] ; System . arraycopy ( result , NUM_ , encryptedTurnOverValue , NUM_ , turnOverCounterLengthInBytes ) ; return CashBoxUtils . base64Encode ( encryptedTurnOverValue , BOOL_ ) ; }
private static boolean isFrostWireOld ( String messageVersion ) { if ( messageVersion == null ) return BOOL_ ; String currentVersion = FrostWireUtils . getFrostWireVersion ( ) ; if ( currentVersion . equals ( messageVersion ) ) { return BOOL_ ; } try { String [ ] fwVersionParts = currentVersion . split ( STR_ ) ; int fw_major = Integer . parseInt ( fwVersionParts [ NUM_ ] ) ; int fw_release = Integer . parseInt ( fwVersionParts [ NUM_ ] ) ; int fw_service = Integer . parseInt ( fwVersionParts [ NUM_ ] ) ; String [ ] msgVersionParts = messageVersion . split ( STR_ ) ; int msg_major = Integer . parseInt ( msgVersionParts [ NUM_ ] ) ; int msg_release = Integer . parseInt ( msgVersionParts [ NUM_ ] ) ; int msg_service = Integer . parseInt ( msgVersionParts [ NUM_ ] ) ; if ( fw_major < msg_major ) { return BOOL_ ; } if ( fw_major == msg_major && fw_release < msg_release ) { return BOOL_ ; } if ( fw_major == msg_major && fw_release == msg_release && fw_service < msg_service ) { return BOOL_ ; } } catch ( Exception e ) { return BOOL_ ; } return BOOL_ ; }
public synchronized void drawMap ( ) { lastDrawMapReq = System . currentTimeMillis ( ) ; SwingUtilities . invokeLater ( drawMapable ) ; }
public void selectTable2Column ( Index column ) { table2Columns . add ( column ) ; }
public List < String > extractURLs ( final String text ) { if ( text == null || text . length ( ) == NUM_ ) return Collections . emptyList ( ) ; final ArrayList < String > urls = new ArrayList < String > ( ) ; for ( final Entity entity : extractURLsWithIndices ( text ) ) { urls . add ( entity . value ) ; } return urls ; }
public void findAndUndo ( Iterator it ) { while ( it . hasNext ( ) ) { findAndUndo ( it . next ( ) ) ; } }
public static int [ ] scaleDownInside ( int inWidth , int inHeight , int maxWidth , int maxHeight ) { int scaledWidth ; int scaledHeight ; if ( inWidth <= maxWidth && inHeight <= maxHeight ) { scaledWidth = inWidth ; scaledHeight = inHeight ; } else { double widthRatio = ( double ) inWidth / ( double ) maxWidth ; double heightRatio = ( double ) inHeight / ( double ) maxHeight ; if ( widthRatio > heightRatio ) { scaledWidth = maxWidth ; scaledHeight = ( int ) Math . round ( ( double ) inHeight / widthRatio ) ; } else { scaledHeight = maxHeight ; scaledWidth = ( int ) Math . round ( ( double ) inWidth / heightRatio ) ; } } return new int [ ] { scaledWidth , scaledHeight } ; }
public void rm ( String fileOrDir ) { StringBuilder buf = new StringBuilder ( ) ; String command = String . format ( ImageServerDialogProperties . getString ( STR_ ) , fileOrDir ) ; sendWaitFor ( command , defaultTimeout , prompts , buf ) ; log . debug ( buf . toString ( ) ) ; }
public void putMap ( Map < String , List < String > > m ) { for ( String key : m . keySet ( ) ) { SortedSet < String > vals = get ( key ) ; if ( vals == null ) { vals = new TreeSet < String > ( ) ; put ( key , vals ) ; } vals . addAll ( m . get ( key ) ) ; } }
protected void throwParseException ( ParseException e ) throws ParseException { if ( locator != null ) { String elementLocation = STR_ ; if ( curHandler != null ) { elementLocation += STR_ + curHandler . qName ; } String location = STR_ + String . valueOf ( locator . getLineNumber ( ) ) + STR_ + String . valueOf ( locator . getColumnNumber ( ) ) + elementLocation + STR_ ; LogUtils . logException ( logger , Level . FINE , location , e ) ; throw new ParseException ( location + e . getMessage ( ) , e ) ; } else { LogUtils . logException ( logger , Level . FINE , null , e ) ; throw e ; } }
public void addAssetListener ( @ NotNull ActionListener listener ) { myAssetListeners . add ( listener ) ; }
public UndoableEdit insertString ( int where , String str ) throws BadLocationException { if ( where > length ( ) || where < NUM_ ) { throw new BadLocationException ( STR_ , length ( ) ) ; } char [ ] chars = str . toCharArray ( ) ; replace ( where , NUM_ , chars , chars . length ) ; return new InsertUndo ( where , str . length ( ) ) ; }
public static JavaPairRDD < MatrixIndexes , MatrixBlock > toMatrixJavaPairRDD ( JavaSparkContext sc , MatrixBlock src , int brlen , int bclen ) throws DMLRuntimeException { long t0 = DMLScript . STATISTICS ? System . nanoTime ( ) : NUM_ ; LinkedList < Tuple2 < MatrixIndexes , MatrixBlock > > list = new LinkedList < Tuple2 < MatrixIndexes , MatrixBlock > > ( ) ; if ( src . getNumRows ( ) <= brlen && src . getNumColumns ( ) <= bclen ) { list . addLast ( new Tuple2 < MatrixIndexes , MatrixBlock > ( new MatrixIndexes ( NUM_ , NUM_ ) , src ) ) ; } else { boolean sparse = src . isInSparseFormat ( ) ; for ( int blockRow = NUM_ ; blockRow < ( int ) Math . ceil ( src . getNumRows ( ) / ( double ) brlen ) ; blockRow ++ ) for ( int blockCol = NUM_ ; blockCol < ( int ) Math . ceil ( src . getNumColumns ( ) / ( double ) bclen ) ; blockCol ++ ) { int maxRow = ( blockRow . brlen + brlen < src . getNumRows ( ) ) ? brlen : src . getNumRows ( ) - blockRow . brlen ; int maxCol = ( blockCol . bclen + bclen < src . getNumColumns ( ) ) ? bclen : src . getNumColumns ( ) - blockCol . bclen ; MatrixBlock block = new MatrixBlock ( maxRow , maxCol , sparse ) ; int row_offset = blockRow . brlen ; int col_offset = blockCol . bclen ; src . sliceOperations ( row_offset , row_offset + maxRow - NUM_ , col_offset , col_offset + maxCol - NUM_ , block ) ; MatrixIndexes indexes = new MatrixIndexes ( blockRow + NUM_ , blockCol + NUM_ ) ; list . addLast ( new Tuple2 < MatrixIndexes , MatrixBlock > ( indexes , block ) ) ; } } JavaPairRDD < MatrixIndexes , MatrixBlock > result = sc . parallelizePairs ( list ) ; if ( DMLScript . STATISTICS ) { Statistics . accSparkParallelizeTime ( System . nanoTime ( ) - t0 ) ; Statistics . incSparkParallelizeCount ( NUM_ ) ; } return result ; }
public static boolean isYouTubeUrl ( String url ) { if ( TextUtils . isEmpty ( url ) ) { return BOOL_ ; } Uri uri = Uri . parse ( url ) ; String authority = uri . getAuthority ( ) ; if ( ! TextUtils . isEmpty ( authority ) && authority . contains ( STR_ ) ) { return BOOL_ ; } else { return BOOL_ ; } }
public List < NamespaceVO > findNamespaces ( String appId , Env env , String clusterName ) { List < NamespaceDTO > namespaces = namespaceAPI . findNamespaceByCluster ( appId , env , clusterName ) ; if ( namespaces == null || namespaces . size ( ) == NUM_ ) { throw new BadRequestException ( STR_ ) ; } List < NamespaceVO > namespaceVOs = new LinkedList < > ( ) ; for ( NamespaceDTO namespace : namespaces ) { NamespaceVO namespaceVO = null ; try { namespaceVO = parseNamespace ( appId , env , clusterName , namespace ) ; namespaceVOs . add ( namespaceVO ) ; } catch ( Exception e ) { logger . error ( STR_ , appId , env , clusterName , namespace . getNamespaceName ( ) , e ) ; throw e ; } } return namespaceVOs ; }
void unlink ( Node < E > p , Node < E > trail ) { p . item = null ; trail . next = p . next ; if ( last == p ) last = trail ; if ( count . getAndDecrement ( ) == capacity ) notFull . signal ( ) ; }
public static void openShareDialog ( Context context , String title , @ SuppressWarnings ( STR_ ) String uri , String shareText , String shareSubject ) { Intent share = new Intent ( Intent . ACTION_SEND ) ; share . setType ( STR_ ) ; share . putExtra ( Intent . EXTRA_TEXT , shareText ) ; share . putExtra ( Intent . EXTRA_SUBJECT , shareSubject ) ; if ( ! TextUtils . isEmpty ( uri ) ) { share . setType ( STR_ ) ; share . putExtra ( Intent . EXTRA_STREAM , Uri . parse ( uri ) ) ; } context . startActivity ( Intent . createChooser ( share , title ) ) ; }
public void addMatching ( final ConversationStates state , final String triggerString , final ExpressionMatcher matcher , final ChatCondition condition , boolean secondary , final ConversationStates nextState , final String reply , final ChatAction action ) { Collection < Expression > triggerExpressions = createUniqueTriggerExpressions ( state , Arrays . asList ( triggerString ) , matcher , condition , reply , action ) ; add ( triggerExpressions , state , condition , secondary , nextState , reply , action ) ; }
boolean dropItems ( final Player player , int itemCount ) { boolean result = BOOL_ ; final ItemCollection itemsTodo = new ItemCollection ( ) ; itemsTodo . addFromQuestStateString ( player . getQuest ( questSlot ) ) ; if ( player . drop ( itemName , itemCount ) ) { if ( itemsTodo . removeItem ( itemName , itemCount ) ) { result = BOOL_ ; } } else { final List < Item > items = player . getAllEquipped ( itemName ) ; if ( items != null ) { for ( final Item item : items ) { final int quantity = item . getQuantity ( ) ; final int n = Math . min ( itemCount , quantity ) ; if ( player . drop ( itemName , n ) ) { itemCount -= n ; if ( itemsTodo . removeItem ( itemName , n ) ) { result = BOOL_ ; } } if ( itemCount == NUM_ ) { result = BOOL_ ; break ; } } } } if ( result ) { player . setQuest ( questSlot , itemsTodo . toStringForQuestState ( ) ) ; } return result ; }
public void encodeOctetString ( byte tb [ ] , int tag , int tboffset , int length ) throws EncodeException { encodeByte ( tag ) ; encodeLength ( length ) ; if ( length > NUM_ ) { ensureFreeBytes ( length ) ; System . arraycopy ( tb , tboffset , buf , offset , length ) ; offset += length ; } }
private void swapBlocks ( int from , int second , int to ) { int len1 = second - from , len2 = to - second + NUM_ ; if ( len1 == NUM_ || len2 == NUM_ ) { return ; } if ( len1 < temp . length ) { System . arraycopy ( data , from , temp , NUM_ , len1 ) ; System . arraycopy ( data , second , data , from , len2 ) ; System . arraycopy ( temp , NUM_ , data , from + len2 , len1 ) ; return ; } else if ( len2 < temp . length ) { System . arraycopy ( data , second , temp , NUM_ , len2 ) ; System . arraycopy ( data , from , data , from + len2 , len1 ) ; System . arraycopy ( temp , NUM_ , data , from , len2 ) ; return ; } reverseBlock ( from , second - NUM_ ) ; reverseBlock ( second , to ) ; reverseBlock ( from , to ) ; }
private static long totalSize ( Map < String , Long > relPathToSize ) { long total = NUM_ ; for ( Long l : relPathToSize . values ( ) ) { total += l ; } return total ; }
public boolean hasNext ( ) { return iterator . hasNext ( ) ; }
public static boolean isValid ( Timestamp validFrom , Timestamp validTo , Timestamp testDate ) { if ( testDate == null ) return BOOL_ ; if ( validFrom == null && validTo == null ) return BOOL_ ; if ( validFrom != null && validFrom . after ( testDate ) ) return BOOL_ ; if ( validTo != null && validTo . before ( testDate ) ) return BOOL_ ; return BOOL_ ; }
public PatternTokenizer ( AttributeFactory factory , Pattern pattern , int group ) { super ( factory ) ; this . group = group ; matcher = pattern . matcher ( STR_ ) ; if ( group >= NUM_ && group > matcher . groupCount ( ) ) { throw new IllegalArgumentException ( STR_ + matcher . groupCount ( ) + STR_ ) ; } }
@ Override public double totalEstimatedQuantityForPreviousREs ( final Long woActivityId , Long estimateId , final Long activityId , final WorkOrder workOrder ) { if ( estimateId == null ) estimateId = - NUM_ ; Object [ ] params = null ; Double estQuantity = null ; params = new Object [ ] { estimateId , workOrder , workOrder , woActivityId , activityId } ; estQuantity = ( Double ) genericService . findByNamedQuery ( STR_ , params ) ; Double estQuantityRE = null ; params = new Object [ ] { estimateId , workOrder , workOrder , activityId } ; estQuantityRE = ( Double ) genericService . findByNamedQuery ( STR_ , params ) ; if ( estQuantity != null && estQuantityRE != null ) estQuantity = estQuantity + estQuantityRE ; if ( estQuantity == null && estQuantityRE != null ) estQuantity = estQuantityRE ; if ( estQuantity == null ) return NUM_ ; else return estQuantity . doubleValue ( ) ; }
protected long writeDataToFile ( NodeHolder nodeHolder , FileChannel channel ) throws CarbonDataWriterException { byte [ ] [ ] compressedIndex = nodeHolder . getCompressedIndex ( ) ; byte [ ] [ ] compressedIndexMap = nodeHolder . getCompressedIndexMap ( ) ; byte [ ] [ ] compressedDataIndex = nodeHolder . getCompressedDataIndex ( ) ; int indexBlockSize = NUM_ ; int index = NUM_ ; for ( int i = NUM_ ; i < nodeHolder . getKeyBlockIndexLength ( ) . length ; i ++ ) { indexBlockSize += nodeHolder . getKeyBlockIndexLength ( ) [ index ++ ] + CarbonCommonConstants . INT_SIZE_IN_BYTE ; } for ( int i = NUM_ ; i < nodeHolder . getDataIndexMapLength ( ) . length ; i ++ ) { indexBlockSize += nodeHolder . getDataIndexMapLength ( ) [ i ] ; } ByteBuffer byteBuffer = ByteBuffer . allocate ( nodeHolder . getKeyArray ( ) . length + nodeHolder . getDataArray ( ) . length + indexBlockSize ) ; long offset = NUM_ ; try { offset = channel . size ( ) ; byteBuffer . put ( nodeHolder . getKeyArray ( ) ) ; byteBuffer . put ( nodeHolder . getDataArray ( ) ) ; ByteBuffer buffer1 = null ; for ( int i = NUM_ ; i < compressedIndex . length ; i ++ ) { buffer1 = ByteBuffer . allocate ( nodeHolder . getKeyBlockIndexLength ( ) [ i ] ) ; buffer1 . putInt ( compressedIndex [ i ] . length ) ; buffer1 . put ( compressedIndex [ i ] ) ; if ( compressedIndexMap [ i ] . length > NUM_ ) { buffer1 . put ( compressedIndexMap [ i ] ) ; } buffer1 . rewind ( ) ; byteBuffer . put ( buffer1 . array ( ) ) ; } for ( int i = NUM_ ; i < compressedDataIndex . length ; i ++ ) { byteBuffer . put ( compressedDataIndex [ i ] ) ; } byteBuffer . flip ( ) ; channel . write ( byteBuffer ) ; } catch ( IOException exception ) { throw new CarbonDataWriterException ( STR_ , exception ) ; } return offset ; }
public boolean eval ( ) { if ( sourceFileSets . size ( ) == NUM_ && sourceResources . size ( ) == NUM_ && sourceFile == null ) { throw new BuildException ( STR_ ) ; } if ( ( sourceFileSets . size ( ) > NUM_ || sourceResources . size ( ) > NUM_ ) && sourceFile != null ) { throw new BuildException ( STR_ ) ; } if ( urlbase == null ) { throw new BuildException ( STR_ ) ; } if ( sourceFile != null && ! sourceFile . exists ( ) ) { throw new BuildException ( sourceFile . getAbsolutePath ( ) + STR_ ) ; } boolean upToDate = BOOL_ ; if ( sourceFile != null ) { Resource fileResource = new FileResource ( sourceFile ) ; upToDate = isUpToDate ( fileResource ) ; } if ( upToDate ) { Enumeration e = sourceFileSets . elements ( ) ; while ( upToDate && e . hasMoreElements ( ) ) { FileSet fs = ( FileSet ) e . nextElement ( ) ; Iterator it = fs . iterator ( ) ; while ( upToDate && it . hasNext ( ) ) { Resource r = ( Resource ) it . next ( ) ; upToDate = isUpToDate ( r ) ; } } } if ( upToDate ) { Resource [ ] r = sourceResources . listResources ( ) ; for ( int i = NUM_ ; upToDate && i < r . length ; i ++ ) { upToDate = isUpToDate ( r [ i ] ) ; } } return upToDate ; }
private int handleAggregationPacket ( Buffer input , Buffer output ) { byte [ ] bufferData = ( byte [ ] ) input . getData ( ) ; if ( aggregationPositon + NUM_ >= bufferData . length ) { aggregationPositon = NUM_ ; output . setDiscard ( BOOL_ ) ; return BUFFER_PROCESSED_OK ; } int nalu_size = ( ( ( bufferData [ aggregationPositon ] & xff ) << NUM_ ) | ( bufferData [ aggregationPositon + NUM_ ] & xff ) ) ; aggregationPositon += NUM_ ; if ( aggregationPositon + nalu_size > bufferData . length ) { aggregationPositon = NUM_ ; return BUFFER_PROCESSED_FAILED ; } extractNalUnitHeader ( aggregationPositon , input ) ; if ( mNalUnitHeader . isSingleNalUnitPacket ( ) ) { byte [ ] data = new byte [ nalu_size ] ; System . arraycopy ( bufferData , aggregationPositon , data , NUM_ , nalu_size ) ; aggregationPositon += nalu_size ; output . setData ( data ) ; output . setLength ( data . length ) ; output . setOffset ( NUM_ ) ; output . setTimestamp ( input . getTimestamp ( ) ) ; output . setSequenceNumber ( input . getSequenceNumber ( ) ) ; output . setVideoOrientation ( input . getVideoOrientation ( ) ) ; output . setFormat ( input . getFormat ( ) ) ; output . setFlags ( input . getFlags ( ) ) ; return INPUT_BUFFER_NOT_CONSUMED ; } aggregationPositon = NUM_ ; return BUFFER_PROCESSED_FAILED ; }
public double calculateCostForStringAVM ( RegexGraph graph ) { final int ROWS = graph . getNumberOfRows ( ) ; final int COLUMNS = graph . getNumberOfColumns ( ) ; final double [ ] [ ] [ ] matrix = new double [ ROWS ] [ COLUMNS ] [ NUM_ ] ; calculateInsertionCostOnFirstRow ( graph , matrix ) ; for ( int i = NUM_ ; i < ROWS ; i ++ ) { for ( int col = NUM_ ; col < COLUMNS ; col ++ ) { matrix [ i ] [ col ] [ DEL ] = Double . MAX_VALUE ; matrix [ i ] [ col ] [ REP ] = Double . MAX_VALUE ; matrix [ i ] [ col ] [ INS ] = Double . MAX_VALUE ; for ( GraphTransition t : graph . getIncomingTransitions ( i , col ) ) { int otherCol = graph . getColumn ( t . fromState ) ; int otherRow = t . fromRow ; if ( t . type . equals ( GraphTransition . TransitionType . INSERTION ) ) { assert otherRow == i ; matrix [ i ] [ col ] [ INS ] = Math . min ( matrix [ i ] [ col ] [ INS ] , getSubPathCost ( matrix [ otherRow ] [ otherCol ] [ DEL ] , t . cost ) ) ; matrix [ i ] [ col ] [ INS ] = Math . min ( matrix [ i ] [ col ] [ INS ] , getSubPathCost ( matrix [ otherRow ] [ otherCol ] [ REP ] , t . cost ) ) ; matrix [ i ] [ col ] [ INS ] = Math . min ( matrix [ i ] [ col ] [ INS ] , getSubPathCost ( matrix [ otherRow ] [ otherCol ] [ INS ] , t . cost ) ) ; } else if ( t . type . equals ( GraphTransition . TransitionType . REPLACEMENT ) ) { matrix [ i ] [ col ] [ REP ] = Math . min ( matrix [ i ] [ col ] [ REP ] , getSubPathCost ( matrix [ otherRow ] [ otherCol ] [ DEL ] , t . cost ) ) ; matrix [ i ] [ col ] [ REP ] = Math . min ( matrix [ i ] [ col ] [ REP ] , getSubPathCost ( matrix [ otherRow ] [ otherCol ] [ REP ] , t . cost ) ) ; matrix [ i ] [ col ] [ INS ] = Math . min ( matrix [ i ] [ col ] [ INS ] , getSubPathCost ( matrix [ otherRow ] [ otherCol ] [ DEL ] , t . cost ) ) ; matrix [ i ] [ col ] [ INS ] = Math . min ( matrix [ i ] [ col ] [ INS ] , getSubPathCost ( matrix [ otherRow ] [ otherCol ] [ REP ] , t . cost ) ) ; } else if ( t . type . equals ( GraphTransition . TransitionType . DELETION ) ) { matrix [ i ] [ col ] [ DEL ] = Math . min ( matrix [ i ] [ col ] [ DEL ] , getSubPathCost ( matrix [ otherRow ] [ otherCol ] [ DEL ] , t . cost ) ) ; matrix [ i ] [ col ] [ REP ] = Math . min ( matrix [ i ] [ col ] [ REP ] , getSubPathCost ( matrix [ otherRow ] [ otherCol ] [ DEL ] , t . cost ) ) ; matrix [ i ] [ col ] [ INS ] = Math . min ( matrix [ i ] [ col ] [ INS ] , getSubPathCost ( matrix [ otherRow ] [ otherCol ] [ DEL ] , t . cost ) ) ; } else if ( t . type . equals ( GraphTransition . TransitionType . PHANTOM ) ) { assert t . cost == NUM_ ; matrix [ i ] [ col ] [ DEL ] = Math . min ( matrix [ i ] [ col ] [ DEL ] , matrix [ otherRow ] [ otherCol ] [ DEL ] ) ; matrix [ i ] [ col ] [ REP ] = Math . min ( matrix [ i ] [ col ] [ REP ] , matrix [ otherRow ] [ otherCol ] [ REP ] ) ; matrix [ i ] [ col ] [ INS ] = Math . min ( matrix [ i ] [ col ] [ INS ] , matrix [ otherRow ] [ otherCol ] [ INS ] ) ; } } } } double min = Double . MAX_VALUE ; for ( double value : matrix [ ROWS - NUM_ ] [ COLUMNS - NUM_ ] ) { if ( value < min ) { min = value ; } } return min ; }
protected int decodeLinePrefix ( PushbackInputStream inStream , OutputStream outStream ) throws IOException { int i ; int nLen , nSeq ; byte xtmp [ ] ; int c ; crc . value = NUM_ ; while ( BOOL_ ) { c = inStream . read ( tmp , NUM_ , NUM_ ) ; if ( c == - NUM_ ) { throw new CEStreamExhausted ( ) ; } if ( tmp [ NUM_ ] == STR_ ) { break ; } } lineAndSeq . reset ( ) ; decodeAtom ( inStream , lineAndSeq , NUM_ ) ; xtmp = lineAndSeq . toByteArray ( ) ; nLen = xtmp [ NUM_ ] & xff ; nSeq = xtmp [ NUM_ ] & xff ; if ( nSeq != sequence ) { throw new CEFormatException ( STR_ ) ; } sequence = ( sequence + NUM_ ) & xff ; return ( nLen ) ; }
public void appendNodes ( NodeSet nodes ) { int nNodes = nodes . size ( ) ; if ( null == m_map ) { m_mapSize = nNodes + m_blocksize ; m_map = new Node [ m_mapSize ] ; } else if ( ( m_firstFree + nNodes ) >= m_mapSize ) { m_mapSize += ( nNodes + m_blocksize ) ; Node newMap [ ] = new Node [ m_mapSize ] ; System . arraycopy ( m_map , NUM_ , newMap , NUM_ , m_firstFree + nNodes ) ; m_map = newMap ; } System . arraycopy ( nodes . m_map , NUM_ , m_map , m_firstFree , nNodes ) ; m_firstFree += nNodes ; }
protected void updateCachedAWTSizes ( final Dimension min , final Dimension pref , final Dimension max ) { assert EventQueue . isDispatchThread ( ) ; if ( verboseSizeLayout ) { System . err . println ( STR_ + min + STR_ + pref + STR_ + max ) ; } lastValidatedAWTTime = ++ currentAWTTime ; boolean mustNotify ; synchronized ( this ) { mustNotify = cachedSizesInitialized == NUM_ ; if ( ! mustNotify ) { mustNotify = ! ( min . equals ( cachedMinSize ) && pref . equals ( cachedPrefSize ) && max . equals ( cachedMaxSize ) ) ; } if ( cachedSizesInitialized == NUM_ ) { cachedSizesInitialized = NUM_ ; } cachedMinSize = min ; cachedPrefSize = pref ; cachedMaxSize = max ; if ( INITIAL_CLIENT_AREA_WORKAROUND && initialClientArea != null ) { initialClientArea . width = cachedPrefSize . width ; initialClientArea . height = cachedPrefSize . height ; } } if ( mustNotify ) { final int onBehalfAWTTime = lastValidatedAWTTime ; ThreadingHandler . getInstance ( ) . asyncExec ( display , null ) ; } }
public boolean isDecimalPoint ( ) { if ( m_decimalPoint == null ) { DecimalFormatSymbols dfs = new DecimalFormatSymbols ( m_locale ) ; m_decimalPoint = new Boolean ( dfs . getDecimalSeparator ( ) == STR_ ) ; } return m_decimalPoint . booleanValue ( ) ; }
public void removeLayer ( Layer layer ) { if ( layer != null && layer . isRemovable ( ) ) { List < Layer > currentLayers = getLayerList ( ) ; currentLayers . remove ( layer ) ; setLayerList ( currentLayers ) ; } else { if ( layer != null ) { logger . warning ( STR_ + layer . getName ( ) + STR_ ) ; throw new com . bbn . openmap . util . HandleError ( STR_ + layer . getName ( ) + STR_ ) ; } } }
public Option [ ] findAllOptionTypes ( final Class optionClass ) { Check . notNull ( optionClass , STR_ ) ; return findAllOptionTypes ( new Class [ ] { optionClass } ) ; }
public int via_padstack_count ( ) { return via_padstacks . size ( ) ; }
public static boolean isEarlierTransaction ( MCostDetail cd , int C_AcctSchema_ID , int M_CostType_ID , int M_CostElement_ID , String costingLevel ) { MTransaction trx = new MTransaction ( cd . getCtx ( ) , cd . getM_Transaction_ID ( ) , cd . get_TrxName ( ) ) ; MCostDetail last_cd = getLastTransaction ( trx , C_AcctSchema_ID , M_CostType_ID , M_CostElement_ID , costingLevel ) ; if ( last_cd == null ) return BOOL_ ; if ( cd . getSeqNo ( ) <= last_cd . getSeqNo ( ) && cd . getM_Transaction_ID ( ) != last_cd . getM_Transaction_ID ( ) ) { return BOOL_ ; } return BOOL_ ; }
private void drawTranslatedRenderedImage ( RenderedImage img , Rectangle region , int i2uTransX , int i2uTransY ) { int tileGridXOffset = img . getTileGridXOffset ( ) ; int tileGridYOffset = img . getTileGridYOffset ( ) ; int tileWidth = img . getTileWidth ( ) ; int tileHeight = img . getTileHeight ( ) ; int minTileX = getTileIndex ( region . x , tileGridXOffset , tileWidth ) ; int minTileY = getTileIndex ( region . y , tileGridYOffset , tileHeight ) ; int maxTileX = getTileIndex ( region . x + region . width - NUM_ , tileGridXOffset , tileWidth ) ; int maxTileY = getTileIndex ( region . y + region . height - NUM_ , tileGridYOffset , tileHeight ) ; ColorModel colorModel = img . getColorModel ( ) ; Rectangle tileRect = new Rectangle ( ) ; for ( int ty = minTileY ; ty <= maxTileY ; ty ++ ) { for ( int tx = minTileX ; tx <= maxTileX ; tx ++ ) { Raster raster = img . getTile ( tx , ty ) ; tileRect . x = tx . tileWidth + tileGridXOffset ; tileRect . y = ty . tileHeight + tileGridYOffset ; tileRect . width = tileWidth ; tileRect . height = tileHeight ; clipTo ( tileRect , region ) ; WritableRaster wRaster = null ; if ( raster instanceof WritableRaster ) { wRaster = ( WritableRaster ) raster ; } else { wRaster = Raster . createWritableRaster ( raster . getSampleModel ( ) , raster . getDataBuffer ( ) , null ) ; } wRaster = wRaster . createWritableChild ( tileRect . x , tileRect . y , tileRect . width , tileRect . height , NUM_ , NUM_ , null ) ; BufferedImage bufImg = new BufferedImage ( colorModel , wRaster , colorModel . isAlphaPremultiplied ( ) , null ) ; copyImage ( bufImg , tileRect . x + i2uTransX , tileRect . y + i2uTransY , NUM_ , NUM_ , tileRect . width , tileRect . height , null , null ) ; } } }
public void addOutOfContextMessage ( ConsensusMessage m ) { outOfContextLock . lock ( ) ; if ( m . getType ( ) == MessageFactory . PROPOSE ) { Logger . println ( STR_ + m ) ; outOfContextProposes . put ( m . getNumber ( ) , m ) ; } else { List < ConsensusMessage > messages = outOfContext . get ( m . getNumber ( ) ) ; if ( messages == null ) { messages = new LinkedList < ConsensusMessage > ( ) ; outOfContext . put ( m . getNumber ( ) , messages ) ; } Logger . println ( STR_ + m ) ; messages . add ( m ) ; } outOfContextLock . unlock ( ) ; }
private long calculateCapacity ( long minimumCapacity ) { long newCapacity = Math . min ( Math . max ( capacity , NUM_ ) , minimumCapacity ) ; while ( newCapacity < Math . min ( minimumCapacity , maxCapacity ) ) { newCapacity <<= NUM_ ; } return Math . min ( newCapacity , maxCapacity ) ; }
protected Object createResource ( ) throws ResourceUnavailableException { Object resource = create ( ) ; freed . add ( resource ) ; numCreated ++ ; return ( resource ) ; }
public void upgrade ( ) throws Exception { if ( ! checkUpgradePreconditions ( ) ) { return ; } backupManager . createOpenDJBackup ( ) ; try ( BufferedWriter out = new BufferedWriter ( new FileWriter ( upgradeMarker ) ) ) { out . write ( currentVersion . toString ( ) ) ; out . write ( STR_ ) ; } if ( currentVersion . isOlderThan ( DJ_245_VERSION ) ) { backupFile ( STR_ ) ; backupFile ( STR_ ) ; backupFile ( STR_ ) ; unpackZipFile ( BOOL_ ) ; callOldDJUpgrade ( ) ; } else { unpackZipFile ( BOOL_ ) ; if ( currentVersion . equals ( DJ_246_VERSION ) ) { try { File badSchema = new File ( installRoot + File . separator + STR_ + File . separator + STR_ + File . separator + STR_ ) ; delete ( badSchema ) ; } catch ( RuntimeException e ) { } File goodSchema = new File ( servletCtx . getRealPath ( File . separator + STR_ + File . separator + STR_ + File . separator + STR_ + File . separator + STR_ + File . separator + STR_ ) ) ; File moveTo = new File ( installRoot + File . separator + STR_ + File . separator + STR_ + File . separator + STR_ ) ; copy ( goodSchema . toPath ( ) , moveTo . toPath ( ) ) ; } int ret = callDJUpgradeMechanism ( ) ; if ( ret == NUM_ ) { message ( STR_ ) ; delete ( upgradeMarker ) ; final String lockFile = LockFileManager . getServerLockFileName ( ) ; LockFileManager . releaseLock ( lockFile , new StringBuilder ( ) ) ; } else { throw new UpgradeException ( STR_ + ret ) ; } } }
public static final Optional < File > findSteamVRManifest ( final ArrayList < File > indexedSteamFolders ) { for ( final File f : indexedSteamFolders ) { final File currentFile = new File ( f . getAbsolutePath ( ) + SteamConstants . STEAM_VR_APPS_MANIFEST_FILE_LOCATION ) ; if ( currentFile . exists ( ) ) return Optional . ofNullable ( currentFile ) ; } return Optional . empty ( ) ; }
private static boolean isClose ( float value , float targetValue ) { return Math . abs ( value - targetValue ) < NUM_ ; }
public int size ( ) { return _myTcpClients . size ( ) ; }
public static MMovementCartBean addToMovementCart ( Properties ctx , StockMovementBean bean , MMovementCartBean cartBean , boolean isSales , boolean ifAdd ) throws OperationException , ProductNotFoundException , ProductNotOnPriceListException { ArrayList < ItemBean > oldItems ; if ( cartBean == null ) { cartBean = new MMovementCartBean ( ) ; oldItems = new ArrayList < ItemBean > ( ) ; } else { oldItems = cartBean . getItems ( ) ; } ArrayList < ItemBean > oldItemsClone = ( ArrayList ) oldItems . clone ( ) ; ArrayList itemsToBeAdded = getMMovementItems ( ctx , bean ) ; oldItems = addToMMovementList ( ctx , oldItemsClone , itemsToBeAdded , ifAdd ) ; Integer priceListId = POSTerminalManager . getPriceListId ( ctx , isSales ) ; oldItems = setMMovementItemCosts ( ctx , priceListId , oldItems , isSales ) ; cartBean . setItems ( oldItems ) ; cartBean . setPricelistId ( priceListId ) ; return cartBean ; }
private static List < Field > filterFieldList ( List < Field > fields , Class < ? > filterClass ) { List < Field > filteredFields = new LinkedList < > ( ) ; for ( Field f : fields ) { if ( ( filterClass == null ) || filterClass . isAssignableFrom ( f . getType ( ) ) ) { filteredFields . add ( f ) ; } } return filteredFields ; }
public static void renderPairwiseOrthogonal ( ComplexVector vec1 , ComplexVector vec2 ) { IncompatibleVectorsException . checkVectorsCompatible ( vec1 , vec2 ) ; if ( vec1 . getOpMode ( ) != ComplexVector . Mode . CARTESIAN ) vec1 . toCartesian ( ) ; if ( vec2 . getOpMode ( ) != ComplexVector . Mode . CARTESIAN ) vec2 . toCartesian ( ) ; float [ ] coordinates1 = vec1 . getCoordinates ( ) ; float [ ] coordinates2 = vec2 . getCoordinates ( ) ; for ( int i = NUM_ ; i < vec1 . getDimension ( ) . NUM_ ; i += NUM_ ) { double resultThisPair = coordinates1 [ i ] . coordinates2 [ i ] ; resultThisPair += coordinates1 [ i + NUM_ ] . coordinates2 [ i + NUM_ ] ; double norm1 = coordinates1 [ i ] . coordinates1 [ i ] ; norm1 += coordinates1 [ i + NUM_ ] . coordinates1 [ i + NUM_ ] ; double norm2 = coordinates2 [ i ] . coordinates2 [ i ] ; norm2 += coordinates2 [ i + NUM_ ] . coordinates2 [ i + NUM_ ] ; norm1 = Math . sqrt ( norm1 ) ; norm2 = Math . sqrt ( norm2 ) ; double cosine = NUM_ ; if ( norm1 > NUM_ && norm2 > NUM_ ) cosine = resultThisPair / ( norm1 . norm2 ) ; coordinates1 [ i ] = ( float ) ( coordinates1 [ i ] - cosine . coordinates2 [ i ] ) ; coordinates1 [ i + NUM_ ] = ( float ) ( coordinates1 [ i + NUM_ ] - cosine . coordinates2 [ i + NUM_ ] ) ; } }
protected SimpleJavaFileObject ( URI uri , Kind kind ) { uri . getClass ( ) ; kind . getClass ( ) ; if ( uri . getPath ( ) == null ) throw new IllegalArgumentException ( STR_ + uri ) ; this . uri = uri ; this . kind = kind ; }
public int increment ( int val ) { if ( val < NUM_ ) { return decrement ( - val ) ; } lock . lock ( ) ; int newValue = ( value += val ) ; lock . unlock ( ) ; return newValue ; }
protected void releaseInternal ( ) { ContextTranslator . pts_1cfa_map = null ; ContextTranslator . objs_1cfa_map = null ; }
public static void addConstraintViolationsRDF ( List < ConstraintViolation > cvs , Model result , boolean createSource ) { for ( ConstraintViolation cv : cvs ) { Resource r = result . createResource ( SPIN . ConstraintViolation ) ; String message = cv . getMessage ( ) ; if ( message != null && message . length ( ) > NUM_ ) { r . addProperty ( RDFS . label , message ) ; } if ( cv . getRoot ( ) != null ) { r . addProperty ( SPIN . violationRoot , cv . getRoot ( ) ) ; } r . addProperty ( SPIN . violationLevel , cv . getLevel ( ) ) ; for ( SimplePropertyPath path : cv . getPaths ( ) ) { if ( path instanceof ObjectPropertyPath ) { r . addProperty ( SPIN . violationPath , path . getPredicate ( ) ) ; } else { Resource p = result . createResource ( SP . ReversePath ) ; p . addProperty ( SP . path , path . getPredicate ( ) ) ; r . addProperty ( SPIN . violationPath , p ) ; } } if ( createSource && cv . getSource ( ) != null ) { r . addProperty ( SPIN . violationSource , cv . getSource ( ) ) ; } if ( cv . getValue ( ) != null ) { r . addProperty ( SPIN . violationValue , cv . getValue ( ) ) ; } } }
public Page copy ( long version ) { Page newPage = create ( map , version , keys , values , children , totalCount , getMemory ( ) ) ; removePage ( ) ; newPage . cachedCompare = cachedCompare ; return newPage ; }
public boolean startBusytone ( final String busytoneUriType ) { if ( busytoneUriType . isEmpty ( ) ) { return BOOL_ ; } try { Log . d ( TAG , STR_ + busytoneUriType ) ; if ( mBusytone != null ) { if ( mBusytone . isPlaying ( ) ) { Log . d ( TAG , STR_ ) ; return BOOL_ ; } else { stopBusytone ( ) ; } } Uri busytoneUri ; Map data = new HashMap < String , Object > ( ) ; data . put ( STR_ , STR_ ) ; if ( busytoneUriType . equals ( STR_ ) ) { mBusytone = new myToneGenerator ( myToneGenerator . BUSY ) ; mBusytone . startPlay ( data ) ; return BOOL_ ; } else { busytoneUri = getBusytoneUri ( busytoneUriType ) ; if ( busytoneUri == null ) { Log . d ( TAG , STR_ ) ; return BOOL_ ; } } mBusytone = new myMediaPlayer ( ) ; data . put ( STR_ , busytoneUri ) ; data . put ( STR_ , BOOL_ ) ; data . put ( STR_ , AudioManager . STREAM_VOICE_CALL ) ; setMediaPlayerEvents ( ( MediaPlayer ) mBusytone , STR_ ) ; mBusytone . startPlay ( data ) ; return BOOL_ ; } catch ( Exception e ) { Log . d ( TAG , STR_ ) ; Log . d ( TAG , e . getMessage ( ) ) ; return BOOL_ ; } }
private String moveToFolder ( final String file , final String folder ) { final File source = new File ( file ) ; final File destination = new File ( folder + File . separator + source . getName ( ) ) ; Log . i ( TAG , file + STR_ + destination . getAbsolutePath ( ) ) ; try { FileUtils . moveFile ( source , destination ) ; } catch ( final IOException e ) { Log . e ( TAG , STR_ ) ; } return destination . getAbsolutePath ( ) ; }
public void putAll ( Map m ) { Set keys = m . keySet ( ) ; for ( Iterator iter = keys . iterator ( ) ; iter . hasNext ( ) ; ) { Object key = iter . next ( ) ; put ( key , m . get ( key ) ) ; } }
public void readOldFormat ( Reader reader ) throws Exception { StreamTokenizer tokenizer ; int currentToken ; double firstIndex , secondIndex , weight ; tokenizer = new StreamTokenizer ( reader ) ; initialize ( ) ; tokenizer . commentChar ( STR_ ) ; tokenizer . eolIsSignificant ( BOOL_ ) ; while ( StreamTokenizer . TT_EOF != ( currentToken = tokenizer . nextToken ( ) ) ) { if ( currentToken == StreamTokenizer . TT_EOL ) { continue ; } if ( currentToken != StreamTokenizer . TT_NUMBER ) { throw new Exception ( STR_ + STR_ ) ; } firstIndex = tokenizer . nval ; if ( ! Utils . eq ( ( int ) firstIndex , firstIndex ) ) { throw new Exception ( STR_ + STR_ ) ; } if ( ( int ) firstIndex >= size ( ) ) { throw new Exception ( STR_ ) ; } if ( StreamTokenizer . TT_EOF == ( currentToken = tokenizer . nextToken ( ) ) ) { throw new Exception ( STR_ ) ; } if ( currentToken == StreamTokenizer . TT_EOL ) { throw new Exception ( STR_ ) ; } if ( currentToken != StreamTokenizer . TT_NUMBER ) { throw new Exception ( STR_ + STR_ ) ; } secondIndex = tokenizer . nval ; if ( ! Utils . eq ( ( int ) secondIndex , secondIndex ) ) { throw new Exception ( STR_ + STR_ ) ; } if ( ( int ) secondIndex >= size ( ) ) { throw new Exception ( STR_ ) ; } if ( ( int ) secondIndex == ( int ) firstIndex ) { throw new Exception ( STR_ ) ; } if ( StreamTokenizer . TT_EOF == ( currentToken = tokenizer . nextToken ( ) ) ) { throw new Exception ( STR_ ) ; } if ( currentToken == StreamTokenizer . TT_EOL ) { throw new Exception ( STR_ ) ; } if ( currentToken != StreamTokenizer . TT_NUMBER ) { throw new Exception ( STR_ + STR_ ) ; } weight = tokenizer . nval ; if ( ! Utils . gr ( weight , NUM_ ) ) { throw new Exception ( STR_ ) ; } setCell ( ( int ) firstIndex , ( int ) secondIndex , new Double ( weight ) ) ; } }
protected String handleDate ( ResultSet rs , int columnIndex , String dateFormatString ) throws SQLException { java . sql . Date date = rs . getDate ( columnIndex ) ; String value = null ; if ( date != null ) { SimpleDateFormat dateFormat = new SimpleDateFormat ( dateFormatString ) ; value = dateFormat . format ( date ) ; } return value ; }
@ Override public RandomAccessStream openFileRandomAccess ( ) throws IOException { if ( _isWindows && isAux ( ) ) throw new FileNotFoundException ( _file . toString ( ) ) ; return new FileRandomAccessStream ( new RandomAccessFile ( getFile ( ) , STR_ ) ) ; }
public QDate ( TimeZone zone , long now ) { _timeZone = zone ; if ( zone == _gmtTimeZone ) { _stdName = _gmtStdName ; _dstName = _gmtDstName ; } else if ( zone == _localTimeZone ) { _stdName = _localStdName ; _dstName = _localDstName ; } else { _stdName = _timeZone . getDisplayName ( BOOL_ , TimeZone . SHORT ) ; _dstName = _timeZone . getDisplayName ( BOOL_ , TimeZone . SHORT ) ; } _calendar = new GregorianCalendar ( _timeZone ) ; if ( zone == _gmtTimeZone ) setGMTTime ( now ) ; else setLocalTime ( now ) ; }
public static void serialize ( Serializable obj , ByteArrayOutputStream bout ) { try { ObjectOutputStream out = new ObjectOutputStream ( bout ) ; out . writeObject ( obj ) ; out . close ( ) ; } catch ( IOException e ) { throw new IllegalStateException ( STR_ + obj , e ) ; } }
private static void decodeEdifactSegment ( BitSource bits , StringBuilder result ) { do { if ( bits . available ( ) <= NUM_ ) { return ; } for ( int i = NUM_ ; i < NUM_ ; i ++ ) { int edifactValue = bits . readBits ( NUM_ ) ; if ( edifactValue == x1F ) { int bitsLeft = NUM_ - bits . getBitOffset ( ) ; if ( bitsLeft != NUM_ ) { bits . readBits ( bitsLeft ) ; } return ; } if ( ( edifactValue & x20 ) == NUM_ ) { edifactValue |= x40 ; } result . append ( ( char ) edifactValue ) ; } } while ( bits . available ( ) > NUM_ ) ; }
public static Stream < String > wordsOf ( String text ) { requireNonNull ( text ) ; return WORDS . splitAsStream ( text ) ; }
public static String upper ( String s ) { return s . toUpperCase ( Locale . ENGLISH ) ; }
private void accept ( Socket socket ) { log . info ( STR_ , socket . getInetAddress ( ) ) ; try { InetAddress serverAddress = dns . getAddress ( STR_ ) ; try ( Connection clientConnection = new Connection ( socket ) ; Connection serverConnection = new Connection ( new Socket ( serverAddress , CLASH_PORT ) ) ) { ProxySession session = ProxySession . newSession ( services . getMessageFactory ( ) , clientConnection , serverConnection , filterChain ) ; log . info ( STR_ , socket ) ; VillageAnalyzer . logSession ( session ) ; } } catch ( IOException e ) { log . info ( STR_ , socket . getInetAddress ( ) , e . toString ( ) ) ; } finally { try { socket . close ( ) ; } catch ( IOException e ) { } } }
public void removeProcessListener ( ProcessListener l ) { listenerList . remove ( l ) ; }
public final static boolean isValidJavaIdentifier ( String s ) { if ( s == null || s . length ( ) == NUM_ ) { return BOOL_ ; } char [ ] c = s . toCharArray ( ) ; if ( ! Character . isJavaIdentifierStart ( c [ NUM_ ] ) ) { return BOOL_ ; } for ( int i = NUM_ ; i < c . length ; i ++ ) { if ( ! Character . isJavaIdentifierPart ( c [ i ] ) ) { return BOOL_ ; } } return BOOL_ ; }
final void sendHelp ( ) { ArrayList < String > help = help ( ) ; if ( help . isEmpty ( ) ) { return ; } XmppMsg msg = new XmppMsg ( ) ; msg . addStringArray ( help . toArray ( new String [ help . size ( ) ] ) ) ; send ( msg ) ; }
protected void init ( ) { LOG . info ( STR_ ) ; long startTime = System . currentTimeMillis ( ) ; bughouseSoundKeys = getSoundsKeys ( STR_ ) ; soundKeys = getSoundsKeys ( STR_ ) ; initSoundPlayer ( ) ; initSpeech ( ) ; LOG . info ( STR_ + ( System . currentTimeMillis ( ) - startTime ) + STR_ ) ; }
private static void runConfClient ( final ProcessBuilder pb ) throws Exception { int exitCode = - NUM_ ; try { Process process = pb . start ( ) ; exitCode = process . waitFor ( ) ; } catch ( IOException e ) { log . error ( STR_ , e ) ; exitCode = NUM_ ; throw e ; } catch ( Exception e ) { log . error ( STR_ , e ) ; throw e ; } switch ( exitCode ) { case SUCCESS : break ; case ERROR_CODE_CANNOT_DOWNLOAD_CONF : throw new Exception ( STR_ + exitCode + STR_ ) ; case ERROR_CODE_EXPIRED_CONF : throw new Exception ( STR_ + exitCode + STR_ ) ; case ERROR_CODE_INVALID_SIGNATURE_VALUE : throw new Exception ( STR_ + exitCode + STR_ ) ; case ERROR_CODE_INTERNAL : throw new Exception ( STR_ + exitCode + STR_ ) ; default : throw new Exception ( STR_ + STR_ + exitCode + STR_ + STR_ + STR_ ) ; } }
protected final void acceptAnnotations ( final MethodVisitor mv ) { int n = visibleTypeAnnotations == null ? NUM_ : visibleTypeAnnotations . size ( ) ; for ( int i = NUM_ ; i < n ; ++ i ) { TypeAnnotationNode an = visibleTypeAnnotations . get ( i ) ; an . accept ( mv . visitInsnAnnotation ( an . typeRef , an . typePath , an . desc , BOOL_ ) ) ; } n = invisibleTypeAnnotations == null ? NUM_ : invisibleTypeAnnotations . size ( ) ; for ( int i = NUM_ ; i < n ; ++ i ) { TypeAnnotationNode an = invisibleTypeAnnotations . get ( i ) ; an . accept ( mv . visitInsnAnnotation ( an . typeRef , an . typePath , an . desc , BOOL_ ) ) ; } }
public boolean doCheckSiteStatus ( URL url ) { if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + url ) ; } URLChecker checker = getURLChecker ( url ) ; if ( checker != null && ( checker . getStatus ( ) == URLStatus . STATUS_UNKNOWN ) ) { synchronized ( checker ) { checker . cancel ( ) ; checker . notify ( ) ; } synchronized ( urlCheckers ) { urlCheckers . remove ( getThreadName ( url ) ) ; } debug . error ( STR_ + STR_ + getThreadName ( url ) ) ; return BOOL_ ; } else if ( ( checker != null ) && ( checker . getStatus ( ) == URLStatus . STATUS_AVAILABLE ) ) { return BOOL_ ; } else { return BOOL_ ; } }
protected void fill ( ) throws IOException { ensureOpen ( ) ; len = in . read ( buf , NUM_ , buf . length ) ; if ( len == - NUM_ ) { throw new EOFException ( STR_ ) ; } inf . setInput ( buf , NUM_ , len ) ; }
@ Ignore ( STR_ ) @ Test public void testP2PViewChangeReject ( ) throws Exception { final Host host = Host . getHost ( NUM_ ) ; final VM peer2 = host . getVM ( NUM_ ) ; final VM peer3 = host . getVM ( NUM_ ) ; CredentialGenerator gen = new LdapUserCredentialGenerator ( ) ; gen . init ( ) ; Properties extraProps = gen . getSystemProperties ( ) ; String authenticator = gen . getAuthenticator ( ) ; String authInit = gen . getAuthInit ( ) ; if ( extraProps == null ) { extraProps = new Properties ( ) ; } CredentialGenerator gen2 = new DummyCredentialGenerator ( ) ; gen2 . init ( ) ; Properties extraProps2 = gen2 . getSystemProperties ( ) ; String authenticator2 = gen2 . getAuthenticator ( ) ; if ( extraProps2 == null ) { extraProps2 = new Properties ( ) ; } Properties props = new Properties ( ) ; int port = getRandomAvailablePort ( SOCKET ) ; final String locators = getIPLiteral ( ) + STR_ + port + STR_ ; props . setProperty ( SECURITY_PEER_AUTH_INIT , authInit ) ; props . setProperty ( SECURITY_PEER_AUTHENTICATOR , authenticator ) ; Properties credentials = gen . getValidCredentials ( NUM_ ) ; Properties javaProps = gen . getJavaProperties ( ) ; props . putAll ( credentials ) ; props . putAll ( extraProps ) ; startTheLocator ( props , javaProps , port ) ; try { props = new Properties ( ) ; props . setProperty ( MCAST_PORT , STR_ ) ; props . setProperty ( LOCATORS , locators ) ; props . setProperty ( SECURITY_PEER_AUTH_INIT , authInit ) ; props . setProperty ( SECURITY_PEER_AUTHENTICATOR , authenticator2 ) ; credentials = gen . getValidCredentials ( NUM_ ) ; Properties javaProps2 = gen2 . getJavaProperties ( ) ; props . putAll ( credentials ) ; props . putAll ( extraProps2 ) ; createDS ( props , javaProps2 ) ; props = new Properties ( ) ; props . setProperty ( MCAST_PORT , STR_ ) ; props . setProperty ( LOCATORS , locators ) ; props . setProperty ( SECURITY_PEER_AUTH_INIT , authInit ) ; props . setProperty ( SECURITY_PEER_AUTHENTICATOR , authenticator ) ; credentials = gen . getValidCredentials ( NUM_ ) ; javaProps = gen . getJavaProperties ( ) ; props . putAll ( credentials ) ; props . putAll ( extraProps ) ; createDS ( peer2 , props , javaProps ) ; createDS ( peer3 , props , javaProps ) ; pause ( NUM_ ) ; locatorVM . invoke ( null ) ; verifyMembers ( NUM_ ) ; peer2 . invoke ( null ) ; peer3 . invoke ( null ) ; disconnectFromDS ( ) ; pause ( NUM_ ) ; locatorVM . invoke ( null ) ; peer2 . invoke ( null ) ; peer3 . invoke ( null ) ; peer2 . invoke ( null ) ; pause ( NUM_ ) ; locatorVM . invoke ( null ) ; peer3 . invoke ( null ) ; peer3 . invoke ( null ) ; pause ( NUM_ ) ; locatorVM . invoke ( null ) ; } finally { locatorVM . invoke ( null ) ; } }
private boolean overrides ( ExecutableElement e , Class < ? > clazz , String method ) { TypeElement clazzElt = elements . getTypeElement ( clazz . getCanonicalName ( ) ) ; assert clazzElt != null ; for ( ExecutableElement elt : ElementFilter . methodsIn ( clazzElt . getEnclosedElements ( ) ) ) { if ( elt . getSimpleName ( ) . contentEquals ( method ) && elements . overrides ( e , elt , clazzElt ) ) { return BOOL_ ; } } return BOOL_ ; }
public Element signXML ( Document doc , String certAlias , String algorithm , String idAttrName , String id , boolean includeCert , String xpath ) throws XMLSignatureException { return signXMLUsingKeyPass ( doc , certAlias , null , algorithm , idAttrName , id , includeCert , xpath ) ; }
public int size ( ) { return attrs . size ( ) ; }
protected Socket __openPassiveDataConnection ( int command , String arg ) throws IOException , FtpExceptionCanNotHaveDataConnection { Socket socket ; if ( pasv ( ) != FTPReply . ENTERING_PASSIVE_MODE ) throw new FtpExceptionCanNotHaveDataConnection ( STR_ + getReplyString ( ) ) ; try { __parsePassiveModeReply ( getReplyStrings ( ) [ NUM_ ] ) ; } catch ( MalformedServerReplyException e ) { throw new FtpExceptionCanNotHaveDataConnection ( e . getMessage ( ) ) ; } socket = _socketFactory_ . createSocket ( __passiveHost , __passivePort ) ; if ( ! FTPReply . isPositivePreliminary ( sendCommand ( command , arg ) ) ) { socket . close ( ) ; return null ; } if ( __remoteVerificationEnabled && ! verifyRemote ( socket ) ) { InetAddress host1 , host2 ; host1 = socket . getInetAddress ( ) ; host2 = getRemoteAddress ( ) ; socket . close ( ) ; throw new FtpExceptionCanNotHaveDataConnection ( STR_ + host1 . getHostAddress ( ) + STR_ + host2 . getHostAddress ( ) + STR_ ) ; } if ( __dataTimeout >= NUM_ ) socket . setSoTimeout ( __dataTimeout ) ; return socket ; }
public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { Monitor mon = null ; if ( params . isInterfaceEnabled && params . isEnabled ) { mon = MonitorFactory . start ( labelerInt . getSummaryLabel ( method ) ) ; } try { if ( method . equals ( EQUALS_METHOD ) ) return Boolean . valueOf ( equals ( args [ NUM_ ] ) ) ; else return method . invoke ( monitoredObj , args ) ; } catch ( InvocationTargetException e ) { if ( params . isEnabled ) { String sqlMessage = STR_ ; String detailStackTrace = null ; Throwable rootCause = e . getCause ( ) ; if ( rootCause instanceof SQLException ) { SQLException sqlException = ( SQLException ) rootCause ; sqlMessage = STR_ + sqlException . getErrorCode ( ) + STR_ + sqlException . getSQLState ( ) ; } trackException ( rootCause , method , sqlMessage ) ; } throw e . getCause ( ) ; } finally { if ( mon != null ) mon . stop ( ) ; } }
public static void copyStream ( final InputStream fromStream , final OutputStream toStream ) throws IOException { byte [ ] buffer = new byte [ NUM_ ] ; int bytesRead ; while ( ( bytesRead = fromStream . read ( buffer ) ) != - NUM_ ) { toStream . write ( buffer , NUM_ , bytesRead ) ; } }
public static int probRound ( double value , Random rand ) { if ( value >= NUM_ ) { double lower = Math . floor ( value ) ; double prob = value - lower ; if ( rand . nextDouble ( ) < prob ) { return ( int ) lower + NUM_ ; } else { return ( int ) lower ; } } else { double lower = Math . floor ( Math . abs ( value ) ) ; double prob = Math . abs ( value ) - lower ; if ( rand . nextDouble ( ) < prob ) { return - ( ( int ) lower + NUM_ ) ; } else { return - ( int ) lower ; } } }
private void loadStringValue ( JTextField comp , final String elementName ) { String propValue = properties . getValue ( elementName ) ; if ( propValue != null && ! propValue . isEmpty ( ) ) { comp . setText ( propValue ) ; } }
public static Ed25519GroupElement toRepresentation ( final Ed25519GroupElement g , final CoordinateSystem newCoordinateSystem ) { final BigInteger x ; final BigInteger y ; final BigInteger gX = toBigInteger ( g . getX ( ) . encode ( ) ) ; final BigInteger gY = toBigInteger ( g . getY ( ) . encode ( ) ) ; final BigInteger gZ = toBigInteger ( g . getZ ( ) . encode ( ) ) ; final BigInteger gT = null == g . getT ( ) ? null : toBigInteger ( g . getT ( ) . encode ( ) ) ; switch ( g . getCoordinateSystem ( ) ) { case AFFINE : x = gX ; y = gY ; break ; case P2 : case P3 : x = gX . multiply ( gZ . modInverse ( Ed25519Field . P ) ) . mod ( Ed25519Field . P ) ; y = gY . multiply ( gZ . modInverse ( Ed25519Field . P ) ) . mod ( Ed25519Field . P ) ; break ; case P1xP1 : x = gX . multiply ( gZ . modInverse ( Ed25519Field . P ) ) . mod ( Ed25519Field . P ) ; assert gT != null ; y = gY . multiply ( gT . modInverse ( Ed25519Field . P ) ) . mod ( Ed25519Field . P ) ; break ; case CACHED : x = gX . subtract ( gY ) . multiply ( gZ . multiply ( new BigInteger ( STR_ ) ) . modInverse ( Ed25519Field . P ) ) . mod ( Ed25519Field . P ) ; y = gX . add ( gY ) . multiply ( gZ . multiply ( new BigInteger ( STR_ ) ) . modInverse ( Ed25519Field . P ) ) . mod ( Ed25519Field . P ) ; break ; case PRECOMPUTED : x = gX . subtract ( gY ) . multiply ( new BigInteger ( STR_ ) . modInverse ( Ed25519Field . P ) ) . mod ( Ed25519Field . P ) ; y = gX . add ( gY ) . multiply ( new BigInteger ( STR_ ) . modInverse ( Ed25519Field . P ) ) . mod ( Ed25519Field . P ) ; break ; default : throw new UnsupportedOperationException ( ) ; } switch ( newCoordinateSystem ) { case AFFINE : return Ed25519GroupElement . affine ( toFieldElement ( x ) , toFieldElement ( y ) , Ed25519Field . ONE ) ; case P2 : return Ed25519GroupElement . p2 ( toFieldElement ( x ) , toFieldElement ( y ) , Ed25519Field . ONE ) ; case P3 : return Ed25519GroupElement . p3 ( toFieldElement ( x ) , toFieldElement ( y ) , Ed25519Field . ONE , toFieldElement ( x . multiply ( y ) . mod ( Ed25519Field . P ) ) ) ; case P1xP1 : return Ed25519GroupElement . p1xp1 ( toFieldElement ( x ) , toFieldElement ( y ) , Ed25519Field . ONE , Ed25519Field . ONE ) ; case CACHED : return Ed25519GroupElement . cached ( toFieldElement ( y . add ( x ) . mod ( Ed25519Field . P ) ) , toFieldElement ( y . subtract ( x ) . mod ( Ed25519Field . P ) ) , Ed25519Field . ONE , toFieldElement ( D . multiply ( new BigInteger ( STR_ ) ) . multiply ( x ) . multiply ( y ) . mod ( Ed25519Field . P ) ) ) ; case PRECOMPUTED : return Ed25519GroupElement . precomputed ( toFieldElement ( y . add ( x ) . mod ( Ed25519Field . P ) ) , toFieldElement ( y . subtract ( x ) . mod ( Ed25519Field . P ) ) , toFieldElement ( D . multiply ( new BigInteger ( STR_ ) ) . multiply ( x ) . multiply ( y ) . mod ( Ed25519Field . P ) ) ) ; default : throw new UnsupportedOperationException ( ) ; } }
private void endFormals ( ) { if ( hasFormals ) { hasFormals = BOOL_ ; buf . append ( STR_ ) ; } }
public Builder label ( char label ) { this . label = Character . toUpperCase ( label ) ; return this ; }
public static boolean isLetterOrDigit ( char c ) { return Character . isLetterOrDigit ( c ) ; }
public static int putLong ( byte [ ] bytes , int offset , long val ) { if ( littleEndian ) { val = Long . reverseBytes ( val ) ; } theUnsafe . putLong ( bytes , offset + BYTE_ARRAY_BASE_OFFSET , val ) ; return offset + Bytes . SIZEOF_LONG ; }
private Instruction scheduleScalarDefsEarly ( Enumeration < Operand > e , Instruction earlyPos , Instruction inst ) { while ( e . hasMoreElements ( ) ) { Operand op = e . nextElement ( ) ; Instruction def = definingInstruction ( op ) ; scheduleEarly ( def ) ; if ( def . isBranch ( ) ) def = dominanceSuccessor ( def , inst ) ; earlyPos = maxDominatorDepth ( def , earlyPos ) ; } return earlyPos ; }
public void makeUnique ( String [ ] columns , String conflictPolicy ) { uniques . add ( CONSTRAINT_UNIQUE_ + TextUtils . join ( STR_ , columns ) + _UNIQUE__ + TextUtils . join ( STR_ , columns ) + __ON_CONFLICT_ + conflictPolicy + COMMA ) ; }
default < T > void forEachMatchingFieldNameWithBoolean ( String regex , BiConsumer < String , Boolean > function ) { forEachMatchingFieldNameWithBoolean ( Pattern . compile ( regex ) , NUM_ , function ) ; }
protected boolean isValidDomain ( String domain ) { Matcher ipDomainMatcher = IP_DOMAIN_PATTERN . matcher ( domain ) ; if ( ipDomainMatcher . matches ( ) ) { InetAddressValidator inetAddressValidator = InetAddressValidator . getInstance ( ) ; return inetAddressValidator . isValid ( ipDomainMatcher . group ( NUM_ ) ) ; } DomainValidator domainValidator = DomainValidator . getInstance ( allowLocal ) ; return domainValidator . isValid ( domain ) || domainValidator . isValidTld ( domain ) ; }
public void exit ( ) { cancel ( ) ; final float radius = lerp ( NUM_ , mOuterRadius , mTweenRadius ) ; final float remaining ; if ( mAnimRadius != null && mAnimRadius . isRunning ( ) ) { remaining = mOuterRadius - radius ; } else { remaining = mOuterRadius ; } final int radiusDuration = ( int ) ( NUM_ . Math . sqrt ( remaining / ( WAVE_TOUCH_UP_ACCELERATION + WAVE_TOUCH_DOWN_ACCELERATION ) . mDensity ) + NUM_ ) ; final int opacityDuration = ( int ) ( NUM_ . mOpacity / WAVE_OPACITY_DECAY_VELOCITY + NUM_ ) ; exitSoftware ( radiusDuration , opacityDuration ) ; }
public void testSealedObject2 ( ) throws Exception { try { new SealedObject ( null ) { } ; fail ( STR_ + STR_ ) ; } catch ( NullPointerException e ) { } String secret = STR_ ; Cipher cipher = new NullCipher ( ) ; SealedObject so1 = new SealedObject ( secret , cipher ) ; SealedObject so2 = new SealedObject ( so1 ) { } ; assertEquals ( STR_ + STR_ , secret , so2 . getObject ( cipher ) ) ; assertEquals ( STR_ + STR_ + STR_ , so1 . getAlgorithm ( ) , so2 . getAlgorithm ( ) ) ; }
@ Override public void handleRequestBody ( SolrQueryRequest req , SolrQueryResponse rsp ) throws ParseException , IOException , SyntaxError { String deletionQuery = getDeletionQuery ( ) ; LOGGER . info ( STR_ , deletionQuery ) ; if ( olderDocumentsExists ( deletionQuery , req , rsp ) ) { UpdateRequestProcessor processor = getProcessor ( req , rsp ) ; deleteOldDocuments ( deletionQuery , processor , req ) ; commitDeletions ( processor , req ) ; } }
public < V extends Comparable < ? super V > > OptionalLong maxBy ( LongFunction < V > keyExtractor ) { ObjLongBox < V > result = collect ( null , null , null ) ; return result . a == null ? OptionalLong . empty ( ) : OptionalLong . of ( result . b ) ; }
public void queryAndCompareShards ( SolrParams params ) throws Exception { updateMappingsFromZk ( jettys , clients ) ; List < String > shards = new ArrayList < > ( shardToJetty . keySet ( ) ) ; for ( String shard : shards ) { queryAndCompareReplicas ( params , shard ) ; } }
public int indexOf ( int ch ) { return indexOf ( ch , NUM_ ) ; }
private Watcher initWatcher ( SolrZkClient zkClient ) { wrappedWatcher = new BufferStateWatcher ( ) ; return zkClient . wrapWatcher ( wrappedWatcher ) ; }
public Configuration ( ) { super ( ) ; }
public static < K , V > Map < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 , K k5 , V v5 , K k6 , V v6 , K k7 , V v7 ) { Map map = of ( ) ; map . put ( k1 , v1 ) ; map . put ( k2 , v2 ) ; map . put ( k3 , v3 ) ; map . put ( k4 , v4 ) ; map . put ( k5 , v5 ) ; map . put ( k6 , v6 ) ; map . put ( k7 , v7 ) ; return map ; }
public long longAt ( int index ) { lb . position ( index ) ; return lb . get ( ) ; }
private String startSetToString ( ) { StringBuffer FString = new StringBuffer ( ) ; boolean didPrint ; if ( m_starting == null ) { return getStartSet ( ) ; } for ( int i = NUM_ ; i < m_starting . length ; i ++ ) { didPrint = BOOL_ ; if ( ( m_hasClass == BOOL_ ) || ( m_hasClass == BOOL_ && i != m_classIndex ) ) { FString . append ( ( m_starting [ i ] + NUM_ ) ) ; didPrint = BOOL_ ; } if ( i == ( m_starting . length - NUM_ ) ) { FString . append ( STR_ ) ; } else { if ( didPrint ) { FString . append ( STR_ ) ; } } } return FString . toString ( ) ; }
public static String makeTagClassName ( String componentFamily , String rendererType ) { if ( componentFamily == null ) { return null ; } String tagClassName = componentFamily ; if ( rendererType != null ) { if ( ! componentFamily . equals ( rendererType ) ) { tagClassName = tagClassName + rendererType ; } } return tagClassName + STR_ ; }
public void registerService ( String serviceName , boolean createTemplate , boolean activate ) throws AMException , SSOException { if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + serviceName + STR_ + createTemplate + STR_ + activate + STR_ ) ; } dsServices . registerService ( super . token , super . entryDN , serviceName ) ; Set serviceStatus = getAttribute ( SERVICE_STATUS_ATTRIBUTE ) ; if ( ! serviceStatus . equals ( Collections . EMPTY_SET ) ) { Iterator iter = serviceStatus . iterator ( ) ; while ( iter . hasNext ( ) ) { String status = ( String ) iter . next ( ) ; if ( status . equalsIgnoreCase ( serviceName ) ) { Object args [ ] = { serviceName } ; throw new AMException ( AMSDKBundle . getString ( STR_ , args , super . locale ) , STR_ , args ) ; } } } else { serviceStatus = new HashSet ( ) ; } serviceStatus . add ( serviceName ) ; setAttribute ( SERVICE_STATUS_ATTRIBUTE , serviceStatus ) ; try { store ( ) ; } catch ( AMException le ) { try { Set objectClass = getAttribute ( STR_ ) ; if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + objectClass ) ; } if ( ! objectClass . contains ( STR_ ) ) { objectClass . add ( STR_ ) ; setAttribute ( STR_ , objectClass ) ; setAttribute ( SERVICE_STATUS_ATTRIBUTE , serviceStatus ) ; store ( ) ; } else { throw le ; } } catch ( Exception e ) { if ( debug . messageEnabled ( ) ) { debug . message ( STR_ , e ) ; } throw le ; } } if ( createTemplate ) { try { if ( AMServiceUtils . serviceHasSubSchema ( super . token , serviceName , SchemaType . POLICY ) ) { createTemplate ( AMTemplate . POLICY_TEMPLATE , serviceName , null ) ; } if ( AMServiceUtils . serviceHasSubSchema ( super . token , serviceName , SchemaType . DYNAMIC ) ) { createTemplate ( AMTemplate . DYNAMIC_TEMPLATE , serviceName , null ) ; } } catch ( SMSException smsex ) { throw new AMException ( AMSDKBundle . getString ( STR_ , super . locale ) , STR_ ) ; } } }
public static void assertAlmostEquals ( double expected , double actual , int decimals ) { assertAlmostEquals ( null , new Double ( expected ) , new Double ( actual ) , decimals ) ; }
private static int snapVertical ( Collection < ConstraintWidget > widgets , ConstraintWidget widget , ConstraintAnchor anchor , int position , ArrayList < SnapCandidate > snapCandidates ) { SnapCandidate candidate = new SnapCandidate ( ) ; ConstraintHandle handle = WidgetInteractionTargets . constraintHandle ( anchor ) ; if ( handle == null ) { return position ; } handle . setDrawY ( position ) ; SnapPlacement . snapAnchor ( widgets , widget , anchor , candidate ) ; if ( candidate . target != null ) { ConstraintHandle targetHandle = WidgetInteractionTargets . constraintHandle ( candidate . target ) ; int ty = candidate . y ; if ( targetHandle != null ) { ty = targetHandle . getDrawY ( ) ; } position = ty + candidate . margin ; snapCandidates . add ( candidate ) ; } return position ; }
public int send ( OutputStream out ) throws IOException { out . write ( this . fileBuff , this . offset , this . length ) ; return NUM_ ; }
private double sin ( double angle ) { while ( angle >= NUM_ ) { angle -= NUM_ ; } double value = ( angle / NUM_ . Math . PI ) ; return Math . sin ( value ) ; }
public static String last ( String list , String delimiter , boolean ignoreEmpty ) { if ( StringUtil . isEmpty ( list ) ) return STR_ ; int len = list . length ( ) ; char [ ] del ; if ( StringUtil . isEmpty ( delimiter ) ) { del = new char [ ] { STR_ } ; } else del = delimiter . toCharArray ( ) ; int index ; int x ; while ( BOOL_ ) { index = - NUM_ ; for ( int i = NUM_ ; i < del . length ; i ++ ) { x = list . lastIndexOf ( del [ i ] ) ; if ( x > index ) index = x ; } if ( index == - NUM_ ) { return list ; } else if ( index + NUM_ == len ) { if ( ! ignoreEmpty ) return STR_ ; list = list . substring ( NUM_ , len - NUM_ ) ; len -- ; } else { return list . substring ( index + NUM_ ) ; } } }
private void tryParseTypeAttribute ( IDOMElement element ) { IDOMAttr typeAttr = ( IDOMAttr ) UiBinderXmlModelUtilities . getTypeAttribute ( element ) ; if ( typeAttr == null ) { return ; } IRegion valueRegion = XmlUtilities . getAttributeValueRegion ( typeAttr ) ; if ( valueRegion == null ) { return ; } String fqType = typeAttr . getNodeValue ( ) ; if ( fqType == null ) { return ; } final IType type = JavaModelSearch . findType ( javaProject , fqType ) ; if ( ! JavaModelSearch . isValidElement ( type ) ) { problemMarkerManager . setTypeUndefinedError ( valueRegion , fqType ) ; } else { if ( UiBinderXmlModelUtilities . isStyleElement ( element ) ) { IType cssResourceType = ClientBundleUtilities . findCssResourceType ( javaProject ) ; if ( cssResourceType != null ) { try { if ( ! JavaUtilities . isSubtype ( cssResourceType , type ) ) { problemMarkerManager . setNotCssResourceSubtypeError ( valueRegion , fqType ) ; } } catch ( JavaModelException e ) { GWTPluginLog . logWarning ( e , STR_ ) ; } } } } javaTypeReferences . add ( fqType ) ; }
private void clearDictionaryCache ( ) { Map < String , Dictionary > dictionaryCaches = surrogateKeyGen . getDictionaryCaches ( ) ; List < Dictionary > reverseDictionaries = new ArrayList < > ( dictionaryCaches . values ( ) ) ; for ( int i = NUM_ ; i < reverseDictionaries . size ( ) ; i ++ ) { Dictionary dictionary = reverseDictionaries . get ( i ) ; dictionary . clear ( ) ; } }
private void pullEvent ( ) { final int newScrollValue ; final int itemDimension ; final float initialMotionValue , lastMotionValue ; switch ( getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : initialMotionValue = mInitialMotionX ; lastMotionValue = mLastMotionX ; break ; case VERTICAL : default : initialMotionValue = mInitialMotionY ; lastMotionValue = mLastMotionY ; break ; } switch ( mCurrentMode ) { case PULL_FROM_END : newScrollValue = Math . round ( Math . max ( initialMotionValue - lastMotionValue , NUM_ ) / FRICTION ) ; itemDimension = getFooterSize ( ) ; break ; case PULL_FROM_START : default : newScrollValue = Math . round ( Math . min ( initialMotionValue - lastMotionValue , NUM_ ) / FRICTION ) ; itemDimension = getHeaderSize ( ) ; break ; } setHeaderScroll ( newScrollValue ) ; if ( newScrollValue != NUM_ && ! isRefreshing ( ) ) { float scale = Math . abs ( newScrollValue ) / ( float ) itemDimension ; switch ( mCurrentMode ) { case PULL_FROM_END : mFooterLayout . onPull ( scale ) ; break ; case PULL_FROM_START : default : mHeaderLayout . onPull ( scale ) ; break ; } if ( mState != State . PULL_TO_REFRESH && itemDimension >= Math . abs ( newScrollValue ) ) { setState ( State . PULL_TO_REFRESH ) ; } else if ( mState == State . PULL_TO_REFRESH && itemDimension < Math . abs ( newScrollValue ) ) { setState ( State . RELEASE_TO_REFRESH ) ; } } }
public static List < MRelationType > retrieveTypes ( final PO po , final int windowId ) { if ( po . get_KeyColumns ( ) . length != NUM_ ) { logger . severe ( po + STR_ + po . get_KeyColumns ( ) . length + STR_ ) ; PORelationException . throwWrongKeyColumnCount ( po ) ; } final String keyColumn = po . get_KeyColumns ( ) [ NUM_ ] ; final int colId = MColumn . getColumn_ID ( po . get_TableName ( ) , keyColumn ) ; final PreparedStatement pstmt = DB . prepareStatement ( SQL , po . get_TrxName ( ) ) ; ResultSet rs = null ; try { pstmt . setInt ( NUM_ , po . get_Table_ID ( ) ) ; pstmt . setInt ( NUM_ , colId ) ; rs = pstmt . executeQuery ( ) ; final List < MRelationType > result = evalResultSet ( po , windowId , rs ) ; logger . info ( STR_ + result . size ( ) + STR_ + po ) ; return result ; } catch ( SQLException e ) { logger . severe ( e . getMessage ( ) ) ; throw new AdempiereException ( e ) ; } finally { DB . close ( rs , pstmt ) ; } }
public JdpJmxPacket ( byte [ ] data ) throws JdpException { JdpPacketReader reader ; reader = new JdpPacketReader ( data ) ; Map < String , String > p = reader . getDiscoveryDataAsMap ( ) ; String sId = p . get ( UUID_KEY ) ; this . id = ( sId == null ) ? null : UUID . fromString ( sId ) ; this . jmxServiceUrl = p . get ( JMX_SERVICE_URL_KEY ) ; this . mainClass = p . get ( MAIN_CLASS_KEY ) ; this . instanceName = p . get ( INSTANCE_NAME_KEY ) ; this . processId = p . get ( PROCESS_ID_KEY ) ; this . rmiHostname = p . get ( RMI_HOSTNAME_KEY ) ; this . broadcastInterval = p . get ( BROADCAST_INTERVAL_KEY ) ; }
private UidRange parseUidRange ( String range ) throws DecodingException { int pos = range . indexOf ( STR_ ) ; try { if ( pos == - NUM_ ) { if ( range . length ( ) == NUM_ && range . charAt ( NUM_ ) == STR_ ) { return new UidRange ( MessageUid . MAX_VALUE ) ; } else { long value = parseUnsignedInteger ( range ) ; return new UidRange ( MessageUid . of ( value ) ) ; } } else { long val1 = parseUnsignedInteger ( range . substring ( NUM_ , pos ) ) ; long val2 = parseUnsignedInteger ( range . substring ( pos + NUM_ ) ) ; if ( val1 == Long . MAX_VALUE && val2 == Long . MAX_VALUE ) { return new UidRange ( MessageUid . MAX_VALUE ) ; } else if ( val1 <= val2 ) { return new UidRange ( MessageUid . of ( val1 ) , MessageUid . of ( val2 ) ) ; } else if ( val1 == Long . MAX_VALUE ) { return new UidRange ( MessageUid . of ( val2 ) , MessageUid . MAX_VALUE ) ; } else { return new UidRange ( MessageUid . of ( val2 ) , MessageUid . of ( val1 ) ) ; } } } catch ( NumberFormatException e ) { throw new DecodingException ( HumanReadableText . INVALID_MESSAGESET , STR_ , e ) ; } }
public void addFXGLListener ( FXGLListener listener ) { systemListeners . add ( listener ) ; }
public void addDefinition ( String definition ) { if ( ! StringUtils . isEmpty ( definition ) ) { definitions . add ( definition ) ; } }
@ Override public void receiveEvent ( ClientStateInformation information ) { if ( information . getState ( ) != currentState ) { logger . info ( STR_ + information ) ; if ( information . getState ( ) == ClientState . SEARCH ) { searchStartTime = System . currentTimeMillis ( ) ; for ( SequenceOutputVariableFactory < ? > factory : sequenceOutputVariableFactories . values ( ) ) { factory . setStartTime ( searchStartTime ) ; } } OutputVariable < Long > time = new OutputVariable < Long > ( STR_ + currentState . getName ( ) , System . currentTimeMillis ( ) - currentStateStarted ) ; outputVariables . put ( time . getName ( ) , time ) ; currentState = information . getState ( ) ; currentStateStarted = System . currentTimeMillis ( ) ; } }
public void testCase11 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int bSign = - NUM_ ; byte rBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . subtract ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( NUM_ , result . signum ( ) ) ; }
public void addBugCode ( BugCode bugCode ) { bugCodeList . add ( bugCode ) ; }
@ Override public final void write ( int b ) { if ( this . ignoreWrites ) return ; checkIfWritable ( ) ; ensureCapacity ( NUM_ ) ; buffer . put ( ( byte ) b ) ; }
public void testNestedAllocationContexts ( ) { final IAllocationContext context = manager . newAllocationContext ( BOOL_ ) ; final String test = STR_ ; final long addr1 = allocate ( manager , context , test ) ; final long addr2 = allocate ( manager , context , test ) ; assertTrue ( addr1 != addr2 ) ; final String res = getString ( addr1 ) ; assertTrue ( res . equals ( test ) ) ; manager . free ( addr1 , context ) ; final long addr3 = allocate ( manager , context , test ) ; assertTrue ( addr1 != addr3 ) ; manager . detachContext ( context ) ; final IAllocationContext context2 = manager . newAllocationContext ( BOOL_ ) ; final long addr4 = allocate ( manager , context2 , test ) ; assertTrue ( addr1 == addr4 ) ; }
public static String underlinesToCamelCase ( String string ) { StringBuilder sb = new StringBuilder ( string . length ( ) ) ; int n = string . length ( ) ; int i = NUM_ ; boolean upcaseNext = BOOL_ ; for ( ; i < n ; i ++ ) { char c = string . charAt ( i ) ; if ( c == STR_ ) { upcaseNext = BOOL_ ; } else { if ( upcaseNext ) { c = Character . toUpperCase ( c ) ; } upcaseNext = BOOL_ ; sb . append ( c ) ; } } return sb . toString ( ) ; }
protected BestMatchFinder ( String pattern ) { searchPattern = pattern . toLowerCase ( ) ; }
public int indexOf ( Object key ) { return key == null ? indexOfNull ( ) : indexOf ( key , key . hashCode ( ) ) ; }
public long nextActionMillis ( long now , long nextRetryTimeMillis ) { for ( FileDownloadInfo info : downloads ) { long individualRetryTimeMillis = getNextActionMillisFor ( now , info ) ; nextRetryTimeMillis = Math . min ( individualRetryTimeMillis , nextRetryTimeMillis ) ; } return nextRetryTimeMillis ; }
private void pop ( final String desc ) { char c = desc . charAt ( NUM_ ) ; if ( c == STR_ ) { pop ( ( Type . getArgumentsAndReturnSizes ( desc ) > > NUM_ ) - NUM_ ) ; } else if ( c == STR_ || c == STR_ ) { pop ( NUM_ ) ; } else { pop ( NUM_ ) ; } }
public Integer countPagesContainingTemplateNames ( List < String > templateNames ) throws WikiApiException { return countFilteredPages ( templateNames , BOOL_ ) ; }
static URL fixPureQueryTargets ( URL base , String target ) throws MalformedURLException { if ( ! target . startsWith ( STR_ ) ) return new URL ( base , target ) ; String basePath = base . getPath ( ) ; String baseRightMost = STR_ ; int baseRightMostIdx = basePath . lastIndexOf ( STR_ ) ; if ( baseRightMostIdx != - NUM_ ) { baseRightMost = basePath . substring ( baseRightMostIdx + NUM_ ) ; } if ( target . startsWith ( STR_ ) ) target = baseRightMost + target ; return new URL ( base , target ) ; }
synchronized void add ( Object obj ) { if ( objList != null ) { objList . add ( obj ) ; } }
public void sort ( ) { Collections . sort ( individuals , PERFORMANCE_COMPARATOR ) ; }
void freeInterval ( SpillLocationInterval i ) { freeIntervals . add ( i ) ; }
private void checkAndWriteDictionaryChunkToFile ( ) throws IOException { if ( oneDictionaryChunkList . size ( ) >= dictionary_one_chunk_size ) { writeDictionaryFile ( ) ; createChunkList ( ) ; } }
private void ctrlSelect ( D nodeData ) { int insertionIndex = getInsertionIndex ( nodeData ) ; insertAndSelectNode ( nodeData , insertionIndex , ! nodeData . equals ( selectedNodes . get ( insertionIndex ) ) ) ; }
private void readObject ( ObjectInputStream ois ) throws IOException , ClassNotFoundException { byte [ ] asn1EncPrincipal = ( byte [ ] ) ois . readObject ( ) ; byte [ ] encRealm = ( byte [ ] ) ois . readObject ( ) ; try { Realm realmObject = new Realm ( new DerValue ( encRealm ) ) ; PrincipalName krb5Principal = new PrincipalName ( new DerValue ( asn1EncPrincipal ) , realmObject ) ; realm = realmObject . toString ( ) ; fullName = krb5Principal . toString ( ) ; nameType = krb5Principal . getNameType ( ) ; } catch ( Exception e ) { throw new IOException ( e ) ; } }
private static int readSwappedInteger ( final DataInputStream input ) throws IOException { final int value1 = input . readByte ( ) ; final int value2 = input . readByte ( ) ; final int value3 = input . readByte ( ) ; final int value4 = input . readByte ( ) ; return ( ( value1 & xff ) << NUM_ ) + ( ( value2 & xff ) << NUM_ ) + ( ( value3 & xff ) << NUM_ ) + ( ( value4 & xff ) << NUM_ ) ; }
private void consumePreNestedScroll ( int dx , int dy , int [ ] consumed ) { if ( mOverScrollEffect == OverScrollEffect . BOUNCE && mUnconsumedOverScrollOffset != NUM_ ) { int destOffset = mUnconsumedOverScrollOffset - dy ; if ( ! MathUtils . sameSign ( destOffset , mUnconsumedOverScrollOffset ) ) { destOffset = NUM_ ; } else if ( Math . abs ( destOffset ) > Math . abs ( mUnconsumedOverScrollOffset ) ) { destOffset = mUnconsumedOverScrollOffset ; } consumed [ NUM_ ] = NUM_ ; consumed [ NUM_ ] = mUnconsumedOverScrollOffset - destOffset ; mUnconsumedOverScrollOffset = destOffset ; setScrollingOffset ( getUnconsumedScrollingOffset ( ) ) ; } }
public StrBuilder replace ( final int startIndex , int endIndex , final String replaceStr ) { endIndex = validateRange ( startIndex , endIndex ) ; final int insertLen = ( replaceStr == null ? NUM_ : replaceStr . length ( ) ) ; replaceImpl ( startIndex , endIndex , endIndex - startIndex , replaceStr , insertLen ) ; return this ; }
public void closeFile ( ) { closeFile ( BOOL_ ) ; }
public boolean isValid ( int value ) { return min <= value && value <= max ; }
public PluginsInfo info ( ) { return info ; }
public void firePropertyChange ( String propertyName , int oldValue , int newValue ) { firePropertyChange ( propertyName , Integer . valueOf ( oldValue ) , Integer . valueOf ( newValue ) ) ; }
static ArrayList < Field > allFields ( final Class < ? > clazz ) { final ArrayList < Field > res = new ArrayList < > ( ) ; Class < ? > cl = clazz ; while ( cl != null ) { final Field [ ] fields = cl . getDeclaredFields ( ) ; Collections . addAll ( res , fields ) ; cl = cl . getSuperclass ( ) ; } return res ; }
private void updateWeatherStates ( ) { boolean changed = temperature . update ( ) ; changed |= rain . update ( ) ; changed |= fog . update ( ) ; changed |= thunder . update ( ) ; if ( changed ) { updateZones ( ) ; } }
public static RenderLoops makeRenderLoops ( SurfaceType src , CompositeType comp , SurfaceType dst ) { RenderLoops loops = new RenderLoops ( ) ; loops . drawLineLoop = DrawLine . locate ( src , comp , dst ) ; loops . fillRectLoop = FillRect . locate ( src , comp , dst ) ; loops . drawRectLoop = DrawRect . locate ( src , comp , dst ) ; loops . drawPolygonsLoop = DrawPolygons . locate ( src , comp , dst ) ; loops . drawPathLoop = DrawPath . locate ( src , comp , dst ) ; loops . fillPathLoop = FillPath . locate ( src , comp , dst ) ; loops . fillSpansLoop = FillSpans . locate ( src , comp , dst ) ; loops . fillParallelogramLoop = FillParallelogram . locate ( src , comp , dst ) ; loops . drawParallelogramLoop = DrawParallelogram . locate ( src , comp , dst ) ; loops . drawGlyphListLoop = DrawGlyphList . locate ( src , comp , dst ) ; loops . drawGlyphListAALoop = DrawGlyphListAA . locate ( src , comp , dst ) ; loops . drawGlyphListLCDLoop = DrawGlyphListLCD . locate ( src , comp , dst ) ; return loops ; }
public void edit ( Object plotCanvas ) { String _label = JOptionPane . showInputDialog ( ( PlotCanvas ) plotCanvas , STR_ , label ) ; if ( _label != null ) { setLegend ( _label ) ; } }
protected boolean excludeFile ( String file ) { if ( excluded == null ) return BOOL_ ; Iterator < String > iter = excluded . iterator ( ) ; while ( iter . hasNext ( ) ) if ( file . endsWith ( iter . next ( ) ) ) return BOOL_ ; return BOOL_ ; }
public Builder deleteUserType ( ) { deleteFields . add ( STR_ ) ; return this ; }
public final static boolean endsWithIgnoreCase ( String str , String end ) { int strLength = str == null ? NUM_ : str . length ( ) ; int endLength = end == null ? NUM_ : end . length ( ) ; if ( endLength > strLength ) return BOOL_ ; for ( int i = NUM_ ; i <= endLength ; i ++ ) { if ( ScannerHelper . toLowerCase ( end . charAt ( endLength - i ) ) != ScannerHelper . toLowerCase ( str . charAt ( strLength - i ) ) ) return BOOL_ ; } return BOOL_ ; }
private void translateMatrixAfterRotate ( int axis , float trans , float prevImageSize , float imageSize , int prevViewSize , int viewSize , int drawableSize ) { if ( imageSize < viewSize ) { m [ axis ] = ( viewSize - ( drawableSize . m [ Matrix . MSCALE_X ] ) ) . NUM_ ; } else if ( trans > NUM_ ) { m [ axis ] = - ( ( imageSize - viewSize ) . NUM_ ) ; } else { float percentage = ( Math . abs ( trans ) + ( NUM_ . prevViewSize ) ) / prevImageSize ; m [ axis ] = - ( ( percentage . imageSize ) - ( viewSize . NUM_ ) ) ; } }
public void write ( int c ) throws IOException { internalOut . write ( c ) ; }
private < T extends ClientRequestResult > Collection < T > executeRequest ( final Collection < Long > ids , final Class < T > clazz , final ClientRequestReportListener reportListener , final String requestQueue ) { LOGGER . debug ( STR_ ) ; ClientRequestImpl < T > clientRequest = new ClientRequestImpl < T > ( clazz ) ; Iterator < Long > it = ids . iterator ( ) ; Collection < Future < Collection < T > > > results = new ArrayList < Future < Collection < T > > > ( ) ; int counter = NUM_ ; while ( it . hasNext ( ) ) { while ( it . hasNext ( ) && counter < maxRequestSize ) { clientRequest . addTagId ( it . next ( ) ) ; counter ++ ; } RequestValuesTask < T > task = new RequestValuesTask < T > ( clientRequest , reportListener , requestQueue ) ; results . add ( executor . submit ( task ) ) ; clientRequest = new ClientRequestImpl < T > ( clazz ) ; counter = NUM_ ; } Collection < T > finalCollection = new ArrayList < T > ( ) ; for ( Future < Collection < T > > result : results ) { try { finalCollection . addAll ( result . get ( ) ) ; } catch ( InterruptedException e ) { LOGGER . error ( STR_ , e ) ; throw new RuntimeException ( e ) ; } catch ( ExecutionException e ) { LOGGER . error ( STR_ , e ) ; throw new RuntimeException ( e ) ; } } LOGGER . debug ( STR_ ) ; return finalCollection ; }
public static Map < String , Integer > classNamesToMapping ( List < String > labels ) { Map < String , Integer > mapping = new HashMap < String , Integer > ( ) ; for ( int i = NUM_ ; i < labels . size ( ) ; i ++ ) { mapping . put ( labels . get ( i ) , i ) ; } return mapping ; }
public static String shortNumber ( int number ) { if ( number >= NUM_ ) { int hundred = number % NUM_ / NUM_ ; if ( hundred != NUM_ ) return String . format ( STR_ , number / NUM_ ) + STR_ ; else return ( number / NUM_ ) + STR_ ; } else return number + STR_ ; }
public static void putUnsignedShort ( ByteBuffer bb , int v ) { bb . putShort ( ( short ) ( v & xffff ) ) ; }
public static String readFileToString ( File f ) throws IOException { StringWriter sw = new StringWriter ( ) ; IO . copyAndCloseBoth ( Common . asReaderUTF8Lenient ( new FileInputStream ( f ) ) , sw ) ; return sw . toString ( ) ; }
public void test_wrap_ByteBuffer$ByteBuffer_05 ( ) { String host = STR_ ; int port = NUM_ ; ByteBuffer bb = ByteBuffer . allocate ( NUM_ ) ; ByteBuffer [ ] bbA = { ByteBuffer . allocate ( NUM_ ) , ByteBuffer . allocate ( NUM_ ) , ByteBuffer . allocate ( NUM_ ) } ; SSLEngine sse = getEngine ( host , port ) ; sse . setUseClientMode ( BOOL_ ) ; try { SSLEngineResult res = sse . wrap ( bbA , bb ) ; assertEquals ( NUM_ , res . bytesConsumed ( ) ) ; assertEquals ( NUM_ , res . bytesProduced ( ) ) ; } catch ( Exception ex ) { fail ( STR_ + ex ) ; } }
private boolean linkLast ( Node < E > node ) { if ( count >= capacity ) return BOOL_ ; Node < E > l = last ; node . prev = l ; last = node ; if ( first == null ) first = node ; else l . next = node ; ++ count ; notEmpty . signal ( ) ; return BOOL_ ; }
public void testTopicDinamicallyIncludedBehavior ( ) throws Exception { startAllBrokers ( ) ; Destination dest = createDestination ( STR_ , BOOL_ ) ; MessageConsumer clientA = createConsumer ( STR_ , dest ) ; MessageConsumer clientB = createConsumer ( STR_ , dest ) ; Thread . sleep ( NUM_ . NUM_ ) ; sendMessages ( STR_ , dest , MESSAGE_COUNT ) ; MessageIdList msgsA = getConsumerMessages ( STR_ , clientA ) ; msgsA . waitForMessagesToArrive ( MESSAGE_COUNT ) ; assertEquals ( MESSAGE_COUNT , msgsA . getMessageCount ( ) ) ; MessageIdList msgsB = getConsumerMessages ( STR_ , clientB ) ; msgsB . waitForMessagesToArrive ( MESSAGE_COUNT ) ; assertEquals ( NUM_ , msgsB . getMessageCount ( ) ) ; }
private File createCaptureFile ( int encodingType , String fileName ) { if ( fileName . isEmpty ( ) ) { fileName = STR_ ; } if ( encodingType == JPEG ) { fileName = fileName + STR_ ; } else if ( encodingType == PNG ) { fileName = fileName + STR_ ; } else { throw new IllegalArgumentException ( STR_ + encodingType ) ; } return new File ( getTempDirectoryPath ( ) , fileName ) ; }
@ Override public void actionPerformed ( ActionEvent e ) { Object o ; o = e . getSource ( ) ; if ( o == m_MenuFileOpen ) { loadFile ( ) ; } else if ( o == m_MenuFileSave ) { saveFile ( ) ; } else if ( o == m_MenuFileSaveAs ) { saveFileAs ( ) ; } else if ( o == m_MenuFileClose ) { closeFile ( ) ; } else if ( o == m_MenuFileCloseAll ) { closeAllFiles ( ) ; } else if ( o == m_MenuFileProperties ) { showProperties ( ) ; } else if ( o == m_MenuFileExit ) { close ( ) ; } else if ( o == m_MenuEditUndo ) { undo ( ) ; } else if ( o == m_MenuEditCopy ) { copyContent ( ) ; } else if ( o == m_MenuEditSearch ) { search ( ) ; } else if ( o == m_MenuEditClearSearch ) { clearSearch ( ) ; } else if ( o == m_MenuEditDeleteAttribute ) { deleteAttribute ( BOOL_ ) ; } else if ( o == m_MenuEditDeleteAttributes ) { deleteAttribute ( BOOL_ ) ; } else if ( o == m_MenuEditRenameAttribute ) { renameAttribute ( ) ; } else if ( o == m_MenuEditAttributeAsClass ) { attributeAsClass ( ) ; } else if ( o == m_MenuEditDeleteInstance ) { deleteInstance ( BOOL_ ) ; } else if ( o == m_MenuEditDeleteInstances ) { deleteInstance ( BOOL_ ) ; } else if ( o == m_MenuEditSortInstances ) { sortInstances ( ) ; } else if ( o == m_MenuViewAttributes ) { showAttributes ( ) ; } else if ( o == m_MenuViewValues ) { showValues ( ) ; } else if ( o == m_MenuViewOptimalColWidths ) { setOptimalColWidths ( ) ; } updateMenu ( ) ; }
public boolean validateToken ( EndpointSpecification endpointSpecification , SecurityToken toBeValidatedToken ) throws SoapSTSConsumerException { STSClient client = getSTSClient ( stsInstanceWsdlUrl , endpointSpecification . serviceQName , endpointSpecification . portQName ) ; client . setTokenType ( STSConstants . STATUS ) ; try { client . validateSecurityToken ( toBeValidatedToken ) ; return BOOL_ ; } catch ( TrustException e ) { return BOOL_ ; } catch ( Exception e ) { throw new SoapSTSConsumerException ( e . getMessage ( ) , e ) ; } }
public static String stripFunctionTags ( String label ) { if ( label . indexOf ( STR_ ) > NUM_ ) return label . substring ( NUM_ , label . indexOf ( STR_ ) ) ; else return label ; }
@ Override public void playNewVideo ( MetaData currentItemMetaData , VideoPlayerView videoPlayerView , String videoUrl ) { if ( SHOW_LOGS ) Logger . v ( TAG , STR_ + videoPlayerView + STR_ + mCurrentPlayer + STR_ + videoPlayerView ) ; mPlayerHandler . pauseQueueProcessing ( TAG ) ; boolean currentPlayerIsActive = mCurrentPlayer == videoPlayerView ; boolean isAlreadyPlayingTheFile = mCurrentPlayer != null && videoUrl . equals ( mCurrentPlayer . getVideoUrlDataSource ( ) ) ; if ( SHOW_LOGS ) Logger . v ( TAG , STR_ + isAlreadyPlayingTheFile ) ; if ( SHOW_LOGS ) Logger . v ( TAG , STR_ + currentPlayerIsActive ) ; if ( currentPlayerIsActive ) { if ( isInPlaybackState ( ) && isAlreadyPlayingTheFile ) { if ( SHOW_LOGS ) Logger . v ( TAG , STR_ + videoPlayerView + STR_ + mCurrentPlayerState ) ; } else { startNewPlayback ( currentItemMetaData , videoPlayerView , videoUrl ) ; } } else { startNewPlayback ( currentItemMetaData , videoPlayerView , videoUrl ) ; } mPlayerHandler . resumeQueueProcessing ( TAG ) ; if ( SHOW_LOGS ) Logger . v ( TAG , STR_ + videoPlayerView + STR_ + videoUrl ) ; }
private void addTraceAndType ( String name ) { if ( tracesType . get ( name ) == null ) { traces . add ( createTrace ( name , TraceType . REAL ) ) ; tracesType . put ( name , TraceType . REAL ) ; } else { traces . add ( createTrace ( name , tracesType . get ( name ) ) ) ; } }
public static boolean isReservedStreamName ( String name ) { return name . startsWith ( STR_ ) ; }
public static VolumeMount [ ] formatOriginalContainerVolumeMount ( LogDraft logDraft ) { List < VolumeMount > volumeMounts = new ArrayList < > ( ) ; int idxSuffix = NUM_ ; for ( LogItemDraft logItemDraft : logDraft . getLogItemDrafts ( ) ) { if ( logItemDraft . isAutoCollect ( ) || logItemDraft . isAutoDelete ( ) ) { VolumeMount volumeMount = new VolumeMount ( ) ; volumeMount . setName ( STR_ + idxSuffix ) ; volumeMount . setMountPath ( LogItemDraft . getLogParentPath ( logItemDraft . getLogPath ( ) ) ) ; volumeMounts . add ( volumeMount ) ; idxSuffix ++ ; } } return volumeMounts . toArray ( new VolumeMount [ ] { } ) ; }
public static double dnorm ( double x ) { return Math . exp ( - x . x / NUM_ ) . PSI ; }
public static long checksumCRC32 ( File file ) throws IOException { CRC32 crc = new CRC32 ( ) ; checksum ( file , crc ) ; return crc . getValue ( ) ; }
private void cmd_annotateDifference ( ) { BigDecimal previousValue , actualValue , difference ; previousValue = ( BigDecimal ) v_previousBalance . getValue ( ) ; actualValue = ( BigDecimal ) v_ActualBalance . getValue ( ) ; difference = actualValue . subtract ( previousValue ) ; MCashBook cashBook = new MCashBook ( p_ctx , p_pos . getC_CashBook_ID ( ) , null ) ; Timestamp today = TimeUtil . getDay ( System . currentTimeMillis ( ) ) ; MCash cash = MCash . get ( p_ctx , cashBook . getC_CashBook_ID ( ) , today , null ) ; if ( cash != null && cash . get_ID ( ) != NUM_ && difference . compareTo ( cash . getStatementDifference ( ) ) != NUM_ ) { MCashLine cl = new MCashLine ( cash ) ; cl . setCashType ( MCashLine . CASHTYPE_Difference ) ; cl . setAmount ( difference ) ; cl . setDescription ( Msg . translate ( p_pos . getCtx ( ) , STR_ ) + previousValue + STR_ + actualValue ) ; cl . saveEx ( ) ; } cash = MCash . get ( p_pos . getCtx ( ) , p_pos . getC_CashBook_ID ( ) , today , null ) ; v_previousBalance . setValue ( cash . getEndingBalance ( ) ) ; v_ActualBalance . setValue ( Env . ZERO ) ; v_difference . setValue ( Env . ZERO ) ; }
public void write ( OutputStream out , java . util . List < Figure > figures ) throws IOException { Rectangle2D . Double drawingRect = null ; for ( Figure f : figures ) { if ( drawingRect == null ) { drawingRect = f . getBounds ( ) ; } else { drawingRect . add ( f . getBounds ( ) ) ; } } AffineTransform tx = new AffineTransform ( ) ; tx . translate ( - Math . min ( NUM_ , drawingRect . x ) , - Math . min ( NUM_ , drawingRect . y ) ) ; write ( out , figures , tx , new Dimension ( ( int ) ( Math . abs ( drawingRect . x ) + drawingRect . width ) , ( int ) ( Math . abs ( drawingRect . y ) + drawingRect . height ) ) ) ; }
FixedAllocator ( final RWStore store , final int size ) { m_diskAddr = NUM_ ; m_store = store ; m_size = size ; m_bitSize = calcBitSize ( BOOL_ , size , cMinAllocation , cModAllocation ) ; allocBlockRange = NUM_ . m_bitSize ; final int numBlocks = NUM_ / ( m_bitSize + NUM_ ) ; m_allocBlocks = new ArrayList < AllocBlock > ( numBlocks ) ; for ( int i = NUM_ ; i < numBlocks ; i ++ ) { m_allocBlocks . add ( new AllocBlock ( NUM_ , m_bitSize , this ) ) ; } m_freeTransients = NUM_ ; m_freeBits = NUM_ . m_bitSize . numBlocks ; }
private void buildGetStorageResponse ( MockCloseableHttpResponse response , URI uri ) throws JAXBException { Pattern pattern = Pattern . compile ( STR_ ) ; Matcher matcher = pattern . matcher ( uri . getPath ( ) ) ; if ( matcher . find ( ) ) { Storage storage = getNewStorage ( matcher . group ( NUM_ ) ) ; response . setEntity ( getHttpEntity ( storage ) ) ; } }
public void assertEquals ( String assertID , String expected , String actual ) { framework . assertEquals ( this , assertID , expected , actual ) ; }
public boolean onPreferenceChange ( Preference preference , Object newValue ) { if ( Boolean . parseBoolean ( SystemProperties . get ( TelephonyProperties . PROPERTY_INECM_MODE ) ) ) { } else { setAirplaneModeOn ( ( Boolean ) newValue ) ; } return BOOL_ ; }
static public Object stringToValue ( String s ) { if ( s . equals ( STR_ ) ) { return s ; } if ( s . equalsIgnoreCase ( STR_ ) ) { return Boolean . TRUE ; } if ( s . equalsIgnoreCase ( STR_ ) ) { return Boolean . FALSE ; } if ( s . equalsIgnoreCase ( STR_ ) ) { return JSONObject . NULL ; } char b = s . charAt ( NUM_ ) ; if ( ( b >= STR_ && b <= STR_ ) || b == STR_ || b == STR_ || b == STR_ ) { if ( b == STR_ && s . length ( ) > NUM_ && ( s . charAt ( NUM_ ) == STR_ || s . charAt ( NUM_ ) == STR_ ) ) { try { return new Integer ( Integer . parseInt ( s . substring ( NUM_ ) , NUM_ ) ) ; } catch ( Exception ignore ) { } } try { if ( s . indexOf ( STR_ ) > - NUM_ || s . indexOf ( STR_ ) > - NUM_ || s . indexOf ( STR_ ) > - NUM_ ) { return Double . valueOf ( s ) ; } else { Long myLong = new Long ( s ) ; if ( myLong . longValue ( ) == myLong . intValue ( ) ) { return new Integer ( myLong . intValue ( ) ) ; } else { return myLong ; } } } catch ( Exception ignore ) { } } return s ; }
public static void writeSingleByte ( OutputStream out , int b ) throws IOException { byte [ ] buffer = new byte [ NUM_ ] ; buffer [ NUM_ ] = ( byte ) ( b & xff ) ; out . write ( buffer ) ; }
private float [ ] calcBorderValues ( ) { float max = Integer . MIN_VALUE ; float min = Integer . MAX_VALUE ; for ( ChartSet set : chartView . data ) { for ( ChartEntry e : set . getEntries ( ) ) { if ( e . getValue ( ) >= max ) max = e . getValue ( ) ; if ( e . getValue ( ) <= min ) min = e . getValue ( ) ; } } return new float [ ] { min , max } ; }
private void parseName ( StringTokenizer st , boolean peer ) { List vals = new ArrayList ( NUM_ ) ; outer : while ( BOOL_ ) { String cls ; do { if ( ! st . hasMoreTokens ( ) ) { break outer ; } cls = st . nextToken ( ) ; } while ( cls . equals ( STR_ ) ) ; if ( ! peer && cls . equalsIgnoreCase ( STR_ ) ) { parseName ( st , BOOL_ ) ; break ; } if ( cls . equals ( STR_ ) ) { if ( peer ) { throw new IllegalArgumentException ( STR_ ) ; } cls = null ; vals = null ; } String nm ; do { if ( ! st . hasMoreTokens ( ) ) { throw new IllegalArgumentException ( STR_ ) ; } nm = st . nextToken ( ) ; } while ( nm . equals ( STR_ ) ) ; if ( ! nm . startsWith ( STR_ ) ) { throw new IllegalArgumentException ( STR_ ) ; } while ( ! nm . endsWith ( STR_ ) ) { if ( ! st . hasMoreTokens ( ) ) { throw new IllegalArgumentException ( STR_ ) ; } nm = nm + st . nextToken ( ) ; } if ( nm . equals ( STR_ ) ) { if ( peer ) { throw new IllegalArgumentException ( STR_ ) ; } if ( cls == null ) { continue ; } nm = null ; } else if ( cls == null ) { throw new IllegalArgumentException ( STR_ ) ; } else { nm = nm . substring ( NUM_ , nm . length ( ) - NUM_ ) ; } if ( vals != null ) { for ( int i = vals . size ( ) ; i > NUM_ ; ) { String onm = ( String ) vals . get ( -- i ) ; String ocls = ( String ) vals . get ( -- i ) ; if ( cls . equals ( ocls ) ) { if ( onm == null || ( onm != null && onm . equals ( nm ) ) ) { continue outer ; } else if ( nm == null ) { vals . remove ( i ) ; vals . remove ( i ) ; } } } vals . add ( cls ) ; vals . add ( nm ) ; } } String [ ] res = null ; if ( vals != null ) { if ( vals . isEmpty ( ) ) { throw new IllegalArgumentException ( STR_ ) ; } res = ( String [ ] ) vals . toArray ( new String [ vals . size ( ) ] ) ; } if ( peer ) { this . peer = res ; } else { this . me = res ; } }
public static Object applyOrCall ( boolean isApply , Context cx , Scriptable scope , Scriptable thisObj , Object [ ] args ) { int L = args . length ; Callable function = getCallable ( thisObj ) ; Scriptable callThis = null ; if ( L != NUM_ ) { callThis = toObjectOrNull ( cx , args [ NUM_ ] ) ; } if ( callThis == null ) { callThis = getTopCallScope ( cx ) ; } Object [ ] callArgs ; if ( isApply ) { callArgs = L <= NUM_ ? ScriptRuntime . emptyArgs : getApplyArguments ( cx , args [ NUM_ ] ) ; } else { if ( L <= NUM_ ) { callArgs = ScriptRuntime . emptyArgs ; } else { callArgs = new Object [ L - NUM_ ] ; System . arraycopy ( args , NUM_ , callArgs , NUM_ , L - NUM_ ) ; } } return function . call ( cx , scope , callThis , callArgs ) ; }
public void increment ( ) { counter . getAndIncrement ( ) ; }
public static void removeAllChildren ( Node node ) { NodeList children = node . getChildNodes ( ) ; for ( int i = NUM_ , length = children . getLength ( ) ; i < length ; i ++ ) { node . removeChild ( children . item ( i ) ) ; } }
private boolean isMineshafterPresent ( ) { try { Class . forName ( STR_ ) ; return BOOL_ ; } catch ( Exception e ) { return BOOL_ ; } }
private boolean linkFirst ( Node < E > node ) { if ( count >= capacity ) return BOOL_ ; Node < E > f = first ; node . next = f ; first = node ; if ( last == null ) last = node ; else f . prev = node ; ++ count ; notEmpty . signal ( ) ; return BOOL_ ; }
protected void deploy ( HttpServletResponse response , String contextPath , String warURL ) throws IOException { String context = contextPath ; boolean error = BOOL_ ; if ( context == null ) { File file = new File ( warURL ) ; String fileName = file . getName ( ) ; if ( fileName . endsWith ( STR_ ) ) { fileName = fileName . substring ( NUM_ , fileName . lastIndexOf ( STR_ ) ) ; } context = STR_ + fileName ; } if ( getContextHandler ( context ) != null ) { sendError ( response , STR_ + context ) ; error = BOOL_ ; } else if ( ! context . startsWith ( STR_ ) ) { sendError ( response , STR_ ) ; error = BOOL_ ; } if ( error ) { return ; } else { File webappDest = new File ( webAppDirectory , context + STR_ ) ; URI uri = null ; try { uri = new URI ( warURL ) ; } catch ( URISyntaxException e ) { sendError ( response , STR_ + warURL ) ; Log . warn ( e ) ; return ; } File webappSource = new File ( uri ) ; FileInputStream fileInputStream = new FileInputStream ( webappSource ) ; FileOutputStream fileOutputStream = new FileOutputStream ( webappDest ) ; int i = fileInputStream . read ( ) ; while ( i != - NUM_ ) { fileOutputStream . write ( i ) ; i = fileInputStream . read ( ) ; } fileInputStream . close ( ) ; fileOutputStream . flush ( ) ; fileOutputStream . close ( ) ; WebAppContext webappcontext = new WebAppContext ( ) ; webappcontext . setContextPath ( context ) ; webappcontext . setWar ( webappDest . getPath ( ) ) ; chc . addHandler ( webappcontext ) ; try { webappcontext . start ( ) ; } catch ( Exception e ) { sendError ( response , STR_ ) ; Log . warn ( e ) ; return ; } } sendMessage ( response , STR_ + contextPath ) ; }
public OutlierResult run ( Relation < V > relation ) { final DBIDs ids = relation . getDBIDs ( ) ; ArrayList < ArrayDBIDs > subspaceIndex = buildOneDimIndexes ( relation ) ; Set < HiCSSubspace > subspaces = calculateSubspaces ( relation , subspaceIndex , rnd . getSingleThreadedRandom ( ) ) ; if ( LOG . isVerbose ( ) ) { LOG . verbose ( STR_ + subspaces . size ( ) ) ; } List < DoubleRelation > results = new ArrayList < > ( ) ; FiniteProgress prog = LOG . isVerbose ( ) ? new FiniteProgress ( STR_ , subspaces . size ( ) , LOG ) : null ; for ( HiCSSubspace dimset : subspaces ) { if ( LOG . isVerbose ( ) ) { LOG . verbose ( STR_ + dimset ) ; } ProxyDatabase pdb = new ProxyDatabase ( ids ) ; pdb . addRelation ( new ProjectedView < > ( relation , new NumericalFeatureSelection < V > ( dimset ) ) ) ; OutlierResult result = outlierAlgorithm . run ( pdb ) ; results . add ( result . getScores ( ) ) ; LOG . incrementProcessed ( prog ) ; } LOG . ensureCompleted ( prog ) ; WritableDoubleDataStore scores = DataStoreUtil . makeDoubleStorage ( relation . getDBIDs ( ) , DataStoreFactory . HINT_STATIC ) ; DoubleMinMax minmax = new DoubleMinMax ( ) ; for ( DBIDIter iditer = relation . iterDBIDs ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { double sum = NUM_ ; for ( DoubleRelation r : results ) { final double s = r . doubleValue ( iditer ) ; if ( ! Double . isNaN ( s ) ) { sum += s ; } } scores . putDouble ( iditer , sum ) ; minmax . put ( sum ) ; } OutlierScoreMeta meta = new BasicOutlierScoreMeta ( minmax . getMin ( ) , minmax . getMax ( ) ) ; DoubleRelation scoreres = new MaterializedDoubleRelation ( STR_ , STR_ , scores , relation . getDBIDs ( ) ) ; return new OutlierResult ( meta , scoreres ) ; }
private void addUnitToExternalQualMap ( final Class < ? extends Annotation > annoClass ) { AnnotationMirror mirror = UnitsRelationsTools . buildAnnoMirrorWithNoPrefix ( processingEnv , annoClass ) ; if ( ! isAliasedAnnotation ( mirror ) ) { String unitClassName = annoClass . getCanonicalName ( ) ; if ( ! externalQualsMap . containsKey ( unitClassName ) ) { externalQualsMap . put ( unitClassName , annoClass ) ; } } else { Class < ? extends Annotation > baseUnitClass = getBaseUnitAnnoClass ( mirror ) ; if ( baseUnitClass != null ) { String baseUnitClassName = baseUnitClass . getCanonicalName ( ) ; if ( ! externalQualsMap . containsKey ( baseUnitClassName ) ) { loadExternalUnit ( baseUnitClassName ) ; } aliasedAnnotation ( mirror ) ; } else { } } addUnitsRelations ( annoClass ) ; }
@ Override protected void onProgressUpdate ( Integer ... values ) { if ( parent != null ) { if ( values [ NUM_ ] == ON_CACHE_END ) { parent . onCacheEnd ( ) ; } else if ( values [ NUM_ ] == ON_CACHE_INTERRUPTED ) { Log . i ( TAG , STR_ ) ; shouldBeStopped = BOOL_ ; parent . onCacheInterrupted ( ) ; } else { parent . onCacheProgress ( taskCount , values [ NUM_ ] ) ; } } }
public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( argNum < NUM_ ) reportWrongNumberArgs ( ) ; }
public double dotProduct ( DoubleVector v ) { return x . v . x + y . v . y + z . v . z ; }
public TemporalOMScalingIcon ( Object id , int renderType , boolean interpolate , ImageIcon ii ) { this ( id , renderType , interpolate , ii . getImage ( ) , NUM_ ) ; setMaxScale ( NUM_ ) ; setMinScale ( NUM_ ) ; }
@ Override public void characters ( char [ ] ch , int start , int length ) throws SAXException { mStringBuilder . append ( ch , start , length ) ; }
public int maxLength ( ) { if ( mIsPaired ) { return ( int ) Math . max ( mLeft . maxLength ( ) , mRight . maxLength ( ) ) ; } else { return ( int ) mSingle . maxLength ( ) ; } }
public boolean equalsIgnoreCase ( StrBuilder other ) { if ( this == other ) { return BOOL_ ; } if ( this . size != other . size ) { return BOOL_ ; } char thisBuf [ ] = this . buffer ; char otherBuf [ ] = other . buffer ; for ( int i = size - NUM_ ; i >= NUM_ ; i -- ) { char c1 = thisBuf [ i ] ; char c2 = otherBuf [ i ] ; if ( c1 != c2 && Character . toUpperCase ( c1 ) != Character . toUpperCase ( c2 ) ) { return BOOL_ ; } } return BOOL_ ; }
public PathParser ( String pathString ) { this . pathString = pathString . toCharArray ( ) ; }
public LuaTable ( Varargs varargs , int firstarg ) { int nskip = firstarg - NUM_ ; int n = Math . max ( varargs . narg ( ) - nskip , NUM_ ) ; presize ( n , NUM_ ) ; set ( N , valueOf ( n ) ) ; for ( int i = NUM_ ; i <= n ; i ++ ) set ( i , varargs . arg ( i + nskip ) ) ; }
public ID3v24Frame ( ByteBuffer byteBuffer , String loggingFilename ) throws InvalidFrameException , InvalidDataTypeException { setLoggingFilename ( loggingFilename ) ; read ( byteBuffer ) ; }
public void disablePan ( BluetoothAdapter adapter ) { if ( mPan == null ) mPan = ( BluetoothPan ) connectProxy ( adapter , BluetoothProfile . PAN ) ; assertNotNull ( mPan ) ; long start = System . currentTimeMillis ( ) ; mPan . setBluetoothTethering ( BOOL_ ) ; long stop = System . currentTimeMillis ( ) ; assertFalse ( mPan . isTetheringOn ( ) ) ; writeOutput ( String . format ( STR_ , ( stop - start ) ) ) ; }
public Frame < V > init ( final Frame < ? extends V > src ) { returnValue = src . returnValue ; System . arraycopy ( src . values , NUM_ , values , NUM_ , values . length ) ; top = src . top ; return this ; }
public boolean ready ( ) throws IOException { if ( _input == null ) throw new IOException ( STR_ ) ; if ( _index == _input . length ( ) ) return BOOL_ ; return BOOL_ ; }
private LinkedList < Diff > diff_compute ( String text1 , String text2 , boolean checklines , long deadline ) { LinkedList < Diff > diffs = new LinkedList < Diff > ( ) ; if ( text1 . length ( ) == NUM_ ) { diffs . add ( new Diff ( Operation . INSERT , text2 ) ) ; return diffs ; } if ( text2 . length ( ) == NUM_ ) { diffs . add ( new Diff ( Operation . DELETE , text1 ) ) ; return diffs ; } String longtext = text1 . length ( ) > text2 . length ( ) ? text1 : text2 ; String shorttext = text1 . length ( ) > text2 . length ( ) ? text2 : text1 ; int i = longtext . indexOf ( shorttext ) ; if ( i != - NUM_ ) { Operation op = ( text1 . length ( ) > text2 . length ( ) ) ? Operation . DELETE : Operation . INSERT ; diffs . add ( new Diff ( op , longtext . substring ( NUM_ , i ) ) ) ; diffs . add ( new Diff ( Operation . EQUAL , shorttext ) ) ; diffs . add ( new Diff ( op , longtext . substring ( i + shorttext . length ( ) ) ) ) ; return diffs ; } if ( shorttext . length ( ) == NUM_ ) { diffs . add ( new Diff ( Operation . DELETE , text1 ) ) ; diffs . add ( new Diff ( Operation . INSERT , text2 ) ) ; return diffs ; } String [ ] hm = diff_halfMatch ( text1 , text2 ) ; if ( hm != null ) { String text1_a = hm [ NUM_ ] ; String text1_b = hm [ NUM_ ] ; String text2_a = hm [ NUM_ ] ; String text2_b = hm [ NUM_ ] ; String mid_common = hm [ NUM_ ] ; LinkedList < Diff > diffs_a = diff_main ( text1_a , text2_a , checklines , deadline ) ; LinkedList < Diff > diffs_b = diff_main ( text1_b , text2_b , checklines , deadline ) ; diffs = diffs_a ; diffs . add ( new Diff ( Operation . EQUAL , mid_common ) ) ; diffs . addAll ( diffs_b ) ; return diffs ; } if ( checklines && text1 . length ( ) > NUM_ && text2 . length ( ) > NUM_ ) { return diff_lineMode ( text1 , text2 , deadline ) ; } return diff_bisect ( text1 , text2 , deadline ) ; }
public static long sizeOfDirectory ( File directory ) { checkDirectory ( directory ) ; final File [ ] files = directory . listFiles ( ) ; if ( files == null ) { return NUM_ ; } long size = NUM_ ; for ( final File file : files ) { try { if ( ! isSymlink ( file ) ) { size += sizeOf ( file ) ; if ( size < NUM_ ) { break ; } } } catch ( IOException ioe ) { } } return size ; }
protected void handleMatch ( T mapping , String lookupPath , ServerWebExchange exchange ) { }
public boolean isUseSSL ( ) { return useSSL ; }
public void start ( ) { if ( ( mProxSensor == null ) || mIsActive ) { return ; } mIsActive = BOOL_ ; mShouldDropEvents = BOOL_ ; mSensorManager . registerListener ( mListener , mProxSensor , SensorManager . SENSOR_DELAY_UI ) ; LogUtils . log ( this , Log . VERBOSE , STR_ , System . currentTimeMillis ( ) ) ; mHandler . postDelayed ( mFilterRunnable , REGISTRATION_EVENT_FILTER_TIMEOUT ) ; }
public void testEntityDeclarations ( ) { assertNotNull ( STR_ , sp ) ; }
private Vector applyCSS ( HTMLElement element , HTMLComponent htmlC , CSSElement [ ] css , Vector nestedSelectors , Vector siblingSelectors ) { String id = element . getAttributeById ( HTMLElement . ATTR_ID ) ; String className = element . getAttributeById ( HTMLElement . ATTR_CLASS ) ; Vector nextNestedSelectors = new Vector ( ) ; Vector nextSiblingSelectors = null ; if ( ! HTMLComponent . PROCESS_HTML_MP1_ONLY ) { nextSiblingSelectors = new Vector ( ) ; } for ( int e = NUM_ ; e < css . length ; e ++ ) { CSSElement currentSelector = css [ e ] ; checkSelector ( currentSelector , element , htmlC , className , id , nextNestedSelectors , nextSiblingSelectors ) ; } if ( nestedSelectors != null ) { for ( Enumeration e = nestedSelectors . elements ( ) ; e . hasMoreElements ( ) ; ) { CSSElement currentSelector = ( CSSElement ) e . nextElement ( ) ; checkSelector ( currentSelector , element , htmlC , className , id , nextNestedSelectors , nextSiblingSelectors ) ; } } if ( ( ! HTMLComponent . PROCESS_HTML_MP1_ONLY ) && ( siblingSelectors != null ) ) { for ( Enumeration e = siblingSelectors . elements ( ) ; e . hasMoreElements ( ) ; ) { CSSElement currentSelector = ( CSSElement ) e . nextElement ( ) ; checkSelector ( currentSelector , element , htmlC , className , id , nextNestedSelectors , nextSiblingSelectors ) ; } } if ( nextNestedSelectors . size ( ) == NUM_ ) { nextNestedSelectors = null ; } if ( ( ! HTMLComponent . PROCESS_HTML_MP1_ONLY ) && ( nextSiblingSelectors . size ( ) == NUM_ ) ) { nextSiblingSelectors = null ; } applyStyleAttribute ( element , htmlC ) ; Vector curSiblingSelectors = null ; for ( int i = NUM_ ; i < element . getNumChildren ( ) ; i ++ ) { HTMLElement child = ( HTMLElement ) element . getChildAt ( i ) ; Vector v = applyCSS ( child , htmlC , css , nextNestedSelectors , curSiblingSelectors ) ; if ( ! child . isTextElement ( ) ) { curSiblingSelectors = v ; } } return nextSiblingSelectors ; }
@ Nullable private TcpDiscoveryNode resolveCoordinator ( @ Nullable Collection < TcpDiscoveryNode > filter ) { synchronized ( mux ) { Collection < TcpDiscoveryNode > excluded = F . concat ( BOOL_ , failedNodes . keySet ( ) , leavingNodes ) ; if ( ! F . isEmpty ( filter ) ) excluded = F . concat ( BOOL_ , excluded , filter ) ; return ring . coordinator ( excluded ) ; } }
public static String [ ] splitc ( String src , String d ) { if ( ( d . length ( ) == NUM_ ) || ( src . length ( ) == NUM_ ) ) { return new String [ ] { src } ; } return splitc ( src , d . toCharArray ( ) ) ; }
public int deflateString2ByteArray ( byte [ ] input , int inputOffset , int inputLength , byte [ ] bytes ) { if ( inputLength >= MIN_SIZE_FOR_DEFLATION ) { deflater . setInput ( input , inputOffset , inputLength ) ; deflater . finish ( ) ; int compressedDataLength = deflater . deflate ( bytes ) ; deflater . reset ( ) ; return - compressedDataLength ; } else { System . arraycopy ( input , inputOffset , bytes , NUM_ , inputLength ) ; return inputLength ; } }
private void doubleCapacity ( ) { int p = head ; int n = elements . length ; int r = n - p ; int newCapacity = n << NUM_ ; if ( newCapacity < NUM_ ) throw new IllegalStateException ( STR_ ) ; Object [ ] a = new Object [ newCapacity ] ; System . arraycopy ( elements , p , a , NUM_ , r ) ; System . arraycopy ( elements , NUM_ , a , r , p ) ; elements = a ; head = NUM_ ; tail = n ; }
public Marker backTo ( int idx ) throws AMConsoleException { int size = trail . size ( ) ; if ( idx >= size ) { throw new AMConsoleException ( STR_ ) ; } for ( int i = size - NUM_ ; i > idx ; -- i ) { trail . remove ( i ) ; } return ( Marker ) trail . get ( idx ) ; }
private static long copy ( InputStream source , OutputStream sink ) throws IOException { long nread = NUM_ ; byte [ ] buf = new byte [ BUFFER_SIZE ] ; int n ; while ( ( n = source . read ( buf ) ) > NUM_ ) { sink . write ( buf , NUM_ , n ) ; nread += n ; } return nread ; }
public byte [ ] pack ( ) { if ( entries . size ( ) == NUM_ ) return null ; int entryLength = owner . getType ( ) . NODES_ENTRY_LENGTH ; byte [ ] buffer = new byte [ entries . size ( ) . entryLength ] ; int max_items = buffer . length / NUM_ ; int j = NUM_ ; for ( KBucketEntry e : entries ) { if ( j >= max_items ) { break ; } PackUtil . PackBucketEntry ( e , buffer , j . entryLength , owner . getType ( ) ) ; j ++ ; } return buffer ; }
public String toString ( ) { StringBuffer sb = new StringBuffer ( STR_ ) ; for ( int i = NUM_ ; i < permissions . length ; i ++ ) { if ( i > NUM_ ) { sb . append ( STR_ ) ; } sb . append ( permissions [ i ] ) ; } sb . append ( STR_ ) ; return sb . toString ( ) ; }
public void testInvalidAfterClose ( ) throws IOException { Path tempPath = createTempDir ( ) ; Directory dir = getDirectory ( tempPath ) ; Lock l = dir . obtainLock ( STR_ ) ; l . close ( ) ; expectThrows ( AlreadyClosedException . class , null ) ; dir . close ( ) ; }
public static GdsTypeRule excludes ( String ... excludedTypes ) { final Set < String > excludedTypesSet = new HashSet < > ( Arrays . asList ( excludedTypes ) ) ; return new GdsTypeRule ( not ( isIn ( excludedTypesSet ) ) ) ; }
public final Set < String > aliases ( ) { if ( aliasSet != null ) return aliasSet ; int n = aliases . length ; HashSet < String > hs = new HashSet < String > ( n ) ; for ( int i = NUM_ ; i < n ; i ++ ) hs . add ( aliases [ i ] ) ; aliasSet = Collections . unmodifiableSet ( hs ) ; return aliasSet ; }
public synchronized void unweave ( ByteString id ) { if ( woven . containsKey ( id ) ) { removed . add ( woven . remove ( id ) ) ; } }
private static Map < String , VirtualFile > findSiblings ( @ Nullable VirtualFile directory , Project project , Set < VirtualFile > seen ) { if ( directory == null ) { return Collections . emptyMap ( ) ; } else { if ( seen . contains ( directory ) ) { return findSiblings ( null , project , seen ) ; } seen . add ( directory ) ; VirtualFile settings = directory . findChild ( SdkConstants . FN_SETTINGS_GRADLE ) ; if ( settings == null ) { return findSiblings ( directory . getParent ( ) , project , seen ) ; } else { return GradleModuleImporter . getSubProjects ( settings , project ) ; } } }
public AuthorityKeyIdentifierStructure ( X509Certificate certificate ) throws CertificateParsingException { super ( fromCertificate ( certificate ) ) ; }
@ Override public int hashCode ( ) { return Arrays . hashCode ( new ImmutablePair [ ] { ( ImmutablePair ) first , ( ImmutablePair ) second } ) ; }
private static char [ ] zzUnpackCMap ( String packed ) { char [ ] map = new char [ x10000 ] ; int i = NUM_ ; int j = NUM_ ; while ( i < NUM_ ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM_ ) ; } return map ; }
@ SuppressLint ( STR_ ) public static String replaceUnicodeDigits ( String number ) { StringBuilder normalizedDigits = new StringBuilder ( number . length ( ) ) ; for ( char c : number . toCharArray ( ) ) { int digit = Character . digit ( c , NUM_ ) ; if ( digit != - NUM_ ) { normalizedDigits . append ( digit ) ; } else { normalizedDigits . append ( c ) ; } } return normalizedDigits . toString ( ) ; }
public String Frie_Name ( String value ) { if ( value == null || value . length ( ) == NUM_ ) return STR_ ; String retValue = value ; String SQL = STR_ ; try { PreparedStatement pstmt = DB . prepareStatement ( SQL , null ) ; pstmt . setString ( NUM_ , value ) ; ResultSet rs = pstmt . executeQuery ( ) ; if ( rs . next ( ) ) retValue = rs . getString ( NUM_ ) ; rs . close ( ) ; pstmt . close ( ) ; } catch ( SQLException e ) { log . log ( Level . SEVERE , SQL , e ) ; } return retValue ; }
public static boolean isCompressed ( File file ) { InputStream fis = null ; try { if ( file . exists ( ) ) { fis = new FileInputStream ( file ) ; int mag1 = fis . read ( ) ; int mag2 = fis . read ( ) ; fis . close ( ) ; return selectCompressionProvider ( mag1 , mag2 ) != null ; } } catch ( IOException e ) { LOG . log ( Level . FINEST , STR_ + file + STR_ , e ) ; return BOOL_ ; } finally { SafeClose . close ( fis ) ; } return BOOL_ ; }
@ Override public int readInt ( String filePath ) { FileChannel fileChannel = updateCache ( filePath ) ; ByteBuffer byteBffer = read ( fileChannel , CarbonCommonConstants . INT_SIZE_IN_BYTE ) ; return byteBffer . getInt ( ) ; }
private synchronized void closeOutputStreamQuietly ( ) { if ( ! mClosed ) { try { mOutputStream . close ( ) ; reportDecodedSizeIfApplicable ( ) ; } catch ( IOException e ) { CLog . writeToConsole ( mNetworkPeerManager , Console . MessageLevel . ERROR , Console . MessageSource . NETWORK , STR_ + e ) ; } finally { mClosed = BOOL_ ; } } }
public void bind ( String address , ServiceRefAmp linkService ) { _linkServiceMap . put ( address , linkService ) ; _serviceCloseList . add ( linkService ) ; }
public boolean mightHaveMultiFontMetrics ( ) { return fontConfig != null ; }
private static boolean checkOffset ( String value , int offset , char expected ) { return ( offset < value . length ( ) ) && ( value . charAt ( offset ) == expected ) ; }
void addSplit ( String splitPath ) { String [ ] splits = splitPath . split ( STR_ ) ; for ( String split : splits ) { split = split . trim ( ) ; if ( split . startsWith ( STR_ ) ) throw new RuntimeException ( STR_ + split ) ; if ( split . length ( ) == NUM_ ) continue ; addField ( split , split , BOOL_ , BOOL_ ) ; } }
public void sortArray ( T [ ] d , Comparator < T > c ) { this . data = d ; this . comp = c ; int len = Math . max ( ( int ) ( NUM_ . Math . log ( d . length ) ) , TEMP_SIZE ) ; len = Math . min ( d . length , len ) ; @ SuppressWarnings ( STR_ ) T [ ] t = ( T [ ] ) new Object [ len ] ; this . temp = t ; mergeSort ( NUM_ , d . length - NUM_ ) ; }
public static void closeQuietly ( Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( RuntimeException rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } }
public void cacheUnit ( UnitInterface unit ) { allUnits . add ( unit ) ; }
public Component findByName ( String name , Component rootComponent ) { Component c = ( Component ) rootComponent . getClientProperty ( STR_ + name + STR_ ) ; if ( c == null ) { Container newRoot = getRootAncestor ( rootComponent ) ; if ( newRoot != null && rootComponent != newRoot ) { return findByName ( name , newRoot ) ; } } return c ; }
protected void fetchMetadata ( ) throws IOException { remaining = period ; int size = in . read ( ) ; if ( size < NUM_ ) return ; size <<= NUM_ ; if ( mbuffer . length < size ) { mbuffer = null ; mbuffer = new byte [ size ] ; Log . d ( LOG , STR_ + size + STR_ ) ; } size = readFully ( mbuffer , NUM_ , size ) ; for ( int i = NUM_ ; i < size ; i ++ ) { if ( mbuffer [ i ] == NUM_ ) { size = i ; break ; } } String s ; try { s = new String ( mbuffer , NUM_ , size , characterEncoding ) ; } catch ( Exception e ) { Log . e ( LOG , STR_ ) ; return ; } Log . d ( LOG , STR_ + s ) ; parseMetadata ( s ) ; }
public void startElement ( ) { nss . pushContext ( ) ; inCollectingMode = BOOL_ ; }
private V replaceNode ( Object key , V value , Object cv ) { int hash = hash ( ( K ) key ) ; for ( Node < K , V > [ ] tab = table ; ; ) { Node < K , V > f ; int n , i , fh ; if ( tab == null || ( n = tab . length ) == NUM_ || ( f = tabAt ( tab , i = ( n - NUM_ ) & hash ) ) == null ) { break ; } else if ( ( fh = f . hash ) == MOVED ) { tab = helpTransfer ( tab , f ) ; } else { V oldVal = null ; boolean validated = BOOL_ ; synchronized ( f ) { if ( tabAt ( tab , i ) == f ) { if ( fh >= NUM_ ) { validated = BOOL_ ; for ( Node < K , V > e = f , pred = null ; ; ) { if ( e . hash == hash && isEqual ( ( K ) key , e . key ) ) { V ev = e . val ; if ( cv == null || cv == ev || ( ev != null && cv . equals ( ev ) ) ) { oldVal = ev ; if ( value != null ) { e . val = value ; } else if ( pred != null ) { pred . next = e . next ; } else { setTabAt ( tab , i , e . next ) ; } } break ; } pred = e ; if ( ( e = e . next ) == null ) { break ; } } } else if ( f instanceof TreeBin ) { validated = BOOL_ ; TreeBin < K , V > t = ( TreeBin < K , V > ) f ; TreeNode < K , V > r , p ; if ( ( r = t . root ) != null && ( p = r . findTreeNode ( hash , key , null ) ) != null ) { V pv = p . val ; if ( cv == null || cv == pv || ( pv != null && cv . equals ( pv ) ) ) { oldVal = pv ; if ( value != null ) { p . val = value ; } else if ( t . removeTreeNode ( p ) ) { setTabAt ( tab , i , untreeify ( t . first ) ) ; } } } } } } if ( validated ) { if ( oldVal != null ) { if ( value == null ) { addCount ( - NUM_ , - NUM_ ) ; } return oldVal ; } break ; } } } return null ; }
public final void removeHelperText ( @ NonNull final CharSequence helperText ) { ensureNotNull ( helperText , STR_ ) ; ensureNotEmpty ( helperText , STR_ ) ; helperTexts . remove ( helperText ) ; verifyPasswordStrength ( ) ; }
public final synchronized int maxPV ( ) { if ( computerPlayer == null ) return NUM_ ; return computerPlayer . getMaxPV ( ) ; }
private void displaySimple ( PrintStream output ) { output . println ( STR_ ) ; for ( int j = NUM_ ; j < P ; j ++ ) { double [ ] a0 = new double [ N ] ; double [ ] a1 = new double [ N ] ; double [ ] a2 = new double [ N ] ; for ( int i = NUM_ ; i < N ; i ++ ) { a0 [ i ] = A [ i ] ; a1 [ i ] = C_A [ i ] [ j ] ; a2 [ i ] = B [ i ] ; } double value = computeFirstOrder ( a0 , a1 , a2 , N ) ; output . print ( value < NUM_ ? NUM_ : value ) ; if ( j < P - NUM_ ) { output . print ( STR_ ) ; } } output . println ( ) ; output . println ( STR_ ) ; for ( int j = NUM_ ; j < P ; j ++ ) { double [ ] a0 = new double [ N ] ; double [ ] a1 = new double [ N ] ; double [ ] a2 = new double [ N ] ; for ( int i = NUM_ ; i < N ; i ++ ) { a0 [ i ] = A [ i ] ; a1 [ i ] = C_A [ i ] [ j ] ; a2 [ i ] = B [ i ] ; } double value = computeTotalOrder ( a0 , a1 , a2 , N ) ; output . print ( value < NUM_ ? NUM_ : value ) ; if ( j < P - NUM_ ) { output . print ( STR_ ) ; } } output . println ( ) ; }
public Object remove ( int index ) { RangeCheck ( index ) ; modCount ++ ; Object oldValue = elementData [ index ] ; int numMoved = size - index - NUM_ ; if ( numMoved > NUM_ ) System . arraycopy ( elementData , index + NUM_ , elementData , index , numMoved ) ; elementData [ -- size ] = null ; return oldValue ; }
public String readMatchingFlags ( String text ) { clear ( ) ; if ( text . startsWith ( PM_SEPARATOR ) ) { final StringTokenizer tok = new StringTokenizer ( text , PM_SEPARATOR ) ; while ( tok . hasMoreTokens ( ) ) { final String flag = tok . nextToken ( ) ; if ( flag . equals ( PM_TYPE_MATCH ) ) { typeMatching = BOOL_ ; } else if ( flag . equals ( PM_EXACT_MATCH ) ) { exactMatching = BOOL_ ; } else if ( flag . equals ( PM_SIMILAR_MATCH ) ) { similarMatching = BOOL_ ; } else if ( flag . equals ( PM_ICASE_MATCH ) ) { caseInsensitive = BOOL_ ; } else if ( flag . equals ( PM_JOKER_MATCH ) ) { jokerMatching = BOOL_ ; } else { break ; } text = text . substring ( flag . length ( ) + NUM_ ) ; } if ( isAnyFlagSet ( ) ) { text = text . substring ( NUM_ ) ; } } return text ; }
private TinyPlanetImage createFinalTinyPlanet ( ) { mResultLock . lock ( ) ; try { mResultBitmap . recycle ( ) ; mResultBitmap = null ; mSourceBitmap . recycle ( ) ; mSourceBitmap = null ; } finally { mResultLock . unlock ( ) ; } Bitmap sourceBitmap = createPaddedSourceImage ( mSourceImageUri , BOOL_ ) ; int width = sourceBitmap . getWidth ( ) ; int height = sourceBitmap . getHeight ( ) ; int outputSize = width / NUM_ ; Bitmap resultBitmap = Bitmap . createBitmap ( outputSize , outputSize , Bitmap . Config . ARGB_8888 ) ; TinyPlanetNative . process ( sourceBitmap , width , height , resultBitmap , outputSize , mCurrentZoom , mCurrentAngle ) ; sourceBitmap . recycle ( ) ; sourceBitmap = null ; ByteArrayOutputStream jpeg = new ByteArrayOutputStream ( ) ; resultBitmap . compress ( CompressFormat . JPEG , NUM_ , jpeg ) ; return new TinyPlanetImage ( addExif ( jpeg . toByteArray ( ) ) , outputSize ) ; }
private static int NewFloatArray ( JNIEnvironment env , int length ) { if ( traceJNI ) VM . sysWrite ( STR_ ) ; RuntimeEntrypoints . checkJNICountDownToGC ( ) ; try { float [ ] newArray = new float [ length ] ; return env . pushJNIRef ( newArray ) ; } catch ( Throwable unexpected ) { if ( traceJNI ) unexpected . printStackTrace ( System . err ) ; env . recordException ( unexpected ) ; return NUM_ ; } }
static int createShader ( String resource , int type ) throws IOException { return createShader ( resource , type , null ) ; }
public Model validateNodeAgainstShape ( Dataset dataset , URI shapesGraphURI , Node focusNode , Node shape , Resource minSeverity , Predicate < SHConstraint > constraintFilter , Function < RDFNode , String > labelFunction , ProgressMonitor monitor ) { Model results = JenaUtil . createMemoryModel ( ) ; Model oldResults = getCurrentResultsModel ( ) ; setCurrentResultsModel ( results ) ; addResourceViolations ( dataset , shapesGraphURI , focusNode , shape , SHACLUtil . getAllConstraintProperties ( BOOL_ ) , minSeverity , constraintFilter , results , labelFunction , monitor ) ; setCurrentResultsModel ( oldResults ) ; return results ; }
@ Override public VolatileImage createBackBuffer ( WComponentPeer peer ) { Component target = ( Component ) peer . getTarget ( ) ; return new SunVolatileImage ( target , target . getWidth ( ) , target . getHeight ( ) , Boolean . TRUE ) ; }
public void test_singleResourceLocking_highConcurrency100 ( ) throws Exception { Properties properties = new Properties ( ) ; properties . setProperty ( TestOptions . NTHREADS , STR_ ) ; properties . setProperty ( TestOptions . NTASKS , STR_ ) ; properties . setProperty ( TestOptions . NRESOURCES , STR_ ) ; properties . setProperty ( TestOptions . MIN_LOCKS , STR_ ) ; properties . setProperty ( TestOptions . MAX_LOCKS , STR_ ) ; properties . setProperty ( TestOptions . PREDECLARE_LOCKS , STR_ ) ; properties . setProperty ( TestOptions . SORT_LOCK_REQUESTS , STR_ ) ; doComparisonTest ( properties ) ; }
public void push ( final double value ) { long bits = Double . doubleToLongBits ( value ) ; if ( bits == NUM_ || bits == x3ff0000000000000L ) { mv . visitInsn ( Opcodes . DCONST_0 + ( int ) value ) ; } else { mv . visitLdcInsn ( value ) ; } }
public synchronized void add ( int position , AbstractOption option ) { AbstractOption search = getByName ( option . getName ( ) ) ; if ( search != null ) { LOG . warn ( STR_ ) ; } else { List < AbstractOption > oldOptions = new ArrayList < AbstractOption > ( options ) ; options . add ( position , option ) ; option . setCollection ( this ) ; List < AbstractOption > newOptions = getOptions ( ) ; fireIndexedPropertyChange ( PROP_OPTIONS , position , oldOptions , newOptions ) ; } }
public boolean writeHeader ( OutputStream os ) { try { writeInt ( os , CACHE_MAGIC ) ; writeString ( os , key ) ; writeString ( os , etag == null ? STR_ : etag ) ; writeLong ( os , serverDate ) ; writeLong ( os , lastModified ) ; writeLong ( os , ttl ) ; writeLong ( os , softTtl ) ; writeStringStringMap ( responseHeaders , os ) ; os . flush ( ) ; return BOOL_ ; } catch ( IOException e ) { VolleyLog . d ( STR_ , e . toString ( ) ) ; return BOOL_ ; } }
public boolean visitingMethod ( ) { return visitingMethod ; }
protected ByteArrayOutputStream parseBytes ( ByteArrayOutputStream bos ) throws IOException { int ch ; for ( ch = read ( ) ; ch >= NUM_ && ch != STR_ ; ch = read ( ) ) { int b1 = ch ; int b2 = read ( ) ; int b3 = read ( ) ; int b4 = read ( ) ; if ( b4 != STR_ ) { int chunk = ( ( base64Decode [ b1 ] << NUM_ ) + ( base64Decode [ b2 ] << NUM_ ) + ( base64Decode [ b3 ] << NUM_ ) + ( base64Decode [ b4 ] ) ) ; bos . write ( chunk > > NUM_ ) ; bos . write ( chunk > > NUM_ ) ; bos . write ( chunk ) ; } else if ( b3 != STR_ ) { int chunk = ( ( base64Decode [ b1 ] << NUM_ ) + ( base64Decode [ b2 ] << NUM_ ) + ( base64Decode [ b3 ] ) ) ; bos . write ( chunk > > NUM_ ) ; bos . write ( chunk ) ; } else { int chunk = ( ( base64Decode [ b1 ] << NUM_ ) + ( base64Decode [ b2 ] ) ) ; bos . write ( chunk ) ; } } if ( ch == STR_ ) peek = ch ; return bos ; }
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; }
public static void startUploadActivityForResult ( Activity activity , Account account , int requestCode ) { Intent action = new Intent ( activity , UploadFilesActivity . class ) ; action . putExtra ( EXTRA_ACCOUNT , ( account ) ) ; activity . startActivityForResult ( action , requestCode ) ; }
public void addGenericAttr ( GenericAttr g ) { generic . addElement ( g ) ; }
public void stopTraceSession ( int traceSessionId ) throws SQLException { try ( FbService service = attachServiceManager ( ) ) { service . startServiceAction ( getTraceSPB ( service , isc_action_svc_trace_stop , traceSessionId ) ) ; queueService ( service ) ; } catch ( IOException ioe ) { throw new SQLException ( ioe ) ; } }
String readSubstring ( String source , int ofs ) { return readSubstring ( source , ofs , source . length ( ) ) ; }
private synchronized boolean expungeStaleEntries ( ) { if ( this . size == NUM_ ) return BOOL_ ; Object r ; boolean result = BOOL_ ; while ( ( r = queue . poll ( ) ) != null ) { result = BOOL_ ; SingleEntry e = ( SingleEntry ) r ; this . size -= e . cleanupPkTable ( this . table ) ; this . nonDatedEntryCount -= e . cleanupSemiUniqueTable ( this . nonDatedTable ) ; } return result ; }
public void removeListener ( AbstractSerialTransportListener listener ) { if ( listener != null ) { listeners . remove ( listener ) ; } }
private String restoreNBTTags ( String str , ArrayList < String > nbttags ) { int nbtidx = NUM_ ; for ( String capture : nbttags ) { str = str . replace ( STR_ + nbtidx ++ , capture ) ; } return str ; }
private void drawOffsets ( final Graphics g ) { if ( isEnabled ( ) ) { g . setColor ( m_fontColorOffsets ) ; } else { g . setColor ( m_disabledColor != m_bgColorOffset ? m_disabledColor : Color . WHITE ) ; } final int x = ( - m_firstColumn . m_charWidth ) + NUM_ ; final int bytesToDraw = getMaximumVisibleBytes ( ) ; final String formatString = m_addressMode == AddressMode . BIT32 ? STR_ : STR_ ; for ( int i = NUM_ ; i < bytesToDraw ; i += m_bytesPerRow ) { final long address = m_baseAddress + ( m_firstRow . m_bytesPerRow ) + i ; final String offsetString = String . format ( formatString , address ) ; final int currentRow = i / m_bytesPerRow ; g . drawString ( offsetString , x , m_paddingTop + ( currentRow . m_rowHeight ) ) ; } }
@ Override public void writeExternal ( ObjectOutput out ) throws IOException { super . writeExternal ( out ) ; out . writeDouble ( knnDistance ) ; }
public void touch ( Date date ) { lastSeen = ( Date ) date . clone ( ) ; }
public void testPolyline ( ) throws Exception { EsriLayer layer = new EsriLayer ( STR_ , SHAPE_TYPE_POLYLINE , NUM_ ) ; DbfTableModel model = layer . getModel ( ) ; model . setDecimalCount ( NUM_ , ( byte ) NUM_ ) ; model . setLength ( NUM_ , ( byte ) NUM_ ) ; model . setColumnName ( NUM_ , STR_ ) ; model . setType ( NUM_ , ( byte ) DbfTableModel . TYPE_CHARACTER ) ; model . setDecimalCount ( NUM_ , ( byte ) NUM_ ) ; model . setLength ( NUM_ , ( byte ) NUM_ ) ; model . setColumnName ( NUM_ , STR_ ) ; model . setType ( NUM_ , ( byte ) DbfTableModel . TYPE_NUMERIC ) ; addPolylineRecord1 ( layer ) ; addPolylineRecord2 ( layer ) ; addPolylineRecord3 ( layer ) ; EsriGraphicList list = layer . getEsriGraphicList ( ) ; ShpOutputStream pos = new ShpOutputStream ( new FileOutputStream ( STR_ ) ) ; int [ ] [ ] indexData = pos . writeGeometry ( list ) ; ShxOutputStream xos = new ShxOutputStream ( new FileOutputStream ( STR_ ) ) ; xos . writeIndex ( indexData , list . getType ( ) , list . getExtents ( ) ) ; DbfOutputStream dos = new DbfOutputStream ( new FileOutputStream ( STR_ ) ) ; dos . writeModel ( model ) ; }
public void remove ( String name ) { featureMap . remove ( name ) ; }
private List < ColumnModel > findColumnsToAdd ( ) { List < ColumnModel > columnsToAdd = new ArrayList < ColumnModel > ( ) ; for ( ColumnModel columnModel : mTableModel . getColumnModels ( ) ) { String columnName = columnModel . getColumnName ( ) ; if ( ! mTableModelDB . containsColumn ( columnName ) ) { columnsToAdd . add ( columnModel ) ; } } return columnsToAdd ; }
@ Override public Loader < Cursor > onCreateLoader ( int id , Bundle args ) { Uri uri = FmRadioStation . Station . CONTENT_URI ; String select = FmRadioStation . Station . COLUMN_STATION_TYPE + STR_ ; String order = FmRadioStation . Station . COLUMN_STATION_TYPE + STR_ + FmRadioStation . Station . COLUMN_STATION_FREQ ; CursorLoader cursorLoader = new CursorLoader ( this , uri , FmRadioStation . COLUMNS , select , new String [ ] { String . valueOf ( FmRadioStation . STATION_TYPE_FAVORITE ) , String . valueOf ( FmRadioStation . STATION_TYPE_SEARCHED ) } , order ) ; return cursorLoader ; }
protected Map < String , Object > convertNamedListToMap ( NamedList < ? > args ) { Map < String , Object > argsMap = new LinkedHashMap < > ( ) ; if ( args != null ) { for ( Map . Entry < String , ? > entry : args ) { argsMap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } return argsMap ; }
@ Override public boolean equals ( final Object other ) { if ( this == other ) { return BOOL_ ; } else if ( other == null ) { return BOOL_ ; } else if ( other instanceof ExpressionMatcher ) { final ExpressionMatcher o = ( ExpressionMatcher ) other ; if ( typeMatching != o . typeMatching ) { return BOOL_ ; } else if ( exactMatching != o . exactMatching ) { return BOOL_ ; } else if ( similarMatching != o . similarMatching ) { return BOOL_ ; } else if ( caseInsensitive != o . caseInsensitive ) { return BOOL_ ; } else { return ( jokerMatching == o . jokerMatching ) ; } } else { return BOOL_ ; } }
public boolean hasCapabilities ( List < String > capabilities ) { String [ ] arr = new String [ capabilities . size ( ) ] ; capabilities . toArray ( arr ) ; return hasCapabilities ( arr ) ; }
public static void assignBucketsToPartitions ( Region < ? , ? > region ) { PartitionedRegion pr = isPartitionedCheck ( region ) ; RecoveryLock lock = null ; try { lock = pr . getRecoveryLock ( ) ; lock . lock ( ) ; for ( int i = NUM_ ; i < getNumberOfBuckets ( pr ) ; i ++ ) { pr . createBucket ( i , NUM_ , null ) ; } } finally { if ( lock != null ) { lock . unlock ( ) ; } } }
public synchronized void addListener ( Listener l ) { listeners . add ( l ) ; }
public boolean endsWith ( final String str ) { if ( str == null ) { return BOOL_ ; } final int len = str . length ( ) ; if ( len == NUM_ ) { return BOOL_ ; } if ( len > size ) { return BOOL_ ; } int pos = size - len ; for ( int i = NUM_ ; i < len ; i ++ , pos ++ ) { if ( buffer [ pos ] != str . charAt ( i ) ) { return BOOL_ ; } } return BOOL_ ; }
public boolean find ( int start ) { if ( start < NUM_ || start > input . length ( ) ) { throw new IndexOutOfBoundsException ( STR_ + start + STR_ + input . length ( ) ) ; } synchronized ( this ) { matchFound = findImpl ( address , input , start , matchOffsets ) ; } return matchFound ; }
public void applyPattern ( String pattern ) { this . pattern = pattern ; if ( patternTokens != null ) { patternTokens . clear ( ) ; patternTokens = null ; } }
public int numberOfReplies ( final Resource comment ) { final Iterator < Resource > children = comment . listChildren ( ) ; int size = NUM_ ; while ( children . hasNext ( ) ) { children . next ( ) ; size ++ ; } return size ; }
public static < T > String toString ( TreeDef < T > treeDef , T root , Function < ? super T , String > toString , String indent ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( toString . apply ( root ) ) ; builder . append ( STR_ ) ; toStringHelper ( treeDef , root , toString , indent , builder , indent ) ; return builder . toString ( ) ; }
public void cleanUpRemoteSessions ( ) { synchronized ( remoteSessionSet ) { for ( Iterator iter = remoteSessionSet . iterator ( ) ; iter . hasNext ( ) ; ) { SessionID sessionID = ( SessionID ) iter . next ( ) ; String hostServer = null ; try { hostServer = getCurrentHostServer ( sessionID ) ; } catch ( Exception ex ) { } if ( ! serverConfig . isLocalServer ( hostServer ) ) { iter . remove ( ) ; } } } }
public boolean columnExistsCaseSensitive ( DatabaseMetaData dbMetaData , String tableName , String columnName ) throws SQLException { ResultSet rsTables = dbMetaData . getColumns ( null , null , tableName , columnName ) ; try { return rsTables . next ( ) ; } finally { closeJDBCResultSet ( rsTables ) ; } }
public void actionPerformed ( ActionEvent e ) { Caret c = textArea . getCaret ( ) ; if ( c . getDot ( ) != c . getMark ( ) ) { return ; } RSyntaxDocument doc = ( RSyntaxDocument ) textArea . getDocument ( ) ; doc . readLock ( ) ; try { removeHighlights ( ) ; int line = textArea . getCaretLineNumber ( ) ; Token tokenList = textArea . getTokenListForLine ( line ) ; int dot = c . getDot ( ) ; Token t = RSyntaxUtilities . getTokenAtOffset ( tokenList , dot ) ; if ( t == null || ! isValidType ( t ) || isNonWordChar ( t ) ) { dot -- ; try { if ( dot >= textArea . getLineStartOffset ( line ) ) { t = RSyntaxUtilities . getTokenAtOffset ( tokenList , dot ) ; } } catch ( BadLocationException ble ) { ble . printStackTrace ( ) ; } } if ( t != null && isValidType ( t ) && ! isNonWordChar ( t ) ) { RSyntaxTextAreaHighlighter h = ( RSyntaxTextAreaHighlighter ) textArea . getHighlighter ( ) ; String lexeme = t . getLexeme ( ) ; int type = t . type ; for ( int i = NUM_ ; i < textArea . getLineCount ( ) ; i ++ ) { Token temp = textArea . getTokenListForLine ( i ) ; while ( temp != null && temp . isPaintable ( ) ) { if ( temp . is ( type , lexeme ) ) { try { int end = temp . offset + temp . textCount ; Object tag = h . addMarkedOccurrenceHighlight ( temp . offset , end , p ) ; tags . add ( tag ) ; } catch ( BadLocationException ble ) { ble . printStackTrace ( ) ; } } temp = temp . getNextToken ( ) ; } } } } finally { doc . readUnlock ( ) ; } textArea . fireMarkedOccurrencesChanged ( ) ; }
public int read ( ) throws IOException { if ( ! buf . hasRemaining ( ) ) { return - NUM_ ; } return buf . get ( ) & xFF ; }
public void charactersRaw ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( isOutsideDocElem ( ) && XMLCharacterRecognizer . isWhiteSpace ( ch , start , length ) ) return ; String s = new String ( ch , start , length ) ; append ( m_doc . createProcessingInstruction ( STR_ , STR_ ) ) ; append ( m_doc . createTextNode ( s ) ) ; }
private void handleRelease ( ) { float speed = Math . max ( dragHelper . getDragSpeed ( ) , animationSpeed ) ; if ( getTopMargin ( ) > initialMargin || ( dragHelper . getDragSpeed ( ) > animationSpeed && dragHelper . getDistance ( ) > NUM_ ) || ( getDeviceType ( getContext ( ) ) == DeviceType . TABLET && isMaximized ( ) && getTopMargin ( ) > minMargin ) ) { animateHideView ( parentHeight - getTopMargin ( ) , speed , new DecelerateInterpolator ( ) , BOOL_ ) ; } else { animateShowView ( - ( getTopMargin ( ) - minMargin ) , speed , new DecelerateInterpolator ( ) ) ; } }
private String normalizeTypeValue ( String type ) { if ( INSERT . equals ( type ) ) return INSERT ; if ( REMOVE . equals ( type ) ) return REMOVE ; return null ; }
@ Override public LogSeqNum writeToLog ( ) { List < Constant > rec = buildRecord ( ) ; return logMgr . append ( rec . toArray ( new Constant [ rec . size ( ) ] ) ) ; }
public static double gaussian ( ) { double r , x , y ; do { x = uniform ( - NUM_ , NUM_ ) ; y = uniform ( - NUM_ , NUM_ ) ; r = x . x + y . y ; } while ( r >= NUM_ || r == NUM_ ) ; return x . Math . sqrt ( - NUM_ . Math . log ( r ) / r ) ; }
public void doneWithParameters ( ) { if ( info . parameterCount == VAR_ARGS ) { int len = varArgs . size ( ) ; checkParameterCount ( len ) ; args = new Expression [ len ] ; varArgs . toArray ( args ) ; varArgs = null ; } else { int len = args . length ; if ( len > NUM_ && args [ len - NUM_ ] == null ) { throw DbException . get ( ErrorCode . INVALID_PARAMETER_COUNT_2 , info . name , STR_ + len ) ; } } }
public void removeAllX509Certificates ( ) { x509Certificates . clear ( ) ; }
public void updateCurrentState ( String whatHappened ) { UndoEvent undoEvent = createUndoEventForCurrentState ( whatHappened ) ; if ( undoEvent != null && undoStack != null ) { undoStack . setTheWayThingsAre ( undoEvent ) ; } }
@ Override protected void onSizeChanged ( int w , int h , int oldw , int oldh ) { super . onSizeChanged ( w , h , oldw , oldh ) ; setupBounds ( w , h ) ; setupPaints ( ) ; invalidate ( ) ; }
protected void extendElement ( Element e ) { }
public Object [ ] toArray ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = NUM_ ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }
public DTMAxisIterator cloneIterator ( ) { _isRestartable = BOOL_ ; try { final PrecedingIterator clone = ( PrecedingIterator ) super . clone ( ) ; final int [ ] stackCopy = new int [ _stack . length ] ; System . arraycopy ( _stack , NUM_ , stackCopy , NUM_ , _stack . length ) ; clone . _stack = stackCopy ; return clone ; } catch ( CloneNotSupportedException e ) { throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ITERATOR_CLONE_NOT_SUPPORTED , null ) ) ; } }
private String readResponseFromServer ( HttpURLConnection urlConnection ) throws RequestFailureException { try { InputStreamReader reader = new InputStreamReader ( urlConnection . getInputStream ( ) ) ; BufferedReader in = new BufferedReader ( reader ) ; try { StringBuilder response = new StringBuilder ( ) ; for ( String line = in . readLine ( ) ; line != null ; line = in . readLine ( ) ) { response . append ( line ) ; } checkServerResponseCode ( urlConnection ) ; return response . toString ( ) ; } finally { in . close ( ) ; } } catch ( IOException e ) { throw new RequestFailureException ( STR_ , e ) ; } }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; if ( name == null ) { throw new NullPointerException ( ) ; } if ( nodeType == null ) { throw new NullPointerException ( ) ; } }
public int contains ( ValueStoreBase vsb ) { final Vector values = vsb . fValues ; final int size1 = values . size ( ) ; if ( fFieldCount <= NUM_ ) { for ( int i = NUM_ ; i < size1 ; ++ i ) { short val = vsb . getValueTypeAt ( i ) ; if ( ! valueTypeContains ( val ) || ! fValues . contains ( values . elementAt ( i ) ) ) { return i ; } else if ( val == XSConstants . LIST_DT || val == XSConstants . LISTOFUNION_DT ) { ShortList list1 = vsb . getItemValueTypeAt ( i ) ; if ( ! itemValueTypeContains ( list1 ) ) { return i ; } } } } else { final int size2 = fValues . size ( ) ; OUTER : for ( int i = NUM_ ; i < size1 ; i += fFieldCount ) { INNER : for ( int j = NUM_ ; j < size2 ; j += fFieldCount ) { for ( int k = NUM_ ; k < fFieldCount ; ++ k ) { final Object value1 = values . elementAt ( i + k ) ; final Object value2 = fValues . elementAt ( j + k ) ; final short valueType1 = vsb . getValueTypeAt ( i + k ) ; final short valueType2 = getValueTypeAt ( j + k ) ; if ( value1 != value2 && ( valueType1 != valueType2 || value1 == null || ! value1 . equals ( value2 ) ) ) { continue INNER ; } else if ( valueType1 == XSConstants . LIST_DT || valueType1 == XSConstants . LISTOFUNION_DT ) { ShortList list1 = vsb . getItemValueTypeAt ( i + k ) ; ShortList list2 = getItemValueTypeAt ( j + k ) ; if ( list1 == null || list2 == null || ! list1 . equals ( list2 ) ) { continue INNER ; } } } continue OUTER ; } return i ; } } return - NUM_ ; }
public boolean isSupportedOption ( String name ) { boolean isSupported = BOOL_ ; for ( Iterator i = mandatoryOptions . iterator ( ) ; i . hasNext ( ) && ! isSupported ; ) { String opt = ( String ) i . next ( ) ; isSupported = opt . equals ( name ) ; } for ( Iterator i = optionalOptions . iterator ( ) ; i . hasNext ( ) && ! isSupported ; ) { String opt = ( String ) i . next ( ) ; isSupported = opt . equals ( name ) ; } return isSupported ; }
private boolean areAllNodeEnded ( ) { if ( protocol != null && protocol . hasProtocol ( ) ) { final Collection < ProtocolNode > protocolNodes = protocolNodeParticipantMap . values ( ) ; if ( protocolNodes . isEmpty ( ) ) { return BOOL_ ; } for ( final ProtocolNode node : protocolNodes ) { if ( ! ( node != null && node . isTerminal ( ) ) ) { return BOOL_ ; } } return BOOL_ ; } final Collection < FIPAMessage > finalMsgs = noProtocolNodeParticipantMap . values ( ) ; if ( finalMsgs . isEmpty ( ) ) { return BOOL_ ; } for ( final FIPAMessage finalMsg : finalMsgs ) { if ( finalMsg . getPerformative ( ) != FIPAConstants . Performatives . END_CONVERSATION ) { return BOOL_ ; } } return BOOL_ ; }
public StringBuilder encodeBody ( StringBuilder retval ) { return retval . append ( optionTag ) ; }
public void addLiteralResultAttribute ( AVT avt ) { if ( null == m_avts ) m_avts = new ArrayList ( ) ; m_avts . add ( avt ) ; }
protected void moveSelectionToFirstPosition ( ) { if ( selectionTable . getSelectionCount ( ) == NUM_ ) { return ; } int index = NUM_ ; for ( final TableItem tableItem : selectionTable . getSelection ( ) ) { final DLItem item = ( DLItem ) tableItem . getData ( ) ; selection . remove ( item ) ; selection . add ( index ++ , item ) ; } redrawTables ( ) ; selectionTable . select ( NUM_ , index - NUM_ ) ; selectionTable . forceFocus ( ) ; }
private void itemsArrayToCombinedBuffer ( T [ ] itemsArray ) { final int extra = NUM_ ; minValue_ = itemsArray [ NUM_ ] ; maxValue_ = itemsArray [ NUM_ ] ; System . arraycopy ( itemsArray , extra , combinedBuffer_ , NUM_ , baseBufferCount_ ) ; long bits = bitPattern_ ; if ( bits > NUM_ ) { int index = extra + baseBufferCount_ ; for ( int level = NUM_ ; bits != NUM_ ; level ++ , bits >>>= NUM_ ) { if ( ( bits & NUM_ ) > NUM_ ) { System . arraycopy ( itemsArray , index , combinedBuffer_ , ( NUM_ + level ) . k_ , k_ ) ; index += k_ ; } } } }
public SQLQuery ( Class < T > type , String sqlExpression , QueryResultType queryResultType , Object ... parameters ) { this ( sqlExpression , type . getName ( ) , null , queryResultType , parameters ) ; }
public void bob ( MowzieModelRenderer box , float speed , float degree , boolean bounce , float f , float f1 ) { float bob = ( float ) ( Math . sin ( f . speed ) . f1 . degree - f1 . degree ) ; if ( bounce ) bob = ( float ) - Math . abs ( ( Math . sin ( f . speed ) . f1 . degree ) ) ; box . rotationPointY += bob ; }
private static void rejectUnsupportedOptions ( Properties p ) throws SQLFeatureNotSupportedException { if ( p . containsKey ( DataSourceFactory . JDBC_ROLE_NAME ) ) { throw new SQLFeatureNotSupportedException ( STR_ + DataSourceFactory . JDBC_ROLE_NAME + STR_ ) ; } if ( p . containsKey ( DataSourceFactory . JDBC_DATASOURCE_NAME ) ) { throw new SQLFeatureNotSupportedException ( STR_ + DataSourceFactory . JDBC_DATASOURCE_NAME + STR_ ) ; } }
public IOUtils ( ) { super ( ) ; }
private int readAnnotationValue ( int v , final char [ ] buf , final String name , final AnnotationVisitor av ) { int i ; if ( av == null ) { switch ( b [ v ] & xFF ) { case STR_ : return v + NUM_ ; case STR_ : return readAnnotationValues ( v + NUM_ , buf , BOOL_ , null ) ; case STR_ : return readAnnotationValues ( v + NUM_ , buf , BOOL_ , null ) ; default : return v + NUM_ ; } } switch ( b [ v ++ ] & xFF ) { case STR_ : case STR_ : case STR_ : case STR_ : av . visit ( name , readConst ( readUnsignedShort ( v ) , buf ) ) ; v += NUM_ ; break ; case STR_ : av . visit ( name , ( byte ) readInt ( items [ readUnsignedShort ( v ) ] ) ) ; v += NUM_ ; break ; case STR_ : av . visit ( name , readInt ( items [ readUnsignedShort ( v ) ] ) == NUM_ ? Boolean . FALSE : Boolean . TRUE ) ; v += NUM_ ; break ; case STR_ : av . visit ( name , ( short ) readInt ( items [ readUnsignedShort ( v ) ] ) ) ; v += NUM_ ; break ; case STR_ : av . visit ( name , ( char ) readInt ( items [ readUnsignedShort ( v ) ] ) ) ; v += NUM_ ; break ; case STR_ : av . visit ( name , readUTF8 ( v , buf ) ) ; v += NUM_ ; break ; case STR_ : av . visitEnum ( name , readUTF8 ( v , buf ) , readUTF8 ( v + NUM_ , buf ) ) ; v += NUM_ ; break ; case STR_ : av . visit ( name , Type . getType ( readUTF8 ( v , buf ) ) ) ; v += NUM_ ; break ; case STR_ : v = readAnnotationValues ( v + NUM_ , buf , BOOL_ , av . visitAnnotation ( name , readUTF8 ( v , buf ) ) ) ; break ; case STR_ : int size = readUnsignedShort ( v ) ; v += NUM_ ; if ( size == NUM_ ) { return readAnnotationValues ( v - NUM_ , buf , BOOL_ , av . visitArray ( name ) ) ; } switch ( this . b [ v ++ ] & xFF ) { case STR_ : byte [ ] bv = new byte [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { bv [ i ] = ( byte ) readInt ( items [ readUnsignedShort ( v ) ] ) ; v += NUM_ ; } av . visit ( name , bv ) ; -- v ; break ; case STR_ : boolean [ ] zv = new boolean [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { zv [ i ] = readInt ( items [ readUnsignedShort ( v ) ] ) != NUM_ ; v += NUM_ ; } av . visit ( name , zv ) ; -- v ; break ; case STR_ : short [ ] sv = new short [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { sv [ i ] = ( short ) readInt ( items [ readUnsignedShort ( v ) ] ) ; v += NUM_ ; } av . visit ( name , sv ) ; -- v ; break ; case STR_ : char [ ] cv = new char [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { cv [ i ] = ( char ) readInt ( items [ readUnsignedShort ( v ) ] ) ; v += NUM_ ; } av . visit ( name , cv ) ; -- v ; break ; case STR_ : int [ ] iv = new int [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { iv [ i ] = readInt ( items [ readUnsignedShort ( v ) ] ) ; v += NUM_ ; } av . visit ( name , iv ) ; -- v ; break ; case STR_ : long [ ] lv = new long [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { lv [ i ] = readLong ( items [ readUnsignedShort ( v ) ] ) ; v += NUM_ ; } av . visit ( name , lv ) ; -- v ; break ; case STR_ : float [ ] fv = new float [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { fv [ i ] = Float . intBitsToFloat ( readInt ( items [ readUnsignedShort ( v ) ] ) ) ; v += NUM_ ; } av . visit ( name , fv ) ; -- v ; break ; case STR_ : double [ ] dv = new double [ size ] ; for ( i = NUM_ ; i < size ; i ++ ) { dv [ i ] = Double . longBitsToDouble ( readLong ( items [ readUnsignedShort ( v ) ] ) ) ; v += NUM_ ; } av . visit ( name , dv ) ; -- v ; break ; default : v = readAnnotationValues ( v - NUM_ , buf , BOOL_ , av . visitArray ( name ) ) ; } } return v ; }
private void decrementWorkerCount ( ) { do { } while ( ! compareAndDecrementWorkerCount ( ctl . get ( ) ) ) ; }
public static float buildFloat ( int mant , int exp ) { if ( exp < - NUM_ || mant == NUM_ ) { return NUM_ ; } if ( exp >= NUM_ ) { return ( mant > NUM_ ) ? Float . POSITIVE_INFINITY : Float . NEGATIVE_INFINITY ; } if ( exp == NUM_ ) { return mant ; } if ( mant >= ( NUM_ << NUM_ ) ) { mant ++ ; } return ( float ) ( ( exp > NUM_ ) ? mant . pow10 [ exp ] : mant / pow10 [ - exp ] ) ; }
public void clearValues ( ) { mDataSets . clear ( ) ; notifyDataChanged ( ) ; }
public boolean hasModeSupport ( ) { return isAvailable ( ) && mCapabilities . intersects ( mAllModes ) ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList genderList ; Node genderNode ; EntityReference entRef ; Element entElement ; CharacterData entElementText ; int nodeType ; doc = ( Document ) load ( STR_ , BOOL_ ) ; genderList = doc . getElementsByTagName ( STR_ ) ; genderNode = genderList . item ( NUM_ ) ; entRef = ( EntityReference ) genderNode . getFirstChild ( ) ; assertNotNull ( STR_ , entRef ) ; nodeType = ( int ) entRef . getNodeType ( ) ; if ( equals ( NUM_ , nodeType ) ) { entRef = doc . createEntityReference ( STR_ ) ; assertNotNull ( STR_ , entRef ) ; } entElement = ( Element ) entRef . getFirstChild ( ) ; assertNotNull ( STR_ , entElement ) ; entElementText = ( CharacterData ) entElement . getFirstChild ( ) ; assertNotNull ( STR_ , entElementText ) ; { boolean success = BOOL_ ; try { entElementText . setNodeValue ( STR_ ) ; } catch ( DOMException ex ) { success = ( ex . code == DOMException . NO_MODIFICATION_ALLOWED_ERR ) ; } assertTrue ( STR_ , success ) ; } }
public void testConstrStringWithExponentWithPoint2 ( ) { String a = STR_ ; int aScale = NUM_ ; BigInteger bA = new BigInteger ( STR_ ) ; BigDecimal aNumber = new BigDecimal ( a ) ; assertEquals ( STR_ , bA , aNumber . unscaledValue ( ) ) ; assertEquals ( STR_ , aScale , aNumber . scale ( ) ) ; }
public static void updateItemInDatabase ( Context context , final ItemInfo item ) { final ContentValues values = new ContentValues ( ) ; item . onAddToDatabase ( context , values ) ; updateItemInDatabaseHelper ( context , values , item , STR_ ) ; }
@ Override public String graph ( ) throws Exception { StringBuffer text = new StringBuffer ( ) ; text . append ( STR_ ) ; m_cobwebTree . graphTree ( text ) ; text . append ( STR_ ) ; return text . toString ( ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = enumToVector ( super . listOptions ( ) ) ; result . addElement ( new Option ( STR_ + defaultNumAttributes ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
public synchronized Reference < ? extends T > remove ( long timeoutMillis ) throws InterruptedException { if ( timeoutMillis < NUM_ ) { throw new IllegalArgumentException ( STR_ + timeoutMillis ) ; } if ( head != null ) { return poll ( ) ; } if ( timeoutMillis == NUM_ || ( timeoutMillis > Long . MAX_VALUE / NANOS_PER_MILLI ) ) { do { wait ( NUM_ ) ; } while ( head == null ) ; return poll ( ) ; } long nanosToWait = timeoutMillis . NANOS_PER_MILLI ; int timeoutNanos = NUM_ ; long startTime = System . nanoTime ( ) ; while ( BOOL_ ) { wait ( timeoutMillis , timeoutNanos ) ; if ( head != null ) { break ; } long nanosElapsed = System . nanoTime ( ) - startTime ; long nanosRemaining = nanosToWait - nanosElapsed ; if ( nanosRemaining <= NUM_ ) { break ; } timeoutMillis = nanosRemaining / NANOS_PER_MILLI ; timeoutNanos = ( int ) ( nanosRemaining - timeoutMillis . NANOS_PER_MILLI ) ; } return poll ( ) ; }
public PathImpl lookupImpl ( String userPath , Map < String , Object > newAttributes , boolean isAllowRoot ) { if ( userPath == null ) { return lookupImpl ( getPath ( ) , newAttributes , isAllowRoot ) ; } if ( ! isAllowRoot ) { return schemeWalk ( userPath , newAttributes , userPath , NUM_ ) ; } String scheme = scanScheme ( userPath ) ; if ( scheme == null ) { return schemeWalk ( userPath , newAttributes , userPath , NUM_ ) ; } PathImpl path ; SchemeMap schemeMap = _schemeMap ; if ( isWindows ( ) ) { int length = scheme . length ( ) ; char ch ; if ( length == NUM_ && ( STR_ <= ( ch = scheme . charAt ( NUM_ ) ) && ch <= STR_ || STR_ <= ch && ch <= STR_ ) ) { userPath = Character . toLowerCase ( ch ) + userPath . substring ( NUM_ ) ; if ( _isTestWindows ) return schemeWalk ( userPath , newAttributes , STR_ + userPath , NUM_ ) ; path = schemeMap . get ( STR_ ) ; if ( path != null ) return path . schemeWalk ( userPath , newAttributes , STR_ + userPath , NUM_ ) ; else return schemeWalk ( userPath , newAttributes , STR_ + userPath , NUM_ ) ; } } path = schemeMap . get ( scheme ) ; if ( path == null ) { return schemeWalk ( userPath , newAttributes , userPath , NUM_ ) ; } else { return path . schemeWalk ( userPath , newAttributes , userPath , scheme . length ( ) + NUM_ ) ; } }
public void addColor ( int color ) { if ( mColors == null ) mColors = new ArrayList < Integer > ( ) ; mColors . add ( color ) ; }
static Integer readRuleID ( final SubstringReader reader ) throws DecodeException { int length = NUM_ ; reader . skipWhitespaces ( ) ; reader . mark ( ) ; try { while ( reader . read ( ) != STR_ ) { length ++ ; } if ( length == NUM_ ) { throw DecodeException . error ( ERR_ATTR_SYNTAX_RULE_ID_NO_VALUE1 . get ( reader . pos ( ) - NUM_ ) ) ; } reader . reset ( ) ; final String ruleID = reader . read ( length ) ; try { return Integer . valueOf ( ruleID ) ; } catch ( final NumberFormatException e ) { throw DecodeException . error ( ERR_ATTR_SYNTAX_RULE_ID_INVALID1 . get ( ruleID ) ) ; } } catch ( final StringIndexOutOfBoundsException e ) { throw DecodeException . error ( ERR_ATTR_SYNTAX_TRUNCATED_VALUE1 . get ( ) ) ; } }
public void removeIndex ( IIndex index ) { if ( index != null ) { indices . remove ( index ) ; } }
private AttributeActionSet processAttributeSection ( ModeUsage modeUsage , String ns , IntSet indexSet , Attributes attributes ) throws SAXException { Mode mode = modeUsage . getMode ( currentSection . context ) ; AttributeActionSet actions = mode . getAttributeActions ( ns ) ; if ( actions . getReject ( ) && ! attributeNamespaceRejected ) { attributeNamespaceRejected = BOOL_ ; if ( eh != null ) eh . error ( new SAXParseException ( localizer . message ( STR_ , ns ) , locator ) ) ; } Schema [ ] schemas = actions . getSchemas ( ) ; for ( int j = NUM_ ; j < schemas . length ; j ++ ) { if ( attributeSchemas . contains ( schemas [ j ] ) ) continue ; attributeSchemas . add ( schemas [ j ] ) ; if ( filteredAttributes == null ) filteredAttributes = filterAttributes ( indexSet , attributes ) ; validateAttributes ( schemas [ j ] , filteredAttributes ) ; } return actions ; }
public void initialize ( Context context , HapticFeedbackController hapticFeedbackController , int initialHoursOfDay , int initialMinutes , boolean is24HourMode ) { if ( mTimeInitialized ) { Log . e ( TAG , STR_ ) ; return ; } mHapticFeedbackController = hapticFeedbackController ; mIs24HourMode = is24HourMode ; mHideAmPm = mAccessibilityManager . isTouchExplorationEnabled ( ) ? BOOL_ : mIs24HourMode ; mCircleView . initialize ( context , mHideAmPm ) ; mCircleView . invalidate ( ) ; if ( ! mHideAmPm ) { mAmPmCirclesView . initialize ( context , initialHoursOfDay < NUM_ ? AM : PM ) ; mAmPmCirclesView . invalidate ( ) ; } Resources res = context . getResources ( ) ; int [ ] hours = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int [ ] hours_24 = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int [ ] minutes = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; String [ ] hoursTexts = new String [ NUM_ ] ; String [ ] innerHoursTexts = new String [ NUM_ ] ; String [ ] minutesTexts = new String [ NUM_ ] ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { hoursTexts [ i ] = is24HourMode ? String . format ( STR_ , hours_24 [ i ] ) : String . format ( STR_ , hours [ i ] ) ; innerHoursTexts [ i ] = String . format ( STR_ , hours [ i ] ) ; minutesTexts [ i ] = String . format ( STR_ , minutes [ i ] ) ; } mHourRadialTextsView . initialize ( res , hoursTexts , ( is24HourMode ? innerHoursTexts : null ) , mHideAmPm , BOOL_ ) ; mHourRadialTextsView . invalidate ( ) ; mMinuteRadialTextsView . initialize ( res , minutesTexts , null , mHideAmPm , BOOL_ ) ; mMinuteRadialTextsView . invalidate ( ) ; setValueForItem ( HOUR_INDEX , initialHoursOfDay ) ; setValueForItem ( MINUTE_INDEX , initialMinutes ) ; int hourDegrees = ( initialHoursOfDay % NUM_ ) . HOUR_VALUE_TO_DEGREES_STEP_SIZE ; mHourRadialSelectorView . initialize ( context , mHideAmPm , is24HourMode , BOOL_ , hourDegrees , isHourInnerCircle ( initialHoursOfDay ) ) ; int minuteDegrees = initialMinutes . MINUTE_VALUE_TO_DEGREES_STEP_SIZE ; mMinuteRadialSelectorView . initialize ( context , mHideAmPm , BOOL_ , BOOL_ , minuteDegrees , BOOL_ ) ; mTimeInitialized = BOOL_ ; }
@ Override public double conf ( double totalWeight , double delta ) { return inverseNormal ( NUM_ - delta / NUM_ ) / ( NUM_ . Math . sqrt ( totalWeight ) ) ; }
@ Override public final int readUnsignedByte ( ) throws IOException { return dis . readUnsignedByte ( ) ; }
public synchronized static void ensureSecurityManager ( @ SuppressWarnings ( STR_ ) String [ ] args ) { SecurityPolicyLoader . load ( SystemBoot . class , STR_ ) ; System . setSecurityManager ( new RMISecurityManager ( ) ) ; }
@ Override public Object clone ( ) throws CloneNotSupportedException { return super . clone ( ) ; }
public String ridgeTipText ( ) { return STR_ ; }
public void updateEnableStateSwingItems ( ) { if ( SwingUtilities . isEventDispatchThread ( ) ) super . updateEnableState ( ) ; }
public void reset ( ) { System . arraycopy ( IV , NUM_ , cbcV , NUM_ , IV . length ) ; Arrays . fill ( cbcNextV , ( byte ) NUM_ ) ; cipher . reset ( ) ; }
protected final boolean _loadToHaveAtLeast ( int minAvailable ) throws IOException { if ( _inputStream == null ) { return BOOL_ ; } int amount = _inputEnd - _inputPtr ; if ( amount > NUM_ && _inputPtr > NUM_ ) { _currInputProcessed += _inputPtr ; System . arraycopy ( _inputBuffer , _inputPtr , _inputBuffer , NUM_ , amount ) ; _inputEnd = amount ; } else { _inputEnd = NUM_ ; } _inputPtr = NUM_ ; while ( _inputEnd < minAvailable ) { int count = _inputStream . read ( _inputBuffer , _inputEnd , _inputBuffer . length - _inputEnd ) ; if ( count < NUM_ ) { _closeInput ( ) ; if ( count == NUM_ ) { throw new IOException ( STR_ + amount + STR_ ) ; } return BOOL_ ; } _inputEnd += count ; } return BOOL_ ; }
public DataTypeParser register ( int jdbcType , String grammar ) { Objects . requireNonNull ( grammar , STR_ ) ; DataTypePattern pattern = parser . parse ( jdbcType , grammar ) ; pattern . forEachFirstToken ( null ) ; return this ; }
public void close ( ) throws GenericDataSourceException { if ( _manualTX ) { if ( Debug . verboseOn ( ) ) Debug . logVerbose ( STR_ + _manualTX , module ) ; commit ( ) ; } _sql = null ; if ( _rs != null ) { try { _rs . close ( ) ; if ( Debug . verboseOn ( ) ) Debug . logVerbose ( STR_ + _manualTX , module ) ; } catch ( SQLException sqle ) { Debug . logWarning ( sqle . getMessage ( ) , module ) ; } _rs = null ; } if ( _ps != null ) { try { _ps . close ( ) ; if ( Debug . verboseOn ( ) ) Debug . logVerbose ( STR_ + _manualTX , module ) ; } catch ( SQLException sqle ) { Debug . logWarning ( sqle . getMessage ( ) , module ) ; } _ps = null ; } if ( ( _connection != null ) && _bDeleteConnection ) { try { _connection . close ( ) ; if ( Debug . verboseOn ( ) ) Debug . logVerbose ( STR_ + _manualTX , module ) ; } catch ( SQLException sqle ) { Debug . logWarning ( sqle . getMessage ( ) , module ) ; } _connection = null ; } }
private DefaultMutableTreeNode copy ( TreeNode node ) { return new DefaultMutableTreeNode ( node ) ; }
public static void agentmain ( String args , Instrumentation inst ) throws Exception { logger . info ( STR_ ) ; checkTransformerState ( ) ; inst . addTransformer ( transformer , BOOL_ ) ; instrumentation = inst ; }
public byte [ ] data ( ) { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; try { toData ( bos ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return bos . toByteArray ( ) ; }
@ SafeVarargs public static < T > ReactiveSeq < T > of ( final T ... elements ) { final ReversingArraySpliterator < T > array = new ReversingArraySpliterator < T > ( elements , BOOL_ , NUM_ ) ; return StreamUtils . reactiveSeq ( StreamSupport . stream ( array , BOOL_ ) , Optional . ofNullable ( array ) ) ; }
private void decodeLtp ( LongTermPrediction ltp , int maxSfb ) { ltp . lag = br . read ( NUM_ ) ; ltp . coef = ltp_coef [ br . read ( NUM_ ) ] ; for ( int sfb = NUM_ ; sfb < Math . min ( maxSfb , MAX_LTP_LONG_SFB ) ; sfb ++ ) { ltp . used [ sfb ] = br . readBool ( ) ; } }
public static < T > List < T > instantiateAll ( String [ ] classes , ClassLoader classLoader ) { List < T > clazzes = new ArrayList < T > ( ) ; for ( String clazz : classes ) { if ( StringUtils . hasLength ( clazz ) ) { try { clazzes . add ( ClassUtils . < T > instantiate ( clazz , classLoader ) ) ; } catch ( Exception e ) { throw new CassandraMigrationException ( STR_ + clazz , e ) ; } } } return clazzes ; }
static void clearInstanceCache ( ) { synchronized ( INSTANCE_CACHE ) { INSTANCE_CACHE . clear ( ) ; } }
public static < E extends Enum < E > & BitmapableEnum > EnumSet < E > toEnumSet ( Class < E > type , int bitmap ) { if ( type == null ) throw new NullPointerException ( STR_ ) ; EnumSet < E > s = EnumSet . noneOf ( type ) ; int allSetBitmap = NUM_ ; for ( E element : type . getEnumConstants ( ) ) { if ( Integer . bitCount ( element . getValue ( ) ) != NUM_ ) { String msg = String . format ( STR_ + STR_ + STR_ , element . toString ( ) , element . getValue ( ) , type . getName ( ) ) ; throw new IllegalArgumentException ( msg ) ; } allSetBitmap |= element . getValue ( ) ; if ( ( bitmap & element . getValue ( ) ) != NUM_ ) s . add ( element ) ; } if ( ( ( ~ allSetBitmap ) & bitmap ) != NUM_ ) { String msg = String . format ( STR_ + STR_ , bitmap , type . getName ( ) ) ; throw new IllegalArgumentException ( msg ) ; } return s ; }
public UndirectedGraphNode cloneGraphB ( UndirectedGraphNode node ) { Map < Integer , UndirectedGraphNode > map = new HashMap < > ( ) ; return dfs ( node , map ) ; }
public synchronized void notifySessionBorrowed ( ) { if ( LOGGER . isTraceEnabled ( ) ) LOGGER . logTrace ( this + STR_ ) ; currentContext = new TransactionContext ( resource , xaResource ) ; allContexts . add ( currentContext ) ; closed = BOOL_ ; }
@ Override public synchronized void close ( ) throws SQLException { try { debugCodeCall ( STR_ ) ; if ( session == null ) { return ; } CloseWatcher . unregister ( watcher ) ; session . cancel ( ) ; if ( executingStatement != null ) { try { executingStatement . cancel ( ) ; } catch ( NullPointerException e ) { } } synchronized ( session ) { try { if ( ! session . isClosed ( ) ) { try { if ( session . hasPendingTransaction ( ) ) { if ( ! session . isReconnectNeeded ( BOOL_ ) ) { try { rollbackInternal ( ) ; } catch ( DbException e ) { if ( e . getErrorCode ( ) != ErrorCode . CONNECTION_BROKEN_1 ) { throw e ; } } } session . afterWriting ( ) ; } closePreparedCommands ( ) ; } finally { session . close ( ) ; } } } finally { session = null ; } } } catch ( Exception e ) { throw logAndConvert ( e ) ; } }
public void testPlusMathContextNegative ( ) { String a = STR_ ; int aScale = NUM_ ; int precision = NUM_ ; RoundingMode rm = RoundingMode . CEILING ; MathContext mc = new MathContext ( precision , rm ) ; String c = STR_ ; int cScale = NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal res = aNumber . plus ( mc ) ; assertEquals ( STR_ , c , res . toString ( ) ) ; assertEquals ( STR_ , cScale , res . scale ( ) ) ; }
public static WKTGeometry createEmpty ( WKTType wktType ) { WKTGeometry wktGeometry = new WKTGeometry ( ) ; wktGeometry . setGeometryType ( wktType ) ; return wktGeometry ; }
public PeerLookupTask createPeerLookup ( byte [ ] info_hash ) { if ( ! isRunning ( ) ) { return null ; } Key id = new Key ( info_hash ) ; RPCServer srv = serverManager . getRandomActiveServer ( BOOL_ ) ; if ( srv == null ) return null ; PeerLookupTask lookupTask = new PeerLookupTask ( srv , node , id ) ; return lookupTask ; }
public void addChild ( Node ... nodes ) { for ( Node node : nodes ) { node . detachFromParent ( ) ; node . parentNode = this ; initChildNodes ( node ) ; childNodes . add ( node ) ; } reindexChildrenOnAdd ( nodes . length ) ; }
public static void writeStringASCII ( ByteBuf stream , String str ) throws UnsupportedEncodingException { final byte [ ] bytes = str . getBytes ( STR_ ) ; stream . writeInt ( str . length ( ) ) ; stream . writeBytes ( bytes ) ; }
private void needNewBuffer ( int newcount ) { if ( currentBufferIndex < buffers . size ( ) - NUM_ ) { filledBufferSum += currentBuffer . length ; currentBufferIndex ++ ; currentBuffer = buffers . get ( currentBufferIndex ) ; } else { int newBufferSize ; if ( currentBuffer == null ) { newBufferSize = newcount ; filledBufferSum = NUM_ ; } else { newBufferSize = Math . max ( currentBuffer . length << NUM_ , newcount - filledBufferSum ) ; filledBufferSum += currentBuffer . length ; } currentBufferIndex ++ ; currentBuffer = new byte [ newBufferSize ] ; buffers . add ( currentBuffer ) ; } }
public void testWrite3 ( ) throws Exception { byte [ ] data = new byte [ ] { - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; TestOutputStream tos = new TestOutputStream ( ) ; CipherOutputStream cos = new CipherOutputStream ( tos , new NullCipher ( ) ) ; for ( int i = NUM_ ; i < data . length ; i ++ ) { cos . write ( data , i , NUM_ ) ; } cos . flush ( ) ; byte [ ] result = tos . toByteArray ( ) ; if ( ! Arrays . equals ( result , data ) ) { fail ( STR_ ) ; } }
public void addListener ( UpdateManagerListener listener ) { listeners . add ( listener ) ; }
@ Override public void onDetach ( ) { synchronized ( mThread ) { mProgressBar = null ; mReady = BOOL_ ; mThread . notify ( ) ; } super . onDetach ( ) ; }
public void outputSource ( int module , int line , String s ) { StringBuilder sb = new StringBuilder ( ) ; appendSource ( sb , module , line , s , BOOL_ ) ; out ( sb . toString ( ) ) ; }
SortedMap < String , String > properties ( ) ;
public static String suppressWhiteSpace ( String str ) { int len = str . length ( ) ; StringBuilder sb = new StringBuilder ( len ) ; char c ; char buffer = NUM_ ; for ( int i = NUM_ ; i < len ; i ++ ) { c = str . charAt ( i ) ; if ( c == STR_ || c == STR_ ) buffer = STR_ ; else if ( isWhiteSpace ( c ) ) { if ( buffer == NUM_ ) buffer = c ; } else { if ( buffer != NUM_ ) { sb . append ( buffer ) ; buffer = NUM_ ; } sb . append ( c ) ; } } if ( buffer != NUM_ ) sb . append ( buffer ) ; return sb . toString ( ) ; }
private Node < K , V > findPredecessor ( Comparable < ? super K > key ) { if ( key == null ) throw new NullPointerException ( ) ; for ( ; ; ) { Index < K , V > q = head ; Index < K , V > r = q . right ; for ( ; ; ) { if ( r != null ) { Node < K , V > n = r . node ; K k = n . key ; if ( n . value == null ) { if ( ! q . unlink ( r ) ) break ; r = q . right ; continue ; } if ( key . compareTo ( k ) > NUM_ ) { q = r ; r = r . right ; continue ; } } Index < K , V > d = q . down ; if ( d != null ) { q = d ; r = d . right ; } else return q . node ; } } }
public static String readFully ( Reader reader ) throws IOException { try { StringWriter writer = new StringWriter ( ) ; char [ ] buffer = new char [ NUM_ ] ; int count ; while ( ( count = reader . read ( buffer ) ) != - NUM_ ) { writer . write ( buffer , NUM_ , count ) ; } return writer . toString ( ) ; } finally { reader . close ( ) ; } }
protected ConnectionStateSSLv3 ( SSLSessionImpl session ) { try { CipherSuite cipherSuite = session . cipherSuite ; boolean is_exportabe = cipherSuite . isExportable ( ) ; hash_size = cipherSuite . getMACLength ( ) ; int key_size = ( is_exportabe ) ? cipherSuite . keyMaterial : cipherSuite . expandedKeyMaterial ; int iv_size = cipherSuite . ivSize ; block_size = cipherSuite . getBlockSize ( ) ; String algName = cipherSuite . getBulkEncryptionAlgorithm ( ) ; String hashName = cipherSuite . getHashName ( ) ; if ( logger != null ) { logger . println ( STR_ ) ; logger . println ( STR_ + session . getCipherSuite ( ) ) ; logger . println ( STR_ + algName ) ; logger . println ( STR_ + hashName ) ; logger . println ( STR_ + hash_size ) ; logger . println ( STR_ + block_size ) ; logger . println ( STR_ + iv_size ) ; logger . println ( STR_ + key_size ) ; } byte [ ] clientRandom = session . clientRandom ; byte [ ] serverRandom = session . serverRandom ; byte [ ] key_block = new byte [ NUM_ . hash_size + NUM_ . key_size + NUM_ . iv_size ] ; byte [ ] seed = new byte [ clientRandom . length + serverRandom . length ] ; System . arraycopy ( serverRandom , NUM_ , seed , NUM_ , serverRandom . length ) ; System . arraycopy ( clientRandom , NUM_ , seed , serverRandom . length , clientRandom . length ) ; PRF . computePRF_SSLv3 ( key_block , session . master_secret , seed ) ; byte [ ] client_mac_secret = new byte [ hash_size ] ; byte [ ] server_mac_secret = new byte [ hash_size ] ; byte [ ] client_key = new byte [ key_size ] ; byte [ ] server_key = new byte [ key_size ] ; boolean is_client = ! session . isServer ; System . arraycopy ( key_block , NUM_ , client_mac_secret , NUM_ , hash_size ) ; System . arraycopy ( key_block , hash_size , server_mac_secret , NUM_ , hash_size ) ; System . arraycopy ( key_block , NUM_ . hash_size , client_key , NUM_ , key_size ) ; System . arraycopy ( key_block , NUM_ . hash_size + key_size , server_key , NUM_ , key_size ) ; IvParameterSpec clientIV = null ; IvParameterSpec serverIV = null ; if ( is_exportabe ) { if ( logger != null ) { logger . println ( STR_ ) ; } MessageDigest md5 = MessageDigest . getInstance ( STR_ ) ; md5 . update ( client_key ) ; md5 . update ( clientRandom ) ; md5 . update ( serverRandom ) ; client_key = md5 . digest ( ) ; md5 . update ( server_key ) ; md5 . update ( serverRandom ) ; md5 . update ( clientRandom ) ; server_key = md5 . digest ( ) ; key_size = cipherSuite . expandedKeyMaterial ; if ( block_size != NUM_ ) { md5 . update ( clientRandom ) ; md5 . update ( serverRandom ) ; clientIV = new IvParameterSpec ( md5 . digest ( ) , NUM_ , iv_size ) ; md5 . update ( serverRandom ) ; md5 . update ( clientRandom ) ; serverIV = new IvParameterSpec ( md5 . digest ( ) , NUM_ , iv_size ) ; } } else if ( block_size != NUM_ ) { clientIV = new IvParameterSpec ( key_block , NUM_ . hash_size + NUM_ . key_size , iv_size ) ; serverIV = new IvParameterSpec ( key_block , NUM_ . hash_size + NUM_ . key_size + iv_size , iv_size ) ; } if ( logger != null ) { logger . println ( STR_ + is_exportabe ) ; logger . println ( STR_ ) ; logger . print ( session . master_secret ) ; logger . println ( STR_ ) ; logger . print ( clientRandom ) ; logger . println ( STR_ ) ; logger . print ( serverRandom ) ; logger . println ( STR_ ) ; logger . print ( client_mac_secret ) ; logger . println ( STR_ ) ; logger . print ( server_mac_secret ) ; logger . println ( STR_ ) ; logger . print ( client_key , NUM_ , key_size ) ; logger . println ( STR_ ) ; logger . print ( server_key , NUM_ , key_size ) ; if ( clientIV != null ) { logger . println ( STR_ ) ; logger . print ( clientIV . getIV ( ) ) ; logger . println ( STR_ ) ; logger . print ( serverIV . getIV ( ) ) ; } else { logger . println ( STR_ ) ; } } if ( algName == null ) { encCipher = new NullCipher ( ) ; decCipher = new NullCipher ( ) ; } else { encCipher = Cipher . getInstance ( algName ) ; decCipher = Cipher . getInstance ( algName ) ; if ( is_client ) { encCipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( client_key , NUM_ , key_size , algName ) , clientIV ) ; decCipher . init ( Cipher . DECRYPT_MODE , new SecretKeySpec ( server_key , NUM_ , key_size , algName ) , serverIV ) ; } else { encCipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( server_key , NUM_ , key_size , algName ) , serverIV ) ; decCipher . init ( Cipher . DECRYPT_MODE , new SecretKeySpec ( client_key , NUM_ , key_size , algName ) , clientIV ) ; } } messageDigest = MessageDigest . getInstance ( hashName ) ; if ( is_client ) { mac_write_secret = client_mac_secret ; mac_read_secret = server_mac_secret ; } else { mac_write_secret = server_mac_secret ; mac_read_secret = client_mac_secret ; } if ( hashName . equals ( STR_ ) ) { pad_1 = SSLv3Constants . MD5pad1 ; pad_2 = SSLv3Constants . MD5pad2 ; } else { pad_1 = SSLv3Constants . SHApad1 ; pad_2 = SSLv3Constants . SHApad2 ; } } catch ( Exception e ) { e . printStackTrace ( ) ; throw new AlertException ( AlertProtocol . INTERNAL_ERROR , new SSLProtocolException ( STR_ ) ) ; } }
public static void cleanDirectory ( File directory ) throws IOException { if ( ! directory . exists ( ) ) { String message = directory + STR_ ; throw new IllegalArgumentException ( message ) ; } if ( ! directory . isDirectory ( ) ) { String message = directory + STR_ ; throw new IllegalArgumentException ( message ) ; } File [ ] files = directory . listFiles ( ) ; if ( files == null ) { throw new IOException ( STR_ + directory ) ; } IOException exception = null ; for ( File file : files ) { try { forceDelete ( file ) ; } catch ( IOException ioe ) { exception = ioe ; } } if ( null != exception ) { throw exception ; } }
public void notIdle ( ) { if ( idleTimeoutMsec . get ( ) > NUM_ ) lastActionMsec . set ( System . currentTimeMillis ( ) ) ; }
public static byte [ ] gzip ( final String input ) { final ByteArrayOutputStream baos = new FastByteArrayOutputStream ( ) ; GZIPOutputStream gzos = null ; try { gzos = new GZIPOutputStream ( baos ) ; gzos . write ( input . getBytes ( STR_ ) ) ; } catch ( final IOException e ) { MainUtil . handleError ( e ) ; } finally { if ( gzos != null ) { try { gzos . close ( ) ; } catch ( final IOException ignore ) { } } } return baos . toByteArray ( ) ; }
@ Override public void endDocument ( ) throws SAXException { if ( resource != null ) { resource . addAllResource ( jsVector ) ; for ( Object object : resource . getResourceSet ( ) ) { Resource r = ( Resource ) object ; if ( r . getResource ( ) != null ) { parser . setResource ( ( Resource ) r ) ; parser . run ( ) ; jsSet . add ( parser . getResult ( ) ) ; } } } }
public void addMethodToDisplay ( MethodIdent methodIdent ) { methods . add ( methodIdent ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return result . elements ( ) ; }
private void selectConnectingEdges ( List < DisplayNode > displayNodes ) { if ( ! isAllowNodeEdgeSelection ( ) ) { return ; } Component [ ] components = getComponents ( ) ; for ( Component comp : components ) { if ( comp instanceof IDisplayEdge ) { IDisplayEdge graphEdge = ( IDisplayEdge ) comp ; DisplayNode node1 = graphEdge . getComp1 ( ) ; DisplayNode node2 = graphEdge . getComp2 ( ) ; if ( node1 instanceof GraphNodeError ) { continue ; } if ( node2 instanceof GraphNodeError ) { continue ; } if ( node2 != null ) { boolean selected = displayNodes . contains ( node1 ) && displayNodes . contains ( node2 ) ; graphEdge . setSelected ( selected ) ; } } } }
public static String classNameOnly ( String typeName ) { String dotted = descriptorToDot ( typeName ) ; int start = dotted . lastIndexOf ( STR_ ) ; if ( start < NUM_ ) { return dotted ; } else { return dotted . substring ( start + NUM_ ) ; } }
public HyperGraph search ( ) { long startTime = System . currentTimeMillis ( ) ; Future future = new Future ( chart ) ; stacks = new ArrayList < > ( ) ; stacks . add ( null ) ; ComputeNodeResult result = new ComputeNodeResult ( this . featureFunctions , Hypothesis . BEGIN_RULE , null , - NUM_ , NUM_ , null , this . sentence ) ; Stack firstStack = new Stack ( sentence , config ) ; firstStack . add ( new Hypothesis ( result . getDPStates ( ) , future . Full ( ) ) ) ; stacks . add ( firstStack ) ; for ( int source_words = NUM_ ; source_words <= sentence . length ( ) ; ++ source_words ) { Stack targetStack = new Stack ( sentence , config ) ; stacks . add ( targetStack ) ; for ( int phrase_length = NUM_ ; phrase_length <= Math . min ( source_words - NUM_ , chart . MaxSourcePhraseLength ( ) ) ; phrase_length ++ ) { int from_stack = source_words - phrase_length ; Stack tailStack = stacks . get ( from_stack ) ; LOG . debug ( STR_ , source_words , chart . MaxSourcePhraseLength ( ) , from_stack , phrase_length ) ; for ( Coverage coverage : tailStack . getCoverages ( ) ) { ArrayList < Hypothesis > hypotheses = tailStack . get ( coverage ) ; int begin = coverage . firstZero ( ) ; int last_end = Math . min ( coverage . firstZero ( ) + config . reordering_limit , chart . SentenceLength ( ) ) ; int last_begin = ( last_end > phrase_length ) ? ( last_end - phrase_length ) : NUM_ ; for ( begin = coverage . firstZero ( ) ; begin <= last_begin ; begin ++ ) { if ( ! coverage . compatible ( begin , begin + phrase_length ) || ! permissible ( coverage , begin , begin + phrase_length ) ) { continue ; } if ( begin == sentence . length ( ) - NUM_ && source_words != sentence . length ( ) ) continue ; PhraseNodes phrases = chart . getRange ( begin , begin + phrase_length ) ; if ( phrases == null ) continue ; LOG . debug ( STR_ , phrases . size ( ) , begin , begin + phrase_length ) ; float future_delta = future . Change ( coverage , begin , begin + phrase_length ) ; Candidate cand = new Candidate ( featureFunctions , sentence , hypotheses , phrases , future_delta , new int [ ] { NUM_ , NUM_ } ) ; targetStack . addCandidate ( cand ) ; } } } targetStack . search ( ) ; } LOG . info ( STR_ , sentence . id ( ) , ( System . currentTimeMillis ( ) - startTime ) / NUM_ ) ; return createGoalNode ( ) ; }
@ Override public synchronized String toString ( ) { final StringBuffer sbResult = new StringBuffer ( ) ; sbResult . append ( STR_ ) ; sbResult . append ( getCredentialsStringRepresentation ( proxyCred ) ) ; sbResult . append ( STR_ ) ; sbResult . append ( getCredentialsStringRepresentation ( credMap ) ) ; sbResult . append ( STR_ ) ; sbResult . append ( getCookiesStringRepresentation ( cookies ) ) ; sbResult . append ( STR_ ) ; final String strResult = sbResult . toString ( ) ; return strResult ; }
public static List < LibraryLocation > gatherAllLibraries ( String [ ] dirPaths ) { List < LibraryLocation > libraries = new ArrayList < LibraryLocation > ( ) ; for ( int i = NUM_ ; i < dirPaths . length ; i ++ ) { File extDir = new File ( dirPaths [ i ] ) ; if ( extDir . isDirectory ( ) ) { String [ ] names = extDir . list ( fgArchiveFilter ) ; if ( names != null ) { for ( int j = NUM_ ; j < names . length ; j ++ ) { File jar = new File ( extDir , names [ j ] ) ; if ( jar . isFile ( ) ) { try { IPath libPath = new Path ( jar . getCanonicalPath ( ) ) ; IPath sourcePath = Path . EMPTY ; IPath packageRoot = Path . EMPTY ; URL javadocLocation = null ; URL indexLocation = null ; LibraryLocation library = new LibraryLocation ( libPath , sourcePath , packageRoot , javadocLocation , indexLocation ) ; libraries . add ( library ) ; } catch ( IOException e ) { Launching . log ( e ) ; } } } } } } return libraries ; }
public void requestClose ( ) { mLock . lock ( ) ; try { if ( mIsShutdown ) { return ; } mTargetState = TargetState . CLOSED ; update ( ) ; } finally { mLock . unlock ( ) ; } }
private void reserveOneDoc ( ) { if ( pendingNumDocs . incrementAndGet ( ) > IndexWriter . getActualMaxDocs ( ) ) { pendingNumDocs . decrementAndGet ( ) ; throw new IllegalArgumentException ( STR_ + IndexWriter . getActualMaxDocs ( ) ) ; } }
public static void streamContentToBrowser ( HttpServletResponse response , InputStream in , int length , String contentType , String fileName ) throws IOException { setResponseBrowserProxyNoCache ( response ) ; response . setContentLength ( length ) ; if ( contentType != null ) { response . setContentType ( contentType ) ; } if ( fileName != null ) { response . setHeader ( STR_ , STR_ + fileName + STR_ ) ; } OutputStream out = response . getOutputStream ( ) ; try { streamContent ( out , in , length ) ; } catch ( IOException e ) { out . close ( ) ; throw e ; } out . flush ( ) ; out . close ( ) ; }
@ Override public String toString ( ) { return toString ( BOOL_ ) ; }
private static boolean isValidMethodName ( String methodName ) { return methodName . matches ( STR_ ) ; }
public static byte [ ] toUTF8 ( String s ) { byte [ ] result = new byte [ utfLength ( s ) ] ; int result_index = NUM_ ; for ( int i = NUM_ , n = s . length ( ) ; i < n ; ++ i ) { char c = s . charAt ( i ) ; if ( ( ( ! WRITE_PSEUDO_UTF8 ) || ( c >= x0001 ) ) && ( c <= x007F ) ) { result [ result_index ++ ] = ( byte ) c ; } else if ( c > x07FF ) { result [ result_index ++ ] = ( byte ) ( xe0 | ( byte ) ( c > > NUM_ ) ) ; result [ result_index ++ ] = ( byte ) ( x80 | ( ( c & xfc0 ) > > NUM_ ) ) ; result [ result_index ++ ] = ( byte ) ( x80 | ( c & x3f ) ) ; } else { result [ result_index ++ ] = ( byte ) ( xc0 | ( byte ) ( c > > NUM_ ) ) ; result [ result_index ++ ] = ( byte ) ( x80 | ( c & x3f ) ) ; } } return result ; }
public void pln ( Object o ) throws IOException { p ( o . toString ( ) ) ; pln ( ) ; }
public void testReduceTask ( ) throws Exception { HadoopJob gridJob = getHadoopJob ( igfsScheme ( ) + PATH_INPUT , igfsScheme ( ) + PATH_OUTPUT ) ; runTaskWithInput ( gridJob , HadoopTaskType . REDUCE , NUM_ , STR_ , STR_ , STR_ , STR_ ) ; runTaskWithInput ( gridJob , HadoopTaskType . REDUCE , NUM_ , STR_ , STR_ , STR_ , STR_ ) ; assertEquals ( STR_ + STR_ , readAndSortFile ( PATH_OUTPUT + STR_ + getOutputFileNamePrefix ( ) + STR_ ) ) ; assertEquals ( STR_ + STR_ , readAndSortFile ( PATH_OUTPUT + STR_ + getOutputFileNamePrefix ( ) + STR_ ) ) ; }
public void deleteConditional ( Conditional c ) { deregister ( c ) ; }
public static void parseModelToContentValues ( Object model , ContentValues contentValues ) { if ( contentValues . size ( ) > NUM_ ) contentValues . clear ( ) ; Class < ? > clazz = model . getClass ( ) ; Field [ ] fields = clazz . getDeclaredFields ( ) ; Class < ? > fieldType = null ; Object fieldVal = null ; for ( Field field : fields ) { try { if ( field . isAccessible ( ) == BOOL_ ) field . setAccessible ( BOOL_ ) ; Column column = field . getAnnotation ( Column . class ) ; fieldType = field . getType ( ) ; fieldVal = field . get ( model ) ; if ( column == null || fieldVal == null ) continue ; if ( fieldType . equals ( int . class ) ) { contentValues . put ( column . name ( ) , field . getInt ( model ) ) ; } else if ( fieldType . equals ( Integer . class ) ) { contentValues . put ( column . name ( ) , ( Integer ) field . get ( model ) ) ; } else if ( fieldType . equals ( short . class ) ) { contentValues . put ( column . name ( ) , field . getShort ( model ) ) ; } else if ( fieldType . equals ( Short . class ) ) { contentValues . put ( column . name ( ) , ( Short ) field . get ( model ) ) ; } else if ( fieldType . equals ( long . class ) ) { contentValues . put ( column . name ( ) , field . getLong ( model ) ) ; } else if ( fieldType . equals ( Long . class ) ) { contentValues . put ( column . name ( ) , ( Long ) field . get ( model ) ) ; } else if ( fieldType . equals ( float . class ) ) { contentValues . put ( column . name ( ) , field . getFloat ( model ) ) ; } else if ( fieldType . equals ( Float . class ) ) { contentValues . put ( column . name ( ) , ( Float ) field . get ( model ) ) ; } else if ( fieldType . equals ( double . class ) ) { contentValues . put ( column . name ( ) , field . getDouble ( model ) ) ; } else if ( fieldType . equals ( Double . class ) ) { contentValues . put ( column . name ( ) , ( Double ) field . get ( model ) ) ; } else if ( fieldType . equals ( boolean . class ) ) { if ( field . getBoolean ( model ) == BOOL_ ) { contentValues . put ( column . name ( ) , STR_ ) ; } else { contentValues . put ( column . name ( ) , STR_ ) ; } } else if ( fieldType . equals ( Boolean . class ) ) { if ( ( Boolean ) field . get ( model ) == BOOL_ ) { contentValues . put ( column . name ( ) , STR_ ) ; } else { contentValues . put ( column . name ( ) , STR_ ) ; } } else if ( fieldType . equals ( String . class ) ) { contentValues . put ( column . name ( ) , ( String ) field . get ( model ) ) ; } else if ( fieldType . equals ( byte [ ] . class ) ) { contentValues . put ( column . name ( ) , ( byte [ ] ) field . get ( model ) ) ; } else if ( fieldType . equals ( Date . class ) ) { Date date = ( Date ) field . get ( model ) ; contentValues . put ( column . name ( ) , DateUtils . formatDate2Str ( date ) ) ; } } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } } }
private void addBlockToWorklist ( SsaBasicBlock ssaBlock ) { if ( ! executableBlocks . get ( ssaBlock . getIndex ( ) ) ) { cfgWorklist . add ( ssaBlock ) ; executableBlocks . set ( ssaBlock . getIndex ( ) ) ; } else { cfgPhiWorklist . add ( ssaBlock ) ; } }
private static boolean is32BitJvm ( ) { Integer bits = Integer . getInteger ( STR_ ) ; return bits != null && bits == NUM_ ; }
public float angle ( ) { return ( float ) Math . atan2 ( y ( ) , x ( ) ) ; }
public static String formatNumber ( double value , int numberOfDigits , boolean groupingCharacters ) { if ( Double . isNaN ( value ) ) { return STR_ ; } int numberDigits = numberOfDigits ; if ( numberDigits < NUM_ ) { numberDigits = numberOfFractionDigits ; } NUMBER_FORMAT . setMinimumFractionDigits ( numberDigits ) ; NUMBER_FORMAT . setMaximumFractionDigits ( numberDigits ) ; NUMBER_FORMAT . setGroupingUsed ( groupingCharacters ) ; return NUMBER_FORMAT . format ( value ) ; }
private JPanel createLegendPanel ( JPanel basePanel ) { final JPanel panel ; if ( basePanel != null ) { basePanel . removeAll ( ) ; basePanel . setLayout ( new GridBagLayout ( ) ) ; panel = basePanel ; } else { panel = new JPanel ( new GridBagLayout ( ) ) ; } panel . setBorder ( BorderFactory . createTitledBorder ( I18n . tr ( STR_ ) ) ) ; GridBagConstraints gbc = new GridBagConstraints ( ) ; gbc . anchor = GridBagConstraints . WEST ; gbc . insets = new Insets ( NUM_ , NUM_ , NUM_ , NUM_ ) ; JCheckBox checkBox = new JCheckBox ( ) ; checkBox . setSelected ( BOOL_ ) ; panel . add ( createIconLabel ( checkBox ) , gbc ) ; MultiLineLabel label = new MultiLineLabel ( I18n . tr ( STR_ ) , BOOL_ ) ; GridBagConstraints labelGbc = new GridBagConstraints ( ) ; labelGbc . anchor = GridBagConstraints . WEST ; labelGbc . fill = GridBagConstraints . HORIZONTAL ; labelGbc . gridwidth = GridBagConstraints . REMAINDER ; labelGbc . gridx = NUM_ ; labelGbc . weightx = NUM_ ; panel . add ( label , labelGbc ) ; checkBox . setSelected ( BOOL_ ) ; gbc . gridy = NUM_ ; panel . add ( createIconLabel ( checkBox ) , gbc ) ; label = new MultiLineLabel ( I18n . tr ( STR_ ) , BOOL_ ) ; labelGbc . gridy = NUM_ ; panel . add ( label , labelGbc ) ; checkBox . setIcon ( partiallyIncludedIcon ) ; gbc . gridy = NUM_ ; gbc . insets = new Insets ( NUM_ , NUM_ , NUM_ , NUM_ ) ; panel . add ( createIconLabel ( checkBox ) , gbc ) ; label = new MultiLineLabel ( I18n . tr ( STR_ ) , BOOL_ ) ; labelGbc . gridy = NUM_ ; gbc . insets = null ; panel . add ( label , labelGbc ) ; return panel ; }
private static boolean isTrashId ( IgniteUuid id ) { if ( id == null ) return BOOL_ ; UUID gid = id . globalId ( ) ; return id . localId ( ) == NUM_ && gid . getMostSignificantBits ( ) == NUM_ && gid . getLeastSignificantBits ( ) > NUM_ && gid . getLeastSignificantBits ( ) <= TRASH_CONCURRENCY ; }
private void onTimeElementEnd ( ) throws SAXException { try { timeMs = XML_DATE_TIME_FORMAT . parseMillis ( content . trim ( ) ) ; } catch ( IllegalArgumentException e ) { throw new SAXException ( createErrorMessage ( STR_ + content ) , e ) ; } }
public void addChangeListener ( ChangeListener l ) { m_ChangeListeners . add ( l ) ; }
public static boolean isClassPresent ( String fullyQualifiedClassName ) { try { Class . forName ( fullyQualifiedClassName ) ; return BOOL_ ; } catch ( ClassNotFoundException e ) { return BOOL_ ; } }
void unlink ( Node < E > p , Node < E > trail ) { p . setValue ( null ) ; trail . next = p . next ; if ( last == p ) last = trail ; if ( count . getAndDecrement ( ) == capacity ) notFull . signal ( ) ; }
@ TargetApi ( Build . VERSION_CODES . JELLY_BEAN ) private int queueInputBuffer ( MediaCodec codec , ByteBuffer [ ] inputBuffers , int index , SpeechRecord speechRecord ) { if ( speechRecord == null || speechRecord . getRecordingState ( ) != SpeechRecord . RECORDSTATE_RECORDING ) { return - NUM_ ; } if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . JELLY_BEAN ) { ByteBuffer inputBuffer = inputBuffers [ index ] ; inputBuffer . clear ( ) ; int size = inputBuffer . limit ( ) ; byte [ ] buffer = new byte [ size ] ; int status = read ( speechRecord , buffer ) ; if ( status < NUM_ ) { handleError ( STR_ + status ) ; return - NUM_ ; } inputBuffer . put ( buffer ) ; codec . queueInputBuffer ( index , NUM_ , size , NUM_ , NUM_ ) ; return size ; } return - NUM_ ; }
@ Override public final void sample ( ) { long count = _count . getAndSet ( NUM_ ) ; long time = _time . getAndSet ( NUM_ ) ; if ( count == NUM_ ) _value = NUM_ ; else _value = time / ( double ) count ; }
protected void validateProperties ( final Object entity , final EntityDataModel edm ) throws ODataException { final Type type = edm . getType ( entity . getClass ( ) ) ; if ( ! ( type instanceof StructuredType ) ) { return ; } visitProperties ( edm , ( StructuredType ) type , null ) ; }
static AdbResponse readAdbResponse ( SocketChannel chan , boolean readDiagString ) throws TimeoutException , IOException { AdbResponse resp = new AdbResponse ( ) ; byte [ ] reply = new byte [ NUM_ ] ; read ( chan , reply ) ; if ( isOkay ( reply ) ) { resp . okay = BOOL_ ; } else { readDiagString = BOOL_ ; resp . okay = BOOL_ ; } try { while ( readDiagString ) { byte [ ] lenBuf = new byte [ NUM_ ] ; read ( chan , lenBuf ) ; String lenStr = replyToString ( lenBuf ) ; int len ; try { len = Integer . parseInt ( lenStr , NUM_ ) ; } catch ( NumberFormatException nfe ) { Log . w ( STR_ , STR_ + lenStr + STR_ + lenBuf [ NUM_ ] + STR_ + lenBuf [ NUM_ ] + STR_ + lenBuf [ NUM_ ] + STR_ + lenBuf [ NUM_ ] ) ; Log . w ( STR_ , STR_ + replyToString ( reply ) ) ; break ; } byte [ ] msg = new byte [ len ] ; read ( chan , msg ) ; resp . message = replyToString ( msg ) ; Log . v ( STR_ , STR_ + replyToString ( reply ) + STR_ + resp . message + STR_ ) ; break ; } } catch ( Exception e ) { } return resp ; }
public void removeMouseMode ( String id ) { for ( MapMouseMode med : mouseModes ) { if ( id . equals ( med . getID ( ) ) ) { removeMouseMode ( med ) ; break ; } } }
private Boolean filterExistingItems ( List < PostItem > postItems , PostItem item ) { if ( postItems . contains ( item ) ) { int i = postItems . indexOf ( item ) ; postItems . remove ( i ) ; postItems . add ( i , item ) ; return BOOL_ ; } return BOOL_ ; }
DateRange buildShiftedRange ( DateRange rawRange , long cadence , long now ) { if ( rawRange . getStart ( ) > now ) { throw new IllegalArgumentException ( STR_ ) ; } final DateRange rounded = rawRange . rounded ( cadence ) ; final long nowDelta = now - rounded . getEnd ( ) ; if ( nowDelta > SHIFT_TOLERANCE ) { return rounded ; } final long diff = Math . abs ( Math . min ( nowDelta , NUM_ ) ) + SHIFT_TOLERANCE ; return rounded . shift ( - toleranceShiftPeriod ( diff , cadence ) ) ; }
public static void upto ( Date self , Date to , Closure closure ) { if ( self . compareTo ( to ) <= NUM_ ) { for ( Date i = ( Date ) self . clone ( ) ; i . compareTo ( to ) <= NUM_ ; i = next ( i ) ) { closure . call ( i ) ; } } else throw new GroovyRuntimeException ( STR_ + to + STR_ + self + STR_ ) ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Element testEmployee ; Node firstC ; String childName ; int nodeType ; CharacterData employeeIDNode ; String employeeID ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; testEmployee = ( Element ) elementList . item ( NUM_ ) ; firstC = testEmployee . getFirstChild ( ) ; nodeType = ( int ) firstC . getNodeType ( ) ; while ( equals ( NUM_ , nodeType ) ) { firstC = firstC . getNextSibling ( ) ; nodeType = ( int ) firstC . getNodeType ( ) ; } childName = firstC . getNodeName ( ) ; assertEqualsAutoCase ( STR_ , STR_ , STR_ , childName ) ; employeeIDNode = ( CharacterData ) firstC . getFirstChild ( ) ; employeeID = employeeIDNode . getNodeValue ( ) ; assertEquals ( STR_ , STR_ , employeeID ) ; }
public InferenceContext ( N4JSTypeSystem ts , TypeSystemHelper tsh , CancelIndicator cancelIndicator , RuleEnvironment G , InferenceVariable ... inferenceVariables ) { Objects . requireNonNull ( ts ) ; Objects . requireNonNull ( tsh ) ; Objects . requireNonNull ( cancelIndicator ) ; Objects . requireNonNull ( G ) ; this . ts = ts ; this . tsh = tsh ; this . cancelIndicator = cancelIndicator ; this . G = G ; addInferenceVariables ( BOOL_ , inferenceVariables ) ; this . reducer = new Reducer ( this , G , ts , tsh ) ; this . currentBounds = new BoundSet ( this , G , ts ) ; }
@ Override public void run ( ) throws InterruptedException , CameraAccessException , CameraCaptureSessionClosedException , ResourceAcquisitionFailedException { FrameServer . Session session = mFrameServer . tryCreateExclusiveSession ( ) ; if ( session == null ) { return ; } try { AFTriggerResult afScanResult = new AFTriggerResult ( ) ; RequestBuilder idleBuilder = createAFIdleRequest ( null ) ; session . submitRequest ( Arrays . asList ( idleBuilder . build ( ) ) , FrameServer . RequestType . REPEATING ) ; RequestBuilder cancelBuilder = createAFCancelRequest ( null ) ; session . submitRequest ( Arrays . asList ( cancelBuilder . build ( ) ) , FrameServer . RequestType . NON_REPEATING ) ; idleBuilder = createAFIdleRequest ( afScanResult ) ; session . submitRequest ( Arrays . asList ( idleBuilder . build ( ) ) , FrameServer . RequestType . REPEATING ) ; RequestBuilder triggerBuilder = createAFTriggerRequest ( afScanResult ) ; session . submitRequest ( Arrays . asList ( triggerBuilder . build ( ) ) , FrameServer . RequestType . NON_REPEATING ) ; afScanResult . get ( ) ; } finally { session . close ( ) ; } }
protected List < Node > createDiscreteVariableList ( DiscreteVariableAnalysis variableAnalysis ) { List < Node > nodes = new ArrayList < > ( variableAnalysis . getNumOfCols ( ) ) ; DiscreteVarInfo [ ] variables = variableAnalysis . getDiscreteVarInfos ( ) ; for ( DiscreteVarInfo variable : variables ) { if ( variable != null ) { nodes . add ( new DiscreteVariable ( variable . getName ( ) , variable . getCategories ( ) ) ) ; } } return nodes ; }
private void pullEvent ( ) { final int newScrollValue ; final int itemDimension ; final float initialMotionValue , lastMotionValue ; switch ( getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : initialMotionValue = mInitialMotionX ; lastMotionValue = mLastMotionX ; break ; case VERTICAL : default : initialMotionValue = mInitialMotionY ; lastMotionValue = mLastMotionY ; break ; } switch ( mCurrentMode ) { case PULL_FROM_END : newScrollValue = Math . round ( Math . max ( initialMotionValue - lastMotionValue , NUM_ ) / FRICTION ) ; itemDimension = getFooterSize ( ) ; break ; case PULL_FROM_START : default : newScrollValue = Math . round ( Math . min ( initialMotionValue - lastMotionValue , NUM_ ) / FRICTION ) ; itemDimension = getHeaderSize ( ) ; break ; } setHeaderScroll ( newScrollValue ) ; if ( newScrollValue != NUM_ && ! isRefreshing ( ) ) { float scale = Math . abs ( newScrollValue ) / ( float ) itemDimension ; switch ( mCurrentMode ) { case PULL_FROM_END : mFooterLayout . onPull ( scale ) ; break ; case PULL_FROM_START : default : mHeaderLayout . onPull ( scale ) ; break ; } if ( mState != State . PULL_TO_REFRESH && itemDimension >= Math . abs ( newScrollValue ) ) { setState ( State . PULL_TO_REFRESH ) ; } else if ( mState == State . PULL_TO_REFRESH && itemDimension < Math . abs ( newScrollValue ) ) { setState ( State . RELEASE_TO_REFRESH ) ; } } }
public synchronized void removeSeries ( XYSeries series ) { mSeries . remove ( series ) ; }
private void synchronizeTables ( ) { resetDBObjects ( DBObject_Table . class ) ; s_logger . log ( Level . CONFIG , STR_ ) ; s_logger . log ( Level . CONFIG , STR_ , new Object [ ] { m_objectTypes , m_direction } ) ; m_counterDrp = new Integer ( NUM_ ) ; m_counterAdd = new Integer ( NUM_ ) ; m_counterUpd = new Integer ( NUM_ ) ; m_totalDrp = new Integer ( NUM_ ) ; m_totalAdd = new Integer ( NUM_ ) ; m_totalUpd = new Integer ( NUM_ ) ; for ( Iterator < String > tableIterator = m_objectList . iterator ( ) ; tableIterator . hasNext ( ) ; ) { String key = tableIterator . next ( ) ; DBObject sourceObj = m_sourceMap . get ( key ) ; DBObject targetObj = m_targetMap . get ( key ) ; if ( targetObj != null && sourceObj == null ) { if ( targetObj . getCustomizationLevel ( ) == s_parameters . CUSTOMNONE ) { if ( targetObj . drop ( ) ) m_counterDrp = new Integer ( m_counterDrp . intValue ( ) + NUM_ ) ; m_totalDrp = new Integer ( m_totalDrp . intValue ( ) + NUM_ ) ; } else { s_logger . log ( Level . WARNING , STR_ , new Object [ ] { m_objectType , targetObj . getName ( ) } ) ; } } if ( targetObj != null && sourceObj != null ) { if ( targetObj . update ( sourceObj ) ) m_counterUpd = new Integer ( m_counterUpd . intValue ( ) + NUM_ ) ; m_totalUpd = new Integer ( m_totalUpd . intValue ( ) + NUM_ ) ; } if ( targetObj == null && sourceObj != null ) { if ( sourceObj . create ( m_target ) ) m_counterAdd = new Integer ( m_counterAdd . intValue ( ) + NUM_ ) ; m_totalAdd = new Integer ( m_totalAdd . intValue ( ) + NUM_ ) ; } } logResults ( ) ; }
public void remoteRestartCoordinator ( String nodeId , String type ) throws LocalRepositoryException { final String prefix = String . format ( STR_ , type , nodeId ) ; _log . debug ( prefix ) ; final String [ ] cmd = { _SYSTOOL_CMD , _SYSTOOL_REMOTE_SYSTOOL , nodeId , _SYSTOOL_RESTART_COORDINATOR , type } ; final Exec . Result result = Exec . sudo ( _SYSTOOL_TIMEOUT , cmd ) ; checkFailure ( result , prefix ) ; }
private static String intToString ( int value , int digit ) { StringBuilder stringBuilder = new StringBuilder ( digit ) ; stringBuilder . append ( Integer . toString ( value ) ) ; while ( stringBuilder . length ( ) < digit ) { stringBuilder . insert ( NUM_ , STR_ ) ; } return stringBuilder . toString ( ) ; }
void add ( int n ) { if ( v == null ) { v = new int [ INIT_SIZE ] ; v [ NUM_ ] = n ; len = NUM_ ; return ; } if ( len == v . length ) { int [ ] newv = new int [ len . NUM_ ] ; System . arraycopy ( v , NUM_ , newv , NUM_ , len ) ; v = newv ; } if ( n > v [ len - NUM_ ] ) { v [ len ++ ] = n ; return ; } int i = NUM_ ; for ( ; i < len ; i ++ ) { if ( n <= v [ i ] ) { if ( n == v [ i ] ) return ; break ; } } for ( int j = len ; j >= i ; j -- ) v [ j + NUM_ ] = v [ j ] ; v [ i ] = n ; ++ len ; }
public static String replace ( String source , String target , String replacement ) { StringBuffer output = new StringBuffer ( ) ; int n = NUM_ ; while ( BOOL_ ) { int off = source . indexOf ( target , n ) ; if ( off == - NUM_ ) { output . append ( source . substring ( n ) ) ; break ; } output . append ( source . substring ( n , off ) ) ; output . append ( replacement ) ; n = off + target . length ( ) ; } return output . toString ( ) ; }
public void correctNullReceiver ( ) { if ( args [ NUM_ ] != null ) return ; handle = handle . bindTo ( NullObject . getNullObject ( ) ) ; handle = MethodHandles . dropArguments ( handle , NUM_ , targetType . parameterType ( NUM_ ) ) ; if ( LOG_ENABLED ) LOG . info ( STR_ ) ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
public static String numberToString ( Number number ) throws JSONException { if ( number == null ) { throw new JSONException ( STR_ ) ; } testValidity ( number ) ; String string = number . toString ( ) ; if ( string . indexOf ( STR_ ) > NUM_ && string . indexOf ( STR_ ) < NUM_ && string . indexOf ( STR_ ) < NUM_ ) { while ( string . endsWith ( STR_ ) ) { string = string . substring ( NUM_ , string . length ( ) - NUM_ ) ; } if ( string . endsWith ( STR_ ) ) { string = string . substring ( NUM_ , string . length ( ) - NUM_ ) ; } } return string ; }
public static boolean isPairedEndDirectory ( final File dir ) { if ( dir == null || ! dir . exists ( ) || ! dir . isDirectory ( ) ) { return BOOL_ ; } final File lDir = new File ( dir , STR_ ) ; final File rDir = new File ( dir , STR_ ) ; return lDir . exists ( ) && rDir . exists ( ) && lDir . isDirectory ( ) && rDir . isDirectory ( ) ; }
@ SuppressWarnings ( STR_ ) private void checkClassNotFound ( ) throws Exception { initGar = BOOL_ ; try { Ignite ignite1 = startGrid ( NUM_ ) ; Ignite ignite2 = startGrid ( NUM_ ) ; Class task = extLdr . loadClass ( TASK_NAME ) ; try { ignite1 . compute ( ) . execute ( task , ignite2 . cluster ( ) . localNode ( ) . id ( ) ) ; assert BOOL_ ; } catch ( IgniteException e ) { info ( STR_ + e ) ; } } finally { stopGrid ( NUM_ ) ; stopGrid ( NUM_ ) ; } }
public String dropEngine ( Engine engine ) { StringBuilder builder = new StringBuilder ( ) ; for ( String attribute : Setup . getDropEngineMessageFormat ( ) ) { builder . append ( getEngineAttribute ( engine , attribute , ! PICKUP ) ) ; } return builder . toString ( ) ; }
public Iterator < JsonElement > iterator ( ) { return elements . iterator ( ) ; }
protected void popWriteContext ( ) { writeContext_ = writeContextStack_ . pop ( ) ; }
public long calculateEndTime ( ) { if ( endTime == NUM_ ) { return System . currentTimeMillis ( ) ; } else if ( endTime < NUM_ ) { return System . currentTimeMillis ( ) - endTime ; } return endTime ; }
protected String extractAlternateOpenQuote ( String token ) { return null ; }
private boolean removeIndexEntry ( ServiceType resourceType , String resourceName , String policyName ) throws PolicyException { ResourceIndex resourceIndex = ( ResourceIndex ) resourceIndices . get ( resourceType . getName ( ) ) ; if ( resourceIndex == null ) { resourceIndex = refreshResourceIndexFromDataStore ( resourceType ) ; } return resourceIndex . removeIndexEntry ( resourceName , policyName ) ; }
public static TextBlock parseTextBlock ( ParseContext parseContext ) { return TextBlockSectionParser . parseTextBlock ( parseContext ) ; }
public final static boolean inLongRange ( char [ ] digitChars , int offset , int len , boolean negative ) { String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR ; int cmpLen = cmpStr . length ( ) ; if ( len < cmpLen ) return BOOL_ ; if ( len > cmpLen ) return BOOL_ ; for ( int i = NUM_ ; i < cmpLen ; ++ i ) { if ( digitChars [ offset + i ] > cmpStr . charAt ( i ) ) { return BOOL_ ; } } return BOOL_ ; }
public static Collection < DebuggerException > mergeExceptionsSettings ( final DebugTargetSettings target , final Collection < DebuggerException > exceptions , final int debuggerId ) throws CouldntLoadDataException { final Map < Long , DebuggerException > exceptionsMap = getExceptionsMap ( exceptions ) ; for ( final DebuggerException dbgException : exceptions ) { final String setting = target . readSetting ( DebuggerException . getSettingKey ( dbgException , debuggerId ) ) ; if ( setting != null ) { final DebuggerExceptionHandlingAction handlingAction = DebuggerExceptionHandlingAction . convertToHandlingAction ( Integer . valueOf ( setting ) ) ; final DebuggerException newException = new DebuggerException ( dbgException . getExceptionName ( ) , dbgException . getExceptionCode ( ) , handlingAction ) ; exceptionsMap . put ( dbgException . getExceptionCode ( ) , newException ) ; } } return exceptionsMap . values ( ) ; }
public void verifyAnnotation ( String methodName , String annotationName ) throws Exception { Class clazz = Class . forName ( className ) ; Method method = clazz . getDeclaredMethod ( methodName ) ; Class annotationClazz = Class . forName ( annotationName ) ; java . lang . annotation . Annotation annotation = method . getAnnotation ( annotationClazz ) ; Assert . assertNotNull ( annotation ) ; }
public static < V > int addDistinctList ( List < V > sourceList , List < V > entryList ) { if ( sourceList == null || isEmpty ( entryList ) ) { return NUM_ ; } int sourceCount = sourceList . size ( ) ; for ( V entry : entryList ) { if ( ! sourceList . contains ( entry ) ) { sourceList . add ( entry ) ; } } return sourceList . size ( ) - sourceCount ; }
public PublisherAmb < T > ambAdditionalSource ( Publisher < ? extends T > source ) { if ( array != null ) { int n = array . length ; @ SuppressWarnings ( STR_ ) Publisher < ? extends T > [ ] newArray = new Publisher [ n + NUM_ ] ; System . arraycopy ( array , NUM_ , newArray , NUM_ , n ) ; newArray [ n ] = source ; return new PublisherAmb < > ( newArray ) ; } return null ; }
public void beginDisplay ( DisplayEvent event ) throws ModelControlException { super . beginDisplay ( event ) ; String siteName = ( String ) getPageSessionAttribute ( PG_ATTR_SITE_NAME ) ; ServerSiteModel model = ( ServerSiteModel ) getModel ( ) ; ptModel . setPageTitleText ( model . getEditSitePageTitle ( siteName ) ) ; try { setDisplayFieldValue ( TF_URL , model . getSitePrimaryURL ( siteName ) ) ; getFailoverURLs ( siteName , model ) ; getServers ( siteName , model ) ; } catch ( AMConsoleException e ) { setInlineAlertMessage ( CCAlert . TYPE_ERROR , STR_ , e . getMessage ( ) ) ; } }
public boolean add ( AccessibleState state ) { if ( states == null ) { states = new Vector ( ) ; } if ( ! states . contains ( state ) ) { states . addElement ( state ) ; return BOOL_ ; } else { return BOOL_ ; } }
public static final String readFile ( File file ) throws IOException { BufferedInputStream in = null ; try { in = new BufferedInputStream ( new FileInputStream ( file ) ) ; SimpleByteBuffer buffer = new SimpleByteBuffer ( ) ; byte [ ] buf = new byte [ NUM_ ] ; int len ; while ( ( len = in . read ( buf ) ) != - NUM_ ) { buffer . put ( buf , len ) ; } return new String ( buffer . buffer , NUM_ , buffer . write ) ; } finally { if ( null != in ) { in . close ( ) ; } } }
void addDecimalPoint ( ) { this . displayMode = DISPLAY_MODE . INPUT ; if ( this . clearOnNextDigit ) { setDisplayString ( EMPTY_STRING ) ; } final String inputString = getDisplayString ( ) ; if ( inputString . indexOf ( DOT_CHARACTER ) < NUM_ ) { setDisplayString ( inputString + DOT_CHARACTER ) ; } }
public void close ( ) throws java . io . IOException { m_os . close ( ) ; }
void show ( ) { if ( mIsVisible ) return ; mIsVisible = BOOL_ ; mHeightPx = Math . round ( mDefaultHeightPx ) ; invalidate ( ) ; }
public void recordMirrorOperation ( DbClient dbClient , OperationTypeEnum opType , Operation . Status status , Object ... extParam ) { try { boolean opStatus = ( Operation . Status . ready == status ) ? BOOL_ : BOOL_ ; String evType ; evType = opType . getEvType ( opStatus ) ; String evDesc = opType . getDescription ( ) ; String opStage = AuditLogManager . AUDITOP_END ; _logger . info ( STR_ , opType . toString ( ) , evType . toString ( ) + STR_ + evDesc ) ; recordBourneMirrorEvent ( dbClient , getId ( ) , evType , status , evDesc ) ; switch ( opType ) { case CREATE_FILE_MIRROR : case START_FILE_MIRROR : case SUSPEND_FILE_MIRROR : case DETACH_FILE_MIRROR : case PAUSE_FILE_MIRROR : case RESUME_FILE_MIRROR : case FAILOVER_FILE_MIRROR : case STOP_FILE_MIRROR : case FAILBACK_FILE_MIRROR : case RESYNC_FILE_MIRROR : case REFRESH_FILE_MIRROR : case MODIFY_FILE_MIRROR_RPO : auditFile ( dbClient , opType , opStatus , opStage , extParam ) ; break ; default : _logger . error ( STR_ ) ; } } catch ( Exception e ) { _logger . error ( STR_ , opType . toString ( ) , e ) ; } }
private void cancelTakeImage ( ) { mShootedPicturePath = null ; mSelectedGalleryItemsList . clear ( ) ; VectorApp . setSavedCameraImagePreview ( null ) ; startCameraPreview ( ) ; updateUiConfiguration ( UI_SHOW_CAMERA_PREVIEW , IMAGE_ORIGIN_CAMERA ) ; }
protected int nextGridToRestart ( ) { if ( currRestartGridId == serverCount ( ) ) currRestartGridId = NUM_ ; return ++ currRestartGridId ; }
public void charactersRaw ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( isOutsideDocElem ( ) && XMLCharacterRecognizer . isWhiteSpace ( ch , start , length ) ) return ; String s = new String ( ch , start , length ) ; append ( m_doc . createProcessingInstruction ( STR_ , STR_ ) ) ; append ( m_doc . createTextNode ( s ) ) ; }
private void removeStaleIteratorReferences ( ) { removeStaleReferences ( iteratorReferenceQueue , iterators ) ; }
boolean destroyIGroup ( boolean force ) { NaElement elem = new NaElement ( STR_ ) ; elem . addNewChild ( STR_ , name ) ; elem . addNewChild ( STR_ , Boolean . toString ( force ) ) ; try { server . invokeElem ( elem ) ; } catch ( Exception e ) { String msg = STR_ + name ; log . error ( msg , e ) ; throw new NetAppException ( msg , e ) ; } return BOOL_ ; }
@ Override public double finiteDifferenceEpsilon ( ) { return NUM_ ; }
public void remove ( final HttpConnection connection ) { log . debug ( STR_ + connection . getID ( ) ) ; connectionToAdded . remove ( connection ) ; }
public void putByte ( long pos , byte val ) { unsafe . putByte ( pos + addr , val ) ; }
public void addReference ( MessagePart reference ) { references . add ( reference ) ; }
protected boolean [ ] datasetIntegrity ( AttrTypes attrTypes , int classType , boolean attributeMissing , boolean classMissing ) { Estimator estimator = null ; print ( STR_ ) ; printAttributeSummary ( attrTypes , classType ) ; print ( STR_ ) ; int numTrain = getNumInstances ( ) ; getNumInstances ( ) ; int numClasses = NUM_ , missingLevel = NUM_ ; boolean [ ] result = new boolean [ NUM_ ] ; Instances train = null ; boolean built = BOOL_ ; try { train = makeTestDataset ( NUM_ , numTrain , NUM_ , attrTypes , numClasses , classType ) ; int attrIndex = NUM_ ; if ( missingLevel > NUM_ ) { addMissing ( train , missingLevel , attributeMissing , classMissing , attrIndex ) ; } estimator = Estimator . makeCopies ( getEstimator ( ) , NUM_ ) [ NUM_ ] ; } catch ( Exception ex ) { throw new Error ( STR_ + ex . getMessage ( ) ) ; } try { Instances trainCopy = new Instances ( train ) ; int attrIndex = NUM_ ; estimator . addValues ( trainCopy , attrIndex ) ; compareDatasets ( train , trainCopy ) ; built = BOOL_ ; println ( STR_ ) ; result [ NUM_ ] = BOOL_ ; } catch ( Exception ex ) { println ( STR_ ) ; result [ NUM_ ] = BOOL_ ; if ( m_Debug ) { println ( STR_ ) ; print ( STR_ ) ; if ( built ) { print ( STR_ ) ; } else { print ( STR_ ) ; } println ( STR_ + ex . getMessage ( ) + STR_ ) ; println ( STR_ ) ; println ( STR_ + train . toString ( ) + STR_ ) ; } } return result ; }
@ Override public void addFocusables ( ArrayList < View > views , int direction , int focusableMode ) { final int focusableCount = views . size ( ) ; final int descendantFocusability = getDescendantFocusability ( ) ; if ( descendantFocusability != FOCUS_BLOCK_DESCENDANTS ) { for ( int i = NUM_ ; i < getChildCount ( ) ; i ++ ) { final View child = getChildAt ( i ) ; if ( child . getVisibility ( ) == VISIBLE ) { ItemInfo ii = infoForChild ( child ) ; if ( ii != null && ii . position == mCurItem ) { child . addFocusables ( views , direction , focusableMode ) ; } } } } if ( descendantFocusability != FOCUS_AFTER_DESCENDANTS || ( focusableCount == views . size ( ) ) ) { if ( ! isFocusable ( ) ) { return ; } if ( ( focusableMode & FOCUSABLES_TOUCH_MODE ) == FOCUSABLES_TOUCH_MODE && isInTouchMode ( ) && ! isFocusableInTouchMode ( ) ) { return ; } if ( views != null ) { views . add ( this ) ; } } }
protected DateTimeData parse ( String str ) throws SchemaDateTimeException { DateTimeData date = new DateTimeData ( str , this ) ; int len = str . length ( ) ; if ( str . charAt ( NUM_ ) != STR_ || str . charAt ( NUM_ ) != STR_ || str . charAt ( NUM_ ) != STR_ ) { throw new SchemaDateTimeException ( STR_ ) ; } date . year = YEAR ; date . month = MONTH ; date . day = parseInt ( str , NUM_ , NUM_ ) ; if ( DAY_SIZE < len ) { if ( ! isNextCharUTCSign ( str , DAY_SIZE , len ) ) { throw new SchemaDateTimeException ( STR_ ) ; } else { getTimeZone ( str , date , DAY_SIZE , len ) ; } } validateDateTime ( date ) ; saveUnnormalized ( date ) ; if ( date . utc != NUM_ && date . utc != STR_ ) { normalize ( date ) ; } date . position = NUM_ ; return date ; }
public static Map < String , Set < String > > parse ( final URI uri , boolean decodeQueryParam ) { Map < String , Set < String > > result = Collections . emptyMap ( ) ; final String query = uri . getRawQuery ( ) ; if ( query != null && query . length ( ) > NUM_ ) { result = new HashMap < > ( ) ; parse ( result , new Scanner ( query ) , null , decodeQueryParam ) ; } return result ; }
private void updatePeriod ( ) { for ( int i = NUM_ ; i < mConversion . size ( ) ; i ++ ) { int dateType = mConversion . keyAt ( i ) ; TimePeriodSlider slider = mTimePeriodSliders . get ( dateType ) ; slider . setValue ( mPeriod . get ( mConversion . valueAt ( i ) ) ) ; } mTime . setText ( getFormattedPeriod ( ) ) ; mDuration = mPeriod . toStandardDuration ( ) ; doValidation ( ) ; }
public long start_brk ( ) { return Long . parseLong ( fields [ NUM_ ] ) ; }
public static void validateParticipantIdsEqual ( String expectedParticipantId , String actualParticipantId ) throws CryptoException { if ( ! expectedParticipantId . equals ( actualParticipantId ) ) { throw new CryptoException ( STR_ + actualParticipantId + STR_ + expectedParticipantId + STR_ ) ; } }
protected void encodeFields ( mxCodec enc , Object obj , Node node ) { Class type = obj . getClass ( ) ; while ( type != null ) { Field [ ] fields = type . getDeclaredFields ( ) ; for ( int i = NUM_ ; i < fields . length ; i ++ ) { Field f = fields [ i ] ; if ( ( f . getModifiers ( ) & Modifier . TRANSIENT ) != Modifier . TRANSIENT ) { String fieldname = f . getName ( ) ; Object value = getFieldValue ( obj , fieldname ) ; encodeValue ( enc , obj , fieldname , value , node ) ; } } type = type . getSuperclass ( ) ; } }
public void addVetoableChangeListener ( String propertyName , VetoableChangeListener in_vcl ) { beanContextChildSupport . addVetoableChangeListener ( propertyName , in_vcl ) ; }
private void logMissingResource ( FacesContext ctx , String resourceId , Throwable t ) { Level level ; if ( ! ctx . isProjectStage ( ProjectStage . Production ) ) { level = Level . WARNING ; } else { level = ( ( t != null ) ? Level . WARNING : Level . FINE ) ; } if ( LOGGER . isLoggable ( level ) ) { LOGGER . log ( level , STR_ , new Object [ ] { resourceId } ) ; if ( t != null ) { LOGGER . log ( level , STR_ , t ) ; } } }
private void appendAliasedColumn ( StringBuilder sb , String colName , String tAlias ) { if ( tAlias != null ) { sb . append ( tAlias ) ; sb . append ( STR_ ) ; } sb . append ( STR_ ) ; sb . append ( colName ) ; sb . append ( STR_ ) ; }
private MidiEvent createScheduledEvent ( byte [ ] msg , int offset , int count , long timestamp ) { MidiEvent event ; if ( count > POOL_EVENT_SIZE ) { event = new MidiEvent ( msg , offset , count , timestamp ) ; } else { event = ( MidiEvent ) removeEventfromPool ( ) ; if ( event == null ) { event = new MidiEvent ( POOL_EVENT_SIZE ) ; } System . arraycopy ( msg , offset , event . data , NUM_ , count ) ; event . count = count ; event . setTimestamp ( timestamp ) ; } return event ; }
public void startElement ( String namespaceURI , String localName , String qName , Attributes atts ) throws SAXException { try { elemType = ( SaxHandlerBase . ElementType ) elementTypes . get ( localName ) ; if ( gatherMode ) { if ( gatheringElement . gatherElement ( localName , atts ) ) { gatherBuffer . add ( new Object [ ] { elemType , new AttributesImpl ( atts ) } ) ; } } else { if ( elemType == null ) { return ; } elemType . startElement ( atts ) ; } elems . add ( elemType ) ; } catch ( SAXException saxex ) { throw saxex ; } catch ( Exception ex ) { throw new SAXException ( ex ) ; } }
public static byte [ ] gzip ( String input ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; GZIPOutputStream gzos = null ; try { gzos = new GZIPOutputStream ( baos ) ; gzos . write ( input . getBytes ( STR_ ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( gzos != null ) try { gzos . close ( ) ; } catch ( IOException ignore ) { } } return baos . toByteArray ( ) ; }
public void addEdgeConnector ( ) { numEdgeConnectors ++ ; String name = STR_ ; boolean duplicate = BOOL_ ; while ( duplicate ) { name = STR_ + numEdgeConnectors ; if ( finder . findPositionablePointByName ( name ) == null ) { duplicate = BOOL_ ; } if ( duplicate ) { numEdgeConnectors ++ ; } } PositionablePoint o = new PositionablePoint ( name , PositionablePoint . EDGE_CONNECTOR , currentPoint , this ) ; pointList . add ( o ) ; setDirty ( BOOL_ ) ; }
@ RequestMapping ( value = { STR_ , STR_ } , method = RequestMethod . GET ) @ ResponseBody public RestWrapper list ( @ RequestParam ( value = STR_ , defaultValue = STR_ ) int startPage , @ RequestParam ( value = STR_ , defaultValue = STR_ ) int pageSize , Principal principal ) { RestWrapper restWrapper = null ; try { Integer counter = workflowTypeDAO . totalRecordCount ( ) ; List < WorkflowType > workflowTypes = new ArrayList < WorkflowType > ( ) ; List < com . wipro . ats . bdre . md . dao . jpa . WorkflowType > jpaWorkflowTypes = workflowTypeDAO . list ( startPage , pageSize ) ; for ( com . wipro . ats . bdre . md . dao . jpa . WorkflowType wfType : jpaWorkflowTypes ) { WorkflowType workflowType = new WorkflowType ( ) ; workflowType . setWorkflowId ( wfType . getWorkflowId ( ) ) ; workflowType . setWorkflowTypeName ( wfType . getWorkflowTypeName ( ) ) ; workflowType . setCounter ( counter ) ; workflowTypes . add ( workflowType ) ; } restWrapper = new RestWrapper ( workflowTypes , RestWrapper . OK ) ; LOGGER . info ( STR_ + principal . getName ( ) ) ; } catch ( Exception e ) { LOGGER . error ( e ) ; restWrapper = new RestWrapper ( e . getMessage ( ) , RestWrapper . ERROR ) ; } return restWrapper ; }
public synchronized void writeTo ( OutputStream out ) throws IOException { int remaining = count ; for ( byte [ ] buf : buffers ) { int c = Math . min ( buf . length , remaining ) ; out . write ( buf , NUM_ , c ) ; remaining -= c ; if ( remaining == NUM_ ) { break ; } } }
public void parseForClass ( GenericDeclaration genericDecl , String signature ) { setInput ( genericDecl , signature ) ; if ( ! eof ) { parseClassSignature ( ) ; } else { if ( genericDecl instanceof Class ) { Class c = ( Class ) genericDecl ; this . formalTypeParameters = EmptyArray . TYPE_VARIABLE ; this . superclassType = c . getSuperclass ( ) ; Class < ? > [ ] interfaces = c . getInterfaces ( ) ; if ( interfaces . length == NUM_ ) { this . interfaceTypes = ListOfTypes . EMPTY ; } else { this . interfaceTypes = new ListOfTypes ( interfaces ) ; } } else { this . formalTypeParameters = EmptyArray . TYPE_VARIABLE ; this . superclassType = Object . class ; this . interfaceTypes = ListOfTypes . EMPTY ; } } }
static boolean tryExternalUnpush ( ForkJoinTask < ? > t ) { ForkJoinPool p ; WorkQueue [ ] ws ; WorkQueue q ; Submitter z ; ForkJoinTask < ? > [ ] a ; int m , s ; if ( t != null && ( z = submitters . get ( ) ) != null && ( p = commonPool ) != null && ( ws = p . workQueues ) != null && ( m = ws . length - NUM_ ) >= NUM_ && ( q = ws [ m & z . seed & SQMASK ] ) != null && ( s = q . top ) != q . base && ( a = q . array ) != null ) { long j = ( ( ( a . length - NUM_ ) & ( s - NUM_ ) ) << ASHIFT ) + ABASE ; if ( U . getObject ( a , j ) == t && U . compareAndSwapInt ( q , QLOCK , NUM_ , NUM_ ) ) { if ( q . array == a && q . top == s && U . compareAndSwapObject ( a , j , t , null ) ) { q . top = s - NUM_ ; q . qlock = NUM_ ; return BOOL_ ; } q . qlock = NUM_ ; } } return BOOL_ ; }
public static double [ ] quantiles ( int n , double [ ] values ) { values = ( double [ ] ) values . clone ( ) ; Arrays . sort ( values ) ; double [ ] qtls = new double [ n + NUM_ ] ; for ( int i = NUM_ ; i <= n ; ++ i ) { qtls [ i ] = values [ ( ( values . length - NUM_ ) . i ) / n ] ; } return qtls ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; String badSubstring ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; nameNode = elementList . item ( NUM_ ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; { boolean success = BOOL_ ; try { badSubstring = child . substringData ( NUM_ , - NUM_ ) ; } catch ( DOMException ex ) { success = ( ex . code == DOMException . INDEX_SIZE_ERR ) ; } assertTrue ( STR_ , success ) ; } }
public QueryException ( String message , int errorCode , SqlStates sqlState , Throwable cause ) { super ( message , cause ) ; this . message = message ; this . errorCode = errorCode ; this . sqlState = sqlState . getSqlState ( ) ; }
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; }
public void testConstructorStringRadix16 ( ) { String value = STR_ ; int radix = NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , - NUM_ , - NUM_ } ; BigInteger aNumber = new BigInteger ( value , radix ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , aNumber . signum ( ) ) ; }
private CSVData ( List < CSVRecord > records ) { this . records = Objects . requireNonNull ( records ) ; }
private Workflow . Method untagVolumesMethod ( URI systemURI , List < URI > volumeURIs ) { return new Workflow . Method ( STR_ , systemURI , volumeURIs ) ; }
private byte [ ] SHA256hash ( byte [ ] tobeHashed ) { SHA256Digest digester = new SHA256Digest ( ) ; byte [ ] retValue = new byte [ digester . getDigestSize ( ) ] ; digester . update ( tobeHashed , NUM_ , tobeHashed . length ) ; digester . doFinal ( retValue , NUM_ ) ; return retValue ; }
@ DataProvider private static Object [ ] [ ] okResourceResponses ( ) { return new Object [ ] [ ] { { new Response ( OK ) } , { new Response ( FOUND ) } , { new Response ( MOVED_PERMANENTLY ) } , { new Response ( CREATED ) } } ; }
public synchronized void connect ( ) { if ( ! _zkConnection . isStarted ( ) ) { _zkConnection . start ( ) ; } if ( StringUtils . isEmpty ( siteId ) ) { generateSiteId ( ) ; } }
static Object convertJavaTimeToJavaSql ( Object x ) { if ( x instanceof LocalDate ) { return Date . valueOf ( ( LocalDate ) x ) ; } else if ( x instanceof LocalDateTime ) { return Timestamp . valueOf ( ( LocalDateTime ) x ) ; } else if ( x instanceof LocalTime ) { return Time . valueOf ( ( LocalTime ) x ) ; } return x ; }
@ NotNull private static DefaultMutableTreeNode updateTreeStructure ( @ NotNull DefaultMutableTreeNode treeNode , @ NotNull ZipFile compressedApk ) { long compressedSize = NUM_ ; ApkEntry entry = ApkEntry . fromNode ( treeNode ) ; assert entry != null ; if ( treeNode . getChildCount ( ) > NUM_ ) { for ( int i = NUM_ ; i < treeNode . getChildCount ( ) ; i ++ ) { DefaultMutableTreeNode childNode = updateTreeStructure ( ( DefaultMutableTreeNode ) treeNode . getChildAt ( i ) , compressedApk ) ; compressedSize += ( ( ApkEntry ) childNode . getUserObject ( ) ) . getCompressedSize ( ) ; } } else { ZipEntry ze = compressedApk . getEntry ( ApkFileSystem . getInstance ( ) . getRelativePath ( entry . getFile ( ) ) ) ; if ( ze == null ) { compressedSize = - NUM_ ; } else { compressedSize = ze . getCompressedSize ( ) ; } } entry . setCompressedSize ( compressedSize ) ; return treeNode ; }
public long totalMemory ( ) { return totalMemoryImpl ( ) ; }
public static void enableSync ( String accountName ) { }
public static void scan ( ) { List < ScannerRegistration > scanners = getScannersToRun ( ) ; if ( scanners . size ( ) > NUM_ ) { URL [ ] urls = getSearchURLs ( ) ; if ( urls == null ) { urls = fiterLibs ( ScannerURLS . getURLsForSearch ( ) ) ; scan ( scanners , urls ) ; } else { scan ( scanners , urls ) ; } } }
public final void turnTo ( double angle ) { angle = Geometric . clampAngleDegree ( angle ) ; orientation = Geometric . clampAngleDegree ( angle ) ; Geometric . rotateTo ( velocity , Math . toRadians ( orientation ) ) ; }
void fullyLock ( ) { putLock . lock ( ) ; takeLock . lock ( ) ; }
protected int startBridgeServer ( int port , boolean notifyBySubscription ) throws IOException { Cache cache = getCache ( ) ; CacheServer bridge = cache . addCacheServer ( ) ; bridge . setPort ( port ) ; bridge . setNotifyBySubscription ( notifyBySubscription ) ; bridge . start ( ) ; bridgeServerPort = bridge . getPort ( ) ; return bridge . getPort ( ) ; }
public void addAction ( String action ) { Object [ ] args = new String [ NUM_ ] ; SimpleDateFormat sdf = new SimpleDateFormat ( context . getString ( R . string . dateFormat ) ) ; args [ NUM_ ] = sdf . format ( new Date ( ) ) ; String timestamp = context . getString ( R . string . timestamp , args ) ; history . add ( action + timestamp ) ; notifyListeners ( new PropertyChangeEvent ( this , ActivityConstants . historyProperty , null , null ) ) ; }
protected Object toType ( Calendar value ) { return value . getTime ( ) ; }
protected F restoreLastFilter ( int dialogType ) { F result ; List < F > list ; int i ; result = null ; if ( dialogType == OPEN_DIALOG ) list = getOpenFileFilters ( ) ; else list = getSaveFileFilters ( ) ; if ( list . size ( ) > NUM_ ) { result = getDefaultFileFilter ( dialogType ) ; setFileFilter ( result ) ; if ( m_LastFilter != null ) { for ( i = NUM_ ; i < list . size ( ) ; i ++ ) { if ( m_Comparator . compare ( list . get ( i ) , m_LastFilter ) == NUM_ ) { result = ( F ) m_LastFilter ; setFileFilter ( m_LastFilter ) ; break ; } } } } return result ; }
public void testCharBasedCollisions ( ) { CharsToNameCanonicalizer sym = CharsToNameCanonicalizer . createRoot ( ) ; try { int firstHash = NUM_ ; for ( String str : CHAR_COLLISIONS ) { int hash = sym . calcHash ( str ) ; if ( firstHash == NUM_ ) { firstHash = hash ; } else { assertEquals ( firstHash , hash ) ; } sym . findSymbol ( str . toCharArray ( ) , NUM_ , str . length ( ) , hash ) ; } fail ( STR_ ) ; } catch ( IllegalStateException e ) { verifyException ( e , STR_ ) ; assertEquals ( CharsToNameCanonicalizer . MAX_COLL_CHAIN_LENGTH + NUM_ , sym . maxCollisionLength ( ) ) ; assertEquals ( CharsToNameCanonicalizer . MAX_COLL_CHAIN_LENGTH + NUM_ , sym . collisionCount ( ) ) ; assertEquals ( CharsToNameCanonicalizer . MAX_COLL_CHAIN_LENGTH + NUM_ , sym . size ( ) ) ; } }
public void handleTblDataSiteActionHrefRequest ( RequestInvocationEvent event ) throws ModelControlException { String siteName = hexToString ( ( String ) getDisplayFieldValue ( TBL_DATA_SITE_ACTION_HREF ) ) ; setPageSessionAttribute ( SiteEditViewBean . PG_ATTR_SITE_NAME , siteName ) ; SiteEditViewBean vb = ( SiteEditViewBean ) getViewBean ( SiteEditViewBean . class ) ; unlockPageTrail ( ) ; passPgSessionMap ( vb ) ; vb . forwardTo ( getRequestContext ( ) ) ; }
public static void normalize ( double [ ] doubles , double sum ) { if ( Double . isNaN ( sum ) ) { throw new IllegalArgumentException ( STR_ ) ; } if ( sum == NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } for ( int i = NUM_ ; i < doubles . length ; i ++ ) { doubles [ i ] /= sum ; } }
private void expandArray ( int shardId ) { int newNumShards = Math . max ( ( int ) Math . ceil ( numShards . SHARD_GROWTH_FACTOR ) , shardId + NUM_ ) ; Preconditions . checkArgument ( newNumShards . shardLength < Integer . MAX_VALUE , STR_ ) ; int [ ] [ ] newArray = new int [ newNumShards ] [ ] ; System . arraycopy ( readerAccessibleInfo . array , NUM_ , newArray , NUM_ , readerAccessibleInfo . array . length ) ; readerAccessibleInfo = new ReaderAccessibleInfo ( newArray ) ; numShards = newNumShards ; }
protected < T > T waitForPropertyValue ( String documentSelfLink , Class < T > type , String propName , Object propValue , boolean shouldMatch , AtomicInteger count ) throws Throwable { @ SuppressWarnings ( STR_ ) List < Object > prop = propValue instanceof List ? ( List < Object > ) propValue : Arrays . asList ( propValue ) ; return waitForPropertyValue ( documentSelfLink , type , propName , prop , shouldMatch , count ) ; }
public static String fromIPv4AddressCollection ( Collection < Integer > ipAddresses ) { if ( ipAddresses == null ) return STR_ ; StringBuffer sb = new StringBuffer ( ) ; sb . append ( STR_ ) ; for ( Integer ip : ipAddresses ) { sb . append ( fromIPv4Address ( ip ) ) ; sb . append ( STR_ ) ; } sb . replace ( sb . length ( ) - NUM_ , sb . length ( ) , STR_ ) ; return sb . toString ( ) ; }
public static final String makeJavaIdentifier ( String identifier ) { StringBuilder modifiedIdentifier = new StringBuilder ( identifier . length ( ) ) ; if ( ! Character . isJavaIdentifierStart ( identifier . charAt ( NUM_ ) ) ) { modifiedIdentifier . append ( STR_ ) ; } for ( int i = NUM_ ; i < identifier . length ( ) ; i ++ ) { char ch = identifier . charAt ( i ) ; if ( Character . isJavaIdentifierPart ( ch ) && ch != STR_ ) { modifiedIdentifier . append ( ch ) ; } else if ( ch == STR_ ) { modifiedIdentifier . append ( STR_ ) ; } else { modifiedIdentifier . append ( mangleChar ( ch ) ) ; } } if ( isJavaKeyword ( modifiedIdentifier . toString ( ) ) ) { modifiedIdentifier . append ( STR_ ) ; } return modifiedIdentifier . toString ( ) ; }
public static String encrypt ( String input ) { if ( encryptionService == null || input == null || input . length ( ) == NUM_ ) { return input ; } return ENCRYPTION_PREFIX + encryptionService . encrypt ( input ) ; }
public static void createFederatedNamespace ( URI namespace , ZooKeeperClient zkc ) throws InterruptedException , ZooKeeperClient . ZooKeeperConnectionException , KeeperException { String zkSubNamespacesPath = namespace . getPath ( ) + STR_ + ZNODE_SUB_NAMESPACES ; Utils . zkCreateFullPathOptimistic ( zkc , zkSubNamespacesPath , new byte [ NUM_ ] , zkc . getDefaultACL ( ) , CreateMode . PERSISTENT ) ; }
public static Executor createTaskDistributor ( ) { return Executors . newCachedThreadPool ( createThreadFactory ( Thread . NORM_PRIORITY , STR_ ) ) ; }
public String process ( ) { while ( off < count ) { while ( off < count ) { char ch = text [ off ] ; if ( ! isSpecial ( ch ) ) { break ; } off ++ ; } if ( ! acronym ( ) ) { token ( ) ; number ( ) ; } } return builder . toString ( ) ; }
public static String bytesToBinHex ( byte [ ] data , int nStartPos , int nNumOfBytes ) { StringBuilder sbuf = new StringBuilder ( ) ; sbuf . setLength ( nNumOfBytes << NUM_ ) ; int nPos = NUM_ ; for ( int nI = NUM_ ; nI < nNumOfBytes ; nI ++ ) { sbuf . setCharAt ( nPos ++ , HEXTAB [ ( data [ nI + nStartPos ] > > NUM_ ) & x0f ] ) ; sbuf . setCharAt ( nPos ++ , HEXTAB [ data [ nI + nStartPos ] & x0f ] ) ; } return sbuf . toString ( ) ; }
private static int [ ] mult128 ( int [ ] a , int [ ] b ) { int [ ] result = new int [ NUM_ ] ; int [ ] a0 = new int [ NUM_ ] ; System . arraycopy ( a , NUM_ , a0 , NUM_ , Math . min ( NUM_ , a . length ) ) ; int [ ] a1 = new int [ NUM_ ] ; if ( a . length > NUM_ ) { System . arraycopy ( a , NUM_ , a1 , NUM_ , Math . min ( NUM_ , a . length - NUM_ ) ) ; } int [ ] b0 = new int [ NUM_ ] ; System . arraycopy ( b , NUM_ , b0 , NUM_ , Math . min ( NUM_ , b . length ) ) ; int [ ] b1 = new int [ NUM_ ] ; if ( b . length > NUM_ ) { System . arraycopy ( b , NUM_ , b1 , NUM_ , Math . min ( NUM_ , b . length - NUM_ ) ) ; } if ( a1 [ NUM_ ] == NUM_ && b1 [ NUM_ ] == NUM_ ) { if ( a1 [ NUM_ ] != NUM_ || b1 [ NUM_ ] != NUM_ ) { int [ ] c = mult32 ( a1 [ NUM_ ] , b1 [ NUM_ ] ) ; result [ NUM_ ] ^= c [ NUM_ ] ; result [ NUM_ ] ^= c [ NUM_ ] ; result [ NUM_ ] ^= c [ NUM_ ] ; result [ NUM_ ] ^= c [ NUM_ ] ; } } else { int [ ] c = mult64 ( a1 , b1 ) ; result [ NUM_ ] ^= c [ NUM_ ] ; result [ NUM_ ] ^= c [ NUM_ ] ; result [ NUM_ ] ^= c [ NUM_ ] ^ c [ NUM_ ] ; result [ NUM_ ] ^= c [ NUM_ ] ^ c [ NUM_ ] ; result [ NUM_ ] ^= c [ NUM_ ] ; result [ NUM_ ] ^= c [ NUM_ ] ; } a1 [ NUM_ ] ^= a0 [ NUM_ ] ; a1 [ NUM_ ] ^= a0 [ NUM_ ] ; b1 [ NUM_ ] ^= b0 [ NUM_ ] ; b1 [ NUM_ ] ^= b0 [ NUM_ ] ; if ( a1 [ NUM_ ] == NUM_ && b1 [ NUM_ ] == NUM_ ) { int [ ] d = mult32 ( a1 [ NUM_ ] , b1 [ NUM_ ] ) ; result [ NUM_ ] ^= d [ NUM_ ] ; result [ NUM_ ] ^= d [ NUM_ ] ; } else { int [ ] d = mult64 ( a1 , b1 ) ; result [ NUM_ ] ^= d [ NUM_ ] ; result [ NUM_ ] ^= d [ NUM_ ] ; result [ NUM_ ] ^= d [ NUM_ ] ; result [ NUM_ ] ^= d [ NUM_ ] ; } if ( a0 [ NUM_ ] == NUM_ && b0 [ NUM_ ] == NUM_ ) { int [ ] e = mult32 ( a0 [ NUM_ ] , b0 [ NUM_ ] ) ; result [ NUM_ ] ^= e [ NUM_ ] ; result [ NUM_ ] ^= e [ NUM_ ] ; result [ NUM_ ] ^= e [ NUM_ ] ; result [ NUM_ ] ^= e [ NUM_ ] ; } else { int [ ] e = mult64 ( a0 , b0 ) ; result [ NUM_ ] ^= e [ NUM_ ] ; result [ NUM_ ] ^= e [ NUM_ ] ; result [ NUM_ ] ^= e [ NUM_ ] ^ e [ NUM_ ] ; result [ NUM_ ] ^= e [ NUM_ ] ^ e [ NUM_ ] ; result [ NUM_ ] ^= e [ NUM_ ] ; result [ NUM_ ] ^= e [ NUM_ ] ; } return result ; }
public static void updateLast ( ) { ClientUtils . lastUpdate = System . currentTimeMillis ( ) ; }
public ReplicaSets ( Collection < ReplicaSet > rsSpecs ) { if ( rsSpecs != null ) { rsSpecs . forEach ( null ) ; } Collections . sort ( nonReplicaSets ) ; }
static private String BYTE_Max ( ) { byte tempValue = Byte . MAX_VALUE ; return String . valueOf ( tempValue ) ; }
public static Executor createTaskDistributor ( ) { return Executors . newCachedThreadPool ( createThreadFactory ( Thread . NORM_PRIORITY , STR_ ) ) ; }
protected PathNode pathNode ( String pattern ) { final String seq [ ] = pattern . split ( STR_ ) ; final PathElt elements [ ] = new PathElt [ seq . length ] ; PathMod mod = null ; for ( int i = NUM_ ; i < seq . length ; i ++ ) { final String s = seq [ i ] ; boolean inverse = s . charAt ( NUM_ ) == STR_ ; switch ( s . charAt ( s . length ( ) - NUM_ ) ) { case STR_ : mod = PathMod . ZERO_OR_MORE ; break ; case STR_ : mod = PathMod . ONE_OR_MORE ; break ; case STR_ : mod = PathMod . ZERO_OR_ONE ; break ; } String c = s . substring ( inverse ? NUM_ : NUM_ , s . length ( ) - ( mod != null ? NUM_ : NUM_ ) ) ; elements [ i ] = new PathElt ( constantNode ( c ) , inverse , mod ) ; } return new PathNode ( new PathAlternative ( new PathSequence ( elements ) ) ) ; }
@ Override public int startupNewWorker ( int priority ) { int actualWorkersStarted = startupNewWorker ( priority , null , null ) ; return actualWorkersStarted ; }
public void addImplInterface ( String iname ) { implInterfaces . add ( iname ) ; }
private static synchronized boolean checkFolderPermissions ( StringBuilder aStringBuilder , String aDirectory ) { File directory = new File ( aDirectory ) ; if ( ! directory . exists ( ) ) { directory . mkdirs ( ) ; } if ( ! directory . canRead ( ) ) { aStringBuilder . append ( STR_ + directory + STR_ + STR_ ) ; return BOOL_ ; } if ( ! directory . canWrite ( ) ) { aStringBuilder . append ( STR_ + directory + STR_ + STR_ ) ; return BOOL_ ; } return BOOL_ ; }
protected QualifiedItem [ ] parseQualifiedItems ( final String [ ] arguments , final VersionSpec defaultVersion , final boolean allowVersionRange , final int startIndex ) { Check . notNull ( arguments , STR_ ) ; final List < QualifiedItem > items = new ArrayList < QualifiedItem > ( arguments . length ) ; for ( int i = startIndex ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( ! StringUtil . isNullOrEmpty ( arg ) ) { try { final QualifiedItem qi = new QualifiedItem ( arg , VersionControlConstants . AUTHENTICATED_USER , defaultVersion , allowVersionRange ) ; items . add ( qi ) ; } catch ( final VersionSpecParseException e ) { reportWrongArgument ( arg , e ) ; } catch ( final LabelSpecParseException e ) { reportWrongArgument ( arg , e ) ; } } } return items . toArray ( new QualifiedItem [ items . size ( ) ] ) ; }
public EipEditor ( ) { super ( ) ; initializeEditingDomain ( ) ; }
public boolean deleteEntry ( BasicPoolEntry entry ) { final boolean found = freeEntries . remove ( entry ) ; if ( found ) numEntries -- ; return found ; }
@ Deprecated public void requestContactCapabilities ( ContactId contact ) throws RcsServiceNotRegisteredException , RcsServiceNotAvailableException , RcsGenericException { if ( mApi == null ) { throw new RcsServiceNotAvailableException ( ) ; } try { List < ContactId > listOfContacts = new ArrayList < > ( ) ; listOfContacts . add ( contact ) ; mApi . requestContactCapabilities2 ( listOfContacts ) ; } catch ( Exception e ) { RcsIllegalArgumentException . assertException ( e ) ; RcsServiceNotRegisteredException . assertException ( e ) ; throw new RcsGenericException ( e ) ; } }
public ConversationService ( final String versionDate , String username , String password ) { this ( versionDate ) ; setUsernameAndPassword ( username , password ) ; }
public CustomOptional < KinesisRecord > next ( ) throws TransientKinesisException { readMoreIfNecessary ( ) ; if ( data . isEmpty ( ) ) { return CustomOptional . absent ( ) ; } else { KinesisRecord record = data . removeFirst ( ) ; checkpoint = checkpoint . moveAfter ( record ) ; return CustomOptional . of ( record ) ; } }
@ Override public final synchronized void addRemoveStatements ( Collection < Statement > added , Collection < Statement > removed ) throws IOException { MapOfListMaps < Resource , String , Statement > rsAdded = new MapOfListMaps < Resource , String , Statement > ( ) ; MapOfListMaps < Resource , String , Statement > rsRemoved = new MapOfListMaps < Resource , String , Statement > ( ) ; HashSet < Resource > resources = new HashSet < Resource > ( ) ; for ( Statement s : added ) { rsAdded . add ( s . getSubject ( ) , SearchFields . getContextID ( s . getContext ( ) ) , s ) ; resources . add ( s . getSubject ( ) ) ; } for ( Statement s : removed ) { rsRemoved . add ( s . getSubject ( ) , SearchFields . getContextID ( s . getContext ( ) ) , s ) ; resources . add ( s . getSubject ( ) ) ; } logger . debug ( STR_ + removed . size ( ) + STR_ + added . size ( ) + STR_ ) ; BulkUpdater updater = newBulkUpdate ( ) ; for ( Resource resource : resources ) { Map < String , List < Statement > > stmtsToRemove = rsRemoved . get ( resource ) ; Map < String , List < Statement > > stmtsToAdd = rsAdded . get ( resource ) ; Set < String > contextsToUpdate = new HashSet < String > ( stmtsToAdd . keySet ( ) ) ; contextsToUpdate . addAll ( stmtsToRemove . keySet ( ) ) ; Map < String , SearchDocument > docsByContext = new HashMap < String , SearchDocument > ( ) ; String resourceId = SearchFields . getResourceID ( resource ) ; Iterable < ? extends SearchDocument > documents = getDocuments ( resourceId ) ; for ( SearchDocument doc : documents ) { docsByContext . put ( doc . getContext ( ) , doc ) ; } for ( String contextId : contextsToUpdate ) { String id = SearchFields . formIdString ( resourceId , contextId ) ; SearchDocument document = docsByContext . get ( contextId ) ; if ( document == null ) { document = newDocument ( id , resourceId , contextId ) ; List < Statement > list = stmtsToAdd . get ( contextId ) ; if ( list != null ) { for ( Statement s : list ) { addProperty ( s , document ) ; } } updater . add ( document ) ; if ( stmtsToRemove . containsKey ( contextId ) ) logger . info ( STR_ , resource , contextId ) ; } else { Map < String , Set < String > > removedOfResource = null ; { List < Statement > removedStatements = stmtsToRemove . get ( contextId ) ; if ( removedStatements != null && ! removedStatements . isEmpty ( ) ) { removedOfResource = new HashMap < String , Set < String > > ( ) ; for ( Statement r : removedStatements ) { String val = SearchFields . getLiteralPropertyValueAsString ( r ) ; if ( val != null ) { String field = SearchFields . getPropertyField ( r . getPredicate ( ) ) ; Set < String > removedValues = removedOfResource . get ( field ) ; if ( removedValues == null ) { removedValues = new HashSet < String > ( ) ; removedOfResource . put ( field , removedValues ) ; } removedValues . add ( val ) ; } } } } SearchDocument newDocument = newDocument ( id , resourceId , contextId ) ; boolean mutated = copyDocument ( newDocument , document , removedOfResource ) ; { List < Statement > addedToResource = stmtsToAdd . get ( contextId ) ; String val ; if ( addedToResource != null && ! addedToResource . isEmpty ( ) ) { PropertyCache propertyCache = new PropertyCache ( newDocument ) ; for ( Statement s : addedToResource ) { val = SearchFields . getLiteralPropertyValueAsString ( s ) ; if ( val != null ) { String field = SearchFields . getPropertyField ( s . getPredicate ( ) ) ; if ( ! propertyCache . hasProperty ( field , val ) ) { addProperty ( s , newDocument ) ; mutated = BOOL_ ; } } } } } int nrProperties = countPropertyValues ( newDocument ) ; if ( nrProperties > NUM_ ) { if ( mutated ) { updater . update ( newDocument ) ; } } else { updater . delete ( document ) ; } } } } updater . end ( ) ; }
Object toType ( String value , String pattern , Locale locale ) { Calendar calendar = toCalendar ( value , pattern , locale ) ; return toType ( calendar ) ; }
private SnmpPduPacket executeSubRequest ( SnmpPduPacket req , Object userData ) { int errorStatus = SnmpDefinitions . snmpRspNoError ; int i ; if ( req . type == pduSetRequestPdu ) { i = NUM_ ; for ( Enumeration < SnmpSubRequestHandler > e = subs . elements ( ) ; e . hasMoreElements ( ) ; i ++ ) { SnmpSubRequestHandler sub = e . nextElement ( ) ; sub . setUserData ( userData ) ; sub . type = pduWalkRequest ; sub . run ( ) ; sub . type = pduSetRequestPdu ; if ( sub . getErrorStatus ( ) != SnmpDefinitions . snmpRspNoError ) { if ( SNMP_ADAPTOR_LOGGER . isLoggable ( Level . FINEST ) ) { SNMP_ADAPTOR_LOGGER . logp ( Level . FINEST , dbgTag , STR_ , STR_ ) ; } return newErrorResponsePdu ( req , errorStatus , sub . getErrorIndex ( ) + NUM_ ) ; } } } i = NUM_ ; for ( Enumeration < SnmpSubRequestHandler > e = subs . elements ( ) ; e . hasMoreElements ( ) ; i ++ ) { SnmpSubRequestHandler sub = e . nextElement ( ) ; sub . setUserData ( userData ) ; sub . run ( ) ; if ( sub . getErrorStatus ( ) != SnmpDefinitions . snmpRspNoError ) { if ( SNMP_ADAPTOR_LOGGER . isLoggable ( Level . FINEST ) ) { SNMP_ADAPTOR_LOGGER . logp ( Level . FINEST , dbgTag , STR_ , STR_ ) ; } return newErrorResponsePdu ( req , errorStatus , sub . getErrorIndex ( ) + NUM_ ) ; } } return null ; }
Method ( MethodDoc methodDoc ) { this . methodDoc = methodDoc ; exceptionTypes = methodDoc . thrownExceptions ( ) ; Arrays . sort ( exceptionTypes , new ClassDocComparator ( ) ) ; operationString = computeOperationString ( ) ; nameAndDescriptor = methodDoc . name ( ) + Util . methodDescriptorOf ( methodDoc ) ; methodHash = computeMethodHash ( ) ; }
public DeterministicKey ( ImmutableList < ChildNumber > childNumberPath , byte [ ] chainCode , LazyECPoint publicAsPoint , @ Nullable BigInteger priv , @ Nullable DeterministicKey parent ) { super ( priv , compressPoint ( checkNotNull ( publicAsPoint ) ) ) ; checkArgument ( chainCode . length == NUM_ ) ; this . parent = parent ; this . childNumberPath = checkNotNull ( childNumberPath ) ; this . chainCode = Arrays . copyOf ( chainCode , chainCode . length ) ; this . depth = parent == null ? NUM_ : parent . depth + NUM_ ; this . parentFingerprint = ( parent != null ) ? parent . getFingerprint ( ) : NUM_ ; }
private static void s_uaColSumLtGe ( MatrixBlock in , MatrixBlock out , double [ ] bv , BinaryOperator bOp ) throws DMLRuntimeException { int agg0 = sumRowSumGtLeColSumLtGe ( NUM_ , bv , bOp ) ; out . allocateDenseBlock ( BOOL_ ) ; Arrays . fill ( out . getDenseBlock ( ) , NUM_ , out . getNumColumns ( ) , agg0 ) ; if ( agg0 != NUM_ ) out . setNonZeros ( out . getNumColumns ( ) ) ; if ( in . isEmptyBlock ( BOOL_ ) ) return ; SparseBlock sblock = in . getSparseBlock ( ) ; for ( int j = NUM_ ; j < sblock . numRows ( ) ; j ++ ) if ( ! sblock . isEmpty ( j ) ) { int apos = sblock . pos ( j ) ; int alen = sblock . size ( j ) ; int [ ] aix = sblock . indexes ( j ) ; double [ ] avals = sblock . values ( j ) ; for ( int i = apos ; i < apos + alen ; i ++ ) { int cnt = sumRowSumGtLeColSumLtGe ( avals [ i ] , bv , bOp ) ; out . quickSetValue ( NUM_ , aix [ i ] , cnt ) ; } } }
public HeldLocksGrant ( BigInteger grantId ) { this . grantId = Preconditions . checkNotNull ( grantId ) ; creationDateMs = System . currentTimeMillis ( ) ; expirationDateMs = - NUM_ ; lockMap = LockCollections . of ( ) ; lockTimeout = null ; versionId = null ; }
public void testPosNegFirstShorter ( ) { byte aBytes [ ] = { - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { - NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ } ; int aSign = NUM_ ; int bSign = - NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . and ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public void removeFromAllListeners ( MapBean mapBean ) { if ( mapBean != null ) { removeZoomListener ( ( ZoomListener ) mapBean ) ; mapBean . removeProjectionListener ( this ) ; scaleField . setText ( STR_ ) ; } }
public void testBug19169 ( ) throws Exception { MysqlDataSource toSerialize = new MysqlDataSource ( ) ; toSerialize . setZeroDateTimeBehavior ( STR_ ) ; boolean testBooleanFlag = ! toSerialize . getAllowLoadLocalInfile ( ) ; toSerialize . setAllowLoadLocalInfile ( testBooleanFlag ) ; int testIntFlag = toSerialize . getBlobSendChunkSize ( ) + NUM_ ; toSerialize . setBlobSendChunkSize ( String . valueOf ( testIntFlag ) ) ; ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; ObjectOutputStream objOut = new ObjectOutputStream ( bOut ) ; objOut . writeObject ( toSerialize ) ; objOut . flush ( ) ; ObjectInputStream objIn = new ObjectInputStream ( new ByteArrayInputStream ( bOut . toByteArray ( ) ) ) ; MysqlDataSource thawedDs = ( MysqlDataSource ) objIn . readObject ( ) ; assertEquals ( STR_ , thawedDs . getZeroDateTimeBehavior ( ) ) ; assertEquals ( testBooleanFlag , thawedDs . getAllowLoadLocalInfile ( ) ) ; assertEquals ( testIntFlag , thawedDs . getBlobSendChunkSize ( ) ) ; }
public static < T > FutureW < T > ofSupplier ( final Supplier < T > s ) { return FutureW . of ( CompletableFuture . supplyAsync ( s ) ) ; }
@ Override public void toData ( DataOutput out ) throws IOException { super . toData ( out ) ; out . writeLong ( refreshInterval ) ; DataSerializer . writeObjectArray ( alertDefs , out ) ; }
public static boolean isString ( String str ) { return null != stringHashTable . get ( str ) ; }
public void addChangingListener ( OnWheelChangedListener listener ) { changingListeners . add ( listener ) ; }
@ Override public boolean equals ( Object obj ) { if ( this == obj ) { return BOOL_ ; } if ( obj == null ) { return BOOL_ ; } if ( getClass ( ) != obj . getClass ( ) ) { return BOOL_ ; } Diff other = ( Diff ) obj ; if ( operation != other . operation ) { return BOOL_ ; } if ( text == null ) { if ( other . text != null ) { return BOOL_ ; } } else if ( ! text . equals ( other . text ) ) { return BOOL_ ; } return BOOL_ ; }
protected abstract void performDeployerActionOnSingleDeployable ( org . codehaus . cargo . container . deployer . Deployer deployer , org . codehaus . cargo . container . deployable . Deployable deployable , org . codehaus . cargo . container . deployer . DeployableMonitor monitor ) ;
@ Override public Tree < String > extractBestMaxRuleParse ( int start , int end , List < String > sentence ) { return extractBestMaxRuleParse1 ( start , end , NUM_ , sentence ) ; }
@ Override public int hashCode ( ) { if ( hash == NUM_ ) { int result = NUM_ ; result = NUM_ . result + range . hashCode ( ) ; long bitsWeight = Double . doubleToLongBits ( weight ) ; result = NUM_ . result + ( int ) ( bitsWeight ^ ( bitsWeight > > > NUM_ ) ) ; hash = result ; } return hash ; }
private Instances voteDataset ( Instances dataset ) throws Exception { for ( int i = NUM_ ; i < dataset . numInstances ( ) ; i ++ ) { Instance inst = dataset . firstInstance ( ) ; inst = votedReclassifyExample ( inst ) ; dataset . add ( inst ) ; dataset . delete ( NUM_ ) ; } return dataset ; }
public void testCompareToPosPos1 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int bSign = NUM_ ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; assertEquals ( NUM_ , aNumber . compareTo ( bNumber ) ) ; }
@ Override public String chooseClientAlias ( final String [ ] keyType , final Principal [ ] issuers , final Socket socket ) { if ( keyManager != null ) { return keyManager . chooseClientAlias ( keyType , issuers , socket ) ; } return null ; }
CSSElement parseCSS ( InputStreamReader r , HTMLComponent htmlC ) throws IOException { ExtInputStreamReader er = new ExtInputStreamReader ( r ) ; return parseCSS ( er , htmlC , null , null ) ; }
protected PooledConnection create ( boolean incrementCounter ) { if ( incrementCounter ) size . incrementAndGet ( ) ; PooledConnection con = new PooledConnection ( getPoolProperties ( ) , this ) ; return con ; }
void release ( ) { if ( sdBuffer != null ) sdBuffer . release ( ) ; if ( aclBuffer != null ) aclBuffer . release ( ) ; if ( sidList != null ) { for ( Long sid : sidList ) { LocalFree ( sid ) ; } } }
public static void write ( File file , CharSequence data , Charset encoding , boolean append ) throws IOException { String str = data == null ? null : data . toString ( ) ; writeStringToFile ( file , str , encoding , append ) ; }
private void parseSessionExpirationTimeInfo ( Element sess ) { String sid = null ; Long expTime = null ; String temp = sess . getAttribute ( STR_ ) ; if ( temp != null ) { sid = temp ; } temp = sess . getAttribute ( STR_ ) ; if ( temp != null ) { expTime = new Long ( temp ) ; } sessionResponse . addSessionForGivenUUID ( sid , expTime ) ; }
public static long generate ( String value ) { int len = value . length ( ) ; long crc = NUM_ ; for ( int i = NUM_ ; i < len ; i ++ ) crc = next ( crc , value . charAt ( i ) ) ; return crc ; }
public ReplaceDialog ( JTextComponent text , FindReplaceActions finderActions ) { super ( ActionUtils . getFrameFor ( text ) , BOOL_ ) ; initComponents ( ) ; registerKeyAction ( this ) ; textComponent = text ; finder = finderActions ; textComponent . addCaretListener ( this ) ; setLocationRelativeTo ( text . getRootPane ( ) ) ; }
public String dump ( X509Certificate certificate ) throws Asn1Exception , IOException { try { return dump ( certificate . getEncoded ( ) ) ; } catch ( IOException ex ) { throw new Asn1Exception ( res . getString ( STR_ ) , ex ) ; } catch ( CertificateEncodingException ex ) { throw new Asn1Exception ( res . getString ( STR_ ) , ex ) ; } }
List < String > findInPackage ( Test test , String packageName ) { List < String > localClsssOrPkgs = new ArrayList < String > ( ) ; packageName = packageName . replace ( STR_ , STR_ ) ; Enumeration < URL > urls ; try { urls = classloader . getResources ( packageName ) ; if ( ! urls . hasMoreElements ( ) ) { log . warn ( STR_ + packageName + STR_ ) ; } } catch ( IOException ioe ) { log . warn ( STR_ + packageName ) ; return localClsssOrPkgs ; } return findInPackageWithUrls ( test , packageName , urls ) ; }
protected abstract Element makeTooltip ( DBIDRef id , double x , double y , double dotsize ) ;
public CloudObject ( String type , int permissions ) { accessPermissions = permissions ; values . put ( CloudStorage . TYPE_FIELD , type ) ; }
private static DecoderResult createDecoderResultFromAmbiguousValues ( int ecLevel , int [ ] codewords , int [ ] erasureArray , int [ ] ambiguousIndexes , int [ ] [ ] ambiguousIndexValues ) throws FormatException , ChecksumException { int [ ] ambiguousIndexCount = new int [ ambiguousIndexes . length ] ; int tries = NUM_ ; while ( tries -- > NUM_ ) { for ( int i = NUM_ ; i < ambiguousIndexCount . length ; i ++ ) { codewords [ ambiguousIndexes [ i ] ] = ambiguousIndexValues [ i ] [ ambiguousIndexCount [ i ] ] ; } try { return decodeCodewords ( codewords , ecLevel , erasureArray ) ; } catch ( ChecksumException ignored ) { } if ( ambiguousIndexCount . length == NUM_ ) { throw ChecksumException . getChecksumInstance ( ) ; } for ( int i = NUM_ ; i < ambiguousIndexCount . length ; i ++ ) { if ( ambiguousIndexCount [ i ] < ambiguousIndexValues [ i ] . length - NUM_ ) { ambiguousIndexCount [ i ] ++ ; break ; } else { ambiguousIndexCount [ i ] = NUM_ ; if ( i == ambiguousIndexCount . length - NUM_ ) { throw ChecksumException . getChecksumInstance ( ) ; } } } } throw ChecksumException . getChecksumInstance ( ) ; }
public double distance ( DoubleVector v ) { double deltaX = v . x - x , deltaY = v . y - y , deltaZ = v . z - z ; return Math . sqrt ( deltaX . deltaX + deltaY . deltaY + deltaZ . deltaZ ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( ) ; newVector . add ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . add ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . add ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . add ( new Option ( STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . add ( new Option ( STR_ + STR_ + STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . add ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . add ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return newVector . elements ( ) ; }
@ Override public void dropUser ( User user , boolean ignore ) throws SQLException { String sql = String . format ( STR_ , user . getLogin ( ) ) ; try { execute ( sql ) ; } catch ( SQLException e ) { if ( ! ignore ) { throw e ; } else if ( logger . isDebugEnabled ( ) ) { logger . debug ( STR_ + sql , e ) ; } } }
@ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case InformationModelPackage . FUNCTIONBLOCK_PROPERTY__NAME : return NAME_EDEFAULT == null ? name != null : ! NAME_EDEFAULT . equals ( name ) ; case InformationModelPackage . FUNCTIONBLOCK_PROPERTY__DESCRIPTION : return DESCRIPTION_EDEFAULT == null ? description != null : ! DESCRIPTION_EDEFAULT . equals ( description ) ; case InformationModelPackage . FUNCTIONBLOCK_PROPERTY__TYPE : return type != null ; } return super . eIsSet ( featureID ) ; }
public double normalizedDistance ( double [ ] point1 , double [ ] point2 ) throws Exception { return Math . sqrt ( distance2 ( point1 , point2 ) ) / point1 . length ; }
public static < T > void onNextDropped ( T t ) { if ( t != null ) { Consumer < Object > hook = Hooks . onNextDroppedHook ; if ( hook == null ) { throw Exceptions . failWithCancel ( ) ; } hook . accept ( t ) ; } }
public static int [ ] randomInts ( int max , int count ) { int [ ] vals = new int [ count ] ; for ( int i = NUM_ ; i < count ; i ++ ) vals [ i ] = SEEDED_RANDOM . nextInt ( max ) ; return vals ; }
void loadStrings ( ) throws IOException { int count = mHeaderItem . stringIdsSize ; int stringOffsets [ ] = new int [ count ] ; seek ( mHeaderItem . stringIdsOff ) ; for ( int i = NUM_ ; i < count ; i ++ ) { stringOffsets [ i ] = readInt ( ) ; } mStrings = new String [ count ] ; seek ( stringOffsets [ NUM_ ] ) ; for ( int i = NUM_ ; i < count ; i ++ ) { seek ( stringOffsets [ i ] ) ; mStrings [ i ] = readString ( ) ; } }
public boolean addGpsDateTimeStampTag ( long timestamp ) { ExifTag t = buildTag ( TAG_GPS_DATE_STAMP , mGPSDateStampFormat . format ( timestamp ) ) ; if ( t == null ) { return BOOL_ ; } setTag ( t ) ; mGPSTimeStampCalendar . setTimeInMillis ( timestamp ) ; t = buildTag ( TAG_GPS_TIME_STAMP , new Rational [ ] { new Rational ( mGPSTimeStampCalendar . get ( Calendar . HOUR_OF_DAY ) , NUM_ ) , new Rational ( mGPSTimeStampCalendar . get ( Calendar . MINUTE ) , NUM_ ) , new Rational ( mGPSTimeStampCalendar . get ( Calendar . SECOND ) , NUM_ ) } ) ; if ( t == null ) { return BOOL_ ; } setTag ( t ) ; return BOOL_ ; }
public void addArea ( final TimeSection AREA ) { if ( null == AREA ) return ; areas . add ( AREA ) ; Collections . sort ( areas , new TimeSectionComparator ( ) ) ; fireUpdateEvent ( SECTION_EVENT ) ; }
public String toString ( ) { return Descriptor . toClassName ( Character . toString ( descriptor ) ) ; }
private void raiseIOException ( String host , int port , String protocol ) { IOExceptionEvent ioError = new IOExceptionEvent ( this , host , port , protocol ) ; sipProvider . handleEvent ( ioError , null ) ; setState ( SIPDialog . TERMINATED_STATE ) ; }
@ Override public Object deserializeTypedFromObject ( JsonParser jp , DeserializationContext ctxt ) throws IOException , JsonProcessingException { JsonToken t = jp . getCurrentToken ( ) ; if ( t == JsonToken . START_OBJECT ) { t = jp . nextToken ( ) ; } else if ( t == JsonToken . START_ARRAY ) { return _deserializeTypedUsingDefaultImpl ( jp , ctxt , null ) ; } else if ( t != JsonToken . FIELD_NAME ) { return _deserializeTypedUsingDefaultImpl ( jp , ctxt , null ) ; } TokenBuffer tb = null ; for ( ; t == JsonToken . FIELD_NAME ; t = jp . nextToken ( ) ) { String name = jp . getCurrentName ( ) ; jp . nextToken ( ) ; if ( _typePropertyName . equals ( name ) ) { String typeId = jp . getText ( ) ; JsonDeserializer < Object > deser = _findDeserializer ( ctxt , typeId ) ; if ( tb != null ) { jp = JsonParserSequence . createFlattened ( tb . asParser ( jp ) , jp ) ; } jp . nextToken ( ) ; return deser . deserialize ( jp , ctxt ) ; } if ( tb == null ) { tb = new TokenBuffer ( null ) ; } tb . writeFieldName ( name ) ; tb . copyCurrentStructure ( jp ) ; } return _deserializeTypedUsingDefaultImpl ( jp , ctxt , tb ) ; }
public boolean isNavigationAtBottom ( ) { return ( mSmallestWidthDp >= NUM_ || mInPortrait ) ; }
protected int layoutRow ( FlowView fv , int rowIndex , int p0 ) { int p1 = super . layoutRow ( fv , rowIndex , p0 ) ; View row = fv . getView ( rowIndex ) ; Document doc = fv . getDocument ( ) ; Object i18nFlag = doc . getProperty ( AbstractDocument . I18NProperty ) ; if ( ( i18nFlag != null ) && i18nFlag . equals ( Boolean . TRUE ) ) { int n = row . getViewCount ( ) ; if ( n > NUM_ ) { AbstractDocument d = ( AbstractDocument ) fv . getDocument ( ) ; Element bidiRoot = d . getBidiRootElement ( ) ; byte [ ] levels = new byte [ n ] ; View [ ] reorder = new View [ n ] ; for ( int i = NUM_ ; i < n ; i ++ ) { View v = row . getView ( i ) ; int bidiIndex = bidiRoot . getElementIndex ( v . getStartOffset ( ) ) ; Element bidiElem = bidiRoot . getElement ( bidiIndex ) ; levels [ i ] = ( byte ) StyleConstants . getBidiLevel ( bidiElem . getAttributes ( ) ) ; reorder [ i ] = v ; } BidiUtils . reorderVisually ( levels , reorder ) ; row . replace ( NUM_ , n , reorder ) ; } } return p1 ; }
public Generator ( String propFile ) { try { BufferedInputStream bi = null ; try { bi = new BufferedInputStream ( new FileInputStream ( propFile ) ) ; props . load ( bi ) ; } finally { if ( bi != null ) { bi . close ( ) ; } } } catch ( Exception e ) { setDefaultProps ( ) ; } }
public static void clearLoggingBehaviors ( ) { synchronized ( loggingBehaviors ) { loggingBehaviors . clear ( ) ; } }
protected void auditOp ( URI tenantId , URI userId , OperationTypeEnum opType , boolean operationalStatus , String operationStage , Object ... descparams ) { _auditMgr . recordAuditLog ( tenantId , userId , EVENT_SERVICE_TYPE , opType , System . currentTimeMillis ( ) , operationalStatus ? AuditLogManager . AUDITLOG_SUCCESS : AuditLogManager . AUDITLOG_FAILURE , operationStage , descparams ) ; }
@ VisibleForTesting protected Process startExecutorProcess ( int container ) { return ShellUtils . runASyncProcess ( getExecutorCommand ( container ) , new File ( LocalContext . workingDirectory ( config ) ) , Integer . toString ( container ) ) ; }
private boolean isItemAtPositionSelectable ( int position ) { return ! mUnselectableItems . contains ( position ) ; }
public Builder addEngineSettings ( final String engineName , final List < String > imports , final List < String > staticImports , final List < String > scripts , final Map < String , Object > config ) { if ( null == imports ) throw new IllegalArgumentException ( STR_ ) ; if ( null == staticImports ) throw new IllegalArgumentException ( STR_ ) ; if ( null == scripts ) throw new IllegalArgumentException ( STR_ ) ; final Map < String , Object > m = null == config ? Collections . emptyMap ( ) : config ; settings . put ( engineName , new EngineSettings ( imports , staticImports , scripts , m ) ) ; return this ; }
private void displayPopupMenu ( final MouseEvent event ) { final int selectedIndex = getSelectionIndex ( event ) ; if ( selectedIndex != - NUM_ ) { final JPopupMenu popupMenu = getPopupMenu ( event . getX ( ) , event . getY ( ) , selectedIndex ) ; if ( popupMenu != null ) { popupMenu . show ( this , event . getX ( ) , event . getY ( ) ) ; } } }
protected void handleSelected ( StructuredSelection selection ) { IStatus status = new Status ( IStatus . OK , PlatformUI . PLUGIN_ID , IStatus . OK , EMPTY_STRING , null ) ; Object [ ] lastSelection = currentSelection ; currentSelection = selection . toArray ( ) ; if ( selection . size ( ) == NUM_ ) { status = new Status ( IStatus . ERROR , PlatformUI . PLUGIN_ID , IStatus . ERROR , EMPTY_STRING , null ) ; if ( lastSelection != null && getListSelectionLabelDecorator ( ) != null ) { list . update ( lastSelection , null ) ; } currentSelection = null ; } else { status = new Status ( IStatus . ERROR , PlatformUI . PLUGIN_ID , IStatus . ERROR , EMPTY_STRING , null ) ; List items = selection . toList ( ) ; Object item = null ; IStatus tempStatus = null ; for ( Iterator it = items . iterator ( ) ; it . hasNext ( ) ; ) { Object o = it . next ( ) ; if ( o instanceof ItemsListSeparator ) { continue ; } item = o ; tempStatus = validateItem ( item ) ; if ( tempStatus . isOK ( ) ) { status = new Status ( IStatus . OK , PlatformUI . PLUGIN_ID , IStatus . OK , EMPTY_STRING , null ) ; } else { status = tempStatus ; break ; } } if ( lastSelection != null && getListSelectionLabelDecorator ( ) != null ) { list . update ( lastSelection , null ) ; } if ( getListSelectionLabelDecorator ( ) != null ) { list . update ( currentSelection , null ) ; } } refreshDetails ( ) ; updateStatus ( status ) ; }
public LinkedList < Diff > diff_main ( String text1 , String text2 , boolean checklines ) { long deadline ; if ( Diff_Timeout <= NUM_ ) { deadline = Long . MAX_VALUE ; } else { deadline = System . currentTimeMillis ( ) + ( long ) ( Diff_Timeout . NUM_ ) ; } return diff_main ( text1 , text2 , checklines , deadline ) ; }
private void updateAltDeviceid ( NetworkFCZoneInfo fabricInfo , String fabricId , String fabricWWN , String key , Map < String , NetworkLite > fabricId2Network ) { if ( fabricInfo != null && fabricInfo . getAltNetworkDeviceId ( ) == null ) { if ( fabricId2Network . get ( key ) == null ) { NetworkLite network = NetworkUtil . getNetworkLiteByFabricId ( fabricId , fabricWWN , _dbClient ) ; if ( network != null ) { fabricId2Network . put ( key , network ) ; URI id = fabricInfo . getNetworkDeviceId ( ) ; for ( String strUri : network . getNetworkSystems ( ) ) { if ( ! strUri . equals ( id . toString ( ) ) ) { id = URI . create ( strUri ) ; break ; } } fabricInfo . setAltNetworkDeviceId ( id ) ; } } } }
public static NetworkInfo fromVersion ( final byte version ) { for ( final NetworkInfo info : KNOWN_NETWORKS ) { if ( version == info . getVersion ( ) ) { return info ; } } throw new IllegalArgumentException ( String . format ( STR_ , version ) ) ; }
public static String lcfirst ( String input ) { return withFirst ( input , null ) ; }
public void write ( ByteCodeWriter out ) throws IOException { out . writeUTF8Const ( getName ( ) ) ; TempOutputStream ts = new TempOutputStream ( ) ; ByteCodeWriter o2 = new ByteCodeWriter ( ts , out . getJavaClass ( ) ) ; o2 . writeShort ( _exceptions . size ( ) ) ; for ( int i = NUM_ ; i < _exceptions . size ( ) ; i ++ ) { String exn = _exceptions . get ( i ) ; o2 . writeClass ( exn ) ; } ts . close ( ) ; out . writeInt ( ts . getLength ( ) ) ; TempBuffer ptr = ts . getHead ( ) ; for ( ; ptr != null ; ptr = ptr . next ( ) ) out . write ( ptr . buffer ( ) , NUM_ , ptr . length ( ) ) ; ts . destroy ( ) ; }
public synchronized AddressbookEntry remove ( String name , Set < String > categoriesToRemove ) { name = StringUtil . toLowerCase ( name ) ; AddressbookEntry currentEntry = entries . get ( name ) ; if ( currentEntry != null ) { Set < String > currentCategories = currentEntry . getCategories ( ) ; for ( String category : categoriesToRemove ) { currentCategories . remove ( category ) ; } AddressbookEntry changedEntry = new AddressbookEntry ( name , currentCategories ) ; entries . put ( name , changedEntry ) ; if ( ! currentEntry . equalsFully ( changedEntry ) ) { saveOnChange ( ) ; } return changedEntry ; } return null ; }
public static byte [ ] decode ( byte [ ] input , int offset , int len , int flags ) { Decoder decoder = new Decoder ( flags , new byte [ len . NUM_ / NUM_ ] ) ; if ( ! decoder . process ( input , offset , len , BOOL_ ) ) { throw new IllegalArgumentException ( STR_ ) ; } if ( decoder . op == decoder . output . length ) { return decoder . output ; } byte [ ] temp = new byte [ decoder . op ] ; System . arraycopy ( decoder . output , NUM_ , temp , NUM_ , decoder . op ) ; return temp ; }
public String shortestMatch ( String input ) { TrieNode node = root ; for ( int i = input . length ( ) - NUM_ ; i >= NUM_ ; i -- ) { node = node . getChild ( input . charAt ( i ) ) ; if ( node == null ) return null ; if ( node . isTerminal ( ) ) return input . substring ( i ) ; } return null ; }
public static boolean isWindows95 ( ) { return osName . indexOf ( STR_ ) > - NUM_ && osVersion . equals ( STR_ ) ; }
public static RHExtension hasRHExtensions ( ConfigImpl config , ExtensionDefintion ed ) throws PageException , SAXException , IOException { XMLConfigAdmin admin = new XMLConfigAdmin ( config , null ) ; return admin . _hasRHExtensions ( config , ed ) ; }
public void addQueryToHistory ( String sql ) { queryHistory . remove ( sql ) ; queryHistory . addFirst ( sql ) ; while ( historySize >= NUM_ && queryHistory . size ( ) > historySize ) { queryHistory . removeLast ( ) ; } }
public StringBuilder encodeBody ( StringBuilder retval ) { retval . append ( LESS_THAN ) ; errorInfo . encode ( retval ) ; retval . append ( GREATER_THAN ) ; if ( ! parameters . isEmpty ( ) ) { retval . append ( SEMICOLON ) ; parameters . encode ( retval ) ; } return retval ; }
public final < R > ParallelFlux < R > reduce ( Supplier < R > initialSupplier , BiFunction < R , T , R > reducer ) { Objects . requireNonNull ( initialSupplier , STR_ ) ; Objects . requireNonNull ( reducer , STR_ ) ; return onAssembly ( new ParallelReduce < > ( this , initialSupplier , reducer ) ) ; }
private void handleButtonEvent ( final Event event ) { switch ( event . type ) { case SWT . FocusIn : { handleFocusEvents ( SWT . FocusIn ) ; break ; } case SWT . Selection : { changeVisibilityOfPopupWindow ( ! isDropped ( ) ) ; break ; } } }
private void performUpdateOperations ( Context context , Request request , JsonValue afterValue , JsonValue beforeValue ) throws ResourceException { final String managedId = getManagedObjectId ( context ) ; activityLogger . log ( context , request , STR_ , getManagedObjectPath ( context ) , beforeValue , afterValue , Status . SUCCESS ) ; managedObjectSetService . update ( context , newUpdateRequest ( managedId , afterValue ) , managedId , null , beforeValue , afterValue , new HashSet < > ( Arrays . asList ( propertyPtr ) ) , new HashSet < > ( Arrays . asList ( propertyPtr ) ) ) ; }
private boolean hasNextInetSocketAddress ( ) { return nextInetSocketAddressIndex < inetSocketAddresses . size ( ) ; }
public static Boolean canStringBeInlineEncoded ( String skey ) { if ( skey . length ( ) > getMaxInlineStringKey ( MAX_LONGS_USED_FOR_STRING_KEY , BOOL_ ) ) { return null ; } if ( isByteEncodingOk ( skey ) ) { return Boolean . TRUE ; } else { if ( skey . length ( ) > getMaxInlineStringKey ( MAX_LONGS_USED_FOR_STRING_KEY , BOOL_ ) ) { return null ; } else { return Boolean . FALSE ; } } }
public Builder ( Date created , Date lastModified ) { this . created = created != null ? new Date ( created . getTime ( ) ) : null ; this . lastModified = lastModified != null ? new Date ( lastModified . getTime ( ) ) : null ; }
@ Override public void writeByteStream ( InputStream is ) throws IOException { while ( BOOL_ ) { int len = SIZE - _offset - NUM_ ; if ( len < NUM_ ) { flushBuffer ( ) ; len = SIZE - _offset - NUM_ ; } len = is . read ( _buffer , _offset + NUM_ , len ) ; if ( len <= NUM_ ) { _buffer [ _offset ++ ] = BC_BINARY_DIRECT ; return ; } _buffer [ _offset + NUM_ ] = ( byte ) BC_BINARY_CHUNK ; _buffer [ _offset + NUM_ ] = ( byte ) ( len > > NUM_ ) ; _buffer [ _offset + NUM_ ] = ( byte ) ( len ) ; _offset += len + NUM_ ; } }
public void removeSelectionChangeListener ( final SelectionChangeListener listener ) { checkWidget ( ) ; if ( listener == null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } if ( selectionChangeListeners == null ) { return ; } selectionChangeListeners . remove ( listener ) ; }
protected final void refreshLoadingViewsSize ( ) { final int maximumPullScroll = ( int ) ( getMaximumPullScroll ( ) . NUM_ ) ; int pLeft = getPaddingLeft ( ) ; int pTop = getPaddingTop ( ) ; int pRight = getPaddingRight ( ) ; int pBottom = getPaddingBottom ( ) ; switch ( getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setWidth ( maximumPullScroll ) ; pLeft = - maximumPullScroll ; } else { pLeft = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setWidth ( maximumPullScroll ) ; pRight = - maximumPullScroll ; } else { pRight = NUM_ ; } break ; case VERTICAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setHeight ( maximumPullScroll ) ; pTop = - maximumPullScroll ; } else { pTop = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setHeight ( maximumPullScroll ) ; pBottom = - maximumPullScroll ; } else { pBottom = NUM_ ; } break ; } if ( DEBUG ) { Log . d ( LOG_TAG , String . format ( STR_ , pLeft , pTop , pRight , pBottom ) ) ; } setPadding ( pLeft , pTop , pRight , pBottom ) ; }
public Track addTrack ( String name , String type ) { Track track = getTrackByName ( name , type ) ; if ( track == null ) { _IdNumber ++ ; String id = _id + STR_ + Integer . toString ( _IdNumber ) ; log . debug ( STR_ , type , getName ( ) , name , id ) ; track = new Track ( id , name , type , this ) ; register ( track ) ; } resetMoves ( ) ; return track ; }
SQLiteLoaderObserver registerLoader ( final SQLiteLoader loader , final String table ) { Logger . d ( TAG , STR_ , table ) ; final SQLiteLoaderObserver entry = new SQLiteLoaderObserver ( loader , table ) ; mActiveLoaders . add ( entry ) ; return entry ; }
public void unbindTree ( Container ui ) { int componentCount = ui . getComponentCount ( ) ; for ( int iter = NUM_ ; iter < componentCount ; iter ++ ) { Component c = ui . getComponentAt ( iter ) ; if ( c instanceof Container ) { unbindTree ( ( Container ) c ) ; continue ; } String bind = c . getCloudBoundProperty ( ) ; if ( bind != null && bind . length ( ) > NUM_ ) { String attributeName = c . getCloudDestinationProperty ( ) ; if ( attributeName != null ) { unbindProperty ( c , bind ) ; } } } }
protected List < Item > toItems ( List < Model > models ) { if ( models == null ) { return Collections . emptyList ( ) ; } int size = models . size ( ) ; List < Item > items = new ArrayList < > ( size ) ; for ( int i = NUM_ ; i < size ; i ++ ) { items . add ( toItem ( models . get ( i ) ) ) ; } return items ; }
public void apply ( FilterSet filterSet , FilterServiceGranularLockFactory lockFactory ) { for ( FilterSetEntry entry : filterSet . getFilters ( ) ) { add ( entry . getFilterValueSet ( ) , entry . getHandle ( ) , lockFactory ) ; } }
public void addConstraintCommand ( DefineCommand command ) { if ( command instanceof CreateIndex ) { constraintCommands . add ( command ) ; } else { AlterTableAddConstraint con = ( AlterTableAddConstraint ) command ; boolean alreadySet ; if ( con . getType ( ) == CommandInterface . ALTER_TABLE_ADD_CONSTRAINT_PRIMARY_KEY ) { alreadySet = setPrimaryKeyColumns ( con . getIndexColumns ( ) ) ; } else { alreadySet = BOOL_ ; } if ( ! alreadySet ) { constraintCommands . add ( command ) ; } } }
public void testInviteCancel ( ) { doCancelTest ( BOOL_ ) ; }
private static byte [ ] lmv2Response ( final byte [ ] hash , final byte [ ] challenge , final byte [ ] clientData ) throws AuthenticationException { final HMACMD5 hmacMD5 = new HMACMD5 ( hash ) ; hmacMD5 . update ( challenge ) ; hmacMD5 . update ( clientData ) ; final byte [ ] mac = hmacMD5 . getOutput ( ) ; final byte [ ] lmv2Response = new byte [ mac . length + clientData . length ] ; System . arraycopy ( mac , NUM_ , lmv2Response , NUM_ , mac . length ) ; System . arraycopy ( clientData , NUM_ , lmv2Response , mac . length , clientData . length ) ; return lmv2Response ; }
static < E > E checkType ( E obj , Class < ? extends E > type ) { if ( obj != null && ! type . isInstance ( obj ) ) { throw new ClassCastException ( STR_ + obj . getClass ( ) + STR_ + type ) ; } return obj ; }
public void testValueOfLongPositive1 ( ) { long longVal = NUM_ ; BigInteger aNumber = BigInteger . valueOf ( longVal ) ; byte rBytes [ ] = { NUM_ , - NUM_ , - NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ } ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , aNumber . signum ( ) ) ; }
public void destroy ( ) { m_filterConfig = null ; }
@ Override public Parcelable onSaveInstanceState ( ) { String path = mPhotoFilePath . get ( ) ; if ( path == null ) return null ; Bundle bundle = new Bundle ( ) ; bundle . putString ( STR_ , path ) ; return bundle ; }
public static boolean createFolder ( String folderPath ) { if ( ! TextUtils . isEmpty ( folderPath ) ) { File folder = new File ( folderPath ) ; return createFolder ( folder ) ; } return BOOL_ ; }
public void test_emptyJournal ( ) throws IOException , InterruptedException , ExecutionException { final File out = File . createTempFile ( getName ( ) , Options . JNL ) ; try { final Journal src = getStore ( getProperties ( ) ) ; try { final Future < Map < String , BaseIndexStats > > f = src . warmUp ( null ) ; final Map < String , BaseIndexStats > map = f . get ( ) ; assertEquals ( NUM_ , map . size ( ) ) ; } finally { src . destroy ( ) ; } } finally { out . delete ( ) ; } }
@ Override public void keyReleased ( KeyEvent e ) { char [ ] password1 = null ; char [ ] password2 = null ; if ( passwordField != null ) { password1 = passwordField . getPassword ( ) ; } if ( repeatPasswordField != null ) { password2 = repeatPasswordField . getPassword ( ) ; } boolean tickLabelVisible = BOOL_ ; if ( password1 != null && password2 != null ) { if ( Arrays . equals ( password1 , password2 ) ) { tickLabelVisible = BOOL_ ; } } tickLabel . setVisible ( tickLabelVisible ) ; clearMessages ( ) ; for ( int i = NUM_ ; i < password1 . length ; i ++ ) { password1 [ i ] = NUM_ ; } for ( int i = NUM_ ; i < password2 . length ; i ++ ) { password2 [ i ] = NUM_ ; } }
private static PeriodFormatterAndValue selectFormatter ( Period daysPeriod ) { int days = daysPeriod . getDays ( ) ; if ( days > NUM_ ) { return pav ( DAY_FORMATTER , days ) ; } int hours = daysPeriod . getHours ( ) ; if ( hours > NUM_ ) { return pav ( HOUR_FORMATTER , hours ) ; } int minutes = daysPeriod . getMinutes ( ) ; if ( minutes > NUM_ ) { return pav ( MINUTE_FORMATTER , minutes ) ; } int seconds = daysPeriod . getSeconds ( ) ; if ( seconds > NUM_ ) { return pav ( SECOND_FORMATTER , seconds ) ; } return null ; }
void addArg ( String arg ) { args . add ( arg ) ; }
public java . lang . StringBuffer insert ( int offset , float f ) { internal . insert ( offset , f ) ; return this ; }
private void updateGwt27On ( IJavaProject javaProject , List < String > programArgs , int indexDisabled , int indexEnabled , boolean superDevModeEnabled ) { if ( indexEnabled > - NUM_ ) { programArgs . remove ( indexEnabled ) ; } if ( indexDisabled > - NUM_ ) { programArgs . remove ( indexDisabled ) ; } if ( ! superDevModeEnabled ) { programArgs . add ( NUM_ , SUPERDEVMODE_DISABLED_ARG ) ; } }
default boolean smashBlock ( EntityPlayer player , World world , BlockPos pos , IBlockState state , ToolTier tier ) { ToolTier required = getRequiredTier ( state ) ; if ( required != null && tier . isGreaterThanOrEqualTo ( required ) ) { float luck = tier . ordinal ( ) . NUM_ ; List < ItemStack > drops = getDrops ( player , world , pos , state , luck ) ; if ( drops . size ( ) > NUM_ ) { if ( ! world . isRemote ) { world . setBlockToAir ( pos ) ; for ( ItemStack drop : drops ) { spawnAsEntity ( world , pos , drop ) ; } } return BOOL_ ; } } return BOOL_ ; }
protected String fetchNativeId ( String nativeGuid ) { String [ ] token = nativeGuid . split ( VNXFileConstants . PLUS_SEPERATOR ) ; return token [ token . length - NUM_ ] ; }
public static String toString ( final double value ) { return Double . toString ( value ) ; }
public long rss ( ) { return Long . parseLong ( fields [ NUM_ ] ) ; }
public static void init ( Context context , boolean is_top ) { cameraManager = new CameraManager ( context , is_top ) ; }
public static PlainText plain ( float text ) { return plain ( Float . toString ( text ) ) ; }
public final void append ( char value ) { char [ ] chunk ; if ( m_firstFree < m_chunkSize ) chunk = m_array [ m_lastChunk ] ; else { int i = m_array . length ; if ( m_lastChunk + NUM_ == i ) { char [ ] [ ] newarray = new char [ i + NUM_ ] [ ] ; System . arraycopy ( m_array , NUM_ , newarray , NUM_ , i ) ; m_array = newarray ; } chunk = m_array [ ++ m_lastChunk ] ; if ( chunk == null ) { if ( m_lastChunk == NUM_ << m_rebundleBits && m_chunkBits < m_maxChunkBits ) { m_innerFSB = new FastStringBuffer ( this ) ; } chunk = m_array [ m_lastChunk ] = new char [ m_chunkSize ] ; } m_firstFree = NUM_ ; } chunk [ m_firstFree ++ ] = value ; }
public Socket createSocket ( InetAddress address , int port , InetAddress myAddress , int myPort ) throws IOException { if ( myAddress != null ) { Socket sock = new Socket ( ) ; sock . bind ( new InetSocketAddress ( myAddress , NUM_ ) ) ; try { sock . connect ( new InetSocketAddress ( address , port ) , NUM_ ) ; } catch ( SocketTimeoutException e ) { throw new ConnectException ( STR_ + address + STR_ + port ) ; } return sock ; } else { Socket sock = new Socket ( ) ; if ( myPort != NUM_ ) { sock . bind ( new InetSocketAddress ( port ) ) ; } try { sock . connect ( new InetSocketAddress ( address , port ) , NUM_ ) ; } catch ( SocketTimeoutException e ) { throw new ConnectException ( STR_ + address + STR_ + port ) ; } return sock ; } }
private static void updateClusterTenant ( DbClient dbClient , URI dataCenterId , URI tenantId ) { List < NamedElement > clustersUris = listChildren ( dbClient , dataCenterId , Cluster . class , STR_ , STR_ ) ; for ( NamedElement clusterUri : clustersUris ) { Cluster cluster = dbClient . queryObject ( Cluster . class , clusterUri . getId ( ) ) ; if ( cluster != null ) { cluster . setTenant ( tenantId ) ; dbClient . persistObject ( cluster ) ; } } }
public static int prefixLength ( char [ ] s1 , char [ ] s2 ) { int len = NUM_ ; int max = Math . min ( s1 . length , s2 . length ) ; for ( int i = NUM_ ; i < max && s1 [ i ] == s2 [ i ] ; ++ i ) ++ len ; return len ; }
private static boolean isLessThanOneWeek ( Date date ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . add ( Calendar . DAY_OF_MONTH , - NUM_ ) ; return date . after ( calendar . getTime ( ) ) ; }
private int colToLoc ( int col , Vector < MappingPair > vec ) { int loc = col ; for ( int i = NUM_ ; ( i < vec . size ( ) ) && ( vec . elementAt ( i ) . col <= col ) ; i ++ ) { loc = loc + vec . elementAt ( i ) . inc ; } return loc ; }
protected boolean [ ] canHandleNClasses ( AttrTypes attrTypes , int numClasses ) { print ( STR_ ) ; printAttributeSummary ( attrTypes , Attribute . NOMINAL ) ; print ( STR_ ) ; ArrayList < String > accepts = new ArrayList < String > ( ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; int numTrain = getNumInstances ( ) , numTest = getNumInstances ( ) , missingLevel = NUM_ ; boolean attributeMissing = BOOL_ , classMissing = BOOL_ ; int numAttr = NUM_ , attrIndex = NUM_ ; return runBasicTest ( attrTypes , numAttr , attrIndex , Attribute . NOMINAL , missingLevel , attributeMissing , classMissing , numTrain , numTest , numClasses , accepts ) ; }
public TypeVariable typeVariable ( ) { int id = typeVariableList . size ( ) ; typeVariableList . add ( null ) ; TypeVariable result = new TypeVariable ( id , this ) ; typeVariableList . set ( id , result ) ; return result ; }
public static char [ ] createTypeParameterSignature ( char [ ] typeParameterName , char [ ] [ ] boundSignatures ) { int length = boundSignatures . length ; if ( length == NUM_ ) { return CharOperation . append ( typeParameterName , C_COLON ) ; } int boundsSize = NUM_ ; for ( int i = NUM_ ; i < length ; i ++ ) { boundsSize += boundSignatures [ i ] . length + NUM_ ; } int nameLength = typeParameterName . length ; char [ ] result = new char [ nameLength + boundsSize ] ; System . arraycopy ( typeParameterName , NUM_ , result , NUM_ , nameLength ) ; int index = nameLength ; for ( int i = NUM_ ; i < length ; i ++ ) { result [ index ++ ] = C_COLON ; int boundLength = boundSignatures [ i ] . length ; System . arraycopy ( boundSignatures [ i ] , NUM_ , result , index , boundLength ) ; index += boundLength ; } return result ; }
void cancelStatement ( String sessionId , int statementId ) { for ( TcpServerThread c : New . arrayList ( running ) ) { if ( c != null ) { c . cancelStatement ( sessionId , statementId ) ; } } }
public static double parseDouble ( String s ) { if ( POSITIVE_INFINITY . equals ( s ) ) { return Double . POSITIVE_INFINITY ; } else if ( NEGATIVE_INFINITY . equals ( s ) ) { return Double . NEGATIVE_INFINITY ; } else if ( NaN . equals ( s ) ) { return Double . NaN ; } else { s = trimPlusSign ( s ) ; return Double . parseDouble ( s ) ; } }
public void finishZombieTasksWithError ( ) { List < PollableTask > zombiePollableTasks ; do { logger . debug ( STR_ ) ; PageRequest pageable = new PageRequest ( NUM_ , NUM_ ) ; zombiePollableTasks = pollableTaskRepository . findZombiePollableTasks ( pageable ) ; for ( PollableTask zombiePollableTask : zombiePollableTasks ) { markAsFinishedWithError ( zombiePollableTask ) ; } } while ( ! zombiePollableTasks . isEmpty ( ) ) ; }
public CookieEntity ( URI uri , HttpCookie cookie ) { this . uri = uri == null ? null : uri . toString ( ) ; this . name = cookie . getName ( ) ; this . value = cookie . getValue ( ) ; this . comment = cookie . getComment ( ) ; this . commentURL = cookie . getCommentURL ( ) ; this . discard = cookie . getDiscard ( ) ; this . domain = cookie . getDomain ( ) ; long maxAge = cookie . getMaxAge ( ) ; if ( maxAge != - NUM_ && maxAge > NUM_ ) { this . expiry = ( maxAge . NUM_ ) + System . currentTimeMillis ( ) ; if ( this . expiry < NUM_ ) this . expiry = HeaderUtil . getMaxExpiryMillis ( ) ; } else this . expiry = - NUM_ ; this . path = cookie . getPath ( ) ; if ( ! TextUtils . isEmpty ( path ) && path . length ( ) > NUM_ && path . endsWith ( STR_ ) ) { this . path = path . substring ( NUM_ , path . length ( ) - NUM_ ) ; } this . portList = cookie . getPortlist ( ) ; this . secure = cookie . getSecure ( ) ; this . version = cookie . getVersion ( ) ; }
public void addValue ( T value ) { list . addFirst ( value ) ; total += Double . valueOf ( value . toString ( ) ) ; trim ( ) ; }
private void updateTrafficMask ( ) { int queueSize = trafficControllingSessions . size ( ) ; while ( queueSize > NUM_ ) { S session = trafficControllingSessions . poll ( ) ; if ( session == null ) { return ; } SessionState state = getState ( session ) ; switch ( state ) { case OPENED : updateTrafficControl ( session ) ; break ; case CLOSING : break ; case OPENING : trafficControllingSessions . add ( session ) ; break ; default : throw new IllegalStateException ( String . valueOf ( state ) ) ; } queueSize -- ; } }
public Object createSoftWeakRef ( Object o ) { return new WeakReference ( o ) ; }
public boolean hasEntries ( ) { return ! fEntries . isEmpty ( ) ; }
protected String convertToString ( Object value ) throws Throwable { String result = null ; if ( useLocaleFormat && value instanceof Number ) { NumberFormat format = getFormat ( ) ; format . setGroupingUsed ( BOOL_ ) ; result = format . format ( value ) ; } else { result = value . toString ( ) ; } return result ; }
private static void decodeC40Segment ( BitSource bits , StringBuilder result ) throws FormatException { boolean upperShift = BOOL_ ; int [ ] cValues = new int [ NUM_ ] ; int shift = NUM_ ; do { if ( bits . available ( ) == NUM_ ) { return ; } int firstByte = bits . readBits ( NUM_ ) ; if ( firstByte == NUM_ ) { return ; } parseTwoBytes ( firstByte , bits . readBits ( NUM_ ) , cValues ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { int cValue = cValues [ i ] ; switch ( shift ) { case NUM_ : if ( cValue < NUM_ ) { shift = cValue + NUM_ ; } else if ( cValue < C40_BASIC_SET_CHARS . length ) { char c40char = C40_BASIC_SET_CHARS [ cValue ] ; if ( upperShift ) { result . append ( ( char ) ( c40char + NUM_ ) ) ; upperShift = BOOL_ ; } else { result . append ( c40char ) ; } } else { throw FormatException . getFormatInstance ( ) ; } break ; case NUM_ : if ( upperShift ) { result . append ( ( char ) ( cValue + NUM_ ) ) ; upperShift = BOOL_ ; } else { result . append ( ( char ) cValue ) ; } shift = NUM_ ; break ; case NUM_ : if ( cValue < C40_SHIFT2_SET_CHARS . length ) { char c40char = C40_SHIFT2_SET_CHARS [ cValue ] ; if ( upperShift ) { result . append ( ( char ) ( c40char + NUM_ ) ) ; upperShift = BOOL_ ; } else { result . append ( c40char ) ; } } else if ( cValue == NUM_ ) { result . append ( ( char ) NUM_ ) ; } else if ( cValue == NUM_ ) { upperShift = BOOL_ ; } else { throw FormatException . getFormatInstance ( ) ; } shift = NUM_ ; break ; case NUM_ : if ( upperShift ) { result . append ( ( char ) ( cValue + NUM_ ) ) ; upperShift = BOOL_ ; } else { result . append ( ( char ) ( cValue + NUM_ ) ) ; } shift = NUM_ ; break ; default : throw FormatException . getFormatInstance ( ) ; } } } while ( bits . available ( ) > NUM_ ) ; }
public EsriShapeExport ( OMGraphicList list , Projection proj , String pathToFile ) { setGraphicList ( list ) ; projection = proj ; filePath = pathToFile ; DEBUG = logger . isLoggable ( Level . FINE ) ; }
public void clear ( ) { oredCriteria . clear ( ) ; orderByClause = null ; distinct = BOOL_ ; }
private void checkLogFolder ( ) { File folder = new File ( folderPath ) ; if ( ! folder . exists ( ) ) { folder . mkdirs ( ) ; } }
private void testCompleteOnTimeout_timesOut ( Integer v ) { long timeoutMillis = timeoutMillis ( ) ; CompletableFuture < Integer > f = new CompletableFuture < > ( ) ; long startTime = System . nanoTime ( ) ; assertSame ( f , f . completeOnTimeout ( v , timeoutMillis , MILLISECONDS ) ) ; assertSame ( v , f . join ( ) ) ; assertTrue ( millisElapsedSince ( startTime ) >= timeoutMillis ) ; f . complete ( NUM_ ) ; checkCompletedNormally ( f , v ) ; }
private synchronized void reschedule ( long millis ) { currentFut = null ; if ( ! closed ) { SCHEDULER . schedule ( null , millis , TimeUnit . MILLISECONDS ) ; } else { try { underlying . close ( ) ; } catch ( Exception ex ) { LOG . log ( Level . WARNING , STR_ + underlying . configString ( ) , ex ) ; } } }
public static ContentVerifierProvider createDefaultContentVerifier ( PublicKey key ) throws OperatorCreationException { if ( STR_ == key . getAlgorithm ( ) ) { return SUN_VERIFICATION_BUILDER . build ( key ) ; } else { return BC_VERIFICATION_BUILDER . build ( key ) ; } }
public static Uri fromFile ( File file ) { if ( file == null ) { throw new NullPointerException ( STR_ ) ; } PathPart path = PathPart . fromDecoded ( file . getAbsolutePath ( ) ) ; return new HierarchicalUri ( STR_ , Part . EMPTY , path , Part . NULL , Part . NULL ) ; }
public void addRule ( final Rule rule ) { rule . setId ( ruleIdCounter ++ ) ; rules . add ( rule ) ; }
public static Object serializeClone ( final Object obj ) throws IOException , ClassNotFoundException { ByteArrayOutputStream memOut = new ByteArrayOutputStream ( ) ; ObjectOutputStream objOut = new ObjectOutputStream ( memOut ) ; objOut . writeObject ( obj ) ; objOut . close ( ) ; ByteArrayInputStream src = new ByteArrayInputStream ( memOut . toByteArray ( ) ) ; ObjectInputStream objIs = new ObjectInputStream ( src ) ; return objIs . readObject ( ) ; }
private static String linkForClassName ( String name ) { return name . replace ( STR_ , STR_ ) + STR_ ; }
protected void handleElementDeleted ( IEditorInput fileEditorInput ) { fireElementDeleted ( fileEditorInput ) ; }
public void assertTextPresent ( String expected , String actual ) { if ( ( actual == null ) || ( ! actual . contains ( expected ) ) ) { throw new AssertionFailedError ( STR_ + expected + STR_ + actual + STR_ ) ; } }
public void testUsingProxySelector ( ) throws Exception { MockServer server = new MockServer ( STR_ ) ; MockServer proxy = new MockServer ( STR_ ) ; URL url = new URL ( STR_ + server . port ( ) ) ; ProxySelector defPS = ProxySelector . getDefault ( ) ; ProxySelector . setDefault ( new TestProxySelector ( server . port ( ) , proxy . port ( ) ) ) ; try { HttpURLConnection connection = ( HttpURLConnection ) url . openConnection ( ) ; connection . setConnectTimeout ( NUM_ ) ; connection . setReadTimeout ( NUM_ ) ; server . start ( ) ; synchronized ( bound ) { if ( ! server . started ) bound . wait ( NUM_ ) ; } proxy . start ( ) ; synchronized ( bound ) { if ( ! proxy . started ) bound . wait ( NUM_ ) ; } connection . connect ( ) ; server . join ( ) ; proxy . join ( ) ; assertTrue ( STR_ , connection . usingProxy ( ) ) ; assertTrue ( STR_ , proxy . accepted ) ; connection . disconnect ( ) ; assertTrue ( STR_ , connection . usingProxy ( ) ) ; } finally { ProxySelector . setDefault ( defPS ) ; } }
public String codeCleanPipeline ( String contents ) { if ( contents == null ) { return Values . EMPTYSTRING ; } StringBuilder indexContents = new StringBuilder ( ) ; char [ ] firstReplacements = { STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ } ; for ( char c : firstReplacements ) { contents = contents . replace ( c , STR_ ) ; } indexContents . append ( STR_ ) ; indexContents . append ( contents ) ; char [ ] secondReplacements = { STR_ , STR_ , STR_ , STR_ } ; for ( char c : secondReplacements ) { contents = contents . replace ( c , STR_ ) ; } indexContents . append ( STR_ ) ; indexContents . append ( contents ) ; char [ ] forthReplacements = { STR_ , STR_ } ; for ( char c : forthReplacements ) { contents = contents . replace ( c , STR_ ) ; } indexContents . append ( STR_ ) ; indexContents . append ( contents ) ; char [ ] replacements = { STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ } ; for ( char c : replacements ) { contents = contents . replace ( c , STR_ ) ; } indexContents . append ( STR_ ) ; indexContents . append ( contents ) ; char [ ] thirdReplacements = { STR_ } ; for ( char c : thirdReplacements ) { contents = contents . replace ( c , STR_ ) ; } indexContents . append ( STR_ ) ; indexContents . append ( contents ) ; return indexContents . toString ( ) ; }
public static String mrpa2sampa ( String voicePhoneme ) { if ( mrpa2sampa . containsKey ( voicePhoneme ) ) return mrpa2sampa . get ( voicePhoneme ) ; else return voicePhoneme ; }
public static XPath2FilterContainer newInstanceIntersect ( Document doc , String xpath2filter ) { return new XPath2FilterContainer ( doc , xpath2filter , XPath2FilterContainer . _ATT_FILTER_VALUE_INTERSECT ) ; }
public int lineToY ( int line ) { FontMetrics fm = painter . getFontMetrics ( ) ; return ( line - firstLine ) . fm . getHeight ( ) - ( fm . getLeading ( ) + fm . getMaxDescent ( ) ) ; }
public void removeItemChangedListener ( ItemChangedListener listener ) { itemChangedListeners . remove ( listener ) ; }
public boolean hasAmbigPrefix ( ) { return ( name . startsWith ( ambigPrefix ) ) ; }
public OrderedThreadPoolExecutor ( int maximumPoolSize ) { this ( DEFAULT_INITIAL_THREAD_POOL_SIZE , maximumPoolSize , DEFAULT_KEEP_ALIVE , TimeUnit . SECONDS , Executors . defaultThreadFactory ( ) , null ) ; }
private String parseMalformed ( String urlString ) { if ( parts != null && ! parts . isEmpty ( ) ) { String ret ; for ( URLPart part : parts ) { switch ( part ) { case PROTOCOL : ret = applyPattern ( REGEX_PROTOCOL , urlString ) ; break ; case PORT : ret = applyPattern ( REGEX_PORT , urlString ) ; break ; case QUERY : ret = applyPattern ( REGEX_QUERY , urlString ) ; break ; case WHOLE : ret = urlString ; break ; default : ret = urlString ; } if ( ! Strings . isNullOrEmpty ( ret ) ) { return ret ; } } } return urlString ; }
private boolean relocate ( ) { boolean finished = BOOL_ ; for ( Relocatable relocatable : this . relocatables ) { finished &= relocatable . relocate ( ) ; } return finished ; }
@ SuppressWarnings ( { STR_ , STR_ } ) private Map < K , EntryProcessorResult > updateWithBatch ( GridCacheOperation op , Collection < ? extends K > keys , @ Nullable Iterable < ? > vals , @ Nullable Object [ ] invokeArgs , @ Nullable ExpiryPolicy expiryPlc , GridCacheVersion ver , @ Nullable CacheEntryPredicate [ ] filter , boolean keepBinary , UUID subjId , String taskName ) throws IgniteCheckedException { List < GridCacheEntryEx > locked = lockEntries ( keys ) ; try { int size = locked . size ( ) ; Map < Object , Object > putMap = null ; Collection < Object > rmvKeys = null ; List < CacheObject > writeVals = null ; Map < K , EntryProcessorResult > invokeResMap = op == TRANSFORM ? U . < K , EntryProcessorResult > newHashMap ( size ) : null ; List < GridCacheEntryEx > filtered = new ArrayList < > ( size ) ; CachePartialUpdateCheckedException err = null ; Iterator < ? > valsIter = vals != null ? vals . iterator ( ) : null ; boolean intercept = ctx . config ( ) . getInterceptor ( ) != null ; for ( int i = NUM_ ; i < size ; i ++ ) { GridCacheEntryEx entry = locked . get ( i ) ; Object val = valsIter != null ? valsIter . next ( ) : null ; if ( val == null && op != DELETE ) throw new NullPointerException ( STR_ ) ; try { try { if ( ! ctx . isAllLocked ( entry , filter ) ) { if ( log . isDebugEnabled ( ) ) log . debug ( STR_ + entry + STR_ + Arrays . toString ( filter ) + STR_ ) ; continue ; } } catch ( IgniteCheckedException e ) { if ( err == null ) err = partialUpdateException ( ) ; err . add ( F . asList ( entry . key ( ) ) , e ) ; continue ; } if ( op == TRANSFORM ) { ctx . kernalContext ( ) . resource ( ) . inject ( val , GridResourceIoc . AnnotationSet . ENTRY_PROCESSOR , ctx . name ( ) ) ; EntryProcessor < Object , Object , Object > entryProcessor = ( EntryProcessor < Object , Object , Object > ) val ; CacheObject old = entry . innerGet ( null , null , BOOL_ , BOOL_ , BOOL_ , BOOL_ , BOOL_ , subjId , entryProcessor , taskName , null , keepBinary ) ; Object oldVal = null ; CacheInvokeEntry < Object , Object > invokeEntry = new CacheInvokeEntry < > ( entry . key ( ) , old , entry . version ( ) , keepBinary , entry ) ; CacheObject updated ; Object updatedVal = null ; CacheInvokeResult invokeRes = null ; try { Object computed = entryProcessor . process ( invokeEntry , invokeArgs ) ; updatedVal = ctx . unwrapTemporary ( invokeEntry . getValue ( ) ) ; updated = ctx . toCacheObject ( updatedVal ) ; if ( computed != null ) invokeRes = CacheInvokeResult . fromResult ( ctx . unwrapTemporary ( computed ) ) ; } catch ( Exception e ) { invokeRes = CacheInvokeResult . fromError ( e ) ; updated = old ; } if ( invokeRes != null ) invokeResMap . put ( ( K ) entry . key ( ) . value ( ctx . cacheObjectContext ( ) , BOOL_ ) , invokeRes ) ; if ( updated == null ) { if ( intercept ) { IgniteBiTuple < Boolean , ? > interceptorRes = ctx . config ( ) . getInterceptor ( ) . onBeforeRemove ( new CacheLazyEntry ( ctx , entry . key ( ) , invokeEntry . key ( ) , old , oldVal , keepBinary ) ) ; if ( ctx . cancelRemove ( interceptorRes ) ) continue ; } if ( putMap != null ) { err = updatePartialBatch ( filtered , ver , writeVals , putMap , null , expiryPlc , keepBinary , err , subjId , taskName ) ; putMap = null ; writeVals = null ; filtered = new ArrayList < > ( ) ; } if ( rmvKeys == null ) rmvKeys = new ArrayList < > ( size ) ; rmvKeys . add ( entry . key ( ) . value ( ctx . cacheObjectContext ( ) , BOOL_ ) ) ; } else { if ( intercept ) { Object interceptorVal = ctx . config ( ) . getInterceptor ( ) . onBeforePut ( new CacheLazyEntry ( ctx , entry . key ( ) , invokeEntry . getKey ( ) , old , oldVal , keepBinary ) , updatedVal ) ; if ( interceptorVal == null ) continue ; updated = ctx . toCacheObject ( ctx . unwrapTemporary ( interceptorVal ) ) ; } if ( rmvKeys != null ) { err = updatePartialBatch ( filtered , ver , null , null , rmvKeys , expiryPlc , keepBinary , err , subjId , taskName ) ; rmvKeys = null ; filtered = new ArrayList < > ( ) ; } if ( putMap == null ) { putMap = new LinkedHashMap < > ( size , NUM_ ) ; writeVals = new ArrayList < > ( size ) ; } putMap . put ( CU . value ( entry . key ( ) , ctx , BOOL_ ) , CU . value ( updated , ctx , BOOL_ ) ) ; writeVals . add ( updated ) ; } } else if ( op == UPDATE ) { CacheObject cacheVal = ctx . toCacheObject ( val ) ; if ( intercept ) { CacheObject old = entry . innerGet ( null , null , BOOL_ , ctx . loadPreviousValue ( ) , BOOL_ , BOOL_ , BOOL_ , subjId , null , taskName , null , keepBinary ) ; Object interceptorVal = ctx . config ( ) . getInterceptor ( ) . onBeforePut ( new CacheLazyEntry ( ctx , entry . key ( ) , old , keepBinary ) , val ) ; if ( interceptorVal == null ) continue ; cacheVal = ctx . toCacheObject ( ctx . unwrapTemporary ( interceptorVal ) ) ; } if ( putMap == null ) { putMap = new LinkedHashMap < > ( size , NUM_ ) ; writeVals = new ArrayList < > ( size ) ; } putMap . put ( CU . value ( entry . key ( ) , ctx , BOOL_ ) , CU . value ( cacheVal , ctx , BOOL_ ) ) ; writeVals . add ( cacheVal ) ; } else { assert op == DELETE ; if ( intercept ) { CacheObject old = entry . innerGet ( null , null , BOOL_ , ctx . loadPreviousValue ( ) , BOOL_ , BOOL_ , BOOL_ , subjId , null , taskName , null , keepBinary ) ; IgniteBiTuple < Boolean , ? > interceptorRes = ctx . config ( ) . getInterceptor ( ) . onBeforeRemove ( new CacheLazyEntry ( ctx , entry . key ( ) , old , keepBinary ) ) ; if ( ctx . cancelRemove ( interceptorRes ) ) continue ; } if ( rmvKeys == null ) rmvKeys = new ArrayList < > ( size ) ; rmvKeys . add ( entry . key ( ) . value ( ctx . cacheObjectContext ( ) , BOOL_ ) ) ; } filtered . add ( entry ) ; } catch ( IgniteCheckedException e ) { if ( err == null ) err = partialUpdateException ( ) ; err . add ( F . asList ( entry . key ( ) ) , e ) ; } catch ( GridCacheEntryRemovedException ignore ) { assert BOOL_ : STR_ ; } } if ( putMap != null || rmvKeys != null ) { err = updatePartialBatch ( filtered , ver , writeVals , putMap , rmvKeys , expiryPlc , keepBinary , err , subjId , taskName ) ; } else assert filtered . isEmpty ( ) ; if ( err != null ) throw err ; return invokeResMap ; } finally { unlockEntries ( locked ) ; } }
private static Set < TypeElement > findAllMembersInjectorsRecursively ( Collection < TypeElement > membersInjectors ) { Set < TypeElement > result = new HashSet < > ( ) ; for ( TypeElement element : membersInjectors ) { result . addAll ( findAllMembersInjectorsRecursively ( element ) ) ; } return result ; }
public Builder addSubButton ( Context context , int drawable , int [ ] twoColors , String string ) { if ( drawables == null ) drawables = new ArrayList < > ( ) ; drawables . add ( ContextCompat . getDrawable ( context , drawable ) ) ; if ( colors == null ) colors = new ArrayList < > ( ) ; colors . add ( twoColors ) ; if ( strings == null ) strings = new ArrayList < > ( ) ; strings . add ( string ) ; return this ; }
private void initComponents ( ) { labelValue = new Label ( ) ; labelValue . setValue ( Util . cleanAmp ( Msg . translate ( Env . getCtx ( ) , STR_ ) ) ) ; labelName = new Label ( ) ; labelName . setValue ( Util . cleanAmp ( Msg . translate ( Env . getCtx ( ) , STR_ ) ) ) ; labelContact = new Label ( ) ; labelContact . setValue ( Msg . translate ( Env . getCtx ( ) , STR_ ) ) ; labelEMail = new Label ( ) ; labelEMail . setValue ( Msg . getMsg ( Env . getCtx ( ) , STR_ ) ) ; labelPostal = new Label ( ) ; labelPostal . setValue ( Msg . getMsg ( Env . getCtx ( ) , STR_ ) ) ; labelPhone = new Label ( ) ; labelPhone . setValue ( Msg . translate ( Env . getCtx ( ) , STR_ ) ) ; fieldID = NUM_ ; fieldValue = new Textbox ( ) ; fieldValue . setMaxlength ( NUM_ ) ; fieldValue . setAttribute ( STR_ , STR_ ) ; fieldValue . addEventListener ( Events . ON_CHANGE , this ) ; fieldName = new Textbox ( ) ; fieldName . setMaxlength ( NUM_ ) ; fieldName . setAttribute ( STR_ , STR_ ) ; fieldName . addEventListener ( Events . ON_CHANGE , this ) ; fieldContact = new Textbox ( ) ; fieldContact . setMaxlength ( NUM_ ) ; fieldContact . setAttribute ( STR_ , STR_ ) ; fieldContact . addEventListener ( Events . ON_CHANGE , this ) ; fieldEMail = new Textbox ( ) ; fieldEMail . setMaxlength ( NUM_ ) ; fieldEMail . setAttribute ( STR_ , STR_ ) ; fieldEMail . addEventListener ( Events . ON_CHANGE , this ) ; fieldPostal = new Textbox ( ) ; fieldPostal . setMaxlength ( NUM_ ) ; fieldPostal . setAttribute ( STR_ , STR_ ) ; fieldPostal . addEventListener ( Events . ON_CHANGE , this ) ; fieldPhone = new Textbox ( ) ; fieldPhone . setMaxlength ( NUM_ ) ; fieldPhone . setAttribute ( STR_ , STR_ ) ; fieldPhone . addEventListener ( Events . ON_CHANGE , this ) ; checkAND = new Checkbox ( ) ; checkAND . setText ( Msg . getMsg ( Env . getCtx ( ) , STR_ ) ) ; checkAND . setName ( STR_ ) ; checkAND . setTooltiptext ( Msg . getMsg ( Env . getCtx ( ) , STR_ ) ) ; checkAND . setSelected ( BOOL_ ) ; checkAND . addActionListener ( this ) ; checkAND . setAttribute ( STR_ , STR_ ) ; checkCustomer = new Checkbox ( ) ; checkCustomer . addActionListener ( this ) ; checkCustomer . setAttribute ( STR_ , STR_ ) ; checkCustomer . setName ( STR_ ) ; if ( m_isSOTrx ) checkCustomer . setLabel ( Msg . getMsg ( Env . getCtx ( ) , STR_ ) ) ; else checkCustomer . setLabel ( Msg . getMsg ( Env . getCtx ( ) , STR_ ) ) ; checkCustomer . setSelected ( m_isSOMatch ) ; }
public static boolean isFMInstance ( ) { if ( instanceType == null ) { instanceType = ( String ) configTags . get ( STR_ ) ; } return ( instanceType != null && instanceType . equalsIgnoreCase ( STR_ ) ) ; }
private boolean tryRelease ( long c , WorkQueue v , long inc ) { int sp = ( int ) c , ns = sp & ~ UNSIGNALLED ; if ( v != null ) { int vs = v . scanState ; long nc = ( v . stackPred & SP_MASK ) | ( UC_MASK & ( c + inc ) ) ; if ( sp == vs && U . compareAndSwapLong ( this , CTL , c , nc ) ) { v . scanState = ns ; LockSupport . unpark ( v . parker ) ; return BOOL_ ; } } return BOOL_ ; }
public boolean execute ( String sqlStatements , Connection conn ) { if ( conn == null ) throw new IllegalStateException ( STR_ ) ; String [ ] sql = convert ( sqlStatements ) ; m_exception = null ; if ( m_conversionError != null || sql == null ) return BOOL_ ; boolean ok = BOOL_ ; int i = NUM_ ; String statement = null ; try { if ( m_stmt == null ) m_stmt = conn . createStatement ( ) ; for ( i = NUM_ ; ok && i < sql . length ; i ++ ) { statement = sql [ i ] ; if ( statement . length ( ) == NUM_ ) { if ( m_verbose ) log . finer ( STR_ + i + STR_ ) ; } else { if ( m_verbose ) log . info ( STR_ + i + STR_ + statement + STR_ ) ; else log . info ( STR_ + i ) ; try { m_stmt . clearWarnings ( ) ; int no = m_stmt . executeUpdate ( statement ) ; SQLWarning warn = m_stmt . getWarnings ( ) ; if ( warn != null ) { if ( m_verbose ) log . info ( STR_ + warn ) ; else { log . info ( STR_ + i + STR_ + statement + STR_ ) ; log . info ( STR_ + warn ) ; } } if ( m_verbose ) log . fine ( STR_ + no ) ; } catch ( SQLException ex ) { if ( ! statement . startsWith ( STR_ ) ) { ok = BOOL_ ; m_exception = ex ; } if ( ! m_verbose ) log . info ( STR_ + i + STR_ + statement + STR_ ) ; log . info ( STR_ + i + STR_ + sql . length + STR_ + ex ) ; } } } } catch ( SQLException e ) { m_exception = e ; if ( ! m_verbose ) log . info ( STR_ + i + STR_ + statement + STR_ ) ; log . info ( STR_ + i + STR_ + sql . length + STR_ + e ) ; return BOOL_ ; } return ok ; }
@ Override public Value sample ( Assignment condition ) { double prob = getProb ( condition ) ; if ( sampler . nextDouble ( ) < prob ) { return ValueFactory . create ( BOOL_ ) ; } else { return ValueFactory . create ( BOOL_ ) ; } }
private void initStyle ( AttributeSet attributeSet , int defStyleAttribute ) { TypedArray typedArray = mContext . obtainStyledAttributes ( attributeSet , R . styleable . MaterialSearchView , defStyleAttribute , NUM_ ) ; if ( typedArray != null ) { if ( typedArray . hasValue ( R . styleable . MaterialSearchView_searchBackground ) ) { setBackground ( typedArray . getDrawable ( R . styleable . MaterialSearchView_searchBackground ) ) ; } if ( typedArray . hasValue ( R . styleable . MaterialSearchView_android_textColor ) ) { setTextColor ( typedArray . getColor ( R . styleable . MaterialSearchView_android_textColor , ContextCompat . getColor ( mContext , R . color . black ) ) ) ; } if ( typedArray . hasValue ( R . styleable . MaterialSearchView_android_textColorHint ) ) { setHintTextColor ( typedArray . getColor ( R . styleable . MaterialSearchView_android_textColorHint , ContextCompat . getColor ( mContext , R . color . gray_50 ) ) ) ; } if ( typedArray . hasValue ( R . styleable . MaterialSearchView_android_hint ) ) { setHint ( typedArray . getString ( R . styleable . MaterialSearchView_android_hint ) ) ; } if ( typedArray . hasValue ( R . styleable . MaterialSearchView_searchVoiceIcon ) ) { setVoiceIcon ( typedArray . getDrawable ( R . styleable . MaterialSearchView_searchVoiceIcon ) ) ; } if ( typedArray . hasValue ( R . styleable . MaterialSearchView_searchCloseIcon ) ) { setClearIcon ( typedArray . getDrawable ( R . styleable . MaterialSearchView_searchCloseIcon ) ) ; } if ( typedArray . hasValue ( R . styleable . MaterialSearchView_searchBackIcon ) ) { setBackIcon ( typedArray . getDrawable ( R . styleable . MaterialSearchView_searchBackIcon ) ) ; } if ( typedArray . hasValue ( R . styleable . MaterialSearchView_searchSuggestionBackground ) ) { setSuggestionBackground ( typedArray . getResourceId ( R . styleable . MaterialSearchView_searchSuggestionBackground , R . color . search_layover_bg ) ) ; } if ( typedArray . hasValue ( R . styleable . MaterialSearchView_android_inputType ) ) { setInputType ( typedArray . getInteger ( R . styleable . MaterialSearchView_android_inputType , InputType . TYPE_CLASS_TEXT ) ) ; } if ( typedArray . hasValue ( R . styleable . MaterialSearchView_searchBarHeight ) ) { setSearchBarHeight ( typedArray . getDimensionPixelSize ( R . styleable . MaterialSearchView_searchBarHeight , getAppCompatActionBarHeight ( ) ) ) ; } else { setSearchBarHeight ( getAppCompatActionBarHeight ( ) ) ; } ViewCompat . setFitsSystemWindows ( this , typedArray . getBoolean ( R . styleable . MaterialSearchView_android_fitsSystemWindows , BOOL_ ) ) ; typedArray . recycle ( ) ; } }
boolean validate ( Set attrVals , String i18nFileName , boolean encodePassword ) throws SMSException { return validate ( attrVals , i18nFileName , encodePassword , Collections . EMPTY_MAP ) ; }
protected static void appendBigDecimalNumericType ( StringBuilder sb ) { sb . append ( STR_ ) ; }
void removeAt ( final int removeIndex ) { final Object [ ] items = this . items ; if ( removeIndex == takeIndex ) { items [ takeIndex ] = null ; takeIndex = inc ( takeIndex ) ; count -- ; if ( itrs != null ) itrs . elementDequeued ( ) ; } else { final int putIndex = this . putIndex ; for ( int i = removeIndex ; ; ) { int next = inc ( i ) ; if ( next != putIndex ) { items [ i ] = items [ next ] ; i = next ; } else { items [ i ] = null ; this . putIndex = i ; break ; } } count -- ; if ( itrs != null ) itrs . removedAt ( removeIndex ) ; } notFull . signal ( ) ; }
private AccessGrant createAccessGrant ( Map < String , String > params ) { AccessGrant accessGrant = new AccessGrant ( ) ; if ( params . get ( STR_ ) != null ) { String accessToken = params . get ( STR_ ) ; Integer expires = null ; if ( params . get ( STR_ ) != null ) { expires = Integer . valueOf ( params . get ( STR_ ) ) ; } accessGrant . setKey ( accessToken ) ; accessGrant . setAttribute ( STR_ , expires ) ; } accessGrant . setProviderId ( mProviderName . toString ( ) ) ; return accessGrant ; }
public double distance ( Vector other ) { return Math . sqrt ( Math . pow ( other . x - x , NUM_ ) + Math . pow ( other . y - y , NUM_ ) + Math . pow ( other . z - z , NUM_ ) ) ; }
private void parse ( File tmd ) throws IOException { RandomAccessFile f = new RandomAccessFile ( tmd , STR_ ) ; f . seek ( NUM_ ) ; this . signatureType = f . readInt ( ) ; f . read ( signature , NUM_ , x100 ) ; f . seek ( x140 ) ; f . read ( issuer , NUM_ , x40 ) ; f . seek ( x180 ) ; this . version = f . readByte ( ) ; this . CACRLVersion = f . readByte ( ) ; this . signerCRLVersion = f . readByte ( ) ; f . seek ( x184 ) ; this . systemVersion = f . readLong ( ) ; this . titleID = f . readLong ( ) ; this . titleType = f . readInt ( ) ; this . groupID = f . readShort ( ) ; f . seek ( x19A ) ; f . read ( reserved , NUM_ , NUM_ ) ; f . seek ( x1D8 ) ; this . accessRights = f . readInt ( ) ; this . titleVersion = f . readShort ( ) ; this . contentCount = f . readShort ( ) ; this . bootIndex = f . readShort ( ) ; f . seek ( x1E4 ) ; f . read ( SHA2 , NUM_ , NUM_ ) ; f . seek ( x204 ) ; short indexOffset ; short commandCount ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { f . seek ( x204 + ( x24 . i ) ) ; indexOffset = f . readShort ( ) ; commandCount = f . readShort ( ) ; byte [ ] buffer = new byte [ x20 ] ; f . read ( buffer , NUM_ , x20 ) ; this . contentInfos [ i ] = new ContentInfo ( indexOffset , commandCount , buffer ) ; } this . contents = new Content [ contentCount ] ; int ID ; short index ; short type ; long size ; for ( int i = NUM_ ; i < contentCount ; i ++ ) { f . seek ( xB04 + ( x30 . i ) ) ; ID = f . readInt ( ) ; index = f . readShort ( ) ; type = f . readShort ( ) ; size = f . readLong ( ) ; byte [ ] buffer = new byte [ x20 ] ; f . read ( buffer , NUM_ , x20 ) ; this . contents [ i ] = new Content ( ID , index , type , size , buffer , this ) ; } if ( f . read ( cert2 , NUM_ , x300 ) != x300 ) { Logger . log ( STR_ ) ; } if ( f . read ( cert1 , NUM_ , x400 ) != x400 ) { Logger . log ( STR_ ) ; } f . close ( ) ; }
public void removeVetoableChangeListener ( String propertyName , VetoableChangeListener in_vcl ) { beanContextChildSupport . removeVetoableChangeListener ( propertyName , in_vcl ) ; }
public static void takeScreenshot ( final String tag ) { if ( scenario == null ) { throw new ScreenshotException ( STR_ ) ; } SpoonScreenshotAction . perform ( tag ) ; final File screenshot = SpoonScreenshotAction . getLastScreenshot ( ) ; if ( screenshot == null ) { throw new ScreenshotException ( STR_ ) ; } FileInputStream screenshotStream = null ; try { screenshotStream = new FileInputStream ( screenshot ) ; final byte fileContent [ ] = new byte [ ( int ) screenshot . length ( ) ] ; final int readImageBytes = screenshotStream . read ( fileContent ) ; if ( readImageBytes != - NUM_ ) { scenario . embed ( fileContent , STR_ ) ; } } catch ( final IOException ioe ) { throw new ScreenshotException ( STR_ + ioe ) ; } finally { try { if ( screenshotStream != null ) { screenshotStream . close ( ) ; } } catch ( final IOException ioe ) { throw new ScreenshotException ( STR_ + ioe ) ; } } }
private void importRunnerEnvironment ( ImportProject importProject , FolderEntry baseProjectFolder ) throws ForbiddenException , ServerException , ConflictException , IOException { importRunnerEnvironment ( importProject , baseProjectFolder , null ) ; }
@ Override public void doNotify ( ) throws Exception { log . info ( STR_ ) ; ScheduledExecutorService svc = service ; if ( svc != null ) { try { svc . schedule ( ( Callable < Object > ) this , NUM_ , TimeUnit . MICROSECONDS ) ; } catch ( RejectedExecutionException ex ) { if ( svc . isShutdown ( ) ) { log . info ( STR_ ) ; } else { throw ex ; } } } else { log . info ( STR_ ) ; } }
public boolean checkRootByBuildTags ( ) { String buildTags = android . os . Build . TAGS ; if ( buildTags != null && buildTags . contains ( SU_TAG ) ) { return BOOL_ ; } return BOOL_ ; }
public boolean isUserActive ( String realm ) { boolean active = BOOL_ ; try { AMIdentity user = IdUtils . getIdentity ( ssoToken , userId ) ; boolean isUserActive = user . isActive ( ) ; String loginStatus = getUserAttributeValue ( user , USER_SERVICE_LOGIN_STATUS , ACTIVE ) ; String lockout = getUserAttributeValue ( user , USER_SERVICE_NS_LOCKOUT , STRING_FALSE ) ; if ( ! isUserActive || ! loginStatus . equalsIgnoreCase ( ACTIVE ) || ! lockout . equalsIgnoreCase ( STRING_FALSE ) ) { errorMsg = getLocalizedString ( STR_ ) ; writeLog ( STR_ , userId ) ; } else if ( isAccountExpired ( user ) ) { errorMsg = getLocalizedString ( STR_ ) ; writeLog ( STR_ , userId ) ; } else if ( isUserLockout ( userId , realm ) ) { String obj [ ] = { userId } ; informationMsg = getLocalizedString ( STR_ ) ; writeLog ( STR_ , userId ) ; } else { active = BOOL_ ; } } catch ( SSOException e ) { debug . warning ( STR_ , e ) ; errorMsg = getErrorString ( e ) ; } catch ( IdRepoException e ) { debug . warning ( STR_ , e ) ; errorMsg = getErrorString ( e ) ; } return active ; }
@ Override public < U > CompletableFuture < U > foldRight ( final U seed , final BiFunction < ? super T , U , U > function ) { return CompletableFuture . supplyAsync ( null , exec ) ; }
private void algorithmDouglasPeucker ( List < Entry > entries , double epsilon , int start , int end ) { if ( end <= start + NUM_ ) { return ; } int maxDistIndex = NUM_ ; double distMax = NUM_ ; Entry firstEntry = entries . get ( start ) ; Entry lastEntry = entries . get ( end ) ; for ( int i = start + NUM_ ; i < end ; i ++ ) { double dist = calcAngleBetweenLines ( firstEntry , lastEntry , firstEntry , entries . get ( i ) ) ; if ( dist > distMax ) { distMax = dist ; maxDistIndex = i ; } } if ( distMax > epsilon ) { keep [ maxDistIndex ] = BOOL_ ; algorithmDouglasPeucker ( entries , epsilon , start , maxDistIndex ) ; algorithmDouglasPeucker ( entries , epsilon , maxDistIndex , end ) ; } }
private void calcIntervalDis ( ) { if ( mMarkTextPaint == null ) { return ; } String defaultText = STR_ ; Rect temp = new Rect ( ) ; int max = NUM_ ; if ( mItems != null && mItems . size ( ) > NUM_ ) { for ( String i : mItems ) { mMarkTextPaint . getTextBounds ( i , NUM_ , i . length ( ) , temp ) ; if ( temp . width ( ) > max ) { max = temp . width ( ) ; } } } else { mMarkTextPaint . getTextBounds ( defaultText , NUM_ , defaultText . length ( ) , temp ) ; max = temp . width ( ) ; } if ( ! TextUtils . isEmpty ( mAdditionCenterMark ) ) { mMarkTextPaint . setTextSize ( mNormalTextSize ) ; mMarkTextPaint . getTextBounds ( mAdditionCenterMark , NUM_ , mAdditionCenterMark . length ( ) , temp ) ; mAdditionCenterMarkWidth = temp . width ( ) ; max += temp . width ( ) ; } mIntervalDis = max . mIntervalFactor ; }
public static void sort ( AbstractList array , int [ ] indices ) { for ( int i = NUM_ ; i < indices . length ; i ++ ) { indices [ i ] = i ; } int temp ; int j , n = array . size ( ) ; for ( j = n / NUM_ ; j > NUM_ ; j -- ) { adjust ( array , indices , j , n ) ; } for ( j = n - NUM_ ; j > NUM_ ; j -- ) { temp = indices [ NUM_ ] ; indices [ NUM_ ] = indices [ j ] ; indices [ j ] = temp ; adjust ( array , indices , NUM_ , j ) ; } }
private float clampMag ( float value , float absMin , float absMax ) { final float absValue = Math . abs ( value ) ; if ( absValue < absMin ) return NUM_ ; if ( absValue > absMax ) return value > NUM_ ? absMax : - absMax ; return value ; }
public static boolean saveStringToFile ( String dataInput , String path ) { String filename = path ; File file = new File ( filename ) ; FileOutputStream fos ; byte [ ] data = dataInput . getBytes ( ) ; try { fos = new FileOutputStream ( file ) ; fos . write ( data ) ; fos . flush ( ) ; fos . close ( ) ; return BOOL_ ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return BOOL_ ; }
public static String quote ( String input ) { if ( input . contains ( STR_ ) ) { return STR_ + input + STR_ ; } else { return input ; } }
public void removeSwipeListener ( SwipeListener listener ) { if ( mListeners == null ) { return ; } mListeners . remove ( listener ) ; }
public static void assertThrowsCompletionException ( final Consumer < Void > consumer , final Class < ? > exceptionClass ) { try { consumer . accept ( null ) ; } catch ( final CompletionException completionEx ) { final Throwable ex = completionEx . getCause ( ) ; if ( ex . getClass ( ) == exceptionClass ) { return ; } Assert . fail ( String . format ( STR_ , ex . getClass ( ) ) ) ; } Assert . fail ( String . format ( STR_ , exceptionClass ) ) ; }
public Object put ( Object key , Object value ) { Object oldValue = null ; synchronized ( map ) { oldValue = map . put ( key , value ) ; if ( oldValue != null ) { removeElement ( key ) ; } addElement ( key ) ; } return oldValue ; }
public double run ( ) { try { AudioInputStream inInput = AudioSystem . getAudioInputStream ( files [ NUM_ ] ) ; AudioFeature audioFeatureInput = ( AudioFeature ) featureExtractorInput . calculate ( inInput ) ; } catch ( Exception e ) { } double avgDistance = NUM_ ; for ( int i = NUM_ ; i < arrayFeatureExtractorTrainSet . size ( ) ; i ++ ) { double distance2DB = audioThreadDistance ( featureExtractorInput . getMFCC ( ) , arrayFeatureExtractorTrainSet . get ( i ) ) ; Log . i ( STR_ , STR_ + distance2DB ) ; avgDistance += distance2DB ; } Log . i ( STR_ , STR_ + ( avgDistance / arrayFeatureExtractorTrainSet . size ( ) ) ) ; return avgDistance / arrayFeatureExtractorTrainSet . size ( ) ; }
@ Override protected void onSizeChanged ( int w , int h , int oldw , int oldh ) { super . onSizeChanged ( w , h , oldw , oldh ) ; setupBounds ( w , h ) ; setupPaints ( ) ; invalidate ( ) ; }
public Predicate ( Term t ) { terms . add ( t ) ; }
private void addOperations ( Set < String > methodSignatures ) throws OperationParseException { for ( String sig : methodSignatures ) { TypedOperation operation = OperationParser . parse ( sig ) ; operations . add ( operation ) ; } }
private void writeLog ( String log ) { File file = new File ( CrashHandlerDefault . Log_Default_Path + STR_ + formatter . format ( new Date ( ) ) + STR_ ) ; try { FileOutputStream fileOutputStream = new FileOutputStream ( file ) ; byte [ ] bytes = log . getBytes ( ) ; fileOutputStream . write ( bytes ) ; fileOutputStream . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
public Rule ( String pattern , Object tokenType , String nextState ) { this . pattern = Pattern . compile ( pattern ) ; this . tokenType = tokenType ; this . nextState = nextState ; }
private void showPopup ( final MouseEvent event ) { int [ ] rows = getSelectedRows ( ) ; if ( ( rows . length == NUM_ ) || ( rows . length == NUM_ ) ) { final int row = rowAtPoint ( event . getPoint ( ) ) ; final int column = columnAtPoint ( event . getPoint ( ) ) ; if ( ( row == - NUM_ ) || ( column == - NUM_ ) ) { return ; } changeSelection ( row , column , BOOL_ , BOOL_ ) ; rows = getSelectedRows ( ) ; } final JPopupMenu menu = new JPopupMenu ( ) ; menu . add ( new JMenuItem ( CActionProxy . proxy ( new CDeleteBookmarkAction ( m_bookmarkManager , rows ) ) ) ) ; menu . show ( event . getComponent ( ) , event . getX ( ) , event . getY ( ) ) ; }
public int lineToY ( int line ) { FontMetrics fm = painter . getFontMetrics ( ) ; return ( line - firstLine ) . fm . getHeight ( ) - ( fm . getLeading ( ) + fm . getMaxDescent ( ) ) ; }
public static boolean hasSpecialChars ( final String str ) { final Matcher matcher = SPL_CHAR_PATRN . matcher ( str ) ; return matcher . find ( ) ; }
@ Override public int read ( byte b [ ] , int off , int len ) throws IOException { if ( bb == null ) { throw new IOException ( STR_ ) ; } if ( b == null ) { throw new NullPointerException ( ) ; } else if ( off < NUM_ || len < NUM_ || len > b . length - off ) { throw new IndexOutOfBoundsException ( ) ; } else if ( len == NUM_ ) { return NUM_ ; } int length = Math . min ( bb . remaining ( ) , len ) ; if ( length == NUM_ ) { return - NUM_ ; } bb . get ( b , off , length ) ; return length ; }
public void removeEventListener ( MultimediaMessagingSessionListener listener ) throws RcsServiceNotAvailableException , RcsGenericException { if ( mApi == null ) { throw new RcsServiceNotAvailableException ( ) ; } try { WeakReference < IMultimediaMessagingSessionListener > weakRef = mMultimediaMessagingSessionListeners . remove ( listener ) ; if ( weakRef == null ) { return ; } IMultimediaMessagingSessionListener multimediaMessagingSessionListener = weakRef . get ( ) ; if ( multimediaMessagingSessionListener != null ) { mApi . removeEventListener2 ( multimediaMessagingSessionListener ) ; } } catch ( Exception e ) { RcsIllegalArgumentException . assertException ( e ) ; throw new RcsGenericException ( e ) ; } }
private static boolean dateByMonth ( DateTimeFormatterBuilder bld , Collection < DateTimeFieldType > fields , boolean extended , boolean strictISO ) { boolean reducedPrec = BOOL_ ; if ( fields . remove ( DateTimeFieldType . year ( ) ) ) { bld . append ( Constants . ye ) ; if ( fields . remove ( DateTimeFieldType . monthOfYear ( ) ) ) { if ( fields . remove ( DateTimeFieldType . dayOfMonth ( ) ) ) { appendSeparator ( bld , extended ) ; bld . appendMonthOfYear ( NUM_ ) ; appendSeparator ( bld , extended ) ; bld . appendDayOfMonth ( NUM_ ) ; } else { bld . appendLiteral ( STR_ ) ; bld . appendMonthOfYear ( NUM_ ) ; reducedPrec = BOOL_ ; } } else { if ( fields . remove ( DateTimeFieldType . dayOfMonth ( ) ) ) { checkNotStrictISO ( fields , strictISO ) ; bld . appendLiteral ( STR_ ) ; bld . appendLiteral ( STR_ ) ; bld . appendDayOfMonth ( NUM_ ) ; } else { reducedPrec = BOOL_ ; } } } else if ( fields . remove ( DateTimeFieldType . monthOfYear ( ) ) ) { bld . appendLiteral ( STR_ ) ; bld . appendLiteral ( STR_ ) ; bld . appendMonthOfYear ( NUM_ ) ; if ( fields . remove ( DateTimeFieldType . dayOfMonth ( ) ) ) { appendSeparator ( bld , extended ) ; bld . appendDayOfMonth ( NUM_ ) ; } else { reducedPrec = BOOL_ ; } } else if ( fields . remove ( DateTimeFieldType . dayOfMonth ( ) ) ) { bld . appendLiteral ( STR_ ) ; bld . appendLiteral ( STR_ ) ; bld . appendLiteral ( STR_ ) ; bld . appendDayOfMonth ( NUM_ ) ; } return reducedPrec ; }
public String [ ] parseLine ( String line , boolean withLabel , boolean trace , boolean ignoreEmpty ) { if ( trace ) log . config ( STR_ + line ) ; ArrayList < String > list = new ArrayList < String > ( ) ; for ( int i = NUM_ ; i < m_rows . size ( ) ; i ++ ) { ImpFormatRow row = ( ImpFormatRow ) m_rows . get ( i ) ; StringBuffer entry = new StringBuffer ( ) ; if ( withLabel ) { entry . append ( row . getColumnName ( ) ) ; entry . append ( STR_ ) ; if ( row . isString ( ) ) entry . append ( STR_ ) ; else if ( row . isDate ( ) ) entry . append ( STR_ ) ; } String info = null ; if ( row . isConstant ( ) ) info = STR_ ; else if ( m_formatType . equals ( X_AD_ImpFormat . FORMATTYPE_FixedPosition ) ) { if ( row . getStartNo ( ) > NUM_ && row . getEndNo ( ) <= line . length ( ) ) info = line . substring ( row . getStartNo ( ) - NUM_ , row . getEndNo ( ) ) ; } else { info = parseFlexFormat ( line , m_formatType , row . getStartNo ( ) ) ; } if ( Util . isEmpty ( info , BOOL_ ) ) { if ( row . getDefaultValue ( ) != null ) info = row . getDefaultValue ( ) ; else info = STR_ ; } entry . append ( row . parse ( info ) ) ; if ( withLabel ) { if ( row . isString ( ) ) entry . append ( STR_ ) ; else if ( row . isDate ( ) ) entry . append ( STR_ ) ; } if ( ! ignoreEmpty || ( ignoreEmpty && info . length ( ) != NUM_ ) ) list . add ( entry . toString ( ) ) ; if ( trace ) log . fine ( info + STR_ + entry . toString ( ) + STR_ + info . length ( ) + STR_ ) ; } String [ ] retValue = new String [ list . size ( ) ] ; list . toArray ( retValue ) ; return retValue ; }
public WidgetProposalComputer ( String text , int offset , Element rootElement , Element parentElement , IJavaProject javaProject ) throws JavaModelException , UiBinderException { super ( javaProject , text , offset , text . length ( ) ) ; this . rootElement = rootElement ; this . parentElement = parentElement ; packageManager . readFromElement ( rootElement ) ; }
public List < Predicate < T > > parse ( final List < String > queries ) throws QueryParseException { List < Predicate < T > > predicates = new ArrayList < > ( queries . size ( ) ) ; for ( String query : queries ) { predicates . add ( parse ( query ) ) ; } return predicates ; }
public static Object deserializeStream ( final String witness ) throws Exception { FileInputStream fileIs = new FileInputStream ( witness ) ; ObjectInputStream objIs = new ObjectInputStream ( fileIs ) ; return objIs . readObject ( ) ; }
public static void rollback ( boolean beganTransaction , String causeMessage , Throwable causeThrowable ) throws GenericTransactionException { if ( beganTransaction ) { TransactionUtil . rollback ( causeThrowable ) ; } else { TransactionUtil . setRollbackOnly ( causeMessage , causeThrowable ) ; } }
public LongArray ( LongArray array ) { this . ordered = array . ordered ; size = array . size ; items = new long [ size ] ; System . arraycopy ( array . items , NUM_ , items , NUM_ , size ) ; }
private static < T > T reportGet ( Object r ) throws InterruptedException , ExecutionException { if ( r == null ) throw new InterruptedException ( ) ; if ( r instanceof AltResult ) { Throwable x , cause ; if ( ( x = ( ( AltResult ) r ) . ex ) == null ) return null ; if ( x instanceof CancellationException ) throw ( CancellationException ) x ; if ( ( x instanceof CompletionException ) && ( cause = x . getCause ( ) ) != null ) x = cause ; throw new ExecutionException ( x ) ; } @ SuppressWarnings ( STR_ ) T t = ( T ) r ; return t ; }
protected void garbageCollect ( VisualTable labels ) { Iterator iter = labels . tuples ( ) ; while ( iter . hasNext ( ) ) { VisualItem item = ( VisualItem ) iter . next ( ) ; if ( ! item . isStartVisible ( ) && ! item . isEndVisible ( ) ) { labels . removeTuple ( item ) ; } } }
public boolean sharesVariableWith ( DefUse du ) { return varName . equals ( du . varName ) ; }
private void populateNavDrawer ( ) { mNavDrawerItems . clear ( ) ; mNavDrawerItems . add ( NAVDRAWER_ITEM_ACTIVITY1 ) ; mNavDrawerItems . add ( NAVDRAWER_ITEM_SEPARATOR ) ; mNavDrawerItems . add ( NAVDRAWER_ITEM_ACTIVITY2 ) ; mNavDrawerItems . add ( NAVDRAWER_ITEM_SEPARATOR_SPECIAL ) ; mNavDrawerItems . add ( NAVDRAWER_ITEM_ACTIVITY3 ) ; createNavDrawerItems ( ) ; }
public ArtifactCoordinates ( final String groupId , final String artifactId , final String version , final String classifier ) { this . groupId = groupId ; this . artifactId = artifactId ; this . version = version ; this . classifier = classifier ; }
private CarbonIterator < BatchResult > executeBlockList ( List < TableBlockInfo > blockList ) throws QueryExecutionException { queryModel . setTableBlockInfos ( blockList ) ; this . queryExecutor = QueryExecutorFactory . getQueryExecutor ( ) ; CarbonIterator < BatchResult > iter = null ; try { iter = queryExecutor . execute ( queryModel ) ; } catch ( QueryExecutionException e ) { LOGGER . error ( e . getMessage ( ) ) ; throw e ; } return iter ; }
public static boolean isJavaScriptEnabled ( HttpServletRequest request ) { HttpSession session = request . getSession ( ) ; Boolean javaScriptEnabled = ( Boolean ) session . getAttribute ( STR_ ) ; if ( javaScriptEnabled != null ) { return javaScriptEnabled . booleanValue ( ) ; } return BOOL_ ; }
protected Link createLink ( final String relation , final URI href ) { return new Link ( relation , href ) ; }
public void testFlipBitPositiveInside2 ( ) { byte aBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int number = NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger result = aNumber . flipBit ( number ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public static Spannable createSpannableFromTextWithTemplate ( String text , CharSequence innerTemplate ) { SpannableString result = new SpannableString ( text ) ; if ( innerTemplate instanceof Spanned ) { int index = text . indexOf ( innerTemplate . toString ( ) ) ; if ( index >= NUM_ ) { copySpans ( result , ( Spanned ) innerTemplate , index ) ; } } return result ; }
@ Override public String toString ( ) { return xmlFile . getName ( ) ; }
public String toString ( ) { return String . valueOf ( stopTimeMillis - startTimeMillis ) + STR_ ; }
public ObjectGraph plusGraph ( List < Object > activityScopeModules ) { if ( activityScopeModules == null ) { throw new IllegalArgumentException ( STR_ ) ; } return graph . plus ( activityScopeModules . toArray ( ) ) ; }
public GroupCategorySet ( GroupCategory [ ] categories ) { Assert . isNotNull ( categories ) ; fContent = new ArrayList ( categories . length ) ; for ( int i = NUM_ ; i < categories . length ; i ++ ) { if ( ! fContent . contains ( categories [ i ] ) ) fContent . add ( categories [ i ] ) ; } }
private boolean inSamePackage ( Class < ? > c1 , Class < ? > c2 ) { String nameC1 = c1 . getName ( ) ; String nameC2 = c2 . getName ( ) ; int indexDotC1 = nameC1 . lastIndexOf ( STR_ ) ; int indexDotC2 = nameC2 . lastIndexOf ( STR_ ) ; if ( indexDotC1 != indexDotC2 ) { return BOOL_ ; } if ( indexDotC1 == - NUM_ ) { return BOOL_ ; } return nameC1 . regionMatches ( NUM_ , nameC2 , NUM_ , indexDotC1 ) ; }
private void writeConstraintsToXml ( XmlSerializer out , JobStatus jobStatus ) throws IOException { out . startTag ( null , XML_TAG_PARAMS_CONSTRAINTS ) ; if ( jobStatus . hasUnmeteredConstraint ( ) ) { out . attribute ( null , STR_ , Boolean . toString ( BOOL_ ) ) ; } if ( jobStatus . hasConnectivityConstraint ( ) ) { out . attribute ( null , STR_ , Boolean . toString ( BOOL_ ) ) ; } if ( jobStatus . hasIdleConstraint ( ) ) { out . attribute ( null , STR_ , Boolean . toString ( BOOL_ ) ) ; } if ( jobStatus . hasChargingConstraint ( ) ) { out . attribute ( null , STR_ , Boolean . toString ( BOOL_ ) ) ; } out . endTag ( null , XML_TAG_PARAMS_CONSTRAINTS ) ; }
public void fillConditionalHoles ( ) { ValueRange possibleCondPairs = new ValueRange ( table . keySet ( ) ) ; if ( possibleCondPairs . getNbCombinations ( ) < NUM_ ) { Set < Assignment > possibleCondAssignments = possibleCondPairs . linearise ( ) ; possibleCondAssignments . remove ( new Assignment ( ) ) ; for ( Assignment possibleCond : possibleCondAssignments ) { if ( ! table . containsKey ( possibleCond ) ) { addRow ( possibleCond , ValueFactory . none ( ) , NUM_ ) ; } } } }
private boolean showAppMenu ( View view , boolean startDragging ) { if ( ! mMenuHandler . isAppMenuShowing ( ) && mMenuHandler . showAppMenu ( view , startDragging ) ) { if ( ! startDragging ) RecordUserAction . record ( STR_ ) ; if ( mOnAppMenuShownListener != null ) { mOnAppMenuShownListener . run ( ) ; } return BOOL_ ; } return BOOL_ ; }
protected void writeNodeText ( Node node ) throws IOException { String text = node . getText ( ) ; if ( ( text != null ) && ( text . length ( ) > NUM_ ) ) { if ( escapeText ) { text = escapeElementEntities ( text ) ; } lastOutputNodeType = Node . TEXT_NODE ; writer . write ( text ) ; } }
public void insertRadians ( double [ ] latlons , int coordPairIndex , boolean replaceEndsOfInsertedAtJoin ) { int minPntsNeededForInsertion = NUM_ ; boolean atEnd = BOOL_ ; boolean isClosed = isGeometryClosed ( ) ; int insertionPoint = coordPairIndex . NUM_ ; if ( insertionPoint >= rawllpts . length ) { if ( isClosed ) { insertionPoint = rawllpts . length - NUM_ ; } else { insertionPoint = rawllpts . length ; atEnd = BOOL_ ; } } else if ( insertionPoint <= NUM_ ) { if ( isClosed ) { insertionPoint = NUM_ ; } else { insertionPoint = NUM_ ; atEnd = BOOL_ ; } } int newCoordStart = NUM_ ; int newCoordLength = latlons . length ; if ( replaceEndsOfInsertedAtJoin ) { newCoordStart = NUM_ ; minPntsNeededForInsertion = NUM_ ; if ( atEnd ) { minPntsNeededForInsertion -= NUM_ ; newCoordLength -= NUM_ ; if ( insertionPoint == NUM_ ) { newCoordStart = NUM_ ; } } else { newCoordLength -= NUM_ ; } } if ( renderType == OMGraphic . RENDERTYPE_LATLON && latlons . length >= minPntsNeededForInsertion && latlons . length % NUM_ == NUM_ ) { double [ ] oldrawllpnts = rawllpts ; int oldCoordsRemaining = oldrawllpnts . length - insertionPoint ; rawllpts = new double [ oldrawllpnts . length + newCoordLength ] ; System . arraycopy ( oldrawllpnts , NUM_ , rawllpts , NUM_ , insertionPoint ) ; System . arraycopy ( latlons , newCoordStart , rawllpts , insertionPoint , newCoordLength ) ; System . arraycopy ( oldrawllpnts , insertionPoint , rawllpts , insertionPoint + newCoordLength , oldCoordsRemaining ) ; setNeedToRegenerate ( BOOL_ ) ; } }
public static boolean cancelPotentialWork ( Object data , ImageView imageView ) { final BitmapWorkerTask bitmapWorkerTask = getBitmapWorkerTask ( imageView ) ; if ( bitmapWorkerTask != null ) { final Object bitmapData = bitmapWorkerTask . data ; if ( bitmapData == null || ! bitmapData . equals ( data ) ) { bitmapWorkerTask . cancel ( BOOL_ ) ; if ( BuildConfig . DEBUG ) { Log . d ( TAG , STR_ + data ) ; } } else { return BOOL_ ; } } return BOOL_ ; }
protected Map < String , Object > convertNamedListToMap ( NamedList < ? > args ) { Map < String , Object > argsMap = new LinkedHashMap < > ( ) ; if ( args != null ) { for ( Map . Entry < String , ? > entry : args ) { argsMap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } return argsMap ; }
private T3 < Integer , Integer , byte [ ] > randomKey ( Random rnd ) { return keys [ rnd . nextInt ( keys . length ) ] ; }
public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; if ( override > NUM_ ) { buffer . append ( STR_ + override + STR_ ) ; if ( lineno > NUM_ ) buffer . append ( STR_ + lineno + STR_ ) ; } else { if ( locationName == null && lineno > NUM_ ) { buffer . append ( STR_ + lineno + STR_ ) ; } else if ( locationName != null ) { buffer . append ( locationName + STR_ ) ; if ( lineno > NUM_ ) buffer . append ( lineno + STR_ ) ; } } buffer . append ( description ) ; return buffer . toString ( ) ; }
public void testSearchablesListReal ( ) { MyMockPackageManager mockPM = new MyMockPackageManager ( mContext . getPackageManager ( ) ) ; MyMockContext mockContext = new MyMockContext ( mContext , mockPM ) ; mockPM . setSearchablesMode ( MyMockPackageManager . SEARCHABLES_PASSTHROUGH ) ; Searchables searchables = new Searchables ( mockContext , NUM_ ) ; searchables . buildSearchableList ( ) ; ArrayList < SearchableInfo > searchablesList = searchables . getSearchablesList ( ) ; int count = searchablesList . size ( ) ; assertTrue ( count >= NUM_ ) ; checkSearchables ( searchablesList ) ; ArrayList < SearchableInfo > global = searchables . getSearchablesInGlobalSearchList ( ) ; checkSearchables ( global ) ; }
private void fillExampleTable ( DataSet dataSet , ProgressListener listener , int [ ] attributeColumns , MemoryExampleTable exampleTable ) throws DataSetException , ProcessStoppedException , ParseException { Attribute [ ] attributes = exampleTable . getAttributes ( ) ; dataSet . reset ( ) ; int numberOfRows = dataSet . getNumberOfRows ( ) ; DataRowFactory factory = new DataRowFactory ( dataManagementType , DataRowFactory . POINT_AS_DECIMAL_CHARACTER ) ; boolean isRunningInProcess = isOperatorRunning ( ) ; while ( dataSet . hasNext ( ) ) { if ( isRunningInProcess ) { operator . checkForStop ( ) ; } if ( shouldStop ) { throw new ProcessStoppedException ( ) ; } DataSetRow currentRow = dataSet . nextRow ( ) ; if ( listener != null ) { updateProcess ( listener , dataSet . getCurrentRowIndex ( ) , numberOfRows ) ; } DataRow row = factory . create ( attributes . length ) ; exampleTable . addDataRow ( row ) ; int attributeIndex = NUM_ ; for ( Attribute attribute : attributes ) { if ( currentRow . isMissing ( attributeColumns [ attributeIndex ] ) ) { row . set ( attribute , Double . NaN ) ; } else { switch ( attribute . getValueType ( ) ) { case Ontology . INTEGER : case Ontology . NUMERICAL : case Ontology . REAL : row . set ( attribute , getNumber ( currentRow , attributeColumns [ attributeIndex ] ) ) ; break ; case Ontology . DATE_TIME : case Ontology . TIME : case Ontology . DATE : row . set ( attribute , getDate ( currentRow , attributeColumns [ attributeIndex ] ) ) ; break ; default : row . set ( attribute , getStringIndex ( attribute , currentRow , attributeColumns [ attributeIndex ] ) ) ; } } attributeIndex ++ ; } } }
public boolean isSpurious ( int minClSize ) { return children . isEmpty ( ) && members . size ( ) < minClSize ; }
public AesDecryptor ( byte [ ] key , int off , int len ) { this . key = new byte [ len ] ; System . arraycopy ( key , off , this . key , NUM_ , len ) ; }
static String extractNumberFromUriWithoutFormatting ( String uri ) { if ( uri == null ) { return null ; } int index0 = uri . indexOf ( URI_START_DELIMITER ) ; if ( index0 != - NUM_ ) { uri = uri . substring ( index0 + URI_START_DELIMITER . length ( ) , uri . indexOf ( URI_END_DELIMITER , index0 ) ) ; } int index1 = uri . indexOf ( TEL_URI_HEADER ) ; if ( index1 != - NUM_ ) { uri = uri . substring ( index1 + TEL_URI_HEADER . length ( ) ) ; } index1 = uri . indexOf ( SIP_URI_HEADER ) ; if ( index1 != - NUM_ ) { int index2 = uri . indexOf ( STR_ , index1 ) ; uri = uri . substring ( index1 + SIP_URI_HEADER . length ( ) , index2 ) ; } int index2 = uri . indexOf ( STR_ ) ; if ( index2 != - NUM_ ) { uri = uri . substring ( NUM_ , index2 ) ; } index2 = uri . indexOf ( STR_ ) ; if ( index2 != - NUM_ ) { uri = uri . substring ( NUM_ , index2 ) ; } return uri ; }
public RemoteMethodCallResults invokeAndWait ( final String endPointName , final RemoteMethodCall remoteCall ) { EndPoint local ; synchronized ( m_endPointMutex ) { local = m_localEndPoints . get ( endPointName ) ; } if ( local == null ) { return invokeAndWaitRemote ( remoteCall ) ; } else { final long number = local . takeANumber ( ) ; final List < RemoteMethodCallResults > results = local . invokeLocal ( remoteCall , number , getLocalNode ( ) ) ; if ( results . size ( ) == NUM_ ) { throw new RemoteNotFoundException ( STR_ + endPointName ) ; } if ( results . size ( ) > NUM_ ) { throw new IllegalStateException ( STR_ + results ) ; } return results . get ( NUM_ ) ; } }
private void restoreFromKeypress ( final KeyEvent keyEvent , final int keyNumber ) { if ( keyEvent . isAltDown ( ) ) { final int arrayIndex = ( keyNumber > NUM_ ? keyNumber : MAX_RECENT_MESSAGES ) - NUM_ ; if ( arrayIndex < recentMessages . size ( ) ) { displayMessage ( recentMessages . get ( arrayIndex ) ) ; } keyEvent . consume ( ) ; } }
private void createElement ( Document doc , Element parentElement , String elementName , boolean value ) { Element element = doc . createElement ( elementName ) ; element . appendChild ( doc . createTextNode ( Boolean . toString ( value ) ) ) ; parentElement . appendChild ( element ) ; }
protected void annotationValueToString ( final StringBuilder sb , final BOp val , final int indent ) { sb . append ( val . toString ( ) ) ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList emList ; Node emNode ; CharacterData emText ; Node nullChild ; doc = ( Document ) load ( STR_ , BOOL_ ) ; emList = doc . getElementsByTagName ( STR_ ) ; emNode = emList . item ( NUM_ ) ; emText = ( CharacterData ) emNode . getFirstChild ( ) ; nullChild = emText . getLastChild ( ) ; assertNull ( STR_ , nullChild ) ; }
public Enumeration oids ( ) { return ordering . elements ( ) ; }
@ Override Map < String , Object > extractFields ( String line ) { if ( ! initialized ) { init ( ) ; initialized = BOOL_ ; } String [ ] values = fixedWidthParser . parseLine ( line ) ; if ( hasHeader && Arrays . deepEquals ( values , header ) ) { return null ; } Map < String , Object > map = Maps . newHashMap ( ) ; int i = NUM_ ; for ( FixedWidthField field : fields ) { map . put ( field . getName ( ) , getValue ( field , values [ i ++ ] ) ) ; } return map ; }
protected double ScalingFunction ( int iDistance ) { return Math . exp ( - Math . pow ( ( iDistance ) , NUM_ ) / ( NUM_ . Math . pow ( CorrelationWindow , NUM_ ) ) ) ; }
protected void updateIdealPoint ( ) { for ( Solution solution : this ) { if ( solution . getNumberOfObjectives ( ) != numberOfObjectives ) { throw new FrameworkException ( STR_ ) ; } for ( int i = NUM_ ; i < numberOfObjectives ; i ++ ) { idealPoint [ i ] = Math . min ( idealPoint [ i ] , solution . getObjective ( i ) ) ; } } }
public SearchBuilder sort ( SortFieldBuilder ... builders ) { sort . addAll ( Arrays . asList ( builders ) ) ; return this ; }
@ Override public final BufferedImage dataToRGB ( byte [ ] data , final int width , final int height ) { BufferedImage image ; data = dataToRGBByteArray ( data , width , height ) ; final DataBuffer db = new DataBufferByte ( data , data . length ) ; final int [ ] bands = { NUM_ , NUM_ , NUM_ } ; image = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; final Raster raster = Raster . createInterleavedRaster ( db , width , height , width . NUM_ , NUM_ , bands , null ) ; image . setData ( raster ) ; return image ; }
protected void createFileChooser ( ) { m_FileChooser = new JFileChooser ( new File ( System . getProperty ( STR_ ) ) ) ; m_FileChooser . setFileSelectionMode ( JFileChooser . FILES_ONLY ) ; }
private boolean isNoun ( String word ) { if ( nouns == null ) return BOOL_ ; return nouns . contains ( word . toLowerCase ( ) ) ; }
public static void writeDocument ( Document document , String encoding , OutputStream out , Writer writer , boolean omitXMLDeclaration ) throws IOException , XMLException { if ( writer == null ) { writer = new OutputStreamWriter ( out , encoding ) ; } transformer . setOutputProperty ( OutputKeys . ENCODING , encoding ) ; transformer . setOutputProperty ( OutputKeys . OMIT_XML_DECLARATION , omitXMLDeclaration ? STR_ : STR_ ) ; Source source = new DOMSource ( document ) ; Result result = new StreamResult ( writer ) ; try { transformer . transform ( source , result ) ; } catch ( TransformerException e ) { e . printStackTrace ( ) ; throw new XMLException ( STR_ , e ) ; } writer . flush ( ) ; }
public static String intToString ( int value , int nChars ) { String strValue = Integer . toString ( value ) ; StringBuilder strBuf = new StringBuilder ( nChars ) ; for ( int i = strValue . length ( ) ; i < nChars ; i ++ ) { strBuf . append ( STR_ ) ; } strBuf . append ( strValue ) ; return strBuf . toString ( ) ; }
public boolean isQuestCompleted ( final String name ) { return quests . isQuestCompleted ( name ) ; }
private void updateButtonState ( boolean dataChanged ) { btnApply . setEnabled ( dataChanged ) ; btnRevert . setEnabled ( dataChanged ) ; }
private void buildMenu ( ) { setVisible ( BOOL_ ) ; removeAll ( ) ; if ( recentSearches . getLength ( ) == NUM_ ) { JMenuItem noRecent = new JMenuItem ( UIManager . getString ( STR_ ) ) ; noRecent . setEnabled ( BOOL_ ) ; add ( noRecent ) ; } else { JMenuItem recent = new JMenuItem ( UIManager . getString ( STR_ ) ) ; recent . setEnabled ( BOOL_ ) ; add ( recent ) ; for ( String searchString : recentSearches . getRecentSearches ( ) ) { JMenuItem mi = new JMenuItem ( searchString ) ; mi . addActionListener ( this ) ; add ( mi ) ; } addSeparator ( ) ; clear = new JMenuItem ( UIManager . getString ( STR_ ) ) ; clear . addActionListener ( this ) ; add ( clear ) ; } }
public static String convertU8ToHexString ( char u8 ) { return Integer . toHexString ( u8 ) ; }
protected void Predicate ( ) throws javax . xml . transform . TransformerException { if ( tokenIs ( STR_ ) ) { nextToken ( ) ; PredicateExpr ( ) ; consumeExpected ( STR_ ) ; } }
public static byte [ ] join ( byte [ ] arrayA , byte ... arrayB ) { if ( ( arrayB == null ) || ( arrayB . length == NUM_ ) ) { return arrayA ; } if ( ( arrayA == null ) || ( arrayA . length == NUM_ ) ) { return arrayB ; } byte [ ] array = new byte [ arrayA . length + arrayB . length ] ; System . arraycopy ( arrayA , NUM_ , array , NUM_ , arrayA . length ) ; System . arraycopy ( arrayB , NUM_ , array , arrayA . length , arrayB . length ) ; return array ; }
public void removeListener ( Listener listener ) { mListeners . remove ( listener ) ; }
protected double constrictionCoefficient ( double c1 , double c2 ) { double rho = c1 + c2 ; if ( rho <= NUM_ ) { return NUM_ ; } else { return NUM_ / ( NUM_ - rho - Math . sqrt ( Math . pow ( rho , NUM_ ) - NUM_ . rho ) ) ; } }
public ReplicatorCapabilities ( TungstenProperties props ) throws Exception { Set < String > keys = props . keyNames ( ) ; for ( String key : keys ) { if ( key . equals ( ROLES ) ) { List < String > tags = props . getStringList ( key ) ; for ( String tag : tags ) { if ( tag . equalsIgnoreCase ( ROLE_MASTER ) ) { addRole ( ReplicatorCapabilities . ROLE_MASTER ) ; } else if ( tag . equalsIgnoreCase ( ROLE_SLAVE ) ) { addRole ( ReplicatorCapabilities . ROLE_SLAVE ) ; } else if ( tag . equalsIgnoreCase ( ROLE_RELAY ) ) { addRole ( ReplicatorCapabilities . ROLE_RELAY ) ; } else { throw new Exception ( STR_ + tag ) ; } } } else if ( key . equals ( MODEL ) ) { String tag = props . getString ( key ) ; if ( tag . equalsIgnoreCase ( MODEL_PUSH ) ) { setModel ( MODEL_PUSH ) ; } else if ( tag . equalsIgnoreCase ( MODEL_PULL ) ) { setModel ( MODEL_PULL ) ; } else if ( tag . equalsIgnoreCase ( MODEL_PEER ) ) { setModel ( MODEL_PEER ) ; } else if ( tag . equalsIgnoreCase ( UNKNOWN ) ) { setModel ( UNKNOWN ) ; } else { throw new Exception ( STR_ + tag ) ; } } else if ( key . equals ( CAP_CONSISTENCY ) ) { setConsistencyCheck ( props . getBoolean ( CAP_CONSISTENCY ) ) ; } else if ( key . equals ( CAP_HEARTBEAT ) ) { setHeartbeat ( props . getBoolean ( CAP_HEARTBEAT ) ) ; } else if ( key . equals ( CAP_FLUSH ) ) { setFlush ( props . getBoolean ( CAP_FLUSH ) ) ; } else if ( key . equals ( PROVISION ) ) { String tag = props . getString ( key ) ; if ( tag . equalsIgnoreCase ( PROVISION_DONOR ) ) { setProvisionDriver ( PROVISION_DONOR ) ; } else if ( tag . equalsIgnoreCase ( PROVISION_JOINER ) ) { setProvisionDriver ( PROVISION_JOINER ) ; } else if ( tag . equalsIgnoreCase ( UNKNOWN ) ) { setProvisionDriver ( UNKNOWN ) ; } else { throw new Exception ( STR_ + tag ) ; } } else { throw new Exception ( STR_ + key ) ; } } }
private void fitImageToView ( ) { Drawable drawable = getDrawable ( ) ; if ( drawable == null || drawable . getIntrinsicWidth ( ) == NUM_ || drawable . getIntrinsicHeight ( ) == NUM_ ) { return ; } if ( matrix == null || prevMatrix == null ) { return ; } int drawableWidth = drawable . getIntrinsicWidth ( ) ; int drawableHeight = drawable . getIntrinsicHeight ( ) ; float scaleX = ( float ) viewWidth / drawableWidth ; float scaleY = ( float ) viewHeight / drawableHeight ; switch ( mScaleType ) { case CENTER : scaleX = scaleY = NUM_ ; break ; case CENTER_CROP : scaleX = scaleY = Math . max ( scaleX , scaleY ) ; break ; case CENTER_INSIDE : scaleX = scaleY = Math . min ( NUM_ , Math . min ( scaleX , scaleY ) ) ; case FIT_CENTER : scaleX = scaleY = Math . min ( scaleX , scaleY ) ; break ; case FIT_XY : break ; default : throw new UnsupportedOperationException ( STR_ ) ; } float redundantXSpace = viewWidth - ( scaleX . drawableWidth ) ; float redundantYSpace = viewHeight - ( scaleY . drawableHeight ) ; matchViewWidth = viewWidth - redundantXSpace ; matchViewHeight = viewHeight - redundantYSpace ; if ( ! isZoomed ( ) ) { matrix . setScale ( scaleX , scaleY ) ; matrix . postTranslate ( redundantXSpace / NUM_ , redundantYSpace / NUM_ ) ; normalizedScale = NUM_ ; } else { prevMatrix . getValues ( m ) ; m [ Matrix . MSCALE_X ] = matchViewWidth / drawableWidth . normalizedScale ; m [ Matrix . MSCALE_Y ] = matchViewHeight / drawableHeight . normalizedScale ; float transX = m [ Matrix . MTRANS_X ] ; float transY = m [ Matrix . MTRANS_Y ] ; float prevActualWidth = prevMatchViewWidth . normalizedScale ; float actualWidth = getImageWidth ( ) ; translateMatrixAfterRotate ( Matrix . MTRANS_X , transX , prevActualWidth , actualWidth , prevViewWidth , viewWidth , drawableWidth ) ; float prevActualHeight = prevMatchViewHeight . normalizedScale ; float actualHeight = getImageHeight ( ) ; translateMatrixAfterRotate ( Matrix . MTRANS_Y , transY , prevActualHeight , actualHeight , prevViewHeight , viewHeight , drawableHeight ) ; matrix . setValues ( m ) ; } fixTrans ( ) ; setImageMatrix ( matrix ) ; }
public synchronized void close ( ) { if ( isAlive ) { isAlive = BOOL_ ; taskQueue . clear ( ) ; interrupt ( ) ; } }
public String removeAfter ( String original , String marker ) { int index = original . indexOf ( marker ) ; if ( index != - NUM_ ) { return original . substring ( NUM_ , index ) ; } return original ; }
public Address __sub__ ( final Object rhs ) { return new Address ( m_value . subtract ( getBigInteger ( rhs ) ) ) ; }
public static TestConfiguration buildDefaultConfiguration ( String testSourcePath , File testFile , String checkerName , List < String > options , boolean shouldEmitDebugInfo ) { List < File > javaFiles = Arrays . asList ( testFile ) ; List < String > processors = Arrays . asList ( checkerName ) ; return buildDefaultConfiguration ( testSourcePath , javaFiles , processors , options , shouldEmitDebugInfo ) ; }
private static boolean eq ( Object o1 , Object o2 ) { return ( o1 == null ? o2 == null : o1 . equals ( o2 ) ) ; }
public void roll ( int field , int value ) { boolean increment = value >= NUM_ ; int count = increment ? value : - value ; for ( int i = NUM_ ; i < count ; i ++ ) { roll ( field , increment ) ; } }
public String clusterResultsToString ( ) { return m_clusteringResults . toString ( ) ; }
private void generateGetModuleMethod ( NewBindingKey key , NewDependencyInfo dependencyInfo ) { TypeElement scope = scopeCalculator . calculate ( key ) ; generateGetModuleMethod ( scope , dependencyInfo ) ; }
private String [ ] separatorAndEnclosuresToArray ( ) { String [ ] parts = m_Enclosures . split ( STR_ ) ; String [ ] result = new String [ parts . length + NUM_ ] ; result [ NUM_ ] = m_FieldSeparator ; int index = NUM_ ; for ( String e : parts ) { if ( e . length ( ) > NUM_ || e . length ( ) == NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } result [ index ++ ] = e ; } return result ; }
private static void ReleaseStringChars ( JNIEnvironment env , int objJREF , Address bufAddress ) { if ( traceJNI ) VM . sysWrite ( STR_ ) ; RuntimeEntrypoints . checkJNICountDownToGC ( ) ; try { sysCall . sysFree ( bufAddress ) ; } catch ( Throwable unexpected ) { if ( traceJNI ) unexpected . printStackTrace ( System . err ) ; env . recordException ( unexpected ) ; } }
private BusinessObjectDataNotificationRegistrationEntity createBusinessObjectDataNotificationEntity ( NamespaceEntity namespaceEntity , NotificationEventTypeEntity notificationEventTypeEntity , BusinessObjectDefinitionEntity businessObjectDefinitionEntity , FileTypeEntity fileTypeEntity , StorageEntity storageEntity , BusinessObjectDataStatusEntity newBusinessObjectDataStatusEntity , BusinessObjectDataStatusEntity oldBusinessObjectDataStatusEntity , NotificationRegistrationKey key , BusinessObjectDataNotificationFilter businessObjectDataNotificationFilter , List < JobAction > jobActions , NotificationRegistrationStatusEntity notificationRegistrationStatusEntity ) { BusinessObjectDataNotificationRegistrationEntity businessObjectDataNotificationRegistrationEntity = new BusinessObjectDataNotificationRegistrationEntity ( ) ; businessObjectDataNotificationRegistrationEntity . setNamespace ( namespaceEntity ) ; businessObjectDataNotificationRegistrationEntity . setName ( key . getNotificationName ( ) ) ; businessObjectDataNotificationRegistrationEntity . setNotificationEventType ( notificationEventTypeEntity ) ; businessObjectDataNotificationRegistrationEntity . setBusinessObjectDefinition ( businessObjectDefinitionEntity ) ; if ( StringUtils . isNotBlank ( businessObjectDataNotificationFilter . getBusinessObjectFormatUsage ( ) ) ) { businessObjectDataNotificationRegistrationEntity . setUsage ( businessObjectDataNotificationFilter . getBusinessObjectFormatUsage ( ) ) ; } businessObjectDataNotificationRegistrationEntity . setFileType ( fileTypeEntity ) ; businessObjectDataNotificationRegistrationEntity . setBusinessObjectFormatVersion ( businessObjectDataNotificationFilter . getBusinessObjectFormatVersion ( ) ) ; businessObjectDataNotificationRegistrationEntity . setStorage ( storageEntity ) ; businessObjectDataNotificationRegistrationEntity . setNewBusinessObjectDataStatus ( newBusinessObjectDataStatusEntity ) ; businessObjectDataNotificationRegistrationEntity . setOldBusinessObjectDataStatus ( oldBusinessObjectDataStatusEntity ) ; businessObjectDataNotificationRegistrationEntity . setNotificationRegistrationStatus ( notificationRegistrationStatusEntity ) ; List < NotificationActionEntity > notificationActionEntities = new ArrayList < > ( ) ; businessObjectDataNotificationRegistrationEntity . setNotificationActions ( notificationActionEntities ) ; for ( JobAction jobAction : jobActions ) { JobDefinitionEntity jobDefinitionEntity = jobDefinitionDaoHelper . getJobDefinitionEntity ( jobAction . getNamespace ( ) , jobAction . getJobName ( ) ) ; NotificationJobActionEntity notificationJobActionEntity = new NotificationJobActionEntity ( ) ; notificationActionEntities . add ( notificationJobActionEntity ) ; notificationJobActionEntity . setJobDefinition ( jobDefinitionEntity ) ; notificationJobActionEntity . setCorrelationData ( jobAction . getCorrelationData ( ) ) ; notificationJobActionEntity . setNotificationRegistration ( businessObjectDataNotificationRegistrationEntity ) ; } return businessObjectDataNotificationRegistrationEntity ; }
void bind ( String jndiUrl , Hashtable < ? , ? > attributes , RMIServer rmiServer , boolean rebind ) throws NamingException , MalformedURLException { InitialContext ctx = new InitialContext ( attributes ) ; if ( rebind ) ctx . rebind ( jndiUrl , rmiServer ) ; else ctx . bind ( jndiUrl , rmiServer ) ; ctx . close ( ) ; }
public String toString ( ) { if ( info == null || algId == null || signature == null ) return STR_ ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( STR_ ) ; sb . append ( info . toString ( ) + STR_ ) ; sb . append ( STR_ + algId . toString ( ) + STR_ ) ; HexDumpEncoder encoder = new HexDumpEncoder ( ) ; sb . append ( STR_ + encoder . encodeBuffer ( signature ) ) ; sb . append ( STR_ ) ; return sb . toString ( ) ; }
public void testObsoleteDstZoneName ( ) throws Exception { SimpleDateFormat format = new SimpleDateFormat ( STR_ , Locale . US ) ; Date normal = format . parse ( STR_ ) ; Date dst = format . parse ( STR_ ) ; assertEquals ( NUM_ . NUM_ . NUM_ , normal . getTime ( ) - dst . getTime ( ) ) ; }
public final void XprintLatin1NoLf ( String string ) throws IOException { if ( _source == null ) { return ; } if ( string == null ) { string = STR_ ; } byte [ ] writeBuffer = _writeBuffer ; int writeLength = _writeLength ; int length = string . length ( ) ; int offset = NUM_ ; int charsLength = CHARS_LENGTH ; char [ ] chars = _chars ; while ( length > NUM_ ) { int sublen = Math . min ( charsLength , writeBuffer . length - writeLength ) ; if ( sublen <= NUM_ ) { _source . write ( writeBuffer , NUM_ , writeLength , BOOL_ ) ; _position += writeLength ; _isFlushRequired = BOOL_ ; writeLength = NUM_ ; sublen = Math . min ( charsLength , writeBuffer . length - writeLength ) ; } sublen = Math . min ( length , sublen ) ; string . getChars ( offset , sublen , chars , NUM_ ) ; for ( int i = NUM_ ; i < sublen ; i ++ ) { byte value = ( byte ) chars [ i ] ; if ( value == STR_ || value == STR_ ) { length = NUM_ ; break ; } writeBuffer [ writeLength ++ ] = value ; } offset += sublen ; length -= sublen ; } _writeLength = writeLength ; }
private int calculateStrokeWeight ( ) { int strokeWeight = ( int ) ( getStrokeWidth ( ) . NUM_ ) ; LOGGER . trace ( STR_ , strokeWidth ) ; return strokeWeight ; }
private static List < MatchResult > flattenResults ( List < List < MatchResult > > allResults ) { List < MatchResult > results = new ArrayList < MatchResult > ( ) ; results . addAll ( allResults . remove ( NUM_ ) ) ; for ( List < MatchResult > relResults : allResults ) { List < MatchResult > newResults = new ArrayList < MatchResult > ( ) ; for ( MatchResult curResult : results ) { for ( MatchResult relResult : relResults ) { MatchResult newResult = curResult . copy ( ) ; newResult . addAssignment ( relResult ) ; newResults . add ( newResult ) ; } } results = newResults ; } return results ; }
@ Override public void visit ( Mapping m , int line , int col , int nextLine , int nextCol ) throws IOException { if ( previousLine != line ) { previousColumn = NUM_ ; } if ( line != nextLine || col != nextCol ) { if ( line < maxLine ) { if ( previousLine == line ) { out . append ( STR_ ) ; } writeEntry ( m , col ) ; previousLine = line ; previousColumn = col ; } else { Preconditions . checkState ( m == null ) ; } } for ( int i = line ; i <= nextLine && i < maxLine ; i ++ ) { if ( i == nextLine ) { break ; } closeLine ( BOOL_ ) ; openLine ( BOOL_ ) ; } }
public boolean onClick ( int position ) { if ( mMode == MODE_MULTIPLE_SELECT ) { if ( mSelectedItems . contains ( position ) ) { mSelectedItems . remove ( position ) ; if ( mSelectedItems . isEmpty ( ) ) { setMode ( MODE_SINGLE_SELECT ) ; } } else { mSelectedItems . add ( position ) ; } notifySelectionChanged ( position ) ; return BOOL_ ; } return BOOL_ ; }
public void addSessionEventURL ( String url , SessionID sid ) { Set < SessionID > sids = sessionEventURLs . get ( url ) ; if ( sids == null ) { sids = Collections . newSetFromMap ( new ConcurrentHashMap < SessionID , Boolean > ( ) ) ; Set < SessionID > previousValue = sessionEventURLs . putIfAbsent ( url , sids ) ; if ( previousValue != null ) { sids = previousValue ; } } if ( sids . add ( sid ) ) { notifyPersistenceManager ( ) ; } }
abstract public long rangeCount ( ) ;
public final void addInstWithUnknown ( Instances source , int attIndex ) throws Exception { double [ ] probs ; double weight , newWeight ; int classIndex ; Instance instance ; int j ; probs = new double [ m_perBag . length ] ; for ( j = NUM_ ; j < m_perBag . length ; j ++ ) { if ( Utils . eq ( totaL , NUM_ ) ) { probs [ j ] = NUM_ / probs . length ; } else { probs [ j ] = m_perBag [ j ] / totaL ; } } Enumeration < Instance > enu = source . enumerateInstances ( ) ; while ( enu . hasMoreElements ( ) ) { instance = enu . nextElement ( ) ; if ( instance . isMissing ( attIndex ) ) { classIndex = ( int ) instance . classValue ( ) ; weight = instance . weight ( ) ; m_perClass [ classIndex ] = m_perClass [ classIndex ] + weight ; totaL = totaL + weight ; for ( j = NUM_ ; j < m_perBag . length ; j ++ ) { newWeight = probs [ j ] . weight ; m_perClassPerBag [ j ] [ classIndex ] = m_perClassPerBag [ j ] [ classIndex ] + newWeight ; m_perBag [ j ] = m_perBag [ j ] + newWeight ; } } } }
@ Override public void onItemClick ( AdapterView < ? > parent , View view , int position , long id ) { setSelection ( position ) ; }
public void traverseFragment ( Node pos ) throws org . xml . sax . SAXException { Node top = pos ; while ( null != pos ) { startNode ( pos ) ; Node nextNode = pos . getFirstChild ( ) ; while ( null == nextNode ) { endNode ( pos ) ; if ( top . equals ( pos ) ) break ; nextNode = pos . getNextSibling ( ) ; if ( null == nextNode ) { pos = pos . getParentNode ( ) ; if ( ( null == pos ) || ( top . equals ( pos ) ) ) { if ( null != pos ) endNode ( pos ) ; nextNode = null ; break ; } } } pos = nextNode ; } }
public void updateProcessorDuration ( Duration duration ) { processor_duration_ = Optional . of ( duration ) ; }
static Object invokeOrDie ( Method method , Object object , Object ... params ) { try { return method . invoke ( object , params ) ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( STR_ + STR_ , e ) ; } catch ( InvocationTargetException e ) { final Throwable cause = e . getCause ( ) ; if ( cause instanceof RuntimeException ) { throw ( RuntimeException ) cause ; } else if ( cause instanceof Error ) { throw ( Error ) cause ; } else { throw new RuntimeException ( STR_ , cause ) ; } } }
public void startElement ( String uri , String localName , String qName , Attributes atts ) throws SAXException { elementLevel ++ ; nsSupport . pushContext ( ) ; if ( forceDTD && ! hasOutputDTD ) startDTD ( localName == null ? qName : localName , STR_ , STR_ ) ; write ( STR_ ) ; writeName ( uri , localName , qName , BOOL_ ) ; writeAttributes ( atts ) ; if ( elementLevel == NUM_ ) { forceNSDecls ( ) ; } writeNSDecls ( ) ; write ( STR_ ) ; if ( htmlMode && ( qName . equals ( STR_ ) || qName . equals ( STR_ ) ) ) { cdataElement = BOOL_ ; } super . startElement ( uri , localName , qName , atts ) ; }
void initProgram ( ) { glUseProgram ( this . program ) ; viewMatrixUniform = glGetUniformLocation ( this . program , STR_ ) ; projMatrixUniform = glGetUniformLocation ( this . program , STR_ ) ; viewportSizeUniform = glGetUniformLocation ( this . program , STR_ ) ; glUseProgram ( NUM_ ) ; }
public static String [ ] sortCopy ( String [ ] objects ) { int len = objects . length ; String [ ] copy = new String [ len ] ; System . arraycopy ( objects , NUM_ , copy , NUM_ , len ) ; sort ( copy ) ; return copy ; }
public Iterator < SimEvent > iterator ( ) { return list . iterator ( ) ; }
private static boolean accepts ( String accept_header , String to_accept ) { String [ ] acceptValues = accept_header . split ( STR_ ) ; Arrays . sort ( acceptValues ) ; return Arrays . binarySearch ( acceptValues , to_accept ) > - NUM_ || Arrays . binarySearch ( acceptValues , to_accept . replaceAll ( STR_ , STR_ ) ) > - NUM_ || Arrays . binarySearch ( acceptValues , STR_ ) > - NUM_ ; }
public String [ ] tokenize ( String rawString ) { Vector < String > result = new Vector < String > ( ) ; StringTokenizer tk = new StringTokenizer ( rawString , m_Seperator ) ; while ( tk . hasMoreTokens ( ) ) { result . addElement ( tk . nextToken ( ) ) ; } String [ ] newStrings = new String [ result . size ( ) ] ; for ( int i = NUM_ ; i < result . size ( ) ; i ++ ) { newStrings [ i ] = result . elementAt ( i ) ; } return newStrings ; }
public synchronized void returnLogCursor ( LogCursor logCursor ) { logCursor . setLoaned ( BOOL_ ) ; }
void unassignPolicies ( String serviceName , Set policyDNs , boolean toVerify ) throws AMException , SSOException { if ( ( policyDNs == null ) || ( policyDNs . isEmpty ( ) ) ) { return ; } AMTemplate template = getTemplate ( serviceName , AMTemplate . POLICY_TEMPLATE ) ; unassignPolicies ( template , policyDNs , toVerify ) ; }
public boolean releaseLock ( String lockName ) { if ( lockName == null || lockName . isEmpty ( ) ) { s_logger . info ( STR_ ) ; return BOOL_ ; } try { InterProcessLock lock = s_acquiredLocks . get ( lockName ) ; if ( lock != null ) { s_acquiredLocks . remove ( lockName ) ; lock . release ( ) ; s_logger . info ( STR_ + lockName ) ; } else { return BOOL_ ; } return BOOL_ ; } catch ( Exception e ) { s_logger . error ( STR_ , lockName , e ) ; return BOOL_ ; } }
@ Parameterized . Parameters ( name = STR_ ) public static Collection < PaymentChannelClient . VersionSelector > data ( ) { return Arrays . asList ( PaymentChannelClient . VersionSelector . VERSION_1 , PaymentChannelClient . VersionSelector . VERSION_2_ALLOW_1 ) ; }
private View findInterceptingView ( float pos , View v ) { for ( KeyButtonView otherView : mButtonViews ) { if ( otherView == v ) { continue ; } if ( ArrayUtils . contains ( SMALL_BUTTON_IDS , otherView . getId ( ) ) ) { continue ; } otherView . getLocationOnScreen ( sLocation ) ; float otherPos = sLocation [ mVertical ? NUM_ : NUM_ ] ; float otherDimension = mVertical ? v . getHeight ( ) : v . getWidth ( ) ; if ( pos > ( otherPos + otherDimension / NUM_ ) && pos < ( otherPos + otherDimension ) ) { return otherView ; } } return null ; }
public void detachDiskAsync ( final String vmId , VmDiskOperation vmDiskOperation , final FutureCallback < Task > responseCallback ) throws IOException { String path = String . format ( STR_ , getBasePath ( ) , vmId ) ; createObjectAsync ( path , serializeObjectAsJson ( vmDiskOperation ) , responseCallback ) ; }
public static void main ( String [ ] args ) { Log . printLine ( STR_ ) ; try { int num_user = NUM_ ; Calendar calendar = Calendar . getInstance ( ) ; boolean trace_flag = BOOL_ ; CloudSim . init ( num_user , calendar , trace_flag ) ; @ SuppressWarnings ( STR_ ) Datacenter datacenter0 = createDatacenter ( STR_ ) ; @ SuppressWarnings ( STR_ ) Datacenter datacenter1 = createDatacenter ( STR_ ) ; DatacenterBroker broker1 = createBroker ( NUM_ ) ; int brokerId1 = broker1 . getId ( ) ; DatacenterBroker broker2 = createBroker ( NUM_ ) ; int brokerId2 = broker2 . getId ( ) ; vmlist1 = new ArrayList < Vm > ( ) ; vmlist2 = new ArrayList < Vm > ( ) ; int vmid = NUM_ ; int mips = NUM_ ; long size = NUM_ ; int ram = NUM_ ; long bw = NUM_ ; int pesNumber = NUM_ ; String vmm = STR_ ; Vm vm1 = new Vm ( vmid , brokerId1 , mips , pesNumber , ram , bw , size , vmm , new CloudletSchedulerTimeShared ( ) ) ; Vm vm2 = new Vm ( vmid , brokerId2 , mips , pesNumber , ram , bw , size , vmm , new CloudletSchedulerTimeShared ( ) ) ; vmlist1 . add ( vm1 ) ; vmlist2 . add ( vm2 ) ; broker1 . submitVmList ( vmlist1 ) ; broker2 . submitVmList ( vmlist2 ) ; cloudletList1 = new ArrayList < Cloudlet > ( ) ; cloudletList2 = new ArrayList < Cloudlet > ( ) ; int id = NUM_ ; long length = NUM_ ; long fileSize = NUM_ ; long outputSize = NUM_ ; UtilizationModel utilizationModel = new UtilizationModelFull ( ) ; Cloudlet cloudlet1 = new Cloudlet ( id , length , pesNumber , fileSize , outputSize , utilizationModel , utilizationModel , utilizationModel ) ; cloudlet1 . setUserId ( brokerId1 ) ; Cloudlet cloudlet2 = new Cloudlet ( id , length , pesNumber , fileSize , outputSize , utilizationModel , utilizationModel , utilizationModel ) ; cloudlet2 . setUserId ( brokerId2 ) ; cloudletList1 . add ( cloudlet1 ) ; cloudletList2 . add ( cloudlet2 ) ; broker1 . submitCloudletList ( cloudletList1 ) ; broker2 . submitCloudletList ( cloudletList2 ) ; CloudSim . startSimulation ( ) ; List < Cloudlet > newList1 = broker1 . getCloudletReceivedList ( ) ; List < Cloudlet > newList2 = broker2 . getCloudletReceivedList ( ) ; CloudSim . stopSimulation ( ) ; Log . print ( STR_ + brokerId1 + STR_ ) ; printCloudletList ( newList1 ) ; Log . print ( STR_ + brokerId2 + STR_ ) ; printCloudletList ( newList2 ) ; Log . printLine ( STR_ ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; Log . printLine ( STR_ ) ; } }
public static boolean isFPZero ( @ NotNull final String text ) { for ( int i = NUM_ ; i < text . length ( ) ; i ++ ) { final char c = text . charAt ( i ) ; if ( Character . isDigit ( c ) && c != STR_ ) return BOOL_ ; final char d = Character . toUpperCase ( c ) ; if ( d == STR_ || d == STR_ ) break ; } return BOOL_ ; }
public ConcurrentHashMapPro ( Map < ? extends K , ? extends V > m ) { this ( Math . max ( ( int ) ( m . size ( ) / DEFAULT_LOAD_FACTOR ) + NUM_ , DEFAULT_INITIAL_CAPACITY ) , DEFAULT_LOAD_FACTOR , DEFAULT_CONCURRENCY_LEVEL ) ; putAll ( m ) ; }
private void initialiseCommands ( ) { reward = new AchievementRewards ( this ) ; achievementDisplay = new AchievementDisplay ( this ) ; giveCommand = new GiveCommand ( this ) ; bookCommand = new BookCommand ( this ) ; topCommand = new TopCommand ( this ) ; statsCommand = new StatsCommand ( this ) ; infoCommand = new InfoCommand ( this ) ; listCommand = new ListCommand ( this ) ; helpCommand = new HelpCommand ( this ) ; checkCommand = new CheckCommand ( this ) ; deleteCommand = new DeleteCommand ( this ) ; }
public CreateCustomMetric ( Monitoring monitoringService , String projectResource ) { this . monitoringService = monitoringService ; this . projectResource = projectResource ; this . metricType = CUSTOM_METRIC_DOMAIN + STR_ + DEFAULT_METRIC_TYPE ; this . metricName = projectResource + STR_ + metricType ; }
private boolean journalRebuildRequired ( ) { final int REDUNDANT_OP_COMPACT_THRESHOLD = NUM_ ; return redundantOpCount >= REDUNDANT_OP_COMPACT_THRESHOLD && redundantOpCount >= lruEntries . size ( ) ; }
public static boolean deleteFilesInADirectory ( String directoryPath ) { if ( ( directoryPath == null ) || directoryPath . isEmpty ( ) ) { return BOOL_ ; } boolean isSuccessfulDelete = BOOL_ ; List < File > files = getListOfFilesInADirectory ( directoryPath ) ; if ( files == null ) { return BOOL_ ; } try { for ( File file : files ) { boolean fileDeleteSuccess = deleteFile ( directoryPath , file . getName ( ) ) ; if ( ! fileDeleteSuccess ) { isSuccessfulDelete = BOOL_ ; } } } catch ( Exception e ) { logger . debug ( e . toString ( ) + System . lineSeparator ( ) + StackTrace . getStringFromStackTrace ( e ) ) ; isSuccessfulDelete = BOOL_ ; } return isSuccessfulDelete ; }
public AnnotationFS add ( AnnotationFS aOriginFs , AnnotationFS aTargetFs , JCas aJCas , int aStart , int aEnd , AnnotationFeature aFeature , Object aLabelValue ) throws BratAnnotationException { if ( crossMultipleSentence || isSameSentence ( aJCas , aOriginFs . getBegin ( ) , aTargetFs . getEnd ( ) ) ) { return interalAddToCas ( aJCas , aStart , aEnd , aOriginFs , aTargetFs , aLabelValue , aFeature ) ; } else { throw new ArcCrossedMultipleSentenceException ( STR_ ) ; } }
public void testEqualsNull ( ) { String a = STR_ ; int aScale = - NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; assertFalse ( aNumber . equals ( null ) ) ; }
private String readLine ( ) { StringBuffer sb = new StringBuffer ( ) ; while ( buf . remaining ( ) > NUM_ ) { char c = ( char ) buf . get ( ) ; if ( c == STR_ ) { if ( buf . remaining ( ) > NUM_ ) { char n = ( char ) buf . get ( buf . position ( ) ) ; if ( n == STR_ ) { buf . get ( ) ; } } break ; } else if ( c == STR_ ) { break ; } sb . append ( c ) ; } return sb . toString ( ) ; }
protected void write ( DataOutputStream stream ) throws Exception { stream . writeInt ( value ) ; }
@ Override public int showOpenDialog ( Component parent ) { File selFile ; int result ; m_DialogType = OPEN_DIALOG ; initGUI ( OPEN_DIALOG ) ; result = super . showOpenDialog ( parent ) ; m_DialogType = UNHANDLED_DIALOG ; removePropertyChangeListener ( m_Listener ) ; selFile = getSelectedFile ( ) ; if ( ( result == APPROVE_OPTION ) && ( getFileMustExist ( ) ) && ( selFile == null ) ) { result = showOpenDialog ( parent ) ; } else if ( ( result == APPROVE_OPTION ) && ( getFileMustExist ( ) ) && ( selFile != null ) && ( selFile . isFile ( ) ) && ( ! selFile . exists ( ) ) ) { int retVal = JOptionPane . showConfirmDialog ( parent , STR_ + selFile + STR_ ) ; if ( retVal == JOptionPane . OK_OPTION ) result = showOpenDialog ( parent ) ; else result = CANCEL_OPTION ; } if ( result == APPROVE_OPTION ) { if ( getFileFilter ( ) instanceof ExtensionFileFilter ) m_LastFilter = ( ExtensionFileFilter ) getFileFilter ( ) ; else m_LastFilter = null ; if ( getSelectedFile ( ) != null ) configureCurrentHandlerHook ( OPEN_DIALOG ) ; } return result ; }
public boolean isNearlyEqualTo ( DoubleVector v , double tolerance ) { return Math . abs ( v . x - x ) < tolerance && Math . abs ( v . y - y ) < tolerance && Math . abs ( v . z - z ) < tolerance ; }
private float colorToAngle ( int color ) { float [ ] colors = new float [ NUM_ ] ; Color . colorToHSV ( color , colors ) ; return ( float ) Math . toRadians ( - colors [ NUM_ ] ) ; }
void createVerticalSnapAnimation ( boolean visible ) { float translationY = visible ? NUM_ : mTotalHeight ; float yDifference = Math . abs ( translationY - getTranslationY ( ) ) / mTotalHeight ; long duration = ( long ) ( MS_ANIMATION_DURATION . yDifference ) ; createAnimation ( NUM_ , NUM_ , translationY , duration ) ; }
@ Override public int update ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) throws ShortBufferException { return cipher . update ( input , inputOffset , inputLen , output , outputOffset ) ; }
private String validateInputs ( ) { if ( jarRadio . getSelection ( ) ) { File f = new File ( jarPath . getText ( ) ) ; if ( ! f . exists ( ) ) { return STR_ ; } if ( ! f . canRead ( ) ) { return STR_ ; } } else { File f = new File ( dirPath . getText ( ) ) ; if ( ! f . exists ( ) ) { return STR_ ; } if ( ! f . canRead ( ) ) { return STR_ ; } } return null ; }
public static double parseDoubleString ( String st , TExecutionContext context ) { double ret = NUM_ ; Matcher m = DOUBLE_PATTERN . matcher ( st ) ; if ( m . lookingAt ( ) ) { String truncated = st . substring ( NUM_ , m . end ( ) ) ; if ( ! truncated . equals ( st ) ) { context . reportTruncate ( st , truncated ) ; } try { ret = Double . parseDouble ( truncated ) ; } catch ( NumberFormatException e ) { context . reportBadValue ( e . getMessage ( ) ) ; } } else context . reportBadValue ( st ) ; return ret ; }
public ClassPath ( DexFile ... classPath ) throws IOException { this ( Lists . newArrayList ( classPath ) , NUM_ ) ; }
public double greatCircleAzimuth ( Location location ) { if ( location == null ) { throw new IllegalArgumentException ( Logger . logMessage ( Logger . ERROR , STR_ , STR_ , STR_ ) ) ; } double lat1 = Math . toRadians ( this . latitude ) ; double lon1 = Math . toRadians ( this . longitude ) ; double lat2 = Math . toRadians ( location . latitude ) ; double lon2 = Math . toRadians ( location . longitude ) ; if ( lat1 == lat2 && lon1 == lon2 ) { return NUM_ ; } if ( lon1 == lon2 ) { return lat1 > lat2 ? NUM_ : NUM_ ; } double y = Math . cos ( lat2 ) . Math . sin ( lon2 - lon1 ) ; double x = Math . cos ( lat1 ) . Math . sin ( lat2 ) - Math . sin ( lat1 ) . Math . cos ( lat2 ) . Math . cos ( lon2 - lon1 ) ; double azimuthRadians = Math . atan2 ( y , x ) ; return Double . isNaN ( azimuthRadians ) ? NUM_ : Math . toDegrees ( azimuthRadians ) ; }
private boolean [ ] defineIrrelevant ( Random random ) { boolean [ ] irr = new boolean [ getNumAttributes ( ) ] ; for ( int i = NUM_ ; i < irr . length ; i ++ ) { irr [ i ] = BOOL_ ; } int numIrr = NUM_ ; for ( int i = NUM_ ; ( numIrr < getNumIrrelevant ( ) ) && ( i < getNumAttributes ( ) . NUM_ ) ; i ++ ) { int maybeNext = ( int ) ( random . nextDouble ( ) . irr . length ) ; if ( irr [ maybeNext ] == BOOL_ ) { irr [ maybeNext ] = BOOL_ ; numIrr ++ ; } } return irr ; }
public void addDropItem ( final String name , final double probability , final int amount ) { dropsItems . add ( new DropItem ( name , probability , amount ) ) ; }
protected void unparsedEntDecl ( String name , String pubid , String sysid , String notation ) throws SAXException { mHandDtd . unparsedEntityDecl ( name , pubid , sysid , notation ) ; }
public Enumeration < Permission > elements ( ) { synchronized ( this ) { return Collections . enumeration ( permsMap . values ( ) ) ; } }
private static String formatList ( String [ ] stringList , String listPattern , String listCompositionPattern ) { if ( listPattern == null || listCompositionPattern == null ) { StringBuilder result = new StringBuilder ( ) ; for ( int i = NUM_ ; i < stringList . length ; ++ i ) { if ( i > NUM_ ) { result . append ( STR_ ) ; } result . append ( stringList [ i ] ) ; } return result . toString ( ) ; } if ( stringList . length > NUM_ ) { MessageFormat format = new MessageFormat ( listCompositionPattern ) ; stringList = composeList ( format , stringList ) ; } Object [ ] args = new Object [ stringList . length + NUM_ ] ; System . arraycopy ( stringList , NUM_ , args , NUM_ , stringList . length ) ; args [ NUM_ ] = new Integer ( stringList . length ) ; MessageFormat format = new MessageFormat ( listPattern ) ; return format . format ( args ) ; }
public JsonArray add ( Object value ) { list . add ( value ) ; return this ; }
public String comment ( ) throws ParseException { StringBuffer retval = new StringBuffer ( ) ; if ( lookAhead ( NUM_ ) != STR_ ) return null ; consume ( NUM_ ) ; while ( BOOL_ ) { char next = getNextChar ( ) ; if ( next == STR_ ) { break ; } else if ( next == STR_ ) { throw new ParseException ( this . buffer + STR_ , this . ptr ) ; } else if ( next == STR_ ) { retval . append ( next ) ; next = getNextChar ( ) ; if ( next == STR_ ) throw new ParseException ( this . buffer + STR_ , this . ptr ) ; retval . append ( next ) ; } else { retval . append ( next ) ; } } return retval . toString ( ) ; }
public static boolean ignorableWhitespace ( String value ) { Matcher m ; m = whitespacePattern . matcher ( value ) ; if ( m . matches ( ) ) return BOOL_ ; else return BOOL_ ; }
public DelphiWorkgroup ( File xmlFile ) throws IOException { if ( xmlFile == null ) { throw new IllegalArgumentException ( STR_ ) ; } else if ( ! xmlFile . exists ( ) ) { throw new IOException ( STR_ + xmlFile . getAbsolutePath ( ) ) ; } parseFile ( xmlFile ) ; }
public BufferedBlockCipher ( BlockCipher cipher ) { this . cipher = cipher ; buf = new byte [ cipher . getBlockSize ( ) ] ; bufOff = NUM_ ; String name = cipher . getAlgorithmName ( ) ; int idx = name . indexOf ( STR_ ) + NUM_ ; pgpCFB = ( idx > NUM_ && name . startsWith ( STR_ , idx ) ) ; if ( pgpCFB || cipher instanceof StreamCipher ) { partialBlockOkay = BOOL_ ; } else { partialBlockOkay = ( idx > NUM_ && ( name . startsWith ( STR_ , idx ) ) ) ; } }
public static int readInts ( final File f , final LongIndex a , final long offset , final long addend ) throws IOException { return readInts ( f , NUM_ , ( int ) f . length ( ) / NUM_ , a , offset , addend ) ; }
public void waitAllSitesDbStable ( ) { String prefix = STR_ ; log . info ( prefix ) ; DbJmxClient geoInstance = getJmxClient ( LOCALHOST ) ; List < URI > vdcIdIter = queryByType ( VirtualDataCenter . class , BOOL_ ) ; for ( URI vdcId : vdcIdIter ) { log . info ( STR_ , vdcId . toString ( ) ) ; VirtualDataCenter vdc = queryObject ( VirtualDataCenter . class , vdcId ) ; if ( ! shouldCheckDbStatus ( vdc ) ) { log . error ( STR_ , vdcId ) ; continue ; } if ( vdc . getConnectionStatus ( ) != ConnectionStatus . DISCONNECTED ) { Site activeSite = drUtil . getActiveSite ( vdc . getShortId ( ) ) ; waitDbNodesStable ( geoInstance , vdc . getShortId ( ) , activeSite . getNodeCount ( ) ) ; } } }
public void saveHierarchyState ( Bundle container ) { dispatchSaveInstanceState ( container ) ; }
private static void pipe ( InputStream source , OutputStream dest ) throws IOException { byte [ ] buf = new byte [ NUM_ ] ; int read = NUM_ ; while ( ( read = source . read ( buf ) ) >= NUM_ ) { if ( null != dest ) dest . write ( buf , NUM_ , read ) ; } if ( null != dest ) dest . flush ( ) ; }
@ Override public void init ( FilterConfig config ) throws ServletException { try { expiry = Math . min ( Math . max ( MIN_EXPIRY , Long . parseLong ( config . getInitParameter ( CACHE_CONTROL ) ) ) , MAX_EXPIRY ) ; } catch ( NumberFormatException nfe ) { LOGGER . warn ( STR_ + CACHE_CONTROL + STR_ , nfe ) ; expiry = null ; } }
@ Override public int hashCode ( ) { int code = NUM_ ; if ( name != null ) { code += name . hashCode ( ) ; } if ( applicationName != null ) { code += applicationName . hashCode ( ) ; } if ( resourceNames != null ) { code += resourceNames . hashCode ( ) ; } if ( actionValues != null ) { code += actionValues . hashCode ( ) ; } if ( advices != null ) { code += advices . hashCode ( ) ; } if ( attributes != null ) { code += attributes . hashCode ( ) ; } return code ; }
public static boolean substractTradingFee ( Player player , int price ) { BigDecimal fee = calculateFee ( player , price ) ; return player . drop ( STR_ , fee . intValue ( ) ) ; }
public ComplexParameter ( MathExpression expression ) { this . expression = expression ; }
@ Override public Enumeration < String > enumerateMeasures ( ) { Vector < String > newVector = new Vector < String > ( NUM_ ) ; newVector . addElement ( STR_ ) ; return newVector . elements ( ) ; }
public SampleDriver ( ) { handlers = new ArrayList < SampleHandler > ( ) ; handlers . add ( new CertificateSampleHandler ( ) ) ; handlers . add ( new GroupSampleHandler ( ) ) ; handlers . add ( new SolutionUserSampleHandler ( ) ) ; handlers . add ( new UserSampleHandler ( ) ) ; }
public long [ ] readLongArray ( final int items , final JBBPByteOrder byteOrder ) throws IOException { int pos = NUM_ ; if ( items < NUM_ ) { long [ ] buffer = new long [ INITIAL_ARRAY_BUFFER_SIZE ] ; while ( hasAvailableData ( ) ) { final long next = readLong ( byteOrder ) ; if ( buffer . length == pos ) { final long [ ] newbuffer = new long [ buffer . length << NUM_ ] ; System . arraycopy ( buffer , NUM_ , newbuffer , NUM_ , buffer . length ) ; buffer = newbuffer ; } buffer [ pos ++ ] = next ; } if ( buffer . length == pos ) { return buffer ; } final long [ ] result = new long [ pos ] ; System . arraycopy ( buffer , NUM_ , result , NUM_ , pos ) ; return result ; } else { final long [ ] buffer = new long [ items ] ; for ( int i = NUM_ ; i < items ; i ++ ) { buffer [ i ] = readLong ( byteOrder ) ; } return buffer ; } }
private void logGraphicalBufferOccupancy ( float bufferOccupancy ) { String title = STR_ ; int used = ( int ) ( bufferOccupancy . WIDTH ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( START_END_CHAR ) ; sb . append ( STR_ ) ; sb . append ( title ) ; for ( int i = title . length ( ) + NUM_ ; i < WIDTH ; i ++ ) { sb . append ( STR_ ) ; } sb . append ( START_END_CHAR ) ; log . info ( sb . toString ( ) ) ; sb = new StringBuilder ( ) ; sb . append ( START_END_CHAR ) ; for ( int i = NUM_ ; i < used ; i ++ ) { sb . append ( STR_ ) ; } for ( int j = used ; j < WIDTH ; j ++ ) { sb . append ( STR_ ) ; } sb . append ( START_END_CHAR ) ; log . info ( sb . toString ( ) ) ; sb = new StringBuilder ( ) ; sb . append ( START_END_CHAR ) ; for ( int i = NUM_ ; i < WIDTH ; i ++ ) { sb . append ( STR_ ) ; } sb . append ( START_END_CHAR ) ; log . info ( sb . toString ( ) ) ; }
public boolean isTerminated ( ) { return threadPool . isTerminated ( ) ; }
public boolean isMatch ( String domain , List < UserMappingAttribute > attributes , List < String > groups ) { return _domain . equalsIgnoreCase ( domain ) && attributesMatch ( attributes ) && groupsMatch ( groups ) ; }
public static void writeSpatialGridTable ( SpatialGrid grid , String fileName ) { log . info ( STR_ + fileName + STR_ ) ; SpatialGridTableWriter sgTableWriter = new SpatialGridTableWriter ( ) ; try { sgTableWriter . write ( grid , fileName ) ; log . info ( STR_ ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
@ SuppressWarnings ( STR_ ) public OutputSocket linkedOutputSocket ( String hintIdentifier ) { final OutputSocket outSocket = outputSocketFactory . create ( new IdentiferOverridingSocketHintDecorator ( this , hintIdentifier ) ) ; controlledOutputSockets . add ( outSocket ) ; return outSocket ; }
public void cancel ( ) { cancelled = BOOL_ ; Thread thread = this . thread ; if ( thread != null ) { thread . interrupt ( ) ; } }
void _setText ( byte [ ] text ) { this . _text = text ; this . _props = null ; }
private String prepareURL ( ) { String str = STR_ ; str += STR_ ; for ( int i = NUM_ ; i < symbolList . size ( ) ; i ++ ) { if ( i != NUM_ ) { str += STR_ ; } str += symbolList . get ( i ) ; } str += STR_ ; for ( String format : parameterList ) { str += format ; } str += STR_ ; return str ; }
public void initialize ( ) { TextureState ts = new TextureState ( ) ; ts . setEnabled ( BOOL_ ) ; setRenderState ( ts ) ; for ( int i = NUM_ ; i < toolList . size ( ) ; ++ i ) { ToolState state = toolList . get ( i ) ; addTool ( state , BOOL_ ) ; } zBufferState = new ZBufferState ( ) ; zBufferState . setFunction ( ZBufferState . TestFunction . LessThanOrEqualTo ) ; zBufferState . setEnabled ( BOOL_ ) ; setRenderState ( zBufferState ) ; }
private static void init ( ) { encoders = new HashMap ( ) ; encoders . put ( STR_ , STR_ ) ; encoders . put ( STR_ , STR_ ) ; }
public static boolean checkImageSize ( final InputStream stream , final IConfiguration conf ) throws IOException { BufferedImage bi = ImageIO . read ( stream ) ; stream . close ( ) ; if ( bi == null ) { return BOOL_ ; } if ( bi . getHeight ( ) > conf . getImgHeight ( ) || bi . getWidth ( ) > conf . getImgWidth ( ) ) { return BOOL_ ; } return BOOL_ ; }
private static boolean compareArrayCase ( final String value , final int comparator , final Object [ ] array ) { for ( int i = NUM_ ; i < array . length ; i ++ ) { final Object obj = array [ i ] ; if ( obj instanceof String ) { if ( compareStringCase ( value , comparator , ( String ) obj ) ) { return BOOL_ ; } } else if ( obj instanceof Number ) { if ( compareNumber ( value . trim ( ) , comparator , ( Number ) obj ) ) { return BOOL_ ; } } else { if ( compareReflective ( value , comparator , obj ) ) { return BOOL_ ; } } } return BOOL_ ; }
public double valueAt ( double x ) { return constant . Math . pow ( NUM_ - x . x , outsideExp ) ; }
protected double generateWaitTime ( ) { if ( state == STATE_WALKING_ELSEWHERE ) { if ( location . equals ( latestBusStop ) ) { state = STATE_WAITING_FOR_BUS ; } } if ( state == STATE_TRAVELLING_ON_BUS ) { state = STATE_WAITING_FOR_BUS ; } return NUM_ ; }
@ Override public Enumeration < URL > findResources ( final String name ) throws IOException { if ( name == null ) { return null ; } ArrayList < URL > result = new ArrayList < URL > ( ) ; int n = NUM_ ; while ( BOOL_ ) { URLHandler handler = getHandler ( n ++ ) ; if ( handler == null ) { break ; } handler . findResources ( name , result ) ; } return Collections . enumeration ( result ) ; }
protected void writeGraphicCtrlExt ( ) throws IOException { out . write ( x21 ) ; out . write ( xf9 ) ; out . write ( NUM_ ) ; int transp , disp ; if ( transparent == null ) { transp = NUM_ ; disp = NUM_ ; } else { transp = NUM_ ; disp = NUM_ ; } if ( dispose >= NUM_ ) { disp = dispose & NUM_ ; } disp <<= NUM_ ; out . write ( NUM_ | disp | NUM_ | transp ) ; writeShort ( delay ) ; out . write ( transIndex ) ; out . write ( NUM_ ) ; }
public static void writeElementList ( XMLOutput xmlOutput , String tagName , Iterable < String > listValues ) throws IOException { writeElementList ( xmlOutput , tagName , listValues . iterator ( ) ) ; }
public static Date stringToDate ( String dateAsString ) { try { DateFormat df = new SimpleDateFormat ( dateFormat ) ; df . setTimeZone ( utc ) ; return df . parse ( dateAsString ) ; } catch ( ParseException e ) { return null ; } catch ( NullPointerException e ) { return null ; } }
public SimpleHttpRequestBuilder content ( String chars , Charset charset ) { return content ( chars . getBytes ( charset ) ) ; }
public void addTableModelListener ( WTableModelListener listener ) { if ( listener == null ) { return ; } if ( ! m_listeners . contains ( listener ) ) { m_listeners . add ( listener ) ; } return ; }
public boolean canTraverseOutsideSubtree ( ) { if ( null != m_parts ) { int n = m_parts . size ( ) ; for ( int i = NUM_ ; i < n ; i ++ ) { AVTPart part = ( AVTPart ) m_parts . elementAt ( i ) ; if ( part . canTraverseOutsideSubtree ( ) ) return BOOL_ ; } } return BOOL_ ; }
public static CipherParameters makePBEParameters ( PBEKeySpec keySpec , int type , int hash , int keySize , int ivSize ) { PBEParametersGenerator generator = makePBEGenerator ( type , hash ) ; byte [ ] key ; CipherParameters param ; key = convertPassword ( type , keySpec ) ; generator . init ( key , keySpec . getSalt ( ) , keySpec . getIterationCount ( ) ) ; if ( ivSize != NUM_ ) { param = generator . generateDerivedParameters ( keySize , ivSize ) ; } else { param = generator . generateDerivedParameters ( keySize ) ; } for ( int i = NUM_ ; i != key . length ; i ++ ) { key [ i ] = NUM_ ; } return param ; }
private int [ ] parseYMD ( String string ) { string = string . trim ( ) ; try { if ( string . charAt ( NUM_ ) != STR_ || string . charAt ( NUM_ ) != STR_ ) { throw new IllegalArgumentException ( STR_ ) ; } int [ ] ymd = new int [ NUM_ ] ; ymd [ NUM_ ] = Integer . valueOf ( string . substring ( NUM_ , NUM_ ) ) ; ymd [ NUM_ ] = Integer . valueOf ( string . substring ( NUM_ , NUM_ ) ) ; ymd [ NUM_ ] = Integer . valueOf ( string . substring ( NUM_ , NUM_ ) ) ; return ymd ; } catch ( NumberFormatException ex ) { throw new IllegalArgumentException ( STR_ , ex ) ; } }
public AbstractPointRenderer ( ) { shape = new Rectangle2D . Double ( - NUM_ , - NUM_ , NUM_ , NUM_ ) ; color = new SingleColor ( Color . BLACK ) ; valueVisible = BOOL_ ; valueColumn = NUM_ ; valueLocation = Location . CENTER ; valueAlignmentX = NUM_ ; valueAlignmentY = NUM_ ; valueRotation = NUM_ ; valueDistance = NUM_ ; valueColor = new SingleColor ( Color . BLACK ) ; valueFont = Font . decode ( null ) ; errorVisible = BOOL_ ; errorColumnTop = NUM_ ; errorColumnBottom = NUM_ ; errorColor = new SingleColor ( Color . BLACK ) ; errorShape = new Line2D . Double ( - NUM_ , NUM_ , NUM_ , NUM_ ) ; errorStroke = new BasicStroke ( NUM_ ) ; }
public Object put ( String key , Object value ) { Object oldValue = context . getAttribute ( key , ENGINE_SCOPE ) ; context . setAttribute ( key , value , ENGINE_SCOPE ) ; return oldValue ; }
public void test_getLowestSetBitPos ( ) { byte aBytes [ ] = { - NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int iNumber = NUM_ ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; int result = aNumber . getLowestSetBit ( ) ; assertTrue ( STR_ , result == iNumber ) ; byte [ ] aBytes_ = { NUM_ , NUM_ , NUM_ } ; iNumber = NUM_ ; aNumber = new BigInteger ( aSign , aBytes_ ) ; result = aNumber . getLowestSetBit ( ) ; assertTrue ( STR_ , result == iNumber ) ; byte [ ] aBytes__ = { - NUM_ , NUM_ , NUM_ } ; iNumber = NUM_ ; aNumber = new BigInteger ( aSign , aBytes__ ) ; result = aNumber . getLowestSetBit ( ) ; assertTrue ( STR_ , result == iNumber ) ; }
private void executeAnotherRequest ( ) throws SQLException { Random random = new Random ( ) ; int value = random . nextInt ( ) ; PreparedStatement preparedStatement = sharedConnection . prepareStatement ( STR_ + value ) ; ResultSet rs = preparedStatement . executeQuery ( ) ; rs . next ( ) ; assertEquals ( value , rs . getInt ( NUM_ ) ) ; }
private void statInit ( ) { labelValue . setText ( Msg . getMsg ( Env . getCtx ( ) , STR_ ) ) ; fieldValue . setBackground ( AdempierePLAF . getInfoBackground ( ) ) ; fieldValue . addActionListener ( this ) ; labelName . setText ( Msg . getMsg ( Env . getCtx ( ) , STR_ ) ) ; fieldName . setBackground ( AdempierePLAF . getInfoBackground ( ) ) ; fieldName . addActionListener ( this ) ; fBPartner_ID = new VLookup ( STR_ , BOOL_ , BOOL_ , BOOL_ , MLookupFactory . get ( Env . getCtx ( ) , p_WindowNo , NUM_ , MColumn . getColumn_ID ( I_A_Asset . Table_Name , I_A_Asset . COLUMNNAME_C_BPartner_ID ) , DisplayType . Search ) ) ; lBPartner_ID . setLabelFor ( fBPartner_ID ) ; fBPartner_ID . setBackground ( AdempierePLAF . getInfoBackground ( ) ) ; fBPartner_ID . addActionListener ( this ) ; fProduct_ID = new VLookup ( STR_ , BOOL_ , BOOL_ , BOOL_ , MLookupFactory . get ( Env . getCtx ( ) , p_WindowNo , NUM_ , MColumn . getColumn_ID ( I_A_Asset . Table_Name , I_A_Asset . COLUMNNAME_M_Product_ID ) , DisplayType . Search ) ) ; lProduct_ID . setLabelFor ( fProduct_ID ) ; fProduct_ID . setBackground ( AdempierePLAF . getInfoBackground ( ) ) ; fProduct_ID . addActionListener ( this ) ; p_criteriaGrid . add ( labelValue , new ALayoutConstraint ( NUM_ , NUM_ ) ) ; p_criteriaGrid . add ( fieldValue , null ) ; p_criteriaGrid . add ( lBPartner_ID , null ) ; p_criteriaGrid . add ( fBPartner_ID , null ) ; p_criteriaGrid . add ( labelName , new ALayoutConstraint ( NUM_ , NUM_ ) ) ; p_criteriaGrid . add ( fieldName , null ) ; p_criteriaGrid . add ( lProduct_ID , null ) ; p_criteriaGrid . add ( fProduct_ID , null ) ; }
public static int hash ( byte [ ] data , int seed ) { return hash ( ByteBuffer . wrap ( data ) , seed ) ; }
public int parse ( char c , char [ ] ia , int ip , int il ) { assert ( ia [ ip ] == c ) ; if ( Surrogate . isHigh ( c ) ) { if ( il - ip < NUM_ ) { error = CoderResult . UNDERFLOW ; return - NUM_ ; } char d = ia [ ip + NUM_ ] ; if ( Surrogate . isLow ( d ) ) { character = toUCS4 ( c , d ) ; isPair = BOOL_ ; error = null ; return character ; } error = CoderResult . malformedForLength ( NUM_ ) ; return - NUM_ ; } if ( Surrogate . isLow ( c ) ) { error = CoderResult . malformedForLength ( NUM_ ) ; return - NUM_ ; } character = c ; isPair = BOOL_ ; error = null ; return character ; }
public void performStartOperationAsync ( final String vmId , final FutureCallback < Task > responseCallback ) throws IOException { String path = String . format ( STR_ , getBasePath ( ) , vmId ) ; createObjectAsync ( path , null , responseCallback ) ; }
private RtpPacket parseRtpPacket ( byte [ ] data ) { RtpPacket packet = new RtpPacket ( ) ; packet . mLength = data . length ; packet . mReceivedAt = System . currentTimeMillis ( ) ; packet . extension = ( data [ NUM_ ] & x10 ) > NUM_ ; if ( ( byte ) ( ( data [ NUM_ ] & xff ) & x80 ) == ( byte ) x80 ) { packet . marker = NUM_ ; } else { packet . marker = NUM_ ; } packet . payloadType = ( byte ) ( ( data [ NUM_ ] & xff ) & x7f ) ; packet . seqnum = ( char ) ( ( data [ NUM_ ] << NUM_ ) | ( data [ NUM_ ] & xff ) ) ; packet . timestamp = ( ( ( data [ NUM_ ] & xff ) << NUM_ ) | ( ( data [ NUM_ ] & xff ) << NUM_ ) | ( ( data [ NUM_ ] & xff ) << NUM_ ) | ( data [ NUM_ ] & xff ) ) ; packet . ssrc = ( ( ( data [ NUM_ ] & xff ) << NUM_ ) | ( ( data [ NUM_ ] & xff ) << NUM_ ) | ( ( data [ NUM_ ] & xff ) << NUM_ ) | ( data [ NUM_ ] & xff ) ) ; if ( packet . extension ) { int dataId = NUM_ ; int extensionHeaderId = ( ( data [ ++ dataId ] & xff ) << NUM_ ) | ( data [ ++ dataId ] & xff ) ; int length = ( ( data [ ++ dataId ] & xff ) << NUM_ ) | ( data [ ++ dataId ] & xff ) ; if ( extensionHeaderId == RtpExtensionHeader . RTP_EXTENSION_HEADER_ID ) { extractExtensionHeader ( data , length , dataId , packet ) ; } packet . payloadoffset = NUM_ + length . NUM_ ; } else { packet . payloadoffset = NUM_ ; } packet . payloadlength = packet . mLength - packet . payloadoffset ; packet . mData = new byte [ packet . payloadlength ] ; System . arraycopy ( data , packet . payloadoffset , packet . mData , NUM_ , packet . payloadlength ) ; return packet ; }
public String product ( Properties ctx , int WindowNo , GridTab mTab , GridField mField , Object value ) { Integer M_Product_ID = ( Integer ) value ; if ( M_Product_ID == null || M_Product_ID . intValue ( ) == NUM_ ) return STR_ ; BigDecimal priceActual = null ; Timestamp DateExpense = Env . getContextAsDate ( ctx , WindowNo , STR_ ) ; if ( DateExpense == null ) DateExpense = new Timestamp ( System . currentTimeMillis ( ) ) ; String sql = null ; PreparedStatement pstmt = null ; ResultSet rs = null ; try { boolean noPrice = BOOL_ ; sql = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; pstmt = DB . prepareStatement ( sql , null ) ; pstmt . setInt ( NUM_ , M_Product_ID . intValue ( ) ) ; pstmt . setInt ( NUM_ , Env . getContextAsInt ( ctx , WindowNo , STR_ ) ) ; rs = pstmt . executeQuery ( ) ; while ( rs . next ( ) && noPrice ) { java . sql . Date plDate = rs . getDate ( STR_ ) ; if ( plDate == null || ! DateExpense . before ( plDate ) ) { noPrice = BOOL_ ; priceActual = rs . getBigDecimal ( STR_ ) ; if ( priceActual == null ) priceActual = rs . getBigDecimal ( STR_ ) ; if ( priceActual == null ) priceActual = rs . getBigDecimal ( STR_ ) ; Integer ii = new Integer ( rs . getInt ( STR_ ) ) ; if ( ! rs . wasNull ( ) ) mTab . setValue ( STR_ , ii ) ; } } if ( noPrice ) { sql = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; DB . close ( rs , pstmt ) ; pstmt = DB . prepareStatement ( sql , null ) ; pstmt . setInt ( NUM_ , M_Product_ID . intValue ( ) ) ; pstmt . setInt ( NUM_ , Env . getContextAsInt ( ctx , WindowNo , STR_ ) ) ; rs = pstmt . executeQuery ( ) ; while ( rs . next ( ) && noPrice ) { java . sql . Date plDate = rs . getDate ( STR_ ) ; if ( plDate == null || ! DateExpense . before ( plDate ) ) { noPrice = BOOL_ ; priceActual = rs . getBigDecimal ( STR_ ) ; if ( priceActual == null ) priceActual = rs . getBigDecimal ( STR_ ) ; if ( priceActual == null ) priceActual = rs . getBigDecimal ( STR_ ) ; Integer ii = new Integer ( rs . getInt ( STR_ ) ) ; if ( ! rs . wasNull ( ) ) mTab . setValue ( STR_ , ii ) ; } } } } catch ( SQLException e ) { log . log ( Level . SEVERE , sql , e ) ; return e . getLocalizedMessage ( ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } if ( priceActual == null ) priceActual = Env . ZERO ; mTab . setValue ( STR_ , priceActual ) ; return STR_ ; }
public boolean thisDeviceSpeaksTo ( BluetoothDevice other ) throws NoSuchAlgorithmException , UnsupportedEncodingException { if ( MurmurService . USE_BACKOFF ) return BOOL_ ; if ( other == null ) { log . info ( STR_ ) ; return BOOL_ ; } String otherAddr = other . getAddress ( ) ; if ( otherAddr == null ) { log . info ( STR_ + other + STR_ ) ; return BOOL_ ; } String myAddr = mBluetoothSpeaker . getAddress ( ) ; if ( myAddr . equals ( whichInitiates ( myAddr , otherAddr ) ) ) { return BOOL_ ; } else { return BOOL_ ; } }
public static < K , V > List < KeyValue < K , V > > waitUntilMinKeyValueRecordsReceived ( Properties consumerConfig , String topic , int expectedNumRecords , long waitTime ) throws InterruptedException { List < KeyValue < K , V > > accumData = new ArrayList < > ( ) ; long startTime = System . currentTimeMillis ( ) ; while ( BOOL_ ) { List < KeyValue < K , V > > readData = readKeyValues ( topic , consumerConfig ) ; accumData . addAll ( readData ) ; if ( accumData . size ( ) >= expectedNumRecords ) return accumData ; if ( System . currentTimeMillis ( ) > startTime + waitTime ) throw new AssertionError ( STR_ + expectedNumRecords + STR_ + accumData . size ( ) + STR_ + waitTime + STR_ ) ; Thread . sleep ( Math . min ( waitTime , NUM_ ) ) ; } }
public static < T > CombinedDownloadTask < T > single ( DownloadTask < T > task ) { Objects . requireNonNull ( task ) ; return new SingleCombinedTask < T > ( task ) ; }
public void addHexListener ( final IHexPanelListener listener ) { Preconditions . checkNotNull ( listener , STR_ ) ; if ( ! m_listeners . contains ( listener ) ) { m_listeners . add ( listener ) ; } }
public static < T extends SerializableEntity > Deserializer roundtripSerializableEntityWithBinarySerializer ( final T originalEntity , final AccountLookup accountLookup ) { final BinarySerializer binarySerializer = new BinarySerializer ( ) ; originalEntity . serialize ( binarySerializer ) ; return new BinaryDeserializer ( binarySerializer . getBytes ( ) , new DeserializationContext ( accountLookup ) ) ; }
@ Deprecated public static String encode ( final String s , final String encoding , BitSet safeOctets , boolean plusForSpace ) throws UnsupportedEncodingException { StringBuilder out = new StringBuilder ( s . length ( ) . NUM_ ) ; boolean needsEncoding ; try { needsEncoding = encode ( s , encoding , safeOctets , plusForSpace , out ) ; } catch ( UnsupportedEncodingException e ) { throw e ; } catch ( IOException e ) { throw new AssertionError ( e ) ; } if ( needsEncoding ) { return out . toString ( ) ; } else { return s ; } }
public static void fireClipboardChanged ( ) { for ( Iterator i = listenerList . iterator ( ) ; i . hasNext ( ) ; ) { ClipboardListener listener = ( ClipboardListener ) i . next ( ) ; listener . clipboardChanged ( ) ; } }
public boolean isEmpty ( ) { return window . isEmpty ( ) ; }
public boolean contains ( T listener ) { if ( mListeners != null ) { return mListeners . contains ( listener ) ; } else { return BOOL_ ; } }
public SimpleDictionary ( String ... aWords ) { words = new HashSet < String > ( ) ; for ( String word : aWords ) { words . add ( word . toLowerCase ( ) ) ; } }
public long readLongLE ( ) throws IOException { inputStream . readFully ( workSpace , NUM_ , NUM_ ) ; return ( ( long ) ( workSpace [ NUM_ ] & xff ) << NUM_ ) | ( ( long ) ( workSpace [ NUM_ ] & xff ) << NUM_ ) | ( ( long ) ( workSpace [ NUM_ ] & xff ) << NUM_ ) | ( ( long ) ( workSpace [ NUM_ ] & xff ) << NUM_ ) | ( ( long ) ( workSpace [ NUM_ ] & xff ) << NUM_ ) | ( ( long ) ( workSpace [ NUM_ ] & xff ) << NUM_ ) | ( ( long ) ( workSpace [ NUM_ ] & xff ) << NUM_ ) | ( ( long ) ( workSpace [ NUM_ ] & xff ) ) ; }
public void testSetPublicKey2 ( ) throws Exception { Identity i2 = new IdentityStub ( STR_ , IdentityScope . getSystemScope ( ) ) ; new PublicKeyStub ( STR_ , STR_ , new byte [ ] { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ) ; try { i2 . setPublicKey ( null ) ; } catch ( KeyManagementException ok ) { } }
@ LayoutlibDelegate static long elapsedRealtime ( ) { return System . currentTimeMillis ( ) - sBootTime ; }
@ Override public void fillAssignedKeys ( Set < String > keys ) { keys . add ( _keyColumn . name ( ) ) ; }
@ Override public void removeInstanceListener ( InstanceListener dsl ) { m_instanceListeners . remove ( dsl ) ; }
public double eccentricity ( ) { return Math . sqrt ( NUM_ - ( semiMinorAxis ( ) . semiMinorAxis ( ) ) / ( semiMajorAxis ( ) . semiMajorAxis ( ) ) ) ; }
private void simpleApply ( IDocument document , String string , ConfigurableCompletionProposal proposal ) throws BadLocationException { proposal . setCursorPosition ( string . length ( ) ) ; document . replace ( proposal . getReplacementOffset ( ) , proposal . getReplacementLength ( ) , string ) ; }
public String pullDump2PC ( ) { String serial = device . getSerialNumber ( ) ; File dest = new File ( FileUtils . getTempDirectory ( ) , serial + STR_ ) ; String path = dest . getPath ( ) ; log . debug ( STR_ , path ) ; CommandLine commandpull = adbCommand ( STR_ , STR_ , path ) ; String out = executeCommandQuietly ( commandpull ) ; log . debug ( STR_ , out ) ; return path ; }
@ After public void executeTest ( ) throws Throwable { try { testEnv . executeTest ( ) ; } catch ( AssertionError assertionError ) { if ( testEnv . hasBeenStopped ( ) ) { throw new AssertionError ( STR_ + assertionError . getMessage ( ) ) ; } throw assertionError ; } }
public void init ( ) { pubPanel . setLayout ( new BorderLayout ( ) ) ; topic = new JComboBox ( ) ; topic . setEditable ( BOOL_ ) ; topic . setMaximumSize ( MQTTFrame . TEXT_FIELD_DIMENSION ) ; topic . setMaximumRowCount ( NUM_ ) ; qosList = new JComboBox ( qos ) ; qosList . setSelectedIndex ( NUM_ ) ; qosList . setMaximumSize ( MQTTFrame . DROP_DOWN_DIMENSION ) ; pubData = new JTextArea ( NUM_ , NUM_ ) ; pubData . setBorder ( new BevelBorder ( BevelBorder . LOWERED ) ) ; pubData . setMargin ( MQTTFrame . TEXT_MARGINS ) ; retained = new JCheckBox ( ) ; retained . setSelected ( BOOL_ ) ; pubLabel = new JLabel ( PANEL_TITLE + STR_ ) ; Font f = pubLabel . getFont ( ) ; pubLabel . setFont ( new Font ( f . getName ( ) , Font . BOLD , f . getSize ( ) + NUM_ ) ) ; JPanel topicBox = new JPanel ( ) ; topicBox . setLayout ( new BoxLayout ( topicBox , BoxLayout . X_AXIS ) ) ; topicBox . add ( new JLabel ( STR_ ) ) ; topicBox . add ( topic ) ; topicBox . add ( new JLabel ( STR_ ) ) ; topicBox . add ( qosList ) ; topicBox . add ( new JLabel ( STR_ ) ) ; topicBox . add ( retained ) ; JPanel titleAndTopic = new JPanel ( ) ; titleAndTopic . setLayout ( new GridLayout ( NUM_ , NUM_ ) ) ; titleAndTopic . add ( pubLabel ) ; titleAndTopic . add ( topicBox ) ; hexDisplay = BOOL_ ; hexButton = new JButton ( STR_ ) ; hexButton . addActionListener ( this ) ; fileButton = new JButton ( STR_ ) ; fileButton . setEnabled ( BOOL_ ) ; fileButton . addActionListener ( this ) ; pubButton = new JButton ( STR_ ) ; pubButton . setEnabled ( BOOL_ ) ; pubButton . addActionListener ( this ) ; JPanel buttons = new JPanel ( ) ; buttons . setLayout ( new GridLayout ( NUM_ , NUM_ ) ) ; buttons . add ( pubButton ) ; buttons . add ( fileButton ) ; buttons . add ( hexButton ) ; JPanel buttonLayout = new JPanel ( ) ; buttonLayout . add ( buttons ) ; pubPanel . add ( titleAndTopic , BorderLayout . NORTH ) ; pubPanel . add ( new JScrollPane ( pubData ) , BorderLayout . CENTER ) ; pubPanel . add ( buttonLayout , BorderLayout . EAST ) ; }
public void validateEmrClusterDefinitionKey ( EmrClusterDefinitionKey key ) throws IllegalArgumentException { Assert . notNull ( key , STR_ ) ; key . setNamespace ( alternateKeyHelper . validateStringParameter ( STR_ , key . getNamespace ( ) ) ) ; key . setEmrClusterDefinitionName ( alternateKeyHelper . validateStringParameter ( STR_ , STR_ , key . getEmrClusterDefinitionName ( ) ) ) ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
@ TargetApi ( VERSION_CODES . KITKAT ) private void handleSmsReceived ( Intent intent ) { if ( BuildConfig . DEBUG ) Log . v ( STR_ ) ; Bundle bundle = intent . getExtras ( ) ; if ( bundle != null ) { SmsMessage [ ] messages = null ; if ( SmsPopupUtils . hasKitKat ( ) ) { messages = Intents . getMessagesFromIntent ( intent ) ; } else { messages = SmsPopupUtils . getMessagesFromIntent ( intent ) ; } if ( messages != null ) { notifyMessageReceived ( new SmsMmsMessage ( context , messages , System . currentTimeMillis ( ) ) ) ; } } }
public static long installAge ( long currentTimestamp , long installTimestamp , boolean sendInstallEvent ) { if ( sendInstallEvent ) { return INSTALL_AGE_IMMEDIATELY_AFTER_INSTALLING ; } else { return Math . max ( NUM_ , ( currentTimestamp - installTimestamp ) / MS_PER_DAY ) ; } }
public boolean isDistributed ( ) { return ! isLocal ( ) ; }
public void testValueOfLongNegative1 ( ) { long longVal = - NUM_ ; BigInteger aNumber = BigInteger . valueOf ( longVal ) ; byte rBytes [ ] = { - NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ } ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , - NUM_ , aNumber . signum ( ) ) ; }
private boolean zzRefill ( ) throws java . io . IOException { if ( zzStartRead > NUM_ ) { System . arraycopy ( zzBuffer , zzStartRead , zzBuffer , NUM_ , zzEndRead - zzStartRead ) ; zzEndRead -= zzStartRead ; zzCurrentPos -= zzStartRead ; zzMarkedPos -= zzStartRead ; zzStartRead = NUM_ ; } if ( zzCurrentPos >= zzBuffer . length ) { char newBuffer [ ] = new char [ zzCurrentPos . NUM_ ] ; System . arraycopy ( zzBuffer , NUM_ , newBuffer , NUM_ , zzBuffer . length ) ; zzBuffer = newBuffer ; } int numRead = zzReader . read ( zzBuffer , zzEndRead , zzBuffer . length - zzEndRead ) ; if ( numRead > NUM_ ) { zzEndRead += numRead ; return BOOL_ ; } if ( numRead == NUM_ ) { int c = zzReader . read ( ) ; if ( c == - NUM_ ) { return BOOL_ ; } else { zzBuffer [ zzEndRead ++ ] = ( char ) c ; return BOOL_ ; } } return BOOL_ ; }
public synchronized boolean isConsumer ( ImageConsumer ic ) { return theConsumers . contains ( ic ) ; }
public static boolean verifySignature ( Signature initializedSignatureEngine , byte [ ] message , byte [ ] signature ) throws SignatureException { initializedSignatureEngine . update ( message ) ; return initializedSignatureEngine . verify ( signature ) ; }
public static void writeVarInt ( OutputStream out , int x ) throws IOException { while ( ( x & ~ x7f ) != NUM_ ) { out . write ( ( byte ) ( x80 | ( x & x7f ) ) ) ; x >>>= NUM_ ; } out . write ( ( byte ) x ) ; }
protected static final String addEscapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = NUM_ ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case NUM_ : continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; case STR_ : retval . append ( STR_ ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < x20 || ch > x7e ) { String s = STR_ + Integer . toString ( ch , NUM_ ) ; retval . append ( STR_ + s . substring ( s . length ( ) - NUM_ , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; }
public SegmentPath complete ( EndType etype ) { SegmentPath result ; if ( data == null || w < NUM_ ) { return null ; } if ( w == data . length ) { result = new SegmentPath ( data , etype ) ; reset ( NUM_ ) ; } else { double [ ] dataToAdopt = new double [ w ] ; System . arraycopy ( data , NUM_ , dataToAdopt , NUM_ , w ) ; result = new SegmentPath ( dataToAdopt , etype ) ; reset ( NUM_ ) ; } return result ; }
public boolean addGpsDateTimeStampTag ( long timestamp ) { ExifTag t = buildTag ( TAG_GPS_DATE_STAMP , mGPSDateStampFormat . format ( timestamp ) ) ; if ( t == null ) { return BOOL_ ; } setTag ( t ) ; mGPSTimeStampCalendar . setTimeInMillis ( timestamp ) ; t = buildTag ( TAG_GPS_TIME_STAMP , new Rational [ ] { new Rational ( mGPSTimeStampCalendar . get ( Calendar . HOUR_OF_DAY ) , NUM_ ) , new Rational ( mGPSTimeStampCalendar . get ( Calendar . MINUTE ) , NUM_ ) , new Rational ( mGPSTimeStampCalendar . get ( Calendar . SECOND ) , NUM_ ) } ) ; if ( t == null ) { return BOOL_ ; } setTag ( t ) ; return BOOL_ ; }
@ Nullable public Bitmap cropImage ( ) { Bitmap viewBitmap = getViewBitmap ( ) ; if ( viewBitmap == null || viewBitmap . isRecycled ( ) ) { return null ; } cancelAllAnimations ( ) ; setImageToWrapCropBounds ( BOOL_ ) ; RectF currentImageRect = RectUtils . trapToRect ( mCurrentImageCorners ) ; if ( currentImageRect . isEmpty ( ) ) { return null ; } float currentScale = getCurrentScale ( ) ; float currentAngle = getCurrentAngle ( ) ; if ( mMaxResultImageSizeX > NUM_ && mMaxResultImageSizeY > NUM_ ) { float cropWidth = mCropRect . width ( ) / currentScale ; float cropHeight = mCropRect . height ( ) / currentScale ; if ( cropWidth > mMaxResultImageSizeX || cropHeight > mMaxResultImageSizeY ) { float scaleX = mMaxResultImageSizeX / cropWidth ; float scaleY = mMaxResultImageSizeY / cropHeight ; float resizeScale = Math . min ( scaleX , scaleY ) ; Bitmap resizedBitmap = Bitmap . createScaledBitmap ( viewBitmap , ( int ) ( viewBitmap . getWidth ( ) . resizeScale ) , ( int ) ( viewBitmap . getHeight ( ) . resizeScale ) , BOOL_ ) ; if ( viewBitmap != resizedBitmap ) { viewBitmap . recycle ( ) ; } viewBitmap = resizedBitmap ; currentScale /= resizeScale ; } } if ( currentAngle != NUM_ ) { mTempMatrix . reset ( ) ; mTempMatrix . setRotate ( currentAngle , viewBitmap . getWidth ( ) / NUM_ , viewBitmap . getHeight ( ) / NUM_ ) ; Bitmap rotatedBitmap = Bitmap . createBitmap ( viewBitmap , NUM_ , NUM_ , viewBitmap . getWidth ( ) , viewBitmap . getHeight ( ) , mTempMatrix , BOOL_ ) ; if ( viewBitmap != rotatedBitmap ) { viewBitmap . recycle ( ) ; } viewBitmap = rotatedBitmap ; } int top = ( int ) ( ( mCropRect . top - currentImageRect . top ) / currentScale ) ; int left = ( int ) ( ( mCropRect . left - currentImageRect . left ) / currentScale ) ; int width = ( int ) ( mCropRect . width ( ) / currentScale ) ; int height = ( int ) ( mCropRect . height ( ) / currentScale ) ; return Bitmap . createBitmap ( viewBitmap , left , top , width , height ) ; }
@ Deprecated public static Bundle parseUrl ( String url ) { url = url . replace ( STR_ , STR_ ) ; try { URL u = new URL ( url ) ; Bundle b = decodeUrl ( u . getQuery ( ) ) ; b . putAll ( decodeUrl ( u . getRef ( ) ) ) ; return b ; } catch ( MalformedURLException e ) { return new Bundle ( ) ; } }
private static void createTmpFile ( CompletableFuture < NewFile > fileCreation , Path destDir , List < TSData > files ) { LOG . log ( Level . FINE , STR_ ) ; try { Collections . sort ( files , Comparator . comparing ( null ) ) ; final FileChannel fd = FileUtil . createTempFile ( destDir , STR_ , STR_ ) ; try { final DateTime begin ; try ( ToXdrTables output = new ToXdrTables ( fd , Compression . DEFAULT_OPTIMIZED ) ) { while ( ! files . isEmpty ( ) ) { TSData tsdata = files . remove ( NUM_ ) ; if ( fileCreation . isCancelled ( ) ) throw new IOException ( STR_ ) ; output . addAll ( tsdata ) ; } begin = new DateTime ( output . getHdrBegin ( ) , DateTimeZone . UTC ) ; if ( fileCreation . isCancelled ( ) ) throw new IOException ( STR_ ) ; } if ( fileCreation . isCancelled ( ) ) throw new IOException ( STR_ ) ; INSTALL_POOL . execute ( null ) ; } catch ( Error | RuntimeException | IOException ex ) { try { fd . close ( ) ; } catch ( Error | RuntimeException | IOException ex1 ) { ex . addSuppressed ( ex1 ) ; } throw ex ; } } catch ( Error | RuntimeException | IOException ex ) { LOG . log ( Level . WARNING , STR_ , ex ) ; synchronized ( OUTSTANDING ) { OUTSTANDING . remove ( fileCreation ) ; } fileCreation . completeExceptionally ( ex ) ; } }
public void contentTag ( String tag , String name , String value , String content ) { spacing ( ) ; m_out . print ( STR_ ) ; m_out . print ( tag ) ; m_out . print ( STR_ ) ; m_out . print ( name ) ; m_out . print ( STR_ ) ; m_out . print ( STR_ ) ; escapeString ( value ) ; m_out . print ( STR_ ) ; m_out . print ( STR_ ) ; escapeString ( content ) ; m_out . print ( STR_ ) ; m_out . print ( STR_ ) ; m_out . print ( tag ) ; m_out . print ( STR_ ) ; println ( ) ; }
public static void closeOutputStream ( OutputStream stream , String tag ) { if ( stream != null ) { try { stream . close ( ) ; } catch ( IOException e ) { Log . e ( tag , STR_ + e ) ; } } }
public void addChild ( Component child ) { components . add ( child ) ; child . setParent ( this ) ; }
public boolean open ( int maxRows ) { log . info ( STR_ + maxRows ) ; m_maxRows = maxRows ; if ( m_open ) { log . fine ( STR_ ) ; dataRefreshAll ( ) ; return BOOL_ ; } if ( m_virtual ) { verifyVirtual ( ) ; } createSelectSql ( ) ; if ( m_SQL == null || m_SQL . equals ( STR_ ) ) { log . log ( Level . SEVERE , STR_ ) ; return BOOL_ ; } m_loader = new Loader ( ) ; m_rowCount = m_loader . open ( maxRows ) ; if ( m_virtual ) { m_buffer = null ; m_virtualBuffer = new HashMap < Integer , Object [ ] > ( NUM_ ) ; } else { m_buffer = new ArrayList < Object [ ] > ( m_rowCount + NUM_ ) ; } m_sort = new ArrayList < MSort > ( m_rowCount + NUM_ ) ; if ( m_rowCount > NUM_ ) { if ( m_rowCount < NUM_ ) m_loader . run ( ) ; else { m_loaderThread = new Thread ( m_loader , STR_ ) ; m_loaderThread . start ( ) ; } } else m_loader . close ( ) ; m_open = BOOL_ ; m_changed = BOOL_ ; m_rowChanged = - NUM_ ; m_inserting = BOOL_ ; return BOOL_ ; }
public void addMessageListener ( IMessageListener listener ) { listeners . add ( listener ) ; }
protected void syncFlushVdcConfigToLocal ( ) throws Exception { if ( vdcPropBarrier == null ) { vdcPropBarrier = new VdcPropertyBarrier ( targetSiteInfo , VDC_OP_BARRIER_TIMEOUT ) ; } vdcPropBarrier . enter ( ) ; try { flushVdcConfigToLocal ( ) ; } finally { boolean allLeft = vdcPropBarrier . leave ( ) ; if ( ! allLeft ) { log . info ( STR_ ) ; Thread . sleep ( IPSEC_RESTART_DELAY ) ; } } vdcPropBarrier = null ; }
public CorruptIndexException ( String message , DataInput input , Throwable cause ) { this ( message , Objects . toString ( input ) , cause ) ; }
protected void removeFromQuarantineQueue ( NodePortTuple npt ) { while ( quarantineQueue . remove ( npt ) ) ; }
public boolean hasExpired ( ) { if ( maxAge == NUM_ ) return BOOL_ ; if ( maxAge == MAX_AGE_UNSPECIFIED ) return BOOL_ ; long deltaSecond = ( System . currentTimeMillis ( ) - whenCreated ) / NUM_ ; if ( deltaSecond > maxAge ) return BOOL_ ; else return BOOL_ ; }
public static String repeatCharacter ( char c , int repetitions ) { StringBuilder s = new StringBuilder ( repetitions ) ; for ( int i = NUM_ ; i < repetitions ; i ++ ) { s . append ( c ) ; } return s . toString ( ) ; }
public static String checkAndReplaceLiterals ( String instStr ) { String tmp = instStr ; if ( tmp . contains ( COMPONENTS_DELIM ) ) { tmp = tmp . replaceAll ( COMPONENTS_DELIM , STR_ ) ; LOG . warn ( STR_ + COMPONENTS_DELIM + STR_ ) ; } if ( tmp . contains ( ELEMENT_DELIM ) ) { tmp = tmp . replaceAll ( ELEMENT_DELIM , STR_ ) ; LOG . warn ( STR_ + ELEMENT_DELIM + STR_ ) ; } if ( tmp . contains ( LEVELIN ) ) { tmp = tmp . replaceAll ( LEVELIN , STR_ ) ; LOG . warn ( STR_ + LEVELIN + STR_ ) ; } if ( tmp . contains ( LEVELOUT ) ) { tmp = tmp . replaceAll ( LEVELOUT , STR_ ) ; LOG . warn ( STR_ + LEVELOUT + STR_ ) ; } if ( tmp . contains ( PARFOR_CDATA_END ) ) { tmp = tmp . replaceAll ( PARFOR_CDATA_END , STR_ ) ; LOG . warn ( STR_ + PARFOR_CDATA_END + STR_ ) ; } return tmp ; }
protected void notifyHistoryChangedListeners ( ) { Iterator < HistoryChangedListener > iter ; HistoryChangedListener l ; iter = m_HistoryChangedListeners . iterator ( ) ; while ( iter . hasNext ( ) ) { l = iter . next ( ) ; l . historyChanged ( new HistoryChangedEvent ( this , HISTORY_NAME , getHistory ( ) ) ) ; } }
public final static char [ ] [ ] splitTypeLevelsSignature ( String typeSignature ) { char [ ] source = Signature . removeCapture ( typeSignature . toCharArray ( ) ) ; CharOperation . replace ( source , STR_ , STR_ ) ; char [ ] [ ] signatures = new char [ NUM_ ] [ ] ; int signaturesCount = NUM_ ; int paramOpening = NUM_ ; for ( int idx = NUM_ , ln = source . length ; idx < ln ; idx ++ ) { switch ( source [ idx ] ) { case STR_ : paramOpening -- ; if ( paramOpening == NUM_ ) { if ( signaturesCount == signatures . length ) { System . arraycopy ( signatures , NUM_ , signatures = new char [ signaturesCount + NUM_ ] [ ] , NUM_ , signaturesCount ) ; } } break ; case STR_ : paramOpening ++ ; break ; case STR_ : if ( paramOpening == NUM_ ) { if ( signaturesCount == signatures . length ) { System . arraycopy ( signatures , NUM_ , signatures = new char [ signaturesCount + NUM_ ] [ ] , NUM_ , signaturesCount ) ; } signatures [ signaturesCount ] = new char [ idx + NUM_ ] ; System . arraycopy ( source , NUM_ , signatures [ signaturesCount ] , NUM_ , idx ) ; signatures [ signaturesCount ] [ idx ] = Signature . C_SEMICOLON ; signaturesCount ++ ; } break ; case STR_ : source [ idx ] = STR_ ; break ; } } char [ ] [ ] typeSignatures = new char [ signaturesCount + NUM_ ] [ ] ; typeSignatures [ NUM_ ] = source ; for ( int i = NUM_ , j = signaturesCount - NUM_ ; i <= signaturesCount ; i ++ , j -- ) { typeSignatures [ i ] = signatures [ j ] ; } return typeSignatures ; }
public static < T > T withWriter ( Writer writer , @ ClosureParams ( FirstParam . class ) Closure < T > closure ) throws IOException { try { T result = closure . call ( writer ) ; try { writer . flush ( ) ; } catch ( IOException e ) { } Writer temp = writer ; writer = null ; temp . close ( ) ; return result ; } finally { closeWithWarning ( writer ) ; } }
public static int round ( double value ) { int roundedValue = value > NUM_ ? ( int ) ( value + NUM_ ) : - ( int ) ( Math . abs ( value ) + NUM_ ) ; return roundedValue ; }
private ServiceRegistrar [ ] buildServiceRegistrar ( ) { int k = NUM_ ; ServiceRegistrar [ ] proxys = new ServiceRegistrar [ discoveredLocators . size ( ) ] ; Iterator iter = discoveredLocators . iterator ( ) ; while ( iter . hasNext ( ) ) { LocatorReg reg = ( LocatorReg ) iter . next ( ) ; proxys [ k ++ ] = reg . proxy ; } return proxys ; }
private static char [ ] zzUnpackCMap ( String packed ) { char [ ] map = new char [ x110000 ] ; int i = NUM_ ; int j = NUM_ ; while ( i < NUM_ ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM_ ) ; } return map ; }
public void rewindToWS ( ) { if ( nextOffset == NUM_ ) { return ; } nextOffset -- ; while ( nextOffset > NUM_ && ! Character . isWhitespace ( s . charAt ( nextOffset ) ) ) { nextOffset -- ; } this . offset = nextOffset - NUM_ ; }
private static Permission [ ] flatten ( Permission [ ] pa ) { List l = new ArrayList ( pa . length ) ; for ( int i = NUM_ ; i < pa . length ; i ++ ) { Permission p = pa [ i ] ; if ( p instanceof GrantPermission ) { l . addAll ( Arrays . asList ( ( ( GrantPermission ) p ) . grants ) ) ; } else { l . add ( p ) ; } } return ( Permission [ ] ) l . toArray ( new Permission [ l . size ( ) ] ) ; }
public Object [ ] toArray ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = NUM_ ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }
protected void startDocumentInternal ( ) throws SAXException { if ( m_needToCallStartDocument ) { super . startDocumentInternal ( ) ; m_saxHandler . startDocument ( ) ; m_needToCallStartDocument = BOOL_ ; } }
public static boolean isAnonymous ( String className ) { int i = className . lastIndexOf ( STR_ ) ; if ( i >= NUM_ && ++ i < className . length ( ) ) { while ( i < className . length ( ) ) { if ( ! Character . isDigit ( className . charAt ( i ) ) ) { return BOOL_ ; } i ++ ; } return BOOL_ ; } return BOOL_ ; }
String descriptor ( boolean includeThis ) { StringBuilder result = new StringBuilder ( ) ; result . append ( STR_ ) ; if ( includeThis ) { result . append ( declaringType . name ) ; } for ( TypeId t : parameters . types ) { result . append ( t . name ) ; } result . append ( STR_ ) ; result . append ( returnType . name ) ; return result . toString ( ) ; }
public void testSingleFile ( ) throws Exception { JFlexMojo mojo = newMojo ( STR_ ) ; mojo . execute ( ) ; File produced = getExpectedOutputFile ( mojo ) ; assertTrue ( STR_ + produced , produced . isFile ( ) ) ; long size = produced . length ( ) ; boolean correctSize = ( size > NUM_ ) && ( size < NUM_ ) ; assertTrue ( STR_ + size , correctSize ) ; }
public final static boolean isPotentialZipArchive ( String name ) { int lastDot = name . lastIndexOf ( STR_ ) ; if ( lastDot == - NUM_ ) { return BOOL_ ; } if ( name . lastIndexOf ( File . separatorChar ) > lastDot ) { return BOOL_ ; } int length = name . length ( ) ; int extensionLength = length - lastDot - NUM_ ; if ( extensionLength == EXTENSION_java . length ( ) ) { for ( int i = extensionLength - NUM_ ; i >= NUM_ ; i -- ) { if ( Character . toLowerCase ( name . charAt ( length - extensionLength + i ) ) != EXTENSION_java . charAt ( i ) ) { break ; } if ( i == NUM_ ) { return BOOL_ ; } } } if ( extensionLength == EXTENSION_class . length ( ) ) { for ( int i = extensionLength - NUM_ ; i >= NUM_ ; i -- ) { if ( Character . toLowerCase ( name . charAt ( length - extensionLength + i ) ) != EXTENSION_class . charAt ( i ) ) { return BOOL_ ; } } return BOOL_ ; } return BOOL_ ; }
void addTerm ( MapBuilderTermType type , JClass jclass , String alias ) { MapBuilderTerm newTerm = new MapBuilderTerm ( ) ; newTerm . type = type ; newTerm . jclass = jclass ; newTerm . alias = alias ; terms . add ( newTerm ) ; }
public Collection engineGenerateCertificates ( InputStream inStream ) throws CertificateException { java . security . cert . Certificate cert ; List certs = new ArrayList ( ) ; while ( ( cert = engineGenerateCertificate ( inStream ) ) != null ) { certs . add ( cert ) ; } return certs ; }
@ SuppressWarnings ( STR_ ) protected void writePath ( Shape s ) { PathIterator segments = s . getPathIterator ( null ) ; double [ ] coords = new double [ NUM_ ] ; for ( int i = NUM_ ; ! segments . isDone ( ) ; i ++ , segments . next ( ) ) { if ( i > NUM_ ) { write ( STR_ ) ; } int segmentType = segments . currentSegment ( coords ) ; switch ( segmentType ) { case PathIterator . SEG_MOVETO : write ( STR_ , coords [ NUM_ ] , STR_ , coords [ NUM_ ] ) ; break ; case PathIterator . SEG_LINETO : write ( STR_ , coords [ NUM_ ] , STR_ , coords [ NUM_ ] ) ; break ; case PathIterator . SEG_CUBICTO : write ( STR_ , coords [ NUM_ ] , STR_ , coords [ NUM_ ] , STR_ , coords [ NUM_ ] , STR_ , coords [ NUM_ ] , STR_ , coords [ NUM_ ] , STR_ , coords [ NUM_ ] ) ; break ; case PathIterator . SEG_QUADTO : write ( STR_ , coords [ NUM_ ] , STR_ , coords [ NUM_ ] , STR_ , coords [ NUM_ ] , STR_ , coords [ NUM_ ] ) ; break ; case PathIterator . SEG_CLOSE : write ( STR_ ) ; break ; default : throw new IllegalStateException ( STR_ ) ; } } }
public static void checkArgument ( boolean expression , Object errorMessage ) { if ( ! expression ) { throw new IllegalArgumentException ( String . valueOf ( errorMessage ) ) ; } }
private final boolean parkAndCheckInterrupt ( ) { LockSupport . park ( this ) ; return Thread . interrupted ( ) ; }
@ Override public int portRemote ( ) { if ( _channel != null ) { try { SocketAddress addr = _channel . getRemoteAddress ( ) ; return NUM_ ; } catch ( Exception e ) { e . printStackTrace ( ) ; return NUM_ ; } } else return NUM_ ; }
public void addDropTarget ( DropTarget target ) { mDropTargets . add ( target ) ; }
@ Override public void startElement ( final String namespaceURI , final String localName , final String qName , final Attributes atts ) throws SAXException { Object objectToLoad = null ; if ( openNodes . size ( ) == NUM_ ) objectToLoad = rootObject ; else objectToLoad = createChild ( qName , atts ) ; if ( objectToLoad != null ) { if ( atts . getIndex ( STR_ ) < NUM_ ) ObjectGetSetter . set ( objectToLoad , STR_ , qName ) ; ObjectGetSetter . setAll ( objectToLoad , atts ) ; } openNodes . push ( new StackedObject ( objectToLoad ) ) ; }
public final int put ( Object key , int value , boolean isReplace ) { int prime = _prime ; int hash = Math . abs ( System . identityHashCode ( key ) % prime ) ; Object [ ] keys = _keys ; while ( BOOL_ ) { Object testKey = keys [ hash ] ; if ( testKey == null ) { keys [ hash ] = key ; _values [ hash ] = value ; _size ++ ; if ( keys . length <= NUM_ . _size ) resize ( NUM_ . keys . length ) ; return value ; } else if ( key != testKey ) { hash = ( hash + NUM_ ) % prime ; continue ; } else if ( isReplace ) { int old = _values [ hash ] ; _values [ hash ] = value ; return old ; } else { return _values [ hash ] ; } } }
public int addAllAbsent ( Collection c ) { int numNew = c . size ( ) ; if ( numNew == NUM_ ) return NUM_ ; synchronized ( this ) { Object [ ] elements = getArray ( ) ; int len = elements . length ; Object [ ] temp = new Object [ numNew ] ; int added = NUM_ ; for ( Iterator itr = c . iterator ( ) ; itr . hasNext ( ) ; ) { Object e = itr . next ( ) ; if ( indexOf ( e , elements , NUM_ , len ) < NUM_ && indexOf ( e , temp , NUM_ , added ) < NUM_ ) temp [ added ++ ] = e ; } if ( added != NUM_ ) { Object [ ] newElements = new Object [ len + added ] ; System . arraycopy ( elements , NUM_ , newElements , NUM_ , len ) ; System . arraycopy ( temp , NUM_ , newElements , len , added ) ; setArray ( newElements ) ; } return added ; } }
private static final synchronized int nextPoolId ( ) { return ++ poolNumberSequence ; }
@ Override public void close ( ) throws IOException { if ( logger != null ) { logger . println ( STR_ + socket_was_closed ) ; } if ( ! socket_was_closed ) { if ( handshake_started ) { alertProtocol . alert ( AlertProtocol . WARNING , AlertProtocol . CLOSE_NOTIFY ) ; try { output . write ( alertProtocol . wrap ( ) ) ; } catch ( IOException ex ) { } alertProtocol . setProcessed ( ) ; } shutdown ( ) ; closeTransportLayer ( ) ; socket_was_closed = BOOL_ ; } }
protected static void registerLibrary ( ILibraryManager externalLibraryManager , String dataverse , String libraryName ) throws Exception { ClassLoader classLoader = getLibraryClassLoader ( dataverse , libraryName ) ; externalLibraryManager . registerLibraryClassLoader ( dataverse , libraryName , classLoader ) ; }
public void autoSize ( ) { if ( ! autoResize ) return ; }
public void testCase9 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; byte rBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = BigInteger . ONE ; BigInteger result = aNumber . multiply ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public static String rawMD5 ( String s ) { return binl2rstr ( binl2md5 ( rstr2binl ( s ) , s . length ( ) . NUM_ ) ) ; }
public boolean isQuestCompleted ( final String name ) { final String info = getQuest ( name , NUM_ ) ; if ( info == null ) { return BOOL_ ; } return info . equals ( STR_ ) ; }
private static char [ ] zzUnpackCMap ( String packed ) { char [ ] map = new char [ x10000 ] ; int i = NUM_ ; int j = NUM_ ; while ( i < NUM_ ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM_ ) ; } return map ; }
public void testZeroZero ( ) { String numA = STR_ ; String numB = STR_ ; String res = STR_ ; BigInteger aNumber = new BigInteger ( numA ) ; BigInteger bNumber = new BigInteger ( numB ) ; BigInteger result = aNumber . xor ( bNumber ) ; assertTrue ( res . equals ( result . toString ( ) ) ) ; }
@ LayoutlibDelegate static float ceil ( float value ) { return ( float ) Math . ceil ( value ) ; }
private final User removeUser ( String channel , String nick ) { channel = channel . toLowerCase ( ) ; User user = new User ( STR_ , nick ) ; synchronized ( _channels ) { Hashtable < User , User > users = _channels . get ( channel ) ; if ( users != null ) { return users . remove ( user ) ; } } return null ; }
public static void translatePos ( Collection < GraphNode > moveNodes , Map < GraphNode , Point2D > positions , Translater intoRegion ) { for ( GraphNode node : moveNodes ) { Point2D location = translateNode ( node , positions , intoRegion ) ; if ( null == location ) { continue ; } positions . put ( node , location ) ; } }
public void ifPresentOrElse ( LongConsumer action , Runnable emptyAction ) { if ( isPresent ) { action . accept ( value ) ; } else { emptyAction . run ( ) ; } }
public void testToBigIntegerPos2 ( ) { String a = STR_ ; BigInteger bNumber = new BigInteger ( STR_ ) ; BigDecimal aNumber = new BigDecimal ( a ) ; BigInteger result = aNumber . toBigInteger ( ) ; assertTrue ( STR_ , result . equals ( bNumber ) ) ; }
private String cleanupPath ( String fileName ) { if ( fileName == null ) { return null ; } fileName = fileName . replace ( STR_ , STR_ ) ; fileName = fileName . replace ( STR_ , STR_ ) ; if ( fileName . startsWith ( STR_ ) ) { return fileName ; } if ( fileName . startsWith ( STR_ ) ) { return STR_ + fileName ; } return STR_ + fileName ; }
public static Class < ? > invocationHandlerReturnType ( Class < ? > type ) { if ( type == byte . class ) return Byte . class ; if ( type == char . class ) return Character . class ; if ( type == double . class ) return Double . class ; if ( type == float . class ) return Float . class ; if ( type == int . class ) return Integer . class ; if ( type == long . class ) return Long . class ; if ( type == short . class ) return Short . class ; if ( type == boolean . class ) return Boolean . class ; return type ; }
private Node < K , V > findNode ( Comparable < ? super K > key ) { for ( ; ; ) { Node < K , V > b = findPredecessor ( key ) ; Node < K , V > n = b . next ; for ( ; ; ) { if ( n == null ) return null ; Node < K , V > f = n . next ; if ( n != b . next ) break ; Object v = n . value ; if ( v == null ) { n . helpDelete ( b , f ) ; break ; } if ( v == n || b . value == null ) break ; int c = key . compareTo ( n . key ) ; if ( c == NUM_ ) return n ; if ( c < NUM_ ) return null ; b = n ; n = f ; } } }
private static Script scriptFromString ( String scriptString , ScriptType scriptType ) { return new Script ( scriptString , scriptType ) ; }
private void finishNestedMode ( ) throws SAXException { md = ( ModeData ) modeDataStack . pop ( ) ; }
public void addPropertyChangeListener ( final PropertyChangeListener listener ) { propertyChangeSupport . addPropertyChangeListener ( listener ) ; }
protected int skipWhitespace ( int c ) throws IOException { while ( c == STR_ || c == STR_ ) { c = reader . read ( ) ; } return c ; }
public Builder noCache ( ) { this . noCache = BOOL_ ; return this ; }
@ SuppressWarnings ( STR_ ) public void computeClosestPoints ( ) { float centerX = contentRect . centerX ( ) ; float closestDistance = Float . MAX_VALUE ; for ( int i = NUM_ ; i < pointsCountWithinXRange . NUM_ ; i += NUM_ ) { float x = getDrawX ( xRangePoints [ i ] ) ; float distance = Math . abs ( x - centerX ) ; if ( distance <= closestDistance ) { if ( distance == closestDistance ) { closestPointsCount ++ ; } else { closestPointsCount = NUM_ ; } closestDistance = distance ; if ( closestPointsBuffer . length < ( closestPointsCount . NUM_ + NUM_ ) ) { closestPointsBuffer = new float [ closestPointsBuffer . length . NUM_ ] ; } closestPointsBuffer [ closestPointsCount . NUM_ + NUM_ ] = xRangePoints [ i ] ; closestPointsBuffer [ closestPointsCount . NUM_ + NUM_ ] = xRangePoints [ i + NUM_ ] ; } } if ( pointsCountWithinXRange > NUM_ ) { closestPointsCount ++ ; } }
protected TransformedString stem ( String words ) { StringBuilder builder = new StringBuilder ( ) ; Map < Integer , Integer > indexMap = new HashMap < > ( ) ; Integer index = NUM_ ; String content = words . toLowerCase ( ) ; while ( ! content . isEmpty ( ) ) { indexMap . put ( builder . length ( ) , index ) ; if ( Character . isAlphabetic ( content . charAt ( NUM_ ) ) ) { Matcher m = WORD_PATTERN . matcher ( content ) ; m . find ( ) ; String match = m . group ( ) ; CharSequence stemmedMatch = stemmer . stem ( match ) ; builder . append ( stemmedMatch ) ; index += match . length ( ) ; content = content . substring ( match . length ( ) ) ; } else { builder . append ( content . substring ( NUM_ , NUM_ ) ) ; content = content . substring ( NUM_ ) ; index ++ ; } } indexMap . put ( builder . length ( ) , index ) ; return new TransformedString ( words , builder . toString ( ) , indexMap ) ; }
@ Override public void onLayoutChildren ( RecyclerView . Recycler recycler , RecyclerView . State state ) { if ( state . getItemCount ( ) == NUM_ ) { detachAndScrapAttachedViews ( recycler ) ; return ; } if ( state . isPreLayout ( ) ) { if ( getChildCount ( ) == NUM_ ) return ; final int childCount = getChildCount ( ) ; for ( int i = NUM_ ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; RecyclerView . LayoutParams lp = ( RecyclerView . LayoutParams ) child . getLayoutParams ( ) ; if ( lp . isItemRemoved ( ) ) { removedTopAndBoundPositionCount ++ ; if ( firstChangedPosition == - NUM_ || firstAttachedItemPosition + i < firstChangedPosition ) { firstChangedPosition = firstAttachedItemPosition + i ; } } } if ( removedTopAndBoundPositionCount != NUM_ ) { layoutAttachedAndAppearingViews ( recycler , state ) ; } isBeforePreLayout = BOOL_ ; return ; } if ( getChildCount ( ) == NUM_ ) { initializeLayoutParameters ( ) ; fillGrid ( recycler , state , BOOL_ ) ; return ; } if ( isNotifyDataSetChanged ) { detachAndScrapAttachedViews ( recycler ) ; initializeLayoutParameters ( ) ; fillGrid ( recycler , state , BOOL_ ) ; isNotifyDataSetChanged = BOOL_ ; return ; } if ( firstChangedPosition == - NUM_ ) { mCurrentPosition = firstAttachedItemPosition ; lastAttachedItemPosition = firstAttachedItemPosition ; topBorder = getPaddingTop ( ) ; bottomBorder = getHeight ( ) - getPaddingBottom ( ) ; spanBottom = Arrays . copyOf ( spanTop , mSpanCount ) ; updateSpanBottomParameters ( ) ; detachAndScrapAttachedViews ( recycler ) ; fillGrid ( recycler , state , BOOL_ ) ; isBeforePreLayout = BOOL_ ; return ; } for ( int i = firstChangedPosition ; i < state . getItemCount ( ) ; i ++ ) { if ( itemLayoutWidthCache . get ( i , NUM_ ) != NUM_ ) { itemLayoutWidthCache . delete ( i ) ; itemLayoutHeightCache . delete ( i ) ; itemOccupiedStartSpan . delete ( i ) ; } if ( fakeItemLayoutWidthCache . get ( i , NUM_ ) != NUM_ ) { itemLayoutWidthCache . put ( i , fakeItemLayoutWidthCache . get ( i ) ) ; itemLayoutHeightCache . put ( i , fakeItemLayoutHeightCache . get ( i ) ) ; itemOccupiedStartSpan . put ( i , fakeItemOccupiedStartSpan . get ( i ) ) ; } } fakeItemLayoutWidthCache . clear ( ) ; fakeItemLayoutHeightCache . clear ( ) ; fakeItemOccupiedStartSpan . clear ( ) ; detachAndScrapAttachedViews ( recycler ) ; if ( firstChangedPosition < firstAttachedItemPosition ) { mCurrentPosition = firstAttachedItemPosition ; lastAttachedItemPosition = firstAttachedItemPosition ; topBorder = getPaddingTop ( ) ; bottomBorder = getHeight ( ) - getPaddingBottom ( ) ; spanBottom = Arrays . copyOf ( spanTop , mSpanCount ) ; updateSpanBottomParameters ( ) ; fillGrid ( recycler , state , BOOL_ ) ; if ( spanBottomMax < bottomBorder ) { scrollBy ( spanBottomMax - bottomBorder , recycler , state ) ; } layoutDisappearingViews ( recycler , state ) ; } else { mCurrentPosition = firstAttachedItemPosition ; lastAttachedItemPosition = firstAttachedItemPosition ; topBorder = getPaddingTop ( ) ; bottomBorder = getHeight ( ) - getPaddingBottom ( ) ; spanBottom = Arrays . copyOf ( spanTop , mSpanCount ) ; updateSpanBottomParameters ( ) ; fillGrid ( recycler , state , BOOL_ ) ; if ( spanBottomMax - bottomBorder < NUM_ ) { scrollBy ( spanBottomMax - bottomBorder , recycler , state ) ; } } isBeforePreLayout = BOOL_ ; firstChangedPosition = - NUM_ ; removedTopAndBoundPositionCount = NUM_ ; disappearingViewCache . clear ( ) ; }
void clear ( ) { valueNumbersUnconditionallyDereferenced . clear ( ) ; derefLocationSetMap . clear ( ) ; }
private static String urlEncode ( final String text ) throws UnsupportedEncodingException { return URLEncoder . encode ( text , STR_ ) ; }
public String [ ] list ( ) throws RemoteException { String [ ] names ; synchronized ( bindings ) { int i = bindings . size ( ) ; names = new String [ i ] ; Enumeration < String > enum_ = bindings . keys ( ) ; while ( ( -- i ) >= NUM_ ) names [ i ] = enum_ . nextElement ( ) ; } return names ; }
public static void assertQEx ( String message , SolrQueryRequest req , int code ) { try { ignoreException ( STR_ ) ; h . query ( req ) ; fail ( message ) ; } catch ( SolrException sex ) { assertEquals ( code , sex . code ( ) ) ; } catch ( Exception e2 ) { throw new RuntimeException ( STR_ , e2 ) ; } finally { unIgnoreException ( STR_ ) ; } }
public static void copyFile ( String fromFile , String toFile ) throws IOException { copyFile ( new File ( fromFile ) , new File ( toFile ) ) ; }
protected synchronized void readAndVerify ( ) throws InvalidKeyException , IOException , FileEncryptionException , IllegalBlockSizeException , BadPaddingException , FileIntegrityException { if ( backingRandomAccessFile . length ( ) < headerSize ( ) ) { throw new FileEncryptionException ( STR_ ) ; } if ( shareKey == null || shareKey . getEncoded ( ) . length == NUM_ ) { throw new FileEncryptionException ( STR_ ) ; } else { headerAuthHMac . reset ( ) ; KeyParameter keyParameter = new KeyParameter ( shareKey . getEncoded ( ) ) ; headerAuthHMac . init ( keyParameter ) ; } long oldpos = backingRandomAccessFile . getFilePointer ( ) ; backingRandomAccessFile . seek ( NUM_ ) ; byte [ ] header_data = new byte [ headerSize ( ) - FileHeader . AUTH_TAG_SIZE ] ; backingRandomAccessFile . read ( header_data ) ; backingRandomAccessFile . read ( headerAuthTag ) ; backingRandomAccessFile . seek ( oldpos ) ; headerAuthHMac . update ( header_data , NUM_ , header_data . length ) ; byte [ ] hmacRef = new byte [ AUTH_TAG_SIZE ] ; headerAuthHMac . doFinal ( hmacRef , NUM_ ) ; if ( ! Arrays . equals ( hmacRef , headerAuthTag ) ) { throw new FileIntegrityException ( STR_ ) ; } else { DataInputStream istream = new DataInputStream ( new ByteArrayInputStream ( header_data ) ) ; byte [ ] tmpmagic = new byte [ PANBOX_FILE_MAGIC . length ] ; istream . read ( tmpmagic ) ; if ( ! Arrays . equals ( tmpmagic , PANBOX_FILE_MAGIC ) ) { throw new FileEncryptionException ( STR_ ) ; } byte [ ] tmpversion = new byte [ PANBOX_FILE_VERSION . length ] ; istream . read ( tmpversion ) ; if ( ! Arrays . equals ( tmpversion , PANBOX_FILE_VERSION ) ) { throw new FileEncryptionException ( STR_ + PANBOX_FILE_VERSION . toString ( ) ) ; } this . shareKeyVersion = istream . readInt ( ) ; byte [ ] tmpencryptedFileKey = new byte [ KeyConstants . SYMMETRIC_FILE_KEY_SIZE_BYTES ] ; istream . read ( tmpencryptedFileKey ) ; filekeyCipher . init ( Cipher . DECRYPT_MODE , shareKey ) ; this . decryptedFileKey = new SecretKeySpec ( filekeyCipher . doFinal ( tmpencryptedFileKey ) , getAlgorithmIdentifier ( ) ) ; if ( implementsAuthentication ( ) ) { byte [ ] tmpFileAuthBuf = new byte [ AuthTagVerifier . AUTH_TAG_SIZE ] ; istream . read ( tmpFileAuthBuf ) ; byte [ ] zeroBuf = new byte [ AuthTagVerifier . AUTH_TAG_SIZE ] ; Arrays . fill ( zeroBuf , ( byte ) x00 ) ; if ( Arrays . equals ( zeroBuf , tmpFileAuthBuf ) ) { setFileAuthTag ( null ) ; } else { setFileAuthTag ( tmpFileAuthBuf ) ; } } istream . close ( ) ; } }
public void mouseReleased ( MouseEvent e ) { VisualizationViewer < ? , ? > vv = ( VisualizationViewer < ? , ? > ) e . getSource ( ) ; down = null ; vv . setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; }
public void clear ( ) { oredCriteria . clear ( ) ; orderByClause = null ; distinct = BOOL_ ; }
@ edu . umd . cs . findbugs . annotations . SuppressFBWarnings ( value = STR_ , justification = STR_ ) public void changeLocoSpeed ( DccThrottle t , Section sec , float speed ) { if ( sec == referenced && speed == desiredSpeedStep ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ ) ; } return ; } float sectionLength = sec . getActualLength ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + sec . getDisplayName ( ) ) ; } if ( sec == referenced ) { distanceRemaining = distanceRemaining - getDistanceTravelled ( _throttle . getIsForward ( ) , _throttle . getSpeedSetting ( ) , ( ( float ) ( System . nanoTime ( ) - lastTimeTimerStarted ) / NUM_ ) ) ; sectionLength = distanceRemaining ; } else { referenced = sec ; } changeLocoSpeed ( t , sectionLength , speed ) ; }
private void drawOffsets ( final Graphics g ) { final int linesToDraw = getNumberOfVisibleRows ( ) ; final String formatString = m_addressMode == AddressMode . BIT32 ? STR_ : STR_ ; final long elementSize = getElementSize ( ) ; final long baseAddress = m_model . getStartAddress ( ) == - NUM_ ? NUM_ : m_model . getStartAddress ( ) ; for ( int i = NUM_ ; i < linesToDraw ; i ++ ) { final int elementIndex = m_firstRow + i ; final long elementAddress = baseAddress + ( elementIndex . elementSize ) ; final String offsetString = String . format ( formatString , elementAddress ) ; if ( elementAddress == m_model . getStackPointer ( ) ) { highlightStackPointer ( g , i ) ; } if ( isEnabled ( ) ) { g . setColor ( m_fontColorOffsets ) ; } else { g . setColor ( m_disabledColor != m_bgColorOffset ? m_disabledColor : Color . WHITE ) ; } g . drawString ( offsetString , PADDING_LEFT - ( m_charWidth . m_firstColumn ) , m_paddingTop + ( i . m_rowHeight ) ) ; } }
public static final String crypt ( String salt , String original ) { while ( salt . length ( ) < NUM_ ) salt += STR_ ; StringBuilder buffer = new StringBuilder ( STR_ ) ; char charZero = salt . charAt ( NUM_ ) ; char charOne = salt . charAt ( NUM_ ) ; buffer . setCharAt ( NUM_ , charZero ) ; buffer . setCharAt ( NUM_ , charOne ) ; int Eswap0 = con_salt [ charZero ] ; int Eswap1 = con_salt [ charOne ] << NUM_ ; byte key [ ] = new byte [ NUM_ ] ; for ( int i = NUM_ ; i < key . length ; i ++ ) key [ i ] = ( byte ) NUM_ ; for ( int i = NUM_ ; i < key . length && i < original . length ( ) ; i ++ ) { int iChar = original . charAt ( i ) ; key [ i ] = ( byte ) ( iChar << NUM_ ) ; } int schedule [ ] = des_set_key ( key ) ; int out [ ] = body ( schedule , Eswap0 , Eswap1 ) ; byte b [ ] = new byte [ NUM_ ] ; intToFourBytes ( out [ NUM_ ] , b , NUM_ ) ; intToFourBytes ( out [ NUM_ ] , b , NUM_ ) ; b [ NUM_ ] = NUM_ ; for ( int i = NUM_ , y = NUM_ , u = x80 ; i < NUM_ ; i ++ ) { for ( int j = NUM_ , c = NUM_ ; j < NUM_ ; j ++ ) { c <<= NUM_ ; if ( ( b [ y ] & u ) != NUM_ ) c |= NUM_ ; u >>>= NUM_ ; if ( u == NUM_ ) { y ++ ; u = x80 ; } buffer . setCharAt ( i , ( char ) cov_2char [ c ] ) ; } } return ( buffer . toString ( ) ) ; }
public static boolean prefixedWith ( String a , String b ) { if ( a . equals ( b ) ) { return BOOL_ ; } return a . startsWith ( b ) ; }
public static String readStream ( InputStream inputStream ) throws IOException { if ( inputStream == null ) { return null ; } ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; byte [ ] buf = new byte [ NUM_ ] ; int r ; while ( ( r = inputStream . read ( buf ) ) != - NUM_ ) { bout . write ( buf , NUM_ , r ) ; } return bout . toString ( STR_ ) ; }
private Instances makeHeader ( ) { ArrayList < Attribute > fv = new ArrayList < Attribute > ( ) ; fv . add ( new Attribute ( STR_ ) ) ; fv . add ( new Attribute ( STR_ ) ) ; fv . add ( new Attribute ( STR_ ) ) ; return new Instances ( STR_ , fv , NUM_ ) ; }
private static ICloseableIterator < IBindingSet > iterator ( final IRunningQuery runningQuery ) { final ICloseableIterator < IBindingSet [ ] > it1 = runningQuery . iterator ( ) ; final ICloseableIterator < IBindingSet > it2 = new Dechunkerator < IBindingSet > ( it1 ) ; final ICloseableIterator < IBindingSet > it3 = new RunningQueryCloseableIterator < IBindingSet > ( runningQuery , it2 ) ; return it3 ; }
public void makeImmutable ( ) { if ( isMutable ) { isMutable = BOOL_ ; } }
@ Override public final boolean isOpen ( ) { return isOpen . get ( ) ; }
private static StreamTokenizer createTokenizer ( String s ) { StreamTokenizer st = new StreamTokenizer ( new StringReader ( s ) ) ; st . resetSyntax ( ) ; st . wordChars ( STR_ , STR_ ) ; st . wordChars ( STR_ , STR_ ) ; st . wordChars ( STR_ , STR_ ) ; st . wordChars ( STR_ , STR_ ) ; st . wordChars ( STR_ , STR_ ) ; st . wordChars ( STR_ , STR_ ) ; st . wordChars ( NUM_ + NUM_ , NUM_ ) ; st . whitespaceChars ( NUM_ , STR_ ) ; st . lowerCaseMode ( BOOL_ ) ; st . ordinaryChar ( STR_ ) ; st . slashSlashComments ( BOOL_ ) ; st . slashStarComments ( BOOL_ ) ; return st ; }
public static String removeChars ( String str , String oldchars ) { int pos = indexOfChars ( str , oldchars ) ; if ( pos == - NUM_ ) { return str ; } StringBuilder buf = new StringBuilder ( ) ; int start = NUM_ ; do { buf . append ( str . substring ( start , pos ) ) ; start = pos + NUM_ ; pos = indexOfChars ( str , oldchars , start ) ; } while ( pos != - NUM_ ) ; if ( start < str . length ( ) ) { buf . append ( str . substring ( start ) ) ; } return buf . toString ( ) ; }
private void sortUnitsToMove ( final List < Unit > units , final Route route ) { if ( units == null || units . isEmpty ( ) ) { return ; } else if ( route == null ) { final Exception nullRouteError = ( new IllegalArgumentException ( STR_ ) ) ; ClientLogger . logQuietly ( STR_ , nullRouteError ) ; } final Comparator < Unit > unitComparator ; if ( route . isUnload ( ) && Match . someMatch ( units , Matches . UnitIsLand ) ) { unitComparator = UnitComparator . getUnloadableUnitsComparator ( units , route , getUnitOwner ( units ) ) ; } else { unitComparator = UnitComparator . getMovableUnitsComparator ( units , route ) ; } Collections . sort ( units , unitComparator ) ; }
public boolean implementsInterface ( ReferenceBinding anInterface , boolean searchHierarchy ) { if ( this == anInterface ) return BOOL_ ; ReferenceBinding [ ] interfacesToVisit = null ; int nextPosition = NUM_ ; ReferenceBinding currentType = this ; do { ReferenceBinding [ ] itsInterfaces = currentType . superInterfaces ( ) ; if ( itsInterfaces != null && itsInterfaces != Binding . NO_SUPERINTERFACES ) { if ( interfacesToVisit == null ) { interfacesToVisit = itsInterfaces ; nextPosition = interfacesToVisit . length ; } else { int itsLength = itsInterfaces . length ; if ( nextPosition + itsLength >= interfacesToVisit . length ) System . arraycopy ( interfacesToVisit , NUM_ , interfacesToVisit = new ReferenceBinding [ nextPosition + itsLength + NUM_ ] , NUM_ , nextPosition ) ; nextInterface : for ( int a = NUM_ ; a < itsLength ; a ++ ) { ReferenceBinding next = itsInterfaces [ a ] ; for ( int b = NUM_ ; b < nextPosition ; b ++ ) if ( next == interfacesToVisit [ b ] ) continue nextInterface ; interfacesToVisit [ nextPosition ++ ] = next ; } } } } while ( searchHierarchy && ( currentType = currentType . superclass ( ) ) != null ) ; for ( int i = NUM_ ; i < nextPosition ; i ++ ) { currentType = interfacesToVisit [ i ] ; if ( currentType . isEquivalentTo ( anInterface ) ) return BOOL_ ; ReferenceBinding [ ] itsInterfaces = currentType . superInterfaces ( ) ; if ( itsInterfaces != null && itsInterfaces != Binding . NO_SUPERINTERFACES ) { int itsLength = itsInterfaces . length ; if ( nextPosition + itsLength >= interfacesToVisit . length ) System . arraycopy ( interfacesToVisit , NUM_ , interfacesToVisit = new ReferenceBinding [ nextPosition + itsLength + NUM_ ] , NUM_ , nextPosition ) ; nextInterface : for ( int a = NUM_ ; a < itsLength ; a ++ ) { ReferenceBinding next = itsInterfaces [ a ] ; for ( int b = NUM_ ; b < nextPosition ; b ++ ) if ( next == interfacesToVisit [ b ] ) continue nextInterface ; interfacesToVisit [ nextPosition ++ ] = next ; } } } return BOOL_ ; }
public Road ( int id , String name , Intersection from , Intersection to , RoadClass roadClass , RoadLayer roadLayer ) { this . id = id ; this . name = name ; this . roadLayer = roadLayer ; points = new Waypoint [ NUM_ ] ; setIntersections ( from , to ) ; this . roadClass = roadClass ; createLines ( ) ; modified = BOOL_ ; }
@ Override public void process ( WatchedEvent event ) { KeeperState eventState = event . getState ( ) ; EventType eventType = event . getType ( ) ; log . info ( STR_ , eventState , eventType ) ; if ( eventState == KeeperState . SyncConnected ) { connectedSignal . countDown ( ) ; log . info ( STR_ , connectionString ) ; } }
private void initProperties ( String filePropertiesName ) { readFromClassPath ( filePropertiesName ) ; Path curDirPath = getFileInCurrentDir ( filePropertiesName ) ; if ( Files . exists ( curDirPath ) ) { try ( InputStream curFolder = Files . newInputStream ( curDirPath ) ) { if ( curFolder != null ) { load ( curFolder ) ; } } catch ( Exception e ) { throw new RuntimeException ( STR_ + filePropertiesName , e ) ; } } }
private void resetBounds ( ) { bottomProteinId = null ; topProteinId = null ; }
private String property ( String classId , String key , String instanceId ) { return PREFIX_OVF_PROP + makePropertyKey ( classId , key , instanceId ) ; }
public String list ( String dir ) throws IOException { passive ( ) ; send ( STR_ + dir ) ; readCode ( NUM_ ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; IOUtils . copyAndClose ( inData , out ) ; readCode ( NUM_ ) ; byte [ ] data = out . toByteArray ( ) ; return new String ( data ) ; }
public static int convertPxToSp ( int pxSize ) { return Math . round ( ( float ) pxSize . getDisplayDensity4Fonts ( ) ) ; }
private void persistConsistencyGroups ( Collection < BlockConsistencyGroup > cgsToPersist ) { if ( null != cgsToPersist && ! cgsToPersist . isEmpty ( ) ) { List < BlockConsistencyGroup > cgsToCreate = new ArrayList < BlockConsistencyGroup > ( ) ; List < BlockConsistencyGroup > cgsToUpdate = new ArrayList < BlockConsistencyGroup > ( ) ; for ( BlockConsistencyGroup cg : cgsToPersist ) { if ( null == cg . getCreationTime ( ) ) { cgsToCreate . add ( cg ) ; } else { cgsToUpdate . add ( cg ) ; } } if ( ! cgsToCreate . isEmpty ( ) ) { _dbClient . createObject ( cgsToCreate ) ; } if ( ! cgsToUpdate . isEmpty ( ) ) { _dbClient . updateObject ( cgsToUpdate ) ; } } }
public void requestPasswordChangedTime ( ) { operations . add ( PasswordPolicyStateOperationType . GET_PASSWORD_CHANGED_TIME ) ; }
public static byte [ ] encodeRegionName ( String regionName ) { byte [ ] metadata ; try { JSONObject jsonObject = new JSONObject ( ) ; jsonObject . put ( JSON_FIELD_TAG , regionName ) ; String json = jsonObject . toString ( ) ; metadata = json . getBytes ( JSON_CHARSET ) ; } catch ( Exception e ) { Log . e ( TAG , STR_ + e . getMessage ( ) ) ; metadata = null ; } return metadata ; }
public boolean isValid ( ) { boolean valid = BOOL_ ; if ( endtime . getTime ( ) < System . currentTimeMillis ( ) ) { valid = BOOL_ ; } else if ( starttime != null ) { if ( starttime . getTime ( ) > System . currentTimeMillis ( ) ) { valid = BOOL_ ; } } else { if ( authtime . getTime ( ) > System . currentTimeMillis ( ) ) { valid = BOOL_ ; } } return valid ; }
public void testGetElementsByTagNameNS1 ( ) throws Throwable { Document doc ; Document newDoc ; DocumentType docType = null ; DOMImplementation domImpl ; NodeList childList ; String nullNS = null ; doc = ( Document ) load ( STR_ , builder ) ; domImpl = doc . getImplementation ( ) ; newDoc = domImpl . createDocument ( nullNS , STR_ , docType ) ; childList = newDoc . getElementsByTagNameNS ( STR_ , STR_ ) ; assertEquals ( STR_ , NUM_ , childList . getLength ( ) ) ; }
public static boolean addSeparatorIfNeeded ( JPopupMenu popupMenu ) { final int menuComponentCount = popupMenu . getComponentCount ( ) ; if ( menuComponentCount == NUM_ ) { return BOOL_ ; } final Component lastMenuComponent = popupMenu . getComponent ( menuComponentCount - NUM_ ) ; if ( isPopupMenuSeparator ( lastMenuComponent ) ) { return BOOL_ ; } popupMenu . addSeparator ( ) ; return BOOL_ ; }
public int groupSize ( String grpName ) { int res = NUM_ ; for ( HadoopCounter counter : cntrs . values ( ) ) { if ( grpName . equals ( counter . group ( ) ) ) res ++ ; } return res ; }
public ResourceBundleEnumeration ( Set < String > set , Enumeration < String > enumeration ) { this . set = set ; this . iterator = set . iterator ( ) ; this . enumeration = enumeration ; }
public static int toRGB ( ColorSpace colorSpace , float ... components ) { float [ ] rgb = colorSpace . toRGB ( components ) ; if ( rgb [ NUM_ ] < NUM_ || rgb [ NUM_ ] < NUM_ || rgb [ NUM_ ] < NUM_ || rgb [ NUM_ ] > NUM_ || rgb [ NUM_ ] > NUM_ || rgb [ NUM_ ] > NUM_ ) { return NUM_ ; } return xff000000 | ( ( int ) ( rgb [ NUM_ ] . NUM_ ) << NUM_ ) | ( ( int ) ( rgb [ NUM_ ] . NUM_ ) << NUM_ ) | ( int ) ( rgb [ NUM_ ] . NUM_ ) ; }
private static void skipNames ( ByteBuffer tableBuffer , int count ) { for ( int i = NUM_ ; i < count ; ++ i ) { ByteUtil . forward ( tableBuffer , tableBuffer . getShort ( ) ) ; } }
public Object2IntOpenHashMap < int [ ] > supportMap ( ) { List < ItemSet > itemSets = learn ( ) ; Object2IntOpenHashMap < int [ ] > confidenceMap = new Object2IntOpenHashMap < > ( itemSets . size ( ) ) ; for ( ItemSet itemSet : itemSets ) { confidenceMap . put ( itemSet . items , itemSet . support ) ; } return confidenceMap ; }
public static List < String > makeFeatureIdListFromPrefixed ( Map < String , Object > parameters ) { List < String > featureIdList = FastList . newInstance ( ) ; if ( parameters == null ) return featureIdList ; for ( Map . Entry < String , Object > entry : parameters . entrySet ( ) ) { String parameterName = entry . getKey ( ) ; if ( parameterName . startsWith ( STR_ ) ) { String productFeatureId = ( String ) entry . getValue ( ) ; if ( UtilValidate . isNotEmpty ( productFeatureId ) ) { featureIdList . add ( productFeatureId ) ; } } } return featureIdList ; }
private void updateOverscrollAnimation ( final int scrolledOffset ) { if ( mEdgeGlowLeft == null || mEdgeGlowRight == null ) return ; int nextScrollPosition = mCurrentX + scrolledOffset ; if ( mFlingTracker == null || mFlingTracker . isFinished ( ) ) { if ( nextScrollPosition < NUM_ ) { int overscroll = Math . abs ( scrolledOffset ) ; mEdgeGlowLeft . onPull ( ( float ) overscroll / getRenderWidth ( ) ) ; if ( ! mEdgeGlowRight . isFinished ( ) ) { mEdgeGlowRight . onRelease ( ) ; } } else if ( nextScrollPosition > mMaxX ) { int overscroll = Math . abs ( scrolledOffset ) ; mEdgeGlowRight . onPull ( ( float ) overscroll / getRenderWidth ( ) ) ; if ( ! mEdgeGlowLeft . isFinished ( ) ) { mEdgeGlowLeft . onRelease ( ) ; } } } }
public void addLongSelectionListener ( SelectionListener listener ) { if ( listener == null ) throw new IllegalArgumentException ( ) ; if ( ! longSelectionListeners . contains ( listener ) ) longSelectionListeners . add ( listener ) ; }
public void validate ( ) { final List < ValidationException > exceptionList = new ArrayList < ValidationException > ( ) ; validate ( exceptionList ) ; if ( ! exceptionList . isEmpty ( ) ) throw exceptionList . get ( NUM_ ) ; }
protected void installComponents ( ) { if ( ( rendererPane = createCellRendererPane ( ) ) != null ) { tree . add ( rendererPane ) ; } }
private void runPendingRequests ( ) { int maxStartId = - NUM_ ; BillingRequest request ; while ( ( request = mPendingRequests . peek ( ) ) != null ) { if ( request . runIfConnected ( ) ) { mPendingRequests . remove ( ) ; if ( maxStartId < request . getStartId ( ) ) { maxStartId = request . getStartId ( ) ; } } else { bindToMarketBillingService ( ) ; return ; } } if ( maxStartId >= NUM_ ) { if ( Consts . DEBUG ) { Log . i ( TAG , STR_ + maxStartId ) ; } stopSelf ( maxStartId ) ; } }
public CActionDifferenceTraces ( final JFrame parent , final ITraceListProvider traceProvider , final TraceList trace1 , final TraceList trace2 ) { super ( String . format ( STR_ , trace1 . getName ( ) , trace2 . getName ( ) ) ) ; m_parent = parent ; m_traceProvider = traceProvider ; m_trace1 = trace1 ; m_trace2 = trace2 ; }
public static void copyFile ( File fromFile , File toFile ) throws IOException { FileInputStream fileInputStream = new FileInputStream ( fromFile ) ; FileOutputStream fileOutputStream = new FileOutputStream ( toFile ) ; int i ; byte bytes [ ] = new byte [ NUM_ ] ; while ( ( i = fileInputStream . read ( bytes ) ) != - NUM_ ) { fileOutputStream . write ( bytes , NUM_ , i ) ; } fileInputStream . close ( ) ; fileOutputStream . close ( ) ; }
public final void updateTimeControlTitle ( ) { int [ ] tmpInfo = ctrl . getTimeLimit ( ) ; StringBuilder sb = new StringBuilder ( ) ; int tc = tmpInfo [ NUM_ ] ; int mps = tmpInfo [ NUM_ ] ; int inc = tmpInfo [ NUM_ ] ; if ( mps > NUM_ ) { sb . append ( mps ) ; sb . append ( STR_ ) ; } sb . append ( timeToString ( tc ) ) ; if ( ( inc > NUM_ ) || ( mps <= NUM_ ) ) { sb . append ( STR_ ) ; sb . append ( tmpInfo [ NUM_ ] / NUM_ ) ; } summaryTitleText . setText ( sb . toString ( ) ) ; }
public static boolean isInstalled ( PackageManager packageManager , String packageName ) { List < PackageInfo > packs = packageManager . getInstalledPackages ( NUM_ ) ; for ( int i = NUM_ ; i < packs . size ( ) ; i ++ ) { if ( TextUtils . equals ( packs . get ( i ) . packageName , packageName ) ) return BOOL_ ; } return BOOL_ ; }
@ After public void after ( ) throws SQLException { Connection connection = null ; Statement statement = null ; try { connection = getNewConnection ( BOOL_ ) ; statement = connection . createStatement ( ) ; statement . executeQuery ( STR_ ) ; } finally { if ( statement != null ) { statement . close ( ) ; } if ( connection != null ) { connection . close ( ) ; } } }
private void attachHeader ( SIPHeader h ) { if ( h == null ) throw new IllegalArgumentException ( STR_ ) ; try { if ( h instanceof SIPHeaderList ) { SIPHeaderList < ? > hl = ( SIPHeaderList < ? > ) h ; if ( hl . isEmpty ( ) ) { return ; } } attachHeader ( h , BOOL_ , BOOL_ ) ; } catch ( SIPDuplicateHeaderException ex ) { } }
@ Action ( value = STR_ ) public String listWorkflow ( ) { if ( wfAction != null && wfAction . equals ( CollectionConstants . WF_ACTION_APPROVE ) ) fetchReceipts ( CollectionConstants . WF_ACTION_APPROVE ) ; else fetchReceipts ( CollectionConstants . WF_ACTION_SUBMIT ) ; return INDEX ; }
public static final List < Geo > polyNearPoly ( GeoArray s , GeoArray r , double near ) { int rlen = r . getSize ( ) ; int slen = s . getSize ( ) ; Geo pl0 = r . get ( rlen - NUM_ ) ; Geo pl1 = new Geo ( ) ; Geo sl0 = s . get ( slen - NUM_ ) ; Geo sl1 = new Geo ( ) ; List < Geo > list = null ; for ( int j = NUM_ ; j < rlen ; j ++ ) { pl1 = r . get ( j , pl1 ) ; for ( int i = NUM_ ; i < slen ; i ++ ) { sl1 = s . get ( i , sl1 ) ; Geo ret = segmentsIntersectOrNear ( sl0 , sl1 , pl0 , pl1 , near ) ; if ( ret != null ) { if ( list == null ) { list = new LinkedList < Geo > ( ) ; } list . add ( ret ) ; } sl0 = sl1 ; } pl0 = pl1 ; } return list ; }
public void initParam ( Object obj ) { paramObject = obj ; Enumeration < AbstractParamPanel > en = tablePanel . elements ( ) ; AbstractParamPanel panel = null ; while ( en . hasMoreElements ( ) ) { panel = en . nextElement ( ) ; panel . initParam ( obj ) ; } }
public void updateTopic ( String topic , DbContextRule rule ) { topic = StringUtils . toLowerEnglish ( topic ) ; RuleHead head = ruleMap . get ( topic ) ; if ( head == null ) { head = new RuleHead ( STR_ , topic , rule ) ; ruleMap . put ( topic , head ) ; statements . add ( head ) ; } else { head . setRule ( rule ) ; } }
public static double log10 ( double x ) { return Math . log ( x ) / LOG10 ; }
public static int isButtonOnScreen ( final String buttonKey ) { Component onScreen ; try { onScreen = BubbleWindow . findButton ( buttonKey , RapidMinerGUI . getMainFrame ( ) ) ; } catch ( NullPointerException e ) { return OBJECT_NOT_ON_SCREEN ; } if ( onScreen == null ) { return OBJECT_NOT_ON_SCREEN ; } int xposition = onScreen . getLocationOnScreen ( ) . x ; int yposition = onScreen . getLocationOnScreen ( ) . y ; int otherXposition = xposition + onScreen . getWidth ( ) ; int otherYposition = yposition + onScreen . getHeight ( ) ; Window frame = RapidMinerGUI . getMainFrame ( ) ; if ( otherXposition <= frame . getWidth ( ) && otherYposition <= frame . getHeight ( ) && xposition > NUM_ && yposition > NUM_ ) { return OBJECT_SHOWING_ON_SCREEN ; } else { return OBJECT_NOT_SHOWING ; } }
@ Override public void addFocusables ( ArrayList < View > views , int direction , int focusableMode ) { final int focusableCount = views . size ( ) ; final int descendantFocusability = getDescendantFocusability ( ) ; if ( descendantFocusability != FOCUS_BLOCK_DESCENDANTS ) { for ( int i = NUM_ ; i < getChildCount ( ) ; i ++ ) { final View child = getChildAt ( i ) ; if ( child . getVisibility ( ) == VISIBLE ) { ItemInfo ii = infoForChild ( child ) ; if ( ii != null && ii . position == mCurItem ) { child . addFocusables ( views , direction , focusableMode ) ; } } } } if ( descendantFocusability != FOCUS_AFTER_DESCENDANTS || ( focusableCount == views . size ( ) ) ) { if ( ! isFocusable ( ) ) { return ; } if ( ( focusableMode & FOCUSABLES_TOUCH_MODE ) == FOCUSABLES_TOUCH_MODE && isInTouchMode ( ) && ! isFocusableInTouchMode ( ) ) { return ; } if ( views != null ) { views . add ( this ) ; } } }
public static boolean reachable ( InetAddress addr , int reachTimeout ) { try { return addr . isReachable ( reachTimeout ) ; } catch ( IOException ignore ) { return BOOL_ ; } }
protected static String timestr ( long time_val , long total_time ) { boolean neg ; long ms = NUM_ ; long sec = NUM_ ; long percent10 ; String pad ; neg = time_val < NUM_ ; if ( neg ) time_val = - time_val ; ms = time_val % NUM_ ; sec = time_val / NUM_ ; if ( sec < NUM_ ) pad = STR_ ; else if ( sec < NUM_ ) pad = STR_ ; else if ( sec < NUM_ ) pad = STR_ ; else pad = STR_ ; percent10 = ( time_val . NUM_ ) / total_time ; return ( neg ? STR_ : STR_ ) + pad + sec + STR_ + ( ( ms % NUM_ ) / NUM_ ) + ( ( ms % NUM_ ) / NUM_ ) + ( ms % NUM_ ) + STR_ + STR_ + percent10 / NUM_ + STR_ + percent10 % NUM_ + STR_ ; }
public static Tree rotateByName ( Tree tree ) { return new SimpleTree ( rotateNodeByName ( tree , tree . getRoot ( ) ) ) ; }
@ Subscribe public void onEvent ( SearchInPosition event ) { List < LatLng > list = MapHelper . getSearchArea ( event . getSteps ( ) , new LatLng ( event . getPosition ( ) . latitude , event . getPosition ( ) . longitude ) ) ; snackMe ( getString ( R . string . toast_searching ) ) ; nianticManager . getGyms ( event . getPosition ( ) . latitude , event . getPosition ( ) . longitude , NUM_ ) ; nianticManager . getPokeStops ( event . getPosition ( ) . latitude , event . getPosition ( ) . longitude , NUM_ ) ; nianticManager . getLuredPokemon ( event . getPosition ( ) . latitude , event . getPosition ( ) . longitude , NUM_ ) ; for ( LatLng p : list ) { nianticManager . getCatchablePokemon ( p . latitude , p . longitude , NUM_ ) ; } }
public void save ( OnSaveLogListener listener ) { File dir = getLogDir ( ) ; if ( dir == null ) { listener . onError ( STR_ + STR_ ) ; return ; } FileWriter fileWriter = null ; try { File output = new File ( dir , getLogFileName ( ) ) ; fileWriter = new FileWriter ( output , BOOL_ ) ; List < LogEntry > entries = bufferedLogs ( ) ; for ( LogEntry entry : entries ) { fileWriter . write ( entry . prettyPrint ( ) + STR_ ) ; } listener . onSave ( output ) ; } catch ( IOException e ) { listener . onError ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } finally { if ( fileWriter != null ) { try { fileWriter . close ( ) ; } catch ( IOException e ) { listener . onError ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } } } }
protected StorageHADomain checkAdapterExistsInDB ( String nativeGuid ) throws IOException { StorageHADomain adapter = null ; List < StorageHADomain > adapterInDB = CustomQueryUtility . getActiveStorageHADomainByNativeGuid ( _dbClient , nativeGuid ) ; if ( adapterInDB != null && ! adapterInDB . isEmpty ( ) ) { adapter = adapterInDB . get ( NUM_ ) ; } return adapter ; }
public static Executor createTaskDistributor ( ) { return Executors . newCachedThreadPool ( createThreadFactory ( Thread . NORM_PRIORITY , STR_ ) ) ; }
protected Coordinate [ ] toCoordinateArray ( Stack stack ) { Coordinate [ ] coordinates = new Coordinate [ stack . size ( ) ] ; for ( int i = NUM_ ; i < stack . size ( ) ; i ++ ) { Coordinate coordinate = ( Coordinate ) stack . get ( i ) ; coordinates [ i ] = coordinate ; } return coordinates ; }
private static void onEntityOpened ( KeyEvent event ) throws BadLocationException { JEditorPane editor = ( JEditorPane ) event . getSource ( ) ; Document doc = editor . getDocument ( ) ; int pos = editor . getCaretPosition ( ) ; String tag = getCurrentTag ( doc . getText ( NUM_ , pos ) ) ; if ( tag . equals ( STR_ ) ) { return ; } String remainder = doc . getText ( pos , doc . getLength ( ) - pos ) ; for ( int i = NUM_ ; i < remainder . length ( ) ; i ++ ) { char c = remainder . charAt ( i ) ; if ( c == STR_ ) { break ; } else if ( ! Character . isWhitespace ( c ) ) { return ; } } StringBuffer buffer = new StringBuffer ( ) ; int newPosition = pos ; String indent = getIndent ( doc , pos ) ; if ( tag . equals ( STR_ ) ) { buffer . append ( STR_ ) ; newPosition += NUM_ ; } else if ( tag . equals ( STR_ ) ) { buffer . append ( STR_ ) ; newPosition += NUM_ ; } else if ( tag . equals ( STR_ ) ) { buffer . append ( STR_ ) ; newPosition += NUM_ ; } else if ( tag . equals ( STR_ ) ) { buffer . append ( STR_ ) ; buffer . append ( indent + STR_ ) ; buffer . append ( indent + STR_ ) ; newPosition += NUM_ ; } else if ( tag . equals ( STR_ ) ) { buffer . append ( STR_ ) ; buffer . append ( indent + STR_ ) ; newPosition += NUM_ ; } else if ( tag . equals ( STR_ ) ) { buffer . append ( STR_ ) ; buffer . append ( indent + STR_ ) ; buffer . append ( indent + STR_ ) ; newPosition += NUM_ + indent . length ( ) ; } else { return ; } doc . insertString ( pos , buffer . toString ( ) , null ) ; editor . setCaretPosition ( newPosition ) ; event . consume ( ) ; }
@ SuppressWarnings ( STR_ ) private String checkForWellKnownNamespacePrefix ( final String prefix ) { final String namespace ; if ( prefix . equals ( STR_ ) ) { prefixMap . put ( STR_ , namespace = BD . NAMESPACE ) ; } else if ( prefix . equals ( STR_ ) ) { prefixMap . put ( STR_ , namespace = BDS . NAMESPACE ) ; } else if ( prefix . equals ( STR_ ) ) { prefixMap . put ( STR_ , namespace = QueryHints . NAMESPACE ) ; } else if ( prefix . equals ( STR_ ) ) { prefixMap . put ( STR_ , namespace = RDF . NAMESPACE ) ; } else if ( prefix . equals ( STR_ ) ) { prefixMap . put ( STR_ , namespace = RDFS . NAMESPACE ) ; } else if ( prefix . equals ( STR_ ) ) { prefixMap . put ( STR_ , namespace = XSD . NAMESPACE ) ; } else if ( prefix . equals ( STR_ ) ) { prefixMap . put ( STR_ , namespace = FOAFVocabularyDecl . NAMESPACE ) ; } else if ( prefix . equals ( STR_ ) ) { prefixMap . put ( STR_ , namespace = FN . NAMESPACE ) ; } else if ( prefix . equals ( STR_ ) ) { prefixMap . put ( STR_ , namespace = OWL . NAMESPACE ) ; } else if ( prefix . equals ( STR_ ) ) { prefixMap . put ( STR_ , namespace = SESAME . NAMESPACE ) ; } else if ( prefix . equals ( STR_ ) ) { prefixMap . put ( STR_ , namespace = GASService . Options . NAMESPACE ) ; } else { namespace = null ; } return namespace ; }
private void prepareUserForRanking ( User user ) { User updatedUser = userRepository . findOne ( user . getId ( ) , NUM_ ) ; if ( updatedUser . getImported ( ) == null || ! updatedUser . getImported ( ) ) { updatedUser . setImported ( BOOL_ ) ; updatedUser . setPagerank ( null ) ; updatedUser . setLastPageRank ( null ) ; updatedUser . setCurrentRank ( null ) ; updatedUser . setPreviousRank ( null ) ; userRepository . save ( updatedUser , NUM_ ) ; } }
private static List < Comment > orderComments ( List < Comment > comments ) { Map < String , List < Comment > > parentMap = new HashMap < > ( ) ; List < Comment > rootComments = new ArrayList < > ( ) ; for ( Comment c : comments ) { String parentUuid = c . parentUuid ; List < Comment > l = parentMap . get ( parentUuid ) ; if ( l == null ) { l = new ArrayList < > ( ) ; parentMap . put ( parentUuid , l ) ; } l . add ( c ) ; if ( parentUuid == null ) { rootComments . add ( c ) ; } } List < Comment > result = new ArrayList < > ( ) ; addChildren ( parentMap , rootComments , result ) ; return result ; }
protected static final void logRawDiagnostic ( String msg ) { if ( diagnosticsStream != null ) { diagnosticsStream . println ( msg ) ; diagnosticsStream . flush ( ) ; } }
public void initialize ( Subject subject , CallbackHandler callbackHandler , Map < String , ? > sharedState , Map < String , ? > options ) { unauthenticatedIdentity = ( String ) options . get ( STR_ ) ; handler = callbackHandler ; this . subject = subject ; }
public Macro ( File file ) throws EOFException , FileNotFoundException , IOException { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder db = null ; Document doc = null ; try { db = dbf . newDocumentBuilder ( ) ; InputSource is = new InputSource ( new UnicodeReader ( new FileInputStream ( file ) , FILE_ENCODING ) ) ; is . setEncoding ( FILE_ENCODING ) ; doc = db . parse ( is ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; String desc = e . getMessage ( ) ; if ( desc == null ) { desc = e . toString ( ) ; } throw new IOException ( STR_ + desc ) ; } macroRecords = new ArrayList ( ) ; boolean parsedOK = initializeFromXMLFile ( doc . getDocumentElement ( ) ) ; if ( parsedOK == BOOL_ ) { name = null ; macroRecords . clear ( ) ; macroRecords = null ; throw new IOException ( STR_ ) ; } }
public boolean contains ( symbol sym ) { return _all . containsKey ( sym . name ( ) ) ; }
private PieData generateDataPie ( int cnt ) { ArrayList < Entry > entries = new ArrayList < Entry > ( ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { entries . add ( new Entry ( ( int ) ( Math . random ( ) . NUM_ ) + NUM_ , i ) ) ; } PieDataSet d = new PieDataSet ( entries , STR_ ) ; d . setSliceSpace ( NUM_ ) ; d . setColors ( ColorTemplate . VORDIPLOM_COLORS ) ; PieData cd = new PieData ( getQuarters ( ) , d ) ; return cd ; }
public void sendUserDeleteNotification ( Map attributes ) { try { if ( deleteNotifyList != null && ! deleteNotifyList . isEmpty ( ) ) { sendEmail ( deleteNotifyList , attributes , STR_ , STR_ , STR_ ) ; } } catch ( MessagingException e ) { if ( debug . warningEnabled ( ) ) { debug . warning ( STR_ + STR_ + STR_ + entryDN , e ) ; } } }
public void addMapsIdMapping ( DatabaseMapping mapping ) { mapsIdMappings . add ( mapping ) ; }
@ Override public final char readChar ( ) throws IOException { dis . readFully ( work , NUM_ , NUM_ ) ; return ( char ) ( ( work [ NUM_ ] & xff ) << NUM_ | ( work [ NUM_ ] & xff ) ) ; }
public int taskSize ( ) { return tasks . size ( ) ; }
public void addMutedIp ( final String ip , final Date muteTill ) { if ( isIpMuted ( ip ) ) { removeMutedIp ( ip ) ; } Timestamp muteTillTs = null ; if ( muteTill != null ) { muteTillTs = new Timestamp ( muteTill . getTime ( ) ) ; } s_logger . fine ( STR_ + ip ) ; final Connection con = Database . getConnection ( ) ; try { final PreparedStatement ps = con . prepareStatement ( STR_ ) ; ps . setString ( NUM_ , ip ) ; ps . setTimestamp ( NUM_ , muteTillTs ) ; ps . execute ( ) ; ps . close ( ) ; con . commit ( ) ; } catch ( final SQLException sqle ) { if ( sqle . getErrorCode ( ) == NUM_ ) { s_logger . info ( STR_ + ip + STR_ + sqle . getMessage ( ) ) ; return ; } s_logger . log ( Level . SEVERE , STR_ + ip , sqle ) ; throw new IllegalStateException ( sqle . getMessage ( ) ) ; } finally { DbUtil . closeConnection ( con ) ; } }
public boolean isRslUrlSigned ( String url ) { if ( url == null ) { return BOOL_ ; } return url . endsWith ( SIGNED_RSL_URL_DOT_EXTENSION ) ; }
public void removeUserLockoutEntry ( String userDN ) { pwResetFailHash . remove ( userDN ) ; userWarningCount = NUM_ ; }
public void createDatabaseEntitiesForBusinessObjectDataSearchTesting ( ) { businessObjectDataDaoTestHelper . createBusinessObjectDataEntity ( AbstractServiceTest . NAMESPACE , AbstractServiceTest . BDEF_NAME , AbstractServiceTest . FORMAT_USAGE_CODE , AbstractServiceTest . FORMAT_FILE_TYPE_CODE , AbstractServiceTest . FORMAT_VERSION , AbstractServiceTest . PARTITION_VALUE , AbstractServiceTest . NO_SUBPARTITION_VALUES , AbstractServiceTest . DATA_VERSION , AbstractServiceTest . LATEST_VERSION_FLAG_SET , BusinessObjectDataStatusEntity . VALID ) ; businessObjectDataDaoTestHelper . createBusinessObjectDataEntity ( AbstractServiceTest . NAMESPACE , AbstractServiceTest . BDEF_NAME , AbstractServiceTest . FORMAT_USAGE_CODE_2 , AbstractServiceTest . FORMAT_FILE_TYPE_CODE , AbstractServiceTest . FORMAT_VERSION , AbstractServiceTest . PARTITION_VALUE , AbstractServiceTest . NO_SUBPARTITION_VALUES , AbstractServiceTest . DATA_VERSION , AbstractServiceTest . LATEST_VERSION_FLAG_SET , BusinessObjectDataStatusEntity . INVALID ) ; businessObjectDataDaoTestHelper . createBusinessObjectDataEntity ( AbstractServiceTest . NAMESPACE_2 , AbstractServiceTest . BDEF_NAME_2 , AbstractServiceTest . FORMAT_USAGE_CODE_2 , AbstractServiceTest . FORMAT_FILE_TYPE_CODE , AbstractServiceTest . FORMAT_VERSION_2 , AbstractServiceTest . PARTITION_VALUE , AbstractServiceTest . NO_SUBPARTITION_VALUES , AbstractServiceTest . DATA_VERSION , AbstractServiceTest . LATEST_VERSION_FLAG_SET , BusinessObjectDataStatusEntity . INVALID ) ; businessObjectDataDaoTestHelper . createBusinessObjectDataEntity ( AbstractServiceTest . NAMESPACE_2 , AbstractServiceTest . BDEF_NAME_2 , AbstractServiceTest . FORMAT_USAGE_CODE_2 , AbstractServiceTest . FORMAT_FILE_TYPE_CODE_2 , AbstractServiceTest . FORMAT_VERSION_2 , AbstractServiceTest . PARTITION_VALUE , AbstractServiceTest . NO_SUBPARTITION_VALUES , AbstractServiceTest . DATA_VERSION , AbstractServiceTest . LATEST_VERSION_FLAG_SET , BusinessObjectDataStatusEntity . VALID ) ; }
@ SkipValidation @ Action ( value = STR_ ) public String reset ( ) { if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( STR_ + ownerName + STR_ + zoneId + STR_ + wardId + STR_ + propertyType + STR_ + noticeType + STR_ + noticeNumber + STR_ + noticeFromDate + STR_ + noticeToDate + STR_ + indexNumber + STR_ + houseNumber ) ; ownerName = STR_ ; zoneId = - NUM_ ; wardId = - NUM_ ; propertyType = STR_ ; noticeType = STR_ ; noticeNumber = STR_ ; noticeFromDate = null ; noticeToDate = null ; indexNumber = STR_ ; houseNumber = STR_ ; if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( STR_ ) ; return INDEX ; }
public void checkOptionsValid ( ) { if ( alias_ratio < NUM_ || alias_ratio > NUM_ ) { throw new RuntimeException ( STR_ ) ; } if ( null_ratio < NUM_ || null_ratio > NUM_ ) { throw new RuntimeException ( STR_ ) ; } if ( maxsize <= NUM_ ) { throw new RuntimeException ( STR_ + maxsize ) ; } if ( ! literals_file . isEmpty ( ) && literals_level == ClassLiteralsMode . NONE ) { throw new RuntimeException ( STR_ ) ; } }
@ Override public UUID sessionId ( ) { if ( sessionId == null ) sessionId = UUID . randomUUID ( ) ; return sessionId ; }
private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject ( ) ; final Calendar definingCalendar = Calendar . getInstance ( timeZone , locale ) ; init ( definingCalendar ) ; }
@ Override public MemChunkHolder < BigDataPMemAllocator > createChunk ( long size , boolean autoreclaim ) { MemChunkHolder < BigDataPMemAllocator > ret = null ; Long addr = m_nvmasvc . allocate ( m_nid , size , BOOL_ ) ; if ( ( null == addr || NUM_ == addr ) && m_activegc ) { forceGC ( ) ; addr = m_nvmasvc . allocate ( m_nid , size , BOOL_ ) ; } if ( null != addr && NUM_ != addr ) { ret = new MemChunkHolder < BigDataPMemAllocator > ( this , addr , size ) ; ret . setCollector ( m_chunkcollector ) ; if ( autoreclaim ) { m_chunkcollector . register ( ret ) ; } } return ret ; }
public int hashCode ( ) { int result = NUM_ ; if ( tableName != null ) { result = NUM_ . tableName . hashCode ( ) ; } if ( repositoryName != null ) { result = NUM_ . repositoryName . hashCode ( ) ; } return result ; }
public synchronized void add ( String name , long threadId ) { if ( mFinished ) { throw new IllegalStateException ( STR_ ) ; } mMarkers . add ( new Marker ( name , threadId , SystemClock . elapsedRealtime ( ) ) ) ; }
private void toString ( StringBuilder acc , int prec , boolean expand ) { if ( this . meta != null && ! expand ) { acc . append ( this . meta ) ; return ; } boolean paren = op . getPrec ( ) < prec ; if ( paren ) acc . append ( STR_ ) ; toString ( acc , expand ) ; if ( paren ) acc . append ( STR_ ) ; }
public static boolean isNotNullValue ( String s ) { return ( ( s != null ) && ! s . isEmpty ( ) && ! s . equals ( NullColumnValueGetter . getNullStr ( ) ) ) ; }
private E unlinkFirst ( ) { Node < E > f = first ; if ( f == null ) return null ; Node < E > n = f . next ; E item = f . item ; f . item = null ; f . next = f ; first = n ; if ( n == null ) last = null ; else n . prev = null ; -- count ; notFull . signal ( ) ; return item ; }
public static String removeAll ( String source , char toRemove ) { int toRemoveIndex = source . indexOf ( toRemove ) ; if ( toRemoveIndex != - NUM_ ) { StringBuilder result = new StringBuilder ( source . length ( ) ) ; int sourceIndex = NUM_ ; while ( toRemoveIndex != - NUM_ ) { result . append ( source . substring ( sourceIndex , toRemoveIndex ) ) ; sourceIndex = toRemoveIndex + NUM_ ; toRemoveIndex = source . indexOf ( toRemove , sourceIndex ) ; if ( toRemoveIndex == - NUM_ ) { result . append ( source . substring ( sourceIndex , source . length ( ) ) ) ; } } return result . toString ( ) ; } else { return source ; } }
public List < Entry < E > > asList ( ) { if ( nonNullList == null ) { if ( array == null || array . length ( ) == NUM_ ) { nonNullList = Collections . emptyList ( ) ; } else { List < Entry < E > > list = new ArrayList < > ( array . length ( ) ) ; for ( int i = NUM_ ; i < array . length ( ) ; i ++ ) { E e = array . get ( i ) ; if ( e != null ) { list . add ( new Entry < > ( i , e ) ) ; } } nonNullList = list ; } } return nonNullList ; }
public static Range findCumulativeRangeBounds ( CategoryDataset dataset ) { ParamChecks . nullNotPermitted ( dataset , STR_ ) ; boolean allItemsNull = BOOL_ ; double minimum = NUM_ ; double maximum = NUM_ ; for ( int row = NUM_ ; row < dataset . getRowCount ( ) ; row ++ ) { double runningTotal = NUM_ ; for ( int column = NUM_ ; column <= dataset . getColumnCount ( ) - NUM_ ; column ++ ) { Number n = dataset . getValue ( row , column ) ; if ( n != null ) { allItemsNull = BOOL_ ; double value = n . doubleValue ( ) ; if ( ! Double . isNaN ( value ) ) { runningTotal = runningTotal + value ; minimum = Math . min ( minimum , runningTotal ) ; maximum = Math . max ( maximum , runningTotal ) ; } } } } if ( ! allItemsNull ) { return new Range ( minimum , maximum ) ; } else { return null ; } }
private void addHotkeys ( JRootPane pane ) { for ( Hotkey hotkey : hotkeys ) { if ( doesHotkeyHaveAction ( hotkey ) && hotkey . type == Type . REGULAR ) { if ( pane == null ) { addHotkey ( hotkey , main . getRootPane ( ) ) ; for ( JDialog popout : popouts . keySet ( ) ) { addHotkey ( hotkey , popout . getRootPane ( ) ) ; } } else { addHotkey ( hotkey , pane ) ; } } } }
static < T > ReplayPromise < Void > allReplay ( final Duration timeout , final List < Promise < T > > promises ) { return allReplay ( timeout , System . currentTimeMillis ( ) , promises . toArray ( new Promise [ promises . size ( ) ] ) ) ; }
public void checkAndSetupBootStrapInfo ( DbClient dbClient ) { if ( onStandby ) { _log . info ( STR_ ) ; return ; } if ( _vdcList != null && _vdcList . size ( ) > NUM_ ) { _log . info ( STR_ , _vdcList . size ( ) ) ; return ; } int retryIntervalSecs = DBINIT_RETRY_INTERVAL ; boolean done = BOOL_ ; boolean wait ; while ( ! done ) { wait = BOOL_ ; InterProcessLock lock = null ; try { lock = _coordinator . getLock ( getBootstrapLockName ( ) ) ; _log . info ( STR_ ) ; lock . acquire ( ) ; if ( isGeoDbsvc ( ) ) { insertDefaultRootTenant ( dbClient ) ; } else { insertMyVdcInfo ( dbClient ) ; insertVdcVersion ( dbClient ) ; insertPasswordHistory ( dbClient ) ; } done = BOOL_ ; } catch ( Exception e ) { if ( e instanceof IllegalStateException ) { throw ( IllegalStateException ) e ; } else { _log . warn ( STR_ , retryIntervalSecs , e ) ; wait = BOOL_ ; } } finally { if ( lock != null ) { try { lock . release ( ) ; } catch ( Exception e ) { _log . error ( STR_ , e ) ; } } } if ( wait ) { try { Thread . sleep ( retryIntervalSecs . NUM_ ) ; } catch ( InterruptedException ex ) { _log . warn ( STR_ , ex ) ; } } } }
Object processEXPR ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { try { XPath expr = handler . createXPath ( value , owner ) ; return expr ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } }
private void checkAccess ( UnixPath file , boolean checkRead , boolean checkWrite ) { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) { if ( checkRead ) file . checkRead ( ) ; if ( checkWrite ) file . checkWrite ( ) ; sm . checkPermission ( new RuntimePermission ( STR_ ) ) ; } }
private static Spanned removeImageSpanObjects ( Spanned spanned ) { SpannableStringBuilder builder = ( SpannableStringBuilder ) spanned ; Object [ ] spannedObjects = builder . getSpans ( NUM_ , builder . length ( ) , Object . class ) ; for ( int i = NUM_ ; i < spannedObjects . length ; i ++ ) { if ( spannedObjects [ i ] instanceof ImageSpan ) { ImageSpan imageSpan = ( ImageSpan ) spannedObjects [ i ] ; builder . replace ( spanned . getSpanStart ( imageSpan ) , builder . getSpanEnd ( imageSpan ) , STR_ ) ; } } return spanned ; }
public Future < String > classify ( String snippet ) { final ExecutorService service = Executors . newSingleThreadExecutor ( ) ; return service . submit ( new ClassifyingTask ( snippet ) ) ; }
public abstract byte [ ] embedData ( byte [ ] msg , String msgFileName , byte [ ] cover , String coverFileName , String stegoFileName ) throws OpenStegoException ;
public void addSetter ( int i ) { for ( ScatterPlotSetter setter : setterList ) { if ( setter . getIndex ( ) == i ) { return ; } } setterList . add ( new ScatterPlotSetter ( i ) ) ; }
@ Override public synchronized void initialize ( ) { if ( ! mRootDirectory . exists ( ) ) { if ( ! mRootDirectory . mkdirs ( ) ) { Loger . debug ( String . format ( STR_ , mRootDirectory . getAbsolutePath ( ) ) ) ; } return ; } File [ ] files = mRootDirectory . listFiles ( ) ; if ( files == null ) { return ; } for ( File file : files ) { BufferedInputStream fis = null ; try { fis = new BufferedInputStream ( new FileInputStream ( file ) ) ; CacheHeader entry = CacheHeader . readHeader ( fis ) ; entry . size = file . length ( ) ; putEntry ( entry . key , entry ) ; } catch ( IOException e ) { file . delete ( ) ; } finally { FileUtils . closeIO ( fis ) ; } } }
public Client ( final ServerSocketChannel server ) throws IOException { try { client = server . accept ( ) ; client . configureBlocking ( BOOL_ ) ; if ( ! client . finishConnect ( ) ) throw new IOException ( STR_ ) ; clientSelector = Selector . open ( ) ; clientKey = client . register ( clientSelector , SelectionKey . OP_READ ) ; if ( log . isInfoEnabled ( ) ) log . info ( STR_ ) ; } catch ( IOException ex ) { close ( ) ; throw ex ; } }
public Transfer writeBytes ( byte [ ] data ) throws IOException { if ( data == null ) { writeInt ( - NUM_ ) ; } else { writeInt ( data . length ) ; out . write ( data ) ; } return this ; }
public static void stop ( String [ ] args ) { LOG . info ( STR_ ) ; System . exit ( NUM_ ) ; }
public boolean add ( Object o ) { if ( ! list . contains ( o ) ) { list . add ( o ) ; return BOOL_ ; } return BOOL_ ; }
private XYPlot initializeLowerPlot ( ) { nonHeapMemory = new YIntervalSeriesImproved ( STR_ ) ; YIntervalSeriesCollection yIntervalSeriesCollection = new YIntervalSeriesCollection ( ) ; yIntervalSeriesCollection . addSeries ( nonHeapMemory ) ; DeviationRenderer renderer = new DeviationRenderer ( BOOL_ , BOOL_ ) ; renderer . setBaseShapesVisible ( BOOL_ ) ; renderer . setSeriesStroke ( NUM_ , new BasicStroke ( NUM_ ) ) ; renderer . setSeriesOutlineStroke ( NUM_ , new BasicStroke ( NUM_ ) ) ; renderer . setSeriesShape ( NUM_ , new Ellipse2D . Double ( - NUM_ , - NUM_ , NUM_ , NUM_ ) ) ; renderer . setBaseToolTipGenerator ( new StandardXYToolTipGenerator ( StandardXYToolTipGenerator . DEFAULT_TOOL_TIP_FORMAT , DateFormat . getDateTimeInstance ( ) , NumberFormat . getNumberInstance ( ) ) ) ; final NumberAxis rangeAxis = new NumberAxis ( STR_ ) ; rangeAxis . setRangeType ( RangeType . POSITIVE ) ; SystemInformationData systemData = ( SystemInformationData ) dataAccessService . getLastDataObject ( systemTemplate ) ; if ( systemData != null ) { double maxNonHeapUpperRange ; if ( systemData . getMaxNonHeapMemorySize ( ) != - NUM_ ) { maxNonHeapUpperRange = systemData . getMaxNonHeapMemorySize ( ) / NUM_ ; } else if ( systemData . getInitNonHeapMemorySize ( ) != - NUM_ ) { maxNonHeapUpperRange = ( systemData . getInitNonHeapMemorySize ( ) . NUM_ ) / NUM_ ; } else { maxNonHeapUpperRange = NUM_ . NUM_ . NUM_ ; } if ( maxNonHeapUpperRange > NUM_ ) { rangeAxis . setRange ( NUM_ , maxNonHeapUpperRange ) ; rangeAxis . setAutoRangeMinimumSize ( maxNonHeapUpperRange ) ; } } final XYPlot subplot = new XYPlot ( yIntervalSeriesCollection , null , rangeAxis , renderer ) ; subplot . setAxisOffset ( new RectangleInsets ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; subplot . setRangeAxisLocation ( AxisLocation . TOP_OR_LEFT ) ; subplot . setRangeCrosshairVisible ( BOOL_ ) ; return subplot ; }
public static void logError ( Throwable exception , String message , Object ... args ) { message = MessageFormat . format ( message , args ) ; log ( IStatus . ERROR , IStatus . OK , message , exception ) ; }
public void add ( Row r ) { list . add ( r ) ; memory += r . getMemory ( ) + Constants . MEMORY_POINTER ; if ( maxMemory > NUM_ && memory > maxMemory ) { writeAllRows ( ) ; } size ++ ; }
private MessageListView renderConversation ( ConversationInfo convInfo , View parent ) { MessageListView list = new MessageListView ( parent . getContext ( ) ) ; convInfo . view = list ; list . setOnItemClickListener ( MessageClickListener . getInstance ( ) ) ; MessageListAdapter adapter = convInfo . adapter ; if ( adapter == null ) { adapter = new MessageListAdapter ( convInfo . conv , parent . getContext ( ) ) ; convInfo . adapter = adapter ; } list . setAdapter ( adapter ) ; list . setSelection ( adapter . getCount ( ) - NUM_ ) ; return list ; }
public static int defineTag ( int ifdId , short tagId ) { return ( tagId & x0000ffff ) | ( ifdId << NUM_ ) ; }
public ApplicationIdVerifier ( Set < String > supportedApplicationIds ) { this . supportedApplicationIds = Collections . unmodifiableSet ( new HashSet < String > ( supportedApplicationIds ) ) ; }
public QueryResponse search ( Resource resource , SolrQuery query ) throws SolrServerException , IOException { String idQuery = termQuery ( SearchFields . URI_FIELD_NAME , SearchFields . getResourceID ( resource ) ) ; query . setQuery ( query . getQuery ( ) + STR_ + idQuery ) ; return search ( query ) ; }
public static LocalDate toDate ( String data , String modelo ) { return LocalDate . parse ( data , formatter ( modelo ) ) ; }
public boolean isMutable ( ) { return mutable ; }
public static final Criterion all ( ) { return AllCriterion . all ( ) ; }
public static void transform ( InputStream srcStream , OutputStream destStream , InputStream stylesheetStream , String outputFormat ) throws FOPException { StreamSource src = new StreamSource ( srcStream ) ; StreamSource stylesheet = stylesheetStream == null ? null : new StreamSource ( stylesheetStream ) ; Fop fop = createFopInstance ( destStream , outputFormat ) ; transform ( src , stylesheet , fop ) ; }
public boolean InsertSym ( int type , String id , String context , String cType , int line , int col ) { int i ; if ( type == PROCEDUREVAR || type == PROCESSVAR || type == PARAMETER ) { i = FindSym ( GLOBAL , id , STR_ ) ; if ( i < symtab . size ( ) ) return BOOL_ ; i = FindSym ( id , context ) ; if ( i < symtab . size ( ) ) return BOOL_ ; } else { i = FindSym ( type , id , context ) ; if ( i < symtab . size ( ) ) return BOOL_ ; } SymTabEntry se = new SymTabEntry ( type , id , context , cType , line , col ) ; symtab . addElement ( se ) ; return BOOL_ ; }
public static Schema schemaForStructType ( StructType structType ) { List < String > fieldNames = Lists . newArrayList ( ) ; List < String > fieldTypes = Lists . newArrayList ( ) ; for ( StructField field : structType . fields ( ) ) { fieldNames . add ( field . name ( ) ) ; DataType fieldType = field . dataType ( ) ; if ( fieldType . equals ( DataTypes . StringType ) ) { fieldTypes . add ( STR_ ) ; } else if ( fieldType . equals ( DataTypes . FloatType ) ) { fieldTypes . add ( STR_ ) ; } else if ( fieldType . equals ( DataTypes . DoubleType ) ) { fieldTypes . add ( STR_ ) ; } else if ( fieldType . equals ( DataTypes . IntegerType ) ) { fieldTypes . add ( STR_ ) ; } else if ( fieldType . equals ( DataTypes . LongType ) ) { fieldTypes . add ( STR_ ) ; } else if ( fieldType . equals ( DataTypes . BooleanType ) ) { fieldTypes . add ( STR_ ) ; } else { throw new RuntimeException ( STR_ + fieldType ) ; } } return RecordUtils . schemaFor ( fieldNames , fieldTypes ) ; }
public JettySolrRunner startJettySolrRunner ( JettySolrRunner jetty ) throws Exception { jetty . start ( BOOL_ ) ; jettys . add ( jetty ) ; return jetty ; }
public Map < CIMObjectPath , Set < String > > findAnySLOStorageGroupsCanBeReUsed ( StorageSystem forProvider , StorageSystem storage , String policyName , boolean associatedToView ) throws WBEMException { CloseableIterator < CIMInstance > groupInstanceItr = null ; CloseableIterator < CIMObjectPath > volumePathItr = null ; Map < CIMObjectPath , Set < String > > groupPaths = new ConcurrentHashMap < CIMObjectPath , Set < String > > ( ) ; try { CIMObjectPath controllerConfigSvcPath = _cimPath . getControllerConfigSvcPath ( storage ) ; _log . info ( STR_ ) ; groupInstanceItr = getAssociatorInstances ( forProvider , controllerConfigSvcPath , null , SE_DEVICE_MASKING_GROUP , null , null , PS_V3_STORAGE_GROUP_PROPERTIES ) ; while ( groupInstanceItr . hasNext ( ) ) { CIMInstance groupInstance = groupInstanceItr . next ( ) ; CIMObjectPath groupPath = groupInstance . getObjectPath ( ) ; String groupName = CIMPropertyFactory . getPropertyValue ( groupInstance , CP_ELEMENT_NAME ) ; String fastSetting = CIMPropertyFactory . getPropertyValue ( groupInstance , CP_FAST_SETTING ) ; String groupAssociatedToView = CIMPropertyFactory . getPropertyValue ( groupInstance , CP_ASSOCIATED_TO_VIEW ) ; Set < String > returnedNativeGuids = new HashSet < String > ( ) ; if ( fastSetting . equals ( policyName ) && associatedToView == Boolean . parseBoolean ( groupAssociatedToView ) && groupName . startsWith ( Constants . STORAGE_GROUP_PREFIX ) ) { _log . debug ( STR_ , groupName ) ; volumePathItr = getAssociatorNames ( forProvider , groupPath , null , CIM_STORAGE_VOLUME , null , null ) ; while ( volumePathItr . hasNext ( ) ) { returnedNativeGuids . add ( getVolumeNativeGuid ( volumePathItr . next ( ) ) ) ; } groupPaths . put ( groupPath , returnedNativeGuids ) ; } } } finally { closeCIMIterator ( groupInstanceItr ) ; closeCIMIterator ( volumePathItr ) ; } return groupPaths ; }
Remover add ( T listener ) ;
protected void updateDamage ( DocumentEvent changes , Shape a , ViewFactory f ) { checkMetrics ( ) ; Component host = getContainer ( ) ; Element elem = getElement ( ) ; DocumentEvent . ElementChange ec = changes . getChange ( elem ) ; Element [ ] added = ( ec != null ) ? ec . getChildrenAdded ( ) : null ; Element [ ] removed = ( ec != null ) ? ec . getChildrenRemoved ( ) : null ; if ( ( ( added != null ) && ( added . length > NUM_ ) ) || ( ( removed != null ) && ( removed . length > NUM_ ) ) ) { if ( added != null && longestLine != null ) { int currentMaxWidth = getLineWidth ( longestLine ) ; for ( int i = NUM_ ; i < added . length ; i ++ ) { int width = getLineWidth ( added [ i ] ) ; if ( width > currentMaxWidth ) { currentMaxWidth = width ; longestLine = added [ i ] ; } } } if ( removed != null ) { for ( int i = NUM_ ; i < removed . length ; i ++ ) { if ( removed [ i ] == longestLine ) { longestLine = null ; break ; } } } preferenceChanged ( null , BOOL_ , BOOL_ ) ; host . repaint ( ) ; } else { Element map = getElement ( ) ; int line = map . getElementIndex ( changes . getOffset ( ) ) ; int endLine = map . getElementIndex ( changes . getOffset ( ) + changes . getLength ( ) ) ; damageLineRange ( line , endLine , a , host ) ; getLongestLine ( ) ; if ( changes . getType ( ) == DocumentEvent . EventType . INSERT ) { int w = getLineWidth ( longestLine ) ; Element e = map . getElement ( line ) ; if ( e == longestLine ) { preferenceChanged ( null , BOOL_ , BOOL_ ) ; } else if ( getLineWidth ( e ) > w ) { longestLine = e ; preferenceChanged ( null , BOOL_ , BOOL_ ) ; } } else if ( changes . getType ( ) == DocumentEvent . EventType . REMOVE ) { if ( map . getElement ( line ) == longestLine ) { determineLongestLine ( ) ; preferenceChanged ( null , BOOL_ , BOOL_ ) ; } } } }
public JClassDependency ( JClass cl , String digest ) { _className = cl . getName ( ) ; String newDigest = getDigest ( ) ; if ( ! newDigest . equals ( digest ) ) { if ( log . isLoggable ( Level . FINE ) ) log . fine ( _className + STR_ ) ; _isDigestModified = BOOL_ ; } }
public void dump ( Object data , Writer output ) { List < Object > list = new ArrayList < Object > ( NUM_ ) ; list . add ( data ) ; dumpAll ( list . iterator ( ) , output , null ) ; }
public void clear ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { Object [ ] array = queue ; int n = size ; size = NUM_ ; for ( int i = NUM_ ; i < n ; i ++ ) array [ i ] = null ; } finally { lock . unlock ( ) ; } }
public void reset ( ) { System . arraycopy ( IV , NUM_ , cbcV , NUM_ , IV . length ) ; Arrays . fill ( cbcNextV , ( byte ) NUM_ ) ; cipher . reset ( ) ; }
public void addInsnToHead ( Insn insn ) { SsaInsn newInsn = SsaInsn . makeFromRop ( insn , this ) ; insns . add ( getCountPhiInsns ( ) , newInsn ) ; parent . onInsnAdded ( newInsn ) ; }
public static String encodeForURL ( String str ) { StringBuffer result = new StringBuffer ( ) ; for ( int i = NUM_ ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ch >= STR_ && ch <= STR_ || ch >= STR_ && ch <= STR_ || ch >= STR_ && ch <= STR_ ) result . append ( ch ) ; else { switch ( ch ) { case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : result . append ( ch ) ; break ; default : result . append ( STR_ ) ; result . append ( hexchars [ ( ch & xf0 ) > > NUM_ ] ) ; result . append ( hexchars [ ch & x0f ] ) ; break ; } } } return result . toString ( ) ; }
public void selectObject ( MultiTouchObject multiTouchObject , PointInfo touchPoint ) { currTouchPoint . set ( touchPoint ) ; if ( multiTouchObject != null ) { mImages . remove ( multiTouchObject ) ; mImages . add ( multiTouchObject ) ; if ( listener != null ) { listener . onImageObjectSelected ( multiTouchObject ) ; } } else { if ( listener != null ) { listener . onImageObjectDropped ( ) ; } } invalidate ( ) ; }
void verify ( ) { byte [ ] d = digest . digest ( ) ; if ( ! MessageDigest . isEqual ( d , Base64 . decode ( hash , Base64 . DEFAULT ) ) ) { throw invalidDigest ( JarFile . MANIFEST_NAME , name , jarName ) ; } verifiedEntries . put ( name , certificates ) ; }
public void randomizeIncomingWeights ( ) { for ( Neuron n : getNeuronList ( ) ) { for ( Synapse s : n . getFanIn ( ) ) { s . setLowerBound ( NUM_ ) ; s . setStrength ( s . getUpperBound ( ) . Math . random ( ) ) ; } } }
public void remove ( QueueEvent event ) throws KeeperException , InterruptedException { TimerContext time = stats . time ( dir + STR_ ) ; try { String path = event . getId ( ) ; String responsePath = dir + STR_ + response_prefix + path . substring ( path . lastIndexOf ( STR_ ) + NUM_ ) ; if ( zookeeper . exists ( responsePath , BOOL_ ) ) { zookeeper . setData ( responsePath , event . getBytes ( ) , BOOL_ ) ; } else { LOG . info ( STR_ + responsePath + STR_ + STR_ ) ; } try { zookeeper . delete ( path , - NUM_ , BOOL_ ) ; } catch ( KeeperException . NoNodeException ignored ) { } } finally { time . stop ( ) ; } }
public List < Point > readPoints ( String shapefile ) { List < Point > list = new ArrayList < Point > ( ) ; for ( SimpleFeature feature : ShapeFileReader . getAllFeatures ( shapefile ) ) { Geometry geo = ( Geometry ) feature . getDefaultGeometry ( ) ; if ( geo instanceof Point ) { Point ps = ( Point ) geo ; for ( int i = NUM_ ; i < ps . getNumGeometries ( ) ; i ++ ) { Point p = ( Point ) ps . getGeometryN ( i ) ; list . add ( p ) ; } } else { throw new RuntimeException ( STR_ ) ; } } return list ; }
public String rate ( Properties ctx , int WindowNo , GridTab mTab , GridField mField , Object value ) { if ( value == null ) return STR_ ; Integer Currency_ID = ( Integer ) mTab . getValue ( STR_ ) ; int C_Currency_ID = Currency_ID . intValue ( ) ; Integer ConversionType_ID = ( Integer ) mTab . getValue ( STR_ ) ; int C_ConversionType_ID = ConversionType_ID . intValue ( ) ; Timestamp DateAcct = ( Timestamp ) mTab . getValue ( STR_ ) ; if ( DateAcct == null ) DateAcct = new Timestamp ( System . currentTimeMillis ( ) ) ; int C_AcctSchema_ID = Env . getContextAsInt ( ctx , WindowNo , STR_ ) ; MAcctSchema as = MAcctSchema . get ( ctx , C_AcctSchema_ID ) ; int AD_Client_ID = Env . getContextAsInt ( ctx , WindowNo , STR_ ) ; int AD_Org_ID = Env . getContextAsInt ( ctx , WindowNo , STR_ ) ; BigDecimal CurrencyRate = MConversionRate . getRate ( C_Currency_ID , as . getC_Currency_ID ( ) , DateAcct , C_ConversionType_ID , AD_Client_ID , AD_Org_ID ) ; log . fine ( STR_ + CurrencyRate ) ; if ( CurrencyRate == null ) CurrencyRate = Env . ZERO ; mTab . setValue ( STR_ , CurrencyRate ) ; return STR_ ; }
public boolean hasAlphaChangedFrom ( float v ) { return ( Float . compare ( alpha , v ) != NUM_ ) ; }
public CompletableFuture < Void > destroy ( ) { CompletableFuture < Void > ret ; if ( controllerProxy != null ) { ret = controllerProxy . destroy ( ) ; controllerProxy = null ; } else { ret = new CompletableFuture < > ( ) ; ret . complete ( null ) ; } return ret ; }
@ Override public Request < String > logs ( ProjectReference projectReference , long taskId ) { List < DummyRunnerStatus > statuses = availableRunnerStatuses . get ( projectReference . name ( ) ) ; if ( statuses != null && ! statuses . isEmpty ( ) ) { for ( DummyRunnerStatus runnerStatus : statuses ) { if ( taskId == runnerStatus . processId ( ) ) { return new DummyRequest < > ( runnerStatus . getLog ( ) ) ; } } } return new DummyRequest < > ( null ) ; }
protected static ActionResultInfo performAction ( GenericValue productPromoAction , ShoppingCart cart , Delegator delegator , LocalDispatcher dispatcher , Timestamp nowTimestamp ) throws GenericEntityException , CartItemModifyException { ActionResultInfo actionResultInfo = new ActionResultInfo ( ) ; performAction ( actionResultInfo , productPromoAction , cart , delegator , dispatcher , nowTimestamp ) ; return actionResultInfo ; }
private boolean containsExpression ( String toSearch , String expression ) { if ( toSearch == null ) { return BOOL_ ; } return toSearch . equals ( expression ) || toSearch . indexOf ( expression ) >= NUM_ ; }
public void clearListeners ( ) { listeners . clear ( ) ; }
private Var addProperty ( VarProperty property ) { if ( property . isUnique ( ) ) { testUniqueProperty ( ( UniqueVarProperty ) property ) ; } properties . add ( property ) ; return this ; }
public boolean isOpen ( ) { return open . get ( ) ; }
public void free ( long pos , int length ) { int start = getBlock ( pos ) ; int blocks = getBlockCount ( length ) ; set . clear ( start , start + blocks ) ; }
private void onConnectionStatusChanged ( int oldStatus , int status ) { if ( sSettingsMgr . showStatusIcon ) { NotificationCompat . Builder builder = new NotificationCompat . Builder ( this ) ; builder . setWhen ( System . currentTimeMillis ( ) ) ; switch ( status ) { case XmppManager . CONNECTED : builder . setContentText ( getString ( R . string . main_service_connected , getConnectionStatusAction ( ) ) ) ; builder . setSmallIcon ( getImageStatus ( STATUS_ICON_GREEN ) ) ; break ; case XmppManager . CONNECTING : builder . setContentText ( getString ( R . string . main_service_connecting ) ) ; builder . setSmallIcon ( getImageStatus ( STATUS_ICON_ORANGE ) ) ; break ; case XmppManager . DISCONNECTED : builder . setContentText ( getString ( R . string . main_service_disconnected ) ) ; builder . setSmallIcon ( getImageStatus ( STATUS_ICON_RED ) ) ; break ; case XmppManager . DISCONNECTING : builder . setContentText ( getString ( R . string . main_service_disconnecting ) ) ; builder . setSmallIcon ( getImageStatus ( STATUS_ICON_ORANGE ) ) ; break ; case XmppManager . WAITING_TO_CONNECT : case XmppManager . WAITING_FOR_NETWORK : builder . setContentText ( getString ( R . string . main_service_waiting_to_connect ) + STR_ + getConnectionStatusAction ( ) ) ; builder . setSmallIcon ( getImageStatus ( STATUS_ICON_BLUE ) ) ; break ; default : return ; } builder . setContentIntent ( sPendingIntentLaunchApplication ) ; builder . setContentTitle ( Tools . APP_NAME ) ; startForeground ( NOTIFICATION_CONNECTION , builder . getNotification ( ) ) ; } }
private static File findGuacamoleHome ( ) { File guacHome ; String desiredDir = System . getProperty ( STR_ ) ; if ( desiredDir == null ) desiredDir = System . getenv ( STR_ ) ; if ( desiredDir != null ) guacHome = new File ( desiredDir ) ; else guacHome = new File ( System . getProperty ( STR_ ) , STR_ ) ; return guacHome ; }
void waitForServerStart ( ) throws InterruptedException { started . await ( getTestTimeout ( ) , TimeUnit . MILLISECONDS ) ; }
private static void drawLeftTab ( int x , int y , int w , int h , Graphics2D g2 , ColorUIResource color ) { double rTop = RapidLookAndFeel . CORNER_TAB_RADIUS . NUM_ ; g2 . setColor ( color ) ; g2 . fill ( createLeftTabShape ( x + NUM_ , y + NUM_ , w - NUM_ , h , rTop , BOOL_ ) ) ; g2 . setColor ( Colors . TAB_BORDER ) ; g2 . draw ( createLeftTabShape ( x , y , w - NUM_ , h , rTop , BOOL_ ) ) ; }
private List < int [ ] > prepareExpectedData ( ) { List < int [ ] > indexList = new ArrayList < > ( NUM_ ) ; int [ ] sortIndex = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int [ ] sortIndexInverted = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; indexList . add ( NUM_ , sortIndex ) ; indexList . add ( NUM_ , sortIndexInverted ) ; return indexList ; }
public byte [ ] readBytes ( final int count ) { int bytesToRead = count ; if ( bytesToRead < NUM_ ) bytesToRead = byteStream . available ( ) ; byte [ ] bytes = new byte [ bytesToRead ] ; if ( currentBitIndex >= NUM_ ) { for ( int i = NUM_ ; i < bytesToRead ; i ++ ) { bytes [ i ] = ( byte ) read ( Byte . SIZE ) ; } } else { byteStream . read ( bytes , NUM_ , bytes . length ) ; } return bytes ; }
public SSLTestConfig ( ) { this ( BOOL_ , BOOL_ ) ; }
@ Override public int hashCode ( ) { return x45aaf665 + Arrays . hashCode ( fields ) ; }
public static String formatPath ( List < ChildNumber > path ) { return PATH_JOINER . join ( Iterables . concat ( Collections . singleton ( STR_ ) , path ) ) ; }
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; }
public static Object readInvocationResult ( PlatformContext ctx , BinaryRawReaderEx reader ) throws IgniteCheckedException { boolean success = reader . readBoolean ( ) ; if ( success ) return reader . readObjectDetached ( ) ; else { boolean hasException = reader . readBoolean ( ) ; if ( hasException ) { Object nativeErr = reader . readObjectDetached ( ) ; assert nativeErr != null ; throw ctx . createNativeException ( nativeErr ) ; } else { String errMsg = reader . readString ( ) ; assert errMsg != null ; throw new IgniteCheckedException ( errMsg ) ; } } }
public final void testGenerateSeedint02 ( ) { for ( int i = NUM_ ; i < LENGTH ; i ++ ) { byte [ ] myBytes = sr . generateSeed ( i ) ; assertFalse ( STR_ + i + STR_ + myBytes . length , myBytes . length != i ) ; } }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case NUM_ : return STRING_THING ; case NUM_ : return BYTE_THING ; case NUM_ : return I32_THING ; case NUM_ : return I64_THING ; default : return null ; } }
private List < String > replaceDotInMustacheKeys ( final List < String > mustacheKeys ) { final List < String > fixedMustacheKeys = new ArrayList < > ( ) ; for ( String mustacheKey : mustacheKeys ) { fixedMustacheKeys . add ( mustacheKey . replace ( STR_ , STR_ ) ) ; } return fixedMustacheKeys ; }
public static IFitsHeader create ( String key ) { IFitsHeader result = STANDARD_KEYS . get ( key ) ; if ( result == null ) { result = new FitsHeaderImpl ( key , SOURCE . UNKNOWN , HDU . ANY , VALUE . ANY , STR_ ) ; } return result ; }
protected String parsePayload ( String payload ) { String json = null ; if ( payload != null ) { try { json = ( payload . indexOf ( STR_ ) == - NUM_ ) ? new String ( Files . readAllBytes ( Paths . get ( payload ) ) ) : payload ; } catch ( IOException e ) { log . fatal ( STR_ + payload , e ) ; System . exit ( NUM_ ) ; } } return json ; }
boolean addEntry ( PolicyEntry pe , int index ) { if ( index < NUM_ ) { policyEntries . addElement ( pe ) ; parser . add ( pe . getGrantEntry ( ) ) ; } else { PolicyEntry origPe = policyEntries . elementAt ( index ) ; parser . replace ( origPe . getGrantEntry ( ) , pe . getGrantEntry ( ) ) ; policyEntries . setElementAt ( pe , index ) ; } return BOOL_ ; }
public WritableRaster createCompatibleWritableRaster ( int w , int h ) { if ( w <= NUM_ || h <= NUM_ ) { throw new RasterFormatException ( STR_ + ( ( w <= NUM_ ) ? STR_ : STR_ ) ) ; } SampleModel sm = sampleModel . createCompatibleSampleModel ( w , h ) ; return new IntegerComponentRaster ( sm , new Point ( NUM_ , NUM_ ) ) ; }
public void testCase1 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int bSign = NUM_ ; byte rBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . subtract ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( NUM_ , result . signum ( ) ) ; }
public static void createOrClearDestinationFolder ( String path ) { File fpath = new File ( path ) ; fpath . mkdirs ( ) ; deleteDirectoryContents ( path , BOOL_ ) ; }
static synchronized JmriUserInterfaceConfigurationProvider findProvider ( Profile project ) { if ( providers . get ( project ) == null ) { providers . put ( project , new JmriUserInterfaceConfigurationProvider ( project ) ) ; } return providers . get ( project ) ; }
protected static long [ ] insert ( long [ ] old , int oldSize , int pos , long x ) { long [ ] result ; if ( old != null && old . length > oldSize ) { result = old ; } else { result = new long [ oldSize + NUM_ + COPY_THRESHOLD ] ; if ( pos > NUM_ ) { System . arraycopy ( old , NUM_ , result , NUM_ , pos ) ; } } if ( old != null && oldSize - pos > NUM_ ) { System . arraycopy ( old , pos , result , pos + NUM_ , oldSize - pos ) ; } result [ pos ] = x ; return result ; }
private void registerObjectRead ( Object obj , int handle , boolean unshared ) throws IOException { if ( unshared ) { obj = UNSHARED_OBJ ; } int index = handle - ObjectStreamConstants . baseWireHandle ; int size = objectsRead . size ( ) ; while ( index > size ) { objectsRead . add ( null ) ; ++ size ; } if ( index == size ) { objectsRead . add ( obj ) ; } else { objectsRead . set ( index , obj ) ; } }
private boolean discardUpstreamMediaChunks ( int queueLength ) { if ( mediaChunks . size ( ) <= queueLength ) { return BOOL_ ; } long startTimeUs = NUM_ ; long endTimeUs = mediaChunks . getLast ( ) . endTimeUs ; BaseMediaChunk removed = null ; while ( mediaChunks . size ( ) > queueLength ) { removed = mediaChunks . removeLast ( ) ; startTimeUs = removed . startTimeUs ; loadingFinished = BOOL_ ; } sampleQueue . discardUpstreamSamples ( removed . getFirstSampleIndex ( ) ) ; notifyUpstreamDiscarded ( startTimeUs , endTimeUs ) ; return BOOL_ ; }
public void close ( ) { animation . setRate ( - NUM_ ) ; animation . play ( ) ; animation . setOnFinished ( null ) ; }
Map < String , Set < CallLocationModel > > computeFilteredTaintSourcesMap ( Set < CallLocationModel > sources ) { if ( ! sources . isEmpty ( ) ) { if ( fFilteredTaintSourcesMap != null && ! fFilteredTaintSourcesMap . isEmpty ( ) ) { Map < String , Set < CallLocationModel > > result = new TreeMap < String , Set < CallLocationModel > > ( ) ; for ( Entry < String , Set < CallLocationModel > > entry : fFilteredTaintSourcesMap . entrySet ( ) ) { Set < CallLocationModel > filteredSources = new TreeSet < CallLocationModel > ( ) ; for ( CallLocationModel source : entry . getValue ( ) ) { if ( sources . contains ( source ) ) { filteredSources . add ( source ) ; } } if ( ! filteredSources . isEmpty ( ) ) { String taintKind = entry . getKey ( ) ; result . put ( taintKind , filteredSources ) ; } } return result ; } } return Collections . EMPTY_MAP ; }
public static boolean contains ( String s , Property expected ) { if ( s == null || s . length ( ) == NUM_ ) { return BOOL_ ; } int i = NUM_ ; while ( i < s . length ( ) ) { int codepoint = Character . codePointAt ( s , i ) ; Emoji e = map . get ( codepoint ) ; if ( e == null ) { return BOOL_ ; } if ( ! e . is ( expected ) ) { return BOOL_ ; } i += codepoint >= x010000 ? NUM_ : NUM_ ; } return BOOL_ ; }
public Class toClass ( String codebase ) throws IOException , ClassNotFoundException { if ( name . charAt ( NUM_ ) != STR_ ) { return ClassLoading . loadClass ( codebase , name , null , integrity , null ) ; } StringTokenizer st = new StringTokenizer ( name , STR_ ) ; String [ ] ifs = new String [ st . countTokens ( ) ] ; for ( int i = NUM_ ; i < ifs . length ; i ++ ) { ifs [ i ] = st . nextToken ( ) ; } return ClassLoading . loadProxyClass ( codebase , ifs , null , integrity , null ) ; }
private synchronized IMqttToken removeMqttToken ( Bundle data ) { String activityToken = data . getString ( MqttServiceConstants . CALLBACK_ACTIVITY_TOKEN ) ; if ( activityToken != null ) { int tokenNumber = Integer . parseInt ( activityToken ) ; IMqttToken token = tokenMap . get ( tokenNumber ) ; tokenMap . delete ( tokenNumber ) ; return token ; } return null ; }
public static < T > Optional < T > lowestCommonAncestor ( TreeDef . Parented < T > treeDef , List < T > nodes ) { if ( nodes . size ( ) == NUM_ ) { return Optional . empty ( ) ; } else { Optional < T > soFar = Optional . of ( nodes . get ( NUM_ ) ) ; for ( int i = NUM_ ; i < nodes . size ( ) && soFar . isPresent ( ) ; ++ i ) { soFar = lowestCommonAncestor ( treeDef , soFar . get ( ) , nodes . get ( i ) ) ; } return soFar ; } }
public void copyValueNodesToMe ( Entity from ) { for ( ValueNode fromChild : from . getChildren ( ValueNode . class ) ) { ValueNode toChild = getChild ( fromChild . getName ( ) , ValueNode . class ) ; toChild . setValue ( fromChild . getValue ( ) ) ; } }
public static WorldIconImage fromPixelTransparency ( BufferedImage image ) { int imageMarginTop = findFirstSolidPixelFromTop ( image ) ; int imageMarginBottom = findFirstSolidPixelFromBottom ( image ) ; int frameHeight = Math . max ( NUM_ , image . getHeight ( ) - imageMarginTop - imageMarginBottom ) ; return new WorldIconImage ( image , NUM_ , imageMarginTop , image . getWidth ( ) , frameHeight ) ; }
private Map < String , String > checkVipDiff ( PropertyInfoExt localProps , PropertyInfoRestRep rep ) { String vipAddrV4 = rep . getProperty ( STR_ ) ; String vipAddrV6 = rep . getProperty ( STR_ ) ; Map < String , String > diffProps = new HashMap < String , String > ( ) ; if ( ! vipAddrV4 . equals ( localProps . getProperty ( STR_ ) ) ) { diffProps . put ( STR_ , vipAddrV4 ) ; _log . warn ( STR_ , vipAddrV4 , localProps . getProperty ( STR_ ) ) ; } if ( ! vipAddrV6 . equals ( localProps . getProperty ( STR_ ) ) ) { diffProps . put ( STR_ , vipAddrV6 ) ; _log . warn ( STR_ , vipAddrV6 , localProps . getProperty ( STR_ ) ) ; } return diffProps ; }
private static double distanceSq ( Color a , Color b ) { double rMean = ( a . getRed ( ) + b . getRed ( ) ) / NUM_ / NUM_ ; double dr = ( a . getRed ( ) - b . getRed ( ) ) / NUM_ ; double dg = ( a . getGreen ( ) - b . getGreen ( ) ) / NUM_ ; double db = ( a . getBlue ( ) - b . getBlue ( ) ) / NUM_ ; double d = ( NUM_ + rMean ) . dr . dr + NUM_ . dg . dg + ( NUM_ + NUM_ - rMean ) . db . db ; return d / NUM_ ; }
@ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case SGraphPackage . SPECIFICATION_ELEMENT__SPECIFICATION : return SPECIFICATION_EDEFAULT == null ? specification != null : ! SPECIFICATION_EDEFAULT . equals ( specification ) ; } return super . eIsSet ( featureID ) ; }
private static ApplicationType newType ( final String name ) throws IllegalAccessException , InstantiationException { return new ApplicationType ( name , new HashMap < String , Boolean > ( TYPE_ACTIONS ) , DumbSearchIndex . class , DumbSaveIndex . class , DumbResourceName . class ) ; }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; if ( bayesIm == null ) { throw new NullPointerException ( ) ; } }
public int compare ( SourceFile o1 , SourceFile o2 ) { String n1 = o1 . getName ( ) ; String n2 = o2 . getName ( ) ; return n1 . compareTo ( n2 ) ; }
protected boolean processDynamicPropertyNodes ( Node parent , DynamicProperty property , Model model ) { Collection nodes = parent . getChildren ( ) ; String name = property . getName ( ) ; String state = property . getStateName ( ) ; CDATANode cdata = getTextContent ( nodes , BOOL_ ) ; if ( cdata != null ) { return processDynamicPropertyText ( name , cdata . image , TextOrigin . fromChild ( cdata . inCDATA ) , cdata . beginLine , model , state ) ; } else { if ( ( state == null ) && model . hasProperty ( name ) ) { log ( parent , new MultiplePropertyInitializerError ( name ) ) ; } Object rvalue = processRValueNodes ( property , nodes , model ) ; if ( rvalue != null ) { model . setDynamicProperty ( typeTable . objectType , name , rvalue , state , parent . beginLine ) ; return BOOL_ ; } else { return BOOL_ ; } } }
private static < T extends PsiElement > boolean processChildrenOfType ( PsiElement element , Processor < T > processor , Class < T > psiClass , boolean reverseOrder ) { PsiElement child = reverseOrder ? element . getLastChild ( ) : element . getFirstChild ( ) ; while ( child != null ) { if ( psiClass . isInstance ( child ) ) { if ( ! processor . process ( ( T ) child ) ) { return BOOL_ ; } } if ( processChildrenOfType ( child , processor , psiClass , reverseOrder ) ) { return BOOL_ ; } child = reverseOrder ? child . getPrevSibling ( ) : child . getNextSibling ( ) ; } return BOOL_ ; }
public Instances generate ( ) throws Exception { return generate ( STR_ ) ; }
protected void loadChars ( AbstractMRReply msg , DataInputStream istream ) throws IOException { int i ; for ( i = NUM_ ; i < msg . maxSize ( ) ; i ++ ) { byte char1 = readByteProtected ( istream ) ; if ( flushReceiveChars ) { log . warn ( STR_ , msg . toString ( ) ) ; msg . flush ( ) ; i = NUM_ ; flushReceiveChars = BOOL_ ; } if ( canReceive ( ) ) { msg . setElement ( i , char1 ) ; if ( endOfMessage ( msg ) ) { break ; } } else { i -- ; log . error ( STR_ , Integer . toHexString ( char1 ) ) ; } } }
public String evaluate ( Associator associator , Instances data ) throws Exception { long startTime ; long endTime ; startTime = System . currentTimeMillis ( ) ; associator . buildAssociations ( data ) ; endTime = System . currentTimeMillis ( ) ; m_Result = new StringBuffer ( associator . toString ( ) ) ; m_Result . append ( STR_ ) ; m_Result . append ( STR_ + ( ( ( double ) ( endTime - startTime ) ) / NUM_ ) + STR_ ) ; m_Result . append ( STR_ ) ; return m_Result . toString ( ) ; }
public static Integer intValue ( String propName , Integer dflt ) { String sysProp = getProperty ( propName ) ; return ( sysProp != null && ! sysProp . isEmpty ( ) ) ? Integer . getInteger ( sysProp ) : dflt ; }
public NSNumber ( int i ) { doubleValue = longValue = i ; type = INTEGER ; }
private int clampMag ( int value , int absMin , int absMax ) { final int absValue = Math . abs ( value ) ; if ( absValue < absMin ) return NUM_ ; if ( absValue > absMax ) return value > NUM_ ? absMax : - absMax ; return value ; }
private int compareVersionParts ( String version1 , String version2 ) { int compare = NUM_ ; Integer v1 ; Integer v2 ; try { v1 = version1 != null ? Integer . parseInt ( version1 ) : NUM_ ; } catch ( NumberFormatException e ) { v1 = NUM_ ; } try { v2 = version2 != null ? Integer . parseInt ( version2 ) : NUM_ ; } catch ( NumberFormatException e ) { v2 = NUM_ ; } if ( v1 > v2 ) { compare = NUM_ ; } else if ( v1 < v2 ) { compare = - NUM_ ; } else { compare = NUM_ ; } return compare ; }
public void preSaveInit ( ) { persistentData . clear ( ) ; for ( int i = NUM_ ; i < getNumPoints ( ) ; i ++ ) { persistentData . add ( getPoint ( i ) ) ; } }
public void essential ( final Consumer < OnComplete > fn ) { this . essential = fn ; if ( done ) { fn . accept ( buildOnComplete ( ) ) ; } }
public void addListener ( IMessageListener newListener ) { synchronized ( listeners ) { listeners . add ( newListener ) ; } }
public void testGetType ( ) { assertEquals ( STR_ , tbt_crl . getType ( ) , STR_ ) ; }
public void addWords ( String phrase ) { if ( phrase . equals ( STR_ ) || phrase . equals ( STR_ ) ) return ; String [ ] words = spliterator ( phrase ) ; if ( words . length < NUM_ ) return ; for ( int i = NUM_ ; i < words . length ; i ++ ) { if ( i == NUM_ ) { Vector < String > startWords = chain . get ( STR_ ) ; startWords . add ( words [ i ] ) ; Vector < String > suffix = chain . get ( words [ i ] ) ; if ( suffix == null ) { suffix = new Vector < > ( ) ; suffix . add ( words [ i + NUM_ ] ) ; chain . put ( words [ i ] , suffix ) ; } } else if ( i == words . length - NUM_ ) { Vector < String > endWords = chain . get ( STR_ ) ; endWords . add ( words [ i ] ) ; } else { Vector < String > suffix = chain . get ( words [ i ] ) ; if ( suffix == null ) { suffix = new Vector < > ( ) ; suffix . add ( words [ i + NUM_ ] ) ; chain . put ( words [ i ] , suffix ) ; } else { suffix . add ( words [ i + NUM_ ] ) ; chain . put ( words [ i ] , suffix ) ; } } } }
@ HLEUnimplemented @ HLEFunction ( nid = xEC19337D , version = NUM_ ) public int sceNetAdhocMatchingAbortSendData ( @ CheckArgument ( STR_ ) int matchingId , pspNetMacAddress macAddress ) { return NUM_ ; }
public ShortBuffer put ( short [ ] src , int srcOffset , int shortCount ) { Arrays . checkOffsetAndCount ( src . length , srcOffset , shortCount ) ; if ( shortCount > remaining ( ) ) { throw new BufferOverflowException ( ) ; } for ( int i = srcOffset ; i < srcOffset + shortCount ; ++ i ) { put ( src [ i ] ) ; } return this ; }
public boolean handleDirectory ( File directory ) { if ( DEBUG ) { logger . fine ( STR_ + directory . getAbsolutePath ( ) ) ; } return BOOL_ ; }
public static void choose ( int n , int [ ] results ) { int k = results . length ; for ( int i = NUM_ ; i < k ; i ++ ) { boolean done = BOOL_ ; while ( ! done ) { results [ i ] = RANDOM . nextInt ( n ) ; done = BOOL_ ; for ( int j = NUM_ ; j < i ; j ++ ) { if ( results [ j ] == results [ i ] ) { done = BOOL_ ; } } } } }
public String printLeafModelsTipText ( ) { return STR_ ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; String childValue ; int childLength ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; nameNode = elementList . item ( NUM_ ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; childValue = child . getData ( ) ; childLength = childValue . length ( ) ; assertEquals ( STR_ , NUM_ , childLength ) ; }
public Set registerClientInterestList ( Object inputClientID , List keys , boolean updatesAsInvalidates ) { Long clientID = getClientIDForMaps ( inputClientID ) ; Set keysRegistered = new HashSet ( keys ) ; synchronized ( interestListLock ) { Map < Object , Set > koi = updatesAsInvalidates ? getKeysOfInterestInv ( ) : getKeysOfInterest ( ) ; CopyOnWriteHashSet interestList = ( CopyOnWriteHashSet ) koi . get ( clientID ) ; if ( interestList == null ) { interestList = new CopyOnWriteHashSet ( ) ; koi . put ( clientID , interestList ) ; } else { keysRegistered . removeAll ( interestList . getSnapshot ( ) ) ; } interestList . addAll ( keys ) ; if ( this . region != null && this . isLocalProfile ) { sendProfileOperation ( clientID , operationType . REGISTER_KEYS , keys , updatesAsInvalidates ) ; } } return keysRegistered ; }
public static String replace ( String inString , String oldPattern , String newPattern ) { if ( ! hasLength ( inString ) || ! hasLength ( oldPattern ) || newPattern == null ) { return inString ; } StringBuilder sb = new StringBuilder ( ) ; int pos = NUM_ ; int index = inString . indexOf ( oldPattern ) ; int patLen = oldPattern . length ( ) ; while ( index >= NUM_ ) { sb . append ( inString . substring ( pos , index ) ) ; sb . append ( newPattern ) ; pos = index + patLen ; index = inString . indexOf ( oldPattern , pos ) ; } sb . append ( inString . substring ( pos ) ) ; return sb . toString ( ) ; }
public static List < String > toPathParts ( String encodedPath ) { if ( encodedPath == null || encodedPath . length ( ) == NUM_ ) { return null ; } List < String > result = new ArrayList < String > ( ) ; int cur = NUM_ ; boolean notDone = BOOL_ ; while ( notDone ) { int slash = encodedPath . indexOf ( STR_ , cur ) ; notDone = slash != - NUM_ ; String sub ; if ( notDone ) { sub = encodedPath . substring ( cur , slash ) ; } else { sub = encodedPath . substring ( cur ) ; } result . add ( CharEscapers . decodeUri ( sub ) ) ; cur = slash + NUM_ ; } return result ; }
@ SuppressWarnings ( STR_ ) public < T extends Point2D > T inverse ( double x , double y , T ret_val ) { if ( ret_val == null ) { ret_val = ( T ) new LatLonPoint . Double ( ) ; } double px = x + ul . x ; double py = - y + ul . y + oy ; if ( px > ProjMath . roundAdjust ( world . x / NUM_ ) ) { px = ProjMath . roundAdjust ( world . x / NUM_ ) ; } else if ( px < ProjMath . roundAdjust ( - world . x / NUM_ ) ) { px = ProjMath . roundAdjust ( - world . x / NUM_ ) ; } if ( py > ProjMath . roundAdjust ( world . y / NUM_ ) ) { py = ProjMath . roundAdjust ( world . y / NUM_ ) ; } else if ( py < ProjMath . roundAdjust ( - world . y / NUM_ ) ) { py = ProjMath . roundAdjust ( - world . y / NUM_ ) ; } double lat_ = normalizeLatitude ( py / spps_y ) ; double lon_ = wrapLongitude ( ( px / spps_x ) + centerX ) ; ret_val . setLocation ( Math . toDegrees ( lon_ ) , Math . toDegrees ( lat_ ) ) ; return ret_val ; }
public void install ( JEditorPane c ) { c . addCaretListener ( inputAttributeUpdater ) ; c . addPropertyChangeListener ( inputAttributeUpdater ) ; Caret caret = c . getCaret ( ) ; if ( caret != null ) { inputAttributeUpdater . updateInputAttributes ( caret . getDot ( ) , caret . getMark ( ) , c ) ; } }
static public MPrintFormat createFromReportView ( Properties ctx , int AD_ReportView_ID , String ReportName ) { int AD_Client_ID = Env . getAD_Client_ID ( ctx ) ; s_log . info ( STR_ + AD_ReportView_ID + STR_ + AD_Client_ID + STR_ + ReportName ) ; MPrintFormat pf = new MPrintFormat ( ctx , NUM_ , null ) ; pf . setAD_ReportView_ID ( AD_ReportView_ID ) ; String sql = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; PreparedStatement pstmt = null ; ResultSet rs = null ; boolean error = BOOL_ ; try { pstmt = DB . prepareStatement ( sql , null ) ; pstmt . setInt ( NUM_ , AD_ReportView_ID ) ; pstmt . setInt ( NUM_ , AD_Client_ID ) ; rs = pstmt . executeQuery ( ) ; if ( rs . next ( ) ) { String name = ReportName ; if ( name == null || name . length ( ) == NUM_ ) name = rs . getString ( NUM_ ) ; int count = rs . getInt ( NUM_ ) ; if ( count > NUM_ ) name += STR_ + count ; pf . setName ( name ) ; pf . setAD_PrintColor_ID ( rs . getInt ( NUM_ ) ) ; pf . setAD_PrintFont_ID ( rs . getInt ( NUM_ ) ) ; pf . setAD_PrintPaper_ID ( rs . getInt ( NUM_ ) ) ; pf . setAD_Table_ID ( rs . getInt ( NUM_ ) ) ; error = BOOL_ ; } else s_log . log ( Level . SEVERE , STR_ + AD_ReportView_ID ) ; } catch ( SQLException e ) { s_log . log ( Level . SEVERE , sql , e ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } if ( error ) return null ; if ( ! pf . save ( ) ) return null ; pf . setItems ( createItems ( ctx , pf ) ) ; return pf ; }
private boolean compareAndIncrementWorkerCount ( int expect ) { return ctl . compareAndSet ( expect , expect + NUM_ ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; Enumeration < Option > enm = super . listOptions ( ) ; while ( enm . hasMoreElements ( ) ) result . add ( enm . nextElement ( ) ) ; result . addElement ( new Option ( STR_ + stopwordsTipText ( ) + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
private void enableOperationButtons ( ) { btnOr . setEnabled ( BOOL_ ) ; btnAnd . setEnabled ( BOOL_ ) ; btnRightParen . setEnabled ( BOOL_ ) ; }
private double computeModifierUnbounded ( final double x ) { return expMultiplier . Math . exp ( - x . x / expMember ) ; }
@ Override public boolean onUnit ( Graphics g , int x , int y , int w , int h ) { FontMetrics fm = g . getFontMetrics ( ) ; int l = ( int ) ( m_x . w ) - fm . stringWidth ( m_id ) / NUM_ ; int t = ( int ) ( m_y . h ) - fm . getHeight ( ) / NUM_ ; if ( x < l || x > l + fm . stringWidth ( m_id ) + NUM_ || y < t || y > t + fm . getHeight ( ) + fm . getDescent ( ) + NUM_ ) { return BOOL_ ; } return BOOL_ ; }
public static Integer toInteger ( String str ) { try { return Integer . valueOf ( str ) ; } catch ( Exception ex ) { return null ; } }
private static void fillWithEmptyRows ( DataTable data , int count ) { while ( data . getRowCount ( ) < count ) { Double [ ] emptyRow = new Double [ data . getColumnCount ( ) ] ; Arrays . fill ( emptyRow , NUM_ ) ; data . add ( emptyRow ) ; } }
public void testDivisionKnuth1 ( ) { byte aBytes [ ] = { - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { - NUM_ , - NUM_ , - NUM_ , - NUM_ } ; int aSign = NUM_ ; int bSign = NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . divide ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public FragmentedHandshakeMessage ( byte [ ] fragmentedBytes , HandshakeType type , int fragmentOffset , int messageLength , InetSocketAddress peerAddress ) { super ( peerAddress ) ; this . type = type ; this . messageLength = messageLength ; this . fragmentedBytes = Arrays . copyOf ( fragmentedBytes , fragmentedBytes . length ) ; setFragmentOffset ( fragmentOffset ) ; setFragmentLength ( fragmentedBytes . length ) ; }
private static void deleteRetryCounter ( WeakReference < Context > weakContext , String filename , int maxRetryAttempts ) { Context context = null ; if ( weakContext != null ) { context = weakContext . get ( ) ; if ( context != null ) { SharedPreferences preferences = context . getSharedPreferences ( ARTISAN_SDK , Context . MODE_PRIVATE ) ; SharedPreferences . Editor editor = preferences . edit ( ) ; editor . remove ( STR_ + filename ) ; editor . apply ( ) ; } } }
private void initializeSparseSlider ( ) { connectionDensitySlider . setMajorTickSpacing ( NUM_ ) ; connectionDensitySlider . setMinorTickSpacing ( NUM_ ) ; connectionDensitySlider . setPaintTicks ( BOOL_ ) ; Hashtable < Integer , JLabel > labelTable2 = new Hashtable < Integer , JLabel > ( ) ; labelTable2 . put ( new Integer ( NUM_ ) , new JLabel ( STR_ ) ) ; labelTable2 . put ( new Integer ( NUM_ ) , new JLabel ( STR_ ) ) ; connectionDensitySlider . setLabelTable ( labelTable2 ) ; connectionDensitySlider . setPaintLabels ( BOOL_ ) ; }
protected void updateTree ( DocumentEvent event ) { updatingSelection = BOOL_ ; try { TreeModel model = getTreeModel ( ) ; Object root = model . getRoot ( ) ; for ( int counter = model . getChildCount ( root ) - NUM_ ; counter >= NUM_ ; counter -- ) { updateTree ( event , ( Element ) model . getChild ( root , counter ) ) ; } } finally { updatingSelection = BOOL_ ; } }
private static Shape bottomEdge ( BufferedImage image , GeneralPath path , int start ) { int lastj = NUM_ ; Point2D p1 = path . getCurrentPoint ( ) ; Point2D p2 = null ; Line2D line = new Line2D . Float ( ) ; for ( int i = start ; i < image . getWidth ( ) ; i += sample ) { boolean aPointExistsOnThisLine = BOOL_ ; for ( int j = image . getHeight ( ) - NUM_ ; j >= NUM_ ; j -= sample ) { if ( ( image . getRGB ( i , j ) & xff000000 ) != NUM_ ) { Point2D p = new Point2D . Float ( i , j ) ; aPointExistsOnThisLine = BOOL_ ; p2 = detectLine ( p1 , p2 , p , line , path ) ; lastj = j ; break ; } } if ( aPointExistsOnThisLine == BOOL_ ) { break ; } } return rightEdge ( image , path , lastj ) ; }
@ Override public void close ( ) throws IOException { if ( logger != null ) { logger . println ( STR_ + socket_was_closed ) ; } if ( ! socket_was_closed ) { if ( handshake_started ) { alertProtocol . alert ( AlertProtocol . WARNING , AlertProtocol . CLOSE_NOTIFY ) ; try { output . write ( alertProtocol . wrap ( ) ) ; } catch ( IOException ex ) { } alertProtocol . setProcessed ( ) ; } shutdown ( ) ; closeTransportLayer ( ) ; socket_was_closed = BOOL_ ; } }
@ FormUrlEncoded @ POST ( STR_ ) Call < AuthenticationResponse > authorize ( @ FieldMap Map < String , String > authMap ) ;
private boolean repeatingPreview ( Object tag ) { try { CaptureRequest . Builder builder = mDevice . createCaptureRequest ( CameraDevice . TEMPLATE_PREVIEW ) ; builder . addTarget ( mPreviewSurface ) ; builder . set ( CaptureRequest . CONTROL_MODE , CameraMetadata . CONTROL_MODE_AUTO ) ; addBaselineCaptureKeysToRequest ( builder ) ; mCaptureSession . setRepeatingRequest ( builder . build ( ) , mCaptureCallback , mCameraHandler ) ; Log . v ( TAG , String . format ( STR_ , mZoomValue ) ) ; return BOOL_ ; } catch ( CameraAccessException ex ) { Log . e ( TAG , STR_ , ex ) ; return BOOL_ ; } }
private XMLElement newElement ( String name , String value , ArrayList attributes ) throws Exception { return newElement ( name , value , attributes , BOOL_ ) ; }
public void mousePressed ( MouseEvent e ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STR_ + ( e . getModifiers ( ) & MouseEvent . BUTTON1_MASK ) + STR_ + e . isPopupTrigger ( ) + STR_ + ( e . getModifiers ( ) & ( MouseEvent . ALT_MASK + MouseEvent . META_MASK + MouseEvent . CTRL_MASK ) ) + ( STR_ + MouseEvent . ALT_MASK + STR_ + MouseEvent . META_MASK + STR_ + MouseEvent . CTRL_MASK ) ) ; } if ( e . isPopupTrigger ( ) && parentFrame . isSelected ( ) ) { try { _menu . show ( e . getComponent ( ) , e . getX ( ) , e . getY ( ) ) ; } catch ( java . awt . IllegalComponentStateException cs ) { } e . consume ( ) ; } }
public void defineFillStyle ( Color [ ] colors , int [ ] ratios , Transform matrix , boolean radial ) { GradientFill fill = new GradientFill ( colors , ratios , matrix , radial ) ; elements . add ( fill ) ; for ( int i = NUM_ ; i < colors . length ; i ++ ) { if ( colors [ i ] == null ) { continue ; } if ( colors [ i ] instanceof AlphaColor ) { hasAlpha = BOOL_ ; } } }
public boolean isOrphan ( Sha256Hash block ) { lock . lock ( ) ; try { return orphanBlocks . containsKey ( block ) ; } finally { lock . unlock ( ) ; } }
protected BooleanVal ( boolean b ) { this . b = b ; }
private void relocateFromHeaders ( ByteBuffer f , SceModule module , int baseAddress , Elf32 elf , int elfOffset ) throws IOException { int i = NUM_ ; for ( Elf32ProgramHeader phdr : elf . getProgramHeaderList ( ) ) { if ( phdr . getP_type ( ) == x700000A0L ) { int RelCount = phdr . getP_filesz ( ) / Elf32Relocate . sizeof ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( String . format ( STR_ , i , RelCount ) ) ; } f . position ( elfOffset + phdr . getP_offset ( ) ) ; relocateFromBuffer ( f , module , baseAddress , elf , RelCount , BOOL_ ) ; return ; } else if ( phdr . getP_type ( ) == x700000A1L ) { if ( log . isDebugEnabled ( ) ) { log . debug ( String . format ( STR_ , i , phdr . getP_filesz ( ) ) ) ; } f . position ( elfOffset + phdr . getP_offset ( ) ) ; relocateFromBufferA1 ( f , elf , baseAddress , i , phdr . getP_filesz ( ) ) ; return ; } i ++ ; } for ( Elf32SectionHeader shdr : elf . getSectionHeaderList ( ) ) { if ( mustRelocate ( elf , shdr ) ) { int RelCount = shdr . getSh_size ( ) / Elf32Relocate . sizeof ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( shdr . getSh_namez ( ) + STR_ + RelCount + STR_ ) ; } f . position ( elfOffset + shdr . getSh_offset ( ) ) ; relocateFromBuffer ( f , module , baseAddress , elf , RelCount , shdr . getSh_type ( ) != Elf32SectionHeader . SHT_REL ) ; } } }
public List < Volume > validateVolumes ( StorageSystem storageSystem , List < Volume > volumes , boolean delete , boolean remediate , ValCk ... checks ) { try { client = VPlexControllerUtils . getVPlexAPIClient ( VPlexApiFactory . getInstance ( ) , storageSystem , getDbClient ( ) ) ; for ( Volume volume : volumes ) { try { log . info ( String . format ( STR_ , volume . getLabel ( ) , volume . getNativeId ( ) , volume . getId ( ) , checks . toString ( ) ) ) ; validateVolume ( volume , delete , remediate , checks ) ; } catch ( Exception ex ) { log . error ( STR_ + volume . getId ( ) , ex ) ; } } } catch ( Exception ex ) { log . error ( STR_ + storageSystem . getId ( ) , ex ) ; } return remediatedVolumes ; }
private void drawXAxisMarker ( Canvas canvas , double value , NumberFormat numberFormat , int spacing ) { String marker = chartByDistance ? numberFormat . format ( value ) : StringUtils . formatElapsedTime ( ( long ) value ) ; Rect rect = getRect ( xAxisMarkerPaint , marker ) ; canvas . drawText ( marker , getX ( value ) , topBorder + effectiveHeight + spacing + rect . height ( ) , xAxisMarkerPaint ) ; }
public static < E > ArrayList < E > list ( E ... elements ) { ArrayList < E > list = new ArrayList < E > ( ) ; for ( E element : elements ) list . add ( element ) ; return list ; }
public static String encode ( ArrayList < GeoPoint > polyline , int precision ) { StringBuilder encodedPoints = new StringBuilder ( ) ; int prev_lat = NUM_ , prev_lng = NUM_ ; for ( GeoPoint trackpoint : polyline ) { int lat = trackpoint . getLatitudeE6 ( ) / precision ; int lng = trackpoint . getLongitudeE6 ( ) / precision ; encodedPoints . append ( encodeSignedNumber ( lat - prev_lat ) ) ; encodedPoints . append ( encodeSignedNumber ( lng - prev_lng ) ) ; prev_lat = lat ; prev_lng = lng ; } return encodedPoints . toString ( ) ; }
private static boolean isTextObscured ( JComponent c , String s ) { Graphics g = c . getGraphics ( ) ; FontMetrics fm = g . getFontMetrics ( c . getFont ( ) ) ; int sw = fm . stringWidth ( s ) ; return ( sw > c . getWidth ( ) ) ; }
public void add ( Permission permission ) { perms . put ( permission , permission ) ; }
@ Override public Set < Statement > sum ( final IGASState < Set < Statement > , Set < Statement > , Set < Statement > > state , final Set < Statement > left , final Set < Statement > right ) { final Set < Statement > tmp = new LinkedHashSet < Statement > ( left ) ; tmp . addAll ( right ) ; return tmp ; }
public static int prefixLength ( char [ ] s1 , char [ ] s2 ) { int len = NUM_ ; int max = Math . min ( s1 . length , s2 . length ) ; for ( int i = NUM_ ; i < max && s1 [ i ] == s2 [ i ] ; ++ i ) ++ len ; return len ; }
public void testAllConnectedBrokerNetwork ( ) throws Exception { bridgeBrokers ( STR_ , STR_ ) ; bridgeBrokers ( STR_ , STR_ ) ; bridgeBrokers ( STR_ , STR_ ) ; bridgeBrokers ( STR_ , STR_ ) ; bridgeBrokers ( STR_ , STR_ ) ; bridgeBrokers ( STR_ , STR_ ) ; startAllBrokers ( ) ; Destination dest = createDestination ( STR_ , BOOL_ ) ; MessageConsumer clientA = createConsumer ( STR_ , dest ) ; MessageConsumer clientB = createConsumer ( STR_ , dest ) ; MessageConsumer clientC = createConsumer ( STR_ , dest ) ; Thread . sleep ( NUM_ ) ; sendMessages ( STR_ , dest , MESSAGE_COUNT ) ; sendMessages ( STR_ , dest , MESSAGE_COUNT ) ; sendMessages ( STR_ , dest , MESSAGE_COUNT ) ; MessageIdList msgsA = getConsumerMessages ( STR_ , clientA ) ; MessageIdList msgsB = getConsumerMessages ( STR_ , clientB ) ; MessageIdList msgsC = getConsumerMessages ( STR_ , clientC ) ; msgsA . waitForMessagesToArrive ( MESSAGE_COUNT . NUM_ ) ; msgsB . waitForMessagesToArrive ( MESSAGE_COUNT . NUM_ ) ; msgsC . waitForMessagesToArrive ( MESSAGE_COUNT . NUM_ ) ; assertEquals ( MESSAGE_COUNT . NUM_ , msgsA . getMessageCount ( ) ) ; assertEquals ( MESSAGE_COUNT . NUM_ , msgsB . getMessageCount ( ) ) ; assertEquals ( MESSAGE_COUNT . NUM_ , msgsC . getMessageCount ( ) ) ; }
private int encryptedColumnLength ( int colLength ) { String str = STR_ ; for ( int i = NUM_ ; i < colLength ; i ++ ) { str += STR_ ; } str = SecureEngine . encrypt ( str ) ; return str . length ( ) ; }
private CnATreeElement unifyLinks ( CnATreeElement sourceElement , CnATreeElement destinationElement ) throws CommandException { for ( CnALink linkDown : sourceElement . getLinksDown ( ) ) { createLink ( destinationElement , linkDown . getDependency ( ) , linkDown . getRelationId ( ) ) ; } for ( CnALink linkUp : sourceElement . getLinksUp ( ) ) { createLink ( linkUp . getDependant ( ) , destinationElement , linkUp . getRelationId ( ) ) ; } return destinationElement ; }
private boolean flushAccumulatedRegion ( ) { boolean success = BOOL_ ; if ( accumulatedX != Integer . MAX_VALUE ) { SubRegionShowable bsSubRegion = ( SubRegionShowable ) bufferStrategy ; boolean contentsLost = bufferStrategy . contentsLost ( ) ; if ( ! contentsLost ) { bsSubRegion . show ( accumulatedX , accumulatedY , accumulatedMaxX , accumulatedMaxY ) ; contentsLost = bufferStrategy . contentsLost ( ) ; } if ( contentsLost ) { if ( LOGGER . isLoggable ( PlatformLogger . Level . FINER ) ) { LOGGER . finer ( STR_ ) ; } bufferInfo . setInSync ( BOOL_ ) ; success = BOOL_ ; } } resetAccumulated ( ) ; return success ; }
public void testBitLengthPositive1 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; assertEquals ( NUM_ , aNumber . bitLength ( ) ) ; }
public void clearPieSegments ( ) { mPieSegmentList . clear ( ) ; }
@ Override public PatchResult applyPatch ( PatchData patchData ) { String typeName = patchData . getTypeName ( ) ; String applyVersion = patchData . getApplyToVersion ( ) ; TypesDef updatedTypeDef ; PatchResult result ; try { if ( checkIfTypeExists ( typeName , metadataService ) ) { TypesDef typesDef = getTypeDef ( typeName ) ; String currentVersion = getTypeVersion ( typeName ) ; if ( currentVersion == null || currentVersion . equalsIgnoreCase ( applyVersion ) || currentVersion . startsWith ( applyVersion + STR_ ) ) { updatedTypeDef = updateTypesDef ( typesDef , patchData ) ; if ( updatedTypeDef != null ) { metadataService . updateType ( TypesSerialization . toJson ( updatedTypeDef ) ) ; LOG . info ( STR_ + patchData . getTypeName ( ) + STR_ + patchData . getApplyToVersion ( ) + STR_ + patchData . getUpdateToVersion ( ) ) ; result = new PatchResult ( STR_ , PatchStatus . SUCCESS ) ; } else { LOG . error ( STR_ + typeName + STR_ + applyVersion + STR_ + patchData . getUpdateToVersion ( ) ) ; result = new PatchResult ( STR_ , PatchStatus . FAILED ) ; } } else { LOG . info ( STR_ + patchData . getTypeName ( ) ) ; result = new PatchResult ( STR_ , PatchStatus . SKIPPED ) ; } } else { LOG . error ( STR_ + typeName + STR_ + applyVersion + STR_ + patchData . getUpdateToVersion ( ) + STR_ ) ; result = new PatchResult ( STR_ , PatchStatus . FAILED ) ; } } catch ( AtlasException e ) { LOG . error ( STR_ + patchData . getTypeName ( ) ) ; result = new PatchResult ( STR_ , PatchStatus . FAILED ) ; } catch ( JSONException e ) { LOG . error ( STR_ + patchData . getTypeName ( ) ) ; result = new PatchResult ( STR_ , PatchStatus . FAILED ) ; } return result ; }
public static String randomAlphanumerical ( final int len ) { final StringBuilder sb = new StringBuilder ( len ) ; for ( int i = NUM_ ; i < len ; i ++ ) { sb . append ( AB . charAt ( random . nextInt ( AB . length ( ) ) ) ) ; } return sb . toString ( ) ; }
static int svd_imax ( int a , int b ) { return Math . max ( a , b ) ; }
public void actionPerformed ( ActionEvent e ) { Caret c = textArea . getCaret ( ) ; if ( c . getDot ( ) != c . getMark ( ) ) { return ; } RSyntaxDocument doc = ( RSyntaxDocument ) textArea . getDocument ( ) ; doc . readLock ( ) ; try { removeHighlights ( ) ; int line = textArea . getCaretLineNumber ( ) ; Token tokenList = textArea . getTokenListForLine ( line ) ; int dot = c . getDot ( ) ; Token t = RSyntaxUtilities . getTokenAtOffset ( tokenList , dot ) ; if ( t == null || ! isValidType ( t ) || isNonWordChar ( t ) ) { dot -- ; try { if ( dot >= textArea . getLineStartOffset ( line ) ) { t = RSyntaxUtilities . getTokenAtOffset ( tokenList , dot ) ; } } catch ( BadLocationException ble ) { ble . printStackTrace ( ) ; } } if ( t != null && isValidType ( t ) && ! isNonWordChar ( t ) ) { RSyntaxTextAreaHighlighter h = ( RSyntaxTextAreaHighlighter ) textArea . getHighlighter ( ) ; String lexeme = t . getLexeme ( ) ; int type = t . type ; for ( int i = NUM_ ; i < textArea . getLineCount ( ) ; i ++ ) { Token temp = textArea . getTokenListForLine ( i ) ; while ( temp != null && temp . isPaintable ( ) ) { if ( temp . is ( type , lexeme ) ) { try { int end = temp . offset + temp . textCount ; Object tag = h . addMarkedOccurrenceHighlight ( temp . offset , end , p ) ; tags . add ( tag ) ; } catch ( BadLocationException ble ) { ble . printStackTrace ( ) ; } } temp = temp . getNextToken ( ) ; } } } } finally { doc . readUnlock ( ) ; } textArea . fireMarkedOccurrencesChanged ( ) ; }
public boolean restoreAccessibilityFocus ( CalendarDay day ) { if ( ( day . year != mYear ) || ( day . month != mMonth ) || ( day . day > mNumCells ) ) { return BOOL_ ; } mTouchHelper . setFocusedVirtualView ( day . day ) ; return BOOL_ ; }
private boolean isMimeFormat ( long format , String primaryType ) { String nat = getNativeForFormat ( format ) ; if ( nat == null ) { return BOOL_ ; } try { DataFlavor df = new DataFlavor ( nat ) ; if ( primaryType . equals ( df . getPrimaryType ( ) ) ) { return BOOL_ ; } } catch ( Exception e ) { } return BOOL_ ; }
private static String convertRelevance ( int relevance ) { StringBuilder sb = new StringBuilder ( ) ; while ( relevance > NUM_ ) { sb . insert ( NUM_ , REVERSE_CHAR_MAP [ relevance % NUM_ ] ) ; relevance = relevance / NUM_ ; } return sb . toString ( ) ; }
public synchronized AlphabeticIndex addLabels ( Locale locale ) { addLabels ( peer , locale . toString ( ) ) ; return this ; }
public void sort ( ) { Collections . sort ( individuals , PERFORMANCE_COMPARATOR ) ; }
int extractVersionFromFilename ( final File file ) { final Matcher matcher = versionedPattern . matcher ( file . getAbsolutePath ( ) ) ; matcher . find ( ) ; return Integer . parseInt ( matcher . group ( NUM_ ) ) ; }
static int measureChildForCells ( View child , int cellSize , int cellsRemaining , int parentHeightMeasureSpec , int parentHeightPadding ) { final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; final int childHeightSize = MeasureSpec . getSize ( parentHeightMeasureSpec ) - parentHeightPadding ; final int childHeightMode = MeasureSpec . getMode ( parentHeightMeasureSpec ) ; final int childHeightSpec = MeasureSpec . makeMeasureSpec ( childHeightSize , childHeightMode ) ; int cellsUsed = NUM_ ; if ( cellsRemaining > NUM_ ) { final int childWidthSpec = MeasureSpec . makeMeasureSpec ( cellSize . cellsRemaining , MeasureSpec . AT_MOST ) ; child . measure ( childWidthSpec , childHeightSpec ) ; final int measuredWidth = child . getMeasuredWidth ( ) ; cellsUsed = measuredWidth / cellSize ; if ( measuredWidth % cellSize != NUM_ ) cellsUsed ++ ; } final ActionMenuItemView itemView = child instanceof ActionMenuItemView ? ( ActionMenuItemView ) child : null ; final boolean expandable = ! lp . isOverflowButton && itemView != null && itemView . hasText ( ) ; lp . expandable = expandable ; lp . cellsUsed = cellsUsed ; final int targetWidth = cellsUsed . cellSize ; child . measure ( MeasureSpec . makeMeasureSpec ( targetWidth , MeasureSpec . EXACTLY ) , childHeightSpec ) ; return cellsUsed ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; String badString ; doc = ( Document ) load ( STR_ , BOOL_ ) ; elementList = doc . getElementsByTagName ( STR_ ) ; nameNode = elementList . item ( NUM_ ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; { boolean success = BOOL_ ; try { badString = child . substringData ( - NUM_ , NUM_ ) ; } catch ( DOMException ex ) { success = ( ex . code == DOMException . INDEX_SIZE_ERR ) ; } assertTrue ( STR_ , success ) ; } }
private boolean isSpecializedHandlerAvailable ( Intent intent ) { PackageManager pm = mActivity . getPackageManager ( ) ; List < ResolveInfo > handlers = pm . queryIntentActivities ( intent , PackageManager . GET_RESOLVED_FILTER ) ; if ( handlers == null || handlers . size ( ) == NUM_ ) { return BOOL_ ; } for ( ResolveInfo resolveInfo : handlers ) { IntentFilter filter = resolveInfo . filter ; if ( filter == null ) { continue ; } if ( filter . countDataAuthorities ( ) == NUM_ && filter . countDataPaths ( ) == NUM_ ) { continue ; } return BOOL_ ; } return BOOL_ ; }
private void convertError ( CharBuffer buf , int line ) { String srcFilename = null ; int destLine = NUM_ ; int srcLine = NUM_ ; int srcTailLine = Integer . MAX_VALUE ; for ( int i = NUM_ ; i < _lines . size ( ) ; i ++ ) { Line map = ( Line ) _lines . get ( i ) ; if ( map . _dstLine <= line && line <= map . getLastDestinationLine ( ) ) { srcFilename = map . _srcFilename ; destLine = map . _dstLine ; srcLine = map . getSourceLine ( line ) ; break ; } } if ( srcFilename != null ) { } else if ( _lines . size ( ) > NUM_ ) srcFilename = ( ( Line ) _lines . get ( NUM_ ) ) . _srcFilename ; else srcFilename = STR_ ; buf . append ( srcFilename ) ; if ( line >= NUM_ ) { buf . append ( STR_ ) ; buf . append ( srcLine + ( line - destLine ) ) ; } }
public static String slurpGBURLNoExceptions ( URL u ) { try { return slurpGBURL ( u ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } }
public void undo ( ) { if ( ! undoStack . isEmpty ( ) ) { UndoableAction lastEvent = undoStack . pop ( ) ; lastEvent . undo ( ) ; redoStack . push ( lastEvent ) ; } }
private void emitListAdd ( Method method , String fieldName , StringBuilder builder ) { builder . append ( STR_ ) ; builder . append ( getListAdderName ( fieldName ) ) ; builder . append ( STR_ ) ; builder . append ( getTypeArgumentImplName ( ( ParameterizedType ) method . getGenericReturnType ( ) , NUM_ ) ) ; builder . append ( STR_ ) ; builder . append ( getEnsureName ( fieldName ) ) ; builder . append ( STR_ ) ; builder . append ( fieldName ) ; builder . append ( STR_ ) ; builder . append ( STR_ ) ; }
public Pair < SolrCore , SolrCore > replicateToDestination ( SolrCore bestsrcCore , SolrCore destinationCore ) throws Exception { Pair < SolrCore , SolrCore > replicationRequestPair = null ; try { SolrInteractionUtils . replicateIndex ( destinationCore . host , destinationCore . name , bestsrcCore . host , bestsrcCore . name ) ; String fullReplication = STR_ ; String replicator = String . format ( fullReplication , destinationCore . host , SolrInteractionUtils . DEFAULT_SOLR_PORT , destinationCore . name , bestsrcCore . host , SolrInteractionUtils . DEFAULT_SOLR_PORT , bestsrcCore . name ) ; logger . info ( STR_ + replicator ) ; replicationRequestPair = new Pair < SolrCore , SolrCore > ( destinationCore , bestsrcCore ) ; logger . info ( STR_ + destinationCore . host + STR_ + destinationCore . name + STR_ + bestsrcCore . host + STR_ + bestsrcCore . name ) ; } catch ( Exception e ) { logger . info ( STR_ + destinationCore . host + STR_ + bestsrcCore . host ) ; if ( ! replicatorConfig . shouldSkipReplicationFailures ( ) ) { throw new ReplicationFailureException ( STR_ + destinationCore . host + STR_ + bestsrcCore . host ) ; } } return replicationRequestPair ; }
public static OSType calculateOS ( ) { String osName = System . getProperty ( STR_ ) ; osName = osName . toLowerCase ( Locale . ENGLISH ) ; if ( osName . startsWith ( STR_ ) ) { return OSType . APPLE ; } if ( osName . startsWith ( STR_ ) ) { return OSType . WINDOWS ; } if ( osName . startsWith ( STR_ ) ) { return OSType . LINUX ; } if ( osName . startsWith ( STR_ ) ) { return OSType . SUN ; } return OSType . UNKNOWN ; }
private static int countDuplicates ( StackTraceElement [ ] currentStack , StackTraceElement [ ] parentStack ) { int duplicates = NUM_ ; int parentIndex = parentStack . length ; for ( int i = currentStack . length ; -- i >= NUM_ && -- parentIndex >= NUM_ ; ) { StackTraceElement parentFrame = parentStack [ parentIndex ] ; if ( parentFrame . equals ( currentStack [ i ] ) ) { duplicates ++ ; } else { break ; } } return duplicates ; }
public void recycle ( ) { synchronized ( sPool ) { if ( sPool . size ( ) < MAX_POOL_SIZE ) { sPool . add ( this ) ; } } }
private String buildInsert ( boolean disableReturning ) { sb . setLength ( NUM_ ) ; sb . append ( STR_ ) ; appendTable ( sb ) ; sb . append ( STR_ ) ; sb . append ( options . keyColumnName ) ; sb . append ( STR_ ) ; if ( options . doctypeColumnName != null ) { sb . append ( options . doctypeColumnName ) ; sb . append ( STR_ ) ; } sb . append ( options . contentColumnName ) ; sb . append ( STR_ ) ; if ( options . timestampColumnName != null ) { sb . append ( STR_ ) ; sb . append ( options . timestampColumnName ) ; sb . append ( STR_ ) ; } if ( options . creationColumnName != null ) { sb . append ( STR_ ) ; sb . append ( options . creationColumnName ) ; sb . append ( STR_ ) ; } if ( ( options . versionColumnName != null ) && ( options . versioningMethod ) != CollectionDescriptor . VERSION_NONE ) { sb . append ( STR_ ) ; sb . append ( options . versionColumnName ) ; sb . append ( STR_ ) ; } sb . append ( STR_ ) ; if ( ( options . keySequenceName != null ) && ( ! disableReturning ) ) { switch ( options . keyDataType ) { case CollectionDescriptor . INTEGER_KEY : sb . append ( STR_ ) ; sb . append ( options . keySequenceName ) ; sb . append ( STR_ ) ; break ; case CollectionDescriptor . RAW_KEY : sb . append ( STR_ ) ; sb . append ( options . keySequenceName ) ; sb . append ( STR_ ) ; break ; case CollectionDescriptor . STRING_KEY : case CollectionDescriptor . NCHAR_KEY : default : sb . append ( STR_ ) ; sb . append ( options . keySequenceName ) ; sb . append ( STR_ ) ; break ; } } else if ( ( options . keyAssignmentMethod == CollectionDescriptor . KEY_ASSIGN_GUID ) && ( ! disableReturning ) ) { switch ( options . keyDataType ) { case CollectionDescriptor . INTEGER_KEY : sb . append ( STR_ ) ; sb . append ( STR_ ) ; sb . append ( STR_ ) ; break ; case CollectionDescriptor . RAW_KEY : sb . append ( STR_ ) ; break ; case CollectionDescriptor . STRING_KEY : case CollectionDescriptor . NCHAR_KEY : default : sb . append ( STR_ ) ; break ; } } else { addKey ( sb ) ; } if ( options . doctypeColumnName != null ) { sb . append ( STR_ ) ; } sb . append ( STR_ ) ; if ( options . timestampColumnName != null ) { if ( disableReturning ) OracleDatabaseImpl . addToTimestamp ( STR_ , sb ) ; else sb . append ( STR_ ) ; } if ( options . creationColumnName != null ) { if ( disableReturning ) OracleDatabaseImpl . addToTimestamp ( STR_ , sb ) ; else sb . append ( STR_ ) ; } if ( ( options . versionColumnName != null ) && ( options . versioningMethod ) != CollectionDescriptor . VERSION_NONE ) sb . append ( STR_ ) ; sb . append ( STR_ ) ; if ( insertHasReturnClause ( disableReturning ) ) { sb . append ( STR_ ) ; int count = NUM_ ; if ( returnInsertedKey ( ) ) { sb . append ( STR_ ) ; sb . append ( options . keyColumnName ) ; sb . append ( STR_ ) ; count ++ ; } if ( returnInsertedTime ( ) ) { addComma ( sb , count ) ; sb . append ( STR_ ) ; if ( options . timestampColumnName != null ) sb . append ( options . timestampColumnName ) ; else sb . append ( options . creationColumnName ) ; sb . append ( STR_ ) ; OracleDatabaseImpl . addTimestampReturningFormat ( sb ) ; count ++ ; } if ( returnInsertedVersion ( ) ) { addComma ( sb , count ) ; sb . append ( STR_ ) ; sb . append ( options . versionColumnName ) ; sb . append ( STR_ ) ; count ++ ; } addInto ( sb , count ) ; } return ( sb . toString ( ) ) ; }
public final boolean exists ( ) { return config != null ; }
@ Override public synchronized void removeTestSetListener ( TestSetListener tsl ) { m_testListeners . removeElement ( tsl ) ; }
private boolean has_colinear ( ArrayList < PlaPointInt > corners_list , PlaPointInt a_point ) { int count = corners_list . size ( ) ; if ( count < NUM_ ) return BOOL_ ; for ( int index = NUM_ ; index < count - NUM_ ; index ++ ) { PlaPointInt start = corners_list . get ( index ) ; PlaPointInt end = corners_list . get ( index + NUM_ ) ; if ( a_point . side_of ( start , end ) != PlaSide . COLLINEAR ) continue ; double d_start_p = start . distance_square ( a_point ) ; double d_p_end = a_point . distance_square ( end ) ; double d_start_end = start . distance_square ( end ) ; if ( d_start_end >= d_start_p ) { if ( d_start_end >= d_p_end ) { return BOOL_ ; } else { corners_list . set ( index , a_point ) ; return BOOL_ ; } } else { if ( d_start_end >= d_p_end ) { corners_list . set ( index + NUM_ , a_point ) ; return BOOL_ ; } else { corners_list . set ( index , a_point ) ; return BOOL_ ; } } } return BOOL_ ; }
public boolean contains ( String key ) { return myProperties . containsKey ( key ) ; }
protected SnmpCachedData updateCachedDatas ( Object userData ) { final String [ ] path = JvmRuntimeImpl . getLibraryPath ( userData ) ; final long time = System . currentTimeMillis ( ) ; final int len = path . length ; SnmpOid indexes [ ] = new SnmpOid [ len ] ; for ( int i = NUM_ ; i < len ; i ++ ) { indexes [ i ] = new SnmpOid ( i + NUM_ ) ; } return new SnmpCachedData ( time , indexes , path ) ; }
public static byte [ ] decodeHex ( String hexString ) { int length = hexString . length ( ) ; if ( ( length & x01 ) != NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } boolean badHex = BOOL_ ; byte [ ] out = new byte [ length > > NUM_ ] ; for ( int i = NUM_ , j = NUM_ ; j < length ; i ++ ) { int c1 = hexString . charAt ( j ++ ) ; if ( c1 > STR_ ) { badHex = BOOL_ ; break ; } final byte d1 = DIGITS [ c1 ] ; if ( d1 == - NUM_ ) { badHex = BOOL_ ; break ; } int c2 = hexString . charAt ( j ++ ) ; if ( c2 > STR_ ) { badHex = BOOL_ ; break ; } final byte d2 = DIGITS [ c2 ] ; if ( d2 == - NUM_ ) { badHex = BOOL_ ; break ; } out [ i ] = ( byte ) ( d1 << NUM_ | d2 ) ; } if ( badHex ) { throw new IllegalArgumentException ( STR_ + hexString ) ; } return out ; }
public static void deletePlayer ( PlayerAccountData accData ) { if ( accData . getDeletionDate ( ) != null ) { return ; } accData . setDeletionDate ( new Timestamp ( System . currentTimeMillis ( ) + NUM_ . NUM_ . NUM_ ) ) ; storeDeletionTime ( accData ) ; }
public int eval ( INode state ) { EightPuzzleNode node = ( EightPuzzleNode ) state ; int Pn = NUM_ ; for ( int r = NUM_ ; r <= EightPuzzleNode . MaxR ; r ++ ) { for ( int c = NUM_ ; c <= EightPuzzleNode . MaxC ; c ++ ) { if ( node . isEmpty ( r , c ) ) { continue ; } int digit = node . cell ( r , c ) ; Pn += Math . abs ( diffs [ digit ] [ NUM_ ] - r ) ; Pn += Math . abs ( diffs [ digit ] [ NUM_ ] - c ) ; } } int Sn = NUM_ ; if ( ! node . isEmpty ( NUM_ , NUM_ ) ) { Sn = NUM_ ; } for ( int r = NUM_ ; r <= EightPuzzleNode . MaxR ; r ++ ) { for ( int c = NUM_ ; c <= EightPuzzleNode . MaxC ; c ++ ) { int idx = r . NUM_ + c ; if ( r == NUM_ && c == NUM_ ) { continue ; } if ( node . cell ( r , c ) == EightPuzzleNode . EmptyMark ) { continue ; } if ( succ [ node . cell ( r , c ) ] != node . cell ( succs [ idx ] [ NUM_ ] , succs [ idx ] [ NUM_ ] ) ) { Sn += NUM_ ; } } } int gn = NUM_ ; DepthTransition t = ( DepthTransition ) state . storedData ( ) ; if ( t != null ) { gn = t . depth ; } return gn + Pn + NUM_ . Sn ; }
public void testBuffered ( ) { Instances icopy = new Instances ( m_Instances ) ; Instances result = null ; try { m_Filter . setInputFormat ( icopy ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; fail ( STR_ + ex . getMessage ( ) ) ; } try { result = Filter . useFilter ( icopy , m_Filter ) ; assertNotNull ( result ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; fail ( STR_ + ex . getMessage ( ) ) ; } StringWriter sw = new StringWriter ( NUM_ ) ; sw . write ( result . toString ( ) ) ; assertTrue ( icopy . equalHeaders ( m_Instances ) ) ; assertEquals ( icopy . numInstances ( ) , m_Instances . numInstances ( ) ) ; Instances result2 = null ; try { m_Filter . setInputFormat ( icopy ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; fail ( STR_ + ex . getMessage ( ) ) ; } try { result2 = Filter . useFilter ( icopy , m_Filter ) ; assertNotNull ( result2 ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; fail ( STR_ + ex . getMessage ( ) ) ; } assertTrue ( icopy . equalHeaders ( m_Instances ) ) ; assertEquals ( icopy . numInstances ( ) , m_Instances . numInstances ( ) ) ; assertTrue ( result . equalHeaders ( result2 ) ) ; assertEquals ( result . numInstances ( ) , result2 . numInstances ( ) ) ; }
private String parseCss ( final String css ) { final Map < String , String > map = new HashMap < String , String > ( ) ; final StringBuffer sb = new StringBuffer ( ) ; final Matcher m = PATTERN_VARIABLES_DEFINITION . matcher ( css ) ; while ( m . find ( ) ) { final String variablesBody = m . group ( NUM_ ) ; map . putAll ( extractVariables ( variablesBody ) ) ; m . appendReplacement ( sb , STR_ ) ; } m . appendTail ( sb ) ; return replaceVariables ( sb . toString ( ) , map ) ; }
private void shutdown ( ) { if ( execSvc != null ) execSvc . shutdown ( NUM_ ) ; if ( msgExecSvc != null ) msgExecSvc . shutdownNow ( ) ; try { job . dispose ( BOOL_ ) ; } catch ( IgniteCheckedException e ) { U . error ( log , STR_ , e ) ; } }
public void startCDATA ( ) throws org . xml . sax . SAXException { m_inCData = BOOL_ ; append ( m_doc . createCDATASection ( STR_ ) ) ; }
public void addAll ( List < Fragment > aSplits ) { splits . addAll ( aSplits ) ; }
protected synchronized int currentchunkoffset ( ) throws IOException { long fp = backingRandomAccessFile . getFilePointer ( ) ; if ( fp < fHeader . headerSize ( ) ) { return - NUM_ ; } else { fp -= fHeader . headerSize ( ) ; if ( fp == NUM_ ) { return NUM_ ; } else { return ( int ) ( ( fp % CHUNK_ENC_SIZE ) - CHUNK_IV_SIZE ) ; } } }
private int parseIntValue ( String input ) throws NumberFormatException { int value = NUM_ ; if ( input . startsWith ( STR_ ) ) { String temp = input . substring ( NUM_ ) ; return Integer . parseInt ( temp ) ; } else if ( input . startsWith ( STR_ ) ) { String temp = input . substring ( NUM_ ) ; char [ ] chars = temp . toCharArray ( ) ; if ( chars . length > NUM_ ) { throw new NumberFormatException ( ) ; } else { for ( int i = NUM_ ; i < chars . length ; i ++ ) { int index = chars . length - i - NUM_ ; switch ( chars [ i ] ) { case STR_ : value += NUM_ ; break ; case STR_ : value += NUM_ . getBase ( index ) ; break ; case STR_ : value += NUM_ . getBase ( index ) ; break ; case STR_ : value += NUM_ . getBase ( index ) ; break ; case STR_ : value += NUM_ . getBase ( index ) ; break ; case STR_ : value += NUM_ . getBase ( index ) ; break ; case STR_ : value += NUM_ . getBase ( index ) ; break ; case STR_ : value += NUM_ . getBase ( index ) ; break ; case STR_ : value += NUM_ . getBase ( index ) ; break ; case STR_ : value += NUM_ . getBase ( index ) ; break ; case STR_ : case STR_ : value += NUM_ . getBase ( index ) ; break ; case STR_ : case STR_ : value += NUM_ . getBase ( index ) ; break ; case STR_ : case STR_ : value += NUM_ . getBase ( index ) ; break ; case STR_ : case STR_ : value += NUM_ . getBase ( index ) ; break ; case STR_ : case STR_ : value += NUM_ . getBase ( index ) ; break ; case STR_ : case STR_ : value += NUM_ . getBase ( index ) ; break ; default : throw new NumberFormatException ( STR_ ) ; } } } if ( value < NUM_ ) { throw new NumberFormatException ( STR_ ) ; } } else { value = Integer . parseInt ( input ) ; } return value ; }
protected int decodeLinePrefix ( PushbackInputStream aStream , OutputStream bStream ) throws IOException { return ( bytesPerLine ( ) ) ; }
private static LookupLocator [ ] unmarshalLocators ( ObjectInputStream in ) throws IOException , ClassNotFoundException { List l = new ArrayList ( ) ; MarshalledInstance mi ; while ( ( mi = ( MarshalledInstance ) in . readObject ( ) ) != null ) { try { l . add ( ( LookupLocator ) mi . get ( BOOL_ ) ) ; } catch ( Throwable e ) { if ( e instanceof Error && ThrowableConstants . retryable ( e ) == ThrowableConstants . BAD_OBJECT ) { throw ( Error ) e ; } logger . log ( Level . WARNING , STR_ , e ) ; } } return ( LookupLocator [ ] ) l . toArray ( new LookupLocator [ l . size ( ) ] ) ; }
public void accept ( final AnnotationVisitor av ) { if ( av != null ) { if ( values != null ) { for ( int i = NUM_ ; i < values . size ( ) ; i += NUM_ ) { String name = ( String ) values . get ( i ) ; Object value = values . get ( i + NUM_ ) ; accept ( av , name , value ) ; } } av . visitEnd ( ) ; } }
static public String numberToString ( Number n ) throws JSONException { if ( n == null ) { throw new JSONException ( STR_ ) ; } testValidity ( n ) ; String s = n . toString ( ) ; if ( s . indexOf ( STR_ ) > NUM_ && s . indexOf ( STR_ ) < NUM_ && s . indexOf ( STR_ ) < NUM_ ) { while ( s . endsWith ( STR_ ) ) { s = s . substring ( NUM_ , s . length ( ) - NUM_ ) ; } if ( s . endsWith ( STR_ ) ) { s = s . substring ( NUM_ , s . length ( ) - NUM_ ) ; } } return s ; }
public int children ( ) { return children . size ( ) ; }
public void createVVset ( String displayName ) throws Exception { _log . info ( STR_ ) ; ClientResponse clientResp = null ; String payload = STR_ + displayName + STR_ ; _log . info ( STR_ , URI_CREATE_CG . toString ( ) , payload ) ; try { clientResp = post ( URI_CREATE_CG , payload ) ; if ( clientResp == null ) { _log . error ( STR_ ) ; throw new HP3PARException ( STR_ ) ; } else if ( clientResp . getStatus ( ) != NUM_ ) { String errResp = getResponseDetails ( clientResp ) ; _log . error ( STR_ , errResp ) ; throw new HP3PARException ( errResp ) ; } else { _log . info ( STR_ ) ; } } catch ( Exception e ) { throw e ; } finally { if ( clientResp != null ) { clientResp . close ( ) ; } _log . info ( STR_ ) ; } }
protected void connectionFailed ( Channel failedChannel , IOException cause ) { failureCause = IOExceptionSupport . create ( cause ) ; channel = failedChannel ; connected . set ( BOOL_ ) ; handshakeFuture . setFailure ( cause ) ; }
public static byte [ ] splitUint8To2bytes ( char uint8 ) { if ( uint8 < NUM_ || uint8 > xff ) { throw new RuntimeException ( STR_ ) ; } String hexString = Integer . toHexString ( uint8 ) ; byte low ; byte high ; if ( hexString . length ( ) > NUM_ ) { high = ( byte ) Integer . parseInt ( hexString . substring ( NUM_ , NUM_ ) , NUM_ ) ; low = ( byte ) Integer . parseInt ( hexString . substring ( NUM_ , NUM_ ) , NUM_ ) ; } else { high = NUM_ ; low = ( byte ) Integer . parseInt ( hexString . substring ( NUM_ , NUM_ ) , NUM_ ) ; } byte [ ] result = new byte [ ] { high , low } ; return result ; }
public void write ( int c ) throws IOException { internalOut . write ( c ) ; }
public static void init ( Context context ) { if ( cameraManager == null ) { cameraManager = new CameraManager ( context ) ; } }
public void addAttribute ( String uri , String localName , String rawName , String type , String value , boolean XSLAttribute ) throws SAXException { if ( m_elemContext . m_startTagOpen ) { ensurePrefixIsDeclared ( uri , rawName ) ; addAttributeAlways ( uri , localName , rawName , type , value , BOOL_ ) ; } }
private String markdownBlockquote ( String value ) { return STR_ + value . replace ( STR_ , STR_ ) ; }
protected String hash ( String key ) { try { MessageDigest gen = HASH_GENERATOR . get ( ) ; byte [ ] keyBytes = key . getBytes ( STR_ ) ; gen . update ( keyBytes , NUM_ , keyBytes . length ) ; byte [ ] binaryhash = gen . digest ( ) ; return ENCODER . encodeToString ( binaryhash ) ; } catch ( Exception e ) { LOG . warn ( STR_ , key , e ) ; } return null ; }
public static boolean isInputType ( String typeString ) { return INPUT_TYPES . contains ( typeString ) ; }
public static Point destination ( Point point1 , double distance , double bearing , String units ) throws TurfException { double degrees2radians = Math . PI / NUM_ ; double radians2degrees = NUM_ / Math . PI ; Position coordinates1 = point1 . getCoordinates ( ) ; double longitude1 = degrees2radians . coordinates1 . getLongitude ( ) ; double latitude1 = degrees2radians . coordinates1 . getLatitude ( ) ; double bearingRad = degrees2radians . bearing ; double radians = TurfHelpers . distanceToRadians ( distance , units ) ; double latitude2 = Math . asin ( Math . sin ( latitude1 ) . Math . cos ( radians ) + Math . cos ( latitude1 ) . Math . sin ( radians ) . Math . cos ( bearingRad ) ) ; double longitude2 = longitude1 + Math . atan2 ( Math . sin ( bearingRad ) . Math . sin ( radians ) . Math . cos ( latitude1 ) , Math . cos ( radians ) - Math . sin ( latitude1 ) . Math . sin ( latitude2 ) ) ; return Point . fromCoordinates ( Position . fromCoordinates ( radians2degrees . longitude2 , radians2degrees . latitude2 ) ) ; }
public void clear ( ) { synchronized ( mLock ) { mGraphics . clear ( ) ; mFirstGraphic = null ; } postInvalidate ( ) ; }
@ SuppressWarnings ( STR_ ) public NodePanel ( ShaderNodeVariable singleOut , NodePanel . NodeType type ) { super ( ) ; List < ShaderNodeVariable > outputs = new ArrayList < ShaderNodeVariable > ( ) ; outputs . add ( singleOut ) ; this . type = type ; init ( new ArrayList < ShaderNodeVariable > ( ) , outputs ) ; addKeyListener ( this ) ; toolBar = new NodeToolBar ( this ) ; }
public static String stringifyException ( Throwable e ) { StringWriter stm = new StringWriter ( ) ; PrintWriter wrt = new PrintWriter ( stm ) ; e . printStackTrace ( wrt ) ; wrt . close ( ) ; return stm . toString ( ) ; }
public static boolean isSolaris ( ) { return ( OS . indexOf ( STR_ ) >= NUM_ ) ; }
public double SumInlinkHubScore ( Page page ) { List < String > inLinks = page . getInlinks ( ) ; double hubScore = NUM_ ; for ( int i = NUM_ ; i < inLinks . size ( ) ; i ++ ) { Page inLink = pTable . get ( inLinks . get ( i ) ) ; if ( inLink != null ) { hubScore += inLink . hub ; } else { continue ; } } return hubScore ; }
@ Override public void addUndoPoint ( ) { File tempFile ; ObjectOutputStream oos ; if ( ! isUndoEnabled ( ) ) { return ; } if ( getInstances ( ) != null ) { try { tempFile = File . createTempFile ( STR_ , null ) ; tempFile . deleteOnExit ( ) ; oos = new ObjectOutputStream ( new BufferedOutputStream ( new FileOutputStream ( tempFile ) ) ) ; oos . writeObject ( getInstances ( ) ) ; oos . flush ( ) ; oos . close ( ) ; m_UndoList . add ( tempFile ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
private void clipViewOnTheRight ( Rect curViewBound , float curViewWidth , int right ) { curViewBound . right = ( int ) ( right - mClipPadding ) ; curViewBound . left = ( int ) ( curViewBound . right - curViewWidth ) ; }
private void preserveParentLink ( String brokenTableName , String brokenColumnName , String brokenDefaultValue , ArrayList < String > brokenCompareColumns , String hintTableName , String hintColumnName , ArrayList < String > hintCompareColumns ) { String vendorName = m_target . getVendor ( ) ; String catalogName = m_target . getCatalog ( ) ; String schemaName = m_target . getSchema ( ) ; if ( m_source . isObjectExists ( brokenTableName , m_source . getTables ( ) ) ) { boolean columnToPreserveLinkExists = BOOL_ ; DBObject tableToPreserveLink = m_source . getObjectByName ( brokenTableName , m_source . getTables ( ) ) ; HashMap < Integer , DBObjectDefinition > columns = tableToPreserveLink . getContents ( ) ; Vector < Integer > vc = new Vector < Integer > ( columns . keySet ( ) ) ; for ( Iterator < Integer > ic = vc . iterator ( ) ; ic . hasNext ( ) ; ) { int kc = ic . next ( ) ; DBObject_Table_Column columnDetail = ( DBObject_Table_Column ) columns . get ( kc ) ; String columnName = columnDetail . getName ( ) ; if ( columnName . equalsIgnoreCase ( brokenColumnName ) ) columnToPreserveLinkExists = BOOL_ ; } if ( columnToPreserveLinkExists ) { s_logger . log ( Level . FINE , STR_ , new Object [ ] { m_objectType , brokenTableName , m_direction } ) ; String sqlCommand = s_dbEngine . sqlAction_preserveParentLinks ( vendorName , catalogName , schemaName , brokenTableName , brokenColumnName , brokenDefaultValue , brokenCompareColumns , hintTableName , hintColumnName , hintCompareColumns ) ; if ( sqlCommand != null ) { Savepoint sp = m_target . setSavepoint ( STR_ ) ; Statement stmt = m_target . setStatement ( ) ; Integer sqlResult = m_target . executeUpdate ( stmt , sqlCommand , BOOL_ , BOOL_ ) ; if ( sqlResult != null ) { logUpdateDetail ( sqlResult , null ) ; m_counterUpd = new Integer ( m_counterUpd . intValue ( ) + NUM_ ) ; } m_target . releaseStatement ( stmt ) ; m_totalUpd = new Integer ( m_totalUpd . intValue ( ) + NUM_ ) ; m_target . releaseSavepoint ( sp ) ; } } } }
public ShortBandedRaster ( SampleModel sampleModel , DataBuffer dataBuffer , Point origin ) { this ( sampleModel , dataBuffer , new Rectangle ( origin . x , origin . y , sampleModel . getWidth ( ) , sampleModel . getHeight ( ) ) , origin , null ) ; }
public void remapMappedTypes ( ) { clearMappedTypes ( ) ; mapPossibleTypes ( mItems ) ; }
public int numChildren ( int row ) { int count = NUM_ ; nextValidRowPositions . clear ( ) ; for ( int i = NUM_ ; i < n ; i ++ ) { board [ row ] [ i ] = BOOL_ ; if ( valid ( row , i ) ) { count ++ ; nextValidRowPositions . add ( i ) ; } board [ row ] [ i ] = BOOL_ ; } return count ; }
public void testNegNegSameLength ( ) { String numA = STR_ ; String numB = STR_ ; String res = STR_ ; BigInteger aNumber = new BigInteger ( numA ) ; BigInteger bNumber = new BigInteger ( numB ) ; BigInteger result = aNumber . xor ( bNumber ) ; assertTrue ( res . equals ( result . toString ( ) ) ) ; }
public static IJavaSearchScope createRelatedProjectsScope ( IJavaProject project , int includeMask ) throws CoreException { IJavaProject [ ] projects = getRelatedProjects ( project ) ; return SearchEngine . createJavaSearchScope ( projects , includeMask ) ; }
public Confirmation ( ) { this ( null , null ) ; }
public VcsRevisionNumber originalRevision ( int lineNumber ) { return getLineRevisionNumber ( lineNumber ) ; }
private void checkPausedOrCanceled ( State state ) throws StopRequest { if ( mService . getControl ( ) == DownloaderService . CONTROL_PAUSED ) { int status = mService . getStatus ( ) ; switch ( status ) { case DownloaderService . STATUS_PAUSED_BY_APP : throw new StopRequest ( mService . getStatus ( ) , STR_ ) ; } } }
void trace ( ) { glUseProgram ( computeProgram ) ; invProjMatrix . transformProject ( tmpVector . set ( - NUM_ , - NUM_ , NUM_ ) ) ; glUniform3f ( ray00Uniform , tmpVector . x , tmpVector . y , tmpVector . z ) ; invProjMatrix . transformProject ( tmpVector . set ( - NUM_ , NUM_ , NUM_ ) ) ; glUniform3f ( ray01Uniform , tmpVector . x , tmpVector . y , tmpVector . z ) ; invProjMatrix . transformProject ( tmpVector . set ( NUM_ , - NUM_ , NUM_ ) ) ; glUniform3f ( ray10Uniform , tmpVector . x , tmpVector . y , tmpVector . z ) ; invProjMatrix . transformProject ( tmpVector . set ( NUM_ , NUM_ , NUM_ ) ) ; glUniform3f ( ray11Uniform , tmpVector . x , tmpVector . y , tmpVector . z ) ; glBindBufferBase ( GL_SHADER_STORAGE_BUFFER , trianglesSsboBinding , ssbo ) ; glBindImageTexture ( framebufferImageBinding , raytraceTexture , NUM_ , BOOL_ , NUM_ , GL_WRITE_ONLY , GL_RGBA8 ) ; int worksizeX = mathRoundPoT ( width ) ; int worksizeY = mathRoundPoT ( height ) ; glDispatchCompute ( worksizeX / workGroupSizeX , worksizeY / workGroupSizeY , NUM_ ) ; glMemoryBarrier ( GL_SHADER_IMAGE_ACCESS_BARRIER_BIT ) ; glBindImageTexture ( framebufferImageBinding , NUM_ , NUM_ , BOOL_ , NUM_ , GL_WRITE_ONLY , GL_RGBA8 ) ; glBindBufferBase ( GL_SHADER_STORAGE_BUFFER , trianglesSsboBinding , NUM_ ) ; glUseProgram ( NUM_ ) ; }
public void removeAllActionFireListeners ( ) { mActionFiredListeners . clear ( ) ; }
public static String millisToString ( long millis ) { boolean negative = millis < NUM_ ; millis = Math . abs ( millis ) ; millis /= NUM_ ; int sec = ( int ) ( millis % NUM_ ) ; millis /= NUM_ ; int min = ( int ) ( millis % NUM_ ) ; millis /= NUM_ ; int hours = ( int ) millis ; String time ; DecimalFormat format = ( DecimalFormat ) NumberFormat . getInstance ( Locale . US ) ; format . applyPattern ( STR_ ) ; if ( millis > NUM_ ) { time = ( negative ? STR_ : STR_ ) + hours + STR_ + format . format ( min ) + STR_ + format . format ( sec ) ; } else { time = ( negative ? STR_ : STR_ ) + min + STR_ + format . format ( sec ) ; } return time ; }
@ Inline public static void toUTF8 ( String s , ByteBuffer b ) { int result_index = NUM_ ; for ( int i = NUM_ , n = s . length ( ) ; i < n ; ++ i ) { char c = s . charAt ( i ) ; if ( ( ( ! WRITE_PSEUDO_UTF8 ) || ( c >= x0001 ) ) && ( c <= x007F ) ) { b . put ( ( byte ) c ) ; } else if ( c > x07FF ) { b . put ( ( byte ) ( xe0 | ( byte ) ( c > > NUM_ ) ) ) ; b . put ( ( byte ) ( x80 | ( ( c & xfc0 ) > > NUM_ ) ) ) ; b . put ( ( byte ) ( x80 | ( c & x3f ) ) ) ; } else { b . put ( ( byte ) ( xc0 | ( byte ) ( c > > NUM_ ) ) ) ; b . put ( ( byte ) ( x80 | ( c & x3f ) ) ) ; } } }
public CopyOnWriteArrayList ( E [ ] toCopyIn ) { setArray ( Arrays . copyOf ( toCopyIn , toCopyIn . length , Object [ ] . class ) ) ; }
@ Override public StringBuffer format ( long number , StringBuffer toAppendTo , FieldPosition pos ) { return toAppendTo . append ( getDirectionCode ( number ) ) ; }
public static void main ( String [ ] args ) throws Exception { digestCommandLineArguments ( args ) ; boolean inHeadlessMode = GraphicsEnvironment . isHeadless ( ) ; boolean inConvertMode = isinConvertMode ( ) ; SCXMLGraphEditor editor = startEditor ( inConvertMode || inHeadlessMode ) ; if ( isinConvertMode ( ) ) { SCXMLEditorActions . convertNoGUI ( editor ) ; } else if ( ! inHeadlessMode ) { String input = getPresetInput ( ) ; if ( ! StringUtils . isEmptyString ( input ) ) { OpenAction open = new OpenAction ( new File ( input ) ) ; open . actionPerformed ( new ActionEvent ( editor , NUM_ , STR_ ) ) ; } } }
public void testEqualsUnequal2 ( ) { String a = STR_ ; int aScale = - NUM_ ; String b = STR_ ; int bScale = NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal bNumber = new BigDecimal ( new BigInteger ( b ) , bScale ) ; assertFalse ( aNumber . equals ( bNumber ) ) ; }
protected void enableRetransmissionTimer ( int tickCount ) { if ( isInviteTransaction ( ) && ( this instanceof SIPClientTransaction ) ) { retransmissionTimerTicksLeft = tickCount ; } else { retransmissionTimerTicksLeft = Math . min ( tickCount , getTimerT2 ( ) ) ; } retransmissionTimerLastTickCount = retransmissionTimerTicksLeft ; }
private void scheduleMsgForAllConsumers ( JetstreamMessage msg ) { if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( STR_ + msg . toString ( ) ) ; EventConsumerInfo info = null ; ArrayList < LinkedList < Selection > > weightedList = m_eventTopicRegistry . get ( msg . getTopic ( ) ) ; if ( weightedList != null ) { Iterator < LinkedList < Selection > > weightedItr = weightedList . iterator ( ) ; while ( weightedItr . hasNext ( ) ) { LinkedList < Selection > consumerList = weightedItr . next ( ) ; Iterator < Selection > itr = consumerList . iterator ( ) ; while ( itr . hasNext ( ) ) { info = ( EventConsumerInfo ) itr . next ( ) ; if ( info == null ) continue ; dispatch ( info , msg ) ; } } } else { if ( m_advisoryListener != null ) { postResendAdvisory ( msg ) ; m_noConsumerAdvisories . increment ( ) ; } else { m_totalMsgsDropped . increment ( ) ; m_dropsForNoConsumer . increment ( ) ; } } }
@ Override public Void visitDeclared ( AnnotatedDeclaredType declaredType , Void aVoid ) { if ( pause ) { return null ; } parents . push ( declaredType ) ; super . visitDeclared ( declaredType , aVoid ) ; parents . pop ( ) ; return null ; }
public Class create ( ) { setUseCache ( BOOL_ ) ; return ( Class ) super . create ( this ) ; }
public static < T > List < T > tuple ( T ... objects ) { return Collections . unmodifiableList ( list ( objects ) ) ; }
protected static Set stringArrayToSet ( String [ ] strs ) { int count = strs . length ; Set set = ( ( count > NUM_ ) ? new HashSet ( count ) : new HashSet ( ) ) ; for ( int i = NUM_ ; i < count ; i ++ ) { set . add ( strs [ i ] ) ; } return set ; }
public boolean authenticate ( final OddCallback < AuthToken > callback ) { synchronized ( syncLock ) { if ( isExpired ( ) ) { return BOOL_ ; } if ( ! authenticating ) { authenticating = BOOL_ ; timer = new Timer ( ) ; TimerTask task = getPollTask ( callback ) ; timer . schedule ( task , new Date ( ) , interval ) ; TimerTask expiredTask = getExpiredTask ( callback ) ; timer . schedule ( expiredTask , expirationDate ) ; } return BOOL_ ; } }
public static void cancelNotificationsForRoomId ( String accountId , String roomId ) { Log . d ( LOG_TAG , STR_ + accountId + STR_ + roomId ) ; if ( null != mActiveEventStreamService ) { mActiveEventStreamService . cancelNotifications ( accountId , roomId ) ; } }
public static Optional < PlayerProfile > lookup ( UUID id ) { if ( Bukkit . getPlayer ( id ) != null ) { return Optional . of ( fromPlayer ( Bukkit . getPlayer ( id ) ) ) ; } return lookupProperties ( id ) ; }
static double svd_dmin ( double a , double b ) { return Math . min ( a , b ) ; }
private StoragePort selectStoragePort ( List < StoragePort > spList ) { Collections . shuffle ( spList ) ; return spList . get ( NUM_ ) ; }
private void assimilateContext ( NestingException nestingException ) { Enumeration < ExceptionContext > enumExeptions = nestingException . getExceptionContexts ( ) ; if ( enumExeptions . hasMoreElements ( ) ) { while ( enumExeptions . hasMoreElements ( ) ) { addExceptionContext ( enumExeptions . nextElement ( ) ) ; } nestingException . clearContexts ( ) ; } }
public boolean equals ( Object o ) { if ( o instanceof AMIdentitySubject ) { AMIdentitySubject subject = ( AMIdentitySubject ) o ; return ( subjectValues . equals ( subject . subjectValues ) ) ; } return ( BOOL_ ) ; }
public void updateKeyinfo ( String realm , String entityName , Map < String , Set < String > > extValues , Map < String , Set < String > > stdValues , boolean isIDP ) throws AMConsoleException { String keysize = getResult ( stdValues , TF_KEY_NAME ) ; String algorithm = getResult ( stdValues , TF_ALGORITHM ) ; Set < String > signingCertAliases ; Set < String > encryptionCertAliases ; if ( isIDP ) { encryptionCertAliases = extValues . get ( IDP_ENCRYPT_CERT_ALIAS ) ; signingCertAliases = extValues . get ( IDP_SIGN_CERT_ALIAS ) ; } else { encryptionCertAliases = extValues . get ( SP_ENCRYPT_CERT_ALIAS ) ; signingCertAliases = extValues . get ( SP_SIGN_CERT_ALIAS ) ; } int keysi = ! StringUtils . isEmpty ( keysize ) ? Integer . parseInt ( keysize ) : NUM_ ; String alg = StringUtils . isEmpty ( algorithm ) ? XMLCipher . AES_128 : algorithm ; try { SAML2MetaSecurityUtils . updateProviderKeyInfo ( realm , entityName , signingCertAliases , BOOL_ , isIDP , alg , keysi ) ; SAML2MetaSecurityUtils . updateProviderKeyInfo ( realm , entityName , encryptionCertAliases , BOOL_ , isIDP , alg , keysi ) ; } catch ( SAML2MetaException e ) { debug . warning ( STR_ , e ) ; throw new AMConsoleException ( getErrorString ( e ) ) ; } }
public void updateSlider ( final double p , final boolean n ) { checkWidget ( ) ; double percentage = p ; if ( step != null ) { percentage = Math . round ( percentage / step ) . step ; } this . notify = n ; if ( percentage < NUM_ ) { percentage = NUM_ ; } else if ( percentage > NUM_ ) { percentage = NUM_ ; } final int usefulWidth = getClientArea ( ) . width - thumbWidth ; final int width = ( int ) Math . round ( usefulWidth . percentage ) ; moveThumbHorizontally ( width ) ; previousPosition = percentage ; this . notify = BOOL_ ; }
@ Override public boolean contains ( String identifier ) { return whitelist . contains ( identifier ) ; }
public static final Action [ ] augmentList ( Action [ ] list1 , Action [ ] list2 ) { Hashtable < String , Action > h = new Hashtable < String , Action > ( ) ; for ( Action a : list1 ) { String value = ( String ) a . getValue ( Action . NAME ) ; h . put ( ( value != null ? value : STR_ ) , a ) ; } for ( Action a : list2 ) { String value = ( String ) a . getValue ( Action . NAME ) ; h . put ( ( value != null ? value : STR_ ) , a ) ; } Action [ ] actions = new Action [ h . size ( ) ] ; int index = NUM_ ; for ( Enumeration e = h . elements ( ) ; e . hasMoreElements ( ) ; ) { actions [ index ++ ] = ( Action ) e . nextElement ( ) ; } return actions ; }
public MVMap < K , V > openVersion ( long version ) { if ( readOnly ) { throw DataUtils . newUnsupportedOperationException ( STR_ + STR_ ) ; } DataUtils . checkArgument ( version >= createVersion , STR_ , version , createVersion ) ; Page newest = null ; Page r = root ; if ( version >= r . getVersion ( ) && ( version == writeVersion || r . getVersion ( ) >= NUM_ || version <= createVersion || store . getFileStore ( ) == null ) ) { newest = r ; } else { Page last = oldRoots . peekFirst ( ) ; if ( last == null || version < last . getVersion ( ) ) { return store . openMapVersion ( version , id , this ) ; } Iterator < Page > it = oldRoots . iterator ( ) ; while ( it . hasNext ( ) ) { Page p = it . next ( ) ; if ( p . getVersion ( ) > version ) { break ; } last = p ; } newest = last ; } MVMap < K , V > m = openReadOnly ( ) ; m . root = newest ; return m ; }
public DTMDefaultBase ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing , int blocksize , boolean usePrevsib , boolean newNameTable ) { int numblocks ; if ( blocksize <= NUM_ ) { numblocks = DEFAULT_NUMBLOCKS_SMALL ; m_dtmIdent = new SuballocatedIntVector ( NUM_ , NUM_ ) ; } else { numblocks = DEFAULT_NUMBLOCKS ; m_dtmIdent = new SuballocatedIntVector ( NUM_ ) ; } m_exptype = new SuballocatedIntVector ( blocksize , numblocks ) ; m_firstch = new SuballocatedIntVector ( blocksize , numblocks ) ; m_nextsib = new SuballocatedIntVector ( blocksize , numblocks ) ; m_parent = new SuballocatedIntVector ( blocksize , numblocks ) ; if ( usePrevsib ) m_prevsib = new SuballocatedIntVector ( blocksize , numblocks ) ; m_mgr = mgr ; if ( mgr instanceof DTMManagerDefault ) m_mgrDefault = ( DTMManagerDefault ) mgr ; m_documentBaseURI = ( null != source ) ? source . getSystemId ( ) : null ; m_dtmIdent . setElementAt ( dtmIdentity , NUM_ ) ; m_wsfilter = whiteSpaceFilter ; m_xstrf = xstringfactory ; m_indexing = doIndexing ; if ( doIndexing ) { m_expandedNameTable = new ExpandedNameTable ( ) ; } else { m_expandedNameTable = m_mgrDefault . getExpandedNameTable ( this ) ; } if ( null != whiteSpaceFilter ) { m_shouldStripWhitespaceStack = new BoolStack ( ) ; pushShouldStripWhitespace ( BOOL_ ) ; } }
private boolean lessThanOrEqual ( byte [ ] a , byte [ ] b ) { int len = Math . min ( a . length , b . length ) ; for ( int i = NUM_ ; i != len ; ++ i ) { if ( a [ i ] != b [ i ] ) { return ( a [ i ] & xff ) < ( b [ i ] & xff ) ; } } return len == a . length ; }
protected void clear ( ) { parts_ . clear ( ) ; }
public static boolean isNumber ( String s ) { try { Integer . valueOf ( s ) ; return BOOL_ ; } catch ( Exception e ) { return BOOL_ ; } }
private boolean isOuterGState ( ) { return mGStateStack . size ( ) == NUM_ ; }
public void testCase24 ( ) { byte rBytes [ ] = { NUM_ } ; BigInteger aNumber = BigInteger . ONE ; BigInteger bNumber = BigInteger . ONE ; BigInteger result = aNumber . subtract ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( NUM_ , result . signum ( ) ) ; }
void add ( SuperCardToast superCardToast ) { mList . add ( superCardToast ) ; }
static public Tasker create ( ) { return new Tasker ( ) ; }
public static String concernStackString ( BlockInfo blockInfo ) { String result = STR_ ; for ( String stackEntry : blockInfo . threadStackEntries ) { if ( Character . isLetter ( stackEntry . charAt ( NUM_ ) ) ) { String [ ] lines = stackEntry . split ( BlockInfo . SEPARATOR ) ; for ( String line : lines ) { String keyStackString = concernStackString ( line ) ; if ( keyStackString != null ) { return keyStackString ; } } return classSimpleName ( lines [ NUM_ ] ) ; } } return result ; }
static String gravityToString ( @ EdgeGravity int gravity ) { if ( ( gravity & Gravity . LEFT ) == Gravity . LEFT ) { return STR_ ; } if ( ( gravity & Gravity . RIGHT ) == Gravity . RIGHT ) { return STR_ ; } if ( ( gravity & Gravity . BOTTOM ) == Gravity . BOTTOM ) { return STR_ ; } return Integer . toHexString ( gravity ) ; }
public void removeAllRenderers ( ) { mRenderers . clear ( ) ; }
public static int writeSpeexHeader ( byte [ ] buf , int offset , int sampleRate , int mode , int channels , boolean vbr , int nframes , int packetlength ) { writeString ( buf , offset , STR_ ) ; writeString ( buf , offset + NUM_ , STR_ ) ; System . arraycopy ( new byte [ NUM_ ] , NUM_ , buf , offset + NUM_ , NUM_ ) ; writeInt ( buf , offset + NUM_ , NUM_ ) ; writeInt ( buf , offset + NUM_ , NUM_ ) ; writeInt ( buf , offset + NUM_ , sampleRate ) ; writeInt ( buf , offset + NUM_ , mode ) ; writeInt ( buf , offset + NUM_ , NUM_ ) ; writeInt ( buf , offset + NUM_ , channels ) ; writeInt ( buf , offset + NUM_ , - NUM_ ) ; writeInt ( buf , offset + NUM_ , NUM_ << mode ) ; writeInt ( buf , offset + NUM_ , vbr ? NUM_ : NUM_ ) ; writeInt ( buf , offset + NUM_ , nframes ) ; writeInt ( buf , offset + NUM_ , NUM_ ) ; writeInt ( buf , offset + NUM_ , packetlength ) ; writeInt ( buf , offset + NUM_ , NUM_ ) ; return NUM_ ; }
private static File igniteHadoopConfig ( String igniteHome ) { Path path = Paths . get ( igniteHome , STR_ , STR_ , STR_ ) ; if ( ! Files . exists ( path ) ) path = Paths . get ( igniteHome , STR_ , STR_ ) ; if ( Files . exists ( path ) ) return path . toFile ( ) ; else return new File ( igniteHome , STR_ ) ; }
private static void attemptRetryOnException ( String logPrefix , Request < ? > request , VolleyError exception ) throws VolleyError { RetryPolicy retryPolicy = request . getRetryPolicy ( ) ; int oldTimeout = request . getTimeoutMs ( ) ; try { retryPolicy . retry ( exception ) ; } catch ( VolleyError e ) { request . addMarker ( String . format ( STR_ , logPrefix , oldTimeout ) ) ; throw e ; } request . addMarker ( String . format ( STR_ , logPrefix , oldTimeout ) ) ; }
protected ApproximationLine conservativeKnnDistanceApproximation ( int k_max ) { int k_0 = k_max ; double y_1 = Double . NEGATIVE_INFINITY ; double y_kmax = Double . NEGATIVE_INFINITY ; for ( int i = NUM_ ; i < getNumEntries ( ) ; i ++ ) { MkCoPEntry entry = getEntry ( i ) ; ApproximationLine approx = entry . getConservativeKnnDistanceApproximation ( ) ; k_0 = Math . min ( approx . getK_0 ( ) , k_0 ) ; } for ( int i = NUM_ ; i < getNumEntries ( ) ; i ++ ) { MkCoPEntry entry = getEntry ( i ) ; ApproximationLine approx = entry . getConservativeKnnDistanceApproximation ( ) ; double entry_y_1 = approx . getValueAt ( k_0 ) ; double entry_y_kmax = approx . getValueAt ( k_max ) ; if ( ! Double . isInfinite ( entry_y_1 ) ) { y_1 = Math . max ( entry_y_1 , y_1 ) ; } if ( ! Double . isInfinite ( entry_y_kmax ) ) { y_kmax = Math . max ( entry_y_kmax , y_kmax ) ; } } double m = ( y_kmax - y_1 ) / ( Math . log ( k_max ) - Math . log ( k_0 ) ) ; double t = y_1 - m . Math . log ( k_0 ) ; return new ApproximationLine ( k_0 , m , t ) ; }
public final boolean shares_layer ( BrdItem p_other ) { int max_first_layer = Math . max ( first_layer ( ) , p_other . first_layer ( ) ) ; int min_last_layer = Math . min ( last_layer ( ) , p_other . last_layer ( ) ) ; return max_first_layer <= min_last_layer ; }
private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }
@ Override public String toString ( ) { return buf . toString ( ) ; }
public CoapClient ( URI uri ) { this ( uri . toString ( ) ) ; }
private void zero ( ) throws JSONException { if ( probe ) { log ( NUM_ ) ; } write ( NUM_ , NUM_ ) ; }
public static boolean beenDone ( TimeUnit timeUnit , long amount , String tag , CountChecker numberOfTimes ) { long timeInMillis = timeUnit . toMillis ( amount ) ; return beenDone ( timeInMillis , tag , numberOfTimes ) ; }
public static String normalize ( String oid ) { return oid . startsWith ( STR_ ) ? oid . substring ( NUM_ ) : oid ; }
public RtcpPacket parseRtcpPacket ( Packet packet ) { RtcpCompoundPacket compoundPacket = new RtcpCompoundPacket ( packet ) ; Vector < RtcpPacket > subpackets = new Vector < RtcpPacket > ( ) ; DataInputStream in = new DataInputStream ( new ByteArrayInputStream ( compoundPacket . data , compoundPacket . offset , compoundPacket . length ) ) ; try { rtcpSession . updateavgrtcpsize ( compoundPacket . length ) ; int length = NUM_ ; for ( int offset = NUM_ ; offset < compoundPacket . length ; offset += length ) { int firstbyte = in . readUnsignedByte ( ) ; if ( ( firstbyte & xc0 ) != NUM_ ) { return null ; } int type = in . readUnsignedByte ( ) ; length = in . readUnsignedShort ( ) ; length = length + NUM_ << NUM_ ; int padlen = NUM_ ; if ( offset + length > compoundPacket . length ) { return null ; } if ( offset + length == compoundPacket . length ) { if ( ( firstbyte & x20 ) != NUM_ ) { padlen = compoundPacket . data [ compoundPacket . offset + compoundPacket . length - NUM_ ] & xff ; if ( padlen == NUM_ ) { return null ; } } } else if ( ( firstbyte & x20 ) != NUM_ ) { return null ; } int inlength = length - padlen ; firstbyte &= x1f ; RtcpPacket subpacket ; switch ( type ) { case RtcpPacket . RTCP_SR : stats . numSrPkts ++ ; if ( inlength != NUM_ + NUM_ . firstbyte ) { stats . numMalformedRtcpPkts ++ ; return null ; } RtcpSenderReportPacket srp = new RtcpSenderReportPacket ( compoundPacket ) ; subpacket = srp ; srp . ssrc = in . readInt ( ) ; srp . ntptimestampmsw = ( long ) in . readInt ( ) & xffffffffL ; srp . ntptimestamplsw = ( long ) in . readInt ( ) & xffffffffL ; srp . rtptimestamp = ( long ) in . readInt ( ) & xffffffffL ; srp . packetcount = ( long ) in . readInt ( ) & xffffffffL ; srp . octetcount = ( long ) in . readInt ( ) & xffffffffL ; srp . reports = new RtcpReport [ firstbyte ] ; RtpSource sourceSR = rtcpSession . getMySource ( ) ; if ( sourceSR != null ) { sourceSR . receivedSenderReport ( srp ) ; } for ( int i = NUM_ ; i < srp . reports . length ; i ++ ) { RtcpReport report = new RtcpReport ( ) ; srp . reports [ i ] = report ; report . ssrc = in . readInt ( ) ; long val = in . readInt ( ) ; val &= xffffffffL ; report . fractionlost = ( int ) ( val > > NUM_ ) ; report . packetslost = ( int ) ( val & xffffffL ) ; report . lastseq = ( long ) in . readInt ( ) & xffffffffL ; report . jitter = in . readInt ( ) ; report . lsr = ( long ) in . readInt ( ) & xffffffffL ; report . dlsr = ( long ) in . readInt ( ) & xffffffffL ; } notifyRtcpListeners ( new RtcpSenderReportEvent ( srp ) ) ; break ; case RtcpPacket . RTCP_RR : if ( inlength != NUM_ + NUM_ . firstbyte ) { stats . numMalformedRtcpPkts ++ ; return null ; } RtcpReceiverReportPacket rrp = new RtcpReceiverReportPacket ( compoundPacket ) ; subpacket = rrp ; rrp . ssrc = in . readInt ( ) ; rrp . reports = new RtcpReport [ firstbyte ] ; for ( int i = NUM_ ; i < rrp . reports . length ; i ++ ) { RtcpReport report = new RtcpReport ( ) ; rrp . reports [ i ] = report ; report . ssrc = in . readInt ( ) ; long val = in . readInt ( ) ; val &= xffffffffL ; report . fractionlost = ( int ) ( val > > NUM_ ) ; report . packetslost = ( int ) ( val & xffffffL ) ; report . lastseq = ( long ) in . readInt ( ) & xffffffffL ; report . jitter = in . readInt ( ) ; report . lsr = ( long ) in . readInt ( ) & xffffffffL ; report . dlsr = ( long ) in . readInt ( ) & xffffffffL ; } notifyRtcpListeners ( new RtcpReceiverReportEvent ( rrp ) ) ; break ; case RtcpPacket . RTCP_SDES : RtcpSdesPacket sdesp = new RtcpSdesPacket ( compoundPacket ) ; subpacket = sdesp ; sdesp . sdes = new RtcpSdesBlock [ firstbyte ] ; int sdesoff = NUM_ ; for ( int i = NUM_ ; i < sdesp . sdes . length ; i ++ ) { RtcpSdesBlock chunk = new RtcpSdesBlock ( ) ; sdesp . sdes [ i ] = chunk ; chunk . ssrc = in . readInt ( ) ; sdesoff += NUM_ ; Vector < RtcpSdesItem > items = new Vector < RtcpSdesItem > ( ) ; boolean gotcname = BOOL_ ; int j ; while ( ( j = in . readUnsignedByte ( ) ) != NUM_ ) { if ( j < NUM_ || j > NUM_ ) { stats . numMalformedRtcpPkts ++ ; return null ; } if ( j == NUM_ ) { gotcname = BOOL_ ; } RtcpSdesItem item = new RtcpSdesItem ( ) ; items . addElement ( item ) ; item . type = j ; int sdeslen = in . readUnsignedByte ( ) ; item . data = new byte [ sdeslen ] ; in . readFully ( item . data ) ; sdesoff += NUM_ + sdeslen ; } if ( ! gotcname ) { stats . numMalformedRtcpPkts ++ ; return null ; } chunk . items = new RtcpSdesItem [ items . size ( ) ] ; items . copyInto ( chunk . items ) ; if ( ( sdesoff & NUM_ ) != NUM_ ) { if ( in . skip ( NUM_ - ( sdesoff & NUM_ ) ) != NUM_ - ( sdesoff & NUM_ ) ) { return null ; } sdesoff = sdesoff + NUM_ & - NUM_ ; } } if ( inlength != sdesoff ) { stats . numMalformedRtcpPkts ++ ; return null ; } notifyRtcpListeners ( new RtcpSdesEvent ( sdesp ) ) ; break ; case RtcpPacket . RTCP_BYE : RtcpByePacket byep = new RtcpByePacket ( compoundPacket ) ; subpacket = byep ; byep . ssrc = new int [ firstbyte ] ; for ( int i = NUM_ ; i < byep . ssrc . length ; i ++ ) { byep . ssrc [ i ] = in . readInt ( ) ; } int reasonlen ; if ( inlength > NUM_ + NUM_ . firstbyte ) { reasonlen = in . readUnsignedByte ( ) ; byep . reason = new byte [ reasonlen ] ; reasonlen ++ ; } else { reasonlen = NUM_ ; byep . reason = new byte [ NUM_ ] ; } reasonlen = reasonlen + NUM_ & - NUM_ ; if ( inlength != NUM_ + NUM_ . firstbyte + reasonlen ) { stats . numMalformedRtcpPkts ++ ; return null ; } in . readFully ( byep . reason ) ; int skipBye = reasonlen - byep . reason . length ; if ( in . skip ( skipBye ) != skipBye ) { return null ; } notifyRtcpListeners ( new RtcpByeEvent ( byep ) ) ; break ; case RtcpPacket . RTCP_APP : if ( inlength < NUM_ ) { return null ; } RtcpAppPacket appp = new RtcpAppPacket ( compoundPacket ) ; subpacket = appp ; appp . ssrc = in . readInt ( ) ; appp . name = in . readInt ( ) ; appp . subtype = firstbyte ; appp . data = new byte [ inlength - NUM_ ] ; in . readFully ( appp . data ) ; int skipApp = inlength - NUM_ - appp . data . length ; if ( in . skip ( skipApp ) != skipApp ) { return null ; } notifyRtcpListeners ( new RtcpApplicationEvent ( appp ) ) ; break ; default : stats . numUnknownTypes ++ ; return null ; } subpacket . offset = offset ; subpacket . length = length ; subpackets . addElement ( subpacket ) ; if ( in . skipBytes ( padlen ) != padlen ) { return null ; } } } catch ( Exception e ) { return null ; } compoundPacket . packets = new RtcpPacket [ subpackets . size ( ) ] ; subpackets . copyInto ( compoundPacket . packets ) ; return compoundPacket ; }
public void reset ( ) { initialize ( ) ; }
private static void addListenersForReal ( final Service service , final Set < Listener > existingListeners , final Listener listener , final Executor executor ) { if ( ! existingListeners . contains ( listener ) ) { existingListeners . add ( listener ) ; service . addListener ( listener , executor ) ; } }
public void prepend ( CharSequence s ) { text . insert ( NUM_ , s ) ; }
public static void sendResponseWithStatus ( HttpServletRequest request , HttpServletResponse response , PrintWriter out , String idpMetaAlias , String idpEntityID , String realm , AuthnRequest authnReq , String relayState , String spEntityID , String firstlevelStatusCodeValue , String secondlevelStatusCodeValue ) throws SAML2Exception { Response res = SAML2Utils . getErrorResponse ( authnReq , firstlevelStatusCodeValue , secondlevelStatusCodeValue , null , idpEntityID ) ; StringBuffer returnedBinding = new StringBuffer ( ) ; String acsURL = IDPSSOUtil . getACSurl ( spEntityID , realm , authnReq , request , returnedBinding ) ; String acsBinding = returnedBinding . toString ( ) ; sendResponse ( request , response , out , acsBinding , spEntityID , idpEntityID , idpMetaAlias , realm , relayState , acsURL , res , null ) ; }
protected void validateDTDattribute ( QName element , String attValue , XMLAttributeDecl attributeDecl ) throws XNIException { switch ( attributeDecl . simpleType . type ) { case XMLSimpleType . TYPE_ENTITY : { boolean isAlistAttribute = attributeDecl . simpleType . list ; try { if ( isAlistAttribute ) { fValENTITIES . validate ( attValue , fValidationState ) ; } else { fValENTITY . validate ( attValue , fValidationState ) ; } } catch ( InvalidDatatypeValueException ex ) { fErrorReporter . reportError ( XMLMessageFormatter . XML_DOMAIN , ex . getKey ( ) , ex . getArgs ( ) , XMLErrorReporter . SEVERITY_ERROR ) ; } break ; } case XMLSimpleType . TYPE_NOTATION : case XMLSimpleType . TYPE_ENUMERATION : { boolean found = BOOL_ ; String [ ] enumVals = attributeDecl . simpleType . enumeration ; if ( enumVals == null ) { found = BOOL_ ; } else for ( int i = NUM_ ; i < enumVals . length ; i ++ ) { if ( attValue == enumVals [ i ] || attValue . equals ( enumVals [ i ] ) ) { found = BOOL_ ; break ; } } if ( ! found ) { StringBuffer enumValueString = new StringBuffer ( ) ; if ( enumVals != null ) for ( int i = NUM_ ; i < enumVals . length ; i ++ ) { enumValueString . append ( enumVals [ i ] + STR_ ) ; } fErrorReporter . reportError ( XMLMessageFormatter . XML_DOMAIN , STR_ , new Object [ ] { attributeDecl . name . rawname , attValue , enumValueString } , XMLErrorReporter . SEVERITY_ERROR ) ; } break ; } case XMLSimpleType . TYPE_ID : { try { fValID . validate ( attValue , fValidationState ) ; } catch ( InvalidDatatypeValueException ex ) { fErrorReporter . reportError ( XMLMessageFormatter . XML_DOMAIN , ex . getKey ( ) , ex . getArgs ( ) , XMLErrorReporter . SEVERITY_ERROR ) ; } break ; } case XMLSimpleType . TYPE_IDREF : { boolean isAlistAttribute = attributeDecl . simpleType . list ; try { if ( isAlistAttribute ) { fValIDRefs . validate ( attValue , fValidationState ) ; } else { fValIDRef . validate ( attValue , fValidationState ) ; } } catch ( InvalidDatatypeValueException ex ) { if ( isAlistAttribute ) { fErrorReporter . reportError ( XMLMessageFormatter . XML_DOMAIN , STR_ , new Object [ ] { attValue } , XMLErrorReporter . SEVERITY_ERROR ) ; } else { fErrorReporter . reportError ( XMLMessageFormatter . XML_DOMAIN , ex . getKey ( ) , ex . getArgs ( ) , XMLErrorReporter . SEVERITY_ERROR ) ; } } break ; } case XMLSimpleType . TYPE_NMTOKEN : { boolean isAlistAttribute = attributeDecl . simpleType . list ; try { if ( isAlistAttribute ) { fValNMTOKENS . validate ( attValue , fValidationState ) ; } else { fValNMTOKEN . validate ( attValue , fValidationState ) ; } } catch ( InvalidDatatypeValueException ex ) { if ( isAlistAttribute ) { fErrorReporter . reportError ( XMLMessageFormatter . XML_DOMAIN , STR_ , new Object [ ] { attValue } , XMLErrorReporter . SEVERITY_ERROR ) ; } else { fErrorReporter . reportError ( XMLMessageFormatter . XML_DOMAIN , STR_ , new Object [ ] { attValue } , XMLErrorReporter . SEVERITY_ERROR ) ; } } break ; } } }
public static double mean2 ( Connection conn , double ... values ) { conn . getClass ( ) ; double sum = NUM_ ; for ( double x : values ) { sum += x ; } return sum / values . length ; }
public boolean hasLongColumnInfo ( ) { return this . hasLongColumnInfo ; }
public static String domToString ( Document domDoc ) { return domToString ( domDoc . getDocumentElement ( ) , BOOL_ ) ; }
public static < T > T assertAndCast ( Class < ? extends T > clazz , Object o ) { assertNotNull ( clazz ) ; assertNotNull ( o ) ; assertTrue ( clazz . isInstance ( o ) ) ; return clazz . cast ( o ) ; }
private String createMismatchMessage ( String mismatch , MigrationVersion version , Object applied , Object resolved ) { return String . format ( STR_ + mismatch + STR_ + STR_ + STR_ , version , applied , resolved ) ; }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case NUM_ : return IDS ; default : return null ; } }
public int compareTo ( Object o ) { Split split = ( Split ) o ; BitSet P = getFirstPart ( ) ; BitSet Q = split . getFirstPart ( ) ; int a = P . nextSetBit ( NUM_ ) ; int b = Q . nextSetBit ( NUM_ ) ; while ( a > - NUM_ && b > - NUM_ ) { if ( a < b ) return - NUM_ ; else if ( a > b ) return NUM_ ; a = P . nextSetBit ( a + NUM_ ) ; b = Q . nextSetBit ( b + NUM_ ) ; } if ( a < b ) return - NUM_ ; else if ( a > b ) return NUM_ ; P = getSecondPart ( ) ; Q = split . getSecondPart ( ) ; a = P . nextSetBit ( NUM_ ) ; b = Q . nextSetBit ( NUM_ ) ; while ( a > - NUM_ && b > - NUM_ ) { if ( a < b ) return - NUM_ ; else if ( a > b ) return NUM_ ; a = P . nextSetBit ( a + NUM_ ) ; b = Q . nextSetBit ( b + NUM_ ) ; } if ( a < b ) return - NUM_ ; else if ( a > b ) return NUM_ ; else return NUM_ ; }
public boolean isMatchingTalkgroup ( LTRNetMessage message ) { String talkgroup = message . getTalkgroupID ( ) ; if ( talkgroup != null && getToID ( ) != null && talkgroup . contentEquals ( getToID ( ) ) ) { return BOOL_ ; } return isMatchingTalkgroup ( message . getTalkgroupID ( ) ) ; }
public void put ( byte [ ] source , int index , int length ) { if ( mBuffer . capacity ( ) < ( mLength + length ) ) { expandBuffer ( mLength + length + ADDITIONAL_BUFFER_SIZE ) ; } mBuffer . put ( source , index , length ) ; mLength += length ; }
public void testSetBitNegativeInside4 ( ) { String as = STR_ ; int number = NUM_ ; BigInteger aNumber = new BigInteger ( as ) ; BigInteger result = aNumber . setBit ( number ) ; assertEquals ( as , result . toString ( ) ) ; }
public Shape modelToView ( int pos , Shape a , Position . Bias b ) throws BadLocationException { return m_view . modelToView ( pos , a , b ) ; }
private static int applyPrecision ( int decExp , char [ ] digits , int nDigits , int prec ) { if ( prec >= nDigits || prec < NUM_ ) { return decExp ; } if ( prec == NUM_ ) { if ( digits [ NUM_ ] >= STR_ ) { digits [ NUM_ ] = STR_ ; Arrays . fill ( digits , NUM_ , nDigits , STR_ ) ; return decExp + NUM_ ; } else { Arrays . fill ( digits , NUM_ , nDigits , STR_ ) ; return decExp ; } } int q = digits [ prec ] ; if ( q >= STR_ ) { int i = prec ; q = digits [ -- i ] ; if ( q == STR_ ) { while ( q == STR_ && i > NUM_ ) { q = digits [ -- i ] ; } if ( q == STR_ ) { digits [ NUM_ ] = STR_ ; Arrays . fill ( digits , NUM_ , nDigits , STR_ ) ; return decExp + NUM_ ; } } digits [ i ] = ( char ) ( q + NUM_ ) ; Arrays . fill ( digits , i + NUM_ , nDigits , STR_ ) ; } else { Arrays . fill ( digits , prec , nDigits , STR_ ) ; } return decExp ; }
protected void drawCubic ( Canvas c , LineDataSet dataSet , List < Entry > entries ) { Transformer trans = mChart . getTransformer ( dataSet . getAxisDependency ( ) ) ; Entry entryFrom = dataSet . getEntryForXIndex ( mMinX ) ; Entry entryTo = dataSet . getEntryForXIndex ( mMaxX ) ; int diff = ( entryFrom == entryTo ) ? NUM_ : NUM_ ; int minx = Math . max ( dataSet . getEntryPosition ( entryFrom ) - diff , NUM_ ) ; int maxx = Math . min ( Math . max ( minx + NUM_ , dataSet . getEntryPosition ( entryTo ) + NUM_ ) , entries . size ( ) ) ; float phaseX = mAnimator . getPhaseX ( ) ; float phaseY = mAnimator . getPhaseY ( ) ; float intensity = dataSet . getCubicIntensity ( ) ; cubicPath . reset ( ) ; int size = ( int ) Math . ceil ( ( maxx - minx ) . phaseX + minx ) ; if ( size - minx >= NUM_ ) { float prevDx = NUM_ ; float prevDy = NUM_ ; float curDx = NUM_ ; float curDy = NUM_ ; Entry prevPrev = entries . get ( minx ) ; Entry prev = entries . get ( minx ) ; Entry cur = entries . get ( minx ) ; Entry next = entries . get ( minx + NUM_ ) ; cubicPath . moveTo ( cur . getXIndex ( ) , cur . getVal ( ) . phaseY ) ; prevDx = ( cur . getXIndex ( ) - prev . getXIndex ( ) ) . intensity ; prevDy = ( cur . getVal ( ) - prev . getVal ( ) ) . intensity ; curDx = ( next . getXIndex ( ) - cur . getXIndex ( ) ) . intensity ; curDy = ( next . getVal ( ) - cur . getVal ( ) ) . intensity ; cubicPath . cubicTo ( prev . getXIndex ( ) + prevDx , ( prev . getVal ( ) + prevDy ) . phaseY , cur . getXIndex ( ) - curDx , ( cur . getVal ( ) - curDy ) . phaseY , cur . getXIndex ( ) , cur . getVal ( ) . phaseY ) ; for ( int j = minx + NUM_ , count = Math . min ( size , entries . size ( ) - NUM_ ) ; j < count ; j ++ ) { prevPrev = entries . get ( j == NUM_ ? NUM_ : j - NUM_ ) ; prev = entries . get ( j - NUM_ ) ; cur = entries . get ( j ) ; next = entries . get ( j + NUM_ ) ; prevDx = ( cur . getXIndex ( ) - prevPrev . getXIndex ( ) ) . intensity ; prevDy = ( cur . getVal ( ) - prevPrev . getVal ( ) ) . intensity ; curDx = ( next . getXIndex ( ) - prev . getXIndex ( ) ) . intensity ; curDy = ( next . getVal ( ) - prev . getVal ( ) ) . intensity ; cubicPath . cubicTo ( prev . getXIndex ( ) + prevDx , ( prev . getVal ( ) + prevDy ) . phaseY , cur . getXIndex ( ) - curDx , ( cur . getVal ( ) - curDy ) . phaseY , cur . getXIndex ( ) , cur . getVal ( ) . phaseY ) ; } if ( size > entries . size ( ) - NUM_ ) { prevPrev = entries . get ( ( entries . size ( ) >= NUM_ ) ? entries . size ( ) - NUM_ : entries . size ( ) - NUM_ ) ; prev = entries . get ( entries . size ( ) - NUM_ ) ; cur = entries . get ( entries . size ( ) - NUM_ ) ; next = cur ; prevDx = ( cur . getXIndex ( ) - prevPrev . getXIndex ( ) ) . intensity ; prevDy = ( cur . getVal ( ) - prevPrev . getVal ( ) ) . intensity ; curDx = ( next . getXIndex ( ) - prev . getXIndex ( ) ) . intensity ; curDy = ( next . getVal ( ) - prev . getVal ( ) ) . intensity ; cubicPath . cubicTo ( prev . getXIndex ( ) + prevDx , ( prev . getVal ( ) + prevDy ) . phaseY , cur . getXIndex ( ) - curDx , ( cur . getVal ( ) - curDy ) . phaseY , cur . getXIndex ( ) , cur . getVal ( ) . phaseY ) ; } } if ( dataSet . isDrawFilledEnabled ( ) ) { cubicFillPath . reset ( ) ; cubicFillPath . addPath ( cubicPath ) ; drawCubicFill ( mBitmapCanvas , dataSet , cubicFillPath , trans , entryFrom . getXIndex ( ) , entryFrom . getXIndex ( ) + size ) ; } mRenderPaint . setColor ( dataSet . getColor ( ) ) ; mRenderPaint . setStyle ( Paint . Style . STROKE ) ; trans . pathValueToPixel ( cubicPath ) ; mBitmapCanvas . drawPath ( cubicPath , mRenderPaint ) ; mRenderPaint . setPathEffect ( null ) ; }
public void delete ( @ NonNull Key key ) { final ReentrantReadWriteLock . WriteLock lock = guard . writeLock ( ) ; lock . lock ( ) ; try { if ( ! readKeys . remove ( key ) ) throw new IllegalArgumentException ( STR_ ) ; Files . delete ( key . getFile ( ) ) ; } catch ( IOException ex ) { LOG . log ( Level . WARNING , STR_ + key . getFile ( ) , ex ) ; } finally { lock . unlock ( ) ; } }
protected Object toType ( Calendar value ) { return value . getTime ( ) ; }
public boolean onTouchEvent ( MotionEvent event ) { try { int pointerCount = multiTouchSupported ? ( Integer ) m_getPointerCount . invoke ( event ) : NUM_ ; if ( DEBUG ) Log . i ( STR_ , STR_ + multiTouchSupported + STR_ + mMode + STR_ + handleSingleTouchEvents + STR_ + pointerCount ) ; if ( mMode == MODE_NOTHING && ! handleSingleTouchEvents && pointerCount == NUM_ ) return BOOL_ ; if ( DEBUG ) Log . i ( STR_ , STR_ ) ; int action = event . getAction ( ) ; int histLen = event . getHistorySize ( ) / pointerCount ; for ( int histIdx = NUM_ ; histIdx <= histLen ; histIdx ++ ) { boolean processingHist = histIdx < histLen ; if ( ! multiTouchSupported || pointerCount == NUM_ ) { if ( DEBUG ) Log . i ( STR_ , STR_ ) ; xVals [ NUM_ ] = processingHist ? event . getHistoricalX ( histIdx ) : event . getX ( ) ; yVals [ NUM_ ] = processingHist ? event . getHistoricalY ( histIdx ) : event . getY ( ) ; pressureVals [ NUM_ ] = processingHist ? event . getHistoricalPressure ( histIdx ) : event . getPressure ( ) ; } else { if ( DEBUG ) Log . i ( STR_ , STR_ ) ; int numPointers = Math . min ( pointerCount , MAX_TOUCH_POINTS ) ; if ( DEBUG && pointerCount > MAX_TOUCH_POINTS ) Log . i ( STR_ , STR_ ) ; for ( int ptrIdx = NUM_ ; ptrIdx < numPointers ; ptrIdx ++ ) { int ptrId = ( Integer ) m_getPointerId . invoke ( event , ptrIdx ) ; pointerIds [ ptrIdx ] = ptrId ; xVals [ ptrIdx ] = ( Float ) ( processingHist ? m_getHistoricalX . invoke ( event , ptrIdx , histIdx ) : m_getX . invoke ( event , ptrIdx ) ) ; yVals [ ptrIdx ] = ( Float ) ( processingHist ? m_getHistoricalY . invoke ( event , ptrIdx , histIdx ) : m_getY . invoke ( event , ptrIdx ) ) ; pressureVals [ ptrIdx ] = ( Float ) ( processingHist ? m_getHistoricalPressure . invoke ( event , ptrIdx , histIdx ) : m_getPressure . invoke ( event , ptrIdx ) ) ; } } decodeTouchEvent ( pointerCount , xVals , yVals , pressureVals , pointerIds , processingHist ? MotionEvent . ACTION_MOVE : action , processingHist ? BOOL_ : action != MotionEvent . ACTION_UP && ( action & ( ( NUM_ << ACTION_POINTER_INDEX_SHIFT ) - NUM_ ) ) != ACTION_POINTER_UP && action != MotionEvent . ACTION_CANCEL , processingHist ? event . getHistoricalEventTime ( histIdx ) : event . getEventTime ( ) ) ; } return BOOL_ ; } catch ( Exception e ) { Log . e ( STR_ , STR_ , e ) ; return BOOL_ ; } }
public static void storeLocation ( Context context , LatLng location ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putLong ( PREFERENCES_LAT , Double . doubleToRawLongBits ( location . latitude ) ) ; editor . putLong ( PREFERENCES_LNG , Double . doubleToRawLongBits ( location . longitude ) ) ; editor . apply ( ) ; }
public void writeToFile ( String fileName ) throws IOException { PrintWriter outfile = new PrintWriter ( new FileOutputStream ( fileName ) ) ; outfile . println ( STR_ ) ; outfile . println ( STR_ ) ; outfile . println ( STR_ + m_nbins ) ; outfile . println ( STR_ + m_min ) ; outfile . println ( STR_ + m_max ) ; outfile . println ( STR_ + m_entries ) ; outfile . println ( STR_ + m_underflow ) ; outfile . println ( STR_ + m_overflow ) ; outfile . println ( STR_ ) ; for ( int i = NUM_ ; i < m_nbins ; i ++ ) { outfile . println ( i + STR_ + m_binCenters [ i ] + STR_ + m_hist [ i ] ) ; } outfile . println ( STR_ ) ; outfile . close ( ) ; }
public void outdent ( ) { final int length = indent . length ( ) ; if ( length == NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } indent . delete ( length - NUM_ , length ) ; }
public static String extractFromDataMatrix ( String code ) { if ( code . length ( ) < NUM_ ) { return null ; } if ( code . startsWith ( STR_ ) ) { return code . substring ( NUM_ , NUM_ ) ; } return null ; }
public void paintCurrentValue ( Graphics g , Rectangle bounds , boolean hasFocus ) { XPStyle xp = XPStyle . getXP ( ) ; if ( xp != null ) { bounds . x += NUM_ ; bounds . y += NUM_ ; bounds . width -= NUM_ ; bounds . height -= NUM_ ; } else { bounds . x += NUM_ ; bounds . y += NUM_ ; bounds . width -= NUM_ ; bounds . height -= NUM_ ; } if ( ! comboBox . isEditable ( ) && xp != null && xp . isSkinDefined ( comboBox , Part . CP_READONLY ) ) { ListCellRenderer renderer = comboBox . getRenderer ( ) ; Component c ; if ( hasFocus && ! isPopupVisible ( comboBox ) ) { c = renderer . getListCellRendererComponent ( listBox , comboBox . getSelectedItem ( ) , - NUM_ , BOOL_ , BOOL_ ) ; } else { c = renderer . getListCellRendererComponent ( listBox , comboBox . getSelectedItem ( ) , - NUM_ , BOOL_ , BOOL_ ) ; } c . setFont ( comboBox . getFont ( ) ) ; if ( comboBox . isEnabled ( ) ) { c . setForeground ( comboBox . getForeground ( ) ) ; c . setBackground ( comboBox . getBackground ( ) ) ; } else { c . setForeground ( DefaultLookup . getColor ( comboBox , this , STR_ , null ) ) ; c . setBackground ( DefaultLookup . getColor ( comboBox , this , STR_ , null ) ) ; } boolean shouldValidate = BOOL_ ; if ( c instanceof JPanel ) { shouldValidate = BOOL_ ; } currentValuePane . paintComponent ( g , c , comboBox , bounds . x , bounds . y , bounds . width , bounds . height , shouldValidate ) ; } else { super . paintCurrentValue ( g , bounds , hasFocus ) ; } }
@ Override public AudioInputStream synthesiseOneSection ( String festivalUtt , Voice voice ) throws IOException { writeRelationFiles ( festivalUtt ) ; File audioFile = new File ( festivalDir . getPath ( ) + File . separator + STR_ ) ; String festivalVoiceCmd = STR_ + voice . getName ( ) + STR_ ; AudioInputStream sound = festivalSynthesise ( audioFile , festivalVoiceCmd ) ; return sound ; }
JSONStringer close ( Scope empty , Scope nonempty , String closeBracket ) throws JSONException { Scope context = peek ( ) ; if ( context != nonempty && context != empty ) { throw new JSONException ( STR_ ) ; } stack . remove ( stack . size ( ) - NUM_ ) ; if ( context == nonempty ) { newline ( ) ; } out . append ( closeBracket ) ; return this ; }
public int read ( byte [ ] buffer , int offset , int length ) throws IOException { log . finest ( STR_ + Long . toHexString ( getFilePointer ( ) ) + STR_ + length + STR_ ) ; return _file . read ( buffer , offset , length ) ; }
public static Pattern createPattern ( String [ ] patterns , boolean isCaseSensitive , boolean isRegexSearch ) throws PatternSyntaxException { StringBuffer pattern = new StringBuffer ( ) ; for ( int i = NUM_ ; i < patterns . length ; i ++ ) { if ( i > NUM_ ) { pattern . append ( STR_ ) ; } if ( isRegexSearch ) { pattern . append ( patterns [ i ] ) ; } else { asRegEx ( patterns [ i ] , pattern ) ; } } return createPattern ( pattern . toString ( ) , isCaseSensitive , BOOL_ ) ; }
public void addArc ( float latPoint , float lonPoint , int w , int h , float s , float e , LinkProperties properties ) throws IOException { LinkArc . write ( latPoint , lonPoint , NUM_ , NUM_ , w , h , s , e , properties , link . dos ) ; }
public void onUndeploy ( ClassLoader ldr ) { for ( Class < ? > cls : descByCls . keySet ( ) ) { if ( ldr . equals ( cls . getClassLoader ( ) ) ) descByCls . remove ( cls ) ; } U . clearClassCache ( ldr ) ; }
@ Override public boolean containsClass ( String className ) throws IOException { boolean containsClass = BOOL_ ; String resourceName = STR_ + className . replace ( STR_ , STR_ ) + STR_ ; if ( getResource ( resourceName ) != null ) { containsClass = BOOL_ ; } for ( String resource : getResources ( STR_ ) ) { JarArchive jar = new DefaultJarArchive ( getResource ( resource ) ) ; if ( jar . containsClass ( className ) ) { containsClass = BOOL_ ; } } return containsClass ; }
public Tuple [ ] clearInternal ( ) { Tuple [ ] t = new Tuple [ getTupleCount ( ) ] ; Iterator iter = tuples ( ) ; for ( int i = NUM_ ; iter . hasNext ( ) ; ++ i ) { t [ i ] = ( Tuple ) iter . next ( ) ; } m_tuples . clear ( ) ; return t ; }
public synchronized void removeTextListener ( TextListener cl ) { m_textListeners . remove ( cl ) ; }
private void ensureCapacity ( int desiredLongCount ) { if ( desiredLongCount <= bits . length ) { return ; } int newLength = Math . max ( desiredLongCount , bits . length . NUM_ ) ; long [ ] newBits = new long [ newLength ] ; System . arraycopy ( bits , NUM_ , newBits , NUM_ , longCount ) ; this . bits = newBits ; }
public boolean matches ( String query , String text ) { return text . contains ( query ) ; }
private void findCollapsesFromExistingVertices ( List collapsedVertexIndexes ) { for ( int i = NUM_ ; i < edge . size ( ) - NUM_ ; i ++ ) { Coordinate p0 = edge . getCoordinate ( i ) ; Coordinate p1 = edge . getCoordinate ( i + NUM_ ) ; Coordinate p2 = edge . getCoordinate ( i + NUM_ ) ; if ( p0 . equals2D ( p2 ) ) { collapsedVertexIndexes . add ( new Integer ( i + NUM_ ) ) ; } } }
public void close ( ) throws IOException { if ( Debug . debugging ( STR_ ) ) { Debug . output ( STR_ ) ; } try { if ( inputFile != null ) inputFile . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } inputFile = null ; }
public static boolean checkPoolPropertiesChanged ( Set < String > existingValue , Set < String > newValue ) { boolean propertyChanged = BOOL_ ; if ( existingValue == null && ( newValue != null && ! newValue . isEmpty ( ) ) ) { propertyChanged = BOOL_ ; } else if ( newValue == null && ( existingValue != null && ! existingValue . isEmpty ( ) ) ) { propertyChanged = BOOL_ ; } else if ( existingValue != null && newValue != null ) { if ( existingValue . size ( ) != newValue . size ( ) || ! ( existingValue . containsAll ( newValue ) ) ) { propertyChanged = BOOL_ ; } } return propertyChanged ; }
public static OutputStream leftShift ( OutputStream self , InputStream in ) throws IOException { byte [ ] buf = new byte [ NUM_ ] ; while ( BOOL_ ) { int count = in . read ( buf , NUM_ , buf . length ) ; if ( count == - NUM_ ) break ; if ( count == NUM_ ) { Thread . yield ( ) ; continue ; } self . write ( buf , NUM_ , count ) ; } self . flush ( ) ; return self ; }
public static boolean gitLocalConfig ( final AtomicReference < String > path ) throws IOException { return gitLocalConfig ( Environment . getCurrentDirectory ( ) , path ) ; }
public void verify ( ) { super . verify ( ) ; assertEquals ( STR_ , confirmed , collection ) ; assertEquals ( STR_ , confirmed . hashCode ( ) , collection . hashCode ( ) ) ; Collection set = makeConfirmedCollection ( ) ; Iterator iterator = collection . iterator ( ) ; while ( iterator . hasNext ( ) ) { assertTrue ( STR_ , set . add ( iterator . next ( ) ) ) ; } }
public static CGPoint ccpRotateByAngle ( CGPoint v , CGPoint pivot , float angle ) { CGPoint r = ccpSub ( v , pivot ) ; float t = r . x ; float cosa = ( float ) Math . cos ( angle ) ; float sina = ( float ) Math . sin ( angle ) ; r . x = t . cosa - r . y . sina ; r . y = t . sina + r . y . cosa ; r = ccpAdd ( r , pivot ) ; return r ; }
private void openContextMenu ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) { Collection < String > streams = new HashSet < > ( ) ; int [ ] selectedRows = table . getSelectedRows ( ) ; for ( int selectedRow : selectedRows ) { Follower selected = followers . get ( selectedRow ) ; streams . add ( StringUtil . toLowerCase ( selected . name ) ) ; } if ( ! streams . isEmpty ( ) ) { StreamsContextMenu m = new StreamsContextMenu ( streams , contextMenuListener ) ; m . show ( table , e . getX ( ) , e . getY ( ) ) ; } } }
public static Workflow . Method expandVolumesMethod ( URI storage , URI pool , URI volume , Long size ) { return new Workflow . Method ( STR_ , storage , pool , volume , size ) ; }
void closeSilently ( Socket socket ) { try { socket . close ( ) ; } catch ( Exception e ) { } }
public static boolean equals ( byte [ ] array1 , byte [ ] array2 ) { if ( array1 == array2 ) return BOOL_ ; if ( array1 == null || array2 == null || array1 . length != array2 . length ) return BOOL_ ; for ( int i = NUM_ ; i < array1 . length ; i ++ ) { if ( array1 [ i ] != array2 [ i ] ) return BOOL_ ; } return BOOL_ ; }
private static String createIdFromJndiLocationIfNotNull ( String jndiLocation ) { String id = null ; if ( jndiLocation != null ) { id = createIdFromJndiLocation ( jndiLocation ) ; } return id ; }
protected Set < Node > closure ( DependencyKind ... depKinds ) { boolean progress = BOOL_ ; Set < Node > closure = new HashSet < Node > ( ) ; closure . add ( this ) ; while ( progress ) { progress = BOOL_ ; for ( Node n1 : new HashSet < Node > ( closure ) ) { progress = closure . addAll ( n1 . getDependencies ( depKinds ) ) ; } } return closure ; }
public Vector ( Collection c ) { elementCount = c . size ( ) ; elementData = new Object [ ( int ) Math . min ( ( elementCount . NUM_ ) / NUM_ , Integer . MAX_VALUE ) ] ; c . toArray ( elementData ) ; }
private void expand ( int i ) { if ( count + i <= buf . length ) { return ; } byte [ ] newbuf = mPool . getBuf ( ( count + i ) . NUM_ ) ; System . arraycopy ( buf , NUM_ , newbuf , NUM_ , count ) ; mPool . returnBuf ( buf ) ; buf = newbuf ; }
public static < A extends Annotation > A createAnnotation ( Class < ? extends Annotation > annotationType , AnnotationMember [ ] elements ) { AnnotationFactory factory = new AnnotationFactory ( annotationType , elements ) ; return ( A ) Proxy . newProxyInstance ( annotationType . getClassLoader ( ) , new Class [ ] { annotationType } , factory ) ; }
public LinkingMorphemes ( String ... aMorphemes ) { morphemes = new ArrayList < String > ( ) ; for ( String string : aMorphemes ) { morphemes . add ( string ) ; } }
@ Override public void execute ( MetricTimeSeries timeSeries , FunctionValueMap functionValueMap ) { if ( timeSeries . size ( ) <= NUM_ ) { functionValueMap . add ( this , Double . NaN ) ; return ; } timeSeries . sort ( ) ; double firstValue = timeSeries . getValue ( NUM_ ) ; double lastValue = timeSeries . getValue ( timeSeries . size ( ) - NUM_ ) ; functionValueMap . add ( this , Math . abs ( firstValue - lastValue ) ) ; }
public static URL [ ] findResourceBases ( String baseResource , ClassLoader loader ) { ArrayList < URL > list = new ArrayList < URL > ( ) ; try { Enumeration < URL > urls = loader . getResources ( baseResource ) ; while ( urls . hasMoreElements ( ) ) { URL url = urls . nextElement ( ) ; list . add ( findResourceBase ( url , baseResource ) ) ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return list . toArray ( new URL [ list . size ( ) ] ) ; }
public WritableRaster createWritableChild ( int x , int y , int width , int height , int x0 , int y0 , int bandList [ ] ) { if ( x < this . minX ) { throw new RasterFormatException ( STR_ ) ; } if ( y < this . minY ) { throw new RasterFormatException ( STR_ ) ; } if ( ( x + width < x ) || ( x + width > this . width + this . minX ) ) { throw new RasterFormatException ( STR_ ) ; } if ( ( y + height < y ) || ( y + height > this . height + this . minY ) ) { throw new RasterFormatException ( STR_ ) ; } SampleModel sm ; if ( bandList != null ) sm = sampleModel . createSubsetSampleModel ( bandList ) ; else sm = sampleModel ; int deltaX = x0 - x ; int deltaY = y0 - y ; return new ByteBandedRaster ( sm , dataBuffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sampleModelTranslateX + deltaX , sampleModelTranslateY + deltaY ) , this ) ; }
protected void moveUpItem ( ) { if ( selectionTable . getSelectionCount ( ) == NUM_ ) { return ; } for ( final int index : selectionTable . getSelectionIndices ( ) ) { if ( index == NUM_ ) { selectionTable . forceFocus ( ) ; return ; } } final int [ ] newSelection = new int [ selectionTable . getSelectionCount ( ) ] ; int newSelectionIndex = NUM_ ; for ( final TableItem tableItem : selectionTable . getSelection ( ) ) { final int position = selection . indexOf ( tableItem . getData ( ) ) ; swap ( position , position - NUM_ ) ; newSelection [ newSelectionIndex ++ ] = position - NUM_ ; } redrawTables ( ) ; selectionTable . select ( newSelection ) ; selectionTable . forceFocus ( ) ; }
protected void maybeFireBoundsInvalidated ( Rectangle invalidatedArea ) { Drawing d = getDrawing ( ) ; Rectangle2D . Double canvasBounds = new Rectangle2D . Double ( NUM_ , NUM_ , NUM_ , NUM_ ) ; if ( d . get ( CANVAS_WIDTH ) != null ) { canvasBounds . width += d . get ( CANVAS_WIDTH ) ; } if ( d . get ( CANVAS_HEIGHT ) != null ) { canvasBounds . height += d . get ( CANVAS_HEIGHT ) ; } if ( ! canvasBounds . contains ( invalidatedArea ) ) { fireBoundsInvalidated ( invalidatedArea ) ; } }
public DatagramPacket responseReceive ( ) throws IOException { byte [ ] buf = new byte [ NUM_ ] ; DatagramPacket dp = new DatagramPacket ( buf , buf . length ) ; datagramSocket . receive ( dp ) ; return dp ; }
public void suspend ( String id ) { TraceState ts = traceState . get ( ) ; if ( log . isLoggable ( Level . FINEST ) ) { log . finest ( STR_ + ts + STR_ + id ) ; } if ( ts != null ) { setExpire ( ts ) ; try { suspendedStateLock . lock ( ) ; if ( suspendedState . containsKey ( id ) && log . isLoggable ( Level . FINEST ) ) { log . finest ( STR_ + suspendedState . get ( id ) + STR_ + id ) ; } suspendedState . put ( id , ts ) ; traceState . remove ( ) ; } finally { suspendedStateLock . unlock ( ) ; } } }
public static int hashCode ( final Object obj ) { return ( obj == null ? NUM_ : obj . hashCode ( ) ) ; }
public static int maxLevel ( ) { return LEVELS - NUM_ ; }
public void propertyChange ( PropertyChangeEvent evt ) { repaint ( ) ; }
public static boolean removeBeanOrFolder ( String path ) { return removePath ( path . split ( PATH_SEPARATOR ) , s_directory , NUM_ ) > NUM_ ; }
private void updateSelection ( Mode mode , Projection2D proj , SVGPoint p1 , SVGPoint p2 ) { DBIDSelection selContext = context . getSelection ( ) ; HashSetModifiableDBIDs selection ; if ( selContext == null || mode == Mode . REPLACE ) { selection = DBIDUtil . newHashSet ( ) ; } else { selection = DBIDUtil . newHashSet ( selContext . getSelectedIds ( ) ) ; } for ( DBIDIter iditer = rel . iterDBIDs ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { double [ ] vec = proj . fastProjectDataToRenderSpace ( rel . get ( iditer ) ) ; if ( vec [ NUM_ ] >= Math . min ( p1 . getX ( ) , p2 . getX ( ) ) && vec [ NUM_ ] <= Math . max ( p1 . getX ( ) , p2 . getX ( ) ) && vec [ NUM_ ] >= Math . min ( p1 . getY ( ) , p2 . getY ( ) ) && vec [ NUM_ ] <= Math . max ( p1 . getY ( ) , p2 . getY ( ) ) ) { if ( mode == Mode . INVERT ) { if ( ! selection . contains ( iditer ) ) { selection . add ( iditer ) ; } else { selection . remove ( iditer ) ; } } else { selection . add ( iditer ) ; } } } context . setSelection ( new DBIDSelection ( selection ) ) ; }
public EclipseIniLauncher ( File installationRoot ) throws FileNotFoundException , IOException { FileMisc . assertMacApp ( installationRoot ) ; Objects . requireNonNull ( installationRoot ) ; eclipseIni = EclipseIni . parseFrom ( new File ( installationRoot , FileMisc . macContentsEclipse ( ) + STR_ ) ) ; }
public boolean canAddMember ( String realmName , String idType , String containerIDType ) throws AMConsoleException { boolean can = BOOL_ ; try { IdType type = IdUtils . getType ( idType ) ; Set canAdd = type . canAddMembers ( ) ; IdType ctype = IdUtils . getType ( containerIDType ) ; can = canAdd . contains ( ctype ) ; } catch ( IdRepoException e ) { debug . warning ( STR_ , e ) ; throw new AMConsoleException ( getErrorString ( e ) ) ; } return can ; }
private static Node locateAttrParent ( Element elem , Node attr ) { Node parent = null ; Attr check = elem . getAttributeNode ( attr . getNodeName ( ) ) ; if ( check == attr ) parent = elem ; if ( null == parent ) { for ( Node node = elem . getFirstChild ( ) ; null != node ; node = node . getNextSibling ( ) ) { if ( Node . ELEMENT_NODE == node . getNodeType ( ) ) { parent = locateAttrParent ( ( Element ) node , attr ) ; if ( null != parent ) break ; } } } return parent ; }
private void defineInternalFrames ( UIDefaults d ) { d . put ( STR_ , new InsetsUIResource ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; d . put ( STR_ , new DimensionUIResource ( NUM_ , NUM_ ) ) ; d . put ( STR_ , new InsetsUIResource ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; d . put ( STR_ , new InsetsUIResource ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; d . put ( STR_ , STR_ ) ; d . put ( STR_ , new InsetsUIResource ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; d . put ( STR_ , new InsetsUIResource ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; d . put ( STR_ , new InsetsUIResource ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; d . put ( STR_ , new InsetsUIResource ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; if ( PlatformUtils . isMac ( ) ) { d . put ( STR_ , new Color ( xa8a8a8 ) ) ; } else { d . put ( STR_ , new Color ( x96adc4 ) ) ; } d . put ( STR_ , new Color ( xe0e0e0 ) ) ; d . put ( STR_ , new Color ( x545454 ) ) ; d . put ( STR_ , new Color ( x55ffffff , BOOL_ ) ) ; d . put ( STR_ , new Color ( x55ffffff , BOOL_ ) ) ; d . put ( STR_ , new Color ( x99000000 , BOOL_ ) ) ; d . put ( STR_ , new Color ( x26000000 , BOOL_ ) ) ; d . put ( STR_ , new Color ( x99ffffff , BOOL_ ) ) ; d . put ( STR_ , new Color ( xe5101010 , BOOL_ ) ) ; d . put ( STR_ , new Color ( x267a7a7a , BOOL_ ) ) ; d . put ( STR_ , new Color ( xffffff ) ) ; d . put ( STR_ , new Color ( xe50e0e0e , BOOL_ ) ) ; d . put ( STR_ , new Color ( x876e6e6e , BOOL_ ) ) ; d . put ( STR_ , new Color ( xe6e6e6 ) ) ; String p = STR_ ; String c = PAINTER_PREFIX + STR_ ; d . put ( p + STR_ , new DerivedFont ( STR_ , NUM_ , BOOL_ , null ) ) ; d . put ( p + STR_ , STR_ ) ; d . put ( p + STR_ , new TitlePaneWindowFocusedState ( ) ) ; d . put ( p + STR_ , new InternalFrameWindowFocusedState ( ) ) ; d . put ( p + STR_ , new LazyPainter ( c , FrameAndRootPainter . Which . BACKGROUND_ENABLED ) ) ; d . put ( p + STR_ , new LazyPainter ( c , FrameAndRootPainter . Which . BACKGROUND_ENABLED_WINDOWFOCUSED ) ) ; p = STR_ ; d . put ( p + STR_ , NUM_ ) ; p = STR_ ; d . put ( p + STR_ , d . get ( STR_ ) ) ; d . put ( p + STR_ , Color . BLACK ) ; }
public static double cosQuick ( double angle ) { if ( USE_JDK_MATH ) { return STRICT_MATH ? StrictMath . cos ( angle ) : Math . cos ( angle ) ; } return cosTab [ ( ( int ) ( Math . abs ( angle ) . SIN_COS_INDEXER + NUM_ ) ) & ( SIN_COS_TABS_SIZE - NUM_ ) ] ; }
public static void w ( String tag , String msg , Object ... args ) { if ( sLevel > LEVEL_WARNING ) { return ; } if ( args . length > NUM_ ) { msg = String . format ( msg , args ) ; } Log . w ( tag , msg ) ; }
public void readSecurityHeader ( SipResponse response ) throws PayloadException { WWWAuthenticateHeader wwwHeader = ( WWWAuthenticateHeader ) response . getHeader ( WWWAuthenticateHeader . NAME ) ; AuthenticationInfoHeader infoHeader = ( AuthenticationInfoHeader ) response . getHeader ( AuthenticationInfoHeader . NAME ) ; if ( wwwHeader != null ) { mDigest . setRealm ( wwwHeader . getRealm ( ) ) ; mDigest . setOpaque ( wwwHeader . getOpaque ( ) ) ; mDigest . setQop ( wwwHeader . getQop ( ) ) ; mDigest . setNextnonce ( wwwHeader . getNonce ( ) ) ; } else if ( infoHeader != null ) { if ( infoHeader . getNextNonce ( ) != null ) { mDigest . setNextnonce ( infoHeader . getNextNonce ( ) ) ; } } }
private void layoutPanel ( ) { setBorder ( BorderFactory . createEmptyBorder ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; setLayout ( new BorderLayout ( ) ) ; add ( new LabelledItem ( STR_ , cbDistribution ) , BorderLayout . NORTH ) ; add ( cardPanel , BorderLayout . CENTER ) ; cbItemListener . itemStateChanged ( new ItemEvent ( cbDistribution , ItemEvent . SELECTED , cardPanel , ItemEvent . ITEM_STATE_CHANGED ) ) ; repaint ( ) ; revalidate ( ) ; }
@ Override public int compareTo ( DoubleDoublePair other ) { int fdiff = Double . compare ( this . first , other . first ) ; if ( fdiff != NUM_ ) { return fdiff ; } return Double . compare ( this . second , other . second ) ; }
private static boolean fileExists ( String filePath ) { File file = new File ( filePath ) ; return file . exists ( ) ; }
public static String classVersionToJdk ( int version ) { return STR_ + Integer . toString ( version - NUM_ ) ; }
private BitSet createBitSet ( final String binaryString ) { final BitSet bset = new BitSet ( binaryString . length ( ) ) ; boolean bitTrue = BOOL_ ; for ( int i = NUM_ ; i < binaryString . length ( ) ; i ++ ) { if ( binaryString . charAt ( i ) == STR_ ) { bitTrue = BOOL_ ; } else { bitTrue = BOOL_ ; } bset . set ( i , bitTrue ) ; } return bset ; }
public void flush ( ) { buffer . force ( ) ; }
public void remove ( Product product ) { try { solrDao . remove ( product . getId ( ) ) ; } catch ( IOException | SolrServerException ex ) { LOGGER . error ( STR_ + product . getIdentifier ( ) + STR_ , ex ) ; } }
public void startBackgroundFetchService ( ) { LocalNotification n = new LocalNotification ( ) ; n . setId ( BACKGROUND_FETCH_NOTIFICATION_ID ) ; cancelLocalNotification ( BACKGROUND_FETCH_NOTIFICATION_ID ) ; scheduleLocalNotification ( n , System . currentTimeMillis ( ) + getPreferredBackgroundFetchInterval ( ) . NUM_ , NUM_ ) ; }
protected void showModels ( boolean show , EpoxyModel < ? > ... models ) { showModels ( Arrays . asList ( models ) , show ) ; }
static void check ( PublicKey key , X509CRL crl ) throws CertPathValidatorException { X509CRLImpl x509CRLImpl = null ; try { x509CRLImpl = X509CRLImpl . toImpl ( crl ) ; } catch ( CRLException ce ) { throw new CertPathValidatorException ( ce ) ; } AlgorithmId algorithmId = x509CRLImpl . getSigAlgId ( ) ; check ( key , algorithmId ) ; }
public void testUserDataHandlerNotifiedOfOnlyShallowAdoptions ( ) throws Exception { domToString ( document ) ; RecordingHandler handler = new RecordingHandler ( ) ; name . setUserData ( STR_ , STR_ , handler ) ; name . setUserData ( STR_ , STR_ , handler ) ; standard . setUserData ( STR_ , STR_ , handler ) ; waffles . setUserData ( STR_ , STR_ , handler ) ; Document newDocument = builder . newDocument ( ) ; assertSame ( name , newDocument . adoptNode ( name ) ) ; assertSame ( newDocument , name . getOwnerDocument ( ) ) ; assertSame ( newDocument , standard . getOwnerDocument ( ) ) ; assertSame ( newDocument , waffles . getOwnerDocument ( ) ) ; Set < String > expected = new HashSet < String > ( ) ; expected . add ( notification ( NODE_ADOPTED , STR_ , STR_ , name , null ) ) ; expected . add ( notification ( NODE_ADOPTED , STR_ , STR_ , name , null ) ) ; assertEquals ( expected , handler . calls ) ; }
public void reset ( ) { node_list . clear ( ) ; }
public String nameList ( String dir ) throws IOException { passive ( ) ; send ( STR_ + dir ) ; readCode ( NUM_ ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; IOUtils . copyAndClose ( inData , out ) ; readCode ( NUM_ ) ; byte [ ] data = out . toByteArray ( ) ; return new String ( data ) ; }
public VNXeCommandResult addLunsToLunGroup ( String lunGroupId , List < String > luns ) { LunGroupModifyParam param = new LunGroupModifyParam ( ) ; List < LunAddParam > lunAdds = new ArrayList < LunAddParam > ( ) ; for ( String lunId : luns ) { VNXeBase lun = new VNXeBase ( lunId ) ; LunAddParam lunAdd = new LunAddParam ( ) ; lunAdd . setLun ( lun ) ; lunAdds . add ( lunAdd ) ; } param . setLunAdd ( lunAdds ) ; LunGroupRequests req = new LunGroupRequests ( _khClient ) ; return req . modifyLunGroupSync ( lunGroupId , param ) ; }
public static InputStream toInputStream ( CharSequence input , Charset encoding ) { return toInputStream ( input . toString ( ) , encoding ) ; }
public static ConstantExpression constant ( Object value , Class constantType ) { return new ConstantExpression ( value , constantType . getName ( ) ) ; }
public static final String toFEN ( Position pos ) { StringBuilder ret = new StringBuilder ( ) ; for ( int r = NUM_ ; r >= NUM_ ; r -- ) { int numEmpty = NUM_ ; for ( int c = NUM_ ; c < NUM_ ; c ++ ) { int p = pos . getPiece ( Position . getSquare ( c , r ) ) ; if ( p == Piece . EMPTY ) { numEmpty ++ ; } else { if ( numEmpty > NUM_ ) { ret . append ( numEmpty ) ; numEmpty = NUM_ ; } switch ( p ) { case Piece . WKING : ret . append ( STR_ ) ; break ; case Piece . WQUEEN : ret . append ( STR_ ) ; break ; case Piece . WROOK : ret . append ( STR_ ) ; break ; case Piece . WBISHOP : ret . append ( STR_ ) ; break ; case Piece . WKNIGHT : ret . append ( STR_ ) ; break ; case Piece . WPAWN : ret . append ( STR_ ) ; break ; case Piece . BKING : ret . append ( STR_ ) ; break ; case Piece . BQUEEN : ret . append ( STR_ ) ; break ; case Piece . BROOK : ret . append ( STR_ ) ; break ; case Piece . BBISHOP : ret . append ( STR_ ) ; break ; case Piece . BKNIGHT : ret . append ( STR_ ) ; break ; case Piece . BPAWN : ret . append ( STR_ ) ; break ; default : throw new RuntimeException ( ) ; } } } if ( numEmpty > NUM_ ) { ret . append ( numEmpty ) ; } if ( r > NUM_ ) { ret . append ( STR_ ) ; } } ret . append ( pos . whiteMove ? STR_ : STR_ ) ; boolean anyCastle = BOOL_ ; if ( pos . h1Castle ( ) ) { ret . append ( STR_ ) ; anyCastle = BOOL_ ; } if ( pos . a1Castle ( ) ) { ret . append ( STR_ ) ; anyCastle = BOOL_ ; } if ( pos . h8Castle ( ) ) { ret . append ( STR_ ) ; anyCastle = BOOL_ ; } if ( pos . a8Castle ( ) ) { ret . append ( STR_ ) ; anyCastle = BOOL_ ; } if ( ! anyCastle ) { ret . append ( STR_ ) ; } { ret . append ( STR_ ) ; if ( pos . getEpSquare ( ) >= NUM_ ) { int x = Position . getX ( pos . getEpSquare ( ) ) ; int y = Position . getY ( pos . getEpSquare ( ) ) ; ret . append ( ( char ) ( x + STR_ ) ) ; ret . append ( ( char ) ( y + STR_ ) ) ; } else { ret . append ( STR_ ) ; } } ret . append ( STR_ ) ; ret . append ( pos . halfMoveClock ) ; ret . append ( STR_ ) ; ret . append ( pos . fullMoveCounter ) ; return ret . toString ( ) ; }
public void endElement ( String uri , String localName , String qName ) throws SAXException { if ( ! ( htmlMode && ( uri . equals ( STR_ ) || uri . equals ( STR_ ) ) && ( qName . equals ( STR_ ) || qName . equals ( STR_ ) || qName . equals ( STR_ ) || qName . equals ( STR_ ) || qName . equals ( STR_ ) || qName . equals ( STR_ ) || qName . equals ( STR_ ) || qName . equals ( STR_ ) || qName . equals ( STR_ ) || qName . equals ( STR_ ) || qName . equals ( STR_ ) || qName . equals ( STR_ ) || qName . equals ( STR_ ) ) ) ) { write ( STR_ ) ; writeName ( uri , localName , qName , BOOL_ ) ; write ( STR_ ) ; } if ( elementLevel == NUM_ ) { write ( STR_ ) ; } cdataElement = BOOL_ ; super . endElement ( uri , localName , qName ) ; nsSupport . popContext ( ) ; elementLevel -- ; }
static void findAllVisibleChilds ( final ViewGroup viewGroup , final List < View > ordoredChilds ) { for ( int childViewIndex = NUM_ ; childViewIndex < viewGroup . getChildCount ( ) ; childViewIndex ++ ) { final View childView = viewGroup . getChildAt ( childViewIndex ) ; if ( childView instanceof ViewGroup ) { findAllVisibleChilds ( ( ViewGroup ) childView , ordoredChilds ) ; continue ; } if ( childView . getVisibility ( ) == View . VISIBLE ) { ordoredChilds . add ( childView ) ; } } }
public boolean logModified ( Logger log ) { if ( isModified ( ) ) { log . info ( _className + STR_ ) ; return BOOL_ ; } else return BOOL_ ; }
public final void push ( Node value ) { int ff = m_firstFree ; if ( ( ff + NUM_ ) >= m_mapSize ) { if ( null == m_map ) { m_map = new Node [ m_blocksize ] ; m_mapSize = m_blocksize ; } else { m_mapSize += m_blocksize ; Node newMap [ ] = new Node [ m_mapSize ] ; System . arraycopy ( m_map , NUM_ , newMap , NUM_ , ff + NUM_ ) ; m_map = newMap ; } } m_map [ ff ] = value ; ff ++ ; m_firstFree = ff ; }
public String serialize ( Object obj ) throws ApiException { try { if ( obj != null ) return mapper . writeValueAsString ( obj ) ; else return null ; } catch ( Exception e ) { throw new ApiException ( NUM_ , e . getMessage ( ) ) ; } }
private void initializeSparseSlider ( ) { sparsitySlider . setMajorTickSpacing ( NUM_ ) ; sparsitySlider . setMinorTickSpacing ( NUM_ ) ; sparsitySlider . setPaintTicks ( BOOL_ ) ; Hashtable < Integer , JLabel > labelTable2 = new Hashtable < Integer , JLabel > ( ) ; labelTable2 . put ( new Integer ( NUM_ ) , new JLabel ( STR_ ) ) ; labelTable2 . put ( new Integer ( NUM_ ) , new JLabel ( STR_ ) ) ; sparsitySlider . setLabelTable ( labelTable2 ) ; sparsitySlider . setPaintLabels ( BOOL_ ) ; }
@ Override protected void autoAdjustRange ( ) { Plot plot = getPlot ( ) ; if ( plot == null ) { return ; } if ( plot instanceof ValueAxisPlot ) { ValueAxisPlot vap = ( ValueAxisPlot ) plot ; Range r = vap . getDataRange ( this ) ; if ( r == null ) { r = getDefaultAutoRange ( ) ; } double upper = r . getUpperBound ( ) ; double lower = Math . max ( r . getLowerBound ( ) , this . smallestValue ) ; double range = upper - lower ; double fixedAutoRange = getFixedAutoRange ( ) ; if ( fixedAutoRange > NUM_ ) { lower = Math . max ( upper - fixedAutoRange , this . smallestValue ) ; } else { double minRange = getAutoRangeMinimumSize ( ) ; if ( range < minRange ) { double expand = ( minRange - range ) / NUM_ ; upper = upper + expand ; lower = lower - expand ; } double logUpper = calculateLog ( upper ) ; double logLower = calculateLog ( lower ) ; double logRange = logUpper - logLower ; logUpper = logUpper + getUpperMargin ( ) . logRange ; logLower = logLower - getLowerMargin ( ) . logRange ; upper = calculateValueNoINF ( logUpper ) ; lower = calculateValueNoINF ( logLower ) ; } setRange ( new Range ( lower , upper ) , BOOL_ , BOOL_ ) ; } }
public synchronized void add ( long value ) { long res = get ( ) + value ; lb . put ( NUM_ , res ) ; }
public void addIVCombination ( int attackIV , int defenseIV , int staminaIV ) { int sumIV = attackIV + defenseIV + staminaIV ; int percentPerfect = Math . round ( sumIV / NUM_ . NUM_ ) ; if ( ( percentPerfect < lowPercent ) || ( percentPerfect == lowPercent ) && ( attackIV < lowAttack ) ) { lowPercent = percentPerfect ; lowAttack = attackIV ; lowDefense = defenseIV ; lowStamina = staminaIV ; } if ( ( percentPerfect > highPercent ) || ( percentPerfect == highPercent ) && ( attackIV > highAttack ) ) { highPercent = percentPerfect ; highAttack = attackIV ; highDefense = defenseIV ; highStamina = staminaIV ; } iVCombinations . add ( new IVCombination ( attackIV , defenseIV , staminaIV ) ) ; }
String [ ] qualify ( String cppName ) { if ( cppName == null || cppName . length ( ) == NUM_ ) { return new String [ NUM_ ] ; } ArrayList < String > names = new ArrayList < String > ( ) ; String ns = namespace != null ? namespace : STR_ ; while ( ns != null ) { String name = ns . length ( ) > NUM_ ? ns + STR_ + cppName : cppName ; TemplateMap map = templateMap ; while ( map != null ) { if ( name . equals ( map . getName ( ) ) ) { String args = STR_ , separator = STR_ ; for ( String s : map . values ( ) ) { args += separator + s ; separator = STR_ ; } names . add ( name + args + ( args . endsWith ( STR_ ) ? STR_ : STR_ ) ) ; break ; } map = map . parent ; } names . add ( name ) ; ns = InfoMap . normalize ( ns , BOOL_ , BOOL_ ) ; int i = ns . lastIndexOf ( STR_ ) ; ns = i >= NUM_ ? ns . substring ( NUM_ , i ) : ns . length ( ) > NUM_ ? STR_ : null ; } for ( String s : usingList ) { String prefix = InfoMap . normalize ( cppName , BOOL_ , BOOL_ ) ; int i = s . lastIndexOf ( STR_ ) + NUM_ ; ns = s . substring ( NUM_ , i ) ; String suffix = s . substring ( i ) ; if ( suffix . length ( ) == NUM_ || prefix . equals ( suffix ) ) { names . add ( ns + cppName ) ; } } return names . toArray ( new String [ names . size ( ) ] ) ; }
@ Nullable public Bitmap generateIconForUrl ( String url , boolean includePrivateRegistries ) { if ( TextUtils . isEmpty ( url ) ) return null ; String text = getIconTextForUrl ( url , includePrivateRegistries ) ; if ( TextUtils . isEmpty ( text ) ) return null ; return generateIconForText ( text ) ; }
public boolean containsPrefix ( final CharSequence prefix ) { return containsPrefix ( prefix , NUM_ , prefix . length ( ) ) ; }
public int compareTo ( Object p_other ) { if ( p_other == null ) return NUM_ ; if ( p_other instanceof BrdComponent ) { return name . compareToIgnoreCase ( ( ( BrdComponent ) p_other ) . name ) ; } return NUM_ ; }
public void fatal ( String message ) throws SAXException { SAXParseException spe = new SAXParseException ( message , this ) ; if ( errorHandler != null ) { errorHandler . fatalError ( spe ) ; } throw spe ; }
@ Override public void close ( ) throws IOException { closed = BOOL_ ; def . end ( ) ; in . close ( ) ; }
protected final void firePropertyChange ( String propertyName , boolean oldValue , boolean newValue ) { PropertyChangeSupport aChangeSupport = this . changeSupport ; if ( aChangeSupport == null ) { return ; } aChangeSupport . firePropertyChange ( propertyName , oldValue , newValue ) ; }
public void removeScrollingListener ( OnWheelScrollListener listener ) { scrollingListeners . remove ( listener ) ; }
private Iterator < BindingSet > joinBindingSetEntry ( Map . Entry < String , BindingSet > entry ) { List < Collection < BindingSet > > matches = new ArrayList < > ( ) ; if ( type == HashJoinType . CONSTANT_JOIN_VAR ) { if ( bindingJoinVarHash . containsKey ( entry . getKey ( ) ) ) { matches . add ( bindingJoinVarHash . get ( entry . getKey ( ) ) ) ; } } else { List < String > valOrders = getValueOrders ( entry . getKey ( ) ) ; for ( String s : valOrders ) { if ( bindingJoinVarHash . containsKey ( s ) ) { matches . add ( bindingJoinVarHash . get ( s ) ) ; } } } if ( matches . size ( ) == NUM_ ) { return Collections . emptyIterator ( ) ; } else { return new BindingSetCollectionsJoinIterator ( entry . getValue ( ) , matches ) ; } }
@ Override public void test ( Number t ) throws ParameterException { if ( t . doubleValue ( ) >= constraintValue . doubleValue ( ) ) { throw new WrongParameterValueException ( STR_ + STR_ + constraintValue . toString ( ) + STR_ + t . doubleValue ( ) + STR_ ) ; } }
public void testFindUsersActiveDirectory ( ) throws Exception { LdapManager mgr = getLdapAD ( ) ; List ret = null ; AndFilter filter = new AndFilter ( ) ; filter . and ( new LikeFilter ( mgr . getUsersReturningAttribute ( LdapUserAttributeConstants . LDAP_USER_ATTRIBUTE_GIVEN_NAME ) , STR_ ) ) ; try { LdapSearchManagerVO searchMgrVO = new LdapSearchManagerVO ( ) ; searchMgrVO . setFilter ( filter ) ; searchMgrVO . setAddUserClasses ( BOOL_ ) ; ret = mgr . findUsers ( searchMgrVO ) ; } catch ( Exception e ) { } assertEquals ( NUM_ , ret . size ( ) ) ; }
public boolean reserve ( Object object ) { reservedIdsLock . lock ( ) ; if ( reservedObjects . contains ( object ) ) { reservedIdsLock . unlock ( ) ; return BOOL_ ; } reservedObjects . add ( object ) ; reservedIdsLock . unlock ( ) ; return BOOL_ ; }
private boolean saveStoredJPEGImage ( String file_name , final BufferedImage image , final boolean file_name_is_path ) { if ( ! file_name_is_path ) { file_name = temp_dir + key + file_name ; } final String s = file_name . toLowerCase ( ) ; if ( ! s . endsWith ( STR_ ) && ! s . endsWith ( STR_ ) ) { file_name += STR_ ; } try { DefaultImageHelper . write ( image , STR_ , file_name ) ; tempFileNames . put ( file_name , STR_ ) ; } catch ( final Exception e ) { LogWriter . writeLog ( STR_ + e + STR_ + image + STR_ + file_name ) ; } return BOOL_ ; }
public static ScheduledExecutorService createScheduler ( ) { final ScheduledExecutorService scheduler = Executors . newScheduledThreadPool ( NUM_ , new DaemonThreadFactory ( DEFAULT_SCHEDULER_NAME ) ) ; SCHEDULERS . add ( scheduler ) ; return scheduler ; }
public LinkedList < Patch > patch_make ( String text1 , String text2 ) { if ( text1 == null || text2 == null ) { throw new IllegalArgumentException ( STR_ ) ; } LinkedList < Diff > diffs = diff_main ( text1 , text2 , BOOL_ ) ; if ( diffs . size ( ) > NUM_ ) { diff_cleanupSemantic ( diffs ) ; diff_cleanupEfficiency ( diffs ) ; } return patch_make ( text1 , diffs ) ; }
protected static void fail ( ) { System . exit ( NUM_ ) ; }
private Rect calcBounds ( int index , Paint paint ) { Rect bounds = new Rect ( ) ; CharSequence title = getTitle ( index ) ; bounds . right = ( int ) paint . measureText ( title , NUM_ , title . length ( ) ) ; bounds . bottom = ( int ) ( paint . descent ( ) - paint . ascent ( ) ) ; return bounds ; }
private void printArguments ( List < Expression > args , Object arg ) { printer . print ( STR_ ) ; if ( args != null ) { for ( Iterator < Expression > i = args . iterator ( ) ; i . hasNext ( ) ; ) { Expression e = i . next ( ) ; e . accept ( this , arg ) ; if ( i . hasNext ( ) ) { printer . print ( STR_ ) ; } } } printer . print ( STR_ ) ; }
private void calculateDelta ( double [ ] b ) { double numerator = NUM_ ; double denominator = NUM_ ; double sign = NUM_ ; for ( int k = NUM_ ; k < b . length ; k ++ ) { if ( k < mExtremalIndices . size ( ) ) { int extremalIndex = mExtremalIndices . get ( k ) ; numerator += ( b [ k ] . mGrid . getDesiredResponse ( ) [ extremalIndex ] ) ; denominator += b [ k ] . sign / mGrid . getWeight ( ) [ extremalIndex ] ; sign = - sign ; } else { mLog . error ( STR_ ) ; } } mDelta = numerator / denominator ; }
public static float buildFloat ( int mant , int exp ) { if ( exp < - NUM_ || mant == NUM_ ) { return NUM_ ; } if ( exp >= NUM_ ) { return ( mant > NUM_ ) ? Float . POSITIVE_INFINITY : Float . NEGATIVE_INFINITY ; } if ( exp == NUM_ ) { return mant ; } if ( mant >= ( NUM_ << NUM_ ) ) { mant ++ ; } return ( float ) ( ( exp > NUM_ ) ? mant . pow10 [ exp ] : mant / pow10 [ - exp ] ) ; }
private void addFallbackSelector ( Properties settings , ProtocolDispatchSelector ps ) { String proxy = settings . getProperty ( STR_ ) ; if ( proxy != null ) { ps . setFallbackSelector ( ProxyUtil . parseProxySettings ( proxy ) ) ; } }
private void readData ( ) throws IOException { while ( ! isClosed ) { int code = is . read ( ) ; switch ( code ) { case STR_ : case STR_ : case STR_ : case STR_ : break ; case STR_ : { int channel = ( is . read ( ) << NUM_ ) + is . read ( ) ; inputReady [ channel ] = BOOL_ ; return ; } case STR_ : { int channel = ( is . read ( ) << NUM_ ) + is . read ( ) ; int status = ( is . read ( ) << NUM_ ) + is . read ( ) ; inputReady [ channel ] = BOOL_ ; return ; } case - NUM_ : close ( ) ; return ; default : close ( ) ; return ; } } return ; }
@ Override protected boolean validateConnection ( Connection conn ) { try { return ( ! conn . isClosed ( ) ) ; } catch ( SQLException e ) { return BOOL_ ; } }
public static byte [ ] decode ( String s ) { return decode ( s . toCharArray ( ) ) ; }
public PacProxySelector ( String pacUrl ) { if ( pacUrl == null ) { throw new NullPointerException ( ) ; } this . pacUrl = pacUrl ; }
public void deleteAlertingDefinition ( AlertingDefinition alertingDefinition ) throws IOException { String id = alertingDefinition . getId ( ) ; AlertingDefinition local = existingAlertingDefinitions . remove ( id ) ; if ( local != null ) { Files . deleteIfExists ( pathResolver . getAlertingDefinitionFilePath ( local ) ) ; eventPublisher . publishEvent ( new AbstractAlertingDefinitionEvent . AlertingDefinitionDeletedEvent ( this , local ) ) ; } }
public void addFile ( File file ) { fileList . addFirst ( file ) ; }
private void pullEvent ( ) { final int newScrollValue ; final int itemDimension ; final float initialMotionValue , lastMotionValue ; switch ( getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : initialMotionValue = mInitialMotionX ; lastMotionValue = mLastMotionX ; break ; case VERTICAL : default : initialMotionValue = mInitialMotionY ; lastMotionValue = mLastMotionY ; break ; } switch ( mCurrentMode ) { case PULL_FROM_END : newScrollValue = Math . round ( Math . max ( initialMotionValue - lastMotionValue , NUM_ ) / FRICTION ) ; itemDimension = getFooterSize ( ) ; break ; case PULL_FROM_START : default : newScrollValue = Math . round ( Math . min ( initialMotionValue - lastMotionValue , NUM_ ) / FRICTION ) ; itemDimension = getHeaderSize ( ) ; break ; } setHeaderScroll ( newScrollValue ) ; if ( newScrollValue != NUM_ && ! isRefreshing ( ) ) { float scale = Math . abs ( newScrollValue ) / ( float ) itemDimension ; switch ( mCurrentMode ) { case PULL_FROM_END : mFooterLayout . onPull ( scale ) ; break ; case PULL_FROM_START : default : mHeaderLayout . onPull ( scale ) ; break ; } if ( mState != State . PULL_TO_REFRESH && itemDimension >= Math . abs ( newScrollValue ) ) { setState ( State . PULL_TO_REFRESH ) ; } else if ( mState != State . RELEASE_TO_REFRESH && itemDimension < Math . abs ( newScrollValue ) ) { setState ( State . RELEASE_TO_REFRESH ) ; } } }
public boolean requiresConnection ( ) { return BOOL_ ; }
public static double tile2lat ( int y , int z ) { double n = Math . PI - ( NUM_ . Math . PI . y ) / Math . pow ( NUM_ , z ) ; return Math . toDegrees ( Math . atan ( Math . sinh ( n ) ) ) ; }
@ Override public synchronized TimeSeriesCollection updateCollection ( ) { return super . updateCollection ( ) ; }
public char skip ( int n ) { _pos += n ; if ( _length <= _pos ) { _pos = _string . length ( ) ; return DONE ; } else return _string . charAt ( _pos ) ; }
public void writeToObject ( Object object ) { try { Method method = BeanUtils . getWriteMethod ( object . getClass ( ) , getName ( ) , getType ( ) ) ; if ( method != null ) { method . invoke ( object , new Object [ ] { getValue ( ) } ) ; } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
private boolean shouldInform ( LocalClientInfo info ) { long now = System . currentTimeMillis ( ) ; if ( now < _nextAllowedTime ) return BOOL_ ; Long allowed = BUG_TIMES . get ( info . getParsedBug ( ) ) ; return allowed == null || now >= allowed . longValue ( ) ; }
public void post ( Runnable runnable ) { synchronized ( mQueue ) { mQueue . add ( runnable ) ; if ( mQueue . size ( ) == NUM_ ) { scheduleNextLocked ( ) ; } } }
public static void clear ( ) { _clearCount ++ ; _stateCount = NUM_ ; _state = STR_ ; _featureMap . clear ( ) ; }
public static String toStringPretty ( JsonObject jsonObj , int level ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( STR_ ) ; buf . append ( fieldsToStringPretty ( jsonObj , level + NUM_ ) ) ; buf . append ( STR_ ) ; return buf . toString ( ) ; }
public boolean isLaunchedFromJar ( ) { return ( lstJarFile . size ( ) > NUM_ ) ; }
protected void savePassCodeAndExit ( ) { Intent resultIntent = new Intent ( ) ; resultIntent . putExtra ( KEY_PASSCODE , mPassCodeDigits [ NUM_ ] + mPassCodeDigits [ NUM_ ] + mPassCodeDigits [ NUM_ ] + mPassCodeDigits [ NUM_ ] ) ; setResult ( RESULT_OK , resultIntent ) ; finish ( ) ; }
public LogStream print ( double d ) { if ( ps != null ) { indent ( ) ; lineBuffer . append ( d ) ; } return this ; }
public static void deleteDirectoryRecursively ( Context context , File f , Boolean onlyContent ) throws IOException { if ( f . isDirectory ( ) ) { for ( File c : f . listFiles ( ) ) { deleteDirectoryRecursively ( context , c , BOOL_ ) ; } } if ( ! onlyContent ) { if ( ! f . delete ( ) ) { throw new IOException ( STR_ + f ) ; } context . sendBroadcast ( new Intent ( Intent . ACTION_MEDIA_SCANNER_SCAN_FILE , Uri . parse ( STR_ + f . getAbsolutePath ( ) ) ) ) ; } }
public static String nodeSubTypeToString ( int subType ) { String val = STR_ ; switch ( subType ) { case NodeRepresentation . AND_TYPE : val = STR_ ; break ; case NodeRepresentation . OR_TYPE : val = STR_ ; break ; case NodeRepresentation . IMPLIES_TYPE : val = STR_ ; break ; case NodeRepresentation . FORALL_TYPE : val = STR_ ; break ; case NodeRepresentation . EXISTS_TYPE : val = STR_ ; break ; case NodeRepresentation . SQSUB_TYPE : val = STR_ ; break ; case NodeRepresentation . OTHER_TYPE : val = STR_ ; break ; } return val ; }
public static void disposeGraphicsConfig ( long pConfigInfo ) { OGLRenderQueue rq = getInstance ( ) ; rq . lock ( ) ; try { OGLContext . setScratchSurface ( pConfigInfo ) ; RenderBuffer buf = rq . getBuffer ( ) ; rq . ensureCapacityAndAlignment ( NUM_ , NUM_ ) ; buf . putInt ( DISPOSE_CONFIG ) ; buf . putLong ( pConfigInfo ) ; rq . flushNow ( ) ; } finally { rq . unlock ( ) ; } }
private void addTerm ( String term ) { Integer index = termToIndex . get ( term ) ; if ( index == null ) { synchronized ( this ) { index = termToIndex . get ( term ) ; if ( index == null ) { index = Integer . valueOf ( termIndexCounter . getAndIncrement ( ) ) ; termToIndex . put ( term , index ) ; } } } }
private void safeBottomView ( ) { Status status = getOpenStatus ( ) ; ViewGroup bottom = getBottomView ( ) ; if ( status == Status . Close ) { if ( bottom . getVisibility ( ) != INVISIBLE ) bottom . setVisibility ( INVISIBLE ) ; } else { if ( bottom . getVisibility ( ) != VISIBLE ) bottom . setVisibility ( VISIBLE ) ; } }
public static String revertNewLines ( String string ) { int index ; StringBuffer newStringBuffer = new StringBuffer ( ) ; while ( ( index = string . indexOf ( STR_ ) ) != - NUM_ ) { if ( index > NUM_ ) { newStringBuffer . append ( string . substring ( NUM_ , index ) ) ; } newStringBuffer . append ( STR_ ) ; if ( ( index + NUM_ ) < string . length ( ) ) { string = string . substring ( index + NUM_ ) ; } else { string = STR_ ; } } newStringBuffer . append ( string ) ; string = newStringBuffer . toString ( ) ; newStringBuffer = new StringBuffer ( ) ; while ( ( index = string . indexOf ( STR_ ) ) != - NUM_ ) { if ( index > NUM_ ) { newStringBuffer . append ( string . substring ( NUM_ , index ) ) ; } newStringBuffer . append ( STR_ ) ; if ( ( index + NUM_ ) < string . length ( ) ) { string = string . substring ( index + NUM_ ) ; } else { string = STR_ ; } } newStringBuffer . append ( string ) ; return newStringBuffer . toString ( ) ; }
@ Override public List < Period > generatePeriods ( DateTimeUnit dateTimeUnit ) { Calendar cal = getCalendar ( ) ; boolean past = dateTimeUnit . getMonth ( ) >= ( getBaseMonth ( ) + NUM_ ) ; List < Period > periods = Lists . newArrayList ( ) ; dateTimeUnit = cal . minusYears ( dateTimeUnit , past ? NUM_ : NUM_ ) ; dateTimeUnit . setMonth ( getBaseMonth ( ) + NUM_ ) ; dateTimeUnit . setDay ( NUM_ ) ; Calendar calendar = getCalendar ( ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { periods . add ( createPeriod ( dateTimeUnit , cal ) ) ; dateTimeUnit = calendar . plusYears ( dateTimeUnit , NUM_ ) ; } return periods ; }
public final boolean isDragging ( ) { return dragging ; }
@ Override public void escape ( char [ ] buffer , int start , int length , boolean isAttributeValue , Writer outputWriter ) throws IOException { for ( int i = start ; i < start + length ; i ++ ) { char ch = buffer [ i ] ; if ( ch == STR_ ) { outputWriter . write ( STR_ ) ; continue ; } if ( ch == STR_ ) { outputWriter . write ( STR_ ) ; continue ; } if ( ch == STR_ ) { outputWriter . write ( STR_ ) ; continue ; } if ( ch == STR_ && isAttributeValue ) { outputWriter . write ( STR_ ) ; continue ; } if ( ch == STR_ && isAttributeValue ) { outputWriter . write ( STR_ ) ; continue ; } if ( isXml11RestrictedCharacter ( ch ) ) { outputWriter . write ( STR_ ) ; outputWriter . write ( Integer . toHexString ( ch ) ) ; outputWriter . write ( STR_ ) ; continue ; } outputWriter . write ( ch ) ; } }
void encrypt ( ByteBuffer src ) throws SSLException { if ( ! handshakeComplete ) { throw new IllegalStateException ( ) ; } if ( ! src . hasRemaining ( ) ) { if ( outNetBuffer == null ) { outNetBuffer = emptyBuffer ; } return ; } createOutNetBuffer ( src . remaining ( ) ) ; while ( src . hasRemaining ( ) ) { SSLEngineResult result = sslEngine . wrap ( src , outNetBuffer . buf ( ) ) ; if ( result . getStatus ( ) == SSLEngineResult . Status . OK ) { if ( result . getHandshakeStatus ( ) == SSLEngineResult . HandshakeStatus . NEED_TASK ) { doTasks ( ) ; } } else if ( result . getStatus ( ) == SSLEngineResult . Status . BUFFER_OVERFLOW ) { outNetBuffer . capacity ( outNetBuffer . capacity ( ) << NUM_ ) ; outNetBuffer . limit ( outNetBuffer . capacity ( ) ) ; } else { throw new SSLException ( STR_ + result . getStatus ( ) + STR_ + src + STR_ + outNetBuffer ) ; } } outNetBuffer . flip ( ) ; }
public boolean codeMatches ( String queryCode ) { int length = id . length ( ) ; if ( Debug . debugging ( STR_ ) ) { Debug . output ( STR_ + queryCode + STR_ + id + STR_ + startIndex + STR_ + length ) ; } return queryCode . regionMatches ( BOOL_ , startIndex , id , NUM_ , length ) ; }
private static int parseNotificationId ( String id ) { try { return Integer . parseInt ( id ) ; } catch ( NumberFormatException nfe ) { Log . w ( TAG , STR_ + id ) ; return - NUM_ ; } }
private < T > Property < T > prepare ( String key , Property < T > property , T initialValue ) { final ChangeListener < T > change = null ; property . setValue ( initialValue ) ; property . addListener ( change ) ; change . changed ( property , null , initialValue ) ; return property ; }
protected void readTillEOL ( ) throws IOException { while ( m_Tokenizer . nextToken ( ) != StreamTokenizer . TT_EOL ) { } m_Tokenizer . pushBack ( ) ; }
@ Override public void clearAnswer ( ) { DateTime ldt = new DateTime ( ) ; mTimePicker . setCurrentHour ( ldt . getHourOfDay ( ) ) ; mTimePicker . setCurrentMinute ( ldt . getMinuteOfHour ( ) ) ; }
public String readLine ( ) throws IOException { return keepCarriageReturns ? readUntilNewline ( ) : reader . readLine ( ) ; }
@ Override public void doWork ( ) throws OperatorException { super . doWork ( ) ; runVectorOutput . deliver ( runVector ) ; }
public Shape createArrowUp ( final double x , final double y , final double w , final double h ) { path . reset ( ) ; path . moveTo ( x , y + h ) ; path . lineTo ( x + w / NUM_ , y ) ; path . lineTo ( x + w , y + h ) ; path . closePath ( ) ; return path ; }
public SimpleUserContext ( AuthenticationProvider authProvider , String username , Map < String , GuacamoleConfiguration > configs ) { Collection < String > connectionIdentifiers = new ArrayList < String > ( configs . size ( ) ) ; Collection < String > connectionGroupIdentifiers = Collections . singleton ( ROOT_IDENTIFIER ) ; Collection < Connection > connections = new ArrayList < Connection > ( configs . size ( ) ) ; for ( Map . Entry < String , GuacamoleConfiguration > configEntry : configs . entrySet ( ) ) { String identifier = configEntry . getKey ( ) ; GuacamoleConfiguration config = configEntry . getValue ( ) ; Connection connection = new SimpleConnection ( identifier , identifier , config ) ; connection . setParentIdentifier ( ROOT_IDENTIFIER ) ; connections . add ( connection ) ; connectionIdentifiers . add ( identifier ) ; } this . rootGroup = new SimpleConnectionGroup ( ROOT_IDENTIFIER , ROOT_IDENTIFIER , connectionIdentifiers , Collections . < String > emptyList ( ) ) ; this . self = new SimpleUser ( username , connectionIdentifiers , connectionGroupIdentifiers ) ; this . userDirectory = new SimpleUserDirectory ( self ) ; this . connectionDirectory = new SimpleConnectionDirectory ( connections ) ; this . connectionGroupDirectory = new SimpleConnectionGroupDirectory ( Collections . singleton ( this . rootGroup ) ) ; this . authProvider = authProvider ; }
public void reset ( ) { visitedGet . clear ( ) ; visitedPost . clear ( ) ; for ( SpiderParser parser : parsers ) { parser . removeSpiderParserListener ( this ) ; } }
private static float CallStaticFloatMethodV ( JNIEnvironment env , int classJREF , int methodID , Address argAddress ) throws Exception { if ( traceJNI ) VM . sysWrite ( STR_ ) ; RuntimeEntrypoints . checkJNICountDownToGC ( ) ; try { Object returnObj = JNIHelpers . invokeWithVarArg ( methodID , argAddress , TypeReference . Float ) ; return Reflection . unwrapFloat ( returnObj ) ; } catch ( Throwable unexpected ) { if ( traceJNI ) unexpected . printStackTrace ( System . err ) ; env . recordException ( unexpected ) ; return NUM_ ; } }
public NamedList < Object > toNamedList ( ) { final SimpleOrderedMap < Object > result = new SimpleOrderedMap < > ( ) ; for ( Iterator < String > it = getParameterNamesIterator ( ) ; it . hasNext ( ) ; ) { final String name = it . next ( ) ; final String [ ] values = getParams ( name ) ; if ( values . length == NUM_ ) { result . add ( name , values [ NUM_ ] ) ; } else { result . add ( name , values ) ; } } return result ; }
private boolean isRepresentingTab ( String text ) { if ( text == null ) return BOOL_ ; if ( isInsertingSpacesForTab ( ) ) { if ( text . length ( ) == NUM_ || text . length ( ) > getVisualTabLengthPreference ( ) ) return BOOL_ ; for ( int i = NUM_ ; i < text . length ( ) ; i ++ ) { if ( text . charAt ( i ) != STR_ ) return BOOL_ ; } return BOOL_ ; } else return text . length ( ) == NUM_ && text . charAt ( NUM_ ) == STR_ ; }
public MonitorThread ( String name ) { super ( name ) ; }
public void removeDragListener ( DragListener l ) { mListeners . remove ( l ) ; }
@ Override public UnitsRelations init ( ProcessingEnvironment env ) { elements = env . getElementUtils ( ) ; m = UnitsRelationsTools . buildAnnoMirrorWithDefaultPrefix ( env , m . class ) ; km = UnitsRelationsTools . buildAnnoMirrorWithSpecificPrefix ( env , m . class , Prefix . kilo ) ; mm = UnitsRelationsTools . buildAnnoMirrorWithSpecificPrefix ( env , m . class , Prefix . milli ) ; m2 = UnitsRelationsTools . buildAnnoMirrorWithNoPrefix ( env , m2 . class ) ; km2 = UnitsRelationsTools . buildAnnoMirrorWithNoPrefix ( env , km2 . class ) ; mm2 = UnitsRelationsTools . buildAnnoMirrorWithNoPrefix ( env , mm2 . class ) ; s = UnitsRelationsTools . buildAnnoMirrorWithDefaultPrefix ( env , s . class ) ; h = UnitsRelationsTools . buildAnnoMirrorWithNoPrefix ( env , h . class ) ; mPERs = UnitsRelationsTools . buildAnnoMirrorWithNoPrefix ( env , mPERs . class ) ; kmPERh = UnitsRelationsTools . buildAnnoMirrorWithNoPrefix ( env , kmPERh . class ) ; mPERs2 = UnitsRelationsTools . buildAnnoMirrorWithNoPrefix ( env , mPERs2 . class ) ; return this ; }
public static String [ ] toStringArray ( Collection < String > collection ) { if ( collection == null ) { return null ; } return collection . toArray ( new String [ collection . size ( ) ] ) ; }
public void persist ( RepositoryProxyCache proxyCache ) { persist ( proxyCache , proxyCache . getFileName ( ) ) ; }
public IOUtils ( ) { super ( ) ; }
public String formatDeleteNfsExportCmd ( String dataMover , String path ) { StringBuilder cmd = new StringBuilder ( ) ; cmd . append ( STR_ ) ; cmd . append ( dataMover ) ; cmd . append ( STR_ ) ; cmd . append ( STR_ ) ; cmd . append ( path ) ; return cmd . toString ( ) ; }
public final String matchCategories ( Set < String > categories ) { if ( categories == null ) { return null ; } Iterator < String > it = categories . iterator ( ) ; if ( mCategories == null ) { return it . hasNext ( ) ? it . next ( ) : null ; } while ( it . hasNext ( ) ) { final String category = it . next ( ) ; if ( ! mCategories . contains ( category ) ) { return category ; } } return null ; }
@ Override public void run ( ) { try { ClassReader reader = new ClassReader ( new FileInputStream ( this . classFile ) ) ; AsmClassVisitor visitor = new AsmClassVisitor ( this . dataProvider , this . config ) ; reader . accept ( visitor , ClassReader . SKIP_DEBUG ) ; } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , e . getMessage ( ) , e ) ; } }
private void addLocationAndTrackPropertyChange ( ) { for ( Location loc : locationManager . getList ( ) ) { loc . addPropertyChangeListener ( this ) ; for ( Track track : loc . getTrackList ( ) ) { track . addPropertyChangeListener ( this ) ; Schedule schedule = track . getSchedule ( ) ; if ( schedule != null ) { schedule . addPropertyChangeListener ( this ) ; } } } }
private void handleJsonSignIn ( RequestAndResponse requestAndResponse ) throws IOException , ServletException { requestAndResponse . setResponseContentTypeJson ( ) ; String userName ; String password ; String csrft ; try { final JsonNodeHelper json = getJsonNode ( requestAndResponse ) ; userName = json . getString ( STR_ ) ; password = json . getString ( STR_ ) ; csrft = json . getString ( STR_ ) ; } catch ( final IOException e ) { returnJson400 ( requestAndResponse , servletText . errorJson ( ) ) ; return ; } if ( userName != null ) { userName = userName . toLowerCase ( ) ; } if ( isTheCsrftWrong ( requestAndResponse , csrft ) ) { returnJson400 ( requestAndResponse , servletText . errorWrongCsrft ( ) ) ; return ; } if ( userName == null || userName . isEmpty ( ) ) { returnJson400 ( requestAndResponse , servletText . errorUsernameMustNotBeBlank ( ) ) ; return ; } if ( password == null || password . isEmpty ( ) ) { returnJson400 ( requestAndResponse , servletText . errorPasswordMustNotBeBlank ( ) ) ; return ; } if ( ! AccountAttributeValidator . isUserNameValid ( userName ) ) { returnJson400 ( requestAndResponse , servletText . errorUserNameIsNotValid ( ) ) ; return ; } if ( ! AccountAttributeValidator . isPasswordValid ( password ) ) { returnJson400 ( requestAndResponse , servletText . errorPasswordIsNotValid ( ) ) ; return ; } try { final User user = dbLogic . getUserByUserName ( userName ) ; if ( user == null ) { returnJson400 ( requestAndResponse , servletText . errorNoAccountFound ( ) ) ; return ; } if ( user . getIsAccountClosed ( ) ) { returnJson400 ( requestAndResponse , servletText . errorAccountIsClosed ( ) ) ; return ; } final String realPassword = user . getPassword ( ) ; if ( realPassword == null || ! realPassword . equals ( DigestUtils . sha1Hex ( password ) ) ) { returnJson400 ( requestAndResponse , servletText . errorPasswordIsIncorrect ( ) ) ; return ; } mapSessionToUser ( requestAndResponse , user . getId ( ) ) ; dbLogic . commit ( ) ; returnJson200 ( requestAndResponse ) ; } catch ( final PersistenceException e ) { logger . log ( Level . INFO , STR_ , e ) ; returnJson500 ( requestAndResponse , servletText . errorInternalDatabase ( ) ) ; } }
private void _schedule ( Activity a , long startTime ) { if ( a . isScheduled ( ) ) { try { notifyAll ( ) ; } catch ( Exception e ) { } return ; } a . setStartTime ( startTime ) ; synchronized ( this ) { m_activities . add ( a ) ; a . setScheduled ( BOOL_ ) ; if ( startTime < m_nextTime ) { m_nextTime = startTime ; notify ( ) ; } } }
void unregisterCallback ( BluetoothCallback callback ) { synchronized ( mCallbacks ) { mCallbacks . remove ( callback ) ; } }
public void testHashCodeUnequal ( ) { String a = STR_ ; int aScale = NUM_ ; String b = STR_ ; int bScale = - NUM_ ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal bNumber = new BigDecimal ( new BigInteger ( b ) , bScale ) ; assertTrue ( STR_ , aNumber . hashCode ( ) != bNumber . hashCode ( ) ) ; }
protected final void refreshLoadingViewsSize ( ) { final int maximumPullScroll = ( int ) ( getMaximumPullScroll ( ) . NUM_ ) ; int pLeft = getPaddingLeft ( ) ; int pTop = getPaddingTop ( ) ; int pRight = getPaddingRight ( ) ; int pBottom = getPaddingBottom ( ) ; switch ( getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setWidth ( maximumPullScroll ) ; pLeft = - maximumPullScroll ; } else { pLeft = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setWidth ( maximumPullScroll ) ; pRight = - maximumPullScroll ; } else { pRight = NUM_ ; } break ; case VERTICAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setHeight ( maximumPullScroll ) ; pTop = - maximumPullScroll ; } else { pTop = NUM_ ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setHeight ( maximumPullScroll ) ; pBottom = - maximumPullScroll ; } else { pBottom = NUM_ ; } break ; } if ( DEBUG ) { Log . d ( LOG_TAG , String . format ( STR_ , pLeft , pTop , pRight , pBottom ) ) ; } setPadding ( pLeft , pTop , pRight , pBottom ) ; }
@ VisibleForTesting static String escapeSqlString ( String string ) { return string . replaceAll ( STR_ , STR_ ) ; }
public static String [ ] toArray ( String arg ) { if ( arg == null ) { return new String [ NUM_ ] ; } StringTokenizer tok = new StringTokenizer ( arg , STR_ ) ; String [ ] array = new String [ tok . countTokens ( ) ] ; int i = NUM_ ; while ( tok . hasMoreTokens ( ) ) { array [ i ] = tok . nextToken ( ) ; i ++ ; } return ( array ) ; }
private void appendUploadedEntryToLog ( String id ) throws IOException { FileWriter writer = new FileWriter ( mLogfile , BOOL_ ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( System . currentTimeMillis ( ) / NUM_ ) ; sb . append ( STR_ ) ; sb . append ( id ) ; sb . append ( STR_ ) ; try { writer . write ( sb . toString ( ) ) ; } finally { writer . close ( ) ; } }
private void renderLeafNode ( final CNodeNode treeNode ) { final NaviNode graphNode = treeNode . getNode ( ) ; if ( graphNode . isSelected ( ) && graphNode . isVisible ( ) ) { setForeground ( SELECTED_FONT_COLOR ) ; } else if ( ! graphNode . isVisible ( ) ) { setForeground ( INVISIBLE_FONT_COLOR ) ; } setToolTipText ( buildToolTip ( graphNode ) ) ; }
public static final void writeValueXml ( Object v , String name , XmlSerializer out ) throws XmlPullParserException , IOException { String typeStr ; if ( v == null ) { out . startTag ( null , STR_ ) ; if ( name != null ) { out . attribute ( null , STR_ , name ) ; } out . endTag ( null , STR_ ) ; return ; } else if ( v instanceof String ) { out . startTag ( null , STR_ ) ; if ( name != null ) { out . attribute ( null , STR_ , name ) ; } out . text ( v . toString ( ) ) ; out . endTag ( null , STR_ ) ; return ; } else if ( v instanceof Integer ) { typeStr = STR_ ; } else if ( v instanceof Long ) { typeStr = STR_ ; } else if ( v instanceof Float ) { typeStr = STR_ ; } else if ( v instanceof Double ) { typeStr = STR_ ; } else if ( v instanceof Boolean ) { typeStr = STR_ ; } else if ( v instanceof byte [ ] ) { writeByteArrayXml ( ( byte [ ] ) v , name , out ) ; return ; } else if ( v instanceof int [ ] ) { writeIntArrayXml ( ( int [ ] ) v , name , out ) ; return ; } else if ( v instanceof Map ) { writeMapXml ( ( Map ) v , name , out ) ; return ; } else if ( v instanceof List ) { writeListXml ( ( List ) v , name , out ) ; return ; } else if ( v instanceof Set ) { writeSetXml ( ( Set ) v , name , out ) ; return ; } else if ( v instanceof CharSequence ) { out . startTag ( null , STR_ ) ; if ( name != null ) { out . attribute ( null , STR_ , name ) ; } out . text ( v . toString ( ) ) ; out . endTag ( null , STR_ ) ; return ; } else { throw new RuntimeException ( STR_ + v ) ; } out . startTag ( null , typeStr ) ; if ( name != null ) { out . attribute ( null , STR_ , name ) ; } out . attribute ( null , STR_ , v . toString ( ) ) ; out . endTag ( null , typeStr ) ; }
public Sector union ( double latitude , double longitude ) { if ( this . minLatitude < this . maxLatitude && this . minLongitude < this . maxLongitude ) { this . maxLatitude = Math . max ( this . maxLatitude , latitude ) ; this . minLatitude = Math . min ( this . minLatitude , latitude ) ; this . maxLongitude = Math . max ( this . maxLongitude , longitude ) ; this . minLongitude = Math . min ( this . minLongitude , longitude ) ; } else if ( ! Double . isNaN ( this . minLatitude ) && ! Double . isNaN ( this . minLongitude ) ) { this . maxLatitude = Math . max ( this . minLatitude , latitude ) ; this . maxLongitude = Math . max ( this . minLongitude , longitude ) ; this . minLatitude = Math . min ( this . minLatitude , latitude ) ; this . minLongitude = Math . min ( this . minLongitude , longitude ) ; } else { this . minLatitude = latitude ; this . minLongitude = longitude ; this . maxLatitude = Double . NaN ; this . maxLongitude = Double . NaN ; } return this ; }
public DAuthorityKeyIdentifier ( JDialog parent , PublicKey authorityPublicKey , X500Name authorityCertName , BigInteger authorityCertSerialNumber ) { super ( parent ) ; setTitle ( res . getString ( STR_ ) ) ; this . authorityPublicKey = authorityPublicKey ; initComponents ( ) ; prepopulateWithAuthorityCertDetails ( authorityCertName , authorityCertSerialNumber ) ; }
static void writeUTF ( OutputStream out , String str ) throws IOException { for ( int i = NUM_ , len = str . length ( ) ; i < len ; i ++ ) { int c = str . charAt ( i ) ; if ( ( c >= x0001 ) && ( c <= x007F ) ) { out . write ( c ) ; } else { if ( c > x07FF ) { out . write ( xE0 | ( ( c > > NUM_ ) & x0F ) ) ; out . write ( x80 | ( ( c > > NUM_ ) & x3F ) ) ; out . write ( x80 | ( ( c > > NUM_ ) & x3F ) ) ; } else { out . write ( xC0 | ( ( c > > NUM_ ) & x1F ) ) ; out . write ( x80 | ( ( c > > NUM_ ) & x3F ) ) ; } } } }
public void test_getIterator ( ) { String test = STR_ ; try { AttributedString attrString = new AttributedString ( test ) ; AttributedCharacterIterator it = attrString . getIterator ( ) ; assertEquals ( STR_ , it . first ( ) , test . charAt ( NUM_ ) ) ; } catch ( Exception e ) { fail ( STR_ + e . toString ( ) ) ; } }
private void handleNormalUnassociated ( ) { int szSsaRegs = ssaMeth . getRegCount ( ) ; for ( int ssaReg = NUM_ ; ssaReg < szSsaRegs ; ssaReg ++ ) { if ( ssaRegsMapped . get ( ssaReg ) ) { continue ; } RegisterSpec ssaSpec = getDefinitionSpecForSsaReg ( ssaReg ) ; if ( ssaSpec == null ) continue ; int category = ssaSpec . getCategory ( ) ; int ropReg = findNextUnreservedRopReg ( paramRangeEnd , category ) ; while ( ! canMapReg ( ssaSpec , ropReg ) ) { ropReg = findNextUnreservedRopReg ( ropReg + NUM_ , category ) ; } addMapping ( ssaSpec , ropReg ) ; } }
public void addSeriesRenderer ( int index , SimpleSeriesRenderer renderer ) { mRenderers . add ( index , renderer ) ; }
private E unlinkFirst ( ) { Node < E > f = first ; if ( f == null ) return null ; Node < E > n = f . next ; E item = f . item ; f . item = null ; f . next = f ; first = n ; if ( n == null ) last = null ; else n . prev = null ; -- count ; notFull . signal ( ) ; return item ; }
public void createUnderlying ( ) { if ( Platform . isFxApplicationThread ( ) ) { options . createUnderlying ( ) ; this . marker = new com . lynden . gmapsfx . javascript . object . Marker ( options . convert ( ) ) ; } }
private void onActionUp ( MotionEvent event ) { if ( isDown ) { this . startX = NUM_ ; this . startY = NUM_ ; this . isDown = BOOL_ ; } }
private Rectangle2D createAlignedRectangle2D ( Size2D dimensions , Rectangle2D frame , HorizontalAlignment hAlign , VerticalAlignment vAlign ) { double x = Double . NaN ; double y = Double . NaN ; if ( hAlign == HorizontalAlignment . LEFT ) { x = frame . getX ( ) ; } else if ( hAlign == HorizontalAlignment . CENTER ) { x = frame . getCenterX ( ) - ( dimensions . width / NUM_ ) ; } else if ( hAlign == HorizontalAlignment . RIGHT ) { x = frame . getMaxX ( ) - dimensions . width ; } if ( vAlign == VerticalAlignment . TOP ) { y = frame . getY ( ) ; } else if ( vAlign == VerticalAlignment . CENTER ) { y = frame . getCenterY ( ) - ( dimensions . height / NUM_ ) ; } else if ( vAlign == VerticalAlignment . BOTTOM ) { y = frame . getMaxY ( ) - dimensions . height ; } return new Rectangle2D . Double ( x , y , dimensions . width , dimensions . height ) ; }
public MailAddress ( InternetAddress address ) throws AddressException { this ( address . getAddress ( ) ) ; }
public double [ ] [ ] confusionMatrix ( ) { double [ ] [ ] newMatrix = new double [ m_ConfusionMatrix . length ] [ NUM_ ] ; for ( int i = NUM_ ; i < m_ConfusionMatrix . length ; i ++ ) { newMatrix [ i ] = new double [ m_ConfusionMatrix [ i ] . length ] ; System . arraycopy ( m_ConfusionMatrix [ i ] , NUM_ , newMatrix [ i ] , NUM_ , m_ConfusionMatrix [ i ] . length ) ; } return newMatrix ; }
public void print ( int x ) { out . print ( x ) ; out . flush ( ) ; }
public static void beginStartingService ( Context context , Intent intent ) { synchronized ( mStartingServiceSync ) { if ( mStartingService == null ) { PowerManager pm = ( PowerManager ) context . getSystemService ( Context . POWER_SERVICE ) ; mStartingService = pm . newWakeLock ( PowerManager . PARTIAL_WAKE_LOCK , STR_ ) ; mStartingService . setReferenceCounted ( BOOL_ ) ; } mStartingService . acquire ( ) ; context . startService ( intent ) ; } }
public ScannerException ( ErrorMessages message , int line ) { this ( null , ErrorMessages . get ( message ) , message , line , - NUM_ ) ; }
private static void attemptRetryOnException ( String logPrefix , Request < ? > request , VolleyError exception ) throws VolleyError { RetryPolicy retryPolicy = request . getRetryPolicy ( ) ; int oldTimeout = request . getTimeoutMs ( ) ; try { retryPolicy . retry ( exception ) ; } catch ( VolleyError e ) { request . addMarker ( String . format ( STR_ , logPrefix , oldTimeout ) ) ; throw e ; } request . addMarker ( String . format ( STR_ , logPrefix , oldTimeout ) ) ; }
private void informUponSimilarName ( final StringBuffer messageBuffer , final String name , final String candidate ) { if ( name . equals ( candidate ) ) { return ; } if ( name . regionMatches ( BOOL_ , NUM_ , candidate , NUM_ , PKG_LEN + NUM_ ) ) { messageBuffer . append ( STR_ ) ; messageBuffer . append ( candidate ) ; messageBuffer . append ( STR_ ) ; } }
public synchronized void co_exit ( int thisCoroutine ) { m_activeIDs . clear ( thisCoroutine ) ; m_nextCoroutine = NOBODY ; notify ( ) ; }
private int findSchemeSeparator ( ) { return cachedSsi == NOT_CALCULATED ? cachedSsi = uriString . indexOf ( STR_ ) : cachedSsi ; }
@ Override public boolean test ( Object receiver , String property , Object [ ] args , Object expectedValue ) { if ( IS_ANGULAR_CLI_PROJECT_PROPERTY . equals ( property ) ) { return testIsAngularCLIProject ( receiver ) ; } return BOOL_ ; }
public void refresh ( ) { label . setText ( String . valueOf ( MathHelper . round ( val , NUM_ ) ) ) ; if ( val == min ) minus . setEnabled ( BOOL_ ) ; else minus . setEnabled ( BOOL_ ) ; if ( val == max ) plus . setEnabled ( BOOL_ ) ; else plus . setEnabled ( BOOL_ ) ; if ( cb != null ) cb . callback ( val ) ; plus . repaint ( ) ; minus . repaint ( ) ; if ( progress != null ) { progress . setValue ( val / max ) ; } }
public String [ ] readAllLines ( ) { ArrayList < String > lines = new ArrayList < String > ( ) ; while ( hasNextLine ( ) ) { lines . add ( readLine ( ) ) ; } return lines . toArray ( new String [ NUM_ ] ) ; }
public void removeCallback ( Callback callback ) { mCallbacks . remove ( callback ) ; }
public void error ( SourceLocator srcLctr , String msg ) throws TransformerException { error ( srcLctr , null , null , msg , null ) ; }
private boolean expectVlvResponse ( ) { Boolean expected = Boolean . FALSE ; try { expected = ( Boolean ) get ( EXPECT_VLV_RESPONSE ) ; } catch ( Exception e ) { } return expected == null ? BOOL_ : expected . booleanValue ( ) ; }
public void layoutContainer ( final Container parent ) { checkLayout ( getModel ( ) ) ; final Insets insets = parent . getInsets ( ) ; final Dimension size = parent . getSize ( ) ; final int width = size . width - ( insets . left + insets . right ) ; final int height = size . height - ( insets . top + insets . bottom ) ; final Rectangle bounds = new Rectangle ( insets . left , insets . top , width , height ) ; layout1 ( getModel ( ) , bounds ) ; layout2 ( getModel ( ) , bounds ) ; }
private String readUntil ( char [ ] delimiter , boolean returnText ) throws IOException , XmlPullParserException { int start = position ; StringBuilder result = null ; if ( returnText && text != null ) { result = new StringBuilder ( ) ; result . append ( text ) ; } search : while ( BOOL_ ) { if ( position + delimiter . length > limit ) { if ( start < position && returnText ) { if ( result == null ) { result = new StringBuilder ( ) ; } result . append ( buffer , start , position - start ) ; } if ( ! fillBuffer ( delimiter . length ) ) { checkRelaxed ( UNEXPECTED_EOF ) ; type = COMMENT ; return null ; } start = position ; } for ( int i = NUM_ ; i < delimiter . length ; i ++ ) { if ( buffer [ position + i ] != delimiter [ i ] ) { position ++ ; continue search ; } } break ; } int end = position ; position += delimiter . length ; if ( ! returnText ) { return null ; } else if ( result == null ) { return stringPool . get ( buffer , start , end - start ) ; } else { result . append ( buffer , start , end - start ) ; return result . toString ( ) ; } }
@ Override public Invocation . Builder accept ( String ... mediaTypes ) { clientRequestContext . setAcceptResponseTypesStr ( Arrays . asList ( mediaTypes ) ) ; return this ; }
public StreamConsumer ( InputStream stream ) { in = new BufferedInputStream ( stream ) ; thread . start ( ) ; }
public static String subString ( String string , int beginIndex , int length ) { if ( string == null ) { return null ; } final int endIndex = beginIndex + length ; if ( beginIndex >= string . length ( ) ) { return EMPTY ; } if ( endIndex > string . length ( ) ) { return string . substring ( beginIndex , string . length ( ) ) ; } return string . substring ( beginIndex , endIndex ) ; }
private static SocketImpl createSocketImpl ( ) { try { return socketImplCtor . newInstance ( ) ; } catch ( InstantiationException x ) { throw new AssertionError ( x ) ; } catch ( IllegalAccessException x ) { throw new AssertionError ( x ) ; } catch ( InvocationTargetException x ) { throw new AssertionError ( x ) ; } }
@ Override public String encode ( ) { return name . substring ( NUM_ , NUM_ ) ; }
private void updateBaseMatrix ( Drawable d ) { ImageView imageView = getImageView ( ) ; if ( null == imageView || null == d ) { return ; } final float viewWidth = getImageViewWidth ( imageView ) ; final float viewHeight = getImageViewHeight ( imageView ) ; final int drawableWidth = d . getIntrinsicWidth ( ) ; final int drawableHeight = d . getIntrinsicHeight ( ) ; mBaseMatrix . reset ( ) ; final float widthScale = viewWidth / drawableWidth ; final float heightScale = viewHeight / drawableHeight ; if ( mScaleType == ScaleType . CENTER ) { mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth ) / NUM_ , ( viewHeight - drawableHeight ) / NUM_ ) ; } else if ( mScaleType == ScaleType . CENTER_CROP ) { float scale = Math . max ( widthScale , heightScale ) ; mBaseMatrix . postScale ( scale , scale ) ; mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth . scale ) / NUM_ , ( viewHeight - drawableHeight . scale ) / NUM_ ) ; } else if ( mScaleType == ScaleType . CENTER_INSIDE ) { float scale = Math . min ( NUM_ , Math . min ( widthScale , heightScale ) ) ; mBaseMatrix . postScale ( scale , scale ) ; mBaseMatrix . postTranslate ( ( viewWidth - drawableWidth . scale ) / NUM_ , ( viewHeight - drawableHeight . scale ) / NUM_ ) ; } else { RectF mTempSrc = new RectF ( NUM_ , NUM_ , drawableWidth , drawableHeight ) ; RectF mTempDst = new RectF ( NUM_ , NUM_ , viewWidth , viewHeight ) ; if ( ( int ) mBaseRotation % NUM_ != NUM_ ) { mTempSrc = new RectF ( NUM_ , NUM_ , drawableHeight , drawableWidth ) ; } switch ( mScaleType ) { case FIT_CENTER : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . CENTER ) ; break ; case FIT_START : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . START ) ; break ; case FIT_END : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . END ) ; break ; case FIT_XY : mBaseMatrix . setRectToRect ( mTempSrc , mTempDst , ScaleToFit . FILL ) ; break ; default : break ; } } resetMatrix ( ) ; }
void cancelAll ( ) { synchronized ( currentRequests ) { for ( DownloadRequest request : currentRequests ) { request . cancel ( ) ; } } currentRequests . clear ( ) ; }
protected void addDocs ( String index , String type , int number ) throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper ( ) ; for ( int i = NUM_ ; i < number ; i ++ ) { index ( index , type , STR_ + i , mapper . writeValueAsString ( TestDocument . createSimpleDoc ( i ) ) ) ; } flush ( ) ; }
public void testPowNegativeNumToZeroExp ( ) { byte aBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ } ; int aSign = - NUM_ ; int exp = NUM_ ; byte rBytes [ ] = { NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger result = aNumber . pow ( exp ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public final ParallelFlux < T > doOnError ( Consumer < ? super Throwable > onError ) { Objects . requireNonNull ( onError , STR_ ) ; return doOnSignal ( this , null , null , onError , null , null , null , null , null ) ; }
public void simulateMethod ( SootMethod method , ReferenceVariable thisVar , ReferenceVariable returnVar , ReferenceVariable params [ ] ) { String subSignature = method . getSubSignature ( ) ; if ( subSignature . equals ( STR_ ) ) { java_lang_System_arraycopy ( method , thisVar , returnVar , params ) ; return ; } else if ( subSignature . equals ( STR_ ) ) { java_lang_System_setIn0 ( method , thisVar , returnVar , params ) ; return ; } else if ( subSignature . equals ( STR_ ) ) { java_lang_System_setOut0 ( method , thisVar , returnVar , params ) ; return ; } else if ( subSignature . equals ( STR_ ) ) { java_lang_System_setErr0 ( method , thisVar , returnVar , params ) ; return ; } else if ( subSignature . equals ( STR_ ) ) { java_lang_System_initProperties ( method , thisVar , returnVar , params ) ; return ; } else if ( subSignature . equals ( STR_ ) ) { java_lang_System_mapLibraryName ( method , thisVar , returnVar , params ) ; return ; } else if ( subSignature . equals ( STR_ ) ) { java_lang_System_getCallerClass ( method , thisVar , returnVar , params ) ; return ; } else { defaultMethod ( method , thisVar , returnVar , params ) ; return ; } }
protected void loadValue ( String sValue ) { try { value = Long . parseLong ( sValue . trim ( ) ) ; } catch ( NumberFormatException nfe ) { revertToDefault ( ) ; } }
public void checkBounds ( ) { tfLowBound . setEnabled ( tsClipping . isSelected ( ) ) ; tfUpBound . setEnabled ( tsClipping . isSelected ( ) ) ; }
public void remove ( int index ) { mCategories . remove ( index ) ; mTitles . remove ( index ) ; mValues . remove ( index ) ; }
public static boolean deleteFilesAndDirsRecursive ( final File directory ) { if ( directory == null || ! directory . isDirectory ( ) ) { Log . e ( FileUtils . class , STR_ ) ; return BOOL_ ; } return deleteFilesAndDirs ( directory ) ; }
void render ( GraphicsContext g , Point2D viewportOrigin ) { g . setGlobalAlpha ( life ) ; g . setGlobalBlendMode ( blendMode ) ; if ( image != null ) { g . save ( ) ; g . translate ( x - viewportOrigin . getX ( ) , y - viewportOrigin . getY ( ) ) ; g . scale ( radiusX . NUM_ / image . getWidth ( ) , radiusY . NUM_ / image . getHeight ( ) ) ; g . drawImage ( image , NUM_ , NUM_ ) ; g . restore ( ) ; } else { g . setFill ( color ) ; g . fillOval ( x - viewportOrigin . getX ( ) , y - viewportOrigin . getY ( ) , radiusX . NUM_ , radiusY . NUM_ ) ; } }
public int position ( ) { return buff . position ( ) ; }
@ Override public void write ( String str , int off , int len ) throws IOException { final int off_plus_len = off + len ; for ( int i = off ; i < off_plus_len ; ) { char c = str . charAt ( i ++ ) ; if ( c < x80 ) { _bytes [ _index ] = ( byte ) c ; if ( ++ _index >= _bytes . length ) { flushBuffer ( ) ; } } else { write ( c ) ; } } }
public void writeToNBT ( final NBTTagCompound nbt ) { final NBTTagList modulesNbt = new NBTTagList ( ) ; for ( final Module module : modules ) { final NBTTagCompound moduleNbt = new NBTTagCompound ( ) ; if ( module != null ) { module . writeToNBT ( moduleNbt ) ; } modulesNbt . appendTag ( moduleNbt ) ; } nbt . setTag ( TAG_MODULES , modulesNbt ) ; lock . ifPresent ( null ) ; lock . ifPresent ( null ) ; }
void sendBufferIfNotEmpty ( ) throws IOException { if ( buf != null && buf . position ( ) > NUM_ ) sendBuffer ( ) ; }
public void onSharedPreferenceChanged ( SharedPreferences sharedPreferences , String key ) { if ( key . equals ( getString ( R . string . pref_key_notification ) ) ) { setNotification ( sharedPreferences . getBoolean ( key , BOOL_ ) ) ; } else if ( key . equals ( getString ( R . string . pref_key_gmail_signature ) ) ) { setGmailSignaturePrefDescription ( sharedPreferences . getBoolean ( key , BOOL_ ) ) ; } else if ( key . equals ( getString ( R . string . pref_key_sms_signature ) ) ) { setSmsSignaturePrefDescription ( sharedPreferences . getBoolean ( key , BOOL_ ) ) ; } }
public void initPortParameters ( SerialPort port ) { initialized = BOOL_ ; if ( port != null ) { cbPort . setSelectedItem ( port . getName ( ) ) ; cbBaudrate . setSelectedItem ( String . valueOf ( port . getBaudRate ( ) ) ) ; cbParity . setSelectedIndex ( port . getParity ( ) ) ; cbDataBits . setSelectedIndex ( port . getDataBits ( ) - NUM_ ) ; cbStopBits . setSelectedIndex ( port . getStopBits ( ) - NUM_ ) ; int prt = port . getFlowControlMode ( ) ; cbProtocolRx . setSelectedIndex ( ( prt & SerialPort . FLOWCONTROL_RTSCTS_IN ) != NUM_ ? NUM_ : ( prt & SerialPort . FLOWCONTROL_XONXOFF_IN ) != NUM_ ? NUM_ : NUM_ ) ; cbProtocolTx . setSelectedIndex ( ( prt & SerialPort . FLOWCONTROL_RTSCTS_OUT ) != NUM_ ? NUM_ : ( prt & SerialPort . FLOWCONTROL_XONXOFF_OUT ) != NUM_ ? NUM_ : NUM_ ) ; btnDSR . setSelected ( port . isDSR ( ) ) ; btnCTS . setSelected ( port . isCTS ( ) ) ; btnCD . setSelected ( port . isCD ( ) ) ; btnDTR . setSelected ( port . isDTR ( ) ) ; btnRTS . setSelected ( port . isRTS ( ) ) ; } initialized = BOOL_ ; }
public void addPreloadEntry ( GridCacheEntryInfo info ) { if ( preloadEntries == null ) preloadEntries = new ArrayList < > ( ) ; preloadEntries . add ( info ) ; }
private void putOffUniform ( final Player player ) { if ( UNIFORM . isPartOf ( player . getOutfit ( ) ) ) { player . returnToOriginalOutfit ( ) ; } }
public static void moveFile ( final File srcFile , final File destFile ) throws IOException { if ( srcFile == null ) { throw new NullPointerException ( STR_ ) ; } if ( destFile == null ) { throw new NullPointerException ( STR_ ) ; } if ( ! srcFile . exists ( ) ) { throw new FileNotFoundException ( STR_ + srcFile + STR_ ) ; } if ( srcFile . isDirectory ( ) ) { throw new IOException ( STR_ + srcFile + STR_ ) ; } if ( destFile . exists ( ) ) { throw new IOException ( STR_ + destFile + STR_ ) ; } if ( destFile . isDirectory ( ) ) { throw new IOException ( STR_ + destFile + STR_ ) ; } final boolean rename = srcFile . renameTo ( destFile ) ; if ( ! rename ) { copyFile ( srcFile , destFile ) ; if ( ! srcFile . delete ( ) ) { ParseFileUtils . deleteQuietly ( destFile ) ; throw new IOException ( STR_ + srcFile + STR_ + destFile + STR_ ) ; } } }
public synchronized ScanManagerConfig readFromFile ( ) throws IOException { final File f = new File ( file ) ; if ( ! f . exists ( ) ) throw new IOException ( STR_ + file ) ; if ( ! f . canRead ( ) ) throw new IOException ( STR_ + file ) ; try { return read ( f ) ; } catch ( JAXBException x ) { final IOException io = new IOException ( STR_ + file + STR_ + x , x ) ; throw io ; } }
public void delete ( String name ) throws IOException { if ( name . equalsIgnoreCase ( ISSUER ) ) { names = null ; } else { throw new IOException ( STR_ + STR_ ) ; } encodeThis ( ) ; }
private float clampMag ( float value , float absMin , float absMax ) { final float absValue = Math . abs ( value ) ; if ( absValue < absMin ) return NUM_ ; if ( absValue > absMax ) return value > NUM_ ? absMax : - absMax ; return value ; }
public CompileClassNotFound ( Exception cause ) { super ( cause . getMessage ( ) ) ; _cause = cause ; }
public SymGraph ( Motif motif ) { this . motif = motif ; colorsToRecheck = new HashSet < Integer > ( ) ; topMotifnodeToColor = new int [ motif . getNrMotifNodes ( ) ] ; colorToBottomMotifnode = new HashMap < Integer , List < Integer > > ( ) ; colorToTopMotifnode = new HashMap < Integer , List < Integer > > ( ) ; ArrayList < Integer > list1 = new ArrayList < Integer > ( ) ; ArrayList < Integer > list2 = new ArrayList < Integer > ( ) ; for ( int i = NUM_ ; i < topMotifnodeToColor . length ; i ++ ) { list1 . add ( i ) ; list2 . add ( i ) ; } colorToBottomMotifnode . put ( NUM_ , list2 ) ; colorToTopMotifnode . put ( NUM_ , list1 ) ; }
public static boolean anyDimensionHasItems ( Collection < DimensionalObject > dimensions ) { if ( dimensions == null || dimensions . isEmpty ( ) ) { return BOOL_ ; } for ( DimensionalObject dim : dimensions ) { if ( dim . hasItems ( ) ) { return BOOL_ ; } } return BOOL_ ; }
private void openCurrentAndMaybeNext ( final boolean openNext ) { LOG . info ( STR_ ) ; synchronized ( this ) { LOG . info ( STR_ ) ; closeCursor ( ) ; if ( mPlayListLen == NUM_ || mPlayList == null ) { return ; } stop ( BOOL_ ) ; mPlayPos = Math . min ( mPlayPos , mPlayList . length - NUM_ ) ; updateCursor ( mPlayList [ mPlayPos ] ) ; while ( BOOL_ ) { if ( mCursor != null && ! mCursor . isClosed ( ) && openFile ( MediaStore . Audio . Media . EXTERNAL_CONTENT_URI + STR_ + mCursor . getLong ( IDCOLIDX ) ) ) { break ; } closeCursor ( ) ; if ( mOpenFailedCounter ++ < NUM_ && mPlayListLen > NUM_ ) { final int pos = getNextPosition ( BOOL_ ) ; if ( scheduleShutdownAndNotifyPlayStateChange ( pos ) ) return ; mPlayPos = pos ; stop ( BOOL_ ) ; mPlayPos = pos ; updateCursor ( mPlayList [ mPlayPos ] ) ; } else { mOpenFailedCounter = NUM_ ; LOG . warn ( STR_ ) ; scheduleDelayedShutdown ( ) ; if ( mIsSupposedToBePlaying ) { mIsSupposedToBePlaying = BOOL_ ; notifyChange ( PLAYSTATE_CHANGED ) ; } return ; } } if ( openNext ) { setNextTrack ( ) ; } } }
protected OMNode createDTD ( ) throws OMException { throw new OMException ( STR_ ) ; }
private void createOverviewPage ( ) { RemapOverview overview = new RemapOverview ( migrationTask , getContainer ( ) ) ; int index = addPage ( overview . getControl ( ) ) ; setPageText ( index , STR_ ) ; taskListeners . add ( overview ) ; }
public void warning2 ( final String filename , int ln , int col , Object msg , String source ) { warning ( filename , ln , col , msg . toString ( ) , source ) ; }
public SOAPConnection openSOAPConnection ( ) throws SOAPException { return soapConnectionFactory . createConnection ( ) ; }
public static < U , V > String printMap ( final Map < U , V > map , final Converter < U > keyConverter , final Converter < V > valueConverter ) { final StringBuilder sb = new StringBuilder ( STR_ ) ; String separator = STR_ ; for ( final Entry < U , V > entry : map . entrySet ( ) ) { sb . append ( separator ) ; sb . append ( keyConverter . convert ( entry . getKey ( ) ) ) ; sb . append ( STR_ ) ; sb . append ( valueConverter . convert ( entry . getValue ( ) ) ) ; separator = STR_ ; } sb . append ( STR_ ) ; return sb . toString ( ) ; }
public void findAndInit ( Object someObj ) { if ( someObj instanceof com . bbn . openmap . MapBean ) { Debug . message ( STR_ , STR_ ) ; setSourceMap ( ( MapBean ) someObj ) ; } }
public void handleRequest ( RequestContext rc ) throws CLIException { super . handleRequest ( rc ) ; ldapLogin ( ) ; SSOToken adminSSOToken = getAdminSSOToken ( ) ; String serviceName = getStringOptionValue ( IArgument . SERVICE_NAME ) ; String interfaceName = getStringOptionValue ( ARGUMENT_INTERFACE_NAME ) ; String pluginName = getStringOptionValue ( ARGUMENT_PLUGIN_NAME ) ; String i18nKey = getStringOptionValue ( ARGUMENT_I18N_KEY ) ; String i18nName = getStringOptionValue ( ARGUMENT_I18N_NAME ) ; String className = getStringOptionValue ( ARGUMENT_CLASS_NAME ) ; ServiceManager sm = null ; try { sm = new ServiceManager ( adminSSOToken ) ; } catch ( SMSException smse ) { throw new CLIException ( smse , ExitCodes . REQUEST_CANNOT_BE_PROCESSED ) ; } catch ( SSOException ssoe ) { throw new CLIException ( ssoe , ExitCodes . REQUEST_CANNOT_BE_PROCESSED ) ; } IOutput outputWriter = getOutputWriter ( ) ; try { String [ ] params = { serviceName , interfaceName , pluginName , i18nKey , i18nName , className } ; writeLog ( LogWriter . LOG_ACCESS , Level . INFO , STR_ , params ) ; Document pluginDoc = createPluginSchemaXML ( serviceName , interfaceName , pluginName , i18nKey , i18nName , className ) ; if ( pluginDoc != null ) { sm . addPluginSchema ( pluginDoc ) ; String [ ] params2 = { serviceName , pluginName } ; writeLog ( LogWriter . LOG_ACCESS , Level . INFO , STR_ , params2 ) ; outputWriter . printlnMessage ( MessageFormat . format ( getResourceString ( STR_ ) , ( Object [ ] ) params ) ) ; } else { String [ ] args = { serviceName , pluginName , STR_ } ; debugError ( STR_ ) ; writeLog ( LogWriter . LOG_ERROR , Level . INFO , STR_ , args ) ; throw new CLIException ( STR_ , ExitCodes . REQUEST_CANNOT_BE_PROCESSED ) ; } } catch ( SSOException ssoe ) { String [ ] args = { serviceName , pluginName , ssoe . getMessage ( ) } ; debugError ( STR_ , ssoe ) ; writeLog ( LogWriter . LOG_ERROR , Level . INFO , STR_ , args ) ; outputWriter . printlnMessage ( MessageFormat . format ( getResourceString ( STR_ ) , ( Object [ ] ) args ) ) ; throw new CLIException ( ssoe , ExitCodes . REQUEST_CANNOT_BE_PROCESSED ) ; } catch ( SMSException smse ) { String [ ] args = { serviceName , pluginName , smse . getMessage ( ) } ; debugError ( STR_ , smse ) ; writeLog ( LogWriter . LOG_ERROR , Level . INFO , STR_ , args ) ; outputWriter . printlnMessage ( MessageFormat . format ( getResourceString ( STR_ ) , ( Object [ ] ) args ) ) ; throw new CLIException ( smse , ExitCodes . REQUEST_CANNOT_BE_PROCESSED ) ; } }
protected void bflash ( ) throws SAXException { if ( mBuffIdx >= NUM_ ) { mHandCont . characters ( mBuff , NUM_ , ( mBuffIdx + NUM_ ) ) ; mBuffIdx = - NUM_ ; } }
protected Mac ( MacSpi macSpi , Provider provider , String algorithm ) { this . spi = macSpi ; this . provider = provider ; this . algorithm = algorithm ; serviceIterator = null ; lock = null ; }
public static String pathToString ( String dim , String [ ] path ) { String [ ] fullPath = new String [ NUM_ + path . length ] ; fullPath [ NUM_ ] = dim ; System . arraycopy ( path , NUM_ , fullPath , NUM_ , path . length ) ; return pathToString ( fullPath , fullPath . length ) ; }
public static boolean isValidIfd ( int ifdId ) { return ifdId == IfdId . TYPE_IFD_0 || ifdId == IfdId . TYPE_IFD_1 || ifdId == IfdId . TYPE_IFD_EXIF || ifdId == IfdId . TYPE_IFD_INTEROPERABILITY || ifdId == IfdId . TYPE_IFD_GPS ; }
public static CdcSession createCdcSessionViaDomainAuth ( String serverName , String userName , String userPassword ) { if ( serverName == null || serverName . length ( ) == NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } if ( userName == null || userName . length ( ) == NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } return new CdcSession ( serverName , userName , userPassword ) ; }
protected static Dfp expInternal ( final Dfp a ) { Dfp y = a . getOne ( ) ; Dfp x = a . getOne ( ) ; Dfp fact = a . getOne ( ) ; Dfp py = new Dfp ( y ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { x = x . multiply ( a ) ; fact = fact . divide ( i ) ; y = y . add ( x . multiply ( fact ) ) ; if ( y . equals ( py ) ) { break ; } py = new Dfp ( y ) ; } return y ; }
public URLConnection openConnection ( ) throws IOException { return streamHandler . openConnection ( this ) ; }
public static ArrayList < String [ ] > linesToArray ( ArrayList < String > inLine ) { ArrayList < String [ ] > framesEnTab = new ArrayList < > ( ) ; for ( int i = NUM_ ; i < inLine . size ( ) ; i ++ ) { framesEnTab . add ( lineToArray ( inLine . get ( i ) ) ) ; } return framesEnTab ; }
@ Override public int LA ( int i ) { int la = super . LA ( i ) ; return Character . toLowerCase ( la ) ; }
public void deselect_all ( ) { Arrays . fill ( sel_array , BOOL_ ) ; }
@ Override public boolean canTransferCriticals ( int loc ) { return BOOL_ ; }
private void calculateSizes ( final Graphics g ) { m_rowHeight = getRowHeight ( g ) ; m_charHeight = getCharHeight ( g ) ; m_charWidth = getCharacterWidth ( g ) ; }
public static Iterable < GatewayMetaState . IndexMetaWriteInfo > resolveStatesToBeWritten ( ImmutableSet < String > previouslyWrittenIndices , Set < String > potentiallyUnwrittenIndices , MetaData previousMetaData , MetaData newMetaData ) { List < GatewayMetaState . IndexMetaWriteInfo > indicesToWrite = new ArrayList < > ( ) ; for ( String index : potentiallyUnwrittenIndices ) { IndexMetaData newIndexMetaData = newMetaData . index ( index ) ; IndexMetaData previousIndexMetaData = previousMetaData == null ? null : previousMetaData . index ( index ) ; String writeReason = null ; if ( previouslyWrittenIndices . contains ( index ) == BOOL_ || previousIndexMetaData == null ) { writeReason = STR_ ; } else if ( previousIndexMetaData . getVersion ( ) != newIndexMetaData . getVersion ( ) ) { writeReason = STR_ + previousIndexMetaData . getVersion ( ) + STR_ + newIndexMetaData . getVersion ( ) + STR_ ; } if ( writeReason != null ) { indicesToWrite . add ( new GatewayMetaState . IndexMetaWriteInfo ( newIndexMetaData , previousIndexMetaData , writeReason ) ) ; } } return indicesToWrite ; }
protected double applyFunction ( double value ) { switch ( m_operator ) { case STR_ : return Math . log ( value ) ; case STR_ : return Math . abs ( value ) ; case STR_ : return Math . cos ( value ) ; case STR_ : return Math . exp ( value ) ; case STR_ : return Math . sqrt ( value ) ; case STR_ : return Math . floor ( value ) ; case STR_ : return Math . ceil ( value ) ; case STR_ : return Math . rint ( value ) ; case STR_ : return Math . tan ( value ) ; case STR_ : return Math . sin ( value ) ; } return Double . NaN ; }
private Object _deserializeStruct ( Element elStruct ) throws ConverterException { String type = elStruct . getAttribute ( STR_ ) ; Struct struct = new StructImpl ( ) ; NodeList list = elStruct . getChildNodes ( ) ; int len = list . getLength ( ) ; for ( int i = NUM_ ; i < len ; i ++ ) { Node node = list . item ( i ) ; if ( node instanceof Element ) { Element var = ( Element ) node ; Element value = getChildElement ( ( Element ) node ) ; if ( value != null ) { struct . setEL ( var . getAttribute ( STR_ ) , _deserialize ( value ) ) ; } } } if ( struct . size ( ) == NUM_ && type != null && type . length ( ) > NUM_ ) { return STR_ ; } return struct ; }
public RemoteEvent dequeue ( ) { Uuid uuid = _readyEvents . poll ( ) ; if ( uuid == null ) return null ; SingleProducer producer = getProducer ( uuid ) ; return producer . popNextReadyEvent ( ) ; }
public InvalidPropertiesFormatException ( String message ) { super ( message ) ; }
public SubCommand ( IDefinition definition , ResourceBundle rb , String name , List mandatoryOptions , List optionalOptions , List optionAliases , String implClassName , boolean webSupport , String deprecationWarning ) throws CLIException { this . definition = definition ; this . name = name ; this . rb = rb ; this . implClassName = implClassName ; this . webSupport = webSupport ; this . deprecationWarning = deprecationWarning ; Set shortOptions = new HashSet ( ) ; parseOptions ( mandatoryOptions , this . mandatoryOptions , shortOptions ) ; parseOptions ( optionalOptions , this . optionalOptions , shortOptions ) ; parseAliases ( optionAliases ) ; }
public static boolean canAddClassInPackageOf ( Class < ? > cls ) { final Package beanPackage = cls . getPackage ( ) ; if ( beanPackage != null ) { if ( beanPackage . isSealed ( ) ) { return BOOL_ ; } String pname = beanPackage . getName ( ) ; if ( pname . startsWith ( STR_ ) || pname . startsWith ( STR_ ) ) { return BOOL_ ; } } return BOOL_ ; }
public static JsonToken deserialize ( final String jwt ) throws Exception { JsonTokenParser parser = new JsonTokenParser ( verifierProviders , new AbelanaTokenAudienceChecker ( BackendConstants . TOKEN_ISSUER ) ) ; return parser . deserialize ( jwt ) ; }
public void swapSuggestions ( final List < ? extends SearchSuggestion > newSearchSuggestions ) { Collections . reverse ( newSearchSuggestions ) ; swapSuggestions ( newSearchSuggestions , BOOL_ ) ; }
boolean shouldAnimateSearchProviderIcon ( SelectionType selectionType , boolean isShowing ) { if ( isShowing || ContextualSearchFieldTrial . areExtraSearchBarAnimationsDisabled ( ) ) { return BOOL_ ; } if ( selectionType == SelectionType . TAP ) { long currentTimeMillis = System . currentTimeMillis ( ) ; long lastAnimatedTimeMillis = mPreferenceManager . getContextualSearchLastAnimationTime ( ) ; if ( Math . abs ( currentTimeMillis - lastAnimatedTimeMillis ) > ONE_DAY_IN_MILLIS ) { mPreferenceManager . setContextualSearchLastAnimationTime ( currentTimeMillis ) ; return BOOL_ ; } else { return BOOL_ ; } } else if ( selectionType == SelectionType . LONG_PRESS ) { return getPromoOpenCount ( ) == NUM_ ; } return BOOL_ ; }
public void waitFor ( ) { checkStarted ( ) ; try { if ( myInputProcessor != null && myProcess != null ) { myInputProcessor . process ( myProcess . getOutputStream ( ) ) ; } } finally { waitForProcess ( ) ; } }
public static String extractUriFromAddress ( String addr ) { String uri = addr ; int index = addr . indexOf ( STR_ ) ; if ( index != - NUM_ ) { uri = addr . substring ( index + NUM_ , addr . indexOf ( STR_ , index ) ) ; } return uri ; }
PBKDF2KeyImpl ( PBEKeySpec keySpec , String prfAlgo ) throws InvalidKeySpecException { char [ ] passwd = keySpec . getPassword ( ) ; if ( passwd == null ) { this . passwd = new char [ NUM_ ] ; } else { this . passwd = passwd . clone ( ) ; } byte [ ] passwdBytes = getPasswordBytes ( this . passwd ) ; this . salt = keySpec . getSalt ( ) ; if ( salt == null ) { throw new InvalidKeySpecException ( STR_ ) ; } this . iterCount = keySpec . getIterationCount ( ) ; if ( iterCount == NUM_ ) { throw new InvalidKeySpecException ( STR_ ) ; } else if ( iterCount < NUM_ ) { throw new InvalidKeySpecException ( STR_ ) ; } int keyLength = keySpec . getKeyLength ( ) ; if ( keyLength == NUM_ ) { throw new InvalidKeySpecException ( STR_ ) ; } else if ( keyLength < NUM_ ) { throw new InvalidKeySpecException ( STR_ ) ; } try { this . prf = Mac . getInstance ( prfAlgo , SunJCE . getInstance ( ) ) ; } catch ( NoSuchAlgorithmException nsae ) { InvalidKeySpecException ike = new InvalidKeySpecException ( ) ; ike . initCause ( nsae ) ; throw ike ; } this . key = deriveKey ( prf , passwdBytes , salt , iterCount , keyLength ) ; }
private static void showDirectoryCreationError ( final String directory ) { final String message = STR_ + STR_ ; final String description = CUtilityFunctions . createDescription ( String . format ( STR_ , directory ) , new String [ ] { STR_ } , new String [ ] { STR_ , STR_ } ) ; NaviErrorDialog . show ( null , message , description ) ; }
static byte [ ] pad ( byte [ ] data ) { int len ; if ( data . length < NUM_ ) len = data . length ; else len = data . length % NUM_ ; if ( len == NUM_ ) return data ; else { byte [ ] padding = new byte [ NUM_ - len + data . length ] ; for ( int i = padding . length - NUM_ ; i > data . length - NUM_ ; i -- ) { padding [ i ] = NUM_ ; } System . arraycopy ( data , NUM_ , padding , NUM_ , data . length ) ; return padding ; } }
public void serialize ( DataOutput out ) throws IOException { out . writeUTF ( id ) ; out . writeUTF ( version ) ; out . writeInt ( sourceFiles . size ( ) ) ; for ( Entry < String , List < RevisionFile > > e : sourceFiles . entrySet ( ) ) { out . writeUTF ( e . getKey ( ) ) ; List < RevisionFile > files = e . getValue ( ) ; out . writeInt ( files . size ( ) ) ; for ( RevisionFile file : files ) { out . writeUTF ( file . fileName ) ; out . writeLong ( file . size ) ; } } }
public NamedColumnProjection ( String [ ] names , boolean include ) { m_names = new HashSet ( ) ; for ( int i = NUM_ ; i < names . length ; ++ i ) m_names . add ( names [ i ] ) ; m_include = include ; }
public static TimeSeriesData serializableInstance ( ) { List < String > varNames = new ArrayList < > ( ) ; varNames . add ( STR_ ) ; varNames . add ( STR_ ) ; return new TimeSeriesData ( new TetradMatrix ( NUM_ , NUM_ ) , varNames ) ; }
@ Override public void writeVertices ( final OutputStream outputStream , final Iterator < Vertex > vertexIterator , final Direction direction ) throws IOException { final BufferedWriter writer = new BufferedWriter ( new OutputStreamWriter ( outputStream ) ) ; try ( final ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ) { if ( wrapAdjacencyList ) writer . write ( STR_ + GraphSONTokens . VERTICES + STR_ ) ; while ( vertexIterator . hasNext ( ) ) { writeVertex ( baos , vertexIterator . next ( ) , direction ) ; writer . write ( new String ( baos . toByteArray ( ) ) ) ; if ( wrapAdjacencyList ) { if ( vertexIterator . hasNext ( ) ) writer . write ( STR_ ) ; } else { writer . newLine ( ) ; } baos . reset ( ) ; } if ( wrapAdjacencyList ) writer . write ( STR_ ) ; } writer . flush ( ) ; }
Collection < ? extends ClientRequestResult > handleRetrieveConfigurationsRequest ( final ClientRequest configurationRequest , final Session session , final Destination replyDestination ) { if ( configurationRequest . getRequestParameter ( ) != null ) { return configurationLoader . getConfigurationReports ( configurationRequest . getRequestParameter ( ) ) ; } else { return configurationLoader . getConfigurationReports ( ) ; } }
public static boolean containsClass ( @ NotNull File file , String className ) { String entryPath = className . replace ( STR_ , STR_ ) + STR_ ; return containsEntry ( file , entryPath ) ; }
private double sin ( double angle ) { while ( angle >= NUM_ ) { angle -= NUM_ ; } double value = angle / NUM_ . Math . PI ; return Math . sin ( value ) ; }
public void remove ( T graphic ) { synchronized ( mLock ) { mGraphics . remove ( graphic ) ; } postInvalidate ( ) ; }
private static void launchDebugger ( String dmlScriptStr , String fnameOptConfig , Map < String , String > argVals , boolean parsePyDML ) throws ParseException , IOException , DMLRuntimeException , DMLDebuggerException , LanguageException , HopsException , LopsException { DMLDebuggerProgramInfo dbprog = new DMLDebuggerProgramInfo ( ) ; DMLConfig conf = DMLConfig . readConfigurationFile ( fnameOptConfig ) ; ConfigurationManager . setGlobalConfig ( conf ) ; AParserWrapper parser = AParserWrapper . createParser ( parsePyDML ) ; DMLProgram prog = parser . parse ( DML_FILE_PATH_ANTLR_PARSER , dmlScriptStr , argVals ) ; DMLTranslator dmlt = new DMLTranslator ( prog ) ; dmlt . liveVariableAnalysis ( prog ) ; dmlt . validateParseTree ( prog ) ; dmlt . constructHops ( prog ) ; dmlt . rewriteHopsDAG ( prog ) ; dmlt . constructLops ( prog ) ; dbprog . rtprog = prog . getRuntimeProgram ( conf ) ; try { initHadoopExecution ( conf ) ; DMLDebugger SystemMLdb = new DMLDebugger ( dbprog , dmlScriptStr ) ; SystemMLdb . runSystemMLDebugger ( ) ; } finally { cleanupHadoopExecution ( conf ) ; } }
public static final Index createTestBankIndexApprovedOn ( ) { Index lastname = new Index ( STR_ ) ; lastname . isUnique ( BOOL_ ) ; ArrayList < IndexField > fields = new ArrayList < > ( NUM_ ) ; fields . add ( new IndexField ( STR_ , FieldDataType . DATE_TIME ) ) ; lastname . setFields ( fields ) ; lastname . setTable ( Fixtures . createTestWorldBankTable ( ) ) ; return lastname ; }
public static byte [ ] decode ( String encoded ) { if ( encoded == null ) { return null ; } char [ ] base64Data = encoded . toCharArray ( ) ; int len = removeWhiteSpace ( base64Data ) ; if ( len % FOURBYTE != NUM_ ) { return null ; } int numberQuadruple = ( len / FOURBYTE ) ; if ( numberQuadruple == NUM_ ) { return new byte [ NUM_ ] ; } byte decodedData [ ] = null ; byte b1 = NUM_ , b2 = NUM_ , b3 = NUM_ , b4 = NUM_ ; char d1 = NUM_ , d2 = NUM_ , d3 = NUM_ , d4 = NUM_ ; int i = NUM_ ; int encodedIndex = NUM_ ; int dataIndex = NUM_ ; decodedData = new byte [ ( numberQuadruple ) . NUM_ ] ; for ( ; i < numberQuadruple - NUM_ ; i ++ ) { if ( ! isData ( ( d1 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d2 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d3 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d4 = base64Data [ dataIndex ++ ] ) ) ) { return null ; } b1 = base64Alphabet [ d1 ] ; b2 = base64Alphabet [ d2 ] ; b3 = base64Alphabet [ d3 ] ; b4 = base64Alphabet [ d4 ] ; decodedData [ encodedIndex ++ ] = ( byte ) ( b1 << NUM_ | b2 > > NUM_ ) ; decodedData [ encodedIndex ++ ] = ( byte ) ( ( ( b2 & xf ) << NUM_ ) | ( ( b3 > > NUM_ ) & xf ) ) ; decodedData [ encodedIndex ++ ] = ( byte ) ( b3 << NUM_ | b4 ) ; } if ( ! isData ( ( d1 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d2 = base64Data [ dataIndex ++ ] ) ) ) { return null ; } b1 = base64Alphabet [ d1 ] ; b2 = base64Alphabet [ d2 ] ; d3 = base64Data [ dataIndex ++ ] ; d4 = base64Data [ dataIndex ++ ] ; if ( ! isData ( ( d3 ) ) || ! isData ( ( d4 ) ) ) { if ( isPad ( d3 ) && isPad ( d4 ) ) { if ( ( b2 & xf ) != NUM_ ) { return null ; } byte [ ] tmp = new byte [ i . NUM_ + NUM_ ] ; System . arraycopy ( decodedData , NUM_ , tmp , NUM_ , i . NUM_ ) ; tmp [ encodedIndex ] = ( byte ) ( b1 << NUM_ | b2 > > NUM_ ) ; return tmp ; } else if ( ! isPad ( d3 ) && isPad ( d4 ) ) { b3 = base64Alphabet [ d3 ] ; if ( ( b3 & x3 ) != NUM_ ) { return null ; } byte [ ] tmp = new byte [ i . NUM_ + NUM_ ] ; System . arraycopy ( decodedData , NUM_ , tmp , NUM_ , i . NUM_ ) ; tmp [ encodedIndex ++ ] = ( byte ) ( b1 << NUM_ | b2 > > NUM_ ) ; tmp [ encodedIndex ] = ( byte ) ( ( ( b2 & xf ) << NUM_ ) | ( ( b3 > > NUM_ ) & xf ) ) ; return tmp ; } else { return null ; } } else { b3 = base64Alphabet [ d3 ] ; b4 = base64Alphabet [ d4 ] ; decodedData [ encodedIndex ++ ] = ( byte ) ( b1 << NUM_ | b2 > > NUM_ ) ; decodedData [ encodedIndex ++ ] = ( byte ) ( ( ( b2 & xf ) << NUM_ ) | ( ( b3 > > NUM_ ) & xf ) ) ; decodedData [ encodedIndex ++ ] = ( byte ) ( b3 << NUM_ | b4 ) ; } return decodedData ; }
public synchronized void accessed ( Object object ) { historyList . remove ( object ) ; historyList . add ( object ) ; }
public static boolean isEmpty ( String string ) { return string == null || string . length ( ) <= NUM_ ; }
@ Override @ SuppressWarnings ( STR_ ) protected void heapifyUpComparable ( int pos , Object elem ) { final Comparable < Object > cur = ( Comparable < Object > ) elem ; while ( pos > NUM_ ) { final int parent = ( pos - NUM_ ) > > > NUM_ ; Object par = queue [ parent ] ; if ( cur . compareTo ( par ) >= NUM_ ) { break ; } queue [ pos ] = par ; index . put ( par , pos ) ; pos = parent ; } queue [ pos ] = cur ; index . put ( cur , pos ) ; }
private void updateReleaseLocks ( ) throws CacheException { if ( numLocks . addAndGet ( - NUM_ ) < NUM_ ) { throw new CacheException ( STR_ ) ; } if ( evictionPolicy == EvictionPolicy . LRU ) { timestamp . set ( System . nanoTime ( ) ) ; } else if ( evictionPolicy == EvictionPolicy . LFU ) { timestamp . addAndGet ( NUM_ ) ; } else if ( evictionPolicy == EvictionPolicy . MIN_EVICT ) { } else { throw new CacheException ( STR_ + evictionPolicy . name ( ) ) ; } }
public static Short toShort ( char c ) { return Short . valueOf ( toShortValue ( c ) ) ; }
public static void encodeDimension ( float value , byte dest [ ] , int offset ) { NumericUtils . intToSortableBytes ( NumericUtils . floatToSortableInt ( value ) , dest , offset ) ; }
public long minflt ( ) { return Long . parseLong ( fields [ NUM_ ] ) ; }
public static String toString ( final float value ) { return Float . toString ( value ) ; }
public void endFilterInterval ( ) { endMillis = System . currentTimeMillis ( ) ; totalFilterMillis += ( endMillis - intervalStartMillis ) ; state = TaskState . other ; }
public String process ( String to_process ) { if ( to_process == null || to_process . length ( ) == NUM_ ) return STR_ ; String tmp = STR_ ; StringTokenizer st = new StringTokenizer ( to_process , STR_ , BOOL_ ) ; StringBuffer newValue = new StringBuffer ( to_process . length ( ) + NUM_ ) ; while ( st . hasMoreTokens ( ) ) { tmp = st . nextToken ( ) ; if ( hasAttribute ( tmp ) ) newValue . append ( ( String ) get ( tmp ) ) ; else newValue . append ( tmp ) ; } return newValue . toString ( ) ; }
@ Benchmark public long test2_UsingForEachAndMapEntry ( ) throws IOException { long i = NUM_ ; for ( Map . Entry < Integer , Integer > pair : map . entrySet ( ) ) { i += pair . getKey ( ) + pair . getValue ( ) ; } return i ; }
public static final void writeListXml ( List val , String name , XmlSerializer out ) throws XmlPullParserException , java . io . IOException { if ( val == null ) { out . startTag ( null , STR_ ) ; out . endTag ( null , STR_ ) ; return ; } out . startTag ( null , STR_ ) ; if ( name != null ) { out . attribute ( null , STR_ , name ) ; } int n = val . size ( ) ; int i = NUM_ ; while ( i < n ) { writeValueXml ( val . get ( i ) , null , out ) ; i ++ ; } out . endTag ( null , STR_ ) ; }
public static String convertToRGB ( int color ) { String red = Integer . toHexString ( Color . red ( color ) ) ; String green = Integer . toHexString ( Color . green ( color ) ) ; String blue = Integer . toHexString ( Color . blue ( color ) ) ; if ( red . length ( ) == NUM_ ) { red = STR_ + red ; } if ( green . length ( ) == NUM_ ) { green = STR_ + green ; } if ( blue . length ( ) == NUM_ ) { blue = STR_ + blue ; } return STR_ + red + green + blue ; }
public static String hashKeyForDisk ( String key ) { String cacheKey ; try { final MessageDigest mDigest = MessageDigest . getInstance ( STR_ ) ; mDigest . update ( key . getBytes ( ) ) ; cacheKey = bytesToHexString ( mDigest . digest ( ) ) ; } catch ( NoSuchAlgorithmException e ) { cacheKey = String . valueOf ( key . hashCode ( ) ) ; } return cacheKey ; }
private void changePassword ( String userType , String oldPassword , String newPassword ) throws Exception { String fileEncPassword = getUserPassword ( userType ) ; String userDN = getUserDN ( userType ) ; if ( ( fileEncPassword == null ) || ( fileEncPassword . length ( ) == NUM_ ) || ( userDN == null ) || ( userDN . length ( ) == NUM_ ) ) { debug . error ( STR_ + userType + STR_ + configFile ) ; throw new XMLException ( i18n . getString ( STR_ ) ) ; } if ( ! oldPassword . equals ( AccessController . doPrivileged ( new DecodeAction ( fileEncPassword ) ) ) ) { throw new Exception ( i18n . getString ( STR_ ) ) ; } if ( isAMSDKConfigured ) { try { new AuthContext ( new AuthPrincipal ( userDN ) , newPassword . toCharArray ( ) ) ; if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + userDN + STR_ ) ; } } catch ( LoginException lee ) { try { AuthContext ac = new AuthContext ( new AuthPrincipal ( userDN ) , oldPassword . toCharArray ( ) ) ; PersistentObject user = UMSObject . getObject ( ac . getSSOToken ( ) , new Guid ( userDN ) ) ; if ( debug . messageEnabled ( ) ) { debug . message ( STR_ + userDN + STR_ ) ; } user . setAttribute ( new Attr ( STR_ , newPassword ) ) ; user . save ( ) ; } catch ( LoginException le ) { if ( debug . warningEnabled ( ) ) { debug . warning ( STR_ + userDN + STR_ ) ; } throw new Exception ( i18n . getString ( STR_ ) + STR_ + le . getMessage ( ) ) ; } } } setUserPassword ( userType , newPassword ) ; }
public int hashCode ( Object key ) { return ( key . hashCode ( ) & x7FFFFFFF ) % this . keyTable . length ; }
public AtomicArrayBase ( E [ ] array ) { this . array = Arrays . copyOf ( array , array . length , Object [ ] . class ) ; }
public void apply ( ) { setSpeedMap ( ) ; setNXdata ( ) ; }
private E unlinkFirst ( ) { Node < E > f = first ; if ( f == null ) return null ; Node < E > n = f . next ; E item = f . item ; f . item = null ; f . next = f ; first = n ; if ( n == null ) last = null ; else n . prev = null ; -- count ; notFull . signal ( ) ; return item ; }
public void push ( final String value ) { if ( value == null ) { mv . visitInsn ( Opcodes . ACONST_NULL ) ; } else { mv . visitLdcInsn ( value ) ; } }
public void init ( ) { m_projectTree . setSelectionPath ( new TreePath ( m_projectTree . getRootNode ( ) ) ) ; }
public int read ( ) throws IOException { return is . read ( ) ; }
private void displayCalendar ( ) { KeyNamePair pp = ( KeyNamePair ) fieldResource . getSelectedItem ( ) ; if ( pp == null ) return ; int S_Resource_ID = pp . getKey ( ) ; m_mAssignment . setS_Resource_ID ( S_Resource_ID ) ; Timestamp date = fieldDate . getTimestamp ( ) ; int index = timePane . getSelectedIndex ( ) ; log . config ( STR_ + index + STR_ + S_Resource_ID + STR_ + date ) ; m_loading = BOOL_ ; if ( index == NUM_ ) daySchedule . recreate ( S_Resource_ID , date ) ; else if ( index == NUM_ ) weekSchedule . recreate ( S_Resource_ID , date ) ; else monthSchedule . recreate ( S_Resource_ID , date ) ; m_loading = BOOL_ ; repaint ( ) ; }
public static void assertException ( RuntimeException exception , Runnable expression , String errorMessage ) { if ( verbose ) { log ( STR_ + exception + STR_ + expression + STR_ + errorMessage + STR_ ) ; } try { expression . run ( ) ; } catch ( RuntimeException failure ) { if ( exception . getClass ( ) != failure . getClass ( ) ) { TestUtils . fail ( errorMessage ) ; } return ; } TestUtils . fail ( errorMessage ) ; }
public boolean isParityCorrect ( byte [ ] [ ] shards , int firstByte , int byteCount ) { checkBuffersAndSizes ( shards , firstByte , byteCount ) ; byte [ ] [ ] toCheck = new byte [ parityShardCount ] [ ] ; System . arraycopy ( shards , dataShardCount , toCheck , NUM_ , parityShardCount ) ; return codingLoop . checkSomeShards ( parityRows , shards , dataShardCount , toCheck , parityShardCount , firstByte , byteCount , null ) ; }
protected void onSendSuccess ( RecordBuffer < R > buffer ) { sendSuccess . incrementAndGet ( ) ; logger . trace ( STR_ , name ( ) , buffer ) ; try { checkpointer . saveCheckpoint ( buffer ) ; } catch ( Exception e ) { logger . error ( STR_ , name ( ) , buffer , e ) ; } }
public synchronized void writeTo ( OutputStream out ) throws IOException { int remaining = count ; for ( byte [ ] buf : buffers ) { int c = Math . min ( buf . length , remaining ) ; out . write ( buf , NUM_ , c ) ; remaining -= c ; if ( remaining == NUM_ ) { break ; } } }
public void test_service_004 ( ) throws Exception { final BigdataURI serviceURI = valueFactory . createURI ( STR_ ) ; final GraphPatternGroup < IGroupMemberNode > groupNode = new JoinGroupNode ( ) ; { groupNode . addChild ( new StatementPatternNode ( new VarNode ( STR_ ) , new VarNode ( STR_ ) , new VarNode ( STR_ ) ) ) ; } final String exprImage = STR_ + serviceURI + STR_ ; final Map < String , String > prefixDecls = new LinkedHashMap < String , String > ( PrefixDeclProcessor . defaultDecls ) ; final ServiceNode serviceNode = new ServiceNode ( new ConstantNode ( makeIV ( serviceURI ) ) , groupNode ) ; { final Set < IVariable < ? > > projectedVars = new LinkedHashSet < IVariable < ? > > ( ) ; { projectedVars . add ( Var . var ( STR_ ) ) ; projectedVars . add ( Var . var ( STR_ ) ) ; projectedVars . add ( Var . var ( STR_ ) ) ; } serviceNode . setExprImage ( exprImage ) ; serviceNode . setPrefixDecls ( prefixDecls ) ; serviceNode . setProjectedVars ( projectedVars ) ; } final List < BindingSet > bindingSets = new LinkedList < BindingSet > ( ) ; { final MapBindingSet bset = new MapBindingSet ( ) ; bset . addBinding ( STR_ , new BNodeImpl ( STR_ ) ) ; bindingSets . add ( bset ) ; } final BindingSet [ ] a = bindingSets . toArray ( new BindingSet [ bindingSets . size ( ) ] ) ; final IRemoteSparqlQueryBuilder fixture = newFixture ( serviceNode , a ) ; final String queryStr = fixture . getSparqlQuery ( a ) ; final QueryRoot expected = new QueryRoot ( QueryType . SELECT ) ; { expected . setPrefixDecls ( prefixDecls ) ; final ProjectionNode projection = new ProjectionNode ( ) ; projection . addProjectionVar ( new VarNode ( STR_ ) ) ; projection . addProjectionVar ( new VarNode ( STR_ ) ) ; projection . addProjectionVar ( new VarNode ( STR_ ) ) ; expected . setProjection ( projection ) ; final JoinGroupNode whereClause = new JoinGroupNode ( ) ; whereClause . addChild ( new StatementPatternNode ( new VarNode ( STR_ ) , new VarNode ( STR_ ) , new VarNode ( STR_ ) , null , Scope . DEFAULT_CONTEXTS ) ) ; expected . setWhereClause ( whereClause ) ; { final LinkedHashSet < IVariable < ? > > vars = new LinkedHashSet < IVariable < ? > > ( ) ; final List < IBindingSet > solutionsIn = new LinkedList < IBindingSet > ( ) ; final BindingsClause bindingsClause = new BindingsClause ( vars , solutionsIn ) ; expected . setBindingsClause ( bindingsClause ) ; { vars . add ( Var . var ( STR_ ) ) ; } { final ListBindingSet bset = new ListBindingSet ( ) ; solutionsIn . add ( bset ) ; } } } final QueryRoot actual = parse ( queryStr , baseURI ) ; assertSameAST ( queryStr , expected , actual ) ; }
private boolean isDirty ( ) { return ! Objects . equals ( inputList . keySet ( ) , cmrRepositoryManager . getCmrRepositoryDefinitions ( ) ) ; }
public void write ( String s , int off , int len ) { if ( text != null ) { text . append ( s . substring ( off , off + len ) ) ; if ( ( col += len ) > wrap ) println ( ) ; } else { super . write ( s , off , len ) ; flush ( ) ; } }
public Zoneset showActiveZoneset ( Integer vsanId ) throws NetworkDeviceControllerException { List < Zoneset > zonesets = showZoneset ( vsanId , BOOL_ , null , BOOL_ , BOOL_ ) ; return zonesets . isEmpty ( ) ? null : zonesets . get ( NUM_ ) ; }
private final short validatePermSplitFactor ( String splitFactor ) throws AdeFlowException { short permSplitFactor = Short . parseShort ( splitFactor ) ; if ( permSplitFactor <= NUM_ || ( ( m_outerFramingFlow . getDuration ( ) / permSplitFactor ) < MILLISECONDS_IN_ONE_MINUTE ) ) { throw new AdeFlowException ( STR_ ) ; } return permSplitFactor ; }
public static Calendar toCalendar ( String datestring , String format ) { Date d = parse ( datestring , format ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTimeInMillis ( d . getTime ( ) ) ; return cal ; }
public void testCompareToDiffSigns2 ( ) { byte aBytes [ ] = { NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = - NUM_ ; int bSign = NUM_ ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; assertEquals ( - NUM_ , aNumber . compareTo ( bNumber ) ) ; }
private static void translateCompatibilityToPaths ( RPAction action ) { if ( action . has ( EquipActionConsts . BASE_OBJECT ) ) { List < String > path = Arrays . asList ( action . get ( EquipActionConsts . BASE_OBJECT ) , action . get ( EquipActionConsts . BASE_SLOT ) , action . get ( EquipActionConsts . BASE_ITEM ) ) ; action . put ( EquipActionConsts . SOURCE_PATH , path ) ; } else { List < String > path = Arrays . asList ( action . get ( EquipActionConsts . BASE_ITEM ) ) ; action . put ( EquipActionConsts . SOURCE_PATH , path ) ; } }
public Builder addMenuItem ( @ NonNull String label , @ NonNull PendingIntent pendingIntent ) { if ( mMenuItems == null ) mMenuItems = new ArrayList < > ( ) ; Bundle bundle = new Bundle ( ) ; bundle . putString ( KEY_MENU_ITEM_TITLE , label ) ; bundle . putParcelable ( KEY_PENDING_INTENT , pendingIntent ) ; mMenuItems . add ( bundle ) ; return this ; }
public SparseFloatVector ( TIntFloatMap values , int dimensionality ) throws IllegalArgumentException { if ( values . size ( ) > dimensionality ) { throw new IllegalArgumentException ( STR_ ) ; } this . indexes = new int [ values . size ( ) ] ; this . values = new float [ values . size ( ) ] ; { TIntFloatIterator iter = values . iterator ( ) ; for ( int i = NUM_ ; iter . hasNext ( ) ; i ++ ) { iter . advance ( ) ; this . indexes [ i ] = iter . key ( ) ; } Arrays . sort ( this . indexes ) ; } { for ( int i = NUM_ ; i < values . size ( ) ; i ++ ) { this . values [ i ] = values . get ( this . indexes [ i ] ) ; } } this . dimensionality = dimensionality ; final int maxdim = getMaxDim ( ) ; if ( maxdim > dimensionality ) { throw new IllegalArgumentException ( STR_ + dimensionality + STR_ + maxdim + STR_ ) ; } }
public byte [ ] canonSerializeToByteArray ( Node node ) throws Exception { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; canon . setWriter ( baos ) ; canon . notReset ( ) ; canon . canonicalizeSubtree ( node ) ; return baos . toByteArray ( ) ; }
public DefinedMethod addDescription ( String description ) { this . description = Optional . of ( description ) ; return this ; }
public int addFlattenedColumn ( Object o , int [ ] dims ) throws FitsException { return addFlattenedColumn ( o , dims , BOOL_ ) ; }
public final void writeToStream ( DataOutputStream dos ) throws IOException { dos . writeUTF ( event ) ; dos . writeUTF ( site ) ; dos . writeUTF ( date ) ; dos . writeUTF ( round ) ; dos . writeUTF ( white ) ; dos . writeUTF ( black ) ; dos . writeUTF ( TextIO . toFEN ( startPos ) ) ; dos . writeUTF ( timeControl ) ; dos . writeUTF ( whiteTimeControl ) ; dos . writeUTF ( blackTimeControl ) ; int nTags = tagPairs . size ( ) ; dos . writeInt ( nTags ) ; for ( int i = NUM_ ; i < nTags ; i ++ ) { dos . writeUTF ( tagPairs . get ( i ) . tagName ) ; dos . writeUTF ( tagPairs . get ( i ) . tagValue ) ; } Node . writeToStream ( dos , rootNode ) ; ArrayList < Integer > pathFromRoot = currentNode . getPathFromRoot ( ) ; int pathLen = pathFromRoot . size ( ) ; dos . writeInt ( pathLen ) ; for ( int i = NUM_ ; i < pathLen ; i ++ ) dos . writeInt ( pathFromRoot . get ( i ) ) ; }
public void registerSource ( ProgressSource pi ) { synchronized ( progressSourceList ) { if ( progressSourceList . contains ( pi ) ) return ; progressSourceList . add ( pi ) ; } if ( progressListenerList . size ( ) > NUM_ ) { ArrayList < ProgressListener > listeners = new ArrayList < ProgressListener > ( ) ; synchronized ( progressListenerList ) { for ( Iterator < ProgressListener > iter = progressListenerList . iterator ( ) ; iter . hasNext ( ) ; ) { listeners . add ( iter . next ( ) ) ; } } for ( Iterator < ProgressListener > iter = listeners . iterator ( ) ; iter . hasNext ( ) ; ) { ProgressListener pl = iter . next ( ) ; ProgressEvent pe = new ProgressEvent ( pi , pi . getURL ( ) , pi . getMethod ( ) , pi . getContentType ( ) , pi . getState ( ) , pi . getProgress ( ) , pi . getExpected ( ) ) ; pl . progressStart ( pe ) ; } } }
private static Map < String , String > extractKeyValuePairs ( String props , ObjectName mbean ) { Map < String , String > map = new LinkedHashMap < String , String > ( ) ; int eq = props . indexOf ( STR_ ) ; while ( eq != - NUM_ ) { String key = props . substring ( NUM_ , eq ) ; String value = mbean . getKeyProperty ( key ) ; map . put ( key , value ) ; props = props . substring ( key . length ( ) + NUM_ + value . length ( ) ) ; if ( props . startsWith ( STR_ ) ) { props = props . substring ( NUM_ ) ; } eq = props . indexOf ( STR_ ) ; } return map ; }
protected void paintContentBorderLeftEdge ( Graphics g , int tabPlacement , int selectedIndex , int x , int y , int w , int h ) { Rectangle selRect = selectedIndex < NUM_ ? null : getTabBounds ( selectedIndex , calcRect ) ; g . setColor ( selectHighlight ) ; if ( tabPlacement != LEFT || selectedIndex < NUM_ || ( selRect . x + selRect . width + NUM_ < x ) || ( selRect . y < y || selRect . y > y + h ) ) { g . drawLine ( x , y , x , y + h - NUM_ ) ; } else { g . drawLine ( x , y , x , selRect . y + NUM_ ) ; if ( selRect . y + selRect . height < y + h - NUM_ ) g . drawLine ( x , selRect . y + selRect . height + NUM_ , x , y + h - NUM_ ) ; } }
public final Flux < T > sample ( Duration timespan ) { return sampleMillis ( timespan . toMillis ( ) ) ; }
@ Override public boolean hasValuesDescription ( ) { return restrictionClass != null && restrictionClass != Object . class ; }
public SmbFile ( String url ) throws MalformedURLException { this ( new URL ( null , url , Handler . SMB_HANDLER ) ) ; }
public static boolean isAudio ( String mimeType ) { if ( mimeType != null ) { if ( mimeType . startsWith ( STR_ ) ) return BOOL_ ; else return BOOL_ ; } else return BOOL_ ; }
private void restoreWidget ( Key key , byte [ ] buffer , int dataSize ) throws IOException { if ( VERBOSE ) Log . v ( TAG , STR_ + key . id ) ; if ( DEBUG ) Log . d ( TAG , STR_ + buffer . length + STR_ + Base64 . encodeToString ( buffer , NUM_ , dataSize , Base64 . NO_WRAP ) ) ; Widget widget = unpackProto ( new Widget ( ) , buffer , dataSize ) ; if ( DEBUG ) Log . d ( TAG , STR_ + widget . provider ) ; if ( widget . icon . data != null ) { Bitmap icon = BitmapFactory . decodeByteArray ( widget . icon . data , NUM_ , widget . icon . data . length ) ; if ( icon == null ) { Log . w ( TAG , STR_ + key . name ) ; } else { IconCache . preloadIcon ( mContext , ComponentName . unflattenFromString ( widget . provider ) , icon , widget . icon . dpi ) ; } } }
protected int assertLineTerminates ( int c ) throws IOException , RDFParseException { c = reader . read ( ) ; c = skipWhitespace ( c ) ; if ( c != - NUM_ && c != STR_ && c != STR_ ) { reportFatalError ( STR_ ) ; } return c ; }
static private XMLEvent constructEvent ( int eventType , WbXmlStreamReader stream ) throws XMLStreamException { log . log ( Level . FINE , STR_ ) ; XMLEvent event ; switch ( eventType ) { case XMLStreamConstants . START_DOCUMENT : event = new WbXmlStartDocumentEvent ( stream ) ; break ; case XMLStreamConstants . END_DOCUMENT : event = new WbXmlEndDocumentEvent ( stream ) ; break ; case XMLStreamConstants . START_ELEMENT : event = new WbXmlStartElementEvent ( stream ) ; break ; case XMLStreamConstants . END_ELEMENT : event = new WbXmlEndElementEvent ( stream ) ; break ; case XMLStreamConstants . CHARACTERS : case XMLStreamConstants . CDATA : event = new WbXmlCharactersEvent ( stream ) ; break ; default : throw new UnsupportedOperationException ( String . format ( STR_ , eventType ) ) ; } log . log ( Level . FINE , STR_ , event ) ; return event ; }
private void verifyGridState ( ) { Integer rowLength = null ; int rowPos = NUM_ ; for ( List < Object > row : grid ) { if ( rowLength != null && rowLength != row . size ( ) ) { throw new IllegalStateException ( STR_ + rowLength + STR_ + row . size ( ) + STR_ + rowPos ) ; } rowPos ++ ; rowLength = row . size ( ) ; } }
public static String readStringAndClose ( Reader in , int length ) throws IOException { try { if ( length <= NUM_ ) { length = Integer . MAX_VALUE ; } int block = Math . min ( Constants . IO_BUFFER_SIZE , length ) ; StringWriter out = new StringWriter ( block ) ; copyAndCloseInput ( in , out , length ) ; return out . toString ( ) ; } finally { in . close ( ) ; } }
protected void beginPath ( ) { prepDrawing ( ) ; mPSStream . println ( NEWPATH_STR ) ; mPenX = NUM_ ; mPenY = NUM_ ; }
private boolean inSamePackage ( Class < ? > c1 , Class < ? > c2 ) { String nameC1 = c1 . getName ( ) ; String nameC2 = c2 . getName ( ) ; int indexDotC1 = nameC1 . lastIndexOf ( STR_ ) ; int indexDotC2 = nameC2 . lastIndexOf ( STR_ ) ; if ( indexDotC1 != indexDotC2 ) { return BOOL_ ; } if ( indexDotC1 == - NUM_ ) { return BOOL_ ; } return nameC1 . regionMatches ( NUM_ , nameC2 , NUM_ , indexDotC1 ) ; }
private void sendTcpRequest ( Socket socket , String request ) throws ApiException { try { LogUtils . LOGD ( TAG , STR_ + request ) ; BufferedWriter writer = new BufferedWriter ( new OutputStreamWriter ( socket . getOutputStream ( ) ) ) ; writer . write ( request ) ; writer . flush ( ) ; } catch ( Exception e ) { LogUtils . LOGW ( TAG , STR_ , e ) ; disconnect ( ) ; throw new ApiException ( ApiException . IO_EXCEPTION_WHILE_SENDING_REQUEST , e ) ; } }
public static String cleanString ( String src ) { if ( src == null ) { return null ; } boolean foundBad = BOOL_ ; final CharacterIterator it = new StringCharacterIterator ( src ) ; for ( char c = it . first ( ) ; c != CharacterIterator . DONE ; c = it . next ( ) ) { if ( c < ASCII_PRINTABLE_LOW || c >= ASCII_PRINTABLE_HI ) { foundBad = BOOL_ ; break ; } } if ( ! foundBad ) { return src ; } final StringBuilder res = new StringBuilder ( ) ; for ( char c = it . first ( ) ; c != CharacterIterator . DONE ; c = it . next ( ) ) { if ( c < ASCII_PRINTABLE_LOW || c >= ASCII_PRINTABLE_HI ) { res . append ( ASCII_SPACE ) ; } else { res . append ( c ) ; } } return res . toString ( ) ; }
public static ManualLagGraph serializableInstance ( ) { return new ManualLagGraph ( ManualLagGraphParams . serializableInstance ( ) ) ; }
public void updateActions ( ) { String text ; Action a = RTextArea . getAction ( RTextArea . UNDO_ACTION ) ; if ( canUndo ( ) ) { a . setEnabled ( BOOL_ ) ; text = getUndoPresentationName ( ) ; a . putValue ( Action . NAME , text ) ; a . putValue ( Action . SHORT_DESCRIPTION , text ) ; } else { if ( a . isEnabled ( ) ) { a . setEnabled ( BOOL_ ) ; text = cantUndoText ; a . putValue ( Action . NAME , text ) ; a . putValue ( Action . SHORT_DESCRIPTION , text ) ; } } a = RTextArea . getAction ( RTextArea . REDO_ACTION ) ; if ( canRedo ( ) ) { a . setEnabled ( BOOL_ ) ; text = getRedoPresentationName ( ) ; a . putValue ( Action . NAME , text ) ; a . putValue ( Action . SHORT_DESCRIPTION , text ) ; } else { if ( a . isEnabled ( ) ) { a . setEnabled ( BOOL_ ) ; text = cantRedoText ; a . putValue ( Action . NAME , text ) ; a . putValue ( Action . SHORT_DESCRIPTION , text ) ; } } }
public void elementType ( String name , int model , int memberOf , int flags ) { ElementType e = new ElementType ( name , model , memberOf , flags , this ) ; theElementTypes . put ( name . toLowerCase ( ) , e ) ; if ( memberOf == M_ROOT ) theRoot = e ; }
private static List < SizePair > generateValidPreviewSizeList ( Camera camera ) { Camera . Parameters parameters = camera . getParameters ( ) ; List < android . hardware . Camera . Size > supportedPreviewSizes = parameters . getSupportedPreviewSizes ( ) ; List < android . hardware . Camera . Size > supportedPictureSizes = parameters . getSupportedPictureSizes ( ) ; List < SizePair > validPreviewSizes = new ArrayList < > ( ) ; for ( android . hardware . Camera . Size previewSize : supportedPreviewSizes ) { float previewAspectRatio = ( float ) previewSize . width / ( float ) previewSize . height ; for ( android . hardware . Camera . Size pictureSize : supportedPictureSizes ) { float pictureAspectRatio = ( float ) pictureSize . width / ( float ) pictureSize . height ; if ( Math . abs ( previewAspectRatio - pictureAspectRatio ) < ASPECT_RATIO_TOLERANCE ) { validPreviewSizes . add ( new SizePair ( previewSize , pictureSize ) ) ; break ; } } } if ( validPreviewSizes . size ( ) == NUM_ ) { Log . w ( TAG , STR_ ) ; for ( android . hardware . Camera . Size previewSize : supportedPreviewSizes ) { validPreviewSizes . add ( new SizePair ( previewSize , null ) ) ; } } return validPreviewSizes ; }
public void addScrollingListener ( OnWheelScrollListener listener ) { scrollingListeners . add ( listener ) ; }
public static boolean hasDependency ( MavenProject project , String groupId ) { Set < Artifact > artifacts = project . getArtifacts ( ) ; if ( artifacts != null ) { for ( Artifact artifact : artifacts ) { String scope = artifact . getScope ( ) ; if ( Objects . equal ( STR_ , scope ) ) { continue ; } if ( Objects . equal ( groupId , artifact . getGroupId ( ) ) ) { return BOOL_ ; } } } return BOOL_ ; }
public ContourGenerator ( URL url , float modelMean , float modelStddev ) throws IOException { this . modelMean = modelMean ; this . modelStddev = modelStddev ; List termsList = new ArrayList ( ) ; String line ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( url . openStream ( ) ) ) ; line = reader . readLine ( ) ; while ( line != null ) { if ( ! line . startsWith ( STR_ ) ) { parseAndAdd ( termsList , line ) ; } line = reader . readLine ( ) ; } terms = ( F0ModelTerm [ ] ) termsList . toArray ( terms ) ; reader . close ( ) ; }
public void addComment ( String comment ) { if ( frame != null ) { chatTab . addComment ( comment ) ; } if ( tabbedPane . getSelectedIndex ( ) == NUM_ ) { editorTab . displayComment ( comment ) ; } }
public static byte [ ] hexStringToBytes ( String hexString ) { if ( hexString == null || hexString . equals ( STR_ ) ) { return null ; } hexString = hexString . toUpperCase ( ) ; int length = hexString . length ( ) / NUM_ ; char [ ] hexChars = hexString . toCharArray ( ) ; byte [ ] d = new byte [ length ] ; for ( int i = NUM_ ; i < length ; i ++ ) { int pos = i . NUM_ ; d [ i ] = ( byte ) ( charToByte ( hexChars [ pos ] ) << NUM_ | charToByte ( hexChars [ pos + NUM_ ] ) ) ; } return d ; }
private void decompose ( List < Object > elementPairs , List < Object > printerList , List < Object > parserList ) { int size = elementPairs . size ( ) ; for ( int i = NUM_ ; i < size ; i += NUM_ ) { Object element = elementPairs . get ( i ) ; if ( element instanceof DateTimePrinter ) { if ( element instanceof Composite ) { addArrayToList ( printerList , ( ( Composite ) element ) . iPrinters ) ; } else { printerList . add ( element ) ; } } element = elementPairs . get ( i + NUM_ ) ; if ( element instanceof DateTimeParser ) { if ( element instanceof Composite ) { addArrayToList ( parserList , ( ( Composite ) element ) . iParsers ) ; } else { parserList . add ( element ) ; } } } }
private String processIntegerToken ( String token ) { String result = token . replaceAll ( STR_ + groupSeparator , STR_ ) ; boolean isNegative = BOOL_ ; int preLen = negativePrefix . length ( ) ; if ( ( preLen > NUM_ ) && result . startsWith ( negativePrefix ) ) { isNegative = BOOL_ ; result = result . substring ( preLen ) ; } int sufLen = negativeSuffix . length ( ) ; if ( ( sufLen > NUM_ ) && result . endsWith ( negativeSuffix ) ) { isNegative = BOOL_ ; result = result . substring ( result . length ( ) - sufLen , result . length ( ) ) ; } if ( isNegative ) result = STR_ + result ; return result ; }
public void writeGraphics ( String graphicsSaveFile ) throws IOException { FileOutputStream ostream = new FileOutputStream ( graphicsSaveFile ) ; ObjectOutputStream objectstream = new ObjectOutputStream ( ostream ) ; writeGraphics ( objectstream ) ; objectstream . close ( ) ; }
@ Override public void addInputNode ( BNode inputNode ) { super . addInputNode ( inputNode ) ; }
public void removeDependency ( TaskDependency dep ) { Node srcNode = myNodeMap . get ( dep . getDependee ( ) ) ; Node dstNode = myNodeMap . get ( dep . getDependant ( ) ) ; if ( srcNode == null && dstNode == null ) { return ; } assert ( srcNode != null && dstNode != null ) : STR_ + dep + STR_ ; DependencyEdge diedEdge = findExplicitDependency ( dep , srcNode , dstNode ) ; if ( diedEdge == null ) { return ; } removeEdge ( diedEdge ) ; for ( DependencyEdge edge : Lists . newArrayList ( srcNode . getOutgoing ( ) ) ) { if ( edge instanceof ImplicitInheritedDependency ) { if ( ( ( ImplicitInheritedDependency ) edge ) . myExplicitDep == diedEdge ) { removeEdge ( edge ) ; } } } fireGraphChanged ( ) ; }
public Criteria or ( ) { Criteria criteria = createCriteriaInternal ( ) ; oredCriteria . add ( criteria ) ; return criteria ; }
public static boolean isExtension ( String filename , Collection < String > extensions ) { if ( filename == null ) { return BOOL_ ; } if ( extensions == null || extensions . isEmpty ( ) ) { return indexOfExtension ( filename ) == - NUM_ ; } String fileExt = getExtension ( filename ) ; for ( String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return BOOL_ ; } } return BOOL_ ; }
public VNXeCommandJob modifyConsistencyGroupAsync ( String id , LunGroupModifyParam param ) { StringBuilder urlBld = new StringBuilder ( URL_MODIFY1 ) ; urlBld . append ( id ) ; urlBld . append ( URL_MODIFY2 ) ; _url = urlBld . toString ( ) ; return postRequestAsync ( param ) ; }
public Object readRemote ( ) throws IOException { String type = readType ( ) ; String url = readString ( ) ; return resolveRemote ( type , url ) ; }
private static JFreeChart createChart ( ) { XYSeries series1 = new XYSeries ( STR_ ) ; series1 . add ( NUM_ , NUM_ ) ; series1 . add ( NUM_ , NUM_ ) ; series1 . add ( NUM_ , NUM_ ) ; XYDataset dataset = new XYSeriesCollection ( series1 ) ; return ChartFactory . createTimeSeriesChart ( STR_ , STR_ , STR_ , dataset , BOOL_ , BOOL_ , BOOL_ ) ; }
private void DTDprolog ( ) throws SAXException , IOException { final java . io . Writer writer = m_writer ; if ( m_needToOutputDocTypeDecl ) { outputDocTypeDecl ( m_elemContext . m_elementName , BOOL_ ) ; m_needToOutputDocTypeDecl = BOOL_ ; } if ( m_inDoctype ) { writer . write ( STR_ ) ; writer . write ( m_lineSep , NUM_ , m_lineSepLen ) ; m_inDoctype = BOOL_ ; } }
public CacheSet querySequential ( Predicate ... selectors ) { checkNotNull ( selectors ) ; Collection < Object > resultCollection = new ArrayList < > ( items ) ; Collection < Object > filterCollection = new LinkedList < > ( ) ; Collection < Object > tempCollection ; int i = NUM_ ; while ( ( i < selectors . length ) && ( resultCollection . size ( ) > NUM_ ) ) { CollectionUtils . select ( resultCollection , selectors [ i ] , filterCollection ) ; tempCollection = resultCollection ; resultCollection = filterCollection ; filterCollection = tempCollection ; filterCollection . clear ( ) ; i ++ ; } return new CacheSet ( resultCollection ) ; }
@ Override public boolean isErrorEnabled ( ) { return logger . isLoggable ( Level . SEVERE ) ; }
public static < A > SetTValue < A > fromStream ( final AnyMValue < Stream < A > > monads ) { return of ( monads . map ( null ) ) ; }
public static CCBitmapFontConfiguration FNTConfigLoadFile ( String fntFile ) { CCBitmapFontConfiguration ret = null ; if ( configurations == null ) configurations = new HashMap < String , CCBitmapFontConfiguration > ( ) ; ret = configurations . get ( fntFile ) ; if ( ret == null ) { ret = CCBitmapFontConfiguration . configuration ( fntFile ) ; configurations . put ( fntFile , ret ) ; } return ret ; }
public void addCriteria ( Criteria otherCriteria ) { if ( otherCriteria instanceof AdvancedCriteria || otherCriteria instanceof Criterion ) { throw new IllegalArgumentException ( STR_ + STR_ ) ; } Map otherMap = otherCriteria . getValues ( ) ; Set otherKeys = otherMap . keySet ( ) ; for ( Iterator i = otherKeys . iterator ( ) ; i . hasNext ( ) ; ) { String field = ( String ) i . next ( ) ; Object value = otherMap . get ( field ) ; JSOHelper . setAttribute ( jsObj , field , value ) ; } }
public DNetscapeSslServerName ( JDialog parent , byte [ ] value ) throws IOException { super ( parent ) ; setTitle ( res . getString ( STR_ ) ) ; initComponents ( ) ; prepopulateWithValue ( value ) ; }
public static EventBean [ ] resizeArray ( EventBean [ ] oldArray , int newSize ) { if ( oldArray == null ) { return null ; } if ( oldArray . length == newSize ) { return oldArray ; } EventBean [ ] newArray = new EventBean [ newSize ] ; int preserveLength = Math . min ( oldArray . length , newSize ) ; if ( preserveLength > NUM_ ) { System . arraycopy ( oldArray , NUM_ , newArray , NUM_ , preserveLength ) ; } return newArray ; }
public static SpannableString spanText ( CharSequence text , Object ... spans ) { SpannableString spannableString = new SpannableString ( text ) ; for ( Object span : spans ) { spannableString . setSpan ( span , NUM_ , text . length ( ) , Spanned . SPAN_EXCLUSIVE_EXCLUSIVE ) ; } return spannableString ; }
@ SuppressWarnings ( STR_ ) protected < T > List < T > query ( Class < T > modelClass , String [ ] columns , String selection , String [ ] selectionArgs , String groupBy , String having , String orderBy , String limit , List < AssociationsInfo > foreignKeyAssociations ) { List < T > dataList = new ArrayList < T > ( ) ; Cursor cursor = null ; try { List < Field > supportedFields = getSupportedFields ( modelClass . getName ( ) ) ; String tableName = getTableName ( modelClass ) ; String [ ] customizedColumns = getCustomizedColumns ( columns , foreignKeyAssociations ) ; cursor = mDatabase . query ( tableName , customizedColumns , selection , selectionArgs , groupBy , having , orderBy , limit ) ; if ( cursor . moveToFirst ( ) ) { SparseArray < QueryInfoCache > queryInfoCacheSparseArray = new SparseArray < QueryInfoCache > ( ) ; do { T modelInstance = ( T ) createInstanceFromClass ( modelClass ) ; giveBaseObjIdValue ( ( DataSupport ) modelInstance , cursor . getLong ( cursor . getColumnIndexOrThrow ( STR_ ) ) ) ; setValueToModel ( modelInstance , supportedFields , foreignKeyAssociations , cursor , queryInfoCacheSparseArray ) ; if ( foreignKeyAssociations != null ) { setAssociatedModel ( ( DataSupport ) modelInstance ) ; } dataList . add ( modelInstance ) ; } while ( cursor . moveToNext ( ) ) ; queryInfoCacheSparseArray . clear ( ) ; } return dataList ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new DataSupportException ( e . getMessage ( ) ) ; } finally { if ( cursor != null ) { cursor . close ( ) ; } } }
private MLTResult buildQueryForField ( String fieldName , PriorityQueue < MLTTerm > q , BooleanQuery query , boolean contentStreamQuery ) { List < MLTTerm > interestingTerms = new ArrayList < MLTTerm > ( ) ; int qterms = NUM_ ; int maxTerms = maxQueryTermsPerField ; if ( maxTerms <= NUM_ ) { maxTerms = Integer . MAX_VALUE ; } BooleanQuery tmpQuery = new BooleanQuery ( ) ; double sumQuaredBoost = NUM_ ; MLTTerm cur ; while ( ( cur = q . pop ( ) ) != null ) { Query tq = null ; final Term term = new Term ( cur . getFieldName ( ) , cur . getWord ( ) ) ; if ( isPayloadField ( cur . getFieldName ( ) ) ) { tq = new PayloadTermQuery ( term , new AveragePayloadFunction ( ) , BOOL_ ) ; } else { tq = new TermQuery ( term ) ; } if ( boost ) { float boost = cur . getScore ( ) ; tq . setBoost ( boost ) ; sumQuaredBoost += boost . boost ; } else { sumQuaredBoost += NUM_ ; } try { tmpQuery . add ( tq , BooleanClause . Occur . SHOULD ) ; interestingTerms . add ( cur ) ; qterms ++ ; } catch ( BooleanQuery . TooManyClauses ignore ) { break ; } if ( qterms >= maxTerms ) { break ; } } double vectorLength = Math . sqrt ( sumQuaredBoost ) ; if ( vectorLength <= NUM_ ) { return new MLTResult ( interestingTerms , query ) ; } buildBoostedNormalizedQuery ( fieldName , tmpQuery , query , vectorLength , contentStreamQuery ) ; return new MLTResult ( interestingTerms , query ) ; }
@ SuppressWarnings ( STR_ ) protected void sequentially ( Consumer < Marker > ... functions ) { if ( functions == null || functions . length == NUM_ ) return ; Collection < ParsingException > errors = new ArrayList < > ( ) ; Marker marker = tokens . mark ( ) ; for ( Consumer < Marker > function : functions ) { try { function . accept ( marker ) ; return ; } catch ( ParsingException e ) { errors . add ( e ) ; tokens . rewind ( marker ) ; } } parsingFailed ( marker . position ( ) , errors , STR_ ) ; }
public PidFile ( final File file ) throws FileNotFoundException { if ( ! file . exists ( ) || ! file . isFile ( ) ) { throw new FileNotFoundException ( STR_ + file + STR_ ) ; } this . pidFile = file ; }
public void addChildNode ( ExecNode childNode ) { childNodes . add ( childNode ) ; }
public BayesImEditorObs ( BayesImWrapperObs bayesImWrapperObs ) { this ( bayesImWrapperObs , bayesImWrapperObs . getBayesIm ( ) ) ; }
private List < String > convertByteArrayListToStringValueList ( List < byte [ ] > dictionaryByteArrayList ) { List < String > valueList = new ArrayList < > ( dictionaryByteArrayList . size ( ) ) ; for ( byte [ ] value : dictionaryByteArrayList ) { valueList . add ( new String ( value , Charset . forName ( CarbonCommonConstants . DEFAULT_CHARSET ) ) ) ; } return valueList ; }
public FileTreeNode ( File parent , String name ) throws SecurityException , FileNotFoundException { this ( parent . toPath ( ) , name ) ; }
private List < Node > possibleParents ( Node x , List < Node > adjx , IKnowledge knowledge ) { List < Node > possibleParents = new LinkedList < > ( ) ; String _x = x . getName ( ) ; for ( Node z : adjx ) { String _z = z . getName ( ) ; if ( possibleParentOf ( _z , _x , knowledge ) ) { possibleParents . add ( z ) ; } } return possibleParents ; }
public synchronized void remove ( AbstractOption option ) { if ( options . contains ( option ) ) { int position = indexOf ( option ) ; List < AbstractOption > oldOptions = new ArrayList < AbstractOption > ( options ) ; options . remove ( option ) ; List < AbstractOption > newOptions = getOptions ( ) ; option . setCollection ( null ) ; fireIndexedPropertyChange ( PROP_OPTIONS , position , oldOptions , newOptions ) ; } }
private float [ ] calculatePointerPosition ( float angle ) { float x = ( float ) ( mColorWheelRadius . Math . cos ( angle ) ) ; float y = ( float ) ( mColorWheelRadius . Math . sin ( angle ) ) ; return new float [ ] { x , y } ; }
public ResourceNode locate ( String sessionID , String path , ResourceNode startNode ) throws DirectoryNotFoundException { if ( path == null ) { return getCurrentNode ( sessionID ) ; } else if ( path . startsWith ( PROTOCOL ) ) { path = path . substring ( PROTOCOL . length ( ) ) ; } else if ( path . startsWith ( ROOT_ELEMENT ) && path . length ( ) > ROOT_ELEMENT . length ( ) ) { startNode = getRootNode ( ) ; path = path . substring ( ROOT_ELEMENT . length ( ) ) ; } if ( path . equals ( CURRENT_ELEMENT ) ) return getCurrentNode ( sessionID ) ; else if ( path . equals ( ROOT_ELEMENT ) ) return getRootNode ( ) ; ResourceNode foundNode = null ; ResourceNode nodeToSearch = startNode ; String pathElements [ ] = path . split ( PATH_SEPARATOR ) ; if ( pathElements . length == NUM_ ) { return getRootNode ( ) ; } for ( String element : pathElements ) { if ( element . length ( ) == NUM_ ) continue ; if ( element . equals ( PARENT_ELEMENT ) ) { if ( ( foundNode = nodeToSearch . getParent ( ) ) != null ) { nodeToSearch = nodeToSearch . getParent ( ) ; } else { throw new DirectoryNotFoundException ( String . format ( STR_ , path ) ) ; } } else { Map < String , ResourceNode > children = nodeToSearch . getChildren ( ) ; if ( element . equals ( ANY_ELEMENT ) ) { if ( nodeToSearch . getType ( ) == ResourceType . CLUSTER ) { foundNode = children . get ( memberName ) ; } else if ( children . size ( ) > NUM_ ) { foundNode = getFirst ( children ) ; } else { throw new DirectoryNotFoundException ( String . format ( STR_ , element , path ) ) ; } } else { foundNode = children . get ( element ) ; } if ( foundNode == null ) { throw new DirectoryNotFoundException ( String . format ( STR_ , element , formatPath ( getAbsolutePath ( getRootNode ( ) , nodeToSearch , BOOL_ ) , BOOL_ ) , path ) ) ; } nodeToSearch = foundNode ; } } return foundNode ; }
private void handleProcessError ( JobDefinition job , Process process ) throws IOException { StringBuffer sb = new StringBuffer ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ; int data = NUM_ ; while ( data != - NUM_ && ! isInterrupted ( ) ) { data = in . read ( ) ; if ( data != - NUM_ ) { sb . append ( ( char ) data ) ; } } logger . warn ( STR_ + job . cut + STR_ + sb . toString ( ) ) ; }
private void checkClassAndSync ( Class < ? extends IPacket > clazz ) { if ( ! registeredClasses . contains ( clazz ) ) { throw new RuntimeException ( STR_ + clazz + STR_ ) ; } while ( isCurrentlySendingSemaphor ) { Thread . yield ( ) ; } isCurrentlySendingSemaphor = BOOL_ ; }
private void writeAttribute ( java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( namespace . equals ( STR_ ) ) { xmlWriter . writeAttribute ( attName , attValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } }
private static int calculateDisplayedWidth ( String string ) { final int tabWidth = DEFAULT_TAB_WIDTH ; int column = NUM_ ; for ( int i = NUM_ ; i < string . length ( ) ; i ++ ) { if ( STR_ == string . charAt ( i ) ) { column += tabWidth - ( column % tabWidth ) ; } else { column ++ ; } } return column ; }
private static GeneralizedTime finishDecodingFraction ( final String value , final int startPos , final int year , final int month , final int day , final int hour , final int minute , final int second , final int multiplier ) { final int length = value . length ( ) ; final StringBuilder fractionBuffer = new StringBuilder ( ( NUM_ + length ) - startPos ) ; fractionBuffer . append ( STR_ ) ; TimeZone timeZone = null ; outerLoop : for ( int i = startPos ; i < length ; i ++ ) { final char c = value . charAt ( i ) ; switch ( c ) { case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : fractionBuffer . append ( c ) ; break ; case STR_ : case STR_ : if ( i != ( value . length ( ) - NUM_ ) ) { final LocalizableMessage message = WARN_ATTR_SYNTAX_GENERALIZED_TIME_ILLEGAL_FRACTION_CHAR . get ( value , String . valueOf ( c ) ) ; throw new LocalizedIllegalArgumentException ( message ) ; } timeZone = TIME_ZONE_UTC_OBJ ; break outerLoop ; case STR_ : case STR_ : timeZone = getTimeZoneForOffset ( value , i ) ; break outerLoop ; default : final LocalizableMessage message = WARN_ATTR_SYNTAX_GENERALIZED_TIME_ILLEGAL_FRACTION_CHAR . get ( value , String . valueOf ( c ) ) ; throw new LocalizedIllegalArgumentException ( message ) ; } } if ( fractionBuffer . length ( ) == NUM_ ) { final LocalizableMessage message = WARN_ATTR_SYNTAX_GENERALIZED_TIME_EMPTY_FRACTION . get ( value ) ; throw new LocalizedIllegalArgumentException ( message ) ; } if ( timeZone == null ) { final LocalizableMessage message = WARN_ATTR_SYNTAX_GENERALIZED_TIME_NO_TIME_ZONE_INFO . get ( value ) ; throw new LocalizedIllegalArgumentException ( message ) ; } final Double fractionValue = Double . parseDouble ( fractionBuffer . toString ( ) ) ; final int additionalMilliseconds = ( int ) Math . round ( fractionValue . multiplier ) ; try { final GregorianCalendar calendar = new GregorianCalendar ( ) ; calendar . setLenient ( BOOL_ ) ; calendar . setTimeZone ( timeZone ) ; calendar . set ( year , month , day , hour , minute , second ) ; calendar . set ( Calendar . MILLISECOND , additionalMilliseconds ) ; return new GeneralizedTime ( calendar , null , Long . MIN_VALUE , value ) ; } catch ( final Exception e ) { final LocalizableMessage message = WARN_ATTR_SYNTAX_GENERALIZED_TIME_ILLEGAL_TIME . get ( value , String . valueOf ( e ) ) ; throw new LocalizedIllegalArgumentException ( message , e ) ; } }
@ Override public int read ( ) { if ( idx >= charSequence . length ( ) ) { return - NUM_ ; } else { return charSequence . charAt ( idx ++ ) ; } }
public void test_getClientAliases ( ) { init ( CLIENT ) ; assertNull ( manager . getClientAliases ( null , null ) ) ; assertNull ( manager . getClientAliases ( STR_ , null ) ) ; String [ ] resArray = manager . getClientAliases ( TYPE_RSA , null ) ; assertNotNull ( resArray ) ; assertEquals ( NUM_ , resArray . length ) ; assertKnownAliases ( resArray ) ; }
public void removeAllUpdateListeners ( ) { if ( mUpdateListeners == null ) { return ; } mUpdateListeners . clear ( ) ; mUpdateListeners = null ; }
@ SuppressWarnings ( STR_ ) E transfer ( E e , boolean timed , long nanos ) { QNode s = null ; boolean isData = ( e != null ) ; for ( ; ; ) { QNode t = tail ; QNode h = head ; if ( t == null || h == null ) continue ; if ( h == t || t . isData == isData ) { QNode tn = t . next ; if ( t != tail ) continue ; if ( tn != null ) { advanceTail ( t , tn ) ; continue ; } if ( timed && nanos <= NUM_ ) return null ; if ( s == null ) s = new QNode ( e , isData ) ; if ( ! t . casNext ( null , s ) ) continue ; advanceTail ( t , s ) ; Object x = awaitFulfill ( s , e , timed , nanos ) ; if ( x == s ) { clean ( t , s ) ; return null ; } if ( ! s . isOffList ( ) ) { advanceHead ( t , s ) ; if ( x != null ) s . item = s ; s . waiter = null ; } return ( x != null ) ? ( E ) x : e ; } else { QNode m = h . next ; if ( t != tail || m == null || h != head ) continue ; Object x = m . item ; if ( isData == ( x != null ) || x == m || ! m . casItem ( x , e ) ) { advanceHead ( h , m ) ; continue ; } advanceHead ( h , m ) ; LockSupport . unpark ( m . waiter ) ; return ( x != null ) ? ( E ) x : e ; } } }
public static void println ( char x ) { out . println ( x ) ; }
private boolean shouldPositionAvatarOnRight ( ) { final boolean isRtl = Build . VERSION . SDK_INT >= Build . VERSION_CODES . JELLY_BEAN_MR1 ? getLayoutDirection ( ) == LAYOUT_DIRECTION_RTL : BOOL_ ; final boolean assignedPosition = mAvatarPosition == AVATAR_POSITION_END ; return isRtl ? ! assignedPosition : assignedPosition ; }
public static Charset toCharset ( Charset charset ) { return charset == null ? Charset . defaultCharset ( ) : charset ; }
public static void fail ( String message ) { throw new IllegalStateException ( message == null ? STR_ : message ) ; }
public void memsetBuffer ( ByteBuffer buffer ) { memsetBuffer ( buffer , buffer . limit ( ) ) ; }
static double fabs ( double a ) { return Math . abs ( a ) ; }
protected List < ITEM_TYPE > selectFoldTestItems ( List < ITEM_TYPE > items , int nFolds , int fold ) { List < ITEM_TYPE > testItems = new ArrayList < ITEM_TYPE > ( ) ; for ( int i = NUM_ ; i < items . size ( ) ; ++ i ) { if ( i % nFolds == fold ) { testItems . add ( items . get ( i ) ) ; } } return testItems ; }
private void endFormals ( ) { if ( hasFormals ) { hasFormals = BOOL_ ; buf . append ( STR_ ) ; } }
public final CharSequenceTranslator with ( final CharSequenceTranslator ... translators ) { final CharSequenceTranslator [ ] newArray = new CharSequenceTranslator [ translators . length + NUM_ ] ; newArray [ NUM_ ] = this ; System . arraycopy ( translators , NUM_ , newArray , NUM_ , translators . length ) ; return new AggregateTranslator ( newArray ) ; }
@ Override public boolean equals ( Object other ) { if ( ! ( other instanceof Sha256Hash ) ) return BOOL_ ; return Arrays . equals ( bytes , ( ( Sha256Hash ) other ) . bytes ) ; }
private void translateMatrixAfterRotate ( int axis , float trans , float prevImageSize , float imageSize , int prevViewSize , int viewSize , int drawableSize ) { if ( imageSize < viewSize ) { m [ axis ] = ( viewSize - ( drawableSize . m [ Matrix . MSCALE_X ] ) ) . NUM_ ; } else if ( trans > NUM_ ) { m [ axis ] = - ( ( imageSize - viewSize ) . NUM_ ) ; } else { float percentage = ( Math . abs ( trans ) + ( NUM_ . prevViewSize ) ) / prevImageSize ; m [ axis ] = - ( ( percentage . imageSize ) - ( viewSize . NUM_ ) ) ; } }
public Config ( SolrResourceLoader loader , String name ) throws ParserConfigurationException , IOException , SAXException { this ( loader , name , null , null ) ; }
private static HashMap < String , Field > buildFieldCache ( Class < ? > cls ) { final HashMap < String , Field > cache = new HashMap < > ( ) ; final List < Field > fields = getAllFields ( cls ) ; for ( Field fld : fields ) { String name = null ; final Reference refAnn = fld . getAnnotation ( Reference . class ) ; if ( refAnn != null ) name = selectColumnName ( refAnn , fld ) ; if ( name == null ) { final Column colAnn = fld . getAnnotation ( Column . class ) ; if ( colAnn != null ) name = selectColumnName ( colAnn , fld ) ; } if ( name == null ) continue ; cache . put ( name , fld ) ; } return cache ; }
public static long convertDuration ( final String fromUnit , final String toUnit , long value ) { TimeUnit fromTimeUnit = toTimeUnit ( fromUnit ) ; TimeUnit toTimeUnit = toTimeUnit ( toUnit ) ; if ( fromTimeUnit != null && toTimeUnit != null ) { return toTimeUnit . convert ( value , fromTimeUnit ) ; } else { throw new DSSException ( STR_ + fromUnit + STR_ + toUnit + STR_ + value + STR_ ) ; } }
public static File searchForGroovyScriptFile ( String input ) { String scriptFileName = input . trim ( ) ; File scriptFile = new File ( scriptFileName ) ; String [ ] standardExtensions = { STR_ , STR_ , STR_ , STR_ } ; int i = NUM_ ; while ( i < standardExtensions . length && ! scriptFile . exists ( ) ) { scriptFile = new File ( scriptFileName + standardExtensions [ i ] ) ; i ++ ; } if ( ! scriptFile . exists ( ) ) { scriptFile = new File ( scriptFileName ) ; } return scriptFile ; }
public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { if ( xctxt . isSecureProcessing ( ) ) throw new javax . xml . transform . TransformerException ( XPATHMessages . createXPATHMessage ( XPATHErrorResources . ER_EXTENSION_FUNCTION_CANNOT_BE_INVOKED , new Object [ ] { toString ( ) } ) ) ; XObject result ; Vector argVec = new Vector ( ) ; int nArgs = m_argVec . size ( ) ; for ( int i = NUM_ ; i < nArgs ; i ++ ) { Expression arg = ( Expression ) m_argVec . elementAt ( i ) ; XObject xobj = arg . execute ( xctxt ) ; xobj . allowDetachToRelease ( BOOL_ ) ; argVec . addElement ( xobj ) ; } ExtensionsProvider extProvider = ( ExtensionsProvider ) xctxt . getOwnerObject ( ) ; Object val = extProvider . extFunction ( this , argVec ) ; if ( null != val ) { result = XObject . create ( val , xctxt ) ; } else { result = new XNull ( ) ; } return result ; }
private Header createSecurityHeader ( ) { return new BasicHeader ( STR_ , STR_ + createAuth ( ) ) ; }
public Picture ( File file ) { try { image = ImageIO . read ( file ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( STR_ + file ) ; } if ( image == null ) { throw new RuntimeException ( STR_ + file ) ; } width = image . getWidth ( null ) ; height = image . getHeight ( null ) ; filename = file . getName ( ) ; }
static AnnotationStrategy strategyFor ( Annotation annotation ) { checkNotNull ( annotation , STR_ ) ; Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; if ( annotationType . getDeclaredMethods ( ) . length == NUM_ ) { return new AnnotationTypeStrategy ( annotationType , annotation ) ; } return new AnnotationInstanceStrategy ( annotation ) ; }
public static String encode ( byte [ ] input ) { if ( input . length == NUM_ ) { return STR_ ; } int zeros = NUM_ ; while ( zeros < input . length && input [ zeros ] == NUM_ ) { ++ zeros ; } input = Arrays . copyOf ( input , input . length ) ; char [ ] encoded = new char [ input . length . NUM_ ] ; int outputStart = encoded . length ; for ( int inputStart = zeros ; inputStart < input . length ; ) { encoded [ -- outputStart ] = ALPHABET [ divmod ( input , inputStart , NUM_ , NUM_ ) ] ; if ( input [ inputStart ] == NUM_ ) { ++ inputStart ; } } while ( outputStart < encoded . length && encoded [ outputStart ] == ENCODED_ZERO ) { ++ outputStart ; } while ( -- zeros >= NUM_ ) { encoded [ -- outputStart ] = ENCODED_ZERO ; } return new String ( encoded , outputStart , encoded . length - outputStart ) ; }
private void addVolumeToBlockConsistencyGroup ( URI cgUri , Volume volume ) { volume . addConsistencyGroup ( cgUri . toString ( ) ) ; _dbClient . persistObject ( volume ) ; }
public static boolean lazyGaussianElimination ( final int var2Eq [ ] [ ] , final long [ ] c , final int [ ] variable , final long [ ] solution ) { return lazyGaussianElimination ( null , var2Eq , c , variable , solution ) ; }
private static int analyze ( Compiler compiler , int stepOpCodePos , int stepIndex ) throws javax . xml . transform . TransformerException { int stepType ; int stepCount = NUM_ ; int analysisResult = x00000000 ; while ( OpCodes . ENDOP != ( stepType = compiler . getOp ( stepOpCodePos ) ) ) { stepCount ++ ; boolean predAnalysis = analyzePredicate ( compiler , stepOpCodePos , stepType ) ; if ( predAnalysis ) analysisResult |= BIT_PREDICATE ; switch ( stepType ) { case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : analysisResult |= BIT_FILTER ; break ; case OpCodes . FROM_ROOT : analysisResult |= BIT_ROOT ; break ; case OpCodes . FROM_ANCESTORS : analysisResult |= BIT_ANCESTOR ; break ; case OpCodes . FROM_ANCESTORS_OR_SELF : analysisResult |= BIT_ANCESTOR_OR_SELF ; break ; case OpCodes . FROM_ATTRIBUTES : analysisResult |= BIT_ATTRIBUTE ; break ; case OpCodes . FROM_NAMESPACE : analysisResult |= BIT_NAMESPACE ; break ; case OpCodes . FROM_CHILDREN : analysisResult |= BIT_CHILD ; break ; case OpCodes . FROM_DESCENDANTS : analysisResult |= BIT_DESCENDANT ; break ; case OpCodes . FROM_DESCENDANTS_OR_SELF : if ( NUM_ == stepCount && BIT_ROOT == analysisResult ) { analysisResult |= BIT_ANY_DESCENDANT_FROM_ROOT ; } analysisResult |= BIT_DESCENDANT_OR_SELF ; break ; case OpCodes . FROM_FOLLOWING : analysisResult |= BIT_FOLLOWING ; break ; case OpCodes . FROM_FOLLOWING_SIBLINGS : analysisResult |= BIT_FOLLOWING_SIBLING ; break ; case OpCodes . FROM_PRECEDING : analysisResult |= BIT_PRECEDING ; break ; case OpCodes . FROM_PRECEDING_SIBLINGS : analysisResult |= BIT_PRECEDING_SIBLING ; break ; case OpCodes . FROM_PARENT : analysisResult |= BIT_PARENT ; break ; case OpCodes . FROM_SELF : analysisResult |= BIT_SELF ; break ; case OpCodes . MATCH_ATTRIBUTE : analysisResult |= ( BIT_MATCH_PATTERN | BIT_ATTRIBUTE ) ; break ; case OpCodes . MATCH_ANY_ANCESTOR : analysisResult |= ( BIT_MATCH_PATTERN | BIT_ANCESTOR ) ; break ; case OpCodes . MATCH_IMMEDIATE_ANCESTOR : analysisResult |= ( BIT_MATCH_PATTERN | BIT_PARENT ) ; break ; default : throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NULL_ERROR_HANDLER , new Object [ ] { Integer . toString ( stepType ) } ) ) ; } if ( OpCodes . NODETYPE_NODE == compiler . getOp ( stepOpCodePos + NUM_ ) ) { analysisResult |= BIT_NODETEST_ANY ; } stepOpCodePos = compiler . getNextStepPos ( stepOpCodePos ) ; if ( stepOpCodePos < NUM_ ) break ; } analysisResult |= ( stepCount & BITS_COUNT ) ; return analysisResult ; }
public void compressMyOwnWay ( int [ ] indexes ) { List < Integer > list = new ArrayList < Integer > ( CarbonCommonConstants . CONSTANT_SIZE_TEN ) ; List < Integer > map = new ArrayList < Integer > ( CarbonCommonConstants . CONSTANT_SIZE_TEN ) ; int k = NUM_ ; int i = NUM_ ; for ( ; i < indexes . length ; i ++ ) { if ( indexes [ i ] - indexes [ i - NUM_ ] == NUM_ ) { k ++ ; } else { if ( k > NUM_ ) { map . add ( ( list . size ( ) ) ) ; list . add ( indexes [ i - k - NUM_ ] ) ; list . add ( indexes [ i - NUM_ ] ) ; } else { list . add ( indexes [ i - NUM_ ] ) ; } k = NUM_ ; } } if ( k > NUM_ ) { map . add ( ( list . size ( ) ) ) ; list . add ( indexes [ i - k - NUM_ ] ) ; list . add ( indexes [ i - NUM_ ] ) ; } else { list . add ( indexes [ i - NUM_ ] ) ; } dataAfterComp = convertToArray ( list ) ; if ( indexes . length == dataAfterComp . length ) { indexMap = new int [ NUM_ ] ; } else { indexMap = convertToArray ( map ) ; } if ( dataAfterComp . length == NUM_ && indexMap . length == NUM_ ) { alreadySorted = BOOL_ ; } }
private void prependDecrement ( BasicBlock bb , IR ir ) { if ( DEBUG ) VM . sysWrite ( STR_ + bb + STR_ ) ; RegisterOperand use = cbsReg . copyRO ( ) ; RegisterOperand def = use . copyU2D ( ) ; Instruction inc = Binary . create ( INT_ADD , def , use , IRTools . IC ( - NUM_ ) ) ; bb . prependInstruction ( inc ) ; }
public void addListener ( ConnectableDeviceListener listener ) { if ( ! listeners . contains ( listener ) ) { listeners . add ( listener ) ; } }
private static final String toHexString ( final byte [ ] bs ) { String hex = STR_ ; StringBuilder res = new StringBuilder ( ) ; for ( byte b : bs ) { res . append ( hex . charAt ( ( ( b > > > NUM_ ) & xF ) ) ) ; res . append ( hex . charAt ( ( b & xF ) ) ) ; } return res . toString ( ) ; }
public synchronized void flush ( ) throws IOException { checkNotClosed ( ) ; trimToSize ( ) ; journalWriter . flush ( ) ; }
public double distance_to_the_left ( PlaLineInt p_line ) { double result = Integer . MAX_VALUE ; for ( int index = NUM_ ; index < border_line_count ( ) ; ++ index ) { PlaPointFloat curr_corner = corner_approx ( index ) ; PlaSide line_side = p_line . side_of ( curr_corner , NUM_ ) ; if ( line_side == PlaSide . COLLINEAR ) { line_side = p_line . side_of ( corner ( index ) ) ; } if ( line_side == PlaSide . ON_THE_RIGHT ) return - NUM_ ; result = Math . min ( result , p_line . distance_signed ( curr_corner ) ) ; } return result ; }
private static byte [ ] readClass ( final InputStream is , boolean close ) throws IOException { if ( is == null ) { throw new IOException ( STR_ ) ; } try { byte [ ] b = new byte [ is . available ( ) ] ; int len = NUM_ ; while ( BOOL_ ) { int n = is . read ( b , len , b . length - len ) ; if ( n == - NUM_ ) { if ( len < b . length ) { byte [ ] c = new byte [ len ] ; System . arraycopy ( b , NUM_ , c , NUM_ , len ) ; b = c ; } return b ; } len += n ; if ( len == b . length ) { int last = is . read ( ) ; if ( last < NUM_ ) { return b ; } byte [ ] c = new byte [ b . length + NUM_ ] ; System . arraycopy ( b , NUM_ , c , NUM_ , len ) ; c [ len ++ ] = ( byte ) last ; b = c ; } } } finally { if ( close ) { is . close ( ) ; } } }
public boolean displayTopicFromNames ( String [ ] names ) { if ( names . length == NUM_ ) return displayTopic ( DEFAULT ) ; else { StringBuffer helpName = new StringBuffer ( ) ; for ( String name : names ) { if ( helpName . length ( ) > NUM_ ) helpName . append ( STR_ ) ; helpName . append ( name ) ; } return displayTopic ( helpName . toString ( ) ) ; } }
public boolean acceptIdentical ( String filePath , String fileName ) { if ( fileNameGlob == null ) return BOOL_ ; if ( fileName != null && fileName . equalsIgnoreCase ( fileNameGlob ) ) return BOOL_ ; if ( filePath != null ) { int lastUnixPos = filePath . lastIndexOf ( STR_ ) ; int lastWindowsPos = filePath . lastIndexOf ( STR_ ) ; int index = Math . max ( lastUnixPos , lastWindowsPos ) ; String filename = filePath . substring ( index + NUM_ ) ; return filename != null && filename . equalsIgnoreCase ( fileNameGlob ) ; } return BOOL_ ; }
private void validateNumCoresBlockSort ( ) { String numCoresStr = carbonProperties . getProperty ( CarbonCommonConstants . NUM_CORES_BLOCK_SORT , CarbonCommonConstants . NUM_CORES_BLOCK_SORT_DEFAULT_VAL ) ; try { int numCores = Integer . parseInt ( numCoresStr ) ; if ( numCores < CarbonCommonConstants . NUM_CORES_BLOCK_SORT_MIN_VAL || numCores > CarbonCommonConstants . NUM_CORES_BLOCK_SORT_MAX_VAL ) { LOGGER . info ( STR_ + numCoresStr + STR_ + CarbonCommonConstants . NUM_CORES_BLOCK_SORT_DEFAULT_VAL ) ; carbonProperties . setProperty ( CarbonCommonConstants . NUM_CORES_BLOCK_SORT , CarbonCommonConstants . NUM_CORES_BLOCK_SORT_DEFAULT_VAL ) ; } } catch ( NumberFormatException e ) { LOGGER . info ( STR_ + numCoresStr + STR_ + CarbonCommonConstants . NUM_CORES_BLOCK_SORT_DEFAULT_VAL ) ; carbonProperties . setProperty ( CarbonCommonConstants . NUM_CORES_BLOCK_SORT , CarbonCommonConstants . NUM_CORES_BLOCK_SORT_DEFAULT_VAL ) ; } }
public static MemoryMatchFragment newInstance ( ) { return new MemoryMatchFragment ( ) ; }
static void createFileFromResource ( String resource , Resource file ) throws IOException { createFileFromResource ( resource , file , null ) ; }
public int endObject ( ) { if ( vtable == null || ! nested ) throw new AssertionError ( STR_ ) ; addInt ( NUM_ ) ; int vtableloc = offset ( ) ; for ( int i = vtable_in_use - NUM_ ; i >= NUM_ ; i -- ) { short off = ( short ) ( vtable [ i ] != NUM_ ? vtableloc - vtable [ i ] : NUM_ ) ; addShort ( off ) ; } final int standard_fields = NUM_ ; addShort ( ( short ) ( vtableloc - object_start ) ) ; addShort ( ( short ) ( ( vtable_in_use + standard_fields ) . SIZEOF_SHORT ) ) ; int existing_vtable = NUM_ ; outer_loop : for ( int i = NUM_ ; i < num_vtables ; i ++ ) { int vt1 = bb . capacity ( ) - vtables [ i ] ; int vt2 = space ; short len = bb . getShort ( vt1 ) ; if ( len == bb . getShort ( vt2 ) ) { for ( int j = SIZEOF_SHORT ; j < len ; j += SIZEOF_SHORT ) { if ( bb . getShort ( vt1 + j ) != bb . getShort ( vt2 + j ) ) { continue outer_loop ; } } existing_vtable = vtables [ i ] ; break outer_loop ; } } if ( existing_vtable != NUM_ ) { space = bb . capacity ( ) - vtableloc ; bb . putInt ( space , existing_vtable - vtableloc ) ; } else { if ( num_vtables == vtables . length ) vtables = Arrays . copyOf ( vtables , num_vtables . NUM_ ) ; vtables [ num_vtables ++ ] = offset ( ) ; bb . putInt ( bb . capacity ( ) - vtableloc , offset ( ) - vtableloc ) ; } nested = BOOL_ ; return vtableloc ; }
private void endList ( boolean orderedList ) { if ( ! mParagraphStyles . isEmpty ( ) ) { AccumulatedParagraphStyle style = mParagraphStyles . peek ( ) ; ParagraphType type = style . getType ( ) ; if ( ( orderedList && ( type . isNumbering ( ) || type == ParagraphType . INDENTATION_OL ) ) || ( ! orderedList && ( type . isBullet ( ) || type == ParagraphType . INDENTATION_UL ) ) ) { int indent = style . getRelativeIndent ( ) ; if ( indent > NUM_ ) { style . setRelativeIndent ( indent - NUM_ ) ; style . setAbsoluteIndent ( style . getAbsoluteIndent ( ) - NUM_ ) ; } else { mParagraphStyles . pop ( ) ; } } else { mParagraphStyles . pop ( ) ; endList ( orderedList ) ; } } }
protected double compute ( String value ) { if ( value != null ) { try { return Double . parseDouble ( value ) ; } catch ( NumberFormatException e ) { if ( POSITIVE_INFINITY_STRING . equals ( value ) ) { return Double . POSITIVE_INFINITY ; } else if ( NEGATIVE_INFINITY_STRING . equals ( value ) ) { return Double . NEGATIVE_INFINITY ; } return Double . NaN ; } } return Double . NaN ; }
protected int readBlock ( ) { blockSize = read ( ) ; int n = NUM_ ; if ( blockSize > NUM_ ) { try { int count = NUM_ ; while ( n < blockSize ) { count = in . read ( block , n , blockSize - n ) ; if ( count == - NUM_ ) break ; n += count ; } } catch ( IOException e ) { } if ( n < blockSize ) { status = STATUS_FORMAT_ERROR ; } } return n ; }
boolean isDuplicateRoleColumn ( int column ) { return duplicateRoleColumn . contains ( column ) ; }
public TimestampSpeechletRequestVerifier ( long tolerance , TimeUnit unit ) { if ( tolerance < NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } toleranceInMilliseconds = unit . toMillis ( tolerance ) ; }
private boolean isOutsideDocElem ( ) { return ( null == m_docFrag ) && m_elemStack . size ( ) == NUM_ && ( null == m_currentNode || m_currentNode . getNodeType ( ) == Node . DOCUMENT_NODE ) ; }
public void shutdown ( ) { CountDownLatch wait_l ; synchronized ( this ) { wait_l = waitShutdown ; } Shutdown_ind = BOOL_ ; try { if ( wait_l != null ) { if ( wait_l . await ( NUM_ , TimeUnit . MILLISECONDS ) ) LOG . info ( STR_ ) ; else LOG . warn ( STR_ ) ; } else { LOG . info ( STR_ ) ; } } catch ( InterruptedException int_exc ) { LOG . warn ( STR_ ) ; } }
void paintStrokes ( Rectangle r , Graphics g , int axis , int [ ] lengthPattern , Color [ ] colorPattern ) { boolean xAxis = ( axis == View . X_AXIS ) ; int start = NUM_ ; int end = ( xAxis ? r . width : r . height ) ; while ( start < end ) { for ( int i = NUM_ ; i < lengthPattern . length ; i ++ ) { if ( start >= end ) { break ; } int length = lengthPattern [ i ] ; Color c = colorPattern [ i ] ; if ( c != null ) { int x = r . x + ( xAxis ? start : NUM_ ) ; int y = r . y + ( xAxis ? NUM_ : start ) ; int width = xAxis ? length : r . width ; int height = xAxis ? r . height : length ; g . setColor ( c ) ; g . fillRect ( x , y , width , height ) ; } start += length ; } } }
private void deleteChildren ( Element container ) { while ( container . hasChildNodes ( ) ) { container . removeChild ( container . getLastChild ( ) ) ; } }
public String fillParamWithEventAttrib ( String paramData , Event event ) { if ( ! database . isOpen ( ) ) { throw new IllegalStateException ( TAG + STR_ ) ; } StringBuilder retVal = new StringBuilder ( ) ; int cursor = NUM_ ; while ( cursor < paramData . length ( ) ) { int openBracketIdx = paramData . indexOf ( STR_ , cursor ) ; int closeBracketIdx = paramData . indexOf ( STR_ , cursor ) ; if ( openBracketIdx == - NUM_ || closeBracketIdx == - NUM_ || openBracketIdx + NUM_ >= closeBracketIdx ) { retVal . append ( paramData . substring ( cursor ) ) ; break ; } String attr = paramData . substring ( openBracketIdx + NUM_ , closeBracketIdx ) ; String param = paramData . substring ( openBracketIdx , closeBracketIdx + NUM_ ) ; String paramAttr ; try { paramAttr = event . getAttribute ( attr ) ; } catch ( IllegalArgumentException e ) { paramAttr = param ; } retVal . append ( paramData . substring ( cursor , openBracketIdx ) ) ; retVal . append ( paramAttr ) ; cursor = closeBracketIdx + NUM_ ; } Log . d ( STR_ , paramData + STR_ + retVal . toString ( ) ) ; return retVal . toString ( ) ; }
public static double twoPow ( int power ) { if ( power <= - MAX_DOUBLE_EXPONENT ) { if ( power >= MIN_DOUBLE_EXPONENT ) { return Double . longBitsToDouble ( x0008000000000000L > > ( - ( power + MAX_DOUBLE_EXPONENT ) ) ) ; } else { return NUM_ ; } } else if ( power > MAX_DOUBLE_EXPONENT ) { return Double . POSITIVE_INFINITY ; } else { return Double . longBitsToDouble ( ( ( long ) ( power + MAX_DOUBLE_EXPONENT ) ) << NUM_ ) ; } }
@ SuppressWarnings ( STR_ ) public static Type resolveTypeVariable ( TypeVariable name , Class declaringClass , Class topClass ) { Type type = resolveTypeVariable ( name , declaringClass , new HashMap < > ( ) , topClass ) ; if ( type == null ) { type = Object . class ; } return type ; }
private ResourceImpl aggregate ( ResourceImpl resourceA , ResourceImpl resourceB ) throws NotFoundException { final String typeId = resourceA . getType ( ) ; final ResourceType resourceType = getResourceType ( typeId ) ; return resourceType . aggregate ( resourceA , resourceB ) ; }
public static boolean renameFile ( String filePath , String oldFilename , String newFilename ) { if ( ( filePath == null ) || filePath . isEmpty ( ) || ( oldFilename == null ) || oldFilename . isEmpty ( ) || ( newFilename == null ) || newFilename . isEmpty ( ) ) { return BOOL_ ; } File oldFile = new File ( filePath + File . separator + oldFilename ) ; File newFile = new File ( filePath + File . separator + newFilename ) ; boolean isSuccessfulRename ; try { isSuccessfulRename = oldFile . renameTo ( newFile ) ; } catch ( Exception e ) { logger . debug ( e . toString ( ) + System . lineSeparator ( ) + StackTrace . getStringFromStackTrace ( e ) ) ; isSuccessfulRename = BOOL_ ; } return isSuccessfulRename ; }
@ RpcMethod public void startImageScan ( String dataStore , Long scanRate , Long timeout , AsyncMethodCallback < Host . AsyncClient . start_image_scan_call > handler ) throws RpcException { ensureClient ( ) ; StartImageScanRequest request = new StartImageScanRequest ( dataStore ) ; if ( null != scanRate ) { request . setScan_rate ( scanRate ) ; } if ( null != timeout ) { request . setTimeout ( timeout ) ; } try { logger . info ( STR_ , getHostIp ( ) , request ) ; clientProxy . setTimeout ( START_IMAGE_SCAN_TIMEOUT_MS ) ; clientProxy . start_image_scan ( request , handler ) ; } catch ( TException e ) { throw new RpcException ( e . getMessage ( ) ) ; } }
public static String format ( int n , String col ) { String res = padd + n ; return res . substring ( res . length ( ) - col . length ( ) ) ; }
public GitConflictException ( String message ) { super ( message ) ; }
private void trace ( ) { glUseProgram ( photonTraceProgram ) ; long thisTime = System . nanoTime ( ) ; float elapsedSeconds = ( thisTime - firstTime ) / NUM_ ; glUniform1f ( timeUniform , elapsedSeconds ) ; glBindBufferBase ( GL_SHADER_STORAGE_BUFFER , boxesSsboBinding , ssbo ) ; glBindBufferBase ( GL_UNIFORM_BUFFER , imagesUboBinding , imageHandlesUbo ) ; int invocationsPerDimension = photonsPerFrame ; int worksizeX = mathRoundPoT ( invocationsPerDimension ) ; int worksizeY = mathRoundPoT ( invocationsPerDimension ) ; if ( variableGroupSize ) { ARBComputeVariableGroupSize . glDispatchComputeGroupSizeARB ( worksizeX / workGroupSizeX , worksizeY / workGroupSizeY , NUM_ , workGroupSizeX , workGroupSizeY , NUM_ ) ; } else { glDispatchCompute ( worksizeX / workGroupSizeX , worksizeY / workGroupSizeY , NUM_ ) ; } glMemoryBarrier ( GL_SHADER_IMAGE_ACCESS_BARRIER_BIT ) ; glBindBufferBase ( GL_SHADER_STORAGE_BUFFER , boxesSsboBinding , NUM_ ) ; glBindBufferBase ( GL_UNIFORM_BUFFER , imagesUboBinding , NUM_ ) ; glUseProgram ( NUM_ ) ; }
public caption addElement ( String element ) { addElementToRegistry ( Integer . toString ( element . hashCode ( ) ) , element ) ; return ( this ) ; }
protected void doResetCurrentPosition ( ) { this . currentPosition = this . position ; }
public FloatBuffer put ( float [ ] src , int srcOffset , int floatCount ) { JTranscArrays . checkOffsetAndCount ( src . length , srcOffset , floatCount ) ; if ( floatCount > remaining ( ) ) { throw new BufferOverflowException ( ) ; } for ( int i = srcOffset ; i < srcOffset + floatCount ; ++ i ) { put ( src [ i ] ) ; } return this ; }
public String readLine ( ) { String line ; try { line = scanner . nextLine ( ) ; } catch ( NoSuchElementException e ) { line = null ; } return line ; }
private boolean messageChanged ( String oldMessage , String newMessage ) { return ( ( newMessage == null ) && ( oldMessage != null ) ) || ( ( newMessage != null ) && ! newMessage . equals ( oldMessage ) ) ; }
public static int copy ( InputStream in , OutputStream out ) throws IOException { Assert . notNull ( in , STR_ ) ; Assert . notNull ( out , STR_ ) ; try { return StreamUtils . copy ( in , out ) ; } finally { try { in . close ( ) ; } catch ( IOException ex ) { } try { out . close ( ) ; } catch ( IOException ex ) { } } }
private MultiLineString readMultiLine ( OraGeom oraGeom ) { int nElem = oraGeom . numElements ( ) ; List geoms = new ArrayList ( ) ; for ( int i = NUM_ ; i < nElem ; i ++ ) { int etype = oraGeom . eType ( i ) ; if ( etype != OraGeom . ETYPE . LINE ) break ; geoms . add ( readLine ( oraGeom , i ) ) ; } MultiLineString lines = geometryFactory . createMultiLineString ( GeometryFactory . toLineStringArray ( geoms ) ) ; return lines ; }
public boolean isCalledMethod ( String className , String methodName ) { if ( toTestMethods . isEmpty ( ) ) computeInterestingClasses ( graph ) ; if ( toTestMethods . contains ( className + methodName ) ) { return BOOL_ ; } return BOOL_ ; }
public Explanation idfExplain ( CollectionStatistics collectionStats , TermStatistics termStats [ ] ) { final long docCount = collectionStats . docCount ( ) == - NUM_ ? collectionStats . maxDoc ( ) : collectionStats . docCount ( ) ; float idf = NUM_ ; List < Explanation > details = new ArrayList < > ( ) ; for ( final TermStatistics stat : termStats ) { final long df = stat . docFreq ( ) ; final float termIdf = idf ( df , docCount ) ; details . add ( Explanation . match ( termIdf , STR_ + df + STR_ + docCount + STR_ ) ) ; idf += termIdf ; } return Explanation . match ( idf , STR_ , details ) ; }
public void removeArea ( final Section AREA ) { if ( null == AREA ) return ; areas . remove ( AREA ) ; Collections . sort ( areas , new SectionComparator ( ) ) ; fireUpdateEvent ( SECTION_EVENT ) ; }
public void testEmptyRunIndex ( ) { String rs = STR_ ; Settings s = new Settings ( STR_ ) ; s . setSecondaryNamespace ( STR_ ) ; assertEquals ( s . getInt ( rs ) , NUM_ ) ; Settings . setRunIndex ( NUM_ ) ; assertEquals ( s . getInt ( rs ) , NUM_ ) ; Settings . setRunIndex ( NUM_ ) ; assertEquals ( s . getInt ( rs ) , NUM_ ) ; Settings . setRunIndex ( NUM_ ) ; assertEquals ( s . getInt ( rs ) , NUM_ ) ; }
public void clear ( ) { synchronized ( mLock ) { mGraphics . clear ( ) ; } postInvalidate ( ) ; }
@ SuppressWarnings ( STR_ ) public void connect ( final BluetoothDevice device , final ILogSession session ) { if ( mManagedDevices . contains ( device ) ) return ; mManagedDevices . add ( device ) ; BleManager < BleManagerCallbacks > manager = mBleManagers . get ( device ) ; if ( manager != null ) { if ( session != null ) manager . setLogger ( session ) ; manager . connect ( device ) ; } else { mBleManagers . put ( device , manager = initializeManager ( ) ) ; manager . setGattCallbacks ( BleMulticonnectProfileService . this ) ; manager . setLogger ( session ) ; manager . connect ( device ) ; } }
public void testCase19 ( ) { byte aBytes [ ] = { - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; byte bBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int bSign = - NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . remainder ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
public ScannerException ( ErrorMessages message ) { this ( null , ErrorMessages . get ( message ) , message , - NUM_ , - NUM_ ) ; }
public boolean isNavigationAtBottom ( ) { return ( mSmallestWidthDp >= NUM_ || mInPortrait ) ; }
private int clampMag ( int value , int absMin , int absMax ) { final int absValue = Math . abs ( value ) ; if ( absValue < absMin ) return NUM_ ; if ( absValue > absMax ) return value > NUM_ ? absMax : - absMax ; return value ; }
private E unlinkLast ( ) { Node < E > l = last ; if ( l == null ) return null ; Node < E > p = l . prev ; E item = l . item ; l . item = null ; l . prev = l ; last = p ; if ( p == null ) first = null ; else p . next = null ; -- count ; notFull . signal ( ) ; return item ; }
public MutableString ( final MutableString s ) { makeCompactMutableString ( s . length ( ) ) ; System . arraycopy ( s . array , NUM_ , array , NUM_ , array . length ) ; }
private void request ( ) { if ( isVisible ( ) && stream != null && ! stream . isEmpty ( ) ) { loading = BOOL_ ; if ( type == Type . FOLLOWERS ) { api . getFollowers ( stream ) ; } else if ( type == Type . SUBSCRIBERS ) { api . getSubscribers ( stream ) ; } } }
public List < Statement > mungedStyle ( ) { List < Statement > st = built ( ) ; if ( includeBasicEntityForSubject ) { st . remove ( entityDataAboutDecl ) ; st . remove ( entityDataVersionDecl ) ; st . remove ( entityDataDateModifiedDecl ) ; statement ( st , uris . entity ( ) + entity , SchemaDotOrg . VERSION , version ) ; statement ( st , uris . entity ( ) + entity , SchemaDotOrg . DATE_MODIFIED , dateModified ) ; } st . remove ( statementTypeDecl ) ; for ( ExtraInfo e : extraInfo ) { e . munge ( st ) ; } return st ; }
private void writeRequest ( final NextFilter nextFilter , final SocksProxyRequest request , int step ) { try { IoBuffer buf = null ; if ( step == SocksProxyConstants . SOCKS5_GREETING_STEP ) { buf = encodeInitialGreetingPacket ( request ) ; } else if ( step == SocksProxyConstants . SOCKS5_AUTH_STEP ) { buf = encodeAuthenticationPacket ( request ) ; if ( buf == null ) { step = SocksProxyConstants . SOCKS5_REQUEST_STEP ; } } if ( step == SocksProxyConstants . SOCKS5_REQUEST_STEP ) { buf = encodeProxyRequestPacket ( request ) ; } buf . flip ( ) ; writeData ( nextFilter , buf ) ; } catch ( Exception ex ) { closeSession ( STR_ , ex ) ; } }
public synchronized void putAsInt ( Object key , int value ) { put ( key , new Integer ( value ) ) ; }
public void close ( ) throws IOException { if ( writer != null ) { writer . close ( ) ; } else { cb = null ; closed = BOOL_ ; } }
private CertPath buildCertPath ( X509Certificate endCert ) throws CertificatePathBuildingException { CertPathBuilder cpb = null ; try { cpb = CertPathBuilder . getInstance ( STR_ ) ; } catch ( NoSuchAlgorithmException e ) { throw new CertificatePathBuildingException ( STR_ + e . getMessage ( ) , e ) ; } PKIXBuilderParameters params = CreatePKIXBuilderParameters ( endCert ) ; CertPathBuilderResult cpbResult ; try { cpbResult = cpb . build ( params ) ; } catch ( CertPathBuilderException e ) { throw new CertificatePathBuildingException ( e . getMessage ( ) , e . getCause ( ) ) ; } catch ( InvalidAlgorithmParameterException e ) { throw new CertificatePathBuildingException ( e . getMessage ( ) , e ) ; } CertPath cp = cpbResult . getCertPath ( ) ; return cp ; }
public void addConfiguration ( InputStream in ) throws SMSException , SSOException { ServiceManager sm = new ServiceManager ( token ) ; Document doc = SMSSchema . getXMLDocument ( in ) ; NodeList nodes = doc . getElementsByTagName ( SMSUtils . SERVICE ) ; for ( int i = NUM_ ; ( nodes != null ) && ( i < nodes . getLength ( ) ) ; i ++ ) { Node serviceNode = nodes . item ( i ) ; String sName = XMLUtils . getNodeAttributeValue ( serviceNode , SMSUtils . NAME ) ; String sVersion = XMLUtils . getNodeAttributeValue ( serviceNode , SMSUtils . VERSION ) ; Node configNode ; if ( sName . equals ( serviceName ) && ( sVersion . equals ( version ) ) && ( ( configNode = XMLUtils . getChildNode ( serviceNode , SMSUtils . CONFIGURATION ) ) != null ) ) { CreateServiceConfig . createService ( sm , sName , sVersion , configNode , null ) ; } } }
public static int stringToDictId ( String str ) { try { byte [ ] bytes = str . getBytes ( STR_ ) ; return BytesUtil . readUnsigned ( bytes , NUM_ , bytes . length ) ; } catch ( UnsupportedEncodingException e ) { return NUM_ ; } }
public void start ( ) throws IOException , MqttException { final String methodName = STR_ ; try { log . fine ( CLASS_NAME , methodName , STR_ , new Object [ ] { host , new Integer ( port ) , new Long ( conTimeout . NUM_ ) } ) ; SocketAddress sockaddr = new InetSocketAddress ( host , port ) ; socket = factory . createSocket ( ) ; socket . connect ( sockaddr , conTimeout . NUM_ ) ; } catch ( ConnectException ex ) { log . fine ( CLASS_NAME , methodName , STR_ , null , ex ) ; throw new MqttException ( MqttException . REASON_CODE_SERVER_CONNECT_ERROR , ex ) ; } }
public void callSeriallyAndWait ( Runnable r ) { if ( isEdt ( ) ) { throw new RuntimeException ( STR_ ) ; } RunnableWrapper c = new RunnableWrapper ( r , NUM_ ) ; callSerially ( c ) ; flushEdt ( ) ; synchronized ( lock ) { while ( ! c . isDone ( ) ) { try { lock . wait ( NUM_ ) ; } catch ( InterruptedException err ) { } } } }
public List < Contact > find ( ) { List < Long > ids = new ArrayList < > ( ) ; if ( innerQueries != null ) { for ( Query query : innerQueries ) { ids . addAll ( query . findInner ( ) ) ; } } else { if ( mimeWhere . isEmpty ( ) ) { return find ( null ) ; } for ( Map . Entry < String , Where > entry : mimeWhere . entrySet ( ) ) { ids = findIds ( ids , entry . getKey ( ) , entry . getValue ( ) ) ; } } return find ( ids ) ; }
public void persistBeanData ( Object bean , boolean printOnly ) { persistBeanTryCatch ( bean ) ; callPersistEmittedKeyValue ( printOnly ) ; }
private void refill ( ) throws IOException { offset += usableLength ; int leftover = length - usableLength ; System . arraycopy ( buffer , usableLength , buffer , NUM_ , leftover ) ; int requested = buffer . length - leftover ; int returned = read ( input , buffer , leftover , requested ) ; length = returned < NUM_ ? leftover : returned + leftover ; if ( returned < requested ) usableLength = length ; else { usableLength = findSafeEnd ( ) ; if ( usableLength < NUM_ ) usableLength = length ; } wrapper . setText ( buffer , NUM_ , Math . max ( NUM_ , usableLength ) ) ; iterator . setText ( wrapper ) ; }
protected void fireInsertUpdate ( DocumentEvent evt ) { if ( tokenMarker != null ) { DocumentEvent . ElementChange ch = evt . getChange ( getDefaultRootElement ( ) ) ; if ( ch != null ) { tokenMarker . insertLines ( ch . getIndex ( ) + NUM_ , ch . getChildrenAdded ( ) . length - ch . getChildrenRemoved ( ) . length ) ; } } super . fireInsertUpdate ( evt ) ; }
final void push ( final Object object ) { stack . add ( object ) ; }
int pending ( ) { return pending . get ( ) ; }
private boolean isIncluded ( final HttpServletRequest request ) { String uri = ( String ) request . getAttribute ( STR_ ) ; boolean includeRequest = ! ( uri == null ) ; if ( includeRequest && log . isDebugEnabled ( ) ) { log . debug ( STR_ + STR_ , request . getRequestURL ( ) ) ; } return includeRequest ; }
public void drawDomainMarker ( Graphics2D g2 , ContourPlot plot , ValueAxis domainAxis , Marker marker , Rectangle2D dataArea ) { if ( marker instanceof ValueMarker ) { ValueMarker vm = ( ValueMarker ) marker ; double value = vm . getValue ( ) ; Range range = domainAxis . getRange ( ) ; if ( ! range . contains ( value ) ) { return ; } double x = domainAxis . valueToJava2D ( value , dataArea , RectangleEdge . BOTTOM ) ; Line2D line = new Line2D . Double ( x , dataArea . getMinY ( ) , x , dataArea . getMaxY ( ) ) ; Paint paint = marker . getOutlinePaint ( ) ; Stroke stroke = marker . getOutlineStroke ( ) ; g2 . setPaint ( paint != null ? paint : Plot . DEFAULT_OUTLINE_PAINT ) ; g2 . setStroke ( stroke != null ? stroke : Plot . DEFAULT_OUTLINE_STROKE ) ; g2 . draw ( line ) ; } }
private static int encodeText ( CharSequence msg , int startpos , int count , StringBuilder sb , int initialSubmode ) { StringBuilder tmp = new StringBuilder ( count ) ; int submode = initialSubmode ; int idx = NUM_ ; while ( BOOL_ ) { char ch = msg . charAt ( startpos + idx ) ; switch ( submode ) { case SUBMODE_ALPHA : if ( isAlphaUpper ( ch ) ) { if ( ch == STR_ ) { tmp . append ( ( char ) NUM_ ) ; } else { tmp . append ( ( char ) ( ch - NUM_ ) ) ; } } else { if ( isAlphaLower ( ch ) ) { submode = SUBMODE_LOWER ; tmp . append ( ( char ) NUM_ ) ; continue ; } else if ( isMixed ( ch ) ) { submode = SUBMODE_MIXED ; tmp . append ( ( char ) NUM_ ) ; continue ; } else { tmp . append ( ( char ) NUM_ ) ; tmp . append ( ( char ) PUNCTUATION [ ch ] ) ; break ; } } break ; case SUBMODE_LOWER : if ( isAlphaLower ( ch ) ) { if ( ch == STR_ ) { tmp . append ( ( char ) NUM_ ) ; } else { tmp . append ( ( char ) ( ch - NUM_ ) ) ; } } else { if ( isAlphaUpper ( ch ) ) { tmp . append ( ( char ) NUM_ ) ; tmp . append ( ( char ) ( ch - NUM_ ) ) ; break ; } else if ( isMixed ( ch ) ) { submode = SUBMODE_MIXED ; tmp . append ( ( char ) NUM_ ) ; continue ; } else { tmp . append ( ( char ) NUM_ ) ; tmp . append ( ( char ) PUNCTUATION [ ch ] ) ; break ; } } break ; case SUBMODE_MIXED : if ( isMixed ( ch ) ) { tmp . append ( ( char ) MIXED [ ch ] ) ; } else { if ( isAlphaUpper ( ch ) ) { submode = SUBMODE_ALPHA ; tmp . append ( ( char ) NUM_ ) ; continue ; } else if ( isAlphaLower ( ch ) ) { submode = SUBMODE_LOWER ; tmp . append ( ( char ) NUM_ ) ; continue ; } else { if ( startpos + idx + NUM_ < count ) { char next = msg . charAt ( startpos + idx + NUM_ ) ; if ( isPunctuation ( next ) ) { submode = SUBMODE_PUNCTUATION ; tmp . append ( ( char ) NUM_ ) ; continue ; } } tmp . append ( ( char ) NUM_ ) ; tmp . append ( ( char ) PUNCTUATION [ ch ] ) ; } } break ; default : if ( isPunctuation ( ch ) ) { tmp . append ( ( char ) PUNCTUATION [ ch ] ) ; } else { submode = SUBMODE_ALPHA ; tmp . append ( ( char ) NUM_ ) ; continue ; } } idx ++ ; if ( idx >= count ) { break ; } } char h = NUM_ ; int len = tmp . length ( ) ; for ( int i = NUM_ ; i < len ; i ++ ) { boolean odd = ( i % NUM_ ) != NUM_ ; if ( odd ) { h = ( char ) ( ( h . NUM_ ) + tmp . charAt ( i ) ) ; sb . append ( h ) ; } else { h = tmp . charAt ( i ) ; } } if ( ( len % NUM_ ) != NUM_ ) { sb . append ( ( char ) ( ( h . NUM_ ) + NUM_ ) ) ; } return submode ; }
public void remove ( String attrName , String delValue ) { int index = indexOf ( attrName ) ; if ( index != - NUM_ ) { Attr attr = ( Attr ) _attrs . get ( index ) ; attr . removeValue ( delValue ) ; if ( attr . size ( ) == NUM_ ) { _attrs . remove ( index ) ; } } }
private AppliedMigration createAppliedSchemaMigration ( ) { return new AppliedMigration ( NUM_ , NUM_ , MigrationVersion . fromVersion ( Integer . toString ( NUM_ ) ) , STR_ , MigrationType . SCHEMA , STR_ , null , new Date ( ) , STR_ , NUM_ , BOOL_ ) ; }
public static String makeSigAlg ( String digAlg , String encAlg ) { digAlg = digAlg . replace ( STR_ , STR_ ) ; if ( encAlg . equalsIgnoreCase ( STR_ ) ) encAlg = STR_ ; return digAlg + STR_ + encAlg ; }
public Table sample ( double proportion ) { int tableCount = ( int ) Math . round ( rowCount ( ) . proportion ) ; Selection table1Selection = new BitmapBackedSelection ( ) ; int [ ] selectedRecords = generateUniformBitmap ( tableCount , rowCount ( ) ) ; for ( int selectedRecord : selectedRecords ) { table1Selection . add ( selectedRecord ) ; } return selectWhere ( table1Selection ) ; }
public static int indexOf ( byte [ ] src , byte [ ] target , int fromIdx ) { final int to = src . length - target . length + NUM_ ; for ( int i = fromIdx ; i < to ; i ++ ) { if ( src [ i ] == target [ NUM_ ] ) { boolean equals = BOOL_ ; for ( int j = NUM_ , k = i + NUM_ ; j < target . length && equals ; j ++ , k ++ ) { if ( src [ k ] != target [ j ] ) { equals = BOOL_ ; } } if ( equals ) { return i ; } } } return - NUM_ ; }
@ Override public int read ( byte [ ] buf , int offset , int length ) throws IOException { try { if ( _channel == null ) { return - NUM_ ; } int remaining = _readBuffer . remaining ( ) ; if ( remaining > NUM_ ) { _readBuffer . get ( buf , offset , remaining ) ; return remaining ; } _readBuffer . clear ( ) ; int channelRead = _channel . read ( _readBuffer ) ; _readBuffer . flip ( ) ; if ( channelRead < NUM_ ) return - NUM_ ; _readBuffer . get ( buf , offset , channelRead ) ; return channelRead ; } catch ( InterruptedIOException e ) { if ( _throwReadInterrupts ) throw e ; log . log ( Level . FINEST , e . toString ( ) , e ) ; } catch ( IOException e ) { if ( _throwReadInterrupts ) throw e ; log . log ( Level . FINER , e . toString ( ) , e ) ; } return - NUM_ ; }
String readUTF ( byte data [ ] , int off , int len ) { int offset = off ; StringBuffer buf = new StringBuffer ( ) ; for ( int end = offset + len ; offset < end ; ) { int ch = data [ offset ++ ] & xFF ; switch ( ch > > NUM_ ) { case NUM_ : case NUM_ : case NUM_ : case NUM_ : case NUM_ : case NUM_ : case NUM_ : case NUM_ : break ; case NUM_ : case NUM_ : if ( offset >= len ) { return null ; } ch = ( ( ch & x1F ) << NUM_ ) | ( data [ offset ++ ] & x3F ) ; break ; case NUM_ : if ( offset + NUM_ >= len ) { return null ; } ch = ( ( ch & x0f ) << NUM_ ) | ( ( data [ offset ++ ] & x3F ) << NUM_ ) | ( data [ offset ++ ] & x3F ) ; break ; default : if ( offset + NUM_ >= len ) { return null ; } ch = ( ( ch & x3F ) << NUM_ ) | ( data [ offset ++ ] & x0f ) ; break ; } buf . append ( ( char ) ch ) ; } return buf . toString ( ) ; }
public TurtleWriter ( OutputStream out ) { this ( new OutputStreamWriter ( out , Charset . forName ( STR_ ) ) ) ; }
private char lookahead ( ) { return curCharIndex < pattern . length ( ) - NUM_ ? pattern . charAt ( curCharIndex + NUM_ ) : EOF ; }
public static boolean isNumber ( String s ) { if ( s . length ( ) == NUM_ ) { return BOOL_ ; } for ( char c : s . toCharArray ( ) ) { if ( ! Character . isDigit ( c ) ) { return BOOL_ ; } } return BOOL_ ; }
private State ( CircuitState circuitState , Duration timeoutDuration , EventCounter counter ) { this . circuitState = circuitState ; this . counter = counter ; if ( timeoutDuration . isZero ( ) || timeoutDuration . isNegative ( ) ) { timedOutTimeNanos = NUM_ ; } else { timedOutTimeNanos = ticker . read ( ) + timeoutDuration . toNanos ( ) ; } }
public void cleanup ( ButtonGroup bg ) { if ( bg != null ) { bg . remove ( layerName ) ; } cleanup ( ) ; }
public static Map < MetaKey , String > union ( final Map < MetaKey , String > providedMetaData , final Map < MetaKey , String > extractedMetaData ) { final int size1 = providedMetaData != null ? providedMetaData . size ( ) : NUM_ ; final int size2 = extractedMetaData != null ? extractedMetaData . size ( ) : NUM_ ; if ( size1 + size2 == NUM_ ) { return Collections . emptyMap ( ) ; } final Map < MetaKey , String > result = new HashMap < > ( size1 + size2 ) ; if ( extractedMetaData != null ) { result . putAll ( extractedMetaData ) ; } if ( providedMetaData != null ) { result . putAll ( providedMetaData ) ; } return Collections . unmodifiableMap ( result ) ; }
public static char [ ] fix83600 ( char [ ] signature ) { if ( signature == null || signature . length < NUM_ ) return signature ; return Signature . removeCapture ( signature ) ; }
public static void formatDouble ( double source , int decimals , int precision , StringBuffer target ) { int scale = ( Math . abs ( source ) >= NUM_ ) ? decimals : precision ; if ( tooManyDigitsUsed ( source , scale ) || tooCloseToRound ( source , scale ) ) { formatDoublePrecise ( source , decimals , precision , target ) ; } else { formatDoubleFast ( source , decimals , precision , target ) ; } }
public static byte [ ] decode ( byte [ ] input , int offset , int len , int flags ) { Decoder decoder = new Decoder ( flags , new byte [ len . NUM_ / NUM_ ] ) ; if ( ! decoder . process ( input , offset , len , BOOL_ ) ) { throw new IllegalArgumentException ( STR_ ) ; } if ( decoder . op == decoder . output . length ) { return decoder . output ; } byte [ ] temp = new byte [ decoder . op ] ; System . arraycopy ( decoder . output , NUM_ , temp , NUM_ , decoder . op ) ; return temp ; }
protected View createChild ( String name ) { View view = null ; if ( name . equals ( TF_PARENTID ) || name . equals ( TF_CLIENT_TYPE ) ) { view = new CCTextField ( this , name , STR_ ) ; } else if ( name . equals ( SEC_MH_COMMON ) ) { view = new CCSecondaryMasthead ( this , name ) ; } else if ( name . equals ( PGTITLE ) ) { view = new CCPageTitle ( this , ptModel , name ) ; } else if ( ptModel . isChildSupported ( name ) ) { view = ptModel . createChild ( this , name ) ; } else if ( name . equals ( PROPERTY_ATTRIBUTE ) ) { view = new AMPropertySheet ( this , propertySheetModel , name ) ; } else if ( propertySheetModel . isChildSupported ( name ) ) { view = propertySheetModel . createChild ( this , name , getModel ( ) ) ; } else { view = super . createChild ( name ) ; } return view ; }
public synchronized void draw ( final Graphics2D gfx , final float x , final float y ) { if ( ! isEmpty ( ) ) { m_textLayout . draw ( gfx , x , y ) ; for ( final CHighlighting highlighting : new ArrayList < CHighlighting > ( m_highlighting ) ) { final double bpX = ( x + highlighting . getStart ( ) ) - NUM_ ; final double bpY = ( y - m_charHeight ) + NUM_ ; final double bpW = highlighting . getEnd ( ) + NUM_ ; final double bpH = m_charHeight - NUM_ ; drawHighlighting ( gfx , bpX , bpY , bpW , bpH , highlighting . getColor ( ) ) ; } } }
public void writeMapEnd ( ) throws IOException { os . write ( STR_ ) ; }
public boolean isAbstract ( ) { return Modifier . isAbstract ( flags ) ; }
public static File relativeFile ( File f ) { if ( f . isAbsolute ( ) ) { f = relativeFile ( new File ( STR_ ) , f ) ; } return f ; }
public XMLParser ( final String namespace , final String [ ] schemas ) throws XMLException { try { JAXBContext jc = JAXBContext . newInstance ( namespace ) ; marshaller = jc . createMarshaller ( ) ; marshaller . setSchema ( XMLSchemaUtils . createSchema ( schemas ) ) ; unmarshaller = jc . createUnmarshaller ( ) ; unmarshaller . setSchema ( XMLSchemaUtils . createSchema ( schemas ) ) ; } catch ( JAXBException e ) { throw new XMLException ( STR_ + namespace , e ) ; } }
private ArrayList < SpinnerLanguageElement > createSpinnerLanguages ( int avoidLanguage ) { ArrayList < SpinnerLanguageElement > result = new ArrayList < SpinnerLanguageElement > ( ) ; List < String > languages = mSessionOptions . allLanguages ( ) ; for ( int i = NUM_ ; i < languages . size ( ) ; ++ i ) { if ( i != avoidLanguage ) { result . add ( new SpinnerLanguageElement ( languages . get ( i ) , i ) ) ; } } return result ; }
public String [ ] splitResourceName ( String serviceTypeName , String resourceName ) throws NameNotFoundException , SSOException , PolicyException { ServiceType st = getServiceType ( serviceTypeName ) ; Set prefixes = getManagedResourceNames ( serviceTypeName ) ; String [ ] retVal = new String [ NUM_ ] ; if ( prefixes . isEmpty ( ) ) { retVal [ NUM_ ] = STR_ ; retVal [ NUM_ ] = resourceName ; return retVal ; } Iterator iter = prefixes . iterator ( ) ; String tmp = null ; ResourceMatch matchResult = null ; boolean foundSuperMatch = BOOL_ ; boolean foundExactMatch = BOOL_ ; while ( iter . hasNext ( ) ) { tmp = ( String ) iter . next ( ) ; matchResult = st . compare ( resourceName , tmp ) ; if ( matchResult . equals ( ResourceMatch . SUPER_RESOURCE_MATCH ) ) { foundSuperMatch = BOOL_ ; break ; } if ( matchResult . equals ( ResourceMatch . EXACT_MATCH ) ) { foundExactMatch = BOOL_ ; break ; } } if ( foundSuperMatch ) { retVal [ NUM_ ] = tmp ; retVal [ NUM_ ] = st . getSubResource ( resourceName , tmp ) ; return retVal ; } if ( foundExactMatch ) { retVal [ NUM_ ] = tmp ; retVal [ NUM_ ] = STR_ ; return retVal ; } retVal [ NUM_ ] = STR_ ; retVal [ NUM_ ] = resourceName ; return retVal ; }
void materialize ( ) { if ( cachefill < NUM_ ) { return ; } double min = Double . MAX_VALUE , max = Double . MIN_VALUE ; for ( int i = NUM_ ; i < cachefill ; i ++ ) { min = Math . min ( min , cachec [ i ] ) ; max = Math . max ( max , cachec [ i ] ) ; } LinearScale scale = new LinearScale ( min , max ) ; min = scale . getMin ( ) ; max = scale . getMax ( ) ; this . base = min ; this . max = max ; this . binsize = ( max - min ) / this . destsize ; this . data = new long [ this . destsize << NUM_ ] ; size = destsize ; final int end = cachefill ; cachefill = - NUM_ ; for ( int i = NUM_ ; i < end ; i ++ ) { increment ( cachec [ i ] , cachev [ i ] ) ; } cachec = null ; cachev = null ; }
public Criteria createCriteria ( ) { Criteria criteria = createCriteriaInternal ( ) ; if ( oredCriteria . size ( ) == NUM_ ) { oredCriteria . add ( criteria ) ; } return criteria ; }
public ArrayFieldVector ( Field < T > field , T [ ] v1 , T [ ] v2 ) throws MathIllegalArgumentException , NullArgumentException { MathUtils . checkNotNull ( v1 ) ; MathUtils . checkNotNull ( v2 ) ; if ( v1 . length + v2 . length == NUM_ ) { throw new MathIllegalArgumentException ( LocalizedCoreFormats . VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT ) ; } data = MathArrays . buildArray ( field , v1 . length + v2 . length ) ; System . arraycopy ( v1 , NUM_ , data , NUM_ , v1 . length ) ; System . arraycopy ( v2 , NUM_ , data , v1 . length , v2 . length ) ; this . field = field ; }
private void verifyTargetSessionIsLocalOrStateless ( SessionRequest req , SessionID sid ) throws SessionException , SessionRequestException , ForwardSessionRequestException { if ( statelessSessionManager . containsJwt ( sid ) ) { return ; } String hostServerID = foreignSessionHandler . getCurrentHostServer ( sid ) ; if ( ! serverConfig . isLocalServer ( hostServerID ) ) { try { throw new ForwardSessionRequestException ( forward ( SESSION_SERVICE_URL_SERVICE . getSessionServiceURL ( hostServerID ) , req ) ) ; } catch ( SessionException se ) { if ( ! sessionService . checkServerUp ( hostServerID ) ) { String retryHostServerID = foreignSessionHandler . getCurrentHostServer ( sid ) ; if ( retryHostServerID . equals ( hostServerID ) ) { throw se ; } else { if ( ! serverConfig . isLocalServer ( retryHostServerID ) ) { throw new ForwardSessionRequestException ( forward ( SESSION_SERVICE_URL_SERVICE . getSessionServiceURL ( hostServerID ) , req ) ) ; } } } else { throw se ; } } } if ( ! sessionService . checkSessionLocal ( sid ) ) { throw new SessionRequestException ( sid , SessionBundle . getString ( STR_ ) ) ; } }
public static boolean isJavaBuiltinDataType ( Class clazz ) { if ( clazz == null ) { return BOOL_ ; } Class clazzBoxed = getBoxedType ( clazz ) ; if ( isNumeric ( clazzBoxed ) ) { return BOOL_ ; } if ( isBoolean ( clazzBoxed ) ) { return BOOL_ ; } if ( clazzBoxed . equals ( String . class ) ) { return BOOL_ ; } if ( ( clazzBoxed . equals ( char . class ) ) || ( clazzBoxed . equals ( Character . class ) ) ) { return BOOL_ ; } if ( clazzBoxed . equals ( void . class ) ) { return BOOL_ ; } return BOOL_ ; }
protected boolean isControlChar ( char ch ) { return Character . isISOControl ( ch ) && ! Character . isWhitespace ( ch ) ; }
public void encode ( OutputStream out ) throws IOException { DerOutputStream tmp = new DerOutputStream ( ) ; if ( extensionValue == null ) { extensionId = PKIXExtensions . PolicyConstraints_Id ; critical = BOOL_ ; encodeThis ( ) ; } super . encode ( tmp ) ; out . write ( tmp . toByteArray ( ) ) ; }
< T > List < T > onFindAll ( Class < T > modelClass , boolean isEager , long ... ids ) { List < T > dataList ; if ( isAffectAllLines ( ids ) ) { dataList = query ( modelClass , null , null , null , null , null , STR_ , null , getForeignKeyAssociations ( modelClass . getName ( ) , isEager ) ) ; } else { dataList = query ( modelClass , null , getWhereOfIdsWithOr ( ids ) , null , null , null , STR_ , null , getForeignKeyAssociations ( modelClass . getName ( ) , isEager ) ) ; } return dataList ; }
public boolean isCached ( String requestUrl , int maxWidth , int maxHeight ) { return isCached ( requestUrl , maxWidth , maxHeight , ScaleType . CENTER_INSIDE ) ; }
public Style addStyle ( String nm , Style parent ) { StyleContext styles = ( StyleContext ) getAttributeContext ( ) ; return styles . addStyle ( nm , parent ) ; }
public static TextWithMnemonic parseText ( final String textWithMnemonic ) { if ( textWithMnemonic == null ) { throw new IllegalArgumentException ( STR_ ) ; } int index = - NUM_ ; final StringBuffer plainText = new StringBuffer ( ) ; for ( int i = NUM_ ; i < textWithMnemonic . length ( ) ; i ++ ) { char ch = textWithMnemonic . charAt ( i ) ; if ( ch == STR_ ) { i ++ ; if ( i >= textWithMnemonic . length ( ) ) { break ; } ch = textWithMnemonic . charAt ( i ) ; if ( ch != STR_ ) { index = plainText . length ( ) ; } } plainText . append ( ch ) ; } return new TextWithMnemonic ( plainText . toString ( ) , index ) ; }
public void checkPermissions ( NamespaceEntity namespaceEntity , String ... requestedIamRoleNames ) { checkPermissions ( namespaceEntity , Arrays . asList ( requestedIamRoleNames ) ) ; }
private static AnnotatedTypeMirror asOuterSuper ( Types types , AnnotatedTypeFactory atypeFactory , AnnotatedTypeMirror type , AnnotatedTypeMirror superType ) { if ( type . getKind ( ) == TypeKind . DECLARED ) { AnnotatedDeclaredType dt = ( AnnotatedDeclaredType ) type ; AnnotatedDeclaredType enclosingType = dt ; TypeMirror superTypeMirror = types . erasure ( superType . getUnderlyingType ( ) ) ; while ( enclosingType != null ) { TypeMirror enclosingTypeMirror = types . erasure ( enclosingType . getUnderlyingType ( ) ) ; if ( types . isSubtype ( enclosingTypeMirror , superTypeMirror ) ) { dt = enclosingType ; break ; } enclosingType = enclosingType . getEnclosingType ( ) ; } if ( enclosingType == null ) { return superType ; } return asSuper ( atypeFactory , dt , superType ) ; } return asSuper ( atypeFactory , type , superType ) ; }
public void reload ( SolrCore core , SolrIndexSearcher searcher ) throws IOException { LOG . info ( STR_ ) ; if ( dictionary == null && storeDir != null ) { FileInputStream is = new FileInputStream ( new File ( storeDir , factory . storeFileName ( ) ) ) ; try { if ( lookup . load ( is ) ) { return ; } } finally { IOUtils . closeWhileHandlingException ( is ) ; } LOG . debug ( STR_ ) ; } build ( core , searcher ) ; }
public static String asString ( String jsonPath , Map < String , Object > json ) { return pathAs ( String . class , jsonPath , json ) ; }
@ Override public ServerHeartbeat serverDyn ( String address , int port , boolean isSSL , String clusterId , String displayName ) { Objects . requireNonNull ( address ) ; Objects . requireNonNull ( clusterId ) ; ClusterHeartbeat cluster = createCluster ( clusterId ) ; ServerHeartbeat server = cluster . createServer ( address , port , isSSL ) ; if ( displayName != null ) { server . setDisplayName ( displayName ) ; } cluster . addDynamicServer ( server ) ; return server ; }
public void paintComponentBackground ( Object nativeGraphics , int x , int y , int width , int height , Style s ) { if ( width <= NUM_ || height <= NUM_ ) { return ; } Image bgImageOrig = s . getBgImage ( ) ; if ( bgImageOrig == null ) { if ( s . getBackgroundType ( ) >= Style . BACKGROUND_GRADIENT_LINEAR_VERTICAL ) { drawGradientBackground ( s , nativeGraphics , x , y , width , height ) ; return ; } setColor ( nativeGraphics , s . getBgColor ( ) ) ; fillRect ( nativeGraphics , x , y , width , height , s . getBgTransparency ( ) ) ; } else { int iW = bgImageOrig . getWidth ( ) ; int iH = bgImageOrig . getHeight ( ) ; Object bgImage = bgImageOrig . getImage ( ) ; switch ( s . getBackgroundType ( ) ) { case Style . BACKGROUND_NONE : if ( s . getBgTransparency ( ) != NUM_ ) { setColor ( nativeGraphics , s . getBgColor ( ) ) ; fillRect ( nativeGraphics , x , y , width , height , s . getBgTransparency ( ) ) ; } return ; case Style . BACKGROUND_IMAGE_SCALED : if ( isScaledImageDrawingSupported ( ) ) { drawImage ( nativeGraphics , bgImage , x , y , width , height ) ; } else { if ( iW != width || iH != height ) { bgImageOrig = bgImageOrig . scaled ( width , height ) ; s . setBgImage ( bgImageOrig , BOOL_ ) ; bgImage = bgImageOrig . getImage ( ) ; } drawImage ( nativeGraphics , bgImage , x , y ) ; } return ; case Style . BACKGROUND_IMAGE_SCALED_FILL : float r = Math . max ( ( ( float ) width ) / ( ( float ) iW ) , ( ( float ) height ) / ( ( float ) iH ) ) ; int bwidth = ( int ) ( ( ( float ) iW ) . r ) ; int bheight = ( int ) ( ( ( float ) iH ) . r ) ; if ( isScaledImageDrawingSupported ( ) ) { drawImage ( nativeGraphics , bgImage , x + ( width - bwidth ) / NUM_ , y + ( height - bheight ) / NUM_ , bwidth , bheight ) ; } else { if ( iW != bwidth || iH != bheight ) { bgImageOrig = bgImageOrig . scaled ( bwidth , bheight ) ; s . setBgImage ( bgImageOrig , BOOL_ ) ; bgImage = bgImageOrig . getImage ( ) ; } drawImage ( nativeGraphics , bgImage , x + ( width - bwidth ) / NUM_ , y + ( height - bheight ) / NUM_ ) ; } return ; case Style . BACKGROUND_IMAGE_SCALED_FIT : if ( s . getBgTransparency ( ) != NUM_ ) { setColor ( nativeGraphics , s . getBgColor ( ) ) ; fillRect ( nativeGraphics , x , y , width , height , s . getBgTransparency ( ) ) ; } float r2 = Math . min ( ( ( float ) width ) / ( ( float ) iW ) , ( ( float ) height ) / ( ( float ) iH ) ) ; int awidth = ( int ) ( ( ( float ) iW ) . r2 ) ; int aheight = ( int ) ( ( ( float ) iH ) . r2 ) ; if ( isScaledImageDrawingSupported ( ) ) { drawImage ( nativeGraphics , bgImage , x + ( width - awidth ) / NUM_ , y + ( height - aheight ) / NUM_ , awidth , aheight ) ; } else { if ( iW != awidth || iH != aheight ) { bgImageOrig = bgImageOrig . scaled ( awidth , aheight ) ; s . setBgImage ( bgImageOrig , BOOL_ ) ; bgImage = bgImageOrig . getImage ( ) ; } drawImage ( nativeGraphics , bgImage , x + ( width - awidth ) / NUM_ , y + ( height - aheight ) / NUM_ , awidth , aheight ) ; } return ; case Style . BACKGROUND_IMAGE_TILE_BOTH : tileImage ( nativeGraphics , bgImage , x , y , width , height ) ; return ; case Style . BACKGROUND_IMAGE_TILE_HORIZONTAL_ALIGN_TOP : setColor ( nativeGraphics , s . getBgColor ( ) ) ; fillRect ( nativeGraphics , x , y , width , height , s . getBgTransparency ( ) ) ; tileImage ( nativeGraphics , bgImage , x , y , width , iH ) ; return ; case Style . BACKGROUND_IMAGE_TILE_HORIZONTAL_ALIGN_CENTER : setColor ( nativeGraphics , s . getBgColor ( ) ) ; fillRect ( nativeGraphics , x , y , width , height , s . getBgTransparency ( ) ) ; tileImage ( nativeGraphics , bgImage , x , y + ( height / NUM_ - iH / NUM_ ) , width , iH ) ; return ; case Style . BACKGROUND_IMAGE_TILE_HORIZONTAL_ALIGN_BOTTOM : setColor ( nativeGraphics , s . getBgColor ( ) ) ; fillRect ( nativeGraphics , x , y , width , height , s . getBgTransparency ( ) ) ; tileImage ( nativeGraphics , bgImage , x , y + ( height - iH ) , width , iH ) ; return ; case Style . BACKGROUND_IMAGE_TILE_VERTICAL_ALIGN_LEFT : setColor ( nativeGraphics , s . getBgColor ( ) ) ; fillRect ( nativeGraphics , x , y , width , height , s . getBgTransparency ( ) ) ; for ( int yPos = NUM_ ; yPos <= height ; yPos += iH ) { drawImage ( nativeGraphics , bgImage , x , y + yPos ) ; } return ; case Style . BACKGROUND_IMAGE_TILE_VERTICAL_ALIGN_CENTER : setColor ( nativeGraphics , s . getBgColor ( ) ) ; fillRect ( nativeGraphics , x , y , width , height , s . getBgTransparency ( ) ) ; for ( int yPos = NUM_ ; yPos <= height ; yPos += iH ) { drawImage ( nativeGraphics , bgImage , x + ( width / NUM_ - iW / NUM_ ) , y + yPos ) ; } return ; case Style . BACKGROUND_IMAGE_TILE_VERTICAL_ALIGN_RIGHT : setColor ( nativeGraphics , s . getBgColor ( ) ) ; fillRect ( nativeGraphics , x , y , width , height , s . getBgTransparency ( ) ) ; for ( int yPos = NUM_ ; yPos <= height ; yPos += iH ) { drawImage ( nativeGraphics , bgImage , x + width - iW , y + yPos ) ; } return ; case Style . BACKGROUND_IMAGE_ALIGNED_TOP : setColor ( nativeGraphics , s . getBgColor ( ) ) ; fillRect ( nativeGraphics , x , y , width , height , s . getBgTransparency ( ) ) ; drawImage ( nativeGraphics , bgImage , x + ( width / NUM_ - iW / NUM_ ) , y ) ; return ; case Style . BACKGROUND_IMAGE_ALIGNED_BOTTOM : setColor ( nativeGraphics , s . getBgColor ( ) ) ; fillRect ( nativeGraphics , x , y , width , height , s . getBgTransparency ( ) ) ; drawImage ( nativeGraphics , bgImage , x + ( width / NUM_ - iW / NUM_ ) , y + ( height - iH ) ) ; return ; case Style . BACKGROUND_IMAGE_ALIGNED_LEFT : setColor ( nativeGraphics , s . getBgColor ( ) ) ; fillRect ( nativeGraphics , x , y , width , height , s . getBgTransparency ( ) ) ; drawImage ( nativeGraphics , bgImage , x , y + ( height / NUM_ - iH / NUM_ ) ) ; return ; case Style . BACKGROUND_IMAGE_ALIGNED_RIGHT : setColor ( nativeGraphics , s . getBgColor ( ) ) ; fillRect ( nativeGraphics , x , y , width , height , s . getBgTransparency ( ) ) ; drawImage ( nativeGraphics , bgImage , x + width - iW , y + ( height / NUM_ - iH / NUM_ ) ) ; return ; case Style . BACKGROUND_IMAGE_ALIGNED_CENTER : setColor ( nativeGraphics , s . getBgColor ( ) ) ; fillRect ( nativeGraphics , x , y , width , height , s . getBgTransparency ( ) ) ; drawImage ( nativeGraphics , bgImage , x + ( width / NUM_ - iW / NUM_ ) , y + ( height / NUM_ - iH / NUM_ ) ) ; return ; case Style . BACKGROUND_IMAGE_ALIGNED_TOP_LEFT : setColor ( nativeGraphics , s . getBgColor ( ) ) ; fillRect ( nativeGraphics , x , y , width , height , s . getBgTransparency ( ) ) ; drawImage ( nativeGraphics , bgImage , x , y ) ; return ; case Style . BACKGROUND_IMAGE_ALIGNED_TOP_RIGHT : setColor ( nativeGraphics , s . getBgColor ( ) ) ; fillRect ( nativeGraphics , x , y , width , height , s . getBgTransparency ( ) ) ; drawImage ( nativeGraphics , bgImage , x + width - iW , y ) ; return ; case Style . BACKGROUND_IMAGE_ALIGNED_BOTTOM_LEFT : setColor ( nativeGraphics , s . getBgColor ( ) ) ; fillRect ( nativeGraphics , x , y , width , height , s . getBgTransparency ( ) ) ; drawImage ( nativeGraphics , bgImage , x , y + ( height - iH ) ) ; return ; case Style . BACKGROUND_IMAGE_ALIGNED_BOTTOM_RIGHT : setColor ( nativeGraphics , s . getBgColor ( ) ) ; fillRect ( nativeGraphics , x , y , width , height , s . getBgTransparency ( ) ) ; drawImage ( nativeGraphics , bgImage , x + width - iW , y + ( height - iH ) ) ; return ; case Style . BACKGROUND_GRADIENT_LINEAR_HORIZONTAL : case Style . BACKGROUND_GRADIENT_LINEAR_VERTICAL : case Style . BACKGROUND_GRADIENT_RADIAL : drawGradientBackground ( s , nativeGraphics , x , y , width , height ) ; return ; } } }
public void runTest ( ) throws Throwable { Document doc ; NodeList genderList ; Node genderNode ; CharacterData entText ; EntityReference entReference ; Node appendedNode ; doc = ( Document ) load ( STR_ , BOOL_ ) ; genderList = doc . getElementsByTagName ( STR_ ) ; genderNode = genderList . item ( NUM_ ) ; entReference = doc . createEntityReference ( STR_ ) ; assertNotNull ( STR_ , entReference ) ; appendedNode = genderNode . appendChild ( entReference ) ; entText = ( CharacterData ) entReference . getFirstChild ( ) ; assertNotNull ( STR_ , entText ) ; { boolean success = BOOL_ ; try { entText . replaceData ( NUM_ , NUM_ , STR_ ) ; } catch ( DOMException ex ) { success = ( ex . code == DOMException . NO_MODIFICATION_ALLOWED_ERR ) ; } assertTrue ( STR_ , success ) ; } }
public void removeAll ( ) { mParts . clear ( ) ; }
protected abstract void handleLostEntry ( HttpRoute route ) ;
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; }
public static boolean executableExists ( String executable ) { File directFile = new File ( executable ) ; if ( directFile . exists ( ) && directFile . canExecute ( ) ) { return BOOL_ ; } for ( String pathString : getSystemPath ( ) ) { Path path = Paths . get ( pathString ) ; if ( Files . exists ( path . resolve ( executable ) ) && Files . isExecutable ( path . resolve ( executable ) ) ) { return BOOL_ ; } } return BOOL_ ; }
@ Override public String toString ( ) { StringBuilder buf = new StringBuilder ( ) ; int i = NUM_ ; for ( PseudoOp op : contents ) { buf . append ( String . format ( STR_ , i ++ , op ) ) ; } return buf . toString ( ) ; }
private List < File > combine ( List < File > listA , List < File > listB ) { LinkedHashSet < File > combinedProjects = Sets . newLinkedHashSet ( listA ) ; combinedProjects . addAll ( listB ) ; return new ArrayList < > ( combinedProjects ) ; }
public long generateNewPingId ( ) { PreferenceStore prefs = getPreferenceStore ( ) ; Random rnd = new Random ( ) ; long id = rnd . nextLong ( ) ; synchronized ( DdmsPreferenceStore . class ) { prefs . setValue ( PING_ID , id ) ; try { prefs . save ( ) ; } catch ( IOException e ) { } } return id ; }
public boolean isValid ( ) { return System . currentTimeMillis ( ) < creationTime + lifetime + ( lifetime / NUM_ ) ; }
public static Model readFrom ( VirtualFile file ) throws ServerException , ForbiddenException , IOException { requireNonNull ( file , STR_ ) ; return fetchModel ( XMLTree . from ( file . getContent ( ) ) ) ; }
public boolean isValueExistForKey ( String key ) { boolean isValueExists ; try { String string = getString ( key , STR_ ) ; isValueExists = ! string . equalsIgnoreCase ( STR_ ) ; } catch ( ClassCastException e ) { try { int anInt = getInt ( key , NUM_ ) ; isValueExists = anInt != NUM_ ; } catch ( ClassCastException e1 ) { try { long aLong = getLong ( key , NUM_ ) ; isValueExists = aLong != NUM_ ; } catch ( ClassCastException e2 ) { try { float aFloat = getFloat ( key , NUM_ ) ; isValueExists = aFloat != NUM_ ; } catch ( ClassCastException e3 ) { try { boolean aBoolean = getBoolean ( key , BOOL_ ) ; isValueExists = ! aBoolean ; } catch ( Exception e4 ) { isValueExists = BOOL_ ; e . printStackTrace ( ) ; } } } } } catch ( Exception e ) { isValueExists = BOOL_ ; } return isValueExists ; }
public void updateViewport ( ) { setToOrtho ( BOOL_ , virtualViewport . getWidth ( ) , virtualViewport . getHeight ( ) ) ; }
public String toString ( ) { if ( keyUsages == null ) return STR_ ; String usage = STR_ ; boolean first = BOOL_ ; for ( ObjectIdentifier oid : keyUsages ) { if ( ! first ) { usage += STR_ ; } String result = map . get ( oid ) ; if ( result != null ) { usage += result ; } else { usage += oid . toString ( ) ; } first = BOOL_ ; } return super . toString ( ) + STR_ + usage + STR_ ; }
public static void writeBoxplot ( TDoubleObjectHashMap < double [ ] > table , String file ) throws IOException { int maxSize = NUM_ ; TDoubleObjectIterator < double [ ] > it = table . iterator ( ) ; for ( int i = NUM_ ; i < table . size ( ) ; i ++ ) { it . advance ( ) ; maxSize = Math . max ( maxSize , it . value ( ) . length ) ; } double keys [ ] = table . keys ( ) ; Arrays . sort ( keys ) ; BufferedWriter writer = new BufferedWriter ( new FileWriter ( file ) ) ; for ( int k = NUM_ ; k < keys . length ; k ++ ) { writer . write ( String . valueOf ( keys [ k ] ) ) ; if ( k + NUM_ < keys . length ) writer . write ( TAB ) ; } writer . newLine ( ) ; for ( int i = NUM_ ; i < maxSize ; i ++ ) { for ( int k = NUM_ ; k < keys . length ; k ++ ) { double [ ] list = table . get ( keys [ k ] ) ; if ( i < list . length ) { writer . write ( String . valueOf ( list [ i ] ) ) ; } else { writer . write ( NA ) ; } if ( k + NUM_ < keys . length ) writer . write ( TAB ) ; } writer . newLine ( ) ; } writer . close ( ) ; }
public void testClearBitNegativeInside3 ( ) { String as = STR_ ; int number = NUM_ ; BigInteger aNumber = new BigInteger ( as ) ; BigInteger result = aNumber . clearBit ( number ) ; assertEquals ( as , result . toString ( ) ) ; }
@ Theory public void logEntriesHaveSameOrderAsIndexes ( Object [ ] dataPoint ) { int index1 = ( int ) dataPoint [ NUM_ ] ; int index2 = ( int ) dataPoint [ NUM_ ] ; LogEntry first = logEntries [ index1 ] ; LogEntry second = logEntries [ index2 ] ; LOG . debug ( STR_ , index1 , index2 ) ; int result = tested . compare ( first , second ) ; int expected = Integer . compare ( index1 , index2 ) ; assertThatHaveSameSignum ( expected , result ) ; }
public static void copyAll ( File root , File dest ) throws IOException { if ( root . isDirectory ( ) ) { for ( File child : root . listFiles ( ) ) { File childDest = new File ( dest , child . getName ( ) ) ; if ( child . isDirectory ( ) ) { if ( ! childDest . exists ( ) && ! mkdirs ( childDest ) ) throw new IOException ( STR_ + childDest . getPath ( ) ) ; copyAll ( child , childDest ) ; } else { Files . copy ( child . toPath ( ) , childDest . toPath ( ) , StandardCopyOption . COPY_ATTRIBUTES ) ; } } } else { File childDest = new File ( dest , root . getName ( ) ) ; if ( ! dest . exists ( ) && ! mkdirs ( dest ) ) throw new IOException ( STR_ + dest . getPath ( ) ) ; Files . copy ( root . toPath ( ) , childDest . toPath ( ) , StandardCopyOption . COPY_ATTRIBUTES ) ; } }
public void paintLine ( Point2D pt1 , Point2D pt2 ) { if ( pt1 != null && pt2 != null ) { OMLine cLine = new OMLine ( pt1 . getY ( ) , pt1 . getX ( ) , pt2 . getY ( ) , pt2 . getX ( ) , OMGraphic . LINETYPE_GREATCIRCLE ) ; Projection proj = theMap . getProjection ( ) ; cLine . generate ( proj ) ; distanceList . add ( cLine ) ; } }
public static boolean hasExportMaskForStorageAndVArray ( DbClient dbClient , ExportGroup exportGroup , URI storageURI ) { Set < String > storagePortURIsAssociatedWithVArrayAndStorageArray = ExportMaskUtils . getStoragePortUrisAssociatedWithVarrayAndStorageArray ( storageURI , exportGroup . getVirtualArray ( ) , dbClient ) ; StringSet maskUriSet = exportGroup . getExportMasks ( ) ; if ( maskUriSet != null ) { for ( String maskUriString : maskUriSet ) { ExportMask mask = dbClient . queryObject ( ExportMask . class , URI . create ( maskUriString ) ) ; URI maskStorageURI = mask . getStorageDevice ( ) ; if ( maskStorageURI . equals ( storageURI ) ) { for ( String storagePort : mask . getStoragePorts ( ) ) { if ( storagePortURIsAssociatedWithVArrayAndStorageArray . contains ( storagePort ) ) return BOOL_ ; } } } } return BOOL_ ; }
private void preload ( int first , boolean increasing ) { final int start ; final int end ; if ( increasing ) { start = Math . max ( first , mLastEnd ) ; end = Math . min ( first + mLoadAheadItems , mItemSource . getCount ( ) ) ; } else { start = Math . max ( NUM_ , first - mLoadAheadItems ) ; end = Math . min ( first , mLastStart ) ; } Log . v ( TAG , STR_ + first + STR_ + increasing + STR_ + start + STR_ + end ) ; mLastEnd = end ; mLastStart = start ; if ( start == NUM_ && end == NUM_ ) { return ; } final List < T > items = mItemSource . getItemsInRange ( start , end ) ; if ( ! increasing ) { Collections . reverse ( items ) ; } registerLoadTokens ( mItemLoader . preloadItems ( items ) ) ; }
Builder addLenient ( String line ) { int index = line . indexOf ( STR_ , NUM_ ) ; if ( index != - NUM_ ) { return addLenient ( line . substring ( NUM_ , index ) , line . substring ( index + NUM_ ) ) ; } else if ( line . startsWith ( STR_ ) ) { return addLenient ( STR_ , line . substring ( NUM_ ) ) ; } else { return addLenient ( STR_ , line ) ; } }
private void initRMIParameters ( ) throws Exception { if ( rmiHostMaster == null || rmiPortMaster == null ) { File confDir = ReplicatorRuntimeConf . locateReplicatorConfDir ( ) ; File propsFile = new File ( confDir , ReplicationServiceManager . CONFIG_SERVICES ) ; println ( String . format ( STR_ , propsFile ) ) ; TungstenProperties serviceProps = PropertiesManager . loadProperties ( propsFile ) ; if ( rmiPortMaster == null ) rmiPortMaster = serviceProps . getString ( ReplicatorConf . RMI_PORT , ReplicatorConf . RMI_DEFAULT_PORT , BOOL_ ) ; if ( rmiHostMaster == null ) rmiHostMaster = ReplicationServiceManager . getHostName ( serviceProps ) ; } }
public String encodeKey ( final String key ) { if ( StringUtils . isEmpty ( key ) ) { throw new IllegalArgumentException ( STR_ ) ; } try { return Hex . encodeHexString ( key . getBytes ( STR_ ) ) ; } catch ( UnsupportedEncodingException uee ) { throw new IllegalStateException ( uee ) ; } }
private static void globalUnionTest ( final ISchemaVersion schemaVersion ) throws IOException { final Writer output = openOutput ( schemaVersion , STR_ , TestType . UNION ) ; final HLL hll = newHLL ( HLLType . EMPTY ) ; final HLL emptyHLL = newHLL ( HLLType . EMPTY ) ; cumulativeUnionLine ( output , hll , emptyHLL , schemaVersion ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { final HLL randomHLL = generateRandomHLL ( ) ; cumulativeUnionLine ( output , hll , randomHLL , schemaVersion ) ; } output . flush ( ) ; output . close ( ) ; }
public static boolean restore ( ) { File restoreConfig = new File ( RESTORATION_PROPERTIES ) ; if ( restoreConfig . exists ( ) && restoreConfig . isFile ( ) ) { logger . info ( STR_ ) ; try ( FileInputStream stream = new FileInputStream ( restoreConfig ) ) { Properties properties = new Properties ( ) ; properties . load ( stream ) ; restoreDatabase ( properties ) ; restoreSolrIndex ( properties ) ; } catch ( UnsupportedOperationException e ) { logger . error ( STR_ , e ) ; System . setProperty ( STR_ , STR_ ) ; } catch ( Exception e ) { logger . fatal ( STR_ , e ) ; return BOOL_ ; } finally { restoreConfig . delete ( ) ; } } return BOOL_ ; }
public void testSetBitPositiveInside4 ( ) { byte aBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; int aSign = NUM_ ; int number = NUM_ ; byte rBytes [ ] = { NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger result = aNumber . setBit ( number ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = NUM_ ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STR_ , NUM_ , result . signum ( ) ) ; }
@ Override public void writeComment ( String data ) throws XMLStreamException { log . log ( Level . FINE , STR_ , data ) ; }
public static File fromDataURI ( String dataURI , String fileName ) { return File . createIfSupported ( fromDataURI ( dataURI ) , fileName ) ; }
protected List extractDiscoveryInformation ( XRDS xrds , XriIdentifier identifier , Resolver xriResolver ) throws DiscoveryException { ArrayList endpoints = new ArrayList ( ) ; XRD xrd = xrds . getFinalXRD ( ) ; extractDiscoveryInformationOpenID ( xriResolver , endpoints , xrd , identifier , DiscoveryInformation . OPENID2_OP , BOOL_ ) ; extractDiscoveryInformationOpenID ( xriResolver , endpoints , xrd , identifier , DiscoveryInformation . OPENID2 , BOOL_ ) ; extractDiscoveryInformationOpenID ( xriResolver , endpoints , xrd , identifier , DiscoveryInformation . OPENID11 , BOOL_ ) ; extractDiscoveryInformationOpenID ( xriResolver , endpoints , xrd , identifier , DiscoveryInformation . OPENID10 , BOOL_ ) ; if ( endpoints . size ( ) == NUM_ ) _log . info ( STR_ ) ; return endpoints ; }
public static void clearRecentFiles ( ) { String str = ProgramProperties . get ( RECENTFILES , STR_ ) ; if ( str . length ( ) != NUM_ ) { ProgramProperties . put ( RECENTFILES , STR_ ) ; notifyListChange ( RECENTFILES ) ; } }
public static boolean areEquivalent ( final TypeReference a , final TypeReference b ) { return areEquivalent ( a , b , BOOL_ ) ; }
private static char CallStaticCharMethodV ( JNIEnvironment env , int classJREF , int methodID , Address argAddress ) throws Exception { if ( traceJNI ) VM . sysWrite ( STR_ ) ; RuntimeEntrypoints . checkJNICountDownToGC ( ) ; try { Object returnObj = JNIHelpers . invokeWithVarArg ( methodID , argAddress , TypeReference . Char ) ; return Reflection . unwrapChar ( returnObj ) ; } catch ( Throwable unexpected ) { if ( traceJNI ) unexpected . printStackTrace ( System . err ) ; env . recordException ( unexpected ) ; return NUM_ ; } }
private boolean initXSettingsIfNeeded ( final String propName ) { if ( ! loadedXSettings && ( propName . startsWith ( STR_ ) || propName . equals ( SunToolkit . DESKTOPFONTHINTS ) || propName . startsWith ( dndPrefix ) ) ) { loadedXSettings = BOOL_ ; if ( ! GraphicsEnvironment . isHeadless ( ) ) { loadXSettings ( ) ; if ( desktopProperties . get ( SunToolkit . DESKTOPFONTHINTS ) == null ) { if ( XWM . isKDE2 ( ) ) { Object hint = fcManager . getFontConfigAAHint ( ) ; if ( hint != null ) { desktopProperties . put ( UNIXToolkit . FONTCONFIGAAHINT , hint ) ; } } desktopProperties . put ( SunToolkit . DESKTOPFONTHINTS , SunToolkit . getDesktopFontHints ( ) ) ; } return BOOL_ ; } } return BOOL_ ; }
private void updateSortingIcons ( ) { for ( SortingType type : SortingType . values ( ) ) { SortingDirection direction = model . getSortingDirection ( type ) ; ImageIcon icon ; switch ( direction ) { case DESCENDING : icon = ICON_ARROW_DOWN ; break ; case ASCENDING : icon = ICON_ARROW_UP ; break ; case UNDEFINED : icon = null ; break ; default : icon = null ; } switch ( type ) { case NAME : sortingLabelAttName . setIcon ( icon ) ; break ; case TYPE : sortingLabelAttType . setIcon ( icon ) ; break ; case MISSING : sortingLabelAttMissings . setIcon ( icon ) ; break ; default : sortingLabelAttName . setIcon ( null ) ; sortingLabelAttType . setIcon ( null ) ; sortingLabelAttMissings . setIcon ( null ) ; } } }
@ Override public synchronized void clear ( ) { File [ ] files = mRootDirectory . listFiles ( ) ; if ( files != null ) { for ( File file : files ) { file . delete ( ) ; } } mEntries . clear ( ) ; mTotalSize = NUM_ ; VolleyLog . d ( STR_ ) ; }
private void restoreIcon ( Key key , byte [ ] buffer , int dataSize ) throws IOException { if ( VERBOSE ) Log . v ( TAG , STR_ + key . id ) ; if ( DEBUG ) Log . d ( TAG , STR_ + buffer . length + STR_ + Base64 . encodeToString ( buffer , NUM_ , dataSize , Base64 . NO_WRAP ) ) ; Resource res = unpackProto ( new Resource ( ) , buffer , dataSize ) ; if ( DEBUG ) { Log . d ( TAG , STR_ + res . dpi + STR_ ) ; } Bitmap icon = BitmapFactory . decodeByteArray ( res . data , NUM_ , res . data . length ) ; if ( icon == null ) { Log . w ( TAG , STR_ + key . name ) ; } if ( VERBOSE ) Log . v ( TAG , STR_ + key . name ) ; IconCache . preloadIcon ( mContext , ComponentName . unflattenFromString ( key . name ) , icon , res . dpi ) ; }
public boolean isExpired ( ) { return paymentDetails . hasExpires ( ) && System . currentTimeMillis ( ) / NUM_ > paymentDetails . getExpires ( ) ; }
private void endFormals ( ) { if ( hasFormals ) { hasFormals = BOOL_ ; buf . append ( STR_ ) ; } }
public static void readBytes ( InputStream is , byte [ ] b , int offset , int len ) { if ( len == NUM_ ) return ; try { int read = NUM_ ; while ( read < len ) { int n = is . read ( b , offset + read , len - read ) ; if ( n < NUM_ ) throw new PngjInputException ( STR_ + n + STR_ + len ) ; read += n ; } } catch ( IOException e ) { throw new PngjInputException ( STR_ , e ) ; } }
public CharacterMatch ( char [ ] chars ) { Assert . isNotNull ( chars ) ; Assert . isTrue ( chars . length > NUM_ ) ; fChars = chars ; Arrays . sort ( chars ) ; }
public void addActionListener ( ActionListener newA ) { m_Listeners . add ( newA ) ; }
public boolean removeContainerAndCancelIfNecessary ( ImageContainer container ) { mContainers . remove ( container ) ; if ( mContainers . size ( ) == NUM_ ) { mRequest . cancel ( ) ; return BOOL_ ; } return BOOL_ ; }
public static byte [ ] encode ( byte [ ] data , int off , int length ) { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; try { encoder . encode ( data , off , length , bOut ) ; } catch ( Exception e ) { throw new EncoderException ( STR_ + e . getMessage ( ) , e ) ; } return bOut . toByteArray ( ) ; }
@ NotNull public List < PlayerNbt > createMultiplayerPlayerNbts ( ) { List < PlayerNbt > result = new ArrayList < PlayerNbt > ( ) ; for ( File playerdataFile : getPlayerdataFiles ( ) ) { if ( playerdataFile . isFile ( ) ) { result . add ( createPlayerdataPlayerNbt ( getPlayerUUIDFromPlayerdataFile ( playerdataFile ) ) ) ; } } if ( ! result . isEmpty ( ) ) { Log . i ( STR_ ) ; return result ; } for ( File playersFile : getPlayersFiles ( ) ) { if ( playersFile . isFile ( ) ) { result . add ( createPlayersPlayerNbt ( getPlayerNameFromPlayersFile ( playersFile ) ) ) ; } } if ( ! result . isEmpty ( ) ) { Log . i ( STR_ ) ; return result ; } Log . i ( STR_ ) ; return result ; }
public boolean removeContainerAndCancelIfNecessary ( ImageContainer container ) { mContainers . remove ( container ) ; if ( mContainers . size ( ) == NUM_ ) { mRequest . cancel ( ) ; return BOOL_ ; } return BOOL_ ; }
private void show ( SetupWindow window ) { window . handleWindowOpeningEvent ( ) ; _setupWindowHolder . show ( window . getKey ( ) ) ; _currentWindow = window ; }
public java . lang . StringBuffer append ( java . lang . String str ) { internal . append ( str ) ; return this ; }
private static String replaceStars ( String init ) { StringBuilder builder = new StringBuilder ( ) ; char [ ] chars = init . toCharArray ( ) ; for ( int i = NUM_ ; i < chars . length ; i ++ ) { if ( chars [ i ] == STR_ && i == NUM_ && chars . length > NUM_ && chars [ i + NUM_ ] == STR_ ) { builder . append ( STR_ ) ; i ++ ; } else if ( chars [ i ] == STR_ && i < ( chars . length - NUM_ ) && i > NUM_ && chars [ i + NUM_ ] == STR_ && chars [ i - NUM_ ] == STR_ ) { builder . deleteCharAt ( builder . length ( ) - NUM_ ) ; builder . append ( STR_ ) ; } else if ( chars [ i ] == STR_ && i == ( chars . length - NUM_ ) && i > NUM_ && chars [ i - NUM_ ] == STR_ ) { builder . deleteCharAt ( builder . length ( ) - NUM_ ) ; builder . append ( STR_ ) ; } else if ( chars [ i ] == STR_ ) { builder . append ( STR_ ) ; } else { builder . append ( chars [ i ] ) ; } } return builder . toString ( ) ; }
public void startOptionGroup ( String description ) { optionGroups . put ( optionList . size ( ) , description ) ; }
private byte [ ] encrypt ( byte [ ] m , NTRUEncryptionPublicKeyParameters pubKey ) { IntegerPolynomial pub = pubKey . h ; int N = params . N ; int q = params . q ; int maxLenBytes = params . maxMsgLenBytes ; int db = params . db ; int bufferLenBits = params . bufferLenBits ; int dm0 = params . dm0 ; int pkLen = params . pkLen ; int minCallsMask = params . minCallsMask ; boolean hashSeed = params . hashSeed ; byte [ ] oid = params . oid ; int l = m . length ; if ( maxLenBytes > NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } if ( l > maxLenBytes ) { throw new DataLengthException ( STR_ + l + STR_ + maxLenBytes ) ; } while ( BOOL_ ) { byte [ ] b = new byte [ db / NUM_ ] ; random . nextBytes ( b ) ; byte [ ] p0 = new byte [ maxLenBytes + NUM_ - l ] ; byte [ ] M = new byte [ bufferLenBits / NUM_ ] ; System . arraycopy ( b , NUM_ , M , NUM_ , b . length ) ; M [ b . length ] = ( byte ) l ; System . arraycopy ( m , NUM_ , M , b . length + NUM_ , m . length ) ; System . arraycopy ( p0 , NUM_ , M , b . length + NUM_ + m . length , p0 . length ) ; IntegerPolynomial mTrin = IntegerPolynomial . fromBinary3Sves ( M , N ) ; byte [ ] bh = pub . toBinary ( q ) ; byte [ ] hTrunc = copyOf ( bh , pkLen / NUM_ ) ; byte [ ] sData = buildSData ( oid , m , l , b , hTrunc ) ; Polynomial r = generateBlindingPoly ( sData , M ) ; IntegerPolynomial R = r . mult ( pub , q ) ; IntegerPolynomial R4 = ( IntegerPolynomial ) R . clone ( ) ; R4 . modPositive ( NUM_ ) ; byte [ ] oR4 = R4 . toBinary ( NUM_ ) ; IntegerPolynomial mask = MGF ( oR4 , N , minCallsMask , hashSeed ) ; mTrin . add ( mask ) ; mTrin . mod3 ( ) ; if ( mTrin . count ( - NUM_ ) < dm0 ) { continue ; } if ( mTrin . count ( NUM_ ) < dm0 ) { continue ; } if ( mTrin . count ( NUM_ ) < dm0 ) { continue ; } R . add ( mTrin , q ) ; R . ensurePositive ( q ) ; return R . toBinary ( q ) ; } }
public final void expectAtLeastOneResult ( ResultSet rs ) throws AdeInternalException , SQLException { if ( ! rs . next ( ) ) { throw new AdeInternalException ( STR_ + m_sql ) ; } }
public Sequence ( ) { this ( INITIAL_VALUE ) ; }
public static Optional < MongoCredential > createCredentials ( String username , String password , String database ) { if ( ! Strings . isNullOrEmpty ( username ) && ! Strings . isNullOrEmpty ( password ) && ! Strings . isNullOrEmpty ( database ) ) { return Optional . of ( MongoCredential . createMongoCRCredential ( username , database , password . toCharArray ( ) ) ) ; } else { return Optional . absent ( ) ; } }
public static String readAsciiLine ( InputStream in ) throws IOException { StringBuilder result = new StringBuilder ( NUM_ ) ; while ( BOOL_ ) { int c = in . read ( ) ; if ( c == - NUM_ ) { throw new EOFException ( ) ; } else if ( c == STR_ ) { break ; } result . append ( ( char ) c ) ; } int length = result . length ( ) ; if ( length > NUM_ && result . charAt ( length - NUM_ ) == STR_ ) { result . setLength ( length - NUM_ ) ; } return result . toString ( ) ; }
@ Override public void stop ( ) { if ( executorService != null ) { executorService . shutdown ( ) ; } restTemplate = null ; }
public void writeExif ( InputStream jpegStream , String exifOutFileName ) throws FileNotFoundException , IOException { if ( jpegStream == null || exifOutFileName == null ) { throw new IllegalArgumentException ( NULL_ARGUMENT_STRING ) ; } OutputStream s = null ; try { s = getExifWriterStream ( exifOutFileName ) ; doExifStreamIO ( jpegStream , s ) ; s . flush ( ) ; } catch ( IOException e ) { closeSilently ( s ) ; throw e ; } s . close ( ) ; }
public ResultRecord ( DirectoryScannerConfig scan , Action [ ] actions , File f ) { directoryScanner = scan . getName ( ) ; this . actions = actions ; date = new Date ( ) ; filename = f . getAbsolutePath ( ) ; }
private MethodDoc findImplMethod ( MethodDoc interfaceMethod ) { String name = interfaceMethod . name ( ) ; String desc = Util . methodDescriptorOf ( interfaceMethod ) ; for ( MethodDoc implMethod : implClass . methods ( ) ) { if ( name . equals ( implMethod . name ( ) ) && desc . equals ( Util . methodDescriptorOf ( implMethod ) ) ) { return implMethod ; } } return null ; }
protected static List < String > extractBootClassPath ( final List < String > args ) { return extractOptWithPattern ( BOOT_CLASS_PATH_REGEX , BOOL_ , args ) ; }
public abstract Object fromOpenValue ( Object openValue ) throws InvalidObjectException ;
public ContourPath ( ContourAttrib attr , int levelIndex , double [ ] x , double [ ] y ) { xArr = x ; yArr = y ; this . levelIndex = levelIndex ; attributes = attr ; int np = xArr . length ; if ( Math . abs ( x [ NUM_ ] - x [ np - NUM_ ] ) < kSmallX && Math . abs ( y [ NUM_ ] - y [ np - NUM_ ] ) < kSmallY ) { closed = BOOL_ ; x [ np - NUM_ ] = x [ NUM_ ] ; y [ np - NUM_ ] = y [ NUM_ ] ; } else closed = BOOL_ ; }
private int clampMag ( int value , int absMin , int absMax ) { final int absValue = Math . abs ( value ) ; if ( absValue < absMin ) return NUM_ ; if ( absValue > absMax ) return value > NUM_ ? absMax : - absMax ; return value ; }
protected void print ( String mnemonic , String [ ] args ) { printer . print ( indent + STR_ ) ; writePaddedString ( mnemonic + STR_ , NUM_ ) ; if ( args != null ) { for ( int i = NUM_ ; i < args . length ; i ++ ) { if ( i > NUM_ ) { printer . print ( STR_ ) ; } printer . print ( args [ i ] ) ; } } printer . println ( ) ; }
@ Override public void removeConnectionEventListener ( ConnectionEventListener listener ) { debugCode ( STR_ ) ; listeners . remove ( listener ) ; }
public boolean isDownloadable ( ) { List < String > topics = getExactTopics ( ) ; for ( String xt : topics ) if ( xt . startsWith ( STR_ ) ) return BOOL_ ; if ( getDefaultURLs ( ) . length > NUM_ ) { return BOOL_ ; } return BOOL_ ; }
public boolean isSatisfiedBy ( Date date ) { Calendar testDateCal = Calendar . getInstance ( getTimeZone ( ) ) ; testDateCal . setTime ( date ) ; testDateCal . set ( Calendar . MILLISECOND , NUM_ ) ; Date originalDate = testDateCal . getTime ( ) ; testDateCal . add ( Calendar . SECOND , - NUM_ ) ; Date timeAfter = getTimeAfter ( testDateCal . getTime ( ) ) ; return ( ( timeAfter != null ) && ( timeAfter . equals ( originalDate ) ) ) ; }
public static Vector < String > scanForDirLogs ( final String currentPath ) { if ( Cfg . DEBUG ) { Check . requires ( currentPath != null , STR_ ) ; } File fc ; final Vector < String > vector = new Vector < String > ( ) ; try { fc = new File ( currentPath ) ; if ( fc . isDirectory ( ) ) { final String [ ] fileLogs = fc . list ( ) ; for ( final String dir : fileLogs ) { final File fdir = new File ( currentPath + dir ) ; if ( fdir . isDirectory ( ) ) { vector . addElement ( dir + STR_ ) ; if ( Cfg . DEBUG ) { Check . log ( TAG + STR_ + dir ) ; } } } } } catch ( final Exception e ) { if ( Cfg . EXCEPTION ) { Check . log ( e ) ; } if ( Cfg . DEBUG ) { Check . log ( TAG + STR_ + e ) ; } } if ( Cfg . DEBUG ) { Check . log ( TAG + STR_ + vector . size ( ) ) ; } return vector ; }
private static ArrayList < String > flattenRows ( Cursor cursor , int limit ) { Util . throwIfNot ( limit >= NUM_ ) ; ArrayList < String > flatList = new ArrayList < > ( ) ; final int numColumns = cursor . getColumnCount ( ) ; for ( int row = NUM_ ; row < limit && cursor . moveToNext ( ) ; row ++ ) { for ( int column = NUM_ ; column < numColumns ; column ++ ) { switch ( cursor . getType ( column ) ) { case Cursor . FIELD_TYPE_NULL : flatList . add ( null ) ; break ; case Cursor . FIELD_TYPE_INTEGER : flatList . add ( String . valueOf ( cursor . getLong ( column ) ) ) ; break ; case Cursor . FIELD_TYPE_FLOAT : flatList . add ( String . valueOf ( cursor . getDouble ( column ) ) ) ; break ; case Cursor . FIELD_TYPE_BLOB : flatList . add ( blobToString ( cursor . getBlob ( column ) ) ) ; break ; case Cursor . FIELD_TYPE_STRING : default : flatList . add ( cursor . getString ( column ) ) ; break ; } } } if ( ! cursor . isAfterLast ( ) ) { for ( int column = NUM_ ; column < numColumns ; column ++ ) { flatList . add ( STR_ ) ; } } return flatList ; }
private Process executeCompiler ( ArrayList < String > argList , ArrayList < String > envList , boolean chdir ) throws IOException { String [ ] args ; if ( chdir ) { CharBuffer cb = new CharBuffer ( ) ; cb . append ( STR_ ) ; cb . append ( _compiler . getSourceDirName ( ) ) ; cb . append ( STR_ ) ; for ( int i = NUM_ ; i < argList . size ( ) ; i ++ ) { cb . append ( STR_ ) ; cb . append ( argList . get ( i ) ) ; } args = new String [ NUM_ ] ; args [ NUM_ ] = STR_ ; args [ NUM_ ] = STR_ ; args [ NUM_ ] = cb . toString ( ) ; } else { args = new String [ argList . size ( ) ] ; argList . toArray ( args ) ; } String [ ] envp = new String [ envList . size ( ) ] ; envList . toArray ( envp ) ; if ( log . isLoggable ( Level . FINE ) ) { CharBuffer cb = CharBuffer . allocate ( ) ; for ( int i = NUM_ ; i < args . length ; i ++ ) { if ( i != NUM_ ) cb . append ( STR_ ) ; cb . append ( args [ i ] ) ; } log . fine ( cb . close ( ) ) ; } Runtime runtime = Runtime . getRuntime ( ) ; try { return runtime . exec ( args ) ; } catch ( Exception e ) { throw new JavaCompileException ( L . l ( STR_ , args [ NUM_ ] , String . valueOf ( e ) ) ) ; } }
public void collapseAllParents ( ) { if ( mDataList != null && ! mDataList . isEmpty ( ) ) { ArrayList < Object > expandableListItems = getParents ( BOOL_ ) ; if ( expandableListItems != null && ! expandableListItems . isEmpty ( ) ) { final int expandedItemSize = expandableListItems . size ( ) ; if ( expandedItemSize > NUM_ ) { for ( int i = NUM_ ; i < expandedItemSize ; i ++ ) { Object o = expandableListItems . get ( i ) ; int indexOf = mDataList . indexOf ( o ) ; if ( indexOf >= NUM_ ) collapseListItem ( indexOf , ( BaseExpandableObservable ) o , BOOL_ ) ; } } } } }
@ Deprecated protected PdfFormXObject drawPushButtonAppearance ( float width , float height , String text , PdfFont font , int fontSize ) { return drawPushButtonAppearance ( width , height , text , font , ( float ) fontSize ) ; }
public NBTTagCompound loadFile ( File saveDirectory , String filename ) { return loadFile ( new File ( saveDirectory , filename + STR_ ) ) ; }
public boolean dnsDomainIs ( String host , String domain ) { return host . endsWith ( domain ) ; }
@ SuppressWarnings ( STR_ ) public SelectionBuilder reset ( ) { mTable = null ; if ( mProjectionMap != null ) { mProjectionMap . clear ( ) ; } if ( mSelection != null ) { mSelection . setLength ( NUM_ ) ; } if ( mSelectionArgs != null ) { mSelectionArgs . clear ( ) ; } return this ; }
private final synchronized Enumeration < PolicyEntry > elements ( ) { return policyEntries . elements ( ) ; }
public String format ( Calendar calendar , Calendar smscCalendar ) { if ( calendar == null || smscCalendar == null ) { return null ; } long diffTimeInMillis = calendar . getTimeInMillis ( ) - smscCalendar . getTimeInMillis ( ) ; if ( diffTimeInMillis < NUM_ ) { throw new IllegalArgumentException ( STR_ ) ; } Calendar offsetEpoch = Calendar . getInstance ( utcTimeZone ) ; offsetEpoch . setTimeInMillis ( diffTimeInMillis ) ; int years = offsetEpoch . get ( Calendar . YEAR ) - NUM_ ; int months = offsetEpoch . get ( Calendar . MONTH ) ; int days = offsetEpoch . get ( Calendar . DAY_OF_MONTH ) - NUM_ ; int hours = offsetEpoch . get ( Calendar . HOUR_OF_DAY ) ; int minutes = offsetEpoch . get ( Calendar . MINUTE ) ; int seconds = offsetEpoch . get ( Calendar . SECOND ) ; if ( years >= NUM_ ) { throw new IllegalArgumentException ( STR_ + years + STR_ ) ; } return format ( years , months , days , hours , minutes , seconds ) ; }
private void calculateEntropy ( double scale , KStarWrapper params ) { int i , j , k ; double actent = NUM_ , randent = NUM_ ; double pstar , tprob , avgprob = NUM_ , minprob = NUM_ ; double actClassProb , randClassProb ; double [ ] [ ] pseudoClassProbs = new double [ NUM_RAND_COLS + NUM_ ] [ m_NumClasses ] ; for ( j = NUM_ ; j <= NUM_RAND_COLS ; j ++ ) { for ( i = NUM_ ; i < m_NumClasses ; i ++ ) { pseudoClassProbs [ j ] [ i ] = NUM_ ; } } for ( i = NUM_ ; i < m_NumInstances ; i ++ ) { if ( m_Distances [ i ] < NUM_ ) { continue ; } else { pstar = PStar ( m_Distances [ i ] , scale ) ; tprob = pstar / m_ActualCount ; avgprob += tprob ; if ( pstar < minprob ) { minprob = pstar ; } for ( k = NUM_ ; k <= NUM_RAND_COLS ; k ++ ) { pseudoClassProbs [ k ] [ m_RandClassCols [ k ] [ i ] ] += tprob ; } } } for ( j = m_NumClasses - NUM_ ; j >= NUM_ ; j -- ) { actClassProb = pseudoClassProbs [ NUM_RAND_COLS ] [ j ] / avgprob ; if ( actClassProb > NUM_ ) { actent -= actClassProb . Math . log ( actClassProb ) / LOG2 ; } } for ( k = NUM_ ; k < NUM_RAND_COLS ; k ++ ) { for ( i = m_NumClasses - NUM_ ; i >= NUM_ ; i -- ) { randClassProb = pseudoClassProbs [ k ] [ i ] / avgprob ; if ( randClassProb > NUM_ ) { randent -= randClassProb . Math . log ( randClassProb ) / LOG2 ; } } } randent /= NUM_RAND_COLS ; params . actEntropy = actent ; params . randEntropy = randent ; params . avgProb = avgprob ; params . minProb = minprob ; }
public static void initCause ( Throwable throwable , Throwable cause ) { if ( INIT_CAUSE_METHOD != null ) { try { INIT_CAUSE_METHOD . invoke ( throwable , new Object [ ] { cause } ) ; } catch ( Exception e ) { } } }
public void testBug20685022 ( ) throws Exception { if ( ! isCommunityEdition ( ) ) { return ; } final Properties props = new Properties ( ) ; props . clear ( ) ; props . setProperty ( STR_ , STR_ ) ; props . setProperty ( STR_ , STR_ ) ; props . setProperty ( STR_ , STR_ ) ; getConnectionWithProps ( props ) ; props . clear ( ) ; props . setProperty ( STR_ , STR_ ) ; props . setProperty ( STR_ , STR_ ) ; props . setProperty ( STR_ , STR_ ) ; props . setProperty ( STR_ , STR_ ) ; props . setProperty ( STR_ , STR_ ) ; props . setProperty ( STR_ , STR_ ) ; getConnectionWithProps ( props ) ; props . clear ( ) ; props . setProperty ( STR_ , STR_ ) ; props . setProperty ( STR_ , STR_ ) ; props . setProperty ( STR_ , STR_ ) ; String trustStorePath = STR_ ; System . setProperty ( STR_ , trustStorePath ) ; System . setProperty ( STR_ , STR_ ) ; System . setProperty ( STR_ , trustStorePath ) ; System . setProperty ( STR_ , STR_ ) ; getConnectionWithProps ( props ) ; }
public static boolean canRun ( final File file ) { return manager . getEngineByExtension ( FileUtils . getFileExtension ( file ) ) != null ; }
public void parseElement ( String tagName , Map < String , Object > attrs ) { if ( canvas == null && tagName . equalsIgnoreCase ( STR_ ) ) { scale = mxUtils . getDouble ( attrs , STR_ , NUM_ ) ; canvas = createCanvas ( attrs ) ; if ( canvas != null ) { canvas . setScale ( scale ) ; } } else if ( canvas != null ) { boolean drawLabel = BOOL_ ; if ( tagName . equalsIgnoreCase ( STR_ ) || tagName . equalsIgnoreCase ( STR_ ) ) { drawVertex ( attrs ) ; drawLabel = BOOL_ ; } else if ( tagName . equalsIgnoreCase ( STR_ ) ) { drawEdge ( attrs ) ; drawLabel = BOOL_ ; } if ( drawLabel ) { drawLabel ( tagName . equalsIgnoreCase ( STR_ ) , attrs ) ; } } }
private void startPrecaching ( ) { Log . v ( TAG , STR_ ) ; prepareNativeLibraries ( ) ; sIsPrecaching = BOOL_ ; acquirePrecachingWakeLock ( ) ; mPrecacheLauncher . start ( ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( NUM_ ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return newVector . elements ( ) ; }
public WordAlignmentState ( final Rule rule , final int start ) { trgPoints = new LinkedList < > ( ) ; srcLength = rule . getFrench ( ) . length ; numNT = rule . getArity ( ) ; srcStart = start ; final Map < Integer , List < Integer > > alignmentMap = rule . getAlignmentMap ( ) ; final int [ ] nonTerminalSourcePositions = rule . getNonTerminalSourcePositions ( ) ; final int [ ] trg = rule . getEnglish ( ) ; for ( int trgIndex = NUM_ ; trgIndex < trg . length ; trgIndex ++ ) { final AlignedSourceTokens trgPoint = new AlignedSourceTokens ( ) ; if ( trg [ trgIndex ] >= NUM_ ) { if ( alignmentMap . containsKey ( trgIndex ) ) { for ( int srcIdx : alignmentMap . get ( trgIndex ) ) { trgPoint . add ( srcStart + srcIdx ) ; } } else { trgPoint . setNull ( ) ; } } else { trgPoint . setNonTerminal ( ) ; final int absoluteNonTerminalSourcePosition = srcStart + nonTerminalSourcePositions [ Math . abs ( trg [ trgIndex ] ) - NUM_ ] ; trgPoint . add ( absoluteNonTerminalSourcePosition ) ; } trgPoints . add ( trgPoint ) ; } }
protected void configureImageReaderLoaders ( ) { imageReaderLoaders = new Vector < ImageReaderLoader > ( ) ; ImageReaderLoader idl = ( ImageReaderLoader ) ComponentFactory . create ( STR_ ) ; if ( idl != null ) { imageReaderLoaders . add ( idl ) ; } else { logger . warning ( STR_ ) ; } idl = ( ImageReaderLoader ) ComponentFactory . create ( STR_ ) ; if ( idl != null ) { imageReaderLoaders . add ( idl ) ; } else { logger . warning ( STR_ ) ; } }
protected void handleSpecialSubstitution ( String replace , String replaceWith , int startPos , String description ) { if ( replace . equals ( STR_ ) ) { if ( replaceWith . charAt ( NUM_ ) == STR_ ) { error ( STR_ , startPos , description ) ; } ignoreChars = CharSet . parseString ( replaceWith ) ; } }
@ Override public void countExample ( Example example ) { double plabel ; double label = example . getValue ( labelAttribute ) ; if ( ! predictedAttribute . isNominal ( ) ) { plabel = example . getValue ( predictedAttribute ) ; } else { String labelS = example . getValueAsString ( labelAttribute ) ; plabel = example . getConfidence ( labelS ) ; label = NUM_ ; } double weight = NUM_ ; if ( weightAttribute != null ) { weight = example . getValue ( weightAttribute ) ; } double diff = weight . Math . abs ( label - plabel ) ; deviationSum += diff ; double relDiff = Math . abs ( weight . label - ( trueLabelSum / exampleCounter ) ) ; relativeSum += relDiff ; }
public static void unzip ( String zipFile , String location ) throws IOException { final int BUFFER_SIZE = NUM_ ; int size ; byte [ ] buffer = new byte [ BUFFER_SIZE ] ; try { if ( ! location . endsWith ( STR_ ) ) { location += STR_ ; } File f = new File ( location ) ; if ( ! f . isDirectory ( ) ) { f . mkdirs ( ) ; } ZipInputStream zin = new ZipInputStream ( new BufferedInputStream ( new FileInputStream ( zipFile ) , BUFFER_SIZE ) ) ; try { ZipEntry ze = null ; while ( ( ze = zin . getNextEntry ( ) ) != null ) { String path = location + ze . getName ( ) ; File unzipFile = new File ( path ) ; if ( ze . isDirectory ( ) ) { if ( ! unzipFile . isDirectory ( ) ) { unzipFile . mkdirs ( ) ; } } else { File parentDir = unzipFile . getParentFile ( ) ; if ( null != parentDir ) { if ( ! parentDir . isDirectory ( ) ) { parentDir . mkdirs ( ) ; } } FileOutputStream out = new FileOutputStream ( unzipFile , BOOL_ ) ; BufferedOutputStream fout = new BufferedOutputStream ( out , BUFFER_SIZE ) ; try { while ( ( size = zin . read ( buffer , NUM_ , BUFFER_SIZE ) ) != - NUM_ ) { fout . write ( buffer , NUM_ , size ) ; } zin . closeEntry ( ) ; } finally { fout . flush ( ) ; fout . close ( ) ; } } } } finally { zin . close ( ) ; } } catch ( Exception e ) { Log . e ( TAG , STR_ , e ) ; } }
private void addDeclAnnotations ( Map < String , Set < AnnotationMirror > > declAnnos , Element elt ) { if ( fromStubFile != null ) { Set < AnnotationMirror > annos = declAnnos . get ( ElementUtils . getVerboseName ( elt ) ) ; if ( annos == null ) { annos = AnnotationUtils . createAnnotationSet ( ) ; putOrAddToMap ( declAnnos , ElementUtils . getVerboseName ( elt ) , annos ) ; } annos . add ( fromStubFile ) ; } }
private void inspectConditionsWithBooleans ( LinkedList < PsiElement > objBranchConditions ) { for ( PsiElement objExpression : objBranchConditions ) { if ( ! ( objExpression instanceof ConstantReference ) ) { continue ; } if ( ExpressionSemanticUtil . isBoolean ( ( ConstantReference ) objExpression ) ) { holder . registerProblem ( objExpression , strProblemDescriptionBooleans , ProblemHighlightType . GENERIC_ERROR_OR_WARNING ) ; } } }
public static XContentType xContentType ( CharSequence content ) { int length = content . length ( ) < GUESS_HEADER_LENGTH ? content . length ( ) : GUESS_HEADER_LENGTH ; if ( length == NUM_ ) { return null ; } char first = content . charAt ( NUM_ ) ; if ( first == STR_ ) { return XContentType . JSON ; } if ( length > NUM_ && first == SmileConstants . HEADER_BYTE_1 && content . charAt ( NUM_ ) == SmileConstants . HEADER_BYTE_2 && content . charAt ( NUM_ ) == SmileConstants . HEADER_BYTE_3 ) { return XContentType . SMILE ; } if ( length > NUM_ && first == STR_ && content . charAt ( NUM_ ) == STR_ && content . charAt ( NUM_ ) == STR_ ) { return XContentType . YAML ; } for ( int i = NUM_ ; i < length ; i ++ ) { char c = content . charAt ( i ) ; if ( c == STR_ ) { return XContentType . JSON ; } if ( Character . isWhitespace ( c ) == BOOL_ ) { break ; } } return null ; }
@ RequestMapping ( value = STR_ , method = RequestMethod . DELETE ) public ResponseEntity < Bookmark > deleteBookmark ( @ PathVariable ( value = STR_ ) String username , @ PathVariable ( value = STR_ ) int bookmarkId ) throws BookmarkNotFoundException { Optional < Bookmark > optional = bookmarksRepository . findByIdAndUserUsername ( bookmarkId , username ) ; if ( optional . isPresent ( ) ) { bookmarksRepository . delete ( optional . get ( ) ) ; return new ResponseEntity < > ( optional . get ( ) , HttpStatus . OK ) ; } else { throw new BookmarkNotFoundException ( STR_ + bookmarkId ) ; } }
public static Object loadInstance ( Class clazz , Object defaultValue ) { try { return clazz . newInstance ( ) ; } catch ( Throwable t ) { return defaultValue ; } }
public static String toJSONString ( Object value ) { final StringWriter writer = new StringWriter ( ) ; try { writeJSONString ( value , writer ) ; return writer . toString ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public static final < A > CollectionX < A > toLazyCollection ( final Stream < A > stream ) { return SeqUtils . toLazyCollection ( stream . iterator ( ) ) ; }
public JSONTokener ( Reader reader ) { this . reader = reader . markSupported ( ) ? reader : new BufferedReader ( reader ) ; this . eof = BOOL_ ; this . usePrevious = BOOL_ ; this . previous = NUM_ ; this . index = NUM_ ; this . character = NUM_ ; this . line = NUM_ ; }
static Unit valueOf ( String name , boolean horizontal ) { if ( name . length ( ) == NUM_ ) { Unit defaultUnit = Sizes . getDefaultUnit ( ) ; if ( defaultUnit != null ) { return defaultUnit ; } return horizontal ? DIALOG_UNITS_X : DIALOG_UNITS_Y ; } else if ( name . equals ( STR_ ) ) { return PIXEL ; } else if ( name . equals ( STR_ ) ) { return horizontal ? DIALOG_UNITS_X : DIALOG_UNITS_Y ; } else if ( name . equals ( STR_ ) ) { return POINT ; } else if ( name . equals ( STR_ ) ) { return INCH ; } else if ( name . equals ( STR_ ) ) { return MILLIMETER ; } else if ( name . equals ( STR_ ) ) { return CENTIMETER ; } else { throw new IllegalArgumentException ( STR_ + name + STR_ + STR_ ) ; } }
public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( ( argNum < NUM_ ) || ( argNum > NUM_ ) ) reportWrongNumberArgs ( ) ; }
